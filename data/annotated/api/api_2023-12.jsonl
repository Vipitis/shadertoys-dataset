{"id": "lcS3Wz", "name": "sincing feeling", "author": "dissident", "description": "my first", "tags": ["bookofshaders", "sinc"], "likes": 2, "viewed": 152, "published": 3, "date": "1704055774", "time_retrieved": "2024-07-30T17:13:59.642454", "image_code": "#define PI 3.14159\n\nfloat sinc(float x, float k) {\n    float a = PI * (x * k - 1.0);\n    return sin(a) / a;\n}\n\nfloat cubicPulse(float c, float w, float x) {\n    x = abs(x - c);\n    if (x > w) return 0.0;\n    x = x / w;\n    return 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float x = uv.x + tan(iTime);\n    float y = sinc(x, 7.0) / 1.5 + 0.25;\n    \n    vec3 color = vec3(0.1);\n    float pct = cubicPulse(y, 0.02, uv.y);\n    color = color + pct * vec3(1.0, 0.0, 0.0);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcS3Wz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 50, 50, 109], [111, 111, 156, 156, 262], [264, 264, 321, 321, 595]], "test": "untested"}
{"id": "MfS3DR", "name": "Stylized LIC AA", "author": "rubioh", "description": "Stylised anti-aliasing with line integral convolution", "tags": ["blur", "aa", "lic"], "likes": 6, "viewed": 332, "published": 3, "date": "1704051568", "time_retrieved": "2024-07-30T17:14:00.694641", "image_code": "#define R iResolution\n#define T(u) texture(iChannel0, u/R.xy).rgb\n#define D(u) texture(iChannel1, u/R.xy).xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n\n    vec3 I = vec3(0.0);\n    float sum = .0;\n    \n    float sigmaL = 5.;\n    \n    \n    float w = gaussian(sigmaL, 0.);\n    I += T(uv)*w;\n    sum += w;\n\n    vec2 dir = D(uv);\n    vec2 where = uv + dir;\n\n    // LIC first side\n    for (float i = 1. ; i<(2.*sigmaL + 1.) ; i++){\n        w = gaussian(sigmaL, i);\n        I += T(where)*w;\n        sum += w;\n        vec2 dir = D(where);\n        where += dir;\n\n    }\n    // LIC second side\n    dir = D(uv);\n    where = uv - dir.xy;\n    for (float i = 1. ; i<(2.*sigmaL + 1.) ; i++){\n        w = gaussian(sigmaL, i);\n        I += T(where)*w;\n        sum += w;\n        vec2 dir = D(where);\n        where -= dir;\n    }\n    I /= sum;\n    fragColor = vec4(I, 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define R iResolution\n#define T(u) texture(iChannel0, u).rgb\n\nvec4 SST(vec2 uv){\n    vec2 d = 1./R.xy;\n    //Sobel\n    vec3 Gx =  (\n           -1.0 * T(uv + vec2(-d.x, -d.y)) +\n           -2.0 * T(uv + vec2(-d.x,  0.0)).xyz + \n           -1.0 * T(uv + vec2(-d.x,  d.y)).xyz +\n           +1.0 * T(uv + vec2( d.x, -d.y)).xyz +\n           +2.0 * T(uv + vec2( d.x,  0.0)).xyz + \n           +1.0 * T(uv + vec2( d.x,  d.y)).xyz\n           ) / 4.0;\n    vec3 Gy = (\n           -1.0 * T(uv + vec2(-d.x, -d.y)).xyz + \n           -2.0 * T(uv + vec2( 0.0, -d.y)).xyz + \n           -1.0 * T(uv + vec2( d.x, -d.y)).xyz +\n           +1.0 * T(uv + vec2(-d.x,  d.y)).xyz +\n           +2.0 * T(uv + vec2( 0.0,  d.y)).xyz + \n           +1.0 * T(uv + vec2( d.x,  d.y)).xyz\n           ) / 4.0;\n    return vec4(dot(Gx, Gx), dot(Gy, Gy), dot(Gy, Gx), .0);         \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/R.xy;\n    vec4 sst = SST(uv); // Compute Structure Space Tensor\n    \n    fragColor = vec4(sst);\n}", "buffer_b_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float gaussian(float s, float pos){\n    return exp(-(pos*pos)/(2.*s*s));\n}", "buffer_c_code": "#define T(u) texelFetch(iChannel0, u, 0).rgb\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    ivec2 uv = ivec2(fragCoord.xy);\n    vec3 G = vec3(0.0);\n    \n    float sigmaG = 8.;\n    \n    float sum = .0;\n\n    float w = gaussian(sigmaG, 0.);\n    G += T(uv)*w;\n    sum += w;\n    // Gaussian Blur Vertical\n    for (float i = 1. ; i<(2.*sigmaG+1.) ; i++){\n        w = gaussian(sigmaG, float(i));\n        G += T(uv + ivec2(0,i))*w;\n        G += T(uv - ivec2(0,i))*w;\n        sum += 2.*w;\n    }\n    G /= sum;\n    fragColor = vec4(G, .0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define T(u) texelFetch(iChannel0, u, 0).rgb\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    ivec2 uv = ivec2(fragCoord.xy);\n    vec3 G = vec3(0.0);\n    \n    float sigmaG = 8.;\n   \n    float sum = .0;\n\n    float w = gaussian(sigmaG, 0.);\n    G += T(uv)*w;\n    sum += w;\n    // Gaussian Blur Horizontal\n    for (float i = 1. ; i<(2.*sigmaG+1.) ; i++){\n        w = gaussian(sigmaG, float(i));\n        G += T(uv + ivec2(i,0))*w;\n        G += T(uv - ivec2(i,0))*w;\n        sum += 2.*w;\n    }\n    G /= sum;\n    \n    // Compute eigen vector\n    float lambda = .5*(G.x + G.y + sqrt((G.y-G.x)*(G.y-G.x) + 4.*G.z*G.z));\n    vec2 d = vec2(-G.x + lambda, -G.z);\n\n    vec4 res = (length(d) != 0.) ? vec4(normalize(d), sqrt(lambda), 1.) : vec4(.0,1.,0.,1.);\n    fragColor = res;    \n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MfS3DR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 167, 217, 946]], "test": "untested"}
{"id": "4fB3RR", "name": "Font Experiment - Text Tunnel ", "author": "byt3_m3chanic", "description": "To Sync Audio - press Stop/Rewind then press Play", "tags": ["2d", "text", "font", "typography", "alphabet", "letters"], "likes": 28, "viewed": 362, "published": 3, "date": "1704036017", "time_retrieved": "2024-07-30T17:14:01.554342", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    12/31/23 @byt3_m3chanic \n    Music Tunephaser - Out of Control\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\nvec3 hue(float t){ return .55 + .45*cos(PI2*t*(vec3(.95,.97,.98)+vec3(1,.5,.2))); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(27.619,57.583)))*4358.5453);}\nfloat sampleFreq(float freq) {\n    return texture(iChannel2, vec2(freq, 0.)).x;\n}\n\nconst float sz = .425;\nconst float hf = sz/2.;\n\nfloat getLetter(float md, vec2 q) {\n    float d = 0.;\n    if(md==0.) d= getA(q.xy);\n    if(md==1.) d= getB(q.xy);\n    if(md==2.) d= getC(q.xy);\n    if(md==3.) d= getD(q.xy);\n    if(md==4.) d= getE(q.xy);\n    if(md==5.) d= getF(q.xy);\n    if(md==6.) d= getG(q.xy);\n    if(md==7.) d= getH(q.xy);\n    if(md==8.) d= getI(q.xy);\n    if(md==9.) d= getJ(q.xy);\n    if(md==10.) d= getK(q.xy);\n    if(md==11.) d= getL(q.xy);\n    if(md==12.) d= getM(q.xy);\n    if(md==13.) d= getN(q.xy);\n    if(md==14.) d= getO(q.xy);\n    if(md==15.) d= getP(q.xy);\n    if(md==16.) d= getQ(q.xy);\n    if(md==17.) d= getR(q.xy);\n    if(md==18.) d= getS(q.xy);\n    if(md==19.) d= getT(q.xy);\n    if(md==20.) d= getU(q.xy);\n    if(md==21.) d= getV(q.xy);\n    if(md==22.) d= getW(q.xy);\n    if(md==23.) d= getX(q.xy);\n    if(md==24.) d= getY(q.xy);\n    if(md==25.) d= getZ(q.xy);\n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 F ){\n\n    vec2 uv = (F.xy - R.xy*.5)/R.y;\n    vec2 xv = uv;\n    \n    vec2 nv = ((F.xy/R.xy)*.99);\n    vec3 C = vec3(0);\n    float md = mod(floor(T),50.);\n    float thr = 35.;\n    float crop = clamp((-.03)+(T*.05),0.,1.);\n    if(uv.x<crop&&uv.x>-crop){\n\n        if(md<thr){\n            uv *= rot(T*.075);\n            uv = vec2(log(length(uv)), atan(uv.y, uv.x))*1.555;\n        }else{\n            uv *= rot(3.85+T*.035);\n            uv*=4.5;\n        }\n        \n        float px = fwidth(uv.x)*.8;\n        vec2 id = floor((uv+hf)/sz);\n        float hx = (hash21(vec2(1,id.y))*.5);\n        vec3 bk = vec3(hx*.05);\n        C = bk;\n\n        uv.x -= T*(.2+hx);\n        id = floor((uv+hf)/sz);\n\n        vec2 q = mod(uv+hf,sz)-hf;\n\n        float hs = floor(hash21(id)*26.);\n\n        float d = getLetter(hs,q.xy);\n\n        hs = fract(hs*32.123);\n        float nsd = sampleFreq(hs*.8);\n\n        vec3 clr = hs>.5? vec3(.2):hue(hs*.1+(id.x*.075)-T*.1 );\n\n        float ths = hash21(id+floor(T*.5)+hs);\n        float mx = mod(floor(hs+T*6.),2.)*2.-1.;\n\n        if(ths>.925) clr = mx>.5? bk : clr;\n        if(ths>.075) {\n            C=mix(C,mix(C,C*.5,nsd),smoothstep(.02+px,-px,d));\n            C=mix(C,mix(bk,clr,nsd),smoothstep(px,-px,d));\n        }\n        px = fwidth(xv.x)*.8;\n        float c = length(xv)-.02;\n        if(md<thr) C = mix(C,C*.03,smoothstep(.08+px,-px,c));\n\n    }\n\n    fragColor = vec4(pow(C, vec3(.4545)),1.);\n}\n\n", "image_inputs": [{"id": 35644, "src": "https://soundcloud.com/tunephaser/out-of-control", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    12/31/23 @byt3_m3chanic \n*/\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nconst vec4 bz = vec4(.075,.055,.035,.0);\nconst vec4 bo = vec4(.175,.15,.075,.025);\nconst vec2 oa = vec2(.15,.1);\n\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\nfloat rbox( in vec2 p, in vec2 b, in vec4 r ) {\n    r.xy = (p.x>0.)?r.xy : r.zw;\n    r.x  = (p.y>0.)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.)+length(max(q,0.))-r.x;\n}\n\n//letters\nfloat getA(vec2 p) {\n    vec2 of = vec2(0,.075);\n    float bt = max(\n    rbox(p,vec2(.15,.175),bz.xwxw),\n    -rbox(p+vec2(.0,.05),vec2(.1,.175),bz.zwzw)\n    );\n    float bb = box(p,vec2(.15,.025));\n    return min(bt,bb);\n}\nfloat getB(vec2 p) {\n    vec2 of = vec2(0,.075);\n    float bt = max(\n        rbox(p-of,oa,bz.xxww),\n        -rbox(p-of,vec2(.1,.05),bz.zzww)\n    );\n    float bb = max(\n        rbox(p+of,oa,bz.xxww),\n        -rbox(p+of,vec2(.1,.05),bz.zzww)\n    );\n    return min(bt,bb);\n}\nfloat getC(vec2 p) {\n    float bt = max(\n        rbox(p,vec2(.15,.175),bz.wwxx),\n        -rbox(p-vec2(.05,0),vec2(.15,.125),bz.wwzz)\n    );\n    return bt;\n}\nfloat getD(vec2 p) {\n    float bt = max(rbox(p,vec2(.15,.175),bz.xxww),\n    -rbox(p,vec2(.1,.125),vec4(.035,.035,0,0)));\n    return bt;\n}\nfloat getE(vec2 p) {\n    vec2 of = vec2(0,.075);\n    float bt = max(\n        rbox(p-of,oa,bz.wwxx),\n        -rbox(p-of-vec2(.05,0),vec2(.15,.05),bz.wwzz)\n    );\n    float bb = max(\n        rbox(p+of,oa,bz.wwxx),\n        -rbox(p+of-vec2(.05,0),vec2(.15,.05),bz.wwzz)\n    );\n    return min(bt,bb);\n}\nfloat getF(vec2 p) {\n    float bt = min(\n        box(vec2(p.x+.125,p.y),vec2(.025,.175)),\n        box(vec2(p.x,abs(p.y-.075)-.075),vec2(.15,.025))\n    );\n    return bt;\n}\nfloat getG(vec2 p) {\n    float bt = max(\n        rbox(p,vec2(.15,.175),bz.wwxx),\n        -rbox(p-vec2(.05,0),vec2(.15,.125),bz.wwzz)\n    );\n    float bf = min(\n        box(vec2(p.x-.125,p.y+.075),vec2(.025,.1)),\n        box(vec2(p.x-.05,p.y),vec2(.1,.025))\n    );\n    return min(bt,bf);\n}\nfloat getH(vec2 p) {\n    float bt = min(\n        box(vec2(abs(p.x)-.125,p.y),vec2(.025,.175)),\n        box(p,vec2(.15,.025))\n    );\n    return bt;\n}\nfloat getI(vec2 p) {\n    float bt = min(\n        box(p,vec2(.025,.175)),\n        box(vec2(p.x,abs(p.y)-.15),vec2(.15,.025))\n    );\n    return bt;\n}\nfloat getJ(vec2 p) {\n    float bt = max(\n        rbox(p,vec2(.15,.175),vec4(.0,.1,0,0)),\n        -rbox(p+vec2(.05,-.05),vec2(.15,.175),vec4(.0,.055,0,0))\n    );\n    return bt;\n}\nfloat getK(vec2 p) {\n    float bt = max(\n        rbox(p-vec2(0,.075),oa,vec4(.0,.1,0,0)),\n        -rbox(p-vec2(0,.12),vec2(.1,.095),vec4(.0,.055,0,0))\n    );\n    float bb = max(\n        rbox(p+vec2(0,.075),oa,vec4(.1,.0,0,0)),\n        -rbox(p+vec2(0,.12),vec2(.1,.095),vec4(.055,.0,0,0))\n    );\n    return min(bt,bb);\n}\nfloat getL(vec2 p) {\n    float bt = min(\n        box(p+vec2(.125,0),vec2(.025,.175)),\n        box(p+vec2(0,.15),vec2(.15,.025))\n    );\n    return bt;\n}\nfloat getM(vec2 p) {\n    vec2 of = vec2(.065,0);\n    float bt = max(\n        rbox(p+of,vec2(.085,.175),bz.xwxw),\n        -rbox(p+of+vec2(.0,.05),vec2(.0375,.175),bz.zwzw)\n    );\n    float bb = max(\n        rbox(p-of,vec2(.085,.175),bz.xwxw),\n        -rbox(p-of+vec2(.0,.05),vec2(.0375,.175),bz.zwzw)\n    );\n    return min(bt,bb);\n}\nfloat getN(vec2 p) {\n    float bt = max(\n        rbox(p,vec2(.15,.175),bz.xwxw),\n        -rbox(p+vec2(.0,.045),vec2(.1,.175),bz.zwzw)\n    );\n    return bt;\n}\nfloat getO(vec2 p) {\n    float bt = max(\n        rbox(p,vec2(.15,.175),bz.xxxx),\n        -rbox(p,vec2(.1,.125),bz.zzzz)\n    );\n    return bt;\n}\nfloat getP(vec2 p) {\n    float bt = max(\n        rbox(p-vec2(.0,.075),oa,bz.xxww),\n        -rbox(p-vec2(.0,.075),vec2(.1,.05),bz.zzww)\n    );\n    float bb = box(p+vec2(.125,0),vec2(.025,.175));\n    return min(bt,bb);\n}\nfloat getQ(vec2 p) {\n    float bt = max(\n        rbox(p,vec2(.15,.175),vec4(.075,.11,.075,.075)),\n        -rbox(p,vec2(.1,.125),vec4(.035,.065,.035,.035))\n    );\n    vec2 q = (p+vec2(-.0925,.115))*rot(.8);\n    float bb = box(q,vec2(.025,.065));\n    return min(bt,bb);\n}\nfloat getR(vec2 p) {\n    float bt = max(\n        rbox(p-vec2(.0,.075),oa,bz.xxww),\n        -rbox(p-vec2(.0,.075),vec2(.1,.05),bz.zzww)\n    );\n    float bb = max(\n        rbox(p+vec2(.0,.075),oa,bz.xwww),\n        -rbox(p+vec2(.0,.12),vec2(.1,.095),bz.zwww)\n    );\n    return min(bt,bb);\n}\nfloat getS(vec2 p) {\n    float bt = max(\n        rbox(p-vec2(.0,.075),oa,bz.wwxx),\n        -rbox(p-vec2(.075,.075),vec2(.175,.05),bz.wwzz)\n    );\n    bt = max(bt,-box(p-vec2(.085,.045),vec2(.08,.08)));\n    float bb = max(\n        rbox(p+vec2(.0,.075),oa,bz.xxww),\n        -rbox(p+vec2(.075,.075),vec2(.175,.05),bz.zzww)\n    );\n    bb = max(bb,-box(p+vec2(.085,.045),vec2(.08,.08)));\n    return min(bt,bb);\n}\nfloat getT(vec2 p) {\n    vec2 of = vec2(0,.075);\n    return min(box(p-of-vec2(0,.075),vec2(.15,.025)),box(p,vec2(.025,.175)));\n}\nfloat getU(vec2 p) {\n    float bt = max(\n        rbox(p,vec2(.15,.175),bz.wxwx),\n        -rbox(p-vec2(0,.045),vec2(.1,.175),bz.wzwz)\n    );\n    return bt;\n}\nfloat getV(vec2 p) {\n    vec2 q = p;\n    p.x=abs(p.x);\n    p*=rot(-.24);\n    float bt = max(\n        rbox(p-vec2(0,.03),vec2(.1,.2),bz.wxwx),\n        -rbox(p-vec2(-.0475,.05),vec2(.1,.175),bz.wzwz)\n    );\n    return max(box(q,vec2(.2,.175)),bt);\n}\nfloat getW(vec2 p) {\n    vec2 of = vec2(.065,0);\n    float bt = max(\n        rbox(p+of,vec2(.085,.175),bz.wxwx),\n        -rbox(p+of-vec2(.0,.05),vec2(.0375,.175),bz.wzwz)\n    );\n    float bb = max(\n    rbox(p-of,vec2(.085,.175),vec4(0,.075,0,.075)),\n    -rbox(p-of-vec2(.0,.05),vec2(.0375,.175),bz.wzwz)\n    );\n    return min(bt,bb);\n}\nfloat getX(vec2 p) {\n    vec2 r = p;\n    vec2 q = p*rot(.5707);\n    p*=rot(-.5707);\n    float bt = min(box(p,vec2(.025,.225)),box(q,vec2(.025,.225)));\n    return max(box(r,vec2(.2,.175)),bt);\n}\nfloat getY(vec2 p) {\n    vec2 of = vec2(0,.075);\n    float bt = max(\n        rbox(p-of,oa,bz.wxwx),\n        -rbox(p-of-vec2(0,.05),vec2(.1),bz.wzwz)\n    );\n    return min(bt,box(p+of,vec2(.025,.1)));\n}\n\nfloat getZ(vec2 p) {\n    vec2 q = p*rot(.86);\n    float bt = min(\n        box(p-vec2(-.0125,.15),vec2(.1375,.025)),\n        box(p+vec2(-.0125,.15),vec2(.1375,.025))\n    );\n    bt = min(\n        min(length(vec2(abs(q.x)-.198,q.y))-.025,bt),\n        box(q,vec2(.195,.025))\n    );\n    return bt;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fB3RR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[278, 278, 296, 296, 361], [362, 362, 383, 383, 440], [441, 441, 471, 471, 522], [572, 572, 607, 607, 1437], [1438, 1438, 1486, 1486, 2901]], "test": "untested"}
{"id": "dlGBz3", "name": "amagi: Wobbly Tunnel", "author": "amagitakayosi", "description": "Just practice.\nInspired by the first scene of \"EMIX by Epoch ft. Trio Tampere\" https://www.youtube.com/watch?v=SYG9zU_bd6U", "tags": ["raymarching"], "likes": 11, "viewed": 382, "published": 3, "date": "1704008103", "time_retrieved": "2024-07-30T17:14:02.305334", "image_code": "#define zoom(uv, x) ((uv - .5) * x + .5)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n\n    // Aberration\n    vec4 c = vec4(\n        texture(iChannel0, zoom(uv, 1.0)).r,\n        texture(iChannel0, zoom(uv, .985)).g,\n        texture(iChannel0, zoom(uv, .97)).b,\n        1.\n    );\n    \n    // Vignette\n    c -= pow(length(p), 2.) * .1;\n    // c.rgb *= mix(vec3(1), vec3(.1, .0, .7), pow(length(p), 2.) * .1);    \n\n    // colorize\n    c.r = smoothstep(-.1, 1., c.r);\n    c.b = smoothstep(.0, .6, c.b);    \n    \n    fragColor = c;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Wobbly Tunnel\n// Inspired by the first scene of \"EMIX by Epoch ft. Trio Tampere\" https://www.youtube.com/watch?v=SYG9zU_bd6U\n// \n// Music: \"Malta 6AM\" by NÃ¸rbak\n// https://soundcloud.com/hate_music/premiere-norbak-malta-6am-hysep49\n\n\n// Constants\n#define EPS 1e-3\n#define BPM 138.\n#define phase ((60. / BPM) * 4.)\n#define phaseCount 4.\n#define TIME_OFFSET 0.2\n    \n// Global vars\nfloat time;\nfloat modetime;\nfloat light;\nfloat lightK = 1.;\n\nmat2 rot(float t) {\n    float c = cos(t), s = sin(t);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdTunnel(vec3 p) {\n    float t = time;\n    p.xy *= .5;    \n    p.z -= time * .3;\n\n    p.xy *= 1. + (\n        cos((p.z * 7. + p.x + 7. + p.y * 5.) - t * 2.) *\n        cos((p.z * -2. + + p.x * 0.5 + p.y * -6.) - t * 2.) *\n        cos((p.z * 3. + + p.x * 2.1 + p.y * -3.7) - t * 1.3) *\n        cos((p.z * -.9 + + p.x * 1.7 + p.y * 8.7) - t * .9)  \n    ) * 0.2;\n    \n\n    return 1. - length(p.xy);    \n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n    return length(vec2(length(p.xy) - r.y, p.z)) - r.x;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) - min(max(max(q.x, q.y), q.z), 0.);\n}\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdLight(vec3 p) {\n    p.xy *= rot(sin(time * .7 + 2.) * 1.);\n    p.xz *= rot(time * 1.2 + 3.);\n\n    // mode change noise\n    float change = smoothstep(.07, 0., modetime / phase) + smoothstep(.93, 1., modetime / phase);        \n    p += vec3(\n        sin(p.y * 3.7 + iTime) * sin(p.y * 17. + iTime) * sin(p.y * 29. - iTime * .7),        \n        sin(p.x * 5.1 + iTime) * sin(p.y * 13. + iTime) * sin(p.y * 23. - iTime * .6),\n        0\n    ) * change;\n\n    float d;\n    float mode = floor(mod(time,  phase * phaseCount) / phase);\n    if (mode == 0.) {    \n        // Double ring\n        vec3 q = p;    \n        p.x += .23;\n        q.xy -= .1;\n        q.xy *= rot(5.);\n        q.xz *= rot(5. + sin(time + 2.) * .1);        \n        vec2 r =  vec2(0.001, .8);\n        d = min(sdTorus(p, r), sdTorus(q, r));\n    } else if (mode == 1.) {\n        // Cross\n        float x = 0.02 * (.3 + 1. * abs(sin(p.y)));\n        \n        p.x += .2;\n        d = sdBox(p, vec3(x, x, .8));\n        \n        p.xy -= .1;        \n        p.xy *= rot(1.);\n        d = min(d, sdBox(p, vec3(x, .9, x)));\n       \n        p.xy *= rot(3.);\n        d = min(d, sdBox(p, vec3(.4, x, x)));\n    } else if (mode == 2.) {\n        // Twist\n        p.xz *= rot(p.y * 1.2);    \n        float a = atan(p.y, p.x);\n        p.xy *= 1.1 + sin(a * 3.) * .2;\n        d = sdTorus(p, vec2(0.02, 1.));\n    } else {    \n        // spheres\n        float r = .3;\n        float r2 = .14;       \n        d = sdSphere(p + vec3(1) * r, r2);\n        d = min(d, sdSphere(p + vec3(1, -1, -1) * r, r2));        \n        d = min(d, sdSphere(p + vec3(-1, 1, -1) * r, r2));        \n        d = min(d, sdSphere(p + vec3(-1, -1, 1) * r, r2));                                             \n    }\n    \n    return d;\n}\n\nvec2 map(vec3 p) {\n    float d1 = sdTunnel(p);\n    \n    float d2 = sdLight(p);    \n    float glow = .015 / d2;\n    float wall = exp(d2 * -1.) * smoothstep(0., 2., length(p)) * .03; // add light for walls\n    light += (glow + wall) * .84;\n    \n    return d1 < d2 ? vec2(d1, 1) : vec2(d2, 2);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 d = vec2(0, 0.001);\n    return normalize(vec3(\n        (map(p + d.yxx) - map(p - d.yxx)).x,\n        (map(p + d.xyx) - map(p - d.xyx)).x,\n        (map(p + d.xxy) - map(p - d.xxy)).x\n    ));\n}\n\nfloat noise(float t) {\n    return sin(t * 3.) * sin (t  * 7.1) * sin(t * 19.3) * sin(t * 37.9);\n}\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(348., 481.))) *948.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;    \n    float l = length(p);\n    \n    p *= 1. + pow(l, 2.) * 0.2; // distort\n        \n    // update globals\n    time = iTime + TIME_OFFSET;\n    modetime = mod(time, phase);\n    lightK = .7 + noise(time) * 0.3;\n                \n    // bokeh\n    p += vec2(hash(p + time), hash(p + time + 2.)) * smoothstep(.4, 8., l) * 2.;\n                        \n    // camera wiggle\n    vec3 ro = vec3(0, 0, 2.2);    \n    ro.xy += vec2(\n        noise(time * .07 + 3.),     \n        noise(time * .03 + 7.)        \n    ) * .17;\n    \n    // define ray\n    vec3 rt = vec3(0);\n    vec3 cf = normalize(ro - rt);        \n    vec3 cu = vec3(0, 1, 0);\n    vec3 cr = cross(cf, cu);    \n    vec3 rd = normalize(p.x * cr + p.y * cu + -1. * cf);\n    \n    \n    vec3 rp;\n    float t, fi;\n    vec2 hit;\n   \n    \n    for (int i = 0; i < 99; i++) {\n        rp = ro + rd * t;\n        hit = map(rp);\n        \n        if (hit.x < EPS) {\n            fi = float(i);\n            break;\n        }\n        t += hit.x * .7;\n    }   \n\n    vec3 col;\n    vec3 ld = normalize(vec3(2,3,1));\n    vec3 ld2 = normalize(vec3(-1,-3,1));    \n    vec3 ld3 = normalize(vec3(-5,-2,0));\n    vec3 n = getNormal(rp);    \n    if (hit.y == 1.) {    \n        col += .8 * (\n            pow(max(0., dot(n, ld)), 110.) + \n            pow(max(0., dot(n, ld2)), 210.) +\n            pow(max(0., dot(n, ld3)), 310.)              \n        ) * lightK;        \n        col *= 0.;\n        \n        vec3 ldd = normalize(-rp);\n        \n        col += .3 * pow(max(0., dot(n, ldd)), 300.) * lightK; // diffuse\n        col += .5 * pow(max(0., dot(n, normalize(ldd - rd))), 30.) * lightK; // specular\n        \n        col += .3; // amb\n                \n        col += light * lightK;\n        col -= .003 * fi; // AO\n        col -= .2 * pow(t, .7);  // dark fog\n    } else if (hit.y == 2.) {\n        col += lightK * 2.;\n    }    \n\n    // it didn't make the look better...\n    // col = pow(col, vec3(.4545));\n\n    fragColor = vec4(col, 1);\n}\n", "buffer_a_inputs": [{"id": 35603, "src": "https://soundcloud.com/hate_music/premiere-norbak-malta-6am-hysep49", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlGBz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 99, 99, 652]], "test": "untested"}
{"id": "lc23zw", "name": "Infinite roguelike dungeon 7", "author": "jarble", "description": "An infinite procedural maze or dungeon using [url=https://www.shadertoy.com/view/Mc23RW]this maze pattern[/url].", "tags": ["maze", "dungeon", "labyrinth", "roguelike"], "likes": 4, "viewed": 169, "published": 3, "date": "1704000791", "time_retrieved": "2024-07-30T17:14:03.134118", "image_code": "int iters = 5;\n\nbool labyrinth(ivec2 I) {\n\tivec2\n        J = I & 1;\n    return\n        bool((J.x ^ J.y) & (I.x / 2 * 97 ^ I.y / 2 * 69) % 7 ^ J.x)\n        //bool(J.x & J.y | (J.x ^ J.y) & (I.x / 2 * 97 ^ I.y / 2 * 69) % 7 ^ J.x)\n        //int(J.x | J.y & (J.x ^ J.y) & (I.x / 2 * 97 ^ I.y / 2 * 69) % 7 ^ J.x)\n    ;\n}\n\nvec4 maze1(ivec2 I){\n    vec4 O = vec4(1);\n    bool b = false;\n    float n = 0.;\n    for(int i = 0; i++ < iters;I =\n    I*2/3\n    //(((I*2)/3)*3)\n    ){\n        b =\n            !b || labyrinth(I)\n        ;\n    }\n    if (!b) O = 1.-O;\n    return O;\n}\n\nvec4 maze(ivec2 I){\n    return\n        //maze1(I)\n        min(maze1(I),maze1(I/2))\n        //min(maze1(I/2*2/3),maze1(I/3*3))\n        //min(maze1(I),maze1(I/3))\n    ;\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    ivec2 I = ivec2( U/4.+ iTime*4.*8.);\n    O = maze(I);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lc23zw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 41, 41, 317], [319, 319, 339, 339, 568], [570, 570, 589, 589, 738], [740, 740, 776, 776, 836]], "test": "untested"}
{"id": "4f23zm", "name": "Fractal V3 (Human Readable)", "author": "spenceryonce", "description": "Human readable fractal with comments to explain each piece.\n\nClick and drag to look around the scene", "tags": ["fractal", "camera", "readable", "human", "v3", "lookaround", "forhumans"], "likes": 7, "viewed": 247, "published": 3, "date": "1703988178", "time_retrieved": "2024-07-30T17:14:03.991825", "image_code": "// Define macros to simplify repeated operations\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a) // Rotation operation\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5) // Hue shift function\n\n// The main image function\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    fragColor = vec4(0); // Initialize the fragment color to black\n\n    // Set up camera and resolution\n    vec3 cameraPosition, resolution = iResolution; // Camera position and resolution\n\n    // Calculate view direction with mouse input\n    vec2 mouse = iMouse.xy / iResolution.xy; // Normalize mouse coordinates\n    float mouseAngleX = mix(-0.5, 0.5, mouse.x); // Convert mouse X to an angle\n    float mouseAngleY = mix(-0.5, 0.5, mouse.y); // Convert mouse Y to an angle\n    mat2 mouseRotationX = mat2(cos(mouseAngleX), sin(mouseAngleX), -sin(mouseAngleX), cos(mouseAngleX)); // Rotation matrix for X\n    mat2 mouseRotationY = mat2(cos(mouseAngleY), sin(mouseAngleY), -sin(mouseAngleY), cos(mouseAngleY)); // Rotation matrix for Y\n\n    // Apply mouse rotation to view direction\n    vec3 viewDirection = normalize(vec3((fragCoord.xy - 0.5 * resolution.xy) / resolution.y, 1));\n    viewDirection.xy *= mouseRotationX; // Rotate view direction based on mouse X\n    viewDirection.yz *= mouseRotationY; // Rotate view direction based on mouse Y\n\n    // Initialize ray marching variables\n    float rayLength = 0.0, globalScale = 0.0, scaleMultiplier, stepSize, hueShift, amplitude;\n\n    // Ray marching loop\n    for (float stepCount = 0.0; stepCount < 99.0; stepCount++) {\n        // Calculate position along the view direction\n        vec3 position = globalScale * viewDirection;\n        position.z += iTime * 0.2; // Animate position over time\n        position = sin(position); // Apply sine distortion to position\n        position = R(position, vec3(.577), iTime * .577); // Rotate position over time\n        position = abs(position) - .4; // Apply absolute value and constant offset\n        // Rearrange components of position vector\n        position = position.x < position.y ? position.zxy : position.zyx;\n        position = position.x < position.y ? position.zxy : position.zyx;\n        scaleMultiplier = 1.4; // Initialize scale multiplier\n\n        // Fractal iteration loop\n        for (int fractalIteration = 0; fractalIteration < 5; fractalIteration++) {\n            // Scale and transform the position vector\n            scaleMultiplier *= stepSize = 2.0 / clamp(dot(position, position), .3, 1.2);\n            position = abs(position) * stepSize - vec3(0.95, .01, 4);\n        }\n        amplitude = 1.0; // Set amplitude for clamping\n        position -= clamp(position, -amplitude, amplitude); // Clamp position vector\n        globalScale += stepSize = length(position) / scaleMultiplier; // Update global scale\n\n        // Calculate color adjustment based on the scale multiplier\n        vec3 colorAdjustment = H(scaleMultiplier * .01) + .5;\n        // Update fragment color with exponential falloff\n        fragColor.rgb += colorAdjustment * .01 * exp(-.4 * stepCount * stepCount * stepSize);\n    }\n    fragColor = pow(fragColor, vec4(4)); // Apply gamma correction to the final color\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4f23zm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 227, 279, 279, 3177]], "test": "untested"}
{"id": "4f2Gzm", "name": "Balloon Party", "author": "me_123", "description": "A simple raymarching shader", "tags": ["3d", "raymarching", "random"], "likes": 8, "viewed": 195, "published": 3, "date": "1703986066", "time_retrieved": "2024-07-30T17:14:04.806647", "image_code": "float hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat sdf(in vec3 z) {\n    vec3 k =vec3(0, (0.5-hash(floor(z.xz)))*iTime*5., 0);\n    vec3 p = fract(z+k)*2.0-1.0;\n    float m = 0.0;\n    return 0.1*(length(p));//(length(vec2(length(p.xz)-m, p.y))-0.25)*0.5;\n}\nvec3 color(in vec3 p) {\n    vec3 z = sin(p*0.1)*10.;\n    return 0.5+0.5*sin(p);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.x*0.5)/min(iResolution.x, iResolution.y);\n    vec3 ro = vec3(\n        cos(iTime*0.1)*10.,\n        1.0+sin(iTime*0.1)*10.,\n        iTime*1.\n    );\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0+sin(iTime)*0.1));\n    \n    float d = 0.0;\n    int k = 100, i;//int(floor(sin(iTime)*10.))+20;\n    for (i = 0; i < k; i += 1) {\n        float s = sdf(ro+rd*d);\n        if (s < 0.01) break;\n        d += s;\n        if (d > 1000.) break;\n    }\n    fragColor = vec4(color((ro+rd*d)+iTime*10.), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4f2Gzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 137], [138, 138, 160, 160, 347], [348, 348, 371, 371, 429], [430, 430, 487, 487, 1013]], "test": "untested"}
{"id": "4c2Gzm", "name": "FBM Earthlike tones, w/ Fractal", "author": "spenceryonce", "description": "Simple fbm with earthlike tones, w/ fractal\n\ndrag with mouse to pan", "tags": ["fractal", "noise", "simple", "fbm", "fun", "earthtones"], "likes": 5, "viewed": 188, "published": 3, "date": "1703985765", "time_retrieved": "2024-07-30T17:14:05.554647", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        314159.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 8\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy*3.0;\n    st+=iMouse.xy/-iResolution.xy*3.;\n\n    // Increased complexity for a more intricate fractal structure\n    vec2 q = vec2(fbm(st + 0.01 * iTime) + fbm(st + vec2(1.0)));\n    vec2 r = vec2(fbm(st + 1.5 * q + vec2(1.7, 9.2) + 0.1 * iTime)) +\n             vec2(fbm(st + 1.5 * q + vec2(8.3, 2.8) + 0.05 * iTime));\n    float f = fbm(st + r);\n\n    // Earth tone color palette\n    vec3 color = mix(vec3(0.545, 0.271, 0.075),  // Dark brown\n                     vec3(0.965, 0.765, 0.463),  // Light tan\n                     clamp((f * f) * 4.752, 0.0, 1.568));\n\n    color = mix(color,\n                 vec3(0.753, 0.561, 0.357),  // Golden brown\n                 clamp(length(q), 0.0, 1.0));\n\n    color = mix(color,\n                 vec3(0.467, 0.533, 0.251),  // Dark olive green\n                 clamp(length(r.x), 0.0, 1.0));\n\n    fragColor = vec4((f * f * f + 0.6 * f * f + 0.5 * f) * color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4c2Gzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 74, 74, 183], [185, 263, 290, 290, 672], [697, 697, 723, 723, 1061], [1063, 1063, 1120, 1120, 2064]], "test": "untested"}
{"id": "4c2GRm", "name": "Controllable Colored Blinders", "author": "spenceryonce", "description": "simple controllable colored blinders.", "tags": ["simple", "colorful", "blinders"], "likes": 2, "viewed": 183, "published": 3, "date": "1703980439", "time_retrieved": "2024-07-30T17:14:06.303644", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 col = vec3(uv.x,0.0,uv.y);\n    vec2 offset = vec2(iMouse.x/iResolution.x,iMouse.y/iResolution.y);\n    vec3 cir = 1.0-vec3(length(uv-offset))-length(uv-offset);\n    vec3 ran = vec3(fract(uv.x*10.0));\n    //col = 1.0-cir-(cir+-0.168)+col;\n    col = cir+col-ran;\n    \n    \n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4c2GRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 103, 103, 452]], "test": "untested"}
{"id": "mdc3RS", "name": "SDF blur - Brute force", "author": "PauloFalcao", "description": "SDF blur using fibonacci points in a sphere\nChange #define iterations 55 at line 39", "tags": ["sdfblur"], "likes": 12, "viewed": 277, "published": 3, "date": "1703977617", "time_retrieved": "2024-07-30T17:14:07.132428", "image_code": "// Brute force SDF blur\n// By PauloFalcao\n//\n// SDF blur using fibonacci points in a sphere\n// Change #define iterations 55 at line 39\n// \n// Since I learned how to do raymarching, I've wanted to do SDFs blur\n// I have some posts on Pouet about it in 2011\n//   - https://www.pouet.net/topic.php?post=367378\n//   - https://www.pouet.net/topic.php?post=367436\n// But the truth is that I've never managed to make something interesting\n// Is it even possible?\n// This why is one of the possible \"brute force\" ones.\n// Sampling the SDF in a sphere in a Fibonacci point distribution.\n// It's brute force, but you can create some interesting things with it.\n// Try changing iterations it to a low value, and you'll get some crystal-like forms! :)\n//\n// I also have a node for this in my MaterialMaker raymarching lib\n// https://github.com/paulofalcao/MaterialMakerRayMarching\n//\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n//Test Object\nfloat sdf_a(vec3 p){\n  float b=sdBox(p,vec3(1.3,1.3,1.3));\n  float s=length(p)-1.5;\n    \n  return max(b,-s);\n}\n\n\n#define iterations 55\n// blur obj is sdf_a\n// b is the blur amount\n// f is just the bounding object size\n//   so it only blurs when close to the object\nfloat blursdf3d(/*obj vec3->float*/in vec3 p,in float b,float f){\n    /*obj vec3->float = sdf_a*/\n\tfloat a=0.0;\n\tfloat d=sdf_a(p);\n\tif (d<b*f){\n        /*iterations*/\n\t\tfor(int i=0;i<iterations;i++){\n\t        float y=1.0-2.0*(float(i)/float(iterations));\n\t        float r=sqrt(1.0-y*y);\n\t        float t=2.39996322973*float(i);\n\t\t\ta+=sdf_a(p+vec3(cos(t)*r,y,sin(t)*r)*b);\n\t\t}\n\t} else{\n\t\treturn d;\n\t}\n\treturn a/float(iterations);\n}\n\n\n//Object Color\nvec3 tex3d_a(vec3 p){\n    return vec3(1.0,0.0,0.0);\n}\n\n//Floor\nfloat sdf_b(vec3 p){\n    return max(p.y+2.0,length(p)-8.0);\n}\n\n//Floor color\nvec3 tex3d_b(vec3 p){\n    p*=2.0;\n\tvec2 w=max(abs(dFdx(p.xz)),abs(dFdy(p.xz)))+1e-5;\n\tif (max(w.x,w.y)>0.5) {\n\t\treturn vec3(mod(floor(p.x)+floor(p.z),2.0));\n\t}\n\tvec2 i=((1.-abs(2.*fract((p.xz+.5*w)/2.)-1.))-(1.-abs(2.*fract((p.xz-.5*w)/2.)-1.)))/w;\n\treturn vec3(.5-.5*i.x*i.y);\n}\n\n\n//Rotation\nvec2 rot(vec2 p,float f){\n    float s=sin(f);float c=cos(f);\n    return p*mat2(c,-s,s,c);\n}\n\n//Combine the 2 SDFs\nvec2 sdf(vec3 p) {\n\n    vec3 p_obja=p;\n    //Rotate the object sdfa\n    p_obja.yz=rot(p_obja.yz,sin(iTime*0.5)*2.0);\n    p_obja.xz=rot(p_obja.xz,sin(iTime*0.2)*0.5);\n    p_obja.xy=rot(p_obja.xy,sin(iTime*0.03)*2.0);\n\n    float sdfa=blursdf3d(p_obja,sin(iTime)*0.1+0.15,0.1);\n\tfloat sdfb=sdf_b(p);\n\tif (sdfa<sdfb) {\n\t  return vec2(sdfa,0.0);\n\t} else {\n\t  return vec2(sdfb,1.0);\n\t}\n}\n\n\n//definition\nvec3 raymarch(vec2 uv,vec3 camera,float cameraZoom,vec3 lookAt,\n    float cameraDistance,vec3 sun, float ambLightIntensity,\n    float lightPow,float lightSpecular,float reflection);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //setup uv\n    vec2 uv=fragCoord/iResolution.xy-0.5;\n    uv.x*=iResolution.x/iResolution.y;\n\n    //rendering parameters\n    vec3 camera=vec3(sin(sin(iTime*0.3)*0.5+0.5)*4.0,2.0,cos(cos(iTime*0.2)*0.5+0.5)*4.0);\n    float cameraZoom=1.5;\n    vec3 lookAt=vec3(0.0,0.0,0.0);\n    float cameraDistance=1.1;\n    vec3 sun=vec3(0.0,2.0,2.5);\n    float ambOcclusion=1.0;\n    float shadowIntensity=1.0;\n    float ambLightIntensity=0.25;\n    float lightPow=128.0;\n    float lightSpecular=0.7;\n    float reflection=0.2;\n    vec3 col = raymarch(uv,camera,cameraZoom,lookAt,cameraDistance,sun,\n        ambLightIntensity,lightPow,lightSpecular,reflection);\n\n    fragColor = vec4(pow(col,vec3(1.0/2.2)),1.0);\n}\n\n\n//************************* Rendering framework ****************************************\n\nvec3 normal(vec3 p){  \n  const vec2 e=vec2(0.001,-0.001);\n  float x=sdf(p+e.xyy).x;\n  float y=sdf(p+e.yxy).x;\n  float z=sdf(p+e.yyx).x;\n  return normalize(vec3(x-y-z,-x+y-z,-x-y+z)+sdf(p+e.xxx).x);\n}\n\nvoid march(inout float d,out vec3 p,out vec2 dS,in vec3 ro,in vec3 rd){\n    for (int i=0; i < 100; i++) {\n    \tp = ro + rd*d;\n        dS = sdf(p);\n        d += dS.x;\n        if (d > 20.0 || abs(dS.x) < 0.0001) break;\n    }\n}\n\n\nvec3 hdri(vec3 p,float v) {\n\treturn pow(texture(iChannel0, p).xyz, vec3(2.2))\n    + pow(texture(iChannel0, p).xxx, vec3(16.0)) * v;\n}\n\nvec3 raymarch(\n        vec2 uv,\n        vec3 camera,\n        float cameraZoom,\n        vec3 lookAt,\n        float cameraDistance,\n        vec3 sun,\n        float ambLightIntensity,\n        float lightPow,\n        float lightSpecular,\n        float reflection) {\n\tvec3 cam=camera*cameraZoom;\n\tvec3 ray=normalize(lookAt-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));\n\tvec3 cY=normalize(cross(ray,cX));\n\tvec3 rd = normalize(ray*cameraDistance+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0.);\n\tvec2 dS=vec2(0.);\n\tmarch(d,p,dS,ro,rd);\n\t\n    vec3 color=vec3(0.);\n\tvec3 objColor=(dS.y<0.5)?tex3d_a(p):tex3d_b(p);\n\tvec3 light=normalize(sun);\n\tif (d<20.0) {\n\t    vec3 n=normal(p);\n\t\tfloat l=clamp(dot(-light,-n),0.,1.0);\n\t\tvec3 ref=normalize(reflect(rd,-n));\n\t\tfloat r=clamp(dot(ref,light),0.,1.0);\n\t\tcolor=max(ambLightIntensity,l)*objColor+pow(r,lightPow)*lightSpecular;\n\t\t//reflection\n        d=0.01;\n\t\tmarch(d,p,dS,p,ref);\n\t\tvec3 objColorRef=vec3(0.);\n\t\tif (d<20.0) {\n\t\t\tobjColorRef=(dS.y<0.5)?tex3d_a(p):tex3d_b(p);\n\t\t\tn=normal(p);\n\t\t\tl=clamp(dot(-light,-n),0.,1.);\n\t\t\tobjColorRef=max(l,ambLightIntensity)*objColorRef;\n\t\t} else {\n\t\t\tobjColorRef=hdri(ref.zyx,1.0);\n\t\t}\n\t\tcolor=mix(color,objColorRef,reflection);\n\t} else {\n\t\tcolor=hdri(rd.zyx,0.0);\n\t}\n\treturn color;\n}\n\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdc3RS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[873, 921, 952, 952, 1039], [1042, 1056, 1076, 1076, 1166], [1754, 1769, 1790, 1790, 1822], [1824, 1832, 1852, 1852, 1893], [1895, 1909, 1930, 1930, 2188], [2191, 2202, 2227, 2227, 2293], [2295, 2316, 2334, 2334, 2697], [2896, 2896, 2952, 2967, 3651], [3744, 3744, 3764, 3764, 3943], [3945, 3945, 4016, 4016, 4169], [4172, 4172, 4199, 4199, 4305], [4307, 4307, 4568, 4568, 5595]], "test": "untested"}
{"id": "Xfj3zw", "name": "parallax basics", "author": "jakedowns", "description": "parallax basics", "tags": ["parallax"], "likes": 1, "viewed": 101, "published": 3, "date": "1703975657", "time_retrieved": "2024-07-30T17:14:07.900375", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy/4.0;\n    vec2 ouv = uv;\n    uv.x = uv.x * sin(iTime);\n    \n    \n    // Calculate the parallax effect based on the vertical position\n    // The center of the screen (uv.y = 0.5) will have no parallax.\n    float parallax = (uv.y - 0.5) * (sin(iTime*.1)*2.0)-1.0; // Ranges from -1 at the top to 1 at the bottom\n\n    // Adjust the amount of horizontal scroll\n    // You can tweak the factor '4.0' to change the scroll speed\n    uv.x += iTime * parallax * 0.1;\n\n    // Wrap the UV coordinates horizontally\n    uv.x = fract(uv.x);\n\n    // Time varying pixel color\n    vec3 col = vec3(uv.x,uv.y,sin(iTime));\n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xfj3zw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 816]], "test": "untested"}
{"id": "ct3fWl", "name": "Geometric semicircles", "author": "Saimon", "description": "Animated reproductin of this image: https://www.posterlounge.fr/p/711186.html#paid=19198 by Jazzberry Blue, check his other graphical work here: https://www.jazzberryblue.com/", "tags": ["color", "moving", "reproduction", "semicircle"], "likes": 3, "viewed": 128, "published": 3, "date": "1703944850", "time_retrieved": "2024-07-30T17:14:08.753095", "image_code": "/* \"Geometric semi circles\"\n * I wanted to practice GLSL and the primitives describe in https://thebookofshaders.com/07/\n * so I started looking for art images to try to reproduce.\n * This one is part of my practice serie, it is based on this image: \n * https://www.posterlounge.fr/p/711186.html#paid=19198\n * It was made by Jazzberry Blue, check his other graphical work here: https://www.jazzberryblue.com/\n * (November 2023)(started with 3005 char - Updated 09/01/24 with massive help from FabriceNeyret2)\n */\n\n\nfloat HALF_PI = 1.57,  PI = 3.14;\n#define R       iResolution.xy\n// Clamp the color to make sure it's between [0;1]\n#define clampColor(C) clamp(C,0.,1.)\n//https://www.shadertoy.com/view/XlsyWX\n#define rot(a)  mat2(cos(a+vec4(0,33,11,0)))\n#define W .8/R.y\n#define sstep(t) smoothstep(-W,W,t)\n#define tweenEaseInOutExpo(t) easeInOutExpo(min(t, 1. -t))\n\nfloat sdBox(vec2 p, vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat semiCircle(vec2 p, float r, float angle){\n  p *= -rot(angle);\n  float d1 = length(p) - r, //signed distance of circle\n        d2 = sdBox(p+vec2(r,0.), vec2(r));\n  return max(d1,d2);\n}\n\nfloat border(float sd, vec2 p, float s){\n  float d2 = abs(sd) - s;\n  return smoothstep(-W,W, max(sd, d2));\n}\n\n// Simplify version of code: https://thebookofshaders.com/edit.php?log=160909065147\n// and http://www.kynd.info\nfloat easeInOutExpo(float t) {\n  t = exp2(40.*t-10.);\n  return t < 1.\n      ?      .5 * t\n      : 1. - .5 / t;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ){\n  vec2 st = (fragCoord*2. -R.xy) / R.y - vec2(0.1,-0.32);\n  float t = fract((iTime)/3.);\n\n  vec3 YELLOW = vec3(0.902,0.549,0.102),\n       ORANGE = vec3(0.984,0.416,0.09),\n       BEIGE = vec3(0.941,0.671,0.455);\n\n  float rotAngle = tweenEaseInOutExpo(t) * HALF_PI,\n        r = 0.243,\n        s = 0.005;\n\n  st /= 1.8; //Increase the size of the figure\n\n  float c1 = border(semiCircle(st - vec2(0.062,0.185), r, -rotAngle), st, s),\n        c2 = border(semiCircle(st - vec2(-0.179,0.428),r, rotAngle + HALF_PI), st, s),\n        c3 = border(semiCircle(st - vec2(-0.186,-0.0585),r,-rotAngle - HALF_PI), st, s),\n        c4 = sstep(semiCircle(st - vec2(0.062,0.428),r, rotAngle +HALF_PI)),\n        c5 = sstep(semiCircle(st - vec2(0.059,-0.0585),r,-rotAngle-HALF_PI)),\n        c6 = sstep(semiCircle(st - vec2(-0.182,0.185) + vec2(tweenEaseInOutExpo(t)/6.380,0.),r,PI));\n\n  fragColor.rgb =  c1\n                   * c2\n                   * c3\n                   * clampColor(c4 + ORANGE )\n                   * clampColor(c5 + BEIGE  )\n                   * clampColor(c6 + YELLOW );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct3fWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[866, 866, 894, 894, 974], [976, 976, 1023, 1023, 1165], [1167, 1167, 1207, 1207, 1275], [1277, 1389, 1419, 1419, 1501], [1503, 1503, 1555, 1555, 2628]], "test": "untested"}
{"id": "XfBGzw", "name": "truchet tetragonal octahedron", "author": "cyperus", "description": "random truchet 3d - cyclic toroidal tetragonal grid - cyclic toroidal spherical octahedron slides", "tags": ["3d", "sdf", "truchet", "tiling", "octahedron", "schwarzchristoffel"], "likes": 5, "viewed": 187, "published": 3, "date": "1703934007", "time_retrieved": "2024-07-30T17:14:09.873101", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"truchet tetragonal octahedron\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n//\n// References & Inspiration:\n//\n// - quick guide for shadertoy by FabriceNeyret2\n//   https://shadertoyunofficial.wordpress.com/\n//\n// - \"Schwarz-Christoffel Mapping\" by mla\n//   https://www.shadertoy.com/view/tsfyRj\n//\n// - signed distance functions & operations by iq\n//   https://iquilezles.org/articles/distfunctions/\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// ray casting bounding shape\nconst float\n    CAM_DIST = 7.,\n    CAM_FLE = 2.,\n    BB_DIST = 3.,\n    RAY_MIN_DIST = 0.1,\n    RAY_MAX_DIST = CAM_DIST+1.1*BB_DIST;   \n\nconst int MAX_MARCHING_STEPS = 600;\nconst float\n    RAY_STEP_FACTOR = 0.0095,\n    RAY_PRECISION = 1.E-1;\n\n// data from sdf\nvec3 mat_to = vec3(0);\nvec3 mat_to_id = vec3(0);\nvec4 mat_tc = vec4(0);\n\nfloat map(in vec3 p) {\n    float rxy = 0., au = 0.0, av = 0.0;\n    vec2 z = vec2(0.);\n    float d = -1.;\n           \n    vec4 psr; float sr = 0.;\n    /// cyclic sphere\n    vec2 e33 = vec2(.125, .75);\n    psr = spb(p, spf_F33(p, 6., e33));                \n    p = psr.xyz; sr = psr.w;\n    \n    p = p.yzx;\n\n    /// torus\n    z = vec2(length(p.zx), p.y);\n    au = atan(p.x, p.z); au += 0.05 * iTime;\n    z = cmul(z,z);  \n    z.x -= 6.;\n    //z.x -= 4.5 + 1.5 * sin(2.*PI*iTime/180.);\n    //z.x -= 1.75 + 4.25 * sin(2.*PI*iTime/360.);\n    av = atan(z.y, z.x);\n    rxy = length(z);\n    \n    \n    vec2 grid_num = vec2(4.,4.);\n    p = vec3(grid_num.x*au/PI, grid_num.y*av/PI, log(rxy)-0.4);\n    /// regular polygon tiles\n    vec2 rpt_id = vec2(1.);  float rpt_sr;\n    p.xy = recgrid2rec(p.xy, rpt_id.xy, rpt_sr);\n    p.xy = inversesc(p.xy,4);\n    mat_to_id = vec3(rpt_id, rpt_sr);\n\n        \n    /// (torus,sphere,2spheres)  \n    rxy = length(p.xy); au = atan(p.y, p.x) + 2.*PI*iTime/120.;\n    z = ccos(PI*vec2(rxy,2.* p.z))/0.5;\n    z.x += (3. + 2. * sin(2.*PI*iTime/120.));\n        \n    p = vec3(log(length(z)), fract(2.*0.5*au/PI)/2., 0.5*atan(z.y,z.x)/PI);\n    vec2 to_uv = vec2(0.5*au/PI,p.z);\n    float to_d = log(length(z)+0.8);\n    mat_to = vec3(to_uv,to_d);\n\n    /// truchet 3D cube grid\n    vec3 tc_id = vec3(0.); float tc_a = 0.;   \n    p *= vec3(1.,24.,4.);\n    p.yzx = p.xyz;\n    \n    ivec3 l0 = -ivec3(2.,0,12.);\n    ivec3 l1 =  ivec3(2.,1.,12.)-ivec3(1.);\n    tc_id = floor(p);\n    tc_id = clamp(tc_id, vec3(l0), vec3(l1));\n    vec3 q = p - tc_id -0.5;\n\n    // truchet 3D cube tiles\n    float rnd = hash21(tc_id.xz);\n    if(rnd<.5) q.x = -q.x;\n    if(fract(rnd*77.57+iTime/6.)>.75) {\n       vec3 q2 =  length(q.xz-.5)<length(q.xz+.5)\n                ? vec3(q.xz-.5,0.)  \n                : vec3(q.xz+.5,1.);\n       d = sdTorus( vec3(q2.x, q.y, q2.y) , vec2(0.5,0.125) );\n    }\n    else {\n       d = opSmoothUnion( sdCylinder( q.zxy, 0.125 ), sdCylinder( q.xzy, 0.125 ), 0.05 );\n    }\n    mat_tc = vec4(q,rnd);  \n   \n    // return\n    return min(d,to_d);\n}\n\n// intersect\nfloat intersect(in vec3 ro, in vec3 rd, in float px) {\n    float res = -1.0;\n    \n    // bb\n    vec2 dis = isphere( ro, rd , abs(BB_DIST));    \n    if( dis.y<0.0 ) return -1.0;\n    dis.x = max( dis.x, RAY_MIN_DIST );\n    dis.y = min( dis.y, RAY_MAX_DIST );\n\n    // raymarch signed distance field    \n\tfloat fh = RAY_STEP_FACTOR;\n    float t = dis.x;\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) {\n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t;\n        float h = map( pos);\n        if( t>dis.y || h<th ) break;\n        t += h*fh;\n    }\n    if( t<dis.y ) {\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) { \n\tif (iMouse.x > 0.0) {\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n    p.yz = crot(p.yz,-1.*PI*(time+10.));\n    p.zx = crot(p.zx,-2.*PI*(time+15.));\n\treturn p.xyz;\n}\n\n// textures\nfloat grid_uv(in vec2 uv) {\n    // uv grid alpha mask\n    vec2 sw = abs(fract(uv-0.25)-0.5)-0.25;\n    float sdf = min(sw.x,sw.y)*-max(sw.x,sw.y);\n    float pp = fwidth(sdf);\n    return smoothstep(+pp,-pp,sdf);\n}\n            \nvec4 cells(in vec2 uv, in float h) {\n    // sectors, uv-grid\n    vec4 C;\n    C.a = 1.;\n    C.rgb = h2rgb(h*0.01*iTime);           // sector  -> hue\n    //C.rgb *= (0.5+ 0.5 * grid_uv(uv))*0.7; // uv-grid -> value\n    return C;\n}\n\nvec4 ribbon(in float uv_x, in float r, in float time) {\n    float sdf = -(2.*pulsecollision(1.,1./3. * uv_x, time, 2./6.)-1.);\n    float px = fwidth(sdf); float a = smoothstep(px+0.1,-px-0.1,sdf+0.2);    \n    vec4 C = r<0.5 ? vec4( h2rgb(sdf -2./6.),a ) : vec4(0.);\n    return C;\n}\n\nvec4 truchet3D(in vec3 p, in float rnd ,in float time) {\n    float sdf = sdBox( p, vec3(0.5*0.9));\n    float px = fwidth(sdf); float a = smoothstep(px,-px,sdf);\n    return mix(vec4(1.), vec4(h2rgb( fract(abs(rnd)*22.93 + time)),1.), a);\n}\n\n// main\nvoid mainImage(out vec4 O, in vec2 fragCoord) {\n\n    // anti-aliasing to take a picture\n    vec3 tot = vec3(0.0);\n    #define AA 1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {       \n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o) - iResolution.xy)/iResolution.y;\n        \n        // camera viewport --> worldspace\n        vec3 ro = vec3(0,0,-CAM_DIST+2. - 2. * cos(2.*PI*iTime/360.));\n        vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n             ro = transform(ro,iTime/360.);\n             rd = normalize(transform(rd,iTime/360.));\n        \n        // distance hit ray surface\n        float px = 2.0/( iResolution.y*CAM_FLE );\n        float t = intersect( ro, rd, px );\n\n        // background\n        vec3 sky_col = vec3(0.);\n        vec4 C = vec4(sky_col,1.);\n        O = C;\n        \n        // object surface\n        if (t >= 0.) {\n            // surface properties\n            vec3 p = ro + rd * t;\n            vec3 n = calcNormal( p, 0.001);\n            \n            const float r0 = 0.5;\n            float a_rpt_tc = 0.5+0.5*sin(2.*PI*iTime/60.);\n            \n            // draw texture\n            O = vec4(0);\n            #if 1\n            if(O.a<1.) {\n                float hue = (mat_to_id.x + 2.)/4. + (mat_to_id.y )/8.;\n                C = 0.8 * cells(mat_to.xy/2., hue);\n                C.a = mat_to.z>r0 ? 1.-a_rpt_tc : O.a;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n            #endif           \n            #if 1\n            if(O.a<1.) {             \n                C = ribbon( 12.* mat_to.x, mat_to.z, 6.*iTime/60.); C.rgb *= 0.7;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n            #endif\n            #if 1\n            if(O.a<1.) {\n                C = vec4(vec3(n)*0.5,0.2);\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n            #endif\n            #if 1\n            if(O.a<1.) {            \n                C = truchet3D(mat_tc.xyz, mat_tc.w, iTime/60.); C.rgb *= 0.5;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n            #endif\n            C = O;\n                       \n            // lighting\n            vec3  came_li_o   = transform(vec3(-10.,10.,-10.),iTime/360.); // origine\n            vec3  came_li_dir = normalize(p - came_li_o);             // direction\n            vec3  came_li_col = vec3(1.,1.,.5);                       // color\n            float came_li_shi = 10.;                                  // shininess            \n\n            float cosa = 1.;\n            O.rgb += 0.1 * cosa * C.rgb * sky_col;           // amb\n            cosa = clamp(dot(-came_li_dir, n), 0., 1.);\n            O.rgb += 0.5 * cosa * C.rgb * came_li_col;       // dif       \n            cosa = pow(clamp(dot(reflect(came_li_dir, n), -rd), 0., 1.), came_li_shi);           \n            O.rgb += 0.4 *(cosa>0.? cosa:0.) * came_li_col ; // spec\n            \n            // fog\n            O.rgb = mix(O.rgb, sky_col, 1.0 - exp(-2.5E-3 * pow(t,3.)));    \n        }\n        tot += O.rgb;\n    }\n    tot /= float(AA*AA);\n    \n    // gamma correction\n    O = vec4(rgb2srgb(tot),1.);\n}", "image_inputs": [], "common_code": "// const\nconst float PI = abs(atan(0.,-1.));\n\n// 1D transformations\nfloat signeveodd(float x){\n    return sign(mod(x-0.5,2.)-1.);}\n\nfloat pulsecollision(in float pf, in float x, in float x0, in float pw) {\n    float ntriw_p = abs( fract( pf*(x - x0) )-0.5);\n    return smoothstep( 0.5*pw, 0., ntriw_p );\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);\n}\n\nfloat sig(float x) {\n    return x < 0. ? -1. : +1.;\n}\n\nfloat dist(float x, float e) {\n    // e in [0., +inf]\n    return sign(x)*abs( pow(abs(x), abs(e)) );\n}\n   \nvec2 r_poly_dist(vec2 z, vec2 e, float sh_a) {   \n    /// r-polygon-distribution\n    float r = length(z); z = (r<0.)? vec2(0) : z/r; \n    float d0 = 0.5 *abs(e.y-e.x);\n    float e2 = e.x + d0 + d0 * (2.*smoothstep(-1., 1., -sh_a) - 1.);\n    return dist(r, e2) * z;\n}\n\n// complex\nvec2 cmul(vec2 za,vec2 zb) {\n    return za*mat2(zb.x,-zb.y,zb.yx);\n}\n\nvec2 crot(vec2 z,float a) {\n    return cmul(vec2(cos(a),sin(a)),z);\n}\n\nvec2 cinv(vec2 z) {\n    return z*vec2(1,-1)/dot(z,z);\n}\n    \nvec2 cdiv(vec2 z, vec2 w) {\n    return cmul(z,cinv(w));\n}\n    \nvec2 cpow(vec2 z, int n) {\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));\n}\n  \nvec2 csqr(vec2 z) {\n    return vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y );\n}\n\nvec2 ccos(vec2 z) {\n    vec2 d=vec2(exp(z.y),exp(-z.y));\n\treturn vec2(cos(z.x)*(d.x+d.y)*.5,-sin(z.x)*(d.x-d.y)*.5);\n}\n\n//  \n\nfloat binomial(float a, int n) {\n   float s = 1.0;\n   for (int i = n; i >= 1; i--,a--) {\n     s *= float(a)/float(i);\n   }\n   return s;\n}\n\nvec2 expi(float x) {\n  return vec2(cos(x),sin(x));\n}\n\nfloat gamma(float z) {\n  const float[8] p = float[](\n    676.5203681218851,\n    -1259.1392167224028,\n    771.32342877765313,\n    -176.61502916214059,\n    12.507343278686905,\n    -0.13857109526572012,\n    9.9843695780195716e-6,\n    1.5056327351493116e-7\n  );\n  z -= 1.0;\n  float x = 0.99999999999980993;\n  for (int i = 0; i < 8; i++) {\n    float pval = p[i];\n    x += pval/(z+float(i+1));\n  }\n  float t = z + 8.0 - 0.5;\n  return sqrt(2.0*PI) * pow(t,z+0.5) * exp(-t) * x;\n}\n\n// beta function\nfloat B(float a, float b) {\n  return (gamma(a)*gamma(b))/gamma(a+b);\n}\n\nvec2 inversesc(vec2 z, int K) {\n  float cn[6];\n  for (int n = 1; n <= 5; n++) {\n    cn[n] = binomial(float(n)-1.0+2.0/float(K),n)/float(1+n*K);\n  }\n  float C = B(1.0/float(K),1.0-2.0/float(K))/float(K);\n  z *= C;\n  vec2 h = cpow(z,int(K));\n  float T1 = -cn[1];\n  float T2 = -cn[2]+float(K+1)*pow(cn[1],2.0);\n  float T3 = -cn[3]+float(3*K+2)*(cn[1]*cn[2]-float(K+1)/2.0*pow(cn[1],3.0));\n  float T4 = -cn[4]+float(2*K+1)*(2.0*cn[1]*cn[3]+pow(cn[2],2.0)-float(4*K+3)*\n                                  (pow(cn[1],2.0)*cn[2]-float(K+1)/3.0*pow(cn[1],4.0)));\n  float T5 = -cn[5]+float(5*K+2)*(cn[1]*cn[4]+cn[2]*cn[3]+float(5*K+3)*\n            (-0.5*pow(cn[1],2.0)*cn[3]-0.5*cn[1]*pow(cn[2],2.0)+float(5*K+4)*\n            (pow(cn[1],3.0)*cn[2]/6.0-float(K+1)*pow(cn[1],5.0)/24.0)));\n  vec2 X = vec2(1,0)+h/pow(C,float(K));\n  vec2 w = cmul(z,vec2(1,0) + T1*h + T2*cpow(h,2) + T3*cpow(h,3) + T4*cpow(h,4) + cdiv(T5*cpow(h,5),X));\n  return w;\n}\n\nvec2 recgrid2rec(in vec2 Z, out vec2 Z_id, out float  z_sr){ \n    const float PI_4 = PI/4.;\n    const float SQRT2 = sqrt(2.);\n    const float SQRT_2 = 1./SQRT2;\n    Z = crot(Z,PI_4);\n    Z/= SQRT_2;\n    Z_id = 2.*floor(Z*.5+0.5);\n    vec2 Z_lo = Z-Z_id;\n    Z = Z_lo;\n    z_sr = signeveodd(0.5*(Z_id.x+Z_id.y));   \n    Z_id = vec2(signeveodd(Z_id.x*0.5),signeveodd(Z_id.y*0.5));\n    Z.x *= Z_id.x;\n    Z.y *= Z_id.y;\n    Z *= SQRT_2;\n    return crot(Z,-PI_4);\n}\n\n// stereographic & transformation\nvec3 spf_F33(vec3 p, float sh_a, vec2 e)\n{\n    // F3,3(z)\n    int k = 3, n = 3;\n    float a1 = 2. * sqrt(2.);\n    vec2 z, zk;\n\n    vec3 pn = normalize(p);\n    if (pn.z < 0.) // stereographic (north pol)\n    {\n        z = pn.xy/(1.-pn.z);\n        zk = cpow(z,k);\n        z = 1./(8.*a1) * zk;\n        z = cmul(z, cpow(zk - vec2(a1,   0.), k));\n        z = cdiv(z, cpow(zk + vec2(1./a1,0.), n));\n    }else          // stereographic (south pol)\n    {\n        z = vec2(pn.x, -pn.y)/(1.+pn.z);\n        zk = cpow(z,k);\n        z = 1./(8.*a1)*cinv(zk);       \n        z = cmul(z, cpow(vec2(1.,0.) - zk * a1, k));\n        z = cdiv(z, cpow(vec2(1.,0.) + zk / a1, n));    \n    }\n    // sense of rotation of the polygon: sig(sr) in {-1.,+1.}\n    // number of sides of the polygon: abs(sr) in {n,k}\n    float sr = float(length(z)>1.0?-n:k);    \n    z = r_poly_dist(z, e, sh_a);    \n    return vec3(z,sr);\n}\n\nvec4 spb(vec3 p, vec3 psr)\n{\n    vec2 z = psr.xy; float sr = psr.z; \n    float r = length(p);\n    // inverse stereograpic projection\n    float k = 2./(1.+dot(z,z));\n    if (bool(sig(sr))) {// north pole\n        p = vec3(k*z, k-1.);}\n    else { // south pol\n        z = cinv(z);\n        p = vec3(k*z, -(k-1.));\n        }\n    // back scaling    \n    p *= r;\n    return vec4(p, sr);\n} \n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// sdf\nfloat opIntersection( float d1, float d2 ) {\n    return max(d1,d2); }\n\nfloat opSmoothUnion( in float d1, in float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, float r ) {\n  return length(p.xz)-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// color\nvec3 h2rgb(float h) {\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n}\n\n// srgb <--> rgb (linear)\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XfBGzw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1037, 1037, 1059, 1059, 3098], [3100, 3113, 3167, 3167, 3736], [3738, 3738, 3783, 3783, 3945], [3947, 3947, 3989, 3989, 4236], [4238, 4250, 4277, 4303, 4461], [4475, 4475, 4511, 4535, 4703], [4705, 4705, 4760, 4760, 4986], [4988, 4988, 5044, 5044, 5226], [5228, 5236, 5283, 5323, 8431]], "test": "untested"}
{"id": "XcS3Rw", "name": "C2H5OH", "author": "FordPerfect", "description": "Happy holidays.", "tags": ["molecule", "chemistry", "ethanol"], "likes": 5, "viewed": 162, "published": 3, "date": "1703930009", "time_retrieved": "2024-07-30T17:14:10.623095", "image_code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Space-filling model of ethanol molecule (C2H5OH).\n// See https://en.wikipedia.org/wiki/Space-filling_model\n\nvec3 light=normalize(vec3(1));\n\n// col=(rgb,specular)\n// cur=(rgb,distance)\n// output=(rgb,distance)\nvec4 add_atom(vec3 ro,vec3 rd,vec3 pos,float r,vec4 col,vec4 cur)\n{\n    // Quadratic equation of the form t*t+2*b*t+c=0.\n    float b=dot(ro-pos,rd),c=dot(ro-pos,ro-pos)-r*r;\n    float d=b*b-c;\n    if(d>0.0)\n    {\n        float t=-sqrt(d)-b;\n        if(t<cur.a)\n        {\n            vec3 p=ro+t*rd;\n            vec3 n=normalize(p-pos);\n            vec3 c=col.xyz*(0.75*max(dot(n,light),0.0)+0.25);\n            vec3 g=normalize(light-rd);\n            c+=col.w*pow(max(dot(g,n),0.0),32.0);\n            return vec4(c,t);\n        }\n        else return cur;\n    }\n    else return cur;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 xy=(2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tfloat a=0.25*iTime;\n\tvec3 ro=vec3(7.0*cos(a)+sin(1.3*a),5.0*sin(0.7*a),7.0*sin(a)+cos(1.3*a));\n    vec3 ta=vec3(0.0,0.0,0.0);\n    vec3 ww=normalize(ta-ro);\n    vec3 uu=normalize(cross(ww,vec3(0.0,1.0,0.0)));\n    vec3 vv=normalize(cross(uu,ww));\n\tvec3 rd=normalize(xy.x*uu+xy.y*vv+1.5*ww);\n    light=normalize(vec3(cos(0.7*a)+sin(0.5*a),cos(0.7*a),sin(0.7*a)+cos(0.5*a)));\n\tvec4 cur=vec4(0.1,0.08,0.04,1e7);\n    // Standard-ish coloring, similar to\n    // https://en.wikipedia.org/wiki/CPK_coloring\n    vec4 H=vec4(0.7,0.7,0.7,0.3);\n    vec4 C=vec4(0.1,0.1,0.1,0.3);\n    vec4 O=vec4(0.8,0.1,0.1,0.3);\n    // Atomic radii, in angstrem.\n    // See https://en.wikipedia.org/wiki/Atomic_radii_of_the_elements_(data_page)\n    // float rH=0.25,rC=0.70,rO=0.60; // empirical radii\n    // float rH=0.32,rC=0.75,rO=0.63; // covalent radii\n    float rH=1.10,rC=1.70,rO=1.52; // van der Waals radii\n    // Ethanol molecule geometry.\n    // See https://cccbdb.nist.gov/exp2x.asp?casno=64175&charge=0\n    cur=add_atom(ro,rd,vec3( 1.1879,-0.3829, 0.0000),rC,C,cur);\n    cur=add_atom(ro,rd,vec3( 0.0000, 0.5526, 0.0000),rC,C,cur);\n    cur=add_atom(ro,rd,vec3(-1.1867,-0.2472, 0.0000),rO,O,cur);\n    cur=add_atom(ro,rd,vec3(-1.9237, 0.3850, 0.0000),rH,H,cur);\n    cur=add_atom(ro,rd,vec3( 2.0985, 0.2306, 0.0000),rH,H,cur);\n    cur=add_atom(ro,rd,vec3( 1.1184,-1.0093, 0.8869),rH,H,cur);\n    cur=add_atom(ro,rd,vec3( 1.1184,-1.0093,-0.8869),rH,H,cur);\n    cur=add_atom(ro,rd,vec3(-0.0227, 1.1812, 0.8852),rH,H,cur);\n    cur=add_atom(ro,rd,vec3(-0.0227, 1.1812,-0.8852),rH,H,cur);\n    cur.xyz=mix(12.92*cur.xyz,1.055*pow(cur.xyz,vec3(1.0/2.4))-0.055,step(0.0031308,cur.xyz)); // sRGB\n\tfragColor=vec4(cur.xyz,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XcS3Rw.jpg", "access": "api", "license": "public-domain", "functions": [[211, 280, 347, 400, 861], [863, 863, 917, 917, 2671]], "test": "untested"}
{"id": "4fXGRl", "name": "Ray Tracing 3", "author": "Andreuicncuza", "description": "Ray tracing code", "tags": ["raytracing"], "likes": 0, "viewed": 113, "published": 3, "date": "1703924837", "time_retrieved": "2024-07-30T17:14:11.374087", "image_code": "#define PI 3.1415926535\n#define NUM_OF_SPHERES 4\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct Material {\n    vec3 albedo;\n    float persistence;\n    bool diffuse;\n    float fuzzines;\n};\n\nstruct Sphere {\n    vec3 c;\n    float r;\n    Material mat;\n};\n\nstruct Record { \n    vec3 p;\n    float t;\n    vec3 n;\n    Material mat;\n    bool didHit;\n};\n\nvec2 randState;\n\nfloat hash( const float n ) \n{\n     return fract(sin(n)*43758.54554213);\n}\n\n\nfloat rand2D()\n{\n    randState.x = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);\n    randState.y = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);;\n    \n    return randState.x;\n}\n\n\n// random direction in unit sphere (for lambert brdf)\nvec3 random_in_unit_sphere()\n{\n    float phi = 2.0 * PI * rand2D();\n    float cosTheta = 2.0 * rand2D() - 1.0;\n    float u = rand2D();\n\n    float theta = acos(cosTheta);\n    float r = pow(u, 1.0 / 3.0);\n\n    float x = r * sin(theta) * cos(phi);\n    float y = r * sin(theta) * sin(phi);\n    float z = r * cos(theta);\n\n    return vec3(x, y, z);\n}\n\nvec3 random_in_hemisphere(vec3 normal)\n{\n    vec3 rand = random_in_unit_sphere();\n    if (dot(normal, rand) < 0.0)\n        return -rand;\n    return rand;\n}\n\n\nSphere SPHERES[] = Sphere[NUM_OF_SPHERES](\n    Sphere(\n        vec3(2.5,-7.5,-15.),\n        7.,\n        Material(vec3(0.9,.2,.2), 0.9, false, .9)  \n    ),\n    Sphere(\n        vec3(.0,-6.,5.),\n        4.,\n        Material(vec3(.2,.2,.9), 0.9, false, .1)  \n    ),\n    Sphere(\n        vec3(0,-5.5,-3),\n        5.,\n        Material(vec3(0.2,0.2,.2)*5.0, 0.8, true,1.12)  \n    ),\n    Sphere(\n        vec3(0,-15.25,-3),\n        2.5,\n        Material(vec3(0.2,0.8,.9)*5.0, 0.8, true, 1.)  \n    )\n);\n\nRecord hit(Ray r, Sphere s){\n    Record info;\n    vec3 oc = r.o - s.c;\n    float a = dot(r.d, r.d);\n    float b = dot(oc, r.d);\n    float c = dot(oc, oc) - s.r * s.r;\n\n    float disc = b*b - a * c;\n\n    if (disc > 0.0){\n        float t = (-b - sqrt(disc)) / a;\n        vec3 p = r.o + r.d * t;\n        info.didHit = true;\n        info.t = t;\n        info.n = (p - s.c) / s.r;\n        info.p = p;\n        info.mat = s.mat;\n        return info;\n    }\n\n    info.didHit = false;\n    return info;\n}\n\nRecord hit_world(Ray r){\n    Record info;\n    info.t = 99999999.0;\n\n    for (int i = 0; i < NUM_OF_SPHERES; i++){\n        Sphere s = SPHERES[i];\n        Record tempinfo = hit(r, s);\n        if (tempinfo.didHit && tempinfo.t < info.t && tempinfo.t > 0.0){\n            info = tempinfo;\n        }\n    }\n\n    return info;\n}\n\nRay calculateRay(vec3 lookTo, vec3 CameraOrigin, vec2 ScaledDown){\n    vec3 forwad = normalize(lookTo - CameraOrigin);\n    vec3 right = normalize(cross(forwad, vec3(0, 1,0)));\n    vec3 up = normalize(cross(forwad, right));\n    vec3 direction = forwad + right * (ScaledDown.x+rand2D()*0.003) + up * (ScaledDown.y + rand2D()*0.003);\n    return Ray(CameraOrigin, direction * 3. ); \n}\n\nvec3 background(Ray r){\n    return vec3(.7);\n}\n\nvec3 rayColor(Ray r){\n    vec3 col = vec3(1);\n    Record info;\n    bool didHit = false;\n    for (int i = 0; i <= 20; i++){\n        info = hit_world(r);\n        if (info.didHit){\n            didHit= true;\n            r.o = info.p;\n            if (info.mat.diffuse){\n                r.d = info.n + random_in_unit_sphere() * info.mat.fuzzines;\n                col *= info.mat.persistence * info.mat.albedo;\n            }\n            else{\n                r.d = reflect(r.d,info.n) + random_in_unit_sphere() * info.mat.fuzzines;\n                col *= info.mat.albedo;\n                }\n        }else{\n            col *= background(r);\n            break;\n        }\n    }\n    \n    if ( r.o.y <= 0. && r.d.y > 0.){\n        float t = -r.o.y / r.d.y;\n        vec3 p = r.o + r.d * t;\n        p/= 5.0;\n        int p_int_x = int(round(p.x));\n        int p_int_y = int(round(p.z));\n        if ((p_int_x+p_int_y)%2==0){\n            col *= vec3(.1, .6, 0.1);\n        }\n        col *= vec3(.4, 0.5, 0.4);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    randState = fragCoord.xy / iResolution.xy;\n    vec2 uv = randState - 0.5;\n    vec2 ScaledDown = iResolution.xy / 400.0 * uv;\n\n    Ray r = calculateRay(\n        vec3(0,-5.5,-7.3),\n        vec3(sin(iTime/2.), -.55 * (sin(iTime)+1.2), cos(iTime/2.)) * 25.,\n        ScaledDown\n    );\n\n    vec3 color = vec3(0,0,0);\n   \n    int resolution = 35;\n    for (int x = 0; x < resolution; x++){\n            Ray clone = r;\n            clone.d += random_in_unit_sphere() * 0.008;\n            color += rayColor(clone);\n    }\n    \n    color /= float(resolution);\n    color *= color * 2.5;\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fXGRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[364, 364, 394, 394, 438], [441, 441, 457, 457, 659], [662, 716, 746, 746, 1060], [1062, 1062, 1102, 1102, 1217], [1713, 1713, 1741, 1741, 2205], [2207, 2207, 2231, 2231, 2526], [2528, 2528, 2594, 2594, 2908], [2910, 2910, 2933, 2933, 2956], [2958, 2958, 2979, 2979, 3971], [3973, 3973, 4029, 4029, 4639]], "test": "untested"}
{"id": "Mfj3RW", "name": "2d- aÃ±o nuevo", "author": "jorge2017a2", "description": "2d- aÃ±o nuevo", "tags": ["2d", "polygon", "happynewyear"], "likes": 12, "viewed": 173, "published": 3, "date": "1703902791", "time_retrieved": "2024-07-30T17:14:12.276674", "image_code": "//por jorge2017a2\n//2d- aÃ±o nuevo\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.5*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\n\nfloat sdPoly6_1 POLY(6)\nvec2  pt6_1[6]=vec2[](\nvec2(2.53,0.99),vec2(4.24,0.31),vec2(5.43,1.44),vec2(3.73,2.3),vec2(3.74,2.3),\nvec2(2.53,0.99)  );\n\nfloat sdPoly5_2 POLY(5)\nvec2  pt5_2[5]=vec2[](\nvec2(2.52,0.99),vec2(3.74,2.3),vec2(3.78,3.62),vec2(2.95,2.63),vec2(2.52,0.99)  );\n\n\nfloat sdPoly5_3 POLY(5)\nvec2  pt5_3[5]=vec2[](\nvec2(1.58,2.96),vec2(2.89,2.34),vec2(3.77,3.38),vec2(2.23,4.37),vec2(1.58,2.96)  );\n\n\nfloat sdPoly5_4 POLY(5)\nvec2  pt5_4[5]=vec2[](\nvec2(3.73,2.31),vec2(5.44,1.45),vec2(4.24,4.43),vec2(3.8,4.72),vec2(3.73,2.31)  );\n\n\nfloat sdPoly5_5 POLY(5)\nvec2  pt5_5[5]=vec2[](\nvec2(2.22,4.39),vec2(3.76,3.41),vec2(3.77,4.74),vec2(3.1,5.25),vec2(2.22,4.39)  );\n\n\nfloat sdPoly5_6 POLY(5)\nvec2  pt5_6[5]=vec2[](\nvec2(4.6,3.28),vec2(5.63,2.67),vec2(4.57,1.51),vec2(3.61,2.05),vec2(4.6,3.28)  );\n\nfloat sdPoly5_7 POLY(5)\nvec2  pt5_7[5]=vec2[](\nvec2(4.72,3.2),vec2(5.59,2.69),vec2(4.71,4.1),vec2(4.21,4.43),vec2(4.72,3.2)  );\n\nfloat sdPoly5_8 POLY(5)\nvec2  pt5_8[5]=vec2[](\nvec2(5.37,0.62),vec2(6.8,0),vec2(7.91,1.08),vec2(6.69,1.84),vec2(5.37,0.62)  );\n\n\nfloat sdPoly5_9 POLY(5)\nvec2  pt5_9[5]=vec2[](\nvec2(5.37,0.62),vec2(6.69,1.82),vec2(5.36,3.56),vec2(4.59,2.83),vec2(5.37,0.62)  );\n\n\nfloat sdPoly5_10 POLY(5)\nvec2  pt5_10[5]=vec2[](\nvec2(6.67,1.79),vec2(7.89,1.09),vec2(6.97,2.32),vec2(5.4,3.52),vec2(6.67,1.79)  );\n\n\nfloat sdPoly5_11 POLY(5)\nvec2  pt5_11[5]=vec2[](\nvec2(3.01,5.25),vec2(6.99,2.26),vec2(7.27,2.61),vec2(3.,6.0),vec2(3.01,5.25)  );\n\n///shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tvec3 col;\n    if (i==100 )\n    { col=tex3D(iChannel0, p/256., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel0, p/128., nor)*2.0; }\n\t//if (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n    return vec3(0.0);\n}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DS(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj-0.025,0.0)); return colOut; }\n\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nvec3 letras(vec2 p, vec3 col)\n{\nvec3 colc =vec3(0.0);\nvec2 A,B;\n\nA= vec2(0.48,0.85);\nB= vec2(0.7,1.53);\nfloat d1=sdSegment(p,A,B);\n\n\nA= vec2(0.48,0.81);\nB= vec2(0.98,0.75);\nfloat d2=sdSegment(p,A,B);\n\nA= vec2(0.52,1.09);\nB= vec2(0.76,1.08);\nfloat d3=sdSegment(p,A,B);\n\nA= vec2(1,1.01);\nB= vec2(1.34,1.05);\nfloat d4=sdSegment(p,A,B);\n\nA= vec2(0.99,1.03);\nB= vec2(1.03,1.54);\nfloat d5=sdSegment(p,A,B);\n\nA= vec2(1.04,1.53);\nB= vec2(1.27,1.54);\nfloat d6=sdSegment(p,A,B);\n\nA= vec2(1.02,1.3);\nB= vec2(1.29,1.32);\nfloat d7=sdSegment(p,A,B);\n\nA= vec2(1.51,0.94);\nB= vec2(1.55,1.49);\nfloat d8=sdSegment(p,A,B);\n\nA= vec2(1.54,1.5);\nB= vec2(1.85,1.5);\nfloat d9=sdSegment(p,A,B);\n\nA= vec2(1.8,0.78);\nB= vec2(2.35,0.78);\nfloat d10=sdSegment(p,A,B);\n\nA= vec2(2.03,0.79);\nB= vec2(2.04,1.36);\nfloat d11=sdSegment(p,A,B);\n\nA= vec2(1.87,1.38);\nB= vec2(2.28,1.35);\nfloat d12=sdSegment(p,A,B);\n\nA= vec2(2.68,0.77);\nB= vec2(3.01,0.82);\nfloat d13=sdSegment(p,A,B);\n\nA= vec2(3.01,0.84);\nB= vec2(2.63,1.4);\nfloat d14=sdSegment(p,A,B);\n\nA= vec2(2.62,1.36);\nB= vec2(2.99,1.41);\nfloat d15=sdSegment(p,A,B);\n\nA= vec2(0.36,1.81);\nB= vec2(0.28,2.38);\nfloat d16=sdSegment(p,A,B);\n\nA= vec2(0.34,1.83);\nB= vec2(0.7,2.37);\nfloat d17=sdSegment(p,A,B);\n\nA= vec2(0.21,2.15);\nB= vec2(0.79,2.15);\nfloat d18=sdSegment(p,A,B);\n\nA= vec2(1.04,2.39);\nB= vec2(0.95,1.94);\nfloat d19=sdSegment(p,A,B);\n\nA= vec2(0.93,1.94);\nB= vec2(1.55,2.35);\nfloat d20=sdSegment(p,A,B);\n\n\nA= vec2(1.5,1.84);\nB= vec2(1.55,2.4);\nfloat d21=sdSegment(p,A,B);\n\nA= vec2(1.05,1.84);\nB= vec2(1.3,1.84);\nfloat d22=sdSegment(p,A,B);\n\nA= vec2(1.85,1.89);\nB= vec2(2.26,1.94);\nfloat d23=sdSegment(p,A,B);\n\nA= vec2(2.27,1.9);\nB= vec2(2.11,2.43);\nfloat d24=sdSegment(p,A,B);\n\nA= vec2(2.19,2.37);\nB= vec2(1.81,2.32);\nfloat d25=sdSegment(p,A,B);\n\nA= vec2(1.86,1.87);\nB= vec2(1.84,2.39);\nfloat d26=sdSegment(p,A,B);\n\ncolc=vec3(1.0,0.0,.0);\ncol=DS(colc,col,d1);\ncol=DS(colc,col,d2);\ncol=DS(colc,col,d3);\ncol=DS(colc,col,d4);\ncol=DS(colc,col,d5);\ncol=DS(colc,col,d6);\ncol=DS(colc,col,d7);\ncol=DS(colc,col,d8);\ncol=DS(colc,col,d9);\ncol=DS(colc,col,d10);\ncol=DS(colc,col,d11);\ncol=DS(colc,col,d12);\ncol=DS(colc,col,d13);\ncol=DS(colc,col,d14);\ncol=DS(colc,col,d15);\ncol=DS(colc,col,d16);\ncol=DS(colc,col,d17);\ncol=DS(colc,col,d18);\ncol=DS(colc,col,d19);\ncol=DS(colc,col,d20);\ncol=DS(colc,col,d21);\ncol=DS(colc,col,d22);\ncol=DS(colc,col,d23);\ncol=DS(colc,col,d24);\ncol=DS(colc,col,d25);\ncol=DS(colc,col,d26);\n    return col;\n}\n\nvec3 edificio(vec2 p, vec3 col)\n{ \n    vec3 colc=vec3(0.82,0.82,0.87);\n    ///antes\n    \n    //lateral -3\n    float sd5_9 = sdPoly5_9(p, pt5_9);\n    colc=vec3(0.7);\n    col=DrawFigBorde(colc,col,sd5_9 );\n    \n    float sd5_6 = sdPoly5_6(p, pt5_6);\n    colc=vec3(0.8);\n    col=DrawFigBorde(colc,col,sd5_6 );\n    \n    \n    //despues\n    \n    //techo 2\n    float sd6_1 = sdPoly6_1(p, pt6_1);\n    colc=vec3(0.9);\n    col= DrawFigBorde(colc,col,sd6_1 );\n    \n    //pared lateral -2\n    float sd5_2 = sdPoly5_2(p, pt5_2);\n    col=DrawFigBorde(colc,col,sd5_2 );\n\n    \n    //techo-1\n    float sd5_3 = sdPoly5_3(p, pt5_3);\n    colc=vec3(0.9);\n    col=DrawFigBorde(colc,col,sd5_3 );\n\n    \n    //pared frontal-1\n    float sd5_4 = sdPoly5_4(p, pt5_4);\n    colc=vec3(0.55,0.55,0.55);\n    col=DrawFigBorde(colc,col,sd5_4 );\n\n    \n    //pared frontal-1\n    float sd5_5 = sdPoly5_5(p, pt5_5);\n    colc=vec3(0.55,0.55,0.55);\n    col=DrawFigBorde(colc,col,sd5_5 );\n\n    \n    //pared frontal-2\n    float sd5_7 = sdPoly5_7(p, pt5_7);\n    colc=vec3(0.55,0.55,0.55);\n    col=DrawFigBorde(colc,col,sd5_7 );\n\n    //techo-1\n    float sd5_8 = sdPoly5_8(p, pt5_8);\n    colc=vec3(0.9);\n    col=DrawFigBorde(colc,col,sd5_8 );\n\n    \n    //pared frontal 3\n    float sd5_10 = sdPoly5_10(p, pt5_10);\n    colc=vec3(0.55,0.55,0.55);\n    col=DrawFigBorde(colc,col,sd5_10 );\n\n    //calle\n    /*\n    float sd5_11 = sdPoly5_11(p, pt5_11);\n    colc=vec3(0.77,0.77,0.8);\n    col=DrawFigBorde(colc,col,sd5_11 );\n    */\n\n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec2 uv0=uv*2.0;\n    \n    uv.y=1.0-uv.y;\n    uv-=vec2(-1.8,-0.05);\n    float esc=2.5;\n    uv*=esc;\n    \n    float t0=iTime;\n    float t=mod(t0,1.3);\n    uv.xy*=1.0+sin(t*0.5);\n    \n    uv.y-=1.0;\n    vec3 col=vec3(1.0);\n    \n    vec3 colt=  getColorTextura(vec3(fragCoord.x,fragCoord.y,1.0), vec3(0.0,.0,1.0),100);\n    col=vec3(0.77,0.77,0.8);\n    if(sin(t0*4.0)>0.0)\n    col*=colt;\n    col= edificio(uv-vec2(-2.5,-2.0),col);\n    col= edificio(uv,col);\n    col= edificio(uv-vec2(3.0,2.0),col);\n    \n    vec2 pr= vec2(uv0.x,1.0-uv0.y);\n    if(sin(t0*4.0+4.0)>0.0)\n     pr= Rotate(vec2(uv0.x,1.0-uv0.y), vec2(1.2,1.15), radians(-t0*60.0));\n    \n    \n    col= letras(pr, col);\n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mfj3RW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2092, 2115, 2165, 2165, 2398], [2400, 2400, 2449, 2449, 2731], [2733, 2733, 2795, 2795, 2925], [2927, 2927, 2980, 2980, 3051], [3054, 3070, 3118, 3118, 3196], [3199, 3199, 3251, 3251, 3367], [3370, 3370, 3401, 3401, 5811], [5813, 5813, 5846, 5846, 7309], [7311, 7311, 7368, 7368, 8209]], "test": "untested"}
{"id": "lfBGRD", "name": "Generation CCA", "author": "antonOTI", "description": "I finally found one of the rule set that mesmerized me when I was younger and playing with Golly, the Cellular Automata Software (I was a fun kid)\n\nThis is Star Wars by Mirek Wojtowicz. 345/2/4\nI found it here : https://golly.sourceforge.io/\n", "tags": ["gameoflife", "multipass"], "likes": 11, "viewed": 216, "published": 3, "date": "1703880071", "time_retrieved": "2024-07-30T17:14:13.175271", "image_code": "//source: https://iquilezles.org/articles/palettes/\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n#define COLOR_PALETTE vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30)\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float value = texture(iChannel0, uv).r;\n    value = value / lifeSpan;\n    value = 1. - (value * .66 + .33);\n\tfragColor.rgb = palette(value, COLOR_PALETTE);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define lookup(pos) texture(iChannel0,mod(pos,iResolution.xy)).x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invResolution = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy * invResolution;\n    \n    ;\n    float birthingValue = lifeSpan - 1.;\n    \n    float e = 0.;\n    for (float x = -1.; x <= 1.; ++x)\n    {\n        for (float y = -1.; y <= 1.; ++y)\n        {\n            if (x == 0. && y == 0.)\n            {\n                continue;\n            }\n            \n            float value = lookup(uv + vec2(x, y) * invResolution);\n\n            if (value == birthingValue)\n            {\n                e++;\n            }\n        }\n    }\n    \n    fragColor = texture(iChannel0,uv);\n    float prevState = fragColor.x;\n    if( prevState < 1. )\n        for (int index = 0; index < birthValues.length(); ++index)\n        {\n            if(e == birthValues[index])\n            {\n                fragColor.r = birthingValue;\n                break;\n            }\n        }\n    else\n    {\n        if (prevState == birthingValue)\n        {\n            fragColor.r = prevState - 1.;\n            for (int index = 0; index < surviveValues.length(); ++index)\n            {\n                if(e == surviveValues[index])\n                {\n                    fragColor.r = birthingValue;\n                    break;\n                }\n            }\n        }\n        else\n        {\n            fragColor.r = prevState - 1.;\n        }\n    }\n    \n    if(iMouse.z > .5)\n    {\n    \tfragColor.r = max(fragColor.r, step(length(iMouse.xy - fragCoord), 5.) * birthingValue);\n    }\n    else if (iFrame < 10)\n    {\n        fragColor = vec4(0.);\n        vec2 hr = iResolution.xy / 2.;\n        if (fragCoord.x > hr.x && fragCoord.x < hr.x + 2. && fragCoord.y > hr.y && fragCoord.y < hr.y + 2.)\n        {\n            fragColor.r = birthingValue;\n        }\n    }\n        \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 invResolution = 1. / iResolution.xy;\n    \n    fragColor = vec4(0.);\n    \n    float kernelSize = 3.;\n    for (float x = -kernelSize; x <= kernelSize; ++x)\n    {\n        for (float y = -kernelSize; y <= kernelSize; ++y)\n        {\n            fragColor += texture(iChannel1, uv + vec2(x, y) * invResolution);\n        }\n    }\n    \n    float side = kernelSize * 2. + 1.;\n    fragColor /= (side * side);\n    fragColor *= .9;\n    \n\tfragColor = max(fragColor, texture(iChannel0,uv));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nfloat[] surviveValues = float[](3.,4.,5.);\nfloat[] birthValues = float[](2.);\nfloat lifeSpan = 4.;", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lfBGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 91, 163, 163, 206], [305, 313, 370, 370, 574]], "test": "untested"}
{"id": "MfSGRD", "name": "Sinc/VHS Lowpass Filter AA", "author": "sampajama", "description": "This is a fork that uses dithered sampling and sinc (brick wall) low pass filtering in order to achieve an analogue look devoid of any artifacts common with rasterized rendering. if you pause or zoom in, you will be unable to find any remnants of a pixel.", "tags": ["aliasing", "vhs", "sinc", "lowpassfilter"], "likes": 3, "viewed": 236, "published": 3, "date": "1703874468", "time_retrieved": "2024-07-30T17:14:14.118749", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv) + 0.0;\n }", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "////////////////////////////////////////\n// Classic raytracing\n// Cook-Torrance shading \n//\n// The shaders displays 3 series of balls with different materials:\n// - Ground: Basic (no reflection, no refraction), roughness and density varying foreach ball.\n// - Along blue wall: Reflective materials, roughness and density varying foreach ball.\n// - Along orange wall: Refractive materials,roughness and density varying foreach ball.\n// - Center: the ball at the center is both reflective and refractive.\n//\n// Hard shadow are supported but enabled only for the ground balls.\n//\n\nstruct Material {\n\tvec3  color;\t\t// diffuse color\n\tbool reflection;\t// has reflection \n\tbool refraction;\t// has refraction\n\tfloat n;\t\t\t// refraction index\n\tfloat roughness;\t// Cook-Torrance roughness\n\tfloat fresnel;\t\t// Cook-Torrance fresnel reflectance\n\tfloat density;\t\t// Cook-Torrance color density i.e. fraction of diffuse reflection\n};\n\nstruct Light {\n\tvec3 pos;\n\tvec3 color;\n};\n\n//////////////////////////////////////\n/// Ray-Primitive intersections\n/// fast version test the existence of \n/// an intersection\n\nstruct Inter {\n\tvec3 p;\t\t//pos\n\tvec3 n; \t//normal\n\tvec3 vd;\t// viewdir\n\tfloat d;\t//distance\n\tbool inside; // inside object\n\tMaterial mat; // object material\n};\n\nfloat fastintSphere(vec3 ro, vec3 rd, vec3 p, float r)\n{\n\tfloat dist = -1.;\n\tvec3 v = ro-p;\n\tfloat b = dot(v,rd);\n\tfloat c = dot(v,v) - r*r;\n\tfloat d = b*b-c;\n\tif (d>0.)\n\t{\n\t\tfloat t1 = (-b-sqrt(d));\n\t\tfloat t2 = (-b+sqrt(d));\n\t\tif (t2>0.)\n\t\t\tdist = t1>0.?t1:t2;\n\t}\n\treturn dist;\n}\n\nvoid intSphere(vec3 ro, vec3 rd, vec3 p, float r, Material mat, inout Inter i)\n{\n\tfloat dist = -1.;\n\tvec3 v = ro-p;\n\tfloat b = dot(v,rd);\n\tfloat c = dot(v,v) - r*r;\n\tfloat d = b*b-c;\n\tif (d>0.)\n\t{\n\t\tfloat t1 = (-b-sqrt(d));\n\t\tfloat t2 = (-b+sqrt(d));\n\t\tif (t2>0.)\n\t\t{\n\t\t\tdist = t1>0.?t1:t2;\n\t\t\tif ((dist<i.d)||(i.d<0.))\n\t\t\t{\n\t\t\t\ti.p = ro+dist*rd;\n\t\t\t\ti.n = normalize(i.p-p);\n\t\t\t\ti.d = dist;\n\t\t\t\ti.vd = -rd;\n\t\t\t\ti.inside = t1<0.;\n\t\t\t\tif (i.inside)\n\t\t\t\t\ti.n *= -1.; //invert the normal when hitting inside during refraction\n\t\t\t\ti.mat = mat;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfloat fastintPlane(vec3 ro, vec3 rd, vec3 p, vec3 n)\n{\n\tfloat res = -1.;\n\tfloat dpn = dot(rd,n);\n\tif (abs(dpn)>0.00001)\n\t\tres = (-(dot(n, p) + dot(n,ro)) / dpn);\n\treturn res;\n}\n\nbool intPlane(vec3 ro, vec3 rd, vec3 p, vec3 n, Material mat, inout Inter i)\n{\n\tfloat d = -1.;\n\tfloat dpn = dot(rd,n);\n\tif (abs(dpn)>0.00001)\n\t{\n\t\td = -(dot(n, p) + dot(n,ro)) / dpn;\n\t\tif ((d>0.)&&((d<i.d)||(i.d<0.)))\n\t\t{\n\t\t\ti.p = ro+d*rd;\n\t\t\ti.n = n;\n\t\t\ti.d = d;\n\t\t\ti.vd = -rd;\n\t\t\ti.inside = false;\n\t\t\ti.mat = mat;\n\t\t}\n\t}\n\treturn (i.d==d);\n}\n\n//////////////////////////////////////\n/// Shading functions\nvec3 shadeBlinnPhong( Inter i, vec3 lp )\n{\n\tfloat diffuse = 0.6;\n\tfloat specular = 0.4;\n\t\n\tvec3 res = vec3(0.);\n\tvec3 ld = normalize(lp-i.p);\n\tres = i.mat.color*diffuse*dot(i.n,ld);\n\tvec3 h = normalize(i.vd+ld);\n\tres += specular*pow(dot(i.n,h), 16.);\n\treturn res;\n}\n\nvec3 shadePhong( Inter i, vec3 lp )\n{\n\tfloat diffuse = 0.6;\n\tfloat specular = 0.4;\n\t\n\tvec3 res = vec3(0.);\n\tvec3 ld = normalize(lp-i.p);\n\tres = i.mat.color*diffuse*dot(i.n,ld);\n\tres += specular*pow( clamp(dot(reflect(i.vd,i.n),ld),0.,1.), 16.);\n\treturn res;\n}\n\n/// References:\n/// http://content.gpwiki.org/index.php/D3DBook:%28Lighting%29_Cook-Torrance\n/// http://ruh.li/GraphicsCookTorrance.html\nvec3 shadeCookTorrance( Inter i, Light lig )\n{\n\tfloat roughness = i.mat.roughness;\n\tfloat F0 = i.mat.fresnel;\n\tfloat K = i.mat.density;\n\t//\n\tvec3 ld = normalize(lig.pos-i.p);\n\tvec3 h = normalize(i.vd+ld);\n\tfloat NdotL = clamp( dot( i.n, ld ),0.,1. );\n\tfloat NdotH = clamp( dot( i.n, h ),0.,1. );\n\tfloat NdotV = clamp( dot( i.n, i.vd ),0.,1. );\n\tfloat VdotH = clamp( dot( h, i.vd ),0.,1. );\n\tfloat rsq = roughness * roughness;\n\t\n\t// Geometric Attenuation\n\tfloat NH2   = 2. * NdotH / VdotH;\n\tfloat geo_b = (NH2 * NdotV );\n\tfloat geo_c = (NH2 * NdotL );\n\tfloat geo   = min( 1., min( geo_b, geo_c ) );\n\t\n\t// Roughness\n\t// Beckmann distribution function\n\tfloat r1 = 1. / ( 4. * rsq * pow(NdotH, 4.));\n\tfloat r2 = (NdotH * NdotH - 1.) / (rsq * NdotH * NdotH);\n\tfloat rough = r1 * exp(r2);\n\t\n\t// Fresnel\t\t\t\n\tfloat fres = pow( 1.0 - VdotH, 5. );\n\tfres *= ( 1.0 - F0 );\n\tfres += F0;\n\t\n\tvec3 spec = (NdotV * NdotL==0.) ? vec3(0.) : vec3 ( fres * geo * rough ) / ( NdotV * NdotL );\n\tvec3 res = NdotL * ( (1.-K)*spec + K*i.mat.color ) * lig.color;// * exp(-0.001*length(lig.pos-i.p));\n\treturn res;\n}\n\n////////////////////////////////////\n// Raytracing\n\nfloat hidden( Inter i, vec3 lp)\n{\n\tvec3 ro = i.p;\n\tfloat dmax = length(lp-ro);\n\tvec3 rd = normalize(lp-ro);\n\tro += 0.001*rd;\n\t//\n\tfloat hit = -1.;\n\tvec3 p = vec3(0.,0.,0.);\n\tvec3 n = vec3(0.,1.,0.);\n\thit = fastintPlane( ro, rd, p, n);\n\thit = hit>dmax?-1.:hit;\n\t//\n\tif (hit<0.)\n\t{\n\t\tfloat pi = 1.25;\n\t\tp = vec3(-2.5,0.5,-2.5);\n\t\tfor (int k=0; k<5; ++k)\n\t\t{\n\t\t\tp.z = -2.5;\n\t\t\tfor (int l=0;l<5;++l)\n\t\t\t{\n\t\t\t\thit = fastintSphere( ro, rd, p, 0.5);\n\t\t\t\tif ((hit>0.) && (hit<dmax)) break;\n\t\t\t\tp.z += pi;\n\t\t\t}\n\t\t\tif (hit>0.) break;\n\t\t\tp.x += pi;\n\t\t}\n\t}\n\treturn hit;\n}\n\nvec3 raytraceRay( vec3 ro, vec3 rd, inout Inter i)\n{\n\tMaterial mat;\n\tmat.color = vec3(0.75);\n\tmat.reflection = false;\n\tmat.refraction = false;\n\tmat.n = 1.;\n\tmat.fresnel = 0.8;\n\tmat.roughness = 1.;\n\tmat.density = 1.;\n\tvec3 p = vec3(0.,0.,0.);\n\tvec3 n = vec3(0.,1.,0.);\n\tif (intPlane( ro, rd, p, n, mat, i))\n\t{\n\t\t// checker plane hack\n\t\ti.mat.color = vec3(0.75)*mod(floor(i.p.x)+floor(i.p.z),2.)+0.25;\n\t}\n\t//\n\tp = vec3(-8.,0.,0.);\n\tn = vec3(-1.,0.,0.);\n\tif (intPlane( ro, rd, p, n, mat, i))\n\t{\n\t\t// checker plane hack\n\t\ti.mat.color = vec3(0.95,0.35,0.)*mod(floor(i.p.y)+floor(i.p.z),2.)+0.25;\n\t}\n\t//\n\tp = vec3(0.,0.,8.);\n\tn = vec3(0.,0.,1.);\n\tif (intPlane( ro, rd, p, n, mat, i))\n\t{\n\t\t// checker plane hack\n\t\ti.mat.color = vec3(0.35,0.65,0.95)*mod(floor(i.p.x)+floor(i.p.y),2.)+0.25;\n\t}\n\t//\n\tmat.color = vec3(1.0,1.0,0.25);\n\tmat.reflection = false;\n\tmat.refraction = false;\n\tmat.n = 1.;\n\tmat.fresnel = 0.8;\n\tmat.roughness = 0.1;\n\tmat.density = 0.95;\n\tfloat pi = 1.25;\n\tfloat ri = 0.2;\n\tp = vec3(-2.5,0.5,-2.5);\n\tfor (int k=0; k<5; ++k)\n\t{\n\t\tmat.roughness = 0.1;\n\t\tp.z = -2.5;\n\t\tfor (int l=0; l<5; ++l)\n\t\t{\n\t\t\tintSphere( ro, rd, p, 0.5, mat, i);\n\t\t\tmat.roughness += ri;\n\t\t\tp.z += pi;\n\t\t}\n\t\tmat.density -= ri;\n\t\tp.x += pi;\n\t}\n\t//\n\tmat.color = vec3(1.0,1.0,0.25);\n\tmat.reflection = true;\n\tmat.refraction = false;\n\tmat.n = 1.;\n\tmat.fresnel = 0.8;\n\tmat.roughness = 0.1;\n\tmat.density = 0.95;\n\tpi = 1.25;\n\tri = 0.2;\n\tp = vec3(-2.5,1.,-4.);\n\tfor (int k=0; k<5; ++k)\n\t{\n\t\tmat.roughness = 0.1;\n\t\tp.y = 1.;\n\t\tfor (int l=0; l<5; ++l)\n\t\t{\n\t\t\tintSphere( ro, rd, p, 0.5, mat, i);\n\t\t\tmat.roughness += ri;\n\t\t\tp.y += pi;\n\t\t}\n\t\tmat.density -= ri;\n\t\tp.x += pi;\n\t}\n\t//\n\tmat.color = vec3(1.0,1.0,0.25);\n\tmat.reflection = false;\n\tmat.refraction = true;\n\tmat.n = 1.16;\n\tmat.fresnel = 0.8;\n\tmat.roughness = 0.9;\n\tmat.density = 0.15;\n\tpi = 1.25;\n\tri = 0.2;\n\tp = vec3(4.,1.,2.5);\n\tfor (int k=0; k<5; ++k)\n\t{\n\t\tmat.density = 0.15;\n\t\tp.y = 1.;\n\t\tfor (int l=0; l<5; ++l)\n\t\t{\n\t\t\tintSphere( ro, rd, p, 0.5, mat, i);\n\t\t\tmat.density += ri;\n\t\t\tp.y += pi;\n\t\t}\n\t\tmat.roughness -= ri;\n\t\tp.z -= pi;\n\t}\n\t//\n\tmat.color = vec3(0.0,1.0,1.0);\n\tmat.reflection = true;\n\tmat.refraction = true;\n\tmat.n = 1.33;\n\tmat.fresnel = 0.8;\n\tmat.roughness = .1;\n\tmat.density = 0.5;\n\tp = vec3(0.,4.0,0.);\n\tintSphere( ro, rd, p, 1.5, mat, i);\n\t//\n\tvec3 col = vec3(0.1,0.1,0.1);\n\tif (i.d>0.)\n\t{\n\t\t// ambiant\n\t\tfloat ambiant = 0.1;\n\t\tcol = ambiant*i.mat.color;\n\t\t\n\t\tif (!i.inside)\n\t\t{\n\t\t\t// lighting\n\t\t\tLight lig;\n\t\t\tlig.color = vec3(1.,1.,1.);\n\t\t\tlig.pos = vec3(0., 6., 0.);\n\t\t\tif (hidden(i,lig.pos)<0.)\n\t\t\t\tcol += 0.5*shadeCookTorrance(i, lig);\n\t\t\tlig.pos = vec3(-4., 6., -4.);\n\t\t\tif (hidden(i,lig.pos)<0.)\n\t\t\t\tcol += 0.5*shadeCookTorrance(i, lig);\n\t\t}\n\t}\n\treturn clamp(col,0.,1.);\n}\n\nvec3 raytrace( vec3 ro, vec3 rd)\n{\n\tInter i;\n\ti.p = vec3(0.,0.,0.);\n\ti.n = vec3(0.,0.,0.);\n\ti.d = -1.;\n\ti.vd = vec3(0.,0.,0.);\n\ti.inside = false;\n\t//\n\tvec3 accum = vec3(0.);\n\tvec3 col = vec3(0.);\n\tfloat refl = 1.;\n\tfloat refr = 1.;\n\tcol = raytraceRay(ro, rd, i);\n\taccum += col; // * exp(-0.0005*i.d*i.d);\n\tif (i.mat.reflection)\n\t{\n\t\tInter li = i;\n\t\tvec3 lro = ro;\n\t\tvec3 lrd = rd;\n\t\tlro = li.p;\n\t\tlrd = reflect(-li.vd,li.n);\n\t\tlro += 0.0001*lrd;\n\t\tfor (int k=1; k<4; ++k)\n\t\t{\n\t\t\tli.d = -1.;\n\t\t\trefl *= 1.-i.mat.density;\n\t\t\t//\n\t\t\tcol = raytraceRay(lro, lrd, li);\n\t\t\t//\n\t\t\taccum += col * refl; // * exp(-0.005*i.d*i.d);\n\t\t\tif ((li.d<.0)||(!li.mat.reflection)) break;\n\t\t\tlro = li.p;\n\t\t\tlrd = reflect(-li.vd,li.n);\n\t\t\tlro += 0.0001*lrd;\n\t\t}\n\t}\n\tif (i.mat.refraction)\n\t{\n\t\tInter li = i;\n\t\tvec3 lro = ro;\n\t\tvec3 lrd = rd;\n\t\tfloat n = 1./li.mat.n;\n\t\tfloat cosI = -dot(li.n,li.vd);\n\t\tfloat cost2 = 1.-n*n*(1.-cosI*cosI);\n\t\tif (cost2>0.)\n\t\t{\n\t\t\tlro = li.p;\n\t\t\tlrd = normalize(-li.vd*n+li.n*(n*cosI - sqrt(cost2)));\n\t\t\tlro += 0.0001*lrd;\n\t\t\tfor (int k=1; k<4; ++k)\n\t\t\t{\n\t\t\t\tli.d = -1.;\n\t\t\t\trefr *= 1.-li.mat.density;\n\t\t\t\t//\n\t\t\t\tcol = raytraceRay(lro, lrd, li);\n\t\t\t\t//\n\t\t\t\taccum += col * refr; //* exp(-0.005*i.d*i.d);\n\t\t\t\tif ((li.d<.0)||(!li.mat.refraction)) break;\n\t\t\t\tif (li.inside)\n\t\t\t\t\tn = li.mat.n;\n\t\t\t\telse\n\t\t\t\t\tn = 1./li.mat.n;\n\t\t\t\tcosI = -dot(li.n,li.vd);\n\t\t\t\tcost2 = 1.-n*n*(1.-cosI*cosI);\n\t\t\t\tif (cost2<=0.) break;\n\t\t\t\tlro = li.p;\n\t\t\t\tlrd = normalize(-li.vd*n+li.n*(n*cosI - sqrt(cost2)));\n\t\t\t\tlro += 0.0001*lrd;\n\t\t\t}\n\t\t}\n\t}\n\treturn clamp(accum,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    /// START NEW CODE ///\n    vec2 uv = fragCoord.xy / iChannelResolution[0].xy;\n    vec2 noise_offset = vec2(fract(iTime), fract(iTime * PHI));\n    vec2 dither = fract(\n        texture(iChannel0, uv).rg + \n        texture(iChannel0, noise_offset).gb + \n        texture(iChannel0, uv + noise_offset).br) - 0.5;\n    \n\tvec2 q = (fragCoord.xy + DITHER_NOISE * dither) / iResolution.xy;\n    /// END NEW CODE ///\n\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\t \n\tfloat Time = 0.04*(15.0 + iTime);\n\t// camera\t\n\tvec3 ro = vec3( 8.0*cos(Time), 6.0, 8.0*sin(Time) );\n//\tvec3 ro = vec3( -8.0, 6.0, 8.0 );\n\tvec3 ta = vec3( 0.0, 2.5, 0. );\n\n\tvec2 m = iMouse.xy / iResolution.xy;\n\tif( iMouse.z>0.0 )\n\t{\n\t\tfloat hd = -m.x * 14.0 + 3.14159;\n\t\tfloat elv = m.y * 3.14159 * 0.4 - 3.14159 * 0.25;\n\t\tro = vec3(sin(hd) * cos(elv), sin(elv), cos(hd) * cos(elv));\n\t\tro = ro * 8.0 + vec3(0.0, 6.0, 0.0);\n\t}\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n    vec3 col = raytrace( ro, rd );\n\t\n\tfragColor=vec4( col, 1.0 );\n}", "buffer_a_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "///                                  ///\n/// EXPONENTIAL SMOOTHING TEMPORALLY ///\n///                                  ///\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dt = iTimeDelta;\n    float rc = TARGET_RC;\n    \n    float a = dt / rc;\n    float t = exp(-a * a);\n \n    vec2 uv = fragCoord.xy / iResolution.xy;\n \n    fragColor = (texture(iChannel1, uv) * (0.0 + t)) + \n                (texture(iChannel0, uv) * (1.0 - t)); \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "///                             ///\n/// SINC CONVOLUTION IN +X AXIS ///\n///    & TEMPORAL SMOOTHING     ///\n///                             ///\n\nvec4 getCoord(vec2 coord)\n{\n    return vec4(texture(iChannel0, coord / iResolution.xy).rgb, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 samp_sum = getCoord(fragCoord);\n    \n    for(float d = 1.0; d < RANGE - 0.5; d += 1.0)\n    {\n        float w = lp_window(d / RANGE);\n        float k = lp_sinc(SQRT1 * d / KERNEL);\n        \n        vec4 s1p = getCoord(fragCoord + vec2(d,0.0)) * k;\n        vec4 s1n = getCoord(fragCoord - vec2(d,0.0)) * k;\n        \n        samp_sum += w * (s1p + s1n);\n    }\n    \n    float dt = iTimeDelta;\n    float rc = TARGET_RC;\n    \n    float a = dt / rc;\n    float t = exp(-a * a);\n \n    vec2 uv = fragCoord.xy / iResolution.xy;\n \n    fragColor = \n        (texture(iChannel1,  uv) * (0.0 + t)) + \n        ((samp_sum / samp_sum.a) * (1.0 - t)); \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "///                             ///\n/// SINC CONVOLUTION IN +Y AXIS ///\n///    & TEMPORAL SMOOTHING     ///\n///                             ///\n\nvec4 getCoord(vec2 coord)\n{\n    return vec4(texture(iChannel0, coord / iResolution.xy).rgb, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 samp_sum = getCoord(fragCoord);\n    \n    for(float d = 1.0; d < RANGE - 0.5; d += 1.0)\n    {\n        float w = lp_window(d / RANGE);\n        float k = lp_sinc(SQRT1 * d / KERNEL);\n        \n        vec4 s1p = getCoord(fragCoord + vec2(0.0,d)) * k;\n        vec4 s1n = getCoord(fragCoord - vec2(0.0,d)) * k;\n        \n        samp_sum += w * (s1p + s1n);\n    }\n    \n    float dt = iTimeDelta;\n    float rc = TARGET_RC;\n    \n    float a = dt / rc;\n    float t = exp(-a * a);\n \n    vec2 uv = fragCoord.xy / iResolution.xy;\n \n    fragColor = \n        (texture(iChannel1,  uv) * (0.0 + t)) + \n        ((samp_sum / samp_sum.a) * (1.0 - t)); \n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/***** CONFIG *****/\n\n////* SPATIAL  *////\n#define DITHER_NOISE (1.0)\n#define KERNEL (4.0)\n#define RANGE floor(KERNEL * 9.0)\n\n////* TEMPORAL *////\n#define TARGET_FPS (24.0)\n#define TARGET_RC  (0.36787944117 / TARGET_FPS)\n\n/***** HELPER FUNCTIONS *****/\n\n#define EPS (5.79334e-21)\n#define PI (3.14159265358979323)\n#define PHI (1.61803398875)\n#define SQRT1 (1.00000000000)\n#define SQRT2 (1.41421356237)\n#define SQRT3 (1.73205080757)\n\n#define lp_sinc(x) (sin(PI * (x) + EPS) / (PI * (x) + EPS))\n\n// NO WINDOW\n// #define lp_window(x) (1.0)\n\n// LANCZOS WINDOW\n#define lp_window(x) (lp_sinc(x))\n\n// RAISED COSINE WINDOW\n// #define lp_window(x) ((cos(PI * (x)) + 1.0) * 0.5)  \n", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MfSGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 151]], "test": "untested"}
{"id": "XcB3zD", "name": "Perlin whirlpool", "author": "ikucha", "description": "looped perlin noise using polar coordinates", "tags": ["noise", "perlin", "radial", "polar"], "likes": 5, "viewed": 197, "published": 3, "date": "1703865551", "time_retrieved": "2024-07-30T17:14:14.872733", "image_code": "const float PI = 3.14159265358979323846;\n\n// copy from https://www.shadertoy.com/view/4sc3z2   \n#define MOD3 vec3(.1031,.11369,.13787)\nconst float PERIOD = 8.;\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\n//this hash loops with period PERIOD in the x coordinate\nvec3 hash33_periodic(vec3 p3)\n{\n    p3.x = mod(p3.x, PERIOD);\n    \n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat perlin_noise_periodic(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33_periodic(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33_periodic(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33_periodic(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33_periodic(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33_periodic(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33_periodic(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33_periodic(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33_periodic(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\nfloat fractal_perlin_noise_periodic(vec3 p){\n    return perlin_noise_periodic(p)+0.5*perlin_noise_periodic(2.*(p+vec3(0.25)))+0.25*perlin_noise_periodic(4.*(p+vec3(0.50)))+0.125*perlin_noise_periodic(8.*(p+vec3(0.75)));\n}\nfloat fractal_perlin_noise(vec3 p){\n    return perlin_noise(p)+0.5*perlin_noise(2.*(p+vec3(0.25)))+0.25*perlin_noise(4.*(p+vec3(0.50)))+0.125*perlin_noise(8.*(p+vec3(0.75)));\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//(seed, frequency) combinations that look good^ (9,3), (2,1), (8,1), (18, 2), (5,4), (16,4), (8,0.5), (11,0.5), (23, 0.5), (40,0.5), (46, 0.5)\nconst float frequency = 0.5;\nconst float seed = 40.;\nvec3 palette(float g){\n    vec3 w = 2.*PI*vec3(perlin_noise(vec3(g*frequency)+seed*vec3(100.,0.,0.)), perlin_noise(vec3(g*frequency)+seed*vec3(200.,0,0)), perlin_noise(vec3(g*frequency)+seed*vec3(300.)));\n    w += 0.5*2.*PI*vec3(perlin_noise(vec3(g*frequency*2.)+seed*vec3(100.,0.,0.)), perlin_noise(vec3(g*frequency*2.)+seed*vec3(600.,0,0)), perlin_noise(vec3(g*frequency*2.)+seed*vec3(300.)));\n    w += 0.25*2.*PI*vec3(perlin_noise(vec3(g*frequency*4.)+seed*vec3(100.,0.,0.)), perlin_noise(vec3(g*frequency*4.)+seed*vec3(600.,0,0)), perlin_noise(vec3(g*frequency*4.)+seed*vec3(300.))); \n    w += 0.125*2.*PI*vec3(perlin_noise(vec3(g*frequency*8.)+seed*vec3(100.,0.,0.)), perlin_noise(vec3(g*frequency*8.)+seed*vec3(600.,0,0)), perlin_noise(vec3(g*frequency*8.)+seed*vec3(300.)));\n    return vec3(0.5)+0.5*cos(w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st = st*2.-1.;\n    st.x *= iResolution.x/iResolution.y;\n    float angle = 0.5*atan(st.y, st.x)/PI+0.5;\n    float radius = length(st);\n    //radius+=0.01*u_time;\n    angle+=pow(radius, 1.2);\n    st.x = angle;\n    st.y = pow(radius, 0.7);\n    \n    st*=vec2(PERIOD,8.);\n    st+=3.*vec2(fractal_perlin_noise_periodic(vec3(st, 0.3*iTime)), fractal_perlin_noise_periodic(vec3(st+vec2(100.), 0.3*iTime)));\n    st.y+=1.*iTime;\n    float gray = 0.5*fractal_perlin_noise_periodic(vec3(st, 0.))+0.5;\n    vec3 color = palette(gray);\n    //color = pal( gray, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20));\n\t//color = vec3(angle);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XcB3zD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 182, 182, 334], [335, 335, 363, 363, 1302], [1304, 1361, 1392, 1392, 1579], [1580, 1580, 1617, 1617, 2628], [2630, 2630, 2674, 2674, 2851], [2852, 2852, 2887, 2887, 3028], [3030, 3030, 3098, 3098, 3141], [3340, 3340, 3362, 3362, 4156], [4158, 4158, 4215, 4215, 4943]], "test": "untested"}
{"id": "4fsGWX", "name": "Happy New Year | 3D Marquee", "author": "byt3_m3chanic", "description": "Hope everyone has a fun and Happy New Year \n\nããã¾ãã¦ããã§ã¨ã | Feliz aÃ±o nuevo | ìí´ ë³µ ë§ì´ ë°ì¼ì¸ì | Bonne annÃ©e | ×©× × ×××× |  Frohes Neues Jahr | à¤¨à¤ à¤¸à¤¾à¤² à¤à¥ à¤¶à¥à¤­à¤à¤¾à¤®à¤¨à¤¾à¤à¤", "tags": ["raymarching", "text", "letters", "happynewyear"], "likes": 18, "viewed": 249, "published": 3, "date": "1703861886", "time_retrieved": "2024-07-30T17:14:15.636690", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    12/29/23 @byt3_m3chanic \n    Happy New Year eveyrone!\n*/\n\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MIN_DIST 1e-4\n#define MAX_DIST 35.\n\nconst float sz = .435;\nconst float dz = sz*2.75;\nconst float df = dz/2.;\nconst float hf = sz/2.;\n\nvec3 hit,hp;\nvec2 fd,sd;\n\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\n\n//@iq sdf extrude \nfloat opx( in vec3 p, float d, in float h ) {\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0);\n    p.y -= 2.;\n    vec3 q = p;\n    q*=.25;\n    \n    float amt = 15.;\n    float xd = floor((q.z+df)/dz);\n    float mx = floor(mod(xd,amt));\n    \n    float id = floor((q.x+hf)/sz)+xd;\n    float md = floor(mod(id,amt));\n          sd = vec2(id,xd);\n          \n    float hs = hash21(sd);\n    q.xz= mod(q.xz+vec2(hf,df),vec2(sz,dz))-vec2(hf,df);\n\n    float ff = .6+.3*sin((xd*2.)+id*.475+T);\n    float tk = .14+.125*cos(id+md*.25+T*1.15);\n    \n    q.y -= ff;\n\n    if(hs>.489) q.zy*=rot(ff*PI2);\n    \n    float d= getdp(q.xy);\n    \n\n    if(md==0.) d= getH(q.xy);\n    if(md==1.) d= getA(q.xy);\n    if(md==2.) d= getP(q.xy);\n    if(md==3.) d= getP(q.xy);\n    if(md==4.) d= getY(q.xy);\n    \n    if(md==6.) d= getN(q.xy);\n    if(md==7.) d= getE(q.xy);\n    if(md==8.) d= getW(q.xy);\n\n    if(md==10.) d= getY(q.xy);\n    if(md==11.) d= getE(q.xy);\n    if(md==12.) d= getA(q.xy);\n    if(md==13.) d= getR(q.xy);\n\n    d=opx(q,d,tk);\n    \n    if(d<res.x) {\n        res=vec2(d/.75,1);\n        hit=p;\n    }\n    \n    float mf = .6+.3*sin((p.x*.7)+p.z*.475+T);\n    float f = p.y+2.+mf;\n    if(f<res.x) {\n        res=vec2(f,2);\n        hit=p;\n    }\n    return res;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec4 FC = vec4(.06,.27,.44,0);\n\nvec3 hue(float t){ \n    return vec3(.35) + vec3(.25)*cos( PI*(vec3(.95,.92,.88)*t+vec3(.93,.36,.07))); \n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec3 p = ro;\n    \n    for(int i=0;i<132;i++) {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<32? ray.x*.75: ray.x;\n        m  = ray.y;\n    } \n    hp = hit;\n    fd = sd;\n\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(22,60,25);\n        vec3 l = normalize(lpos);\n\n        float diff = clamp(dot(n,l),0.,1.);\n     \n        float shdw = 1.;\n        for(float t=.01; t < 9.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 64.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>9. ) break;\n        }\n        diff = mix(diff,diff*shdw,.5);\n\n        vec3 h = vec3(0);\n\n        if(m==1.) {\n            h=hue(3.+(fd.x*.1)+fd.y*.2);\n            ref=h*.5;\n        }\n        if(m==2.) {\n            h = hue((hp.x*.07)+hp.z*.025);\n            ref = vec3(.05);\n            vec2 f = fract(hp.xz*.3)-.5;\n            if(f.x*f.y>0.) { \n                h = vec3(.55);\n                ref=h;\n            }\n        }\n\n        C = h*diff;\n\n        ro = p+n*MIN_DIST;\n        rd = reflect(rd,n);\n    }\n    return vec4(C,1);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    const float zoom = 12.;\n\n    vec3 ro = vec3(uv*zoom,-(zoom+8.));\n    vec3 rd = vec3(0,0,1.);\n   \n    mat2 rx = rot(-.78), ry = rot(.48);\n    ro.yz *= rx,ro.xz *= ry;\n    rd.yz *= rx,rd.xz *= ry;\n\n    ro.xz+=T*.4;\n    vec3 C = vec3(0), ref=vec3(0), fil=vec3(1);\n    \n    float d = 0., a = 0.;\n    float numBounces = 2.;\n    \n    for(float i=0.; i<numBounces; i++) {\n        d =0.;\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.) a = d;\n    }\n\n    float tg = hash21(uv);\n    if(tg>.5) C = mix(C,C+.07,tg);\n\n    C = mix(FC.rgb,C,exp(-.0001*a*a*a));\n    O = vec4(pow(C, vec3(.4545)),1);\n}\n\n", "image_inputs": [], "common_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    12/29/23 @byt3_m3chanic \n*/\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\nfloat rbox( in vec2 p, in vec2 b, in vec4 r ) {\n    r.xy = (p.x>0.)?r.xy : r.zw;\n    r.x  = (p.y>0.)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.)+length(max(q,0.))-r.x;\n}\n// special\nfloat getdp(vec2 p) {\n    float bt = length(p)-.075;\n    return bt;\n}\nconst vec4 bz = vec4(.075,.055,.035,.0);\nconst vec4 bo = vec4(.175,.15,.075,.025);\nconst vec2 oa = vec2(.15,.1);\n\n//letters\nfloat getA(vec2 p) {\n    vec2 of = vec2(0,.075);\n    float bt = max(\n    rbox(p,vec2(.15,.175),bz.xwxw),\n    -rbox(p+vec2(.0,.05),vec2(.1,.175),bz.zwzw)\n    );\n    float bb = box(p,vec2(.15,.025));\n    return min(bt,bb);\n}\n\nfloat getE(vec2 p) {\n    vec2 of = vec2(0,.075);\n    float bt = max(\n        rbox(p-of,oa,bz.wwxx),\n        -rbox(p-of-vec2(.05,0),vec2(.15,.05),bz.wwzz)\n    );\n    float bb = max(\n        rbox(p+of,oa,bz.wwxx),\n        -rbox(p+of-vec2(.05,0),vec2(.15,.05),bz.wwzz)\n    );\n    return min(bt,bb);\n}\n\nfloat getH(vec2 p) {\n    float bt = min(\n        box(vec2(abs(p.x)-.125,p.y),vec2(.025,.175)),\n        box(p,vec2(.15,.025))\n    );\n    return bt;\n}\nfloat getI(vec2 p) {\n    float bt = min(\n        box(p,vec2(.025,.175)),\n        box(vec2(p.x,abs(p.y)-.15),vec2(.15,.025))\n    );\n    return bt;\n}\nfloat getN(vec2 p) {\n    float bt = max(\n        rbox(p,vec2(.15,.175),bz.xwxw),\n        -rbox(p+vec2(.0,.045),vec2(.1,.175),bz.zwzw)\n    );\n    return bt;\n}\nfloat getP(vec2 p) {\n    float bt = max(\n        rbox(p-vec2(.0,.075),oa,bz.xxww),\n        -rbox(p-vec2(.0,.075),vec2(.1,.05),bz.zzww)\n    );\n    float bb = box(p+vec2(.125,0),vec2(.025,.175));\n    return min(bt,bb);\n}\nfloat getR(vec2 p) {\n    float bt = max(\n        rbox(p-vec2(.0,.075),oa,bz.xxww),\n        -rbox(p-vec2(.0,.075),vec2(.1,.05),bz.zzww)\n    );\n    float bb = max(\n        rbox(p+vec2(.0,.075),oa,bz.xwww),\n        -rbox(p+vec2(.0,.12),vec2(.1,.095),bz.zwww)\n    );\n    return min(bt,bb);\n}\nfloat getW(vec2 p) {\n    vec2 of = vec2(.065,0);\n    float bt = max(\n        rbox(p+of,vec2(.085,.175),bz.wxwx),\n        -rbox(p+of-vec2(.0,.05),vec2(.0375,.175),bz.wzwz)\n    );\n    float bb = max(\n    rbox(p-of,vec2(.085,.175),vec4(0,.075,0,.075)),\n    -rbox(p-of-vec2(.0,.05),vec2(.0375,.175),bz.wzwz)\n    );\n    return min(bt,bb);\n}\n\nfloat getY(vec2 p) {\n    vec2 of = vec2(0,.075);\n    float bt = max(\n        rbox(p-of,oa,bz.wxwx),\n        -rbox(p-of-vec2(0,.05),vec2(.1),bz.wzwz)\n    );\n    return min(bt,box(p+of,vec2(.025,.1)));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fsGWX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[434, 434, 458, 458, 516], [518, 537, 582, 582, 677], [679, 679, 697, 697, 1869], [1871, 1871, 1901, 1901, 2140], [2174, 2174, 2192, 2192, 2279], [2281, 2281, 2366, 2366, 3601], [3603, 3603, 3644, 3644, 4359]], "test": "untested"}
{"id": "DsjfzV", "name": "Raytracing 3D Bezier w/ Normals ", "author": "morimea", "description": "This shader is just mix of three shaders:\n1. [url]https://www.shadertoy.com/view/cdsGD4[/url] - SDF normals\n2. [url]https://www.shadertoy.com/view/dsX3RM[/url] - improved Raytracing Quadratic Bezier 3D \n", "tags": ["3d", "raytracing", "bezier", "normals", "intersection", "curve", "normal", "quadratic", "analytic", "intersect"], "likes": 12, "viewed": 300, "published": 3, "date": "1703847835", "time_retrieved": "2024-07-30T17:14:16.390674", "image_code": "\n// Created by Danil (2023+) https://github.com/danilw\n// The MIT License\n\n// self https://www.shadertoy.com/view/DsjfzV\n\n// This shader is just mix of two shaders:\n// https://www.shadertoy.com/view/cdsGD4 - SDF normals\n// https://www.shadertoy.com/view/dsX3RM - improved Raytracing Quadratic Bezier 3D \n\n\n// WARNING - BROKEN NORMALS\n// 1. normal of surface and halph-sphere on sides is broken because self-intersect broken\n// 2. normal of surface is broken at extreme angle/curve - or when camera close to surface\n// This makes this Raytraced 3d Bezier not very good for something like pathtracing.\n// \n// notice that with bloxard_improved_normal - normals do move little\n// but bloxard_improved_normal is cheaper by performance\n// and uncomment col = vec3(dif)... at end of code to see visual color of SDF_normal and bloxard_improved_normal\n\n//--------------------\n// Normals:\n\n// Two ways to get normal - by 1 call to SDF with position on surface - second call of solving\n// Or from improved more recent version of a Raytracing 3D Bezier - by bloxard\n// https://www.shadertoy.com/view/dsX3RM\n\n#define SDF_normal\n//#define bloxard_improved_normal\n\n//--------------------\n\n\n\n#define MAX_DIST 1000.\n#define MIN_DIST .001\n\n#define PI 3.141592653589793\n#define TAU (2.*PI)\n#define HALFPI 1.57079632679\n\n// from https://www.shadertoy.com/view/3sjXDm\n\nconst float fThickness = 335e-3;\n\nmat3 inverseView(vec2 a)\n{\n    vec2 c = cos(a);\n    vec2 s = sin(a);\n    return mat3(c.y,0.,-s.y,s.x*s.y,c.x,s.x*c.y,c.x*s.y,-s.x,c.x*c.y);\n}\n\nvec2 solveCubic2(float a, float b, float c)\n{\n\tfloat p = b-a*a/3., p3 = p*p*p;\n\tfloat q = a*(2.*a*a-9.*b)/27.+ c;\n\tfloat d = q*q+4.*p3/27.;\n\tfloat offset = -a / 3.;\n\tif(d>0.)\n\t{ \n\t\tfloat z = sqrt(d);\n\t\tvec2 x = (vec2(z,-z)-q)*0.5;\n        \n// from https://www.shadertoy.com/view/dsX3RM spalmer comment\n// this bug not visible on this shader \n// visual bug - https://danilw.github.io/GLSL-howto/vulkan_sh_launcher/images_bugs/DsjfzV.png\n// if needed define below\n// #define fixCubic\n// spalmer comment:\n        // credit: iq from comment at http://shadertoy.com/view/dsfGWN \n        // led me back to http://shadertoy.com/view/MlKcDD\n#ifdef fixCubic\n        if (abs(p) < .0504)\n        {\n            float kx = a/3., ky = b/3., kz = c;\n            float P = ky - kx*kx;\n            float P3 = P*P*P;\n            float Q = kx*(2.*kx*kx - 3.*ky) + kz;\n            float k = P3/Q;              // linear approx\n            //float k = (1.-P3/(Q*Q))*P3/Q;  // quadratic approx \n            x = vec2(k,-k-Q);\n        } \n#endif\n\t\tvec2 uv = sign(x)*pow(abs(x), vec2(1./3.));\n\t\treturn vec2(offset + uv.x + uv.y);\n\t}\n\tfloat v = acos(-sqrt(-27./p3)*q/2.)/3.;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\treturn vec2(m + m, -n - m) * sqrt(-p / 3.0) + offset;\n}\n\n#ifdef SDF_normal\n\n// sdBezier from https://www.shadertoy.com/view/cdsGD4\n//--------------------\n\n// for normal\n// if I understand correctly - you do need second run of *Bezier to get normal\n// because you need surface pos as input\n// Warning - generate little broken normal on some angles\nvec4 sdBezier( in vec3 pos, in vec3 A, in vec3 B, in vec3 C) {\n    const float i3 = 1.0 / 3.0;\n    const float sqrt3 = sqrt(3.0);\n    vec3 a = B - A;\n    vec3 b = A - 2.0 * B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n    \n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) * i3;\n    float kz = kk * dot(d, a);\n    \n    float p  = ky - kx * kx;\n    float q  = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float p3 = p * p * p;\n    float h  = q * q + 4.0 * p3;\n    bool tsth = h >= 0.0;\n    h = sqrt(h);\n    float k = p3 / q;\n    bool tstp = abs(p) < 0.01;\n    vec2 x = float(!tstp) * (vec2(h, -h) - q) * 0.5 + float(tstp) * vec2(k, -k - q);\n    vec2 uv = sign(x) * pow(abs(x), vec2(i3));\n    float t1 = clamp(uv.x + uv.y - kx, 0.0, 1.0);\n    vec3  qv3 = d + (c + b * t1) * t1;\n    float z = sqrt(-p);\n    float v = acos(q / (p * z * 2.0)) * i3;\n    float m = cos(v);\n    float n = sin(v) * sqrt3;\n    vec2 t2 = clamp(vec2(m + m, -n - m) * z - kx, 0.0, 1.0);\n    vec3  qx = d + (c + b * t2.x) * t2.x;\n    float dx = dot(qx, qx);\n    vec3  qy = d + (c + b * t2.y) * t2.y;\n    float dy = dot(qy, qy);\n    bool tstdxy = dx < dy;\n    vec4 res;\n    if(tstdxy){\n        float td = float(tsth)*dot(qv3, qv3) + float(!tsth) * dx;\n        vec3 norm = float(tsth)*qv3+ float(!tsth)*qx;\n        res = vec4(td,norm);\n    }else{\n        float td = float(tsth)*dot(qv3, qv3) + float(!tsth) * dy;\n        vec3 norm = float(tsth)*qv3+ float(!tsth)*qy;\n        res = vec4(td,norm);\n    }\n    \n    res.x = sqrt(res.x);\n    res.yzw /= -res.x;\n    \n    return res;\n}\n//--------------------\n#endif\n\n\n// from https://www.shadertoy.com/view/dsX3RM\n//--------------------\n\nvec2 closestPointOnQuadraticBezierCurve(vec3 p0, vec3 p1, vec3 p2) \n{\n\tvec2 A2 = p1.xy - p0.xy;\n\tvec2 B2 = p2.xy - p1.xy - A2;\n\t// Equation solution here: https://perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\n\tvec3 r = vec3(-3.*dot(A2,B2), dot(-p0.xy,B2)-2.*dot(A2,A2), dot(-p0.xy,A2)) / -dot(B2,B2);\n\tvec2 t = clamp(solveCubic2(r.x, r.y, r.z), 0., 1.);\n\tvec3 A3 = p1 - p0;\n\tvec3 B3 = p2 - p1 - A3;\n\tvec3 D3 = A3 * 2.;\n\tvec3 pos1 = (D3+B3*t.x)*t.x+p0;\n\tvec3 pos2 = (D3+B3*t.y)*t.y+p0;\n\tpos1.xy /= fThickness;\n\tpos2.xy /= fThickness;\n\tfloat pos1Len = length(pos1.xy);\n\tif (pos1Len>1.)\n\t{\n\t\tpos1 = vec3(1e8);\n\t}\n\tfloat pos2Len = length(pos2.xy);\n\tif (pos2Len>1.)\n\t{\n\t\tpos2 = vec3(1e8);\n\t}\n\tpos1.z -= cos(pos1Len*HALFPI)*fThickness;\n\tpos2.z -= cos(pos2Len*HALFPI)*fThickness;\n\treturn (length(pos1) < length(pos2)) ? vec2(t.x, pos1Len) : vec2(t.y, pos2Len);\n}\n\nvec2 findRaySphereRoots(in vec3 ro, in vec3 rd, in vec3 sc, in float r, out float disc)\n{\n\tvec3 dRoSc = ro - sc;\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.*dot(rd, dRoSc);\n\tfloat c = dot(dRoSc, dRoSc) - r * r;\n\tdisc = max(b * b - 4. * a * c, 0.);\n\tfloat sqrtD = sqrt(disc);\n\tfloat twoA = 2.*a;\n\treturn (vec2(-b) + vec2(sqrtD, -sqrtD)) / twoA;\n}\n//--------------------\n\nbool QuadraticBezierIntersect(vec3 ro, vec3 rd, out float td, out vec3 norm) {\n    \n    norm = vec3(0.,1.,0.);\n    td = MAX_DIST+1.;\n    mat3 m = inverseView(vec2(asin(-rd.y),atan(rd.x, rd.z)));\n    \n    float timer = iTime*0.00051+11.*0.5;\n    vec3 f = vec3(1.2133, 1.4763, 1.0);\n    vec3 offs = vec3(0.1, 2.5, 3.7);\n    vec3 amp = vec3(3.0, 3.1, 2.9);\n    vec3 p0 = vec3(-4.5, 0.0, 0.0);\n    vec3 p1 = sin(iTime * f + offs) * amp;\n    vec3 p2 = vec3(4.5, 0.0, 0.0);\n\n    vec2 t = closestPointOnQuadraticBezierCurve((p0 - ro)*m, (p1 - ro)*m, (p2 - ro)*m);\n    vec3 A = p1 - p0;\n    vec3 vPointOnInnerBezierCurve = (A * 2. + (p2 - p1 - A) * t.x) * t.x + p0;\n    float disc;\n    vec2 sR = findRaySphereRoots(ro, rd, vPointOnInnerBezierCurve, fThickness, disc);\n    if (disc > 0.)\n    {\n        vec3 vSphereSurfacePos = ro + rd * min(sR.x, sR.y);\n        vec3 vNormal = normalize(vSphereSurfacePos - vPointOnInnerBezierCurve);\n        td = min(sR.x, sR.y);\n#ifdef bloxard_improved_normal\n        norm = vNormal;\n#endif\n#ifdef SDF_normal\n        norm = sdBezier(ro+rd*td,p0,p1,p2).yzw;\n#endif\n    }\n    bool res = td>MIN_DIST&&td<MAX_DIST;\n\n    return res;\n}\n\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s,\n                s,  c);\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3\n        f = normalize(l - p),\n        r = normalize(cross(vec3(0.0, 1.0, 0.0), f)),\n        u = cross(f, r),\n        c = f * z,\n        i = c + uv.x * r + uv.y * u;\n    return normalize(i);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 m = iMouse.xy / iResolution.xy;\n    \n    vec3 ro = vec3(0.0, 3.0, -7.0);\n    ro.yz *= rot(-m.y * PI * 0.9 + 1.0);\n    ro.xz *= rot(-m.x * TAU);\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 rd = getRayDir(uv, ro, vec3(0.0, 0.0, 0.0), 1.0);\n    \n    float td; //depth\n    vec3 norm; //normal\n    QuadraticBezierIntersect(ro, rd, td, norm);\n\n    if(td < MAX_DIST) {\n    \n        col = vec3(norm); // debug\n        //col = vec3(td*0.1); // debug\n    \n        float dif = dot(norm, normalize(vec3(1.0, 2.0, 3.0))) * 0.5 + 0.5;\n        //col = vec3(dif) * vec3(0.4, 0.0, 0.8); //color\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjfzV.jpg", "access": "api", "license": "mit", "functions": [[1382, 1382, 1408, 1408, 1523], [1525, 1525, 1570, 1570, 2772], [4776, 4776, 4845, 4845, 5641], [5643, 5643, 5732, 5732, 5982], [6007, 6007, 6085, 6085, 7162], [7164, 7164, 7183, 7183, 7266], [7268, 7268, 7318, 7318, 7519], [7521, 7521, 7576, 7576, 8277]], "test": "untested"}
{"id": "4cjGR1", "name": "Don't fullscreen or hypnosis?", "author": "cake5diamond", "description": "This one is pretty cool, but if you fullscreen it you are definitely going to get hypnotized or maybe it will be like one of those things where you look at the center for 30 seconds and then look away and it messes up your vision. An optical illusion.", "tags": ["opticalillusion", "cool", "hypnosis"], "likes": 2, "viewed": 133, "published": 3, "date": "1703823265", "time_retrieved": "2024-07-30T17:14:17.472781", "image_code": "void cameraMotion(in vec2 fragCoord, inout vec3 sceneColor);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 sceneColor;\n    \n    cameraMotion(fragCoord, sceneColor);\n    \n    vec2 center = iResolution.xy / 2.0;\n    float dotSize = 50.0;\n    float distanceToCenter = length(fragCoord - center);\n    float dot = smoothstep(0.0, dotSize, dotSize - distanceToCenter);\n    sceneColor = mix(sceneColor, vec3(0.0), dot); // Mix with black for the dot\n    \n    fragColor = vec4(sceneColor, 1.0);\n}\n\nvoid cameraMotion(in vec2 fragCoord, inout vec3 sceneColor)\n{\n    float squareSize = 0.5;\n    vec2 center = iResolution.xy / 2.0;\n    float angle = iTime;\n    vec2 rotatedCoord = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * (fragCoord - center);\n    sceneColor = 0.5 + 0.5 * cos(rotatedCoord.xyx + vec3(0, 2, 4));\n    float distanceToCenter = length(rotatedCoord);\n    float smoothEdge = smoothstep(squareSize, squareSize + 0.01, distanceToCenter);\n    sceneColor *= smoothEdge;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4cjGR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 117, 117, 508], [510, 510, 571, 571, 1001]], "test": "untested"}
{"id": "4f23zh", "name": "Almost creepy?", "author": "cake5diamond", "description": "I have no idea what I made. It's pretty cool though.", "tags": ["psychadelic"], "likes": 1, "viewed": 96, "published": 3, "date": "1703822764", "time_retrieved": "2024-07-30T17:14:18.532946", "image_code": "float hash(vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 baseColor = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));\n    \n    vec2 noiseCoord = uv * 10.0;\n    float noiseValue = 0.5 + 0.5 * sin(iTime + 10.0 * noise(noiseCoord));\n    \n    vec3 finalColor = baseColor * noiseValue;\n    \n    finalColor = mix(finalColor, vec3(1.0, 0.2, 0.7), 0.5 * sin(iTime));\n    finalColor = mix(finalColor, vec3(0.2, 0.8, 0.5), 0.5 * cos(iTime));\n    \n    fragColor = vec4(finalColor, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4f23zh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 89], [91, 91, 112, 112, 422], [424, 424, 479, 479, 956]], "test": "untested"}
{"id": "lfl3Dj", "name": "Christmas for Ff", "author": "saul", "description": "A simple Christmas Tree made from 2D points. ", "tags": ["2d", "christmas", "sdf", "points"], "likes": 2, "viewed": 142, "published": 3, "date": "1703819638", "time_retrieved": "2024-07-30T17:14:19.371704", "image_code": "/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* A simple christmas tree made from 2D points.\n*\n*/\n\n#define PI 3.1415926535\n#define TAU 6.2831853071\n#define ROTATE(v, x) mat2(cos(x), sin(x), -sin(x), cos(x)) * v\n#define REMAP_HALF_NDC(x, c, d) (((x + 0.5) * (d - c)) + c) // Remap from [-0.5, 0.5] domain to [c, d]\n\n#define N 512.0\n#define N_ONE_QUARTER N * 0.25\n// This is mostly to cull any points at the bottom that are too close to the \"camera\".\n#define N_OFFSET 1.0\n#define STAR_N 7.0\n\nconst vec3 LIGHT_COLORS[3] = vec3[3](\n                                        vec3(1.0,  0.05,  0.05), \n                                        vec3(0.05, 1.0,   0.05), \n                                        vec3(1.0,  0.25,  0.05)\n                                    );\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 Hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\n\n// Signed distance to an n-star polygon with external angle en by iq: https://www.shadertoy.com/view/3tSGDy\nfloat SignedDistanceNStar2D(in vec2 p, in float r, in float an, in float bn, in vec2 acs, in float m) // m=[2,n]\n{\n    float en = PI / m;\n    vec2  ecs = vec2(cos(en), sin(en));\n    p = length(p) * vec2(cos(bn), abs(sin(bn)));\n\n    p -= r * acs;\n    p += ecs * clamp(-dot(p, ecs), 0.0, r * acs.y / ecs.y);\n    return length(p) * sign(p.x);\n}\n\nvoid DrawStar(in vec2 uv, in float time, inout vec3 outColor)\n{\n    uv -= vec2(0.001, 0.225);\n    uv = ROTATE(uv, time * 0.75);\n    // Some common pre-calculation in order to avoid duplication\n    float an = PI / STAR_N;\n    float bn = mod(atan(uv.x, uv.y), 2.0 * an) - an;\n    vec2 acs = vec2(cos(an), sin(an));\n    // Top star\n    outColor += 5e-4 / pow(abs(SignedDistanceNStar2D(uv, 0.01, an, bn, acs, STAR_N * 0.5)), 1.23) * LIGHT_COLORS[2];\n    // Star beams\n    outColor += smoothstep(2.0 / max(iResolution.x, iResolution.y), 0.0, SignedDistanceNStar2D(uv, 1.5, an, bn, acs, STAR_N)) * \n        LIGHT_COLORS[2] * smoothstep(0.75, -5.0, length(uv));\n}\n\nvoid DrawTree(in vec2 uv, in float time, inout vec3 outColor)\n{\n    float u, theta, pointHeight, invN = 1.0 / N;\n    vec2 st, hash, layer;\n    vec3 pointOnCone, pointColor = vec3(1.0);\n    const vec2 radius = vec2(1.5, 3.2);\n    uvec3 colorThreshold;\n    for (float i = N_OFFSET; i < N; ++i)\n    {\n        // Modify this to change the tree pattern\n        hash = Hash21(2.0 * TAU * i);\n        \n        // Some basic light color based on hash\n        colorThreshold.x = uint(hash.x < 0.45); // red;\n        colorThreshold.y = 1u - colorThreshold.x; // green\n        colorThreshold.z = uint(hash.x > 0.9); // white;\n        pointColor = vec3(colorThreshold | colorThreshold.z);\n        \n        // Calculate point on cone based on: https://mathworld.wolfram.com/Cone.html\n        u = i * invN;\n        theta = 1609.0 * hash.x + time * 0.5;\n        pointHeight = 1.0 - u;\n        \n        // Split the cone into layers to make it look more like a christmas tree\n        layer = vec2(3.2 * mod(i, N_ONE_QUARTER) * invN, 0.0);\n        pointOnCone = 0.5 * (radius.xyx - layer.xyx) * vec3(pointHeight * cos(theta), u - 0.5, pointHeight * sin(theta)); // [-0.5, 0.5]\n        \n        // Scale uv based on depth of the point\n        st = uv * (REMAP_HALF_NDC(pointOnCone.z, 0.5, 1.0) + hash.y) * 4.5;\n        \n        // outColor += smoothstep(0.01, 0.0, length(st - pointOnCone.xy));\n        outColor += REMAP_HALF_NDC(pointOnCone.z, 3.0, 0.6) * // Slightly adjust the size of the point based on distance to \"camera\" \n            2e-5 / pow(length(st - pointOnCone.xy), 1.7) * pointColor;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y; // [-0.5, 0.5] adjusted for aspect ratio\n    vec3 outColor = vec3(0.005, 0.01, 0.03); // Background color\n    vec4 m = iMouse / iResolution.yyyy;\n    float t = 0.0;\n    \n    if (m.z > 0.0)\n    {\n        t = m.x * TAU;\n    }\n    else\n    {\n        t = iTime * 0.5;\n    }\n    \n    DrawTree(uv, t, outColor);\n    DrawStar(uv, t, outColor);\n    \n    float vignette = dot(uv, uv);\n    vignette *= vignette;\n    vignette = 1.0 / (vignette * vignette + 1.0);\n    \n    fragColor = vec4(pow(outColor * vignette, vec3(0.4545)), 1.0) - Hash12(fragCoord.xy * t + iResolution.yy) * 0.04;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lfl3Dj.jpg", "access": "api", "license": "cc0-1.0", "functions": [[768, 809, 831, 831, 948], [950, 950, 972, 972, 1105], [1107, 1215, 1329, 1329, 1556], [1558, 1558, 1621, 1621, 2214], [2216, 2216, 2279, 2279, 3805], [3807, 3807, 3864, 3864, 4507]], "test": "untested"}
{"id": "4cjGzh", "name": "Cloudy Night", "author": "fishy", "description": "This (should) show the actual phase of the moon (I hope)", "tags": ["clouds", "fbm", "cycle", "glow", "moon", "phases"], "likes": 2, "viewed": 139, "published": 3, "date": "1703818887", "time_retrieved": "2024-07-30T17:14:20.266312", "image_code": "// Just a quick little thingy\n// Took a little bit to figure out the phases though\n\n#define PI 3.1415926536\n#define TAU (2.0 * PI)\n\nvec3 rot(vec3 v, vec3 k, float t)\n{\n    k = normalize(k);\n    return mix(k*dot(k,v), v, cos(t)) + cross(k, v)*sin(t);\n}\n\nvec2 moon(vec2 uv, vec3 l, float amb)\n{\n    float l2 = dot(uv, uv);\n    vec3 sphere = vec3(uv, sqrt(1.0 -  clamp(l2, 0.0, 1.0)));\n    \n    vec4 surf = vec4(0);\n    float a = 1.0;\n    float b = 1.0;\n    for(float i = 0.0; i < 3.0; i++)\n    {\n        surf += texture(iChannel0, sphere * a * 0.05) * b;\n        a *= 2.71828;\n        b /= 2.71828;\n    }\n    \n    return vec2((max(dot(normalize(sphere + (surf.xyz - 0.5) * 0.1), l), 0.0) + amb)*surf.w*surf.w*0.5, smoothstep(1.0, 1.0-64.0/iResolution.y, l2));\n}\n\nvec4 fbm(vec2 uv, vec2 o)\n{\n    vec4 r = vec4(0);\n    float str = 1.0;\n    float scale = 1.0;\n    for(float i = 0.0; i < 3.0; i++)\n    {\n        r += texture(iChannel1, uv * scale * 0.004) * str;\n        uv *= mat2(0.80,  0.60, -0.60,  0.80);\n        uv += o;\n        scale *= 2.0;\n        str *= 0.5;\n    }\n    \n    return r * 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y * 8.0;\n    \n    float moonRot = (iDate.x * 365.0 + iDate.y * 30.5 + iDate.z + iDate.w / 86400.0) - 738757.0;\n    moonRot = mod(moonRot, 29.53059) / 29.53059 * TAU;\n    vec3 lgt = rot(vec3(0, 0, 1), normalize(vec3(0.3, 1, 0)), -moonRot);\n    \n    vec2 moon = moon(uv, lgt, 0.002);\n    vec4 clouds = fbm(uv*0.05 + vec2(0.025, 0.005) * iTime, vec2(0.5, 0.0) * iTime * 0.01);\n    \n    vec3 col = vec3(step(texture(iChannel2, uv*0.2).r * texture(iChannel2, uv*0.1).r, 0.1) * 0.0002 + 0.001);\n    col = mix(col, moon.rrr, moon.g);\n    \n    float glow = 1.0 / pow((dot(uv, uv) * 0.2 + 1.0), 3.0) * (lgt.z*0.5 + 0.5);\n    col += pow(smoothstep(0.5, 0.0, abs(clouds.r - 0.5)), 3.0) * glow * 0.02;\n    \n    col = mix(col, vec3(0.0001), smoothstep(0.2, 0.6, clouds.r) * 0.8);\n\n    fragColor = vec4(pow(col, vec3(0.4545)), 1);\n    fragColor.rgb += texelFetch(iChannel1, ivec2(fragCoord) % textureSize(iChannel1, 0).xy, 0).rgb/256.0;\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4cjGzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 132, 167, 167, 251], [253, 253, 292, 292, 759], [761, 761, 788, 788, 1095], [1097, 1097, 1152, 1152, 2134]], "test": "untested"}
{"id": "McBGRh", "name": "Fork conway representation", "author": "antonOTI", "description": "I randomly glimpsed at this type of presentation for game of life and I wanted to code it myself (and also it has been a while since I did a shader).", "tags": ["gameoflife", "multipass"], "likes": 4, "viewed": 160, "published": 3, "date": "1703796688", "time_retrieved": "2024-07-30T17:14:21.217769", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = mix(vec4(.1),vec4(.9),smoothstep(.5, .525, texture(iChannel0,uv)));\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define lookup(pos) texture(iChannel0,pos).x\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invResolution = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy * invResolution;\n    \n    float prevState = texture(iChannel0,uv).x;\n    \n    float e = 0.;\n    for (float x = -1.; x <= 1.; ++x)\n    {\n        for (float y = -1.; y <= 1.; ++y)\n        {\n            if (x == 0. && y == 0.)\n            {\n                continue;\n            }\n            \n            e+= lookup(uv + vec2(x, y) * invResolution);\n        }\n    }\n    \n    if( e == 2. && prevState == 1. || e == 3. )\n    \tfragColor= vec4(1.);\n    else\n    \tfragColor= vec4(0.);\n    \n    if(iMouse.z > .5)\n    \tfragColor= max(fragColor,vec4(step(length(iMouse.xy - fragCoord), 5.)));\n    else if (iFrame < 10)\n        fragColor = step(.5, texture(iChannel1, uv)).rrrr;\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 invResolution = 1. / iResolution.xy;\n    \n    fragColor = vec4(0.);\n    \n    float kernelSize = 2.;\n    for (float x = -kernelSize; x <= kernelSize; ++x)\n    {\n        for (float y = -kernelSize; y <= kernelSize; ++y)\n        {\n            fragColor += texture(iChannel1, uv + vec2(x, y) * invResolution);\n        }\n    }\n    \n    float side = kernelSize * 2. + 1.;\n    fragColor /= (side * side);\n    fragColor *= .99;\n    \n\tfragColor = max(fragColor, texture(iChannel0,uv));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/McBGRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 182]], "test": "untested"}
{"id": "Mf23Rz", "name": "Fake Tilt-shift / DOF", "author": "SnoopethDuckDuck", "description": "This is very messily coded. The rough idea is to oscillate the terrain (things far from centre oscillate more), then average the output over many frames. Click the screen to change position", "tags": ["raymarch", "depthoffield", "tiltshift", "micro", "photography"], "likes": 22, "viewed": 419, "published": 3, "date": "1703773507", "time_retrieved": "2024-07-30T17:14:22.213107", "image_code": "// !!! CLICK THE SCREEN !!!\n\nvoid mainImage( out vec4 o, vec2 u )\n{\n    o = texture(iChannel0, u/iResolution.xy);\n    o.rgb /= o.a;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define pi 3.14159\n#define Dir(a) vec2(cos(a), sin(a))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvec3 ori() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 ro = vec3(6, 3, 3);\n    //ro.yz *= rot(-m.y*3.14+1.);\n    ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nvec2 map(vec3 p) {\n    float mat = 0.;   \n    p /= 1.+.005*dot(p,p);\n    //p.y += 1.- 1./cosh(.15*length(p.xz));\n    p.xz *= .4; //mix(.38, .42, tanh(iTime));\n    p.x += 4.*iMouse.y / iResolution.y - 2.;\n    float d = p.y + .15 - texture(iChannel0, .1* p.xz).r;\n   \n    d -= .3 * texture(iChannel0, .3 * p.xz).r;\n    d -= .13*exp(-6.*texture(iChannel0, .5 * p.xz).r);\n    d += .06 * texture(iChannel0, p.xz).r;\n    \n    float falloff = 1.-1./cosh(.15*abs(dot(p,p) - .5*cos(61.*iTime)));\n    //falloff = smoothstep(1., 2.2, length(p.xz));\n    //falloff += .5*texture(iChannel0, .1 * p.xz).r - .2;\n    float rand = texture(iChannel1, p.xz - Dir(p.x+10.*iTime)*iTime).r;\n    \n    // comment this for worse output but less lag\n    //rand = texture(iChannel1, p.xz + Dir(rand) * iTime).r;\n    \n    d -= falloff * rand;\n    \n    return vec2(d, mat);\n}\n\nvec3 march(vec3 ro, vec3 rd, float z) {\t\n    float d = 0.;\n    float s = sign(z);\n    int steps = 0;\n    float mat = 0.;\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = ro + rd * d;\n        vec2 m = map(p);\n        if (s != sign(m.x)) { z *= 0.5; s = sign(m.x); }\n        if (abs(m.x) < SURF_DIST || d > MAX_DIST) {\n            steps = i + 1;\n            mat = m.y;\n            break;\n        }\n        d += m.x * z; \n    }   \n    return vec3(min(d, MAX_DIST), steps, mat);\n}\n\nvec3 norm(vec3 p) {\n\tfloat d = map(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 dir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat AO(in vec3 p, in vec3 n) {\n\tfloat occ = 0.;\n    float sc = 1.;\n    for (float i = 0.; i < 5.; i++) {\n        float h = 0.015 + 0.015 * i;\n        float d = map(p+h*n).x;\n        occ += (h-d)*sc;\n        sc *= 0.95;\n    }\n    return clamp(1. - 3.*occ, 0., 1.);\n}\n\nfloat shadow(in vec3 ro, in vec3 rd) {\n    float res = 1.;\n    float t = SURF_DIST;\n    for (int i=0; i<24; i++)\n    {\n\t\tfloat h = map(ro + rd * t).x;\n        float s = clamp(32. * h / t, 0., 1.);\n        res = min(res, s);\n        t += clamp(h, 0.01, 0.2);\n        if(res<SURF_DIST || t>MAX_DIST ) break;\n    }\n    res = clamp(res, 0.0, 1.0);\n    return smoothstep(0., 1., res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t//uv += .03*(1.-1./cosh(2.*length(uv))) * Dir(10.*iTime+texture(iChannel1, uv+iTime).x);\n    vec3 ro = ori();\n    \n    vec3 rd = dir(uv, ro, vec3(0,.5,0), 2.3);\n    vec3 col = vec3(0);\n   \n    vec3 m = march(ro, rd, 1.);  \n    float d = m.x;    \n    vec3 p = ro + rd * d;\n    \n    if (d<MAX_DIST) {        \n        vec3 n = norm(p);\n        vec3 r = reflect(rd, n);        \n\n        vec3 ld = normalize(vec3(1,2,3));\n        float dif  = dot(normalize(n+r),  ld)*.5+.5;\n        float spec = pow(dif, 12.);\n        float fres = pow(1. + dot(rd, n),  5.);\n     \n        //col = vec3(1);\n        col = vec3(dif);//fres * vec3(spec*45.);  \n        col *= 1.+r;\n        col *= fres;\n        //col = min(col, 1.-spec);\n    }\n    \n    col = max(col, vec3(1.4, .7, 1.2*cos(.5*p.x))*(1.-exp(-.005*m.y)) \n        * (1.+cos(8.*p.y)));\n        \n    col = pow(col, vec3(1./2.3));   \n    col = tanh(2.5*col);\n    fragColor = vec4(col, 1);\n    \n    vec4 A = texture(iChannel2, fragCoord / iResolution.xy);\n    if (iMouse.z <= 0.) fragColor += A;\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mf23Rz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 67, 67, 133]], "test": "untested"}
{"id": "cldfWf", "name": "Colored Void", "author": "Saimon", "description": "Animated reproduction of Lino Russo work: https://www.behance.net/gallery/49992709/Blurld", "tags": ["color", "circle", "void", "reproduction"], "likes": 4, "viewed": 198, "published": 3, "date": "1703759271", "time_retrieved": "2024-07-30T17:14:23.108712", "image_code": "/* \"Colored Void\"\n * I wanted to practice GLSL and the primitives describe in https://thebookofshaders.com/07/\n * so I started looking for art images to try to reproduce.\n * This one is the part of the serie, it is based on Lino Ruso work: \n * https://www.behance.net/gallery/49992709/Blurld\n * (November 2023)(started with 1596 char - Updated 11/01/24)\n */\n \n#define R       iResolution.xy\n// Clamp the color to make sure it's between [0;1]\n#define clampColor(C) clamp(C,0.,1.)\n//https://www.shadertoy.com/view/XlsyWX\n#define rot(a)  mat2(cos(a+vec4(0,33,11,0)))\n\nfloat sdCircle(vec2 p, float r, float blur){\n  return smoothstep(0.,blur/6.92,length(p) - r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 st = ( fragCoord.xy*2. -R.xy ) /R.y ;\n  st /= 2.; // Increase the size by 2.\n\n  vec3 BLUE = vec3(0.,0.,1.),\n       RED = vec3(1.,0.,0.),\n       CYAN = vec3(0.,1.,1.),\n       MAGENTA = vec3(1.,0.,1.),\n       YELLOW = vec3(1.,1.,0.);\n \n  vec2 st1 = rot(0.5+iTime/2.3)*st,\n       st2 = rot(0.5-iTime/2.3)*st;\n\n  float c1 = sdCircle(st1-vec2(0.02), 0.32, 0.346),\n        c2 = sdCircle(st2+vec2(0.04, -0.0125), 0.32, 0.346),\n        c3 = sdCircle(st2-vec2(0.05), 0.2, 1.4),\n        c4 = sdCircle(st1+vec2(0.02,0.02), 0.34, 0.386),\n        c5 = sdCircle(st2+vec2(0.08,-0.04), 0.25, 1.4);\n  fragColor.rgb = clampColor(c1+BLUE) \n                  * clampColor(c2+RED) \n                  * clampColor(c3+CYAN) \n                  * clampColor(c4+MAGENTA) \n                  * clampColor(c5+YELLOW);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cldfWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[565, 565, 609, 609, 660], [662, 662, 718, 718, 1516]], "test": "untested"}
{"id": "4c2GRz", "name": "fake line light ", "author": "kristemmerman", "description": "based on: https://www.shadertoy.com/view/XsjyRy", "tags": ["linelight"], "likes": 1, "viewed": 172, "published": 3, "date": "1703756127", "time_retrieved": "2024-07-30T17:14:23.979384", "image_code": "//based on\n//https://www.shadertoy.com/view/XsjyRy\n\n\nconst float bidpScale = 0.2;\n\n\n\nvec3 acestonemap( vec3 color){\n    mat3 m1 = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n    );\n    mat3 m2 = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n    );\n    vec3 v = m1 * color;\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return clamp(m2 * (a / b), 0.0, 1.0);\n}\n\nvec3 getLight( vec2 pos, vec2 line0, vec2 line1,vec3 lightColor,float lightStrength )\n{\n\tvec2 dir = normalize( line1 - line0 );\n\tvec2 rt = vec2(-dir.y,dir.x);\n\tfloat tp0 = dot( rt, line0 );\n\tfloat tpx = dot( rt, pos );\n\tfloat bidp = mix( 1.0, dot( normalize( line0 - pos ), normalize( line1 - pos ) ), bidpScale );\n\tfloat distf = clamp( (tp0 - tpx)  , 0.0, 1.0 );\n\treturn pow((1.0-bidp)*distf*5.0,4.0)*lightStrength*lightColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 bg = vec3(0.4,0.4,0.9);\n\tvec3 color = getLight( fragCoord, vec2(480,300), vec2(480,20) ,vec3(1.0,0.1,0.1),1.0)* bg;\n\tcolor +=  getLight( fragCoord, vec2(30,200), vec2(300,200) ,vec3(0.1,1.0,0.1),1.0)* bg;\n    color +=  getLight( fragCoord, vec2(400,400),vec2(40,40)  ,vec3(0.0,0.0,1.0),1.0)* bg;\n     color+= bg*0.3; //global light\n\tfragColor = vec4(acestonemap(color),1);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4c2GRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 115, 115, 534], [536, 536, 623, 623, 965], [967, 967, 1024, 1024, 1413]], "test": "untested"}
{"id": "lfB3zR", "name": "Copy of 71372.0", "author": "corabelster", "description": "Translation of the original shader: https://glslsandbox.com/e#71372.0", "tags": ["glslsandbox"], "likes": 4, "viewed": 221, "published": 3, "date": "1703735005", "time_retrieved": "2024-07-30T17:14:24.745337", "image_code": "   vec3 field(vec3 p) {\n        p *= .1;\n        float f = .1;\n        for (int i = 0; i < 5; i++) {\n            p = p.yzx*mat3(.8,.6,0,-.6,.8,0,0,0,1);\n            p += vec3(.123,.456,.789)*float(i);\n            p = abs(fract(p)-.5);\n            p *= 2.0;\n            f *= 2.0;\n        }\n        p *= p;\n        return sqrt(p+p.yzx)/f-.002;\n    }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 iResolution = iResolution.xy;  // ShaderToy built-in resolution\n    vec2 iMouse = iMouse.xy / iResolution.xy;  // Normalized mouse coordinates\n\n    #define R_FACTOR 5.\n    #define G_FACTOR 0.\n    #define B_FACTOR 0.\n\n    const int MAXITER = 42;\n\n \n    vec3 dir = normalize(vec3((fragCoord.xy-iResolution*.5)/iResolution.x,1.));\n    vec3 pos = vec3(iMouse-.5,iTime);\n    vec3 color = vec3(0);\n    for (int i = 0; i < MAXITER; i++) {\n        vec3 f2 = field(pos);\n        float f = min(min(f2.x,f2.y),f2.z);\n        \n        pos += dir*f;\n        color += float(MAXITER-i)/(f2+.001);\n    }\n    vec3 color3 = vec3(1.-1./(1.+color*(.09/float(MAXITER*MAXITER))));\n    color3 *= color3;\n    fragColor = vec4(color3.r*R_FACTOR, color3.g*G_FACTOR, color3.b*B_FACTOR,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lfB3zR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 23, 23, 347], [349, 349, 404, 404, 1178]], "test": "untested"}
{"id": "XcBGzz", "name": "[steve] sin wave raymarching", "author": "import_shader_steve", "description": "Slightly changed version of the basic raymarching shader by TheArtOfCode, but in this one, when ray marching, the light doesn't follow straight paths. Instead, they follow a 3d-sin-wave-like pattern, as illustrated by the RayMarch() function.", "tags": ["3d", "sdf", "editor"], "likes": 0, "viewed": 156, "published": 3, "date": "1703717532", "time_retrieved": "2024-07-30T17:14:25.616008", "image_code": "#define MAX_STEP 100\n#define SURF_DIST 0.01\n#define MAX_DIST 100.\n#define PI 3.14159\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdGround(vec3 p) {\n    return p.y;\n}\n\nfloat GetDist(vec3 p) {\n    vec3 pBox = vec3(0., 1., 6.);\n    float dBox = sdBox(p - pBox, vec3(1.));\n    vec3 pGround = vec3(0., 0., 3.);\n    float dGround = sdGround(p - pGround);\n    \n    float dScene = min(dBox, dGround);\n    return dScene;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    float d = GetDist(p);\n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n    return normalize(n);\n}\n\n// make a light above the sphere\nvec3 lightPos = vec3(2, 5, 1);\n\nfloat GetLight(vec3 p) {\n    //lightPos.xz = vec2(sin(iTime*2.), cos(iTime*2.)) * 5.;\n    vec3 lv = normalize(lightPos - p);\n    vec3 nv = GetNormal(p);\n    float rawLight = dot(lv, nv);\n    float finalLight = clamp(rawLight, 0., 1.);\n    return finalLight;\n}\n\nvec3 twistFunction(float t, float fq, float amt) {\n    // return vec3(t, sin(fq * t), sin(fq * t)) * amt;\n    return vec3(t, sin(fq * t), 0.) * amt;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float twistFrequency) {\n    float d0 = 0.;\n    for (int i = 0; i < MAX_STEP; i++) {\n        // here we need to twist the ray based on d0\n        // make the direction not rd, but a 3d-sin-wave-like function extending along rd direction\n        // we need to take this function (t, sint, sint) (direction (1, 0, 0)), and rotate it towards rd\n        // replace t with d0, and then normalize it. Use this resulting vec3 to replace rd\n        vec3 newRd = twistFunction(d0, twistFrequency, 1.);\n        vec4 quat = quatFromUnitVectors(vec3(1., 0., 0.), normalize(rd));\n        newRd = applyQuat(newRd, quat);\n        vec3 p = ro + newRd;\n        // vec3 p = ro + rd * d0;\n        float ds = GetDist(p);\n        d0 += ds;\n        if (ds < SURF_DIST || d0 > MAX_DIST) break;\n    }\n    return d0;\n}\n\nfloat GetShadow(vec3 p, float twistFrequency) {\n    vec3 rd = normalize(lightPos - p);\n    vec3 pOffset = p + GetNormal(p) * SURF_DIST * 2.;\n    float ds = RayMarch(pOffset, rd, twistFrequency);\n    float dl = length(p - lightPos);\n    if (ds < dl) {\n        return 0.1;\n    } else {\n        return 1.;\n    }\n}\n\n// input camera position, lookAt point, & zoomFactor, output camera ray direction\nvec3 makeCamera(vec3 ro, vec3 lookAt, float zoomFactor, vec2 uv) {\n    vec3 fVect = normalize(lookAt - ro);\n    vec3 rVect = normalize(cross(vec3(0., 1., 0.), fVect));\n    vec3 uVect = normalize(cross(fVect, rVect));\n    vec3 rd = normalize(uv.x * rVect + uv.y * uVect + zoomFactor * fVect);\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy; //[0, 1]\n    m = vec2(iTime * 0.08);\n    vec3 color = vec3(0.);\n    \n    vec3 lookAt = vec3(0., 1.5, 6.);\n    vec3 ro = lookAt + vec3( 4.5*cos(7.0*-m.x), 2.2, 4.5*sin(7.0*-m.x) );\n    // haven't taken into account the m.y\n    // maybe should normalize the two rotations in order to get rid of the weird \"zooming out\"\n    // effect in my previous \"Flappy Bird on a 3D Console\" code\n    \n    float twistFrequency = zigzag(iTime * .1); // range [0., 1.]\n    twistFrequency = remap(twistFrequency, 0., 1., 0., 1.);\n    // twistFrequency = 0.002;\n    // twistFrequency = 0.1;\n\n    float zoomFactor = 1.;\n    vec3 rd = makeCamera(ro, lookAt, zoomFactor, uv);\n    \n    float d = RayMarch(ro, rd, twistFrequency);\n    if (d > MAX_DIST) {\n        color = backgroundColor;\n    } else {\n        vec3 p = ro + rd * d;\n        float l = GetLight(p) * GetShadow(p, twistFrequency);\n        color += vec3(l);\n    }\n    \n    \n    fragColor = vec4(color ,1.0);\n}", "image_inputs": [], "common_code": "const vec3 backgroundColor = vec3(1., 169./256., 20./256.);\n\nconst ivec2 txCameraPos = ivec2(31, 1);\n\nconst float PI = 3.14159;\n\nvec4 quatSetAxisAngle(vec3 axis, float rad) {\n    vec4 outVec4 = vec4(0., 0., 0., 0.);\n    \n    rad = rad * 0.5;\n    float s = sin(rad);\n    outVec4.x = s * axis.x;\n    outVec4.y = s * axis.y;\n    outVec4.z = s * axis.z;\n    outVec4.w = cos(rad);\n    \n    return outVec4;\n}\n\nvec4 quatFromUnitVectors(vec3 a, vec3 b) {\n    vec3 tmpvec3 = vec3(0., 0., 0.);\n    vec3 xUnitVec3 = vec3(1., 0., 0.);\n    vec3 yUnitVec3 = vec3(0., 1., 0.);\n    \n    float dotFloat = dot(a, b);\n    \n    if (dotFloat < -0.999999) {\n        tmpvec3 = cross(xUnitVec3, a);\n        if (length(tmpvec3) < 0.000001) tmpvec3 = cross(yUnitVec3, a);\n        tmpvec3 = normalize(tmpvec3);\n        vec4 outVec4 = quatSetAxisAngle(tmpvec3, PI);\n        return outVec4;\n    } else if (dotFloat > 0.999999) {\n        vec4 outVec4 = vec4(0., 0., 0., 0.);\n        outVec4.x = 0.;\n        outVec4.y = 0.;\n        outVec4.z = 0.;\n        outVec4.w = 1.;\n        return outVec4;\n    } else {\n        vec4 outVec4 = vec4(0., 0., 0., 0.);\n        tmpvec3 = cross(a, b);\n        outVec4.x = tmpvec3.x;\n        outVec4.y = tmpvec3.y;\n        outVec4.z = tmpvec3.z;\n        outVec4.w = 1. + dotFloat;\n        return normalize(outVec4);\n    }\n}\n\nvec3 applyQuat(vec3 a, vec4 q) {\n    float qx = q.x;\n    float qy = q.y;\n    float qz = q.z;\n    float qw = q.w;\n    float x = a.x;\n    float y = a.y;\n    float z = a.z;\n    // var qvec = [qx, qy, qz];\n    // var uv = vec3.cross([], qvec, a);\n    float uvx = qy * z - qz * y;\n    float uvy = qz * x - qx * z;\n    float uvz = qx * y - qy * x;\n    // var uuv = vec3.cross([], qvec, uv);\n    float uuvx = qy * uvz - qz * uvy;\n    float uuvy = qz * uvx - qx * uvz;\n    float uuvz = qx * uvy - qy * uvx;\n    // vec3.scale(uv, uv, 2 * w);\n    float w2 = qw * 2.;\n    uvx *= w2;\n    uvy *= w2;\n    uvz *= w2;\n    // vec3.scale(uuv, uuv, 2);\n    uuvx *= 2.;\n    uuvy *= 2.;\n    uuvz *= 2.;\n    // return vec3.add(out, a, vec3.add(out, uv, uuv));\n    vec3 outVec3 = vec3(0., 0., 0.);\n    outVec3.x = x + uvx + uuvx;\n    outVec3.y = y + uvy + uuvy;\n    outVec3.z = z + uvz + uuvz;\n    return outVec3;\n}\n\n// generate a zigzag pattern that oscillates between 0. and 1.\nfloat zigzag(float x) {\n    float modX = mod(x, 2.);\n    \n    if (modX < 1.) {\n        return fract(x);\n    } else {\n        return 1. - fract(x);\n    }\n}\n\nfloat remap01(float x, float low, float high) {\n    x = clamp(x, low, high);\n    return (x - low) / (high - low);\n}\n\nfloat remap(float x, float lowIn, float highIn, float lowOut, float highOut) {\n    float a = remap01(x, lowIn, highIn);\n    return lowOut + a * (highOut - lowOut);\n}", "buffer_a_code": "vec4 loadValue( in ivec2 valueCoord )\n{\n    return texelFetch( iChannel0, valueCoord, 0 );\n}\n\nvoid storeValue( in ivec2 valueCoord, in vec4 value, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = ( valueCoord.x == fragCoord.x && valueCoord.y == fragCoord.y ) \n    ? value : fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XcBGzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 121, 121, 145], [147, 147, 178, 178, 265], [267, 267, 300, 300, 365], [367, 367, 391, 391, 409], [411, 411, 434, 434, 657], [659, 659, 683, 683, 873], [940, 940, 964, 1025, 1199], [1201, 1201, 1251, 1306, 1351], [1353, 1353, 1409, 1409, 2178], [2180, 2180, 2227, 2227, 2490], [2492, 2574, 2640, 2640, 2882], [2884, 2884, 2941, 2941, 3995]], "test": "untested"}
{"id": "Xcs3Dl", "name": "Slowmotion of Tetrascope", "author": "4eckme", "description": "Tetrascope universe slow motion + fix colors", "tags": ["2d", "fractal", "demo", "rgb", "universe", "tetrascope"], "likes": 0, "viewed": 191, "published": 3, "date": "1703687116", "time_retrieved": "2024-07-30T17:14:26.373982", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m =iMouse.xy;\n    if (iMouse.x<1.0&&iMouse.y<1.0) m=iResolution.xy/2.0;\n    vec2 coord = fragCoord-iResolution.xy*1.5+m.xy*2.0;\n    float x = coord.x;\n    float y = coord.y;\n    float t = iTime+1540.0;\n    float r2 = float(x*x*t + y*y*t);\n    int a = int(floor(r2*pow(16.0, 6.0-ceil(log2(r2)/4.0))));   \n    fragColor = vec4(\n        float((a >> 16) & 255) / 255.0,\n        float((a >> 8) & 255) / 255.0,\n        float((a >> 8) & 255) / 255.0,\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xcs3Dl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 531]], "test": "untested"}
{"id": "4fl3Wl", "name": "Inkelly", "author": "leon", "description": "noise driven shape with an ink pen style", "tags": ["ink"], "likes": 66, "viewed": 867, "published": 3, "date": "1703683218", "time_retrieved": "2024-07-30T17:14:27.129961", "image_code": "// Inkelly\n// leon denise 2023-12-27\n\n// other variations\n// https://www.shadertoy.com/view/4cs3Rs\n// https://www.shadertoy.com/view/4cX3WS\n\n// render pass\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float d = length(uv-.5);\n    \n    // blue noise\n    vec4 blu = texture(iChannel1, fragCoord/iChannelResolution[1].xy);\n    \n    // background\n    d += blu.x*.2;\n    vec3 color = vec3(1)*smoothstep(2., 0., d);\n    \n    // edge\n    float feather = .02;\n    vec3 ep = vec3(1./iChannelResolution[0].xy,0);\n    #define T(u) smoothstep(0., feather, texture(iChannel0, uv+u).r)\n    float mr = T(.0);\n    float edge = abs(T(ep.xz)-mr)+abs(T(-ep.xz)-mr)+abs(T(ep.zy)-mr)+abs(T(-ep.zy)-mr);\n    color *= vec3(1.-clamp(edge/2., 0., 1.));\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Inkelly\n// leon denise 2023-12-27\n\n// other variations\n// https://www.shadertoy.com/view/4cs3Rs\n// https://www.shadertoy.com/view/4cX3WS\n\n// feedback displace pass\n\nfloat delay = 4.;\n\n// crazy noise\nfloat gyroid (vec3 seed) { return dot(sin(seed),cos(seed.yzx)); }\nfloat fbm (vec2 pos)\n{\n    float t = floor(iTime/delay);\n    float t2 = t*1.354;\n    vec3 p = vec3(pos, t);\n    float result = 0., a = .5;\n    for (int i = 0; i < 3; ++i, a /= 2.) {\n        result += abs(gyroid(p/a)*a);\n    }\n    result = sin(result*6.283+t2-pos.x);\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // curl noise\n    vec2 e = vec2(4./iResolution.y,0);\n    vec2 curl = vec2(fbm(p+e.xy)-fbm(p-e.xy), fbm(p+e.yx)-fbm(p-e.yx)) / (2.*e.x);\n    curl = vec2(curl.y, -curl.x);\n    \n    // spawn shape\n    p += curl*.05;\n    float dist = max(abs(p.x)-2.,abs(p.y));\n    //dist = abs(length(p)-.5);\n    float mask = smoothstep(.01, 0., dist);\n    \n    // displace\n    curl *= 0.005;\n    vec4 frame = texture(iChannel0, uv + curl);\n\n    // feedback\n    mask = max(mask, frame.r - iTimeDelta);\n    \n    fragColor = vec4(mask, curl, 1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fl3Wl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 214, 214, 825]], "test": "untested"}
{"id": "XfsGWl", "name": " kishimisu_raymarching_tutorial", "author": "anmol", "description": "raymarching tutorial by https://www.youtube.com/@kishimisu \nhttps://www.youtube.com/watch?v=khblXafu7iA\n", "tags": ["raymarching"], "likes": 1, "viewed": 168, "published": 3, "date": "1703681336", "time_retrieved": "2024-07-30T17:14:28.067454", "image_code": "/*\nfloat map(vec3 p) {\n    return length(p) - 1.;\n}\n*/\nmat2 rot2D(float angle)\n{\n    float s=sin(angle), c=cos(angle);\n    return mat2( c, -s, \n                 s,  c );\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 rot3D(vec3 p, vec3 axis, float angle){\n    return mix(dot(axis,p) * axis, p, cos(angle)) + cross(axis, p) * sin(angle);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a-b), 0.0)/k;\n    return min(a,b) - h*h*h*k*(1.0/6.0);\n\n}\n\nfloat map(vec3 p){\n   vec3 spherePos = vec3(sin(iTime) * 3.,0,0);\n   float sphere = sdSphere(p - spherePos, 1.0);\n   \n   vec3 q = fract(p) - .5;\n   \n   q.xy *= rot2D(iTime);\n   \n   float box = sdBox(q, vec3(0.1));\n   \n   float ground = p.y + 0.75;\n   \n   return smin(smin(sphere,box,2.), ground,1.);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0,0,-3);\n    vec3 rd = normalize(vec3(uv,1));\n    vec3 col = vec3(0);\n    \n    float t = 0.;\n    \n    ro.yz *= rot2D(-m.y);\n    rd.yz *= rot2D(-m.y);\n    \n    ro.xz *= rot2D(-m.x);\n    rd.xz *= rot2D(-m.x);\n    \n    // Raymarching\n    for(int i = 0; i < 80; i++){\n        vec3 p = ro + rd * t;\n        \n        float d = map(p);\n        \n        t += d;\n        \n        \n        if(d < .001 || t > 100.) {\n            break;\n        }\n    }\n    \n    // Coloring\n    col = vec3(t * .2);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XfsGWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 55, 80, 80, 171], [173, 173, 206, 206, 234], [236, 236, 264, 264, 355], [357, 357, 400, 400, 483], [485, 485, 524, 524, 608], [610, 610, 628, 628, 911], [915, 915, 972, 972, 1648]], "test": "untested"}
{"id": "XflGDf", "name": "Vyshyvanka pattern on cloth", "author": "ikucha", "description": "Fork of \"Vyshyvanka GPU Patterns \" by mkngry. The pattern is mapped to white, black and red which are the most common vyshyvanka colors\n", "tags": ["pattern", "cloth", "integerhashing", "vyshyvanka"], "likes": 3, "viewed": 182, "published": 3, "date": "1703664814", "time_retrieved": "2024-07-30T17:14:28.888259", "image_code": "// Fork of \"Vyshyvanka GPU Patterns \" by mkngry. https://shadertoy.com/view/sllGRB\n\nconst float PI = 3.1415926535;\nconst float WIDTH = 0.9;\nconst float HEIGHT = 1.5;\nconst float CLOTHTHICKNESS = 0.15;\nconst float CLOTHFINENESS =30.;\nconst vec3 LINENCOLOR = vec3(0.97, 0.97, 0.95);\n\n//hash function is by mkngry\nuvec3 hash(vec2 s)\n{\t\n  uvec2 u = uvec2(s);\n  //uint x = fmix(yellow_code(u.x^u.y));\n  uint x = triple32(fmix(u.x^u.y));\n  //uint x = pcg_hash(fmix(u.x^u.y));\n  uint y = avalanche0(yellow_code(u.x^~u.y));\n  uint z = avalanche1(yellow_code(~u.x^u.y));\n  //return uvec3(tw_hash(x),tw_hash(y),tw_hash(z));\n  return uvec3(yellow_code(EncodeMorton2(x,tw_hash(y))),yellow_code(EncodeMorton2(z,esgtsa(x))),yellow_code(EncodeMorton2(y,z)));\n}\n\nvec3 basePattern(vec2 st){\n    //unnormalized st\n    //create a fake resolution to make the size of the pattern consistent accross different resolutions\n    vec2 fakeRes = iResolution.xy/iResolution.x*700.;\n    vec2 unst = st*fakeRes.xy;\n    uint bit = uint(st.x+4.) + uint(st.y);\n    vec2 seed = mod(unst, vec2(fakeRes.x, fakeRes.y));\n    uvec3 hash = hash(seed);\n    return vec3((hash >> bit) & 1u);\n}\n//this function rotates the pattern properly and also takes isometric coordinates as input while basepattern takes [0,1]^2\n//and outputs a pattern that fills any resolution canvas\nvec3 rotatedPattern(vec2 st){\n    mat2 rotate = mat2(1., -1.,\n                     1., 1.);    \n    //the pattern is skewed so we need to unskew rotate and then skew again to rotate the pattern\n    st = rotate*st;\n    st.x*=iResolution.y/iResolution.x;\n    return basePattern(st);\n}\n\nvec3 mapColor(vec3 col){\n    //get a number from 0 to 7 from amount of 1s in color\n    float n = 4.*col.x+2.*col.y+col.z;\n    vec3 mappedCol = LINENCOLOR;\n    if(n>=2.9){mappedCol = vec3(0.1);}\n    if(n>=6.){mappedCol = vec3(0.93,0.,0.);}\n    return mappedCol;\n}\n\n//draws a sinetube on [-1,1]^2\nfloat sineTube(vec2 v, float _width, float _height){\n    float sine = -0.5*cos(v.x*PI)+0.5;\n    float _y = v.y/_width;\n    float circHeight = sqrt(_width-_y*_y)*_height/_width;\n    //can be NaN if _y is >than _width\n    //circHeight = isnan(circHeight)? 0. : circHeight;\n    float result = (sine+circHeight)/(1.+_height);\n    return isnan(result)? 0.: result*CLOTHTHICKNESS;\n}\n\n//here v is in [0,1]^2\nfloat clothPattern(vec2 v, float _width, float _height){\n    float threadht = sineTube(vec2(v.x*2.-1.-0.5,map(0.,1.,-3.,1.,v.y)),_width,_height);\n    float threadhb = sineTube(vec2(v.x*2.-1.+0.5,map(0.,1.,-1.,3.,v.y)),_width,_height);\n    float threadvr = sineTube(vec2(v.y*2.-1.+0.5,map(0.,1.,-3.,1.,v.x)),_width,_height);\n    float threadvl = sineTube(vec2(v.y*2.-1.-0.5,map(0.,1.,-1.,3.,v.x)),_width,_height);\n    float un = max(max(max(threadht, threadhb),threadvl),threadvr);\n    return un;\n}\n\nvec3 clothPatternNormal(vec2 v, float _width, float _height){\n    float epsilon = 1./(2.*max(iResolution.x,iResolution.y));\n    vec2 xnudge = v + vec2(epsilon, 0.);\n    vec2 ynudge = v+vec2(0.,epsilon);\n    \n    vec3 v3 = vec3(v,clothPattern(v,_width,_height));\n    vec3 xnudge3 = vec3(xnudge,clothPattern(xnudge,_width,_height));\n    vec3 ynudge3 = vec3(ynudge,clothPattern(ynudge,_width,_height));\n    vec3 normal = normalize(cross(xnudge3-v3,ynudge3-v3));\n    return normal;\n}\nvec2 pixellate(vec2 v, float n){\n    v= v*2.-1.;\n    v*=n;\n    return (floor(v)+vec2(0.5))/n;\n}\nvec2 distort(vec2 v, float frequency, float amplitude){\n    return v + vec2(snoise(v*frequency)*amplitude, snoise((v+vec2(100.,200.)*frequency)*amplitude));\n}\n\nvec3 clothPatternPhongLighting(vec3 albedo, vec2 pos, float n){\n    //normal is already normalized\n    vec3 normal = clothPatternNormal(fract(pos*n), WIDTH, HEIGHT);\n    //for now - a directional light\n    vec3 lightDir = normalize(vec3(1.,1., 1.));\n    \n    vec3 ambient = albedo * vec3(0.5);\n    vec3 diffuse = albedo * dot(normal, lightDir) * step(0.,dot(normal, lightDir));\n    //if dot product is negative then set to zero\n    //return vec3(step(dot(normal,lightDir), 0.));\n    return diffuse+ambient;\n}\n\n//averages clothPatternPhongLighting to fix a flashing issue\nvec3 smoothLighting(vec3 albedo, vec2 pos, float n){\n    const float epsilon = 0.001;\n    vec3 sum = vec3(0.);\n    for(float x = -1.; x<=1.;x+=1.){\n        for(float y = -1.; y<=1.; y+=1.){\n            //15 degree rotation for the offset vectors so that it doesn't align with the vertical and horizontal\n            vec2 offsetPos = pos + epsilon*(x*vec2(0.965926, -0.258819) +y*vec2(0.258819, 0.965926));\n            sum += clothPatternPhongLighting(albedo, offsetPos, n);\n        }\n    }\n    sum/=9.;\n    return sum;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy;\n  uv.x*=iResolution.x/iResolution.y;\n  uv+=iTime*vec2(1., 0.8)*0.1;\n  \n  vec3 color = smoothLighting(mapColor(rotatedPattern((distort(uv/14., 1500., 0.00015)))), distort(uv,500.,0.003), CLOTHFINENESS);\n  \n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "float map(float froml, float fromr, float tol, float tor, float x){\n    x-=froml;\n    x/=fromr-froml;\n    x*=tor-tol;\n    x+=tol;\n    return x;\n}\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n//random function from user hornet https://www.shadertoy.com/view/4ssXRX\nfloat rand21( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n//everything below is from https://www.shadertoy.com/view/sllGRB/ by mkngry\n\n// from fxt_book\n// https://jjj.de/\nuint yellow_code(uint a)\n{\n  uint m = ~0u >> 16u;\n  a ^= ((a & m) << 16u);\n  m ^= (m << 8u);\n  a ^= ((a & m) << 8u);\n  m ^= (m << 4u);\n  a ^= ((a & m) << 4u);\n  m ^= (m << 2u);\n  a ^= ((a & m) << 2u);\n  m ^= (m << 1u);\n  a ^= ((a & m) << 1u);\n  return a;\n}\n\n// from http://burtleburtle.net/bob/hash/integer.html\nuint avalanche0(uint a)\n{\n  a = (a+0x7ed55d16u) + (a<<12u);\n  a = (a^0xc761c23cu) ^ (a>>19u);\n  a = (a+0x165667b1u) + (a<<5u);\n  a = (a+0xd3a2646cu) ^ (a<<9u);\n  a = (a+0xfd7046c5u) + (a<<3u);\n  a = (a^0xb55a4f09u) ^ (a>>16u);\n  return a;\n}\n\n// from http://burtleburtle.net/bob/hash/integer.html\nuint avalanche1(uint a)\n{\n  a = (a+0x7fb9b1eeu) + (a<<12u);\n  a = (a^0xab35dd63u) ^ (a>>19u);\n  a = (a+0x41ed960du) + (a<<5u);\n  a = (a+0xc7d0125eu) ^ (a<<9u);\n  a = (a+0x071f9f8fu) + (a<<3u);\n  a = (a^0x55ab55b9u) ^ (a>>16u);\n  return a;\n}\n\n// from http://burtleburtle.net/bob/hash/integer.html\nuint avalanche2(uint a)\n{\n  a -= (a<<6);\n  a ^= (a>>17);\n  a -= (a<<9);\n  a ^= (a<<4);\n  a -= (a<<3);\n  a ^= (a<<10);\n  a ^= (a>>15);\n  return a;\n}\n\n// Also avalanche, last step from from murmur3 hash\n// see: \"Hash Functions for GPU Rendering\" \n// https://www.shadertoy.com/view/XlGcRh\nuint fmix(uint h)\n{\n  h ^= h >> 16;\n  h *= 0x85ebca6bu;\n  h ^= h >> 13;\n  h *= 0xc2b2ae35u;\n  h ^= h >> 16;\n  return h;\n}\n\n// Tomas Wang hash\n// http://burtleburtle.net/bob/hash/integer.html\n// also https://github.com/tugrul512bit/EpicWarCL/blob/master/EpicWarCL/bin/x64/Release/opencl_source/opencl_kernels.cl\nuint tw_hash(uint s)\n{\n  s = (s ^ 61u) ^ (s >> 16u);\n  s *= 9u;\n  s = s ^ (s >> 4u);\n  s *= 0x27d4eb2du;\n  s = s ^ (s >> 15u);\n  return s;\n}\n\n// Schechter and Bridson hash\n// https://www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf\nuint esgtsa(uint s)\n{\n  s = (s ^ 2747636419u) * 2654435769u;\n  s = (s ^ (s >> 16u)) * 2654435769u;\n  s = (s ^ (s >> 16u)) * 2654435769u;\n  return s;\n}\n\n// 32-bit xorshift\n//  - Marsaglia, Xorshift RNGs, Journal of Statistical Software, v8n14, 2003\nuint xorshift32(uint v)\n{\n  v ^= v << 13u;\n  v ^= v >> 17u;\n  v ^= v << 5u;\n  return v;\n}\n\nuint triple32(uint x)\n{\n  x ^= x >> 17u;\n  x *= 0xed5ad4bbu;\n  x ^= x >> 11u;\n  x *= 0xac4c1b51u;\n  x ^= x >> 15u;\n  x *= 0x31848babu;\n  x ^= x >> 14u;\n  return x;\n}\n\nuint pcg_hash(uint x)\n{\n  uint state = x * 747796405u + 2891336453u;\n  uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n  return (word >> 22u) ^ word;\n}\n\n// Morton Code taken from fg:\n// https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/\n\n// \"Insert\" a 0 bit after each of the 16 low bits of x\nuint Part1By1(uint x)\n{\n  x &= 0x0000ffffu;                  // x = ---- ---- ---- ---- fedc ba98 7654 3210\n  x = (x ^ (x <<  8u)) & 0x00ff00ffu; // x = ---- ---- fedc ba98 ---- ---- 7654 3210\n  x = (x ^ (x <<  4u)) & 0x0f0f0f0fu; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210\n  x = (x ^ (x <<  2u)) & 0x33333333u; // x = --fe --dc --ba --98 --76 --54 --32 --10\n  x = (x ^ (x <<  1u)) & 0x55555555u; // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0\n  return x;\n}\n\n// \"Insert\" two 0 bits after each of the 10 low bits of x\nuint Part1By2(uint x)\n{\n  x &= 0x000003ffu;                  // x = ---- ---- ---- ---- ---- --98 7654 3210\n  x = (x ^ (x << 16u)) & 0xff0000ffu; // x = ---- --98 ---- ---- ---- ---- 7654 3210\n  x = (x ^ (x <<  8u)) & 0x0300f00fu; // x = ---- --98 ---- ---- 7654 ---- ---- 3210\n  x = (x ^ (x <<  4u)) & 0x030c30c3u; // x = ---- --98 ---- 76-- --54 ---- 32-- --10\n  x = (x ^ (x <<  2u)) & 0x09249249u; // x = ---- 9--8 --7- -6-- 5--4 --3- -2-- 1--0\n  return x;\n}\n\nuint EncodeMorton2(uint x, uint y)\n{\n  return (Part1By1(y) << 1u) + Part1By1(x);\n}\n\nuint EncodeMorton3(uint x, uint y, uint z)\n{\n  return (Part1By2(z) << 2u) + (Part1By2(y) << 1u) + Part1By2(x);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XflGDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 311, 331, 331, 745], [747, 747, 773, 899, 1150], [1151, 1331, 1360, 1360, 1613], [1615, 1615, 1639, 1697, 1877], [1879, 1910, 1962, 1962, 2286], [2288, 2311, 2367, 2367, 2808], [2810, 2810, 2871, 2871, 3289], [3290, 3290, 3322, 3322, 3385], [3386, 3386, 3441, 3441, 3544], [3546, 3546, 3609, 3644, 4054], [4056, 4117, 4169, 4169, 4637], [4640, 4640, 4697, 4697, 4974]], "test": "untested"}
{"id": "MfX3Wl", "name": "Drag Around Maze", "author": "spenceryonce", "description": "maze drag around with truchet pattern", "tags": ["simple", "drag", "maze"], "likes": 1, "viewed": 155, "published": 3, "date": "1703664718", "time_retrieved": "2024-07-30T17:14:29.757934", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265358979323846\n\nfloat zoomLevel = 10.0;\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nvec2 truchetPattern(in vec2 _st, in float _index){\n    _index = fract(((_index-0.5)*2.0));\n    if (_index > 0.75) {\n        _st = vec2(1.0) - _st;\n    } else if (_index > 0.5) {\n        _st = vec2(1.0-_st.x,_st.y);\n    } else if (_index > 0.25) {\n        _st = 1.0-vec2(1.0-_st.x,_st.y);\n    }\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy / iResolution.xy;\n    st.x *= iResolution.x / iResolution.y;\n    st *= zoomLevel;\n\n    // Adjust mouse coordinates for aspect ratio\n    vec2 mouseAdjusted = iMouse.xy / iResolution.xy;\n    mouseAdjusted.x *= iResolution.x / iResolution.y;\n\n    // Apply mouse interaction\n    st -= mouseAdjusted * zoomLevel;\n\n    vec2 ipos = floor(st);  // integer position\n    vec2 fpos = fract(st);  // fractional position\n\n    vec2 tile = truchetPattern(fpos, random(ipos));\n    float color = 0.0;\n\n    // Maze\n    color = smoothstep(tile.x-0.164, tile.x, tile.y) -\n            smoothstep(tile.x, tile.x+0.172, tile.y);\n\n    fragColor = vec4(vec3(color), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MfX3Wl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 134, 134, 210], [212, 212, 262, 262, 523], [525, 525, 582, 582, 1258]], "test": "untested"}
{"id": "MffGWl", "name": "Infinite Texture Zoom -314 chars", "author": "GregRostami", "description": "This is a variant of Fabrice's amazing \"infinite star zoom\" [url]https://shadertoy.com/view/ltdfWH[/url]\nPlease help me make it shorter.\nThank you", "tags": ["2d", "texture", "zoom", "short", "golf"], "likes": 9, "viewed": 249, "published": 3, "date": "1703664196", "time_retrieved": "2024-07-30T17:14:30.503940", "image_code": "// Fork of \"infinite star zoom (160 chars)\" by FabriceNeyret2. https://shadertoy.com/view/MtdfWH\n// 2023-12-27 08:00:15\n\n// 314 chars - Fabrice made 9 chars disappear!\n#define A(a) texture(a, (U+U-iResolution.xy)*s/4e4 + i/L) //\n#define c(t) t<1. ? A(iChannel0) : t<2. ? A(iChannel1) : t<3. ? A(iChannel2) : A(iChannel3)\nvoid mainImage(out vec4 O, vec2 U) {\n    float k, s, i, L = 20., T = 4.*fract(iTime / 40.);\n    for( O*=s; i++ < L;\n         O += ( 1. - cos(6.3*k/L) ) / s\n              * ( 8.* mix( c(T), c(mod(T+1.,4.)), fract(T) ) - 1.2 )\n       )\n         s = exp2( k = mod( i-iTime, L ) );\n}\n\n// 323 chars - Golfed by Greg by removing the smoothstep:\n/*\n#define A(a) texture(a, (U+U-iResolution.xy)*s/4e4 + i/L)\nvoid mainImage(out vec4 O, vec2 U)\n{\n    vec4 c[4];\n    float k, s, i, L = 20., T = 4.*fract(iTime / 40.);\n    for( O *= s; i++ < L;\n       O += ( 1. - cos(6.3*k/L) ) / s *\n       (8.* mix( c[int(T)], c[(int(T) + 1) % 4], fract(T)) - 1.2))\n     s = exp2( k = mod( i-iTime, L ) ),\n     c[0] = A(iChannel0),\n     c[1] = A(iChannel1),\n     c[2] = A(iChannel2),\n     c[3] = A(iChannel3);\n}\n*/\n\n// 341 chars - Original shader:\n/*\n#define A(a) texture(a, (U+U-iResolution.xy)*s/4e4 + i/L)\nvoid mainImage(out vec4 O, vec2 U)\n{\n    vec4 c[4];\n    float k, s, i, L = 20., T = 4.*fract(iTime / 40.);\n    for( O *= s; i++ < L;\n       O += ( 1. - cos(6.3*k/L) ) / s *\n       (8.* mix( c[int(T)], c[(int(T) + 1) % 4], smoothstep(0., 1., fract(T))) - 1.2))\n     s = exp2( k = mod( i-iTime, L ) ),\n     c[0] = A(iChannel0),\n     c[1] = A(iChannel1),\n     c[2] = A(iChannel2),\n     c[3] = A(iChannel3);\n}\n*/", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MffGWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[321, 321, 357, 357, 600]], "test": "untested"}
{"id": "XfX3Wl", "name": "RipplesÂ²", "author": "corabelster", "description": "@author Jan <LJ> Scheurer", "tags": ["glslsandbox"], "likes": 13, "viewed": 278, "published": 3, "date": "1703643854", "time_retrieved": "2024-07-30T17:14:31.250942", "image_code": "/*\nAdapted from here:\nhttps://glslsandbox.com/e#78289.0\n*/\n\nprecision highp float;\n\nfloat rand(vec2 p){\n    return fract(sin(dot(p,vec2(12.412,38.5123)))*42164.5123);\n}\n\nconst vec2 O = vec2(0, 1);\n\nfloat bnoisea(vec2 b){\n    b = floor(b);\n    return (rand(b) + rand(b + O) + rand(b + O.yx) + rand(b + O.yy)) * .25;\n}\n\nfloat bnoise(vec2 b){\n    float time = iTime * .4;\n    return mix(bnoisea(b + floor(time)), bnoisea(b + floor(time + 1.)), fract(time));\n}\n\nmat2 r2d(float a){\n    float sa = sin(a), ca = cos(a);\n    return mat2(ca, sa, -sa, ca);\n}\n\nfloat pat(vec2 p) {\n    for(int i = 0; i < 7; i++) \n        p = max(abs(abs(p - 4.) * r2d(.785) - 5.5), vec2(0., bnoise(vec2(i)) - 1.));\n    return bnoise(p.xx * 40. + iTime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy / iResolution.xy) * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    float T = iTime * .1 + 4.;\n    vec3\n    ro = vec3(sin(T) * 3., 2.5 + sin(T + 1.), cos(T) * 3.),\n    rd = normalize(vec3(p * r2d(.7 + T), -2.)),\n    mp = ro;\n\n    rd.yz *= r2d(1.5 - cos(T + .3) * .5);\n    rd.xz *= r2d(T);\n\n    for(int i = 0; i < 50; i++)\n        mp += rd * (mp.y + pat(mp.xz * 3.) * .4) * .15;\n\n    fragColor = vec4(vec3(pow(pow(.7 / abs(mp.y) * .35, .5) * 1.4 * vec3(.4, .45, .5), vec3(5.)) * 2.) * max(1. - length(p) * .45, 0.), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XfX3Wl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 103, 103, 168], [198, 198, 220, 220, 316], [318, 318, 339, 339, 456], [458, 458, 476, 476, 548], [550, 550, 569, 569, 727], [729, 729, 786, 786, 1343]], "test": "untested"}
{"id": "lcs3WX", "name": "Rolling Function plot", "author": "Neervana", "description": "A really stupid idea I had, turns out it's not hard at all to adapt a fragment shader into a generic function plotter, it looks very similar to the mechanism for mandelbrot visualization.", "tags": ["basic", "function", "plot"], "likes": 4, "viewed": 156, "published": 3, "date": "1703632273", "time_retrieved": "2024-07-30T17:14:32.112638", "image_code": "#define FOO(X) cos(X + iTime) + exp(X)/10.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= 0.5;\n    uv *= 10.0;\n    float u = uv.x;\n    float v = uv.y;\n    \n    float ratio = iResolution.x / iResolution.y;\n    u *= ratio;\n    \n    fragColor = vec4(0.0f);\n    \n    if(abs(FOO(u) - v) <= 2e-2) { \n        fragColor += vec4(1.0, 0.0, 0.0, 1.0); // plot the func\n    } else if (dot(vec2(u,v),vec2(u,v)) <= 2.5e-3) { \n        fragColor += vec4(1.0, 1.0, 0.0, 1.0); // plot the origin\n    } else if(abs(u) <= 2e-2) { \n        fragColor += vec4(1.0); // plot the Y axis\n    } else if(abs(v) <= 2e-2) {\n        fragColor += vec4(1.0); // plot the X axis\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcs3WX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 102, 152, 770]], "test": "untested"}
{"id": "Xfl3Wf", "name": "kas-CheckerBoard", "author": "mokasiri", "description": "CheckerBoard", "tags": ["checkerboard"], "likes": 1, "viewed": 147, "published": 3, "date": "1703624096", "time_retrieved": "2024-07-30T17:14:32.960372", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n    \n    //uv.x *= sin(iTime/10.);\n    //uv.y *= cos(iTime/10.);\n    \n    \n    float uvx = floor(uv.x/10.);\n    float uvy = floor(uv.y/10.);\n    \n    float agg = uvx + uvy;\n    \n    \n    float col = mod(agg,2.);\n    \n    \n\n    fragColor = col * vec4(1.,1.,1.,1.0);\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xfl3Wf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 355]], "test": "untested"}
{"id": "McXGD2", "name": "float texture test 1", "author": "janpitokiala", "description": "if the right side is white, buffers can hold values above 1, if it's grey, they can't, and if it's black, buffers can't hold values?", "tags": ["test"], "likes": 0, "viewed": 53, "published": 3, "date": "1703612053", "time_retrieved": "2024-07-30T17:14:33.803118", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,uv)/2.;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(vec3(uv.x),1.0)*2.;\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/McXGD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 141]], "test": "untested"}
{"id": "4ffGWX", "name": "kiloatom", "author": "edfilo", "description": "simple circle xyzlkjlkjlkj", "tags": ["circle"], "likes": 12, "viewed": 262, "published": 3, "date": "1703611302", "time_retrieved": "2024-07-30T17:14:34.558100", "image_code": "\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n       float time = iTime;\n       float alpha = 1.0;\n       float orbitals = 10.;\n       vec3 color = vec3(0.1, 0.5, 0.8);\n       float radius = .25;\n        vec3 shape = vec3(0.);\n        float expand = .5555;\n\n         \n        float f;\n       \n\n      \n         vec2 xUv = ( fragCoord -.5*iResolution.xy )/iResolution.y;\n        \n\n        for(float i = 0.0; i < orbitals; i++){\n\n            // based off https://www.shadertoy.com/view/NscyDN\n            float s = sin((time / 111.0) + i * cos(time*0.02+i)*0.05+0.05);\n            float c = cos((time / 111.0) + i * sin(time*0.02+i)*0.05+0.05);\n            c += sin(time) *  expand; //not sure if i like this \n            s += sin(time) * expand; //not sure if i like this \n            // Point manipulations based on position, time, and index\n            vec2 pt = vec2(c, s);\n            f = 0.01 / abs(length(xUv / pt) - radius);\n            float idx = float(i) / orbitals;\n            idx = fract(idx);\n            shape += f * color;\n            xUv *= r2d(time*0.1);\n         \n        }\n\n\n        vec4 atom = vec4(shape.r, shape.g, shape.b, 1.0);\n        fragColor = vec4(atom) * vec4(alpha);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ffGWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 21, 21, 106], [108, 108, 165, 165, 1324]], "test": "untested"}
{"id": "Mcf3DX", "name": "truchet3d tetragonal logspiral", "author": "cyperus", "description": "truchet3d toroidal  tetragonal cyclic logarithmic spiral", "tags": ["3d", "grid", "sdf", "spiral", "tiling", "logarithm", "schwarzchristoffel", "tetragon"], "likes": 11, "viewed": 225, "published": 3, "date": "1703610968", "time_retrieved": "2024-07-30T17:14:35.568399", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"truchet3d tetragonal logspiral\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n//\n// References & Inspiration:\n// - \"Schwarz-Christoffel Mapping\" by mla\n//   https://www.shadertoy.com/view/tsfyRj\n//\n// - quick guide for shadertoy by FabriceNeyret2\n//   https://shadertoyunofficial.wordpress.com/\n//\n// - signed distance functions & operations by iq\n//   https://iquilezles.org/articles/distfunctions/\n//\n////////////////////////////////////////////////////////////////////////////////\n// ray casting bounding shape\nconst float CAM_DIST = 5.; \nconst float CAM_FLE  = 2.;\nconst float BB_DIST  = 10.;\nconst float RAY_MIN_DIST = 0.5;\nconst float RAY_MAX_DIST = CAM_DIST+1.1*BB_DIST;\n\nconst int   MAX_MARCHING_STEPS = 800;\nconst float RAY_STEP_FACTOR = 0.07;\nconst float RAY_PRECISION = 0.1;\n\n// data from sdf\nvec3 mat_to = vec3(0);\nvec3 mat_to_id = vec3(0);\nvec4 mat_tc = vec4(0);\n\nfloat map(in vec3 p) {\n    float rxy = 0., au = 0.0;\n    vec2 z = vec2(0.);\n    \n    /// clog spiral\n    float rxy1 = length(p.xy);\n    p.z *= func0(rxy1, 0.5, 20.)/0.4;   \n    vec2 sp_k = 2.*vec2(1.,3.);\n    p.xy = clog(p.xy)/(2.*PI);\n    p.xy = cmul(p.xy,sp_k);      \n    p.xy -= vec2(0.01, 0.1 )* iTime;\n    \n    /// regular polygon tiles\n    vec2 rpt_id = vec2(1.);  float rpt_sr;\n    z = recgrid2rec(p.xy, rpt_id.xy, rpt_sr);\n    mat_to_id = vec3(rpt_id, rpt_sr);\n    z = inversesc(z,4);\n    p.xy = z;\n\n    /// (torus,sphere,2spheres)  \n    rxy = length(p.xy); au = atan(p.y, p.x) + 2.*PI*iTime/120.;\n    z = ccos(PI*vec2(rxy,p.z))/0.5;\n    z.x += 2.*(1. + sin(2.*PI*iTime/120.));\n        \n    p = vec3(log(length(z)), fract(2.*0.5*au/PI)/2., 0.5*atan(z.y,z.x)/PI);\n    vec2 to_uv = vec2(0.5*au/PI,p.z);\n    float to_d = log(length(z)+0.8);   \n\n    p.yzx = p;\n    \n    /// truchet grid\n    float TC3D_nu = 16.;\n    float TC3D_nv = 8.;\n    float TC3D_nr = 1.;\n    p *= vec3(TC3D_nv,TC3D_nr,TC3D_nu);\n\n    ivec3 l0 = -ivec3(TC3D_nv/2.,0,TC3D_nu/2.);\n    ivec3 l1 = ivec3(TC3D_nv/2.,TC3D_nr,TC3D_nu/2.)-ivec3(1.);\n    vec3 tc_id = floor(p);\n        \n    tc_id = clamp(tc_id, vec3(l0), vec3(l1));\n    vec3 q = p - tc_id -0.5;\n\n    // random\n    float rnd = hash21(tc_id.xz);  \n\n    // flip cell direction randomly\n    if(rnd<.5) q.x = -q.x;\n\n    // sdf\n    float d;\n    if(fract(rnd*77.57+iTime/10.)>.75) {\n       // offset-xz circle, id diagonal sub domain\n       vec3 q2 =  length(q.xz-.5)<length(q.xz+.5)\n                ? vec3(q.xz-.5,0.)  \n                : vec3(q.xz+.5,1.);\n       d = sdTorus( vec3(q2.x, q.y, q2.y) , vec2(0.5,0.0625) );\n    }\n    else {\n       d = opSmoothUnion( sdCylinder( q.zxy, 0.0625 ), sdCylinder( q.xzy,0.0625 ), 0.05 );\n    }\n\n    /// return\n    mat_to = vec3(to_uv,to_d); // torus: surface uv, distance function\n    mat_tc = vec4(q,rnd);      // truchet: local cell coords, random cell id\n    return min(d,to_d);\n}\n\n// intersect\nfloat intersect(in vec3 ro, in vec3 rd, in float px) {\n    float res = -1.0;\n    \n    // bounding shape BB\n    vec2 dis = isphere( ro, rd , abs(BB_DIST));\n    \n    if( dis.y<0.0 ) return -1.0;\n\n    dis.x = max( dis.x, RAY_MIN_DIST );\n    dis.y = min( dis.y, RAY_MAX_DIST );\n\n    // raymarch signed distance field    \n\tfloat fh = RAY_STEP_FACTOR;\n    float t = dis.x;\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) {\n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t;\n        float h = map( pos);\n        if( t>dis.y || h<th ) break;\n        t += h*fh;\n    }\n    if( t<dis.y ) {\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) { \n\tif (iMouse.x > 0.0) {\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n    p.yz = crot(p.yz,-2.*PI*1.*time/12.);\n    p.zx = crot(p.zx,-2.*PI*2.*time/12.);\n\treturn p.xyz;\n}\n\n// textures\nfloat grid_uv(in vec2 uv) {\n    // uv grid alpha mask\n    vec2 sw = abs(fract(uv-0.25)-0.5)-0.25;\n    float sdf = min(sw.x,sw.y)*-max(sw.x,sw.y);\n    float pp = fwidth(sdf);\n    return smoothstep(+pp,-pp,sdf);\n}\n            \nvec4 cells(in vec2 uv, in float h) {\n    // sectors, uv-grid\n    vec4 C;\n    C.a = 1.;\n    C.rgb = h2rgb(h);                      // sector  -> hue\n    C.rgb *= (0.5+ 0.5 * grid_uv(uv))*0.7; // uv-grid -> value\n    return C;\n}\n\nvec4 ribbon(in float uv_x, in float r, in float time) {\n    float sdf = -(2.*pulsecollision(1.,1./3. * uv_x, time, 2./6.)-1.);\n    float px = fwidth(sdf); float a = smoothstep(px+0.1,-px-0.1,sdf+0.2);    \n    vec4 C = r<0.5 ? vec4( h2rgb(sdf -2./6.),a ) : vec4(0.);\n    return C;\n}\n\nvec4 truchet3D(in vec3 p, in float rnd ,in float time) {\n    float sdf = sdBox( p, vec3(0.5*0.9));\n    float px = fwidth(sdf); float a = smoothstep(px,-px,sdf);\n    return mix(vec4(1.), vec4(h2rgb( fract(abs(rnd)*22.93 + time)),1.), a);\n}\n\n//\nvoid mainImage(out vec4 O, in vec2 fragCoord) {   \n    // anti-aliasing to take a picture\n    vec3 tot = vec3(0.0);\n    #define AA 1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ ) {       \n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o) - iResolution.xy)/iResolution.y;\n        \n        // camera viewport --> worldspace\n        vec3 ro = vec3(0,0,-CAM_DIST);\n        vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n             ro = transform(ro,iTime/60.);\n             rd = normalize(transform(rd,iTime/60.));\n        \n        // distance hit ray surface\n        float px = 2.0/( iResolution.y*CAM_FLE );\n        float t = intersect( ro, rd, px );\n\n        //vec3 sky_col = rd*.3+.7;\n        vec3 sky_col = vec3(0.);\n        // background\n        vec4 C = vec4(sky_col,1.);\n        O = C;\n        \n        // object surface\n        if (t >= 0.) {\n            // surface properties\n            vec3 p = ro + rd * t;\n            vec3 n = calcNormal( p, 0.001);\n            \n            const float r0 = 0.5;\n            float a_rpt_tc = 0.5+0.5*sin(2.*PI*iTime/60.);\n            \n            // draw texture\n            O = vec4(0);\n            #if 1\n            if(O.a<1.) {\n                float hue = (mat_to_id.x + 2.)/4. + (mat_to_id.y )/8.;\n                C = cells(mat_to.xy/2., hue);\n                C.a = mat_to.z>r0 ? 1.-a_rpt_tc : O.a;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n            #endif           \n            #if 1\n            if(O.a<1.) {             \n                C = ribbon( 12.* mat_to.x, mat_to.z, 6.*iTime/60.); C.rgb *= 0.7;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n            #endif\n            #if 1\n            if(O.a<1.) {\n                C = vec4(vec3(n)*0.5,0.2);\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n            #endif\n            #if 1\n            if(O.a<1.) {            \n                C = truchet3D(mat_tc.xyz, mat_tc.w, iTime/60.); C.rgb *= 0.5;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n            #endif\n            C = O;\n                       \n            // lighting\n            vec3  came_li_o   = transform(vec3(-10.,10.,-10.),iTime/60.); // origine\n            vec3  came_li_dir = normalize(p - came_li_o);             // direction\n            vec3  came_li_col = vec3(1.,1.,.5);                       // color\n            float came_li_shi = 10.;                                  // shininess            \n\n            float cosa = 1.;\n            O.rgb += 0.1 * cosa * C.rgb * sky_col;           // amb\n            cosa = clamp(dot(-came_li_dir, n), 0., 1.);\n            O.rgb += 0.5 * cosa * C.rgb * came_li_col;       // dif       \n            cosa = pow(clamp(dot(reflect(came_li_dir, n), -rd), 0., 1.), came_li_shi);           \n            O.rgb += 0.4 *(cosa>0.? cosa:0.) * came_li_col ; // spec\n            \n            // fresnel\n            //O.rgb += pow(clamp(1. - dot(n, -rd), 0., 1.), 5.) * 0.6 * sky_col;\n            \n            // fog\n            O.rgb = mix(O.rgb, sky_col, 1.0 - exp(-0.05E-2 * pow(t,4.)));\n        }\n        tot += O.rgb;\n    }\n    tot /= float(AA*AA);\n    \n    // gamma correction\n    O = vec4(rgb2srgb(tot),1.);\n}", "image_inputs": [], "common_code": "// const\nconst float \n    PI = abs(atan(0.,-1.));\n\n/// 1D transformations\nfloat signeveodd(float x){\n    return sign(mod(x-0.5,2.)-1.);}\n\nfloat pulsecollision(in float pf, in float x, in float x0, in float pw) {\n    float ntriw_p = abs( fract( pf*(x - x0) )-0.5);\n    return smoothstep( 0.5*pw, 0., ntriw_p );\n\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);\n}\n\nfloat func0(in float x, in float x0, in float k) {\n    x = abs(x/x0);\n    return x > 1. ? 1./x : -pow(x,k)/k + (1.+ 1./k);\n}\n\n// complex\nvec2 cmul(vec2 za,vec2 zb) {\n    return za*mat2(zb.x,-zb.y,zb.yx);}\n\nvec2 crot(vec2 z,float a) {\n    return cmul(vec2(cos(a),sin(a)),z);}\n\nvec2 cinv(vec2 z) {\n    return z*vec2(1,-1)/dot(z,z);}\n    \nvec2 cdiv(vec2 z, vec2 w) {\n    return cmul(z,cinv(w));}\n    \nvec2 cpow(vec2 z, int n) {\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));}\n \nvec2 csqr(vec2 z) {\n    return vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y );}\n\nvec2 ccos(vec2 z) {\n    vec2 d=vec2(exp(z.y),exp(-z.y));\n\treturn vec2(cos(z.x)*(d.x+d.y)*.5,-sin(z.x)*(d.x-d.y)*.5);}\n\nvec2 clog(vec2 z) {\n    return vec2(0.5*log(z.x*z.x+z.y*z.y),atan(z.y,z.x));\n}\n\nfloat binomial(float a, int n) {\n   float s = 1.0;\n   for (int i = n; i >= 1; i--,a--) {\n     s *= float(a)/float(i);\n   }\n   return s;\n}\n\nvec2 expi(float x) {\n  return vec2(cos(x),sin(x));\n}\n\nfloat gamma(float z) {\n  const float[8] p = float[](\n    676.5203681218851,\n    -1259.1392167224028,\n    771.32342877765313,\n    -176.61502916214059,\n    12.507343278686905,\n    -0.13857109526572012,\n    9.9843695780195716e-6,\n    1.5056327351493116e-7\n  );\n  z -= 1.0;\n  float x = 0.99999999999980993;\n  for (int i = 0; i < 8; i++) {\n    float pval = p[i];\n    x += pval/(z+float(i+1));\n  }\n  float t = z + 8.0 - 0.5;\n  return sqrt(2.0*PI) * pow(t,z+0.5) * exp(-t) * x;\n}\n\n// The Beta function\nfloat B(float a, float b) {\n  return (gamma(a)*gamma(b))/gamma(a+b);\n}\n\nvec2 inversesc(vec2 z, int K) {\n  float cn[6];\n  for (int n = 1; n <= 5; n++) {\n    cn[n] = binomial(float(n)-1.0+2.0/float(K),n)/float(1+n*K);\n  }\n  float C = B(1.0/float(K),1.0-2.0/float(K))/float(K);\n  z *= C;\n  vec2 h = cpow(z,int(K));\n  float T1 = -cn[1];\n  float T2 = -cn[2]+float(K+1)*pow(cn[1],2.0);\n  float T3 = -cn[3]+float(3*K+2)*(cn[1]*cn[2]-float(K+1)/2.0*pow(cn[1],3.0));\n  float T4 = -cn[4]+float(2*K+1)*(2.0*cn[1]*cn[3]+pow(cn[2],2.0)-float(4*K+3)*\n                                  (pow(cn[1],2.0)*cn[2]-float(K+1)/3.0*pow(cn[1],4.0)));\n  float T5 = -cn[5]+float(5*K+2)*(cn[1]*cn[4]+cn[2]*cn[3]+float(5*K+3)*\n            (-0.5*pow(cn[1],2.0)*cn[3]-0.5*cn[1]*pow(cn[2],2.0)+float(5*K+4)*\n            (pow(cn[1],3.0)*cn[2]/6.0-float(K+1)*pow(cn[1],5.0)/24.0)));\n  vec2 X = vec2(1,0)+h/pow(C,float(K));\n  vec2 w = cmul(z,vec2(1,0) + T1*h + T2*cpow(h,2) + T3*cpow(h,3) + T4*cpow(h,4) + cdiv(T5*cpow(h,5),X));\n  return w;\n}\n\n// grid's\nvec2 recgrid2rec(in vec2 Z, out vec2 Z_id, out float  z_sr){ \n    const float PI_4 = PI/4.;\n    const float SQRT2 = sqrt(2.);\n    const float SQRT_2 = 1./SQRT2;\n    Z = crot(Z,PI_4);\n    Z/= SQRT_2;\n    Z_id = 2.*floor(Z*.5+0.5);\n    vec2 Z_lo = Z-Z_id;\n    Z = Z_lo;\n    z_sr = signeveodd(0.5*(Z_id.x+Z_id.y));   \n    Z_id = vec2(signeveodd(Z_id.x*0.5),signeveodd(Z_id.y*0.5));\n    Z.x *= Z_id.x;\n    Z.y *= Z_id.y;\n    Z *= SQRT_2;\n    return crot(Z,-PI_4);\n}\n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// sdf\nfloat opIntersection( float d1, float d2 ) {\n    return max(d1,d2); }\n\nfloat opSmoothUnion( in float d1, in float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, float r ) {\n  return length(p.xz)-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// color\nvec3 h2rgb(float h){\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n}\n\nvec3 hsv2rgb(float h, float s, float v){     \n    return v * mix( vec3(1.0), h2rgb(h), s);\n}\n\n// srgb <--> rgb (linear)\nvec3 srgb2rgb(vec3 col) {\n    return pow(col, vec3(2.2));\n}\n\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mcf3DX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1065, 1065, 1087, 1087, 3014], [3016, 3029, 3083, 3083, 3669], [3671, 3671, 3716, 3716, 3878], [3880, 3880, 3922, 3922, 4171], [4173, 4185, 4212, 4238, 4396], [4410, 4410, 4446, 4470, 4636], [4638, 4638, 4693, 4693, 4919], [4921, 4921, 4977, 4977, 5159], [5161, 5164, 5211, 5253, 8465]], "test": "untested"}
{"id": "MclGDj", "name": "integral image box blur", "author": "janpitokiala", "description": "It takes some time to make the integral image (O(log n)), but after that it's O(1)", "tags": ["blur", "boxblur"], "likes": 1, "viewed": 104, "published": 3, "date": "1703606515", "time_retrieved": "2024-07-30T17:14:36.460015", "image_code": "vec4 samp(vec2 point) {\n    return texture(iChannel0, point/iResolution.xy);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord;\n    vec2 uv = fragCoord/iResolution.xy;\n    float blurx = 6.+5.*sin(2.*iTime);\n    float blury = blurx;\n    p += vec2(blurx,blury)/2.;\n    vec4 a = samp(p-vec2(blurx,0));\n    vec4 b = samp(p-vec2(0,0));\n    vec4 c = samp(p-vec2(blurx,blury));\n    vec4 d = samp(p-vec2(0,blury));\n    vec4 col = b-a-d+c;\n    col /= float(blurx*blury);\n    fragColor = vec4(col.rgb, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame==1) {\n      vec2 uv = fragCoord/iResolution.xy;\n      fragColor = texture(iChannel1, uv);\n      return;\n    }\n    int size = int(pow(2.,float(iFrame-2)));\n    ivec2 origin = ivec2(fragCoord)&(-(size<<1));\n    ivec3 p = ivec3(ivec2(fragCoord)-origin,size-1);\n    vec4 val = texelFetch(iChannel0, p.xy+origin, 0);\n    if(p.x>p.z) {\n      val += texelFetch(iChannel0, p.zy+origin, 0);\n    }\n    if(p.y>p.z) {\n      val += texelFetch(iChannel0, p.xz+origin, 0);\n      if(p.x>p.z) {\n        val += texelFetch(iChannel0, p.zz+origin, 0);\n      }\n    }\n    fragColor = val;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MclGDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 78], [79, 79, 136, 136, 531]], "test": "untested"}
{"id": "McXGW2", "name": "falling into black hole", "author": "Mik0", "description": "Light bending simulation. Use mouse to look around.  (spacey colors function is from chatgpt)", "tags": ["space", "galaxy", "blackhole", "bending"], "likes": 0, "viewed": 153, "published": 3, "date": "1703594404", "time_retrieved": "2024-07-30T17:14:37.532148", "image_code": "const float halfPi = acos(0.0);\nconst float convert = halfPi/90.0;\nconst float gravitationalConst = 6.674*pow(10.0, -11.0);\n\nstruct ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nray cam(vec3 pos, vec2 turn, float zoom, vec2 uv)\n{\n    vec3 forward = vec3(sin((turn.x)*convert)*cos((turn.y)*convert), cos((turn.x)*convert)*cos((turn.y)*convert), sin((turn.y)*convert));\n    vec3 right = vec3(sin((turn.x+90.0)*convert), cos((turn.x+90.0)*convert), 0);\n    vec3 up = vec3(sin((turn.x)*convert)*cos((turn.y+90.0)*convert), cos((turn.x)*convert)*cos((turn.y+90.0)*convert), sin((turn.y+90.0)*convert));\n    vec3 p = (forward*zoom)+(right*uv.x)+(up*uv.y);\n    return ray(pos, normalize(p));\n}\n\nfloat hash(vec3 p3) {\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 cellNoise(vec3 p) {\n    vec3 pi = floor(p);\n    vec3 pf = fract(p);\n    \n    float d = 1e30;\n    for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n            for (int k = -1; k <= 1; k++) {\n                vec3 offset = vec3(float(i), float(j), float(k));\n                vec3 neighbor = vec3(hash(pi + offset));\n                vec3 diff = offset + neighbor - pf;\n                float dist = dot(diff, diff);\n                d = min(d, dist);\n            }\n        }\n    }\n    return vec3(sqrt(d));\n}\n\nfloat worley(vec3 p) {\n    vec3 cell = floor(p);\n    vec3 fc = fract(p);\n    \n    float d = 1.0;\n    for (int xo = -1; xo <= 1; xo++) {\n        for (int yo = -1; yo <= 1; yo++) {\n            for (int zo = -1; zo <= 1; zo++) {\n                vec3 offset = vec3(float(xo), float(yo), float(zo));\n                vec3 neighbor = cellNoise(cell + offset);\n                vec3 diff = offset - fc + neighbor;\n                float dist = dot(diff, diff);\n                d = min(d, dist);\n            }\n        }\n    }\n    return sqrt(d);\n}\n\nfloat fractalWorley(vec3 p, int octaves, float lacunarity, float persistence) {\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    float maxValue = 0.0; // Used for normalizing result to 0.0 - 1.0\n\n    for (int i = 0; i < octaves; i++) {\n        total += worley(p * frequency + float(i)) * amplitude;\n        amplitude *= persistence;\n        frequency *= lacunarity;\n        maxValue += amplitude;\n    }\n\n    return total / maxValue; // Normalize to 0.0 - 1.0\n}\n\nfloat ring(vec3 vec, vec2 turn, float thickness)\n{\n    vec3 p = vec3(sin((turn.x)*convert)*cos((turn.y)*convert), cos((turn.x)*convert)*cos((turn.y)*convert), sin((turn.y)*convert));\n    return pow(1.0-abs(dot(vec, p)), thickness);\n}\n\n\nvec3 spaceyColors(float t) {\n\n    // Define spacey colors\n    vec3 color1 = vec3(12.0/255.0, 23.0/255.0, 44.0/255.0);    // Deep Space Blue\n    vec3 color2 = vec3(63.0/255.0, 27.0/255.0, 71.0/255.0);    // Galactic Purple\n    vec3 color3 = vec3(146.0/255.0, 45.0/255.0, 141.0/255.0);  // Nebula Pink\n    vec3 color4 = vec3(47.0/255.0, 184.0/255.0, 118.0/255.0);  // Aurora Green\n    vec3 color5 = vec3(29.0/255.0, 133.0/255.0, 142.0/255.0);  // Stardust Teal\n    vec3 color6 = vec3(52.0/255.0, 32.0/255.0, 92.0/255.0);    // Cosmic Indigo\n    vec3 color7 = vec3(87.0/255.0, 95.0/255.0, 103.0/255.0);   // Meteorite Gray\n    vec3 color8 = vec3(78.0/255.0, 122.0/255.0, 153.0/255.0);  // Comet Blue\n    vec3 color9 = vec3(255.0/255.0, 149.0/255.0, 45.0/255.0);  // Solar Flare Orange\n    vec3 color10 = vec3(5.0/255.0, 5.0/255.0, 5.0/255.0);      // Dark Matter Black\n\n    // Blend between colors using smoothstep\n    vec3 blendedColor = mix(color1, color2, smoothstep(0.0, 1.0, t));\n    blendedColor = mix(blendedColor, color3, smoothstep(0.1, 1.0, t));\n    blendedColor = mix(blendedColor, color4, smoothstep(0.2, 1.0, t));\n    blendedColor = mix(blendedColor, color5, smoothstep(0.3, 1.0, t));\n    blendedColor = mix(blendedColor, color6, smoothstep(0.4, 1.0, t));\n    blendedColor = mix(blendedColor, color7, smoothstep(0.5, 1.0, t));\n    blendedColor = mix(blendedColor, color8, smoothstep(0.6, 1.0, t));\n    blendedColor = mix(blendedColor, color9, smoothstep(0.7, 1.0, t));\n    blendedColor = mix(blendedColor, color10, smoothstep(0.8, 1.0, t));\n\n    return blendedColor;\n}\n\n\nvec3 sky(vec3 p)\n{\n    vec3 col;\n    col += vec3(ring(p, vec2(45, 60), 2.0))*abs(1.0-fractalWorley(p+100.0, 2, 2.,0.5));\n    col += pow(worley(p*2.0), 10.0)*0.3;\n    col *= (spaceyColors(col.x*2.0-0.5)*vec3(3.09, 2.0, 1.2)*2.0) + (sqrt(sqrt(spaceyColors(col.x*0.5))*vec3(1.0, 1.2, 1.5)));\n    col += pow(1.0-worley(p*20.0), 50.0);\n    //col=texture(iChannel0, p.yzx).xyz;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 blackHolePos = vec3(0, 5000, 0); // meters away\n    float gravity = 6.0*pow(10.0, 20.0); // mass in kg\n    float speedOfLight = 299792458.0; // speed of light in m/s\n    float simulationStep;\n    float dist = 0.0;\n    bool hit = false;\n    float power = 99999.0;\n    \n    ray ray = cam(vec3(0, clamp(iTime*200.0, -999999.0, blackHolePos.y), 0), vec2(iMouse.x/iResolution.x*720.0-360.0, iMouse.y/iResolution.y*180.0-90.0), 0.5, uv);\n    \n    while(power>1000.0 && !hit)\n    {\n        vec3 gravityDir = blackHolePos-ray.pos;\n        dist = length(gravityDir);\n        gravityDir/=dist;\n        simulationStep = dist*0.05/speedOfLight;\n        power = (gravity*gravitationalConst)/(dist*dist);\n        ray.dir = normalize(ray.dir+(gravityDir*power*simulationStep));\n        ray.pos+=ray.dir*speedOfLight*simulationStep;\n        hit = speedOfLight<power;\n    }\n    \n    \n\n    \n    vec3 col;\n    \n    if(hit)\n    {\n        col = vec3(0);\n    }\n    else\n    {\n        //col = vec3(pow(1.0-worley(ray.dir*20.0), 40.0));\n        col = sky(ray.dir);\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//----------------------------------------------------------------------------------------\n// 1 out 4 in...\nfloat hash14(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/McXGW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 170, 221, 221, 678], [680, 680, 701, 701, 807], [809, 809, 833, 833, 1339], [1341, 1341, 1363, 1363, 1877], [1879, 1879, 1958, 1958, 2371], [2373, 2373, 2423, 2423, 2606], [2609, 2609, 2637, 2666, 4187], [4190, 4190, 4208, 4208, 4579], [4581, 4581, 4638, 4638, 5854]], "test": "untested"}
{"id": "lflGRs", "name": "[steve] non-uniform camera ray", "author": "import_shader_steve", "description": "Slightly changed version of the basic raymarching shader by TheArtOfCode, but in this one, camera rays don't distribute evenly across the view plane, as illustrated by the makeCamera() function.", "tags": ["3d", "sdf", "editor"], "likes": 0, "viewed": 147, "published": 3, "date": "1703552828", "time_retrieved": "2024-07-30T17:14:38.457674", "image_code": "// Fork of \"[steve] SDF Editor\" by import_shader_steve. https://shadertoy.com/view/DsBXDc\n// 2023-12-24 05:15:06\n\n#define MAX_STEP 100\n#define SURF_DIST 0.01\n#define MAX_DIST 100.\n#define PI 3.14159\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdGround(vec3 p) {\n    return p.y;\n}\n\nfloat GetDist(vec3 p) {\n    vec3 pBox = vec3(0., 1., 6.);\n    float dBox = sdBox(p - pBox, vec3(1.));\n    vec3 pGround = vec3(0., 0., 3.);\n    float dGround = sdGround(p - pGround);\n    \n    float dScene = min(dBox, dGround);\n    return dScene;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    float d = GetDist(p);\n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n    return normalize(n);\n}\n\n// make a light above the sphere\nvec3 lightPos = vec3(2, 5, 1);\n\nfloat GetLight(vec3 p) {\n    //lightPos.xz = vec2(sin(iTime*2.), cos(iTime*2.)) * 5.;\n    vec3 lv = normalize(lightPos - p);\n    vec3 nv = GetNormal(p);\n    float rawLight = dot(lv, nv);\n    float finalLight = clamp(rawLight, 0., 1.);\n    return finalLight;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float d0 = 0.;\n    for (int i = 0; i < MAX_STEP; i++) {\n        vec3 p = ro + rd * d0;\n        float ds = GetDist(p);\n        d0 += ds;\n        if (ds < SURF_DIST || d0 > MAX_DIST) break;\n    }\n    return d0;\n}\n\nfloat GetShadow(vec3 p) {\n    vec3 rd = normalize(lightPos - p);\n    vec3 pOffset = p + GetNormal(p) * SURF_DIST * 2.;\n    float ds = RayMarch(pOffset, rd);\n    float dl = length(p - lightPos);\n    if (ds < dl) {\n        return 0.1;\n    } else {\n        return 1.;\n    }\n}\n\n// input camera position, lookAt point, & zoomFactor, output camera ray direction\nvec3 makeCamera(vec3 ro, vec3 lookAt, float zoomFactor, in vec2 uv, float power) {\n    // todo Steve: his is exactly like Ben's VirtualCamera.js lookAt matrix algorithm. Need to put these commonalities in the notebook. \n    // After all, a lookAt matrix is not hard at all to compute\n    vec3 fVect = normalize(lookAt - ro);\n    vec3 rVect = normalize(cross(vec3(0., 1., 0.), fVect));\n    vec3 uVect = normalize(cross(fVect, rVect));\n    // here we want to get it more twisted, as uv gets closer to -1 & 1\n    vec2 signUV = sign(uv);\n    // need an abs b/c we already extracted the signs w/ sign() funciton. We don't want to change sign here.\n    uv = signUV * pow(abs(uv), vec2(power));\n    // here zoomFactor need to be powered too, b/c all three directions need to be in the same scale, for the image to keep its zoom level\n    // but rd.x/y/z are not scaling at the same speed, b/c uv.x/y and zoomFactor are not of the same range, therefore even though power variable is the same, they can't be scaled at the same speed\n    // here through some hard-coded experiments, I secured some values to keep the visual zoom level the same:\n    // (power, powerFunc) needs to pass through these points: (0, -8.5), (1, 0.5)\n    float powerFunc = power * (8.5 - pow(2., 4. - power));\n    // logFunc = power * 0.5;\n    vec3 rd = normalize(uv.x * rVect + uv.y * uVect + pow(zoomFactor, powerFunc) * fVect);\n    return rd;\n    \n    // just messing around:\n    // uv = normalize(uv) + 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // todo Steve: here the uv ranges from [-1, 1]. Exactly the same as three js raymarching game YouTube (and also fragment shader?\n    // further figure out if this is the case. At least in three-js-screen-space-shader project, it is the case\n    // is this a coincidence? Key to unlock the relationship between the 2 methods mentioned in three js raymarching game yt tut is here\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.x; // ([-1, 1], [-9./16., 9./16.])\n    vec2 m = iMouse.xy/iResolution.xy; //[0, 1]\n    m = vec2(iTime * 0.08);\n    vec3 color = vec3(0.);\n    \n    vec3 lookAt = vec3(0., 1.5, 6.);\n    vec3 ro = lookAt + vec3( 4.5*cos(7.0*-m.x), 2.2, 4.5*sin(7.0*-m.x) );\n    // vec3 ro = lookAt + vec3( 4.5*cos(7.0*-1.), 2.2, 4.5*sin(7.0*-1.) );\n    // haven't taken into account the m.y\n    // maybe should normalize the two rotations in order to get rid of the weird \"zooming out\"\n    // effect in my previous \"Flappy Bird on a 3D Console\" code\n\n    // zoomFactor cannot be 1., b/c pow(zoomFactor, powerFunc) would have no effect\n    float zoomFactor = 0.9;\n    \n    float power = zigzag(iTime * 0.1) * 10.;\n    vec3 rd = makeCamera(ro, lookAt, zoomFactor, uv, power);\n    \n    float d = RayMarch(ro, rd);\n    if (d > MAX_DIST) {\n        color = backgroundColor;\n    } else {\n        vec3 p = ro + rd * d;\n        float l = GetLight(p) * GetShadow(p);\n        color += vec3(l);\n    }\n    \n    // color += grid3x3(uv, 0.001) * vec3(0., 1., 1.);\n    \n    \n    fragColor = vec4(color ,1.0);\n}", "image_inputs": [], "common_code": "const vec3 backgroundColor = vec3(1., 169./256., 20./256.);\n\nconst ivec2 txCameraPos = ivec2(31, 1);\n\nfloat grid3x3(vec2 uv, float thickness) {\n    if ( (uv.x > -1./3.-thickness && uv.x < -1./3.+thickness) || (uv.x > 1./3.-thickness && uv.x < 1./3.+thickness) ) {\n        return 1.;\n    } else {\n        return 0.;\n    }\n}\n\n// generate a zigzag pattern that oscillates between 0. and 1.\nfloat zigzag(float x) {\n    float modX = mod(x, 2.);\n    \n    if (modX < 1.) {\n        return fract(x);\n    } else {\n        return 1. - fract(x);\n    }\n}", "buffer_a_code": "vec4 loadValue( in ivec2 valueCoord )\n{\n    return texelFetch( iChannel0, valueCoord, 0 );\n}\n\nvoid storeValue( in ivec2 valueCoord, in vec4 value, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = ( valueCoord.x == fragCoord.x && valueCoord.y == fragCoord.y ) \n    ? value : fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lflGRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 200, 235, 235, 259], [261, 261, 292, 292, 379], [381, 381, 414, 414, 479], [481, 481, 505, 505, 523], [525, 525, 548, 548, 771], [773, 773, 797, 797, 987], [1054, 1054, 1078, 1139, 1313], [1315, 1315, 1349, 1349, 1564], [1566, 1566, 1591, 1591, 1838], [1840, 1922, 2004, 2205, 3400], [3402, 3402, 3459, 3841, 4981]], "test": "untested"}
{"id": "Mcf3Dj", "name": "FBM Voronoi", "author": "beans_please", "description": "i like voronoi", "tags": ["voronoi", "noise", "random", "worley", "cellular", "prng", "rng"], "likes": 2, "viewed": 188, "published": 3, "date": "1703544197", "time_retrieved": "2024-07-30T17:14:39.438053", "image_code": "vec2 screen_to_uv(vec2 coord)\n{\n    return 2. * (coord - .5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nfloat dist_sq(vec2 a, vec2 b)\n{\n    a -= b;\n    return dot(a, a);\n}\n\n// random offset for a sample point inside a cell\nvec2 cell_corner_offs(ivec2 icell, float cell_size)\n{\n    prng_init(uvec2(icell));\n    return cell_size * (vec2(random(), random()) - .5);\n}\n\nfloat voronoi(vec2 coord)\n{\n    const float cell_size = 1.;\n\n    // cell indices\n    ivec2 icell = ivec2(floor(coord / cell_size));\n    \n    // sample positions (bottom left, top left, etc.)\n    // p0 = center point of the current cell\n    vec2 p0 = (vec2(icell) + .5) * cell_size;\n    vec2 p1 = p0 + vec2(-cell_size, 0);\n    vec2 p2 = p0 + vec2(-cell_size, cell_size);\n    vec2 p3 = p0 + vec2(0, cell_size);\n    vec2 p4 = p0 + vec2(cell_size, cell_size);\n    vec2 p5 = p0 + vec2(cell_size, 0);\n    vec2 p6 = p0 + vec2(cell_size, -cell_size);\n    vec2 p7 = p0 + vec2(0, -cell_size);\n    vec2 p8 = p0 + vec2(-cell_size, -cell_size);\n    \n    // randomly offset the sample points\n    p0 += cell_corner_offs(icell, cell_size);\n    p1 += cell_corner_offs(icell + ivec2(-1, 0), cell_size);\n    p2 += cell_corner_offs(icell + ivec2(-1, 1), cell_size);\n    p3 += cell_corner_offs(icell + ivec2(0, 1), cell_size);\n    p4 += cell_corner_offs(icell + ivec2(1, 1), cell_size);\n    p5 += cell_corner_offs(icell + ivec2(1, 0), cell_size);\n    p6 += cell_corner_offs(icell + ivec2(1, -1), cell_size);\n    p7 += cell_corner_offs(icell + ivec2(0, -1), cell_size);\n    p8 += cell_corner_offs(icell + ivec2(-1, -1), cell_size);\n    \n    // smallest distance between coord and any of the sample points\n    float dist = 1e9;\n    dist = min(dist, dist_sq(coord, p0));\n    dist = min(dist, dist_sq(coord, p1));\n    dist = min(dist, dist_sq(coord, p2));\n    dist = min(dist, dist_sq(coord, p3));\n    dist = min(dist, dist_sq(coord, p4));\n    dist = min(dist, dist_sq(coord, p5));\n    dist = min(dist, dist_sq(coord, p6));\n    dist = min(dist, dist_sq(coord, p7));\n    dist = min(dist, dist_sq(coord, p8));\n    dist = sqrt(dist);\n    \n    // normalize the output in [0, 1] and return.\n    const float max_dist = 1.4142135624 * cell_size;\n    const float fac = 1. / max_dist;\n    return dist * fac;\n}\n\nfloat voronoi_fractal(\n    vec2 coord,\n    int depth,\n    float roughness,\n    float lacunarity\n)\n{\n    float v = 0.;\n    float sum_fac = 0.;\n    \n    for (int i = 0; i < depth; i++)\n    {\n        // factor (impact of the current layer)\n        float fac = 0.;\n        roughness = clamp(roughness, -1., 1.);\n        if (roughness < 0.)\n        {\n            // roughness [-1, 0) will go from fully smooth to normal\n            fac = pow(\n                lacunarity / max(roughness + 1., .0001),\n                float(-i)\n            );\n        }\n        else\n        {\n            // roughness [0, 1] will go from normal to fully rough\n            fac = pow(\n                mix(lacunarity, 1., roughness),\n                float(-i)\n            );\n        }\n        sum_fac += fac;\n        \n        // scale of the current layer\n        float scale = pow(lacunarity, float(i));\n        \n        // add sample\n        v += fac * voronoi(coord * scale);\n        \n        // translate the next layer\n        coord += 100.;\n    }\n    \n    return v / sum_fac;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec2 uv = screen_to_uv(frag_coord) + .2 * iTime;\n    \n    vec2 coord = 3. * uv;\n    int depth = 6;\n    float roughness = -cos(TAU * .08 *  iTime);\n    float lacunarity = 2.;\n    \n    vec3 col = vec3(voronoi_fractal(\n        coord,\n        depth,\n        roughness,\n        lacunarity\n    ));\n    \n    // Output\n    col = pow(col, vec3(1. / 2.2));\n    frag_col = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "/*_________________ Math Utils ________________*/\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T inp, float inp_start, float inp_end) \\\n{ \\\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nmat2 rotate_2d(float angle)\n{\n    return mat2(cos(angle), sin(angle), cos(angle + PI_OVER_2), sin(angle + PI_OVER_2));\n}\n\n/*____________________ End ____________________*/\n\n\n\n/*_______ Pseudo-Random Number Generator ______*/\n// Source: https://www.shadertoy.com/view/WdSSRt\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// Random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// Random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// Random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// Generate two normally distributed random numbers using the\n// Box-Muller Transform.\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // Unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_unit_vec2()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_unit_vec3()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\n// Initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// Initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// Initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// Initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// Initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n/*____________________ End ____________________*/\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mcf3Dj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 116], [118, 118, 149, 149, 185], [187, 237, 290, 290, 377], [379, 379, 406, 406, 2254], [2256, 2256, 2355, 2355, 3312], [3314, 3314, 3369, 3369, 3752]], "test": "untested"}
{"id": "lfXGW2", "name": "happy bouncing with antialiasing", "author": "janpitokiala", "description": "merry bouncing!", "tags": ["colorful", "animation"], "likes": 1, "viewed": 97, "published": 3, "date": "1703531272", "time_retrieved": "2024-07-30T17:14:40.343631", "image_code": "// Fork of \"happy bouncing\" by leon. https://shadertoy.com/view/flyXRh\n// 2021-12-22 00:11:16\n\n// \"happy bouncing\"\n// shader about boucing animation, space transformation, easing functions,\n// funny shape and colorful vibes.\n// by leon denise (2021-12-21)\n// licensed under hippie love conspiracy\n\n// using Inigo Quilez works:\n// arc sdf from https://www.shadertoy.com/view/wl23RK\n// color palette https://iquilezles.org/articles/palettes\n\n// global variable\nvec3 rng;\nfloat bodySize = 0.2;\n\n// shape eyes\nvec2 size = vec2(.07, .05);\nfloat divergence = 0.06;\n\n// easing curves are below\nfloat jump(float);\nfloat walk(float);\nfloat stretch(float);\nfloat bounce(float);\nfloat swing(float);\n\n// list of transformation (fun to tweak)\nvec2 animation(vec2 p, float t)\n{\n    t = fract(t);\n    \n    p.y -= bodySize-0.5;\n    p.y -= jump(t)*0.5;\n    //p.x += walk(t)*0.1;\n    p.x *= stretch(t)*-0.2+1.;\n    \n    // bounce stretch with collision\n    float b = bounce(t)*.2;\n    p.y *= b+1.;\n    p.y += abs(b)*bodySize;\n    \n    return p;\n}\n\nvoid mainImage( out vec4 color, in vec2 pixel )\n{\n    color = vec4(0,0,0,1);\n    \n    // number of friends\n    const float buddies = 3.;\n    for (float i = 0.; i < buddies; ++i)\n    {\n        // usefull to dissociate instances\n        float ii = i/(buddies-1.);\n        float iii = 1.-ii;\n        \n        // translate instances\n        vec2 pp = (pixel-0.5*iResolution.xy)/iResolution.y;\n        pp.x += (ii*2.-1.)*.4;\n        pp.y -= 0.1;\n        \n        // time\n        float t = fract(iTime*.5 + ii * .5);\n        \n        // there will be sdf shapes\n        float shape = 1000.;\n        vec2 p;\n        \n        // there will be layers\n        vec3 col = vec3(0);\n        \n        // color palette\n        // Inigo Quilez (https://iquilezles.org/articles/palettes)\n        vec3 tint = pow(.5+.5*cos(vec3(0.,.3,.6)*6.28+i-length(animation(pp-vec2(0,.1),t))*3.),vec3(2.2));\n        \n        // body shape\n        float body = circle(animation(pp, t), bodySize);\n        col += tint*fill(body);\n        shape = min(shape, body);\n\n        // eyes positions\n        p = animation(pp, t+0.02);\n        p *= rot(swing(t)*-.5);\n        p -= vec2(.03, bodySize+size.x*.2);\n        p.x = abs(p.x)-divergence;\n        \n        // globe shape\n        float eyes = circle(p, size.x);\n        shape = min(shape, eyes);\n        col = mix(col, tint, fill(eyes));\n        \n        // white eye shape\n        eyes = circle(p, size.y);\n        col = mix(col, vec3(1), fill(eyes));\n        shape = min(shape, eyes);\n        \n        // black dot shape\n        eyes = circle(p, 0.02);\n        col = mix(col, vec3(0), fill(eyes));\n        \n        // smile animation\n        float anim = cos(pow(t, .5)*6.28)*.5+.5;\n        \n        // smile position\n        p = animation(pp, t-0.02);\n        p *= rot(swing(t)*.5);\n        p -= bodySize*vec2(.4, 1.-1.5*anim);\n        \n        // arc (fun to tweak)\n        float smile = mix(0., 1., anim);//+(.5+.5*sin(ii*12.+iTime*12.*ii));\n        float thin = mix(0.1, 0.02, anim);//+0.04*(.5+.5*sin(ii*12.+iTime*22.*ii));\n        float d = sdArc(p,-3.14/2., smile, 0.1, thin);\n        \n        // mouth shape\n        d = d-mix(.01, .04, anim);\n        shape = min(shape, d);\n        col = mix(col, tint*(1.-p.x), fill(d));\n        \n        // black line\n        float offsetd = d+.05;\n        col = mix(col, tint*.2, fill(offsetd));\n        \n        // add color to frame\n        color.rgb = mix(color.rgb, col, fill(shape));\n    }\n    color = vec4(pow(color.rgb,vec3(0.45)),1.);\n}\n\n// easing curves (not easy to tweak)\n// affect timing of transformations;\n\nfloat jump (float t)\n{\n    t = min(1., t*4.);\n    t = abs(sin(t*3.1415));\n    return pow(sin(t*3.14/2.), 1.9);\n}\n\nfloat walk (float t)\n{\n    t = mix(pow(t,.5), pow(t, 2.0), t);\n    return (cos(t*3.1415*2.));\n}\n\nfloat swing (float t)\n{\n    t = pow(t, .5);\n    //t = t*2.;\n    //t = pow(t, .5);\n    t = sin(t*3.14*2.);\n    return t;\n}\n\nfloat stretch (float t)\n{\n    float tt = sin(pow(t, .2)*10.);\n    return tt;\n}\n\nfloat bounce (float t)\n{\n    float tt = cos(pow(t, .2)*6.38);\n    return tt;\n}", "image_inputs": [], "common_code": "\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdArc( in vec2 p, in float ta, in float tb, in float ra, float rb )\n{\n    vec2 sca = vec2(sin(ta),cos(ta));\n    vec2 scb = vec2(sin(tb),cos(tb));\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p,scb) : length(p);\n    return sqrt(abs( dot(p,p) + ra*ra - 2.0*ra*k )) - rb;\n}\n\n// snippets\n#define fill(sdf) (smoothstep(fwidth(sdf)/2., -fwidth(sdf)/2., sdf))\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat circle (vec2 p, float size)\n{\n    return length(p)-size;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lfXGW2.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[689, 730, 763, 763, 1028], [1030, 1030, 1079, 1079, 3535], [3612, 3612, 3634, 3634, 3724], [3726, 3726, 3748, 3748, 3821], [3823, 3823, 3846, 3846, 3944], [3946, 3946, 3971, 3971, 4024], [4026, 4026, 4050, 4050, 4104]], "test": "untested"}
{"id": "MfX3Dj", "name": "Trees and sky", "author": "OfficeBatman", "description": "Trying out some stuff", "tags": ["sdf"], "likes": 2, "viewed": 150, "published": 3, "date": "1703529051", "time_retrieved": "2024-07-30T17:14:41.395818", "image_code": "float bush(vec2 p) {\n    float k = 0.5;\n    float d = circle(p, .5);\n    // Add noise\n    d += mapRange(fbm(vec3(p, 0.)), 0., 1., -k, k * 0.2);\n    return d;\n}\n\nfloat tree(vec2 p) {\n    float k = 0.03;\n    float d = triangle(p, vec2(-.2, 0.), vec2(.2, 0.), vec2(0., .8));\n    d = min(d, triangle(p, vec2(-.25, -.5), vec2(.25, -.5), vec2(0., .2)));\n    // Add rounding\n    d -= .08;\n    // This allows the fbm noise in the next line to cut through the tree\n    d = max(d, -.08);\n    // Add noise\n    d += mapRange(fbm(vec3(p * 4., 0.)), 0., 1., -k, k);\n    d += mapRange(fbm(vec3(p * 4., 0.)), 0., 1., -.3, .2);\n    return sign(d) * pow(abs(d), .9);\n}\n\nfloat grassBlade(vec2 p, float k) {\n    p.x += 1.;\n    p *= rotate(-p.y * .28 * k);\n    p.x -= 1.;\n    return triangle(p, vec2(0), vec2(.1, 1.), vec2(.3, 0.));\n}\n\nfloat grass(vec2 p) {\n    float d = grassBlade(p, 1.);\n    d = min(d, grassBlade(p * vec2(-1., 1.) + vec2(.5, 0.), .3));\n    d = min(d, grassBlade(p * vec2(-1., 1.) + vec2(.7, 0.), .6));\n    return d;\n}\n\nfloat scene(vec2 p) {\n    float d = bush(p * .8 + vec2(1.4, 1.));\n    d = min(d, bush(2. * p + vec2(-2.8, 1.8)));\n    d = min(d, tree(p * rotate(-.2) + vec2(-.2, .6)));\n    d = min(d, grass(2. * (p + vec2(1.1, 1.)) * rotate(.4)));\n    return d;\n}\n\nconst vec3 sunColor = vec3(247, 197, 104) / 255.;\n\nvec4 bandColor(vec2 p) {\n    if (p.y < -.8) {\n        return vec4(232, 154, 81, 255) / 255.;\n    }\n    if (p.y < -.61) {\n        return vec4(232, 172, 81, 205) / 255.;\n    }\n    if (p.y < -.43) {\n        return vec4(247, 209, 84, 150) / 255.;\n    }\n    if (p.y < -.26) {\n        return vec4(247, 209, 84, 100) / 255.;\n    }\n    if (p.y < .1) {\n        return vec4(247, 209, 84, 30) / 255.;\n    }\n    return vec4(0);\n}\n\nvec3 skyColor(vec2 p) {\n    const vec3 bottom = vec3(74, 176, 207) / 255.;\n    const vec3 top = vec3(154, 222, 252) / 255.;\n    vec3 col = mapRange(p.y, -1., 1., bottom, top);\n    // Add bands\n    col = mix(col, bandColor(p).rgb, bandColor(p).a);\n    // Add pink gradient\n    vec3 pink = vec3(245, 161, 127) / 255.;\n    float t = pow(1.5 - abs(p.y + .25), 1.1);\n    t *= .38;\n    col = mix(col, pink, t);\n    return col;\n}\n\nvec3 color(vec2 p) {\n    float d = scene(p);\n    if (d <= 0.) {\n        vec3 col = vec3(58, 99, 90) / 255.;\n        d = abs(d);\n        // Shadow gradient\n        col *= mapRange(p.y, -1., 1., .2, 1.);\n        // Rim lighting\n        col += sunColor * mapRange(d*d, 0., .004, 2., 0.);\n        // Mix with background\n        float t = pow(mapRange(d*d, 0., .004, 1., 0.), 2.9);  \n        col = mix(col, skyColor(p), t);\n        return col;\n    }\n    return skyColor(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = UV_SCALED;\n    vec3 col = color(uv);\n    \n    // Antialias\n    for (int i = -1; i < 2; i++) for (int j = -1; j < 2; j++) {\n       vec2 offset = vec2(i, j) * .001;\n       col += color(uv + offset);\n    }\n    col *= .1;\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n#define IZERO (min(0, int(iTime)))\n#define FZERO (min(0., iTime))\n#define INF 1./FZERO\n\nfloat min_(float x1) {\n    return x1;\n}\n\nfloat min_(float x1, float x2) {\n    return min(x1, x2);\n}\n\nfloat min_(float x1, float x2, float x3) {\n    return min_(x1, min(x2, x3));\n}\n\nfloat min_(float x1, float x2, float x3, float x4) {\n    return min_(x1, x2, min(x3, x4));\n}\n\nfloat max_(float a) {\n    return a;\n}\n\nfloat max_(float a, float b) {\n    return max(a, b);\n}\n\nfloat max_(float a, float b, float c) {\n    return max(max(a, b), c);\n}\n\n#define CLAMP01(X) clamp((X), 0., 1.)\n\n// Vectors\n#define RIGHT vec3(1., 0., 0.)\n#define UP vec3(0., 1., 0.)\n#define FORWARD vec3(0., 0., 1.)\n#define ZERO vec3(0)\n\n// polynomial smooth min\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat mapRange(float x, float min1, float max1, float min2, float max2) {\n    return (clamp(x, min1, max1) - min1) * ((max2 - min2) / (max1 - min1)) + min2;\n}\n\nvec2 mapRange(float x, float min1, float max1, vec2 min2, vec2 max2) {\n    return mix(min2, max2, mapRange(x, min1, max1, 0., 1.));\n}\n\nvec3 mapRange(float x, float min1, float max1, vec3 min2, vec3 max2) {\n    return mix(min2, max2, mapRange(x, min1, max1, 0., 1.));\n}\n\n#define OP_SCALE(SDF, P, S) \\\n    SDF((P) / (S)) * (S)\n    \nmat2 rotate(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nmat3 rotateX(float a) {\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\nmat3 rotateY(float a) {\n    return mat3(\n        cos(a), 0., -sin(a),\n        0., 1., 0.,\n        sin(a), 0., cos(a)\n    );\n}\nmat3 rotateZ(float a) {\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n\n// Noise functions\n\nfloat hash2d(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash2d( ii + vec2(0.0,0.0) );\n\tfloat b = hash2d( ii + vec2(1.0,0.0) );    \n    float c = hash2d( ii + vec2(0.0,1.0) );\n\tfloat d = hash2d( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash2d( ii + vec2(0.0,0.0) );\n\tb = hash2d( ii + vec2(1.0,0.0) );    \n    c = hash2d( ii + vec2(0.0,1.0) );\n\td = hash2d( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\nfloat fbm(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<7; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\n// Sdf\n\n#define TOUCHING(SDF, POS) (abs(SDF((POS))) < E_SURF)\n#define INSIDE(SDF, POS) (SDF((POS)) < E_SURF)\n\nfloat sphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sphere(vec3 p) {\n    return sphere(p, 1.);\n}\n\nfloat box(vec3 p, vec3 b, float r) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat box(vec3 p, vec3 b) {\n    return box(p, b, 0.);\n}\n\nfloat box(vec3 p) {\n    return box(p, vec3(1));\n}\n\nfloat capsule(vec3 p, float r, float height) {\n    return length(p - (UP * clamp(p.y, r, height - r))) - r;\n}\n\nfloat plane(vec3 p) {\n\treturn p.y;\n}\n\nfloat cone(vec3 p, vec2 c, float h) {\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat roundCone(vec3 p, vec3 a, vec3 b, float r1, float r2) {\n  // sampling independent computations (only depend on shape)\n  vec3  ba = b - a;\n  float l2 = dot(ba,ba);\n  float rr = r1 - r2;\n  float a2 = l2 - rr*rr;\n  float il2 = 1.0/l2;\n    \n  // sampling dependant computations\n  vec3 pa = p - a;\n  float y = dot(pa,ba);\n  float z = y - l2;\n  float x2 = dot(pa*l2 - ba*y, pa*l2 - ba*y);\n  float y2 = y*y*l2;\n  float z2 = z*z*l2;\n\n  // single square root!\n  float k = sign(rr)*rr*rr*x2;\n  if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - r2;\n  if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - r1;\n                        return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat triangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat circle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n\n#define NORMAL_SAMPLE_R 0.01\n#define DEFINE_GET_NORMAL(scene) \\\n    vec3 getNormal(vec3 p) \\\n    { \\\n        return normalize(vec3( \\\n            scene(vec3(p.x + NORMAL_SAMPLE_R, p.y, p.z)) - scene(vec3(p.x - NORMAL_SAMPLE_R, p.y, p.z)), \\\n            scene(vec3(p.x, p.y + NORMAL_SAMPLE_R, p.z)) - scene(vec3(p.x, p.y - NORMAL_SAMPLE_R, p.z)), \\\n            scene(vec3(p.x, p.y, p.z + NORMAL_SAMPLE_R)) - scene(vec3(p.x, p.y, p.z - NORMAL_SAMPLE_R)) \\\n        )); \\\n    }\n\n// Main\n#define SCREEN_TO_SCALED(X) ((2. * (X) - iResolution.xy) / iResolution.yy)\n#define UV_SCALED SCREEN_TO_SCALED(fragCoord.xy)\n#define MOUSE_SCALED SCREEN_TO_SCALED(iMouse.xy)\n\n// parameters should be normalized\nmat3 camera(vec3 forward, vec3 globalUp) {\n    vec3 right = cross(forward, globalUp);\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MfX3Dj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 159], [161, 161, 181, 181, 650], [652, 652, 687, 687, 813], [815, 815, 836, 836, 1017], [1019, 1019, 1040, 1040, 1265], [1318, 1318, 1342, 1342, 1735], [1737, 1737, 1760, 1760, 2159], [2161, 2161, 2181, 2181, 2631], [2633, 2633, 2690, 2690, 2960]], "test": "untested"}
{"id": "Xcf3D2", "name": "Fork Simple 2D  OriginalSi 198", "author": "OriginalSin", "description": "2D Circle", "tags": ["2d", "circle"], "likes": 0, "viewed": 131, "published": 3, "date": "1703520220", "time_retrieved": "2024-07-30T17:14:42.415093", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat radius = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord.xy / vec2(radius, radius);\n\n    float dist = distance(vec2(0.9, 0.5), uv);\n    vec4 r = vec4(smoothstep(0.5, 0.51, 1.0 - dist), 0.0, 0.0, 0.0);\n    vec4 g = vec4(0.0, smoothstep(0.5, 0.51, 1.0 - dist), 0.0, 0.0);\n    vec4 b = vec4(0.0, 0.0, smoothstep(0.5, 0.51, 1.0 - dist), 0.0);\n    vec4 rings = b;\n    fragColor = rings;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xcf3D2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 459]], "test": "untested"}
{"id": "ddGBzt", "name": "My first attempt at a raymarcher", "author": "Monetenbube", "description": "features:\nspecular lighting\nsoft shadows\nsmooth min composition\nspatial repetition\n", "tags": ["raymarching"], "likes": 2, "viewed": 175, "published": 3, "date": "1703508040", "time_retrieved": "2024-07-30T17:14:43.563023", "image_code": "//Parts inspired by \n//https://michaelwalczyk.com/blog-ray-marching.html\n//https://iquilezles.org/articles/distfunctions/\n#define PI 3.1415926538\n\n\n#define MIN_D 0.001\n#define MAX_D 100.0\n#define MAX_I 1000\n#define SHADOW_SOFTNESS 0.9\n#define BG_C vec3(0.3, 0.8, 1.0)\n\n\n\n#define Sphere(x, y, z, r, cr, cg, cb) sdSphere(ray, vec3(x, y, z), r, vec3(cr, cg, cb))\n#define HPlane(h, cr, cg, cb) sdHPlane(ray, h, vec3(cr, cg, cb))\n#define MandelBulb(power, i, cr, cg, cb) sdMandelBulb(ray, power, i, vec3(cr, cg, cb))\n\n\nstruct MarchResult {\n    float d;\n    vec3 c;\n};\n\nvoid repeatXZ(inout vec3 ray, vec2 r) {\n    vec2 tmp = mod(ray.xz, r) - 0.5*r;\n\tray =  vec3(tmp.x, ray.y, tmp.y);\n}\nvoid repeatXYZ(inout vec3 ray, vec3 r) {\n    ray = mod(ray, r) - 0.5 * r;\n}\n\n\nMarchResult opU(MarchResult a, MarchResult b) {//Union\n    if (a.d < b.d) {\n        return a;\n    }\n    return b;\n}\n\nMarchResult opSU(MarchResult b, MarchResult a, float k) {//Smooth union\n    float smin = -log2(exp2( -k*a.d ) + exp2( -k*b.d ))/k;\n    \n    float t = clamp(b.d - a.d, -1.0, 1.0) / 2.0 + 0.5;\n    a.c = a.c * t + b.c * (1.0-t);\n    \n    a.d = smin;\n    return a;\n}\n\n\nMarchResult sdSphere(vec3 ray, vec3 p, float r, vec3 c) {\n    return MarchResult(distance(ray, p) - r, c);\n}\n\nMarchResult sdHPlane(vec3 ray, float h, vec3 c) {\n    return MarchResult(ray.y - h, c);\n}\n\nMarchResult sdMandelBulb(vec3 pos,float power, int max_i, vec3 c) {//Taken from http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < max_i ; i++) {\n\t\tr = length(z);\n\t\tif (r>4.0) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, power-1.0)*power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn MarchResult(0.5*log(r)*r/dr, c);\n}\n\nMarchResult sdScene(in vec3 ray) {\n    \n    //MarchResult p = HPlane(-3.0,    0.0, 1.0, 0.0);\n    \n    //repeatXYZ(ray, vec3(5.0, 5.0,  5.0));\n    /*\n    \n    return opSU(\n        Sphere(3.0*sin(iTime), -1.0, 5.0,    1.0,   1.0, 0.0, 0.0),\n        opSU(\n            Sphere(3.0*sin(iTime + PI * 2.0 / 3.0), -1.0, 5.0,    1.0,   0.0, 1.0, 0.0),\n            Sphere(3.0*sin(iTime + PI * 4.0 / 3.0), -1.0, 5.0,    1.0,   0.0, 0.0, 1.0),\n            8.0),\n        8.0\n    );*/\n    /*return opSU(\n        Sphere(0.0, -2.5, 0.0, 1.0,    1.0, 0.0, 0.0),\n        p,\n        5.0\n    );*/\n    return MandelBulb(8.0,min(10, int(iTime/10.0 + 3.0)), 1.0, 1.0, 1.0);\n    \n}\n\nvec3 calculate_normal(vec3 p) {\n    const vec3 s = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = sdScene(p + s.xyy).d - sdScene(p - s.xyy).d;\n    float gradient_y = sdScene(p + s.yxy).d - sdScene(p - s.yxy).d;\n    float gradient_z = sdScene(p + s.yyx).d - sdScene(p - s.yyx).d;\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    return normalize(normal);\n}   \n\n\nMarchResult marchRay(vec3 ray, vec3 rd) {\n    \n    for (int i = 0; i < MAX_I; i++) {\n        MarchResult res = sdScene(ray);\n        if (res.d > MAX_D) {\n            res.c = BG_C;\n            return res;\n        }\n        else if (res.d < MIN_D) {//hit \n        \n            vec3 light_position = vec3(5.0, 5.0, 5.0);\n            //light_position.x += iTime*10.0;\n            //light_position.z += iTime*2.0;\n            vec3 dir_to_light = normalize(light_position - ray);\n        \n            //Specular lighting\n            vec3 normal = calculate_normal(ray);\n            float diffuse_intensity = max(0.3, dot(normal, dir_to_light));\n            res.c *= diffuse_intensity;\n            \n            //Shadows\n            MarchResult closest = MarchResult(MAX_D, vec3(0.0));\n            ray += dir_to_light * SHADOW_SOFTNESS;\n            for (int j = 0; j < MAX_I; j++) {\n                MarchResult sres = sdScene(ray);\n                if (sres.d < closest.d) {closest = sres;}\n                if (sres.d > MAX_D) {\n                    break;\n                }\n                else if (res.d < MIN_D) {\n                    break;\n                }\n                ray += dir_to_light * sres.d;\n            }\n            float shadow_intensity = closest.d / SHADOW_SOFTNESS;\n            res.c *= shadow_intensity;\n            \n            \n            return res;\n        }\n        else {\n            ray += rd * res.d;\n        }\n    }\n    return MarchResult(MAX_D, BG_C);\n    \n    \n\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n\n    \n    vec3 ro = vec3(cos(iTime/2.0) * 2.5, -sin(iTime/2.0) * 2.5, sin(iTime/2.0) * 2.5);//ray origin(Camera position)\n\n    vec3 ta = vec3(0.0);//What the camera looks at(target)\n    //Camera rotation matrix\n    vec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(0.0), cos(0.0),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    mat3 camera_matrix =  mat3( cu, cv, cw );\n    \n    vec3 rd = camera_matrix * normalize(vec3(uv.x, uv.y * iResolution.y / iResolution.x, 1.0));//ray direction\n    MarchResult res = marchRay(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(res.c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddGBzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[564, 564, 603, 603, 679], [680, 680, 720, 720, 755], [758, 758, 805, 812, 873], [875, 875, 932, 946, 1137], [1140, 1140, 1197, 1197, 1248], [1250, 1250, 1299, 1299, 1339], [1341, 1341, 1408, 1543, 2078], [2080, 2080, 2114, 2656, 2737], [2739, 2739, 2770, 2770, 3110], [3116, 3116, 3157, 3157, 4605], [4608, 4608, 4662, 4713, 5387]], "test": "untested"}
{"id": "XffGDj", "name": "The Line ", "author": "Oztaquio", "description": "My first shader, very simple, but I still like how it turned out", "tags": ["2d", "glow", "loop"], "likes": 3, "viewed": 181, "published": 3, "date": "1703505891", "time_retrieved": "2024-07-30T17:14:44.923386", "image_code": "vec3 colorA = vec3(0.0, 1.0, 0.0);\nvec3 colorB = vec3(1.0, 0.0, 0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.5;\n    float aspect = iResolution.x/iResolution.y;\n    \n    vec2 uv = fragCoord/iResolution.xy*2.0 - 1.0;\n    uv.x *= aspect;\n    \n    float d = uv.x;\n    d *= sin(-d*4.0 + time);\n    d = abs(d);\n    d = 0.05 / d;\n    \n    vec3 col = vec3(0.0);\n    float inpol = abs(sin(time));\n    \n    col = mix(colorA, colorB, inpol);\n    col += smoothstep(d, 0.1, 0.1);\n\n    col *= d;\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XffGDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 128, 128, 565]], "test": "untested"}
{"id": "Dts3R2", "name": "Christmas Tree 2023", "author": "piyushslayer", "description": "A simple Christmas Tree made from 2D points. ", "tags": ["2d", "christmas", "sdf", "points"], "likes": 50, "viewed": 1825, "published": 3, "date": "1703442664", "time_retrieved": "2024-07-30T17:14:45.946650", "image_code": "/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* A simple christmas tree made from 2D points.\n*\n*/\n\n#define PI 3.1415926535\n#define TAU 6.2831853071\n#define ROTATE(v, x) mat2(cos(x), sin(x), -sin(x), cos(x)) * v\n#define REMAP_HALF_NDC(x, c, d) (((x + 0.5) * (d - c)) + c) // Remap from [-0.5, 0.5] domain to [c, d]\n\n#define N 512.0\n#define N_ONE_QUARTER N * 0.25\n// This is mostly to cull any points at the bottom that are too close to the \"camera\".\n#define N_OFFSET 1.0\n#define STAR_N 7.0\n#define STAR_BEAM_THICKNESS 3.0\n\nconst vec3 LIGHT_COLORS[3] = vec3[3](\n                                        vec3(1.0,  0.05,  0.05), \n                                        vec3(0.05, 1.0,   0.05), \n                                        vec3(1.0,  0.25,  0.05)\n                                    );\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 Hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\n\n// Signed distance to an n-star polygon with external angle en by iq: https://www.shadertoy.com/view/3tSGDy\nfloat SignedDistanceNStar2D(in vec2 p, in float r, in float an, in float bn, in vec2 acs, in float m) // m=[2,n]\n{\n    float en = PI / m;\n    vec2  ecs = vec2(cos(en), sin(en));\n    p = length(p) * vec2(cos(bn), abs(sin(bn)));\n\n    p -= r * acs;\n    p += ecs * clamp(-dot(p, ecs), 0.0, r * acs.y / ecs.y);\n    return length(p) * sign(p.x);\n}\n\nvoid DrawStar(in vec2 uv, in float time, inout vec3 outColor)\n{\n    uv -= vec2(0.001, 0.225);\n    uv = ROTATE(uv, time * 0.75);\n    // Some common pre-calculation in order to avoid duplication\n    float an = PI / STAR_N;\n    float bn = mod(atan(uv.x, uv.y), 2.0 * an) - an;\n    vec2 acs = vec2(cos(an), sin(an));\n    // Top star\n    outColor += 5e-4 / pow(abs(SignedDistanceNStar2D(uv, 0.01, an, bn, acs, STAR_N * 0.5)), 1.23) * LIGHT_COLORS[2];\n    // Star beams\n    outColor += smoothstep(STAR_BEAM_THICKNESS / max(iResolution.x, iResolution.y), 0.0, SignedDistanceNStar2D(uv, 1.5, an, bn, acs, STAR_N)) * \n        LIGHT_COLORS[2] * smoothstep(0.75, -5.0, length(uv));\n}\n\nvoid DrawTree(in vec2 uv, in float time, inout vec3 outColor)\n{\n    float u, theta, pointHeight, invN = 1.0 / N;\n    vec2 st, hash, layer;\n    vec3 pointOnCone, pointColor = vec3(1.0);\n    const vec2 radius = vec2(1.5, 3.2);\n    uvec3 colorThreshold;\n    for (float i = N_OFFSET; i < N; ++i)\n    {\n        // Modify this to change the tree pattern\n        hash = Hash21(2.0 * TAU * i);\n        \n        // Some basic light color based on hash\n        colorThreshold.x = uint(hash.x < 0.45); // red;\n        colorThreshold.y = 1u - colorThreshold.x; // green\n        colorThreshold.z = uint(hash.x > 0.9); // white;\n        pointColor = vec3(colorThreshold | colorThreshold.z);\n        \n        // Calculate point on cone based on: https://mathworld.wolfram.com/Cone.html\n        u = i * invN;\n        theta = 1609.0 * hash.x + time * 0.5;\n        pointHeight = 1.0 - u;\n        \n        // Split the cone into layers to make it look more like a christmas tree\n        layer = vec2(3.2 * mod(i, N_ONE_QUARTER) * invN, 0.0);\n        pointOnCone = 0.5 * (radius.xyx - layer.xyx) * vec3(pointHeight * cos(theta), u - 0.5, pointHeight * sin(theta)); // [-0.5, 0.5]\n        \n        // Scale uv based on depth of the point\n        st = uv * (REMAP_HALF_NDC(pointOnCone.z, 0.5, 1.0) + hash.y) * 4.5;\n        \n        // outColor += smoothstep(0.01, 0.0, length(st - pointOnCone.xy));\n        outColor += REMAP_HALF_NDC(pointOnCone.z, 3.0, 0.6) * // Slightly adjust the size of the point based on distance to \"camera\" \n            2e-5 / pow(length(st - pointOnCone.xy), 1.7) * pointColor;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y; // [-0.5, 0.5] adjusted for aspect ratio\n    vec3 outColor = vec3(0.005, 0.01, 0.03); // Background color\n    vec4 m = iMouse / iResolution.yyyy;\n    float t = 0.0;\n    \n    if (m.z > 0.0)\n    {\n        t = m.x * TAU;\n    }\n    else\n    {\n        t = iTime * 0.5;\n    }\n    \n    DrawTree(uv, t, outColor);\n    DrawStar(uv, t, outColor);\n    \n    float vignette = dot(uv, uv);\n    vignette *= vignette;\n    vignette = 1.0 / (vignette * vignette + 1.0);\n    \n    fragColor = vec4(pow(outColor * vignette, vec3(0.4545)), 1.0) - Hash12(fragCoord.xy * t + iResolution.yy) * 0.04;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dts3R2.jpg", "access": "api", "license": "cc0-1.0", "functions": [[800, 841, 863, 863, 980], [982, 982, 1004, 1004, 1137], [1139, 1247, 1361, 1361, 1588], [1590, 1590, 1653, 1653, 2262], [2264, 2264, 2327, 2327, 3853], [3855, 3855, 3912, 3912, 4555]], "test": "untested"}
{"id": "XcX3DB", "name": "Hyperbolic Weave", "author": "mla", "description": "Weaving patterns in hyperbolic tilings. A nice decoration for the festive season.\n\nMouse rotates, see code for other controls.", "tags": ["hyperbolic", "weave"], "likes": 22, "viewed": 318, "published": 3, "date": "1703437899", "time_retrieved": "2024-07-30T17:14:46.724571", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Hyperbolic Weave, mla, 2023.\n//\n// First attempt at a generic weave pattern for hyperbolic tilings.\n//\n// c: don't colour tiles\n// d: don't shade area outside disc\n// h: half space projection\n// w: hide weave\n// x: show single tile\n// z: zoom in (only in half space projection)\n//\n// Most of the calculations are done in the hyperboloid model, with\n// the Poincare disc used for folding into the fundamental region.\n// The tile colouring doesn't always work properly.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int N = 3;\nivec3 angles = ivec3(2,3,7);\nfloat lwidth = 0.07;\nbool doubleup = true;\nvoid config(int i) {\n  i %= 6;\n  if (i == 0) { angles = ivec3(2,3,7); lwidth = 0.07; }\n  if (i == 1) { angles = ivec3(2,7,3); lwidth = 0.11; }\n  if (i == 2) { angles = ivec3(2,4,5); lwidth = 0.09; }\n  if (i == 3) { angles = ivec3(5,3,3); lwidth = 0.09; }\n  if (i == 4) { angles = ivec3(4,4,4); lwidth = 0.15; }\n  if (i == 5) { angles = ivec3(3,4,5); lwidth = 0.12; }\n  doubleup = angles[0] == 2;\n}\n\n#define configmode (key(CHAR_X))\n\nvec2 getselection(int i) {\n  if (configmode && iMouse.x > 0.0) return (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  return vec2(0.8,0.7);\n}\n\nvec2 defaultselection() {\n  if (iMouse.x > 0.0) return (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  return vec2(0);\n}\n\n// Basic operations for hyperbolic (Minkowski) space\n// Inner product\nfloat hdot(vec3 p, vec3 q) {\n  return dot(vec3(1,1,-1)*p,q);\n}\n\nvec3 hcross(vec3 p, vec3 q) {\n  // hdot(p,hcross(p,q)) = hdot(q,hcross(p,q)) = 0\n  return cross(p,q)*vec3(1,1,-1);\n}\n\nfloat hnorm(vec3 p) {\n  return hdot(p,p);\n}\n\nfloat hlength(vec3 p) {\n  return sqrt(abs(hnorm(p)));\n}\n\n// Normalize a point or a line\nvec3 hnormalize(vec3 p) {\n  float t = hnorm(p);\n  if (t < 0.0 && p.z < 0.0) p = -p;\n  return p/sqrt(abs(t));\n}\n\n// Now redundant\nvec3 pnormalize(vec3 p) {\n  if (p.z < 0.0) p = -p;\n  return hnormalize(p);\n}\n\n// Map point on plane to hyperboloid hnorm(p) = -1\nvec3 unproject(vec2 z) {\n  // kÂ²|z|Â²-(1-k)Â² = -1\n  // kÂ²|z|Â²-1+2k-kÂ² = -1\n  // k|z|Â²+2-k = 0\n  float k = 2.0/(1.0-dot(z,z));\n  return vec3(k*z,k-1.0);\n}\n\n// NB: sinh(x) = asinh(x) = tanh(x) = x (approximately) for\n// small values of x (eg. sinh 0.1 = 0.10017, tanh 0.1 = 0.0997)\n// Hyperbolic distance from line\nfloat hline(vec3 p, vec3 l) {\n  return abs(asinh(hdot(p,l)));\n}\n\n// Hyperbolic distance between points\nfloat hpoint(vec3 p, vec3 q) {\n  //return acosh(-hdot(p,q)); // Bad truncation error\n  return 2.0*abs(asinh(0.5*hlength(p-q)));\n}\n\n// Reflect in a hyperbolic line\nint tryreflect(vec3 l, int i, inout vec3 p, inout uint h) {\n  float k = hdot(p,l);\n  if (k > 0.0) return 0;\n  p -= 2.0*k*l;\n  h = ihash(h^uint(i));\n  return 1;\n}\n\n// Reflect in a euclidean line\nint tryreflect(vec2 l, int i, inout vec2 z, inout uint h) {\n  float k = dot(z,l);\n  if (k > 0.0) return 0;\n  z -= 2.0*k*l;\n  h = ihash(h^uint(i));\n  return 1;\n}\n\n// Invert in a euclidean circle\nint tryinvert(vec3 c, int i, inout vec2 z, inout uint h) {\n  float r2 = c.z;\n  vec2 z1 = z-c.xy;\n  float l2 = dot(z1,z1);\n  if (l2 > r2) return 0;\n  z1 *= r2/l2;\n  z = z1+c.xy;\n  h = ihash(h^uint(i));\n  return 1;\n}\n\n// Convert hyperbolic line into a Euclidean circle.\n// z component is square of radius.\nvec3 tocircle(vec3 l) {\n  assert(l.z != 0.0);\n  l /= l.z;\n  l.z = dot(l.xy,l.xy)-1.0;\n  return l;\n}\n\n// Convert hyperbolic line into a Euclidean line.\nvec2 toline(vec3 l) {\n  assert(l.z == 0.0);\n  return l.xy;\n}\n\nvec3 fold(vec2 z, int nfolds, mat3 edges, inout uint h, inout int parity) {\n  // Using Poincare model for the fold seems to be more stable\n  // so convert hyperbolic lines to Euclidean lines or circles\n  vec3 a = tocircle(edges[0]);\n  vec3 a1 = a*vec3(-1,1,1);\n  vec2 b = toline(edges[1]);\n  vec2 c = toline(edges[2]);\n  for (int step = 0; step < nfolds; step++) {\n    int k = 0;\n    uint h0;\n    k += tryinvert(a,0,z,h);\n    k += tryinvert(a1,1,z,h);\n    k += tryreflect(b,2,z,h);\n    if (k == 1 || k == 3) z.x = -z.x; // Keep chirality\n    if (k == 0) break;\n    parity += k;\n  }\n  return unproject(z);\n}\n\nvec3 hfold(vec2 z, int nsteps, mat3 edges, inout uint h, inout int parity) {\n  // Neat, but errors accumulate much more quickly\n  vec3 p = unproject(z);\n  for (int step = 0; step < nsteps; step++) {\n    int k = 0;\n    for (int i = 0; i < N; i++) {\n      k += tryreflect(edges[i],i,p,h);\n    }\n    if (k == 0) break;\n    parity += k;\n  }\n  return p;\n}\n\nvec3 absx(vec3 p) {\n  p.x = abs(p.x);\n  return p;\n}\n\n// Construct the sides of a hyperbolic triangle, for\n// p,q,r the cosines of the dihedral angles.\n// b.c = -p, c.a = -q, a.b = -r.\n// (Side a is opposite point A at (0,0,1) etc.)\n// These are normals so that side c is the y-axis, etc.\n// Ensure everthing is properly (h)normalized.\nmat3 triangle(float p, float q, float r) {\n  vec3 c = vec3(1,0,0);\n  vec3 b = vec3(-p,sqrt(1.0-p*p),0);\n  // a = (x,y,z):\n  // a.c = -r -> x = -r\n  // a.b = -q = -r*-p + y*b.y = -q\n  // xÂ²+yÂ²-zÂ² = 1\n  float x = -r, y = -(q+p*r)/b.y, z = -sqrt(x*x+y*y-1.0);\n  vec3 a = vec3(x,y,z);\n  return mat3(a,b,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  config(int(iTime));\n  mat3 edges = triangle(icos(angles[0]),icos(angles[1]),icos(angles[2]));\n  mat3 points = mat3(vec3(0,0,1),\n                     hnormalize(hcross(edges[2],edges[0])),\n                     hnormalize(hcross(edges[0],edges[1])));\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      // Check incidence relation\n      assert(eq(hdot(points[i],edges[j]),0.0) == (i != j));\n    }\n  }\n  assert(eq(hdot(points[0],edges[1]),0.0));\n  vec2 z = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  vec2 w = vec2(0);\n  if (!configmode) w = defaultselection();\n  \n  float px = fwidth(z.x);\n  bool dohalfplane = key(CHAR_H);\n  bool dozoom = key(CHAR_Z);\n  if (dohalfplane) z.y += 1.0;\n  // Conversion factor between hyperbolic and screen distances\n  float scalefactor = 1.0;\n  if (dohalfplane) {\n    if (dozoom) {\n      float k = exp(-iTime);\n      z *= k;\n      scalefactor /= k;\n    }\n    z.y += 1.0;\n    float k = 2.0/dot(z,z);\n    z *= k;\n    scalefactor /= k;\n    z.y -= 1.0;\n  }\n  scalefactor *= 0.5*abs(1.0 - dot(z,z));\n  if (!configmode) {\n    // Invert to mouse position\n    vec2 c = w;\n    z -= c;\n    z *= (dot(c,c)-1.0)/dot(z,z);\n    z += c;\n    z /= -dot(z,z);\n  }\n  px /= scalefactor;\n  bool indisc = dot(z,z) <= 1.0;\n  if (!indisc) z /= dot(z,z);\n  int nfolds = configmode ? 0 : 20;\n  uint h = 12345678u; // hash for region\n  int flips = 0;\n  vec3 p = (doubleup) ? fold(z,nfolds,edges,h,flips) : hfold(z,nfolds,edges,h,flips);\n  bool parity = flips%2 == 1;\n  //p.x = abs(p.x);\n  vec3 col = vec3(1,1,0.5);\n  if (!configmode && !key(CHAR_C)) col = h2rgb(float(h)/exp2(32.0));\n  //if (parity) col *= 0.5;\n  vec3 lcol = vec3(0.2);\n  {\n    float t = 1e8;\n    for (int i = 0; i < N; i++) {\n      if (doubleup && i == 2) continue;\n      t = min(t,hline(absx(p),edges[i]));\n    }\n    col = mix(lcol,col,smoothstep(0.0,px,abs(t)));\n  }\n  if (!key(CHAR_W)) {\n    vec3 xflip = vec3(-1,1,1);\n    vec3 A = points[0], B = points[1], C = points[2];\n    vec3 a = edges[0], b = edges[1], c = edges[2];\n    vec3 lines[3];\n    if (doubleup) {\n      vec3 a1 = xflip*a;\n      vec3 d = hcross(C,a1); // Altitude\n      vec3 D = hcross(d,a1); // Foot of altitude\n      vec3 D1 = xflip*D;\n      vec3 f = hnormalize(hcross(A,D)); // Left side of orthic\n      vec3 f1 = xflip*f; // Right side of orthic\n      vec3 g = hnormalize(hcross(D,D1)); // Top side of orthic\n      lines = vec3[](f,f1,g);\n    } else {\n      vec3 d = hcross(A,a); // Altitudes\n      vec3 e = hcross(B,b);\n      vec3 f = hcross(C,c);\n      vec3 D = hcross(a,d);\n      vec3 E = hcross(b,e);\n      vec3 F = hcross(c,f);\n      vec3 g = hnormalize(hcross(D,E));\n      vec3 h = hnormalize(hcross(E,F));\n      vec3 i = hnormalize(hcross(F,D));\n      lines = vec3[](h,g,i);\n      if (parity) lines = vec3[](i,g,h);\n    }\n    float t = 1e8; int imin = -1;\n    for (int i = 0; i < lines.length(); i++) {\n      float t = hline(p,lines[i]);\n      //0 beats 1, 1 beats 2, 2 beats 0\n      bool draw = false;\n      if (t < lwidth+px) {\n        if (imin < 0 || i == 0) { draw = true; imin = i; }\n        else if (i == 2 && imin == 0) { draw = true; imin = i; }\n      }\n      if (draw) {\n        col = mix(lcol,col,smoothstep(0.0,px,t - lwidth));\n        col = mix(vec3(1),col,smoothstep(0.0,px,abs(t - lwidth)));\n      }\n    }\n  }  \n  if (!key(CHAR_D) && !indisc) col *= 0.0;\n  col = pow(col,vec3(0.4545));\n  if (!key(CHAR_A) && alert) col.r = 1.0;\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define map(screenpos) ((2.0*(screenpos)-iResolution.xy)/iResolution.y)\n\nconst float PI = 3.141592654;\nconst float TWOPI = 2.0*PI;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n// const int KEY_SHIFT = 16;\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\n// const int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\n// const int CHAR_K = 75;\nconst int CHAR_L = 76;\n//const int CHAR_M = 77;\nconst int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\n// const int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\n// const int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n\nvec2 expi(float t) {\n  return normalize(vec2(cos(t),sin(t)));\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nbool eq(float a, float b) {\n  return abs(a-b) < 1e-4;\n}\n\nfloat COS[] =\n  float[](1.0,-1.0,0.0,0.5,0.7071067812,0.8090169944,0.8660254038,\n          0.9009688679,0.9238795325,0.9396926208,0.9510565163,0.9594929736,\n          0.9659258263,0.9709418174,0.9749279122,0.9781476007,0.9807852804,\n          0.9829730997,0.984807753,0.9863613034,0.9876883406,0.9888308262,\n          0.9898214419,0.990685946,0.9914448614,0.9921147013,0.9927088741,\n          0.9932383577,0.9937122099,0.9941379572,0.9945218954,0.9948693234);\n\nfloat icos(int p) {\n  // cos(PI/p)\n  if (p < COS.length()) return COS[p];\n  return cos(PI/float(p));\n}\n                        \nfloat isin(int p) {\n  // sin(PI/p)\n  float t = icos(p);\n  return sqrt(1.0-t*t);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XcX3DB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[729, 729, 749, 749, 1126], [1162, 1162, 1188, 1188, 1303], [1305, 1305, 1330, 1330, 1425], [1427, 1497, 1525, 1525, 1559], [1561, 1561, 1590, 1641, 1677], [1679, 1679, 1700, 1700, 1722], [1724, 1724, 1747, 1747, 1779], [1781, 1812, 1837, 1837, 1922], [1924, 1941, 1966, 1966, 2017], [2019, 2070, 2094, 2169, 2229], [2231, 2389, 2418, 2418, 2452], [2454, 2492, 2522, 2576, 2621], [2623, 2655, 2714, 2714, 2816], [2818, 2849, 2908, 2908, 3009], [3011, 3043, 3101, 3101, 3257], [3259, 3347, 3370, 3370, 3446], [3448, 3498, 3519, 3519, 3558], [3560, 3560, 3635, 3761, 4166], [4168, 4168, 4244, 4295, 4518], [4520, 4520, 4539, 4539, 4571], [4573, 4855, 4897, 4897, 5162]], "test": "untested"}
{"id": "McfGWS", "name": "Mathematical pendulum", "author": "FordPerfect", "description": "Mathematical pendulum: exact solution (green) vs. small-angle approximation (gray).", "tags": ["integral", "pendulum", "elliptic", "jacobi"], "likes": 3, "viewed": 166, "published": 3, "date": "1703429206", "time_retrieved": "2024-07-30T17:14:47.474566", "image_code": "// Public Domain under http://unlicense.org, see link for details.\n\n// See https://en.wikipedia.org/wiki/Pendulum_(mechanics)\n\nconst float pi=3.14159265358979323846;\n\n// Complete elliptic integral of the 1st kind.\n// Accuracy: error is less than 4 ulp on [0;1)\n// in float32.\n// NOTE: this produces K(1)=NaN (same as\n// std::comp_ellint_1(1.0) in C++) even though\n// K(1)=inf seems reasonable.\nfloat K(float k)\n{\n    k=abs(k);\n    if(k<0.9765625)\n    {\n        // Arithmetic-geometric mean approach.\n        float a=1.0,b=sqrt(1.0-k*k);\n        for(int i=0;i<4;++i)\n        {\n            float an=0.5*(a+b);\n            float bn=sqrt(a*b);\n            a=an;\n            b=bn;\n        }\n        return pi/(2.0*a);\n    }\n    else\n    {\n        // Series expansion at k=1.\n        // K(1-x) = -1/2 log(x/8) + 1/4 (-log(x) + log(8) - 1) x + 1/32 (-5 log(x) + 15 log(2) - 7) x^2 + 1/192 (-21 log(x) + 63 log(2) - 34) x^3 + ...\n        float x=1.0f-k,y=log(x);\n        return (1.03972077084-0.5*y)\n            +x*(0.26986038542-0.25*y\n            +x*(0.10616274088-0.15625*y\n            +x*(0.05035558528-0.109375*y)));\n    }\n}\n\n// Jacobi elliptic amplitude.\n// Assumes range-reduced argument (accuracy worsens for |u|>4*K(k)).\n// Accuracy not tested much.\nfloat am(float u,float k)\n{\n    // Arithmetic-geometric mean approach.\n    float a0=1.0,b0=sqrt(1.0-k*k)/*,c0=sqrt(1.0-b0*b0)*/;\n    float a1=0.5*(a0+b0),  b1=sqrt(a0*b0),  c1=0.5*(a0-b0);\n    float a2=0.5*(a1+b1),  b2=sqrt(a1*b1),  c2=0.5*(a1-b1);\n    float a3=0.5*(a2+b2),  b3=sqrt(a2*b2),  c3=0.5*(a2-b2);\n    float a4=0.5*(a3+b3),/*b4=sqrt(a3*b3),*/c4=0.5*(a3-b3);\n    float phi4=16.0*a4*u;\n    float phi3=0.5*(phi4+asin((c4/a4)*sin(phi4)));\n    float phi2=0.5*(phi3+asin((c3/a3)*sin(phi3)));\n    float phi1=0.5*(phi2+asin((c2/a2)*sin(phi2)));\n    float phi0=0.5*(phi1+asin((c1/a1)*sin(phi1)));\n    return phi0;\n}\n\n// Jacobi elliptic cd(u;k) function.\n// Accuracy not tested much.\nfloat cd(float u,float k)\n{\n    // Range reduction.\n    // Easy to reduce to quarter-period ([0;K]) with\n    // several cases, but let's just reduce to full period.\n    u=mod(u,4.0*K(k));\n    float a=am(u,k),sn=sin(a),cn=cos(a),dn=sqrt(1.0-k*k*sn*sn);\n    return cn/dn;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 xy=(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float A0=pi/2.0;\n    float w=1.0;\n    vec2 O=vec2(0.0,1.0);\n    vec3 col=vec3(0.25);\n    if(true) // Exact solution.\n    {\n        float k=sin(A0/2.0);\n        float theta=2.0*asin(k*cd(w*iTime,k));\n        vec2 P=O+vec2(sin(theta),-cos(theta));\n        float a=smoothstep(0.05,0.04,length(xy-P))+\n            smoothstep(0.01,0.00,abs(dot(P-O,vec2(xy.y-O.y,O.x-xy.x))))*smoothstep(1.01,0.99,length(xy-O));\n        col+=vec3(0.25,0.625,0.25)*clamp(a,0.0,1.0);\n    }\n    if(true) // Small-angle approximation.\n    {\n        float theta=A0*cos(w*iTime);\n        vec2 P=O+vec2(sin(theta),-cos(theta));\n        float a=smoothstep(0.05,0.04,length(xy-P))+\n            smoothstep(0.01,0.00,abs(dot(P-O,vec2(xy.y-O.y,O.x-xy.x))))*smoothstep(1.01,0.99,length(xy-O));\n        col+=vec3(0.5,0.5,0.5)*clamp(a,0.0,1.0);\n    }\n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/McfGWS.jpg", "access": "api", "license": "public-domain", "functions": [[167, 394, 412, 412, 1121], [1123, 1251, 1278, 1321, 1868], [1870, 1936, 1963, 2100, 2207], [2209, 2209, 2263, 2263, 3169]], "test": "untested"}
{"id": "4cX3WS", "name": "Cloudish Featherly Spiralum", "author": "leon", "description": "the kind of shapes I like, a bit baroquish", "tags": ["weird"], "likes": 34, "viewed": 433, "published": 3, "date": "1703412753", "time_retrieved": "2024-07-30T17:14:48.480875", "image_code": "\n// Cloudish Featherly Spiralum\n// fork of Flamished Fractalited Formings\n// https://www.shadertoy.com/view/4cs3Rs\n// leon denise 2023-12-25\n\n// render pass\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 map = texture(iChannel0, uv);\n    \n    // dim \n    map.r -= 0.2;\n    \n    // blured normal\n    #define T(u) textureLod(iChannel0, uv+u, 4.).r\n    vec3 ep = vec3(20./iChannelResolution[0].xy,0);\n    vec3 normal = normalize(vec3(T(-ep.xz)-T(ep.xz), T(-ep.zy)-T(ep.zy), map.r));\n    \n    // lighting\n    float light = dot(normal, normalize(vec3(0,1,1)))*.5+.5;\n    vec3 color = vec3(light*light);\n    \n    // coloring\n    vec3 tint = 0.5 + 0.5 * cos(vec3(0,1,2) - normal.z* 4. - 4.);\n    light = dot(normal, normalize(vec3(0,-1,-1)))*.5+.5;\n    color += tint * light;\n    \n    // stencil\n    color *= smoothstep(.0,.01,map.r);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// Cloudish Featherly Spiralum\n// fork of Flamished Fractalited Formings\n// https://www.shadertoy.com/view/4cs3Rs\n// leon denise 2023-12-25\n\n// feedback displace pass\n\nfloat gyroid (vec3 seed) { return dot(sin(seed),cos(seed.yzx)); }\n\n// noise\nfloat fbm (vec2 pos)\n{\n    vec3 p = vec3(pos*2., iTime*.1 - length(pos));\n    float result = 0., a = .5;\n    for (int i = 0; i < 4; ++i, a /= 2.) {\n        //p.z += result*.5;\n        result += abs(gyroid(p/a)*a);\n    }\n    return result;\n}\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec4 frame = texture(iChannel0, uv);\n    vec2 offset = vec2(0);\n    \n    // curl noise\n    vec2 e = vec2(1./iResolution.y,0);\n    vec2 curl = vec2(fbm(p+e.xy)-fbm(p-e.xy), fbm(p+e.yx)-fbm(p-e.yx)) / (2.*e.x);\n    curl = vec2(curl.y, -curl.x);\n    \n    // normal\n    #define T(u) texture(iChannel0, uv+u).r\n    vec3 ep = vec3(1./iChannelResolution[0].xy,0);\n    vec3 normal = normalize(vec3(T(-ep.xz)-T(ep.xz), T(-ep.zy)-T(ep.zy), frame.r + 0.001));\n    \n    // spawn shape\n    float dist = abs(length(uv-.5)-.25);\n    float shape = smoothstep(.01, 0., dist);\n    \n    // displace\n    offset = curl * 2. - normal.xy;\n    frame = texture(iChannel0, uv + offset * 0.0018 * vec2(ep.x/ep.y, 1));\n\n    // feedback\n    float mask = max(shape, frame.r - iTimeDelta * 2.);\n    \n    fragColor = vec4(mask, shape, 0, 1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4cX3WS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 215, 215, 928]], "test": "untested"}
{"id": "mtyfRV", "name": "GGX Voxel Raytracing", "author": "KylBlz", "description": "Just having fun shading fb39ca4's voxel scene.", "tags": ["idk"], "likes": 10, "viewed": 513, "published": 3, "date": "1703403732", "time_retrieved": "2024-07-30T17:14:49.535056", "image_code": "\n// GGX BRDF - thanks XT95 - https://www.shadertoy.com/view/Dtl3WS\n// ACES fitted - thanks Paniq - https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n// Voxel Raymarch - thanks fb39ca4 - https://www.shadertoy.com/view/4dX3zl\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 channel0 = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor.rgb = linear_srgb(ACESFitted(\n        channel0.rgb / floor(channel0.a)\n    ));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SHADOWS\n//#define USE_DFD_COARSE\n//#define USE_DFD_SMOOTH\n\n// camera properties\nconst float\tznear = 0.1, zfar = 64.0, FOV = 69.0;\nconst int MAX_RAY_STEPS = 64;\nconst int MAX_REFLECTION_STEPS = 64;\nconst int MAX_SHADOW_STEPS = 64;\nconst int TEMPORALSMOOTHING = 6;\n\n// math constants\nconst highp float\tSQRT2 = 1.4142136, SC45 = 0.7071068, D2R = 0.0174533,\n            eps = 0.001, ieps = 0.999, epsCol = 0.0039062,\n            QTRPI = 0.7853981, HPI = 1.5707963, PI = 3.1415926, TWOPI = 6.2831853,\n            iQTRPI = 1.2732396, iHPI = 0.6366197, iPI = 0.3183098, iTWOPI = 0.1591549;\n\n// average of px considering coarse dfd_ group of 3 pixels per quad\nfloat dfCoarse(in vec2 fc, in float v) {\n    vec2 f = vec2(uvec2(fc.xy) & uvec2(1)),\n         d = vec2(dFdx(v), dFdy(v)),\n         q = d * (0.0 - f),\n         i = d * (1.0 - f);\n    vec3 vals = q.xyx + vec3(q.y, i.xy) + v;\n    return dot(vals, vec3(0.3333333));\n}\n\n// thanks iradicator, this is less sensitive to nonlinear local neighborhood (with respect to fragcoord)\nfloat dfSmooth(in vec2 fc, in float v) { \n    vec2 q = vec2(uvec2(fc.xy) & uvec2(1));\n    q = q * 2.0 - 1.0;    \n    v -= 0.5 * dFdx(v) * q.x;\n    v -= 0.5 * dFdy(v) * q.y;\n    return v;\n}\n\n// generate a unique value for each pixel/frame\nint genSeed(in int f, in ivec2 c) {\n    return (c.x + c.y*2 + f*11) + (c.x*1155 ^ c.y*2244);\n}\n\n// low discrepancy sequence - https://www.shadertoy.com/view/7dByR1\nfloat weyl1(in int v) {\n    return fract(float(v*40503) * exp2(-16.0));\n}\n\nvec2 weyl2(in int v) {\n    return fract(vec2(v*ivec2(49471, 37345)) * exp2(-16.0));\n}\n\nvec3 weyl3(in int v) {\n    return fract(vec3(v*ivec3(53685, 43977, 36025)) * exp2(-16.0));\n}\n\nfloat linearAngle(float d, float r) {\n    return asin(clamp(r/d, eps, ieps));\n}\n\n// orthonormal basis assuming up is +y\nmat3 basisUp(in vec3 forward) {\n    vec3 down = vec3(0.0, -1.0, 0.0);\n    vec3 right = normalize(cross(forward, down));\n    return mat3(right, normalize(cross(forward, right)), forward);\n}\n\n// orthonormal basis at normal\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n    float s = (n.z >= 0.0)? 1.0: -1.0;\n    float a = 1.0 / (s + n.z);\n    float b = -n.x*n.y*a;\n    f = vec3(1.0 - n.x*n.x*a*s, b*s, -n.x*s);\n    r = vec3(b, s - n.y*n.y*a, -n.y);\n}\n\n// concentric mapping square [0,1] to circle [-1,1]\nvec2 concentric(in vec2 v) {\n    vec2 w = v * 2.0 - 1.0;\n    float thta, rad;\n    if (abs(w.x) > abs(w.y)) {\n        rad = w.x;\n        thta = QTRPI * (w.y/w.x);\n    } else {\n        rad = w.y;\n        thta = HPI - QTRPI * (w.x/w.y);\n    }\n    return rad * vec2(cos(thta), sin(thta));\n}\n\n// uniform sample cone\nvec3 uniformConeDir(vec3 lv, float lr, in vec2 rng) {\n    // cone section\n    float sa = tan(linearAngle(length(lv), lr));\n    vec3 u, r, nlv = normalize(lv);\n    basis(nlv, r, u);\n    return normalize(nlv + sa * (r * rng.x + u * rng.y));\n}\n\nvec2 rotate2d(in vec2 v, in float a) {\n    float sinA = sin(a);\n    float cosA = cos(a);\n    return vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\n// thanks XT95 https://www.shadertoy.com/view/Dtl3WS\nfloat F_Schlick(float f0, float f90, float theta) {\n    return f0 + (f90 - f0) * pow(1.0 - theta, 5.0);\n}\n\nfloat D_GTR(float roughness, float NoH, float k) {\n    float a2 = roughness*roughness;\n    return a2 / (PI * pow(NoH*NoH * (a2*a2 - 1.0) + 1.0, k));\n}\n\nfloat G_Smith(float NoV, float roughness2) {\n    float b = NoV*NoV;\n    float a = roughness2*roughness2;\n    return 2.0 * NoV / (NoV + sqrt(a+b - a*b));\n}\n\nfloat GeometryTerm(float NoL, float NoV, float roughness) {\n    float a2 = roughness*roughness;\n    float G1 = G_Smith(NoV, a2);\n    float G2 = G_Smith(NoL, a2);\n    return G1*G2;\n}\n\nfloat ggxDiffuse(float NoL, float NoV, float LoH, float roughness) {\n    float FD90 = 0.5 + 2.0 * roughness * LoH*LoH;\n    float a = F_Schlick(1.0, FD90, NoL);\n    float b = F_Schlick(1.0, FD90, NoV);\n    return a * b / PI;\n}\n\nfloat ggxSpecular(float roughness, float NoH, float NoV, float NoL) {\n    float alpha = roughness*roughness;\n    float D = D_GTR(alpha, NoH, 2.0);\n    float beta = 0.5 + roughness * 0.5;\n    float G = GeometryTerm(NoL, NoV, beta*beta);\n    return D * G / (4.0 * NoL * NoV);\n}\n\n// fast orthogonal matrix inverse\nmat4 orthoInverse(in mat4 m) {\n    mat3 r = transpose(mat3(m));\n    return mat4(\n        vec4(r[0], 0.0),\n        vec4(r[1], 0.0),\n        vec4(r[2], 0.0),\n        vec4(r * vec3(-m[3]), 1.0)\n    );\n}\n\n// construct 4x4 view mat from camera origin, forward direction, time\nmat4 viewMat(in vec3 origin, in vec3 direction, in float time) {\n    // update camera here\n    origin.xz = rotate2d(origin.xz, time * 0.5 - HPI);\n    direction.xz = rotate2d(direction.xz, time * 0.5 - HPI);\n    // construct view mat\n    mat3 bas = basisUp(direction);\n    return mat4(\n        vec4(bas[0], 0.0),\n        vec4(bas[1], 0.0),\n        vec4(bas[2], 0.0),\n        vec4(origin, 1.0)\n    );\n}\n \n// construct 4x4 projection mat using offaxis parameters, aspect ratio, global FOV\nmat4 projectionMat(in vec2 offaxis, in float aspect) {\n    // proj parameters\n    float f = zfar;\n    float n = znear;\n    float fovrad = FOV * D2R;\n    float r =  n * aspect * tan(0.5 * (fovrad - offaxis.x));\n    float l = -n * aspect * tan(0.5 * (fovrad + offaxis.x));\n    float t =  n          * tan(0.5 * (fovrad - offaxis.y));\n    float b = -n          * tan(0.5 * (fovrad + offaxis.y));\n    // construct proj mat\n    return mat4(\n        vec4(2.0*n/(r-l),         0.0, (r+l)/(r-l),           0.0),\n        vec4(        0.0, 2.0*n/(t-b), (t+b)/(t-b),           0.0),\n        vec4(        0.0,         0.0, (f+n)/(f-n), 2.0*f*n/(f-n)),\n        vec4(        0.0,         0.0,         1.0,           0.0)\n    );\n}\n\n// project the pixel at ndc into a worldspace ray\nvoid getCameraRay(in mat4 view, in mat4 proj, in vec2 ndc, out vec3 ro, out vec3 rd) {\n    ro = view[3].xyz;\n    // inverse projection\n    vec4 ndch = inverse(proj) * vec4(ndc, 1.0, 1.0);\n    // apply view matrix\n    rd = normalize(mat3(view) * vec3(ndch.xy, 1.0));\n}\n\n// project a worldspace location hl into camera NDC using its view projection\nvec3 reprojCoordsNDC(in mat4 view, in mat4 proj, in vec3 hl) {\n    // inverse view to camera space\n    vec4 camspace = orthoInverse(view) * vec4(hl, 1.0);\n    // homogenous projection\n    vec4 ndch = camspace * proj;\n    // perspective divide xy, path length in z for depth filtering\n    return vec3(ndch.xy / ndch.w, length(camspace));\n}\n\n// 3D reproject given image, distance, pixel location (see reprojCoordsNDC)\nvec4 reprojectBuffer(in sampler2D iChannel, in float dist, in vec2 fc) {\n    ivec2 ifc = ivec2(fc);\n    // get the 4 neighboring pixel values\n    vec4 b   = texelFetch(iChannel, ifc,               0);\n    vec4 bx  = texelFetch(iChannel, ifc + ivec2(1, 0), 0);\n    vec4 by  = texelFetch(iChannel, ifc + ivec2(0, 1), 0);\n    vec4 bxy = texelFetch(iChannel, ifc + ivec2(1, 1), 0);\n    // depth match filter\n    float has   = step(abs(fract(b.a) - dist), exp2(-8.0));\n    float hasx  = step(abs(fract(bx.a) - dist), exp2(-8.0));\n    float hasy  = step(abs(fract(by.a) - dist), exp2(-8.0));\n    float hasxy = step(abs(fract(bxy.a) - dist), exp2(-8.0));\n    float ttl = has + hasx + hasy + hasxy;\n    if (ttl < 1.0)\n        return vec4(0.0);\n    if (ttl > 3.0) {\n        // fancy bilinear interpolation\n        vec2 a = clamp(fc - floor(fc), vec2(0.0), vec2(1.0));\n        return max(vec4(0.0), mix(mix(b, bx, a.x), mix(by, bxy, a.x), a.y));\n    }\n    // last resort interp\n    return (b*has + bx*hasx + by*hasy + bxy*hasxy) / ttl;\n}\n\n// Thanks Paniq\nvec3 linear_srgb(in vec3 x) {\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, step(x, vec3(0.0031308)));\n}\n\nvec3 srgb_linear(in vec3 x) {\n    return mix(pow((x + 0.055)/1.055,vec3(2.4)), x / 12.92, step(x, vec3(0.04045)));\n}\n\n// Paniq's ACES fitted from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nvec3 ACESFitted(in vec3 color) {\n    // ODT_SAT => XYZ => D60_2_D65 => sRGB\n    color = color * mat3(\n        0.59719, 0.35458, 0.04823,\n        0.07600, 0.90834, 0.01566,\n        0.02840, 0.13383, 0.83777\n    );\n    // Apply RRT and ODT\n    vec3 a = color * (color + 0.0245786) - 0.000090537;\n    vec3 b = color * (0.983729 * color + 0.4329510) + 0.238081;\n    color = a / b;\n    // Back to color space\n    color = color * mat3(\n         1.60475, -0.53108, -0.07367,\n        -0.10208,  1.10813, -0.00605,\n        -0.00327, -0.07276,  1.07602\n    );\n    // Clamp to [0, 1]\n    return clamp(color, 0.0, 1.0);\n}\n\nfloat sdSphere(vec3 p, float d) {\n    return length(p) - d;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nbool getVoxel(ivec3 c) {\n    vec3 p = vec3(c) + vec3(0.5);\n    float d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 20.0));\n    return d < 0.0;\n}\n\n// thanks fb39ca4 https://www.shadertoy.com/view/4dX3zl\nvoid voxelRaymarch(in vec3 rayPos, in vec3 rayDir, in int MAX_STEPS, out float t, out vec3 normal, out ivec3 mapPos, out vec3 hitloc) {\n    mapPos = ivec3(floor(rayPos));\n    ivec3 rayStep = ivec3(sign(rayDir));\n    vec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n    vec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n    vec3 mask;\n    bool hitvoxel = false;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (getVoxel(mapPos)) {\n            hitvoxel = true;\n            break;\n        }\n        // Thanks kzy for the suggestion!\n        mask = vec3(lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy)));\n        // All components of mask are false except for the corresponding largest component of sideDist, which is the axis along which the ray should be incremented.\t\t\t\n        sideDist += mask * deltaDist;\n        mapPos += ivec3(mask) * rayStep;\n    }\n    if (hitvoxel) {\n        // there's probably a better way\n        normal = sign(-rayDir) * mask;\n        t = dot(normal, vec3(mapPos) + max(vec3(0.0), normal) - rayPos) / dot(normal, rayDir);\n        hitloc = rayPos + rayDir * t;\n        return;\n    }\n    t = zfar;\n    normal = vec3(0.0);\n    hitloc = rayPos + rayDir * t;\n    mapPos = ivec3(hitloc);\n}\n\nfloat getAO(in vec3 hitPos, in ivec3 mapPos, in vec3 normal) {\n    vec3 basis = 1.0 - abs(normal);\n    vec3 mapos = vec3(mapPos) + 0.5;\n    vec3 diff = (hitPos - mapos) * basis;\n    vec3 absdiff = abs(diff);\n    // two potential closest walls\n    vec3 maxcomp = vec3(greaterThanEqual(absdiff.xyz, max(absdiff.yzx, absdiff.zxy)));\n    vec3 diff1stmax = diff * maxcomp;\n    vec3 diff2ndmax = diff * (1.0 - maxcomp);\n    // sample 3 voxels\n    vec3 nd1m = normalize(diff1stmax);\n    vec3 nd2m = normalize(diff2ndmax);\n    vec3 nd3m = nd1m + nd2m;\n    bool occupied0 = getVoxel(ivec3( floor(mapos + normal + nd1m) ));\n    bool occupied1 = getVoxel(ivec3( floor(mapos + normal + nd2m) ));\n    bool occupied2 = getVoxel(ivec3( floor(mapos + normal + nd3m) ));\n    // distance functions of occupied voxels\n    diff1stmax = abs(diff1stmax);\n    diff2ndmax = abs(diff2ndmax);\n    float occlu0 = float(occupied0) * max(diff1stmax.x, max(diff1stmax.y, diff1stmax.z));\n    float occlu1 = float(occupied1) * max(diff2ndmax.x, max(diff2ndmax.y, diff2ndmax.z));\n    float occlu2 = float(occupied2 && !occupied0 && !occupied1) * (0.5 - distance(hitPos * basis, (mapos + nd3m * 0.5) * basis));\n    // occlude up to 3/4 hemisphere\n    return 1.0 - min(ieps, (occlu0 + occlu1 + occlu2) * 0.5);\n}\n\nvec4 sampleLight(in vec3 hitloc, in vec3 lv, in ivec3 light) {\n\n#ifdef SHADOWS\n    float t;\n    vec3 normal, hitloc2;\n    ivec3 mapPos;\n    voxelRaymarch(hitloc, lv, MAX_SHADOW_STEPS, t, normal, mapPos, hitloc2);\n#else\n    ivec3 mapPos = light;\n    float t = distance(hitloc, vec3(light));\n#endif\n    return vec4(vec3(mapPos), t);\n}\n\nvec3 shade_ggx(in vec2 fc, in vec3 diffCol, in vec3 spec8, in vec3 specCol, in vec3 rayPos, in vec3 rayDir, in vec3 hitloc, in float t, inout vec3 normal, in ivec3 mapPos, in ivec3 light, in vec3 litCol, in vec3 rflcol, in vec3 rng) {\n    // really sampling a sphere inside the voxel\n    vec3 ll = vec3(light) + 0.5;\n    vec3 lv = ll - hitloc;\n    lv = uniformConeDir(lv, 0.5, rng.xy);\n    // light stuff\n    vec3 hv = normalize(lv - rayDir);\n    float dnl = dot(normal, lv);\n    float dnh = dot(normal, hv);\n    float dnv = dot(normal, -rayDir);\n    float dlh = dot(lv, hv);\n    // sample light\n    vec4 smp = sampleLight(hitloc + normal * eps, lv, light);\n    // decide to shade\n    float diff = 0.0;\n    float spec = 0.0;\n    if (step(0.0, dnl) > 0.5) {\n        float invsquare = TWOPI / (1.0 + smp.w*smp.w);\n        float hitlit = invsquare * float(ivec3(smp.xyz) == light);\n        // value sharing\n#ifdef USE_DFD_COARSE\n        hitlit = (hitlit + dfCoarse(fc, hitlit)) * 0.5;\n#endif\n#ifdef USE_DFD_SMOOTH\n        hitlit = (hitlit + dfSmooth(fc, hitlit)) * 0.5;\n#endif\n        // ggx\n        float rough = 1.0 - specCol.b * 0.5;\n        diff = ggxDiffuse(dnl, dnv, dlh, rough) * hitlit;\n        spec = ggxSpecular(rough, dnh, dnv, dnl) * hitlit;\n    }\n    // base ambient\n    float amb = 0.02 * max(0.5, dot(normal, normalize(ll + vec3(0.0, 5.0, 0.0))));\n    // ambient occlusion\n    float ao = getAO(hitloc, mapPos, normal);\n    // reflection\n    float refl = F_Schlick(0.1, 0.5, dnv);\n    // emissive\n    float emiss = float(mapPos == light);\n    // bloom\n    vec3 rll = ll - rayPos;\n    float srl = sqrt(dot(rll, rll));\n    float drd = dot(rll / srl, rayDir);\n    float bloom = 0.2 * clamp(t - srl + 0.5, 0.0, 1.0) * pow(max(0.0, drd), 1024.0);\n    // integrate, clamping spec is biased\n    \n    vec3 color = (amb + diff) * diffCol;\n    color += clamp(spec * specCol * specCol, 0.0, 1.0);\n    color *= litCol;\n    color += rflcol * refl;\n    color *= ao;\n    color += litCol * emiss;\n    color.rgb += bloom * litCol;\n    return max(vec3(0.0), color);\n}\n", "buffer_a_code": "// https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf\n\nvoid textureMap(in ivec3 mapPos, in vec3 hitloc, sampler2D channel, inout vec3 normal, out vec3 diffCol, out vec3 spec8, out vec3 specCol) {\n    // mapping\n    vec2 mirror = vec2((mapPos.x ^ mapPos.z) & 1, (mapPos.y ^ mapPos.z) & 1);\n    mat3 rot = mat3(normal.yzx, normal.xyz, normal.zxy);\n    vec2 plnpos = fract(rotate2d(fract((hitloc - vec3(mapPos)) * rot).xz, HPI*mirror.x + PI*mirror.y));\n    // textures\n    diffCol = texture(channel, plnpos).rgb;\n    spec8 = textureLod(channel, vec2(0.5), 7.0).grb;\n    specCol = diffCol;\n    // normals\n    normal = normalize(normal * PI + (spec8 - specCol));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // get current camera\n    float time = float(iFrame)*0.01 - 0.001;\n    vec3 camOrigin = vec3(0.0, 0.0, -15.0);\n    vec3 camDirection = vec3(0.0, 0.0, 1.0);\n    float aspect = iResolution.x / iResolution.y;\n    mat4 view = viewMat(camOrigin, camDirection, time);\n    mat4 proj = projectionMat(vec2(0.0), aspect);\n\n    // get last camera\n    float lastTime = float(iFrame-1)*0.01 - 0.001;\n    mat4 lastView = viewMat(camOrigin, camDirection, lastTime);\n    mat4 lastProj = proj;\n    \n    // get pixel ray to trace\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ndc = uv * 2.0 - 1.0;\n    vec3 ro, rd;\n    getCameraRay(view, proj, ndc, ro, rd);\n\n    // main voxel ray march\n    float t;\n    vec3 normal, hitloc;\n    ivec3 mapPos;\n    voxelRaymarch(ro, rd, MAX_RAY_STEPS, t, normal, mapPos, hitloc);\n\n    // last frame reprojection in NDC\n    vec3 lastNDC = reprojCoordsNDC(lastView, lastProj, hitloc);\n    vec2 lastPx = (lastNDC.xy * 0.5 + 0.5) * iChannelResolution[0].xy;\n    vec4 lastFrame = reprojectBuffer(iChannel0, lastNDC.z/zfar, lastPx - 0.5);\n\n    // main material properties\n    vec3 diffCol = vec3(1.0);\n    vec3 spec8 = vec3(1.0);\n    vec3 specCol = vec3(1.0);\n    textureMap(mapPos, hitloc, iChannel1, normal, diffCol, spec8, specCol);\n\n    // reflection sharpness based on roughness and Schlick\n    float rough = (1.0 / specCol.b) - 1.0;\n    float dnv = dot(normal, -rd);\n    float nrmPwr = TWOPI * rough / (1.0 - F_Schlick(0.1, 0.5, dnv));\n\n    // reflected ray march\n    float t2;\n    vec3 normal2, hitloc2;\n    ivec3 mapPos2;\n    int seed = genSeed(iFrame, ivec2(fragCoord));\n    vec3 rng = vec4(concentric(weyl2(seed)), concentric(weyl2(~seed))).xyz;\n    vec3 rfldir = reflect(rd, normalize(normal * nrmPwr + rng));\n    voxelRaymarch(hitloc + normal * eps, rfldir, MAX_REFLECTION_STEPS, t2, normal2, mapPos2, hitloc2);\n\n    // reflected material properties\n    vec3 diffCol2 = vec3(1.0);\n    vec3 spec82 = vec3(1.0);\n    vec3 specCol2 = vec3(1.0);\n    textureMap(mapPos2, hitloc2, iChannel1, normal2, diffCol2, spec82, specCol2);\n\n    // lights\n    const int NLIGHTS = 4;\n    ivec3 lights[NLIGHTS] = ivec3[](ivec3(5, 4, -3), ivec3(-6, 4, 2), ivec3(-3, 4, -6), ivec3(2, 4, 5));\n    vec3 litCols[NLIGHTS] = vec3[](vec3(3.0, 0.3, 0.3), vec3(0.3, 3.0, 0.3), vec3(0.3, 0.3, 3.0), vec3(5.0, 4.5, 4.0));\n\n    // shade reflections\n    vec3 col2 = vec3(0.0);\n    for (int i = 0; i < NLIGHTS; i++) {\n        col2 += shade_ggx(fragCoord, diffCol2, spec82, specCol2, hitloc, rfldir, hitloc2, t2, normal2, mapPos2, lights[i], litCols[i], vec3(0.0), rng);\n    }\n\n    // reflections decay to prevent fireflies \n    col2 *= 1.0 / (1.0 + t2*t2*0.1);\n\n    // shade main ray\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < NLIGHTS; i++) {\n        col += shade_ggx(fragCoord, diffCol, spec8, specCol, ro, rd, hitloc, t, normal, mapPos, lights[i], litCols[i], col2, rng);\n    }\n\n    // temporal smoothing, moving average\n    int lastFrameN = int(floor(lastFrame.a));\n    if (lastFrameN > TEMPORALSMOOTHING) {\n        float s = float(TEMPORALSMOOTHING) / float(lastFrameN);\n        lastFrame.a = float(TEMPORALSMOOTHING);\n        lastFrame.rgb *= s;\n    }\n\n    // encode sample number in integer componenet and distance in fractional componenet of .a\n    fragColor = vec4(lastFrame.rgb + col, floor(lastFrame.a) + 1.0 + (t/zfar) );\n    \n}\n", "buffer_a_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtyfRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 302, 302, 461]], "test": "untested"}
{"id": "MfsGRs", "name": "spqr alpha 4", "author": "spqr", "description": "Please offer suggestions before I lose my mind ", "tags": ["a"], "likes": 12, "viewed": 210, "published": 3, "date": "1703400631", "time_retrieved": "2024-07-30T17:14:50.536379", "image_code": "vec3 r;\n\nfloat sph (vec3 p, float r) {\n    return length(p) - r;\n}\nfloat box(vec3 p, vec3 d) {\n    p = abs(p) - d;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat aabb(vec3 p, vec3 d) {\n  \n    vec3 neg = -(d / 2. - p)/r;\n    vec3 pos =  (d / 2. - p)/r;\n\n    vec3 bot = min(neg, pos);\n \n    float top = max(max(bot.x, bot.y), bot.z);\n\n    return max(0.0, top); // Ensure we don't return a negative value\n}\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash21(vec2 p){\n    p = fract(p*vec2(234.34,435.345));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\nfloat field (vec3 p, float scale) {\n  \n   p *= scale;\n   vec3 id = floor(p)-.5; \n   p = fract(p) -.5;\n   \n   float f1 = hash31(id);\n \n  \n   float shape = box(p, vec3(f1 * .46));\n\n   float bound = aabb(p, vec3(scale*1.01));\n   \n   return min(bound , shape)/scale;\n}\nfloat hash (float t) {\n    return fract(sin(t*5425.232)*9931.335);\n}\nfloat rnd(float t) { return fract(sin(t*758.655)*352.741); }\nfloat curve(float t, float d) { \n    t/=d; \n    \n    return mix(rnd(floor(t)), rnd(floor(t)+1.0), pow(smoothstep(0.0,1.0,fract(t)),50.));}\nfloat map(vec3 p) {\n    vec3 q = p;\n    float pos = p.y + 1.;\n\n    float f1 = curve(iTime,5.);\n    for (float i = 1.; i < 9.; i++) {\n            \n      \n            pos = max(pos, -field(q,pow(1.4 + f1/2.,i)/16.));\n     \n    }\n    \n    return pos;\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n}\n\nfloat occ ( vec3 p, vec3 n, float ni, float L) {\n    float occ = 1.;\n    for (float i =1.; i < ni; i++) {\n        float l = i * L / ni;\n        float d = map(p + n * l);\n        occ -= max(0., l -d ) / l / ni;\n    \n    }\n    return max(0.,occ);\n\n\n}\nmat2 rot(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nfloat tick ( float t ) {\n    float i = floor(t);\n    float r = fract(t);\n    r = smoothstep(0.,1.,r);\n    return i + r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    \n    float tt = iTime ;\n    float ttt = tick(iTime/3.);\n    // nav \n    vec3 s = vec3(0,2,-15);\n    vec3 arm = vec3(0,0,1);\n    vec3 fwd = vec3(.1,0,5)*tt;\n    s += fwd;\n    arm.xz *= rot((cos(ttt)));\n    arm.yz *= rot((sin(ttt))/3. - .8);\n    \n    \n    s.y += sin(iTime)+ cos(iTime*3.1)/2.1;\n    s.x += sin(iTime/1.3)+ cos(iTime*2.1)/2.1;\n   \n    vec3 t = s + arm;\n    \n\n    \n    \n    vec3 z = normalize(t-s);\n    vec3 x = normalize(cross(vec3(0,-1,0),z));\n    vec3 y = cross(x,z);  \n    r = mat3(x,y,z) * normalize(vec3(uv,1));\n    vec3 p = s;\n    float l;\n    \n    float L = 100.;\n    \n\n    for (float i = 0.; i < 100.; i++) {\n        float d = map(p)*.7 ;\n        \n        if ( d < .0001) {\n        \n            break;\n        }\n        if ( l > L) {\n            break;\n        }\n        p += r * d;\n        l += d;\n    }\n    \n    vec3 col = vec3(0);\n   \n    //col += l/L;\n    \n    vec3 n = norm(p);\n    \n    vec3 light = normalize(vec3(1,1,0));\n \n\n \n    col += occ(p, n , 10., 3.);\n    col *=( dot(n,normalize(light))*.5+.5 ) ;\n    \n\n    //col=mix(col,vec3(1),l/L);\n    \n    \n    \n    col *= vec3(.3,.7,.94);\n    col=mix(vec3(1),col,exp(-.00006 *l*l*l));\n    \n    \n\n   // col = sqrt(col);\n \n\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MfsGRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[9, 9, 38, 38, 66], [67, 67, 94, 94, 150], [152, 152, 180, 180, 399], [400, 400, 423, 423, 526], [528, 528, 549, 549, 643], [644, 644, 679, 679, 908], [909, 909, 931, 931, 977], [978, 978, 998, 998, 1038], [1039, 1039, 1070, 1070, 1177], [1178, 1178, 1197, 1197, 1427], [1429, 1429, 1448, 1448, 1558], [1560, 1560, 1608, 1608, 1808], [1809, 1809, 1828, 1828, 1877], [1880, 1880, 1901, 1901, 1950], [1952, 1952, 1976, 1976, 2073], [2074, 2074, 2131, 2131, 3517]], "test": "untested"}
{"id": "lcl3Rs", "name": "moduloDither", "author": "natet", "description": "An example of a very simple dithering algorithim i came up with. There are two lines that can be (un)commeted in/out that make the shader a bit more interesting, both have a slight performance impact. Try switching iChannel0 to the 1961 commercial! ", "tags": ["dither", "modulus", "dithering"], "likes": 4, "viewed": 199, "published": 3, "date": "1703397611", "time_retrieved": "2024-07-30T17:14:51.587568", "image_code": "// This function returns an integer to use as the modulus value for a given pixel. \n//  The brighter this pixel, the smaller this integer is, relative to the width of the image (so that a black pixel returns\n//  the image width as an integer)\nint ditherModFactor(float val, vec2 imgSize){\n    return int(floor((1.0-pow(val,0.01)) * imgSize.x));\n    //The pow here applies an aggressive log curve to the greyscale colour of the image. This is needed due to \n    // multiplying the 0-1 greyscale value by such a large number (screen width in pixels). An exponent of 0.01 happens to work \n    // very well here, but playing around with the exponent can be interesting. \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Load a pixel from the image and write it to a variable\n    vec4 pix = texture(iChannel0,uv);\n    \n    //If the green channel of this pixel is more than a small value, and the red and blue are less than a threshold, make this \n    // pixel black.\n    if(pix.y > 0.01 && pix.x < 0.2 && pix.z < 0.2){pix = vec4(0.0,0.0,0.0,1.0);} //uncomment to chroma key (for black background) \n    \n    //Store a float of the average value of all three colour channels of this pixel\n    float pixVal = (pix.x+pix.y+pix.z)/3.0;\n    \n    //Work out what number/index pixel this is in the image. It is also interesting to use the x or y coordinate of the current\n    // pixel (not normalised) in place of i (**try replacing i on line 39 with fragCoord.x or fragCoord.y!**).\n    float i = uv.x + (uv.y * iResolution.y);\n    \n    //Get the modulo value for this pixel\n    int shadeMod = ditherModFactor(pixVal, iResolution.xy);\n        \n    //Compare the modulo value for this pixel with it's number/index - if the pixel index is a multiple of the modulo, \n    // output a white pixel - if not, black. This means that brighter pixels in the original image both have more white \n    // neighbours and are more likely to be white themselves, based on where they fall in the image. This is why it's important\n    // to scale the modulo to the image width so that no repeating patterns of white appear in parts of the image that should be \n    // black. When this is done, the only black/dark pixels in the original image that will return white in the modulo check are \n    // the pixels that have the \"address\" (index or x or y coord) equal to the max value in range of values that address can be. \n    if(int(i) % shadeMod == 0){\n        fragColor = vec4(1.0);\n    } else {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    //if((1.0-uv.x) < uv.y){fragColor = vec4(pixVal,pixVal,pixVal,1.0);} //uncommenting shows undithered b&w image on half of screen\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcl3Rs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 243, 288, 288, 668], [670, 670, 727, 776, 2761]], "test": "untested"}
{"id": "lflGzl", "name": "Star Struct", "author": "pxlmage", "description": "Sparkly, twilight, milkyway", "tags": ["shadertoy"], "likes": 7, "viewed": 212, "published": 3, "date": "1703388463", "time_retrieved": "2024-07-30T17:14:52.493147", "image_code": "#define NUM_LAYERS 6.\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Star(vec2 uv, float flare){\n    float d = length(uv);\n    float m = .05/d;\n    \n    \n    float rays = max(0.,1.-abs(uv.x * uv.y * 1000.));\n    m += rays* flare;\n    uv *= Rot(3.1415/4.);\n    rays = max(0.,1.-abs(uv.x * uv.y * 1000.));\n    m += rays * .3 * flare;\n    m*= smoothstep(1.,.2,d);\n    return m;\n}\n\n//RNG\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n}\n\nvec3 StarLayer(vec2 uv){\n    vec3 col = vec3(0);\n\n    //boxes\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            vec2 offs = vec2(x,y);\n            float n=  Hash21(id+offs); // random betwen 0 and 1\n            float size = fract(n*345.32);\n            float star = Star(gv-offs-vec2(n,fract(n*34.))+.5,smoothstep(.8, .9, size));\n            vec3 color = sin(vec3(.2,.3,.9)*fract(n*2345.2)*6.2831* 100.)* 0.5 + 0.5;\n            color = color* vec3(1,.5,1.+size);\n            star *= sin(iTime*3.+n*6.2831)*.5+1.;\n            col += size * star * color;\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord -.5*iResolution.xy)/iResolution.y;\n    vec2 M = (iMouse.xy -.5*iResolution.xy)/iResolution.y;\n    float t = iTime*.01;\n    uv += M *4.;\n    uv *= Rot(t);\n    vec3 col = vec3(0);\n    \n    for(float i=0.; i<1.; i+=1./NUM_LAYERS) {\n        float depth = fract(i+t);\n        float scale = mix(20.,.5,depth);\n        float fade = depth* smoothstep(1.,.9,depth);\n        col += StarLayer(uv*scale+i*453.2-M)*fade;\n    }\n    \n    //red grid\n    //if(gv.x > .48 || gv.y > .48) col.r = 1.;\n    \n    //col.rg += id*.4;\n    //col += Hash21(uv);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lflGzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 42, 42, 108], [110, 110, 143, 143, 423], [425, 431, 452, 452, 550], [552, 552, 576, 576, 1217], [1219, 1219, 1276, 1331, 1952]], "test": "untested"}
{"id": "4cs3Rs", "name": "Flamished Fractalited Formings", "author": "leon", "description": "the kind of shapes I like", "tags": ["weird"], "likes": 39, "viewed": 584, "published": 3, "date": "1703378847", "time_retrieved": "2024-07-30T17:14:53.796662", "image_code": "// Flamished Fractalited Formings\n// leon denise 2023-12-24\n\n// render pass\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 map = texture(iChannel0, uv);\n    \n    // dim (clean the seams)\n    map.r -= 0.1;\n    \n    // blured normal\n    #define T(u) textureLod(iChannel0, uv+u, 4.).r\n    vec3 ep = vec3(10./iChannelResolution[0].xy,0);\n    vec3 normal = normalize(vec3(T(-ep.xz)-T(ep.xz), T(-ep.zy)-T(ep.zy), map.r));\n    \n    // lighting\n    float light = dot(normal, normalize(vec3(0,1,1)))*.5+.5;\n    vec3 color = vec3(light*light);\n    \n    // stencil\n    color *= smoothstep(.0,.01,map.r);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Flamished Fractalited Formings\n// leon denise 2023-12-24\n\n// feedback displace pass\n\nfloat gyroid (vec3 seed) { return dot(sin(seed),cos(seed.yzx)); }\n\n// crazy noise\nfloat fbm (vec2 pos)\n{\n    vec3 p = vec3(pos, iTime*.1);\n    float result = 0., a = .5;\n    for (int i = 0; i < 3; ++i, a /= 2.) {\n        result += abs(gyroid(p/a)*a);\n    }\n    result = sin(result*6.283+iTime*.5-length(pos));\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // curl noise\n    vec2 e = vec2(1./iResolution.y,0);\n    vec2 curl = vec2(fbm(p+e.xy)-fbm(p-e.xy), fbm(p+e.yx)-fbm(p-e.yx)) / (2.*e.x);\n    curl = vec2(curl.y, -curl.x);\n    \n    // spawn shape\n    float dist = abs(length(p)-.5);\n    float mask = smoothstep(.01, 0., dist);\n    \n    // displace\n    curl *= 0.005;\n    vec4 frame = texture(iChannel0, uv + curl);\n\n    // feedback\n    mask = max(mask, frame.r - iTimeDelta);\n    \n    fragColor = vec4(mask, curl, 1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4cs3Rs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 134, 134, 693]], "test": "untested"}
{"id": "Xfs3Rl", "name": "Exploring FBM", "author": "mgmbass", "description": "Variation on fbm from https://iquilezles.org/articles/warp/", "tags": ["noise"], "likes": 2, "viewed": 139, "published": 3, "date": "1703366656", "time_retrieved": "2024-07-30T17:15:00.504726", "image_code": "\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nfloat pattern( in vec2 p )\n{\n    vec2 q = vec2( fbm( p + vec2(0.0,0.0) + 0.07 * -1. * iTime ),\n                   fbm( p + vec2(1.2,1.3) + 0.12 * iTime) );\n\n    vec2 r = vec2( fbm( p + 4.0*q + vec2(1.7,9.2) + 0.11 * iTime ),\n                   fbm( p + 4.0*q + vec2(8.3,2.8) + 0.09 * -1. *iTime));\n\n    return fbm( p + 40.0*r );\n}\n  \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = fract(uv);\n    vec3 color = vec3(0.0);\n    float f = pattern(uv);\n    color = mix(vec3(0.251,0.087,0.910),\n                vec3(0.980,0.121,0.046),\n                f);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xfs3Rl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 28, 28, 135], [137, 215, 241, 241, 621], [641, 641, 665, 687, 941], [943, 943, 971, 971, 1273], [1279, 1279, 1336, 1386, 1663]], "test": "untested"}
{"id": "4fX3Rs", "name": "truchet3d hexagonal logspiral", "author": "cyperus", "description": "truchet3d - toroidal hexagonal grid - logarithmic spiral", "tags": ["3d", "grid", "sdf", "spiral", "hexagon", "tiling", "logarithm", "schwarzchristoffel"], "likes": 11, "viewed": 219, "published": 3, "date": "1703343428", "time_retrieved": "2024-07-30T17:15:01.830183", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"truchet3d hexagonal logspiral\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n// References, Inspiration:\n//\n// - \"Schwarz-Christoffel Mapping\" by mla\n//   https://www.shadertoy.com/view/tsfyRj\n//\n// - \"Logarithmic Moebius color arrows\" by FabriceNeyret2\n//   https://www.shadertoy.com/view/fldSWS\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// ray casting bounding shape\nconst float\n    CAM_DIST = 5.5,\n    CAM_FLE = 2.,\n    BB_DIST = 8.,\n    RAY_MIN_DIST = 0.5,\n    RAY_MAX_DIST = CAM_DIST+1.1*BB_DIST;\n\nconst int   MAX_MARCHING_STEPS = 500;\nconst float\n    RAY_STEP_FACTOR = 0.1,\n    RAY_PRECISION = 1.E-1;\n\n// data from sdf\nvec3 mat_to = vec3(0);\nvec3 mat_to_id = vec3(0);\nvec4 mat_tc = vec4(0);\n\nfloat map(in vec3 p) {\n    float rxy = 0., au = 0.0, av = 0.0;\n    vec2 z = vec2(0.);\n    float d = -1.;\n    \n    // clog spiral\n    p.z *= exp(-0.5 * length(p.xy));\n    vec2 sp_k = vec2(6.*sqrt(3.),3.);    // subdivide & twist spiral branch\n    p.xy = clog(p.xy)/(2.*PI);           // complex log normalized\n    p.xy = cmul(p.xy,sp_k);              // subdiv spiral branches, twist        \n    p.xy += vec2(-0.4, 0.0 )* iTime;     // move to and rotate around spiralcenter\n    //vec2 sp_id = floor(U);             // index at the branch cut (0,-+PI) not the same!   \n    //vec2 sp_id = floor( vec2(-p.y,p.x) - floor(-p.y/sp_k.x) * sp_k );\n    \n    // regular hexagonal tiles\n    vec3 rpt_id = vec3(1.); vec3 p_hex;    \n    p.xy = hexgrid2hex(p.xy, rpt_id);    \n    p.xy = inversesc(p.xy, int(6.));\n    mat_to_id = rpt_id;\n\n    // torus,sphere,2spheres       \n    rxy = length(p.xy); au = atan(p.y, p.x);    \n    z = 2.5*ccos(PI*vec2(rxy,2.*p.z));\n    z.x += (3. + 3. * sin(2.*PI*iTime/60.));\n            \n    p = vec3(log(length(z))-0.02, 0.5*au/PI, 0.5*atan(z.y,z.x)/PI);\n    \n    vec2 to_uv = p.yz;\n    float to_d = log(length(z)+0.8);\n    mat_to = vec3(to_uv,to_d);   \n\n    // truchet 3D cube grid\n    vec3 tc_id = vec3(0.); float tc_a = 0.;   \n    p *= vec3(1.,18.,4.); // r,u,v\n    p.yzx = p.xyz;\n    \n    ivec3 l0 = -ivec3(4./2.,0,18./2.);\n    ivec3 l1 = ivec3(4./2.,1.,18./2.)-ivec3(1.);\n    tc_id = floor(p);\n    tc_id = clamp(tc_id, vec3(l0), vec3(l1));\n    vec3 q = p - tc_id -0.5;\n\n    // truchet 3D cube tiles\n    float rnd = hash21(tc_id.xz);\n    if(rnd<.5) q.x = -q.x;\n    float r0 = 0.5; float r1 = 0.125;\n\n    if(fract(rnd*77.57+iTime/6.)>.75) {\n       vec3 q2 =  length(q.xz-.5)<length(q.xz+.5)\n                ? vec3(q.xz-.5,0.)  \n                : vec3(q.xz+.5,1.);\n       d = sdTorus( vec3(q2.x, q.y, q2.y) , vec2(0.5,r1) );\n    }\n    else {\n       d = opSmoothUnion( sdCylinder( q.zxy, r1 ), sdCylinder( q.xzy, r1 ), 0.05 );\n    }\n    mat_tc = vec4(q,rnd);  \n   \n    // return\n    return min(d,to_d);\n}\n\n// intersect\nfloat intersect(in vec3 ro, in vec3 rd, in float px) {\n    float res = -1.0;\n    \n    // bb\n    //vec2 dis = isphere( ro, rd , abs(BB_DIST));\n    vec2 dis = ibox( ro, rd, vec3(BB_DIST,BB_DIST,4.));\n    if( dis.y<0.0 ) return -1.0;\n    dis.x = max( dis.x, RAY_MIN_DIST );\n    dis.y = min( dis.y, RAY_MAX_DIST );\n\n    // raymarch signed distance field    \n\tfloat fh = RAY_STEP_FACTOR;\n    float t = dis.x;\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) {\n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t;\n        float h = map( pos);\n        if( t>dis.y || h<th ) break;\n        t += h*fh;\n    }\n    if( t<dis.y ) {\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) { \n\tif (iMouse.x > 0.0) {\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n    p.yz = crot(p.yz,-1.*PI*(time+10.));\n    p.zx = crot(p.zx,-2.*PI*(time+15.));\n\treturn p.xyz;\n}\n\n// textures\nfloat grid_uv(in vec2 uv) {\n    // uv grid alpha mask\n    vec2 sw = abs(fract(uv-0.25)-0.5)-0.25;\n    float sdf = min(sw.x,sw.y)*-max(sw.x,sw.y);\n    float pp = fwidth(sdf);\n    return smoothstep(+pp,-pp,sdf);\n}\n            \nvec4 cells(in vec2 uv, in float h) {\n    // sectors, uv-grid\n    vec4 C;\n    C.a = 1.;\n    C.rgb = h2rgb(h);                      // sector  -> hue\n    C.rgb *= (0.5+ 0.5 * grid_uv(uv))*0.7; // uv-grid -> value\n    return C;\n}\n\nvec4 ribbon(in float uv_x, in float time) {\n    float sdf = -(2.*pulsecollision(1.,1./3. * uv_x, time, 2./6.)-1.);\n    float px = fwidth(sdf); float a = smoothstep(px+0.1,-px-0.1,sdf+0.2);    \n    return vec4( h2rgb(sdf -2./6.),a );\n}\n\nvec4 truchet3D(in vec3 p, in float rnd ,in float time) {\n    float sdf = sdBox( p, vec3(0.5*0.9));\n    float px = fwidth(sdf); float a = smoothstep(px,-px,sdf);\n    return mix(vec4(1.), vec4(h2rgb( fract(abs(rnd)*22.93 + time)),1.), a);\n}\n\n// main\nvoid mainImage(out vec4 O, in vec2 fragCoord) {\n    // normalized time\n    float ntime = iTime/360.;\n\n    // anti-aliasing to take a picture\n    vec3 tot = vec3(0.0);\n    #define AA 1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {       \n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o) - iResolution.xy)/iResolution.y;\n        \n        // camera viewport --> worldspace\n        vec3 ro = vec3(0,0,-CAM_DIST);\n        vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n             ro = transform(ro,ntime);\n             rd = normalize(transform(rd,ntime));\n        \n        // distance hit ray surface\n        float px = 2.0/( iResolution.y*CAM_FLE );\n        float t = intersect( ro, rd, px );\n\n        // background\n        vec3 sky_col = rd*.3+.7;\n        vec4 C = vec4(sky_col,1.);\n        O = C;\n        \n        // object surface\n        if (t >= 0.) {\n            // surface properties\n            vec3 p = ro + rd * t;\n            vec3 n = calcNormal( p, 0.001);\n            \n            const float r0 = 0.5;\n            float a_rpt_tc = 0.5+0.5*sin(2.*PI*ntime);\n            \n            // draw textures\n            O = vec4(0);\n\n            if(O.a<1.) {          \n                float hue = (mat_to_id.x + 2.)/4. + (mat_to_id.z )/8.;\n                C = cells(mat_to.xy/2., hue);\n                C.a = mat_to.z>r0 ? 1.-a_rpt_tc : O.a;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n\n            if(O.a<1.) {\n                C =  mat_to.z<r0 ? ribbon( 6.*3.* mat_to.x,  6.*ntime) : vec4(0.);\n                C.rgb *= 0.7;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n\n            if(O.a<1.) {\n                C = truchet3D(mat_tc.xyz, mat_tc.w, ntime);\n                C.a = a_rpt_tc; C.rgb *= 0.5;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n\n            C = O;\n                       \n            // lighting\n            vec3  came_li_o   = transform(vec3(-10.,10.,-10.),ntime); // origine\n            vec3  came_li_dir = normalize(p - came_li_o);             // direction\n            vec3  came_li_col = vec3(1.,1.,.5);                       // color\n            float came_li_shi = 10.;                                  // shininess            \n\n            float cosa = 1.;\n            O.rgb += 0.1 * cosa * C.rgb * sky_col;           // amb\n            cosa = clamp(dot(-came_li_dir, n), 0., 1.);\n            O.rgb += 0.5 * cosa * C.rgb * came_li_col;       // dif       \n            cosa = pow(clamp(dot(reflect(came_li_dir, n), -rd), 0., 1.), came_li_shi);           \n            O.rgb += 0.4 *(cosa>0.? cosa:0.) * came_li_col ; // spec\n            \n            // fog\n            O.rgb = mix(O.rgb, sky_col, 1.0 - exp(-0.05E-2 * pow(t,4.))); \n        }\n        tot += O.rgb;\n    }\n    tot /= float(AA*AA);\n    \n    // gamma correction\n    O = vec4(rgb2srgb(tot),1.);\n}", "image_inputs": [], "common_code": "// const\nconst float PI = abs(atan(0.,-1.));\n\n// 1D transformations\nfloat pulsecollision(in float pf, in float x, in float x0, in float pw) {\n    float ntriw_p = abs( fract( pf*(x - x0) )-0.5);\n    float ntriw_n = abs( fract( pf*(x + x0) )-0.5);\n    float pp = smoothstep( 0.5*pw, 0., ntriw_p );\n    float pn = smoothstep( 0.5*pw, 0., ntriw_n );\n    return (pp+pn);\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);\n}\n\n// complex\nvec2 cmul(vec2 za,vec2 zb) {\n    return za*mat2(zb.x,-zb.y,zb.yx);\n}\n\nvec2 crot(vec2 z,float a) {\n    return cmul(vec2(cos(a),sin(a)),z);\n}\n\nvec2 cinv(vec2 z) {\n    return z*vec2(1,-1)/dot(z,z);\n}\n    \nvec2 cdiv(vec2 z, vec2 w) {\n    return cmul(z,cinv(w));\n}\n    \nvec2 cpow(vec2 z, int n) {\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));\n}\n  \nvec2 csqr(vec2 z) {\n    return vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y );\n}\n\nvec2 ccos(vec2 z) {\n    vec2 d=vec2(exp(z.y),exp(-z.y));\n\treturn vec2(cos(z.x)*(d.x+d.y)*.5,-sin(z.x)*(d.x-d.y)*.5);\n}\n\nvec2 clog(vec2 z) {// : 1 --> 1 (we use only the visible main branch)\n\n    return vec2(0.5*log(z.x*z.x+z.y*z.y),atan(z.y,z.x));\n}\n\nfloat binomial(float a, int n) {\n   float s = 1.0;\n   for (int i = n; i >= 1; i--,a--) {\n     s *= float(a)/float(i);\n   }\n   return s;\n}\n\nvec2 expi(float x) {\n  return vec2(cos(x),sin(x));\n}\n\nfloat gamma(float z) {\n  const float[8] p = float[](\n    676.5203681218851,\n    -1259.1392167224028,\n    771.32342877765313,\n    -176.61502916214059,\n    12.507343278686905,\n    -0.13857109526572012,\n    9.9843695780195716e-6,\n    1.5056327351493116e-7\n  );\n  z -= 1.0;\n  float x = 0.99999999999980993;\n  for (int i = 0; i < 8; i++) {\n    float pval = p[i];\n    x += pval/(z+float(i+1));\n  }\n  float t = z + 8.0 - 0.5;\n  return sqrt(2.0*PI) * pow(t,z+0.5) * exp(-t) * x;\n}\n\n// beta function\nfloat B(float a, float b) {\n  return (gamma(a)*gamma(b))/gamma(a+b);\n}\n\nvec2 inversesc(vec2 z, int K) {\n  float cn[6];\n  for (int n = 1; n <= 5; n++) {\n    cn[n] = binomial(float(n)-1.0+2.0/float(K),n)/float(1+n*K);\n  }\n  float C = B(1.0/float(K),1.0-2.0/float(K))/float(K);\n  z *= C;\n  vec2 h = cpow(z,int(K));\n  float T1 = -cn[1];\n  float T2 = -cn[2]+float(K+1)*pow(cn[1],2.0);\n  float T3 = -cn[3]+float(3*K+2)*(cn[1]*cn[2]-float(K+1)/2.0*pow(cn[1],3.0));\n  float T4 = -cn[4]+float(2*K+1)*(2.0*cn[1]*cn[3]+pow(cn[2],2.0)-float(4*K+3)*\n                                  (pow(cn[1],2.0)*cn[2]-float(K+1)/3.0*pow(cn[1],4.0)));\n  float T5 = -cn[5]+float(5*K+2)*(cn[1]*cn[4]+cn[2]*cn[3]+float(5*K+3)*\n            (-0.5*pow(cn[1],2.0)*cn[3]-0.5*cn[1]*pow(cn[2],2.0)+float(5*K+4)*\n            (pow(cn[1],3.0)*cn[2]/6.0-float(K+1)*pow(cn[1],5.0)/24.0)));\n  vec2 X = vec2(1,0)+h/pow(C,float(K));\n  vec2 w = cmul(z,vec2(1,0) + T1*h + T2*cpow(h,2) + T3*cpow(h,3) + T4*cpow(h,4) + cdiv(T5*cpow(h,5),X));\n  return w;\n}\n\nvec2 hexgrid2hex(in vec2 Z, out vec3 U_id) {\n    const float\n        SQRT3 = sqrt(3.),\n        SQRT_3 = 1./SQRT3;\n\tconst mat2\n        M = mat2(SQRT_3,-1.,-SQRT_3,-1.),\n        iM = 0.5*mat2(SQRT3,-SQRT3,-1.,-1.);\n    Z = crot(Z,PI/6.);\n    Z = iM*Z/0.75;\n    vec3 U = vec3(Z.x,-Z.x-Z.y,Z.y);\n    U_id = 2.*floor(U*0.5+0.5);\n    vec3 U_lo = U-U_id;\n    vec3 aU_lo = abs(U_lo);\n    if (aU_lo.x > aU_lo.y && aU_lo.x > aU_lo.z) {\n        U_lo.x = -U_lo.y-U_lo.z;\n        U_id.x = -U_id.y-U_id.z;\n    }\n    if (aU_lo.y > aU_lo.z) {\n        U_lo.y = -U_lo.x-U_lo.z;\n        U_id.y = -U_id.x-U_id.z;\n    }\n    else {\n        U_lo.z = -U_lo.x-U_lo.y;\n        U_id.z = -U_id.x-U_id.y;\n    }\n    Z = U_lo.rb;\n    Z = M*Z*0.75;\n    return crot(Z,-PI/6.);\n}\n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\nvec2 ibox( in vec3 ro, in vec3 rd, in vec3 rad) {\n    // https://iquilezles.org/articles/boxfunctions/ by iq\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    \n    //oN = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz); // normal at near intersection point\n\n    return vec2( tN, tF ); // distances at near and far intersection point\n}\n\n// sdf\n// https://iquilezles.org/articles/distfunctions/\n\nfloat opIntersection( float d1, float d2 ) {\n    return max(d1,d2); }\n\nfloat opSmoothUnion( in float d1, in float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, float r ) {\n  return length(p.xz)-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// color\nvec3 h2rgb(float h) {\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n}\n\n// srgb <--> rgb (linear)\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fX3Rs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[929, 929, 951, 951, 2953], [2955, 2968, 3022, 3022, 3645], [3647, 3647, 3692, 3692, 3854], [3856, 3856, 3898, 3898, 4145], [4147, 4159, 4186, 4212, 4370], [4384, 4384, 4420, 4444, 4610], [4612, 4612, 4655, 4655, 4846], [4848, 4848, 4904, 4904, 5086], [5088, 5096, 5143, 5166, 8038]], "test": "untested"}
{"id": "Mcs3RX", "name": "spqr alpha 2", "author": "spqr", "description": "a", "tags": ["a"], "likes": 23, "viewed": 451, "published": 3, "date": "1703320716", "time_retrieved": "2024-07-30T17:15:02.998060", "image_code": "vec3 r;\n\nfloat sph (vec3 p, float r) {\n    return length(p) - r;\n}\nfloat box(vec3 p, vec3 d) {\n    p = abs(p) - d;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat aabb(vec3 p, vec3 d) {\n  \n    vec3 neg = -(d / 2. - p)/r;\n    vec3 pos =  (d / 2. - p)/r;\n\n    vec3 bot = min(neg, pos);\n \n    float top = max(max(bot.x, bot.y), bot.z);\n\n    return max(0.0, top); // Ensure we don't return a negative value\n}\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash21(vec2 p){\n    p = fract(p*vec2(234.34,435.345));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\nfloat field (vec3 p, float scale) {\n  \n   p *= scale;\n   vec3 id = floor(p)-.5; \n   p = fract(p) -.5;\n   \n   float f1 = hash31(id);\n \n  \n   float shape = box(p, vec3(f1 * .46));\n\n   float bound = aabb(p, vec3(scale*1.01));\n   \n   return min(bound , shape)/scale;\n}\nfloat map(vec3 p) {\n    vec3 q = p;\n    float pos = p.y + 1.;\n\n\n    for (float i = 1.; i < 9.; i++) {\n      \n            pos = max(pos, -field(q,pow(1.8,i)/16.));\n     \n    }\n    \n    return pos;\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n}\n\nfloat occ ( vec3 p, vec3 n, float ni, float L) {\n    float occ = 1.;\n    for (float i =1.; i < ni; i++) {\n        float l = i * L / ni;\n        float d = map(p + n * l);\n        occ -= max(0., l -d ) / l / ni;\n    \n    }\n    return max(0.,occ);\n\n\n}\nmat2 rot(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    \n    float tt = iTime ;\n    // nav \n    vec3 s = vec3(0,2,-15);\n    vec3 arm = vec3(0,0,1);\n    vec3 fwd = vec3(.1,0,5)*tt;\n    s += fwd;\n    arm.xz *= rot(cos(tt)/2.);\n    arm.yz *= rot(sin(tt/2.)/3. - .8);\n    vec3 t = s + arm;\n    \n\n    \n    \n    vec3 z = normalize(t-s);\n    vec3 x = normalize(cross(vec3(0,-1,0),z));\n    vec3 y = cross(x,z);  \n    r = mat3(x,y,z) * normalize(vec3(uv,1));\n    vec3 p = s;\n    float l;\n    \n    float L = 300.;\n    \n\n    for (float i = 0.; i < 100.; i++) {\n        float d = map(p) ;\n        \n        if ( d < .0001) {\n            break;\n        }\n        if ( l > L) {\n            break;\n        }\n        p += r * d;\n        l += d;\n    }\n    \n    vec3 col = vec3(0);\n   \n    //col += l/L;\n    \n    vec3 n = norm(p);\n    \n    \n    col += occ(p, n , 10., 3.);\n    \n    \n    //col=mix(col,vec3(1),l/L);\n    col *= vec3(232.,220.,202.)/256.;\n    col=mix(vec3(1),col,exp(-.00002*l*l*l));\n    \n    \n\n   // col = sqrt(col);\n \n   \n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mcs3RX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[9, 9, 38, 38, 66], [67, 67, 94, 94, 150], [152, 152, 180, 180, 399], [400, 400, 423, 423, 526], [528, 528, 549, 549, 643], [644, 644, 679, 679, 908], [909, 909, 928, 928, 1106], [1108, 1108, 1127, 1127, 1237], [1239, 1239, 1287, 1287, 1487], [1488, 1488, 1507, 1507, 1556], [1559, 1559, 1580, 1580, 1629], [1632, 1632, 1689, 1689, 2841]], "test": "untested"}
{"id": "4cs3Rf", "name": "  hexagon test", "author": "jorge2017a2", "description": "\n\nhexagon test", "tags": ["2d", "test", "hexagon"], "likes": 12, "viewed": 180, "published": 3, "date": "1703301163", "time_retrieved": "2024-07-30T17:15:03.990407", "image_code": "//por jorge2017a2\n//hexagon test\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n//22-dic_2023\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n\n\n//art_of_code\nconst vec2 D = vec2(1, 1.73); // hexagon diagonal\nconst vec2 R = D * 0.5; // hexagon radius\n\n\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\n\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    uv *= 4.+2.0*sin(iTime);\n    \n       //repetir hexdiz\n     vec2 a = mod(uv, D) - R;\n    vec2 b = mod(uv-R, D) - R;\n    // smarter than compiler, hehe\n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n\n    vec2 p=gv;\n\nvec2 pos,med;\nfloat d1;\nvec3 colc;\nvec3 colc1,colc2,colc3;\n\npos=vec2(0.01,0.31); //spalmer, \n//pos=vec2(0.0,0.28);\nmed=vec2(0.71, 0.41)*0.65;\nd1= sdRhombus( p-pos, med);\n\ncolc=vec3(0.5,0.6,0.2);\ncol=DrawFigBorde(colc, col, d1);\n\n\n\npos=vec2(-0.06,0.13);\nmed=vec2(0.71, 0.41)*0.65;\n//rotar\nfloat ang = -60.0 * PI / 180.0;\nvec2 pr = Rotate(p-pos, med, ang);\nfloat d2 = sdRhombus(pr- pos, med);\ncolc=vec3(0.8,0.3,0.2);\ncol=DrawFigBorde(colc, col, d2);\n\n\n//-----------\n pos=vec2(0.077,-0.41);\n med=vec2(0.71, 0.41)*0.69;\n//rotar\nang = 60.0 * PI / 180.0;\npr = Rotate(p-pos, med, ang);\nfloat d3 = sdRhombus(pr- pos, med);\ncolc=vec3(0.2,0.3,0.8);\ncol=DrawFigBorde(colc, col, d3);\n//-----------\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4cs3Rf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[410, 410, 457, 457, 484], [485, 485, 528, 528, 555], [556, 556, 604, 604, 632], [635, 635, 697, 697, 827], [829, 829, 891, 891, 956], [959, 959, 1023, 1023, 1094], [1096, 1112, 1160, 1160, 1238], [1240, 1240, 1265, 1265, 1284], [1285, 1285, 1310, 1310, 1329], [1330, 1330, 1366, 1366, 1394], [1398, 1398, 1440, 1440, 1621], [1624, 1624, 1681, 1681, 2697]], "test": "untested"}
{"id": "McXGRX", "name": "SymVox  SVDAG Octree DDA", "author": "GabeRundlett", "description": "A port of the symvox SVDAG octree dda algorithm\nhttps://github.com/RvanderLaan/SVDAG-Compression\nIt's supposed to look very wrong. There's no SVDAG data yet.\nI don't believe the shader works correctly...\n", "tags": ["voxel", "dda", "trace", "octree", "dag", "svdag", "directedacyclicgraph", "symvox"], "likes": 3, "viewed": 217, "published": 3, "date": "1703289024", "time_retrieved": "2024-07-30T17:15:05.020652", "image_code": "\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 image_size = vec4(iResolution.xy, vec2(1.0) / iResolution.xy);\n    // invert Y because OpenGL is silly\n    vec2 pixel_pos = vec2(fragCoord.x, image_size.y - 1.0 - fragCoord.y);\n\n    Player player = load_player(iChannel0);\n    Camera cam = player_get_camera(player, image_size);\n\n    vec2 uv = get_uv(pixel_pos, image_size);\n    ViewRayContext vrc = vrc_from_uv(cam, uv);\n\n    vec3 ray_pos = ray_origin_ws(vrc);\n    vec3 ray_dir = ray_dir_ws(vrc);\n\n    Ray ray = Ray(ray_pos, ray_dir);\n\n    vec3 pos = vec3(0);\n    vec3 nrm = vec3(0);\n    vec4 res = trace_ray(ray, vec2(1e-10, 1e30), 1.0, nrm);\n\n    vec3 col = vec3(0);\n    switch (int(res.x)) {\n    case -1: col = vec3(0.0);           // inside bbox, no intersection\n    case -3: col = vec3(1.0, 0.0, 0.0); // too many iterations\n    case -4: col = vec3(0.5, 0.7, 1.0); // never hit bbox\n    case -2: break;   // left the bounds\n    default:\n        pos = ray_pos + ray_dir * res.x;\n        col = pos;\n        break;\n    }\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// CAMERA CONTROLLER\n\nconst float MOUSE_SENSITIVITY = 0.01;                  // radians per pixel\nconst float WALK_SPEED = 1.0;                          // units (meters) per second\nconst float SPRINT_SPEED = 4.0;                        // units (meters) per second\nconst float VERTICAL_FOV = 75.0;                       // degrees\nconst float VERTICAL_FOV_ZOOM = 20.0;                  // degrees\nconst float VERTICAL_FOV_ZOOM_ANIMATION_SPEED = 500.0; // degrees per second\n\nconst int KEY_MOVE_FORWARD = 87;  // W\nconst int KEY_MOVE_BACKWARD = 83; // S\nconst int KEY_MOVE_LEFT = 65;     // A\nconst int KEY_MOVE_RIGHT = 68;    // D\nconst int KEY_MOVE_UP = 32;       // SPACE\nconst int KEY_MOVE_DOWN = 17;     // CTRL\nconst int KEY_MOVE_SPRINT = 16;   // SHIFT\nconst int KEY_ZOOM = 70;          // F\n\nconst float PI = 3.14159265;\n\nstruct Rotor3d {\n    float scalar;\n    float xy;\n    float yz;\n    float zx;\n};\nstruct RigidTransform {\n    vec3 translation;\n    Rotor3d orientation;\n};\n\nRotor3d from_to_rotor(vec3 from_dir, vec3 to_dir) {\n    from_dir = normalize(from_dir);\n    to_dir = normalize(to_dir);\n    // Calculations below assume the input directions are normalised\n    vec3 halfway = normalize(from_dir + to_dir);\n    vec3 wedge = vec3(\n        (halfway.x * from_dir.y) - (halfway.y * from_dir.x),\n        (halfway.y * from_dir.z) - (halfway.z * from_dir.y),\n        (halfway.z * from_dir.x) - (halfway.x * from_dir.z));\n    Rotor3d result;\n    result.scalar = dot(from_dir, halfway);\n    result.xy = wedge.x;\n    result.yz = wedge.y;\n    result.zx = wedge.z;\n    return result;\n}\nRotor3d reverse(Rotor3d r) {\n    Rotor3d result;\n    result.scalar = r.scalar,\n    result.xy = -r.xy;\n    result.yz = -r.yz;\n    result.zx = -r.zx;\n    return result;\n}\nvec3 transform(Rotor3d r, vec3 v) {\n    // Assume r is formed by the multiplication of two unit vectors.\n    // Then S = Rv, result = SR^{-1} where R^{-1} is just R with the bivector coefficients negated\n    float S_x = r.scalar * v.x + r.xy * v.y - r.zx * v.z;\n    float S_y = r.scalar * v.y - r.xy * v.x + r.yz * v.z;\n    float S_z = r.scalar * v.z - r.yz * v.y + r.zx * v.x;\n    float S_xyz = r.xy * v.z + r.yz * v.x + r.zx * v.y;\n\n    vec3 result;\n    result.x = S_x * r.scalar + S_y * r.xy + S_xyz * r.yz - S_z * r.zx;\n    result.y = S_y * r.scalar - S_x * r.xy + S_z * r.yz + S_xyz * r.zx;\n    result.z = S_z * r.scalar + S_xyz * r.xy - S_y * r.yz + S_x * r.zx;\n    return result;\n}\n\nstruct Player {\n    vec3 pos;\n    vec4 rot;\n\n    float near;\n    float fov;\n    vec2 mouse_state;\n};\n\nstruct Camera {\n    mat4 view_to_clip;\n    mat4 clip_to_view;\n    mat4 world_to_view;\n    mat4 view_to_world;\n};\n\nstruct ViewRayContext {\n    vec4 ray_dir_cs;\n    vec4 ray_dir_vs_h;\n    vec4 ray_dir_ws_h;\n    vec4 ray_origin_cs;\n    vec4 ray_origin_vs_h;\n    vec4 ray_origin_ws_h;\n};\n\nvoid player_init(inout Player self) {\n    self.pos = vec3(3.0, 3.0, 2.5);\n    self.rot = vec4(-2.4, 1.0, 0.0, 0.0);\n    self.near = 0.01;\n    self.fov = VERTICAL_FOV;\n    self.mouse_state = vec2(-1.0);\n}\n\nvoid player_update(inout Player self, float dt, vec4 mouse_pos, sampler2D keyboard_image) {\n    vec2 mouse_delta = vec2(0.0);\n    if (self.mouse_state.x > 0.0) {\n        mouse_delta = mouse_pos.xy - self.mouse_state;\n    }\n    if (mouse_pos.z > 0.0) {\n        self.mouse_state = mouse_pos.xy;\n    } else {\n        self.mouse_state = vec2(-1.0);\n    }\n\n    self.rot.x += mouse_delta.x * MOUSE_SENSITIVITY;\n    self.rot.y += mouse_delta.y * MOUSE_SENSITIVITY;\n\n    self.rot.y = clamp(self.rot.y, 0.0, PI);\n\n    vec3 forward = vec3(sin(self.rot.x), cos(self.rot.x), 0.0);\n    vec3 right = vec3(forward.yx * vec2(1.0, -1.0), 0.0);\n    vec3 up = vec3(0.0, 0.0, 1.0);\n\n#define LOAD_KEY(KEY) texelFetch(keyboard_image, ivec2(KEY, 0), 0).x > 0.0\n\n    float speed = WALK_SPEED;\n    if (LOAD_KEY(KEY_MOVE_SPRINT)) {\n        speed = SPRINT_SPEED;\n    }\n\n    if (LOAD_KEY(KEY_MOVE_FORWARD)) {\n        self.pos += forward * speed * dt;\n    }\n    if (LOAD_KEY(KEY_MOVE_BACKWARD)) {\n        self.pos -= forward * speed * dt;\n    }\n    if (LOAD_KEY(KEY_MOVE_LEFT)) {\n        self.pos -= right * speed * dt;\n    }\n    if (LOAD_KEY(KEY_MOVE_RIGHT)) {\n        self.pos += right * speed * dt;\n    }\n    if (LOAD_KEY(KEY_MOVE_UP)) {\n        self.pos += up * speed * dt;\n    }\n    if (LOAD_KEY(KEY_MOVE_DOWN)) {\n        self.pos -= up * speed * dt;\n    }\n\n    if (LOAD_KEY(KEY_ZOOM)) {\n        self.fov = clamp(self.fov - dt * VERTICAL_FOV_ZOOM_ANIMATION_SPEED, VERTICAL_FOV_ZOOM, VERTICAL_FOV);\n    } else {\n        self.fov = clamp(self.fov + dt * VERTICAL_FOV_ZOOM_ANIMATION_SPEED, VERTICAL_FOV_ZOOM, VERTICAL_FOV);\n    }\n\n#undef LOAD_KEY\n}\n\nmat4 rotation_matrix(float yaw, float pitch, float roll) {\n    float sin_rot_x = sin(pitch), cos_rot_x = cos(pitch);\n    float sin_rot_y = sin(roll), cos_rot_y = cos(roll);\n    float sin_rot_z = sin(yaw), cos_rot_z = cos(yaw);\n    return mat4(\n               cos_rot_z, -sin_rot_z, 0, 0,\n               sin_rot_z, cos_rot_z, 0, 0,\n               0, 0, 1, 0,\n               0, 0, 0, 1) *\n           mat4(\n               1, 0, 0, 0,\n               0, cos_rot_x, sin_rot_x, 0,\n               0, -sin_rot_x, cos_rot_x, 0,\n               0, 0, 0, 1) *\n           mat4(\n               cos_rot_y, -sin_rot_y, 0, 0,\n               sin_rot_y, cos_rot_y, 0, 0,\n               0, 0, 1, 0,\n               0, 0, 0, 1);\n}\nmat4 inv_rotation_matrix(float yaw, float pitch, float roll) {\n    float sin_rot_x = sin(-pitch), cos_rot_x = cos(-pitch);\n    float sin_rot_y = sin(-roll), cos_rot_y = cos(-roll);\n    float sin_rot_z = sin(-yaw), cos_rot_z = cos(-yaw);\n    return mat4(\n               cos_rot_y, -sin_rot_y, 0, 0,\n               sin_rot_y, cos_rot_y, 0, 0,\n               0, 0, 1, 0,\n               0, 0, 0, 1) *\n           mat4(\n               1, 0, 0, 0,\n               0, cos_rot_x, sin_rot_x, 0,\n               0, -sin_rot_x, cos_rot_x, 0,\n               0, 0, 0, 1) *\n           mat4(\n               cos_rot_z, -sin_rot_z, 0, 0,\n               sin_rot_z, cos_rot_z, 0, 0,\n               0, 0, 1, 0,\n               0, 0, 0, 1);\n}\nmat4 translation_matrix(vec3 pos) {\n    return mat4(\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        pos, 1);\n}\n\nCamera player_get_camera(Player self, vec4 tex_size) {\n    Camera result;\n\n    float aspect = tex_size.x * tex_size.w;\n    float tan_half_fov = tan(self.fov * PI / 180.0 * 0.5);\n\n    result.view_to_clip = mat4(0.0);\n    result.view_to_clip[0][0] = +1.0 / tan_half_fov / aspect;\n    result.view_to_clip[1][1] = +1.0 / tan_half_fov;\n    result.view_to_clip[2][2] = +0.0;\n    result.view_to_clip[2][3] = -1.0;\n    result.view_to_clip[3][2] = self.near;\n\n    result.clip_to_view = mat4(0.0);\n    result.clip_to_view[0][0] = tan_half_fov * aspect;\n    result.clip_to_view[1][1] = tan_half_fov;\n    result.clip_to_view[2][2] = +0.0;\n    result.clip_to_view[2][3] = +1.0 / self.near;\n    result.clip_to_view[3][2] = -1.0;\n\n    result.view_to_world = translation_matrix(self.pos) * rotation_matrix(self.rot.x, self.rot.y, self.rot.z);\n    result.world_to_view = inv_rotation_matrix(self.rot.x, self.rot.y, self.rot.z) * translation_matrix(-self.pos);\n\n    return result;\n}\n\nvec2 get_uv(vec2 pix, vec4 tex_size) { return (floor(pix) + 0.5) * tex_size.zw; }\nvec2 cs_to_uv(vec2 cs) { return cs * vec2(0.5, -0.5) + vec2(0.5, 0.5); }\nvec2 uv_to_cs(vec2 uv) { return (uv - 0.5) * vec2(2.0, -2.0); }\n\nViewRayContext vrc_from_uv(Camera cam, vec2 uv) {\n    ViewRayContext res;\n\n    res.ray_dir_cs = vec4(uv_to_cs(uv), 0.0, 1.0);\n    res.ray_dir_vs_h = cam.clip_to_view * res.ray_dir_cs;\n    res.ray_dir_ws_h = cam.view_to_world * res.ray_dir_vs_h;\n    res.ray_origin_cs = vec4(uv_to_cs(uv), 1.0, 1.0);\n    res.ray_origin_vs_h = cam.clip_to_view * res.ray_origin_cs;\n    res.ray_origin_ws_h = cam.view_to_world * res.ray_origin_vs_h;\n\n    return res;\n}\n\nvec3 ray_dir_vs(in ViewRayContext vrc) { return normalize(vrc.ray_dir_vs_h.xyz); }\nvec3 ray_dir_ws(in ViewRayContext vrc) { return normalize(vrc.ray_dir_ws_h.xyz); }\nvec3 ray_origin_vs(in ViewRayContext vrc) { return vrc.ray_origin_vs_h.xyz / vrc.ray_origin_vs_h.w; }\nvec3 ray_origin_ws(in ViewRayContext vrc) { return vrc.ray_origin_ws_h.xyz / vrc.ray_origin_ws_h.w; }\n\n// ShaderToy-specific code\n\nPlayer load_player(sampler2D player_image) {\n    Player result;\n    result.pos = texelFetch(player_image, ivec2(0, 0), 0).xyz;\n    result.rot = texelFetch(player_image, ivec2(1, 0), 0);\n    vec4 nf = texelFetch(player_image, ivec2(2, 0), 0);\n    result.mouse_state = texelFetch(player_image, ivec2(3, 0), 0).xy;\n    result.near = nf.x;\n    result.fov = nf.y;\n    return result;\n}\n\nvoid save_player(Player self, out vec4 fragColor, vec2 fragCoord) {\n    ivec2 pixel_i = ivec2(fragCoord);\n    if (pixel_i.y == 0 && pixel_i.x <= 4) {\n        switch (pixel_i.x) {\n        case 0:\n            fragColor = vec4(self.pos, 0.0);\n            break;\n        case 1:\n            fragColor = self.rot;\n            break;\n        case 2:\n            fragColor = vec4(self.near, self.fov, 0.0, 0.0);\n            break;\n        case 3:\n            fragColor = vec4(self.mouse_state, 0.0, 0.0);\n            break;\n        }\n    }\n}\n\n//=============================================================\n//  This file is part of the SymVox (Symmetry Voxelization) software\n//  Copyright (C) 2016 by CRS4 Visual Computing Group, Pula, Italy\n//\n//  For more information, visit the CRS4 Visual Computing Group\n//  web pages at http://vic.crs4.it\n//\n//  This file may be used under the terms of the GNU General Public\n//  License as published by the Free Software Foundation and appearing\n//  in the file LICENSE included in the packaging of this file.\n//\n//  CRS4 reserves all rights not expressly granted herein.\n//\n//  This file is provided AS IS with NO WARRANTY OF ANY KIND,\n//  INCLUDING THE WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS\n//  FOR A PARTICULAR PURPOSE.\n//=============================================================\n\n// Defined from outside:\n// SVDAG || USSVDAG || SSVDAG\n// SSVDAG_TEX3D\n// VIEWER_MODE || DEPTH_MODE || SHADOW_MODE || AO_MODE\n// N_HS_SAMPLES\n\nconst vec3 sceneBBoxMin = vec3(0);\nconst vec3 sceneBBoxMax = vec3(2);\n\nconst vec3 sceneCenter = (sceneBBoxMax + sceneBBoxMin) * 0.5;\n// half the width of the root-node. Aka half the max extent\nconst float rootHalfSide = max(max(sceneBBoxMax.x - sceneBBoxMin.x, sceneBBoxMax.y - sceneBBoxMin.y), sceneBBoxMax.z - sceneBBoxMin.z) / 2.0;\nconst uint drawLevel = 12u;\nconst uint maxIters = 300u;\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct traversal_status {\n    float t_current;\n    int node_index;\n    uint hdr;\n    ivec3 mirror_mask;\n    uvec2 leaf_data;\n\n    ivec3 idx;\n    ivec3 local_idx;\n    uint child_linear_index;\n    vec3 t_next_crossing;\n    vec3 inv_ray_d;\n    ivec3 delta_idx;\n    int current_node_size;\n\n    float cell_size;\n    uint level;\n};\n\n//////////////////////////// STACK STUFF ////////////////////\n\n#define INNER_LEVELS 12\n#define MAX_STACK_DEPTH (INNER_LEVELS + 1)\n\nivec3 stack[MAX_STACK_DEPTH];\nuint stack_size = 0u;\n\nvoid stack_push(in int node, in uint hdr, in ivec3 mirror_mask, in uint level) {\n    int mask = mirror_mask.x | (mirror_mask.y << 1) | (mirror_mask.z << 2) | int(level << 3);\n    stack[stack_size] = ivec3(node, hdr, mask);\n    ++stack_size;\n}\n\nvoid stack_pop_in(out int node, out uint hdr, out ivec3 mirror_mask, out uint level) {\n    --stack_size;\n    ivec3 node_mask = stack[stack_size];\n    node = node_mask.x;\n    hdr = uint(node_mask.y);\n    int mask = node_mask.z;\n    mirror_mask = ivec3(mask & 1, (mask >> 1) & 1, (mask >> 2) & 1);\n    level = uint(mask >> 3u) & 255u;\n}\n\nbool stack_is_empty() {\n    return stack_size == 0u;\n}\n\nuint voxel_to_linear_idx(in ivec3 mirror_mask, in ivec3 idx, in int sz) {\n    idx = (ivec3(1) - 2 * mirror_mask) * idx + mirror_mask * (sz - 1);\n    return uint(idx.z + sz * (idx.y + sz * idx.x));\n}\n\n#define SVDAG 1\n#define USSVDAG 0\n\nint bit_count(int x) {\n    int c;\n    c = (x & 0x55555555) + ((x >> 1) & 0x55555555);\n    c = (c & 0x33333333) + ((c >> 2) & 0x33333333);\n    c = (c & 0x0F0F0F0F) + ((c >> 4) & 0x0F0F0F0F);\n    c = (c & 0x00FF00FF) + ((c >> 8) & 0x00FF00FF);\n    c = (c & 0x0000FFFF) + ((c >> 16) & 0x0000FFFF);\n    return c;\n}\n\nuvec4 fetch_buffer(int index) {\n    // Given that you have SVDAG voxel data, here's where you'd supply it\n    return uvec4(16 + 4 + 2);\n}\n\n#if SVDAG // ----------------------------------------------------------------------\n\n#define LEAF_SIZE 2\n\nuint myFetch(in int idx) {\n    // On AMD GPUs this causes some problems for files > 32 MM. Took some time to find this out\n    // The idx is signed, so cast it to unsigned\n    // uvec4 tmp = fetch_buffer(idx/4);\n    uvec4 tmp = fetch_buffer(int(uint(idx) / 4u));\n\n    int selected = idx % 4;\n    uint result;\n    if (selected == 0)\n        result = tmp.x;\n    else if (selected == 1)\n        result = tmp.y;\n    else if (selected == 2)\n        result = tmp.z;\n    else if (selected == 3)\n        result = tmp.w;\n    return result;\n}\n\nbool fetch_voxel_bit(in traversal_status ts) {\n    return (ts.hdr & (1u << ts.child_linear_index)) != 0u;\n}\n\nvoid fetch_data(inout traversal_status ts) {\n    ts.hdr = myFetch(ts.node_index);\n}\n\nvoid fetch_child_index_in(inout traversal_status ts) {\n    int childPtrPos = bit_count((int(ts.hdr) & 0xFF) >> ts.child_linear_index);\n    ts.node_index = int(myFetch(ts.node_index + childPtrPos));\n}\n\n#elif USSVDAG // ------------------------------------------------------------------\n\n#define LEAF_SIZE 2\n\nuint myFetch(in int idx) {\n    uvec4 tmp = fetch_buffer(int(uint(idx) / 4u));\n    int selected = idx % 4;\n    uint result;\n    if (selected == 0)\n        result = tmp.x;\n    else if (selected == 1)\n        result = tmp.y;\n    else if (selected == 2)\n        result = tmp.z;\n    else if (selected == 3)\n        result = tmp.w;\n    return result;\n}\n\nbool fetch_voxel_bit(in traversal_status ts) {\n    return (ts.hdr & (1u << ts.child_linear_index)) != 0u;\n}\n\nvoid fetch_data(inout traversal_status ts) {\n    ts.hdr = myFetch(ts.node_index);\n}\n\nvoid fetch_child_index_in(inout traversal_status ts) {\n    int childPtrPos = bit_count((int(ts.hdr) & 0xFF) >> ts.child_linear_index);\n    ts.node_index = int(myFetch(ts.node_index + childPtrPos));\n    ivec3 m = ivec3(0, 0, 0); // FIXME optimize\n    if ((ts.hdr & (1u << (ts.child_linear_index + 8u))) != 0u)\n        m.x = 1;\n    if ((ts.hdr & (1u << (ts.child_linear_index + 16u))) != 0u)\n        m.y = 1;\n    if ((ts.hdr & (1u << (ts.child_linear_index + 24u))) != 0u)\n        m.z = 1;\n    ts.mirror_mask ^= m;\n}\n\n#endif\n\n///////////////////////////// DDA PRIMITIVES\n\nbool in_bounds(in ivec3 local_idx, in int sz) {\n    bvec3 cond0 = lessThan(local_idx, ivec3(sz));\n    bvec3 cond1 = lessThanEqual(ivec3(0, 0, 0), local_idx);\n    return cond0.x && cond0.y && cond0.z && cond1.x && cond1.y && cond1.z;\n}\n\nvec2 intersectAABB(in Ray r, in vec3 aabbMin, in vec3 aabbMax) {\n    vec3 t1 = (aabbMin - r.o) / r.d;\n    vec3 t2 = (aabbMax - r.o) / r.d;\n    vec3 tMin = min(t1, t2);\n    vec3 tMax = max(t1, t2);\n\n    vec2 t = vec2(max(max(tMin.x, 0.0), max(tMin.y, tMin.z)), min(tMax.x, min(tMax.y, tMax.z)));\n    return t;\n}\n\nbool resolution_ok(float t, float cell_size, float projection_factor) {\n    return (cell_size * projection_factor) < t;\n}\n\n// ==========================================================================\n\nvoid dda_init(in Ray r, inout traversal_status ts) {\n    // Init dda FIXME USE OCTREE POINT LOCATION\n    float voxel_eps = 1.0f / (256. * 1024.);\n    vec3 p_a = r.o + (ts.t_current + voxel_eps) * r.d; // find current pos\n    ts.idx = ivec3(p_a / ts.cell_size);                // current global grid voxel\n\n    // During initialization do not step back for dir < 0, because it would move of more than once cell\n    ivec3 delta_idx_conservative = max(ivec3(0), ts.delta_idx);\n    ivec3 idx_next = ts.idx + delta_idx_conservative;\n    vec3 p_next_a = vec3(idx_next) * ts.cell_size; // this should be the plane\n\n    ts.t_next_crossing = (p_next_a - r.o) * ts.inv_ray_d;\n    ts.local_idx = ts.idx % 2;\n}\n\n// https://stackoverflow.com/questions/24599502/is-there-a-built-in-function-in-glsl-for-and-or-is-there-some-optimized-method-f\nbvec3 bvec3_and(bvec3 one, bvec3 two) {\n    return bvec3(uvec3(one) & uvec3(two));\n}\n\n// Returns the direction of the step\nivec3 dda_next(inout traversal_status ts) {\n    bvec3 b1 = lessThan(ts.t_next_crossing.xyz, ts.t_next_crossing.yzx);\n    bvec3 b2 = lessThanEqual(ts.t_next_crossing.xyz, ts.t_next_crossing.zxy);\n    bvec3 mask = bvec3_and(b1, b2);\n    vec3 mask_v3 = vec3(mask);\n\n    // All components of mask are false except the one components to the shortest t_next_crossing\n    //  which is the direction in which the step have to be done\n    ivec3 delta = ivec3(mask) * ts.delta_idx;\n    ts.idx += delta;\n    ts.local_idx += delta;\n\n    ts.t_current = dot(mask_v3, ts.t_next_crossing);\n    ts.t_next_crossing += mask_v3 * ts.cell_size * abs(ts.inv_ray_d);\n    return delta;\n}\n\nivec3 dda_next_delta_index(in traversal_status ts) {\n    bvec3 b1 = lessThan(ts.t_next_crossing.xyz, ts.t_next_crossing.yzx);\n    bvec3 b2 = lessThanEqual(ts.t_next_crossing.xyz, ts.t_next_crossing.zxy);\n    bvec3 mask = bvec3_and(b1, b2);\n    return ivec3(mask) * ts.delta_idx;\n}\n\nvoid up_in(in Ray r, inout traversal_status ts) {\n    uint delta_level = ts.level;\n    stack_pop_in(ts.node_index, ts.hdr, ts.mirror_mask, ts.level);\n    delta_level -= ts.level;\n\n    ts.idx >>= delta_level; // always delta_level >= 1\n    ts.cell_size *= float(1 << delta_level);\n    ts.current_node_size = ts.level < uint(INNER_LEVELS) ? 2 : LEAF_SIZE;\n    ts.local_idx = ts.idx & 1;\n\n    ivec3 delta_idx_conservative = max(ivec3(0), ts.delta_idx);\n    ivec3 idx_next = ts.idx + delta_idx_conservative;\n    vec3 p_next_a = vec3(idx_next) * ts.cell_size; // this should be the plane\n    ts.t_next_crossing = (p_next_a - r.o) * ts.inv_ray_d;\n}\n\nvoid go_down_one_level(in Ray r, inout traversal_status ts) {\n    ++ts.level;\n    ts.cell_size *= 0.5;\n\n    // Init ts idx, t_next_crossing, local_idx using octree point location\n    vec3 p_a = r.o + ts.t_current * r.d;\n    vec3 p_center = vec3(ts.idx * 2 + 1) * ts.cell_size;\n    bvec3 child_pos = lessThan(p_center, p_a);\n    ivec3 delta = ivec3(child_pos);\n    ts.idx = ts.idx * 2 + delta;\n\n    ivec3 delta_idx_conservative = max(ivec3(0), ts.delta_idx);\n    ivec3 idx_next = ts.idx + delta_idx_conservative;\n    vec3 p_next_a = vec3(idx_next) * ts.cell_size; // this should be the plane\n\n    ts.t_next_crossing = (p_next_a - r.o) * ts.inv_ray_d;\n    ts.local_idx = ts.idx & (ts.current_node_size - 1);\n}\n\nvoid down_in(in Ray r, inout traversal_status ts) {\n    // Check/push next\n    ivec3 local_idx = ts.local_idx;\n    ivec3 delta = dda_next_delta_index(ts);\n\n    if (in_bounds(local_idx + delta, 2)) {\n        stack_push(ts.node_index, ts.hdr, ts.mirror_mask, ts.level);\n    }\n\n    // Go down to next level: Fetch child index (store in node_idx)\n    // and update accumulated_mirror_mask\n    fetch_child_index_in(ts);\n\n    go_down_one_level(r, ts);\n\n    if (ts.level == uint(INNER_LEVELS)) {\n        // GO TO LEAVES\n        ts.current_node_size = LEAF_SIZE;\n        int voxel_count = LEAF_SIZE / 2;\n        while (voxel_count > 1) {\n            go_down_one_level(r, ts);\n            voxel_count >>= 1;\n        }\n    }\n}\n\nbool transform_ray(inout Ray r, inout vec2 t_min_max) {\n    float epsilon = 1E-4f;\n    vec3 sign_rd = sign(r.d);\n\n    // Move ray to LOCAL box\n    float scale = 1.0 / (2.0 * rootHalfSide);\n    vec3 octree_min = sceneCenter - vec3(rootHalfSide);\n    vec3 octree_max = sceneCenter + vec3(rootHalfSide);\n    r.o = r.o - octree_min;\n    r.o *= scale;\n    t_min_max *= scale;\n\n    // avoid div by zero\n    if (r.d.x * sign_rd.x < epsilon)\n        r.d.x = sign_rd.x * epsilon;\n    if (r.d.y * sign_rd.y < epsilon)\n        r.d.y = sign_rd.y * epsilon;\n    if (r.d.z * sign_rd.z < epsilon)\n        r.d.z = sign_rd.z * epsilon;\n\n    vec3 clip_box_min = (sceneBBoxMin - octree_min) * scale;\n    vec3 clip_box_max = (sceneBBoxMax - octree_min) * scale;\n\n    vec2 t_intersection = intersectAABB(r, clip_box_min, clip_box_max);\n\n    t_min_max.x = max(t_intersection.x, t_min_max.x + 1e-10);\n    t_min_max.y = min(t_intersection.y, t_min_max.y);\n\n    return t_intersection.x < t_intersection.y;\n}\n\nvoid init(inout Ray r, inout traversal_status ts) {\n    ts.inv_ray_d = vec3(1.0 / r.d);\n    ts.delta_idx = ivec3(sign(r.d));\n\n    // Level status\n    ts.mirror_mask = ivec3(0, 0, 0);\n    ts.level = 0u;\n    ts.cell_size = 0.5;\n\n    // Step status\n    dda_init(r, ts);\n    ts.current_node_size = 2;\n\n    ts.node_index = 0;\n    fetch_data(ts);\n    ts.child_linear_index = voxel_to_linear_idx(ts.mirror_mask, ts.local_idx, ts.current_node_size);\n}\n\n// TRACE RAY\n// returns vec3\n//\tX: intersection t\n//\t\t >= 0 := intersection!\n//\t\t-1   := inside scene bbox, but no intersection\n//\t\t-2   := -2 out of t bounds\n//\t\t-3   := too many iterations used (> maxIters)\n//\t\t-4   := out of scene bbox\n//\tY: level of the intersection (-1 => no intersection)\n//\tZ: num Iterations used.\n//  W: node index (-1 => no intersection)\n\nvec4 trace_ray(in Ray r, in vec2 t_min_max, in float projection_factor, out vec3 norm) {\n\n    if (!transform_ray(r, t_min_max))\n        return vec4(-4.0, 0, 0, -1); // out of scene Bbox\n\n    float scale = 2.0 * rootHalfSide;\n    traversal_status ts;\n    ts.t_current = t_min_max.x;\n    init(r, ts);\n\n    ivec3 stepDir = ivec3(0);\n\n    int iteration_count = 0;\n    uint max_level = min(uint(INNER_LEVELS), drawLevel - 1u);\n    do {\n        bool full_voxel = fetch_voxel_bit(ts);\n\n        if (!full_voxel) {\n            stepDir = dda_next(ts);\n            if (!in_bounds(ts.local_idx, ts.current_node_size)) {\n                if (stack_is_empty()) {\n                    return vec4(-1., 0, float(iteration_count), -1); // inside scene BBox, but no intersection\n                }\n                up_in(r, ts);\n            }\n        } else {\n            bool hit = (ts.level >= max_level || resolution_ok(ts.t_current, ts.cell_size, projection_factor));\n            if (hit) {\n                norm = -vec3(stepDir);\n                return vec4(ts.t_current * scale, ts.level, float(iteration_count), ts.node_index); // intersection\n            } else {\n                down_in(r, ts);\n                fetch_data(ts);\n            }\n        }\n\n        ts.child_linear_index = voxel_to_linear_idx(ts.mirror_mask, ts.local_idx, ts.current_node_size);\n        ++iteration_count;\n    } while ((ts.t_current < t_min_max.y) && (uint(iteration_count) < maxIters));\n\n    if (uint(iteration_count) >= maxIters)\n        return vec4(-3., 0, float(iteration_count), -1); // too much itarations\n    return vec4(-2., 0, float(iteration_count), -1);     // intersection out of t bounds\n}\n", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Player player = load_player(iChannel0);\n\n    if (iFrame == 0) {\n        player_init(player);\n    } else {\n        player_update(player, iTimeDelta, iMouse, iChannel1);\n    }\n\n    // This buffer isn't wasted for another use, it just stores the player state in a few pixels.\n    // So basically, it's only necessary that you call `save_player` last in this function to ensure\n    // the player state is saved in the necessary pixels.\n\n    save_player(player, fragColor, fragCoord);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/McXGRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 56, 56, 1072]], "test": "untested"}
{"id": "Xcl3z2", "name": "Burnt Orange", "author": "TheSandvichMaker", "description": "LMB to look around.", "tags": ["raymarching", "ray", "raymarch", "clouds", "volumetric", "atmosphere", "march"], "likes": 2, "viewed": 229, "published": 3, "date": "1703278691", "time_retrieved": "2024-07-30T17:15:06.118716", "image_code": "// iChannel0: BufferB\n// iChannel1: Blue Noise\n\nconst float sharpen_kernel[9] = float[](\n\t-0.0023, -0.0432, -0.0023,\n\t-0.0432,  1.1820, -0.0432,\n\t-0.0023, -0.0432, -0.0023\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 sharpened = vec3(0.0);\n\n    for (int yy = 0; yy < 3; yy++)\n    {\n        for (int xx = 0; xx < 3; xx++)\n        {\n            vec3  x = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(xx - 1, yy - 1), 0).rgb;\n            float w = sharpen_kernel[xx + 3*yy];\n            sharpened += x*w;\n        }\n    }\n\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n\n    col = mix(col, sharpened, float(SHARPEN_AMOUNT));\n\n    vec4 blue_noise = texelFetch(iChannel1, ivec2(fragCoord.xy) % ivec2(1024, 1024), 0);\n    float phi = 0.5*(1.0 + sqrt(5.0));\n    blue_noise = fract(blue_noise + float(iFrame)*phi);\n\n    vec3 dither = -1.0 + 2.0*vec3(remap_pdf_tri_erp(blue_noise.r),\n                                  remap_pdf_tri_erp(blue_noise.g),\n                                  remap_pdf_tri_erp(blue_noise.b));\n\n    col = saturate(col + dither / 255.0);\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//\n// Settings\n//\n\n// Quality settings:\n// 2: high\n// 1: normal\n// 0: bad\n#define QUALITY 1\n\n#define TAA_ENABLED 1\n#define TAA_USE_NEIGHBORHOOD_CLAMPING 1\n#define TAA_ALPHA 0.1\n#define SHARPEN_AMOUNT 8.0\n\n#if QUALITY == 2\n#define PRIMARY_STEP_COUNT 32\n#define SHADOW_STEP_COUNT 128\n#elif QUALITY == 1\n#define PRIMARY_STEP_COUNT 24\n#define SHADOW_STEP_COUNT 64\n#else\n#define PRIMARY_STEP_COUNT 16\n#define SHADOW_STEP_COUNT 32\n#endif\n\n#define PRIMARY_MAX_DISTANCE 3500\n#define SHADOW_MAX_DISTANCE 2000\n#define AMBIENT_STRENGTH 2.25\n#define STEP_NONLINEARITY 2\n#define CAMERA_FILM_DISTANCE 1.55 // TODO: Fov in degrees\n\n//\n// Internal common stuff\n//\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define rcp(x) (1.0 / (x))\n#define PI 3.14159265\n\n#define remap01(x, out_lo, out_hi) ((out_lo) + x*((out_hi) - (out_lo)))\n\n// taken from https://www.shadertoy.com/view/WldSRf\nfloat remap_pdf_tri_erp( const float v )\n{\n    float r2 = 0.5 * v;\n    float f1 = sqrt( r2 );\n    float f2 = 1.0 - sqrt( r2 - 0.25 );\n    return (v < 0.5) ? f1 : f2;\n}\n\nvec3 get_camera(in vec3 zz, in vec2 p, in float tilt, out vec3 xx, out vec3 yy)\n{\n    vec3 world_up = normalize(vec3(-0.12*tilt, 1, 0));\n    xx = normalize(cross(zz, world_up));\n    yy = normalize(cross(xx, zz));\n\n    vec3 rd = normalize(p.x*xx + p.y*yy + CAMERA_FILM_DISTANCE*zz);\n    return rd;\n}\n\n// bilateral = value between -1 and 1\n// encoding/decoding to pass along between passes\nfloat encode_bilateral(float x)\n{\n    return 0.5 + 0.5*x;\n}\n\nfloat decode_bilateral(float x)\n{\n    return 2.0*x - 1.0;\n}\n\nvec3 encode_direction(vec3 dir)\n{\n    return vec3(0.5) + 0.5*dir;\n}\n\nvec3 decode_direction(vec3 dir)\n{\n    return 2.0*dir - vec3(1.0);\n}\n", "buffer_a_code": "// iChannel0: BufferA\n// iChannel1: Blue Noise\n\nstruct Scene\n{\n    vec3 noise;\n\n    vec3 sun_dir;\n    vec3 sun_col;\n\n    vec3 atmos_absorption;\n    vec3 atmos_scattering;\n    float atmos_k;\n\n    vec3 atmos_absorption2;\n    vec3 atmos_scattering2;\n    float atmos_k2;\n\n    float cloud_absorption;\n    float cloud_scattering;\n    float cloud_k;\n\n    float cloud_top;\n    float cloud_top_fade;\n    float cloud_bot;\n    float cloud_bot_fade;\n};\n\n// integer hash credit: https://www.shadertoy.com/view/XlXcW4\nvec3 integer_hash3( uvec3 x )\n{\n    const uint k = 1103515245U;  // GLIB C\n                                 //\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n// 3D perlin noise credit: https://www.shadertoy.com/view/Xsl3Dl\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 sky_color(in Scene s, vec2 uv, vec3 d)\n{\n    vec3 bot = vec3(0.6, 0.12, 0.05);\n    vec3 top = vec3(0.6, 0.55, 0.45);\n    vec3 col = 0.5*mix(bot, top, saturate(d.y));\n    col *= 1.0 + min(0.0, d.y);\n\n    // sun dust\n    float sun_dust_speed = 0.04;\n    float sun_dust_scale = 0.2;\n    vec3 sun_dust = vec3(0.0);\n    sun_dust += texture(iChannel1, sun_dust_scale*0.125*(uv.xy + sun_dust_speed*vec2(0.12, -0.30)*iTime)).xyz;\n    sun_dust += texture(iChannel1, sun_dust_scale*0.160*(uv.xy + sun_dust_speed*vec2(0.21, -0.08)*iTime)).xyz;\n    sun_dust += texture(iChannel1, sun_dust_scale*0.190*(uv.xy + sun_dust_speed*vec2(0.35,  0.28)*iTime)).xyz;\n    sun_dust /= 3.0; // normalize\n\n    // sun disk and fake sun bloom\n\n    float haze_wobble = 0.0105;\n    vec3  d_hazy = normalize(d + haze_wobble*(sun_dust.yzx - vec3(0.5)));\n    float sun_t = max(0.0, dot(d_hazy, s.sun_dir));\n\n    float sun_mask  = smoothstep(0.9995, 0.99995, sun_t);\n    float sun_atten = 0.50 - 0.42*sun_dust.x; // fake a stronger \"hazy atmosphere\" effect\n    col += sun_atten*s.sun_col*sun_mask;\n\n    sun_t *= sun_t;\n    sun_t *= sun_t;\n    sun_t *= sun_t;\n    sun_t *= sun_t;\n    sun_t *= sun_t;\n    sun_t *= sun_t;\n    sun_t *= sun_t;\n\n    col += 0.24*s.sun_col*sun_t;\n\n    sun_t *= sun_t;\n    sun_t *= sun_t;\n    sun_t *= sun_t;\n\n    col += 0.12*s.sun_col*sun_t;\n\n    return col;\n}\n\nvec3 cloud_layer_fade(in Scene s, in vec3 x)\n{\n    float y_offset_range = 450.0;\n    vec3 slew = vec3(-550, -500, 0) + 4.0*iTime*vec3(0.2, 1.5, 0.3);\n    float y_offset = y_offset_range*(noise((x + slew) / 3000.0) - 0.15);\n\n    vec3 result = vec3(smoothstep(s.cloud_top, s.cloud_top - s.cloud_top_fade, y_offset + x.y),\n                       smoothstep(s.cloud_bot, s.cloud_bot + s.cloud_bot_fade, y_offset + x.y),\n                       smoothstep(s.cloud_bot, s.cloud_top, y_offset + x.y));\n    return result;\n}\n\nfloat cloud_density(in vec3 x)\n{\n    float result = 0.0;\n    \n    // bias noise - creates holes in the clouds by applying bias\n    vec3 scroll = vec3(200, 100, 0) + 45.0*vec3(iTime, 0.25*iTime, 0.03*iTime);\n    float bias_noise = noise((scroll + x*vec3(1, 1.2, 1)) / 1024.0);\n\n    // cloud octaves\n    float w     = 1.0;\n    float w_sum = 0.0;\n    float wx    = 0.5;\n    vec3 x_oct  = x / 256.0;\n\n    vec4 oct_turbulence[4] = vec4[](\n        vec4(0.01, -0.005, 0, 1),\n        vec4(-0.007, 0.03, 0.01, 1),\n        vec4(0.04, 0.01, -0.002, remap01(bias_noise, 0.8, 1.0)),\n        vec4(0.02, 0.005, 0.021, remap01(bias_noise, 0.5, 1.0))\n    );\n\n    for (int i = 0; i < 4; i++) \n    {\n        result += oct_turbulence[i].w*w*noise(x_oct + 1.8*iTime*oct_turbulence[i].xyz);\n        x_oct *= 2.0;\n        w_sum += w;\n        w     *= wx;\n    }\n\n    result *= rcp(w_sum);\n    float unbiased = result;\n\n    // shaping, modulating and applying the bias noise\n    float bias_height_mod = 0.25*cos(0.0195*iTime + 2.5);\n    bias_noise = max(0.0, bias_noise - (0.35 + bias_height_mod)*exp(-(x.y - 400.0) / 8192.0));\n\n    float bias_min = 0.3;\n    float bias_max = 1.0;\n    float bias_gamma = 0.8;\n\n    float bias = remap01(pow(bias_noise, bias_gamma), bias_min, bias_max);\n    result = max(0.0, result - bias) / (1.0 - bias);\n    \n    // shaping the end result with some gamma for controllable whispiness/blobbiness\n    float result_gamma = 0.75;\n    result = pow(result, result_gamma);\n\n    // pulsars\n    {\n        // float tile_size = 2048.0;\n        float tile_size = 3128.0;\n        vec2 tile   = round(vec2(x.x, x.z) / tile_size);\n        vec3 jitter = integer_hash3(uvec3(tile.x, tile.y, 123));\n        vec2 point  = tile_size*tile + tile_size*(jitter.xy - vec2(0.5));\n\n        float dist  = length(point - vec2(x.x, x.z));\n        float pulse = 5.0*sin((pow(2.0*dist, 0.9) + 35.0*iTime) / 60.0) - unbiased*3.5;\n        float atten = exp(-dist / (350.0 + 250.0*sin(0.0239*iTime + 3.14*jitter.z)));\n        result = max(0.0, result - max(0.0, pulse*atten));\n    }\n\n    return result;\n}\n\nfloat phase(float cos_theta, float k)\n{\n    float denom = (1.0 - k*cos_theta);\n    denom *= denom;\n\n    float result = 0.25*PI*(1.0 - k*k) / denom;\n    return result;\n}\n\nfloat march_cloud_shadow(in Scene s, in vec3 ro, in vec3 rd)\n{\n    int   step_count = SHADOW_STEP_COUNT;\n    float step_max   = float(SHADOW_MAX_DISTANCE);\n    float step_size  = step_max / float(step_count);\n    float t          = s.noise.y*step_size;\n\n    float extinction = s.cloud_absorption + s.cloud_scattering;\n\n    float transmittance = 1.0;\n\n    for (int i = 0; i < step_count; i++)\n    {\n        vec3 step_p = ro + t*rd;\n\n        float density = cloud_density(step_p);\n\n        vec3 layer = cloud_layer_fade(s, step_p);\n        density *= layer.x*layer.y;\n\n        transmittance *= exp(-extinction*density*step_size); \n    }\n\n    return transmittance;\n}\n\nvoid march_clouds(in Scene s, in vec2 uv, in vec3 ro, in vec3 rd, out vec3 illumination, out vec3 transmittance)\n{\n    int   step_count = PRIMARY_STEP_COUNT;\n    float step_max   = float(PRIMARY_MAX_DISTANCE);\n    // float step_size  = step_max / float(step_count);\n    // float t          = 0.0; // s.noise.x*step_size;\n\n    vec3 cloud_extinction = vec3(s.cloud_absorption + s.cloud_scattering);\n    vec3 atmos_extinction = s.atmos_absorption + s.atmos_scattering;\n\n    illumination  = vec3(0.0);\n    transmittance = vec3(1.0);\n\n    float prev_step_distance = 0.0;\n    \n    float cos_theta = -dot(rd, s.sun_dir);\n    float phase_clouds = phase(cos_theta, s.cloud_k);\n    float phase_atmos1 = phase(cos_theta, s.atmos_k);\n    float phase_atmos2 = phase(cos_theta, s.atmos_k2);\n\n    for (int i = 0; i < step_count; i++)\n    {\n        float t = (float(i) + s.noise.x) / float(step_count);\n        float step_distance = step_max*pow(t, float(STEP_NONLINEARITY));\n        float step_size = step_distance - prev_step_distance;\n        prev_step_distance = step_distance;\n        vec3 step_p = ro + step_distance*rd;\n\n        float atmos_density = exp((-step_p.y - 450.0) / 1024.0);\n\n        if (step_p.y < -1200.0)\n        {\n            atmos_density = 0.0;\n        }\n\n        float density = cloud_density(step_p);\n\n        vec3 layer = cloud_layer_fade(s, step_p);\n        density *= layer.x*layer.y;\n\n        vec3 ambient = float(AMBIENT_STRENGTH)*sky_color(s, uv, vec3(0.0, layer.z, -1.0));\n\n        float shadow = march_cloud_shadow(s, step_p, s.sun_dir);\n\n        transmittance *= exp(-cloud_extinction*density*step_size); \n        transmittance *= exp(-atmos_extinction*atmos_density*step_size);\n\n\n        vec3 in_scattering  = shadow*s.sun_col;\n\n        vec3 out_scattering = vec3(0.0);\n        out_scattering += s.cloud_scattering*density*phase_clouds;\n        out_scattering += s.atmos_scattering*atmos_density*phase_atmos1;\n        out_scattering += s.atmos_scattering2*atmos_density*phase_atmos2;\n\n        vec3 light = in_scattering * out_scattering;\n\n#if 0\n        vec3 light = vec3(0.0);\n        light += s.cloud_scattering*density*shadow*s.sun_col*phase(cos_theta, s.cloud_k);\n        light += s.atmos_scattering*atmos_density*shadow*s.sun_col*phase(cos_theta, s.atmos_k);\n        light += s.atmos_scattering2*atmos_density*shadow*s.sun_col*phase(cos_theta, s.atmos_k2);\n        light += ambient*s.cloud_scattering*density;\n#endif\n\n        illumination += transmittance*light*step_size;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // init scene\n    Scene s;\n    s.noise             = integer_hash3(uvec3(uvec2(fragCoord), iFrame));\n    s.sun_dir           = normalize(vec3(0.8, 0.15, 0.6));\n    s.sun_col           = 13.5*vec3(1.0, 0.25, 0.18);\n    s.atmos_absorption  = 1.0*vec3(0.00001, 0.0004, 0.0006);\n    s.atmos_scattering  = 0.25*vec3(0.00015, 0.0003, 0.0002);\n    s.atmos_k           = -0.7;\n    s.atmos_absorption2 = vec3(0.00001);\n    s.atmos_scattering2 = 0.23*vec3(0.00002, 0.00015, 0.00011);\n    s.atmos_k2          = 0.2;\n    s.cloud_absorption  = 0.0014;\n    s.cloud_scattering  = 0.008;\n    s.cloud_k           = -0.3;\n    s.cloud_top         = 0.0;\n    s.cloud_top_fade    = 450.0;\n    s.cloud_bot         = -1400.0;\n    s.cloud_bot_fade    = 150.0;\n\n    // calculate camera\n    vec2 p     = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    vec2 mouse = (-iResolution.xy + 2.0*iMouse.xy) / iResolution.y;\n    \n    if (iMouse.x == 0.0 && iMouse.y == 0.0)\n    {\n        mouse = vec2(-0.75, -0.20);\n    }\n\n    mouse += vec2(0.15*sin(0.025*iTime), -0.18*sin(0.049*iTime - 1.23));\n\n    float tilt = sin(0.01*iTime);\n    float tilt_sign = sign(tilt);\n    tilt *= tilt;\n    tilt *= tilt;\n    tilt *= tilt_sign;\n\n    vec3 zz = normalize(vec3(0, -0.1, 1) + vec3(-mouse.x, mouse.y, 0));\n\n    vec3 xx, yy;\n    vec3 rd = get_camera(zz, p, tilt, xx, yy);\n    vec3 ro = vec3(75, 35, -200);\n    ro += vec3(35.0*sin(0.05*iTime), 100.0*sin(0.099*iTime - 1.23) - 50.0, 46.0*iTime);\n\n    // render scene\n    vec3 col = sky_color(s, uv, rd);\n\n    vec3 illumination, transmittance;\n    march_clouds(s, uv, ro, rd, illumination, transmittance);\n\n    col = col*transmittance + illumination;\n    \n    // vignette\n    float vignette = length(p) / 2.0;\n    vignette *= vignette;\n    vignette *= vignette;\n    col *= 1.0 - vignette*0.33;\n    \n    // tonemap\n    col = vec3(1.0) - exp(-col);\n\n    // output\n    fragColor = vec4(col, 1.0);\n\n    // write out camera direction and tilt for TAA\n    if (fragCoord.y < 1.0)\n    {\n        if      (fragCoord.x < 1.0) fragColor.a = encode_bilateral(zz.x);\n        else if (fragCoord.x < 2.0) fragColor.a = encode_bilateral(zz.y);\n        else if (fragCoord.x < 3.0) fragColor.a = encode_bilateral(zz.z);\n        else if (fragCoord.x < 4.0) fragColor.a = encode_bilateral(tilt);\n    }\n    else if (fragCoord.y < 2.0)\n    {\n        if      (fragCoord.x < 1.0) fragColor.a = texelFetch(iChannel0, ivec2(0, 0), 0).a;\n        else if (fragCoord.x < 2.0) fragColor.a = texelFetch(iChannel0, ivec2(1, 0), 0).a;\n        else if (fragCoord.x < 3.0) fragColor.a = texelFetch(iChannel0, ivec2(2, 0), 0).a;\n        else if (fragCoord.x < 4.0) fragColor.a = texelFetch(iChannel0, ivec2(3, 0), 0).a;\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// iChannel0: BufferA (scene input)\n// iChannel1: BufferB (TAA output)\n\n// 0: off\n// 1: camera direction\n// 2: ray direction\n// 3: prev_uv\n// 4: uv (for reference)\n// 5: camera direction (mode 2)\n// 6: uv diff\n#define DEBUG_MODE 0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n\n#if TAA_ENABLED\n\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p  = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n    // read current camera\n    vec4 curr_data = vec4(texelFetch(iChannel0, ivec2(0, 0), 0).a,\n                          texelFetch(iChannel0, ivec2(1, 0), 0).a,\n                          texelFetch(iChannel0, ivec2(2, 0), 0).a,\n                          texelFetch(iChannel0, ivec2(3, 0), 0).a);\n\n    vec3  zz   = decode_direction(curr_data.xyz);\n    float tilt = decode_bilateral(curr_data.w);\n\n    vec3 xx, yy;\n    vec3 rd = get_camera(zz, p, tilt, xx, yy);\n\n    // read prev camera\n    vec4 prev_data = vec4(texelFetch(iChannel0, ivec2(0, 1), 0).a,\n                          texelFetch(iChannel0, ivec2(1, 1), 0).a,\n                          texelFetch(iChannel0, ivec2(2, 1), 0).a,\n                          texelFetch(iChannel0, ivec2(3, 1), 0).a);\n\n    vec3  zz_prev   = decode_direction(prev_data.xyz);\n    float tilt_prev = decode_bilateral(prev_data.w);\n\n    vec3 xx_prev, yy_prev;\n    vec3 rd_prev = get_camera(zz_prev, p, tilt_prev, xx_prev, yy_prev);\n\n    // reverse engineer pixel motion from camera rotation\n    float t              = CAMERA_FILM_DISTANCE / dot(zz_prev, rd);\n    vec2  p_prev         = vec2(dot(t*rd, xx_prev), dot(t*rd, yy_prev));\n    vec2  fragCoord_prev = 0.5*(p_prev*iResolution.y + iResolution.xy);\n    vec2  uv_prev        = fragCoord_prev / iResolution.xy;\n\n    // do TAA\n    if (uv_prev.x >= 0.0 && uv_prev.x < 1.0 &&\n        uv_prev.y >= 0.0 && uv_prev.y < 1.0)\n    {\n        vec3 old_col = texture(iChannel1, uv_prev).rgb;\n#if TAA_USE_NEIGHBORHOOD_CLAMPING\n        vec3 nb_min = col;\n        vec3 nb_max = col;\n\n        for (int yy = -1; yy <= 1; yy++)\n        {\n            for (int xx = -1; xx <= 1; xx++)\n            {\n                if (xx == 0 && yy == 0) continue;\n\n                vec3 samp = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(xx, yy), 0).rgb;\n                nb_min = min(nb_min, samp);\n                nb_max = max(nb_max, samp);\n            }\n        }\n\n        old_col = clamp(old_col, nb_min, nb_max);\n#endif\n        col     = mix(old_col, col, float(TAA_ALPHA));\n    }\n\n#if DEBUG_MODE == 1\n    col = abs(zz - zz_prev);\n#elif DEBUG_MODE == 2\n    col = abs(rd_curr - rd_prev);\n#elif DEBUG_MODE == 3\n    col = vec3(uv_prev, 0.0);\n#elif DEBUG_MODE == 4\n    col = vec3(uv, 0.0);\n#elif DEBUG_MODE == 5\n    if (uv.x < 0.5)\n        col = encode_direction(zz);\n    else\n        col = encode_direction(zz_prev);\n#elif DEBUG_MODE == 6\n    col = vec3(uv - uv_prev, 0.0);\n#endif\n\n#endif /* TAA_ENABLED */\n    \n    fragColor = vec4(col, 1.0);\n\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xcl3z2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 231, 231, 1128]], "test": "untested"}
{"id": "lcsGzj", "name": "Static Flow Field", "author": "mgmbass", "description": "Using noise to rotate cells in and out of view. ", "tags": ["perlinnoise"], "likes": 3, "viewed": 177, "published": 3, "date": "1703276348", "time_retrieved": "2024-07-30T17:15:06.889655", "image_code": "\nvec3 hash(vec3 p){\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\n\nfloat noise(in vec3 p){\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n\n\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_st);\n    uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 av = uv;\n    uv *= 16.;\n    uv = fract(uv);\n    uv -= 0.5;\n    float n = noise(vec3(av, iTime));\n    uv = rotate2D(uv, n * 5.);\n\n    vec3 b = vec3(box(uv, vec2(1.0, 0.1), 0.1));\n\n    // Output to screen\n    fragColor = vec4(b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcsGzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 19, 19, 188], [192, 192, 215, 215, 1040], [1044, 1044, 1096, 1096, 1289], [1291, 1291, 1329, 1329, 1469], [1471, 1471, 1528, 1578, 1861]], "test": "untested"}
{"id": "lcfGz2", "name": "harmonic waves trying to connect", "author": "timmaffett", "description": "reference: https://www.facebook.com/CymaticUniverse/posts/741183981377178\n-tmm just added some color\n-wrapped cos(iTime) with sin and incorporated U.y for some warping ", "tags": ["2d", "2tweets", "short", "yinyang", "reproduction"], "likes": 3, "viewed": 195, "published": 3, "date": "1703257969", "time_retrieved": "2024-07-30T17:15:07.660594", "image_code": "// Fork of \"harmonic waves w/color\" by timmaffett. https://shadertoy.com/view/McX3WH\n// 2023-12-22 15:08:10\n\n// Fork of \"harmonic waves\" by FabriceNeyret2. https://shadertoy.com/view/XfX3Dn\n// 2023-12-19 16:15:48\n\n// -2Â by Observer\n\n\nvec3 hsb2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return (c.z * mix( vec3(1.0), rgb, c.y));\n}\n\n\n//#define S(v) smoothstep( 1.5, 0., abs(v)/fwidth(v) )\n#define S(P) smoothstep( 5./R.y*i, 0., abs( length(P) - 1. ) )\n#define PI  3.14159265359\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 1.2*( u+u - R ) / R.y, V;\n         \n    float i=1., v=i;   \n    \n    O = vec4( S(U) );                                // circle\n    if ( dot(U,U) < i+3. )                               // inside only\n        for( ; i++ < 9.;  v /= 1.2 )                  // foreach harmonic\n            V = U*i, \n            V.x = mod( V.x + i + sign(V.y), 4.) - sin(cos((iTime+U.y))*2.),// arc center\n            O = max(O, S(V)*v ) ;                    // draw arc, grey=v\n    //add some color\n    if ( dot(U,U) < 0.99 )\n      O *= vec4(hsb2rgb(vec3(PI/9.*U.x,0.9,0.9)),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcfGz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[235, 235, 262, 262, 497], [644, 644, 682, 682, 1292]], "test": "untested"}
{"id": "lflGRS", "name": "Emissive Ikura", "author": "amagitakayosi", "description": "raymarching\nglow + motionblur + aberration + text", "tags": ["raymarching"], "likes": 66, "viewed": 4081, "published": 3, "date": "1703236572", "time_retrieved": "2024-07-30T17:15:08.421560", "image_code": "// global vars\nfloat light = 999.;\nfloat dark = 1.;\nfloat roty = 0.;\nfloat time;\nfloat mode;\nfloat modetime;\n\nmat2 rot(float t) {\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nvec2 map(vec3 p) {\n    p.xz *= rot(roty);\n    \n    float d1, d2;\n    d1 = d2 = 999.;    \n    \n    // White cells\n    for (int i = 0; i < 7; i++) {\n        float fi = float(i) * 0.8+ time * 0.3;\n        vec3 pp = p + vec3(\n            cos(fi* 1.7),\n            sin(fi * 2.3),\n            sin(fi * 1.9)\n        ) * 1.3;\n        pp.xz *= rot(fi * 0.1);\n        pp.xy *= rot(fi * -0.4);\n        pp *= 1. + sin(fi * 3.) * 0.1;\n        d1 = min(d1, sdSphere(pp, 1.3));\n    }\n\n    // Ikura\n    vec3 p2 = p * 2.;   \n    vec3 p3 = p2.yxz;       \n\n    p2 = abs(p2);\n    p2 -= vec3(2,0,0);        \n    d2 = min(d2, sdSphere(p2, 1.));\n\n    p3.xy *= rot(time * .7);\n    p3 = abs(p3);        \n    p3 -= vec3(2, 1, 2);\n    d2 = min(d2, sdSphere(p3, 1.));               \n\n    // Save ikura dist as light power\n    light = d2;\n\n    return d1 < d2 ? vec2(d1, 1) : vec2(d2, 2);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 d = vec2(0, 0.001);\n    return normalize(vec3(\n        (map(p + d.yxx) - map(p - d.yxx)).x,\n        (map(p + d.xyx) - map(p - d.xyx)).x,\n        (map(p + d.xxy) - map(p - d.xxy)).x\n    ));\n}\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(49., 489.))) * 39284.);\n}\n\nfloat char(vec2 uv, float i, vec2 offset) {\n    uv += offset;\n    uv = (uv - .5) * 2. + .5;\n    uv = clamp(uv, 0., 1.);\n    \n    float x = mod(i, 16.);\n    float y = 15. - floor(i / 16.);    \n    vec4 char = texture(iChannel0, (uv + vec2(x, y)) / 16.);\n    return 1. - char.a;\n}\n\nfloat text(vec2 p, bool isEdge) {\n    vec2 uv = p * 0.5 * vec2(1, 2.2) + 0.5;    \n\n    // Joint \"C\" and \"T\"\n    uv.x = max(min(uv.x, .34), min(uv.x, step(.675, uv.x) * uv.x));\n        \n    float c = 0.;\n    c = max(c, char(uv, 82., vec2(0.7, 0)));\n    c = max(c, char(uv, 69., vec2(0.51, 0)));\n    c = max(c, char(uv, 65., vec2(0.34, 0)));\n    c = max(c, char(uv, 67., vec2(0.19, 0)));\n    c = max(c, char(uv * .97, 84., vec2(-.18, 0.016))); // Adjust \"T\"\n    c = max(c, char(uv, 73., vec2(-.35, 0)));\n    c = max(c, char(uv, 79., vec2(-.5, 0)));\n    c = max(c, char(uv, 78., vec2(-.7, 0)));\n\n    return isEdge\n        ? smoothstep(.01, 0., abs(c - .5))\n        : smoothstep(.5, .52, c);\n}\n\nvec3 raymarch(in vec2 p, vec3 ro, vec3 rd) {\n    float l = length(p);\n\n    vec3 rp;\n    float t;\n    vec2 hit;\n    float iter;\n\n    vec3 col;            \n\n    // keep the iteration count low; I love the artifact\n    for (int i = 0; i < 30; i++) {\n        iter = float(i);    \n        rp = ro + rd * t;\n\n        hit = map(rp);\n        if (hit.x < 0.03) {\n            break;\n        } else if (t > 30.) {\n            hit = vec2(0);\n        }\n        \n        t += hit.x * 0.5;\n    }\n\n    vec3 ld = normalize(vec3(1, 1, 0));\n    ld.xz *= rot(-roty);\n\n    // Cheap AO with dither\n    float ao = pow(iter, .8);\n    ao *= (0.8 + 0.2 * hash(p + iTime));\n\n    vec3 n = normalize(getNormal(rp) + vec3(0, 0, hash(p * 0.2 + iTime) * 0.03));\n    if (hit.y == 1.) {                                   \n        // diffuse\n        float dif = clamp(dot(n, ld), 0., 1.) * .2;\n        float amb = 0.8;\n        col += vec3(.92, .9, .99) * (dif+amb);\n\n        // specular\n        vec3 hv = normalize(ld - rd);                \n        col += pow(clamp(dot(n,hv),0.,1.), 88.0) * 0.2;\n        \n        // reflection\n        col *= mix(vec3(1), texture(iChannel1, n).rgb * 3., .07); \n        \n        col += pow(.2 / light, 0.8) * vec3(1., .3, 0); // glow\n        col -= 0.01 * ao;\n        \n        col *= smoothstep(-8., 0.7, rp.y); // vertical shadow\n    } else if (hit.y == 2.) {     \n        // diffuse\n        float fre = pow(1. - clamp(dot(-rd, n), 0., 1.), 1.);        \n        col += pow(fre, 3.) * 7.; \n        \n        // specular\n        vec3 hv = normalize(ld - rd);                \n        col += pow(clamp(dot(n,hv),0.,1.),99.0) * 0.9; \n\n        // reflection\n        col *= mix(vec3(1), texture(iChannel1, n).rgb * 2., .9);        \n\n        // glow\n        fre = pow(1. - clamp(dot(-rd, n), 0., 1.), 8.);\n        col += mix(vec3(3., 2., 0), vec3(.2, .0, .0), fre) * 0.8;\n        col -= 0.2 * ao;\n    } else {    \n        // BG\n        col = cos(l * 1.2 - 1.2) * vec3(.94, .99, 1.) * 0.9;\n        \n        // Text animation\n        if (mode == 1. || mode == 3.) {                    \n            bool isEdge = mode > 2.;\n            float y = 0.3;\n            for (int i = 0; i < 6; i++) {\n                float fi = float(i);\n                col -= text(p + vec2(0, -.75 + float(i) * y), isEdge) * 0.7 \n                    * step(fi * .1 + .3, modetime) * step(modetime, fi * .1 + 1.3);\n                col += text(p + vec2(0, -.75 + float(i) * y), isEdge) * 0.7 \n                    * step(fi * .1 + 2., modetime) * step(modetime, fi * .1 + 3.);\n            }\n        }\n    }   \n\n    return col;\n}\n\nfloat spin(float x, float div, float slope) {\n    return (1. - exp(mod(x, div) * -3.) + floor(x / div) + x / slope);\n}\n\n#define PHASE_1 0.5\n#define PHASE_2 4.0\n#define PHASE_12 4.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n\n    time = iTime;\n    \n    // motion blur\n    float motion = exp(mod((time - PHASE_1), PHASE_12)* -2.);\n    time += motion * hash(p * vec2(.000003, 20.)) * 0.02;\n    \n    // Update global variables\n    roty = spin(time - PHASE_1, PHASE_12, 16.) * 18.;           \n    mode = mod(floor(time / PHASE_12) + floor((time - PHASE_1) / PHASE_12) + 1., 4.);\n    modetime = min(mod(time, PHASE_12), mod(time - PHASE_1, PHASE_12));\n\n    float l = length(p);\n\n    // Change camera zoom by mode\n    float zoom = 1.0;    \n    if (mode == 0.) { zoom = 3.0; }\n    else if (mode == 1.) { zoom = 1.2; }\n    else if (mode == 2.) { zoom = 2.1; p *= rot(.78); }\n    else { zoom = 1.1; }    \n\n    vec3 ro = vec3(0, 0, 5);\n    vec3 rd = normalize(vec3(p, -zoom + 0.2 * pow(l, 2.)));        \n\n    vec3 col;\n    \n    // Aberration    \n    col.r += raymarch(p, ro, rd).r;\n    col.g += raymarch(p*.99, ro, rd).g;\n    col.b += raymarch(p*.98, ro, rd).b;    \n    \n    // Overlay text\n    if (mode == 0.) {\n        col.rgb += text(p, true) * step(0., sin(time * 50.));\n    }\n    if (mode == 2.) {        \n        col.rgb -= text(abs(uv * 2. - 1.) * vec2(3, 2) - 1., false) * sin(time * 50.);\n        col.rgb = 1. - col.grb; // Invert\n    }    \n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lflGRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 129, 129, 181], [183, 183, 216, 216, 244], [246, 246, 264, 264, 1106], [1108, 1108, 1132, 1132, 1332], [1334, 1334, 1354, 1354, 1413], [1415, 1415, 1458, 1458, 1693], [1695, 1695, 1728, 1728, 2384], [2386, 2386, 2430, 2430, 4975], [4977, 4977, 5022, 5022, 5095], [5159, 5159, 5216, 5216, 6574]], "test": "untested"}
{"id": "4fXGzj", "name": "spqr alpha", "author": "spqr", "description": "a", "tags": ["a"], "likes": 18, "viewed": 284, "published": 3, "date": "1703235637", "time_retrieved": "2024-07-30T17:15:09.194493", "image_code": "vec3 r;\n\nfloat sph (vec3 p, float r) {\n    return length(p) - r;\n}\nfloat box(vec3 p, vec3 d) {\n    p = abs(p) - d;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat aabb(vec3 p, vec3 d) {\n  \n    vec3 neg = -(d / 2. - p)/r;\n    vec3 pos =  (d / 2. - p)/r;\n\n    vec3 bot = min(neg, pos);\n \n    float top = max(max(bot.x, bot.y), bot.z);\n\n    return max(0.0, top); // Ensure we don't return a negative value\n}\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat field (vec3 p, float scale) {\n  \n   p *= scale;\n   vec3 id = floor(p)-.5; \n   p = fract(p) -.5;\n   \n   float f1 = hash31(id);\n \n  \n   float shape = box(p, vec3(f1 * .46));\n\n   float bound = aabb(p, vec3(scale*1.01));\n   \n   return min(bound , shape)/scale;\n}\nfloat map(vec3 p) {\n    vec3 q = p;\n    float pos = p.y + 1.;\n\n\n    for (float i = 1.; i < 9.; i++) {\n      \n            pos = max(pos, -field(q,pow(1.8,i)/16.));\n     \n    }\n    \n    return pos;\n}\nfloat map2(vec3 p) {\n\n    // geo\n    \n    float fl = p.y + 1.;\n    p.xz = mod(p.xz, 5.) - 2.5;\n    \n    float b = box(p, vec3(1.));\n    return min(fl,b);\n}\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat occ ( vec3 p, vec3 n, float ni, float L) {\n    float occ = 1.;\n    for (float i =1.; i < ni; i++) {\n        float l = i * L / ni;\n        float d = map(p + n * l);\n        occ -= max(0., l -d ) / l / ni;\n    \n    }\n    return max(0.,occ);\n\n\n}\nmat2 rot(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    \n    \n    // nav \n    vec3 s = vec3(0,2,-15);\n    vec3 arm = vec3(0,0,1);\n    vec3 fwd = vec3(.1,0,5)*iTime;\n    s += fwd;\n    arm.xz *= rot(cos(iTime)/2.);\n    arm.yz *= rot(sin(iTime)/2. - .8);\n    vec3 t = s + arm;\n    \n    \n    vec3 z = normalize(t-s);\n    vec3 x = normalize(cross(vec3(0,-1,0),z));\n    vec3 y = cross(x,z);  \n    r = mat3(x,y,z) * normalize(vec3(uv,1));\n    vec3 p = s;\n    float l;\n    \n    float L = 100.;\n    \n    for (float i = 0.; i < 100.; i++) {\n        float d = map(p) ;\n        \n        if ( d < .001) {\n            break;\n        }\n        if ( l > L) {\n            break;\n        }\n        p += r * d;\n        l += d;\n    }\n    \n    vec3 col = vec3(0);\n   \n    //col += l/L;\n    \n    vec3 n = norm(p);\n    \n    \n    col += occ(p, n , 5., 3.);\n    \n    col = sqrt(col);\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fXGzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[9, 9, 38, 38, 66], [67, 67, 94, 94, 150], [152, 152, 180, 180, 399], [400, 400, 423, 423, 526], [528, 528, 563, 563, 792], [793, 793, 812, 812, 990], [991, 991, 1011, 1023, 1146], [1147, 1147, 1166, 1166, 1285], [1287, 1287, 1335, 1335, 1535], [1536, 1536, 1555, 1555, 1604], [1605, 1605, 1662, 1662, 2654]], "test": "untested"}
{"id": "XcfGD7", "name": "Raymarching - bendy 3d shaplines", "author": "sancho1509", "description": "a", "tags": ["raymarching"], "likes": 10, "viewed": 299, "published": 3, "date": "1703220093", "time_retrieved": "2024-07-30T17:15:10.039234", "image_code": "\n// Shpaes distance func\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdPyramid( vec3 p, float h )\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n//Utils\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k- abs(a-b), 0.0)/k;\n    return min(a,b) - h*h*h*k*(1.0/6.0);\n}\n\nvec3 rot3D(vec3 p, vec3 axis, float angle)\n{\n    return mix(dot(axis,p) * axis, p, cos(angle)) + cross(axis,p) * sin(angle);\n}\n\nmat2 rot2D(float angle)\n{\n     float s = sin(angle);\n     float c = cos(angle);\n     \n     return mat2(c, -s, s, c);\n}\n\n\n// Custom gradient - https://iquilezles.org/articles/palettes/\nvec3 palette(float t) {\n    float time = iTime*0.05;\n    time += 230.; // Time offset\n    vec3 vector = vec3(\n        clamp( smoothstep(0.2, 0.8, 0.8 + 0.5 * sin(0.6 * time)), 0.3, .7),\n        clamp( smoothstep(0.2, 0.8, 0.5 + 0.5 * cos(0.8 * time + 2.0)), 0.5, .6),\n        clamp( smoothstep(0.2, 0.8, 0.5 + 0.5 * sin(1.5 * time + 4.0)), 0.2, .4)\n    );\n\n    return .5+.5*cos(6.28318*(t+vector));\n}\n\nfloat movementCurve( float x) {\n    return -2.0 / (1.0 + exp(-10.0 * (0.5 * x - 0.5))) + 1.0;\n}\n\nfloat PI = 3.1416;\nfloat fovMult(float x, float a, float d) \n{\n    return a + d + sin(PI * x - sqrt(PI)) * a;\n}\n\n//Render\nfloat map(vec3 p)\n{\n    vec3 q = p;\n    \n    q.z +=  iTime*0.8;//smootherstep(0.,1.,sin(iTime));\n    \n    \n    q.xy = fract(vec2(q.x, q.y)) - .5;\n    q.z = mod(q.z, .3) - .125;\n    \n    \n    float oct = sdEllipsoid(q, vec3(fovMult(iTime*0.1, 0.6, 0.01)*.3));\n    \n    return oct;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    \n    \n    \n    //Movement\n    vec2  m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    if (iMouse.z < 0.) \n        m = vec2(cos(iTime*.05), sin(iTime*.25));\n    \n        \n    \n    vec3 ro = vec3(0,0,-5);           //Ray origin\n    vec3 rd = normalize(vec3(uv/(5.*fovMult( iTime*0.01, 0.57, 0.03)),1));  // Ray direction\n    vec3 col = vec3(0);\n    \n    float t = 0.;                     //Distance travelled\n    \n    int i = 0;\n    for( ;i < 130; i++)\n    {\n        vec3 p = ro + rd*t;\n        //Sound\n        // the sound texture is 512x2\n        int tx = int((t/10000.)*512.0);\n\n        // first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n        float fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n\n        float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n        \n        p.y += 0.5* sin(t*(m.y+1.)*.5)*.7;\n        p.xy *= rot2D(t*.2*m.x);\n        p.y += sin(cos(tan(cos(t*6.*fovMult(-iTime*0.02, 0.5, 0.3)))*fft)/10.) ;\n        \n        p.y += 0.5*cos(t*(m.y+1.)*.5)*.7;\n        \n        float d = map(p);\n        \n        t += d;\n        \n        if(t >= 10000. || d <= 0.003) break;\n        \n    }\n    \n    \n    col = palette(t*0.01+float(i)*0.01);\n    \n    fragColor = vec4(col,1);\n    \n\n}", "image_inputs": [{"id": 35571, "src": "https://soundcloud.com/valefaus/time-pink-floyd", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XcfGD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 25, 60, 60, 84], [85, 85, 118, 118, 183], [184, 184, 222, 222, 502], [504, 504, 540, 540, 1025], [1027, 1027, 1064, 1064, 1147], [1158, 1158, 1197, 1197, 1279], [1281, 1281, 1325, 1325, 1407], [1409, 1409, 1434, 1434, 1527], [1530, 1593, 1616, 1616, 1993], [1995, 1995, 2026, 2026, 2090], [2111, 2111, 2154, 2154, 2203], [2205, 2214, 2233, 2233, 2495], [2498, 2498, 2555, 2610, 3925]], "test": "untested"}
{"id": "4csGzB", "name": "sobel edge detection", "author": "jonasfrey", "description": "edge detection", "tags": ["edgedetection"], "likes": 2, "viewed": 231, "published": 3, "date": "1703206914", "time_retrieved": "2024-07-30T17:15:10.831117", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trn_nor = ( (fragCoord.xy - iResolution.xy*0.5) / iResolution.yy );\n    \n    vec2 o_scl_krnl = vec2(3.);\n    vec2 o_scl_krnl_half = floor(o_scl_krnl/2.);\n    float n_elements_krnl = o_scl_krnl.x * o_scl_krnl.y;\n    vec2 o_factor_edge = vec2(2.);\n    vec2 o_factor_nonedge = vec2(1.);\n    vec4 o_blur = vec4(0.);\n    vec4 o_sum_sobel_x = vec4(0.);\n    vec4 o_sum_sobel_y = vec4(0.);\n    for(\n        float n_trn_x = - o_scl_krnl_half.x;  \n        n_trn_x<o_scl_krnl_half.x+1.;\n        n_trn_x+=1.\n    ){  \n        for(\n            float n_trn_y = - o_scl_krnl_half.y;  \n            n_trn_y<o_scl_krnl_half.y+1.;\n            n_trn_y+=1.\n        ){\n\n            vec2 o_trn = fragCoord.xy+vec2(n_trn_x, n_trn_y);\n            vec4 o_c_b1 = texture(iChannel0, o_trn/iResolution.xy);\n            vec2 o_fctr = vec2(\n                (n_trn_y == 0.) ? n_trn_x*o_factor_edge.x : o_factor_nonedge.x*n_trn_x,\n                (n_trn_x == 0.) ? n_trn_y*o_factor_edge.y : o_factor_nonedge.y*n_trn_y\n            );\n            o_sum_sobel_x += o_c_b1*o_fctr.x;\n            o_sum_sobel_y += o_c_b1*o_fctr.y;\n            o_blur += o_c_b1;\n        }\n\n    }\n    vec4 o_prod_sobel_x = o_sum_sobel_x*o_sum_sobel_x;\n    vec4 o_prod_sobel_y = o_sum_sobel_y*o_sum_sobel_y;\n    \n    vec4 o_edges = vec4(\n        length(o_prod_sobel_x.x+o_prod_sobel_y.x),\n        length(o_prod_sobel_x.y+o_prod_sobel_y.y),\n        length(o_prod_sobel_x.z+o_prod_sobel_y.z),\n        length(o_prod_sobel_x.w+o_prod_sobel_y.w)\n    );\n\n    o_blur /= n_elements_krnl;\n    vec4 o_c_b1 = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    fragColor = vec4(o_edges);//*(1.+(1./n_elements_krnl));\n    //fragColor = vec4(o_c_b1)*o_edges;//*(1.+(1./n_elements_krnl));\n    //fragColor = vec4(0.)+n*(1./n_elements_krnl);\n    fragColor = (fragColor);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4csGzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1866]], "test": "untested"}
{"id": "4cs3zS", "name": "buffer buffer feedback", "author": "jonasfrey", "description": "original title: webcam fractal builder\niwhen you point the webcam on the screen, fractals will naturally form because of the feedback loop!\n\nok i did not quite achieve what i wanted but this is still cool :) \nuse the mouse to play around", "tags": ["fractal"], "likes": 6, "viewed": 195, "published": 3, "date": "1703201568", "time_retrieved": "2024-07-30T17:15:11.598066", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 o_trn = ( (fragCoord.xy - iResolution.xy*0.5) / iResolution.yy );\n    vec4 o_col_b1 = texture( iChannel0, fragCoord.xy/iResolution.xy);\n    \n\n    fragColor = vec4(o_col_b1);\n    \n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trn = ( (fragCoord.xy - iResolution.xy*0.5) / iResolution.yy );\n    float n_t = fract(iTime);\n\n\n    vec4 o_col_b1 = texture( iChannel0, fragCoord.xy/iResolution.xy);\n    fragColor = vec4(o_col_b1);\n    \n    \n    float n_tau = 6.2831;\n    float n = o_trn.y - sin(o_trn.x*n_tau)*.2;\n    n = length(o_trn);\n    float n_ang = fract(atan(o_trn.x, o_trn.y)/n_tau);\n    n_ang = sin(n_ang*n_tau+iTime)*0.01;\n    fragColor += 0.5*vec4(abs(n));\n    vec4 o_diff = fragColor-o_col_b1;\n    fragColor = o_col_b1+abs(o_diff)*.1;\n    fragColor = fract(fragColor);\n\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float f_n_rand2(vec2 pos)\n{\n    return fract(sin(1234.1234*pos.y+pos.y+iTime)*234.123);\n}\nfloat f_n_rand(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_trn_mouse = ( (iMouse.xy - iResolution.xy*0.5) / iResolution.yy );\n\n    if( iMouse.w== 0.0 ){\n        float n_m = -.05*(sin(iTime)*0.5+.5);\n        float n_toggle = 0.001+float(fract(iTime*0.5)>0.5)*-.1;\n        o_trn_mouse = vec2(n_toggle)+vec2(n_m)+0.05;\n    }\n    \n    o_trn_mouse*=0.2;\n    float n = 1.+o_trn_mouse.x;//sin(iTime*0.2)*0.003;//0.001;\n    \n    vec2 o_fc = (fragCoord.xy*(1.+o_trn_mouse));//+sin(iTime*0.001)*.5+.5)*0.00001);\n    vec2 o_ires = iResolution.xy;\n    vec2 o = o_fc/o_ires;\n    o-=o_trn_mouse/2.;\n    vec4 o_col_b1 = texture( iChannel0,o);\n    fragColor = fract(o_col_b1);\n    \n    o_trn_mouse *= 0.1;\n    float n_rnd = f_n_rand(fragColor.xy+iTime);\n    fragColor.xyz += o_trn_mouse.x*n_rnd;\n    //fragColor.y += (1.-o_trn_mouse.x)*f_n_rand(fragColor.xy);\n    //fragColor.z += fract(o_trn_mouse.x*2.)*f_n_rand(fragColor.xy);\n    vec4 o_diff = fragColor.xyzw-o_col_b1.zyxw;\n    fragColor += o_diff*0.1;\n    //fragColor.x = o_col_b1.z+abs(o_diff.z)*n_rnd;\n    //fragColor.y = o_col_b1.x+abs(o_diff.x)*(1.-n_rnd);\n    //fragColor.z = o_col_b1.y+abs(o_diff.y)*0.2;\n    fragColor = fract(fragColor);\n    \n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4cs3zS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 184, 299]], "test": "untested"}
{"id": "4fs3zS", "name": "Merry Christmas 2023", "author": "jgonzaga", "description": "Merry Christmas 2023", "tags": ["christmas", "2023"], "likes": 9, "viewed": 202, "published": 3, "date": "1703197090", "time_retrieved": "2024-07-30T17:15:12.360029", "image_code": "int C[26]=int[](7325,53709,35217,53705,36241,3217,39317,7196,49601,39176,11282,35088,6202,14392,39321,3229,47513,11421,37285,16577,39192,2578,14872,8738,16418,33667);\nint N[10]=int[](39835,4106,36237,38285,5148,38293,40341,643,40349,38301);\n\nfloat de16Seg(vec2 p,int n)\n{\n\tfloat e=2.;\n\tmat2 m=mat2(0,-1,1,0);\n    for(int i=0;i<16;i++){\n\t\tint j=i&3;\n\t\tif(j==0)m*=mat2(0,1,-1,0);\n\t\tif((n>>i&1)==1){\n\t\t\tvec2 a=m*vec2(26>>j&1,19>>j&1)*vec2(0.6,1);\n\t\t\tvec2 b=m*vec2(13>>j&1,9>>j&1)*vec2(0.6,1);\n            a.x+=0.3*a.y;\n            b.x+=0.3*b.y;\n            vec2 c=p-a,d=b-a;\n\t\t\te=min(e,length(c-d* clamp(dot(c,d)/dot(d,d), 0.1, 0.9)));\n\t\t}\n\t}\n\treturn e;\n}\n\n#define A(a) idx=N[a];de=min(de,de16Seg(p,idx));p.x-=2.0;\n#define B(a) idx=C[a];de=min(de,de16Seg(p,idx));p.x-=2.0;\n#define S(a) int(mix(123456.0,float(a),min(time-=0.1,1.0)))%26\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 p = fragCoord.xy/iResolution.y;\n\tvec3 col =vec3(0.05,0.1,0.3)- vec3(p.y*p.y)*0.3;\n    col = mix(col, texture(iChannel0, p + vec2(0,iTime * 0.08)).xyz, 0.3);\n    p *=20.0;\n    float time = mod(iTime,12.0)*0.2+1.0;\n\tint idx;\n\tfloat de=10.0;\n\tp +=vec2(-8,-14);\n\tB(S(12))\n\tB(S(4))\n\tB(S(17))\n\tB(S(17))\n\tB(S(24))\n\tp +=vec2(8,5);\n\tB(S(2))\n\tB(S(7))\n\tB(S(17))\n\tB(S(8))\n\tB(S(18))\n\tB(S(19))\n\tB(S(12))\n\tB(S(0))\n\tB(S(18))\n\tp +=vec2(6,5);\n\tA(2)\n\tA(0)\n\tA(2)\n\tA(3)\n    de /= sin(iTime*3.0)+2.0;\n\tcol = mix(col, mix(vec3(0.1,0.7,0.1),vec3(1.0,0.7,0.1),step(2.5,p.y)),exp(-6.0*de));\n\tcol = mix(col, vec3(1),exp(-25.0*de));\n\n    fragColor = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fs3zS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 242, 271, 271, 652]], "test": "untested"}
{"id": "Mcf3zS", "name": "Returning Home", "author": "DanielXMoore", "description": "I followed kishimisu's YouTube tutorial here: https://www.youtube.com/watch?v=f4s1h2YETNY\n\nThe end result has been modified into something original.", "tags": ["psychedelic"], "likes": 12, "viewed": 254, "published": 3, "date": "1703185466", "time_retrieved": "2024-07-30T17:15:13.119997", "image_code": "const float TAU = 6.28318;\n\nvec3 palette(in float t)\n{\n\n    // vec3 a = vec3(0.138, 0.189, 0.761); vec3 b = vec3(0.448, 0.797, 0.568); vec3 c = vec3(0.591, 1.568, 0.065); vec3 d = vec3(4.347, 2.915, 0.976);\n\n    vec3 a = vec3(0.000, 0.500, 0.500);\n    vec3 b = vec3(2.000, 0.500, 0.490);\n    vec3 c = vec3(2.000, 2.000, 0.500);\n    vec3 d = vec3(0.000, 0.667, 0.500);\n\n    return a + b * cos( TAU * (c * t + d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.);\n    \n    for (float i = 0.; i < 3.; i++) {\n        uv = (fract(6. * uv * pow(0.125, i)) - .5);\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i *.4 + iTime * pow(0.4, i));\n\n        d = sin(d * 8. + iTime) / 8.;\n\n        d = abs(d);\n\n        d = pow(0.01 / d, 3.);\n\n        finalColor += col * d;\n\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mcf3zS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 54, 206, 415], [417, 417, 474, 474, 981]], "test": "untested"}
{"id": "ddVXWd", "name": "Mineral Symbols", "author": "SkyCrusher", "description": "Some description", "tags": ["symbols", "maps"], "likes": 15, "viewed": 286, "published": 3, "date": "1703184948", "time_retrieved": "2024-07-30T17:15:14.064472", "image_code": "#define PI 3.14159265359\n\n#define THICKNESS 0.002\n#define GRID_N 10\n#define CENTER vec2(0.5)\n#define WIDTH 0.025\n#define SIZE vec2(0.5)\n#define RADIUS 0.25\n\n////\n//maths\n////\n\nfloat cross2(vec2 a,vec2 b){ \n    return a.x*b.y - a.y*b.x; \n}\n\nvec2 rotate(vec2 uv, float angle){\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * uv;\n}\n\n////\n//drawing functions\n////\n\nfloat line(vec2 uv, vec2 a, vec2 b, float r) \n{\n    vec2 g = b - a;\n    vec2 h = uv - a;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn smoothstep(r/2. + THICKNESS, r/2., d);\n}\n\nfloat rect(vec2 uv, vec2 center, vec2 size, float angle){\n    uv = rotate(center - uv, angle);\n    return smoothstep(THICKNESS, .0, abs(uv.x)-size.x/2.)\n            * smoothstep(THICKNESS, .0, abs(uv.y)-size.y/2.);\n}\n\nfloat rect_outline(vec2 uv, vec2 center, vec2 size, float width, float angle){\n    return rect(uv, center, size + width, angle)\n            - rect(uv, center, size - width, angle);\n}\n\nfloat circle(vec2 uv, vec2 center, float radius){\n    return smoothstep(THICKNESS, .0, length(center-uv)-radius); \n}\n\nfloat circle_outline(vec2 uv, vec2 center, float radius, float width){\n    return circle(uv, center, radius + width/2.)\n            - circle(uv, center, radius - width/2.); \n}\n\nfloat circle_segment(vec2 uv, vec2 center, float radius, float len, float thickness, float rot){\n    uv = 2.0 * (CENTER - center + uv) - 1.0;\n    uv = rotate(uv, rot);\n\n    radius *= 2.;\n    float d = length(uv);\n\tfloat angle = atan(uv.x, uv. y) * 1./PI * 0.5;\n\tangle = fract(angle);\n    \n    float wd = fwidth(d);\n    float circle = smoothstep(radius + THICKNESS/2., radius - THICKNESS/2., d);\n    \n    float inner = radius - thickness;\n    circle -= smoothstep(inner + wd, inner - wd, d);\n    \n    float wa = fwidth(angle);\n    float segment = smoothstep(len + wa, len - wa, angle);\n\tsegment *= smoothstep(.0, 2. * wa, angle);    \n    circle *= mix(segment, 1., step(1.0, len));\n    \n    return circle;\n}\n\nfloat triangle(vec2 uv, vec2 vertex0, vec2 vertex1, vec2 vertex2)\n{\n    vec3 barycentricCoord;\n    \n    float triangleArea = cross(vec3(vertex1 - vertex0, 0), vec3(vertex2 - vertex0, 0)).z;\n    \n    barycentricCoord.x = cross(vec3(vertex1 - uv, 0), vec3(vertex2 - uv, 0)).z / triangleArea;\n    barycentricCoord.y = cross(vec3(vertex2 - uv, 0), vec3(vertex0 - uv, 0)).z / triangleArea;\n    barycentricCoord.z = cross(vec3(vertex0 - uv, 0), vec3(vertex1 - uv, 0)).z / triangleArea;\n    \n    return step(0., barycentricCoord.x)\n            * step(0., barycentricCoord.y)\n            * step(0., barycentricCoord.z);\n}\n\nfloat triangle_outline(vec2 uv, vec2 vertex0, vec2 vertex1, vec2 vertex2, float width){\n    return line(uv, vertex0, vertex1, width)\n            + line(uv, vertex1, vertex2, width)\n            + line(uv, vertex2, vertex0, width);\n}\n\nfloat polygon(vec2 uv, int n, vec2 center, float radius, float angle){\n  uv = rotate((CENTER - center + uv)*2.-1., angle);\n  \n  float a = atan(uv.x,uv.y)+PI;\n  float r = 2.*PI/float(n);\n\n  float d = cos(floor(.5+a/r)*r-a)*length(uv);\n  return 1.0-smoothstep(radius,radius + THICKNESS,d);\n}\n\nfloat polygon_outline(vec2 uv, int n, vec2 center, float radius, float angle, float width){\n  return polygon(uv, n, center, radius + width, angle)\n          - polygon(uv, n, center, radius, angle);\n}\n\n////\n//ceil logic functions\n////\n\nfloat set_ceil(vec2 grid, int xIndex, int yIndex){\n    return step(floor(grid.x), float(xIndex))\n            * step(floor(grid.y), float(yIndex))\n            * step(float(xIndex), floor(grid.x))\n            * step(float(yIndex), floor(grid.y));\n                \n}\n\n////\n//minerals functions\n////\n\n////\n//amphiboles\n////\n\nfloat hornblende(vec2 uv){\n    return rect_outline(uv, CENTER, SIZE, WIDTH, PI*.25);\n}\n\nfloat anthophyllite(vec2 uv){\n    return rect_outline(uv, CENTER, SIZE, WIDTH, PI*.25)\n            + rect(uv, CENTER, vec2(length(SIZE), WIDTH), .0);\n}\n\nfloat arfvedsonite(vec2 uv){\n    return rect_outline(uv, CENTER, SIZE, WIDTH, PI*.25)\n            + rect(uv, CENTER, vec2(WIDTH, length(SIZE)), .0);\n}\n\nfloat actinolite(vec2 uv){\n    return rect_outline(uv, CENTER, SIZE, WIDTH, PI*.25)\n            + rect(uv, CENTER, vec2(length(SIZE), WIDTH), .0)\n            + circle(uv, CENTER, length(SIZE) * .1);\n}\n\nfloat glaucophane(vec2 uv){\n    return rect_outline(uv, CENTER, SIZE, WIDTH, PI*.25)\n            + rect(uv, CENTER, vec2(WIDTH, length(SIZE)), .0)\n            + circle(uv, CENTER, length(SIZE) * .1);\n}\n\nfloat tremolite(vec2 uv){\n    return rect_outline(uv, CENTER, SIZE, WIDTH, PI*.25)\n            + rect(uv, CENTER, vec2(length(SIZE), WIDTH), .0)\n            - circle(uv, CENTER, length(SIZE) * .1 - WIDTH)\n            + circle_outline(uv, CENTER, length(SIZE) * .1, WIDTH);\n}\n\n\n////\n//pomegranates\n////\n\nfloat almandine(vec2 uv){\n    return circle_outline(uv, CENTER, RADIUS, WIDTH)\n            + rect(uv, CENTER, vec2(RADIUS*2., WIDTH), PI*.25)\n            + rect(uv, CENTER, vec2(WIDTH, RADIUS*2.), PI*.25);\n}\n\nfloat andradite(vec2 uv){\n    return circle_outline(uv, CENTER, RADIUS, WIDTH)\n            + rect(uv, CENTER, vec2(RADIUS*2., WIDTH), PI*.25)\n            + rect(uv, CENTER, vec2(WIDTH, RADIUS*2.), PI*.25)\n            + circle_segment(uv, CENTER, RADIUS, .25, 1., PI*.25);\n}\n\nfloat pyrope(vec2 uv){\n    return circle_outline(uv, CENTER, RADIUS, WIDTH)\n            + rect(uv, CENTER, vec2(RADIUS*2., WIDTH), PI*.25)\n            + rect(uv, CENTER, vec2(WIDTH, RADIUS*2.), PI*.25)\n            + circle_segment(uv, CENTER, RADIUS, .25, 1., PI*.25)\n            + circle_segment(uv, CENTER, RADIUS, .25, 1., -PI*.75);\n}\n\n////\n//nuggets\n////\n\nfloat diamond(vec2 uv){\n    return rect_outline(uv, CENTER, SIZE, WIDTH, PI*.25)\n            + rect(uv, CENTER, vec2(length(SIZE), WIDTH), .0)\n            + rect(uv, CENTER, vec2(WIDTH, length(SIZE)), .0);\n}\n\nfloat bismud(vec2 uv){\n    return triangle_outline(uv, vec2(.5-length(SIZE)/2., .5), vec2(.5+length(SIZE)/2., .5), vec2(.5, .5 - length(SIZE)/2.), WIDTH);\n}\n\nfloat graphite(vec2 uv){\n    return rect(uv, CENTER, vec2(.6, .15), 0.);\n}\n\nfloat copper(vec2 uv){\n    return triangle_outline(uv, vec2(.2, .2), vec2(.8, .2), vec2(.5, .8), WIDTH);\n}\n\nfloat arsenic(vec2 uv){\n    return rect_outline(uv, CENTER, vec2(.6, .3), WIDTH, 0.);\n}\n\nfloat nevyaskit(vec2 uv){\n    float mult = 2.5;\n    vec2 uv0 = uv;\n    uv0.y *= mult;\n    vec2 center = vec2(CENTER.x, CENTER.y*mult);\n    return polygon_outline(uv0, 6, center, .5, PI*.5, WIDTH*mult);\n}\n\nfloat platinum(vec2 uv){\n    return circle_outline(uv, CENTER, RADIUS, WIDTH)\n            + circle(uv, CENTER, RADIUS/3.);\n}\n\nfloat sulfur(vec2 uv){\n    vec2 a = vec2(.2, .35);\n    vec2 b = vec2(.4, .65);\n    vec2 c = vec2(.65, .35);\n    vec2 d = vec2(.85, .65);\n    float radius = 0.06;\n    return line(uv, a, b, WIDTH)\n            + line(uv, b, c, WIDTH)\n            + line(uv, c, d, WIDTH)\n            + line(uv, a, c, WIDTH)\n            + line(uv, b, d, WIDTH)\n            + circle(uv, a, radius)\n            + circle(uv, b, radius)\n            + circle(uv, c, radius)\n            + circle(uv, d, radius);\n}\n\nfloat sysertskit(vec2 uv){\n    float mult = 2.5;\n    vec2 uv0 = uv;\n    uv0.y *= mult;\n    vec2 center = vec2(CENTER.x, CENTER.y*mult);\n    return polygon_outline(uv0, 6, center, .6, PI*.5, WIDTH*mult)\n            + line(uv, vec2(.5, .375), vec2(.5, .625), WIDTH);\n}\n\n////\n//sulfides\n////\n\nfloat bismuth(vec2 uv){\n    return triangle_outline(uv, vec2(.5-length(SIZE)/2., .5), vec2(.5+length(SIZE)/2., .5), vec2(.5, .5 - length(SIZE)/2.), WIDTH)\n            + line(uv, vec2(.5, .5 - length(SIZE)/2.), vec2(.5), WIDTH);\n}\n\nfloat pyrite(vec2 uv){\n    return rect(uv, CENTER, SIZE/2., 0.)\n            + rect(uv, vec2(.65, .5), vec2(.04, .7), 0.);\n}\n\nfloat pyrrhotite(vec2 uv){\n    return rect(uv, CENTER, vec2(.6, .15), 0.)\n            + rect(uv, vec2(.5, .65), vec2(.15), 0.);\n}\n\nfloat glaucodot(vec2 uv){\n    return triangle_outline(uv, vec2(.5-length(SIZE)/2., .5), vec2(.5+length(SIZE)/2., .5), vec2(.5, .5 + length(SIZE)/2.), WIDTH)\n            + line(uv, vec2(.5, .5 + length(SIZE)/2.), vec2(.5), WIDTH);\n}\n\n\nfloat cobaltin(vec2 uv){\n    return triangle_outline(uv, vec2(.5-length(SIZE)/2., .5), vec2(.5+length(SIZE)/2., .5), vec2(.5, .5 + length(SIZE)/2.), WIDTH)\n            + triangle(uv, vec2(.5-length(SIZE)/2., .5), vec2(.5, .5 + length(SIZE)/2.), vec2(.5));\n}\n\nfloat smaltin(vec2 uv){\n    return triangle_outline(uv, vec2(.5-length(SIZE)/2., .5), vec2(.5+length(SIZE)/2., .5), vec2(.5, .5 + length(SIZE)/2.), WIDTH)\n            + triangle(uv, vec2(.5, .5 + length(SIZE)/2.), vec2(.5), vec2(.5+length(SIZE)/2., .5));\n}\n\nfloat bornite(vec2 uv){\n    return triangle_outline(uv, vec2(.2), vec2(.8, .2), vec2(.5, .8), WIDTH)\n            + triangle(uv, vec2(.2), vec2(.8, .2), vec2(.65, .5));\n}\n\nfloat covelline(vec2 uv){\n    return triangle_outline(uv, vec2(.2), vec2(.8, .2), vec2(.5, .8), WIDTH)\n            + triangle(uv, vec2(.2), vec2(.5, .2), vec2(.5, .8));\n}\n\nfloat tennantitis(vec2 uv){\n    return triangle_outline(uv, vec2(.2), vec2(.8, .2), vec2(.5, .8), WIDTH)\n            + triangle(uv, vec2(.35, .5), vec2(.65, .5), vec2(.5, .8));\n}\n\nfloat tetrahedrite(vec2 uv){\n    return triangle(uv, vec2(.2), vec2(.8, .2), vec2(.5, .8))\n            - triangle(uv, vec2(.4, .5), vec2(.6, .5), vec2(.5, .7));\n}\n\nfloat chalcosine(vec2 uv){\n    return triangle_outline(uv, vec2(.2), vec2(.8, .2), vec2(.5, .8), WIDTH)\n            + triangle(uv, vec2(.5, .2), vec2(.8, .2), vec2(.5, .8));\n}\n\nfloat chalcopyrite(vec2 uv){\n    return triangle(uv, vec2(.2), vec2(.8, .2), vec2(.5, .8));\n}\n\nfloat molebdenite(vec2 uv){\n    return rect(uv, CENTER, vec2(.45, .7), 0.) \n            - triangle(uv, vec2(.25, .9), vec2(.75, .9), vec2(.5));\n}\n\nfloat arsenopyrite(vec2 uv){\n    return rect_outline(uv, CENTER, vec2(.6, .3), WIDTH, 0.)\n            + rect(uv, vec2(.65, .5), vec2(.3, .3), 0.);\n}\n\nfloat orpiment(vec2 uv){\n    return rect_outline(uv, CENTER, vec2(.6, .3), WIDTH, 0.)\n            + line(uv, vec2(.5, .35), vec2(.5, .65), WIDTH);\n}\n\nfloat lellingite(vec2 uv){\n    return rect_outline(uv, CENTER, vec2(.6, .3), WIDTH, 0.)\n            + triangle(uv, vec2(.2, .35), vec2(.2, .65), vec2(.8, .65));\n}\n\nfloat realgar(vec2 uv){\n    return rect_outline(uv, CENTER, vec2(.6, .3), WIDTH, 0.)\n            + line(uv, vec2(.2, .35), vec2(.8, .65), WIDTH);\n}\n\nfloat millerite(vec2 uv){\n    return triangle_outline(uv, vec2(.2), vec2(.5, .8), vec2(.5, .2), WIDTH)\n            + line(uv, vec2(.5, .2), vec2(.3, .4), WIDTH);\n}\n\nfloat nickeline(vec2 uv){\n    return triangle_outline(uv, vec2(.2), vec2(.5, .8), vec2(.5, .2), WIDTH);\n}\n\nfloat pentlandite(vec2 uv){\n    return triangle(uv, vec2(.2), vec2(.5, .8), vec2(.5, .2));\n}\n\nfloat chloanitis(vec2 uv){\n    return triangle_outline(uv, vec2(.2), vec2(.5, .8), vec2(.5, .2), WIDTH)\n            + triangle(uv, vec2(.5, .8), vec2(.5, .2), vec2(.3, .4));\n}\n\nfloat sperrylite(vec2 uv){\n    return circle_outline(uv, CENTER, RADIUS, WIDTH)\n            + rect_outline(uv, CENTER, vec2(0.15), WIDTH, 0.);\n}\n\nfloat cinnabar(vec2 uv){\n    return rect_outline(uv, CENTER, vec2(.3), WIDTH, 0.)\n            + rect(uv, CENTER, vec2(WIDTH, .45), 0.)\n            + rect(uv, vec2(.45, .5), vec2(.155, .3), 0.);\n}\n\nfloat metacin_nabarite(vec2 uv){\n    return rect(uv, CENTER, vec2(.3), 0.)\n            + rect(uv, CENTER, vec2(WIDTH, .45), 0.);\n}\n\nfloat galena(vec2 uv){\n    return rect(uv, CENTER, SIZE, PI*.25);\n}\n\nfloat antimonite(vec2 uv){\n    vec2 a = vec2(.5);\n    vec2 a1 = vec2(.5, .65);\n    vec2 b = vec2(.2, .3);\n    vec2 b1 = vec2(.12, .25);\n    vec2 c = vec2(.8, .3);\n    vec2 c1 = vec2(.87, .25);\n    return triangle(uv, a, b, c)\n            + line(uv, CENTER, a1, WIDTH)\n            + line(uv, CENTER, b1, WIDTH)\n            + line(uv, CENTER, c1, WIDTH);\n}\n\nfloat boulangerite(vec2 uv){\n    vec2 a = vec2(.5);\n    vec2 a1 = vec2(.5, .65);\n    vec2 b = vec2(.2, .3);\n    vec2 b1 = vec2(.12, .25);\n    vec2 c = vec2(.8, .3);\n    vec2 c1 = vec2(.87, .25);\n    return triangle_outline(uv, a, b, c, WIDTH)\n            + line(uv, CENTER, a1, WIDTH)\n            + line(uv, CENTER, b1, WIDTH)\n            + line(uv, CENTER, c1, WIDTH)\n            - triangle(uv, a, b, c);\n}\n\n////\n//oxides and hydroxides\n////\n\nfloat boehmite(vec2 uv){\n    return triangle_outline(uv, vec2(.5), vec2(.2), vec2(.8, .2), WIDTH)\n            + triangle_outline(uv, vec2(.5), vec2(.2, .8), vec2(.8), WIDTH)\n                + line(uv, vec2(.5, .2), vec2(.5, .8), WIDTH); \n}\n\nfloat hydrargillite(vec2 uv){\n    return triangle(uv, vec2(.5), vec2(.2), vec2(.8, .2))\n            + triangle(uv, vec2(.5), vec2(.2, .8), vec2(.8)); \n}\n\nfloat diasporas(vec2 uv){\n    return triangle(uv, vec2(.5), vec2(.2), vec2(.8, .2))\n            + triangle_outline(uv, vec2(.5), vec2(.2, .8), vec2(.8), WIDTH)\n                + line(uv, vec2(.5, .2), vec2(.5, .8), WIDTH);\n}\n\nfloat corundum(vec2 uv){\n    float mult = 2.5;\n    vec2 uv0 = uv;\n    uv0.x *= mult;\n    vec2 center = vec2(CENTER.x*mult, CENTER.y);\n    return polygon_outline(uv0, 6, center, .6, 0., WIDTH*mult);\n}\n\nfloat chrysoberyl(vec2 uv){\n    float mult = 2.5;\n    vec2 uv0 = uv;\n    uv0.y *= mult;\n    vec2 center = vec2(CENTER.x, CENTER.y*mult);\n    return polygon_outline(uv0, 6, center, .6, 0., WIDTH*mult)\n            + line(uv, vec2(.5, .35), vec2(.5, .65), WIDTH);\n}\n\nfloat spinel(vec2 uv){\n    return polygon_outline(uv, 5, CENTER, .5, 0., WIDTH);\n}\n\nfloat ice(vec2 uv){\n    return circle_outline(uv, CENTER, RADIUS, WIDTH)\n            + clamp(\n                rect(uv, CENTER, vec2(WIDTH, .7), 0.)\n                + rect(uv, CENTER, vec2(WIDTH, .7), PI*.25)\n                + rect(uv, CENTER, vec2(WIDTH, .7), PI*.5)\n                + rect(uv, CENTER, vec2(WIDTH, .7), PI*.75),\n                0., 1.)\n            - circle(uv, CENTER, RADIUS - WIDTH/2.);\n}\n\nfloat hematite(vec2 uv){\n    float mult = 1.5;\n    uv.x *= mult;\n    vec2 center = vec2(CENTER.x*mult, CENTER.y);\n    return rect_outline(uv, center, SIZE, WIDTH, PI*.25);\n}\n\nfloat goethite(vec2 uv){\n    float off = SIZE.x/2. + WIDTH/2.;\n    return triangle(uv, vec2(CENTER.x - off, CENTER.y), vec2(CENTER.x + off, CENTER.y), vec2(.5, .9))\n            + triangle_outline(uv, vec2(CENTER.x - (off - WIDTH/2.), CENTER.y), vec2(CENTER.x + (off - WIDTH/2.), CENTER.y), vec2(.5, .1), WIDTH); \n}\n\nfloat ilmenite(vec2 uv){\n    float off = SIZE.x/2.;\n    return triangle_outline(uv, vec2(CENTER.x - (off - WIDTH/2.), CENTER.y), vec2(CENTER.x + (off - WIDTH/2.), CENTER.y), vec2(.5, .9), WIDTH)\n            + triangle(uv, vec2(CENTER.x - off, CENTER.y), vec2(CENTER.x + off, CENTER.y), vec2(.5, .1)); \n}\n\nfloat limonite(vec2 uv){\n    return circle(uv, CENTER, .15)\n            + rect(uv, CENTER, vec2(WIDTH, .7), 0.)\n            + rect(uv, CENTER, vec2(WIDTH, .7), PI*.25)\n            + rect(uv, CENTER, vec2(WIDTH, .7), PI*.5)\n            + rect(uv, CENTER, vec2(WIDTH, .7), PI*.75);\n}\n\nfloat magnetite(vec2 uv){\n    float mult = 1.5;\n    uv.x *= mult;\n    vec2 center = vec2(CENTER.x*mult, CENTER.y);\n    return rect(uv, center, SIZE, PI*.25);\n}\n\nfloat quartz(vec2 uv){\n    return triangle_outline(uv, vec2(.35, .3), vec2(.65, .3), vec2(.5, .8), WIDTH);\n}\n\nfloat opal(vec2 uv){\n    return triangle(uv, vec2(.35, .3), vec2(.65, .3), vec2(.5, .8));\n}\n\nfloat chalcedony(vec2 uv){\n    return triangle_outline(uv, vec2(.35, .3), vec2(.65, .3), vec2(.5, .8), WIDTH)\n            + circle(uv, vec2(.5, .45), 0.075);\n}\n\nfloat brownite(vec2 uv){\n    float mult = 1.5;\n    uv.y *= mult;\n    vec2 center = vec2(CENTER.x, CENTER.y*mult);\n    return rect_outline(uv, center, SIZE, WIDTH, PI*.25);\n}\n\nfloat hausmanite(vec2 uv){\n    float off = SIZE.y/2.;\n    return triangle_outline(uv, vec2(CENTER.x, CENTER.y - off), vec2(CENTER.x, CENTER.y  + off), vec2(.9, .5), WIDTH)\n            + triangle_outline(uv, vec2(CENTER.x, CENTER.y - off), vec2(CENTER.x, CENTER.y + off), vec2(.1, .5), WIDTH); \n}\n\nfloat manganite(vec2 uv){\n    float off = SIZE.y/2.;\n    return triangle_outline(uv, vec2(.1+WIDTH/2., .5), vec2(CENTER.x, CENTER.y  + off), vec2(.9-WIDTH/2., .5), WIDTH)\n            + triangle(uv, vec2(.1, .5), vec2(CENTER.x, CENTER.y - off), vec2(.9, .5)); \n}\n\nfloat pyrolusite(vec2 uv){\n    float mult = 1.5;\n    uv.y *= mult;\n    vec2 center = vec2(CENTER.x, CENTER.y*mult);\n    return rect(uv, center, SIZE, PI*.25);\n}\n\nfloat psilomelan(vec2 uv){\n    float off = SIZE.y/2.;\n    return triangle_outline(uv, vec2(CENTER.x, CENTER.y - off), vec2(CENTER.x, CENTER.y  + off), vec2(.9, .5), WIDTH)\n            + triangle_outline(uv, vec2(CENTER.x, CENTER.y - off), vec2(CENTER.x, CENTER.y + off), vec2(.1, .5), WIDTH)\n            + line(uv, vec2(.1, .5), vec2(.9, .5), WIDTH); \n}\n\nfloat columbite(vec2 uv){\n    return rect_outline(uv, CENTER, vec2(.3, .75), WIDTH, 0.)\n            + rect(uv, vec2(.5-.075, .5), vec2(.15, .75), 0.);\n}\n\nfloat loparite(vec2 uv){\n    return rect_outline(uv, CENTER, vec2(.3, .75), WIDTH, 0.)\n            + rect(uv, vec2(.5, .25), vec2(.3, .375), 0.);\n}\n\nfloat pyrochlore(vec2 uv){\n    return rect_outline(uv, CENTER, vec2(.3, .75), WIDTH, 0.)\n            + rect(uv, vec2(.5+.075, .5), vec2(.15, .75), 0.);\n}\n\nfloat tantalite(vec2 uv){\n    return rect_outline(uv, CENTER, vec2(.3, .75), WIDTH, 0.)\n            + rect(uv, vec2(.5, .75), vec2(.3, .375), 0.);\n}\n\nfloat cassiterite(vec2 uv){\n    return line(uv, vec2(.2, .7), vec2(.8, .7), WIDTH)\n            + line(uv, vec2(.2, .3), vec2(.8, .3), WIDTH)\n            + line(uv, vec2(.3, .2), vec2(.3, .8), WIDTH)\n            + line(uv, vec2(.7, .2), vec2(.7, .8), WIDTH);\n}\n\nfloat anatase(vec2 uv){\n    return circle_outline(uv, CENTER, RADIUS, WIDTH)\n            + circle(uv, CENTER, .075)\n            + clamp(\n                clamp(\n                    rect(uv, CENTER, vec2(WIDTH, .7), 0.)\n                    + rect(uv, CENTER, vec2(WIDTH, .7), PI*.5),\n                    0., 1.)\n                - circle(uv, CENTER, RADIUS - WIDTH/2.),\n                0., 1.);\n}\n\nfloat rutile(vec2 uv){\n    return circle_outline(uv, CENTER, RADIUS, WIDTH)\n            + clamp(\n                clamp(\n                    rect(uv, CENTER, vec2(WIDTH, .7), 0.)\n                    + rect(uv, CENTER, vec2(WIDTH, .7), PI*.5),\n                    0., 1.)\n                - circle(uv, CENTER, RADIUS - WIDTH/2.),\n                0., 1.);\n}\n\nfloat chrome_spinel(vec2 uv){\n    return rect_outline(uv, CENTER, SIZE, WIDTH, 0.)\n        + clamp(\n            rect(uv, CENTER, vec2(WIDTH, .9), PI*.25)\n            + rect(uv, CENTER, vec2(WIDTH, .9), PI*.75),\n            0., 1.)\n        - rect(uv, CENTER, SIZE, 0.);\n}\n\nfloat uraninite(vec2 uv){\n    return rect_outline(uv, CENTER, vec2(.3), WIDTH*2., 0.);\n}\n\n////\n//halides\n////\n\nfloat halite(vec2 uv){\n    return rect_outline(uv, CENTER, SIZE, WIDTH, 0.);\n}\n\nfloat carnallite(vec2 uv){\n    float len = length(SIZE);\n    return rect_outline(uv, CENTER, SIZE, WIDTH, 0.)\n            + rect(uv, CENTER, vec2(WIDTH, len), PI*.25)\n            + rect(uv, CENTER, vec2(WIDTH, len), PI*.75);\n}\n\nfloat silvin(vec2 uv){\n    float len = length(SIZE);\n    return rect_outline(uv, CENTER, SIZE, WIDTH, 0.)\n            + rect(uv, CENTER, vec2(WIDTH, len), PI*.25);\n}\n\nfloat fluorite(vec2 uv){\n    float len = length(SIZE);\n    return rect_outline(uv, CENTER, SIZE, WIDTH, 0.)\n            + rect_outline(uv, CENTER, SIZE/2., WIDTH, 0.)\n            + line(uv, vec2(.5, .25), vec2(.5, .625), WIDTH);\n}\n\n////\n//oxygen salts\n////\n\nfloat annabergite(vec2 uv){\n    return triangle_outline(uv, vec2(.2), vec2(.5, .8), vec2(.5, .2), WIDTH)\n            + circle(uv, vec2(.4, .3), .05);\n}\n\nfloat skorodite(vec2 uv){\n    float mult = 2.;\n    vec2 uv0 = uv;\n    uv0.x *= mult;\n    vec2 center = vec2(CENTER.x*mult, CENTER.y);\n    return polygon_outline(uv0, 6, center, .6, PI*.5, WIDTH*mult);\n}\n\nfloat erythrin(vec2 uv){\n    return triangle_outline(uv, vec2(.5-length(SIZE)/2., .5), vec2(.5+length(SIZE)/2., .5), vec2(.5, .5 + length(SIZE)/2.), WIDTH)\n            + circle(uv, vec2(.5, .65), .05);\n}\n\nfloat vanadinite(vec2 uv){\n    float len = length(SIZE)/2.;\n    float off = .075;\n    return line(uv, vec2(.5-off, .5+len+off), vec2(.5+len+off, .5-off), WIDTH)\n            + line(uv, vec2(.5-len-off, .5+off), vec2(.5+off, .5-len-off), WIDTH)\n            + line(uv, vec2(.5+off, .5+len+off), vec2(.5-len-off, .5-off), WIDTH)\n            + line(uv, vec2(.5+len+off, .5+off), vec2(.5-off, .5-len-off), WIDTH)\n            + line(uv, vec2(.5-len, .5), vec2(.5+len, .5), WIDTH);\n}\n\nfloat carnotite(vec2 uv){\n    return circle_segment(uv, CENTER, .3, .5, WIDTH*2., PI*.5)\n            + line(uv, vec2(.1, .5), vec2(.9, .5), WIDTH);\n}\n\nfloat apatite(vec2 uv){\n    return polygon_outline(uv, 6, CENTER, RADIUS*2., PI*.5, WIDTH);\n}\n\nfloat turquoise(vec2 uv){\n    float len = length(SIZE)/2.;\n    float off = .075;\n    return line(uv, vec2(.5-off, .5+len+off), vec2(.5+len+off, .5-off), WIDTH)\n            + line(uv, vec2(.5-len-off, .5+off), vec2(.5+off, .5-len-off), WIDTH)\n            + line(uv, vec2(.5+off, .5+len+off), vec2(.5-len-off, .5-off), WIDTH)\n            + line(uv, vec2(.5+len+off, .5+off), vec2(.5-off, .5-len-off), WIDTH);\n}\n\nfloat monazite(vec2 uv){\n    return line(uv, vec2(.2, .35), vec2(.8, .35), WIDTH)\n            + line(uv, vec2(.8, .35), vec2(.8, .65), WIDTH)\n            + line(uv, vec2(.8, .65), vec2(.325, .65), WIDTH)\n            + line(uv, vec2(.325, .65), vec2(.2, .35), WIDTH);\n}\n\nfloat othenit(vec2 uv){\n    return circle_segment(uv, CENTER, .3, .5, 1., PI*.5)\n            + line(uv, vec2(.1, .5), vec2(.9, .5), WIDTH);\n}\n\nfloat pyromorphite(vec2 uv){\n    float len = length(SIZE)/2.;\n    float off = .075;\n    return line(uv, vec2(.5-off, .5+len+off), vec2(.5+len+off, .5-off), WIDTH)\n            + line(uv, vec2(.5-len-off, .5+off), vec2(.5+off, .5-len-off), WIDTH)\n            + line(uv, vec2(.5+off, .5+len+off), vec2(.5-len-off, .5-off), WIDTH)\n            + line(uv, vec2(.5+len+off, .5+off), vec2(.5-off, .5-len-off), WIDTH)\n            + circle(uv, CENTER, .05);\n}\n\nfloat asharite(vec2 uv){\n    return circle_outline(uv, vec2(.5, .65), .15, WIDTH)\n            + circle_outline(uv, vec2(.5, .35), .15, WIDTH);\n}\n\nfloat boracite(vec2 uv){\n    return circle(uv, vec2(.5, .65), .15)\n            + circle(uv, vec2(.5, .35), .15);\n}\n\nfloat boronatro_calcite(vec2 uv){\n    return circle(uv, CENTER, .15);\n}\n\nfloat bura(vec2 uv){\n    return circle_outline(uv, vec2(.65, .65), .15, WIDTH)\n            + circle_outline(uv, vec2(.35, .65), .15, WIDTH)\n            + circle_outline(uv, vec2(.5, .38), .15, WIDTH);\n}\n\nfloat hydroboracite(vec2 uv){\n    return circle(uv, vec2(.35, .5), .15)\n            + rect(uv, vec2(.5, .65), vec2(WIDTH, RADIUS), PI*.75);\n}\n\nfloat colemanite(vec2 uv){\n    return circle_outline(uv, CENTER, .15, WIDTH)\n            + circle(uv, CENTER, 0.075);\n}\n\nfloat pandermite(vec2 uv){\n    return circle_outline(uv, vec2(.5, .65), .15, WIDTH)\n            + circle(uv, vec2(.5, .65), .075)\n            + circle_outline(uv, vec2(.5, .35), .15, WIDTH)\n            + circle(uv, vec2(.5, .35), .075);\n}\n\nfloat wolframite(vec2 uv){\n    return line(uv, vec2(.15, .7), vec2(.45, .3), WIDTH)\n            + line(uv, vec2(.45, .3), vec2(.75, .7), WIDTH)\n            + line(uv, vec2(.3, .7), vec2(.6, .3), WIDTH)\n            + line(uv, vec2(.6, .3), vec2(.9, .7), WIDTH);\n}\n\nfloat wulferite(vec2 uv){\n    return triangle_outline(uv, vec2(.5, .2), vec2(.225, .2), vec2(.225, .8), WIDTH)\n            + triangle_outline(uv, vec2(.5, .2), vec2(.775, .2), vec2(.775, .8), WIDTH);\n}\n\nfloat scheelite(vec2 uv){\n    return line(uv, vec2(.15, .7), vec2(.45, .3), WIDTH)\n            + line(uv, vec2(.45, .3), vec2(.75, .7), WIDTH)\n            + line(uv, vec2(.3, .7), vec2(.6, .3), WIDTH)\n            + line(uv, vec2(.6, .3), vec2(.9, .7), WIDTH)\n            + circle(uv, vec2(.525, .425), .05);\n}\n\nfloat alunite(vec2 uv){\n    return triangle_outline(uv, CENTER, vec2(.35, .8), vec2(.65, .8), WIDTH)\n            + triangle_outline(uv, CENTER, vec2(.35, .2), vec2(.65, .2), WIDTH);\n}\n\nfloat potassium_alum(vec2 uv){\n    return triangle_outline(uv, CENTER, vec2(.35, .8), vec2(.65, .8), WIDTH)\n            + triangle_outline(uv, CENTER, vec2(.35, .2), vec2(.65, .2), WIDTH)\n            + circle(uv, CENTER, .1);\n}\n\nfloat barite(vec2 uv){\n    float mult = 1.5;\n    vec2 uv0 = uv;\n    uv0.x *= mult;\n    vec2 center = vec2(CENTER.x*mult, CENTER.y);\n    return rect(uv0, center, SIZE, PI*.25)\n            + line(uv, vec2(.275, .5), vec2(.1, .8), WIDTH)\n            + line(uv, vec2(.275, .5), vec2(.1, .2), WIDTH)\n            + line(uv, vec2(.725, .5), vec2(.9, .8), WIDTH)\n            + line(uv, vec2(.725, .5), vec2(.9, .2), WIDTH);\n}\n\nfloat witherite(vec2 uv){\n    float mult = 1.5;\n    vec2 uv0 = uv;\n    uv0.x *= mult;\n    vec2 center = vec2(CENTER.x*mult, CENTER.y);\n    return rect_outline(uv0, center, SIZE, WIDTH, PI*.25)\n            + line(uv, vec2(.275, .5), vec2(.1, .8), WIDTH)\n            + line(uv, vec2(.275, .5), vec2(.1, .2), WIDTH)\n            + line(uv, vec2(.725, .5), vec2(.9, .8), WIDTH)\n            + line(uv, vec2(.725, .5), vec2(.9, .2), WIDTH);\n}\n\nfloat rhodochrosite(vec2 uv){\n    float mult = 1.5;\n    vec2 uv0 = uv;\n    uv0.y *= mult;\n    vec2 center = vec2(CENTER.x, CENTER.y*mult);\n    return rect_outline(uv0, center, SIZE, WIDTH, PI*.25)\n            + circle(uv, CENTER, 0.05);\n}\n\nfloat siderite(vec2 uv){\n    float mult = 1.5;\n    vec2 uv0 = uv;\n    uv0.x *= mult;\n    vec2 center = vec2(CENTER.x*mult, CENTER.y);\n    return rect_outline(uv0, center, SIZE, WIDTH, PI*.25)\n            + circle(uv, CENTER, 0.05);\n}\n\nfloat kieserite(vec2 uv){\n    return rect_outline(uv, CENTER, vec2(.6), WIDTH, 0.)\n            + line(uv, vec2(.5, .2), vec2(.5, .8), WIDTH)\n            + circle(uv, CENTER, 0.065);\n}\n\nfloat mirabilite(vec2 uv){\n    return rect_outline(uv, CENTER, vec2(.6), WIDTH, 0.)\n            + line(uv, vec2(.2, .8), vec2(.8, .2), WIDTH)\n            + circle(uv, CENTER, 0.065);\n}\n\nfloat polyhalite(vec2 uv){\n    return rect_outline(uv, CENTER, vec2(.6), WIDTH, 0.)\n            + line(uv, vec2(.2, .8), vec2(.8, .2), WIDTH)\n            + line(uv, vec2(.2, .2), vec2(.8, .8), WIDTH)\n            + circle(uv, CENTER, 0.065);\n}\n\nfloat thenardite(vec2 uv){\n    return rect_outline(uv, CENTER, vec2(.6), WIDTH, 0.)\n            + circle(uv, CENTER, 0.065);\n}\n\nfloat epsomite(vec2 uv){\n    return rect_outline(uv, CENTER, vec2(.6), WIDTH, 0.)\n            + line(uv, vec2(.2, .2), vec2(.8, .8), WIDTH)\n            + circle(uv, CENTER, 0.065);\n}\n\nfloat potassium_kalium(vec2 uv){\n    return rect_outline(uv, CENTER, vec2(.6), WIDTH, 0.)\n            + line(uv, vec2(.2, .5), vec2(.8, .5), WIDTH)\n            + circle_outline(uv, CENTER, 0.065, WIDTH)\n            - circle(uv, CENTER, 0.065-WIDTH/2.);\n}\n\nfloat potassium_nitrate(vec2 uv){\n    return rect_outline(uv, CENTER, vec2(.6), WIDTH, 0.)\n            + line(uv, vec2(.5, .2), vec2(.5, .8), WIDTH)\n            + circle_outline(uv, CENTER, 0.065, WIDTH)\n            - circle(uv, CENTER, 0.065-WIDTH/2.);\n}\n\nfloat soda(vec2 uv){\n    return rect_outline(uv, CENTER, vec2(.6), WIDTH, 0.)\n            + circle_outline(uv, CENTER, 0.065, WIDTH);\n}\n\nfloat anhydrite(vec2 uv){\n    return circle_segment(uv, vec2(.5, .1), .5, .25, WIDTH*2., PI*.25)\n            + line(uv, vec2(.15, .45), vec2(.5, .8), WIDTH)\n            + line(uv, vec2(.85, .45), vec2(.5, .8), WIDTH);\n}\n\nfloat aragonite(vec2 uv){\n    vec2 a = vec2(.2, .35);\n    vec2 b = vec2(.4, .65);\n    vec2 c = vec2(.65, .35);\n    vec2 d = vec2(.85, .65);\n    float radius = 0.06;\n    return line(uv, a, b, WIDTH)\n            + line(uv, b, c, WIDTH)\n            + line(uv, c, d, WIDTH)\n            + line(uv, a, c, WIDTH)\n            + line(uv, b, d, WIDTH);\n}\n\nfloat gypsum(vec2 uv){\n    return circle_segment(uv, vec2(.5, .9), .5, .25, WIDTH*2., PI*1.25)\n            + line(uv, vec2(.15, .55), vec2(.5, .2), WIDTH)\n            + line(uv, vec2(.85, .55), vec2(.5, .2), WIDTH);\n}\n\nfloat dolonitis(vec2 uv){\n    return triangle_outline(uv, vec2(.3, .35), vec2(.7, .35), vec2(.5, .65), WIDTH)\n            + line(uv, vec2(.5, .65), vec2(.6, .825), WIDTH);\n}\n\nfloat calcite(vec2 uv){\n    vec2 a = vec2(.2, .35);\n    vec2 b = vec2(.4, .65);\n    vec2 c = vec2(.65, .35);\n    vec2 d = vec2(.85, .65);\n    float radius = 0.06;\n    return line(uv, a, b, WIDTH)\n            + line(uv, c, d, WIDTH)\n            + line(uv, a, c, WIDTH)\n            + line(uv, b, d, WIDTH);\n}\n\nfloat magnesite(vec2 uv){\n    vec2 a = vec2(.2, .35);\n    vec2 b = vec2(.4, .65);\n    vec2 c = vec2(.65, .35);\n    vec2 d = vec2(.85, .65);\n    float radius = 0.06;\n    return line(uv, a, b, WIDTH)\n            + line(uv, c, d, WIDTH)\n            + line(uv, a, c, WIDTH)\n            + line(uv, b, d, WIDTH)\n            + line(uv, a, d, WIDTH);\n}\n\nfloat azurite(vec2 uv){\n    return triangle_outline(uv, vec2(.2), vec2(.8, .2), vec2(.5, .8), WIDTH)\n            + circle_outline(uv, vec2(.5, .4), .075, WIDTH);\n}\n\nfloat malachite(vec2 uv){\n    return triangle_outline(uv, vec2(.2), vec2(.8, .2), vec2(.5, .8), WIDTH)\n            + circle(uv, vec2(.5, .4), .075);\n}\n\nfloat anglesite(vec2 uv){\n    return triangle(uv, vec2(.2, .5), vec2(.8, .5), vec2(.5, .8))\n            + triangle_outline(uv, vec2(.2, .5), vec2(.8, .5), vec2(.5, .2), WIDTH);\n}\n\nfloat cerussite(vec2 uv){\n    return triangle_outline(uv, vec2(.2, .5), vec2(.8, .5), vec2(.5, .8), WIDTH)\n            + triangle(uv, vec2(.2, .5), vec2(.8, .5), vec2(.5, .2));\n}\n\nfloat strontianite(vec2 uv){\n    float mult = 1.5;\n    vec2 uv0 = uv;\n    uv0.y *= mult;\n    vec2 center = vec2(CENTER.x, CENTER.y*mult);\n    return rect_outline(uv0, center, SIZE, WIDTH, PI*.25)\n            + line(uv, vec2(.5, .275), vec2(.1, .1), WIDTH)\n            + line(uv, vec2(.5, .275), vec2(.9, .1), WIDTH)\n            + line(uv, vec2(.5, .725), vec2(.1, .9), WIDTH)\n            + line(uv, vec2(.5, .725), vec2(.9, .9), WIDTH)\n            + circle(uv, CENTER, 0.075);\n}\n\nfloat celestine(vec2 uv){\n    float mult = 1.5;\n    vec2 uv0 = uv;\n    uv0.y *= mult;\n    vec2 center = vec2(CENTER.x, CENTER.y*mult);\n    return rect_outline(uv0, center, SIZE, WIDTH, PI*.25)\n            + line(uv, vec2(.5, .275), vec2(.1, .1), WIDTH)\n            + line(uv, vec2(.5, .275), vec2(.9, .1), WIDTH)\n            + line(uv, vec2(.5, .725), vec2(.1, .9), WIDTH)\n            + line(uv, vec2(.5, .725), vec2(.9, .9), WIDTH);\n}\n\nfloat smithsonite(vec2 uv){\n    return polygon_outline(uv, 6, CENTER, RADIUS*2., 0., WIDTH)\n            + circle_outline(uv, CENTER, 0.075, WIDTH);\n}\n\n\n////\n//main\n////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = vec3(0.0);\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float patternMask = rect(uv, vec2(0.5), vec2(1.0), -2.);\n    \n    vec2 grid = uv * float(GRID_N);\n    uv = fract(grid);\n    \n    color += set_ceil(grid, 0, 0) * vec3(hornblende(uv));\n    color += set_ceil(grid, 0, 1) * vec3(anthophyllite(uv));\n    color += set_ceil(grid, 0, 2) * vec3(arfvedsonite(uv));\n    color += set_ceil(grid, 0, 3) * vec3(actinolite(uv));\n    color += set_ceil(grid, 0, 4) * vec3(glaucophane(uv));\n    color += set_ceil(grid, 0, 5) * vec3(tremolite(uv));\n\n    color += set_ceil(grid, 1, 0) * vec3(almandine(uv));\n    color += set_ceil(grid, 1, 1) * vec3(andradite(uv));\n    color += set_ceil(grid, 1, 2) * vec3(pyrope(uv));\n    \n    color += set_ceil(grid, 2, 0) * vec3(diamond(uv));\n    color += set_ceil(grid, 2, 1) * vec3(bismud(uv));\n    color += set_ceil(grid, 2, 2) * vec3(graphite(uv));\n    color += set_ceil(grid, 2, 3) * vec3(copper(uv));\n    color += set_ceil(grid, 2, 4) * vec3(arsenic(uv));\n    color += set_ceil(grid, 2, 5) * vec3(nevyaskit(uv));\n    color += set_ceil(grid, 2, 6) * vec3(platinum(uv));\n    color += set_ceil(grid, 2, 7) * vec3(sulfur(uv));\n    color += set_ceil(grid, 2, 8) * vec3(sysertskit(uv));\n    \n    color += set_ceil(grid, 3, 0) * vec3(bismuth(uv));\n    color += set_ceil(grid, 3, 1) * vec3(pyrite(uv));\n    color += set_ceil(grid, 3, 2) * vec3(pyrrhotite(uv));\n    color += set_ceil(grid, 3, 3) * vec3(glaucodot(uv));\n    color += set_ceil(grid, 3, 4) * vec3(cobaltin(uv));\n    color += set_ceil(grid, 3, 5) * vec3(smaltin(uv));\n    color += set_ceil(grid, 3, 6) * vec3(bornite(uv));\n    color += set_ceil(grid, 3, 7) * vec3(covelline(uv));\n    color += set_ceil(grid, 3, 8) * vec3(tennantitis(uv));\n    color += set_ceil(grid, 3, 9) * vec3(tetrahedrite(uv));\n    \n    color += set_ceil(grid, 4, 0) * vec3(chalcosine(uv));\n    color += set_ceil(grid, 4, 1) * vec3(chalcopyrite(uv));\n    color += set_ceil(grid, 4, 2) * vec3(molebdenite(uv));\n    color += set_ceil(grid, 4, 3) * vec3(arsenopyrite(uv));\n    color += set_ceil(grid, 4, 4) * vec3(orpiment(uv));\n    color += set_ceil(grid, 4, 5) * vec3(lellingite(uv));\n    color += set_ceil(grid, 4, 6) * vec3(realgar(uv));\n    color += set_ceil(grid, 4, 7) * vec3(millerite(uv));\n    color += set_ceil(grid, 4, 8) * vec3(nickeline(uv));\n    color += set_ceil(grid, 4, 9) * vec3(pentlandite(uv));\n\n    color += set_ceil(grid, 5, 0) * vec3(chloanitis(uv));\n    color += set_ceil(grid, 5, 1) * vec3(sperrylite(uv));\n    color += set_ceil(grid, 5, 2) * vec3(cinnabar(uv));\n    color += set_ceil(grid, 5, 3) * vec3(metacin_nabarite(uv));\n    color += set_ceil(grid, 5, 4) * vec3(galena(uv));\n    color += set_ceil(grid, 5, 5) * vec3(antimonite(uv));\n    color += set_ceil(grid, 5, 6) * vec3(boulangerite(uv));\n    \n    color += set_ceil(grid, 6, 0) * vec3(boehmite(uv));\n    color += set_ceil(grid, 6, 1) * vec3(hydrargillite(uv));\n    color += set_ceil(grid, 6, 2) * vec3(diasporas(uv));\n    color += set_ceil(grid, 6, 3) * vec3(corundum(uv));\n    color += set_ceil(grid, 6, 4) * vec3(chrysoberyl(uv));\n    color += set_ceil(grid, 6, 5) * vec3(spinel(uv));\n    color += set_ceil(grid, 6, 6) * vec3(ice(uv));\n    color += set_ceil(grid, 6, 7) * vec3(hematite(uv));\n    color += set_ceil(grid, 6, 8) * vec3(goethite(uv));\n    color += set_ceil(grid, 6, 9) * vec3(ilmenite(uv));\n    \n    color += set_ceil(grid, 7, 0) * vec3(limonite(uv));\n    color += set_ceil(grid, 7, 1) * vec3(magnetite(uv));\n    color += set_ceil(grid, 7, 2) * vec3(quartz(uv));\n    color += set_ceil(grid, 7, 3) * vec3(opal(uv));\n    color += set_ceil(grid, 7, 4) * vec3(chalcedony(uv));\n    color += set_ceil(grid, 7, 5) * vec3(brownite(uv));\n    color += set_ceil(grid, 7, 6) * vec3(hausmanite(uv));\n    color += set_ceil(grid, 7, 7) * vec3(manganite(uv));\n    color += set_ceil(grid, 7, 8) * vec3(pyrolusite(uv));\n    color += set_ceil(grid, 7, 9) * vec3(psilomelan(uv));\n    \n    color += set_ceil(grid, 8, 0) * vec3(columbite(uv));\n    color += set_ceil(grid, 8, 1) * vec3(loparite(uv));\n    color += set_ceil(grid, 8, 2) * vec3(pyrochlore(uv));\n    color += set_ceil(grid, 8, 3) * vec3(tantalite(uv));\n    color += set_ceil(grid, 8, 4) * vec3(cassiterite(uv));\n    color += set_ceil(grid, 8, 5) * vec3(anatase(uv));\n    color += set_ceil(grid, 8, 6) * vec3(rutile(uv));\n    color += set_ceil(grid, 8, 7) * vec3(chrome_spinel(uv));\n    color += set_ceil(grid, 8, 8) * vec3(uraninite(uv));\n    \n    color += set_ceil(grid, 9, 0) * vec3(halite(uv));\n    color += set_ceil(grid, 9, 1) * vec3(carnallite(uv));\n    color += set_ceil(grid, 9, 2) * vec3(silvin(uv));\n    color += set_ceil(grid, 9, 3) * vec3(fluorite(uv));\n    \n    color += set_ceil(grid, 10, 0) * vec3(annabergite(uv));\n    color += set_ceil(grid, 10, 1) * vec3(skorodite(uv));\n    color += set_ceil(grid, 10, 2) * vec3(erythrin(uv));\n    color += set_ceil(grid, 10, 3) * vec3(vanadinite(uv));\n    color += set_ceil(grid, 10, 4) * vec3(carnotite(uv));\n    color += set_ceil(grid, 10, 5) * vec3(apatite(uv));\n    color += set_ceil(grid, 10, 6) * vec3(turquoise(uv));\n    color += set_ceil(grid, 10, 7) * vec3(monazite(uv));\n    color += set_ceil(grid, 10, 8) * vec3(othenit(uv));\n    color += set_ceil(grid, 10, 9) * vec3(pyromorphite(uv));\n    \n    color += set_ceil(grid, 11, 0) * vec3(asharite(uv));\n    color += set_ceil(grid, 11, 1) * vec3(boracite(uv));\n    color += set_ceil(grid, 11, 2) * vec3(boronatro_calcite(uv));\n    color += set_ceil(grid, 11, 3) * vec3(bura(uv));\n    color += set_ceil(grid, 11, 4) * vec3(hydroboracite(uv));\n    color += set_ceil(grid, 11, 5) * vec3(colemanite(uv));\n    color += set_ceil(grid, 11, 6) * vec3(pandermite(uv));\n    color += set_ceil(grid, 11, 7) * vec3(wolframite(uv));\n    color += set_ceil(grid, 11, 8) * vec3(wulferite(uv));\n    color += set_ceil(grid, 11, 9) * vec3(scheelite(uv));\n    \n    color += set_ceil(grid, 12, 0) * vec3(alunite(uv));\n    color += set_ceil(grid, 12, 1) * vec3(potassium_alum(uv));\n    color += set_ceil(grid, 12, 2) * vec3(barite(uv));\n    color += set_ceil(grid, 12, 3) * vec3(witherite(uv));\n    color += set_ceil(grid, 12, 4) * vec3(rhodochrosite(uv));\n    color += set_ceil(grid, 12, 5) * vec3(siderite(uv));\n    color += set_ceil(grid, 12, 6) * vec3(kieserite(uv));\n    color += set_ceil(grid, 12, 7) * vec3(mirabilite(uv));\n    color += set_ceil(grid, 12, 8) * vec3(polyhalite(uv));\n    color += set_ceil(grid, 12, 9) * vec3(thenardite(uv));\n    \n    color += set_ceil(grid, 13, 0) * vec3(epsomite(uv));\n    color += set_ceil(grid, 13, 1) * vec3(potassium_kalium(uv));\n    color += set_ceil(grid, 13, 2) * vec3(potassium_nitrate(uv));\n    color += set_ceil(grid, 13, 3) * vec3(soda(uv));\n    color += set_ceil(grid, 13, 4) * vec3(anhydrite(uv));\n    color += set_ceil(grid, 13, 5) * vec3(aragonite(uv));\n    color += set_ceil(grid, 13, 6) * vec3(gypsum(uv));\n    color += set_ceil(grid, 13, 7) * vec3(dolonitis(uv));\n    color += set_ceil(grid, 13, 8) * vec3(calcite(uv));\n    color += set_ceil(grid, 13, 9) * vec3(magnesite(uv));\n    \n    color += set_ceil(grid, 14, 0) * vec3(azurite(uv));\n    color += set_ceil(grid, 14, 1) * vec3(malachite(uv));\n    color += set_ceil(grid, 14, 2) * vec3(anglesite(uv));\n    color += set_ceil(grid, 14, 3) * vec3(cerussite(uv));\n    color += set_ceil(grid, 14, 4) * vec3(strontianite(uv));\n    color += set_ceil(grid, 14, 5) * vec3(celestine(uv));\n    color += set_ceil(grid, 14, 6) * vec3(smithsonite(uv));\n    \n    color = vec3(1.) - color;\n    \n    // * patternMask * mod(floor(grid.x), 2.);\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddVXWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 204, 204, 238], [240, 240, 274, 274, 347], [380, 380, 427, 427, 586], [588, 588, 645, 645, 804], [806, 806, 884, 884, 988], [990, 990, 1039, 1039, 1106], [1108, 1108, 1178, 1178, 1283], [1285, 1285, 1381, 1381, 1991], [1993, 1993, 2060, 2060, 2606], [2608, 2608, 2695, 2695, 2839], [2841, 2841, 2911, 2911, 3130], [3132, 3132, 3223, 3223, 3331], [3367, 3367, 3417, 3417, 3630], [3688, 3688, 3714, 3714, 3774], [3776, 3776, 3805, 3805, 3927], [3929, 3929, 3957, 3957, 4079], [4081, 4081, 4107, 4107, 4281], [4283, 4283, 4310, 4310, 4484], [4486, 4486, 4511, 4511, 4760], [4789, 4789, 4814, 4814, 4996], [4998, 4998, 5023, 5023, 5271], [5273, 5273, 5295, 5295, 5610], [5633, 5633, 5656, 5656, 5840], [5842, 5842, 5864, 5864, 5998], [6000, 6000, 6024, 6024, 6074], [6076, 6076, 6098, 6098, 6182], [6184, 6184, 6207, 6207, 6271], [6273, 6273, 6298, 6298, 6476], [6478, 6478, 6502, 6502, 6602], [6604, 6604, 6626, 6626, 7089], [7091, 7091, 7117, 7117, 7357], [7381, 7381, 7404, 7404, 7610], [7612, 7612, 7634, 7634, 7735], [7737, 7737, 7763, 7763, 7866], [7868, 7868, 7893, 7893, 8099], [8102, 8102, 8126, 8126, 8359], [8361, 8361, 8384, 8384, 8617], [8619, 8619, 8642, 8642, 8788], [8790, 8790, 8815, 8815, 8960], [8962, 8962, 8989, 8989, 9140], [9142, 9142, 9170, 9170, 9304], [9306, 9306, 9332, 9332, 9481], [9483, 9483, 9511, 9511, 9576], [9578, 9578, 9605, 9605, 9723], [9725, 9725, 9753, 9753, 9873], [9875, 9875, 9899, 9899, 10023], [10025, 10025, 10051, 10051, 10187], [10189, 10189, 10212, 10212, 10336], [10338, 10338, 10363, 10363, 10501], [10503, 10503, 10528, 10528, 10608], [10610, 10610, 10637, 10637, 10702], [10704, 10704, 10730, 10730, 10879], [10881, 10881, 10907, 10907, 11025], [11027, 11027, 11051, 11051, 11222], [11224, 11224, 11256, 11256, 11354], [11356, 11356, 11378, 11378, 11423], [11425, 11425, 11451, 11451, 11779], [11781, 11781, 11809, 11809, 12188], [12225, 12225, 12249, 12249, 12464], [12466, 12466, 12495, 12495, 12618], [12620, 12620, 12645, 12645, 12844], [12846, 12846, 12870, 12870, 13045], [13047, 13047, 13074, 13074, 13309], [13311, 13311, 13333, 13333, 13393], [13395, 13395, 13414, 13414, 13801], [13803, 13803, 13827, 13827, 13976], [13978, 13978, 14002, 14002, 14292], [14294, 14294, 14318, 14318, 14597], [14599, 14599, 14623, 14623, 14880], [14882, 14882, 14907, 14907, 15041], [15043, 15043, 15065, 15065, 15151], [15153, 15153, 15173, 15173, 15244], [15246, 15246, 15272, 15272, 15405], [15407, 15407, 15431, 15431, 15580], [15582, 15582, 15608, 15608, 15877], [15879, 15879, 15904, 15904, 16140], [16142, 16142, 16168, 16168, 16302], [16304, 16304, 16330, 16330, 16657], [16659, 16659, 16684, 16684, 16811], [16813, 16813, 16837, 16837, 16960], [16962, 16962, 16988, 16988, 17115], [17117, 17117, 17142, 17142, 17265], [17267, 17267, 17294, 17294, 17526], [17528, 17528, 17551, 17551, 17921], [17923, 17923, 17945, 17945, 18276], [18278, 18278, 18307, 18307, 18548], [18550, 18550, 18575, 18575, 18638], [18661, 18661, 18683, 18683, 18739], [18741, 18741, 18767, 18767, 18967], [18969, 18969, 18991, 18991, 19134], [19136, 19136, 19160, 19160, 19366], [19394, 19394, 19421, 19421, 19545], [19547, 19547, 19572, 19572, 19749], [19751, 19751, 19775, 19775, 19954], [19956, 19956, 19982, 19982, 20431], [20433, 20433, 20458, 20458, 20582], [20584, 20584, 20607, 20607, 20677], [20679, 20679, 20704, 20704, 21087], [21089, 21089, 21113, 21113, 21357], [21359, 21359, 21382, 21382, 21500], [21502, 21502, 21530, 21530, 21951], [21953, 21953, 21977, 21977, 22097], [22099, 22099, 22123, 22123, 22213], [22215, 22215, 22248, 22248, 22286], [22288, 22288, 22308, 22308, 22490], [22492, 22492, 22521, 22521, 22633], [22635, 22635, 22661, 22661, 22754], [22756, 22756, 22782, 22782, 22994], [22996, 22996, 23022, 23022, 23258], [23260, 23260, 23285, 23285, 23461], [23463, 23463, 23488, 23488, 23772], [23774, 23774, 23797, 23797, 23957], [23959, 23959, 23989, 23989, 24186], [24188, 24188, 24210, 24210, 24605], [24607, 24607, 24632, 24632, 25042], [25044, 25044, 25073, 25073, 25282], [25284, 25284, 25308, 25308, 25517], [25519, 25519, 25544, 25544, 25702], [25704, 25704, 25730, 25730, 25888], [25890, 25890, 25916, 25916, 26132], [26134, 26134, 26160, 26160, 26260], [26262, 26262, 26286, 26286, 26444], [26446, 26446, 26478, 26478, 26700], [26702, 26702, 26735, 26735, 26957], [26959, 26959, 26979, 26979, 27094], [27096, 27096, 27121, 27121, 27315], [27317, 27317, 27342, 27342, 27661], [27663, 27663, 27685, 27685, 27880], [27882, 27882, 27907, 27907, 28055], [28057, 28057, 28080, 28080, 28363], [28365, 28365, 28390, 28390, 28709], [28711, 28711, 28734, 28734, 28874], [28876, 28876, 28901, 28901, 29026], [29028, 29028, 29053, 29053, 29206], [29208, 29208, 29233, 29233, 29386], [29388, 29388, 29416, 29416, 29866], [29868, 29868, 29893, 29893, 30303], [30305, 30305, 30332, 30332, 30454], [30475, 30475, 30530, 30530, 38146]], "test": "untested"}
{"id": "Mcs3WM", "name": "amagi test: easy bokeh", "author": "amagitakayosi", "description": "easy bokeh vignettea", "tags": ["raymarching"], "likes": 9, "viewed": 231, "published": 3, "date": "1703181656", "time_retrieved": "2024-07-30T17:15:14.833416", "image_code": "mat2 rot(float t) {\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\n\nfloat sdBox(vec3 p, vec3 b) {\n    return length(max(abs(p) - b, 0.));\n}\n\nvec2 map(vec3 p) {\n    vec3 p0 = p;\n    p.z -= iTime * 2.;\n    p.xy *= rot(iTime * 3.141593 / 2. / 6.);\n\n    // fold\n    for (int i = 0; i < 4; i++) {\n        p = abs(p);\n        p += sin(1. + float(i) * 11.);\n        p.xy *= rot(3.141593 / 4.); // 45deg\n        p *= 1.1;\n    }    \n\n    // repeat\n    p = mod(p + vec3(2, 2, 0), 4.) - 2.;        \n\n    float d = 999.;    \n    \n    // box\n    d = min(d, sdBox(p - vec3(1, 0, 0), vec3(0.1, 1.1, 0.1)));    \n    d = min(d, sdBox(p + vec3(1, 0, 0), vec3(0.1, 1.1, 0.1)));    \n    d = min(d, sdBox(p - vec3(0, 1, 0), vec3(1.1, 0.1, 0.1)));        \n    d = min(d, sdBox(p + vec3(0, 1, 0), vec3(1.1, 0.1, 0.1))); \n\n    return vec2(d, 0);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 d = vec2(0, 1) * 0.0001;\n    return normalize(vec3(\n       (map(p + d.yxx) - map(p - d.yxx)).x,\n       (map(p + d.xyx) - map(p - d.xyx)).x,\n       (map(p + d.xxy) - map(p - d.xxy)).x\n    ));       \n}\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(8389., 8939.))) * 498.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv * 2. - 1.;       \n    p.x *= iResolution.x / iResolution.y;\n    \n    vec2 dist = mix(vec2(0), vec2(hash(p), hash(p + 1.)) * 2. - 1., pow(length(p) * 0.5, 2.) * 0.08);\n\n    vec3 ro = vec3(0, 0, 5);\n    vec3 rd = normalize(vec3(p + dist, -1. + 0.2 * length(p)));\n    \n    vec3 rp;\n    \n    vec2 hit;\n    float t;\n\n    vec3 col;\n\n    for (int i = 0; i < 120; i++) {\n        rp = ro + rd * t;\n        hit = map(rp);\n        \n        if (hit.x < 0.001) {\n            vec3 n = getNormal(rp);\n            if (hit.y == 0.) {\n                float x = sin(iTime * 3.141593) * 0.5 + 0.5;\n                float y = sin(rp.z + iTime * 3.141593 / 2.) * 0.5 + 0.5; \n                col = mix(vec3(1), vec3(x, 0, 0), y) - float(i) * 0.005 - t * 0.02;\n            }\n            break;\n        }\n        \n        t += hit.x * 0.4;\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mcs3WM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 71], [74, 74, 103, 103, 145], [147, 147, 165, 165, 829], [831, 831, 855, 855, 1064], [1066, 1066, 1086, 1086, 1146], [1148, 1148, 1203, 1203, 2138]], "test": "untested"}
{"id": "lffGRS", "name": "2 colors, black and white, video", "author": "afl_ext", "description": "I wanted to see what can be done with only black and white pixels dithered", "tags": ["white", "dithering", "black"], "likes": 3, "viewed": 149, "published": 3, "date": "1703179175", "time_retrieved": "2024-07-30T17:15:15.599368", "image_code": "float rand2d(vec2 co){\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float rd = fract(rand2d(uv) + iTime);\n\n    float col = texture(iChannel0, uv).r;\n    col = floor(col + rd);\n\n    fragColor = vec4(col, col, col ,1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lffGRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 93], [95, 95, 152, 152, 354]], "test": "untested"}
{"id": "lcXGRS", "name": "Ice Experiments", "author": "BeardThings", "description": "Experiments with approximate subsurface scattering based on https://www.gdcvault.com/play/1014538/Approximating-Translucency-for-a-Fast", "tags": ["subsurface", "ice"], "likes": 5, "viewed": 152, "published": 3, "date": "1703178308", "time_retrieved": "2024-07-30T17:15:16.464056", "image_code": "#define SS_AMBIENT 0.5\n#define SS_DISTORTION 0.2\n#define SS_POWER 8.0\n#define SS_SCALE 2.5\n#define CONE_THICKNESS 0.8\n#define CONE_POWER 3.0\n#define CONE_ANGLE 1.05\n#define ROUGHNESS 0.2\n#define FRESNEL vec3(1.0,1.0,1.0) * 0.2\n\nfloat rcp(float v) { return 1.0 / v; }\nfloat Pi = 3.14159265358979323846264338327;\n\nvec3 fresnelSchlick(vec3 r0, vec3 n, vec3 i)\n{\n\tfloat a = 1.0 - dot(n, i);\n\treturn r0 + (1.0 - r0) * a*a*a*a*a;\n}\n\nfloat ggx_d(float roughnessSq, float hdotn)\n{\n\t// https://jcgt.org/published/0003/02/03/paper.pdf\n\tfloat hdotnSq = hdotn * hdotn;\n\tfloat t = (hdotnSq * (roughnessSq - 1.0) + 1.0);\n\treturn roughnessSq * rcp(t * t) / Pi;\n}\n\nvec3 ggx(float roughness, float hdotn, float vdotn, float ldotn, vec3 fresnel)\n{\n\tvec3 F = fresnel;\n\n\t// Generalized form:\n\t/*float roughnessSq = roughness*roughness;\n\tfloat D = ggxD(roughnessSq, hdotn) * (hdotn > 0.0f ? 1.0f : 0.0f);\n\tfloat maskingLambda = ggxLambda(roughnessSq, vdotn);\n\tfloat shadowingLambda = ggxLambda(roughnessSq, ldotn);\n\tfloat G = maskingShadowingCorrelatedG(maskingLambda, shadowingLambda);\n\treturn F * (G * D / (4.0f * vdotn * ldotn));*/\n\n\t// Shadowing Masking Simplified Form:\n\tfloat roughnessSq = roughness*roughness;\n\tfloat D = ggx_d(roughnessSq, hdotn) * (hdotn > 0.0f ? 1.0f : 0.0f);\n\n\t// Algebraically merged shadowingLambda and maskingLambda\n\tfloat t0 = vdotn * sqrt((1.0f - roughnessSq) * ldotn * ldotn + roughnessSq);\n\tfloat t1 = ldotn * sqrt((1.0f - roughnessSq) * vdotn * vdotn + roughnessSq);\n\tfloat simplifiedG = rcp(t0 + t1);\n\treturn F * (simplifiedG * D * 0.5f);\n}\n\nvec3 RayDirection(in vec3 \tforward,\n                  in float \tfocalDistance,\n                  in vec3 \tright,\n                  in vec3 \tup,\n                  in vec2 \tscreenSpaceCoord,\n                  in float \taspectRatioXOverY)\n{\n    return normalize(forward * focalDistance + \n                     right * screenSpaceCoord.x * aspectRatioXOverY +\n                     up * screenSpaceCoord.y);\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat coneThickness(vec3 p)\n{\n    return 1.0-pow((abs(p.y - 0.8) / 1.4) * CONE_THICKNESS, CONE_POWER);\n}\n\nfloat SDF(vec3 p, bool useBump)\n{\n    float a = CONE_ANGLE+(useBump ? texture(iChannel2, vec2(atan(p.z,p.x)*2.0, p.y*1.2)).r*0.03 : 0.0);\n    float coneSDF = sdCone(p-vec3(0.0,0.8,0.0),\n        vec2(cos(a), sin(a)), 1.4);\n    return coneSDF;\n}\n\nvec3 Norm(vec3 p)\n{\n    const float cEps = 0.01;\n \n\treturn normalize\n\t(\tvec3\n\t\t(\tSDF(p + vec3(cEps, 0, 0),true) - SDF(p - vec3(cEps, 0, 0),true),\n\t\t\tSDF(p + vec3(0, cEps, 0),true) - SDF(p - vec3(0, cEps, 0),true),\n\t\t\tSDF(p + vec3(0, 0, cEps),true) - SDF(p - vec3(0, 0, cEps),true)\n\t\t)\n\t);\n}\n\nvec3 PaleIceBlue = vec3(186,242,239)/255.0;\nvec3 IceBlue = vec3(115,155,208)/255.0;\n\n// Based on https://www.gdcvault.com/play/1014538/Approximating-Translucency-for-a-Fast\nvec3 subsurface(vec3 l, vec3 n, vec3 v, float t)\n{\n    float distortion = SS_DISTORTION;\n    float power = SS_POWER;\n    float scale = SS_SCALE;\n    vec3 ambient = PaleIceBlue*SS_AMBIENT;\n    \n    vec3 transluentL = l + n * distortion;\n    float translucentDot = \n        pow(min(max(dot(-transluentL, v), 0.0), 1.0), power) * scale;\n    return (ambient + translucentDot) * t;\n}\nvec4 Sample(vec3 o, vec3 direction)\n{\n    vec4 fc;\n    \n    float d = 0.0;\n    for(float i = 0.; i < 64.; ++i)\n    {\n        vec3 pos = o + direction * d;\n\n        float sdf = SDF(pos, false);\n        d += sdf;\n        \n        fc = pow(texture(iChannel0, direction), vec4(2.2));\n        \n        const float EPSILON = 0.0001;\n        if(sdf < EPSILON)\n        {\n            fc = vec4(0.0);\n            vec3 n = Norm(pos);\n            vec3 albedo = IceBlue/Pi;\n            \n            vec3 lp = vec3(1.0, 0.0, 0.0);\n            vec3 ld = normalize(lp-pos);\n            \n            vec3 v = -direction;\n            \n            // Direct\n            float thick = coneThickness(pos);\n            if(true)\n            {\n                float lightInten = 8.0 * min(rcp(pow(distance(lp, pos), 2.0)), 1.0);\n            \n                float ndotl = max(dot(ld, n), 0.0);\n                vec3 h = normalize(ld+v);\n                vec3 F = fresnelSchlick(FRESNEL, h, v);\n                float hdotn = dot(h, n);\n                float vdotn = dot(v, n);\n                fc.rgb += lightInten*ndotl * ggx(ROUGHNESS,\n                    hdotn,\n                    vdotn,\n                    ndotl,\n                    F);\n               \n                fc.rgb += lightInten*albedo*subsurface(ld, n, v, thick);\n            }\n\n            // Ambient\n            if(true)\n            {\n                float lightInten = 1.0;\n            \n                vec3 aDir = -v;\n                vec3 ambientSS = subsurface(aDir, n, v, thick);\n            \tvec3 ambient = lightInten*pow(textureLod(iChannel1,aDir,1.0).rgb,vec3(2.2));\n            \tambient = albedo*ambientSS*ambient;\n                \n                float specIntensity = 1.0;\n                vec3 iv = reflect(-v, n);\n                vec3 h = n;\n                vec3 F = fresnelSchlick(FRESNEL, h, iv);\n                vec3 spec = specIntensity*F *pow(textureLod(iChannel1,iv,0.0).rgb,vec3(2.2));\n            \n                fc.rgb += spec+ambient; \n            }\n            \n            break;\n        }\n        \n        if(d > 30.)\n        {\n            break;\n        }\n    }\n    \n    return fc;\n}\n\nvec3 simpleReinhardToneMapping(vec3 color)\n{\n\tfloat exposure = 1.0;\n\tcolor *= exposure/(1. + color / exposure);\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 screenSpace = uv * 2.0 - 1.0;\n\t\n    const float height = 0.0;\n    vec3 o = vec3(sin(iTime*0.2)*1.5,height,-1.5*cos(iTime*0.2));\n    \n    vec3 f = normalize(-o);\n    vec3 u = vec3(0,1,0);\n    vec3 r = normalize(cross(f, u));\n    \n    vec3 direction = RayDirection(f, \n                                  1.0, \n                                  r, \n                                  u, \n                                  screenSpace, \n                                  iResolution.x / iResolution.y);\n    \n    vec3 fc = Sample(o, direction).xyz;\n    \n    const float gamma = 2.2;\n    // reinhard tone mapping\n    vec3 mapped = fc;//simpleReinhardToneMapping(fc);\n    // gamma correction \n    mapped = pow(mapped, vec3(1.0 / gamma));\n    \n    fragColor = vec4(mapped, 1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcXGRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[228, 228, 248, 248, 266], [312, 312, 358, 358, 425], [427, 427, 472, 524, 647], [649, 649, 729, 729, 1555], [1557, 1557, 1794, 1794, 1961], [1963, 1963, 2004, 2138, 2473], [2475, 2475, 2504, 2504, 2579], [2581, 2581, 2614, 2614, 2824], [2826, 2826, 2845, 2845, 3116], [3203, 3291, 3341, 3341, 3669], [3670, 3670, 3707, 3707, 5821], [5823, 5823, 5867, 5867, 5951], [5954, 5954, 6011, 6011, 6833]], "test": "untested"}
{"id": "XclGWr", "name": "reflections!", "author": "aerowave", "description": "A simple raymarcher that supports single reflections. Mouse to rotate mirror.\n\nI'm still learning this awesome tech, so I might be doing things the wrong way. Comment if you have any suggestions!", "tags": ["raymarching", "reflection", "mirror"], "likes": 1, "viewed": 186, "published": 3, "date": "1703176358", "time_retrieved": "2024-07-30T17:15:17.296829", "image_code": "const float EPSILON = .001;\nconst int MAX_STEPS = 256;\nconst float MAX_DIST = 100.0;\nconst float PI = asin(1.0) * 2.0;\n\nconst bool REFLECTIONS = true;\n\n// i thought maybe i could also store color, but the ground plane would lose its pattern\nstruct Material {\n    float mirror;\n};\n\nMaterial[] materials = Material[](\n    Material(0.2), // floor plane\n    Material(0.0), // sphere 1\n    Material(0.2), // sphere 2\n    Material(0.9) // mirror\n);\n\nfloat sceneSDF(vec3 p, out int ID) {\n    // floor\n    ID = 0;\n    float dist = p.y;\n        \n    // spheres\n    if (dist > EPSILON) ID = 1;\n    dist = min(dist, length(p - vec3(sin(iTime), 1, cos(iTime))) - 0.5);\n    \n    if (dist > EPSILON) ID = 2;\n    dist = min(dist, length(p - vec3(sin(iTime+PI), 1, cos(iTime+PI))) - 0.5);\n    \n    // mirror thing\n    if (dist > EPSILON) ID = 3;\n    dist = min(dist, \n        max(\n            length(p - vec3(3, 1, -1)) - 1.0,\n            (cos(3.0 - iMouse.x / iResolution.x) * (p.x - 3.0) + sin(3.0 - iMouse.x / iResolution.x) * (p.z + 1.0))\n        )\n    );\n    \n    // nothing hit\n    if (dist > EPSILON) ID = -1;\n    return dist;\n}\n\n// Calculate the normal by taking the central differences on the distance field.\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    int a = 0;\n    return normalize(\n        e.xyy * sceneSDF(p + e.xyy, a) +\n        e.yyx * sceneSDF(p + e.yyx, a) +\n        e.yxy * sceneSDF(p + e.yxy, a) +\n        e.xxx * sceneSDF(p + e.xxx, a));\n}\n\n// gets color for given object\nvec3 albedo(vec3 p, vec3 n, int ID) {\n    switch (ID) {\n        case 0:\n            return vec3(mod(floor(p.x) + floor(p.y) + floor(p.z), 2.0)) * 0.5 + 0.5;\n        case 1:\n            return vec3(1,0,0.5);\n        case 2:\n            return vec3(0,1,0.5);\n        case 3:\n            return vec3(1,1,1);\n    }\n}\n\n// final material shader\nvec3 shade(vec3 p, vec3 d, vec3 n, int ID) {\n    if (ID == -1) // sky\n        return mix(vec3(1,1,0), vec3(1,0,1), dot(d, vec3(0,1,0)) * 2.0);\n        \n    // phong shading or something idk\n    vec3 color = albedo(p, n, ID);\n    return color * (0.5 + 0.5 * dot(n, normalize(vec3(-1,2,0))));\n}\n\n// is this a good way of storing optional data?\nstruct RaycastData {\n    int steps;\n    int ID;\n};\n\n// Sends a ray from input position and marches until a surface is hit\nvec3 raycast(in vec3 rayOrigin, inout vec3 rayDirection, inout RaycastData data) {\n    float dist = 1.;\n    float rayLength = EPSILON * 2.0;\n    data.ID = -1;\n    \n    // march the ray\n    while (data.steps < MAX_STEPS) {\n        dist = sceneSDF(rayOrigin + rayDirection * rayLength, data.ID);\n        rayLength += dist;\n        \n        \n        // hit\n        if (dist < EPSILON) {\n            break;\n        }\n        // render distance\n        if (rayLength > MAX_DIST) {\n            data.ID = -1;\n            break;\n        }\n        data.steps++;\n    }\n    return rayOrigin + rayDirection * rayLength;\n}\n\n// Main code execution\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // centered screen coords\n    vec2 q = (fragCoord.xy - .5 * iResolution.xy ) / iResolution.y;\n    \n    vec3 cameraPos = vec3(0, 1, 3);\n    vec3 rayPosition = vec3(0, 0, 1); // ray origin\n\n    // ray direction for fragCoord.xy... what is this code lol\n    vec3 rayDirection = normalize(vec3(q, 0.) - rayPosition);\n    \n    // default background color\n    vec3 color = shade(vec3(0), rayDirection, vec3(0), -1);\n\n    rayPosition += cameraPos;\n    float dist, rayLength = 1.;\n    RaycastData data = RaycastData(0, -1);\n    \n    // raycast from camera\n    rayPosition = raycast(rayPosition, rayDirection, data);\n    vec3 normal = calcNormal(rayPosition);\n\n    color = shade(rayPosition, rayDirection, normal, data.ID);\n\n    // reflect!\n    if (REFLECTIONS && data.ID != -1 && materials[data.ID].mirror > 0.0) {\n        float mirror = materials[data.ID].mirror;\n\n        // raycast reflection\n        rayDirection = reflect(rayDirection, normal);\n        rayPosition = raycast(rayPosition, rayDirection, data);\n        normal = calcNormal(rayPosition);\n        color = mix(color, shade(rayPosition, rayDirection, normal, data.ID), mirror);\n    }\n\n    // DEBUG: show steps\n    //color = vec3(1.0 - sqrt(float(data.steps) / (float(MAX_STEPS))));\n    \n    fragColor = vec4(color, 1);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XclGWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[444, 444, 480, 493, 1119], [1121, 1202, 1230, 1230, 1481], [1483, 1514, 1551, 1551, 1826], [1828, 1853, 1897, 1897, 2145], [2247, 2317, 2399, 2399, 2926], [2928, 2951, 3006, 3036, 4298]], "test": "untested"}
{"id": "4cXGRB", "name": "tiles-003", "author": "jorge2017a2", "description": "tiles-003", "tags": ["2d", "tiles", "mozaic"], "likes": 3, "viewed": 109, "published": 3, "date": "1703170965", "time_retrieved": "2024-07-30T17:15:18.060787", "image_code": "//por jorge2017a2\n//tiles-003\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n//21-dic_2023\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nvec3 cuadro(vec2 p, vec3 col)\n{\nvec2 pos, med,pr;\nfloat ang;\nfloat d1a,d1b,d1c, d2b,d2c;\n    \npos=vec2(-0.9,-0.4);\nmed=vec2(0.75, 0.75);\nang = 135. * PI / 180.0;\npr = Rotate(p- pos, med/2.0, ang);\nd1a = sdTriangleIsosceles(pr, med);\ncol = DrawFigSolo(vec3(0.4), col, d1a);\n\n\npos=vec2(-0.45,-0.25);\nmed=vec2(0.35, 0.35);\nang = 135. * PI / 180.0;\npr = Rotate(p- pos, med/2.0, ang);\nd1b = sdTriangleIsosceles(pr, med);\ncol = DrawFigSolo(vec3(0.95), col, d1b);\n\n\npos=vec2(-0.24,-0.15);\nmed=vec2(0.155, 0.155);\nang = 135. * PI / 180.0;\npr = Rotate(p- pos, med/2.0, ang);\nd1c = sdTriangleIsosceles(pr, med);\ncol = DrawFigSolo(vec3(0.05,0.0,0.0), col, d1c);\n\n///----------cuadro inferior\npos=vec2(0.12,-0.45);\nmed=vec2(0.75, 0.75);\nang = 315. * PI / 180.0;\npr = Rotate(p- pos, med/2.0, ang);\nfloat d2a = sdTriangleIsosceles(pr, med);\ncol = DrawFigSolo(vec3(0.98), col, d2a);\n\npos=vec2(0.05,-0.25);\nmed=vec2(0.35, 0.35);\nang = 315. * PI / 180.0;\npr = Rotate(p- pos, med/2.0, ang);\nd2b = sdTriangleIsosceles(pr, med);\ncol = DrawFigSolo(vec3(0.05), col, d2b);\n\n\npos=vec2(0.0,-0.16);\nmed=vec2(0.15, 0.15);\nang = 315. * PI / 180.0;\npr = Rotate(p- pos, med/2.0, ang);\nd2c = sdTriangleIsosceles(pr, med);\ncol = DrawFigSolo(vec3(0.95), col, d2c);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv*=vec2(4.0,5.0+2.0*sin(iTime));\n    vec2 iuv=floor(uv);\n    vec2 fuv=fract(uv)-0.5;\n    uv=fuv;\n    vec2 p=fuv;\n    vec3 col=vec3(1.0);\n    col=cuadro(p,col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4cXGRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[296, 296, 358, 358, 488], [490, 490, 552, 552, 617], [620, 636, 684, 684, 762], [765, 765, 816, 816, 1124], [1126, 1126, 1157, 1157, 2376], [2378, 2378, 2435, 2435, 2736]], "test": "untested"}
{"id": "lfs3DM", "name": "3D SDF outlined", "author": "rubioh", "description": "raymarching, shading, contour", "tags": ["raymarching", "shading", "contour"], "likes": 9, "viewed": 251, "published": 3, "date": "1703157721", "time_retrieved": "2024-07-30T17:15:18.828733", "image_code": "#define R iResolution\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/R.xy;\n    // Very cheap antialiasing pass 2 \n    vec3 res = texture(iChannel0, uv- vec2(.5)/R.xy).rgb;\n    fragColor = vec4(res, .0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere(vec3 p, float r )\n{\n  return length(p) - r;\n}\nmat2 rotate2d(float a){\n    \n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat ssub( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n", "buffer_a_code": "#define tz iTime*.3\n#define tr iTime*4.1\n#define tf iTime*3.\n#define th iTime\n\nfloat map_finger(vec3 p)\n{\n  float d = 1e10;\n    \n  \n  float[4] amp = float[4](1.,1.1,.9,.8);\n  float SF = .1;  \n  float size_f = .21;\n  int i = 0;\n  vec3 q = p;\n  q.xz *= rotate2d(.3*float(i));\n  vec3 S0 = vec3(.7,-.1,.4)*amp[i], \n  S1 = vec3(.9,0.,.8)*amp[i] + vec3(.0, .05*cos(tf*.95 - .4 + 1.), .0),\n  S2 = vec3(1., -.1, 1.2)*amp[i] + vec3(.0, .1+.2*cos(tf*.95 - .2 + 1.), .0),\n  S3 = vec3(1.,-.3,1.6)*amp[i] + vec3(.0, .1*cos(tf*.95 - .0 + 1.), .0);\n  float df = sdCapsule(q, S0, S1, size_f);\n  df = smin(df, sdCapsule(q, S1, S2, size_f), SF);\n  df = smin(df, sdCapsule(q, S2, S3, size_f), SF);\n  d = smin(d, df, .1);\n  \n  \n  i = 1;\n  q = p;\n  q.xz += vec2(+.6,-.2);\n  S0 = vec3(.8,.2,.4)*amp[i], \n  S1 = vec3(.9,.3,.8)*amp[i]+ vec3(.0, .05*cos(tf - .4), .0),\n  S2 = vec3(1., .2, 1.2)*amp[i]+ vec3(.0, .1+.2*cos(tf - .2), .0),\n  S3 = vec3(1.1,.0,1.6)*amp[i] + vec3(.0, .1*cos(tf), .0);\n\n  df = sdCapsule(q, S0, S1, size_f);\n  df = smin(df, sdCapsule(q, S1, S2, size_f), SF);\n  df = smin(df, sdCapsule(q, S2, S3, size_f), SF);\n  d = smin(d, df, .05);\n    \n    \n  i = 2;\n  q = p;\n  q.xz += vec2(+1.,-.3);\n  S0 = vec3(.9,-.1,.4)*amp[i], \n  S1 = vec3(.9,0.,.8)*amp[i]+ vec3(.0, .05*cos(tf*1.15 - .4 + 2.), .0),\n  S2 = vec3(1., -.1, 1.2)*amp[i]+ vec3(.0, .1+.2*cos(tf*1.15 - .4 + 2.), .0),\n  S3 = vec3(1.2,-.3,1.6)*amp[i]+ vec3(.0, .1*cos(tf*1.15 - .4 + 2.), .0);\n\n  df = sdCapsule(q, S0, S1, size_f);\n  df = smin(df, sdCapsule(q, S1, S2, size_f), SF);\n  df = smin(df, sdCapsule(q, S2, S3, size_f), SF);\n  d = smin(d, df, .05);\n  \n  \n  \n  i = 2;\n  q = p;\n  q.xyz += vec3(+1.5, .5, -.2);\n  S0 = vec3(.9,-.1,.4)*amp[i], \n  S1 = vec3(.9,-.1,.8)*amp[i]+ vec3(.05*cos(tf*1.05 - .0 + 2.), .0, .0),\n  S2 = vec3(1., -.2, 1.2)*amp[i]+ vec3(-.05+.1*cos(tf*1.05 - .2 + 2.), .0, .0),\n  S3 = vec3(1.2,-.35,1.6)*amp[i]+ vec3(.1*cos(tf*1.05 - .4 + 2.), .0, .0);\n\n  df = sdCapsule(q, S0, S1, size_f);\n  df = smin(df, sdCapsule(q, S1, S2, size_f), SF);\n  df = smin(df, sdCapsule(q, S2, S3, size_f), SF);\n  d = smin(d, df, .05);\n \n  \n  \n  q = p;\n  q.x += .1;\n  q.y += .5;\n  q.z -= .25;\n  S0 = vec3(-.3,-.8,.4)*amp[i], \n  S1 = vec3(-.3,-1.,.8)*amp[i]+ vec3(.05*cos(tf*.85 - .2), .0, .0),\n  S2 = vec3(.0, -1.2, 1.2)*amp[i]+ vec3(.1*cos(tf*.85 - .4), .3, .0),\n\n  df = sdCapsule(q, S0, S1, size_f);\n  df = smin(df, sdCapsule(q, S1, S2, size_f), SF);\n  d = smin(d, df, .05);  \n  return d;\n}\n\n\nfloat map(vec3 p, inout float df, inout float dp){\n\n    float d = 1e10;\n    \n    \n    vec3 q = p-vec3(.0,.55+.05*cos(th), 1.);\n    d = sdSphere(q, .45);\n\n    q = p-vec3(.0,-.45-.05*cos(th), 1.);\n    d = opSmoothUnion(d, sdSphere(q, .5), 1.);\n    \n    float dH = 10.;\n    \n    d = min(d, dH);\n    \n    \n    float scale = 2.+cos(tz);\n    q = p*scale;\n    q.z *= -1.;\n    q.z += 1.5;\n    q.x = abs(q.x);\n    q.x -= 2.;\n    q.xy *= rotate2d(-1.25 + .75*cos(tr*.1));\n    df = map_finger(q)/scale;\n    dp = d;\n    d = min(d,df);\n    \n\n    return d;\n}\n#define PI 3.14159\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    \n    vec3 ro = vec3(.0, .0, -3.);\n    vec3 rd = normalize(vec3(uv, 1.));\n\n    int i = 0;\n    float d = .0;\n    float depth = .0;\n    float dmin = 100.;\n    float edge = .0;\n    float edge_p = .0;\n    float d_p = .0;\n    float d_f = 100.;\n    float d_ef = .0;\n    float d_ep = .0;\n    for (; i<60; i++){\n        vec3 p = ro + rd*depth;\n        d = map(p, d_f, d_p);\n        depth += d*.5;\n        dmin = min(abs(d), dmin);\n        if (d<.001 || depth>5.) break;\n        if (d_f<.06 - .04*cos(tz)) {edge = 1.; d_ef = depth;}\n        if (d_p<.04){edge_p = 1.; d_ep = depth;}\n    }\n    float edge_finger = (d_f<.001 && i<60) ? .0:edge;\n    edge_p = (d_p<.001) ? .0: edge_p;\n    edge = max(edge_finger, edge_p);\n    d_ef = max(d_ef, d_ep);\n    fragColor = vec4(edge, d_ef, d, depth);\n}", "buffer_a_inputs": [], "buffer_b_code": "#define th iTime\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nvec3 palette(float t){\n    vec3 a = vec3(0.204,0.396,0.643);\n    vec3 b = vec3(0.361,0.208,0.400);\n    vec3 c = vec3(1., 1., 1.);\n    vec3 d = vec3(0.961,0.475,0.000)*.1;\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 uvE = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;\n    // Very cheap antialiasing pass 1\n    vec4 res = texture(iChannel0, uv+vec2(.5)/iResolution.xy).rgba;\n    float eye = sdBox(uvE*5.+vec2(-.3,-1.35-.1*cos(th)), vec2(.01,.08 + .02*cos(th) ));\n    eye = min(eye, sdBox(uvE*5.+vec2(.3,-1.35-.1*cos(th)), vec2(.01,.08+ .02*cos(th) )));\n    eye = smoothstep(.02, .0, eye-.05);\n    vec3 col = pow(palette(res.y*.4-iTime)*.8+.2, vec3(2.))*res.x;\n    fragColor = vec4(col+eye*palette(res.x*.4-iTime),1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lfs3DM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 79, 239]], "test": "untested"}
{"id": "MflGDM", "name": "SAMSA - Fragment I", "author": "Kris_Katur", "description": "Samsa unveils a dance of geometry, where distinct bodies seamlessly merge, creating a fluid-like sculpture in permanent flux. This metamorphosis perpetually evolves, as if on a quest to discover its ultimate and absolute form.", "tags": ["raymarching", "normal", "morph", "fresnel", "bool", "cineshader", "samsa"], "likes": 27, "viewed": 1057, "published": 3, "date": "1703155625", "time_retrieved": "2024-07-30T17:15:19.601668", "image_code": "/* \"Samsa - Fragment I\"\n    2023\n    by KÎTUR\n    License - Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Unported License.\n\n    \n    Fragment I   - https://www.shadertoy.com/view/MflGDM\n    Fragment II  - https://www.shadertoy.com/view/XX2SRR\n    Fragment III - https://www.shadertoy.com/view/XX2SWR\n    Fragment IV  - https://www.shadertoy.com/view/4XBSRK\n    \n    https://lichterloh.tv/portfolio/samsa/\n    \n//========================================================//\n\n               â§â¨â§â¨â§â¨â§â¨â§â¨â§â¨â§â¨â§ââ¨â§â§â¨â§â¨â§â¨â§â¨â§â¨â§â¨â§\n               âââââÂ¬âââââÂ¬ââÂ¬Â¬Â¬ââÂ¬âââââÂ¬âââââ\n               âÂ¬Â¬Â¬Â¬Â¬ââÂ¬Â¬âÂ¬âââÂ¬âââÂ¬âÂ¬Â¬Â¬Â¬Â¬ââÂ¬Â¬â\n               âââââÂ¬âââ â âÂ¬âÂ¬Â¬âÂ¬Â¬âÂ¬âââââÂ¬âââ â â\n               Â¬Â¬Â¬Â¬âÂ¬ââÂ¬Â¬âÂ¬âÂ¬Â¬Â¬Â¬Â¬âÂ¬Â¬Â¬Â¬Â¬âÂ¬ââÂ¬Â¬â\n               âââââÂ¬ââÂ¬Â¬âÂ¬âÂ¬Â¬Â¬Â¬Â¬âÂ¬âââââÂ¬ââÂ¬Â¬â\n               â¨â§â¨â§â¨â§â¨â§â¨â§â¨â§â¨â§â¨ââ§â¨â¨â§â¨â§â¨â§â¨â§â¨â§â¨â§â¨\n\n        An exploration of light and form, continuously\n          adapting on a quest to find equilibrium.\n\n             Motivated by the uncluttered yet\n                 intricate beauty of math.\n\n//========================================================//\n\nCHOOSE FROM DIFFERENT STYLES HERE\n\nSHADE 0 = NORMALS\nSHADE 1 = BLACK & WHITE (stolen from FabriceNeyret2s comment:)\n*/    \n\n#define SHADE 0\n\nfloat SDF(vec3 p){\n    \n    float t = iTime*.5;\n    t += sin(iTime*.7)*.3+.5;\n    float iter = 16.;\n        \n    // TORUS\n    float tor = 1e9;\n    for(float i=min(t,0.);i<iter;i++){\n        vec3 pt = p;\n        float j = i-iter*.5;\n        float s = sin(t+i)*.2+.7;\n        pt.x += sin(t*.15+i*1.3)*3.;\n        pt.y += sin(t*.52+i*1.2);\n        pt.z += sin(t*.32+i*1.1)*2.;\n        pt.xz *= Rot(t*.59-i);\n        pt.xy *= Rot(t*.62+i);\n        pt.yz *= Rot(t*.47-i);\n        tor = Smin(tor,Torus(pt,vec2(s,s*.2)),.8);\n    }\n    \n    // SPHERE\n    float sph = 1e9;\n    for(float i=min(t,0.);i<iter*.5;i++){\n        vec3 ps = p;\n        ps.x += sin(t*.33+i*1.1)*3.;\n        ps.y += sin(t*.21+i*1.4);\n        ps.z -= sin(t*.27+i*1.5);\n        sph = Smin(sph,Sphere(ps,1.),1.);\n        sph += (cos(t*.13+i-ps.x*2.)+sin(t*.13-i+ps.y*2.)+sin(t*.15+i+ps.z*2.))*.1;\n    }\n    \n    // GYROID\n    vec3  pg = p;\n    float sg = 1.3;\n    float gyr = abs(dot(sin(pg*sg), cos(pg.zxy*sg)))/sg-.6;\n    \n    // COMPOSITION               // == Boolsche Operation ==\n    float d = Smax(sph,-tor,1.); // Subtraction:::Sdf = Sphere NOT Torus\n    d = Smin(d,tor+.02,.1);      // Union:::::::::Sdf OR smaller Torus\n    gyr = Smax(gyr,d-.1,.2);     // Intersection::Gyroid AND bigger Sdf\n    d = min(d,gyr);              // Union:::::::::Gyroid OR Sdf\n        \n    return d;\n}\n\nfloat March(vec3 ro, vec3 rd){\n    float h=0.;\n    for(int i=0;i<MAX_STEPS; i++){\n        vec3 p = ro + rd*h;\n        float dS = SDF(p);\n        h += dS;\n        if(h>MAX_DIST||abs(dS)<SURF_DIST) break;\n    }\n    return h;\n}\n\nvec3 CalcNormal (vec3 p){\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ ){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*SDF(p+.001*e);\n    }\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime*.5;\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,0,7),\n         rd = CastRay(uv, ro, vec3(0), 2.),\n         col = vec3(0);\n    float d = March(ro, rd);\n    \n    if(d<MAX_DIST){ \n        vec3 p = ro + rd*d,\n             n = CalcNormal(p);\n             n.xz *= Rot(sin(t)*.5);\n        float fresnel = pow(1.+dot(rd, n),2.);\n        col = vec3(fresnel)*(n.y*.5+.5);\n        col += n*.5+.5;\n        \n    }\n    \n    col = mix( col, vec3(1), 1.-exp(-pow(.12*d,6.)));//fog    \n    col = pow(col, vec3(.4545)); //gamma correction\n\n\n    fragColor = vec4(col,1.0);\n\n#if SHADE == 1\n    fragColor = vec4(length(col)/1.8);//thanks to https://www.shadertoy.com/user/FabriceNeyret2\n#endif\n}", "image_inputs": [{"id": 35567, "src": "https://soundcloud.com/richarddjames/1a1?in=richarddjames/sets/selected-ambient-works-6&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "/* \"Samsa - Fragment I\"\n    2023\n    by KÎTUR\n    License - Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Unported License.\n    \n    \n    Fragment I   - https://www.shadertoy.com/view/MflGDM\n    Fragment II  - https://www.shadertoy.com/view/XX2SRR\n    Fragment III - https://www.shadertoy.com/view/XX2SWR\n    Fragment IV  - https://www.shadertoy.com/view/4XBSRK\n    \n    https://lichterloh.tv/portfolio/samsa/\n    \n//========================================================//\n\n               â§â¨â§â¨â§â¨â§â¨â§â¨â§â¨â§â¨â§ââ¨â§â§â¨â§â¨â§â¨â§â¨â§â¨â§â¨â§\n               âââââÂ¬âââââÂ¬ââÂ¬Â¬Â¬ââÂ¬âââââÂ¬âââââ\n               âÂ¬Â¬Â¬Â¬Â¬ââÂ¬Â¬âÂ¬âââÂ¬âââÂ¬âÂ¬Â¬Â¬Â¬Â¬ââÂ¬Â¬â\n               âââââÂ¬âââ â âÂ¬âÂ¬Â¬âÂ¬Â¬âÂ¬âââââÂ¬âââ â â\n               Â¬Â¬Â¬Â¬âÂ¬ââÂ¬Â¬âÂ¬âÂ¬Â¬Â¬Â¬Â¬âÂ¬Â¬Â¬Â¬Â¬âÂ¬ââÂ¬Â¬â\n               âââââÂ¬ââÂ¬Â¬âÂ¬âÂ¬Â¬Â¬Â¬Â¬âÂ¬âââââÂ¬ââÂ¬Â¬â\n               â¨â§â¨â§â¨â§â¨â§â¨â§â¨â§â¨â§â¨ââ§â¨â¨â§â¨â§â¨â§â¨â§â¨â§â¨â§â¨\n\n        An exploration of light and form, continuously\n          adapting on a quest to find equilibrium.\n\n             Motivated by the uncluttered yet\n                 intricate beauty of math.\n\n//========================================================*/\n\n#define MAX_STEPS 100\n#define MAX_DIST 20.\n#define SURF_DIST .001\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);}\n\n//===================================================================//\n// below by https://iquilezles.org/\n\nfloat Smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat Smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat Sphere(vec3 p,float s){\n    return length(p)-s;\n    }\n\nfloat Torus( vec3 p, vec2 t){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n    }\n\nfloat Box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// above by https://iquilezles.org/\n//===================================================================//\n\nvec3 CastRay(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MflGDM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1598, 1598, 1616, 1616, 2949], [2951, 2951, 2981, 2981, 3175], [3177, 3177, 3202, 3300, 3502], [3504, 3504, 3561, 3561, 4292]], "test": "untested"}
{"id": "MfsGWM", "name": "Basic Circular Blur", "author": "FinnishGameFan", "description": "A basic circular blur based on box blur. Sadly it's fairly expensive.\nYou're free to use this in anything you want, no need to credit me.", "tags": ["postprocessing", "blur"], "likes": 1, "viewed": 232, "published": 3, "date": "1703151085", "time_retrieved": "2024-07-30T17:15:20.372606", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //This value modifies the size of the blur\n   \n    float blur = 5.0;\n    \n    vec3 color = vec3(0.0);\n\n    for (float i = -blur; i <= blur; i++) {\n        for (float j = -blur; j <= blur; j++) {\n            float distance = sqrt(i * i + j * j);\n            float weight = smoothstep(blur, blur - 1.0, distance);\n            color += texture(iChannel0, (fragCoord + vec2(i, j)) / iResolution.xy).rgb * weight;\n        }\n    }\n    \n    color /= pow(blur, 2.6-(blur/100.0)); //Change this if there are problems with the brightness\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MfsGWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 102, 623]], "test": "untested"}
{"id": "4fX3D8", "name": "Alligator Noise +Octaves +Tiling", "author": "gehtsiegarnixan", "description": "This demo features Alligator noise with bubbly texture resembling alligator skin. Enhanced with octaves and tiling for versatility, this algorithm originates from Side Effects. ", "tags": ["3d", "fractal", "voronoi", "noise", "volume", "random", "tiling", "procedual", "octave", "alligator", "persistance", "lacunarity"], "likes": 5, "viewed": 381, "published": 3, "date": "1703148175", "time_retrieved": "2024-07-30T17:15:21.137560", "image_code": "/*\nThis shader showcases Alligator noise, resembling the distinctive pattern \nfound on the skin of an alligator. It is particularly well-suited as detail \nnoise for volumetric clouds but can be applied in various scenarios. \n\nThe shader offers several controls: the mouse's x-axis adjusts the height in \nthis 3D noise, while the y-axis controls the zoom. Additional settings can \nbe found in the global parameters below the header.\n\nThis shader is an adaptation of the original Alligator Noise shader from \nSide Effects Software's Houdini Development Kit. The original copyright \nnotice from Side Effects Software has been preserved below.\n\nThe original source code is available on the Side Effects website:\nhttps://www.sidefx.com/docs/hdk/alligator_2alligator_8_c-example.html\n\nAdditional reading material: \n\nSebastian Lague explains Voronoi Noise, which works similar to Alligator noise:\nhttps://youtu.be/4QOcCGI6xOU?si=nadKunwxoVDgCWD6&t=56\n\nCatlike Coding has a nice guide on Fractal and Tiling Noise:\nhttps://catlikecoding.com/unity/tutorials/pseudorandom-noise/noise-variants/\n\n____________________________________________________________________________\nCopyright (c) 2023\n    Side Effects Software Inc.  All rights reserved.\n    Adapted for GLSL by GehtSieGarNixAn in 2023\n\nRedistribution and use of Houdini Development Kit samples in source and\nbinary forms, with or without modification, are permitted provided that the\nfollowing conditions are met:\n1. Redistributions of source code must retain the above copyright notice,\n   this list of conditions and the following disclaimer.\n2. The name of Side Effects Software may not be used to endorse or\n   promote products derived from this software without specific prior\n   written permission.\n\nTHIS SOFTWARE IS PROVIDED BY SIDE EFFECTS SOFTWARE `AS IS' AND ANY EXPRESS\nOR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\nOF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN\nNO EVENT SHALL SIDE EFFECTS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\nOR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\nEVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nAlligator Noise is provided by Side Effects Software Inc. and is licensed\nunder a Creative Commons Attribution-ShareAlike 4.0 International License.\n*/\n\n// Size of the noise cells, value range 1-inf\n#define GRIDSIZE 8.0\n\n// Number of noise Layers, value range 1-inf\n#define OCTAVES 5\n\n// Scaling of successive octaves, value range 1-inf\n#define LACUNARITY 2.0\n\n// Amplitude reduction of each successive octave, value range 0-1\n#define PERSISTENCE 0.5\n\n// Enable repeating Tiling.\n#define TILING\n\n// Add lines for the grid outlines\n#define SHOWGRID\n\n// Simplified Smoothstep https://www.desmos.com/calculator/un0o21eokv\nfloat smoothValue(float x) {\n    x = clamp(x, 0.0, 1.0);\n    return x * x * (3.0 - 2.0 * x);\n}\n\n// Alligator Noise, originally from Side Effects:\n// https://www.sidefx.com/docs/hdk/alligator_2alligator_8_c-example.html\nfloat alligator(vec3 position, uint gridsize, uvec3 seed) {\n    // scale the position\n    position *= float(gridsize);\n    \n    vec3 id = floor(position); // Integer coordinates\n    vec3 grid = position - id; // Fractional coordinates\n    \n    // Initialize results\n    float densest;\n    float secondDensest;\n    \n    // compare to 3x3x3 neighbor cells\n    for (int ix = -1; ix <= 1; ++ix) {\n        for (int iy = -1; iy <= 1; ++iy) {\n            for (int iz = -1; iz <= 1; ++iz) {\n            \n                // Offset to the neighbor cell\n                vec3 offset = vec3(ix, iy, iz);\n            \n                // Current Cell coordinates\n                vec3 cell = id + offset;\n                \n                #ifdef TILING\n                    // makes the noise repeat at pos 0-1\n                    cell = mod(cell, float(gridsize));\n                #endif\n                                \n                // Modify the result with some Offset\n                // This hash doesn't like 0 so plus 1\n                cell += vec3(seed);\n                \n                // Get random center of the Cell\n                vec3 center = hash33(cell) + offset;\n                \n                // Distance from center\n                float dist = distance(grid, center);\n\n                // 'if(dist < 1.0)' doesn't have any effect and doesn't improve\n                // performance. See: https://www.shadertoy.com/view/MflGWM\n\n                // Get random density scaled by the distance to the random point          \n                float density = hash13(cell) * smoothValue(1.0 - dist);\n              \n                // find largest values\n                if (densest < density) {\n                    // move previous highest to second place\n                    secondDensest = densest;\n                    // update highest to current height\n                    densest = density;\n\n                } else if (secondDensest < density) {\n                    // update second highest to current height\n                    secondDensest = density;\n                }\n            }\n        }\n    }\n    // Subtract two largest density values for the result\n    return densest - secondDensest;\n}\n\n// Alligator noise with Octaves\nfloat alligator(vec3 position, float gridsize, \n                int octaves, float lacunarity, float persistence) {\n    \n    // Initialize the constants    \n    // For Amplitude math see: https://www.desmos.com/calculator/xgqeepapwn\n    float amplitude = 1.0;\n    float amplitudeSum = 0.0;\n    float result = 0.0;\n    uvec3 seed = uvec3(421); // can be any positive integer\n    \n    // For each Octave\n    for(int i = 0; i < octaves; ++i) {\n        // sample noise and apply amplitude\n        result += alligator(position, uint(gridsize), seed) * amplitude;\n        \n        // add up amplitude to normalize result later\n        amplitudeSum += amplitude;\n        \n        // increase frequency for the next octave\n        gridsize *= lacunarity;\n        \n        // decrease amplitude for the next octave\n        amplitude *= persistence; \n        \n        // change seed/offset noise so it is unique for the next octave\n        seed += uvec3(gridsize);\n    }\n    \n    // normalize the result to 0-1 range\n    result /= amplitudeSum;\n\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Square UVs with (0.5,0.5) in the center\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y + 0.5; \n    \n    // If the mouse was not clicked, animate\n    float height;\n    float zoom;\n    if (iMouse.x > 0.0) {\n        // scale mouse coords to 0-1 range of screen\n        vec2 mouse = iMouse.xy / iResolution.xy;\n    \n        // Mouse controls zoom with steps\n        float zoomsteps = 15.0;\n        zoom = mix(1.75, 0.1, pow(floor(mouse.y * zoomsteps) / zoomsteps, 0.5));\n    \n        // Mouse controls the height of the noise slice\n        height = mix(-0.1, 1.1, mouse.x);\n    } else {\n        // Animated zoom\n        float zoomTime = iTime * 0.1;\n        zoom = mix(1.1, 0.5, -cos(zoomTime) * 0.5 + 0.5);\n    \n        // Animated height of the noise slice\n        height = iTime * 0.01;\n    } \n    \n    // Apply zoom on coordinates (0.5,0.5) point\n    uv = (uv - 0.5) * zoom + 0.5;\n    \n    // Generate position from UV and height\n    vec3 position = vec3(uv, height);\n    \n    // Sample alligator noise\n    float noise = alligator(position, GRIDSIZE, OCTAVES, LACUNARITY, PERSISTENCE);\n    \n    #if OCTAVES != 1\n        // Aristic increase of the gamma, so the noise is not so dark\n        noise = clamp(noise *1.5,0.,1.);\n        noise = pow(noise, 0.7);\n    #endif\n    \n    // Apply colormap for better readability\n    vec3 color = viridis(noise);\n\n    #ifdef SHOWGRID\n        // Add lines on the edges of the grid\n        float thickness = 0.01;\n        vec3 grid = abs(fract(position) * 2.0 - 1.0);\n        color *= smoothstep(thickness*0.1, thickness, 1.-max(grid.x, grid.y));  \n    #endif\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "\n//_____________________GENERIC FUNCTIONS______________________________\n\n// makes viridis colormap with polynimal 6\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n//_____________________HASH FUNCTIONS_________________________________\n// These are particularly fast hash functions, but any hash should work fine \n\n// my reworked version of Dave_Hoskins https://www.shadertoy.com/view/XdGfRR\n#define FPRIME 1317666547U\n#define VPRIME uvec3(3480082861U, 2420690917U, 2149110343U)\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nfloat hash13(vec3 p) {\n\tuvec3 q = uvec3(ivec3(p)) * VPRIME;\n\tuint n = (q.x & q.y ^ q.z) * FPRIME;\n\treturn float(n) * SMALLESTFLOAT;\n}\n\n// 3 in 3 out hash from \n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\nvec3 hash33(vec3 p) {\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fX3D8.jpg", "access": "api", "license": "bsd-source-code", "functions": [[3027, 3097, 3125, 3125, 3191], [3193, 3316, 3375, 3401, 5515], [5517, 5549, 5664, 5781, 6605], [6607, 6607, 6662, 6709, 8343]], "test": "untested"}
{"id": "4cs3W7", "name": "BouncyButt", "author": "Delincoter", "description": "Inspired by the animation of YouTube anchor \"Cas van de Pol\" :)\nPS: Have anyone can tell me how to change the timbre?", "tags": ["2d"], "likes": 5, "viewed": 244, "published": 3, "date": "1703147041", "time_retrieved": "2024-07-30T17:15:21.997262", "image_code": "/////////\"sdRoundBox\"function cited from: https://www.shadertoy.com/view/4llXD7\n\n#define PI 3.14159265359\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r ) \n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdPygal(vec2 p, float b, float t)\n{\n   return sdRoundBox(p+vec2(0., sin(t)*0.1), vec2(0.4, 0.3)+b, vec4(0.2)+b);\n}\n\nfloat sdButt(vec2 p, float b, float t)\n{\n   return sdRoundBox(p-vec2(0.3+sin(t)*0.1,cos(t)*0.1), vec2(0.3-cos(t+PI*0.5)*0.05, 0.3-sin(t)*0.05)+b, vec4(0.1)+b*0.3);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float t = iTime*10.;\n\n    float dP = sdPygal(uv, 0., t);\n    \n    float dB = sdButt(vec2(abs(uv.x), uv.y), 0., t);\n    \n    float outLine = smoothstep(0., -0.01, min(dP, dB)); \n    \n    float sB = smoothstep(0., 0.01, dB);\n    float buttLine = smoothstep(0., -0.01, dB); \n    \n    float dL = sdButt(vec2(abs(uv.x-0.125),uv.y)+vec2(0.,-0.15), -0.2, t);\n    dL = smoothstep(0.01,0.,dL)*0.5;\n    \n    \n    float l = 1.-mix(buttLine, 1., sB);\n    \n    vec3 c = mix(vec3(.8,0.5,0.1), mix(vec3(0.,0.25,0.3)+dL, vec3(0.), l), outLine);\n\n    fragColor = vec4(c,1.);\n}", "image_inputs": [], "sound_code": "#define PI 3.14159265359*0.5\n\nvec2 mainSound( int samp, float time )\n{\n    float t = fract(time * PI + PI);\n    \n    vec2 s = vec2(sin(6.2831*100.0*t)*exp(-3.0*t) )*0.3;\n    s += sin(6.2831*200.0*t)*exp(-3.0*t)*0.3;\n    s += sin(6.2831*300.0*t)*exp(-3.0*t)*0.2;\n    s += sin(6.2831*400.0*t)*exp(-3.0*t)*0.1;\n    s += sin(6.2831*500.0*t)*exp(-3.0*t)*0.03;\n    s += sin(6.2831*800.0*t)*exp(-3.0*t)*0.004;\n    \n    return s;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4cs3W7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 161, 161, 318], [320, 320, 361, 361, 440], [442, 442, 482, 482, 607], [608, 608, 663, 663, 1332]], "test": "untested"}
{"id": "XcsGW7", "name": "all the rays we cannot see", "author": "elenzil", "description": "1. heat map (off)\n2. shadows (on)\n3. reflections (on)\n4. diffuse (on)\n5. ambient (on)\n6. render IOR (off)", "tags": ["refraction", "optics"], "likes": 13, "viewed": 256, "published": 3, "date": "1703143520", "time_retrieved": "2024-07-30T17:15:22.947720", "image_code": "// Fork of \"draft: more glass 2\" by elenzil. https://shadertoy.com/view/Xcf3RH\n// 2023-12-21 07:18:41\n\n\n\n\n/*\n\nKeyboard (iChannel3)\n--------------------\n1. heat map\n2. shadows\n3. reflections\n4. diffuse\n5. ambient\n6. render IOR\n\n*/\n\nconst float gZoom       = 0.8;\nconst float gFOVZoom    = 3.0;\n      float gT;         // set in main\n      vec3  gDebugRGB   = v0;\n      \n//--------------------------------------------------------------------------\n// ray handling parameters\n\n// maximum number of rays per pixel.\n// reflections, shadows, and transmission all spawn a ray,\n// and a single ray travels until it hits a boundary.\nconst uint  gMaxRays        = 20u;\n\n// standard marching parameters\nconst uint  gMaxMarchSteps  = 120u;\nconst float gMarchEps       = 0.001;\nconst float gNormEps        = gMarchEps * 5e-1;\nconst float gMarchMaxDist   = 6e1;\nconst float gMarchUnderstep = 0.9;\n\n// cleans up a little bit of sparklies.\nconst float gHitBackoff     = gMarchEps * 4.0;\n\n// smallest contribution before extinguishing a ray\nconst float gMinAmt         = 0.01;\n\n// heat map stuff\n      float gMapCount       = 0.0;\nconst float cHeatMapSteps   = 130.0;\nconst float cHeatMapRays    = 15.0;\n\n// ambient!\nconst vec3  gAmbient        = v1 * 0.02;\n      \n// FIFO queue of rays. see Common tab.\n#define Q_TYPE ray_t\n#define Q_MAX_ENTRIES (gMaxRays)\nQ_IMPLEMENTATION\n\n\n//---------------------------------------------------------\n#define renderSegmentsMax (26u)\n#if (renderSegmentsMax % 2u != 0u) || (renderSegmentsMax < 1u)\n#error renderSegmentsMax must be even and positive\n#endif\nuint renderSegmentCount = 0u;\nvec4 renderSegments[renderSegmentsMax];\nbool gIncludeRenderRays = false;\n\nMST sdRenderRays(in vec3 p) {\n    float d = 1e9;\n    \n    for (uint n = 0u; n < renderSegmentCount; n += 2u) {\n        float amt = renderSegments[n + 0u].w;\n        amt = pow(amt, 0.25);\n        float segD = sdCapsule(p,\n                        renderSegments[n + 0u].xyz,\n                        renderSegments[n + 1u].xyz,\n                        0.2 * amt);\n        d = min(d, segD);\n                        \n    }\n        \n    return MST(d, 4u);\n}\n\n\n//--------------------------------------------------------------------------\n// Scene Setup\nvec3  gSceneCenter;\nfloat gFloorGap;\nvec3  gLightDir;\nmat2  gObjRot1;\n\nvoid setupScene() {\n    gSceneCenter = vY * 5.0;\n    gFloorGap    = gMarchEps * 3.0;\n    gLightDir    = normalize(vec3(1.0, 1.5, 1.9));\n    gObjRot1     = rot2(gT * 0.2);\n}\n\nMST sdScene(vec3 p) {\n    MST ms = MST(1e9, 0u);\n\n    if (p.y < 0.0) {\n        return ms;\n    }\n\n    gMapCount += 1.0;\n    \n    \n    vec3 q = p - (gSceneCenter + gFloorGap);\n        \n    float h   = gSceneCenter.y;\n    float r   = h * 0.05;\n    float b   = h * 0.2 - r;\n    vec3  rod = vec3(b, b, h + 2.0 * b);\n    \n    if (true || !gIncludeRenderRays) {\n    opUnion   (ms, MST(sdBox(q, (h - r) * v1           ) - r, 2u));\n//    opSub     (ms,     sdBox(q.zyx, rod) - r);\n//    q.xy = abs(q.xy) - h + 4.0 * r + b;\n//    q.xy *= gObjRot1;\n//    opSubUnion(ms, MST(sdBox(q, rod) - r, 3u));\n       q.xz *= gObjRot1;\n    opSub(ms.dist, sdBox(q, h * 0.5 * v1) - r * 3.0);\n    }\n    \n    if (gIncludeRenderRays) {\n        opSubUnion(ms, sdRenderRays(p));\n    }\n    \n    return ms;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normalScene(vec3 p) {\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+e*gNormEps).dist;\n    }\n    return normalize(n);\n}\n\n\nvec3 albedo(hit_t hit) {\n    switch(hit.ms.mtl) {\n        case 1u: return v1 * 0.3;\n        case 2u: return 0.0 * (vX + vY);\n        case 3u: return 0.0 * (vec3(0.3, 0.7, 0.8));\n        case 4u: return v1 * 8.0;\n        default: return (vX + vZ) * 1e9;\n    }\n}\n\n\nfloat ior(MST ms) {\n    if (ms.dist > 0.0) {\n        return 1.0;\n    }\n    \n    switch(ms.mtl) {\n        case 1u: return 1.0;\n        case 2u: return 1.2;\n        case 3u: return 1.2;\n        case 4u: return 1.0;\n        default: return 1e9;\n    }\n}\n\n\n//---------------------------------------------------------------------\n// keyboard stuff\n\nconst float cPipScale = 0.45;\n\nbool kPipOn       = false;      // heat map.          1\nbool kShadows     = true;       // shadows.           2\nbool kReflections = true;       // reflections.       3\nbool kDiffuse     = true;       // diffuse.           4\nbool kAmbient     = true;       // ambient.           5\nbool kRenderIOR   = true;\n\nvoid readKeyboard() {\n    const int ZRO = 48;\n    kPipOn        =  KEY_TOGGLED(ZRO + 1, iChannel3);\n    kShadows      = !KEY_TOGGLED(ZRO + 2, iChannel3);\n    kReflections  = !KEY_TOGGLED(ZRO + 3, iChannel3);\n    kDiffuse      = !KEY_TOGGLED(ZRO + 4, iChannel3);\n    kAmbient      = !KEY_TOGGLED(ZRO + 5, iChannel3);\n    kRenderIOR    =  KEY_TOGGLED(ZRO + 6, iChannel3);    \n}\n\n\n//--------------------------------------------------------------------------\n\nvec3 sky(ray_t ray) {\n\n    vec3 c = v1 * (1.0 - (0.2 + 0.8 * saturate(ray.rd.y)));\n    c.r *= 0.2;\n    c.g *= 0.4;\n    \n    float d = dot(ray.rd, gLightDir) * 0.5 + 0.5;\n    \n    c = mix(c, v1, sqr(sqr(sqr(d))) * 0.85);\n    \n    float dddd = d * d;\n    dddd *= dddd;\n    c *= mix(sin(dddd * dddd * 30.0 + gT) * 0.5 + 0.5, 1.0, 1.0 - dddd * 0.1);\n    \n    float a = atan(ray.rd.z, ray.rd.x);\n    \n    c = mix(c, v1 * (1.0 - sqrt(d)), 0.3 * smoothstep(0.06 + (1.0 - d) * 0.02 * cos(a * 23.0), 0.0, abs(ray.rd.y)));\n    return c;\n}\n\n//--------------------------------------------------------------------------\n\nvoid rayVsFloor(ray_t ray, inout hit_t hit) {\n    float t = rayVsPlane(ray.ro, ray.rd, vY, 0.0);\n    if (t > 0.0 && (!hit.hit || t < hit.t)) {\n        hit.t   = t;\n        hit.hit = true;\n        hit.pnt = ray.ro + ray.rd * t;\n        hit.of_nrm = vY;\n        hit.hf_nrm = hit.of_nrm * -sign(dot(hit.of_nrm, ray.rd));\n        hit.ms  = MST(0.0, 1u);\n    }\n}\n\nvoid rayMarch(ray_t ray, inout hit_t hit) {\n\n    float t = 0.0;\n    \n    MST ms;\n    uint n;\n    vec3 p;\n    for (n = 0u; n < gMaxMarchSteps; ++n) {\n    \n        // if our hit already has a hit\n        // and our t is not closer than it, return.\n        if (hit.hit && t >= hit.t) {\n            return;\n        }\n    \n        // sample the map\n        p        = ray.ro + ray.rd * t;        \n        ms       = sdScene(p);\n        float d  = abs(ms.dist);\n\n        if (d < gMarchEps) {\n            // close to a surface!\n            // mark it the hit & return\n            hit.hit    = true;\n            hit.t      = t;\n            hit.pnt    = p;\n            hit.of_nrm = normalScene(p - ray.rd * gHitBackoff);\n            hit.hf_nrm = hit.of_nrm * -sign(dot(hit.of_nrm, ray.rd));\n            hit.ms     = ms;\n            return;\n        }\n        \n        // advance\n        t += d * gMarchUnderstep;\n        \n        // if we're just too far away, return.\n        if (dot(p, p) > (gMarchMaxDist * gMarchMaxDist)) {\n            return;\n        }\n    }\n    \n    if (t < 1e4) {\n        // ran out of steps.\n        hit.hit = true;\n        hit.t   = t;\n        hit.pnt = p;\n        hit.of_nrm = normalScene(p - ray.rd * gHitBackoff);\n        hit.hf_nrm = hit.of_nrm * -sign(dot(hit.of_nrm, ray.rd));\n        hit.ms  = ms;        \n    }\n}\n\nhit_t rayVsScene(ray_t ray) {\n    hit_t hit;\n    hit.hit = false;\n    \n    rayVsFloor(ray, hit);\n    rayMarch  (ray, hit);\n    \n    return hit;\n}\n\nvoid tryAddRenderRay(ray_t ray, hit_t hit) {\n    if (gIncludeRenderRays) {\n        return;\n    }\n    if (ray.isLightingRay) {\n       return;\n    }\n    if (renderSegmentCount > renderSegmentsMax - 2u) {\n        return;\n    }\n    vec3 endPoint;\n    if (hit.hit) {\n        endPoint = hit.pnt;\n    }\n    else {\n        endPoint = ray.ro + ray.rd * 1e2;\n    }\n    renderSegments[renderSegmentCount + 0u] = vec4(ray.ro , ray.amt);\n    renderSegments[renderSegmentCount + 1u] = vec4(endPoint, 0.0);\n    renderSegmentCount += 2u;\n}\n\n\n// run a single ray.\n// if it hits the sky, contribute sky.\n// if it hits external surfaces, fire a ray to the light.\n// if it's a \"light ray\", and it doesn't get blocked, contribute to the scene.\nvec3 runRay(ray_t ray) {\n    hit_t hit = rayVsScene(ray);\n\n    tryAddRenderRay(ray, hit);\n\n    if (ray.isLightingRay) {\n        if (!hit.hit) {\n            return ray.amt;\n        }\n        return v0;\n    }\n    \n    if (!hit.hit) {\n        return ray.amt * sky(ray);\n    }\n    \n    // transmission part 1.\n    // sample the scene on either side of the surface,\n    // so we can get the ratio of indices of refraction.\n    const float matSampOff = gMarchEps * 2.0;\n    MST   msA = sdScene(hit.pnt + hit.hf_nrm * matSampOff);\n    MST   msB = sdScene(hit.pnt - hit.hf_nrm * matSampOff);\n    bool  totalInternal = false;\n    float eta = ior(msA) / ior(msB);\n    if (gIncludeRenderRays && !kRenderIOR) {\n        eta = 1.0;\n    }\n\n    vec3  rfr = refract(ray.rd, hit.hf_nrm, eta);\n    if (dot(rfr, rfr) == 0.0) {\n        // total internal.\n        totalInternal = true;\n    }\n    \n    \n    vec3  reflAmt;\n    if (totalInternal) {\n        reflAmt = v1;\n    }\n    else {\n        // fake fresnel\n        vec3  reflMin = v1 * 0.05;\n        vec3  reflMax = v1 * 0.95;\n        float fakeFres = 1.0 + dot(ray.rd, hit.hf_nrm);\n        reflAmt = mix(reflMin, reflMax, sqr(fakeFres));\n        if (gIncludeRenderRays && !kRenderIOR) {\n            reflAmt = v0;\n        }\n    }\n    vec3  tmp;\n    tmp = reflAmt * ray.amt;\n    if (kReflections && vmax(tmp) > gMinAmt && !QIsFull()) {\n        ray_t reflectRay;\n        reflectRay.amt = tmp;\n        reflectRay.ro = hit.pnt + hit.hf_nrm * gMarchEps * 2.0;\n        reflectRay.rd = reflect(ray.rd, hit.hf_nrm);\n        reflectRay.isLightingRay = false;\n        reflectRay.isRenderRay   = ray.isRenderRay;\n        QEnqueue(reflectRay);\n    }\n    \n    vec3 diffAmt = 1.0 - reflAmt;\n    \n    // only used for 'no shadows' mode.\n    vec3 shadowlessAmt = v0;\n    \n    // enqueue lighting ray\n    // but only if we're in the open air.\n    if (kDiffuse && hit.ms.dist >= 0.0 && !QIsFull()) {\n        vec3 legitFactors = diffAmt * max(0.0, dot(hit.of_nrm, gLightDir));\n        tmp = albedo(hit) * ray.amt * legitFactors;\n        tmp *= 1.0 - gAmbient;\n        if (vmax(tmp) > gMinAmt) {\n            ray_t lightingRay;\n            lightingRay.amt = tmp;\n            lightingRay.ro = hit.pnt + hit.of_nrm * gMarchEps * 2.0;\n            lightingRay.rd = gLightDir;\n            lightingRay.isLightingRay = true;\n            lightingRay.isRenderRay   = ray.isRenderRay;\n            if (kShadows) {\n                QEnqueue(lightingRay);\n            }\n            else {\n              shadowlessAmt = lightingRay.amt;\n            }\n        }\n    }\n\n\n    // transmission part 2\n    vec3 trnAmt = ray.amt * 0.4; // sssssssss\n    if (hit.ms.mtl == 4u) {\n        trnAmt = v0;\n    }\n    if (!totalInternal && !QIsFull() && vmax(trnAmt) > gMinAmt) {\n        ray_t transmissionRay;\n        transmissionRay.amt = trnAmt;\n        transmissionRay.ro = hit.pnt - hit.hf_nrm * matSampOff;\n        transmissionRay.rd = rfr;\n        transmissionRay.isLightingRay = false;\n        transmissionRay.isRenderRay   = ray.isRenderRay;\n        if (true) {\n            QEnqueue(transmissionRay);\n        }\n    }\n    \n    \n    vec3 ambient;\n    if (kAmbient) {\n        ambient = albedo(hit) * gAmbient;\n    }\n    else {\n        ambient = v0;\n    }\n    \n    return ray.amt * (shadowlessAmt + ambient);\n}\n\nvoid runRenderRays() {\n    uint rayCount = 0u;\n    bool keepGoing = true;\n    gIncludeRenderRays = false;\n    while (keepGoing) {\n        keepGoing = keepGoing && !QIsEmpty();\n        keepGoing = keepGoing && rayCount < gMaxRays;\n        keepGoing = keepGoing && renderSegmentCount < renderSegmentsMax;\n        if (!keepGoing) {\n            break;\n        }\n        ray_t ray = QDequeue();\n        runRay(ray);\n        rayCount += 1u;\n    }\n}\n\nvec3 runRays() {\n\n    vec3 rgb = v0;\n    \n    uint rayCount = 0u;\n    \n    gIncludeRenderRays = true;\n\n\n    while (!QIsEmpty() && rayCount < gMaxRays) {\n        rgb += runRay(QDequeue());\n        rayCount += 1u;\n    }\n    \n    return rgb;\n}\n\n//--------------------------------------------------------------------------\n\nray_t getCameraRay(vec2 xy) {\n    ray_t ret;\n    \n    vec3 lookFrom = vec3(0.0, 2.0, 14.0) * 2.0;\n    float rX      = 0.0;\n    float rY      = 0.0;\n    if (length(MS) > 50.0) {\n        rX = (MS.x / RES.x * 2.0 - 1.0) * pi * -1.2;\n        rY = (1.0 - MS.y / RES.y) * pi * 0.45;\n    }\n    \n    lookFrom.yz  *= rot2(rY);\n    lookFrom.xz  *= rot2(rX);\n    lookFrom.y    = max(0.1, lookFrom.y);\n         \n    vec3 lookTo   = gSceneCenter;\n    \n    vec3 camFw    = normalize(lookTo - lookFrom);\n    vec3 camRt    = normalize(cross(camFw, vY));\n    vec3 camUp    = cross(camRt, camFw);\n    \n    ret.ro            = lookFrom;\n    ret.rd            = normalize(camFw + (xy.x * camRt + xy.y * camUp) / gFOVZoom);\n    ret.amt           = v1;\n    ret.isLightingRay = false;\n        \n    return ret;\n}\n      \n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    readKeyboard();\n    \n    // modify XY for picture-in-picture\n    bool isPip = kPipOn && (XY.x < RES.x * cPipScale && XY.y < RES.y * cPipScale);\n    if (isPip) {\n        XY /= cPipScale;\n    }\n\n    gT      = iTime;\n    vec2 xy = VIEWFROMSCREEN(XY);\n    \n    setupScene();\n    \n    ray_t renderRay;\n    renderRay.ro  = vec3(9.0, 8.0 + 8.0 * sin(gT * 0.356), 0.0) * 1.3;\n    renderRay.ro.xz *= rot2(gT * 0.2);\n    \n    renderRay.rd  = normalize(gSceneCenter + vX * gSceneCenter.y * 0.9 - renderRay.ro);\n    renderRay.amt = v1;\n    renderRay.isLightingRay = false;\n    renderRay.isRenderRay   = true;\n    QEnqueue(renderRay);\n    \n    runRenderRays();\n    \n    QClear();\n    QEnqueue(getCameraRay(xy));\n\n    vec3 c  = runRays();\n\n    c      *= 1.0 - pow(LENGTHSQR(XY/RES - 0.5) * 1.8, 3.0);\n    c       = pow(c, vec3(1.0 / 2.2));\n    c      *= 1.0;\n    c      += gDebugRGB;\n    \n    if (isPip) {\n        const vec3 cCool = vec3(0.0, 0.0, 0.2);\n        const vec3 cHot  = vec3(1.0, 0.9, 0.2);\n        float temp = gMapCount / float(cHeatMapSteps * cHeatMapRays);\n        c = mix(cCool, cHot, pow(temp, 0.6));\n    }\n    \n    RGBA    = vec4(c, 1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const vec2  v01 = vec2(0.0, 1.0);\nconst vec3  vX  = v01.yxx;\nconst vec3  vY  = v01.xyx;\nconst vec3  vZ  = v01.xxy;\nconst vec3  v0  = v01.xxx;\nconst vec3  v1  = v01.yyy;\nconst float pi  = 3.14159265359;\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n#define MS     (iMouse.xy)\n#define ZERO   (min(iFrame,0))\n\n#define VIEWFROMSCREEN_DIST(distance)                     \\\n        ( (distance) / MINRES / gZoom                     )\n#define VIEWFROMSCREEN(xy)                                \\\n        ( vec2(VIEWFROMSCREEN_DIST((xy).x * 2.0 - RES.x), \\\n               VIEWFROMSCREEN_DIST((xy).y * 2.0 - RES.y)) )\n               \n#define LENGTHSQR(a) ( dot((a), (a)) )\n#define saturate(v) ( clamp((v), 0.0, 1.0) )\n#define sqr(a) ( (a) * (a) )\n\nmat2 rot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nfloat vmax(vec2 A) { return max(    A.x, A.y); }\nfloat vmax(vec3 A) { return max(max(A.x, A.y), A.z); }\nfloat vmin(vec2 A) { return min(    A.x, A.y); }\nfloat vmin(vec3 A) { return min(min(A.x, A.y), A.z); }\n\n//--------------------------------------------------------------------------\n// keyboard conveniences\n//\n#define KEY_IS_DOWN(key, chan) (texelFetch(chan, ivec2(key, 0), 0).r > 0.0)\n#define KEY_TOGGLED(key, chan) (texelFetch(chan, ivec2(key, 2), 0).r > 0.0)\n\n\n//--------------------------------------------------------------------------\n// ray stuff\n//\nstruct ray_t {\n    vec3  ro;\n    vec3  rd;\n    vec3  amt;   // [0, 1] amount of light left in the ray\n    bool  isLightingRay;\n    bool  isRenderRay;\n};\n\nstruct mapSample_t {\n    float dist;\n    uint  mtl;\n};\n#define MST mapSample_t\n\nstruct hit_t {\n    bool  hit;\n    float t;\n    vec3  pnt;\n    vec3  hf_nrm;\n    vec3  of_nrm;\n    MST   ms;\n};\n\n//--------------------------------------------------------------------------\n\n// fifo queue.\n// This is a basic ringbuffer.\n// NO ERROR CHECKING\n//\n// usage:\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENTATION.\n// (Q_MAX_ENTRIES is a uint)\n//\n// for example:\n// #define Q_TYPE        ray_t\n// #define Q_MAX_ENTRIES 16u\n// Q_IMPLEMENTATION\n//\n// orion elenzil 2022.\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIES;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nvoid QClear() {                                    \\\n    gQHead = gQTail = 0u;                          \\\n}                                                  \\\n                                                   \\\nuint QCount() {                                    \\\n    if (gQHead >= gQTail) {                        \\\n        return gQHead - gQTail;                    \\\n    }                                              \\\n    else {                                         \\\n        return gQNumSlots - (gQTail - gQHead);     \\\n    }                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n    return gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n    return QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n    return QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint _QEnqueueIndex() {                            \\\n    gQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint _QDequeueIndex() {                            \\\n    gQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n    gQ[_QEnqueueIndex()] = item;                   \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n    return gQ[_QDequeueIndex()];                   \\\n}\n\n//--------------------------------------------------------------------------------\n\nvoid opUnion(inout MST A, MST B) {\n    if (A.dist > B.dist) {\n        A = B;\n    }\n}\n\nvoid opSub(inout float d1, in float d2) {\n    d1 = max(d1, -d2);\n}\n\nvoid opSub(inout MST ms1, in float d2) {\n    opSub(ms1.dist, d2);\n}\n\nvoid opSubUnion(inout float d1, in float d2) {\n    opSub(d1, d2);\n    d1 = min(d1, d2);\n}\n\n\nvoid opSubUnion(inout MST ms1, in MST ms2) {\n    opSub(ms1.dist, ms2.dist);\n    opUnion(ms1, ms2);\n}\n\n//--------------------------------------------------------------------------------\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nfloat rayVsPlane(in vec3 ro, in vec3 rd, in vec3 n, in float d) {\n    float t = -(dot(ro, n) + d) / (dot(rd, n));\n    return t;\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XcsGW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1677, 1677, 1706, 1706, 2128], [2294, 2294, 2313, 2313, 2466], [2468, 2468, 2489, 2489, 3244], [3246, 3292, 3318, 3318, 3526], [3529, 3529, 3553, 3553, 3789], [3792, 3792, 3811, 3811, 4041], [4473, 4473, 4494, 4494, 4848], [4929, 4929, 4950, 4950, 5457], [5537, 5537, 5582, 5582, 5894], [5896, 5896, 5939, 5939, 7232], [7234, 7234, 7263, 7263, 7379], [7381, 7381, 7425, 7425, 7904], [7907, 8104, 8128, 8128, 11396], [11398, 11398, 11420, 11420, 11840], [11842, 11842, 11858, 11858, 12082], [12162, 12162, 12191, 12191, 12950], [12959, 12959, 13002, 13002, 14151]], "test": "untested"}
{"id": "4fs3DM", "name": "POSTHELIOS - Akkma - Osinni", "author": "POSTHELIOS", "description": "What you get when you screw with hexagons for too long. Scrub time with the mouse. Watch fullscreen!", "tags": ["psychedelic", "hexagon", "trippy", "dmt"], "likes": 8, "viewed": 296, "published": 3, "date": "1703140947", "time_retrieved": "2024-07-30T17:15:23.790467", "image_code": "// Hexagone by Martijn Steinrucken aka BigWings - 2019\n// countfrolic@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// This started as an idea to do the effect below, but with hexagons:\n// https://www.shadertoy.com/view/wdlGRM\n//\n// Turns out that really doesn't look very nice so I just made it\n// into a dance party instead ;)\n//\n// Music: https://soundcloud.com/buku/front-to-back\n\n\n#define R3 1.732051\n\nvec4 HexCoords(vec2 uv) {\n    vec2 s = vec2(1, R3);\n    vec2 h = .5*s;\n\n    vec2 gv = s*uv;\n    \n    vec2 a = mod(gv, s)-h;\n    vec2 b = mod(gv+h, s)-h;\n    \n    vec2 ab = dot(a,a)<dot(b,b) ? a : b;\n    vec2 st = ab;\n    vec2 id = gv-ab;\n    \n   // ab = abs(ab);\n    //st.x = .5-max(dot(ab, normalize(s)), ab.x);\n\tst = ab;\n    return vec4(st, id);\n}\n\nfloat GetSize(vec2 id, float seed) {\n    float d = length(id);\n    float t = iTime*.5;\n    float a = sin(d*seed+t)+sin(d*seed*seed*10.+t*2.);\n    return a/2. +.5;\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    \n    //float s = tan(a);\n    //float c = atan(a);\n    \n  //  s = tan(a);\n  //  c = tan(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hexagon(vec2 uv, float r, vec2 offs) {\n    \n    uv *= Rot(mix(0., 3.1415, r));\n    \n    r /= 1./sqrt(2.);\n    uv = vec2(-uv.y, uv.x);\n    uv.x *= R3;\n    uv = abs(uv);\n    \n    vec2 n = normalize(vec2(1,1));\n    float d = dot(uv, n)-r;\n    d = max(d, uv.y-r*.707);\n    \n    d = smoothstep(.06, .02, abs(d));\n    \n    d += smoothstep(.1, .09, abs(r-.5))*sin(iTime);\n    return d;\n}\n\nfloat Xor(float a, float b) {\n\t//return a+b;\n    return a*(1.-b) + b*(1.-a);\n}\n\nfloat Layer(vec2 uv, float s) {\n    vec4 hu = HexCoords(uv*2.);\n\n    float d = Hexagon(hu.xy, GetSize(hu.zw, s), vec2(0));\n    vec2 offs = vec2(1,0);\n    d = Xor(d, Hexagon(hu.xy-offs, GetSize(hu.zw+offs, s), offs));\n    d = Xor(d, Hexagon(hu.xy+offs, GetSize(hu.zw-offs, s), -offs));\n    \n    offs = vec2(.5,.8725);\n    d = Xor(d, Hexagon(hu.xy-offs, GetSize(hu.zw+offs, s), offs));\n    d = Xor(d, Hexagon(hu.xy+offs, GetSize(hu.zw-offs, s), -offs));\n    \n    offs = vec2(-.5,.8725);\n    d = Xor(d, Hexagon(hu.xy-offs, GetSize(hu.zw+offs, s), offs));\n    d = Xor(d, Hexagon(hu.xy+offs, GetSize(hu.zw-offs, s), -offs));\n    \n    return d;\n}\n\nfloat N(float p) {\n    return fract(sin(p*123.34)*cos(345.456));\n}\n\nvec3 Col(float p, float offs) {\n    float n = N(cos(p))*1.34;\n    \n //   return sin(p*vec3(123.11,173.23,75.2)+offs*3.)*1.2;\n    \n    return cos(n*vec3(12.23,45.23,56.2)+offs*3.)*.5+.5;\n    \n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 lookat, float zoom) {\n    vec3 f = normalize(lookat-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f, r),\n        c = p+f*zoom,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 UV = fragCoord.xy/iResolution.xy-.5;\n    float duv= dot(UV, UV);\n    vec2 m = iMouse.xy/iResolution.xy-.5;\n    \n    float t = iTime*.2+m.x*10.+5.;\n    \n    float y = sin(t*.5);//+sin(1.5*t)/3.;\n    vec3 ro = vec3(0, 20.*y, -5);\n    vec3 lookat = vec3(0,0,-10);\n    vec3 rd = GetRayDir(uv, ro, lookat, 1.);\n    \n    vec3 col = vec3(0.5);\n    \n    vec3 p = ro+rd*(ro.y/rd.y);\n    float dp = length(p.xz);\n    \n    if((ro.y/rd.y)>0.)\n    \tcol *= 0.05;\n    else {\n        uv = p.xz*.1;\n\n        uv *= mix(1., 5., sin(t*.5)*.5+.5);\n\n        uv *= Rot(t);\n        m *= Rot(t);\n\n        uv.x *= R3;\n        \n\n        for(float i=0.; i<1.; i+=1./3.) {\n            float id = floor(i+t);\n            float t = fract(i+t);\n            float z = mix(5., .1, t);\n            float fade = smoothstep(0., .3, t)*smoothstep(1., .7, t);\n\n            col += fade*t*Layer(uv*z, N(i+id))/Col(id,duv);\n        }\n    }\n    col *= 2.;\n    \n    if(ro.y<0.) col = 1.- cos(col);\n    \n    col *= smoothstep(18., 5., dp);\n    col *= 1.-duv*2.;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 35563, "src": "https://soundcloud.com/akkma/osinni-sutinky-va-blackout-moon-koradji-records", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fs3DM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[462, 462, 487, 487, 811], [813, 813, 849, 849, 977], [979, 979, 998, 998, 1169], [1171, 1171, 1215, 1215, 1557], [1559, 1559, 1588, 1603, 1637], [1639, 1639, 1670, 1670, 2279], [2281, 2281, 2299, 2299, 2347], [2349, 2349, 2380, 2380, 2541], [2543, 2543, 2601, 2601, 2805], [2807, 2807, 2864, 2864, 3979]], "test": "untested"}
{"id": "lff3D7", "name": "tiles-002", "author": "jorge2017a2", "description": "tiles-002", "tags": ["2d", "tiles", "mozaic"], "likes": 11, "viewed": 181, "published": 3, "date": "1703126808", "time_retrieved": "2024-07-30T17:15:24.560409", "image_code": "//por jorge2017a2\n//tiles-002\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n//20-dic_2023\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define PI     3.14159265\n///oneshade\nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nvec3 bloque(vec2 fuv,vec2 iuv, vec3 col)\n{\n    vec2 p=fuv;\n    float d1=sdBox(fuv,vec2(0.5,0.5));\n    vec3 col1=vec3(0.8,0.8,0.8);\n    col= DrawFigSolo(col1, col, d1);\n        \n    vec2 pos, med;\n    float x=mod(iuv.x+iuv.y,2.0);\n\n    if(x>0.25 )\n    {\n\n        pos=vec2(-0.5,0.0);\n        med=vec2(0.5, 0.5);\n        //rotar\n        float ang = 270. * PI / 180.0;\n        vec2 pr = Rotate(fuv- pos, med/2.0, ang);\n        float d3 = sdTriangleIsosceles(pr, med);\n        vec3 col3=vec3(0.,0.,0.);\n        col=DrawFigSolo(col3,col,d3); //triangulo\n\n        //trapecio1\n        float r1,r2,he;\n        r1=0.6;\n        r2=0.6;\n        he=0.3;\n        pos=vec2(0.0,0.25);\n        float d4= sdTrapezoid(p-pos, r1, r2, he);\n        d4=differenceSDF(d4,d3);\n        vec3 col4=vec3(0.52,0.53,0.54);//tapecio1\n        col=DrawFigSolo(col4,col,d4);//tapecio1\n        //-------------\n\n        r1=0.6;\n        r2=1.0;\n        he=0.25;\n        pos=vec2(0.0,-0.75);\n        ang = 180. * PI / 180.0;\n        pr = Rotate(p- pos, med/2.0, ang);\n        float d5= sdTrapezoid(pr, r1, r2, he);\n        d5=differenceSDF(d5,d3);\n        vec3 col5=vec3(1.,0.98,0.96);;\n        col=DrawFigSolo(col5,col,d5);//tapecio2\n\n    }\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = fragCoord/iResolution.xy;\n    float t=iTime*0.5;\n    uv*=vec2(7.0+2.0*sin(t),4.0+2.0*sin(t+5.0*cos(t)));\n    vec2 iuv=floor(uv);\n    vec2 fuv=fract(uv)-0.5;\n    vec3 col = vec3(0.0);\n    col=bloque(fuv,iuv,col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lff3D7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 254, 302, 302, 380], [382, 382, 429, 429, 456], [457, 457, 500, 500, 527], [528, 528, 576, 576, 604], [606, 606, 668, 668, 733], [735, 735, 772, 772, 846], [848, 848, 873, 873, 892], [893, 893, 918, 918, 937], [938, 938, 974, 974, 1002], [1004, 1004, 1069, 1069, 1379], [1381, 1381, 1432, 1432, 1740], [1742, 1742, 1784, 1784, 2961], [2963, 2963, 3020, 3020, 3277]], "test": "untested"}
{"id": "lff3W7", "name": "Fakemarching [148 Chars]", "author": "SnoopethDuckDuck", "description": "i guess its just layers with feedback but it feels more 3d than it should", "tags": ["25d", "magic", "golf"], "likes": 16, "viewed": 239, "published": 3, "date": "1703123889", "time_retrieved": "2024-07-30T17:15:25.321374", "image_code": "void mainImage( out vec4 o, vec2 u )\n{    \n    u = (u+u-(o.xy=iResolution.xy))/o.y/3.;    \n    //u.y += .5*cos(.2*iTime); u.x += .3*iTime;\n    o *= 0.;\n    for (float i; ++i < 40.; ) \n        o += exp(\n             //cos(i + vec4(2,1,7,0))\n             -4.*length(1.3+2.*cos(i*u-8.*o.b+iTime))\n                );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lff3W7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 314]], "test": "untested"}
{"id": "4fX3D7", "name": "Orb Audio Lines", "author": "Peace", "description": "Orb Audio Lines", "tags": ["lines", "colorful", "audio", "glow", "orb"], "likes": 3, "viewed": 192, "published": 3, "date": "1703108975", "time_retrieved": "2024-07-30T17:15:26.189054", "image_code": "const float TAU = 6.2831;\n\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n}\n\nvec2 rand(vec2 p)\n{\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn 2.0*fract(sin(p)*43758.5453123) - 1.0;\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 i = floor(p + (p.x+p.y)*0.366025404);\n    vec2 a = p - i + (i.x+i.y)*0.211324865;\n    float m = step(a.y,a.x); \n    vec2 o = vec2(m,1.0-m);\n    vec2 b = a - o + 0.211324865;\n\tvec2 c = a - 1.0 + 2.0*0.211324865;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0);\n\tvec3 n = h*h*h*h*vec3( dot(a,rand(i+0.0)), dot(b,rand(i+o)), dot(c,rand(i+1.0)));\n    return dot(n, vec3(70))*.5+.5;\n}\n\nvec2 rot2D(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvec4 orb(vec2 uv, float t, float min_res) {\n    float l = dot(uv, uv);\n    l *= l * l * l;\n    vec3 n = normalize(vec3(uv, sqrt(abs(1.0 - l))));\n    float f = 48.0 / min_res;\n    float mask = smoothstep(1.0, 1.0 - f, l);\n    float alpha = pow(l, 0.2) * mask;\n    vec4 col = vec4(mix(vec3(0.1, 0.0, 0.5), vec3(0.4, 0, 0.5), min(1.0, dot(n, vec3(.5, .5, -.1)) + l)), alpha);\n    col.rgb += smoothstep(0., 1., noise(rot2D(n.xy, -t * 0.5) / (1.0 + n.z * n.z * n.z) + t)) * vec3(.4, .2, .7);\n    col.rgb += smoothstep(.2, .9, noise(rot2D(n.xy, t) * 2. / (1.0 + n.z * n.z * n.z) - t)) * smoothstep(0.2, 0.0, l) * vec3(.2, .1, .5);\n    float fresnel = mask * (luma(col.rgb) + 0.5) * pow(l, 4.0);\n    col.rgb += fresnel;\n    col.a += col.a * fresnel;\n    float s = smoothstep(1., -1.0, noise(vec2(-t) + n.z * 3. + noise(noise(n.xy) * 4. + \n        normalize(rot2D(n.xy, t)) * (0.9 + length(n.xy) * 1.5) * 4. + t) * .2));\n    col = vec4(mix(col.rgb - vec3(0.2, .3, .6) * s, col.rgb, s), col.a / (1.0 + 1. * s));\n    float d = 1.0 / (0.1 + pow(length(uv) - 1.0, 2.));\n    col.a += (1.0 - mask) * d * 0.1;\n    return col;\n}\n\nvec4 lines(vec2 uv, float t) {\n    t *= 0.6;\n    vec4 col = vec4(0);\n    vec2 nv = normalize(uv);\n    float d = 1.0 + noise(nv + t) * .2;\n    \n    float mask = smoothstep(0.05, 0.0, distance(nv * d, uv));\n    col.rgb = mix(col.rgb, vec3(0.3, 1, 0.5) + vec3(smoothstep(0.96, 1.05, mask)), mask);\n    col.a += mask;\n\n    d = 1.0 + noise(nv + t + 85.161) * .2;\n    mask = smoothstep(0.05, 0.0, distance(nv * d, uv));\n    col.rgb = mix(col.rgb, vec3(0.2, 0.7, 1) + vec3(smoothstep(0.96, 1.05, mask)), mask);\n    col.a += mask;\n\n    d = 1.0 + noise(nv + t - 85.161) * .2;\n    mask = smoothstep(0.05, 0.0, distance(nv * d, uv));\n    col.rgb = mix(col.rgb, vec3(1, 0.2, 0.4) + vec3(smoothstep(0.94, 1.05, mask)), mask);\n    col.a += mask;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float min_res = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min_res * 1.6;\n    float t = iTime * 0.5;\n    fragColor.a = 0.0;\n\n    vec3 col = vec3(0);\n    vec4 orb = orb(uv, t, min_res);    \n    col.rgb += orb.rgb * orb.a;\n    fragColor.a += orb.a;\n\n    vec4 li = lines(uv, t);\n    col.rgb = orb.rgb * orb.a;\n    col.rgb = mix(col.rgb, li.rgb, li.a);\n    fragColor.a += li.a;\n\n    fragColor.rgb = col * fragColor.a;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fX3D7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 49, 49, 149], [151, 151, 170, 170, 282], [284, 284, 305, 305, 706], [708, 708, 737, 737, 821], [823, 823, 847, 847, 897], [899, 899, 942, 942, 2011], [2013, 2013, 2043, 2043, 2767], [2769, 2769, 2826, 2826, 3293]], "test": "untested"}
{"id": "ddVBDh", "name": "dead channel 2", "author": "lennyjpg", "description": ";alkjdfal;dkjf", "tags": ["fasldkfjalskdj"], "likes": 5, "viewed": 173, "published": 3, "date": "1703107818", "time_retrieved": "2024-07-30T17:15:26.999886", "image_code": "  #define hashi(x)   triple32(x) \n\n  #define hash(x)  ( float( hashi(x) ) / float( 0xffffffffU ) )\n\n//bias: 0.17353355999581582 ( very probably the best of its kind )\nuint lowbias32(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n# define PI 3.141592653589793\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// bias: 0.020888578919738908 = minimal theoretic limit\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 uv = U/iResolution.xy;\n    vec2 uu = U;\n   float p = (uv.y-0.2)*0.9;\n//uv.y-=sin(uv.x*3.3)*0.3;\n       uu.x+=iTime*iResolution.y*0.02/p;\n       uu.x *= uu.y*0.00035;\n    uvec2 V = uvec2(uu);\n    float h = hash( V.x + hashi(V.y) ); \n    h = floor(h+0.7*uv.y*uv.y);    \n    O = vec4( h );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddVBDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 167, 191, 191, 305], [337, 337, 357, 357, 429], [431, 487, 510, 510, 664], [666, 666, 703, 703, 1001]], "test": "untested"}
{"id": "4ff3zH", "name": "Ring of fire (2024)", "author": "orblivius", "description": "Ring of fire visualizer", "tags": ["sound", "fft", "spectrum", "music", "visualizer"], "likes": 0, "viewed": 63, "published": 3, "date": "1703106282", "time_retrieved": "2024-07-30T17:15:27.761849", "image_code": "// Trying to hack together a neat visualizer I saw a year or so ago,\n// something along those lines...\n\n// optimizations? better camera movement?\n\nconst int MAX_MARCH_STEPS = 20;\nconst float EPSILON = .001;\nconst float PI = 3.14159;\nconst float PI23 = PI * .66;\nconst float LIGHT_INTENSITY =  .8;\nconst float BASE_LIGHT = 0.7;\n\nstruct Light\n{\n    vec3 Position;\n    vec3 Color;\n};\n\n\nstruct Ray\n{\n    vec3 Origin;\n    vec3 Direction;\n};\n\nstruct Camera\n{\n    vec3 Position;\n    vec3 LookAt;\n    vec3 Up;\n};\n\nmat4 ViewMatrix(Camera camera)\n{\n    vec3 viewDir = normalize(camera.LookAt - camera.Position);\n    vec3 right = normalize(cross(viewDir, camera.Up));\n    vec3 transUp = normalize(cross(right, viewDir));\n    \n    return mat4(\n        vec4(right, 0.0),\n        vec4(transUp, 0.0),\n        vec4(-viewDir, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\n//Almost all of the SDF functions are taken directly from or adapted from:\n//https://iquilezles.org/articles/distfunctions\nfloat IntersectSDF(float distA, float distB) \n{\n    return max(distA, distB);\n}\n\nfloat UnionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat DifferenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\nfloat SphereSDF(vec3 center, float radius)\n{\n    return length(center) - radius;\n}\n\nfloat BoxSDF(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Create infinite copies of an object\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\n//A single instance of the infinitely repeated scene\nfloat RepeatedSceneSingleInstance(vec3 point)\n{\n    float finalT = 10.;\n    float i_step = 1./20.;\n    float i = -2.5;\n    for(int j=0; j<125; j++)\n    {\n        float freq = texture(iChannel0, vec2((i + 2.5) / 20.0, 0.0)).x;\n        float discFrequency = pow(floor(freq * 20.0) / 20.0, 4.0) * 4.0;\n        \n        vec3 boxPoint = vec3(5.-point.x-10.*sin(i), 5.-point.y, point.z-10.*cos(i));\n        finalT = UnionSDF(finalT, BoxSDF(boxPoint, vec3(.1, discFrequency,.1)));\n        i += i_step;\n    }\n    \n    \n    return finalT;\n}\n\n\n//The single instance scene\nfloat NormalScene(vec3 point, Light light1, Light light2, Light light3)\n{\n    vec3 lightPoint = point - light1.Position;\n    float t = SphereSDF(lightPoint, .5);\n    \n    lightPoint = point - light2.Position;\n    t = UnionSDF(t, SphereSDF(lightPoint, .5));\n    \n    lightPoint = point - light3.Position;\n    t = UnionSDF(t, SphereSDF(lightPoint, .5));\n    return t;\n}\n\n\nvec3 GetNormal(vec3 point, Light light1, Light light2, Light light3) \n{\n    vec3 normal = vec3(0,0,0);\n    \n    normal.x  = RepeatedSceneSingleInstance(vec3(point.x + EPSILON, point.y, point.z));\n    normal.x -= RepeatedSceneSingleInstance(vec3(point.x - EPSILON, point.y, point.z));\n    \n    normal.y  = RepeatedSceneSingleInstance(vec3(point.x, point.y + EPSILON, point.z));\n    normal.y -= RepeatedSceneSingleInstance(vec3(point.x, point.y - EPSILON, point.z));\n    \n    normal.z  = RepeatedSceneSingleInstance(vec3(point.x, point.y, point.z + EPSILON));\n    normal.z -= RepeatedSceneSingleInstance(vec3(point.x, point.y, point.z - EPSILON));\n\n    return normalize(normal);\n}\n\nfloat RayMarch(Ray ray, float startingTValue, float maxTValue) \n{\n    float currentT = startingTValue;\n    \n    for(int i = 0; i < MAX_MARCH_STEPS; ++i) \n    {\n        vec3 point = ray.Origin + ray.Direction * currentT;\n        \n        float closestTValue = RepeatedSceneSingleInstance(point);\n        currentT += closestTValue;\n        \n        if(closestTValue < EPSILON || closestTValue > maxTValue) \n        {\n            return currentT;\n        }\n    }\n    \n    return currentT;\n}\n\nfloat RayMarchLights(Ray ray, float startingTValue, float maxTValue, Light light1, Light light2, Light light3) \n{\n    float currentT = startingTValue;\n    \n    for(int i = 0; i < MAX_MARCH_STEPS; ++i) \n    {\n        vec3 point = ray.Origin + ray.Direction * currentT;\n        \n        float closestTValue = NormalScene(point, light1, light2, light3);\n        currentT += closestTValue;\n        \n        if(closestTValue < EPSILON || closestTValue > maxTValue) \n        {\n            return currentT;\n        }\n    }\n    \n    return currentT;\n}\n\n\nfloat Diffuse(vec3 point, vec3 normal, Light light) \n{\n    \n    vec3 lightVector = normalize(light.Position - point);\n    \n    float cosAngle = max(dot(lightVector, normal), 0.0);\n    \n    return max(cosAngle, 0.0);\n}\n\nfloat Specular(vec3 point, vec3 normal, Camera camera, Light light, float shinyNess) \n{\n    vec3 lightVector = normalize(light.Position - point);\n    lightVector = reflect(lightVector, normal);\n    vec3 viewVector = normalize(camera.Position - point);\n    \n    float cosAngle = pow(max(dot(-lightVector, viewVector), 0.0), shinyNess);\n    \n    return max(cosAngle, 0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    //Generating our ray\n    vec2 uvRay = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    \n    vec3 col = vec3(0,0,0);\n    \n    //Construct camera\n    Camera camera;\n    camera.Position = vec3(cos(iTime * .25) * 0.0, 10, sin(iTime * .25) * 20.0);\n    camera.Up = vec3(0, 1, 0);\n    camera.LookAt = vec3(10, 2, 0);\n    \n    mat4 worldToView = ViewMatrix(camera);\n    \n    vec4 worldDirection = normalize(vec4(uvRay, -1, 0));\n    vec4 viewDir = worldToView * worldDirection;\n    \n    //Get view ray\n    Ray ray;\n    ray.Origin = camera.Position;\n    ray.Direction = viewDir.xyz;\n    \n    vec4 tx = vec4(texture(iChannel0, uvRay));\n    vec3 k = 0.9*cos(tx.x*8.9)*cos(tx.x*8.9)*vec3(0.15, 0.25, 0.55) ;\n    \n    float bassFreq = texture(iChannel0, vec2((.1), 0.0)).x;\n    float medFreq = texture(iChannel0, vec2((.2), 0.0)).x;\n    medFreq += texture(iChannel0, vec2((.3), 0.0)).x;\n    medFreq += texture(iChannel0, vec2((.4), 0.0)).x;\n    medFreq = medFreq / 3.0;\n    \n    float topFreq = texture(iChannel0, vec2((.5), 0.0)).x;\n    topFreq += texture(iChannel0, vec2((.6), 0.0)).x;\n    topFreq += texture(iChannel0, vec2((.7), 0.0)).x;\n    topFreq += texture(iChannel0, vec2((.8), 0.0)).x;\n    topFreq += texture(iChannel0, vec2((.9), 0.0)).x;\n    topFreq = topFreq / 5.0f;\n    \n    vec3 lightColor = vec3(1, 0.533, 0.066);\n    \n    //Define our lights\n    Light light1;\n    light1.Position = camera.LookAt + vec3(cos(iTime * 1.0), .25, sin(iTime * 1.0)) * 10.0;\n    light1.Color = BASE_LIGHT * lightColor;\n    vec3 light1ModulatedColor = BASE_LIGHT * lightColor + lightColor * LIGHT_INTENSITY * bassFreq;\n    \n    lightColor = vec3(0.125, 0.639, 0.619);\n    Light light2;\n    light2.Position = camera.LookAt + vec3(cos(PI23 + iTime * 1.0), .25, sin(PI23 + iTime * 1.0)) * 10.0;\n    light2.Color = BASE_LIGHT * lightColor;\n    vec3 light2ModulatedColor = BASE_LIGHT * lightColor + lightColor * LIGHT_INTENSITY * medFreq;\n    \n    lightColor = vec3(0.615, 0, 1);\n    Light light3;\n    light3.Position = camera.LookAt + vec3(cos(2.0 * PI23 + iTime * 1.0), .25, sin(2.0 * PI23 + iTime * 1.0)) * 10.0;\n    light3.Color = BASE_LIGHT * lightColor;\n    vec3 light3ModulatedColor = BASE_LIGHT * lightColor + lightColor * LIGHT_INTENSITY * topFreq;\n    \n    float rayTValue = RayMarch(ray, 0.0, 100.0);\n    \n    vec3 point = ray.Origin + ray.Direction * rayTValue;\n    float closestTValue = RepeatedSceneSingleInstance(point);\n    \n    if(closestTValue < EPSILON) \n    {\n        vec3 surfaceColor = vec3(1.0f, 1.0f, 1.0f);\n        vec3 normal = GetNormal(point, light1, light2, light3);\n        col = surfaceColor * .1f;  \n         \n        col += Diffuse(point, normal, light1) * light1ModulatedColor * surfaceColor;\n            col += Specular(point, normal, camera, light1, 10.0) * light1ModulatedColor * surfaceColor;\n        col += Diffuse(point, normal, light2) * light2ModulatedColor * surfaceColor;\n          col += Specular(point, normal, camera, light2, 10.0) * light2ModulatedColor * surfaceColor;\n        col += Diffuse(point, normal, light3) * light3ModulatedColor * surfaceColor;\n        col += Specular(point, normal, camera, light3, 10.0) * light3ModulatedColor * surfaceColor;\n    }\n   //  col = clamp(pow(vec3(col*bassFreq),0.3/col), vec3(0),vec3(2));\n   \n //  col = mix(col, vec3(0,0,0), min(rayTValue / 200.0, 1.0));\n    \n    fragColor = vec4(col, rayTValue);\n}\n\n", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ff3zH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[506, 506, 538, 538, 856], [858, 981, 1028, 1028, 1060], [1062, 1062, 1105, 1105, 1137], [1139, 1139, 1187, 1187, 1220], [1222, 1222, 1266, 1266, 1304], [1306, 1306, 1336, 1336, 1423], [1425, 1464, 1499, 1499, 1550], [1552, 1605, 1652, 1652, 2136], [2139, 2167, 2240, 2240, 2534], [2537, 2537, 2608, 2608, 3215], [3217, 3217, 3282, 3282, 3704], [3706, 3706, 3819, 3819, 4249], [4252, 4252, 4306, 4306, 4469], [4471, 4471, 4558, 4558, 4843], [4846, 4846, 4902, 4927, 8283]], "test": "untested"}
{"id": "4fXGWM", "name": "DLS path tracing", "author": "FrederickAmpsUp", "description": "Thumbnail pic took 60s on my gtx 980ti\nMore scenes in the Common tab\n\nIf anyone knows how to speed up compile times for large models, let me know. Ty :)\nAlso, advice on how to fix fireflies would be appreciated", "tags": ["raytracing", "dls"], "likes": 5, "viewed": 340, "published": 3, "date": "1703102752", "time_retrieved": "2024-07-30T17:15:29.084313", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Output to screen\n    vec4 col = texture(iChannel1, uv);\n    col.xyz = flim(col.xyz, 0.0);\n    \n    fragColor = col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define N_BOUNCES 5\n#define N_SAMPLES  5 // Number of samples (at 50% variance)\n#define SAMPLE_VAR 0 // Variation in samplerate (in either direction)\n                     // This is set to 0 as, on my old GPU, it causes huge framerate drops.\n// Uncomment to disable Direct Light Sampling\n//#define NO_DLS\n\n// Uncomment the scene to display\n// Scenes marked with [lag] WILL take a long time to compile.\n// Give them up to 60s to compile before reloading\n\n// custom-made scenes\n#define SCENE_CORNELL_0 // Cornell box w/ infinite mirrors\n//#define SCENE_CORNELL_1_SUZANNE // Cornell box w/ Suzanne the Blender monkey [lag]\n//#define SCENE_CORNELL_2_TEAPOT  // Cornell box w/ that one teapot [lag]\n//#define SCENE_CORNELL_3_STANFORD // Cornell box w/ stanford bunny [lag]\n//#define MIRROR_WORLD // Infinite mirrors :)\n//#define SCENE_FURNACE // Blue furnace test\n\n// chatgpt scenes\n//#define SCENE_MYSTIC_HORIZON\n//#define SCENE_GLOWING_EMBER\n\nstruct Material {\n    vec3    color;\n    vec3 emission;\n    \n    float roughness;\n};\n\nstruct Sphere {\n    vec3  center;\n    float radius;\n    \n    Material mat;\n};\n\nstruct Triangle {\n    vec3 v1,v2,v3;\n    \n    Material mat;\n};\n\nstruct Ray {\n    vec3    origin;\n    vec3 direction;\n};\n\nstruct HitInfo {\n    bool hit;\n    \n    vec3 position;\n    vec3   normal;\n    \n    float dst;\n    \n    Material mat;\n};\n#define MISS HitInfo(false, vec3(0), vec3(0), 0.0, Material(vec3(0), vec3(0), 0.0))\n\nfloat seed;\nfloat rand(vec2 co){\n    return fract(sin(dot(co*(seed+1.0), vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat rand(vec3 co) {\n    return sqrt(rand(co.xy)*rand(co.yz));\n}\nvec3 in_unit_sphere(vec3 co) {\n    vec3 p;\n    do {\n        p = vec3(rand(co), rand(co*2.0), rand(co*3.0)) * 2.0 - 1.0;\n    } while(dot(p,p) > 1.0);\n    return p;\n}\nvec3 in_hemisphere(vec3 co, vec3 norm) {\n    vec3 unit = normalize(in_unit_sphere(co));\n    float dotValue = dot(unit, norm);\n    return unit * sign(dotValue);\n}\n// start scenes\n#ifdef SCENE_CORNELL_0\n// Cornell box scene with infinite mirrors\n\n#define LIGHT_POS vec3(0.0, 2.2, 0.0)\n#define LIGHT_RADIUS 0.5\n#define LIGHT_STRENGTH 40.0\n#define LIGHT_COLOR vec3(1.0, 1.0, 1.0)\n\n#define N_SPHERES 8\nconst Sphere SPHERES[N_SPHERES] = Sphere[](\n    Sphere(vec3(0.0, -1000.5, 0.0), 1000.0, Material(vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), 1.0)), // Ground\n    Sphere(vec3(1001.5, 0.0, 0.0), 1000.0, Material(vec3(0.0, 0.8, 0.0), vec3(0.0, 0.0, 0.0), 1.0)), // Right wall\n    Sphere(vec3(-1001.5, 0.0, 0.0), 1000.0, Material(vec3(0.8, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 1.0)), // Left wall\n    Sphere(vec3(0.0, 0.0, 1001), 1000.0, Material(vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), 0.02)), // Back wall\n    Sphere(vec3(0.0, 0.0, -1002), 1000.0, Material(vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), 0.02)), // Front wall\n    Sphere(vec3(0.0, 1002, 0.0), 1000.0, Material(vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), 1.0)), // Ceiling\n    \n    Sphere(vec3(-0.3, 0.0, 0.0), 0.5, Material(vec3(0.9, 0.9, 0.9), vec3(0.0, 0.0, 0.0), 1.0)), // White diffuse ball (to showcase GI)\n\n    Sphere(LIGHT_POS, LIGHT_RADIUS, Material(vec3(0.0, 0.0, 0.0), LIGHT_COLOR * LIGHT_STRENGTH, 1.0)) // Light sphere\n);\n\n#define N_TRIANGLES 1\nconst Triangle TRIS[N_TRIANGLES] = Triangle[](\n    Triangle(vec3(0), vec3(0), vec3(0), MISS.mat)\n);\n\n    // Doesn't matter since we're in a box\nvec3 sky_color(vec3 d) {\n    return vec3(0.0);\n}\n\n// basic camera ray\nRay camera(vec2 ndc) {\n    Ray cam; \n    cam.origin    = vec3(0.4, 0.5, -1.2);\n    cam.direction = normalize(vec3(ndc, 1.0));\n    \n    return cam;\n}\n#endif\n\n#ifdef SCENE_CORNELL_1_SUZANNE\n// Cornell box scene with Suzanne the Blender monkey\n\n#define LIGHT_POS vec3(0.0, 2.2, 0.0)\n#define LIGHT_RADIUS 0.5\n#define LIGHT_STRENGTH 40.0\n#define LIGHT_COLOR vec3(1.0, 1.0, 1.0)\n\n#define N_SPHERES 7\nconst Sphere SPHERES[N_SPHERES] = Sphere[](\n    Sphere(vec3(0.0, -1000.5, 0.0), 1000.0, Material(vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), 1.0)), // Ground\n    Sphere(vec3(1001.5, 0.0, 0.0), 1000.0, Material(vec3(0.0, 0.8, 0.0), vec3(0.0, 0.0, 0.0), 1.0)), // Right wall\n    Sphere(vec3(-1001.5, 0.0, 0.0), 1000.0, Material(vec3(0.8, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 1.0)), // Left wall\n    Sphere(vec3(0.0, 0.0, 1001), 1000.0, Material(vec3(0.0, 0.0, 0.8), vec3(0.0, 0.0, 0.0), 1.0)), // Back wall\n    Sphere(vec3(0.0, 0.0, -1002), 1000.0, Material(vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), 1.0)), // Front wall\n    Sphere(vec3(0.0, 1002, 0.0), 1000.0, Material(vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), 1.0)), // Ceiling\n\n    Sphere(LIGHT_POS, LIGHT_RADIUS, Material(vec3(0.0, 0.0, 0.0), LIGHT_COLOR * LIGHT_STRENGTH, 1.0)) // Light sphere\n);\n\n#define MESH_MAT Material(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), 1.0)\n#define N_TRIANGLES 202\nconst Triangle TRIS[N_TRIANGLES] = Triangle[](\n    Triangle(vec3(0.516567, -0.010352, -0.516567), vec3(0.516567, -1.811388, 0.516567), vec3(0.516567, -1.811388, -0.516567), MESH_MAT),Triangle(vec3(0.516567, -0.010352, 0.516567), vec3(-0.516567, -1.811388, 0.516567), vec3(0.516567, -1.811388, 0.516567), MESH_MAT),Triangle(vec3(-0.516567, -0.010352, 0.516567), vec3(-0.516567, -1.811388, -0.516567), vec3(-0.516567, -1.811388, 0.516567), MESH_MAT),Triangle(vec3(-0.516567, -0.010352, -0.516567), vec3(0.516567, -1.811388, -0.516567), vec3(-0.516567, -1.811388, -0.516567), MESH_MAT),Triangle(vec3(0.516567, -0.010352, 0.516567), vec3(-0.516567, -0.010352, -0.516567), vec3(-0.516567, -0.010352, 0.516567), MESH_MAT),Triangle(vec3(-0.233546, 0.61699, -0.384061), vec3(-0.205803, 0.527703, -0.397327), vec3(-0.316684, 0.583845, -0.283267), MESH_MAT),Triangle(vec3(0.205802, 0.527703, -0.397327), vec3(0.233309, 0.617333, -0.38407), vec3(0.316631, 0.583807, -0.283247), MESH_MAT),Triangle(vec3(-0.205803, 0.527703, -0.397327), vec3(-0.174411, 0.442847, -0.313077), vec3(-0.273438, 0.490136, -0.289062), MESH_MAT),Triangle(vec3(0.174411, 0.442847, -0.313077), vec3(0.205802, 0.527703, -0.397327), vec3(0.273437, 0.490136, -0.289063), MESH_MAT),Triangle(vec3(-0.205803, 0.527703, -0.397327), vec3(-0.121718, 0.554431, -0.404544), vec3(-0.174411, 0.442847, -0.313077), MESH_MAT),Triangle(vec3(0.121568, 0.554376, -0.404802), vec3(0.205802, 0.527703, -0.397327), vec3(0.174411, 0.442847, -0.313077), MESH_MAT),Triangle(vec3(-0.032811, 0.583529, -0.332166), vec3(-0.078125, 0.490136, -0.324219), vec3(-0.121718, 0.554431, -0.404544), MESH_MAT),Triangle(vec3(-0.121718, 0.554431, -0.404544), vec3(-0.148134, 0.645054, -0.40256), vec3(-0.032811, 0.583529, -0.332166), MESH_MAT),Triangle(vec3(0.146875, 0.644556, -0.402612), vec3(0.121568, 0.554376, -0.404802), vec3(0.033043, 0.58333, -0.331984), MESH_MAT),Triangle(vec3(0.146875, 0.644556, -0.402612), vec3(0.033043, 0.58333, -0.331984), vec3(0.078125, 0.681542, -0.324219), MESH_MAT),Triangle(vec3(0.146875, 0.644556, -0.402612), vec3(0.078125, 0.681542, -0.324219), vec3(0.175781, 0.720605, -0.308594), MESH_MAT),Triangle(vec3(-0.316684, 0.583845, -0.283267), vec3(-0.273438, 0.681542, -0.289062), vec3(-0.233546, 0.61699, -0.384061), MESH_MAT),Triangle(vec3(-0.205803, 0.527703, -0.397327), vec3(-0.148134, 0.645054, -0.40256), vec3(-0.121718, 0.554431, -0.404544), MESH_MAT),Triangle(vec3(0.121568, 0.554376, -0.404802), vec3(0.146875, 0.644556, -0.402612), vec3(0.205802, 0.527703, -0.397327), MESH_MAT),Triangle(vec3(-0.205803, 0.527703, -0.397327), vec3(-0.233546, 0.61699, -0.384061), vec3(-0.148134, 0.645054, -0.40256), MESH_MAT),Triangle(vec3(0.146875, 0.644556, -0.402612), vec3(0.233309, 0.617333, -0.38407), vec3(0.205802, 0.527703, -0.397327), MESH_MAT),Triangle(vec3(-0.111547, 0.371506, -0.26876), vec3(-0.280553, 0.421092, -0.284562), vec3(-0.04298, 0.397742, -0.402468), MESH_MAT),Triangle(vec3(0.295262, 0.433562, -0.291302), vec3(0.118886, 0.353896, -0.25372), vec3(0.045652, 0.403664, -0.396194), MESH_MAT),Triangle(vec3(-0.400736, 0.663557, -0.315983), vec3(-0.268162, 0.561394, -0.343881), vec3(-0.394926, 0.516696, -0.200264), MESH_MAT),Triangle(vec3(0.124122, 0.787203, -0.427289), vec3(0.125586, 0.8489, -0.351199), vec3(0.408331, 0.65779, -0.319708), MESH_MAT),Triangle(vec3(0.002234, 0.648687, -0.404854), vec3(-0.126488, 0.790882, -0.425327), vec3(-0.125314, 0.848878, -0.350857), MESH_MAT),Triangle(vec3(0.139154, 0.664416, -0.380804), vec3(0.002234, 0.648687, -0.404854), vec3(0.124122, 0.787203, -0.427289), MESH_MAT),Triangle(vec3(0.408331, 0.65779, -0.319708), vec3(0.139154, 0.664416, -0.380804), vec3(0.124122, 0.787203, -0.427289), MESH_MAT),Triangle(vec3(-0.04298, 0.397742, -0.402468), vec3(-0.280553, 0.421092, -0.284562), vec3(-0.111447, 0.528968, -0.378309), MESH_MAT),Triangle(vec3(-0.111447, 0.528968, -0.378309), vec3(0.109793, 0.528353, -0.3769), vec3(-0.04298, 0.397742, -0.402468), MESH_MAT),Triangle(vec3(-0.171167, -0.013261, -0.289646), vec3(0.032971, 0.030154, -0.341508), vec3(0.178364, -0.001195, -0.286764), MESH_MAT),Triangle(vec3(-0.067141, 0.341459, -0.37578), vec3(-0.047467, 0.06566, -0.351474), vec3(-0.171167, -0.013261, -0.289646), MESH_MAT),Triangle(vec3(0.0, 0.369042, -0.398438), vec3(0.0, 0.39248, -0.371094), vec3(0.0, 0.365136, -0.375), MESH_MAT),Triangle(vec3(0.0, 0.369042, -0.398438), vec3(0.0, 0.39248, -0.371094), vec3(0.045652, 0.403664, -0.396194), MESH_MAT),Triangle(vec3(-0.04298, 0.397742, -0.402468), vec3(0.001755, 0.296561, -0.381233), vec3(-0.067141, 0.341459, -0.37578), MESH_MAT),Triangle(vec3(0.001755, 0.296561, -0.381233), vec3(-0.04298, 0.397742, -0.402468), vec3(0.064127, 0.341445, -0.379544), MESH_MAT),Triangle(vec3(0.0, 0.39248, -0.371094), vec3(-0.04298, 0.397742, -0.402468), vec3(0.109793, 0.528353, -0.3769), MESH_MAT),Triangle(vec3(0.045652, 0.403664, -0.396194), vec3(0.0, 0.39248, -0.371094), vec3(0.109793, 0.528353, -0.3769), MESH_MAT),Triangle(vec3(0.032971, 0.030154, -0.341508), vec3(-0.047467, 0.06566, -0.351474), vec3(0.049287, 0.097595, -0.364454), MESH_MAT),Triangle(vec3(-0.280553, 0.421092, -0.284562), vec3(-0.268162, 0.561394, -0.343881), vec3(-0.207264, 0.497387, -0.34865), MESH_MAT),Triangle(vec3(0.271579, 0.569159, -0.341605), vec3(0.295262, 0.433562, -0.291302), vec3(0.207003, 0.506708, -0.35946), MESH_MAT),Triangle(vec3(0.139154, 0.664416, -0.380804), vec3(0.274003, 0.613714, -0.340889), vec3(0.206486, 0.657058, -0.376267), MESH_MAT),Triangle(vec3(-0.099075, 0.614842, -0.380184), vec3(-0.162208, 0.658042, -0.403412), vec3(-0.153416, 0.701143, -0.37639), MESH_MAT),Triangle(vec3(0.002234, 0.648687, -0.404854), vec3(-0.125314, 0.848878, -0.350857), vec3(0.001246, 0.678252, -0.316118), MESH_MAT),Triangle(vec3(0.125586, 0.8489, -0.351199), vec3(0.002234, 0.648687, -0.404854), vec3(0.001246, 0.678252, -0.316118), MESH_MAT),Triangle(vec3(-0.394926, 0.516696, -0.200264), vec3(-0.358732, 0.664522, -0.156321), vec3(-0.400736, 0.663557, -0.315983), MESH_MAT),Triangle(vec3(-0.000141, 0.215137, -0.153545), vec3(-0.160596, 0.007487, -0.204363), vec3(0.143389, -0.011551, -0.200413), MESH_MAT),Triangle(vec3(-0.000141, 0.215137, -0.153545), vec3(0.143389, -0.011551, -0.200413), vec3(0.107026, 0.257677, -0.170954), MESH_MAT),Triangle(vec3(-0.171167, -0.013261, -0.289646), vec3(0.143389, -0.011551, -0.200413), vec3(-0.160596, 0.007487, -0.204363), MESH_MAT),Triangle(vec3(-0.171167, -0.013261, -0.289646), vec3(-0.160596, 0.007487, -0.204363), vec3(-0.099877, 0.263675, -0.148737), MESH_MAT),Triangle(vec3(0.143389, -0.011551, -0.200413), vec3(0.178364, -0.001195, -0.286764), vec3(0.107026, 0.257677, -0.170954), MESH_MAT),Triangle(vec3(-0.160596, 0.007487, -0.204363), vec3(-0.000141, 0.215137, -0.153545), vec3(-0.099877, 0.263675, -0.148737), MESH_MAT),Triangle(vec3(-0.087285, 0.283275, 0.210542), vec3(-0.099877, 0.263675, -0.148737), vec3(-0.000141, 0.215137, -0.153545), MESH_MAT),Triangle(vec3(-0.080927, 0.675597, 0.443123), vec3(-0.385411, 0.774394, 0.171219), vec3(-0.416923, 0.638911, 0.195618), MESH_MAT),Triangle(vec3(-0.232804, 0.913283, -0.07611), vec3(-0.390749, 0.750821, -0.047924), vec3(-0.385411, 0.774394, 0.171219), MESH_MAT),Triangle(vec3(0.390749, 0.750821, -0.047924), vec3(0.238038, 0.912358, -0.064413), vec3(0.359312, 0.809934, 0.190415), MESH_MAT),Triangle(vec3(0.001246, 0.678252, -0.316118), vec3(-0.125314, 0.848878, -0.350857), vec3(-0.230119, 0.726441, -0.236319), MESH_MAT),Triangle(vec3(0.125586, 0.8489, -0.351199), vec3(0.001246, 0.678252, -0.316118), vec3(0.228729, 0.727074, -0.237354), MESH_MAT),Triangle(vec3(-0.175781, 0.720605, -0.308594), vec3(-0.233546, 0.61699, -0.384061), vec3(-0.273438, 0.681542, -0.289062), MESH_MAT),Triangle(vec3(-0.430741, 0.635244, 0.096042), vec3(-0.385411, 0.774394, 0.171219), vec3(-0.390749, 0.750821, -0.047924), MESH_MAT),Triangle(vec3(0.359312, 0.809934, 0.190415), vec3(0.425606, 0.644591, 0.095939), vec3(0.390749, 0.750821, -0.047924), MESH_MAT),Triangle(vec3(-0.385411, 0.774394, 0.171219), vec3(-0.430741, 0.635244, 0.096042), vec3(-0.416923, 0.638911, 0.195618), MESH_MAT),Triangle(vec3(-0.087285, 0.283275, 0.210542), vec3(-0.269783, 0.391343, 0.07924), vec3(-0.099877, 0.263675, -0.148737), MESH_MAT),Triangle(vec3(-0.348236, 0.431813, 0.187355), vec3(-0.080927, 0.675597, 0.443123), vec3(-0.416923, 0.638911, 0.195618), MESH_MAT),Triangle(vec3(0.385843, 0.40248, 0.161723), vec3(0.422259, 0.664239, 0.227806), vec3(0.206099, 0.385193, 0.23506), MESH_MAT),Triangle(vec3(0.422259, 0.664239, 0.227806), vec3(0.005809, 0.425213, 0.38968), vec3(0.206099, 0.385193, 0.23506), MESH_MAT),Triangle(vec3(0.572193, 0.709347, 0.176395), vec3(0.681625, 0.619507, 0.222366), vec3(0.605289, 0.621201, 0.222109), MESH_MAT),Triangle(vec3(-0.605856, 0.619805, 0.222295), vec3(-0.589788, 0.453912, 0.198183), vec3(-0.655388, 0.682794, 0.215691), MESH_MAT),Triangle(vec3(0.491707, 0.613633, 0.177227), vec3(0.572193, 0.709347, 0.176395), vec3(0.605289, 0.621201, 0.222109), MESH_MAT),Triangle(vec3(-0.269783, 0.391343, 0.07924), vec3(-0.352066, 0.423646, 0.062407), vec3(-0.394926, 0.516696, -0.200264), MESH_MAT),Triangle(vec3(-0.394926, 0.516696, -0.200264), vec3(-0.352066, 0.423646, 0.062407), vec3(-0.430741, 0.635244, 0.096042), MESH_MAT),Triangle(vec3(0.425606, 0.644591, 0.095939), vec3(0.397961, 0.51422, 0.154137), vec3(0.354444, 0.427229, 0.069641), MESH_MAT),Triangle(vec3(0.425606, 0.644591, 0.095939), vec3(0.572193, 0.709347, 0.176395), vec3(0.397961, 0.51422, 0.154137), MESH_MAT),Triangle(vec3(0.400522, 0.504134, -0.174586), vec3(0.425606, 0.644591, 0.095939), vec3(0.354444, 0.427229, 0.069641), MESH_MAT),Triangle(vec3(-0.395389, 0.515025, 0.15448), vec3(-0.492634, 0.611389, 0.179686), vec3(-0.430741, 0.635244, 0.096042), MESH_MAT),Triangle(vec3(-0.425889, 0.462587, 0.146546), vec3(-0.492634, 0.611389, 0.179686), vec3(-0.395389, 0.515025, 0.15448), MESH_MAT),Triangle(vec3(-0.571347, 0.483608, 0.229016), vec3(-0.492634, 0.611389, 0.179686), vec3(-0.425889, 0.462587, 0.146546), MESH_MAT),Triangle(vec3(0.491707, 0.613633, 0.177227), vec3(0.573507, 0.486901, 0.21894), vec3(0.424844, 0.461658, 0.147897), MESH_MAT),Triangle(vec3(-0.492634, 0.611389, 0.179686), vec3(-0.571347, 0.483608, 0.229016), vec3(-0.605856, 0.619805, 0.222295), MESH_MAT),Triangle(vec3(-0.655388, 0.682794, 0.215691), vec3(-0.613501, 0.703207, 0.276414), vec3(-0.430741, 0.635244, 0.096042), MESH_MAT),Triangle(vec3(0.425606, 0.644591, 0.095939), vec3(0.422259, 0.664239, 0.227806), vec3(0.611595, 0.707537, 0.275748), MESH_MAT),Triangle(vec3(0.626597, 0.462337, 0.231018), vec3(0.611595, 0.707537, 0.275748), vec3(0.385843, 0.40248, 0.161723), MESH_MAT),Triangle(vec3(-0.613501, 0.703207, 0.276414), vec3(-0.655388, 0.682794, 0.215691), vec3(-0.612544, 0.457862, 0.273501), MESH_MAT),Triangle(vec3(0.626597, 0.462337, 0.231018), vec3(0.681625, 0.619507, 0.222366), vec3(0.611595, 0.707537, 0.275748), MESH_MAT),Triangle(vec3(-0.269783, 0.391343, 0.07924), vec3(-0.348236, 0.431813, 0.187355), vec3(-0.352066, 0.423646, 0.062407), MESH_MAT),Triangle(vec3(-0.316684, 0.583845, -0.283267), vec3(-0.205803, 0.527703, -0.397327), vec3(-0.273438, 0.490136, -0.289062), MESH_MAT),Triangle(vec3(0.273437, 0.490136, -0.289063), vec3(0.205802, 0.527703, -0.397327), vec3(0.316631, 0.583807, -0.283247), MESH_MAT),Triangle(vec3(-0.174411, 0.442847, -0.313077), vec3(-0.121718, 0.554431, -0.404544), vec3(-0.078125, 0.490136, -0.324219), MESH_MAT),Triangle(vec3(0.078125, 0.490136, -0.324219), vec3(0.121568, 0.554376, -0.404802), vec3(0.174411, 0.442847, -0.313077), MESH_MAT),Triangle(vec3(0.033043, 0.58333, -0.331984), vec3(0.121568, 0.554376, -0.404802), vec3(0.078125, 0.490136, -0.324219), MESH_MAT),Triangle(vec3(-0.148134, 0.645054, -0.40256), vec3(-0.078125, 0.681542, -0.324219), vec3(-0.032811, 0.583529, -0.332166), MESH_MAT),Triangle(vec3(-0.148134, 0.645054, -0.40256), vec3(-0.175781, 0.720605, -0.308594), vec3(-0.078125, 0.681542, -0.324219), MESH_MAT),Triangle(vec3(0.175781, 0.720605, -0.308594), vec3(0.233309, 0.617333, -0.38407), vec3(0.146875, 0.644556, -0.402612), MESH_MAT),Triangle(vec3(0.002234, 0.648687, -0.404854), vec3(-0.153416, 0.701143, -0.37639), vec3(-0.126488, 0.790882, -0.425327), MESH_MAT),Triangle(vec3(0.316631, 0.583807, -0.283247), vec3(0.233309, 0.617333, -0.38407), vec3(0.273437, 0.681542, -0.289063), MESH_MAT),Triangle(vec3(-0.111547, 0.371506, -0.26876), vec3(-0.067141, 0.341459, -0.37578), vec3(-0.171167, -0.013261, -0.289646), MESH_MAT),Triangle(vec3(0.178364, -0.001195, -0.286764), vec3(0.064127, 0.341445, -0.379544), vec3(0.118886, 0.353896, -0.25372), MESH_MAT),Triangle(vec3(-0.280553, 0.421092, -0.284562), vec3(-0.394926, 0.516696, -0.200264), vec3(-0.268162, 0.561394, -0.343881), MESH_MAT),Triangle(vec3(0.408331, 0.65779, -0.319708), vec3(0.400522, 0.504134, -0.174586), vec3(0.295262, 0.433562, -0.291302), MESH_MAT),Triangle(vec3(-0.125314, 0.848878, -0.350857), vec3(-0.126488, 0.790882, -0.425327), vec3(-0.400736, 0.663557, -0.315983), MESH_MAT),Triangle(vec3(0.002234, 0.648687, -0.404854), vec3(0.125586, 0.8489, -0.351199), vec3(0.124122, 0.787203, -0.427289), MESH_MAT),Triangle(vec3(-0.274725, 0.614508, -0.33776), vec3(-0.126488, 0.790882, -0.425327), vec3(-0.153416, 0.701143, -0.37639), MESH_MAT),Triangle(vec3(0.408331, 0.65779, -0.319708), vec3(0.271579, 0.569159, -0.341605), vec3(0.274003, 0.613714, -0.340889), MESH_MAT),Triangle(vec3(0.408331, 0.65779, -0.319708), vec3(0.274003, 0.613714, -0.340889), vec3(0.139154, 0.664416, -0.380804), MESH_MAT),Triangle(vec3(-0.268162, 0.561394, -0.343881), vec3(-0.400736, 0.663557, -0.315983), vec3(-0.274725, 0.614508, -0.33776), MESH_MAT),Triangle(vec3(-0.111447, 0.528968, -0.378309), vec3(0.002234, 0.648687, -0.404854), vec3(0.109793, 0.528353, -0.3769), MESH_MAT),Triangle(vec3(0.045652, 0.403664, -0.396194), vec3(0.109793, 0.528353, -0.3769), vec3(0.295262, 0.433562, -0.291302), MESH_MAT),Triangle(vec3(0.002234, 0.648687, -0.404854), vec3(0.139154, 0.664416, -0.380804), vec3(0.098035, 0.610104, -0.380545), MESH_MAT),Triangle(vec3(0.064127, 0.341445, -0.379544), vec3(0.049287, 0.097595, -0.364454), vec3(0.001755, 0.296561, -0.381233), MESH_MAT),Triangle(vec3(0.109793, 0.528353, -0.3769), vec3(0.002234, 0.648687, -0.404854), vec3(0.098035, 0.610104, -0.380545), MESH_MAT),Triangle(vec3(-0.047467, 0.06566, -0.351474), vec3(0.032971, 0.030154, -0.341508), vec3(-0.171167, -0.013261, -0.289646), MESH_MAT),Triangle(vec3(0.032971, 0.030154, -0.341508), vec3(0.049287, 0.097595, -0.364454), vec3(0.178364, -0.001195, -0.286764), MESH_MAT),Triangle(vec3(-0.047467, 0.06566, -0.351474), vec3(0.001755, 0.296561, -0.381233), vec3(0.049287, 0.097595, -0.364454), MESH_MAT),Triangle(vec3(-0.230119, 0.726441, -0.236319), vec3(-0.400736, 0.663557, -0.315983), vec3(-0.358732, 0.664522, -0.156321), MESH_MAT),Triangle(vec3(0.0, 0.369042, -0.398438), vec3(-0.04298, 0.397742, -0.402468), vec3(0.0, 0.39248, -0.371094), MESH_MAT),Triangle(vec3(0.045652, 0.403664, -0.396194), vec3(-0.04298, 0.397742, -0.402468), vec3(0.0, 0.369042, -0.398438), MESH_MAT),Triangle(vec3(0.064127, 0.341445, -0.379544), vec3(-0.04298, 0.397742, -0.402468), vec3(0.045652, 0.403664, -0.396194), MESH_MAT),Triangle(vec3(-0.111547, 0.371506, -0.26876), vec3(-0.04298, 0.397742, -0.402468), vec3(-0.067141, 0.341459, -0.37578), MESH_MAT),Triangle(vec3(0.064127, 0.341445, -0.379544), vec3(0.045652, 0.403664, -0.396194), vec3(0.118886, 0.353896, -0.25372), MESH_MAT),Triangle(vec3(-0.111447, 0.528968, -0.378309), vec3(-0.280553, 0.421092, -0.284562), vec3(-0.207264, 0.497387, -0.34865), MESH_MAT),Triangle(vec3(0.207003, 0.506708, -0.35946), vec3(0.295262, 0.433562, -0.291302), vec3(0.109793, 0.528353, -0.3769), MESH_MAT),Triangle(vec3(-0.153416, 0.701143, -0.37639), vec3(-0.162208, 0.658042, -0.403412), vec3(-0.274725, 0.614508, -0.33776), MESH_MAT),Triangle(vec3(0.228729, 0.727074, -0.237354), vec3(0.408331, 0.65779, -0.319708), vec3(0.125586, 0.8489, -0.351199), MESH_MAT),Triangle(vec3(-0.087285, 0.283275, 0.210542), vec3(0.107026, 0.257677, -0.170954), vec3(0.206099, 0.385193, 0.23506), MESH_MAT),Triangle(vec3(0.400522, 0.504134, -0.174586), vec3(0.408331, 0.65779, -0.319708), vec3(0.355827, 0.663179, -0.153664), MESH_MAT),Triangle(vec3(0.118886, 0.353896, -0.25372), vec3(0.295262, 0.433562, -0.291302), vec3(0.400522, 0.504134, -0.174586), MESH_MAT),Triangle(vec3(0.143389, -0.011551, -0.200413), vec3(-0.171167, -0.013261, -0.289646), vec3(0.178364, -0.001195, -0.286764), MESH_MAT),Triangle(vec3(-0.111547, 0.371506, -0.26876), vec3(-0.171167, -0.013261, -0.289646), vec3(-0.099877, 0.263675, -0.148737), MESH_MAT),Triangle(vec3(0.107026, 0.257677, -0.170954), vec3(0.178364, -0.001195, -0.286764), vec3(0.118886, 0.353896, -0.25372), MESH_MAT),Triangle(vec3(-0.111547, 0.371506, -0.26876), vec3(-0.394926, 0.516696, -0.200264), vec3(-0.280553, 0.421092, -0.284562), MESH_MAT),Triangle(vec3(-0.348236, 0.431813, 0.187355), vec3(-0.087285, 0.283275, 0.210542), vec3(0.005809, 0.425213, 0.38968), MESH_MAT),Triangle(vec3(0.206099, 0.385193, 0.23506), vec3(0.005809, 0.425213, 0.38968), vec3(-0.087285, 0.283275, 0.210542), MESH_MAT),Triangle(vec3(-0.093502, 0.928684, 0.249446), vec3(0.238038, 0.912358, -0.064413), vec3(-0.000876, 0.951055, -0.095386), MESH_MAT),Triangle(vec3(-0.080927, 0.675597, 0.443123), vec3(-0.348236, 0.431813, 0.187355), vec3(0.005809, 0.425213, 0.38968), MESH_MAT),Triangle(vec3(0.422259, 0.664239, 0.227806), vec3(-0.080927, 0.675597, 0.443123), vec3(0.005809, 0.425213, 0.38968), MESH_MAT),Triangle(vec3(-0.000876, 0.951055, -0.095386), vec3(-0.232804, 0.913283, -0.07611), vec3(-0.093502, 0.928684, 0.249446), MESH_MAT),Triangle(vec3(-0.080927, 0.675597, 0.443123), vec3(0.359312, 0.809934, 0.190415), vec3(-0.093502, 0.928684, 0.249446), MESH_MAT),Triangle(vec3(-0.390749, 0.750821, -0.047924), vec3(-0.230119, 0.726441, -0.236319), vec3(-0.358732, 0.664522, -0.156321), MESH_MAT),Triangle(vec3(-0.080927, 0.675597, 0.443123), vec3(-0.093502, 0.928684, 0.249446), vec3(-0.385411, 0.774394, 0.171219), MESH_MAT),Triangle(vec3(-0.093502, 0.928684, 0.249446), vec3(-0.232804, 0.913283, -0.07611), vec3(-0.385411, 0.774394, 0.171219), MESH_MAT),Triangle(vec3(0.390749, 0.750821, -0.047924), vec3(0.228729, 0.727074, -0.237354), vec3(0.238038, 0.912358, -0.064413), MESH_MAT),Triangle(vec3(-0.000876, 0.951055, -0.095386), vec3(-0.230119, 0.726441, -0.236319), vec3(-0.232804, 0.913283, -0.07611), MESH_MAT),Triangle(vec3(-0.000876, 0.951055, -0.095386), vec3(0.228729, 0.727074, -0.237354), vec3(0.001246, 0.678252, -0.316118), MESH_MAT),Triangle(vec3(-0.358732, 0.664522, -0.156321), vec3(-0.430741, 0.635244, 0.096042), vec3(-0.390749, 0.750821, -0.047924), MESH_MAT),Triangle(vec3(0.355827, 0.663179, -0.153664), vec3(0.425606, 0.644591, 0.095939), vec3(0.400522, 0.504134, -0.174586), MESH_MAT),Triangle(vec3(0.354444, 0.427229, 0.069641), vec3(0.118886, 0.353896, -0.25372), vec3(0.400522, 0.504134, -0.174586), MESH_MAT),Triangle(vec3(0.359312, 0.809934, 0.190415), vec3(0.422259, 0.664239, 0.227806), vec3(0.425606, 0.644591, 0.095939), MESH_MAT),Triangle(vec3(0.206099, 0.385193, 0.23506), vec3(0.107026, 0.257677, -0.170954), vec3(0.118886, 0.353896, -0.25372), MESH_MAT),Triangle(vec3(-0.269783, 0.391343, 0.07924), vec3(-0.111547, 0.371506, -0.26876), vec3(-0.099877, 0.263675, -0.148737), MESH_MAT),Triangle(vec3(0.626597, 0.462337, 0.231018), vec3(0.605289, 0.621201, 0.222109), vec3(0.681625, 0.619507, 0.222366), MESH_MAT),Triangle(vec3(0.206099, 0.385193, 0.23506), vec3(0.354444, 0.427229, 0.069641), vec3(0.385843, 0.40248, 0.161723), MESH_MAT),Triangle(vec3(-0.087285, 0.283275, 0.210542), vec3(-0.348236, 0.431813, 0.187355), vec3(-0.269783, 0.391343, 0.07924), MESH_MAT),Triangle(vec3(-0.425889, 0.462587, 0.146546), vec3(-0.589788, 0.453912, 0.198183), vec3(-0.571347, 0.483608, 0.229016), MESH_MAT),Triangle(vec3(-0.655388, 0.682794, 0.215691), vec3(-0.492634, 0.611389, 0.179686), vec3(-0.605856, 0.619805, 0.222295), MESH_MAT),Triangle(vec3(0.354444, 0.427229, 0.069641), vec3(0.573507, 0.486901, 0.21894), vec3(0.626597, 0.462337, 0.231018), MESH_MAT),Triangle(vec3(-0.605856, 0.619805, 0.222295), vec3(-0.571347, 0.483608, 0.229016), vec3(-0.589788, 0.453912, 0.198183), MESH_MAT),Triangle(vec3(-0.348236, 0.431813, 0.187355), vec3(-0.589788, 0.453912, 0.198183), vec3(-0.352066, 0.423646, 0.062407), MESH_MAT),Triangle(vec3(-0.395389, 0.515025, 0.15448), vec3(-0.352066, 0.423646, 0.062407), vec3(-0.425889, 0.462587, 0.146546), MESH_MAT),Triangle(vec3(0.424844, 0.461658, 0.147897), vec3(0.354444, 0.427229, 0.069641), vec3(0.397961, 0.51422, 0.154137), MESH_MAT),Triangle(vec3(-0.430741, 0.635244, 0.096042), vec3(-0.352066, 0.423646, 0.062407), vec3(-0.395389, 0.515025, 0.15448), MESH_MAT),Triangle(vec3(0.397961, 0.51422, 0.154137), vec3(0.572193, 0.709347, 0.176395), vec3(0.491707, 0.613633, 0.177227), MESH_MAT),Triangle(vec3(0.573507, 0.486901, 0.21894), vec3(0.354444, 0.427229, 0.069641), vec3(0.424844, 0.461658, 0.147897), MESH_MAT),Triangle(vec3(0.424844, 0.461658, 0.147897), vec3(0.397961, 0.51422, 0.154137), vec3(0.491707, 0.613633, 0.177227), MESH_MAT),Triangle(vec3(0.491707, 0.613633, 0.177227), vec3(0.605289, 0.621201, 0.222109), vec3(0.573507, 0.486901, 0.21894), MESH_MAT),Triangle(vec3(-0.416923, 0.638911, 0.195618), vec3(-0.612544, 0.457862, 0.273501), vec3(-0.348236, 0.431813, 0.187355), MESH_MAT),Triangle(vec3(0.385843, 0.40248, 0.161723), vec3(0.354444, 0.427229, 0.069641), vec3(0.626597, 0.462337, 0.231018), MESH_MAT),Triangle(vec3(-0.589788, 0.453912, 0.198183), vec3(-0.612544, 0.457862, 0.273501), vec3(-0.655388, 0.682794, 0.215691), MESH_MAT),Triangle(vec3(0.681625, 0.619507, 0.222366), vec3(0.572193, 0.709347, 0.176395), vec3(0.611595, 0.707537, 0.275748), MESH_MAT),Triangle(vec3(0.572193, 0.709347, 0.176395), vec3(0.425606, 0.644591, 0.095939), vec3(0.611595, 0.707537, 0.275748), MESH_MAT),Triangle(vec3(-0.430741, 0.635244, 0.096042), vec3(-0.613501, 0.703207, 0.276414), vec3(-0.416923, 0.638911, 0.195618), MESH_MAT),Triangle(vec3(0.385843, 0.40248, 0.161723), vec3(0.611595, 0.707537, 0.275748), vec3(0.422259, 0.664239, 0.227806), MESH_MAT),Triangle(vec3(-0.175781, 0.720605, -0.308594), vec3(-0.148134, 0.645054, -0.40256), vec3(-0.233546, 0.61699, -0.384061), MESH_MAT),Triangle(vec3(0.175781, 0.720605, -0.308594), vec3(0.273437, 0.681542, -0.289063), vec3(0.233309, 0.617333, -0.38407), MESH_MAT),Triangle(vec3(0.002234, 0.648687, -0.404854), vec3(-0.099075, 0.614842, -0.380184), vec3(-0.153416, 0.701143, -0.37639), MESH_MAT),Triangle(vec3(-0.274725, 0.614508, -0.33776), vec3(-0.400736, 0.663557, -0.315983), vec3(-0.126488, 0.790882, -0.425327), MESH_MAT),Triangle(vec3(0.408331, 0.65779, -0.319708), vec3(0.295262, 0.433562, -0.291302), vec3(0.271579, 0.569159, -0.341605), MESH_MAT),Triangle(vec3(-0.111447, 0.528968, -0.378309), vec3(-0.099075, 0.614842, -0.380184), vec3(0.002234, 0.648687, -0.404854), MESH_MAT),Triangle(vec3(0.064127, 0.341445, -0.379544), vec3(0.178364, -0.001195, -0.286764), vec3(0.049287, 0.097595, -0.364454), MESH_MAT),Triangle(vec3(-0.047467, 0.06566, -0.351474), vec3(-0.067141, 0.341459, -0.37578), vec3(0.001755, 0.296561, -0.381233), MESH_MAT),Triangle(vec3(-0.230119, 0.726441, -0.236319), vec3(-0.125314, 0.848878, -0.350857), vec3(-0.400736, 0.663557, -0.315983), MESH_MAT),Triangle(vec3(0.228729, 0.727074, -0.237354), vec3(0.355827, 0.663179, -0.153664), vec3(0.408331, 0.65779, -0.319708), MESH_MAT),Triangle(vec3(-0.087285, 0.283275, 0.210542), vec3(-0.000141, 0.215137, -0.153545), vec3(0.107026, 0.257677, -0.170954), MESH_MAT),Triangle(vec3(-0.093502, 0.928684, 0.249446), vec3(0.359312, 0.809934, 0.190415), vec3(0.238038, 0.912358, -0.064413), MESH_MAT),Triangle(vec3(-0.080927, 0.675597, 0.443123), vec3(0.422259, 0.664239, 0.227806), vec3(0.359312, 0.809934, 0.190415), MESH_MAT),Triangle(vec3(-0.390749, 0.750821, -0.047924), vec3(-0.232804, 0.913283, -0.07611), vec3(-0.230119, 0.726441, -0.236319), MESH_MAT),Triangle(vec3(0.390749, 0.750821, -0.047924), vec3(0.355827, 0.663179, -0.153664), vec3(0.228729, 0.727074, -0.237354), MESH_MAT),Triangle(vec3(-0.000876, 0.951055, -0.095386), vec3(0.001246, 0.678252, -0.316118), vec3(-0.230119, 0.726441, -0.236319), MESH_MAT),Triangle(vec3(-0.000876, 0.951055, -0.095386), vec3(0.238038, 0.912358, -0.064413), vec3(0.228729, 0.727074, -0.237354), MESH_MAT),Triangle(vec3(-0.358732, 0.664522, -0.156321), vec3(-0.394926, 0.516696, -0.200264), vec3(-0.430741, 0.635244, 0.096042), MESH_MAT),Triangle(vec3(0.355827, 0.663179, -0.153664), vec3(0.390749, 0.750821, -0.047924), vec3(0.425606, 0.644591, 0.095939), MESH_MAT),Triangle(vec3(0.354444, 0.427229, 0.069641), vec3(0.206099, 0.385193, 0.23506), vec3(0.118886, 0.353896, -0.25372), MESH_MAT),Triangle(vec3(-0.269783, 0.391343, 0.07924), vec3(-0.394926, 0.516696, -0.200264), vec3(-0.111547, 0.371506, -0.26876), MESH_MAT),Triangle(vec3(0.626597, 0.462337, 0.231018), vec3(0.573507, 0.486901, 0.21894), vec3(0.605289, 0.621201, 0.222109), MESH_MAT),Triangle(vec3(-0.425889, 0.462587, 0.146546), vec3(-0.352066, 0.423646, 0.062407), vec3(-0.589788, 0.453912, 0.198183), MESH_MAT),Triangle(vec3(-0.655388, 0.682794, 0.215691), vec3(-0.430741, 0.635244, 0.096042), vec3(-0.492634, 0.611389, 0.179686), MESH_MAT),Triangle(vec3(-0.348236, 0.431813, 0.187355), vec3(-0.612544, 0.457862, 0.273501), vec3(-0.589788, 0.453912, 0.198183), MESH_MAT),Triangle(vec3(-0.416923, 0.638911, 0.195618), vec3(-0.613501, 0.703207, 0.276414), vec3(-0.612544, 0.457862, 0.273501), MESH_MAT),Triangle(vec3(0.516567, -0.010352, -0.516567), vec3(0.516567, -0.010352, 0.516567), vec3(0.516567, -1.811388, 0.516567), MESH_MAT),Triangle(vec3(0.516567, -0.010352, 0.516567), vec3(-0.516567, -0.010352, 0.516567), vec3(-0.516567, -1.811388, 0.516567), MESH_MAT),Triangle(vec3(-0.516567, -0.010352, 0.516567), vec3(-0.516567, -0.010352, -0.516567), vec3(-0.516567, -1.811388, -0.516567), MESH_MAT),Triangle(vec3(-0.516567, -0.010352, -0.516567), vec3(0.516567, -0.010352, -0.516567), vec3(0.516567, -1.811388, -0.516567), MESH_MAT),Triangle(vec3(0.516567, -0.010352, 0.516567), vec3(0.516567, -0.010352, -0.516567), vec3(-0.516567, -0.010352, -0.516567), MESH_MAT)\n);\n    // Doesn't matter since we're in a box\nvec3 sky_color(vec3 d) {\n    return vec3(0.0);\n}\n\n// basic camera ray\nRay camera(vec2 ndc) {\n    Ray cam; \n    cam.origin    = vec3(0.0, 0.5, -1.2);\n    cam.direction = normalize(vec3(ndc, 1.0));\n    \n    return cam;\n}\n#endif\n\n#ifdef SCENE_CORNELL_2_TEAPOT\n\n#define LIGHT_POS vec3(0.0, 2.2, 0.0)\n#define LIGHT_RADIUS 0.5\n#define LIGHT_STRENGTH 40.0\n#define LIGHT_COLOR vec3(1.0, 1.0, 1.0)\n\n#define N_SPHERES 7\nconst Sphere SPHERES[N_SPHERES] = Sphere[](\n    Sphere(vec3(0.0, -1000.5, 0.0), 1000.0, Material(vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), 1.0)), // Ground\n    Sphere(vec3(1001.5, 0.0, 0.0), 1000.0, Material(vec3(0.0, 0.8, 0.0), vec3(0.0, 0.0, 0.0), 1.0)), // Right wall\n    Sphere(vec3(-1001.5, 0.0, 0.0), 1000.0, Material(vec3(0.8, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 1.0)), // Left wall\n    Sphere(vec3(0.0, 0.0, 1001), 1000.0, Material(vec3(0.0, 0.0, 0.8), vec3(0.0, 0.0, 0.0), 1.0)), // Back wall\n    Sphere(vec3(0.0, 0.0, -1002), 1000.0, Material(vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), 1.0)), // Front wall\n    Sphere(vec3(0.0, 1002, 0.0), 1000.0, Material(vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), 1.0)), // Ceiling\n\n    Sphere(LIGHT_POS, LIGHT_RADIUS, Material(vec3(0.0, 0.0, 0.0), LIGHT_COLOR * LIGHT_STRENGTH, 1.0)) // Light sphere\n);\n\n#define MESH_MAT Material(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), 1.0)\n#define N_TRIANGLES 186\nconst Triangle TRIS[N_TRIANGLES] = Triangle[](\n    Triangle(vec3(-0.249307, 0.599072, -0.249307), vec3(-0.138359, 0.60751, -0.345989), vec3(-0.323411, 0.627775, -0.164723), MESH_MAT),Triangle(vec3(-0.349958, 0.600004, -0.057812), vec3(-0.323411, 0.627775, -0.164723), vec3(-0.351764, 0.62555, 0.039078), MESH_MAT),Triangle(vec3(0.249307, 0.599072, -0.249307), vec3(0.345989, 0.60751, -0.138359), vec3(0.164723, 0.627775, -0.323411), MESH_MAT),Triangle(vec3(0.057812, 0.600004, -0.349958), vec3(0.164723, 0.627775, -0.323411), vec3(-0.039078, 0.62555, -0.351764), MESH_MAT),Triangle(vec3(0.249307, 0.599072, 0.249307), vec3(0.138359, 0.60751, 0.345989), vec3(0.323411, 0.627775, 0.164723), MESH_MAT),Triangle(vec3(0.349958, 0.600004, 0.057812), vec3(0.323411, 0.627775, 0.164723), vec3(0.351764, 0.62555, -0.039078), MESH_MAT),Triangle(vec3(-0.249307, 0.599072, 0.249307), vec3(-0.345989, 0.60751, 0.138359), vec3(-0.164723, 0.627775, 0.323411), MESH_MAT),Triangle(vec3(-0.057812, 0.600004, 0.349958), vec3(-0.164723, 0.627775, 0.323411), vec3(0.039078, 0.62555, 0.351764), MESH_MAT),Triangle(vec3(-0.138359, 0.60751, -0.345989), vec3(0.0, 0.371287, -0.476709), vec3(-0.255161, 0.25326, -0.452322), MESH_MAT),Triangle(vec3(-0.49201, 0.163631, -0.095757), vec3(-0.439659, 0.318825, -0.231298), vec3(-0.351552, 0.153297, -0.351552), MESH_MAT),Triangle(vec3(-0.476709, 0.371287, 0.0), vec3(-0.323411, 0.627775, -0.164723), vec3(-0.439659, 0.318825, -0.231298), MESH_MAT),Triangle(vec3(0.345989, 0.60751, -0.138359), vec3(0.476709, 0.371287, 0.0), vec3(0.452322, 0.25326, -0.255161), MESH_MAT),Triangle(vec3(0.231298, 0.318825, -0.439659), vec3(0.426294, 0.147658, -0.250751), vec3(0.228177, 0.153246, -0.441203), MESH_MAT),Triangle(vec3(-0.054437, 0.147319, -0.490102), vec3(0.231298, 0.318825, -0.439659), vec3(0.228177, 0.153246, -0.441203), MESH_MAT),Triangle(vec3(0.0, 0.371287, -0.476709), vec3(0.164723, 0.627775, -0.323411), vec3(0.231298, 0.318825, -0.439659), MESH_MAT),Triangle(vec3(0.138359, 0.60751, 0.345989), vec3(0.0, 0.252701, 0.515607), vec3(0.255161, 0.25326, 0.452322), MESH_MAT),Triangle(vec3(0.439659, 0.318825, 0.231298), vec3(0.250751, 0.147658, 0.426294), vec3(0.396154, 0.153873, 0.290729), MESH_MAT),Triangle(vec3(0.482774, 0.146905, 0.098954), vec3(0.439659, 0.318825, 0.231298), vec3(0.396154, 0.153873, 0.290729), MESH_MAT),Triangle(vec3(0.500377, 0.222735, 0.024836), vec3(0.439659, 0.318825, 0.231298), vec3(0.482774, 0.146905, 0.098954), MESH_MAT),Triangle(vec3(0.476709, 0.371287, 0.0), vec3(0.323411, 0.627775, 0.164723), vec3(0.439659, 0.318825, 0.231298), MESH_MAT),Triangle(vec3(-0.345989, 0.60751, 0.138359), vec3(-0.476709, 0.371287, 0.0), vec3(-0.452322, 0.25326, 0.255161), MESH_MAT),Triangle(vec3(-0.231298, 0.318825, 0.439659), vec3(-0.426294, 0.147658, 0.250751), vec3(-0.228177, 0.153246, 0.441203), MESH_MAT),Triangle(vec3(0.0, 0.252701, 0.515607), vec3(-0.231298, 0.318825, 0.439659), vec3(-0.228177, 0.153246, 0.441203), MESH_MAT),Triangle(vec3(0.0, 0.252701, 0.515607), vec3(-0.164723, 0.627775, 0.323411), vec3(-0.231298, 0.318825, 0.439659), MESH_MAT),Triangle(vec3(-0.172714, 0.031555, -0.334116), vec3(-0.054437, 0.147319, -0.490102), vec3(0.0592, 0.012201, -0.355237), MESH_MAT),Triangle(vec3(-0.351552, 0.153297, -0.351552), vec3(-0.255161, 0.25326, -0.452322), vec3(-0.054437, 0.147319, -0.490102), MESH_MAT),Triangle(vec3(-0.321398, 0.018498, -0.176568), vec3(-0.351552, 0.153297, -0.351552), vec3(-0.172714, 0.031555, -0.334116), MESH_MAT),Triangle(vec3(0.452322, 0.25326, -0.255161), vec3(0.500377, 0.222735, 0.024836), vec3(0.482774, 0.146905, 0.098954), MESH_MAT),Triangle(vec3(0.26619, 0.03156, -0.26619), vec3(0.426294, 0.147658, -0.250751), vec3(0.35943, 0.018277, -0.069233), MESH_MAT),Triangle(vec3(0.228177, 0.153246, -0.441203), vec3(0.26619, 0.03156, -0.26619), vec3(0.0592, 0.012201, -0.355237), MESH_MAT),Triangle(vec3(0.250751, 0.147658, 0.426294), vec3(0.0, 0.252701, 0.515607), vec3(0.055529, 0.007041, 0.350784), MESH_MAT),Triangle(vec3(0.301283, 0.015293, 0.216175), vec3(0.250751, 0.147658, 0.426294), vec3(0.055529, 0.007041, 0.350784), MESH_MAT),Triangle(vec3(0.482774, 0.146905, 0.098954), vec3(0.301283, 0.015293, 0.216175), vec3(0.35943, 0.018277, -0.069233), MESH_MAT),Triangle(vec3(-0.426294, 0.147658, 0.250751), vec3(-0.49201, 0.163631, -0.095757), vec3(-0.355089, 0.011388, -0.006513), MESH_MAT),Triangle(vec3(-0.176568, 0.018498, 0.321398), vec3(-0.426294, 0.147658, 0.250751), vec3(-0.334116, 0.031555, 0.172714), MESH_MAT),Triangle(vec3(0.0, 0.252701, 0.515607), vec3(-0.228177, 0.153246, 0.441203), vec3(0.055529, 0.007041, 0.350784), MESH_MAT),Triangle(vec3(0.736081, 0.404985, -0.04904), vec3(0.709511, 0.529378, -0.048025), vec3(0.737858, 0.474215, 0.050934), MESH_MAT),Triangle(vec3(0.378397, 0.555335, -0.040293), vec3(0.374749, 0.569049, 0.029679), vec3(0.709511, 0.529378, -0.048025), MESH_MAT),Triangle(vec3(0.399265, 0.507753, -0.030793), vec3(0.709511, 0.529378, -0.048025), vec3(0.678734, 0.497833, -0.049), MESH_MAT),Triangle(vec3(0.683743, 0.511723, 0.056311), vec3(0.399265, 0.507753, -0.030793), vec3(0.678734, 0.497833, -0.049), MESH_MAT),Triangle(vec3(0.374749, 0.569049, 0.029679), vec3(0.683743, 0.511723, 0.056311), vec3(0.709511, 0.529378, -0.048025), MESH_MAT),Triangle(vec3(0.477956, 0.158239, -0.037447), vec3(0.694117, 0.29403, 0.040552), vec3(0.474552, 0.152372, 0.024304), MESH_MAT),Triangle(vec3(0.736081, 0.404985, -0.04904), vec3(0.737858, 0.474215, 0.050934), vec3(0.694117, 0.29403, 0.040552), MESH_MAT),Triangle(vec3(0.496787, 0.216419, -0.038448), vec3(0.643977, 0.289417, -0.058055), vec3(0.477956, 0.158239, -0.037447), MESH_MAT),Triangle(vec3(0.500377, 0.222735, 0.024836), vec3(0.643977, 0.289417, -0.058055), vec3(0.496787, 0.216419, -0.038448), MESH_MAT),Triangle(vec3(0.682994, 0.450033, 0.021708), vec3(0.678734, 0.497833, -0.049), vec3(0.643977, 0.289417, -0.058055), MESH_MAT),Triangle(vec3(0.683743, 0.511723, 0.056311), vec3(0.682994, 0.450033, 0.021708), vec3(0.737858, 0.474215, 0.050934), MESH_MAT),Triangle(vec3(0.694117, 0.29403, 0.040552), vec3(0.500377, 0.222735, 0.024836), vec3(0.474552, 0.152372, 0.024304), MESH_MAT),Triangle(vec3(-0.829186, 0.618599, -0.032608), vec3(-0.720253, 0.520742, -0.040315), vec3(-0.847829, 0.619009, 0.025431), MESH_MAT),Triangle(vec3(-0.671274, 0.603165, -0.026947), vec3(-0.720253, 0.520742, -0.040315), vec3(-0.829186, 0.618599, -0.032608), MESH_MAT),Triangle(vec3(-0.580066, 0.365267, -0.091783), vec3(-0.598754, 0.243296, -0.094482), vec3(-0.671274, 0.603165, -0.026947), MESH_MAT),Triangle(vec3(-0.425754, 0.241713, -0.132374), vec3(-0.598754, 0.243296, -0.094482), vec3(-0.580066, 0.365267, -0.091783), MESH_MAT),Triangle(vec3(-0.426234, 0.360888, 0.0), vec3(-0.580066, 0.365267, -0.091783), vec3(-0.572346, 0.387626, 0.073487), MESH_MAT),Triangle(vec3(-0.707075, 0.604365, 0.027655), vec3(-0.572346, 0.387626, 0.073487), vec3(-0.671274, 0.603165, -0.026947), MESH_MAT),Triangle(vec3(-0.712237, 0.530236, 0.047183), vec3(-0.707075, 0.604365, 0.027655), vec3(-0.847829, 0.619009, 0.025431), MESH_MAT),Triangle(vec3(-0.629229, 0.282696, 0.084402), vec3(-0.572346, 0.387626, 0.073487), vec3(-0.707075, 0.604365, 0.027655), MESH_MAT),Triangle(vec3(-0.629229, 0.282696, 0.084402), vec3(-0.427318, 0.190885, 0.119844), vec3(-0.572346, 0.387626, 0.073487), MESH_MAT),Triangle(vec3(-0.629229, 0.282696, 0.084402), vec3(-0.712237, 0.530236, 0.047183), vec3(-0.720253, 0.520742, -0.040315), MESH_MAT),Triangle(vec3(-0.598754, 0.243296, -0.094482), vec3(-0.427318, 0.190885, 0.119844), vec3(-0.629229, 0.282696, 0.084402), MESH_MAT),Triangle(vec3(-0.043697, 0.677187, -0.015062), vec3(-0.060866, 0.765399, -0.077808), vec3(0.015062, 0.668629, -0.043697), MESH_MAT),Triangle(vec3(-0.077626, 0.773918, 0.062203), vec3(-0.060866, 0.765399, -0.077808), vec3(-0.043697, 0.677187, -0.015062), MESH_MAT),Triangle(vec3(0.015062, 0.668629, -0.043697), vec3(0.077808, 0.765399, -0.060866), vec3(0.045294, 0.688527, 0.011482), MESH_MAT),Triangle(vec3(-0.060866, 0.765399, -0.077808), vec3(0.077808, 0.765399, -0.060866), vec3(0.015062, 0.668629, -0.043697), MESH_MAT),Triangle(vec3(-0.060866, 0.765399, -0.077808), vec3(-0.077626, 0.773918, 0.062203), vec3(0.077808, 0.765399, -0.060866), MESH_MAT),Triangle(vec3(0.000471, 0.701722, 0.048582), vec3(-0.030383, 0.67022, 0.047763), vec3(0.045294, 0.688527, 0.011482), MESH_MAT),Triangle(vec3(0.045294, 0.688527, 0.011482), vec3(0.060866, 0.765399, 0.077808), vec3(0.000471, 0.701722, 0.048582), MESH_MAT),Triangle(vec3(0.077808, 0.765399, -0.060866), vec3(0.060866, 0.765399, 0.077808), vec3(0.045294, 0.688527, 0.011482), MESH_MAT),Triangle(vec3(0.077808, 0.765399, -0.060866), vec3(-0.077626, 0.773918, 0.062203), vec3(0.060866, 0.765399, 0.077808), MESH_MAT),Triangle(vec3(0.000471, 0.701722, 0.048582), vec3(-0.077626, 0.773918, 0.062203), vec3(-0.043697, 0.677187, -0.015062), MESH_MAT),Triangle(vec3(0.060866, 0.765399, 0.077808), vec3(-0.077626, 0.773918, 0.062203), vec3(0.000471, 0.701722, 0.048582), MESH_MAT),Triangle(vec3(-0.197995, 0.611249, -0.270095), vec3(0.0, 0.6, -0.325), vec3(-0.103688, 0.6, -0.308672), MESH_MAT),Triangle(vec3(-0.043697, 0.677187, -0.015062), vec3(0.104502, 0.610348, -0.316797), vec3(-0.197995, 0.611249, -0.270095), MESH_MAT),Triangle(vec3(-0.316797, 0.610348, -0.104502), vec3(-0.197995, 0.611249, -0.270095), vec3(-0.263016, 0.6, -0.193024), MESH_MAT),Triangle(vec3(-0.316797, 0.610348, -0.104502), vec3(-0.030383, 0.67022, 0.047763), vec3(-0.197995, 0.611249, -0.270095), MESH_MAT),Triangle(vec3(0.270095, 0.602691, -0.197995), vec3(0.325, 0.6, 0.0), vec3(0.308672, 0.6, -0.103688), MESH_MAT),Triangle(vec3(0.015062, 0.668629, -0.043697), vec3(0.316797, 0.610348, 0.104502), vec3(0.270095, 0.602691, -0.197995), MESH_MAT),Triangle(vec3(0.104502, 0.610348, -0.316797), vec3(0.270095, 0.602691, -0.197995), vec3(0.193024, 0.6, -0.263016), MESH_MAT),Triangle(vec3(0.104502, 0.610348, -0.316797), vec3(-0.043697, 0.677187, -0.015062), vec3(0.270095, 0.602691, -0.197995), MESH_MAT),Triangle(vec3(0.197995, 0.611249, 0.270095), vec3(0.0, 0.6, 0.325), vec3(0.103688, 0.6, 0.308672), MESH_MAT),Triangle(vec3(-0.030383, 0.67022, 0.047763), vec3(-0.104502, 0.610348, 0.316797), vec3(0.197995, 0.611249, 0.270095), MESH_MAT),Triangle(vec3(0.316797, 0.610348, 0.104502), vec3(0.197995, 0.611249, 0.270095), vec3(0.263016, 0.6, 0.193024), MESH_MAT),Triangle(vec3(0.316797, 0.610348, 0.104502), vec3(0.015062, 0.668629, -0.043697), vec3(0.197995, 0.611249, 0.270095), MESH_MAT),Triangle(vec3(0.015062, 0.668629, -0.043697), vec3(0.045294, 0.688527, 0.011482), vec3(-0.030383, 0.67022, 0.047763), MESH_MAT),Triangle(vec3(-0.270095, 0.611249, 0.197995), vec3(-0.325, 0.6, 0.0), vec3(-0.308672, 0.6, 0.103688), MESH_MAT),Triangle(vec3(-0.030383, 0.67022, 0.047763), vec3(-0.316797, 0.610348, -0.104502), vec3(-0.270095, 0.611249, 0.197995), MESH_MAT),Triangle(vec3(-0.104502, 0.610348, 0.316797), vec3(-0.270095, 0.611249, 0.197995), vec3(-0.193024, 0.6, 0.263016), MESH_MAT),Triangle(vec3(-0.104502, 0.610348, 0.316797), vec3(-0.030383, 0.67022, 0.047763), vec3(-0.270095, 0.611249, 0.197995), MESH_MAT),Triangle(vec3(-0.039078, 0.62555, -0.351764), vec3(-0.138359, 0.60751, -0.345989), vec3(0.057812, 0.600004, -0.349958), MESH_MAT),Triangle(vec3(-0.349958, 0.600004, -0.057812), vec3(-0.249307, 0.599072, -0.249307), vec3(-0.323411, 0.627775, -0.164723), MESH_MAT),Triangle(vec3(0.351764, 0.62555, -0.039078), vec3(0.345989, 0.60751, -0.138359), vec3(0.349958, 0.600004, 0.057812), MESH_MAT),Triangle(vec3(0.057812, 0.600004, -0.349958), vec3(0.249307, 0.599072, -0.249307), vec3(0.164723, 0.627775, -0.323411), MESH_MAT),Triangle(vec3(0.039078, 0.62555, 0.351764), vec3(0.138359, 0.60751, 0.345989), vec3(-0.057812, 0.600004, 0.349958), MESH_MAT),Triangle(vec3(0.349958, 0.600004, 0.057812), vec3(0.249307, 0.599072, 0.249307), vec3(0.323411, 0.627775, 0.164723), MESH_MAT),Triangle(vec3(-0.351764, 0.62555, 0.039078), vec3(-0.345989, 0.60751, 0.138359), vec3(-0.349958, 0.600004, -0.057812), MESH_MAT),Triangle(vec3(-0.057812, 0.600004, 0.349958), vec3(-0.249307, 0.599072, 0.249307), vec3(-0.164723, 0.627775, 0.323411), MESH_MAT),Triangle(vec3(-0.255161, 0.25326, -0.452322), vec3(0.0, 0.371287, -0.476709), vec3(-0.054437, 0.147319, -0.490102), MESH_MAT),Triangle(vec3(-0.138359, 0.60751, -0.345989), vec3(-0.039078, 0.62555, -0.351764), vec3(0.0, 0.371287, -0.476709), MESH_MAT),Triangle(vec3(-0.439659, 0.318825, -0.231298), vec3(-0.255161, 0.25326, -0.452322), vec3(-0.351552, 0.153297, -0.351552), MESH_MAT),Triangle(vec3(-0.439659, 0.318825, -0.231298), vec3(-0.323411, 0.627775, -0.164723), vec3(-0.255161, 0.25326, -0.452322), MESH_MAT),Triangle(vec3(-0.323411, 0.627775, -0.164723), vec3(-0.138359, 0.60751, -0.345989), vec3(-0.255161, 0.25326, -0.452322), MESH_MAT),Triangle(vec3(-0.49201, 0.163631, -0.095757), vec3(-0.476709, 0.371287, 0.0), vec3(-0.439659, 0.318825, -0.231298), MESH_MAT),Triangle(vec3(-0.476709, 0.371287, 0.0), vec3(-0.351764, 0.62555, 0.039078), vec3(-0.323411, 0.627775, -0.164723), MESH_MAT),Triangle(vec3(0.452322, 0.25326, -0.255161), vec3(0.476709, 0.371287, 0.0), vec3(0.500377, 0.222735, 0.024836), MESH_MAT),Triangle(vec3(0.345989, 0.60751, -0.138359), vec3(0.351764, 0.62555, -0.039078), vec3(0.476709, 0.371287, 0.0), MESH_MAT),Triangle(vec3(0.231298, 0.318825, -0.439659), vec3(0.452322, 0.25326, -0.255161), vec3(0.426294, 0.147658, -0.250751), MESH_MAT),Triangle(vec3(0.231298, 0.318825, -0.439659), vec3(0.164723, 0.627775, -0.323411), vec3(0.452322, 0.25326, -0.255161), MESH_MAT),Triangle(vec3(0.164723, 0.627775, -0.323411), vec3(0.345989, 0.60751, -0.138359), vec3(0.452322, 0.25326, -0.255161), MESH_MAT),Triangle(vec3(-0.054437, 0.147319, -0.490102), vec3(0.0, 0.371287, -0.476709), vec3(0.231298, 0.318825, -0.439659), MESH_MAT),Triangle(vec3(0.0, 0.371287, -0.476709), vec3(-0.039078, 0.62555, -0.351764), vec3(0.164723, 0.627775, -0.323411), MESH_MAT),Triangle(vec3(0.138359, 0.60751, 0.345989), vec3(0.039078, 0.62555, 0.351764), vec3(0.0, 0.252701, 0.515607), MESH_MAT),Triangle(vec3(0.439659, 0.318825, 0.231298), vec3(0.255161, 0.25326, 0.452322), vec3(0.250751, 0.147658, 0.426294), MESH_MAT),Triangle(vec3(0.439659, 0.318825, 0.231298), vec3(0.323411, 0.627775, 0.164723), vec3(0.255161, 0.25326, 0.452322), MESH_MAT),Triangle(vec3(0.323411, 0.627775, 0.164723), vec3(0.138359, 0.60751, 0.345989), vec3(0.255161, 0.25326, 0.452322), MESH_MAT),Triangle(vec3(0.500377, 0.222735, 0.024836), vec3(0.476709, 0.371287, 0.0), vec3(0.439659, 0.318825, 0.231298), MESH_MAT),Triangle(vec3(0.476709, 0.371287, 0.0), vec3(0.351764, 0.62555, -0.039078), vec3(0.323411, 0.627775, 0.164723), MESH_MAT),Triangle(vec3(-0.452322, 0.25326, 0.255161), vec3(-0.476709, 0.371287, 0.0), vec3(-0.49201, 0.163631, -0.095757), MESH_MAT),Triangle(vec3(-0.345989, 0.60751, 0.138359), vec3(-0.351764, 0.62555, 0.039078), vec3(-0.476709, 0.371287, 0.0), MESH_MAT),Triangle(vec3(-0.231298, 0.318825, 0.439659), vec3(-0.452322, 0.25326, 0.255161), vec3(-0.426294, 0.147658, 0.250751), MESH_MAT),Triangle(vec3(-0.231298, 0.318825, 0.439659), vec3(-0.164723, 0.627775, 0.323411), vec3(-0.452322, 0.25326, 0.255161), MESH_MAT),Triangle(vec3(-0.164723, 0.627775, 0.323411), vec3(-0.345989, 0.60751, 0.138359), vec3(-0.452322, 0.25326, 0.255161), MESH_MAT),Triangle(vec3(0.0, 0.252701, 0.515607), vec3(0.039078, 0.62555, 0.351764), vec3(-0.164723, 0.627775, 0.323411), MESH_MAT),Triangle(vec3(-0.172714, 0.031555, -0.334116), vec3(-0.351552, 0.153297, -0.351552), vec3(-0.054437, 0.147319, -0.490102), MESH_MAT),Triangle(vec3(-0.49201, 0.163631, -0.095757), vec3(-0.351552, 0.153297, -0.351552), vec3(-0.321398, 0.018498, -0.176568), MESH_MAT),Triangle(vec3(-0.355089, 0.011388, -0.006513), vec3(-0.49201, 0.163631, -0.095757), vec3(-0.321398, 0.018498, -0.176568), MESH_MAT),Triangle(vec3(0.35943, 0.018277, -0.069233), vec3(0.426294, 0.147658, -0.250751), vec3(0.482774, 0.146905, 0.098954), MESH_MAT),Triangle(vec3(0.426294, 0.147658, -0.250751), vec3(0.452322, 0.25326, -0.255161), vec3(0.482774, 0.146905, 0.098954), MESH_MAT),Triangle(vec3(0.26619, 0.03156, -0.26619), vec3(0.228177, 0.153246, -0.441203), vec3(0.426294, 0.147658, -0.250751), MESH_MAT),Triangle(vec3(-0.054437, 0.147319, -0.490102), vec3(0.228177, 0.153246, -0.441203), vec3(0.0592, 0.012201, -0.355237), MESH_MAT),Triangle(vec3(0.250751, 0.147658, 0.426294), vec3(0.255161, 0.25326, 0.452322), vec3(0.0, 0.252701, 0.515607), MESH_MAT),Triangle(vec3(0.301283, 0.015293, 0.216175), vec3(0.396154, 0.153873, 0.290729), vec3(0.250751, 0.147658, 0.426294), MESH_MAT),Triangle(vec3(0.482774, 0.146905, 0.098954), vec3(0.396154, 0.153873, 0.290729), vec3(0.301283, 0.015293, 0.216175), MESH_MAT),Triangle(vec3(-0.334116, 0.031555, 0.172714), vec3(-0.426294, 0.147658, 0.250751), vec3(-0.355089, 0.011388, -0.006513), MESH_MAT),Triangle(vec3(-0.426294, 0.147658, 0.250751), vec3(-0.452322, 0.25326, 0.255161), vec3(-0.49201, 0.163631, -0.095757), MESH_MAT),Triangle(vec3(-0.176568, 0.018498, 0.321398), vec3(-0.228177, 0.153246, 0.441203), vec3(-0.426294, 0.147658, 0.250751), MESH_MAT),Triangle(vec3(0.055529, 0.007041, 0.350784), vec3(-0.228177, 0.153246, 0.441203), vec3(-0.176568, 0.018498, 0.321398), MESH_MAT),Triangle(vec3(0.736081, 0.404985, -0.04904), vec3(0.678734, 0.497833, -0.049), vec3(0.709511, 0.529378, -0.048025), MESH_MAT),Triangle(vec3(0.399265, 0.507753, -0.030793), vec3(0.378397, 0.555335, -0.040293), vec3(0.709511, 0.529378, -0.048025), MESH_MAT),Triangle(vec3(0.683743, 0.511723, 0.056311), vec3(0.678734, 0.497833, -0.049), vec3(0.682994, 0.450033, 0.021708), MESH_MAT),Triangle(vec3(0.683743, 0.511723, 0.056311), vec3(0.396087, 0.514329, 0.042982), vec3(0.399265, 0.507753, -0.030793), MESH_MAT),Triangle(vec3(0.683743, 0.511723, 0.056311), vec3(0.374749, 0.569049, 0.029679), vec3(0.396087, 0.514329, 0.042982), MESH_MAT),Triangle(vec3(0.709511, 0.529378, -0.048025), vec3(0.683743, 0.511723, 0.056311), vec3(0.737858, 0.474215, 0.050934), MESH_MAT),Triangle(vec3(0.477956, 0.158239, -0.037447), vec3(0.643977, 0.289417, -0.058055), vec3(0.694117, 0.29403, 0.040552), MESH_MAT),Triangle(vec3(0.643977, 0.289417, -0.058055), vec3(0.736081, 0.404985, -0.04904), vec3(0.694117, 0.29403, 0.040552), MESH_MAT),Triangle(vec3(0.643977, 0.289417, -0.058055), vec3(0.678734, 0.497833, -0.049), vec3(0.736081, 0.404985, -0.04904), MESH_MAT),Triangle(vec3(0.500377, 0.222735, 0.024836), vec3(0.590879, 0.275795, 0.043794), vec3(0.643977, 0.289417, -0.058055), MESH_MAT),Triangle(vec3(0.590879, 0.275795, 0.043794), vec3(0.682994, 0.450033, 0.021708), vec3(0.643977, 0.289417, -0.058055), MESH_MAT),Triangle(vec3(0.737858, 0.474215, 0.050934), vec3(0.682994, 0.450033, 0.021708), vec3(0.590879, 0.275795, 0.043794), MESH_MAT),Triangle(vec3(0.694117, 0.29403, 0.040552), vec3(0.590879, 0.275795, 0.043794), vec3(0.500377, 0.222735, 0.024836), MESH_MAT),Triangle(vec3(0.694117, 0.29403, 0.040552), vec3(0.737858, 0.474215, 0.050934), vec3(0.590879, 0.275795, 0.043794), MESH_MAT),Triangle(vec3(-0.720253, 0.520742, -0.040315), vec3(-0.598754, 0.243296, -0.094482), vec3(-0.629229, 0.282696, 0.084402), MESH_MAT),Triangle(vec3(-0.425754, 0.241713, -0.132374), vec3(-0.420264, 0.163284, -0.033372), vec3(-0.598754, 0.243296, -0.094482), MESH_MAT),Triangle(vec3(-0.671274, 0.603165, -0.026947), vec3(-0.598754, 0.243296, -0.094482), vec3(-0.720253, 0.520742, -0.040315), MESH_MAT),Triangle(vec3(-0.426234, 0.360888, 0.0), vec3(-0.425754, 0.241713, -0.132374), vec3(-0.580066, 0.365267, -0.091783), MESH_MAT),Triangle(vec3(-0.572346, 0.387626, 0.073487), vec3(-0.580066, 0.365267, -0.091783), vec3(-0.671274, 0.603165, -0.026947), MESH_MAT),Triangle(vec3(-0.572346, 0.387626, 0.073487), vec3(-0.427318, 0.190885, 0.119844), vec3(-0.426234, 0.360888, 0.0), MESH_MAT),Triangle(vec3(-0.712237, 0.530236, 0.047183), vec3(-0.629229, 0.282696, 0.084402), vec3(-0.707075, 0.604365, 0.027655), MESH_MAT),Triangle(vec3(-0.720253, 0.520742, -0.040315), vec3(-0.712237, 0.530236, 0.047183), vec3(-0.847829, 0.619009, 0.025431), MESH_MAT),Triangle(vec3(-0.598754, 0.243296, -0.094482), vec3(-0.420264, 0.163284, -0.033372), vec3(-0.427318, 0.190885, 0.119844), MESH_MAT),Triangle(vec3(-0.829186, 0.618599, -0.032608), vec3(-0.847829, 0.619009, 0.025431), vec3(-0.796838, 0.608175, 0.0), MESH_MAT),Triangle(vec3(-0.70093, 0.60071, -0.00908), vec3(-0.829186, 0.618599, -0.032608), vec3(-0.796838, 0.608175, 0.0), MESH_MAT),Triangle(vec3(-0.70093, 0.60071, -0.00908), vec3(-0.671274, 0.603165, -0.026947), vec3(-0.829186, 0.618599, -0.032608), MESH_MAT),Triangle(vec3(-0.70093, 0.60071, -0.00908), vec3(-0.707075, 0.604365, 0.027655), vec3(-0.671274, 0.603165, -0.026947), MESH_MAT),Triangle(vec3(-0.796838, 0.608175, 0.0), vec3(-0.847829, 0.619009, 0.025431), vec3(-0.707075, 0.604365, 0.027655), MESH_MAT),Triangle(vec3(-0.030383, 0.67022, 0.047763), vec3(0.000471, 0.701722, 0.048582), vec3(-0.043697, 0.677187, -0.015062), MESH_MAT),Triangle(vec3(-0.197995, 0.611249, -0.270095), vec3(0.104502, 0.610348, -0.316797), vec3(0.0, 0.6, -0.325), MESH_MAT),Triangle(vec3(-0.197995, 0.611249, -0.270095), vec3(-0.030383, 0.67022, 0.047763), vec3(-0.043697, 0.677187, -0.015062), MESH_MAT),Triangle(vec3(0.270095, 0.602691, -0.197995), vec3(0.316797, 0.610348, 0.104502), vec3(0.325, 0.6, 0.0), MESH_MAT),Triangle(vec3(0.270095, 0.602691, -0.197995), vec3(-0.043697, 0.677187, -0.015062), vec3(0.015062, 0.668629, -0.043697), MESH_MAT),Triangle(vec3(0.197995, 0.611249, 0.270095), vec3(-0.104502, 0.610348, 0.316797), vec3(0.0, 0.6, 0.325), MESH_MAT),Triangle(vec3(0.197995, 0.611249, 0.270095), vec3(0.015062, 0.668629, -0.043697), vec3(-0.030383, 0.67022, 0.047763), MESH_MAT),Triangle(vec3(-0.270095, 0.611249, 0.197995), vec3(-0.316797, 0.610348, -0.104502), vec3(-0.325, 0.6, 0.0), MESH_MAT),Triangle(vec3(-0.334116, 0.031555, 0.172714), vec3(-0.355089, 0.011388, -0.006513), vec3(-0.176568, 0.018498, 0.321398), MESH_MAT),Triangle(vec3(-0.172714, 0.031555, -0.334116), vec3(0.0592, 0.012201, -0.355237), vec3(-0.321398, 0.018498, -0.176568), MESH_MAT),Triangle(vec3(-0.70093, 0.60071, -0.00908), vec3(-0.796838, 0.608175, 0.0), vec3(-0.707075, 0.604365, 0.027655), MESH_MAT),Triangle(vec3(0.446255, 0.026361, -0.446256), vec3(0.446256, -1.25306, 0.446255), vec3(0.446255, -1.25306, -0.446256), MESH_MAT),Triangle(vec3(0.446256, 0.026361, 0.446255), vec3(-0.446255, -1.25306, 0.446256), vec3(0.446256, -1.25306, 0.446255), MESH_MAT),Triangle(vec3(-0.446255, 0.026361, 0.446256), vec3(-0.446256, -1.25306, -0.446255), vec3(-0.446255, -1.25306, 0.446256), MESH_MAT),Triangle(vec3(-0.446256, 0.026361, -0.446255), vec3(0.446255, -1.25306, -0.446256), vec3(-0.446256, -1.25306, -0.446255), MESH_MAT),Triangle(vec3(-0.446255, -1.25306, 0.446256), vec3(0.446255, -1.25306, -0.446256), vec3(0.446256, -1.25306, 0.446255), MESH_MAT),Triangle(vec3(0.446256, 0.026361, 0.446255), vec3(-0.446256, 0.026361, -0.446255), vec3(-0.446255, 0.026361, 0.446256), MESH_MAT),Triangle(vec3(0.446255, 0.026361, -0.446256), vec3(0.446256, 0.026361, 0.446255), vec3(0.446256, -1.25306, 0.446255), MESH_MAT),Triangle(vec3(0.446256, 0.026361, 0.446255), vec3(-0.446255, 0.026361, 0.446256), vec3(-0.446255, -1.25306, 0.446256), MESH_MAT),Triangle(vec3(-0.446255, 0.026361, 0.446256), vec3(-0.446256, 0.026361, -0.446255), vec3(-0.446256, -1.25306, -0.446255), MESH_MAT),Triangle(vec3(-0.446256, 0.026361, -0.446255), vec3(0.446255, 0.026361, -0.446256), vec3(0.446255, -1.25306, -0.446256), MESH_MAT),Triangle(vec3(-0.446255, -1.25306, 0.446256), vec3(-0.446256, -1.25306, -0.446255), vec3(0.446255, -1.25306, -0.446256), MESH_MAT),Triangle(vec3(0.446256, 0.026361, 0.446255), vec3(0.446255, 0.026361, -0.446256), vec3(-0.446256, 0.026361, -0.446255), MESH_MAT)\n);\n    // Doesn't matter since we're in a box\nvec3 sky_color(vec3 d) {\n    return vec3(0.0);\n}\n\n// basic camera ray\nRay camera(vec2 ndc) {\n    Ray cam; \n    cam.origin    = vec3(0.0, 0.5, -1.2);\n    cam.direction = normalize(vec3(ndc, 1.0));\n    \n    return cam;\n}\n#endif\n\n#ifdef SCENE_CORNELL_3_STANFORD\n\n#define LIGHT_POS vec3(0.0, 2.2, 0.0)\n#define LIGHT_RADIUS 0.5\n#define LIGHT_STRENGTH 40.0\n#define LIGHT_COLOR vec3(1.0, 1.0, 1.0)\n\n#define N_SPHERES 7\nconst Sphere SPHERES[N_SPHERES] = Sphere[](\n    Sphere(vec3(0.0, -1000.5, 0.0), 1000.0, Material(vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), 1.0)), // Ground\n    Sphere(vec3(1001.5, 0.0, 0.0), 1000.0, Material(vec3(0.0, 0.8, 0.0), vec3(0.0, 0.0, 0.0), 1.0)), // Right wall\n    Sphere(vec3(-1001.5, 0.0, 0.0), 1000.0, Material(vec3(0.8, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 1.0)), // Left wall\n    Sphere(vec3(0.0, 0.0, 1001), 1000.0, Material(vec3(0.0, 0.0, 0.8), vec3(0.0, 0.0, 0.0), 1.0)), // Back wall\n    Sphere(vec3(0.0, 0.0, -1002), 1000.0, Material(vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), 1.0)), // Front wall\n    Sphere(vec3(0.0, 1002, 0.0), 1000.0, Material(vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), 1.0)), // Ceiling\n\n    Sphere(LIGHT_POS, LIGHT_RADIUS, Material(vec3(0.0, 0.0, 0.0), LIGHT_COLOR * LIGHT_STRENGTH, 1.0)) // Light sphere\n);\n\n#define MESH_MAT Material(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), 1.0)\n#define N_TRIANGLES 357\nconst Triangle TRIS[N_TRIANGLES] = Triangle[](\n    Triangle(vec3(0.5, 0.183406, -0.5), vec3(0.5, -0.816594, 0.5), vec3(0.5, -0.816594, -0.5), MESH_MAT),Triangle(vec3(0.5, 0.183406, 0.5), vec3(-0.5, -0.816594, 0.5), vec3(0.5, -0.816594, 0.5), MESH_MAT),Triangle(vec3(-0.5, 0.183406, 0.5), vec3(-0.5, -0.816594, -0.5), vec3(-0.5, -0.816594, 0.5), MESH_MAT),Triangle(vec3(-0.5, 0.183406, -0.5), vec3(0.5, -0.816594, -0.5), vec3(-0.5, -0.816594, -0.5), MESH_MAT),Triangle(vec3(0.5, 0.183406, 0.5), vec3(-0.5, 0.183406, -0.5), vec3(-0.5, 0.183406, 0.5), MESH_MAT),Triangle(vec3(0.362396, 0.549906, -0.111638), vec3(0.352736, 0.549814, -0.010589), vec3(0.387782, 0.482593, -0.109372), MESH_MAT),Triangle(vec3(-0.059392, 0.65576, -0.004542), vec3(0.074057, 0.633076, -0.055413), vec3(-0.013012, 0.625487, -0.167894), MESH_MAT),Triangle(vec3(0.212764, 0.705754, -0.14764), vec3(0.171646, 0.592425, -0.160019), vec3(0.15368, 0.647185, -0.073041), MESH_MAT),Triangle(vec3(-0.203962, 0.618832, -0.065334), vec3(-0.098662, 0.658875, -0.100965), vec3(-0.150085, 0.612643, -0.165824), MESH_MAT),Triangle(vec3(0.074871, 0.184721, -0.087058), vec3(0.098173, 0.175957, -0.172192), vec3(0.096535, 0.167887, -0.04525), MESH_MAT),Triangle(vec3(0.385579, 0.742502, -0.139541), vec3(0.385201, 0.753052, -0.062109), vec3(0.391541, 0.677659, -0.082719), MESH_MAT),Triangle(vec3(0.352736, 0.549814, -0.010589), vec3(0.362396, 0.549906, -0.111638), vec3(0.410932, 0.592365, -0.085967), MESH_MAT),Triangle(vec3(0.385201, 0.753052, -0.062109), vec3(0.292536, 0.781958, -0.011948), vec3(0.319153, 0.751898, 0.026741), MESH_MAT),Triangle(vec3(-0.059392, 0.65576, -0.004542), vec3(-0.098662, 0.658875, -0.100965), vec3(-0.157191, 0.633864, 0.005751), MESH_MAT),Triangle(vec3(0.323986, 0.561269, -0.242568), vec3(0.266756, 0.590052, -0.264737), vec3(0.337285, 0.655444, -0.267331), MESH_MAT),Triangle(vec3(0.2281, 0.47862, -0.226023), vec3(0.292534, 0.534289, -0.188198), vec3(0.30518, 0.460187, -0.206164), MESH_MAT),Triangle(vec3(-0.144218, 0.234272, -0.220998), vec3(-0.067673, 0.26109, -0.27042), vec3(0.016246, 0.247408, -0.247708), MESH_MAT),Triangle(vec3(0.30518, 0.460187, -0.206164), vec3(0.267049, 0.373613, -0.203833), vec3(0.2281, 0.47862, -0.226023), MESH_MAT),Triangle(vec3(-0.114724, 0.365276, -0.278493), vec3(-0.050032, 0.34676, -0.29179), vec3(-0.067673, 0.26109, -0.27042), MESH_MAT),Triangle(vec3(0.2281, 0.47862, -0.226023), vec3(0.171646, 0.592425, -0.160019), vec3(0.292534, 0.534289, -0.188198), MESH_MAT),Triangle(vec3(-0.04316, 0.491362, -0.268452), vec3(-0.117347, 0.439528, -0.279151), vec3(-0.152486, 0.514627, -0.231943), MESH_MAT),Triangle(vec3(-0.098662, 0.658875, -0.100965), vec3(-0.059392, 0.65576, -0.004542), vec3(-0.013012, 0.625487, -0.167894), MESH_MAT),Triangle(vec3(0.357676, 0.475485, 0.020862), vec3(0.273186, 0.583892, 0.049482), vec3(0.304708, 0.440428, 0.083115), MESH_MAT),Triangle(vec3(-0.020466, 0.859784, 0.139961), vec3(0.126361, 0.819345, 0.068201), vec3(0.007918, 0.939911, 0.118217), MESH_MAT),Triangle(vec3(0.267049, 0.373613, -0.203833), vec3(0.185607, 0.449029, -0.229979), vec3(0.2281, 0.47862, -0.226023), MESH_MAT),Triangle(vec3(0.375577, 0.696178, -0.195693), vec3(0.385579, 0.742502, -0.139541), vec3(0.391541, 0.677659, -0.082719), MESH_MAT),Triangle(vec3(0.331801, 0.36684, 0.011608), vec3(0.246268, 0.360992, 0.082906), vec3(0.215546, 0.301405, 0.024583), MESH_MAT),Triangle(vec3(0.185607, 0.449029, -0.229979), vec3(0.171646, 0.592425, -0.160019), vec3(0.2281, 0.47862, -0.226023), MESH_MAT),Triangle(vec3(-0.150085, 0.612643, -0.165824), vec3(-0.069865, 0.507934, -0.220294), vec3(-0.152486, 0.514627, -0.231943), MESH_MAT),Triangle(vec3(0.267049, 0.373613, -0.203833), vec3(0.141412, 0.354538, -0.214361), vec3(0.185607, 0.449029, -0.229979), MESH_MAT),Triangle(vec3(0.03305, 0.453248, -0.283001), vec3(-0.117347, 0.439528, -0.279151), vec3(-0.04316, 0.491362, -0.268452), MESH_MAT),Triangle(vec3(-0.276686, 0.374743, 0.03664), vec3(-0.291695, 0.490704, -0.023125), vec3(-0.305576, 0.373212, -0.040783), MESH_MAT),Triangle(vec3(0.216949, 0.183398, -0.245842), vec3(0.129681, 0.232976, -0.200208), vec3(0.185811, 0.255815, -0.174283), MESH_MAT),Triangle(vec3(0.137197, 0.47532, -0.21665), vec3(0.171646, 0.592425, -0.160019), vec3(0.185607, 0.449029, -0.229979), MESH_MAT),Triangle(vec3(0.21536, 0.779135, -0.057927), vec3(0.160816, 0.783611, -0.036162), vec3(0.086318, 0.887022, 0.016255), MESH_MAT),Triangle(vec3(-0.114724, 0.365276, -0.278493), vec3(-0.117347, 0.439528, -0.279151), vec3(-0.050032, 0.34676, -0.29179), MESH_MAT),Triangle(vec3(0.137197, 0.47532, -0.21665), vec3(0.185607, 0.449029, -0.229979), vec3(0.141412, 0.354538, -0.214361), MESH_MAT),Triangle(vec3(-0.199353, 0.182421, -0.125183), vec3(-0.292781, 0.26389, -0.171092), vec3(-0.234868, 0.24988, -0.161808), MESH_MAT),Triangle(vec3(0.137197, 0.47532, -0.21665), vec3(0.091376, 0.596168, -0.151104), vec3(0.171646, 0.592425, -0.160019), MESH_MAT),Triangle(vec3(0.129681, 0.232976, -0.200208), vec3(0.141412, 0.354538, -0.214361), vec3(0.185811, 0.255815, -0.174283), MESH_MAT),Triangle(vec3(0.069617, 0.279744, -0.177789), vec3(0.141412, 0.354538, -0.214361), vec3(0.129681, 0.232976, -0.200208), MESH_MAT),Triangle(vec3(0.090798, 0.414595, -0.210227), vec3(0.137197, 0.47532, -0.21665), vec3(0.141412, 0.354538, -0.214361), MESH_MAT),Triangle(vec3(0.053113, 0.491003, -0.226095), vec3(0.091376, 0.596168, -0.151104), vec3(0.137197, 0.47532, -0.21665), MESH_MAT),Triangle(vec3(-0.04316, 0.491362, -0.268452), vec3(-0.152486, 0.514627, -0.231943), vec3(-0.069865, 0.507934, -0.220294), MESH_MAT),Triangle(vec3(0.090798, 0.414595, -0.210227), vec3(0.053113, 0.491003, -0.226095), vec3(0.137197, 0.47532, -0.21665), MESH_MAT),Triangle(vec3(0.069617, 0.279744, -0.177789), vec3(0.090798, 0.414595, -0.210227), vec3(0.141412, 0.354538, -0.214361), MESH_MAT),Triangle(vec3(-0.050032, 0.34676, -0.29179), vec3(-0.117347, 0.439528, -0.279151), vec3(0.03305, 0.453248, -0.283001), MESH_MAT),Triangle(vec3(0.259169, 0.223479, -0.163731), vec3(0.188193, 0.233623, -0.089333), vec3(0.250665, 0.174116, -0.100404), MESH_MAT),Triangle(vec3(-0.013012, 0.625487, -0.167894), vec3(0.091376, 0.596168, -0.151104), vec3(0.053113, 0.491003, -0.226095), MESH_MAT),Triangle(vec3(0.018997, 0.812234, 0.07921), vec3(-0.020466, 0.859784, 0.139961), vec3(-0.00112, 0.810283, 0.054013), MESH_MAT),Triangle(vec3(-0.157191, 0.633864, 0.005751), vec3(-0.098662, 0.658875, -0.100965), vec3(-0.203962, 0.618832, -0.065334), MESH_MAT),Triangle(vec3(-0.096226, 0.167059, -0.079861), vec3(-0.10164, 0.197004, -0.165343), vec3(-0.039482, 0.191432, -0.05586), MESH_MAT),Triangle(vec3(0.091376, 0.596168, -0.151104), vec3(-0.013012, 0.625487, -0.167894), vec3(0.074057, 0.633076, -0.055413), MESH_MAT),Triangle(vec3(-0.292781, 0.26389, -0.171092), vec3(-0.281899, 0.333827, -0.133303), vec3(-0.234868, 0.24988, -0.161808), MESH_MAT),Triangle(vec3(-0.098662, 0.658875, -0.100965), vec3(-0.013012, 0.625487, -0.167894), vec3(-0.150085, 0.612643, -0.165824), MESH_MAT),Triangle(vec3(0.016869, 0.323674, -0.266694), vec3(0.03305, 0.453248, -0.283001), vec3(0.046464, 0.408514, -0.283861), MESH_MAT),Triangle(vec3(-0.051289, 0.563098, -0.215935), vec3(-0.013012, 0.625487, -0.167894), vec3(0.053113, 0.491003, -0.226095), MESH_MAT),Triangle(vec3(0.016869, 0.323674, -0.266694), vec3(-0.050032, 0.34676, -0.29179), vec3(0.03305, 0.453248, -0.283001), MESH_MAT),Triangle(vec3(0.053113, 0.491003, -0.226095), vec3(-0.069865, 0.507934, -0.220294), vec3(-0.051289, 0.563098, -0.215935), MESH_MAT),Triangle(vec3(0.016246, 0.247408, -0.247708), vec3(-0.067673, 0.26109, -0.27042), vec3(0.016869, 0.323674, -0.266694), MESH_MAT),Triangle(vec3(-0.067673, 0.26109, -0.27042), vec3(-0.050032, 0.34676, -0.29179), vec3(0.016869, 0.323674, -0.266694), MESH_MAT),Triangle(vec3(-0.069865, 0.507934, -0.220294), vec3(0.053113, 0.491003, -0.226095), vec3(-0.04316, 0.491362, -0.268452), MESH_MAT),Triangle(vec3(-0.291695, 0.490704, -0.023125), vec3(-0.256291, 0.423615, 0.079129), vec3(-0.233824, 0.536232, 0.056396), MESH_MAT),Triangle(vec3(0.186887, 0.738968, -0.063496), vec3(0.19213, 0.713509, -0.005638), vec3(0.107978, 0.758046, 0.004797), MESH_MAT),Triangle(vec3(0.266756, 0.590052, -0.264737), vec3(0.268901, 0.739683, -0.209514), vec3(0.337285, 0.655444, -0.267331), MESH_MAT),Triangle(vec3(0.266756, 0.590052, -0.264737), vec3(0.212764, 0.705754, -0.14764), vec3(0.268901, 0.739683, -0.209514), MESH_MAT),Triangle(vec3(0.292534, 0.534289, -0.188198), vec3(0.236239, 0.615671, -0.215522), vec3(0.266756, 0.590052, -0.264737), MESH_MAT),Triangle(vec3(0.368073, 0.422161, -0.005827), vec3(0.351141, 0.392923, -0.135184), vec3(0.387782, 0.482593, -0.109372), MESH_MAT),Triangle(vec3(0.236239, 0.615671, -0.215522), vec3(0.212764, 0.705754, -0.14764), vec3(0.266756, 0.590052, -0.264737), MESH_MAT),Triangle(vec3(-0.327424, 0.270177, 0.028727), vec3(-0.364637, 0.337168, -0.013378), vec3(-0.350233, 0.241543, -0.10102), MESH_MAT),Triangle(vec3(-0.114724, 0.365276, -0.278493), vec3(-0.180101, 0.403586, -0.251679), vec3(-0.117347, 0.439528, -0.279151), MESH_MAT),Triangle(vec3(0.292534, 0.534289, -0.188198), vec3(0.171646, 0.592425, -0.160019), vec3(0.236239, 0.615671, -0.215522), MESH_MAT),Triangle(vec3(0.062931, 0.177577, -0.271961), vec3(0.016246, 0.247408, -0.247708), vec3(0.071902, 0.227024, -0.266072), MESH_MAT),Triangle(vec3(0.107978, 0.758046, 0.004797), vec3(-0.00112, 0.810283, 0.054013), vec3(0.160816, 0.783611, -0.036162), MESH_MAT),Triangle(vec3(0.171646, 0.592425, -0.160019), vec3(0.212764, 0.705754, -0.14764), vec3(0.236239, 0.615671, -0.215522), MESH_MAT),Triangle(vec3(-0.234868, 0.24988, -0.161808), vec3(-0.160306, 0.289153, -0.242056), vec3(-0.144218, 0.234272, -0.220998), MESH_MAT),Triangle(vec3(0.21606, 0.767988, -0.155961), vec3(0.268901, 0.739683, -0.209514), vec3(0.212764, 0.705754, -0.14764), MESH_MAT),Triangle(vec3(-0.350233, 0.241543, -0.10102), vec3(-0.364637, 0.337168, -0.013378), vec3(-0.364106, 0.346302, -0.106801), MESH_MAT),Triangle(vec3(-0.152536, 0.178287, -0.215175), vec3(-0.234868, 0.24988, -0.161808), vec3(-0.144218, 0.234272, -0.220998), MESH_MAT),Triangle(vec3(-0.00112, 0.810283, 0.054013), vec3(0.007918, 0.939911, 0.118217), vec3(0.160816, 0.783611, -0.036162), MESH_MAT),Triangle(vec3(0.007918, 0.939911, 0.118217), vec3(0.086318, 0.887022, 0.016255), vec3(0.160816, 0.783611, -0.036162), MESH_MAT),Triangle(vec3(-0.305576, 0.373212, -0.040783), vec3(-0.291695, 0.490704, -0.023125), vec3(-0.288008, 0.45592, -0.120457), MESH_MAT),Triangle(vec3(-0.160306, 0.289153, -0.242056), vec3(-0.180101, 0.403586, -0.251679), vec3(-0.114724, 0.365276, -0.278493), MESH_MAT),Triangle(vec3(-0.281899, 0.333827, -0.133303), vec3(-0.257466, 0.337239, -0.181975), vec3(-0.234868, 0.24988, -0.161808), MESH_MAT),Triangle(vec3(-0.180101, 0.403586, -0.251679), vec3(-0.242617, 0.458769, -0.199365), vec3(-0.152486, 0.514627, -0.231943), MESH_MAT),Triangle(vec3(-0.144218, 0.234272, -0.220998), vec3(0.016246, 0.247408, -0.247708), vec3(0.062931, 0.177577, -0.271961), MESH_MAT),Triangle(vec3(0.245825, 0.716175, 0.03344), vec3(0.273493, 0.777428, 0.276229), vec3(0.238478, 0.842075, 0.306499), MESH_MAT),Triangle(vec3(-0.257466, 0.337239, -0.181975), vec3(-0.288008, 0.45592, -0.120457), vec3(-0.242617, 0.458769, -0.199365), MESH_MAT),Triangle(vec3(-0.257466, 0.337239, -0.181975), vec3(-0.242617, 0.458769, -0.199365), vec3(-0.180101, 0.403586, -0.251679), MESH_MAT),Triangle(vec3(-0.257466, 0.337239, -0.181975), vec3(-0.180101, 0.403586, -0.251679), vec3(-0.160306, 0.289153, -0.242056), MESH_MAT),Triangle(vec3(-0.234868, 0.24988, -0.161808), vec3(-0.257466, 0.337239, -0.181975), vec3(-0.160306, 0.289153, -0.242056), MESH_MAT),Triangle(vec3(0.229873, 0.243325, -0.043296), vec3(0.211259, 0.280859, -0.052263), vec3(0.215546, 0.301405, 0.024583), MESH_MAT),Triangle(vec3(-0.136813, 0.174497, 0.108037), vec3(0.137027, 0.168355, 0.157235), vec3(0.025993, 0.22367, 0.139888), MESH_MAT),Triangle(vec3(0.15368, 0.647185, -0.073041), vec3(0.19213, 0.713509, -0.005638), vec3(0.186887, 0.738968, -0.063496), MESH_MAT),Triangle(vec3(0.186887, 0.738968, -0.063496), vec3(0.160816, 0.783611, -0.036162), vec3(0.21536, 0.779135, -0.057927), MESH_MAT),Triangle(vec3(0.107978, 0.758046, 0.004797), vec3(0.160816, 0.783611, -0.036162), vec3(0.186887, 0.738968, -0.063496), MESH_MAT),Triangle(vec3(-0.305576, 0.373212, -0.040783), vec3(-0.257466, 0.337239, -0.181975), vec3(-0.281899, 0.333827, -0.133303), MESH_MAT),Triangle(vec3(-0.364106, 0.346302, -0.106801), vec3(-0.292781, 0.26389, -0.171092), vec3(-0.350233, 0.241543, -0.10102), MESH_MAT),Triangle(vec3(-0.117347, 0.439528, -0.279151), vec3(-0.180101, 0.403586, -0.251679), vec3(-0.152486, 0.514627, -0.231943), MESH_MAT),Triangle(vec3(-0.069865, 0.507934, -0.220294), vec3(-0.150085, 0.612643, -0.165824), vec3(-0.051289, 0.563098, -0.215935), MESH_MAT),Triangle(vec3(-0.256291, 0.423615, 0.079129), vec3(-0.291695, 0.490704, -0.023125), vec3(-0.276686, 0.374743, 0.03664), MESH_MAT),Triangle(vec3(-0.152486, 0.514627, -0.231943), vec3(-0.242617, 0.458769, -0.199365), vec3(-0.228712, 0.569285, -0.15157), MESH_MAT),Triangle(vec3(-0.152486, 0.514627, -0.231943), vec3(-0.228712, 0.569285, -0.15157), vec3(-0.150085, 0.612643, -0.165824), MESH_MAT),Triangle(vec3(-0.160306, 0.289153, -0.242056), vec3(-0.067673, 0.26109, -0.27042), vec3(-0.144218, 0.234272, -0.220998), MESH_MAT),Triangle(vec3(-0.166502, 0.175303, 0.014959), vec3(-0.170752, 0.172512, -0.039055), vec3(-0.10598, 0.178193, -0.021878), MESH_MAT),Triangle(vec3(-0.00112, 0.810283, 0.054013), vec3(0.107978, 0.758046, 0.004797), vec3(0.018997, 0.812234, 0.07921), MESH_MAT),Triangle(vec3(0.185811, 0.255815, -0.174283), vec3(0.218577, 0.29514, -0.099413), vec3(0.188193, 0.233623, -0.089333), MESH_MAT),Triangle(vec3(-0.020466, 0.859784, 0.139961), vec3(0.007918, 0.939911, 0.118217), vec3(-0.00112, 0.810283, 0.054013), MESH_MAT),Triangle(vec3(0.391541, 0.677659, -0.082719), vec3(0.385201, 0.753052, -0.062109), vec3(0.36033, 0.695769, -0.006685), MESH_MAT),Triangle(vec3(0.19213, 0.713509, -0.005638), vec3(0.15368, 0.647185, -0.073041), vec3(0.181319, 0.644357, 0.017247), MESH_MAT),Triangle(vec3(0.391541, 0.677659, -0.082719), vec3(0.36033, 0.695769, -0.006685), vec3(0.410932, 0.592365, -0.085967), MESH_MAT),Triangle(vec3(0.387782, 0.482593, -0.109372), vec3(0.352736, 0.549814, -0.010589), vec3(0.357676, 0.475485, 0.020862), MESH_MAT),Triangle(vec3(-0.168866, 0.224887, 0.1125), vec3(-0.254881, 0.286715, 0.037952), vec3(-0.166502, 0.175303, 0.014959), MESH_MAT),Triangle(vec3(0.245825, 0.716175, 0.03344), vec3(0.238478, 0.842075, 0.306499), vec3(0.239678, 0.793818, 0.11364), MESH_MAT),Triangle(vec3(-0.173063, 0.282673, 0.134147), vec3(-0.254881, 0.286715, 0.037952), vec3(-0.168866, 0.224887, 0.1125), MESH_MAT),Triangle(vec3(-0.152536, 0.178287, -0.215175), vec3(-0.199353, 0.182421, -0.125183), vec3(-0.234868, 0.24988, -0.161808), MESH_MAT),Triangle(vec3(-0.168866, 0.224887, 0.1125), vec3(-0.166502, 0.175303, 0.014959), vec3(-0.136813, 0.174497, 0.108037), MESH_MAT),Triangle(vec3(-0.173063, 0.282673, 0.134147), vec3(-0.256291, 0.423615, 0.079129), vec3(-0.254881, 0.286715, 0.037952), MESH_MAT),Triangle(vec3(-0.039482, 0.191432, -0.05586), vec3(0.079803, 0.190642, -0.019812), vec3(0.098698, 0.190798, 0.002408), MESH_MAT),Triangle(vec3(-0.254881, 0.286715, 0.037952), vec3(-0.256291, 0.423615, 0.079129), vec3(-0.276686, 0.374743, 0.03664), MESH_MAT),Triangle(vec3(-0.288008, 0.45592, -0.120457), vec3(-0.228712, 0.569285, -0.15157), vec3(-0.242617, 0.458769, -0.199365), MESH_MAT),Triangle(vec3(-0.276686, 0.374743, 0.03664), vec3(-0.305576, 0.373212, -0.040783), vec3(-0.254881, 0.286715, 0.037952), MESH_MAT),Triangle(vec3(0.229873, 0.243325, -0.043296), vec3(0.250665, 0.174116, -0.100404), vec3(0.188193, 0.233623, -0.089333), MESH_MAT),Triangle(vec3(0.212764, 0.705754, -0.14764), vec3(0.186887, 0.738968, -0.063496), vec3(0.21606, 0.767988, -0.155961), MESH_MAT),Triangle(vec3(-0.291695, 0.490704, -0.023125), vec3(-0.228712, 0.569285, -0.15157), vec3(-0.288008, 0.45592, -0.120457), MESH_MAT),Triangle(vec3(-0.114724, 0.365276, -0.278493), vec3(-0.067673, 0.26109, -0.27042), vec3(-0.160306, 0.289153, -0.242056), MESH_MAT),Triangle(vec3(-0.013012, 0.625487, -0.167894), vec3(-0.051289, 0.563098, -0.215935), vec3(-0.150085, 0.612643, -0.165824), MESH_MAT),Triangle(vec3(-0.210573, 0.168274, -0.013991), vec3(-0.327424, 0.270177, 0.028727), vec3(-0.350233, 0.241543, -0.10102), MESH_MAT),Triangle(vec3(0.15368, 0.647185, -0.073041), vec3(0.186887, 0.738968, -0.063496), vec3(0.212764, 0.705754, -0.14764), MESH_MAT),Triangle(vec3(0.286647, 0.873747, 0.200479), vec3(0.327255, 0.885993, 0.244963), vec3(0.292536, 0.781958, -0.011948), MESH_MAT),Triangle(vec3(0.351141, 0.392923, -0.135184), vec3(0.368073, 0.422161, -0.005827), vec3(0.331801, 0.36684, 0.011608), MESH_MAT),Triangle(vec3(0.309039, 0.782641, -0.127481), vec3(0.385579, 0.742502, -0.139541), vec3(0.268901, 0.739683, -0.209514), MESH_MAT),Triangle(vec3(0.286647, 0.873747, 0.200479), vec3(0.292536, 0.781958, -0.011948), vec3(0.239678, 0.793818, 0.11364), MESH_MAT),Triangle(vec3(-0.305576, 0.373212, -0.040783), vec3(-0.364106, 0.346302, -0.106801), vec3(-0.364637, 0.337168, -0.013378), MESH_MAT),Triangle(vec3(-0.305576, 0.373212, -0.040783), vec3(-0.281899, 0.333827, -0.133303), vec3(-0.364106, 0.346302, -0.106801), MESH_MAT),Triangle(vec3(-0.305576, 0.373212, -0.040783), vec3(-0.288008, 0.45592, -0.120457), vec3(-0.257466, 0.337239, -0.181975), MESH_MAT),Triangle(vec3(0.385201, 0.753052, -0.062109), vec3(0.309039, 0.782641, -0.127481), vec3(0.292536, 0.781958, -0.011948), MESH_MAT),Triangle(vec3(0.152295, 0.239825, 0.05623), vec3(0.094689, 0.267498, 0.049501), vec3(0.062239, 0.247316, 0.138586), MESH_MAT),Triangle(vec3(0.215546, 0.301405, 0.024583), vec3(0.246268, 0.360992, 0.082906), vec3(0.166991, 0.36131, 0.085108), MESH_MAT),Triangle(vec3(0.309039, 0.782641, -0.127481), vec3(0.268901, 0.739683, -0.209514), vec3(0.21606, 0.767988, -0.155961), MESH_MAT),Triangle(vec3(0.074057, 0.633076, -0.055413), vec3(0.15368, 0.647185, -0.073041), vec3(0.091376, 0.596168, -0.151104), MESH_MAT),Triangle(vec3(0.091376, 0.596168, -0.151104), vec3(0.15368, 0.647185, -0.073041), vec3(0.171646, 0.592425, -0.160019), MESH_MAT),Triangle(vec3(0.239678, 0.793818, 0.11364), vec3(0.292536, 0.781958, -0.011948), vec3(0.245825, 0.716175, 0.03344), MESH_MAT),Triangle(vec3(0.309039, 0.782641, -0.127481), vec3(0.21606, 0.767988, -0.155961), vec3(0.21536, 0.779135, -0.057927), MESH_MAT),Triangle(vec3(0.309039, 0.782641, -0.127481), vec3(0.385201, 0.753052, -0.062109), vec3(0.385579, 0.742502, -0.139541), MESH_MAT),Triangle(vec3(0.292536, 0.781958, -0.011948), vec3(0.309039, 0.782641, -0.127481), vec3(0.21536, 0.779135, -0.057927), MESH_MAT),Triangle(vec3(-0.291695, 0.490704, -0.023125), vec3(-0.203962, 0.618832, -0.065334), vec3(-0.228712, 0.569285, -0.15157), MESH_MAT),Triangle(vec3(0.238478, 0.842075, 0.306499), vec3(0.269382, 0.910315, 0.298144), vec3(0.286647, 0.873747, 0.200479), MESH_MAT),Triangle(vec3(0.094689, 0.267498, 0.049501), vec3(0.152295, 0.239825, 0.05623), vec3(0.166991, 0.36131, 0.085108), MESH_MAT),Triangle(vec3(-0.233824, 0.536232, 0.056396), vec3(-0.203962, 0.618832, -0.065334), vec3(-0.291695, 0.490704, -0.023125), MESH_MAT),Triangle(vec3(0.21536, 0.779135, -0.057927), vec3(0.21606, 0.767988, -0.155961), vec3(0.186887, 0.738968, -0.063496), MESH_MAT),Triangle(vec3(-0.203962, 0.618832, -0.065334), vec3(-0.150085, 0.612643, -0.165824), vec3(-0.228712, 0.569285, -0.15157), MESH_MAT),Triangle(vec3(0.239678, 0.793818, 0.11364), vec3(0.238478, 0.842075, 0.306499), vec3(0.286647, 0.873747, 0.200479), MESH_MAT),Triangle(vec3(0.181319, 0.644357, 0.017247), vec3(0.15368, 0.647185, -0.073041), vec3(0.074057, 0.633076, -0.055413), MESH_MAT),Triangle(vec3(0.368073, 0.422161, -0.005827), vec3(0.387782, 0.482593, -0.109372), vec3(0.357676, 0.475485, 0.020862), MESH_MAT),Triangle(vec3(0.007918, 0.939911, 0.118217), vec3(0.149563, 0.861575, 0.028843), vec3(0.086318, 0.887022, 0.016255), MESH_MAT),Triangle(vec3(0.269382, 0.910315, 0.298144), vec3(0.327255, 0.885993, 0.244963), vec3(0.286647, 0.873747, 0.200479), MESH_MAT),Triangle(vec3(0.185811, 0.255815, -0.174283), vec3(0.259169, 0.223479, -0.163731), vec3(0.216949, 0.183398, -0.245842), MESH_MAT),Triangle(vec3(0.107978, 0.758046, 0.004797), vec3(0.19213, 0.713509, -0.005638), vec3(0.018997, 0.812234, 0.07921), MESH_MAT),Triangle(vec3(0.03305, 0.453248, -0.283001), vec3(0.053113, 0.491003, -0.226095), vec3(0.090798, 0.414595, -0.210227), MESH_MAT),Triangle(vec3(0.185976, 0.317338, -0.170419), vec3(0.185811, 0.255815, -0.174283), vec3(0.141412, 0.354538, -0.214361), MESH_MAT),Triangle(vec3(0.016246, 0.247408, -0.247708), vec3(0.016869, 0.323674, -0.266694), vec3(0.069617, 0.279744, -0.177789), MESH_MAT),Triangle(vec3(0.069617, 0.279744, -0.177789), vec3(0.129681, 0.232976, -0.200208), vec3(0.071902, 0.227024, -0.266072), MESH_MAT),Triangle(vec3(0.016869, 0.323674, -0.266694), vec3(0.046464, 0.408514, -0.283861), vec3(0.069617, 0.279744, -0.177789), MESH_MAT),Triangle(vec3(0.130785, 0.17467, -0.209267), vec3(0.071902, 0.227024, -0.266072), vec3(0.129681, 0.232976, -0.200208), MESH_MAT),Triangle(vec3(0.18522, 0.280924, -0.086853), vec3(0.188193, 0.233623, -0.089333), vec3(0.218577, 0.29514, -0.099413), MESH_MAT),Triangle(vec3(0.185811, 0.255815, -0.174283), vec3(0.185976, 0.317338, -0.170419), vec3(0.218577, 0.29514, -0.099413), MESH_MAT),Triangle(vec3(0.069617, 0.279744, -0.177789), vec3(0.046464, 0.408514, -0.283861), vec3(0.090798, 0.414595, -0.210227), MESH_MAT),Triangle(vec3(0.069617, 0.279744, -0.177789), vec3(0.071902, 0.227024, -0.266072), vec3(0.016246, 0.247408, -0.247708), MESH_MAT),Triangle(vec3(0.337285, 0.655444, -0.267331), vec3(0.268901, 0.739683, -0.209514), vec3(0.385579, 0.742502, -0.139541), MESH_MAT),Triangle(vec3(0.216949, 0.183398, -0.245842), vec3(0.130785, 0.17467, -0.209267), vec3(0.129681, 0.232976, -0.200208), MESH_MAT),Triangle(vec3(-0.292781, 0.26389, -0.171092), vec3(-0.364106, 0.346302, -0.106801), vec3(-0.281899, 0.333827, -0.133303), MESH_MAT),Triangle(vec3(0.301093, 0.175622, -0.038996), vec3(0.229873, 0.243325, -0.043296), vec3(0.294254, 0.171391, 0.027213), MESH_MAT),Triangle(vec3(0.094689, 0.267498, 0.049501), vec3(0.166991, 0.36131, 0.085108), vec3(0.107609, 0.441088, 0.121235), MESH_MAT),Triangle(vec3(0.271874, 0.178675, -0.190704), vec3(0.259169, 0.223479, -0.163731), vec3(0.250665, 0.174116, -0.100404), MESH_MAT),Triangle(vec3(0.387782, 0.482593, -0.109372), vec3(0.30518, 0.460187, -0.206164), vec3(0.292534, 0.534289, -0.188198), MESH_MAT),Triangle(vec3(0.398941, 0.574632, -0.211248), vec3(0.323986, 0.561269, -0.242568), vec3(0.337285, 0.655444, -0.267331), MESH_MAT),Triangle(vec3(0.188193, 0.233623, -0.089333), vec3(0.18522, 0.280924, -0.086853), vec3(0.211259, 0.280859, -0.052263), MESH_MAT),Triangle(vec3(0.375577, 0.696178, -0.195693), vec3(0.337285, 0.655444, -0.267331), vec3(0.385579, 0.742502, -0.139541), MESH_MAT),Triangle(vec3(0.216949, 0.183398, -0.245842), vec3(0.259169, 0.223479, -0.163731), vec3(0.271874, 0.178675, -0.190704), MESH_MAT),Triangle(vec3(0.21536, 0.779135, -0.057927), vec3(0.086318, 0.887022, 0.016255), vec3(0.149563, 0.861575, 0.028843), MESH_MAT),Triangle(vec3(0.250665, 0.174116, -0.100404), vec3(0.229873, 0.243325, -0.043296), vec3(0.301093, 0.175622, -0.038996), MESH_MAT),Triangle(vec3(0.107609, 0.441088, 0.121235), vec3(0.200558, 0.477239, 0.112074), vec3(0.065221, 0.547188, 0.103696), MESH_MAT),Triangle(vec3(0.090798, 0.414595, -0.210227), vec3(0.046464, 0.408514, -0.283861), vec3(0.03305, 0.453248, -0.283001), MESH_MAT),Triangle(vec3(0.183732, 0.168592, 0.067833), vec3(0.214293, 0.23531, 0.023866), vec3(0.215546, 0.301405, 0.024583), MESH_MAT),Triangle(vec3(0.267049, 0.373613, -0.203833), vec3(0.30518, 0.460187, -0.206164), vec3(0.351141, 0.392923, -0.135184), MESH_MAT),Triangle(vec3(0.387782, 0.482593, -0.109372), vec3(0.292534, 0.534289, -0.188198), vec3(0.362396, 0.549906, -0.111638), MESH_MAT),Triangle(vec3(0.337285, 0.655444, -0.267331), vec3(0.375577, 0.696178, -0.195693), vec3(0.398941, 0.574632, -0.211248), MESH_MAT),Triangle(vec3(0.30518, 0.460187, -0.206164), vec3(0.387782, 0.482593, -0.109372), vec3(0.351141, 0.392923, -0.135184), MESH_MAT),Triangle(vec3(0.03305, 0.453248, -0.283001), vec3(-0.04316, 0.491362, -0.268452), vec3(0.053113, 0.491003, -0.226095), MESH_MAT),Triangle(vec3(0.229873, 0.243325, -0.043296), vec3(0.188193, 0.233623, -0.089333), vec3(0.211259, 0.280859, -0.052263), MESH_MAT),Triangle(vec3(0.214293, 0.23531, 0.023866), vec3(0.183732, 0.168592, 0.067833), vec3(0.294254, 0.171391, 0.027213), MESH_MAT),Triangle(vec3(0.269382, 0.910315, 0.298144), vec3(0.324657, 0.817069, 0.153857), vec3(0.327255, 0.885993, 0.244963), MESH_MAT),Triangle(vec3(0.273493, 0.777428, 0.276229), vec3(0.324657, 0.817069, 0.153857), vec3(0.269382, 0.910315, 0.298144), MESH_MAT),Triangle(vec3(0.327255, 0.885993, 0.244963), vec3(0.324657, 0.817069, 0.153857), vec3(0.292536, 0.781958, -0.011948), MESH_MAT),Triangle(vec3(0.273493, 0.777428, 0.276229), vec3(0.319153, 0.751898, 0.026741), vec3(0.324657, 0.817069, 0.153857), MESH_MAT),Triangle(vec3(0.319153, 0.751898, 0.026741), vec3(0.273493, 0.777428, 0.276229), vec3(0.303702, 0.749047, 0.179161), MESH_MAT),Triangle(vec3(0.107609, 0.441088, 0.121235), vec3(0.036224, 0.453763, 0.190561), vec3(0.093153, 0.399664, 0.167451), MESH_MAT),Triangle(vec3(0.259169, 0.223479, -0.163731), vec3(0.185811, 0.255815, -0.174283), vec3(0.188193, 0.233623, -0.089333), MESH_MAT),Triangle(vec3(0.062239, 0.247316, 0.138586), vec3(0.093153, 0.399664, 0.167451), vec3(0.02551, 0.326473, 0.190923), MESH_MAT),Triangle(vec3(0.410932, 0.592365, -0.085967), vec3(0.398941, 0.574632, -0.211248), vec3(0.391541, 0.677659, -0.082719), MESH_MAT),Triangle(vec3(0.232218, 0.773804, -0.002178), vec3(0.149563, 0.861575, 0.028843), vec3(0.126361, 0.819345, 0.068201), MESH_MAT),Triangle(vec3(0.062239, 0.247316, 0.138586), vec3(0.094689, 0.267498, 0.049501), vec3(0.093153, 0.399664, 0.167451), MESH_MAT),Triangle(vec3(-0.083438, 0.576525, 0.096248), vec3(0.065221, 0.547188, 0.103696), vec3(-0.00778, 0.61798, 0.043527), MESH_MAT),Triangle(vec3(0.093153, 0.399664, 0.167451), vec3(0.094689, 0.267498, 0.049501), vec3(0.107609, 0.441088, 0.121235), MESH_MAT),Triangle(vec3(0.324657, 0.817069, 0.153857), vec3(0.319153, 0.751898, 0.026741), vec3(0.292536, 0.781958, -0.011948), MESH_MAT),Triangle(vec3(0.183732, 0.168592, 0.067833), vec3(0.152295, 0.239825, 0.05623), vec3(0.137027, 0.168355, 0.157235), MESH_MAT),Triangle(vec3(-0.00778, 0.61798, 0.043527), vec3(0.122386, 0.618535, 0.044929), vec3(0.074057, 0.633076, -0.055413), MESH_MAT),Triangle(vec3(0.289604, 0.711879, 0.039908), vec3(0.319153, 0.751898, 0.026741), vec3(0.303702, 0.749047, 0.179161), MESH_MAT),Triangle(vec3(0.398941, 0.574632, -0.211248), vec3(0.375577, 0.696178, -0.195693), vec3(0.391541, 0.677659, -0.082719), MESH_MAT),Triangle(vec3(0.368073, 0.422161, -0.005827), vec3(0.357676, 0.475485, 0.020862), vec3(0.304708, 0.440428, 0.083115), MESH_MAT),Triangle(vec3(0.352736, 0.549814, -0.010589), vec3(0.273186, 0.583892, 0.049482), vec3(0.357676, 0.475485, 0.020862), MESH_MAT),Triangle(vec3(0.36033, 0.695769, -0.006685), vec3(0.385201, 0.753052, -0.062109), vec3(0.289604, 0.711879, 0.039908), MESH_MAT),Triangle(vec3(0.385201, 0.753052, -0.062109), vec3(0.319153, 0.751898, 0.026741), vec3(0.289604, 0.711879, 0.039908), MESH_MAT),Triangle(vec3(0.107609, 0.441088, 0.121235), vec3(-0.062308, 0.506301, 0.117343), vec3(0.036224, 0.453763, 0.190561), MESH_MAT),Triangle(vec3(0.137027, 0.168355, 0.157235), vec3(0.152295, 0.239825, 0.05623), vec3(0.062239, 0.247316, 0.138586), MESH_MAT),Triangle(vec3(0.229873, 0.243325, -0.043296), vec3(0.214293, 0.23531, 0.023866), vec3(0.294254, 0.171391, 0.027213), MESH_MAT),Triangle(vec3(0.232218, 0.773804, -0.002178), vec3(0.21536, 0.779135, -0.057927), vec3(0.149563, 0.861575, 0.028843), MESH_MAT),Triangle(vec3(0.229873, 0.243325, -0.043296), vec3(0.215546, 0.301405, 0.024583), vec3(0.214293, 0.23531, 0.023866), MESH_MAT),Triangle(vec3(-0.115264, 0.181389, 0.065295), vec3(0.091191, 0.185885, 0.092948), vec3(0.137027, 0.168355, 0.157235), MESH_MAT),Triangle(vec3(0.352736, 0.549814, -0.010589), vec3(0.410932, 0.592365, -0.085967), vec3(0.350381, 0.624555, 0.029195), MESH_MAT),Triangle(vec3(0.36033, 0.695769, -0.006685), vec3(0.350381, 0.624555, 0.029195), vec3(0.410932, 0.592365, -0.085967), MESH_MAT),Triangle(vec3(-0.350233, 0.241543, -0.10102), vec3(-0.199353, 0.182421, -0.125183), vec3(-0.210573, 0.168274, -0.013991), MESH_MAT),Triangle(vec3(0.232218, 0.773804, -0.002178), vec3(0.19213, 0.713509, -0.005638), vec3(0.245825, 0.716175, 0.03344), MESH_MAT),Triangle(vec3(-0.180952, 0.488165, 0.113129), vec3(-0.062308, 0.506301, 0.117343), vec3(-0.233824, 0.536232, 0.056396), MESH_MAT),Triangle(vec3(-0.062308, 0.506301, 0.117343), vec3(-0.08969, 0.470277, 0.163361), vec3(0.036224, 0.453763, 0.190561), MESH_MAT),Triangle(vec3(-0.180952, 0.488165, 0.113129), vec3(-0.233824, 0.536232, 0.056396), vec3(-0.256291, 0.423615, 0.079129), MESH_MAT),Triangle(vec3(0.098173, 0.175957, -0.172192), vec3(0.130785, 0.17467, -0.209267), vec3(0.149229, 0.170443, -0.135435), MESH_MAT),Triangle(vec3(0.109739, 0.178609, -0.103104), vec3(0.096535, 0.167887, -0.04525), vec3(0.149229, 0.170443, -0.135435), MESH_MAT),Triangle(vec3(0.074057, 0.633076, -0.055413), vec3(-0.059392, 0.65576, -0.004542), vec3(-0.00778, 0.61798, 0.043527), MESH_MAT),Triangle(vec3(0.232218, 0.773804, -0.002178), vec3(0.245825, 0.716175, 0.03344), vec3(0.292536, 0.781958, -0.011948), MESH_MAT),Triangle(vec3(-0.157191, 0.633864, 0.005751), vec3(-0.233824, 0.536232, 0.056396), vec3(-0.083438, 0.576525, 0.096248), MESH_MAT),Triangle(vec3(0.018997, 0.812234, 0.07921), vec3(0.19213, 0.713509, -0.005638), vec3(0.126361, 0.819345, 0.068201), MESH_MAT),Triangle(vec3(-0.364637, 0.337168, -0.013378), vec3(-0.327424, 0.270177, 0.028727), vec3(-0.305576, 0.373212, -0.040783), MESH_MAT),Triangle(vec3(0.122386, 0.618535, 0.044929), vec3(-0.00778, 0.61798, 0.043527), vec3(0.065221, 0.547188, 0.103696), MESH_MAT),Triangle(vec3(0.181319, 0.644357, 0.017247), vec3(0.202868, 0.57492, 0.082844), vec3(0.273186, 0.583892, 0.049482), MESH_MAT),Triangle(vec3(-0.203962, 0.618832, -0.065334), vec3(-0.233824, 0.536232, 0.056396), vec3(-0.157191, 0.633864, 0.005751), MESH_MAT),Triangle(vec3(-0.059392, 0.65576, -0.004542), vec3(-0.157191, 0.633864, 0.005751), vec3(-0.083438, 0.576525, 0.096248), MESH_MAT),Triangle(vec3(0.19213, 0.713509, -0.005638), vec3(0.181319, 0.644357, 0.017247), vec3(0.245825, 0.716175, 0.03344), MESH_MAT),Triangle(vec3(-0.059392, 0.65576, -0.004542), vec3(-0.083438, 0.576525, 0.096248), vec3(-0.00778, 0.61798, 0.043527), MESH_MAT),Triangle(vec3(0.181319, 0.644357, 0.017247), vec3(0.122386, 0.618535, 0.044929), vec3(0.202868, 0.57492, 0.082844), MESH_MAT),Triangle(vec3(-0.062308, 0.506301, 0.117343), vec3(0.107609, 0.441088, 0.121235), vec3(0.065221, 0.547188, 0.103696), MESH_MAT),Triangle(vec3(0.149563, 0.861575, 0.028843), vec3(0.007918, 0.939911, 0.118217), vec3(0.126361, 0.819345, 0.068201), MESH_MAT),Triangle(vec3(0.21536, 0.779135, -0.057927), vec3(0.232218, 0.773804, -0.002178), vec3(0.292536, 0.781958, -0.011948), MESH_MAT),Triangle(vec3(0.122386, 0.618535, 0.044929), vec3(0.181319, 0.644357, 0.017247), vec3(0.074057, 0.633076, -0.055413), MESH_MAT),Triangle(vec3(-0.180952, 0.488165, 0.113129), vec3(-0.08969, 0.470277, 0.163361), vec3(-0.062308, 0.506301, 0.117343), MESH_MAT),Triangle(vec3(0.122386, 0.618535, 0.044929), vec3(0.065221, 0.547188, 0.103696), vec3(0.202868, 0.57492, 0.082844), MESH_MAT),Triangle(vec3(0.036224, 0.453763, 0.190561), vec3(-0.08969, 0.470277, 0.163361), vec3(-0.034259, 0.408164, 0.190775), MESH_MAT),Triangle(vec3(-0.327424, 0.270177, 0.028727), vec3(-0.254881, 0.286715, 0.037952), vec3(-0.305576, 0.373212, -0.040783), MESH_MAT),Triangle(vec3(0.273186, 0.583892, 0.049482), vec3(0.289604, 0.711879, 0.039908), vec3(0.245825, 0.716175, 0.03344), MESH_MAT),Triangle(vec3(-0.210573, 0.168274, -0.013991), vec3(-0.166502, 0.175303, 0.014959), vec3(-0.327424, 0.270177, 0.028727), MESH_MAT),Triangle(vec3(0.350381, 0.624555, 0.029195), vec3(0.36033, 0.695769, -0.006685), vec3(0.289604, 0.711879, 0.039908), MESH_MAT),Triangle(vec3(-0.166502, 0.175303, 0.014959), vec3(-0.254881, 0.286715, 0.037952), vec3(-0.327424, 0.270177, 0.028727), MESH_MAT),Triangle(vec3(0.250622, 0.505524, 0.088913), vec3(0.304708, 0.440428, 0.083115), vec3(0.273186, 0.583892, 0.049482), MESH_MAT),Triangle(vec3(0.200558, 0.477239, 0.112074), vec3(0.250622, 0.505524, 0.088913), vec3(0.202868, 0.57492, 0.082844), MESH_MAT),Triangle(vec3(0.166991, 0.36131, 0.085108), vec3(0.200558, 0.477239, 0.112074), vec3(0.107609, 0.441088, 0.121235), MESH_MAT),Triangle(vec3(0.250622, 0.505524, 0.088913), vec3(0.273186, 0.583892, 0.049482), vec3(0.202868, 0.57492, 0.082844), MESH_MAT),Triangle(vec3(0.215546, 0.301405, 0.024583), vec3(0.166991, 0.36131, 0.085108), vec3(0.152295, 0.239825, 0.05623), MESH_MAT),Triangle(vec3(0.304708, 0.440428, 0.083115), vec3(0.200558, 0.477239, 0.112074), vec3(0.166991, 0.36131, 0.085108), MESH_MAT),Triangle(vec3(-0.173063, 0.282673, 0.134147), vec3(-0.134577, 0.348916, 0.156555), vec3(-0.256291, 0.423615, 0.079129), MESH_MAT),Triangle(vec3(-0.180952, 0.488165, 0.113129), vec3(-0.256291, 0.423615, 0.079129), vec3(-0.134577, 0.348916, 0.156555), MESH_MAT),Triangle(vec3(0.273186, 0.583892, 0.049482), vec3(0.350381, 0.624555, 0.029195), vec3(0.289604, 0.711879, 0.039908), MESH_MAT),Triangle(vec3(-0.134577, 0.348916, 0.156555), vec3(-0.08969, 0.470277, 0.163361), vec3(-0.180952, 0.488165, 0.113129), MESH_MAT),Triangle(vec3(-0.168866, 0.224887, 0.1125), vec3(-0.070533, 0.252196, 0.154089), vec3(-0.173063, 0.282673, 0.134147), MESH_MAT),Triangle(vec3(0.269382, 0.910315, 0.298144), vec3(0.238478, 0.842075, 0.306499), vec3(0.273493, 0.777428, 0.276229), MESH_MAT),Triangle(vec3(0.062931, 0.177577, -0.271961), vec3(-0.152536, 0.178287, -0.215175), vec3(-0.144218, 0.234272, -0.220998), MESH_MAT),Triangle(vec3(0.352736, 0.549814, -0.010589), vec3(0.350381, 0.624555, 0.029195), vec3(0.273186, 0.583892, 0.049482), MESH_MAT),Triangle(vec3(0.200558, 0.477239, 0.112074), vec3(0.202868, 0.57492, 0.082844), vec3(0.065221, 0.547188, 0.103696), MESH_MAT),Triangle(vec3(0.304708, 0.440428, 0.083115), vec3(0.331801, 0.36684, 0.011608), vec3(0.368073, 0.422161, -0.005827), MESH_MAT),Triangle(vec3(-0.173063, 0.282673, 0.134147), vec3(-0.070533, 0.252196, 0.154089), vec3(-0.134577, 0.348916, 0.156555), MESH_MAT),Triangle(vec3(0.183732, 0.168592, 0.067833), vec3(0.215546, 0.301405, 0.024583), vec3(0.152295, 0.239825, 0.05623), MESH_MAT),Triangle(vec3(0.232218, 0.773804, -0.002178), vec3(0.126361, 0.819345, 0.068201), vec3(0.19213, 0.713509, -0.005638), MESH_MAT),Triangle(vec3(-0.070533, 0.252196, 0.154089), vec3(0.02551, 0.326473, 0.190923), vec3(-0.134577, 0.348916, 0.156555), MESH_MAT),Triangle(vec3(-0.034259, 0.408164, 0.190775), vec3(-0.08969, 0.470277, 0.163361), vec3(-0.134577, 0.348916, 0.156555), MESH_MAT),Triangle(vec3(0.025993, 0.22367, 0.139888), vec3(-0.168866, 0.224887, 0.1125), vec3(-0.136813, 0.174497, 0.108037), MESH_MAT),Triangle(vec3(-0.134577, 0.348916, 0.156555), vec3(0.02551, 0.326473, 0.190923), vec3(-0.034259, 0.408164, 0.190775), MESH_MAT),Triangle(vec3(0.273186, 0.583892, 0.049482), vec3(0.245825, 0.716175, 0.03344), vec3(0.181319, 0.644357, 0.017247), MESH_MAT),Triangle(vec3(0.025993, 0.22367, 0.139888), vec3(-0.070533, 0.252196, 0.154089), vec3(-0.168866, 0.224887, 0.1125), MESH_MAT),Triangle(vec3(-0.062308, 0.506301, 0.117343), vec3(-0.083438, 0.576525, 0.096248), vec3(-0.233824, 0.536232, 0.056396), MESH_MAT),Triangle(vec3(-0.039482, 0.191432, -0.05586), vec3(0.074871, 0.184721, -0.087058), vec3(0.079803, 0.190642, -0.019812), MESH_MAT),Triangle(vec3(0.096535, 0.167887, -0.04525), vec3(0.098173, 0.175957, -0.172192), vec3(0.149229, 0.170443, -0.135435), MESH_MAT),Triangle(vec3(0.200558, 0.477239, 0.112074), vec3(0.304708, 0.440428, 0.083115), vec3(0.250622, 0.505524, 0.088913), MESH_MAT),Triangle(vec3(0.025993, 0.22367, 0.139888), vec3(0.02551, 0.326473, 0.190923), vec3(-0.070533, 0.252196, 0.154089), MESH_MAT),Triangle(vec3(0.246268, 0.360992, 0.082906), vec3(0.304708, 0.440428, 0.083115), vec3(0.166991, 0.36131, 0.085108), MESH_MAT),Triangle(vec3(0.137027, 0.168355, 0.157235), vec3(0.062239, 0.247316, 0.138586), vec3(0.025993, 0.22367, 0.139888), MESH_MAT),Triangle(vec3(-0.136813, 0.174497, 0.108037), vec3(-0.115264, 0.181389, 0.065295), vec3(0.137027, 0.168355, 0.157235), MESH_MAT),Triangle(vec3(0.02551, 0.326473, 0.190923), vec3(0.036224, 0.453763, 0.190561), vec3(-0.034259, 0.408164, 0.190775), MESH_MAT),Triangle(vec3(0.126361, 0.819345, 0.068201), vec3(-0.020466, 0.859784, 0.139961), vec3(0.018997, 0.812234, 0.07921), MESH_MAT),Triangle(vec3(0.062239, 0.247316, 0.138586), vec3(0.02551, 0.326473, 0.190923), vec3(0.025993, 0.22367, 0.139888), MESH_MAT),Triangle(vec3(0.331801, 0.36684, 0.011608), vec3(0.304708, 0.440428, 0.083115), vec3(0.246268, 0.360992, 0.082906), MESH_MAT),Triangle(vec3(0.093153, 0.399664, 0.167451), vec3(0.036224, 0.453763, 0.190561), vec3(0.02551, 0.326473, 0.190923), MESH_MAT),Triangle(vec3(-0.118051, 0.173732, -0.10069), vec3(-0.152536, 0.178287, -0.215175), vec3(-0.099449, 0.170033, -0.187359), MESH_MAT),Triangle(vec3(0.002328, 0.196857, -0.197549), vec3(0.070428, 0.19538, -0.187712), vec3(-0.039482, 0.191432, -0.05586), MESH_MAT),Triangle(vec3(-0.210573, 0.168274, -0.013991), vec3(-0.158281, 0.179789, -0.108768), vec3(-0.170752, 0.172512, -0.039055), MESH_MAT),Triangle(vec3(-0.199353, 0.182421, -0.125183), vec3(-0.118051, 0.173732, -0.10069), vec3(-0.158281, 0.179789, -0.108768), MESH_MAT),Triangle(vec3(-0.166502, 0.175303, 0.014959), vec3(-0.210573, 0.168274, -0.013991), vec3(-0.170752, 0.172512, -0.039055), MESH_MAT),Triangle(vec3(0.245825, 0.716175, 0.03344), vec3(0.289604, 0.711879, 0.039908), vec3(0.303702, 0.749047, 0.179161), MESH_MAT),Triangle(vec3(0.091191, 0.185885, 0.092948), vec3(-0.039482, 0.191432, -0.05586), vec3(0.098698, 0.190798, 0.002408), MESH_MAT),Triangle(vec3(-0.099449, 0.170033, -0.187359), vec3(-0.152536, 0.178287, -0.215175), vec3(0.062931, 0.177577, -0.271961), MESH_MAT),Triangle(vec3(0.062931, 0.177577, -0.271961), vec3(0.017069, 0.173181, -0.223031), vec3(-0.017042, 0.179769, -0.212595), MESH_MAT),Triangle(vec3(-0.10164, 0.197004, -0.165343), vec3(-0.118051, 0.173732, -0.10069), vec3(-0.099449, 0.170033, -0.187359), MESH_MAT),Triangle(vec3(-0.059192, 0.174127, -0.20089), vec3(0.062931, 0.177577, -0.271961), vec3(-0.017042, 0.179769, -0.212595), MESH_MAT),Triangle(vec3(-0.199353, 0.182421, -0.125183), vec3(-0.158281, 0.179789, -0.108768), vec3(-0.210573, 0.168274, -0.013991), MESH_MAT),Triangle(vec3(-0.199353, 0.182421, -0.125183), vec3(-0.152536, 0.178287, -0.215175), vec3(-0.118051, 0.173732, -0.10069), MESH_MAT),Triangle(vec3(0.070428, 0.19538, -0.187712), vec3(0.098173, 0.175957, -0.172192), vec3(0.074871, 0.184721, -0.087058), MESH_MAT),Triangle(vec3(0.087228, 0.172225, -0.209682), vec3(0.062931, 0.177577, -0.271961), vec3(0.130785, 0.17467, -0.209267), MESH_MAT),Triangle(vec3(-0.115264, 0.181389, 0.065295), vec3(-0.039482, 0.191432, -0.05586), vec3(0.091191, 0.185885, 0.092948), MESH_MAT),Triangle(vec3(0.410932, 0.592365, -0.085967), vec3(0.292534, 0.534289, -0.188198), vec3(0.398941, 0.574632, -0.211248), MESH_MAT),Triangle(vec3(0.017069, 0.173181, -0.223031), vec3(0.062931, 0.177577, -0.271961), vec3(0.087228, 0.172225, -0.209682), MESH_MAT),Triangle(vec3(0.292534, 0.534289, -0.188198), vec3(0.410932, 0.592365, -0.085967), vec3(0.362396, 0.549906, -0.111638), MESH_MAT),Triangle(vec3(0.331801, 0.36684, 0.011608), vec3(0.282746, 0.304155, -0.075912), vec3(0.351141, 0.392923, -0.135184), MESH_MAT),Triangle(vec3(0.087228, 0.172225, -0.209682), vec3(0.130785, 0.17467, -0.209267), vec3(0.098173, 0.175957, -0.172192), MESH_MAT),Triangle(vec3(0.323986, 0.561269, -0.242568), vec3(0.398941, 0.574632, -0.211248), vec3(0.292534, 0.534289, -0.188198), MESH_MAT),Triangle(vec3(-0.166502, 0.175303, 0.014959), vec3(-0.115264, 0.181389, 0.065295), vec3(-0.136813, 0.174497, 0.108037), MESH_MAT),Triangle(vec3(0.331801, 0.36684, 0.011608), vec3(0.215546, 0.301405, 0.024583), vec3(0.282746, 0.304155, -0.075912), MESH_MAT),Triangle(vec3(-0.166502, 0.175303, 0.014959), vec3(-0.10598, 0.178193, -0.021878), vec3(-0.115264, 0.181389, 0.065295), MESH_MAT),Triangle(vec3(0.282746, 0.304155, -0.075912), vec3(0.267049, 0.373613, -0.203833), vec3(0.351141, 0.392923, -0.135184), MESH_MAT),Triangle(vec3(0.266756, 0.590052, -0.264737), vec3(0.323986, 0.561269, -0.242568), vec3(0.292534, 0.534289, -0.188198), MESH_MAT),Triangle(vec3(0.215546, 0.301405, 0.024583), vec3(0.211259, 0.280859, -0.052263), vec3(0.282746, 0.304155, -0.075912), MESH_MAT),Triangle(vec3(0.294254, 0.171391, 0.027213), vec3(0.250665, 0.174116, -0.100404), vec3(0.301093, 0.175622, -0.038996), MESH_MAT),Triangle(vec3(0.245825, 0.716175, 0.03344), vec3(0.303702, 0.749047, 0.179161), vec3(0.273493, 0.777428, 0.276229), MESH_MAT),Triangle(vec3(0.071902, 0.227024, -0.266072), vec3(0.130785, 0.17467, -0.209267), vec3(0.062931, 0.177577, -0.271961), MESH_MAT),Triangle(vec3(0.065221, 0.547188, 0.103696), vec3(-0.083438, 0.576525, 0.096248), vec3(-0.062308, 0.506301, 0.117343), MESH_MAT),Triangle(vec3(-0.099449, 0.170033, -0.187359), vec3(0.062931, 0.177577, -0.271961), vec3(-0.059192, 0.174127, -0.20089), MESH_MAT),Triangle(vec3(0.211259, 0.280859, -0.052263), vec3(0.218577, 0.29514, -0.099413), vec3(0.282746, 0.304155, -0.075912), MESH_MAT),Triangle(vec3(0.185976, 0.317338, -0.170419), vec3(0.282746, 0.304155, -0.075912), vec3(0.218577, 0.29514, -0.099413), MESH_MAT),Triangle(vec3(-0.039482, 0.191432, -0.05586), vec3(0.070428, 0.19538, -0.187712), vec3(0.074871, 0.184721, -0.087058), MESH_MAT),Triangle(vec3(0.294254, 0.171391, 0.027213), vec3(0.20394, 0.16692, -0.076098), vec3(0.250665, 0.174116, -0.100404), MESH_MAT),Triangle(vec3(0.185976, 0.317338, -0.170419), vec3(0.267049, 0.373613, -0.203833), vec3(0.282746, 0.304155, -0.075912), MESH_MAT),Triangle(vec3(0.174443, 0.172387, -0.046664), vec3(0.294254, 0.171391, 0.027213), vec3(0.183732, 0.168592, 0.067833), MESH_MAT),Triangle(vec3(-0.10598, 0.178193, -0.021878), vec3(-0.096226, 0.167059, -0.079861), vec3(-0.039482, 0.191432, -0.05586), MESH_MAT),Triangle(vec3(0.20394, 0.16692, -0.076098), vec3(0.294254, 0.171391, 0.027213), vec3(0.174443, 0.172387, -0.046664), MESH_MAT),Triangle(vec3(0.137027, 0.168355, 0.157235), vec3(0.174443, 0.172387, -0.046664), vec3(0.183732, 0.168592, 0.067833), MESH_MAT),Triangle(vec3(0.137695, 0.166329, 0.010797), vec3(0.137027, 0.168355, 0.157235), vec3(0.091191, 0.185885, 0.092948), MESH_MAT),Triangle(vec3(0.137695, 0.166329, 0.010797), vec3(0.174443, 0.172387, -0.046664), vec3(0.137027, 0.168355, 0.157235), MESH_MAT),Triangle(vec3(0.216949, 0.183398, -0.245842), vec3(0.271874, 0.178675, -0.190704), vec3(0.250665, 0.174116, -0.100404), MESH_MAT),Triangle(vec3(0.188624, 0.170386, -0.131015), vec3(0.250665, 0.174116, -0.100404), vec3(0.20394, 0.16692, -0.076098), MESH_MAT),Triangle(vec3(0.091191, 0.185885, 0.092948), vec3(0.114107, 0.183072, 0.026409), vec3(0.137695, 0.166329, 0.010797), MESH_MAT),Triangle(vec3(0.188624, 0.170386, -0.131015), vec3(0.130785, 0.17467, -0.209267), vec3(0.250665, 0.174116, -0.100404), MESH_MAT),Triangle(vec3(0.130785, 0.17467, -0.209267), vec3(0.216949, 0.183398, -0.245842), vec3(0.250665, 0.174116, -0.100404), MESH_MAT),Triangle(vec3(0.121866, 0.169367, -0.016774), vec3(0.174443, 0.172387, -0.046664), vec3(0.137695, 0.166329, 0.010797), MESH_MAT),Triangle(vec3(0.185976, 0.317338, -0.170419), vec3(0.141412, 0.354538, -0.214361), vec3(0.267049, 0.373613, -0.203833), MESH_MAT),Triangle(vec3(0.127711, 0.175283, -0.057786), vec3(0.174443, 0.172387, -0.046664), vec3(0.121866, 0.169367, -0.016774), MESH_MAT),Triangle(vec3(-0.118051, 0.173732, -0.10069), vec3(-0.10164, 0.197004, -0.165343), vec3(-0.096226, 0.167059, -0.079861), MESH_MAT),Triangle(vec3(-0.115264, 0.181389, 0.065295), vec3(-0.10598, 0.178193, -0.021878), vec3(-0.039482, 0.191432, -0.05586), MESH_MAT),Triangle(vec3(0.114107, 0.183072, 0.026409), vec3(0.091191, 0.185885, 0.092948), vec3(0.098698, 0.190798, 0.002408), MESH_MAT),Triangle(vec3(0.130785, 0.17467, -0.209267), vec3(0.188624, 0.170386, -0.131015), vec3(0.149229, 0.170443, -0.135435), MESH_MAT),Triangle(vec3(-0.10164, 0.197004, -0.165343), vec3(-0.041141, 0.197265, -0.183413), vec3(-0.039482, 0.191432, -0.05586), MESH_MAT),Triangle(vec3(-0.350233, 0.241543, -0.10102), vec3(-0.292781, 0.26389, -0.171092), vec3(-0.199353, 0.182421, -0.125183), MESH_MAT),Triangle(vec3(-0.041141, 0.197265, -0.183413), vec3(0.002328, 0.196857, -0.197549), vec3(-0.039482, 0.191432, -0.05586), MESH_MAT),Triangle(vec3(0.096535, 0.167887, -0.04525), vec3(0.127711, 0.175283, -0.057786), vec3(0.121866, 0.169367, -0.016774), MESH_MAT),Triangle(vec3(0.096535, 0.167887, -0.04525), vec3(0.109739, 0.178609, -0.103104), vec3(0.127711, 0.175283, -0.057786), MESH_MAT),Triangle(vec3(0.5, 0.183406, -0.5), vec3(0.5, 0.183406, 0.5), vec3(0.5, -0.816594, 0.5), MESH_MAT),Triangle(vec3(0.5, 0.183406, 0.5), vec3(-0.5, 0.183406, 0.5), vec3(-0.5, -0.816594, 0.5), MESH_MAT),Triangle(vec3(-0.5, 0.183406, 0.5), vec3(-0.5, 0.183406, -0.5), vec3(-0.5, -0.816594, -0.5), MESH_MAT),Triangle(vec3(-0.5, 0.183406, -0.5), vec3(0.5, 0.183406, -0.5), vec3(0.5, -0.816594, -0.5), MESH_MAT),Triangle(vec3(0.5, 0.183406, 0.5), vec3(0.5, 0.183406, -0.5), vec3(-0.5, 0.183406, -0.5), MESH_MAT)\n);\n    // Doesn't matter since we're in a box\nvec3 sky_color(vec3 d) {\n    return vec3(0.0);\n}\n\n// basic camera ray\nRay camera(vec2 ndc) {\n    Ray cam; \n    cam.origin    = vec3(0.0, 0.5, -1.2);\n    cam.direction = normalize(vec3(ndc, 1.0));\n    \n    return cam;\n}\n#endif\n\n#ifdef MIRROR_WORLD\n// Cornell box scene with infinite mirrors\n\n#define LIGHT_POS vec3(0.0, 2.2, 0.0)\n#define LIGHT_RADIUS 0.5\n#define LIGHT_STRENGTH 40.0\n#define LIGHT_COLOR vec3(1.0, 1.0, 1.0)\n\n#define N_SPHERES 8\nconst Sphere SPHERES[N_SPHERES] = Sphere[](\n    Sphere(vec3(0.0, -1000.5, 0.0), 1000.0, Material(vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), 0.0)), // Ground\n    Sphere(vec3(1001.5, 0.0, 0.0), 1000.0, Material(vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), 0.0)), // Right wall\n    Sphere(vec3(-1001.5, 0.0, 0.0), 1000.0, Material(vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), 0.0)), // Left wall\n    Sphere(vec3(0.0, 0.0, 1001), 1000.0, Material(vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), 0.0)), // Back wall\n    Sphere(vec3(0.0, 0.0, -1002), 1000.0, Material(vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), 0.0)), // Front wall\n    Sphere(vec3(0.0, 1002, 0.0), 1000.0, Material(vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), 0.0)), // Ceiling\n    \n    Sphere(vec3(0.0, 0.0, 0.0), 0.5, Material(vec3(0.9, 0.9, 0.9), vec3(0.0, 0.0, 0.0), 1.0)), // White diffuse ball (to showcase GI)\n\n    Sphere(LIGHT_POS, LIGHT_RADIUS, Material(vec3(0.0, 0.0, 0.0), LIGHT_COLOR * LIGHT_STRENGTH, 1.0)) // Light sphere\n);\n\n#define N_TRIANGLES 1\nconst Triangle TRIS[N_TRIANGLES] = Triangle[](\n    Triangle(vec3(0), vec3(0), vec3(0), MISS.mat)\n);\n\n    // Doesn't matter since we're in a box\nvec3 sky_color(vec3 d) {\n    return vec3(0.0);\n}\n\n// basic camera ray\nRay camera(vec2 ndc) {\n    Ray cam; \n    cam.origin    = vec3(0.0, 0.7, -1.2);\n    cam.direction = normalize(vec3(ndc, 1.0));\n    \n    return cam;\n}\n#endif\n\n#ifdef SCENE_FURNACE\n// Blue Furnace test scene\n#define LIGHT_POS vec3(1.0, 1.0, -1.0)\n#define LIGHT_RADIUS 0.1\n#define LIGHT_STRENGTH 0.0\n#define LIGHT_COLOR vec3(1.0, 1.0, 1.0)\n\n#define N_SPHERES 2\nconst Sphere SPHERES[N_SPHERES] = Sphere[](\n    Sphere(vec3(0.0, 0.0, 0.0), 0.5, Material(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), 1.0)), // Perfect white sphere\n    \n    Sphere(LIGHT_POS, LIGHT_RADIUS, Material(vec3(0.0, 0.0, 0.0), LIGHT_COLOR * LIGHT_STRENGTH, 1.0)) // Light sphere\n);\n\n#define N_TRIANGLES 1\nconst Triangle TRIS[N_TRIANGLES] = Triangle[](\n    Triangle(vec3(0), vec3(0), vec3(0), MISS.mat)\n);\n\nvec3 sky_color(vec3 d) {\n    return vec3(0.0, 0.0, 1.0);\n}\n\n// basic camera ray\nRay camera(vec2 ndc) {\n    Ray cam; \n    cam.origin    = vec3(0.0, 0.0, -1.0);\n    cam.direction = normalize(vec3(ndc, 1.0));\n    \n    return cam;\n}\n#endif\n\n#ifdef SCENE_MYSTIC_HORIZON\n#define LIGHT_POS vec3(0.0, 2.2, 0.0)\n#define LIGHT_RADIUS 0.5\n#define LIGHT_STRENGTH 40.0\n#define LIGHT_COLOR vec3(1.0, 1.0, 1.0)\n\n#define N_SPHERES 5\nconst Sphere SPHERES[N_SPHERES] = Sphere[](\n    Sphere(vec3(0.0, -1000.5, 0.0), 1000.0, Material(vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), 1.0)), // Ground\n    Sphere(vec3(-0.8, 0.0, 0.0), 0.4, Material(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 1.0)),  // Red sphere\n    Sphere(vec3(0.8, 0.0, 0.0), 0.4, Material(vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 0.0), 1.0)),  // Green sphere\n    Sphere(vec3(0.0, 0.0, 0.8), 0.4, Material(vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 0.0), 1.0)),  // Blue sphere\n    Sphere(LIGHT_POS, LIGHT_RADIUS, Material(vec3(0.0, 0.0, 0.0), LIGHT_COLOR * LIGHT_STRENGTH, 1.0)) // Light sphere\n);\n\n#define N_TRIANGLES 1\nconst Triangle TRIS[N_TRIANGLES] = Triangle[](\n    Triangle(vec3(0), vec3(0), vec3(0), MISS.mat)\n);\n\nvec3 sky_color(vec3 d) {\n    float t = 0.5 * (d.y + 1.0); // Mapping y-direction to color intensity\n    return mix(vec3(0.1, 0.3, 0.7), vec3(1.0, 1.0, 1.0), t); // Gradient from blue to white\n}\n\nRay camera(vec2 ndc) {\n    Ray cam; \n    cam.origin    = vec3(0.0, 1.0, -3.0); // Adjusted camera position\n    cam.direction = normalize(vec3(ndc, 1.0));\n    \n    return cam;\n}\n#endif\n\n#ifdef SCENE_GLOWING_EMBER\n#define LIGHT_POS vec3(0.0, 2.2, 0.0)\n#define LIGHT_RADIUS 0.5\n#define LIGHT_STRENGTH 50.0\n#define LIGHT_COLOR vec3(1.0, 0.4, 0.2) // Warm orange light\n\n#define N_SPHERES 6\nconst Sphere SPHERES[N_SPHERES] = Sphere[](\n    Sphere(vec3(0.0, -1000.5, 0.0), 1000.0, Material(vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), 1.0)), // Ground\n    Sphere(vec3(-0.5, 0.0, 0.0), 0.4, Material(vec3(0.9, 0.5, 0.2), vec3(0.0, 0.0, 0.0), 0.1)),  // Warm and reflective sphere\n    Sphere(vec3(0.5, 0.0, 0.0), 0.4, Material(vec3(0.9, 0.5, 0.2), vec3(0.0, 0.0, 0.0), 0.9)),  // Warm and reflective sphere\n    Sphere(vec3(0.0, 0.6, 0.0), 0.4, Material(vec3(0.9, 0.5, 0.2), vec3(0.0, 0.0, 0.0), 0.5)),  // Warm and reflective sphere\n    Sphere(vec3(0.0, -0.6, 0.0), 0.4, Material(vec3(0.9, 0.5, 0.2), vec3(0.0, 0.0, 0.0), 0.8)), // Warm and reflective sphere\n    Sphere(LIGHT_POS, LIGHT_RADIUS, Material(vec3(0.0, 0.0, 0.0), LIGHT_COLOR * LIGHT_STRENGTH, 1.0)) // Light sphere\n);\n\n#define N_TRIANGLES 1\nconst Triangle TRIS[N_TRIANGLES] = Triangle[](\n    Triangle(vec3(0), vec3(0), vec3(0), MISS.mat)\n);\n\nvec3 sky_color(vec3 d) {\n    float t = 0.5 * (d.y + 1.0);\n    return mix(vec3(0.1, 0.1, 0.2), vec3(0.8, 0.3, 0.0), t); // Gradient from dark blue to warm orange\n}\n\nRay camera(vec2 ndc) {\n    Ray cam; \n    cam.origin    = vec3(0.0, 1.5, -3.0);\n    cam.direction = normalize(vec3(ndc, 1.0));\n    \n    return cam;\n}\n#endif\n\n// end scenes\nfloat hit_sphere(vec3 center, float radius, Ray r) {\n    vec3 oc = r.origin - center;\n    if (dot(oc,oc) < radius*radius) return 0.01;\n    float a = dot(r.direction, r.direction);\n    float half_b = dot(oc, r.direction);\n    float c = dot(oc,oc) - radius*radius;\n    float discriminant = half_b*half_b - a*c;\n\n    if (discriminant < 0.0) {\n        return -1.0;\n    } else {\n        return (-half_b - sqrt(discriminant) ) / a;\n    }\n}\n\n// ty chatgpt\nfloat hit_triangle(vec3 v1, vec3 v2, vec3 v3, Ray r) {\n    const float EPSILON = 0.0001;\n    vec3 e1 = v2 - v1;\n    vec3 e2 = v3 - v1;\n    vec3 h = cross(r.direction, e2);\n    float a = dot(e1, h);\n\n    if (a > -EPSILON && a < EPSILON) {\n        return -1.0; // Ray and triangle are parallel\n    }\n\n    float f = 1.0 / a;\n    vec3 s = r.origin - v1;\n    float u = f * dot(s, h);\n\n    if (u < 0.0 || u > 1.0) {\n        return -1.0; // Intersection point is outside the triangle\n    }\n\n    vec3 q = cross(s, e1);\n    float v = f * dot(r.direction, q);\n\n    if (v < 0.0 || u + v > 1.0) {\n        return -1.0; // Intersection point is outside the triangle\n    }\n\n    float t = f * dot(e2, q);\n\n    if (t > EPSILON) {\n        return t; // Intersection\n    } else {\n        return -1.0; // Intersection point is behind the ray origin\n    }\n}\n\n\nHitInfo intersect_spheres(Ray r) {\n    float closest = 100000.0;\n    Sphere o_closest;\n    for (int i = 0; i < N_SPHERES; ++i) {\n        Sphere obj = SPHERES[i];\n        float dst = hit_sphere(obj.center, obj.radius, r);\n        if (dst < closest && dst > 0.0) {\n            o_closest = obj;\n            closest = dst;\n        }\n    }\n    \n    if (closest > 99999.0) {\n        return MISS;\n    } else {\n        vec3 pos = r.origin + r.direction * closest;\n        return HitInfo(true, pos, (pos - o_closest.center) / o_closest.radius, closest, o_closest.mat); \n    }\n}\n\nHitInfo intersect_triangles(Ray r) {\n    float closest = 100000.0;\n    Triangle o_closest;\n    int i = 0;\n    while (i < N_TRIANGLES) {\n        Triangle obj = TRIS[i];\n        float dst = hit_triangle(obj.v1, obj.v2, obj.v3, r);\n        if (dst < closest && dst > 0.0) {\n            o_closest = obj;\n            closest = dst;\n        }\n        ++i;\n    }\n    \n    if (closest > 99999.0) {\n        return MISS;\n    } else {\n        vec3 pos = r.origin + r.direction * closest;\n        \n        vec3 norm12 = normalize(o_closest.v2 - o_closest.v1);\n        vec3 norm13 = normalize(o_closest.v3 - o_closest.v1);\n        vec3 norm = normalize(cross(norm12, norm13));\n        norm *= sign(dot(norm, r.origin - pos));\n        return HitInfo(true, pos, norm, closest, o_closest.mat); \n    }\n}\n\nHitInfo intersect_scene(Ray r) {\n    HitInfo sphere_int =   intersect_spheres(r);\n    HitInfo tri_int    = intersect_triangles(r);\n    \n    if (!tri_int.hit) return sphere_int;\n    if (!sphere_int.hit) return tri_int;\n    \n    if (tri_int.dst < sphere_int.dst) {\n        return tri_int;\n    }\n    return sphere_int;\n}\n\nvec3 trace(Ray r) {\n    vec3 color = vec3(1);\n    vec3 light = vec3(0);\n    \n    for (int bounce = 0; bounce < N_BOUNCES; ++bounce) {\n        HitInfo intersect = intersect_scene(r);\n        if (!intersect.hit || length(color) < 0.01) {\n            light += color * sky_color(r.direction);\n            break;\n        }\n        \n        Material mat = intersect.mat;\n\n        // Direct Light Sampling (DLS)\n        vec3 light_pos = LIGHT_POS + normalize(in_unit_sphere(intersect.position*4.0)) * LIGHT_RADIUS;\n        vec3 dir_to_light = normalize(light_pos - intersect.position);\n        \n        float diffuse_strength = max(0.0, dot(intersect.normal, dir_to_light));\n        float refl_strength = float(dot(normalize(reflect(r.direction, intersect.normal)), dir_to_light) > 0.99);\n        float dl_strength = mix(refl_strength, diffuse_strength, clamp(mat.roughness, 0.0, 1.0)); \n        \n        vec3 direct_lighting = vec3(dl_strength) * LIGHT_COLOR;\n        direct_lighting *= LIGHT_STRENGTH / pow(distance(intersect.position, light_pos), 2.0);\n        Ray r_shadow = Ray(intersect.position + intersect.normal * 0.001, dir_to_light);\n        HitInfo shadow = intersect_scene(r_shadow);\n        bool shadowed = true;\n        if (!shadow.hit) shadowed = false;\n        else {\n            if (shadow.dst > distance(light_pos, intersect.position)) shadowed = false;\n            if (distance(shadow.position, LIGHT_POS) <= LIGHT_RADIUS+0.01) shadowed = false;\n        }\n        direct_lighting *= float(!shadowed);\n        \n#ifndef NO_DLS\n        // DLS is really bright without this correction\n        #define DLS_BRIGHTNESS (0.125)\n        light += color * direct_lighting * mat.color * DLS_BRIGHTNESS;\n        light += color * mat.emission * (DLS_BRIGHTNESS*2.0);\n#else\n        light += color * mat.emission;\n#endif\n        \n        color *= mat.color;\n        \n        r.origin = intersect.position + intersect.normal * .001;\n        vec3 diffuse_dir = normalize(normalize(in_unit_sphere(intersect.position)) + intersect.normal);\n        vec3 refl_dir = reflect(r.direction, intersect.normal);\n        r.direction = mix(refl_dir, diffuse_dir, mat.roughness);\n    }\n    \n    return light;  \n}\n\nfloat greyscale(vec4 color) {\n    float luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114));\n    return luminance;\n}\n\n#define flim(x,y) flim_transform(iChannel0,x,y)\n\n/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Common\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The common unit contains most of the code, and\n  receives gamut extension matrices from a buffer.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n  Minified by 01000001\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// Parameters\n\nconst float pe = 4.3; const vec3 fpff = vec3(1); const float fpffs = 0.;\nconst float egr = 1.05; const float egg = 1.12; const float egb = 1.045;\nconst float grr = .5; const float ggr = 2.; const float gbr = .1;\nconst float grm = 1.; const float ggm = 1.; const float gbm = 1.; const float flsi = -10.;\nconst float flsa = 22.; const float fsx = .44; const float fsy = .28;\nconst float fssx = .591; const float fssy = .779; const float fe = 6.;\nconst float fd = 5.; const vec3 pb = vec3(1); const float pfe = 6.;\nconst float pfd = 27.5; const float bp = -1.; const vec3 pff = vec3(1);\nconst float pffs = 0.; const float ms = 1.02;\nfloat wrap(float i, float s, float e){return s + mod(i - s, e - s);}\nfloat lerp(float a, float b, float t){return a + t * (b - a);}\nvec3 lerp(vec3 a, vec3 b, float t){return a + t * (b - a);}\nfloat mrc(float i, float is, float ie, float os, float oe){\n    float t = clamp((i - is) / (ie - is), 0., 1.);\n    float v = os + t * (oe - os);\n    return v; }\nvec3 rth(vec3 rgb){\n    float ca, ci, h, s, v, cd;\n    vec3 c;\n    ca = max(rgb[0], max(rgb[1], rgb[2]));\n    ci = min(rgb[0], min(rgb[1], rgb[2]));\n    cd = ca - ci;\n    v = ca;\n    if (ca != 0.) s = cd / ca;\n    else s = 0.0; h = 0.0;\n    if (s == 0.) h = 0.0; \n    else{\n        c = (vec3(ca) - rgb.xyz) / cd;\n\n        if (rgb.x == ca) h = c[2] - c[1];\n        else if (rgb.y == ca) h = 2.+ c[0] - c[2];\n        else h = 4.+ c[1] - c[0];\n        h /= 6.0;\n        if (h < 0.) h += 1.0; }\n    return vec3(h, s, v); }\nvec3 htr(vec3 hsv){\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n    if (s == 0.) rgb = vec3(v, v, v);\n    else {\n        if (h == 1.) h = 0.0;\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.- s);\n        q = v * (1.- (s * f));\n        t = v * (1.- (s * (1.- f)));\n        if (i == 0.) rgb = vec3(v, t, p);\n        else if (i == 1.) rgb = vec3(q, v, p);\n        else if (i == 2.) rgb = vec3(p, v, t);\n        else if (i == 3.) rgb = vec3(p, q, v);\n        else if (i == 4.) rgb = vec3(t, p, v);\n        else rgb = vec3(v, p, q); }\n    return rgb; }\nvec3 bhs(vec3 col, float hue, float sat, float value){\n    vec3 hsv = rth(col);\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n    return htr(hsv); }\nfloat rgb_avg(vec3 i){\n    return (i.x + i.y + i.z) / 3.0; }\nfloat rgb_sum(vec3 i){\n    return i.x + i.y + i.z; }\nfloat rgb_max(vec3 i){\n    return max(max(i.x, i.y), i.z); }\nfloat rgb_min(vec3 i){\n    return min(min(i.x, i.y), i.z); }\nvec3 uo(vec3 i, float bp, float wp){\n    float mono = rgb_avg(i);\n    float mono2 = mrc(mono, bp / 1000., 1.- (wp / 1000.), 0., 1.);\n    return i * (mono2 / mono); }\n// https://www.desmos.com/calculator/khkztixyeu\nfloat ss(float i, float tx, float ty, float sx, float sy){\n    i = clamp(i, 0., 1.);\n    tx = clamp(tx, 0., 1.);\n    ty = clamp(ty, 0., 1.);\n    sx = clamp(sx, 0., 1.);\n    sy = clamp(sy, 0., 1.);\n    float slope = (sy - ty) / (sx - tx);\n    if (i < tx){\n        float toe_pow = slope * tx / ty;\n        return ty * pow(i / tx, toe_pow); }\n    if (i < sx){\n        float intercept = ty - (slope * tx);\n        return slope * i + intercept; }\n    float shoulder_pow = -slope / (((sx - 1.) / pow(1.- sx, 2.)) * (1.- sy));\n    return (1.- pow(1.- (i - sx) / (1.- sx), shoulder_pow)) * (1.- sy) + sy; }\nfloat dmf(float mono, float max_density){\n    float offset = pow(2., flsi);\n    float fac = mrc(log2(mono + offset), flsi, flsa, 0., 1.);\n    fac = ss(fac, fsx, fsy, fssx, fssy);\n    fac *= max_density;\n    fac = pow(2., -fac);\n    return clamp(fac, 0., 1.); }\nvec3 cl(vec3 i, vec3 sensitivity_tone, vec3 dye_tone, float max_density){\n    vec3 sensitivity_tone_norm = sensitivity_tone / rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / rgb_max(dye_tone);\n    float mono = dot(i, sensitivity_tone_norm);\n    float mixFac = dmf(mono, max_density);\n    return lerp(dye_tone_norm, vec3(1.), mixFac); }\nvec3 rgbd(vec3 i, float e, float max_density){\n    i *= pow(2., e);\n    vec3 result = cl(i, vec3(0, 0, 1), vec3(1, 1, 0), max_density);\n    result *= cl(i, vec3(0, 1, 0), vec3(1, 0, 1), max_density);\n    result *= cl(i, vec3(1, 0, 0), vec3(0, 1, 1), max_density);\n    return result; }\nvec3 emr(float ph, float s, float r, float m){\n    vec3 result = htr(vec3(wrap(ph + (r / 360.), 0., 1.), 1./ s, 1.));\n    result /= rgb_sum(result);\n    result *= m;\n    return result; }\nmat3 gem(float rs,float gs,float bs,float rr,float gr, float br, float rm, float gm, float bm){\n    mat3 m;\n    m[0] = emr(0., rs, rr, rm);\n    m[1] = emr(1./ 3., gs, gr, gm);\n    m[2] = emr(2./ 3., bs, br, bm);\n    return m; }\nvec3 nap(vec3 i, vec3 bex){\n    i = rgbd(i, fe, fd);\n    i *= bex;\n    i = rgbd(i, pfe, pfd);\n    return i; }\nbool flm(sampler2D mc, out mat3 em, out mat3 emi){\n    const float valid_w = 2.0;\n    vec4 row;\n    row = texelFetch(mc, ivec2(0, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    em[0] = row.xyz;\n\n    row = texelFetch(mc, ivec2(1, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    em[1] = row.xyz;\n\n    row = texelFetch(mc, ivec2(2, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    em[2] = row.xyz;\n    row = texelFetch(mc, ivec2(3, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    emi[0] = row.xyz;\n\n    row = texelFetch(mc, ivec2(4, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    emi[1] = row.xyz;\n\n    row = texelFetch(mc, ivec2(5, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    emi[2] = row.xyz;\n    return true; }\nvec3 flim_transform(sampler2D mc, vec3 i, float e){\n    i = max(i, 0.);\n    i *= pow(2., pe + e);\n    i = min(i, 5000.);\n    mat3 em, emi;\n    if (!flm(mc, em, emi)){ return vec3(1, 0, 1); }\n    vec3 bex = pb * em;\n    const float big = 10000000.0;\n    vec3 white_cap = nap(vec3(big, big, big), bex);\n    i = lerp(i, i * fpff, fpffs);\n    i *= em;\n    i = nap(i, bex);\n    i *= emi;\n    i = max(i, 0.);\n    i /= white_cap;\n    if (bp == -1.){\n        vec3 black_cap = nap(vec3(0.), bex);\n        black_cap /= white_cap;\n        i = uo(i, rgb_avg(black_cap) * 1000., 0.);\n    }else{ i = uo(i, bp, 0.); }\n    i = lerp(i, i * pff, pffs);\n    i = clamp(i, 0., 1.);\n    float mono = rgb_avg(i);\n    float mixFac = (mono < 0.5) ? mrc(mono, 0.05, 0.5, 0., 1.) : mrc(mono, 0.5, 0.95, 1., 0.);\n    i = lerp(i, bhs(i, 0.5, ms, 1.), mixFac);\n    i = clamp(i, 0., 1.);\n    i = pow(i, vec3(1./ 2.2));\n    return i; }\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Common\n\n***********************************/\n", "buffer_a_code": "// Progressive rendering pipeline\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ndc = uv * 2.0 - 1.0;\n    ndc.x *= iResolution.x / iResolution.y;\n    \n    Ray cam = camera(ndc);\n    \n        // Concentrate more samples in noisier areas\n    int nSamples = N_SAMPLES;\n    float variance = texture(iChannel1, uv).x; // Variance map (last frame)\n    variance = variance * 2.0 - 1.0;\n    variance *= float(SAMPLE_VAR);\n    nSamples += int(variance);\n    nSamples = max(1, nSamples);\n    \n    vec3 col;\n    for (int i = 0; i < nSamples; ++i) {\n        seed = float(i+nSamples*iFrame);\n        Ray cam_jitter = Ray(cam.origin + 0.005*in_unit_sphere(cam.direction), cam.direction);\n        col += trace(cam_jitter);\n    }\n    col /= float(nSamples);\n\n    // Output to screen\n    fragColor = mix(texture(iChannel0, uv), vec4(col, 1.0), 1.0 / float(iFrame+1));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Buffer X\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The buffer unit performs a one-time calculation\n  of flim's gamut extension matrices.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n  Minified by 01000001\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// NOTE:\n// iChannel0 must be set to this buffer (self-feeding).\n\nvoid mainImage(out vec4 O, in vec2 U){\n    const float w = 2.0;\n    if (ivec2(U).x > 5 || ivec2(U).y > 0)\n        return;\n    vec4 p = texelFetch(iChannel0, ivec2(U), 0);\n    O = p;\n    bool n = (p.w != w) || (iTime == 0.0) || (iFrame < 1);\n    if (!n)\n        return;\n    mat3 e = gem(egr,egg,egb,grr,ggr,gbr,grm,ggm,gbm);\n    mat3 ei = inverse(e);\n    if (ivec2(U) == ivec2(0, 0)) {\n        O = vec4(e[0], w);\n    } if (ivec2(U) == ivec2(1, 0)) {\n        O = vec4(e[1], w);\n    } if (ivec2(U) == ivec2(2, 0)) {\n        O = vec4(e[2], w);\n    }\n    if (ivec2(U) == ivec2(3, 0)) {\n        O = vec4(ei[0], w);\n    } if (ivec2(U) == ivec2(4, 0)) {\n        O = vec4(ei[1], w);\n    } if (ivec2(U) == ivec2(5, 0)) {\n        O = vec4(ei[2], w);\n    }}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Buffer X\n\n***********************************/\n", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "float variance(vec2 uv, sampler2D tex) {\n    // Number of samples in each dimension\n    const int numSamples = 2;\n\n    // Calculate the mean\n    float mean = 0.0;\n    for (int i = -numSamples; i <= numSamples; ++i) {\n        for (int j = -numSamples; j <= numSamples; ++j) {\n            vec2 offset = vec2(float(i), float(j)) / float(textureSize(tex, 0));\n            mean += greyscale(texture(tex, uv + offset));\n        }\n    }\n    mean /= float((2 * numSamples + 1) * (2 * numSamples + 1));\n\n    // Calculate the variance\n    float variance = 0.0;\n    for (int i = -numSamples; i <= numSamples; ++i) {\n        for (int j = -numSamples; j <= numSamples; ++j) {\n            vec2 offset = vec2(float(i), float(j)) / float(textureSize(tex, 0));\n            float value = greyscale(texture(tex, uv + offset));\n            variance += (value - mean) * (value - mean);\n        }\n    }\n    variance /= float((2 * numSamples + 1) * (2 * numSamples + 1));\n\n    return variance;\n}\n\n\n// Variance map\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(variance(uv, iChannel0), 0.0,0.0,1.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fXGWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 272]], "test": "untested"}
{"id": "lcs3WN", "name": "YT shader", "author": "Andreuicncuza", "description": "The simplest diffuse sphere code", "tags": ["raytracing"], "likes": 1, "viewed": 161, "published": 3, "date": "1703098905", "time_retrieved": "2024-07-30T17:15:29.852260", "image_code": "#define PI 3.1415926535\n#define NUM_OF_SPHERES 4\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct Material {\n    vec3 albedo;\n    float persistence;\n    bool diffuse;\n};\n\nstruct Sphere {\n    vec3 c;\n    float r;\n    Material mat;\n};\n\nstruct Record { \n    vec3 p;\n    float t;\n    vec3 n;\n    Material mat;\n    bool didHit;\n};\n\nvec2 randState;\n\nfloat hash( const float n ) \n{\n     return fract(sin(n)*43758.54554213);\n}\n\n\nfloat rand2D()\n{\n    randState.x = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);\n    randState.y = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);;\n    \n    return randState.x;\n}\n\n\n// random direction in unit sphere (for lambert brdf)\nvec3 random_in_unit_sphere()\n{\n    float phi = 2.0 * PI * rand2D();\n    float cosTheta = 2.0 * rand2D() - 1.0;\n    float u = rand2D();\n\n    float theta = acos(cosTheta);\n    float r = pow(u, 1.0 / 3.0);\n\n    float x = r * sin(theta) * cos(phi);\n    float y = r * sin(theta) * sin(phi);\n    float z = r * cos(theta);\n\n    return vec3(x, y, z);\n}\n\nvec3 random_in_hemisphere(vec3 normal)\n{\n    vec3 rand = random_in_unit_sphere();\n    if (dot(normal, rand) < 0.0)\n        return -rand;\n    return rand;\n}\n\n\nSphere SPHERES[] = Sphere[NUM_OF_SPHERES](\n    Sphere(\n        vec3(.05,0,-.3)*5.0,\n        1.0,\n        Material(vec3(.9,.2,.2), 0.9, false)  \n    ),\n    Sphere(\n        vec3(.0,.0,.1)*5.0,\n        0.4,\n        Material(vec3(.2,.2,.9), 0.9, false)  \n    ),\n    Sphere(\n        vec3(0,0,-.3),\n        0.5,\n        Material(vec3(0.2,0.2,.9)*5.0, 0.8, true)  \n    ),\n    Sphere(\n        vec3(0,-1.0,-.3),\n        0.2,\n        Material(vec3(0.2,0.8,.9)*5.0, 0.8, true)  \n    )\n);\n\nRecord hit(Ray r, Sphere s){\n    Record info;\n    vec3 oc = r.o - s.c;\n    float a = dot(r.d, r.d);\n    float b = dot(oc, r.d);\n    float c = dot(oc, oc) - s.r * s.r;\n\n    float disc = b*b - a * c;\n\n    if (disc > 0.0){\n        float t = (-b - sqrt(disc)) / a;\n        vec3 p = r.o + r.d * t;\n        info.didHit = true;\n        info.t = t;\n        info.n = (p - s.c) / s.r;\n        info.p = p;\n        info.mat = s.mat;\n        return info;\n    }\n\n    info.didHit = false;\n    return info;\n}\n\nRecord hit_world(Ray r){\n    Record info;\n    info.t = 99999999.0;\n\n    for (int i = 0; i < NUM_OF_SPHERES; i++){\n        Sphere s = SPHERES[i];\n        Record tempinfo = hit(r, s);\n        if (tempinfo.didHit && tempinfo.t < info.t && tempinfo.t > 0.0){\n            info = tempinfo;\n        }\n    }\n\n    return info;\n}\n\nRay calculateRay(vec3 lookTo, vec3 CameraOrigin, vec2 ScaledDown){\n    vec3 forwad = normalize(lookTo - CameraOrigin);\n    vec3 right = normalize(cross(forwad, vec3(0, 1,0)));\n    vec3 up = normalize(cross(forwad, right));\n    vec3 direction = forwad + right * ScaledDown.x + up * ScaledDown.y;\n    return Ray(CameraOrigin, direction); \n}\n\nvec3 background(Ray r){\n    return vec3(0);\n}\n\nvec3 rayColor(Ray r){\n    vec3 col = vec3(1);\n    for (int i = 0; i <= 20; i++){\n        Record info = hit_world(r);\n        if (info.didHit){\n            r.o = info.p;\n            r.d = random_in_hemisphere(info.n);\n            if (info.mat.diffuse){\n                col *= info.mat.persistence;\n            }\n            else{\n                col *= info.mat.albedo;\n                break;\n                }\n        }else{\n            col *= background(r);\n            break;\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    randState = fragCoord.xy / iResolution.xy;\n    vec2 uv = randState - 0.5;\n    vec2 ScaledDown = iResolution.xy / 400.0 * uv;\n    float t = iTime;\n    t = fract(t/20.);\n    t+=0.4;\n    if (t<0.5){\n        t = 4. * t * t;\n    }else {\n        t = 1. - pow(-2.0*t + 2.,3.)/2.;\n    }\n    \n    t*= 10.;\n \n    \n    Ray r = calculateRay(\n        vec3(0,0,0),\n        vec3(sin(t), 0, cos(t)) * 2.7,\n        ScaledDown\n    );\n\n    vec3 color = rayColor(r);\n   \n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcs3WN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[344, 344, 374, 374, 418], [421, 421, 437, 437, 639], [642, 696, 726, 726, 1040], [1042, 1042, 1082, 1082, 1197], [1678, 1678, 1706, 1706, 2170], [2172, 2172, 2196, 2196, 2491], [2493, 2493, 2559, 2559, 2831], [2833, 2833, 2856, 2856, 2878], [2880, 2880, 2901, 2901, 3391], [3393, 3393, 3449, 3449, 3938]], "test": "untested"}
{"id": "lcfGDN", "name": "Neon Party", "author": "rcargou", "description": "I wanted to exeperiment again with light raymarching and do pretty stuff with neon and reflections", "tags": ["reflection", "neon", "raynarching"], "likes": 9, "viewed": 142, "published": 3, "date": "1703097703", "time_retrieved": "2024-07-30T17:15:30.940350", "image_code": "#define AA 1   // make this 2 or 3 for antialiasing\n\n\nvec3 getcol(float x1) {\n//return vec3(0.120,0.737,0.737);\n//return vec3(.0, 1., .0);\n//float x2= mod(iTime / 3., 7.) + 0.;\nfloat x2 = 0.;\nfloat x = fract(x1 / 1.);\n//x2=0.;\n    vec3 cols[7] = vec3[7] (pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) ),\n    pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) ),\n    pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) ),\n    pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) ),\n    pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) ),\n    pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) ),\n    pal( x, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) )\n    );\n    return mix( cols[int(x2)], cols[int(mod(x2, 7.)) + 1] , fract(x2));\n}\n\n//------------------------------------------------------------------\n#define ANIMATE\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat o2(){\nreturn 0.;\n#ifndef ANIMATE\nreturn 0.;\n#endif\n    return .5 + sin(iTime / 12.) * .5;\n}\n\nfloat o(){\n#ifndef ANIMATE\nreturn 1.;\n#endif\n//return 1.;\nreturn .5 + sin(iTime) * .5;\n}\n\nvec3 kal(vec3 p) {\nreturn p;\np = abs(p);\np.xy*=rotate2d(iTime / 8.);\np=abs(p);p.xy*=rotate2d(iTime / 18.);\np=abs(p);\nreturn p;\np.xy*=rotate2d(iTime / 1.);\n    p.y = abs(p.y);\n    p.x = abs(p.x);\n    p.xy*=rotate2d(iTime / 2.);\n        p.y = abs(p.y);\n    p.x = abs(p.x);\n    p.x-=.3;\n    p.xy*=rotate2d(-iTime / 4.);\np.x-=.3;\n    p.y = abs(p.y);\n    p.x = abs(p.x);\n    p.xy*=rotate2d(iTime / 6.);\n//p.x-=.1;\n    p.y -= .2;\n    p.y+=.1;\n    return p;\n}\nvec3 neon_col(float id) {\n    return getcol(id);\n    vec3 c =  .5*pal( id, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    return normalize(c);\n}\n\nfloat mapPillars(in vec3 p) {\n    float r = 15.;\n    \n    float r3 = 15.;\n    float r2=.4;\n    vec3 p2  = p;\n    p2.z += 5.;\n    float id = hash( floor(p.z/r) *r );\n    p.xy *= rotate2d(iTime + id * 6.28);\n\n    p.z = mod(p.z, r) - r / 2.;\n    p2.z = mod(p2.z, r3) - r3 / 2.;\n    \n       float ds =  sdTorus(p2.xzy, vec2(.4, .05));\n \n    p.x = mod(p.x, r2) - r2/2.;\n    return min(length(p.xz) -.05, ds);\n}\n\nfloat mapBalls(in vec3 p, out vec3 lightCol) {\n    return 1e10;\n    float r = .5;\n    p.z += iTime * 6.;\n    vec3 id = floor(p/r) *r;\n    float h = hash( hash(id.x) + hash(id.y)+hash(id.z) );\n    float s = .02;\n    p = mod(p, r) - r/2.;\n    lightCol = 2.*pal( hash(h), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    if (h < .9)\n        return 1.;\n    return length(p) - s;\n}\nfloat mapHexagonLight(in vec3 p, out vec3 lightCol) {\n    float r = 5.;\n    p.y-=iMouse.x/200.;\n    float t = p.z;\n    \n    lightCol = vec3(1., 0., 0.);\n    float id = hash( floor( (p.z + -15.*iTime) / r) * r); // 5\n    float a = 3.14 / 6.;\n    p.z = mod(p.z,r)-r/2.;\n    lightCol = neon_col(id * 12.);\n        float h = mix(.66, 1.05, o());\n    float s = .02;\n    \n    vec2 sh = vec2(s, h);\n    float d1 = sdCylinder(p, sh);\n    p.xy *= rotate2d(a);\n    \n    float d2 = sdCylinder(p, sh);\n    p.xy *= rotate2d(a);\n    float d3 = sdCylinder(p, sh);\n    p.xy *= rotate2d(a);\n    float d4 = sdCylinder(p, sh);\n    p.xy *= rotate2d(a);\n    float d5 = sdCylinder(p, sh);\n    p.xy *= rotate2d(a);\n    float d6 = sdCylinder(p,sh);\n    float u = min (min(d1, d3), min( min(d2, d6), min(d4, d5)) );\n    \n    return u;\n}\nfloat mapLight(in vec3 p, out vec3 lightCol) {\n   // return mapHexagonLight(p,lightCol);\n  float r = 5.;\n  float t = p.z;\n  lightCol = vec3(1., 0., 0.);\n      float id = hash( floor( (p.z + -15.*iTime) / r) * r); // 5\n  //p.xy *= rotate2d(p.z + iTime + id);\n//p.xy *= 5.5;\n    p.z = mod(p.z,r)-r/2.;\n    lightCol = neon_col(id * 12.);\n//    return length(p) - .1;\n    float a = mix(3.15, 2.6, o());\n    \n    float h = mix(.66, 1.05, o());\n    float s = .02;\n    float ox = mix(.65, .5, o());\n    float of = .81;\n    float of2 = 0.196;\n    vec2 sh = vec2(s, h);\n    float d1 = sdCylinder(p.yxz + vec3(-of, 0., 0.), sh);\n    float d4 = sdCylinder(p.yxz + vec3(.45 + o() / 1., 0., 0.), sh);\n    vec3 p2 = p;\n    p.xy *= rotate2d(a);\n    float d2 = sdCylinder(p.xyz + vec3(-ox, of2, 0.), sh);\n    p2.xy *= rotate2d(-a);\n    float d3 = sdCylinder(p2.xyz + vec3(ox, of2, 0.), sh);\n\n    float dt= min(min(d4, d2), min(d1, d3));\n    return dt;\n    float ds = sdTorus(p.xzy, vec2(.9, .01) );\n    return min(ds, dt);\n    return mix(dt, ds, sin(iTime) * .5 + .5);\n   /*\n        pos.y *= -1.;\n    pos.y+=.2;\n//    float a = 2.1;\n    float a = mix(1.55, 2.1, o());\n\n    float d4 = sdCylinder(pos * vec3(1., -1., 1.) + vec3(0., 0.6 * o(), 0.),vec2(.02, 1.9));\n    float d1 = sdCylinder(pos,vec2(.02, 1.9));\n    vec3 p2 = pos;\n    pos.xy *= rotate2d(a);\n    float d2 = sdCylinder(pos,vec2(.02, 1.9));\n    p2.xy *= rotate2d(-a);\n    float d3 = sdCylinder(p2,vec2(.02, 1.9));\n    return min(d1, min(d2, min(d3, d4))) ;*/\n}\n\n\nvec3 get_light(in vec3 p, out float l, bool rm) {\n    vec3 lc;\n    float s;\n    p = kal(p);\n    s = mapLight(p, lc);\n    l=s;\n    if (rm) {\n        pow(s, 3.);\n        return lc * (.0002 / (.001 + s *s));\n    }\n    return lc * (.2 / (.001+s * s * s * s));\n}\n\nvec3 rmLight(in vec3 ro, vec3 rd, float d) {\n    vec3 out_col = vec3(0.);\n//return vec3(0.);\n    float t = 0.;\n    float oui = 0.;\n    for (int i = 0; i < 40; ++i) {\n        vec3 p = ro + rd * t;\n        p = kal(p);\n        //if (d<t)\n        out_col += get_light(p,oui, true);\n        vec3 lb;\n        //float ii = mapBalls(p, lb);\n       // out_col += lb * (.0005 / (.001 + ii*ii));\n        t += .15;\n    }\n    return vec3(out_col);\n}\n\nfloat mapPlan(in vec3 pos, out float mat) {\n    pos.y-=.3;\n  //  pos.y += sin(pos.z * 2.) / 112.;\n    float d1 = pos.y + 1.;\n    vec3 p2 = pos;\n    float r = .4;\n    float h = .05;\n    vec2 id = floor(pos.xz / r) * r;\n    float ha = hash(id.x + id.y);\n    mat = ha < .7 ? 0. : 1.;\n    p2.x = mod(pos.x, r) - r / 2.;\n    float d2 = abs(p2.x);\n    d2 = max(d2, abs(p2.y+1.) - h );\n   \n    vec3 p3 = pos;\n    p3.z = mod(pos.z, r) - r / 2.;\n    float d3 = abs(p3.z);\n    d3 = max(d3, abs(p3.y+1.) - h );\n    return min(d1,min(d2, d3));\n}\n\n\n\nfloat mapTrianglePlan(in vec3 pos, out float id) {\n   // pos.xy *= rotate2d(iTime / 4.);\n    pos.y *= -1.;\n    pos.y+=.2;\n  //  pos.z-=iTime * 2.;\n//    float a = 2.1;\n    float a = mix(1.55, 2.1, o());\n\n    float d4 = mapPlan(pos * vec3(1., -1., 1.) + vec3(0., 0.8 * o(), 0.) , id);\n    float d1 = mapPlan(pos, id);\n    vec3 p2 = pos;\n    pos.xy *= rotate2d(a);\n    float d2 = mapPlan(pos, id);\n    p2.xy *= rotate2d(-a);\n    float d3 = mapPlan(p2, id);\n    return min(d1, min(d2, min(d3, d4))) ;\n}\n\nfloat mapHexagon(in vec3 pos, out float id) {\n\n    float a = 3.14 / 3.;\n    float d1 = mapPlan(pos, id);\n    pos.xy *= rotate2d(a);\n    float d2 = mapPlan(pos, id);\n    pos.xy *= rotate2d(a);\n    float d3 = mapPlan(pos, id);\n    pos.xy *= rotate2d(a);\n    float d4 = mapPlan(pos, id);\n    pos.xy *= rotate2d(a);\n    float d5 = mapPlan(pos, id);\n    pos.xy *= rotate2d(a);\n    float d6 = mapPlan(pos, id);\n    return min (min(d1, d3), min( min(d2, d6), min(d4, d5)) );\n}\n\nfloat mapTunnel(in vec3 pos, out float id) {\n//    pos.xy *= rotate2d(pos.z + iTime);\n//    pos.xy *= rotate2d( mod(iTime, 6.28) * 1. );\n    float d1 =  mapHexagon(pos, id);\n    float d2 = mapTrianglePlan(pos, id);\n    return mix(d1, d2, smoothstep(-.1, .0, sin(pos.z / 12.)));\n}\nvec2 map( in vec3 pos, out vec3 lightCol, out float id)\n{\n    pos = kal(pos);\n    vec2 res = vec2( 1e10, 0.0 );\n    float d;\n    if ((res.x = length(pos) - .5f) < .0f)\n        res.y = 1.0f;\n    if ( (d = mapTunnel(pos, id) ) < res.x ) {\n        res.x = d;\n        res.y = 1.;\n    }\n    vec3 clight;\n    vec3 lightColtmp;\n    if ( (d = mapLight(pos, clight) ) < res.x ) {\n        res.x = d;\n        res.y = 2.;\n        lightCol = clight;\n    }\n    if ( (d = mapBalls(pos, clight) ) < res.x ) {\n        res.x = d;\n        res.y = 3.;\n        lightCol = clight;\n    }\n    if ( (d = mapPillars(pos) ) < res.x ) {\n        res.x = d;\n        res.y = 1.;\n    }\n    return res;\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd, out vec3 lightCol, bool ref, out float mat)\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 30.0;\n    int num_step = ref ? 30 : 50;\n    // raymarch primitives   \n    {\n    \n        float t = tmin;\n        for( int i=0; i<num_step && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t , lightCol, mat);\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 a;\n    float b;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy,a,b ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ,a,b).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ,a ,b).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ,a,b).x );\n \n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 light_equation(vec3 p, vec3 n, vec3 albedo, vec3 lc, float l, float ref) {\n    vec3 light_pos = p + l * vec3(.0, .0, 1.);\n    float ndotl = max(.1, dot(-n, normalize(light_pos - p) ));\n    return (lc+.3) * albedo * 3. * abs(n.y);\n    return  (200.*lc*ndotl+1.5)*albedo;\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(.0f);\n    vec3 lc;\n    float mat = 0.;\n    vec2 res = castRay(ro,rd, lc,false, mat);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 p = ro + rd * t;\n    vec3 p1 = p;\n    vec3 n = calcNormal(ro + rd*t);\n    //vec3 albedo = tex3D(iChannel0, ro+rd*t + .0*vec3(iTime, iTime, iTime)*n.yzx,n).xxx * vec3(.1, 11., 0.1);\n    vec3 albedo = pow(tex3D(iChannel1, ro+rd*t,n).xxx, vec3(2.));\n    float l;\n    bool le = false;\n    float ref_str = 1.;\n    vec3 amb = vec3(0.);\n    if (mat == 1. && false){ \n        ref_str = .1;\n       amb = vec3(.0, .3, .1) / 12.;\n        albedo *= 2.;\n   }\n    vec3 closest_lc = get_light(p, l, false);\n    if (res.x > .0f) {\n//    return closest_lc;\n        if (res.y == 1.) { \n            vec3 ref = reflect(rd, n);\n            res = castRay(p, ref, lc, true, mat);\n            p = p + ref * res.x;\n            n = calcNormal(p);\n            closest_lc = get_light(p, l, false) * ref_str;\n            le = true;\n        }\n        if (res.y == 2.) {\n            col = lc * 2.;\n        } else if (res.y == 3.){\n            col = lc;\n        }else {\n            col = amb + light_equation(p, n, albedo, closest_lc, l, 0.);\n            if (mat == 1.)\n                col *= 2.;\n        }\n    }\n//    col = vec3(0.);\n    col += 4.*rmLight(ro, rd, res.x);\n//  col = mix(col, vec3(0.), min(1., res.x * res.x / 500. ) );\n  \n   \treturn vec3(col);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = vec2(0);//iMouse.xy/iResolution.xy;\n\tfloat time = .0f; //iTime;\n\n    // camera\t\n    vec3 ro = vec3(.0f, .0f, -4.0f + iTime * 4.);//vec3( 4.6*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.6*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -0.5, -0.4, 0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = normalize( vec3(p.xy,2.) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);   \n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcfGDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 77, 176, 953], [1070, 1139, 1167, 1167, 1253], [1255, 1255, 1266, 1266, 1352], [1354, 1354, 1364, 1364, 1442], [1444, 1444, 1462, 1462, 1896], [1897, 1897, 1922, 1922, 2075], [2077, 2077, 2106, 2106, 2482], [2484, 2484, 2530, 2530, 2892], [2893, 2893, 2946, 2946, 3704], [3705, 3705, 3751, 3793, 5210], [5213, 5213, 5262, 5262, 5470], [5472, 5472, 5516, 5516, 5908], [5910, 5910, 5953, 5953, 6443], [6447, 6447, 6497, 6535, 6946], [6948, 6948, 6993, 6993, 7417], [7419, 7419, 7463, 7555, 7698], [7699, 7699, 7756, 7756, 8370], [8399, 8399, 8482, 8482, 8959], [8963, 9009, 9041, 9041, 9293], [9296, 9296, 9348, 9348, 9525], [9527, 9527, 9606, 9606, 9803], [9805, 9805, 9844, 9844, 11229]], "test": "untested"}
{"id": "McsGD4", "name": "Planetary rings lookup texture", "author": "barth", "description": "This is a lookup texture (LUT) for planetary rings used in CosmosJourneyer. More informations about the creation of this texture can be found at http://barthpaleologue.github.io/Blog/posts/making-shaders-faster-1/", "tags": ["rings", "planet", "lut"], "likes": 1, "viewed": 229, "published": 3, "date": "1703091706", "time_retrieved": "2024-07-30T17:15:31.707300", "image_code": "const float seed = 0.0; // noise offset for unique rings\nconst float frequency = 30.0; // noise frequency\nconst float ringStart = 2.0; // relative distance where the ring starts\nconst float ringEnd = 3.0; // relative distance where the ring ends\n\n\nfloat mod289(float x){ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x){ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 perm(vec4 x){ return mod289(((x * 34.0) + 1.0) * x); }\n\nfloat noise(float r) {\n    float a = floor(r);\n    float d = r - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = vec4(a) + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + vec4(a);\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d + o1 * (1.0 - d);\n    vec2 o4 = o3.yw * d + o3.xz * (1.0 - d);\n\n    return o4.y * d + o4.x * (1.0 - d);\n}\n\n\nfloat fbm(float r, int nbOctaves, float decay, float lacunarity) {\n    float totalAmplitude = 0.0;\n    float amp = 1.0;\n    float samplePointMultiplier = 1.0;\n    float value = 0.0;\n    for (int i = 0; i < nbOctaves; i++) {\n        amp /= decay;\n        samplePointMultiplier *= lacunarity;\n        totalAmplitude += amp;\n        value += amp * noise(r * samplePointMultiplier);\n    }\n    return value / totalAmplitude;\n}\n\n// remap a value comprised between low1 and high1 to a value between low2 and high2\nfloat remap(float value, float low1, float high1, float low2, float high2) {\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // reversed remapping\n    float relativeDistance = remap(uv.x, 0.0, 1.0, ringStart, ringEnd);\n\n    // layer noise to get a more interesting result\n    float macroRingDensity = fbm(fract(seed) + relativeDistance * frequency / 10.0, 1, 2.0, 2.0);\n    float ringDensity = fbm(fract(seed) + relativeDistance * frequency, 5, 2.0, 2.0);\n    ringDensity = mix(ringDensity, macroRingDensity, 0.5);\n\n    // fade out the ring at the start and the end\n    ringDensity *= smoothstep(ringStart, ringStart + 0.03, relativeDistance);\n    ringDensity *= smoothstep(ringEnd, ringEnd - 0.03, relativeDistance);\n\n    // accentuate density gradient\n    ringDensity *= ringDensity;\n\n\n    // Output to screen\n    fragColor = vec4(vec3(ringDensity),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/McsGD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 248, 270, 270, 317], [318, 318, 338, 338, 385], [386, 386, 404, 404, 445], [447, 447, 469, 469, 952], [955, 955, 1021, 1021, 1376], [1378, 1462, 1538, 1538, 1608], [1610, 1610, 1667, 1717, 2496]], "test": "untested"}
{"id": "MclGW4", "name": "Playground ACES", "author": "GrooveDZX", "description": "Shader description", "tags": ["common"], "likes": 0, "viewed": 136, "published": 3, "date": "1703088708", "time_retrieved": "2024-07-30T17:15:32.538079", "image_code": "float plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nfloat smoothINV_ACES(float x)\n{\n    float DELTA = 0.04;// Modify this value if you want to change the way the functions are mixed together\n    float MERGE_POINT = 0.0225;\n    float INV_ACES = (sqrt(-10127.*x*x + 13702.*x+9.) + 59.0*x-3.0) / (502.0 - 486.0*x);\n    return mix(x, INV_ACES, 1.0-smoothstep(MERGE_POINT-DELTA, MERGE_POINT+DELTA, x));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    \n    float y = smoothINV_ACES(st.x);\n    //float y = (sqrt(-10127.*x*x + 13702.*x+9.) + 59.0*x-3.0) / (502.0 - 486.0*x); // For comparison\n    \n    vec3 color = vec3(y);\n    float pct = plot(st,y);\n    color = (1.0-pct)*color+pct*vec3(0.0,1.0,0.0);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MclGW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 122], [124, 124, 155, 155, 476], [478, 478, 535, 535, 875]], "test": "untested"}
{"id": "4clGW4", "name": "corona tilings / Heesch problem2", "author": "FabriceNeyret2", "description": "How many coronas can you do around one given tile ?\nMouse click + drag tile, Mouse.x + SPACE to rotate.\nAnswer here: https://shadertoy.com/view/Mcf3D4\nref: https://en.wikipedia.org/wiki/Heesch%27s_problem\n", "tags": ["tiling", "puzzle", "short", "reproduction"], "likes": 18, "viewed": 365, "published": 3, "date": "1703080333", "time_retrieved": "2024-07-30T17:15:33.325972", "image_code": "// interactive variant of https://shadertoy.com/view/Mcf3D4\n\n#define S(v) smoothstep(20./R.y,0., v)           // AA draw\n\nfloat M(vec2 U, float a) {                       // --- tear-shape tile SDF\n    U *= 8.* mat2(cos( a - vec4(0,33,11,0)));    // local frame â to peak direction\n    U.y = abs(U.y);                              // tear symmetry\n    float l = length(U);\n    return U.x/l < .867 || l*l > 3. \n      ? l  - 1.                                  // circle part\n      : 1. - length( U - vec2(1.732,1) );        // peak part\n}\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u / R.y;\n         \n    float d = 9.;\n    for(int i; i<12; i++)                        \n        d = min( d, M( U - T(i).xy, T(i).z ) );  // find tile closest to the pixel\n                                        \n    O = vec4( max( S( abs(d) ) ,                 // outline\n                   .5 * S(d) ) );                // fill\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === manage tiles. .xy = pos, .z = angle, .w = edit\n\n#define keyDown(a)  ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    int i = int(u), k, j;\n    if ( i > 11 || u.y > 1. ) return;                // we manage 12 tiles\n    \n    O = iFrame < 1                                   // init: tile on grid, random angle\n        ? vec4( vec2(i%4, i/4)/vec2(3,2)*(R/R.y-.3)+.15, float(i*16807%31)*6.28/31., 0 )\n        : T(i);                                      // previous state\n        \n    if ( iMouse.z > 0. ) {                           // mouse pressed\n        vec2 M = iMouse.xy / R.y;\n        if ( iMouse.w > 0. ) {                       // on click\n            float d = 9., l;\n            for(; k<12; k++ ) {\n                l = length( M - T(k).xy );           // find tile closest to mouse\n                if ( l < d ) j = k, d = l;\n            }\n            O.w = float( j == i && d < .125 );       // set edit mode for the closest ( if under mouse )\n        }\n        if( O.w == 1. )                              // tile in edit mode:\n            if ( keyDown(32) )   \n                 O.z -= .05* ( M.x - T(i).x );       //   SPACE pressed: tilt angle\n            else O.xy = M;                           //   else: follow mouse\n     }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(i) texelFetch( iChannel0, ivec2(i,0), 0 )\n#define R    iResolution.xy\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4clGW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 148, 197, 539], [542, 542, 580, 580, 923]], "test": "untested"}
{"id": "lcf3DN", "name": "Bicubic texture dithering", "author": "FordPerfect", "description": "Bottom left - nearest.\nBottom right - linear-dithered.\nTop left - cubic-dithered.\nTop right - linear.", "tags": ["texture", "dither", "cubic"], "likes": 12, "viewed": 314, "published": 3, "date": "1703076061", "time_retrieved": "2024-07-30T17:15:34.097909", "image_code": "// Public Domain under http://unlicense.org, see link for details.\n\n// A reasonably well-known technique (sometimes called \"poor man's bilinear\")\n// mimics bilinear filtering via dithering in texture space. See e.g.:\n//     https://www.flipcode.com/archives/Texturing_As_In_Unreal.shtml\n//     https://hugi.scene.org/online/coding/hugi%2020%20-%20cobil.htm\n// This shader demonstrates a bicubic variation of the technique.\n// This approach cannot use sharp kernels (with negative lobes, e.g.\n// Catmull-Rom), since while negative weights make sense, the negative\n// probabilities do not. This specific example uses cubic B-spline\n// (i.e. BC-spline with B=1, C=0).\n// This is still a 1-tap texturing approach, but the computations are\n// somewhat heavier.\n// While the merits of this approach are debatable (blurry and\n// not that cheap), now you at least can see what it looks like.\n\nivec2 XY; // Pixel coordinates.\n\n// https://www.shadertoy.com/view/dllSW7\nuint hash(uint x)\n{\n    x ^= x >> 15;\n    x ^= (x * x) | 1u;\n    x ^= x >> 17;\n    x *= 0x9E3779B9u;\n    x ^= x >> 13;\n    return x;\n}\n\n// \"Manual\" nearest. It is possible instead to bind\n// the same texture to a different channel set to nearest,\n// but whatever.\nvec4 texture_nearest(sampler2D s,vec2 uv)\n{\n    vec2 wh=vec2(textureSize(s,0));\n    uv=uv*wh;\n    uv=mod(uv,wh);\n    return texelFetch(s,ivec2(uv),0);\n}\n\nvec4 texture_dither_linear(sampler2D s,vec2 uv)\n{\n    vec2 wh=vec2(textureSize(s,0));\n    uv=uv*wh;\n    uv-=0.5; // Half-texel offset (so that samples are at integers).\n    uint h=hash(uint(65536*XY.y+XY.x)); // Screen-space hash.\n    vec2 d=vec2(h>>16,h&65535u)/65536.0; // White noise dither. Blue might be better.\n    uv+=d;\n    uv=mod(uv,wh);\n    return texelFetch(s,ivec2(uv),0);\n}\n\nvec4 texture_dither_cubic(sampler2D s,vec2 uv)\n{\n    vec2 wh=vec2(textureSize(s,0));\n    uv=uv*wh;\n    uv-=0.5; // Half-texel offset (so that samples are at integers).\n    vec2 t=uv-floor(uv);\n    uv=floor(uv);\n    uint h=hash(uint(65536*XY.y+XY.x)); // Screen-space hash.\n    vec2 d=vec2(h>>16,h&65535u)/65536.0; // White noise dither. Blue might be better.\n    // It would be *nice* to just remap d via some\n    // transform f [0;1]->[lo;hi], so that distinct results of\n    // floor(f(d)) would have the probabilities we need. Finding\n    // such transform, however, looks non-trivial, so we do\n    // a low-tech solution instead.\n    // Below are 3 thresholds, which are just cumulative weights\n    // of our B-spline (multiplied by 6).\n    vec2 w0=1.0+t*(-3.0+t*(+3.0+t*-1.0)); // weight[-1]\n    vec2 w1=5.0+t*(-3.0+t*(-3.0+t*+2.0)); // weight[-1]+weight[0]\n    vec2 w2=6.0-t*t*t; // weight[-1]+weight[0]+weight[+1]\n    d*=6.0;\n    uv+=step(w0,d)+step(w1,d)+step(w2,d)-1.0;\n    uv=mod(uv,wh);\n    return texelFetch(s,ivec2(uv),0);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    float scale=64.0;\n    XY=ivec2(fragCoord);\n    vec2 xy=(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 uv=(xy+0.25*iTime)/scale;\n    vec3 col=vec3(0);\n    switch((xy.x>0.0?1:0)+(xy.y>0.0?2:0))\n    {\n        case 0: col=texture_nearest      (iChannel0,uv).xyz; break;\n        case 1: col=texture_dither_linear(iChannel0,uv).xyz; break;\n        case 2: col=texture_dither_cubic (iChannel0,uv).xyz; break;\n        case 3: col=texture              (iChannel0,uv).xyz; break;\n    }\n    fragColor=vec4(col,1.0);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcf3DN.jpg", "access": "api", "license": "public-domain", "functions": [[918, 959, 978, 978, 1093], [1095, 1223, 1266, 1266, 1375], [1377, 1377, 1426, 1426, 1763], [1765, 1765, 1813, 1813, 2802], [2804, 2804, 2858, 2858, 3377]], "test": "untested"}
{"id": "Mcf3WN", "name": "Classical Snowglobe", "author": "dr2", "description": "Night view of a stylish (Palladian) residence (mouseable)", "tags": ["snowglobe"], "likes": 29, "viewed": 361, "published": 3, "date": "1703070681", "time_retrieved": "2024-07-30T17:15:35.043380", "image_code": "#define Ck min(IH,0)\n#define XY(x)(sin((x)+vec2(0.5*ZN,0.)))\n#define JX(Ow)if(Bu<Im){Im=Bu; WZ=Ow; Wa=Up;}\nconst int Hn=1,Cg=2,Qh=3,Av=4,DR=5,YK=6,TD=7,IY=8,RS=9,FC=10,Vo=11;const float ZN=3.1415927;vec3 Tm,UX,Wa,Nt,ON,Sj,Cx;vec2 RF[2],LI;float Jt,SA,LZ,ID,Ko,Vb,PU,Tq[2],AQ,Le,GW,My,DV,FT,SE;int IH,WZ;bool Ei,Mu;float GF(vec3 Yc,vec3 Ng){vec3 Bu;Bu=abs(Yc)-Ng;return min(max(Bu.x,max(Bu.y,Bu.z)),0.)+length(max(Bu,0.));}float Nx(vec3 Yc,vec3 Ng,float CS){return length(max(abs(Yc)-Ng,0.))-CS;}float EU(vec2 Yc,vec2 Ng){vec2 Bu;Bu=abs(Yc)-Ng;return min(max(Bu.x,Bu.y),0.)+length(max(Bu,0.));}float LM(vec2 Yc,vec2 Ng,float CS){return length(max(abs(Yc)-Ng,0.))-CS;}float Pi(vec3 Yc,float Bh){return length(Yc)-Bh;}float Kb(vec3 Yc,float Bh,float HE){return max(length(Yc.xy)-Bh,abs(Yc.z)-HE);}float Iq(vec3 Yc,vec2 ZJ,float Bh,float HE){float Bu;Bu=max(dot(vec2(length(Yc.xy)-Bh,Yc.z),ZJ),abs(Yc.z)-HE);HE/=ZJ.x*ZJ.x;Bh/=ZJ.x;Bu=min(Bu,min(length(vec3(Yc.xy,Yc.z+Bh*ZJ.y-HE))-Bh+HE*ZJ.y,length(vec3(Yc.xy,Yc.z+Bh*ZJ.y+HE))-Bh-HE*ZJ.y));return Bu;}float QT(vec3 Yc,float Bu){vec2 Zs;Zs=vec2(1.,-1.)/sqrt(3.);return max(max(dot(Yc,Zs.yxx),dot(Yc,Zs.xyx)),max(dot(Yc,Zs.xxy),dot(Yc,Zs.yyy)))-Bu;}float Yt(vec2 Yc){return min(Yc.x,Yc.y);}float WI(vec3 Yc){return max(Yc.x,max(Yc.y,Yc.z));}float Ae(vec3 Yc){return min(Yc.x,min(Yc.y,Yc.z));}mat3 FX(float Bd,float Fh){vec2 UG,NK,OR;UG=vec2(Bd,Fh);NK=cos(UG);OR=sin(UG);return mat3(NK.y,0.,-OR.y,0.,1.,0.,OR.y,0.,NK.y)*mat3(1.,0.,0.,0.,NK.x,-OR.x,0.,OR.x,NK.x);}vec2 Lv(vec2 Up,float BL){vec2 ZJ;ZJ=sin(BL+vec2(0.5*ZN,0.));return vec2(dot(Up,vec2(ZJ.x,-ZJ.y)),dot(Up.yx,ZJ));}vec2 JK(vec2 Up,vec2 ZJ){return vec2(dot(Up,vec2(ZJ.x,-ZJ.y)),dot(Up.yx,ZJ));}const float Rg=43758.54;float Jp(vec2 Yc){return fract(sin(dot(Yc,vec2(37.,39.)))*Rg);}vec2 La(vec2 Yc){vec2 SR=vec2(37.,39.);return fract(sin(dot(Yc,SR)+vec2(0.,SR.x))*Rg);}vec3 ML(float Yc){return fract(sin(Yc+vec3(37.,39.,41.))*Rg);}float Ks(vec2 Yc){vec2 HI,KJ,JG;KJ=floor(Yc);JG=fract(Yc);JG=JG*JG*(3.-2.*JG);HI=mix(La(KJ),La(KJ+vec2(0.,1.)),JG.y);return mix(HI.x,HI.y,JG.x);}float Gk(vec2 Yc){float Ez,BL;Ez=0.;BL=1.;for(int Of=0;Of<5;Of++){Ez+=BL*Ks(Yc);BL*=0.5;Yc*=2.;}return Ez*(1./1.9375);}float HV(vec3 Yc,vec3 DA){vec3 Ng;float BL;Ng=vec3(0.);BL=1.;for(int Of=0;Of<5;Of++){Ng+=BL*vec3(Ks(Yc.yz),Ks(Yc.zx),Ks(Yc.xy));BL*=0.5;Yc*=2.;}return dot(Ng,abs(DA));}vec3 Az(vec3 Yc,vec3 DA,float Ez){vec4 YO;vec3 HE;vec2 Zs;Zs=vec2(0.1,0.);for(int Of=Ck;Of<=3;Of++)YO[Of]=HV(Yc+((Of<2)?((Of==0)?Zs.xyy:Zs.yxy):((Of==2)?Zs.yyx:Zs.yyy)),DA);HE=YO.xyz-YO.w;return normalize(DA+Ez*(HE-DA*dot(DA,HE)));}float Md(vec3 Yc){vec3 Up,Dj;vec2 Vs;float Im,Bu,Yx,Pe,EQ;Pe=0.48;Im=SA;Dj=Yc;Dj.xz=mix(abs(Dj.xz),abs(Dj.zx),step(abs(Dj.z),abs(Dj.x)));Up=Dj;Up.yz-=vec2(ID,LZ);Yx=abs(abs(Up.x)-2.1)-0.4;Bu=EU(vec2(Up.y,Up.z),vec2(ID,Ko));for(int PQ=0;PQ<2;PQ++)Bu=max(min(Bu,Nx(vec3(Yx,Up.y+Tq[PQ],Up.z),vec3(RF[PQ],Ko),0.03)),-EU(vec2(Yx,Up.y+Tq[PQ]),RF[PQ]));Bu=min(Bu,Nx(vec3(Up.x,Up.y+Pe,Up.z),vec3(Nt.xy*vec2(2.,1.),0.04),0.04));Bu=max(Bu,-EU(vec2(Up.x,Up.y+Pe),Nt.xy*vec2(2.,1.)));JX(Hn);Up=Dj;Up.yz-=vec2(ID-Pe,LZ);Up.x=abs(Up.x);Up.xz-=vec2(0.2,0.01);Up.xz=JK(Up.xz-Nt.xz*vec2(1.,-1.),LI)+Nt.xz*vec2(1.,-1.);Bu=GF(Up,Nt);JX(RS);Up=Dj;Up.yz-=vec2(ID,LZ);Vs=vec2(abs(abs(Yx)-0.5*Vb)-0.5*Vb,abs(abs(Up.y+Tq[0])-0.5*RF[0].y)-0.5*RF[0].y);EQ=length(vec2(Vs.x,Up.z))-PU;Bu=min(max(EQ,abs(Vs.y)-RF[0].y),Kb(vec3(Vs,Up.z).yzx,PU,RF[0].x));JX(IY);Vs.y=abs(Up.y+Tq[1])-RF[1].y;Bu=min(max(EQ,abs(Vs.y)-RF[1].y),Kb(vec3(Vs,Up.z).yzx,PU,RF[1].x));JX(IY);Up=Dj;Up.yz-=vec2(2.8,LZ);Bu=max(abs(dot(vec2(Up.y,-Up.z),XY(-0.1*ZN)))-0.02,Up.z-Ko);Bu=max(Bu,1.-length(Yc.xz));JX(Cg);Up=Yc;Up.y-=3.;Bu=max(abs(length(vec3(Up.xz,max(Up.y,0.8)).xzy)-1.28)-0.02,0.3-Up.y);Bu=max(Bu,0.1-length(vec2(Dj.x,Up.y-0.63)));JX(Qh);Up=Yc;Up.y=abs(Up.y-0.2)-0.18;Bu=Nx(Up,vec3(LZ+Ko,0.,LZ+Ko),0.02);Up=Yc;Up.y=abs(Up.y-2.23)-0.55;Bu=min(Bu,Nx(Up,vec3(LZ+Ko,0.,LZ+Ko),0.02));JX(TD);Up=Dj;Up.yz-=vec2(0.9,LZ+0.5);Bu=EU(Up.xz,vec2(1.3,0.5));Up.y-=1.65;Vs.y=dot(Up.yx,XY(0.1*ZN));Bu=max(Bu,max(max(Vs.y,-0.45-Up.y),-max(max(Vs.y+0.06,-0.39-Up.y),0.42-Up.z)));Bu=max(Bu,-Kb(Up-vec3(0.,-0.25,0.47),0.08,0.1));JX(Av);Up=Dj;Vs=Up.yz-2.1;Vs=20.*vec2(Vs.x+Vs.y,-Vs.x+Vs.y)/sqrt(2.);Bu=(1./20.)*(Vs.x-abs(0.5-abs(0.5-fract(Vs.y/sqrt(2.))))*sqrt(2.));Bu=0.5*max(Bu,max(max(abs(Up.x)-1.3,abs(Up.y-0.2)-0.2),LZ-Up.z));JX(DR);Up=Dj;Up.yz-=vec2(1.25,LZ+0.6);Bu=1.3-abs(Up.x);Up.x=(fract(2.2*Up.x)-0.5)/2.2;Bu=max(min(Kb(Up.xzy,0.06,0.85),GF(vec3(Up.x,abs(Up.y)-0.83,Up.z),vec3(0.08,0.02,0.08))),-Bu);JX(YK);Up=Dj;Up.x=abs(Up.x);Up-=vec3(2.7,0.15,LZ+2.5);Bu=LM(vec2(length(Up.xz)-0.55,Up.y),vec2(0.15,0.2)-0.1,0.1);JX(FC);Up.y-=1.25;Bu=Iq(Up.xzy,XY(0.03*ZN),0.15,1.1);JX(FC);Up=Dj;Up.x=abs(Up.x);Up-=vec3(1.45,0.2,LZ+3.1);Bu=Nx(Up,vec3(0.15,0.25,1.6)-0.1,0.1);JX(FC);Up=Yc;Up.xz=Lv(Up.xz,2.*ZN*(floor(32.*atan(Up.z,-Up.x)/(2.*ZN)+0.5))/32.);Up.xy-=vec2(-8.5,1.);Bu=Iq(Up.xzy,XY(0.04*ZN),0.15,0.75);Bu=max(Bu,1.3-abs(Dj.x));JX(FC);Up=Yc;Up.y-=-0.51;Bu=Kb(Up.xzy,AQ,0.51);JX(Vo);return Im;}float Pz(vec3 Go,vec3 CS){float GB,Bu;GB=0.;for(int Of=Ck;Of<120;Of++){Bu=Md(Go+GB*CS);if(Bu<0.0005||GB>SA)break;GB+=Bu;}return GB;}vec3 NO(vec3 Yc){vec4 YO;vec2 Zs;Zs=2e-4*vec2(1.,-1.);for(int Of=Ck;Of<=3;Of++){YO[Of]=Md(Yc+((Of<2)?((Of==0)?Zs.xxx:Zs.xyy):((Of==2)?Zs.yxy:Zs.yyx)));}YO.x=-YO.x;return normalize(2.*YO.yzw-dot(YO,vec4(1.)));}float Rk(vec3 Go,vec3 CS){float Sn,Bu,HE;Sn=1.;Bu=0.02;for(int Of=Ck;Of<40;Of++){HE=Md(Go+Bu*CS);Sn=min(Sn,smoothstep(0.,0.05*Bu,HE));Bu+=HE;if(Sn<0.05)break;}return Mu?0.7+0.3*Sn:0.5+0.5*Sn;}float VF(vec3 Yc){vec3 Up;float Bu;Bu=SA/FT;if(Ei){Yc-=Sj;Yc/=FT;Yc.yz=JK(Yc.yz,XY(Cx.x));Yc.xz=JK(Yc.xz,XY(Cx.y));Yc.xy=JK(Yc.xy,XY(Cx.z));for(float PQ=-1.;PQ<=1.;PQ+=2.){Up=Yc;Up.y*=PQ;Up.xz=JK(Up.xz,XY(-PQ*ZN/6.));Up.xy=JK(Up.xy,XY(ZN/2.-0.5*acos(1./3.)));Up.xz=JK(Up.xz,XY(ZN/4.));Bu=min(Bu,QT(Up,0.04));}}return FT*Bu;}void AM(vec3 Yc){vec3 KN,Up;KN=ML(dot(ON,vec3(31.1,41.1,51.1))+99.);Ei=(length(ON.xz+0.5)<AQ&&length(KN)<sqrt(3.)*SE);if(Ei){Up=ON+0.5;Sj=Up+0.3*cos((1.+KN)*Jt+KN.zxy);Cx=2.*(KN-0.5)*Jt;Up.y=floor(Up.y-DV);FT=0.001+0.999*smoothstep(0.,0.1*AQ,min(AQ-length(Up),Yc.y));}}vec3 TU(vec3 Yc){ON.xz=floor(Yc.xz);DV=My*Jt*(1.+Jp(ON.xz));Yc.y+=DV;ON.y=floor(Yc.y);return Yc;}\nfloat Zb(vec3 Go,vec3 CS){vec3 Yc,By,Qy,ED;float GB,Bu,CO;CO=0.001;if(CS.x==0.)CS.x=0.001;if(CS.y==0.)CS.y=0.001;if(CS.z==0.)CS.z=0.001;ED=1./CS;Qy=vec3(-999.);GB=CO;for(int Of=Ck;Of<160;Of++){By=Go+GB*CS;Yc=TU(By);if(ON!=Qy){AM(By);Qy=ON;}Bu=((length(floor(By+0.5))-1.)<AQ)?VF(Yc):SA;Bu=min(Bu,abs(Ae((ON+step(0.,CS)-Yc)*ED))+CO);GB+=Bu;if(Bu<CO||GB>SA)break;}if(Bu>=CO)GB=SA;return GB;}vec3 Xq(vec3 Yc){vec4 YO;vec2 Zs;Zs=2e-4*vec2(1.,-1.);for(int Of=Ck;Of<=3;Of++){YO[Of]=VF(Yc+((Of<2)?((Of==0)?Zs.xxx:Zs.xyy):((Of==2)?Zs.yxy:Zs.yyx)));}YO.x=-YO.x;return normalize(2.*YO.yzw-dot(YO,vec4(1.)));}float Ql(vec3 Yc){vec3 Up,Dj;float Im,Bu,Yx;Im=SA;Dj=Yc;Dj.xz=mix(abs(Dj.xz),abs(Dj.zx),step(abs(Dj.z),abs(Dj.x)));Up=Dj;Up.yz-=vec2(ID,LZ);Yx=abs(abs(Up.x)-2.1)-0.4;Bu=Im;for(int PQ=0;PQ<2;PQ++)Bu=min(Bu,EU(vec2(Yx,Up.y+Tq[PQ]),RF[PQ]));Bu=max(Bu,abs(Up.z)-PU+0.004);JX(0);Up=Yc;Bu=max(abs(length(Up.xz)-1.)-0.02,length(vec2(Dj.x,Up.y-3.63))-0.1);JX(0);return Im;}float TH(vec3 Go,vec3 CS){float GB,Bu;GB=0.;for(int Of=Ck;Of<50;Of++){Bu=Ql(Go+GB*CS);if(Bu<0.0005||GB>SA)break;GB+=Bu;}return GB;}vec3 RW(vec3 Yc){vec4 YO;vec2 Zs;Zs=2e-4*vec2(1.,-1.);for(int Of=Ck;Of<=3;Of++){YO[Of]=Ql(Yc+((Of<2)?((Of==0)?Zs.xxx:Zs.xyy):((Of==2)?Zs.yxy:Zs.yyx)));}YO.x=-YO.x;return normalize(2.*YO.yzw-dot(YO,vec4(1.)));}vec4 Zf(vec3 Go,vec3 CS,float Zw){vec3 Hr;float GS,Bu,WM;GS=dot(CS,Go);WM=GS*GS+Zw*Zw-dot(Go,Go);Bu=SA;if(WM>0.){Bu=-GS-sqrt(WM);Hr=(Go+Bu*CS)/Zw;}return vec4(Bu,Hr);}vec3 Em(vec3 CS,float QC){vec3 OA,XL,Vs;vec2 Up;float Ez;OA=-1./max(abs(CS),0.0001);XL=-sign(CS)*step(OA.zxy,OA)*step(OA.yzx,OA);Vs=WI(OA)*CS;Up=atan(vec2(dot(Vs.zxy,XL),dot(Vs.yzx,XL)),vec2(1.))/ZN;Ez=0.57*(Gk(11.*dot(0.5*(XL+1.),vec3(1.,2.,4.))+131.13*QC*Up)+Gk(13.*dot(0.5*(XL+1.),vec3(1.,2.,4.))+171.13*QC*Up.yx));return 4.*vec3(1.,1.,0.8)*pow(Ez,16.);}vec3 VJ(vec3 CS){vec3 UC;if(Mu)UC=vec3(0.,0.,0.05)+Em(CS,8.);else{CS.y=abs(CS.y);UC=mix(vec3(0.3,0.35,0.7),vec3(0.8,0.8,0.8),clamp(2.*(Gk(2.*CS.xz/CS.y+0.1*Jt)-0.1)*CS.y,0.,1.));}return UC;}vec3 TY(vec3 Go,vec3 CS){vec4 Wn,Df;vec3 UC,Hr,HZ,Jc;vec2 FG,Vs;float VW,XH,Ul,QP,Xu,Sn,HI;bool Wr;LZ=3.;ID=1.4;Ko=0.05;PU=0.012;Vb=0.18;RF[0]=vec2(Vb,0.45);RF[1]=vec2(Vb,0.2);Tq[0]=0.35;Tq[1]=-0.95;Nt=vec3(0.2,0.55,0.02);LI=XY(-0.5*ZN*clamp(-0.3+1.6*abs(2.*fract(0.25*Jt)-1.),0.,1.)*(1.-smoothstep(0.01,0.1,SE)));Wr=true;HZ=Go;VW=Pz(Go,CS);if(VW<SA){Go+=VW*CS;Hr=NO(Go);FG=vec2(0.);if(WZ==Hn){if(Wa.z<0.){Wn=vec4(0.7,0.7,0.75,0.05);Wr=false;}else{Wn=vec4(0.9,0.9,0.5,0.02);if(abs(Wa.z-0.05)<0.002){Vs=Wa.xy*vec2(1./6.,1.)*16.;if(abs(Hr.x)<abs(Hr.z))Vs.x+=0.5;HI=Vs.x+1./3.+((fract(0.5*Vs.y)<0.5)?0.:0.5);Wn*=0.8+0.2*smoothstep(0.12,0.15,min(fract(Vs.y),6.*min(fract(HI),fract(HI+2./3.))));FG=vec2(64.,1.);}}}else if(WZ==Cg){Wn=vec4(1.,0.5,0.,0.1)*(0.8+0.2*smoothstep(0.08,0.1,fract(8.*Wa.z)));FG=vec2(64.,0.1);}else if(WZ==Qh){if(Wa.y>0.8){Wn=vec4(0.95,1.,0.95,0.05)*(0.9+0.1*smoothstep(0.08,0.1,fract(8.*length(Wa.xz)+0.5)));}else{Wn=vec4(0.9,0.9,0.5,0.1);FG=vec2(64.,0.5);}}else if(WZ==TD){if(max(abs(Wa.x),abs(Wa.z))>LZ){Wn=vec4(0.7,0.7,0.4,0.1);}else{Wn=(Hr.y>0.)?vec4(0.7,0.4,0.2,0.05):vec4(1.,1.,1.,0.05);Wr=false;}}else if(WZ==Av){Wn=vec4(0.8,0.8,0.7,0.1);FG=vec2(64.,0.5);}else if(WZ==DR){Wn=vec4(0.8,0.8,0.7,0.1);FG=vec2(64.,0.5);}else if(WZ==YK){Wn=vec4(0.8,0.7,0.7,0.1);if(abs(Wa.y)<0.81)Wn*=(0.8+0.2*smoothstep(0.06,0.08,fract(4.9*Wa.y)))*(1.-0.3*smoothstep(0.15,0.17,fract(16.*atan(Wa.z,Wa.x)/(2.*ZN)+0.5)));else FG=vec2(64.,0.5);}else if(WZ==IY){Wn=vec4(0.2,0.4,0.2,0.2);Wr=false;}else if(WZ==RS){Wn=vec4(0.7,0.3,0.1,0.1);Wn*=1.-0.5*smoothstep(0.01,0.012,EU(Wa.xy,Nt.xy-0.05));Wr=false;}else if(WZ==FC){Wn=vec4(0.,0.5,0.,0.);FG=vec2(16.,8.);}else if(WZ==Vo){if(Wa.y>0.5){if(Yt(abs(Wa.xz))<1.4||length(Wa.xz)<sqrt(2.)*LZ+0.5){Wn=vec4(0.8,0.8,0.6,0.1);FG=vec2(16.,0.2);}else{Wn=vec4(0.,0.8,0.,0.05);if(Hr.y>0.1)FG=vec2(8.,0.5);}}else{Wn=vec4(0.6,0.3,0.,0.1)*(0.8+0.2*sin(16.*ZN*Wa.y));}Wn.rgb*=0.7;}Xu=smoothstep(0.15,0.35,Le-0.15*Gk(2.*Go.xz+mod(GW,16.)))-smoothstep(0.8,0.95,Le);if(FG.y>0.){if(Xu>0.&&Wr&&Hr.y>0.01)FG=vec2(min(FG.x,16.),max(FG.y,0.2));Hr=Az(FG.x*Go,Hr,FG.y);}if(Xu>0.&&Wr&&Hr.y>0.01)Wn=mix(Wn,vec4(0.95,0.95,1.,0.1),Xu);Sn=Rk(Go+0.01*Hr,Tm);UC=Wn.rgb*(0.3+0.7*Sn*max(dot(Hr,Tm),0.))+Wn.a*step(0.95,Sn)*pow(max(dot(Tm,reflect(CS,Hr)),0.),32.);}else{UC=VJ(CS);}Go=HZ;XH=TH(Go,CS);if(XH<min(VW,SA)){Go+=XH*CS;Hr=RW(Go);UC=Mu?vec3(1.,0.7,0.2)*(0.2+0.6*max(-dot(Hr,CS),0.)):mix(UC,VJ(reflect(CS,Hr)),0.3+0.7*pow(1.-abs(dot(Hr,CS)),5.));}Go=HZ;Df=Zf(Go,CS,AQ);QP=Df.x;Jc=Df.yzw;if(QP<SA){Go+=QP*CS;Ul=Zb(Go,CS);if(Ul<min(VW,SA)){Hr=Xq(TU(Go+Ul*CS));UC=vec3(1.)*(0.2+0.8*max(-dot(CS,Hr),0.));}HI=0.;if(Go.y>0.)HI=0.02+0.05*max(dot(UX,Jc),0.)+0.25*pow(max(dot(reflect(UX,Jc),CS),0.),64.);if(Mu)HI*=2.;UC+=HI*vec3(1.);}return clamp(UC,0.,1.);}void mainImage(out vec4 Lr,in vec2 Nc){mat3 Oj;vec4 BP;vec3 Go,CS,UC;vec2 Pv,Xd;float Bd,Fh,Ai,Dw,CB,MP,HI;\nIH=iFrame;Pv=iResolution.xy;Xd=2.*Nc.xy/Pv-1.;Xd.x*=Pv.x/Pv.y;Jt=iTime;BP=iMouse;BP.xy=BP.xy/Pv-0.5;\nDw=Pv.x/Pv.y;Fh=0.;Bd=-0.1*ZN;if(BP.z>0.){Fh+=2.*ZN*BP.x;Bd+=0.5*ZN*BP.y;}else{HI=mod(0.007*Jt,2.);Fh=2.*ZN*(abs((floor(12.*HI)+smoothstep(0.8,1.,fract(12.*HI)))/12.-1.));}Bd=clamp(Bd,-0.25*ZN,-0.02*ZN);Oj=FX(Bd,Fh);AQ=10.;My=0.05*AQ;Go=Oj*vec3(0.,2.,-5.*AQ);Ai=4.5+1.2*abs(mod(Fh+ZN,2.*ZN)-ZN);SA=length(Go)+AQ;MP=25.;GW=floor(Jt/MP);Le=fract(Jt/MP);SE=smoothstep(0.05,0.5,Le)-smoothstep(0.65,0.8,Le);Mu=true;Tm=Oj*normalize(vec3(1.,1.,-1.));UX=Oj*normalize(vec3(0.6,1.,-0.03));const float Fl=3.;UC=vec3(0.);CB=2.*mod(dot(mod(floor(0.5*(Xd+1.)*Pv),2.),vec2(1.)),2.)-1.;for(float BL=float(Ck);BL<Fl;BL++){CS=Oj*normalize(vec3(Xd+step(1.5,Fl)*Lv(vec2(0.5/Pv.y,0.),CB*(0.667*BL+0.5)*ZN),Ai));UC+=(1./Fl)*TY(Go,CS);}Lr=vec4(UC,1.);}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mcf3WN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[314, 314, 340, 340, 422], [422, 422, 457, 457, 495], [495, 495, 521, 521, 593], [593, 593, 628, 628, 666], [666, 666, 693, 693, 715], [715, 715, 751, 751, 794], [794, 794, 838, 838, 1048], [1048, 1048, 1075, 1075, 1194], [1194, 1194, 1212, 1212, 1235], [1235, 1235, 1253, 1253, 1286], [1286, 1286, 1304, 1304, 1337], [1337, 1337, 1364, 1364, 1507], [1507, 1507, 1533, 1533, 1621], [1621, 1621, 1646, 1646, 1699], [1723, 1723, 1741, 1741, 1786], [1786, 1786, 1803, 1803, 1873], [1873, 1873, 1891, 1891, 1935], [1935, 1935, 1953, 1953, 2080], [2080, 2080, 2098, 2098, 2199], [2199, 2199, 2225, 2225, 2367], [2367, 2367, 2401, 2401, 2599], [2599, 2599, 2617, 2617, 5028], [5028, 5028, 5054, 5054, 5160], [5160, 5160, 5177, 5177, 5369], [5369, 5369, 5395, 5395, 5561], [5561, 5561, 5579, 5579, 5885], [5885, 5885, 5902, 5902, 6154], [6154, 6154, 6171, 6171, 6251], [6252, 6252, 6278, 6278, 6640], [6640, 6640, 6657, 6657, 6849], [6849, 6849, 6867, 6867, 7214], [7214, 7214, 7240, 7240, 7345], [7345, 7345, 7362, 7362, 7554], [7554, 7554, 7588, 7588, 7721], [7721, 7721, 7747, 7747, 8078], [8078, 8078, 8095, 8095, 8268], [8268, 8268, 8293, 8293, 11034], [11034, 11034, 11073, 11073, 11972]], "test": "untested"}
{"id": "Mcf3D4", "name": "corona tilings / Heesch problem", "author": "FabriceNeyret2", "description": "How many coronas can you do with one given tile ?\nCould you place one more ? (answer: no. For this tile, Heesch number = 1 crown ).\nTry by yourself here ! :-p â https://www.shadertoy.com/view/4clGW4\nref: https://en.wikipedia.org/wiki/Heesch%27s_problem\n", "tags": ["tiling", "short", "reproduction"], "likes": 27, "viewed": 392, "published": 3, "date": "1703064969", "time_retrieved": "2024-07-30T17:15:35.808335", "image_code": "// try the interactive version here: https://www.shadertoy.com/view/4clGW4\n\n#define S(v) smoothstep(20./R.y,0., v)     // AA draw\n \nvec2 D = vec2(1.732,1);\n\nfloat T(vec2 U, float a) {                 // --- tear-shape tile SDF\n    U *= mat2(cos( a - vec4(0,33,11,0)));  // local frame â to peak direction\n    U.y = abs(U.y);                        // tear symmetry\n    float l = length(U);\n // return atan(U.y,U.x) > 3.14/6. || dot(U,U) > 3. \n    return U.x/l < .867 || l*l > 3. \n      ? l  - 1.                            // circle part\n      : 1. - length( U - D );              // peak part\n}\n// note: we could either avoid the rotation by adjusting peak angle + D offset\n// or avoid the atan by just considering cos = U.x/length < sqrt(3)/2\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 4.* ( u+u - R ) / R.y,\n         E = vec2(-D.x,D.y), J = vec2(0,2);\n    \n    float d = min( min( min( T(U  ,0.)  , T(U-D-D+J,3.14) ),   // center & E\n                        min( T(U+D,0.)  , T(U-D,3.14 ) )  ),   // SW & NE\n                   min( min( T(U+E,0.)  , T(U-E,-1.05) ),      // SE & NW\n                        min( T(U+J,1.05), T(U-J,-2.1 ) ) ));   //  S & N                   \n                   \n    O = vec4( max( S( abs(d) ) ,           // outline\n                   .5 * S(d) ) );          // fill\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mcf3D4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 183, 226, 597], [749, 749, 787, 787, 1346]], "test": "untested"}
{"id": "4clGDH", "name": "spqr better aabb city", "author": "spqr", "description": "a", "tags": ["a"], "likes": 8, "viewed": 167, "published": 3, "date": "1703058763", "time_retrieved": "2024-07-30T17:15:36.572292", "image_code": "vec3 r;\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat hash11(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n\n  vec3 a =  \n  mix(\n      vec3(\n          hash11(mx)-.5,\n          hash11(my)-.5,\n          hash11(mz)-.5\n      ),\n      vec3(\n          hash11(nx)-.5,\n          hash11(ny)-.5,\n          hash11(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\n\n\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fractal(vec3 p) {\n\n  float d=0.5;\n  float f=0.0;\n  for(int i=0; i<5; ++i) {\n    f+=noise(p/d)*d;\n    d*=.5;\n  }\n  return f;\n}\n\nfloat hash21(vec2 p2)\n{\n\tp2  = fract(p2 * .1031);\n    p2 += dot(p2, p2.xy + 33.33);\n    return fract((p2.x + p2.y));\n}\n\nfloat closestWall(vec3 p) {\n    vec3 d = min(fract(p), 1.0 - fract(p));\n    return min(min(d.x, d.y), d.z);\n}\n\nfloat box (vec3 p, vec3 s) {\n    vec3 q = abs(p) - s;\n   // return max(max(q.x,q.y),q.z);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\n\nfloat fbm( vec2 a)\n{\n    vec3 p = vec3(a,1.);\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n  \n    return f;\n}\nfloat sph (vec3 p, float n) {\n    return length(p) -n ;\n}\n\nfloat aabb(vec3 p, vec3 d) {\n  \n    vec3 neg = -(d / 2. - p)/r;\n    vec3 pos =  (d / 2. - p)/r;\n\n    vec3 bot = min(neg, pos);\n \n    float top = max(max(bot.x, bot.y), bot.z);\n\n    return max(0.0, top); // Ensure we don't return a negative value\n}\n\n\nfloat field (vec3 p, float scale) {\n  \n   p *= scale;\n   vec3 id = floor(p)-.5; \n   p = fract(p) -.5;\n   \n   float f1 = hash31(id);\n \n  \n   float shape = box(p, vec3(f1 * .46));\n\n   float bound = aabb(p, vec3(scale*1.01));\n   \n   return min(bound , shape)/scale;\n}\nfloat hash(float n) {\n\n    return fract(sin(n*3553.2352)*452.322);\n}\nfloat map (vec3 p){\n    // geo\n   \n    vec3 q = p;\n    p = mod(p,20.) - 10.;\n    float pos = box(p,vec3(5));\n\n\n    for (float i = 1.; i < 10.; i++) {\n      \n            pos = max(pos, -field(q,pow(1.3,i)/16.));\n     \n    }\n    \n    return pos;\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat tick(float t){\n    float i = floor(t);\n    float f = fract(t);\n    f = smoothstep(0.,1.,f);\n    return i + f;\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\nfloat path (float t) {\n    float a = sin(sin(t) + .3 * t);\n    return a;\n    \n}\nfloat pathfbm(float t) {\n    float a = 0.;\n    \n    a += path( (t+0. ) );\n    a += path( (t+21.)*2.)/2.1;\n    a += path( (t+211.)*5.)/5.1;\n    \n    return a/2.;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n\n  float tt = iTime*.3;\n \n  // nav\n\n\n  vec3 s = vec3(0);\n  vec3 arm = vec3(0,0,1);\n  arm.xz *= rot(cos(tick(tt)));\n  arm.zy *= rot(cos(tick(tt*.6)));\n  vec3 fwd = lattice(tick(tt))*400.;\n  s += fwd;\n  vec3 t = s + arm;\n\n  \n\n \n\n  \n  \n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=-normalize(cross(cz,cx));\n  r=normalize(cx*uv.x+cy*uv.y+cz);\n  \n\n  vec3 p=s;\n  float i=0.;\n  float dd = 0.;\n  float d;\n  \n  // march\n  \n  bool hit = false;\n  for(float z=0.; z <200.; ++z) {\n    i = z;\n    d=abs(map(p)*.7);\n    if(d<0.001) {\n      hit = true;\n      break;\n    }\n    if ( dd > 500.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n\n  // color\n \n  vec3 n = norm(p);\n  vec3 light = normalize(vec3(-1,2,3));\n \n  \n\n\n  float diff = dot(n,light)*.5+.5;\n\n\n  \n  \n  vec3 col = vec3(0);\n  \n  col += diff;\n\n\n  \n  if ( ! hit ) {\n\n    col = vec3(1) - pow(r.y,.2);\n  }\n\n\n\n  \n \n  fragColor = vec4(col, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4clGDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[8, 8, 27, 27, 96], [100, 100, 142, 142, 249], [252, 252, 275, 275, 324], [326, 326, 351, 351, 826], [830, 830, 853, 853, 956], [957, 957, 978, 978, 1269], [1271, 1271, 1294, 1294, 1402], [1404, 1404, 1427, 1427, 1522], [1524, 1524, 1551, 1551, 1633], [1635, 1635, 1663, 1663, 1790], [1792, 1792, 1814, 1814, 1904], [1907, 1907, 1927, 1927, 2110], [2111, 2111, 2140, 2140, 2168], [2170, 2170, 2198, 2198, 2417], [2420, 2420, 2455, 2455, 2684], [2685, 2685, 2706, 2706, 2753], [2754, 2754, 2773, 2784, 2999], [3001, 3001, 3020, 3020, 3139], [3141, 3141, 3161, 3161, 3258], [3260, 3260, 3301, 3301, 3347], [3348, 3348, 3370, 3370, 3427], [3428, 3428, 3452, 3452, 3590], [3595, 3595, 3652, 3652, 4708]], "test": "untested"}
{"id": "lcs3DH", "name": "An introduction to Raymarching", "author": "kishimisu", "description": "[url]https://youtu.be/khblXafu7iA[/url]", "tags": ["raymarching"], "likes": 57, "viewed": 3608, "published": 3, "date": "1703040930", "time_retrieved": "2024-07-30T17:15:37.337247", "image_code": "// This scene is taken from my second tutorial about shader coding,\n// which introduces the concept of raymarching as well as some useful\n// transforms and space-bending techniques.\n// \n//     Mouse interactive!\n//                            Video URL: https://youtu.be/khblXafu7iA\n\n// 2D rotation function\nmat2 rot2D(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n// Custom gradient - https://iquilezles.org/articles/palettes/\nvec3 palette(float t) {\n    return .5+.5*cos(6.28318*(t+vec3(.3,.416,.557)));\n}\n\n// Octahedron SDF - https://iquilezles.org/articles/distfunctions/\nfloat sdOctahedron(vec3 p, float s) {\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n// Scene distance\nfloat map(vec3 p) {\n    p.z += iTime * .4; // Forward movement\n    \n    // Space repetition\n    p.xy = fract(p.xy) - .5;     // spacing: 1\n    p.z =  mod(p.z, .25) - .125; // spacing: .25\n    \n    return sdOctahedron(p, .15); // Octahedron\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2  m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    \n    // Default circular motion if mouse not clicked\n    if (iMouse.z <= 0.) m = vec2(cos(iTime*.2), sin(iTime*.2));\n\n    // Initialization\n    vec3 ro = vec3(0, 0, -3);         // ray origin\n    vec3 rd = normalize(vec3(uv, 1)); // ray direction\n    vec3 col = vec3(0);               // final pixel color\n\n    float t = 0.; // total distance travelled\n\n    int i; // Raymarching\n    for (i = 0; i < 80; i++) {\n        vec3 p = ro + rd * t; // position along the ray\n        \n        p.xy *= rot2D(t*.15 * m.x);     // rotate ray around z-axis\n\n        p.y += sin(t*(m.y+1.)*.5)*.35;  // wiggle ray\n\n        float d = map(p);     // current distance to the scene\n\n        t += d;               // \"march\" the ray\n\n        if (d < .001 || t > 100.) break; // early stop\n    }\n\n    // Coloring\n    col = palette(t*.04 + float(i)*.005);\n\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcs3DH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[283, 307, 328, 328, 380], [382, 445, 468, 468, 524], [526, 593, 630, 630, 687], [689, 707, 726, 726, 948], [950, 950, 1007, 1007, 2008]], "test": "untested"}
{"id": "XflGDH", "name": "The Problem of Apollonius in 3D", "author": "mla", "description": "Apollonian Spheres - given four spheres, find a sphere that touches all four. There are up to 16 solutions, shown here two at a time.\n\nUse mouse for rotation & up and down to zoom. See Common tab for the maths, which is quite fun.", "tags": ["spheres", "problem", "apollonius"], "likes": 14, "viewed": 263, "published": 3, "date": "1703023943", "time_retrieved": "2024-07-30T17:15:38.291695", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// The Problem of Apollonius in 3D, mla, 2023.\n//\n// Given four spheres, find another that touches them all. There are up to\n// 16 solutions (the configuration used here has all 16, shown two at a time).\n//\n// The tangent spheres are found by reducing one sphere to a point, which is\n// used as a centre of inversion. Then find a tangent plane to the inverted\n// spheres. Inverting that plane back gives the required sphere. The 16\n// solutions come from which side of the solution plane or circle the original\n// circles are.\n// \n// Controls:\n// <mouse>: rotate view\n// <up>/<down>: zoom in/out\n// 1,2: hide solution spheres 1,2\n// o: show orthogonal spheres\n// p: use zero sphere as animation base\n// r: rotation\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvec4 spheres[] = vec4[](vec4(1,1.5,0,1),\n                        vec4(1.2,-1.8,0,1.4),\n                        vec4(-1.5,0,2.1,1.2),\n                        vec4(-1,0,-2,1.1),\n                        vec4(0),\n                        vec4(0),\n                        vec4(0));\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) {\n    //p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  return p;\n}\n\nvec3 skycolor(vec3 r) {\n  //return vec3(1,1,0.5);\n  //return vec3(0.5,0.5,1);\n  //return pow(abs(r),vec3(2.0));\n  //return abs(transform(r));\n  return texture(iChannel0,r).rgb;\n}\n\nvec3 getcol(int i) {\n  if (i == 0) return vec3(1,0.75,0.75);\n  if (i == 1) return vec3(0.75,1,0.75);\n  if (i == 2) return vec3(0.75,0.75,1);\n  return vec3(1);\n}\n\nconst int NSPHERES = spheres.length();\nconst int MAXSTEPS = 20;\nfloat ambient = 0.2;\nfloat diffuse = 0.4;\nfloat specular = 0.6;\nfloat specularpow = 10.0;\nvec3 specularcolor = vec3(1);\n\nvec3 raycolor(vec3 p, vec3 r) {\n  vec3 att = vec3(1);\n  vec3 col = vec3(0);\n  vec3 light = normalize(vec3(1,2,3));\n  for (int i = 0; i < MAXSTEPS; i++) {\n    float t = 1e8;\n    int hitsphere = -1;\n    for (int j = 0; j < NSPHERES; j++) {\n      if (key(CHAR_0+1) && j == 4) continue;\n      if (key(CHAR_0+2) && j == 5) continue;\n      bool transparent = j >= 4; // Need proper materials\n      vec2 tt;\n      if (intersectsphere(p,r,spheres[j],tt)) {\n        if (tt[0] > 0.0) {\n          if (tt[0] < t) {\n            t = tt[0];\n            hitsphere = j;\n          }\n        } else if (transparent && tt[1] > 0.0)\n          if (tt[1] < t) {\n            t = tt[1];\n            hitsphere = j;\n          }\n      }\n    }\n    if (hitsphere == -1) {\n      col += att*skycolor(r);\n      return col;\n    }\n    p += (t+1e-4)*r; // Try not to get trapped\n    vec3 n = normalize(p-spheres[hitsphere].xyz); // Normal is just direction from sphere centre\n    if (hitsphere >= 4) {\n      // Need to add some colour here\n      float s = pow(max(0.0,dot(reflect(light,n),vec3(r))),specularpow);\n      vec3 scol = getcol(hitsphere-4);\n      col += att*specular*s*specularcolor;\n      col += att*0.1*scol*(ambient+diffuse*max(0.0,dot(light,n)));\n      //return att*col;\n      att *= 0.8*scol;\n    } else {\n      //att *= 0.9;\n      r = reflect(r,n);\n    }\n  }\n  return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float AA = 2.0;\n  vec3 col = vec3(0);\n  int signs = int(0.2*iTime);\n  float t = mod(iTime,5.0);\n  t = min(t,4.0-t);\n  t = clamp(t,0.0,1.0);\n  float k = smoothstep(0.0,1.0,t);\n  mat2x4 res = apollonius(mat4(setsign(spheres[0],signs>>0),\n                               setsign(spheres[1],signs>>1),\n                               setsign(spheres[2],signs>>2),\n                               spheres[3]));\n  vec4 orth = orthogonal(spheres[0],spheres[1],spheres[2],spheres[3]);\n  vec4 base = vec4(0);\n  if (!key(CHAR_P)) base = orth;\n  if (key(CHAR_O)) spheres[6] = orth;\n  vec4 eps = vec4(0,0,0,1e-3);\n  spheres[4] = mix(base-eps,res[0],k);\n  spheres[5] = mix(base+eps,res[1],k);\n  if (key(CHAR_O)) spheres[6] = orth;\n  float camera = 8.0*exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec3 p = vec3(0,0,camera);\n      p = transform(p);\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 r = vec3(uv,-2);\n      r = transform(r);\n      r = normalize(r);\n      col += raycolor(p,r);\n    }\n  }\n  col /= AA*AA;\n  //assert(max(col.x,max(col.y,col.z)) <= 1.0);\n  col = clamp(col,0.0,1.0);\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////////////////////\n// Common\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\n\nbool alert = false;\nvoid assert(bool b) { if (!b) alert = true; }\n#define CHECK true\n\n// Use this to check our work\nbool eq(float x, float y) {\n  return abs(x-y) < 1e-5;\n}\n\n// GLM compatibility\n#define xyz(a) (a.xyz)\n#define zxy(a) (a.zxy)\n#define yzx(a) (a.yzx)\n#define xy(a) (a.xy)\n#define yz(a) (a.yz)\n#define zx(a) (a.zx)\n\n// Circles are sometimes 'oriented', ie. the radius component is signed.\nfloat sgn(int n) {\n  if ((n&1) == 0) return 1.0;\n  else return -1.0;\n}\n\nvec4 setsign(vec4 s, int sign) {\n  s.w *= sgn(sign);\n  return s;\n}\n\nvec4 clearsign(vec4 s) {\n s.w = abs(s.w);\n return s;\n}\n\n// We really could do with a generic representation that covers\n// both planes and spheres. eg. something like (p,k) where p and\n// pk are ends of a diameter (so for k = infinity, we have a plane).\n// Inversion is then just (p,k) -> (p/dot(p,p),1/k)\n\nvec4 invertplane(vec4 s) {\n  // plane is (n,d) and point p: p.n+d = 0\n  // so if p = kn want kn.n+d = 0, k = -d/n.n\n  vec3 n = xyz(s); // n should be normalized\n  float d = -s.w; // distance from origin\n  float k = 0.5/d;\n  vec3 p = n*k;  // (2.0*d); // Half of inverse point\n  return vec4(p,-k); // That's the sphere!\n}\n\nvec4 invertsphere(vec4 s) {\n  // Note resemblance to Minkowski product\n  float sgn = sign(s.w);\n  vec4 H = vec4(1,1,1,-1);\n  float k = dot(H*s,s);\n  // If k = 0, then we have a sphere through the centre of inversion,\n  // which becomes a plane. Dealing with this is a nuisance, so we won't.\n  assert(k != 0.0);\n  s /= k;\n  // Possibly need to worry about the sign, but this seems OK.\n  return s;\n}\n\n// Find a point in both plane0 and plane1. This is simple except\n// for dealing with planes being parallel to the coordinate\n// planes.\nvec3 getintersectionpoint(vec4 plane0, vec4 plane1) {\n  // Find 3 intersections of line with reference planes and choose\n  // the best. Since this involves inverting a 2x2 matrix, use\n  // the one with the largest determinant.\n  vec3 m = xyz(plane0), n = xyz(plane1);\n  vec2 t = vec2(plane0.w,plane1.w);\n  mat2 m0 = mat2(xy(m),xy(n));\n  mat2 m1 = mat2(yz(m),yz(n));\n  mat2 m2 = mat2(zx(m),zx(n));\n  float d0 = abs(determinant(m0));\n  float d1 = abs(determinant(m1));\n  float d2 = abs(determinant(m2));\n  float dmax = max(d0,max(d1,d2));\n  if (dmax == d1) m0 = m1;\n  else if (dmax == d2) m0 = m2;\n  vec3 p = vec3(t*inverse(m0),0);\n  if (dmax == d1) p = zxy(p);\n  else if (dmax == d2) p = yzx(p);\n  assert(eq(dot(m,p),t[0]));\n  assert(eq(dot(n,p),t[1]));\n  return p;\n}\n\n// Find a plane, equation p.n = k, with |n| = 1, and satifying:\n// c0.n - r0 = c1.n - r1 = c2.n - r2 = k, for some k\n// this gives two equations which define a line:\n// n.(c0-c1) = r0-r1 & n.(c1-c2) = r1-r2\n// Get line direction with cross product & find a point on\n// the line, then intersect line with unit sphere to get\n// a normalized normal vector.\nmat2x3 gettangentnormals(vec4 s0, vec4 s1, vec4 s2) {\n  vec3 c0 = xyz(s0), c1 = xyz(s1), c2 = xyz(s2);\n  float r0 = s0.w, r1 = s1.w, r2 = s2.w;\n  vec3 r = cross(c0-c1,c1-c2); // Direction of plane intersection\n  if (r0 == r1 && r1 == r2) {\n    // The normal locus passes through origin, so just use\n    // origin and cross product for sample points.\n    // If centres collinear, an infinity of solutions\n    r = normalize(r);\n    return mat2x3(-r,r);\n  }\n  // Find a point in the intersections of the two planes\n  vec3 p = getintersectionpoint(vec4(c0-c1,r0-r1),vec4(c1-c2,r1-r2));\n\n  // Now intersect line p+tr line with unit sphere.\n  // Full equation is n.n = (p+tr)Â² = p.p+2tp.r+tÂ²r.r = 1\n  // but we ensure that p.r = 0\n  p -= dot(p,r)/dot(r,r)*r; // Advance so p.r = 0\n  float A = dot(r,r);\n  float C = dot(p,p)-1.0;\n  float D = -A*C;\n  if (D < 0.0) return mat2x3(0);\n  float t = sqrt(D)/A;\n  return mat2x3(p-t*r,p+t*r);\n}\n\nmat2x4 gettangentplanes(vec4 s0, vec4 s1, vec4 s2) {\n  mat2x3 a = gettangentnormals(s0,s1,s2);\n  if (a[0] == vec3(0)) return mat2x4(0);\n  vec3 c0 = xyz(s0); float r0 = s0.w;\n  mat2x4 res;\n  for (int i = 0; i < 2; i++) {\n    vec3 n = a[i];\n    // Want (n,k).(c0,1) = n.c0 + k = r0 etc\n    vec4 p = vec4(n,r0-dot(n,c0));\n    res[i] = p;\n    if (CHECK){\n      vec3 c1 = xyz(s1), c2 = xyz(s2);\n      float r1 = s1.w, r2 = s2.w;\n      assert(eq(length(n),1.0));\n      assert(eq(dot(p,vec4(c0,1)),r0));\n      assert(eq(dot(p,vec4(c1,1)),r1));\n      assert(eq(dot(p,vec4(c2,1)),r2));\n    }\n  }\n  return res;\n}  \n\nmat2x4 apollonius0(mat4 s) {\n  // Solve the 3D problem of Apollonius for\n  // four spheres. Rebase the spheres with\n  // the fourth at origin. This also subtracts\n  // the radius, so we are now after a sphere\n  // through the origin tangent to three spheres.\n  // Having solved this, reduce the radius of\n  // the solution sphere to solve the original\n  // problem.\n  vec4 base = s[3];\n  for (int i = 0; i < 3; i++) {\n    s[i] -= base;\n    s[i] = invertsphere(s[i]);\n  }\n  // Now find a plane tangent to those 3 circles\n  mat2x4 res = gettangentplanes(s[0],s[1],s[2]);\n  for (int i = 0; i < 2; i++) {\n    vec4 plane = res[i];\n    if (plane == vec4(0)) continue;\n    vec4 a = invertplane(plane);\n    // Rebase a, but _subtract_ the base radius.\n    a += base*vec4(1,1,1,-1); // a is the Apollonian sphere\n    res[i] = a;\n  }\n  return res;\n}\n\nmat2x4 apollonius(mat4 s) {\n  mat2x4 res = apollonius0(s);\n  if (CHECK) {\n    vec4 s0 = s[0], s1 = s[1], s2 = s[2], s3 = s[3];\n    vec3 c0 = xyz(s0), c1 = xyz(s1), c2 = xyz(s2), c3 = xyz(s3);\n    float r0 = s0.w, r1 = s1.w, r2 = s2.w, r3 = s3.w;\n    for (int i = 0; i < 2; i++) {\n      vec3 ca = xyz(res[i]); float ra = res[i].w;\n      assert(eq(distance(ca,c0)-abs(r0+ra),0.0));\n    }\n  }\n  res[0] = clearsign(res[0]);\n  res[1] = clearsign(res[1]);\n  return res;\n}\n\n// \"cross product\" for ââ´ - ie, given three 4-vectors, find\n// a fourth orthogonal to all three (unique up to scaling).\n// So for homogeneous coordinates, the function is finding\n// the plane spanned by three points, or the point of\n// intersection of three planes.\nvec4 cross3(vec4 p, vec4 q, vec4 r) {\n  mat4x3 m = transpose(mat3x4(p,q,r));\n#if 0\n  // det(a,b,c) = dot(a,cross(b,c)) so there is scope\n  // for optimization here\n  return vec4(determinant(mat3(m[1],m[2],m[3])),\n              -determinant(mat3(m[2],m[3],m[0])),\n              determinant(mat3(m[3],m[0],m[1])),\n              -determinant(mat3(m[0],m[1],m[2])));\n#else\n  // For example:\n  vec3 m01 = cross(m[0],m[1]);\n  vec3 m23 = cross(m[2],m[3]);\n  vec4 res = vec4(dot(m[1],m23),-dot(m[0],m23),\n                  dot(m[3],m01),-dot(m[2],m01));\n  return res;\n#endif\n}\n\nvec3 unhomogenize(vec4 p) {\n  return xyz(p)/p.w;\n}\n\nfloat dist2(vec3 a, vec3 b) {\n  return dot(b-a,b-a);\n}\n\nfloat power(vec3 p, vec4 s) {\n  return dist2(p,vec3(s))-s.w*s.w;\n}\n\nvec4 radical(vec4 s, vec4 S) {\n  vec3 n = vec3(s)-vec3(S);\n  float r2 = s.w*s.w, R2 = S.w*S.w;\n  float d2 = dot(n,n);\n  float A = 0.5*(d2+R2-r2)/d2;\n  vec3 p = xyz(S)+A*n;\n  float k = dot(n,p);\n  return vec4(n,-k);\n}\n\n// The centre of the unique orthogonal circle to a,b,c,d is at\n// the intersection of their pairwise radical planes (ie. the\n// point with the same power with respect to each of the spheres).\n// So construct 3 radical planes and intersect...\nvec4 orthogonal(vec4 a, vec4 b, vec4 c, vec4 d) {\n  vec4 p = radical(a,b);\n  vec4 q = radical(b,c);\n  vec4 r = radical(c,d);\n  vec3 centre = unhomogenize(cross3(p,q,r));\n  // Now find orthogonal sphere from centre to a:\n  float radius = sqrt(dist2(centre,xyz(a))-a.w*a.w);\n  return vec4(centre,radius);\n}\n\n///////////////////////////////////////////////////////////////////\n\nvec2 expi(float t) {\n  return vec2(cos(t),sin(t));\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nbool intersectsphere(vec3 p, vec3 r, vec4 sphere, out vec2 t) {\n  vec3 centre = sphere.xyz;\n  float radius = sphere.w;\n  p -= centre; // Centre on sphere\n  float r2 = radius*radius;\n  // Want dot(p+t*r,p+t*r) = r2\n  // ie. p.p - r2 + 2tp.r + t^2 = 0\n  float k = -dot(p,r);\n  p += k*r; // Advance p so p.r = 0\n  float C = r2-dot(p,p);\n  if (C < 0.0) return false;\n  float D = sqrt(C);\n  t = vec2(-D,D)+k;\n  return true;\n}\n\n///////////////////////////////////////////////////////////////////\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n\n// const int KEY_SHIFT = 16;\nconst int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\n// const int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\n// const int CHAR_Q = 81;\nconst int CHAR_R = 82;\n// const int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\n// const int CHAR_X = 88;\n// const int CHAR_Y = 89;\n// const int CHAR_Z = 90;", "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XflGDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1161, 1161, 1188, 1188, 1525], [1527, 1527, 1550, 1668, 1705], [1707, 1707, 1727, 1727, 1867], [2054, 2054, 2085, 2085, 3413], [3415, 3415, 3472, 3472, 4765]], "test": "untested"}
{"id": "ctyBDt", "name": "Product Tetrabrot", "author": "domrally", "description": "n -> nânâ¿\ntetrated mandelbrot\n[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]", "tags": ["fractal", "mandelbrot", "orbit", "trap", "short", "tweet", "golf", "tetration", "tetration", "hyperoperation", "tetrate"], "likes": 6, "viewed": 214, "published": 3, "date": "1703018111", "time_retrieved": "2024-07-30T17:15:39.063631", "image_code": "/*\nby Dom Mandy in 2023\n*/\nvoid mainImage(out vec4 P, vec2 V) {\n    float a, c, k, v, g, b, r = g = b = 9.;\n    vec2 R = iResolution.xy,\n         C = V + V - R;\n    C /= R.y;\n    C.x -= .7;\n    V = C *= 2.;\n\n    for (; k++ < 999.; ) {\n        // exponentiate\n        c = dot(V, vec2(a = atan(V.y, V.x), log(v = dot(V, V)) / 2.)),\n        V = exp(-a * V.y) * pow(v, V.r / 2.) * vec2(cos(c), sin(c)),\n        // multiply\n        V = vec2(C.x * V.x - C.y * V.y, dot(C, V.yx));\n        \n        // orbit traps\n        r > (v = dot(V, V)) ? r = v, R = V : R,\n        g = min(g, abs(V.x)),\n        b = min(b, abs(V.y));\n    }\n\n    // real\n    g = smoothstep(1., -25., log(g));\n    // imaginary\n    b = smoothstep(1., -25., log(b));\n\n    // overlay blend mode\n    r = b < .5 ? 2. * g * b : 1. - 2. * (1. - g) * (1. - b);\n\n    // rainbow\n    r = 2. * smoothstep(.0, .2, r);\n    P = isnan(v) ? vec4(1) : sqrt(r + r * cos(atan(R.y, R.x) - vec4(0, 2.1, 4.2, 0)));\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctyBDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 27, 63, 63, 954]], "test": "untested"}
{"id": "dt3fRs", "name": "Finally Free", "author": "alexwerner9", "description": "A trip to the world's bathtub.", "tags": ["raymarching", "water", "duck"], "likes": 11, "viewed": 257, "published": 3, "date": "1703009533", "time_retrieved": "2024-07-30T17:15:39.920342", "image_code": "#define AMPLITUDE .78 // the height of the waves\nfloat PI = 3.14159;\n\nstruct Hit {\n    vec3 point;\n    vec3 dir;\n    int material;\n};\n\nstruct OceanHit {\n    float d;\n    int material;\n};\n\nstruct DuckHit {\n    float d;\n    int material;\n};\n\nstruct WaterHit {\n    float ocean;\n    float duckie;\n};\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r)\n{\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\n// some of this inspired by https://www.shadertoy.com/view/MdXyzX\nWaterHit calcHeight(vec3 p, float iterations) {\n    float iter = 0.;\n    float addedNoiseW = 0.;\n    float addedNoiseD = 0.;\n    float frequency = .7;\n    float weight = 1.;\n    float timeMultiplier = 2.6;\n    float sumW = 0.;\n    float sumD = 0.;\n    for(float i = 1.; i < iterations; i += 1.) {\n        vec2 p2 = vec2(sin(iter), cos(iter));\n        vec3 waveDirection = vec3(p2.x, 0., p2.y);\n        // line of wave: waveDirection.x * x + waveDirection.z * y + 0\n        // therefore the distance from our current point to this line is\n        float a = waveDirection.x;\n        float b = waveDirection.z;\n        float distToLine = abs(a * p.x + b * p.z + 15.) / sqrt(a*a + b*b);\n        \n        float additionW = pow(3.5, sin(distToLine*frequency+iTime*timeMultiplier)-1.) * (weight);\n        addedNoiseW += additionW;\n        \n        if(i < 7.) {\n            vec3 dp = p;\n            dp.y += 1.5;\n            dp.z += 1.5;\n            vec3 pd = vec3(0.,dp.y+0.8,dp.z-2.);\n            distToLine = abs(a * pd.x + b * pd.z + 15.) / sqrt(a*a + b*b);\n            float additionD = pow(3.5, sin(distToLine*frequency+iTime*timeMultiplier)-1.) * (weight);\n\n            addedNoiseD += additionD;\n            sumD += weight;\n        }\n        \n        iter += 0.399963;\n        weight *= 0.79;\n        frequency *= 1.22;\n        timeMultiplier /= 1.1;\n        sumW += weight;\n    }\n    \n    WaterHit waterHit;\n    waterHit.ocean = addedNoiseW*AMPLITUDE / sumW;\n    waterHit.duckie = addedNoiseD*AMPLITUDE / sumD;\n    \n    return waterHit;\n}\n\nvec4 translate(vec4 v, vec3 t) {\n    mat4 translation = mat4(\n        1., 0., 0., t.x,\n        0., 1., 0., t.y,\n        0., 0., 1., t.z,\n        0., 0., 0., 1.\n    );\n    return v * translation;\n}\n\nvec4 rotateY(vec4 v, float theta) {\n    float s = sin(PI * theta);\n    float c = cos(PI * theta);\n    mat4 rotX = mat4(\n          c,  0.,  s, 0.,\n          0., 1.,  0., 0.,\n         -s,  0.,  c, 0.,\n          0., 0.,  0.,  1.\n    );\n    return v * rotX;\n}\n\nvec4 rotateZ(vec4 v, float theta) {\n    float s = sin(PI * theta);\n    float c = cos(PI * theta);\n    mat4 rotX = mat4(\n          c, -s,  0., 0.,\n          s,  c,  0., 0.,\n          0., 0., 1., 0.,\n          0., 0., 0.,  1.\n    );\n    return v * rotX;\n}\n\nDuckHit sdDuck(vec3 p) {\n\n    vec4 dp = vec4(p.xyz, 1.);\n    dp = translate(dp, vec3(0.,0.8,3.));\n    float dBody = sdEllipsoid(dp.xyz, vec3(2., 1.3, 1.));\n    \n    vec4 head = vec4(p.xyz, 1.);\n    head = translate(head, vec3(0.5,0.8-1.8,3.));\n    head = rotateZ(head, 0.2);\n    float dHead = sdEllipsoid(head.xyz, vec3(1., 1.05, 1.));\n    \n    vec4 wing1 = vec4(p.xyz, 1.);\n    wing1 = translate(wing1, vec3(-0.3,0.7,2.));\n    wing1 = rotateZ(wing1, -.3);\n    wing1 = rotateY(wing1, 0.1);\n    float dWing1 = sdEllipsoid(wing1.xyz/.1, vec3(5.,4.,2.))*.1;\n    \n    vec4 tail = vec4(p.xyz, 1.);\n    tail = translate(tail, vec3(-1.8,0.3,3.));\n    tail = rotateZ(tail, 0.7);\n    float dTail = sdEllipsoid(tail.xyz/.1, vec3(4.6,2.,3.))*.1;\n    \n    vec4 beak1 = vec4(p.xyz, 1.);\n    beak1 = translate(beak1, vec3(0.9, 0.8-2.,3.));\n    beak1 = rotateZ(beak1, 0.15);\n    float dBeak1 = sdEllipsoid(beak1.xyz/.2, vec3(5.,1.,3.))*.2;\n    \n    vec4 beak2 = vec4(p.xyz, 1.);\n    beak2 = translate(beak2, vec3(0.9, 0.8-2.,3.));\n    beak2 = rotateZ(beak2, -0.);\n    float dBeak2 = sdEllipsoid(beak2.xyz/.2, vec3(5.,1.,3.))*.2;\n\n    vec4 eye1 = vec4(p.xyz, 1.);\n    eye1 = translate(eye1, vec3(.87, 0.8-2.4, 2.2));\n    eye1 = rotateY(eye1, -0.2);\n    eye1 = rotateZ(eye1, 0.2);\n    float dEye1 = sdEllipsoid(eye1.xyz/.05, vec3(1., 3., 3.))*.05;\n    \n    float d = opSmoothUnion(dBody, dWing1, 0.1);\n    d = opSmoothUnion(d, dHead, 0.1);\n    d = opSmoothUnion(d, dTail, 0.4);\n    d = opSmoothUnion(d, dBeak1, 0.1);\n    d = opSmoothUnion(d, dBeak2, 0.1);\n    \n    DuckHit duckHit;\n    if(dBeak2 <= 0.05 || dBeak1 <= 0.05) {\n        duckHit.material = 2;\n    } else if(dEye1 <= 0.05) {\n        duckHit.material = 3;\n    } else {\n        duckHit.material = 1;\n    }\n    duckHit.d = d;\n    return duckHit;\n}\n\nOceanHit sceneOpaque(vec3 p) {\n    vec3 np = p;\n    np.y += 11.7;\n    \n    WaterHit calcedHeight = calcHeight(np,20.);\n    \n    float oceanLocation = sdBox(np, vec3(40., 10., 40.))\n                          -calcedHeight.ocean;\n    \n    vec3 dp = p;\n    dp.y += 1.4;\n    dp.z += 1.5;\n    float duckieLocation = 10.;\n    DuckHit duckHit;\n    dp.y -= calcedHeight.duckie;\n    duckHit = sdDuck(dp/.2);\n    duckHit.d *= .2;\n    duckieLocation = duckHit.d;\n    OceanHit oceanHit;\n    oceanHit.material = duckHit.material * int(step(duckieLocation-oceanLocation,0.));\n    oceanHit.d = min(oceanLocation, duckieLocation);\n    return oceanHit;\n}\n\nOceanHit sceneWater(vec3 p) {\n    //return opSmoothUnion(sceneOpaque(p), sdOrca(p), 1.);\n    return sceneOpaque(p);\n}\n\nfloat sceneFull(vec3 p) {\n    return sceneWater(p).d;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 h = vec2(.0001, 0); // Epsilon vector for swizzling\n    vec3 normal = vec3(\n       sceneFull(p+h.xyy) - sceneFull(p-h.xyy),   // x gradient\n       sceneFull(p+h.yxy) - sceneFull(p-h.yxy),   // y gradient\n       sceneFull(p+h.yyx) - sceneFull(p-h.yyx)    // z gradient\n    );\n    return normalize(normal);\n}\n\n\n// return where we hit, and the direction to move from there\nHit newHit(Hit h) {\n    Hit hit;\n    hit.point = vec3(-111.);\n    hit.dir = h.dir;\n    hit.material = 0;\n    \n    vec3 ogPoint = h.point;\n    vec3 ogDir = h.dir;\n    \n    ogPoint += normalize(ogDir)*0.011;\n    for(int i = 0; i < 100; i++) {\n        OceanHit oceanHit = sceneWater(ogPoint);\n        float distToWater = oceanHit.d;\n        if(distToWater <= 0.01) {\n            vec3 d = normalize(ogDir);\n            vec3 n = calcNormal(ogPoint);\n            \n            hit.point = ogPoint;\n            hit.dir = reflect(normalize(ogDir), n);\n            hit.material = oceanHit.material;\n            \n            break;\n        }\n        ogPoint += normalize(ogDir)*distToWater;\n    }\n    return hit;\n}\n\nvec3 colors[4];\n\nvec3 calcSkyColor(Hit hit, float damper, int material) {\n    vec3 dir = hit.dir;\n    vec3 ret = vec3(0.);\n    \n    colors[1] = vec3(1.,1.,0.2);\n    colors[2] = vec3(1.,0.2,0.2);\n    colors[3] = vec3(0.);\n    \n    vec3 color1;\n    if(material == 1 || material == 2 || material == 3) {\n        vec3 duckColor = colors[material];\n        vec3 n = calcNormal(hit.point);\n        vec3 lightDir = normalize(vec3(0.,1.,0.));\n        float diffuse = clamp(dot(n, lightDir),0.,1.)*2.;\n        vec3 fc = duckColor * diffuse;\n        fc = max(fc, duckColor*0.67);\n        color1 = clamp(fc+0.1*duckColor, 0., 1.);\n    }\n    \n    \n    dir.y -= sin(iTime/4.)/5.;\n    ret.rg = vec2((.8-abs(dir.y/1.5)));\n    ret.g -= 0.15;\n    ret.b += 0.3;\n    \n    vec3 newDir = vec3(dir.xy*6., dir.z);\n    float dotProduct = dot(normalize(newDir), normalize(vec3(0.,0.,1.)));\n    \n    vec3 newRet = vec3(1.)*pow(-dotProduct, 7.)*5.;\n    ret += newRet;\n    \n    vec3 color2 = clamp(ret / damper, 0., 1.);\n    return mix(color1, color2, step(float(material), .5));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate uv\n    vec2 uv = (fragCoord / iResolution.xy - .5) * 2.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 lightPos = vec3(-0.8,-0.1,1.);\n    vec3 lightColor = vec3(.8,0.8,0.3);\n   \n    vec3 cam_origin = vec3(0.,0.,1.);\n    vec3 rayDir = normalize(vec3(uv,0.) - cam_origin);\n    vec3 camPos = cam_origin;\n    vec3 color = vec3(0.);\n    float blurFactor = 0.;\n    \n    vec3 d;\n    vec3 n;\n    vec3 r;\n    float distToWater;\n    \n    Hit hit;\n    hit.point = camPos;\n    hit.dir = rayDir;\n    if(rayDir.y > 0.) {\n        color = calcSkyColor(hit, 1., -1);\n        \n        color -= mod(color,.1);\n        fragColor = vec4(color, 1.);\n        return;\n    }\n    \n    Hit secondHit;\n    secondHit.material = 0;\n    hit = newHit(hit);\n    if(hit.material != 0 || hit.dir.y > 0. || hit.dir.x > 0.3 || hit.dir.x < -0.3) {\n        color = calcSkyColor(hit, 1., hit.material);\n    } else {\n        vec3 waterColor = calcSkyColor(hit, 1., hit.material);\n        Hit secondHit;\n        secondHit = newHit(hit);\n        if(secondHit.material != 0) {\n            vec3 duckieColor = calcSkyColor(secondHit, 1., secondHit.material);\n            color = mix(waterColor, duckieColor, 0.7);\n            fragColor = vec4(color,1.);\n            return;\n        } else {\n            color = waterColor;\n        }\n    }\n    \n    if(hit.point != vec3(-111.) && hit.material == 0) {\n        // genius by https://www.shadertoy.com/view/MdXyzX\n        vec3 n = calcNormal(hit.point);\n        n.y = abs(n.y);\n        float dist = distance(camPos, hit.point);\n        n = mix(n, vec3(0.0, 1.0, 0.0), min(1.0, sqrt(dist*0.5) * 1.1));\n        float fres = (0.1 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-n, rayDir)), 1.0)));\n        \n        vec3 scattering = vec3(0.0493, 0.1598, 0.317)*2.4;\n        if(secondHit.material != 0) {\n            scattering = vec3(0.3, 0.3, 0.15)*2.4;\n        }\n        \n        color = fres * color + (1.0 - fres) * scattering;\n        \n    }\n    \n    color -= mod(color,.1);\n\tfragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt3fRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 297, 349, 349, 448], [450, 450, 481, 481, 568], [570, 570, 605, 605, 706], [708, 774, 821, 821, 2311], [2313, 2313, 2345, 2345, 2509], [2511, 2511, 2546, 2546, 2766], [2768, 2768, 2803, 2803, 3021], [3023, 3023, 3047, 3047, 4811], [4813, 4813, 4843, 4843, 5450], [5452, 5452, 5481, 5540, 5569], [5571, 5571, 5596, 5596, 5626], [5628, 5628, 5653, 5653, 5969], [5972, 6033, 6052, 6052, 6736], [6755, 6755, 6811, 6811, 7791], [7794, 7794, 7851, 7871, 9877]], "test": "untested"}
{"id": "lff3WH", "name": "Harmonic Sin Arcs 2 w/color", "author": "timmaffett", "description": "I did a thing to what spalmer's did of Fabrice's toy\n-tmm i like color, what can i say", "tags": ["2d", "2tweets", "short", "golf"], "likes": 5, "viewed": 160, "published": 3, "date": "1703003066", "time_retrieved": "2024-07-30T17:15:40.800986", "image_code": "// Fork of \"Harmonic Sinusoidal Arcs 2\" by FabriceNeyret2. https://shadertoy.com/view/Mcf3Dr\n// 2023-12-19 16:20:21\n\n// respin of spalmer https://www.shadertoy.com/view/XcfGDr\n// respin of FabriceNeyret2 http://shadertoy.com/view/XfX3Dn\n\n\nvec3 hsb2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return (c.z * mix( vec3(1.0), rgb, c.y));\n}\n#define PI  3.14159265359\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy,\n         U = 1.2 * (u + u - R) / R.y;\n    O *= 0.;\n    for (float i; i++ < 9.; )\n        O = max(O, smoothstep(5./R.y*i, 0., \n                       abs(length(  vec2(\n                               mod( iTime + U.x*i + sign(U.y), 4.) - 2.\n                             , U.y*i\n                                 )   )\n                        - 1.\n                          )   ) \n                  / pow(1.2, i)\n                );\n    //add some color\n    O *= vec4(hsb2rgb(vec3(PI/9.*U.x,0.9,0.9)),1.0);                \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lff3WH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[239, 239, 266, 266, 501], [528, 528, 564, 564, 1114]], "test": "untested"}
{"id": "McX3WH", "name": "harmonic waves w/color", "author": "timmaffett", "description": "reference: https://www.facebook.com/CymaticUniverse/posts/741183981377178\n-tmm just added some color", "tags": ["2d", "2tweets", "short", "yinyang", "reproduction"], "likes": 2, "viewed": 136, "published": 3, "date": "1703002608", "time_retrieved": "2024-07-30T17:15:41.563946", "image_code": "// Fork of \"harmonic waves\" by FabriceNeyret2. https://shadertoy.com/view/XfX3Dn\n// 2023-12-19 16:15:48\n\n// -2Â by Observer\n\n\nvec3 hsb2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return (c.z * mix( vec3(1.0), rgb, c.y));\n}\n\n\n//#define S(v) smoothstep( 1.5, 0., abs(v)/fwidth(v) )\n#define S(P) smoothstep( 5./R.y*i, 0., abs( length(P) - 1. ) )\n#define PI  3.14159265359\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 1.2*( u+u - R ) / R.y, V;\n         \n    float i=1., v=i;   \n    \n    O = vec4( S(U) );                                // circle\n    if ( dot(U,U) < i )                               // inside only\n        for( ; i++ < 9.;  v /= 1.2 )                  // foreach harmonic\n            V = U*i, \n            V.x = mod( V.x + i + sign(V.y), 4.) - cos((iTime))*2.,// arc center\n            O = max(O, S(V)*v ) ;                    // draw arc, grey=v\n    //add some color\n    if ( dot(U,U) < 0.99 )\n      O *= vec4(hsb2rgb(vec3(PI/9.*U.x,0.9,0.9)),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/McX3WH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 153, 153, 388], [535, 535, 573, 573, 1171]], "test": "untested"}
{"id": "dtdfDf", "name": "Superposed disapearing circle", "author": "Saimon", "description": "Animated reproductin of this image: https://geometrydaily.tumblr.com/post/19002626421/69-staring-into-the-sun-a-new-minimal-geometric by Tilman Zitzmann, check his other graphical work here: https://geometrydaily.tumblr.com/", "tags": ["color", "circle", "animated", "reproduction"], "likes": 4, "viewed": 163, "published": 3, "date": "1703001791", "time_retrieved": "2024-07-30T17:15:42.323914", "image_code": "/* \"Superposed disapearing circles\"\n * I wanted to practice GLSL and the primitives describe in https://thebookofshaders.com/07/\n * so I started looking for art images to try to reproduce.\n * This one is part of my practice serie, it is based on this image: \n * https://geometrydaily.tumblr.com/post/19002626421/69-staring-into-the-sun-a-new-minimal-geometric\n * It was made by Tilman Zitzmann, check his other graphical work here: https://geometrydaily.tumblr.com/\n * (November 2023)(started with 1965 char - Updated 08/01/2024)\n */\n\n#define R       iResolution.xy\n// Clamp the color to make sure it's between [0;1]\n#define clampColor(C) clamp(C,0.,1.)\n\n// r: radius\n// s: size of the border\n// Derived from: http://iquilezles.org/articles/distfunctions2d/\nfloat sdCircleBorder(vec2 p, float r, float s){\n    float d = length(p) - r, //signed distance of circle\n          d2 = abs(d) - s,\n          w = .8/R.y;\n    return smoothstep(-w,w,max(d,d2));\n}\n\n\n// Simplify version of code: https://thebookofshaders.com/edit.php?log=160909065147\n// and http://www.kynd.info\nfloat easeInOutExpo(float t) {\n  t = exp2(40.*t-10.);\n  return t < 1.\n      ?      .5 * t\n      : 1. - .5 / t;\n}\n\n#define tweenEaseInOutExpo(t) easeInOutExpo(min(t, 1. -t))\n#define moove(t) tweenEaseInOutExpo(t)/10.3\n\nfloat radius = 0.65;\n#define sdCB(st,p) sdCircleBorder(st-p,radius, moove(t))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 st = ( fragCoord*2. -R.xy ) /R.y + vec2(0.5,.45);\n  float t = fract((iTime+2.)/3.);\n\n  vec3 CYAN = vec3(0.267,0.667,0.729),\n       YELLOW = vec3(0.949,0.898,0.216),\n       MAGENTA = vec3(0.863,0.325,0.592);\n\n  float c1 = sdCB(st,vec2(0.47,0.52));\n\n  t = fract((iTime+1.85)/3.);\n  float c2 = sdCB(st,vec2(0.42, 0.50));\n\n  t = fract((iTime+1.68)/3.);\n  float c3 = sdCB(st,vec2(0.52, 0.38));\n\n  t = fract((iTime+1.55)/3.);\n  float c4 = sdCB(st,vec2(0.38, 0.38));\n\n  t = fract((iTime+1.48)/3.);\n  float c5 = sdCB(st,vec2(0.370, 0.42));\n\n  t = fract((iTime+1.4)/3.);\n  float c6 = sdCB(st,vec2(0.47, 0.39));\n\n  fragColor.rgb = clampColor(c1+YELLOW)\n                     * clampColor(c2+CYAN)\n                     * clampColor(c3+MAGENTA)\n                     * clampColor(c4+MAGENTA)\n                     * clampColor(c5+YELLOW)\n                     * clampColor(c6+CYAN);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtdfDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[655, 758, 805, 805, 952], [955, 1067, 1097, 1097, 1179], [1364, 1364, 1420, 1420, 2296]], "test": "untested"}
{"id": "lcfGWH", "name": "grandmas christmas tree", "author": "timmaffett", "description": "glass christmas tree toy\nfork of @Efim https://www.shadertoy.com/view/lcfGW8\n-tmm made it a little more colorful, like the one my grandma had", "tags": ["raymarching", "christmas", "sdf", "repetition", "toy"], "likes": 5, "viewed": 185, "published": 3, "date": "1703000921", "time_retrieved": "2024-07-30T17:15:43.088869", "image_code": "//Fork of @Efim's Christmas Tree https://www.shadertoy.com/view/lcfGW8\n\n// SNOW background from @g1mishr's \"Snow Simple \" https://www.shadertoy.com/view/DlGczD\n#define TILES 10.0\n\n//2D random from https://www.shadertoy.com/view/WstGDj\nfloat random (vec2 uv) {\n    return fract(sin(dot(uv, vec2(135., 263.))) * 103.214532);\n}\n\nvec4 drawSnow(vec2 curid, vec2 uv, vec4 fragColor, float r, float c)\n{\n    float maxoff = 2.0 / TILES; //calculate the max offset a particle can have (two tiles)\n\n    //loop through neighboring tiles\n    for(int x=-2; x<=1; x++)\n    {\n        for(int y=-2; y<=0; y++)\n        {\n            float rad = (1.0 / (TILES * 5.0)) * r; //set default radius\n            vec2 id = curid + vec2(x, y); //get the id of the tile we're visiting\n            vec2 pos = id / TILES; //calculate position\n            float xmod = mod(random(pos), maxoff);\n            pos.x += xmod; //add a random x-offset\n            pos.y += mod(random(pos+vec2(4,3)), maxoff); //add a random y-offset\n            rad *= mod(random(pos), 1.0); //vary the radius by multiplying by a random val\n            pos.x += 0.5*(maxoff-xmod)*sin(iTime*r + random(pos)*100.0); //dynamic sin wave x-offset\n            \n            float len = length(uv - pos); //calculate distance from tile's particle\n\n            //if we're inside the particle, draw it\n            float v = smoothstep(0.0, 1.0, (rad - len) / rad*0.75);\n            fragColor = mix(fragColor, vec4(c), v);      \n        }\n    }\n    \n    return fragColor;\n}\n\n\nvec4 snowBackground( vec2 fragCoord )\n{\n    vec4 fragColor = vec4(0.0);\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.x;\n    uv.y -= 0.3;\n    \n    //uv.x -= 0.6;\n\n    \n    vec3 col = mix(vec3(0.0, 0.45, 0.85), vec3(1), -0.3-uv.y);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    vec4 bg = vec4(.529, .808, .922, 1) * 0.25;\n    vec2 uvNorm = fragCoord.xy / iResolution.xy; //normalized UV coordinate [0, 1]\n    vec2 uvog = fragCoord.xy / iResolution.y; //UV coordinate (will remain static)\n    uv = fragCoord.xy / iResolution.y; //UV coordinate (we'll modify this one)\n    \n    //draw the closest snow layer\n    uv += 0.2*vec2(-iTime, iTime); //move the UV coords based on time\n    vec2 curid = floor(uv * TILES); //calculate the ID associated with the current UV\n    curid += vec2(0.5); //center the ID\n    \n    //if(curid.y > 10.0)\n    {\n    fragColor = drawSnow(curid, uv, fragColor, 1.0, 0.9); //draw closest snow layer\n    \n    //draw the middle snow layer, calculate new UV and ID\n    uv = uvog + 0.1*vec2(-iTime - 100.0, iTime + 100.0);\n    curid = floor(uv * TILES);\n    curid += vec2(0.5);\n    fragColor += drawSnow(curid, uv, vec4(0), 0.75, 0.45); \n    \n    //draw the far snow layer, calculate new UV and ID\n    uv = uvog + 0.05*vec2(-iTime - 150.0, iTime + 150.0);\n    curid = floor(uv * TILES);\n    curid += vec2(0.5);\n    fragColor += drawSnow(curid, uv, vec4(0), 0.5, 0.225);\n    \n    //fragColor = smoothstep(0.0, 3.0, iTime)*fragColor;\n    }\n    return fragColor;\n}\n\n// END Snow Simple https://www.shadertoy.com/view/DlGczD\n\n\n\n#define PI  3.14159265359\n#define TAU 6.28318530718\n#define rot(f) mat2(cos(f), -sin(f), sin(f), cos(f))\n\n#define COLOR_RANGE 128.   //360.\n\n\n\nvec3 hsb2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return (c.z * mix( vec3(1.0), rgb, c.y));\n}\n\n\n\nconst float dist_infin = 10.0;\n#define nn 128\nconst float eps = 0.001;\n\nvec3 sdfColor;\nvec3 resColor;\n\nvec3 col1 = vec3(0.024,0.357,0.153);  // base green\nvec3 col2 = vec3(0.412,0.827,0.439);  //snow highlight\nvec3 col3 = vec3(1., 0.8431, 0.);\nfloat sdfReflect = 0.5;\nfloat resReflect = 0.5;\n\nvec3 csky(vec3 p) {\n    float n = 5., m = 5., dlat = PI / n, dlon = TAU / m;\n    float lon = mod(atan(p.y, p.x), TAU), lat = atan(length(p.xy), p.z);\n    float fo = fract(lon / dlon), fa = fract(lat / dlat);\n\n    float pst = fo * fa * (1. - fo) * (1. - fa);\n    pst = smoothstep(0.0, 0.0625, pst);\n    pst = clamp(pst, 0.1, 1.0);\n    return vec3(pst);\n}\n\nfloat sdSolidAngle(vec3 p, vec2 c, float ra) {\n  // c is the sin/cos of the angle\n    vec2 q = vec2(length(p.xz), p.y);\n    float l = length(q) - ra;\n    float m = length(q - c * clamp(dot(q, c), 0.0, ra));\n    return max(l, m * sign(c.y * q.x - c.x * q.y));\n}\n\nfloat heigthBranch(vec2 p) {\n    float n = 2.5;\n    float df = PI / n / 2.5;\n    float fi = atan(p.y, p.x);\n    float L = length(p.xy);\n    float r = cos(n * fi);\n    if(abs(fi) > df)\n        r = 0.;\n    float d = r - L;\n    float h = smoothstep(0., 0.3, d * L * L);\n    if (h > 0.)\n    {\n        \n        sdfColor = col1;\n        float pst = smoothstep(0.2, 0., abs(L-0.6));\n        sdfColor = mix(col1, col2, pst);\n        sdfReflect = mix(0.2, 0., pst);\n    }\n    return h;\n}\n\nfloat getlon(float lon, float n, float shift) {\n    lon = lon - shift;\n    float dlon = TAU / n, lon1 = floor(lon / dlon) * dlon;\n    if((lon - lon1) >= dlon / 2.)\n        lon1 +=  dlon;\n    return lon1 + shift; ////mod(lon1 + shift, TAU);\n}\n\nfloat sdTree(vec3 p, float l, float r) {\n    float mfi = PI / 8.;\n    float d = sdSolidAngle(p, vec2(sin(mfi), cos(mfi)), l) - r;\n    if(p.y < 0. || p.y > l * cos(mfi)) {\n        sdfColor = col2;\n        sdfReflect = 0.;\n        return d;\n    }\n    sdfColor = col1;\n    sdfReflect = 0.1;\n\n    float n = 8., m = 5., nc = 6., dnc = l/nc;\n    float lss = l/2./m,  ls = 2.*lss;\n    float z = clamp(p.y, 0., l);\n    float lon = mod(atan(p.z, p.x), TAU), dlon = TAU / n;\n\n    \n    float j = floor(z / lss);\n    float h1 = j * lss, shift1 = mod(j, 2.) * dlon / 2.;//,h2 = h1 + lss, shift2 = mod((j + 1.), 2.) * dlon / 2.;\n    float h3 = h1 - lss, shift3 = mod(j - 1., 2.) * dlon / 2.;//h4 = h1 - 2.*lss, shift4 = mod((j - 2.), 2.) * dlon / 2.;\n\n    float lon1 = getlon(lon, n, shift1);//, lon2 = getlon(lon, n, shift2);\n    float lon3 = getlon(lon, n, shift3);//, lon4 = getlon(lon, n, shift4);\n    \n    float h = 0.;\n    if (j < n && h1 > 0.)\n        h = max(heigthBranch(vec2((p.y - h1)/ls, (lon-lon1)/dlon*0.5))*l, h);\n    if (h3 > 0. && h3 + ls < l)\n        h = max(heigthBranch(vec2((p.y - h3)/ls, (lon-lon3)/dlon*0.5))*l, h);\n    \n\n    float blink=1.0-cos(5.0*2.0*iTime);\n    float glowFact = 0.;//blink*0.01;\n    \n\tvec3 glowColor = col1;\n\t\n\t//@Efim's correct logic to avoid loop\n\tfloat level=j;\n\tif(h1+lss-z<z-h1) \n\t\tlevel = j+1.;\n\tif(level>2.0) {\n    \n    ///@Efim's logic computes if there are any iterations of the loop that do anything - and avoids the loop otherwise\n    ///  very nice!\n    ///for(float level=2.0;level<10.0;level+=1.) {\n        //shpere\n        float hp = /*6.*/level*lss;\n        float offset = mod(level,2.0) * mfi;\n        float lonsp = getlon(lon, n, offset);\n        float dx = hp*tan(mfi)*(lon - lonsp);\n        float dy = (z - hp)/cos(mfi), dr = l/15.;\n        float ra = length(vec2(dx, dy)/dr);\n        lonsp=abs(lonsp);\n        if(lonsp<mfi) lonsp+=mfi;\n        float colorfact=lonsp;\n        if (ra < 0.4-(0.2/level))\n        {\n            h = max(sqrt(0.16-ra*ra), h);\n            //sdfColor = vec3(0.698*lonsp,0.098,0.176);\n            sdfColor = hsb2rgb(vec3(offset+COLOR_RANGE/(level*colorfact),1.,blink+0.9));\n            sdfReflect = 0.4;\n//        } else if (ra < 0.4+glowFact) {\n//           glowColor = hsb2rgb(vec3(330./(level*colorfact*1.5),1.,blink+0.9));\n//           sdfReflect = 0.4;\n        }\n    }\n\n    float pst = smoothstep(0.1, 0., fract(z/dnc));\n    sdfColor = mix(sdfColor, col3, pst);\n    sdfReflect = mix(sdfReflect, 0.8, pst);\n    \n    return d * 0.3 - h*0.06*sqrt(z/l);\n\n}\n\nfloat map(vec3 p) {\n    float l = 2.3;\n    p.xy *= rot(PI);\n    p += vec3(0., l / 2., 0.);\n    p.xz *= rot(iTime/2.);\n    float d = sdTree(p, l, 0.05);\n    resColor = sdfColor;\n    resReflect = sdfReflect;\n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pos) {\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * map(pos + k.xyy * h) +\n        k.yyx * map(pos + k.yyx * h) +\n        k.yxy * map(pos + k.yxy * h) +\n        k.xxx * map(pos + k.xxx * h));\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l - p), r = normalize(vec3(f.z, 0, -f.x)), u = cross(f, r), c = f * z, i = c + uv.x * r + uv.y * u;\n    return normalize(i);\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\n//#define AA 1\n\nvec3 calccolor(vec3 col_in, vec3 backcol, vec3 rd, vec3 light1, vec3 light2, vec3 nor) {\n    vec3 col = col_in;\n    float d = dot(rd, nor);\n    if(d < 0.0)\n        col = backcol;\n\n    nor *= -sign(d);\n    float difu1 = dot(nor, light1);\n    float difu2 = dot(nor, light2);\n    float difu = max(difu1, difu2);\n    col *= clamp(difu, 0.3, 1.0);\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec3 snowBgcol = snowBackground( fragCoord ).rgb;\n    \n    vec3 light = normalize(vec3(1.0, .0, -2.5)); //light\n    vec3 light2 = normalize(vec3(-1.0, -.0, 2.5)); //light\n    vec2 mo = vec2(0.0, 0.0);\n    if  (iMouse.z > 0.0)\n    {\n        mo = (-iResolution.xy + 2.0 * (iMouse.xy)) / iResolution.y;\n    }\n    vec3 ro = vec3(0.0, 0.0, 2.5); // camera\n    //camera rotation\n    ro.yz *= rot(mo.y * PI);\n    ro.xz *= rot(-mo.x * TAU);\n\n    const float fl = 1.5; // focal length\n    float dist = dist_infin;\n\n    //vec3 b1 = vec3(0.23529411764705882, 0.4235294117647059, 0.7725490196078432), b2 = vec3(0.3686274509803922, 0.5725490196078431, 0.8941176470588236);\n    //vec3 bg = mix(b1, b2, vec3((1.0 - abs(fragCoord.x - iResolution.x / 2.) / iResolution.y * 2.) * fragCoord.y / iResolution.x));   \n    vec3 bg = snowBgcol; //mix(b2, b1, fragCoord.y / iResolution.y);   \n    //antialiasing\n    vec3 tot = vec3(0.0);\n    for(int m = 0; m < AA; m++) for(int n = 0; n < AA; n++) {\n            vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n            vec2 p = (-iResolution.xy + 2.0 * (fragCoord + o)) / iResolution.y;\n            vec3 rd = GetRayDir(p, ro, vec3(0, 0., 0), fl); //ray direction\n            vec3 col = bg * bg; // background  \n            //==========================raymatch=============================\n            float td = 0.;\n            vec3 pos = vec3(0.);\n            for(int i = 0; i < nn; i++) {\n                pos = ro + rd * td;\n                float h = map(pos);\n                if(h < eps || td >= dist_infin)\n                    break;\n                td += h;\n            }\n            if(td < dist_infin) {\n                col = resColor;\n                vec3 nor = calcNormal(pos);\n\n                //reflection\n\n                vec3 psk = reflect(rd, nor);\n                vec3 c2 = csky(psk);\n\n                col = calccolor(col, col, -rd, light, light2, nor);\n                col = mix(col, c2, resReflect);\n\n                //col += c2*0.1;\n\n            }\n            //==========================raymatch=============================\n            tot += col;\n        }\n    tot = sqrt(tot) / float(AA);\n    //tot = pow(tot, vec3(0.7)) / float(AA);\n    //antialiasing\n    fragColor = vec4(tot, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcfGWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 235, 259, 259, 324], [326, 326, 396, 396, 1509], [1512, 1512, 1551, 1551, 3023], [3228, 3228, 3255, 3255, 3490], [3787, 3787, 3806, 3806, 4140], [4142, 4142, 4188, 4223, 4402], [4404, 4404, 4432, 4432, 4882], [4884, 4884, 4931, 4931, 5125], [5127, 5127, 5167, 5167, 7659], [7661, 7661, 7680, 7680, 7882], [7884, 7930, 7960, 7960, 8226], [8228, 8228, 8278, 8278, 8428], [8508, 8508, 8596, 8596, 8868], [8870, 8870, 8925, 8925, 11172]], "test": "untested"}
{"id": "4fX3Dr", "name": "byt3 m3chanic text effects", "author": "byt3_m3chanic", "description": "Just playing around, was inspired by @yasuo's recent text experiment. (https://www.shadertoy.com/view/XffGRN) But I only did the letters I needed here.. ", "tags": ["2d", "text", "effects", "letters"], "likes": 21, "viewed": 266, "published": 3, "date": "1702990629", "time_retrieved": "2024-07-30T17:15:43.984474", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    12/18/23 @byt3_m3chanic \n*/\n\n#define R iResolution\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    O = vec4(pow(texture(iChannel0,F.xy/R.xy).rgb, vec3(.4545)),1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    12/18/23 @byt3_m3chanic \n*/\n\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\nfloat rbox( in vec2 p, in vec2 b, in vec4 r ) {\n    r.xy = (p.x>0.)?r.xy : r.zw;\n    r.x  = (p.y>0.)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.)+length(max(q,0.))-r.x;\n}\n\n// number\nfloat get3(vec2 p) {\n    vec2 of = vec2(0,.075);\n    float bt = max(\n    rbox(p-of,vec2(.15,.1),vec4(.075,.075,0,0)),\n    -rbox(p-of+vec2(.05,0),vec2(.15,.05),vec4(.035,.035,0,0))\n    );\n    float bb = max(\n    rbox(p+of,vec2(.15,.1),vec4(.075,.075,0,0)),\n    -rbox(p+of+vec2(.05,0),vec2(.15,.05),vec4(.035,.035,0,0))\n    );\n    return min(bt,bb);\n}\n//letters\nfloat getA(vec2 p) {\n    vec2 of = vec2(0,.075);\n    float bt = max(\n    rbox(p,vec2(.15,.175),vec4(.075,0,.075,0)),\n    -rbox(p+vec2(.0,.05),vec2(.1,.175),vec4(.035,0,.035,0))\n    );\n    float bb = box(p,vec2(.15,.025));\n    return min(bt,bb);\n}\n\nfloat getB(vec2 p) {\n    vec2 of = vec2(0,.075);\n    float bt = max(\n        rbox(p-of,vec2(.15,.1),vec4(.075,.075,0,0)),\n        -rbox(p-of,vec2(.1,.05),vec4(.035,.035,0,0))\n    );\n    float bb = max(\n        rbox(p+of,vec2(.15,.1),vec4(.075,.075,0,0)),\n        -rbox(p+of,vec2(.1,.05),vec4(.035,.035,0,0))\n    );\n    return min(bt,bb);\n}\n\nfloat getC(vec2 p) {\n    float bt = max(\n        rbox(p,vec2(.15,.175),vec4(0,0,.075,.075)),\n        -rbox(p-vec2(.05,0),vec2(.15,.125),vec4(0,0,.035,.035))\n    );\n    return bt;\n}\n\nfloat getE(vec2 p) {\n    vec2 of = vec2(0,.075);\n    float bt = max(\n        rbox(p-of,vec2(.15,.1),vec4(0,0,.075,.075)),\n        -rbox(p-of-vec2(.05,0),vec2(.15,.05),vec4(0,0,.035,.035))\n    );\n    float bb = max(\n        rbox(p+of,vec2(.15,.1),vec4(0,0,.075,.075)),\n        -rbox(p+of-vec2(.05,0),vec2(.15,.05),vec4(0,0,.035,.035))\n    );\n    return min(bt,bb);\n}\n\nfloat getH(vec2 p) {\n    float bt = min(\n        box(vec2(abs(p.x)-.125,p.y),vec2(.025,.175)),\n        box(p,vec2(.15,.025))\n    );\n    return bt;\n}\n\nfloat getI(vec2 p) {\n    float bt = min(\n        box(p,vec2(.025,.175)),\n        box(vec2(p.x,abs(p.y)-.15),vec2(.15,.025))\n    );\n    return bt;\n}\n\nfloat getM(vec2 p) {\n    vec2 of = vec2(.065,0);\n    float bt = max(\n        rbox(p+of,vec2(.085,.175),vec4(.075,0,.075,0)),\n        -rbox(p+of+vec2(.0,.05),vec2(.0375,.175),vec4(.035,0,.035,0))\n    );\n    float bb = max(\n        rbox(p-of,vec2(.085,.175),vec4(.075,0,.075,0)),\n        -rbox(p-of+vec2(.0,.05),vec2(.0375,.175),vec4(.035,0,.035,0))\n    );\n    return min(bt,bb);\n}\n\nfloat getN(vec2 p) {\n    float bt = max(\n        rbox(p,vec2(.15,.175),vec4(.075,0,.075,0)),\n        -rbox(p+vec2(.0,.045),vec2(.1,.175),vec4(.035,0,.035,0))\n    );\n    return bt;\n}\nfloat getT(vec2 p) {\n    vec2 of = vec2(0,.075);\n    return min(box(p-of-vec2(0,.075),vec2(.15,.025)),box(p,vec2(.025,.175)));\n}\n\nfloat getY(vec2 p) {\n    vec2 of = vec2(0,.075);\n    float bt = max(\n        rbox(p-of,vec2(.15,.1),vec4(0,.075,0,.075)),\n        -rbox(p-of-vec2(0,.05),vec2(.1,.1),vec4(0,.035,0,.035))\n    );\n    return min(bt,box(p+of,vec2(.025,.1)));\n}\n\n\n", "buffer_a_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    12/18/23 @byt3_m3chanic \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define TAU         6.28318530718\n\nfloat time;\nconst float scale = 7.;\nconst vec3 d = vec3(0.957,0.439,0.043);\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 a) { return fract(sin(dot(a, vec2(27.609, 57.583)))*43758.5453); }\nvec3 hue(float t){ return .55 + .45*cos(TAU*t*(vec3(.95,.97,.98)+vec3(1,.5,.2))); }\n\nvoid shade(float d, inout vec3 C, vec3 clr, float px) {\n    //d=abs(d)-.01;\n    C = mix(C,C*.6,smoothstep(.05+px,-px,d));\n    C = mix(C,clr,smoothstep(px,-px,d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 F )\n{\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    time =  texture(iChannel1,F/8.).r * iTimeDelta;\n    vec3 C = texture(iChannel0,(F.xy/R.xy)-vec2(0,time)*.013).rgb*exp2(-5.*time);\n    float v= max(box(uv,vec2(.95,.51)),-box(uv,vec2(.93,.49)));\n\n    float px = fwidth(uv.x);\n    float ths = hash21(vec2(floor(T*.5)));\n    float scale = ths>.75?2.75:ths>.45?1.75:.75;\n    \n    \n    C = mix(C,clamp(C+.01,C,vec3(1)),smoothstep(px,-px,v));\n    \n    uv*=rot(.2*cos(time*.1));\n    uv.x+=T*.125;\n    vec2 id = floor(uv*scale);\n    float hs = hash21(vec2(id.x,1.));\n    float rs = fract(hs*32.213);\n    \n    vec3 clr = hue(4.+(.5+.5*sin(uv.y*1.5+T)));\n    \n    if(rs>.5) { uv.y-=T*hs*.5; }else{uv.y+=T*hs*.5;}\n\n    id = floor(uv*scale)*.5;\n    uv=fract(uv*scale)-.5;\n    \n    hs = hash21(id+hs)*TAU;\n\n    uv*=rot(TAU*cos(hs+T*.075));\n    uv*=3.;\n    uv-=vec2(0,.50);\n\n    float d = getB(uv+vec2(.52,0));\n    shade(d,C,clr,px);\n    \n    d = getY(uv+vec2(.175,0));  \n    shade(d,C,clr,px);\n    \n    d = getT(uv-vec2(.175,0));  \n    shade(d,C,clr,px);\n \n    d = get3(uv-vec2(.52,0));  \n    shade(d,C,clr,px);\n    \n    // next line\n    uv+=vec2(0,.5);\n    \n    d = getM(uv+vec2(1.22,0));  \n    shade(d,C,clr,px);\n    \n    d = get3(uv+vec2(.87,0));  \n    shade(d,C,clr,px);\n \n    d = getC(uv+vec2(.52,0));  \n    shade(d,C,clr,px);\n    \n    d = getH(uv+vec2(.175,0));  \n    shade(d,C,clr,px);\n    \n    d = getA(uv-vec2(.175,0));  \n    shade(d,C,clr,px);\n    \n    d = getN(uv-vec2(.52,0));  \n    shade(d,C,clr,px);\n    \n    d = getI(uv-vec2(.87,0));  \n    shade(d,C,clr,px);\n    \n    d = getC(uv-vec2(1.22,0));  \n    shade(d,C,clr,px);\n\n    fragColor = vec4(C,1.);\n}", "buffer_a_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fX3Dr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[150, 150, 191, 191, 262]], "test": "untested"}
{"id": "XcX3DH", "name": "Georgian Alphabet (bitmap)", "author": "koiava", "description": "Bitmap font for the Georgian alphabet.\n\nGalaktioni\nhttps://en.wikipedia.org/wiki/Galaktion_Tabidze", "tags": ["text", "bitmap", "font", "alphabet", "symbols", "georgian"], "likes": 16, "viewed": 335, "published": 3, "date": "1702988852", "time_retrieved": "2024-07-30T17:15:44.753418", "image_code": "#define INTERPOLATION_LINEAR\n\nbool readBit(uint bits, int bitIndex) {\n    return (bits & (1u << bitIndex)) != 0u;\n}\n\nbool draw_char(uint c, ivec2 size, ivec2 uv){\n    if( uv.x >= size.x || uv.x < 0 ||\n        uv.y >= size.y || uv.y < 0)\n        return false;\n    \n    int y = size.y - uv.y - 1;\n    int bit = uv.x + y * size.x;\n    int uintIndex = bit / 32;\n    uint val = bitmaps[int(c)*3 + uintIndex];\n    \n    return readBit(val, 32 - bit % 32 - 1);\n}\n\nfloat draw_text(ivec2 uv, vec2 print_pos) {\n    float res = 0.0f;\n    float xEdge = print_pos.x;\n\n    if( float(uv.x) < print_pos.x ||\n        float(uv.y-12) > print_pos.y ||\n        float(uv.x-280) > print_pos.x ||\n        float(uv.y+1000) < print_pos.y) {\n        return 0.0f;\n    }\n    \n    int i = 0;\n    uint c;\n    while ((c = galaktioni[i]) != 255u) {\n       if (c == 50u) {\n           print_pos.y -= 14.0f;\n           print_pos.x = xEdge;\n       } else {\n           int char_actual_width = char_w[c];\n           vec2 new_uv = vec2(uv) - print_pos;\n           if(new_uv.x >= -1.0f &&\n           new_uv.x < float(char_actual_width+1) &&\n           new_uv.y >= -1.0f &&\n           new_uv.y < float(char_size.y+1)) {\n               vec2 uv_frac = fract(new_uv);\n               //bilinear sampling\n               \n               float val;\n#ifdef INTERPOLATION_LINEAR\n               float v0 = draw_char(c, char_size, ivec2(floor(new_uv)) + ivec2(0, 0))? 1.0f : 0.0f;\n               float v1 = draw_char(c, char_size, ivec2(floor(new_uv)) + ivec2(1, 0))? 1.0f : 0.0f;\n               float v2 = draw_char(c, char_size, ivec2(floor(new_uv)) + ivec2(0, 1))? 1.0f : 0.0f;\n               float v3 = draw_char(c, char_size, ivec2(floor(new_uv)) + ivec2(1, 1))? 1.0f : 0.0f;\n               val = mix(\n               mix(v0, v1, uv_frac.x),\n               mix(v2, v3, uv_frac.x),\n               uv_frac.y);\n#else\n               val = draw_char(c, char_size, ivec2(floor(new_uv)))? 1.0f : 0.0f;\n#endif\n               \n               res += val;\n           }\n           print_pos.x += float(char_actual_width + 1);\n       }\n       i++;\n    }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy;\n    \n    if(iMouse.z > 0.001f) {\n        uv -= iMouse.xy; \n        uv /= 4.0;\n        uv += iMouse.xy; \n    }\n\tivec2 duv = ivec2(floor(uv));\n    float h = iResolution.y;\n    float fade = h/3.0;\n    \n    vec2 print_pos;\n    print_pos.x = iResolution.x/2.0f - 100.0f;\n    print_pos.y = mod(iTime*5.0, iResolution.y * 2.5);\n\tfloat pixel = draw_text(duv, print_pos);\n    float dist1 = clamp(h - fragCoord.y, 0.0f, fade) / fade;\n    float dist2 = clamp(fragCoord.y, 0.0f, fade) / fade;\n    pixel *= min(dist1, dist2);\n    \n    pixel = pow(pixel, 0.45f);\n\n\tfragColor = vec4(vec3(pixel, pixel, pixel), 1.0);\n}", "image_inputs": [{"id": 35554, "src": "https://soundcloud.com/mariam-natroshvili/galaktioni-meri", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "const ivec2 char_size = ivec2(8, 12);\nconst uint bitmaps[] = uint[](\n0x00002010u,0x08888870u,0x00000000u, // á\n0x80C02070u,0x88888870u,0x00000000u, // á\n0x00000060u,0x90101070u,0x88888870u, // á\n0x0000006Cu,0x9292928Cu,0x8040FC02u, // á\n0x00000070u,0x88880808u,0x08888870u, // á\n0x00000070u,0x88080830u,0x08888870u, // á\n0x6090907Cu,0x1212120Cu,0x00000000u, // á\n0x0000006Cu,0x92929264u,0x00000000u, // á\n0x00000070u,0x88888850u,0x00000000u, // á\n0x00000010u,0x08080830u,0x08888870u, // á\n0x0000005Au,0xA5A58180u,0x8040FE01u, // á\n0x70880878u,0x88888870u,0x00000000u, // á\n0xF88080F0u,0x88888870u,0x00000000u, // á\n0x0000006Cu,0x92928244u,0x00000000u, // á\n0x20100808u,0x30088870u,0x00000000u, // á\n0x00000038u,0x4828A848u,0x08888870u, // á\n0x3E40C0ECu,0x92928244u,0x00000000u, // á \n0x80808090u,0x88888870u,0x00000000u, // á¡\n0x00000854u,0x949498A4u,0x84848478u, // á¢\n0x000000D8u,0x24240404u,0x04848478u, // á£\n0x0000006Cu,0x92929264u,0x0482827Cu, // á¤\n0x08080878u,0x88880808u,0x08888870u, // á¥\n0x0000006Cu,0x92928280u,0x8040FC02u, // á¦\n0x00000048u,0x88888878u,0x08888870u, // á§\n0x70A80878u,0x88888870u,0x00000000u, // á¨\n0xF08888F0u,0xC8888890u,0x00000000u, // á©\n0x00000090u,0x888888B0u,0x88888870u, // áª\n0x08080878u,0x88888870u,0x00000000u, // á«\n0x50A880F0u,0x88888870u,0x00000000u, // á¬\n0x10101074u,0x98987410u,0x08888870u, // á­\n0x808080F0u,0x88888870u,0x00000000u, // á®\n0x10101010u,0x701C1210u,0x08888870u, // á¯\n0x10083008u,0x08300888u,0x70000000u, // á°\n0x00000000u,0x00000000u,0x00000000u, // space\n0x00000000u,0x00000080u,0x80800000u, // ,\n0x00000000u,0x00000080u,0x00000000u, // .\n0x80808080u,0x80000080u,0x00000000u, // !\n0x70880808u,0x10200020u,0x00000000u, // ?\n0x00000000u,0x00FF0000u,0x00000000u, // -\n0x50505000u,0x00000000u,0x00000000u, // \"\n0x70888888u,0x88888870u,0x00000000u, // 0\n0x202060E0u,0x202020F8u,0x00000000u, // 1\n0x70888808u,0x102040FFu,0x00000000u, // 2\n0x70880830u,0x08888870u,0x00000000u, // 3\n0x88888888u,0xF8080808u,0x00000000u, // 4\n0xFF8080F0u,0x08088870u,0x00000000u, // 5\n0x708880F0u,0x88888870u,0x00000000u, // 6\n0xFF080808u,0x10102020u,0x00000000u, // 7\n0x70888870u,0x88888870u,0x00000000u, // 8\n0x70888888u,0x78088870u,0x00000000u  // 9\n);\n\nconst int char_w[] = int[](\n//  á  á  á  á  á  á  á  á  á  á á  á  á  á  á  á  á   á¡  á¢  á£  á¤  á¥  á¦  á§  á¨  á©  áª  á«  á¬  á­  á®  á¯  á°    ,  .  !  ?  -  \"  0  1  2  3  4  5  6  7  8  9\n    5, 5, 5, 7, 5, 5, 7, 7, 5, 5, 8, 5, 5, 7, 5, 6, 7, 5, 6, 6, 7, 5, 7, 5, 5, 5, 5, 5, 5, 6, 5, 7, 5, 8, 2, 2, 3, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5\n);\n\n#define _a 0u,\n#define _b 1u,\n#define _g 2u,\n#define _d 3u,\n#define _e 4u,\n#define _v 5u,\n#define _z 6u,\n#define _T 7u,\n#define _i 8u,\n#define _k 9u,\n#define _l 10u,\n#define _m 11u,\n#define _n 12u,\n#define _o 13u,\n#define _p 14u,\n#define _J 15u,\n#define _r 16u,\n#define _s 17u,\n#define _t 18u,\n#define _u 19u,\n#define _f 20u,\n#define _q 21u,\n#define _R 22u,\n#define _y 23u,\n#define _S 24u,\n#define _C 25u,\n#define _c 26u,\n#define _Z 27u,\n#define _w 28u,\n#define _W 29u,\n#define _x 30u,\n#define _j 31u,\n#define _h 32u,\n#define _spc 33u,\n#define _com 34u,\n#define _dot 35u,\n#define _exc 36u,\n#define _que 37u,\n#define _dsh 38u,\n#define _quo 39u,\n#define _0 40u,\n#define _1 41u,\n#define _2 42u,\n#define _3 43u,\n#define _4 44u,\n#define _5 45u,\n#define _6 46u,\n#define _7 47u,\n#define _8 48u,\n#define _9 49u,\n#define _nl 50u,\n\nconst uint galaktioni[] = uint[](\n_S _e _n _spc _j _v _a _r _s _spc _i _w _e _r _d _i _spc _i _m _spc _R _a _m _e _s _com _spc _m _e _r _i _exc _nl\n_m _e _r _i _com _spc _i _m _spc _R _a _m _e _s _spc _m _a _g _spc _T _v _a _l _T _a _spc _k _v _d _o _m _a _com _nl\n_s _a _n _d _o _m _i _a _n _spc _c _i _s _spc _e _l _v _a _spc _d _a _spc _f _e _r _i _nl\n_m _w _u _x _a _r _e _spc _i _y _o _com _spc _v _i _T _spc _S _e _m _o _d _g _o _m _a _exc _nl\n_nl\n_a _f _e _T _q _e _b _u _l _i _spc _d _a _spc _m _o _c _a _x _c _a _x _e _nl\n_i _w _o _d _a _spc _n _a _T _e _l _spc _a _l _T _a _spc _k _r _e _b _u _l _i _com _nl\n_m _a _g _r _a _m _spc _s _a _n _T _l _e _b _z _e _spc _u _f _r _o _spc _e _g _spc _s _a _x _e _nl\n_i _y _o _spc _i _d _u _m _a _l _spc _g _a _f _i _T _r _e _b _u _l _i _dot _nl\n_nl\n_i _w _o _d _a _spc _t _a _Z _r _i _s _spc _g _u _m _b _a _T _i _com _spc _k _a _l _T _a _com _nl\n_v _a _r _d _T _a _spc _d _i _o _d _a _spc _n _e _l _i _spc _s _u _r _n _e _l _i _dot _nl\n_m _a _g _r _a _m _spc _l _o _d _i _n _i _T _spc _d _a _R _a _l _u _l _spc _q _a _l _T _a _nl\n_s _x _v _a _spc _a _r _i _s _spc _l _o _c _v _a _spc _g _a _n _u _k _u _r _n _e _l _i _dot _nl\n_nl\n_m _e _s _m _o _d _a _spc _S _e _n _i _spc _u _g _o _n _o _spc _f _i _c _i _dot _dot _dot _nl\n_m _e _r _i _com _spc _Z _v _i _r _f _a _s _o _exc _spc _d _R _e _s _a _c _spc _a _r _spc _m _j _e _r _a _dot _dot _dot _nl\n_v _i _c _i _spc _w _a _m _e _b _a _com _spc _m _a _g _r _a _m _spc _a _r _spc _v _i _c _i _com _nl\n_e _s _spc _g _l _o _v _a _spc _i _y _o _spc _T _u _spc _j _v _a _r _i _s _w _e _r _a _que _nl\n_nl\n_l _o _d _e _b _T _a _n _spc _v _i _R _a _c _spc _m _w _a _r _e _d _spc _g _o _d _e _b _d _a _nl\n_d _a _spc _b _e _W _d _e _b _i _s _spc _T _v _l _e _b _s _spc _q _a _r _S _i _spc _k _a _r _g _a _v _d _a _dot _dot _dot _nl\n_i _y _o _spc _o _b _l _o _b _a _spc _d _a _spc _S _e _c _o _d _e _b _a _com _nl\n_d _R _e _s _a _s _w _a _u _l _s _spc _k _i _spc _e _s _spc _d _R _e _spc _a _r _spc _h _g _a _v _d _a _dot _nl\n_nl\n_t _a _Z _r _i _d _a _n _spc _g _a _s _u _l _s _spc _n _a _b _i _j _i _spc _C _q _a _r _i _nl\n_s _a _d _spc _m _a _t _a _r _e _b _d _a _que _spc _x _e _d _v _a _spc _m _i _m _Z _i _m _d _a _exc _nl\n_q _u _C _a _S _i _spc _m _Z _a _f _r _i _spc _d _a _h _q _r _o _d _a _spc _q _a _r _i _nl\n_d _a _spc _g _a _n _u _w _y _v _e _t _l _i _v _spc _w _v _i _m _d _a _spc _d _a _spc _w _v _i _m _d _a _dot _nl\n_nl\n_n _a _b _a _d _i _spc _t _a _n _z _e _spc _S _e _m _o _v _i _x _v _i _e _com _nl\n_T _a _v _i _spc _m _i _v _a _n _d _e _spc _f _i _q _r _s _spc _S _e _u _w _y _v _e _t _e _l _s _dot _dot _dot _nl\n_o _h _exc _spc _S _e _n _i _spc _s _a _x _l _i _exc _spc _m _e _spc _s _a _x _l _T _a _n _spc _i _q _v _e _nl\n_R _o _n _e _m _i _x _d _i _l _i _spc _m _i _v _a _w _e _q _spc _k _e _d _e _l _s _dot _nl\n_nl\n_a _s _e _spc _m _w _u _x _a _r _e _spc _v _i _d _e _q _i _spc _d _i _d _x _a _n _s _nl\n_d _a _spc _C _e _m _s _spc _w _i _n _spc _S _a _v _i _com _spc _s _w _o _r _i _spc _v _e _r _x _v _e _b _i _nl\n_a _S _r _i _a _l _e _b _d _n _e _n _spc _f _o _T _l _e _b _s _spc _b _n _e _l _x _m _i _a _n _s _com _nl\n_r _o _g _o _r _c _spc _g _a _f _r _e _n _i _l _spc _a _r _w _i _v _i _s _spc _f _r _T _e _b _i _dot _nl\n_nl\n_d _a _spc _S _r _i _a _l _e _b _d _a _spc _t _o _t _i _spc _v _e _r _x _v _i _s _a _com _nl\n_r _a _z _e _spc _dsh _spc _v _i _n _spc _i _c _i _s _exc _spc _v _i _n _spc _i _c _i _s _spc _m _e _r _i _exc _nl\n_b _e _d _i _com _spc _r _o _m _e _l _i _c _spc _m _e _spc _a _r _spc _m _e _R _i _r _s _a _spc _dsh _nl\n_q _a _r _s _spc _m _i _h _y _v _e _b _o _d _a _com _spc _r _o _g _o _r _c _spc _n _a _m _q _e _r _i _dot _nl\n_nl\n_s _T _q _v _i _spc _u _e _c _a _r _i _spc _g _a _s _x _i _v _o _s _n _e _b _a _nl\n_r _a _d _spc _C _a _q _r _a _spc _a _s _e _que _spc _v _i _s _spc _v _e _v _e _d _r _e _b _i _que _nl\n_r _a _d _spc _a _S _r _i _a _l _d _a _spc _C _e _m _i _spc _o _c _n _e _b _a _com _nl\n_r _o _g _o _r _c _spc _g _a _f _r _e _n _i _l _spc _a _r _w _i _v _i _s _spc _f _r _T _e _b _i _que _nl\n_nl\n_a _n _spc _c _a _s _spc _R _i _m _i _l _i _T _spc _r _a _d _spc _g _a _v _c _q _e _r _o _d _i _com _nl\n_a _n _spc _r _a _d _spc _v _i _W _e _r _d _i _spc _S _u _q _s _spc _m _o _k _a _m _k _a _m _e _s _que _nl\n_a _n _spc _quo _m _e _s _a _f _l _a _v _e _s _quo _spc _r _i _s _T _v _i _s _spc _v _m _R _e _r _o _d _i _com _nl\n_a _n _spc _v _i _n _spc _i _s _m _e _n _d _a _spc _C _e _m _s _spc _quo _m _e _spc _d _a _spc _R _a _m _e _s _quo _que _nl\n_nl\n_q _a _r _i _spc _d _a _spc _w _v _i _m _i _s _spc _w _v _e _T _e _b _i _spc _x _S _i _r _i _nl\n_w _y _d _e _b _o _d _n _e _n _spc _r _o _g _o _r _c _spc _m _w _y _d _e _b _o _d _a _spc _g _u _l _i _nl\n_d _a _spc _m _e _spc _a _v _t _i _r _d _i _spc _v _i _T _spc _m _e _f _e _spc _l _i _r _i _com _nl\n_l _i _r _i _spc _y _v _e _l _a _s _g _a _n _spc _m _i _t _o _v _e _b _u _l _i _dot _nl\n_nl _nl\n_spc _spc _spc _spc _spc _spc _spc _spc _spc _spc _spc _g _a _l _a _k _t _i _o _n _i _dot _spc _1 _9 _1 _5 _spc\n255u);", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XcX3DH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 69, 69, 115], [117, 117, 162, 162, 454], [456, 456, 499, 499, 2113], [2115, 2115, 2172, 2172, 2803]], "test": "untested"}
{"id": "lcl3Wr", "name": "easing scan line transition", "author": "zyc", "description": "a easing scan line transition demo", "tags": ["line", "scan", "scan", "easing", "transitioner"], "likes": 0, "viewed": 148, "published": 3, "date": "1702974338", "time_retrieved": "2024-07-30T17:15:45.521365", "image_code": "#define POINT_FACTOR 0.05\n#define LINE_WIDTH 0.01\n\n\nfloat pointy (float f) {\n    return POINT_FACTOR/(abs(f)+POINT_FACTOR);\n}\n\nfloat vMag (vec4 v) {\n    return v.x*v.x + v.y*v.y + v.z*v.z;\n}\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 texF = texture(iChannel0, uv ).xyz; \n    vec3 texT = texture(iChannel1, uv ).xyz; \n    \n    vec3 col = vec3(0.0);    \n    float r = fract(iTime*0.3);    \n    float cp = cubicInOut(r);\n    \n    float f = abs(uv.x - cp);\n    f = step(LINE_WIDTH, f) * (f - LINE_WIDTH);\n    \n    col = vec3(pointy(f));\n    vec3 bg = mix(texT, texF, step(cp, uv.x));\n    //col = bg + col;\n    col = mix(bg, col, col.r);\n    fragColor = vec4(col, 0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcl3Wr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 76, 76, 125], [127, 127, 148, 148, 190], [192, 192, 219, 219, 303], [305, 305, 362, 362, 842]], "test": "untested"}
{"id": "Mfs3Wn", "name": "Equal-Area Octahedral Mapping", "author": "BeRo", "description": "left: equal-area octahedral normal mapping, right: collignon quincuncial projection\n\nComparison framework based on paniq's https://www.shadertoy.com/view/flcXRl . ", "tags": ["sphere", "normal", "mapping", "octahedral"], "likes": 10, "viewed": 235, "published": 3, "date": "1702969991", "time_retrieved": "2024-07-30T17:15:46.655334", "image_code": "// left: equal-area octahedral normal mapping, right: collignon quincuncial projection\n//\n// Comparison framework based on paniq's https://www.shadertoy.com/view/flcXRl \n//\n// oct*Encode and oct*Decode functions by Benjamin 'BeRo' Rosseaux - zlib licensed\n//\n// For to sum up, what this shader shows:\n//\n// The equal-area octahedral mapping seems to be comparable to the collignon\n// quincuncial projection, and with apparently less mathematical effort.\n\n// if defined, equal-area octahedral normal mapping is used\n#define OCT_EQUAL_AREA_AS_DEFAULT\n\n// if defined, shows how the spherical L1 arclength mapping is tilable in 2D\n//#define SHOW_TILING\n\n// if defined, shows latitude/longitude lines\n#define SHOW_FLOW_LINES\n\n// if defined, shows an environment map instead of a XYZ color gradient\n// for inverse mode, demonstrates texture mapping\n//#define SHOW_CUBEMAP\n\n// if defined, shows the latitude as cos(theta) instead of theta\n//#define SHOW_COS_THETA\n\n// if defined, shows a UV tesselation of quadliterals, and the proportional\n// difference between the quadliteral area and the expected average size (pi/NÂ²)\n// if FIX_EQUAL_AREA is defined, the proportions will be ideal.\n//#define SHOW_SOLID_ANGLE\n\n// if defined, adjusts the latitude so that equal spaced points on the map\n// are equal spaced on the sphere; if not defined, the latitude will map\n// exactly to the L1 radius.\n#define FIX_EQUAL_AREA\n\n// if not defined, computes a more accurate solid angle from cosines,\n// though the precision of this method is terrible and is only relevant\n// for rough tesselations anyway.\n#define USE_TRIANGLE_AREA\n\n// if defined, demonstrate the inverse mapping \n//#define SHOW_INVERSE\n#define SHOW_GUYOU_MAP\n\n// subdivisions per quadrant\n#if defined(SHOW_SOLID_ANGLE)||defined(SHOW_INVERSE)\n#undef SHOW_FLOW_LINES\n// solid angle subdivisions\nconst float subdivisions = 16.0;\n#else\n// flow line subdivisions\nconst float subdivisions = 8.0;\n#endif\n\n// WebGL's GLSL doesn't have fma, so define it here as macro \n#define fma(a, b, c) (((a) * (b)) + (c))\n\n//////\n\n#ifndef OCT_EQUAL_AREA_VARIANT\n  #define OCT_EQUAL_AREA_VARIANT 0\n#endif\n\n#ifdef OCT_EQUAL_AREA_AS_DEFAULT\n  #define octEncode octEqualAreaSignedEncode\n  #define octDecode octEqualAreaSignedDecode\n  #define octSignedEncode octEqualAreaSignedEncode\n  #define octSignedDecode octEqualAreaSignedDecode\n  #define octUnsignedEncode octEqualAreaUnsignedEncode\n  #define octUnsignedDecode octEqualAreaUnsignedDecode\n#else\n  #define octEncode octNonEqualAreaSignedEncode\n  #define octDecode octNonEqualAreaSignedDecode\n  #define octSignedEncode octNonEqualAreaSignedEncode\n  #define octSignedDecode octNonEqualAreaSignedDecode\n  #define octUnsignedEncode octNonEqualAreaUnsignedEncode\n  #define octUnsignedDecode octNonEqualAreaUnsignedDecode\n#endif\n\nvec2 octNonEqualAreaSignedEncode(vec3 vector) {\n  vector = normalize(vector); // just for to make sure that it is normalized\n  vec2 result = vector.xy / (abs(vector.x) + abs(vector.y) + abs(vector.z));\n  return (vector.z < 0.0) ? ((1.0 - abs(result.yx)) * fma(step(vec2(0.0), result.xy), vec2(2.0), vec2(-1.0))) : result;\n}\n\nvec2 octNonEqualAreaUnsignedEncode(vec3 vector) {\n  return fma(octNonEqualAreaSignedEncode(vector), vec2(0.5), vec2(0.5));\n}\n\nvec3 octNonEqualAreaSignedDecode(vec2 uv) {\n  vec3 v = vec3(uv.xy, 1.0 - (abs(uv.x) + abs(uv.y)));\n  return normalize((v.z < 0.0) ? vec3((1.0 - abs(v.yx)) * fma(step(vec2(0.0), v.xy), vec2(2.0), vec2(-1.0)), v.z) : v);\n}\n\nvec3 octNonEqualAreaUnsignedDecode(vec2 uv) {\n  return octNonEqualAreaSignedDecode(fma(uv, vec2(2.0), vec2(-1.0)));\n}\n\nvec2 octEqualAreaSignedEncode(vec3 vector){\n  vector = normalize(vector); // just for to make sure that it is normalized\n  const float oneOverHalfPi = 0.6366197723675814;\n#if OCT_EQUAL_AREA_VARIANT == 0\n  // More optimized version of variant 1 \n  vec2 uv = vec2(sqrt(1.0 - abs(vector.z)));\n  uv.y *= atan(abs(vector.y), max(1e-17, abs(vector.x))) * oneOverHalfPi;\n  uv.x -= uv.y;\n  return ((vector.z < 0.0) ? (vec2(1.0) - uv.yx) : uv.xy) * fma(step(vec2(0.0), vector.xy), vec2(2.0), vec2(-1.0));\n#elif OCT_EQUAL_AREA_VARIANT == 1\n  vec3 absVector = abs(vector);\n  vec2 phiTheta = vec2(atan(absVector.x, max(1e-17, absVector.y)) * oneOverHalfPi, sqrt(1.0 - absVector.z));\n  vec2 s = fma(vec2(lessThan(vector.xy, vec2(0.0))), vec2(-2.0), vec2(1.0)); // vec2 s = fma(step(vec2(0.0), vector.xy), vec2(2.0), vec2(-1.0));\n  vec2 uv = (vec2(phiTheta.x, 1.0 - phiTheta.x) * phiTheta.y) * s.xy;\n  return (vector.z < 0.0) ? fma(abs(uv.yx), -s, s) : uv;\n#else \n  // The latitude isn't equal area in this variant\n  vec3 absVector = abs(vector);\n  vec2 phiTheta = vec2(atan(absVector.x, max(1e-17, absVector.y)), acos(absVector.z)) * oneOverHalfPi;\n  vec2 s = fma(vec2(lessThan(vector.xy, vec2(0.0))), vec2(-2.0), vec2(1.0)); // vec2 s = fma(step(vec2(0.0), vector.xy), vec2(2.0), vec2(-1.0));\n  vec2 uv = (vec2(phiTheta.x, 1.0 - phiTheta.x) * phiTheta.y) * s.xy;\n  return (vector.z < 0.0) ? fma(abs(uv.yx), -s, s) : uv;\n#endif\n}\n\nvec2 octEqualAreaUnsignedEncode(vec3 vector){\n  return fma(octEqualAreaSignedEncode(vector), vec2(0.5), vec2(0.5));\n}\n\nvec3 octEqualAreaSignedDecode(vec2 uv){\n  const float halfPI = 1.5707963267948966;\n  vec2 absUV = abs(uv);\n#if OCT_EQUAL_AREA_VARIANT == 0\n  // More optimized version of variant 1 \n  const float PIover4 = 0.7853981633974483;\n  float d = 1.0 - (absUV.x + absUV.y), r = 1.0 - abs(d);\n  vec2 phiCosSin = sin(vec2((r != 0.0) ? (((absUV.y - absUV.x) / max(1e-17, r)) + 1.0) * PIover4 : 0.0) + vec2(halfPI, 0.0));\n  return normalize(vec3(abs(phiCosSin * (r * sqrt(2.0 - (r * r)))), 1.0 - (r * r)) * fma(step(vec3(0.0), vec3(uv, d)), vec3(2.0), vec3(-1.0)));  \n#elif OCT_EQUAL_AREA_VARIANT == 1\n  float absUVSum = absUV.x + absUV.y;\n  vec2 s = fma(step(vec2(0.0), uv), vec2(2.0), vec2(-1.0));\n  uv = (absUVSum > 1.0) ? ((vec2(1.0) - abs(uv.yx)) * s) : uv;\n  float d = 1.0 - absUVSum, r = 1.0 - abs(d);   \n  vec4 phiThetaSinCos = vec4(sin(vec2((abs(uv.x) / max(1e-17, abs(uv.x) + abs(uv.y))) * halfPI) + vec2(0.0, halfPI)), r * sqrt(2.0 - (r * r)), 1.0 - (r * r)); \n  return normalize(vec3(phiThetaSinCos.xy * phiThetaSinCos.zz * s.xy, (d < 0.0) ? -phiThetaSinCos.w : phiThetaSinCos.w));\n#else\n  // The latitude isn't equal area in this variant\n  float absUVSum = absUV.x + absUV.y;\n  vec2 s = fma(step(vec2(0.0), uv), vec2(2.0), vec2(-1.0));\n  uv = (absUVSum > 1.0) ? ((vec2(1.0) - abs(uv.yx)) * s) : uv;\n  vec4 phiThetaSinCos = sin(vec2(vec2(abs(uv.x) / max(1e-17, abs(uv.x) + abs(uv.y)), absUVSum) * halfPI).xxyy + vec2(0.0, halfPI).xyxy); \n  return normalize(vec3(phiThetaSinCos.xy * phiThetaSinCos.zz * s.xy, phiThetaSinCos.w));\n#endif\n}\n\n// thesis related functions\n//////////////////////////////////////////////////////////\n\nvec2 oct_wrap (vec2 v) {\n    return (1.0 - abs(v.yx)) * sign(v);\n}\n\n// https://jcgt.org/published/0003/02/01/\n// uv is [-1..1]x[-1..1]\nvec3 octahedral_surface(vec2 uv) {\n    float z = 1.0 - abs(uv.x) - abs(uv.y);\n    return vec3((z >= 0.0)?uv:oct_wrap(uv), z);\n    ///return octSignedDecode(uv); \n}\n\n// spherical coordinates from points on L1 surface\nvec2 L1_to_spherical(vec3 o) {\n    // L1 to L2 arclength\n    float r = abs(o.x) + abs(o.y);\n    float h = 1.0 - o.x / r;\n    // phi = half the L1 arclength * pi/2\n    float phi = (r == 0.0)?0.0:((o.y >= 0.0)?h: -h) * radians(90.0);\n    // L1 to L2 radius\n#ifdef FIX_EQUAL_AREA\n    // inverse of https://en.wikipedia.org/wiki/Collignon_projection\n    float z = 1.0 - abs(o.z);    \n    float theta = radians(90.0) - asin(1.0 - z*z)*sign(o.z);\n#else\n    float theta = (1.0 - o.z) * radians(90.0);\n#endif\n    return vec2(phi, theta);\n}\n\n// uv is [-pi..pi]x[0..pi]\nvec3 spherical_surface(vec2 uv) {\n    float phi_s = sin(uv.x);\n    float phi_c = cos(uv.x);\n    float theta_s = sin(uv.y);\n    float theta_c = cos(uv.y);\n    return vec3(\n        theta_s * phi_c,\n        theta_s * phi_s,\n        theta_c\n    );\n}\n\n// [0..1]x[0..1]+offset -> [-1..1]x[-1..1]\n// https://en.wikipedia.org/wiki/Peirce_quincuncial_projection\nvec2 tile_quincuncial(vec2 p) {\n    p = mod(p, 2.0);\n    ivec2 q = ivec2(p);\n    vec2 uv = p - vec2(q);\n    return (uv*2.0-1.0)*((((q.x ^ q.y) & 1) != 0)?-1.0:1.0);\n}\n\n// [0..2]x[0..1]+offset -> [-1..1]x[-1..1]\n// https://en.wikipedia.org/wiki/Guyou_hemisphere-in-a-square_projection\nvec2 tile_guyou(vec2 p) {\n    p = vec2(p.x + p.y, p.y - p.x + 1.0)/2.0;\n    return tile_quincuncial(p);\n}\n\n//// inversion\n\n// n is a normal vector\nvec2 spherical_coordinates(vec3 n) {\n    return vec2(atan(n.y, n.x), acos(n.z));\n}\n\n// point on L1 surface from spherical coordinates\nvec3 spherical_to_L1(vec2 uv) {\n    // L2 to L1 radius\n#ifdef FIX_EQUAL_AREA\n    // forward formula of https://en.wikipedia.org/wiki/Collignon_projection\n    float theta = radians(90.0) - uv.y;\n    float z = (1.0 - sqrt(1.0 - sin(abs(theta))))*sign(theta);\n#else\n    float z = 1.0 - uv.y / radians(90.0);\n#endif\n    // L2 to L1 arclength\n    float a = uv.x / radians(45.0);\n    float r = 1.0 - abs(z);\n    a = mod(a + 4.0, 8.0) - 4.0;\n    float cos_x = 1.0 - abs(a) / 2.0;\n    vec2 xy = r * vec2(cos_x, sign(a)*(1.0 - abs(cos_x)));\n    return vec3(xy, z);\n}\n\nvec3 L1normalize(vec3 n) {\n    return n / (abs(n.x) + abs(n.y) + abs(n.z));\n}\n\n// n is a point on the L1 surface\nvec2 octahedral_coordinates(vec3 n) {\n    n = L1normalize(n); // not necessary if point is already normalized\n    return (n.z >= 0.0)?n.xy:oct_wrap(n.xy);\n}\n\n// [-1..1]x[-1..1] -> [0..2]x[0..1]\nvec2 inverse_guyou(vec2 o) {    \n    o = vec2(o.x - o.y + 1.0/2.0, o.x + o.y - 1.0/2.0);\n    o += vec2(-0.5, 0.5);\n    if (o.y >= 1.0) {\n        o = 2.0 - o;        \n    } else if (o.x < -1.0) {\n        o.x = o.x + 4.0;\n    } else if (o.y < -1.0) {\n        o = vec2(2.0,-2.0) - o;\n    }\n    return (o+1.0)/2.0;\n}\n\n// visualization\n//////////////////////////////////////////////////////////\n\nfloat triangle_area(vec3 A, vec3 B, vec3 C) {\n    return length(cross(B - A, C - A)) / 2.0;\n}\n\nvec2 nanglebasis (vec3 a, vec3 b) {\n    float ab = dot(a, b);\n    return vec2(ab, sqrt(1.0 - ab * ab));\n}\n\nfloat simplex_solid_angle (vec2 u, vec2 v, vec2 w) {\n    float A =\n            acos((u.x - v.x * w.x) / (v.y * w.y))\n            + acos((v.x - w.x * u.x) / (w.y * u.y))\n            + acos((w.x - u.x * v.x) / (u.y * v.y))\n            - radians(180.0);\n    return (A != A)?0.0:A;\n}\n\nfloat pyramid_points_solid_angle (vec3 A, vec3 B, vec3 C, vec3 D) {\n#ifdef USE_TRIANGLE_AREA\n    return triangle_area(A, B, C) + triangle_area(C, D, A);\n#else\n    vec2 ab = nanglebasis(A, B);\n    vec2 ac = nanglebasis(A, C);\n    vec2 da = nanglebasis(A, D);\n    vec2 bc = nanglebasis(B, C);\n    vec2 cd = nanglebasis(C, D);\n    return simplex_solid_angle(bc, ac, ab) + simplex_solid_angle(da, ac, cd);\n#endif\n}\n\nvec3 plasma(float t) {\n\n    const vec3 c0 = vec3(0.05873234392399702, 0.02333670892565664, 0.5433401826748754);\n    const vec3 c1 = vec3(2.176514634195958, 0.2383834171260182, 0.7539604599784036);\n    const vec3 c2 = vec3(-2.689460476458034, -7.455851135738909, 3.110799939717086);\n    const vec3 c3 = vec3(6.130348345893603, 42.3461881477227, -28.51885465332158);\n    const vec3 c4 = vec3(-11.10743619062271, -82.66631109428045, 60.13984767418263);\n    const vec3 c5 = vec3(10.02306557647065, 71.41361770095349, -54.07218655560067);\n    const vec3 c6 = vec3(-3.658713842777788, -22.93153465461149, 18.19190778539828);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a); float s = sin(a);\n    return vec2(p.x*c + p.y*s, s*p.x - c*p.y);\n}\n\nvec3 stereographic_sphere(vec2 uv) {\n    vec3 n = vec3(uv, sqrt(1.0 - dot(uv,uv)));\n    float t = iTime*0.1;\n    n.yz = rotate(n.yz, radians(sin(t*0.25*radians(360.0))*45.0));    \n    n.xz = rotate(n.xz, t*radians(360.0));    \n    return n;\n}\n\n//////////////////////////////////////////////////////////\n\n// for inverse mapping\nvec3 transfer_color(vec2 q) {\n#ifdef SHOW_GUYOU_MAP\n    q = inverse_guyou(q);\n    // mirror U coordinate (0-1-0)\n    q.x = 1.0-abs(1.0-q.x);\n#else\n    q = q*0.5 + 0.5;\n#endif\n#ifdef SHOW_CUBEMAP\n    return textureLod(iChannel1, q*4.0, 2.0).rgb;\n#else\n    q = q - mod(q, 1.0/subdivisions);\n    return vec3(q, 0.0);\n#endif\n}\n\nvec3 transfer_color(vec3 p) {\n#ifdef SHOW_CUBEMAP\n    p.xy = rotate(p.xy, radians(90.0 + 45.0));\n    p.xz = rotate(p.xz, radians(90.0));\n    return textureLod(iChannel0, p, 0.0).xyz;\n#elif defined(SHOW_INVERSE)\n    vec2 q = octahedral_coordinates(spherical_to_L1(spherical_coordinates(p)));\n    q = q - mod(q, 1.0/subdivisions);\n    return vec3(q*0.5 + 0.5, 0.0);\n#else\n    return p*0.5 + 0.5;\n#endif\n}\n\nfloat flow_lines(vec3 q) {\n    float a = atan(q.y, q.x);\n#ifdef SHOW_COS_THETA\n    float r = q.z*radians(90.0);\n#else\n    float r = acos(q.z);\n#endif\n    float A = subdivisions;\n    return sin((a-iTime*0.1)*2.0*A)*sin(r*A);\n}\n\nfloat octahedral_map_flow_lines(vec2 p) {\n    return flow_lines(normalize(octSignedDecode(p)));    \n}\n\nfloat octahedral_arc_map_flow_lines(vec2 p) {\n    return flow_lines(spherical_surface(L1_to_spherical(octahedral_surface(p))));\n}\n\nfloat tiled_octahedral_arc_map_flow_lines(vec2 p) {\n    return flow_lines(spherical_surface(L1_to_spherical(octahedral_surface(tile_guyou((p-1.0)/2.0)))));\n}\n\nbool in_range(vec2 p) {\n    return max(abs(p.x),abs(p.y)) < 1.0;\n}\n\nvec3 solid_angle_color(vec3 p00, vec3 p10, vec3 p01, vec3 p11) {\n    // ideal solid angle: pi / subdivisionsÂ²\n    float isa = radians(180.0) / (subdivisions * subdivisions);\n    float sa1 = pyramid_points_solid_angle(p00,p10,p11,p01);\n    float sa2 = pyramid_points_solid_angle(p10,p00,p01,p11);\n    float sa = (uv.x*uv.y < 0.0)?sa1:sa2;\n#if 1\n    sa = abs(sa/isa-1.0);\n#else\n    sa = abs(log2(sa/isa));\n#endif\n    return plasma(clamp(sa,0.0,1.0));\n}\n\nvoid paint_octahedral_map() {\n    set_line_width_px(1.2);\n    vec2 uv = get_origin();    \n    vec3 p = normalize(octSignedDecode(uv));\n    set_source_rgb(transfer_color(p));\n#ifdef SHOW_SOLID_ANGLE\n    float s = 1.0/subdivisions;\n    uv = uv - mod(uv, s) + s * 0.5;\n    vec2 w = 0.5*vec2(-s,s);\n    vec3 p00 = normalize(octSignedDecode(uv + w.xx));\n    vec3 p10 = normalize(octSignedDecode(uv + w.yx));\n    vec3 p01 = normalize(octSignedDecode(uv + w.xy));\n    vec3 p11 = normalize(octSignedDecode(uv + w.yy));\n    set_source_rgb(solid_angle_color(p00,p10,p01,p11));\n#endif        \n    rectangle(-1.0, -1.0, 2.0, 2.0);    \n    fill_preserve();    \n    set_source_rgb(vec3(0.0));\n    stroke();\n#ifdef SHOW_FLOW_LINES    \n    if (in_range(get_origin())) {\n       graph2D(octahedral_map_flow_lines);\n       stroke();\n    }\n#endif\n}\n\nvoid paint_inverse_octahedral_map() {\n    set_line_width_px(1.2);\n    vec3 n = stereographic_sphere(get_origin());     \n    vec2 uv = octEncode(n);    \n    set_source_rgb(transfer_color(uv));\n    circle(0.0, 0.0, 1.0);\n    fill_preserve();    \n    set_source_rgb(vec3(0.0));\n    stroke();\n}\n\nvoid tile_octahedral_arc_map() {\n    set_line_width_px(1.5);\n#if 1\n    vec3 p = spherical_surface(L1_to_spherical(octahedral_surface(tile_guyou((get_origin()+1.0)/2.0))));\n    set_source_rgb(transfer_color(p));\n#else\n    vec2 uv = (get_origin()+1.0)/2.0;\n    #if 1\n    uv = fract(uv);\n    uv = uv*2.0-1.0;\n    #endif\n    #if 1\n    //uv = tile_guyou(uv);\n    uv = inverse_guyou(uv);\n    #else\n    uv = tile_quincuncial(uv);\n    #endif\n    uv = uv*0.5+0.5;\n    if (min(uv.x,uv.y) < 0.0)\n        return;\n    if (uv.x > 2.0)\n        return;   \n    if (uv.y > 1.0)\n        return; \n    float b = clamp(uv.x - 1.0, 0.0, 1.0);\n    uv.x = fract(uv.x);\n    set_source_rgb(vec3(uv,b));\n#endif\n    clear();\n    rectangle(-1.0, -1.0, 4.0, 2.0);\n    set_source_rgb(vec3(0.0));\n    stroke();\n#ifdef SHOW_FLOW_LINES\n    set_source_rgb(vec3(0.0));\n    graph2D(tiled_octahedral_arc_map_flow_lines);\n    stroke();\n#endif\n}\n\nvoid paint_octahedral_arc_map() {\n    set_line_width_px(1.2);\n    \n    vec2 uv = get_origin();    \n    vec3 p = spherical_surface(L1_to_spherical(octahedral_surface(uv)));\n    set_source_rgb(transfer_color(p));\n#ifdef SHOW_SOLID_ANGLE\n    float s = 1.0/subdivisions;\n    uv = uv - mod(uv, s) + s * 0.5;\n    vec2 w = 0.5*vec2(-s,s);\n    vec3 p00 = spherical_surface(L1_to_spherical(octahedral_surface(uv + w.xx)));\n    vec3 p10 = spherical_surface(L1_to_spherical(octahedral_surface(uv + w.yx)));\n    vec3 p01 = spherical_surface(L1_to_spherical(octahedral_surface(uv + w.xy)));\n    vec3 p11 = spherical_surface(L1_to_spherical(octahedral_surface(uv + w.yy)));\n    set_source_rgb(solid_angle_color(p00,p10,p01,p11));\n#endif    \n    rectangle(-1.0, -1.0, 2.0, 2.0);\n    fill_preserve();    \n    set_source_rgb(vec3(0.0));\n    stroke();\n#ifdef SHOW_FLOW_LINES\n    if (in_range(get_origin())) {\n        graph2D(octahedral_arc_map_flow_lines);\n        stroke();\n    }\n#endif\n}\n\nvoid paint_inverse_octahedral_arc_map() {\n    set_line_width_px(1.2);\n    vec3 n = stereographic_sphere(get_origin());     \n    vec2 uv = octahedral_coordinates(spherical_to_L1(spherical_coordinates(n)));\n    set_source_rgb(transfer_color(uv));\n    circle(0.0, 0.0, 1.0);\n    fill_preserve();\n    set_source_rgb(vec3(0.0));\n    stroke();\n}\n\nvoid paint() {\n    set_source_rgb(vec3(0.2));\n    clear();\n\n#ifdef SHOW_TILING\n    scale(0.5);\n    tile_octahedral_arc_map();\n#elif defined(SHOW_INVERSE)\n    scale(0.75);\n    if (get_origin().x < 0.0) {\n        translate(-1.1,0.0);\n        paint_inverse_octahedral_map();\n    } else {\n        translate(1.1,0.0);\n        paint_inverse_octahedral_arc_map();\n    }\n#else\n    scale(0.75);\n    if (get_origin().x < 0.0) {\n        translate(-1.1,0.0);\n        paint_octahedral_map();\n    } else {\n        translate(1.1,0.0);\n        paint_octahedral_arc_map();\n    }\n#endif    \n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord, iMouse.xy, iResolution.xy);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.16\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2020-12-02: 0.16\n// * support for drawing concentric rings\n\n// 2020-11-30: 0.15\n// * support for drawing orthogonal grids\n// * adjusted uv so corners are centered on pixels\n// * small adjustment to line pixel width computation\n\n// 2020-11-12: 0.14\n// * added support for depth testing\n\n// 2020-11-11: 0.13\n// * fixed 2D graphs not filling\n// * added circle_px()\n\n// 2019-06-06: 0.12\n// * split implementation and demo into common and image tab\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\nvoid set_source_depth(float depth);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the old source with the new one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n// if enabled, use the depth value for testing;\n// smaller values win\nvoid depth_test(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add a circle path at P with pixel radius R\nvoid circle_px(vec2 p, float r);\nvoid circle_px(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// add an orthogonal grid with cell size S\nvoid grid(vec2 s);\nvoid grid(float w, float h);\nvoid grid(float s);\n// draw concentric rings around origin p, with spacing r and offset phase\nvoid rings(vec2 p, float r, float phase);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// draw a letter with the given texture coordinate\nvoid letter(sampler2D font_texture_source, ivec2 l);\nvoid letter(sampler2D font_texture_source, int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    bool depth_test;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n    float source_z;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n#define DEFAULT_DEPTH 1e+30\n\nContext _stack;\n\nvoid init (vec2 fragCoord, vec2 mouse, vec2 resolution) {\n\taspect = vec2(resolution.x / resolution.y, 1.0);\n\tScreenH = min(resolution.x,resolution.y);\n\tAA = ScreenH*0.5;\n\tAAINV = 1.0 / AA;\n    \n    uv = (fragCoord.xy - 0.5) / resolution;\n    vec2 m = mouse / resolution;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false,\n        DEFAULT_DEPTH\n    );\n}\n\nvec3 _color = vec3(1);\nfloat _depth = DEFAULT_DEPTH;\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color.rgb = mix(_color.rgb, _stack.source.rgb, _stack.source.a);\n    _depth = (_stack.source.a == 1.0)?_stack.source_z:_depth;\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(pow(_color.rgb, vec3(1.0/2.2)), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color.rgb;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    if (_stack.depth_test) {\n        if ((w == 1.0) && (_stack.source_z <= _depth)) {\n            _depth = _stack.source_z;\n        } else if ((w == 0.0) || (_stack.source_z > _depth)) {            \n            return;\n        }\n    }\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color.rgb = _color.rgb * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\n\nvoid depth_test(bool enable) {\n    _stack.depth_test = enable;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_depth(float depth) {\n    _stack.source_z = depth;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(sampler2D font_texture_source, ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(sampler2D font_texture_source, int lx, int ly) {\n    letter(font_texture_source, ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid grid(vec2 size) {\n    vec4 f = abs(fract(_stack.position/size.xyxy+0.5)-0.5)*size.xyxy;\n    add_field(vec2(min(f.x,f.y),min(f.z,f.w)));\n}\nvoid grid(float w, float h) {\n    grid(vec2(w,h));\n}\nvoid grid(float s) {\n    grid(vec2(s));\n}\nvoid rings(vec2 p, float r, float phase) {\n    vec4 q = _stack.position - p.xyxy;\n    vec2 f = abs(fract(vec2(length(q.xy),length(q.zw))/r-phase+0.5)-0.5)*r;\n    add_field(f);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid circle_px(vec2 p, float r) {\n    circle(p, r/(0.5*ScreenH));\n}\nvoid circle_px(float x, float y, float r) {\n    circle_px(vec2(x,y), r);\n}\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(f_x / length(df_x));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mfs3Wn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2800, 2800, 2847, 2847, 3123], [3125, 3125, 3174, 3174, 3249], [3251, 3251, 3294, 3294, 3471], [3473, 3473, 3518, 3518, 3590], [3592, 3592, 3635, 3635, 5008], [5010, 5010, 5055, 5055, 5127], [5129, 5129, 5168, 5168, 6663], [6753, 6753, 6777, 6777, 6819], [6821, 6888, 6922, 6922, 7051], [7053, 7104, 7134, 7160, 7635], [7637, 7664, 7697, 7697, 7909], [7911, 8017, 8048, 8048, 8183], [8185, 8301, 8326, 8326, 8406], [8424, 8448, 8484, 8484, 8530], [8532, 8582, 8613, 8636, 9139], [9141, 9141, 9167, 9167, 9218], [9220, 9254, 9291, 9291, 9410], [9412, 9448, 9476, 9476, 9760], [9839, 9839, 9884, 9884, 9932], [9934, 9934, 9969, 9969, 10039], [10041, 10041, 10093, 10093, 10320], [10322, 10322, 10389, 10389, 10732], [10734, 10734, 10756, 10756, 11410], [11412, 11412, 11442, 11442, 11531], [11533, 11533, 11569, 11569, 11775], [11837, 11860, 11889, 11889, 12182], [12184, 12184, 12213, 12213, 12586], [12588, 12588, 12614, 12614, 12813], [12815, 12815, 12856, 12856, 12916], [12918, 12918, 12963, 12963, 13047], [13049, 13049, 13100, 13100, 13206], [13208, 13208, 13231, 13231, 13274], [13276, 13276, 13340, 13386, 13727], [13729, 13729, 13758, 13758, 14557], [14559, 14559, 14596, 14596, 14849], [14851, 14851, 14883, 14883, 15755], [15757, 15757, 15790, 15790, 16728], [16730, 16730, 16771, 16771, 17069], [17071, 17071, 17085, 17085, 17645], [17707, 17707, 17764, 17764, 17850]], "test": "untested"}
{"id": "lfs3Wn", "name": "Green and gold flower rug", "author": "jarble", "description": "A rug with a green and gold flower pattern.", "tags": ["fractal", "music", "carpet", "rug"], "likes": 18, "viewed": 435, "published": 3, "date": "1702964329", "time_retrieved": "2024-07-30T17:15:47.447216", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nconst float scale = 1.5;\n\nvoid transform(inout vec2 uv, inout vec2 t2){\n        t2 = triangle_wave(uv+.5);\n        uv =\n            t2-triangle_wave(uv.yx)-fract(t2/2.)\n        ;\n        //{t2.x = (t2.x+1.5*sign(t2.y-t2.x)); }\n        //{uv.x = (uv.x+1.5*sign(uv.y-uv.x)); }\n        //{t2.y = (t2.y+1.*sign(t2.y-t2.x)); }\n\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\nvec3 fractal(vec2 uv){\n    vec3 col = vec3(0.);\n    vec2 t2 = vec2(0.);\n    vec3 col1 = col;\n    float c1=0.;\n    for(int k = 0; k < 15; k++){\n        float warp_scale = 16.;\n        vec2 warp =\n            //abs(.5-fract(uv*3.))*3.\n            //abs(.5-fract(t2*3.))*3.\n            vec2(sin((t2.x)*warp_scale),cos((t2.y)*warp_scale))\n            //vec2(sin((uv.x)*warp_scale),cos((uv.y)*warp_scale))\n        ;\n        uv.y -= 1./4.;\n\n        uv = (uv+t2)/scale;\n        \n        uv = (fract(vec2(uv+vec2(.5,1.5))*scale)-.5)/scale;\n        col.x =\n            max(length(uv-t2-c1)/3.,col.x);\n        \n        ;\n        if(k>1)\n        warp = warp*warp/warp_scale;\n        else\n        warp = vec2(0);\n\n        vec2 uv_1 =\n            uv + warp.yx\n        ,\n        t2_1=\n            t2 + warp.yx\n        ;\n        vec3 col_1 = col;\n        transform(uv,t2);\n\n        transform(uv_1,t2_1);\n        //uv_1 = rotate(uv_1,t2.x*2.);\n        //t2_1 = rotate(t2_1,t2.x*2.);\n        \n        c1 =\n            max(abs(uv_1.y+uv_1.x)/2.,c1)\n            //max(abs(uv_1.y-uv_1.x),c1)\n        ;\n        c1 =\n            max(1.-abs(2.*c1-1.),c1/4.)\n        ;\n        col.x =\n            max(length(uv_1-t2_1-c1)/3.,col.x)\n\n        ;\n        //if(uv.y>-.25)\n        col =\n            abs(col-(1.-(c1*col.x)));\n        col1 =\n            abs(col1*c1-col-1.).yzx\n            //abs(col1*c1*sign(t2.y-t2.x)/2.-col-1.).yzx\n            //abs(col1*c1-col+sign(t2.x-t2.y)).yzx\n        ;\n    }\n    return col1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    float t1 = 2.*8.;\n    \n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.xy += iTime/t1/12./2.;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec3 col1 = fractal(uv);\n    fragColor = vec4(col1/2.,1.0);\n}\n", "image_inputs": [], "sound_code": "//remix of https://www.shadertoy.com/view/DddBD4\n\nint collatz(int initial, int steps){\n    //makes some interesting rhythms\n    for(int i = 0; i < steps; i++){\n        if(initial%2==0) initial /= 2;\n        else initial = initial*3+1;\n    }\n    return initial;\n}\nfloat collatz(float initial, float steps){\n    return float(collatz(int(initial),int(steps)));\n}\n\nfloat fibonacci(float nthNumber_) {\n        int nthNumber = int(nthNumber_);\n        int previouspreviousNumber, previousNumber = 0, currentNumber = 1;\n        for (int i = 1; i < nthNumber ; i++) {\n\n            previouspreviousNumber = previousNumber;\n\n            previousNumber = currentNumber;\n\n            currentNumber = previouspreviousNumber + previousNumber;\n\n        }\n        return float(currentNumber);\n}\n\nfloat mod1(float a,float b){\n\n    //a += collatz(a/8./2.,b)*4.;\n    //a += mod(a/8.,2.) - mod(a/8.,3.);\n    \n    return \n        mod(a,b)\n        //mod(a+floor(a/4.),b)\n        //mod(a-mod(a,5.)+mod(a,4.),b)\n        //mod(a+mod(a+mod(-a,3.),5.)+mod(a+mod(-a,5.),3.),b)\n        //mod(a+floor(floor(a/8.)/3.)-floor(floor(a/8.)/2.),b)\n        //mod(a+3.*floor(floor(a)/3.),b)\n    ;\n}\n\nfloat fmod(float a, float b){\n    \n    //a *= (mod(a/8.,3.)-mod(a/8.,2.));\n\n    \n    //a += (mod(a/8.,3.)-mod(a/8.,2.));\n    \n    //a += floor(16.*fractal(vec2(floor(a),floor(a/2.))).y);\n    \n    float\n    t1 = mod1(floor(b/2.),2.),\n    a1 =\n        floor(a/4.+floor(a/4./4.)+t1),\n    a2 = mod1(a1,3.),\n    a3 =\n        //mod(a1,4.+a2)\n        //mod1(a1+a1*sign(1.-t1),4.)\n        mod1(a1,4.)\n    ;\n    \n    return\n        //abs(mod(a1-mod(a1,3.+t1)-mod(a1,4.+t1),b+t1)-t1)\n        //mod(a1-mod(a1,3.+t1)-mod(a1,4.+t1),b)\n        //mod1(a1*sign(1.-t1)-a2-a3,b)\n        //floor(mod(a,b)-mod(a/2.,b)+1.)\n        mod1(a1-a2-a3,b)\n    ;\n}\n\nfloat prime_rhythm(float time){\n    \n    //time += mod(time,5.)-mod(time,3.);\n    //time += mod(time/8.,2.) - mod(time/8.,3.);\n    //time += collatz(time/4.,8.)*2.;\n    \n    return (1.+fmod(time/4.,2.))/(1.+fmod(time/2.,2.));\n}\n\nfloat fmod1(float a, float b){\n    //a += collatz(a,mod(a,b))*2.;\n    \n    //a += collatz(mod(floor(a),4.)+floor(a/8.),4.);\n    \n    //a += ((mod(a/2.,3.)-mod(a/2.,5.)));\n    \n    //a += fibonacci(mod(floor(a),64.));\n    //a -= floor((a)/8./8./2.);\n    //a += prime_rhythm(a);\n    return fmod(a+4.,b);\n}\n\n\n//oud\n//#define fract1(a) (1.-pow(fract(-a),1./(2.-fract(-a))))\n\n//gamelan\n#define fract1(a) (1.-pow(fract(-a),2.))\n\n//#define fract1(a) fract(a)*fract(a)\n\n//#define fract1(a) pow(fract(a),1.+log(2.)-log(1.+fract(a)))\n//#define fract1(a) pow(fract(a),1.+atan(2.)-atan(1.+fract(a)))\n\n//#define fract1(a) log(1.+fract(a)*fract(a))/log(2.)\n\nvec2 synth_(vec2 a1,vec2 a,vec2 a2,vec2 a3,vec2 nb,vec2 a4){\n    return log(a1+a*abs(a2-abs(.5-a3*vec2(fract1(nb.x*.998),fract1(nb.y)))*a4));\n}\n#define synth(a1,a,a2,a3,nb,a4) synth_(vec2(a1),vec2(a),vec2(a2),vec2(a3),vec2(nb),vec2(a4))\n\nvec2 banjo(vec2 a, vec2 nb){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./6.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,6./4.));\n}\n\nvec2 harp(vec2 a, vec2 nb){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,2.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.));\n}\n\nvec2 synth_drum(vec2 a, vec2 nb,float m2){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./m2)\n  + synth(1./8.,a,1./4.,1.,nb*2.,m2/4.));\n}\n\nvec2 oud(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(.5+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      +.5*log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 steel_drum(vec2 a, vec2 nb){\nreturn a/16./4.*abs(synth(1./2.,a,1./8.,1.,nb*4.,1.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.))\n;\n}\n\nvec2 gamelan(vec2 a, vec2 nb){\nreturn\na/16./4.*abs(synth(1./4.,a,1./8.,1.,nb*2.,1./2.)\n  +.5*synth(1./4.,a,1./4.,1.,nb*2.,1./2.)) \n;\n}\n\nvec2 mainSound1(int samp, float time,float scale,float duration){\n  //time += collatz(time,mod(time,8.));\n  \n  //time += mod(time/8.,2.) - mod(time/8.,3.);\n  \n  //time += prime_rhythm(time*8.);\n  float s1 =\n      8.,\n  tempo1 =\n      prime_rhythm(time/16.)*2./prime_rhythm(time/4./16.)*2.\n  ,\n  t = s1*time/4./tempo1,\n  t4 = t/prime_rhythm(time/32.+11.),\n  t1 =\n       fmod(t4,2.)\n       //fmod(t4+fmod(t4/2.,2.),2.)\n  ,\n\n  t5 = t*2./prime_rhythm(time+7.),\n  t3 =\n      (1.+fmod(t5,2.))\n      //(1.+fmod(t5+fmod(t5/2.,2.),2.))\n  ,\n\n  t6 = time*8./t3,\n  m3 =\n      floor(fmod1(t6,s1/2.)/2.),\n  m2 =\n      1. + fmod1(t/t3/2.+mod(floor(time/4.),2.),s1/2.);\n      //1. + fmod1(t/t3/2.+fmod1(time,8.),s1/2.)\n  ;\n  vec2 a=\n      //vec2(log(fract(t/2./prime_rhythm(time+14.))/8.)*log(fract(t/prime_rhythm(time+7.))/8.))\n      //vec2((1.-log(fract(t/2./prime_rhythm(time+14.))/2.))*(1.-log(fract(t/prime_rhythm(time+7.))/4.)))\n      -vec2((log(1./64.+fract1(t/2./prime_rhythm(time+14.))/2./duration)),(log(1./64.+fract1(t/prime_rhythm(time+7.))/4./duration)))\n  ,\n  nb =\n      t*vec2(pow(2.,(m3+m2-t1*4.)/7.+scale),pow(2.,(m3+m2-t1*4.)/7.+scale))*tempo1\n      //vec2(t*pow(2.,(m3+m2-t1*4.*sign(1.-t3))/7.+6.)*tempo1)\n  ;\n  return\n      //log(abs(.5-vec2(fract1(nb.x+.5),fract1(nb.y)))*a)\n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb.x+.5),fract(nb.y)))*a))\n      //abs(log(a*abs(1./4.-abs(.5-vec2(fract1(nb.x+.5),fract1(nb.y*2.))))))\n      \n      //sitar\n      //a/16./2.*abs(log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      //+.5*log(1./4.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*.998/2.),fract1(nb.y/2.)))/2.)))   \n      \n      //banjo\n      //banjo(a,nb)\n      \n      //synth drum\n      //a/16./4.*abs(log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))*2.))\n      //+ log(1./8.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.)))\n\n      //oud\n      oud(a,nb)\n\n      //harp\n      //a/16./4.*abs(\n      //synth(1./4.,a,1./8.,1.,nb*4.,2.)\n      //+ synth(1./8.,a,1./4.,1.,nb*2.,1./2.))\n  ;\n}\n\nvec2 mainSound1(int samp, float time,float scale){\n    return mainSound1(samp,time,scale,1.);\n}\n\nvec2 mainSound(int a,float b){\n    //b += mod(-b,3.)+mod(b,5.);\n    return\n        //sounds like sitar (using oud)\n        //abs(mainSound1(a,b,6.5,1./2.)-mainSound1(a,b,7.5)/2.)\n        \n        //abs(mainSound1(a,b,6.5,1.))\n        \n        abs(mainSound1(a,b*2.,3.25,1./2.)/2.+mainSound1(a,b*2.,5.25,1.)+mainSound1(a,b*2.,7.25,1./2.)/2.)/2.\n        \n        //sqrt(mainSound1(a,b*2.,5.25,1.)*mainSound1(a,b*2.,6.25,1.))\n        \n        //abs(mainSound1(a,b,7.,2.)/4.+mainSound1(a,b,6.,1./2.))\n\n        //abs(mainSound1(a,b*2.,7.)-mainSound1(a,b,6.))\n        //abs(mainSound1(a,b,6.)-mainSound1(a,b,7.)/4.)\n        //(mainSound1(a,b,6.)+mainSound1(a,b/2.,5.))/2.\n    ;\n}\n", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lfs3Wn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 129], [157, 157, 202, 202, 455], [457, 457, 487, 487, 571], [573, 573, 595, 595, 2061], [2063, 2063, 2120, 2120, 2386]], "test": "untested"}
{"id": "XfsGWr", "name": "Langton's ant", "author": "rafa_br34", "description": "Implementation of Langton's ant universal Turing machine.\nFor best results disable the FPS cap by setting layout.frame_rate to 0 in about:config (if you're using Firefox), use --args --disable-frame-rate-limit for Chrome.", "tags": ["automata", "cellular", "ant", "turing", "machine", "langtons"], "likes": 1, "viewed": 83, "published": 3, "date": "1702960008", "time_retrieved": "2024-07-30T17:15:48.312902", "image_code": "void mainImage(out vec4 FragColor, in vec2 FragCoord) {\n    Cell C = ReadCell(READP_V4(C_StateBuffer, uvec2(FragCoord) / 1u));\n    \n    FragColor = vec4(ColorFromState(C.State), 0.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define C_StateBuffer iChannel0\n\n\n// Variable Extensions\n#define URES uvec2(iResolution)\n#define IRES ivec2(iResolution)\n#define FRES vec2(iResolution)\n\n#define UFRAME uint(iFrame)\n#define IFRAME int(iFrame)\n#define FFRAME float(iFrame)\n\n#define TIMESTAMP ((uint(iDate.x) - 1970u) * 31557600u) + (uint(iDate.y) * 2629800u) + (uint(iDate.z - 1.0) * 86400u) + uint(iDate.w)\n\n// Vector utilities\n#define FLATTEN_V2(Width, Vector) ((Width) * (Vector).y + (Vector).x)\n#define EXPAND_V2(Width, Index) (Index) % Width, (Index) / Width\n\n#define UNIQUE_STATE(Vector) (FLATTEN_V2(URES.x, uvec2(Vector)) + (UFRAME * URES.x * URES.y))\n\n#define READP_V4(Buffer, Position) texelFetch(Buffer, ivec2(Position), 0)\n#define READP_F32(Buffer, Position) READP_V4(Buffer, ivec2(Position) / 4)[FLATTEN_V2(2, ivec2(Position)) % 4]\n#define READP_U8(Buffer, Position) READP_F32(Buffer, ivec2(Position) / 4)[FLATTEN_V2(2, ivec2(Position)) % 4]\n\n#define READI_V4(Buffer, Index) READP_V4(Buffer, ivec2(EXPAND_V2(URES.x, uint(Index))))\n#define READI_F32(Buffer, Index) READI_V4(Buffer, uint(Index) / 4u)[uint(Index) % 4u]\n#define READI_U8(Buffer, Index) (uint(READI_F32(Buffer, uint(Index) / 4u)) & (0xFFu << ((Index % 4u) * 8u))) >> ((Index % 4u) * 8u)\n\n#define U8(V) uint(int(V) % 256)\n#define FU8(V) float(U8(V)) / 255.0\n\n#define XOR_SHIFT32(S) S ^= (S << 13); S ^= (S >> 17); S ^= (S << 5);\n\n\nconst int C  =  0;\nconst int R  =  1;\nconst int L  = -1;\nconst int U  = -2;\n\nconst int[] c_StateMachine = int[](\n    R,R,L,L,L,R,L,L,L,R,R,R // Creates a filled triangle shape\n    //L,L,R,R,R,L,R,L,R,L,L,R // Creates a convoluted highway\n    //L,R,R,R,R,R,L,L,R // Fills space in a square around itself\n    //L,L,R,R // Grows symmetrically\n    //R,L,R // Growns chaotically\n    \n    //R,L // Default Langton's ant\n);\nconst uint c_StateCount = uint(c_StateMachine.length());\n\n\n// Get cell color from cell state\nvec3 ColorFromState(in uint State) {\n    XOR_SHIFT32(State); State *= 0x9E3779B9u;\n    \n    return vec3(\n        FU8((State >> 16) & 0xFFu),\n        FU8((State >> 8) & 0xFFu),\n        FU8((State >> 0) & 0xFFu)\n    );\n}\n\n\n\n\nstruct Cell {\n    uint State;\n    \n    // Stored in a 8-bit value\n    int Direction;\n    bool Moving;\n};\n\n\nCell ReadCell(in vec4 Input) {\n    Cell N;\n    \n    N.State = (uint(Input.x) & 0xFFFF00u) >> 8; // I doubt anyone would ever build a langton ant with 65535 states but you can never know\n    \n    uint Flags = (uint(Input.x) & 0x0000FFu);\n    N.Direction = int(Flags & 3u);\n    N.Moving = ((Flags >> 3) & 1u) > 0u;\n    \n    return N;\n}\n\n\nvec4 WriteCell(in Cell Input) {\n    return vec4(\n        float(\n        ((Input.State % c_StateCount) << 8) |\n        (uint(Input.Moving) << 3) | uint(Input.Direction % 4)),\n        0.0, 0.0, 0.0\n    );\n}\n\n\n\n//   0 \n// 3   1\n//   2 \nvoid ComputeCell(inout Cell C, in Cell[4] Neighbors) {\n    if (C.Moving) { C.Moving = false; C.State = (C.State + 1u) % c_StateCount; }\n    \n    \n    for (uint i = 0u; i < 4u; i++) {\n        Cell N = Neighbors[i];\n        // int[](2, 3, 0, 1)\n        // int[](1, 0, 3, 2)\n        if (N.Moving && N.Direction == int[](2, 3, 0, 1)[i]) { //int[](0, 1, 2, 3)\n            C.Direction = (N.Direction + c_StateMachine[C.State] + 4) % 4;\n            C.Moving = true;\n            break;\n        }\n    }\n    \n    \n}", "buffer_a_code": "\nvoid mainImage(out vec4 FragColor, in vec2 FragCoord) {\n    #define N(X, Y) ReadCell(READP_V4(C_StateBuffer, ivec2(FragCoord) + ivec2(X, Y)))\n    Cell C = N(0, 0);\n    \n    ComputeCell(\n        C,\n        Cell[](N(0, 1), N(1, 0), N(0, -1), N(-1, 0))\n    );\n    \n    uvec2 F = uvec2(FragCoord);\n    if (iFrame == 0 && F.x == URES.x / 2u && F.y == URES.y / 2u) {\n        C.Moving = true;\n        C.Direction = 0;\n    }\n\n    FragColor = WriteCell(C);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XfsGWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 185]], "test": "untested"}
{"id": "4csGWr", "name": "A concept for starmap", "author": "Cewein", "description": "A star map, sort of a proof of concept as it can be improved in many ways.", "tags": ["procedural", "2d", "sun", "star", "sky", "map", "ellipse", "quadtree", "milkyway", "gaz", "nigthsky"], "likes": 16, "viewed": 777, "published": 3, "date": "1702950471", "time_retrieved": "2024-07-30T17:15:49.095808", "image_code": "// Shader made by Maximilien \"Cewein\", december 2023\n//\n// This is a 2D star field, this use a probabilistic quad tree [1]\n// to make the star, the version it was based on was nice but still very\n// bloated, therefore was cleaned here. Use fractal brownian motion [2] from\n// perlin noise [3] to generate the \"space dust\". star brigthness is a poor's man\n// black body radiation approximation [4][5]\n//\n//\n// Possible improvement :\n// \t\t- Anti-Aliasing (but heave on perf)\n//\t\t- in the quadtree perform neighbour check\n//      - better control of the star size, color, brigthness and blinking periode\n//      - better control for the gaz clouds\n//\n// sources : \n// [1]: https://ciphrd.com/2020/04/02/building-a-quadtree-filter-in-glsl-using-a-probabilistic-approach/\n// [2]: https://www.esaim-proc.org/articles/proc/pdf/1998/03/proc-Vol5.7.pdf\n// [3]: https://mrl.cs.nyu.edu/~perlin/paper445.pdf\n// [4]: https://www.atnf.csiro.au/outreach//education/senior/cosmicengine/stars_colour.html\n// [5]: https://en.wikipedia.org/wiki/Planck%27s_law\n\n// Constants for quadtree division and iteration counts\n#define MIN_DIVISIONS 10.0\n#define MAX_ITERATIONS 4\n#define SAMPLES_PER_ITERATION 5\n\n// Function to calculate color variation for a quad division in space\n// Computes the average and variance of color components from random samples\nfloat colorVariation(in vec2 center, in float size, vec2 a, vec2 b) \n{\n    vec3 avg = vec3(0);\n    vec3 var = vec3(0);\n\n    // Sampling for color calculation\n    for (int i = 0; i < SAMPLES_PER_ITERATION; i++) {\n        vec2 r = hash22(center.xy + vec2(float(i))) - 0.5;\n        float d = -sdEllipse(center + r * size, a, b);\n        d = smoothstep(-.3, 2.0, d);\n        vec3 sp = vec3(d);\n        avg += sp;\n        var += sp * sp;\n    }\n    \n    // Calculate average and variance\n    avg /= float(SAMPLES_PER_ITERATION);\n    var = var / float(SAMPLES_PER_ITERATION) - avg * avg;\n    \n    return dot(var, vec3(1.0, 1.0, 1.0)) / 3.0;\n}\n\n// Main function for rendering\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;;\n    \n    // Threshold for quad variance\n    float threshold = 1.5e-5;  \n\n    // Number of space divisions\n    float divs = MIN_DIVISIONS;\n\n    // Initialize ellipses parameters\n    vec2 a = vec2(sin(2.5) * 0.1 + 0.5, 0);\n    vec2 b = vec2(0, sin(1.5) * 0.1 + 0.5);\n\n    for (int i = 0; i < MAX_ITERATIONS; i++) \n    {\n    \n        //probabilistic quadtree information\n        // Center of the active quad and length of a side of the active quad\n        vec2 quadCenter = (floor(uv * divs) + 0.5) / divs;\n        float quadSize = 1.0 / divs;\n        \n        // Calculate color variation \n        float quadAvgVar = colorVariation(quadCenter, quadSize, a * rot(0.5) * 2.2, b * rot(0.75) * 0.05);\n        \n        // Check if variance is below threshold\n        if (quadAvgVar < threshold) break;\n        \n        // Divide the space again\n        divs *= 2.0;\n    }\n    \n    // Coordinates inside the quad\n    vec2 nUv = fract(uv * divs);\n    vec2 id = floor(uv * divs);\n    \n    // Random position and color\n    vec2 randPos = hash22(id);\n    vec3 col = hash32(id);\n    float randNum = hash12(id);\n    \n    //distance to the \"star\"\n    float d = 1.0 - smoothstep(distance(randPos, nUv), 0.0001 * divs, 0.002 * divs);\n    vec4 color = vec4(d);\n\n    // Perform blinking effect between two colors\n    // and fake black body radiation\n    // the blinking is slow and just for a pure \"artistic\" vision\n    // and the brigthness as a poorman's version of the Planck's law\n    float blinkFactor = clamp(sin(100.0 * cos(randNum) + .50 * iTime * randNum),0.,1.0);\n    float brigthness = smoothstep(0.1, 1.0, randNum * 0.7 + 0.3);\n    \n    //brigth star are \"white blue\" and dim stars are \"fire orange\"\n    vec4 brightColor = vec4(0.859, 0.914, 0.957,1.0); // White-blue color\n    vec4 dimColor = vec4(0.70, 0.27, 0.0,1.0); // Fire orange color\n    vec4 blendedColor = mix(dimColor, brightColor,randNum);\n    color *= brigthness * blinkFactor * blendedColor; \n    \n    // Apply ellipses with different parameters and update color each time\n    color = applyEllipse(uv, a, b, vec2(2.2, 0.5), vec2(0.25, 0.75), vec3(2.0, 0.9, 0.7), color, 0.75, vec4(1.0, 0.4, 0.6, 1.0));\n    color = applyEllipse(uv, a, b, vec2(0.75, 0.5), vec2(0.5, 0.65), vec3(2.5, 0.8, 0.7), color, 0.5, vec4(1.0, 0.8, 0.4, 1.0));\n    color = applyEllipse(uv, a, b, vec2(2.25, 0.5), vec2(0.75, 0.75), vec3(1.0, 0.7, 0.6), color, 0.1, vec4(.0, 0.2, 0.9, 1.0));\n    \n    // Create lines from the UV coordinates\n    vec2 lWidth = vec2(1.0 / iResolution.x, 1.0 / iResolution.y);\n    vec2 uvAbs = abs(nUv - 0.5);\n    float s = step(0.5 - uvAbs.x, lWidth.x * divs) + step(0.5 - uvAbs.y, lWidth.y * divs);\n    \n    // Output to screen\n    fragColor = color;\n}\n", "image_inputs": [], "common_code": "//A define to create a 2D rotation matrix based on an angle.\n//The angle must be in radian\n#define rot(t) mat2(cos(t), -sin(t), sin(t), cos(t))\n\n///// SDF FUNCTION - MOSTLY 2D /////\n\n// for visualization purposes only\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\n// Function to compute the signed distance from a 2D point 'p' to an ellipse defined by two radii 'a' and 'b'\n// The function utilizes Newton's method for root finding to determine the distance\n// See https://www.shadertoy.com/view/4sS3zz for more details on this method\nfloat sdEllipse(vec2 p, vec2 a, vec2 b) \n{\n    // Perform transformations and calculate the minor/major radii\n    float la = length(a);\n    float lb = length(b);\n    p *= mat2(a / la, b / lb);\n    vec2 ab = vec2(la, lb);\n    \n    // Code beyond this point by Inigo Quilez (iq)\n    \n    // Ensure symmetry\n    p = abs(p);\n\n    // Find root with Newton's solver\n    vec2 q = ab * (p - ab);\n    float w = (q.x < q.y) ? 1.570796327 : 0.0;\n    for (int i = 0; i < 4; i++) {\n        vec2 cs = vec2(cos(w), sin(w));\n        vec2 u = ab * vec2(cs.x, cs.y);\n        vec2 v = ab * vec2(-cs.y, cs.x);\n        w = w + dot(p - u, v) / (dot(p - u, u) + dot(v, v));\n    }\n    \n    // Compute final point and distance\n    float d = length(p - ab * vec2(cos(w), sin(w)));\n    \n    // Return signed distance\n    return (dot(p / ab, p / ab) > 1.0) ? d : -d;\n}\n\n///// RANDOMNESS - PART ONE: HASH /////\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n/// 2 out, 2 in... made for perlin noise and use a sinusoid\n/// work well with small value or hit floating point precision error\nvec2 hashNoise22(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n///// RANDOMNESS - PART TWO: PERLIN NOISE AND FRACTAL BROWNIAN MOTION /////\n\n// From https://www.shadertoy.com/view/4tdSWr\n// Function to generate Perlin noise at a 2D coordinate 'p' using Perlin's algorithm\n// The noise function produces smooth, continuous noise values based on the input coordinate\nfloat noise(in vec2 p) \n{\n    // Constants used in the Perlin noise calculation\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n    vec2 i = floor(p + (p.x + p.y) * K1);\n    vec2 a = p - i + (i.x + i.y) * K2;\n    vec2 o = (a.x > a.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0 * K2;\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    vec3 n = h * h * h * h * vec3(dot(a, hashNoise22(i + 0.0)), dot(b, hashNoise22(i + o)), dot(c, hashNoise22(i + 1.0)));\n    return dot(n, vec3(70.0));\n}\n\n// Function to generate fractal Brownian motion (FBM) using Perlin noise from a point \"n\"\n// with the two parametre (I.E : lacunarity and Persistance )\nfloat fbm(vec2 n, float amplitude, float resiliation) \n{\n    // Initialize the total value to accumulate noise\n    float total = 0.0; \n    \n    // Define a transformation matrix 'm', it provide rotation and scaling to avoid repetion\n    // without this matrix the fbm will stack every octave on top of on and each other and become uniform\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n\n    // Iterate through multiple octaves to compute the final noise value\n    for (int i = 0; i < 7; i++) {\n        // Accumulate noise values with varying amplitudes\n        total += (0.1 + noise(n)) * amplitude;\n        \n        // Apply the transformation matrix 'm' to 'n' for the next octave\n        n = m * n;\n        \n        // Decrease the amplitude for the next octave\n        amplitude *= resiliation;\n    }\n    \n    // Return the absolute accumulated noise value\n    return abs(total);\n}\n\n\n/* Function to calculate the distance to an elliptical shape and perform color blending at a given UV coordinate\nParameter explanantion :\nvec2 uv,           // 2D coordinates of the point on the surface\nvec2 a,            // First axis of the ellipse\nvec2 b,            // Second axis of the ellipse\nvec2 factorA,      // Factors to modify the first axis: [scale, rotation]\nvec2 factorB,      // Factors to modify the second axis: [scale, rotation]\nvec3 fbmParam,     // Parameters for the fractal Brownian motion (scale, octaves, persistence)\nvec4 color,        // Original color to be mixed\nfloat intensity,   // Mixing factor\nvec4 gazColor      // Color for blending\n*/\nvec4 applyEllipse(vec2 uv, vec2 a, vec2 b, vec2 factorA, vec2 factorB, vec3 fbmParam, vec4 color, float intensity, vec4 gazColor) \n{\n    // Compute the distance from the current UV to the ellipse\n    float d = -sdEllipse(uv, a * rot(factorA.y) * factorA.x, b * rot(factorB.y) * factorB.x);\n    \n    // smooth out the distance from the ellipse and clamp it between 0. and 1.\n    d = smoothstep(-0.1, 0.4, d);\n    \n    // use d as a mask for the fractal Brownian motion and blend the two color with the value given from the mask * fbm\n    color = mix(color, gazColor, intensity * d * fbm(uv * fbmParam.x, fbmParam.y, fbmParam.z));\n    \n    // Return the modified color\n    return color;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4csGWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1183, 1330, 1400, 1400, 1965], [1967, 1998, 2054, 2104, 4882]], "test": "untested"}
{"id": "4cl3Wn", "name": "GLSL Matrix construction", "author": "jakel101", "description": "Definition: https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Matrix_constructors\nHowever it is possible (and often done on shadertoy) to construct a mat2 form a vec4.\nIt's not possible to construct a mat2 from a single vec2 on shadertoy?", "tags": ["test", "error"], "likes": 0, "viewed": 169, "published": 3, "date": "1702942180", "time_retrieved": "2024-07-30T17:15:49.861760", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // \"identity\" matrix\n    mat2 a = mat2(0.1);\n    \n    // from vec2: 1 does not work, 2 works\n    // mat2 b1 = mat2(vec2(0.2));\n    mat2 b2 = mat2(vec2(0.2), vec2(0.2));\n    \n    // with two floats\n    mat2 c = mat2(0.3, 0.3, 0.3, 0.3);\n    \n    // with a vec4\n    mat2 d = mat2(vec4(0.4));\n    \n    // some mixture of vec2 and float: e1 and e2 aren't enough components, e3-e5 work\n    // mat2 e1 = mat2(vec2(0.5), 0.5);\n    // mat2 e2 = mat2(0.5, vec2(0.5));\n    mat2 e3 = mat2(vec2(0.5), 0.5, 0.5);\n    mat2 e4 = mat2(0.5, vec2(0.5), 0.5);\n    mat2 e5 = mat2(0.5, 0.5, vec2(0.5));\n    mat2 e6 = mat2(0.5, 0.5, 0.5, vec2(0.5));\n    \n    vec4 col = vec4(a+b2+c+e3+e4+e5+e6);\n    // Output to screen\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4cl3Wn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 82, 788]], "test": "untested"}
{"id": "Mcf3Dr", "name": "Harmonic Sinusoidal Arcs 2", "author": "FabriceNeyret2", "description": "I did a thing to what spalmer's did of Fabrice's toy", "tags": ["2d", "2tweets", "short", "golf"], "likes": 28, "viewed": 337, "published": 3, "date": "1702941959", "time_retrieved": "2024-07-30T17:15:50.634694", "image_code": "// respin of spalmer https://www.shadertoy.com/view/XcfGDr\n// respin of FabriceNeyret2 http://shadertoy.com/view/XfX3Dn\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy,\n         U = 1.2 * (u + u - R) / R.y;\n    O *= 0.;\n    for (float i; i++ < 9.; )\n        O = max(O, smoothstep(5./R.y*i, 0., \n                       abs(length(  vec2(\n                               mod( iTime + U.x*i + sign(U.y) , 4.) - 2.\n                             , U.y*i\n                                  )     )\n                        - 1.\n                          )   ) \n                  / pow(1.2, i)\n                );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mcf3Dr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 157, 157, 621]], "test": "untested"}
{"id": "XfX3Dn", "name": "harmonic waves", "author": "FabriceNeyret2", "description": "reference: https://www.facebook.com/CymaticUniverse/posts/741183981377178", "tags": ["2d", "2tweets", "short", "yinyang", "reproduction"], "likes": 16, "viewed": 371, "published": 3, "date": "1702934294", "time_retrieved": "2024-07-30T17:15:51.407627", "image_code": "/**/ // see golfed version below.\n\n\n//#define S(v) smoothstep( 1.5, 0., abs(v)/fwidth(v) )\n#define S(P) smoothstep( 5./R.y*i, 0., abs( length(P) - 1. ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 1.2*( u+u - R ) / R.y, V;\n         \n    float i=1., v=i;   \n    \n    O = vec4( S(U) );                                // circle\n    if ( length(U) < 1. )                           // inside only\n        for( ; i++ < 9.;  v /= 1.2 )                 // foreach harmonic\n            V = U*i, \n            V.x = mod( V.x + i + sign(V.y), 4.) - 2.,// arc center\n            O = max(O, S(V)*v ) ;                    // draw arc, grey=v\n}\n\n\n\n\n/**   // -2Â by Observer, -4 by SnoopethDuckDuck, -10 by Fab\n\n#define S(P) ( 1.- R.y/5./i * abs( length(P) - 1. ) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,V;    \n    float i, v=++i;   \n    O = S(U = 1.2*(U+U-R)/R.y) + 0.*O;  // circle\n    if ( dot(U,U) < i )                              // inside only\n        for( ; i++ < 9.;  v /= 1.2 )                 // foreach harmonic\n            V = U*i, \n            V.x = mod( V.x + i + sign(V.y), 4.) - 2.,// arc center\n            O = max(O, S(V)*v ) ;                    // draw arc, grey=v\n}\n\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XfX3Dn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 193, 193, 667]], "test": "untested"}
{"id": "4cf3Wn", "name": "iFrameRate test", "author": "jakel101", "description": "really simple shader to test iFrameRate functionality for matching it's behaviour. seems to be updated like ~2 times per second? definitely not every frame.", "tags": ["test"], "likes": 0, "viewed": 132, "published": 3, "date": "1702928031", "time_retrieved": "2024-07-30T17:15:52.170587", "image_code": "// see https://www.shadertoy.com/view/lsKGWV for a possible explanation\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    // 1.0/iTimeDelta at the top\n    col += (float((1.0/iTimeDelta) / 255.0 >= uv.x) * float(uv.y>=0.5));\n    // iFrameRate at the bottom\n    col += float(iFrameRate/ 255.0 >= uv.x) * float(uv.y<=0.5);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4cf3Wn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "XclGR7", "name": "SDF Bump Mapping", "author": "rubioh", "description": "2D Square SDF bump mapped", "tags": ["2d", "sdf", "bumpmapping"], "likes": 10, "viewed": 249, "published": 3, "date": "1702914426", "time_retrieved": "2024-07-30T17:15:53.070182", "image_code": "#define R iResolution\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/R.xy;\n    \n    // Anti Aliasing\n    vec3 res = texture(iChannel0, uv).rgb;\n    vec3 dX = texture(iChannel0, uv+ vec2(1.,.0)/R.x).rgb;\n    vec3 dY = texture(iChannel0, uv+ vec2(.0,1.)/R.y).rgb;\n\n    vec3 col = res+dX+dY;\n    col /= 3.;\n    fragColor = vec4(col, .0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 hash22(vec2 p){\n    return fract(  sin( vec2(\n                            dot(p,vec2(178.357, 37.456)),\n                            dot(p,vec2(54.678, 87.3965)))) * vec2(36.5657, 25.689));\n}\nfloat hash(float d){\n    return fract(sin(d*21.45879)*14564.57);\n}\nfloat noise1(float p){\n    float idx = floor(p);\n    float f = fract(p);\n    \n    f = f*f*3.-2.*f*f*f;\n\n    float h0 = hash(idx);\n    float h1 = hash(idx+1.);\n    \n    return mix(h0, h1, f);\n}\nfloat noise(vec2 p){\n    vec2 idx = floor(p);\n    vec2 f = fract(p);\n    \n    f = f*f*3.-2.*f*f*f;\n\n    float h00 = hash22(idx).x;\n    float h01 = hash22(idx+vec2(0.,1.)).x;\n    float h10 = hash22(idx+vec2(1.,0.)).x;\n    float h11 = hash22(idx+vec2(1.,1.)).x;\n    \n    return mix(\n                mix(h00, h01, f.y),\n                mix(h10, h11, f.y),\n            f.x);\n}\nfloat PeriodicNoise(float t, vec2 seed){\n    t = t*3.14159;\n    return noise(vec2(cos(t), sin(t)) + seed);\n\n}", "buffer_a_code": "float sdBox( in vec2 p, float r, float t)\n{\n    float M = 6. + 4.*cos(iTime*.05 + t*2.*3.14);\n    return pow(pow(abs(p.x), M) + pow(abs(p.y), M), 1./M) - r-.1;\n}\n\nfloat smoothmin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\nfloat map(vec2 uv){\n    float id = 2.*(hash(-1.)-.5);\n    float PN = PeriodicNoise(iTime*(hash(id)-.5)*2., vec2(id, id)+150.);\n    vec2 pB = vec2(PeriodicNoise(iTime*id*.1, vec2(id, id)), PeriodicNoise(iTime*id*.1 + 17., vec2(id, id)))*3.*(PN-.5)*2.;\n    float a = iTime*.2;\n    mat2 rB = mat2(cos(a), sin(a), -sin(a), cos(a));\n    float d = sdBox(uv*rB - pB, .5, id);\n\n    for (float i=0.; i<15.; i++){\n        id = 2.*(hash(id)-.5);\n        PN = PeriodicNoise(iTime*(hash(id)-.5)*.1, vec2(id, id)+150.);\n        pB = vec2(PeriodicNoise(iTime*id*.01, vec2(id, id)), PeriodicNoise(iTime*id*.1 + 17., vec2(id, id)))*7.*(PN-.5)*4.;\n        a = iTime*.1*(exp(id))*id;\n        rB = mat2(cos(a), sin(a), -sin(a), cos(a));\n        d = smoothmin(d, sdBox(1.5*uv*rB - pB, .5*(.5+.5*sin(id*iTime*.5 + id + iTime*.5)), id), .2);\n    }\n\n    return d;\n}\n\nfloat smooth_floor(float x){\n    float m = fract(x);\n    return floor(x) + (pow(m, 20.) - pow(1.-m, 20.) )/2.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float d = map(uv*7.);\n    float X = 3. + 2.*cos(iTime * .17);\n    float idx =  floor(d*X);\n    if (d<.0){ d = .0; idx=-1.;}\n    float smth_idx = smooth_floor(d*X+4.);\n    float coord = fract(d*X);\n    fragColor = vec4(d, idx+1., coord, smth_idx);\n}", "buffer_a_inputs": [], "buffer_b_code": "#define T(p) pow(texture(iChannel0, p).a, 2.)\n#define R iResolution\n\nvec3 palette(float t){\n    vec3 a = vec3(0.204,0.396,0.643);\n    vec3 b = vec3(0.361,0.208,0.400);\n    vec3 c = vec3(1., 1., 1.);\n    vec3 d = vec3(0.306,0.604,0.024)*.1;\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 calcNormal(vec2 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0001; // epsilon\n    float orig = T(p);\n    return normalize(\n      vec3( T(p - vec2(.5,.0)/iResolution.x) - T(p + vec2(.5,.0)/iResolution.x),\n             T(p - vec2(.0,.5)/iResolution.y) - T(p + vec2(0.,.5)/iResolution.y),\n            1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 info = texture(iChannel0, uv).rgb;\n    float d = info.x, idx = info.y, coord = info.z;\n  \n    vec3 col = palette(hash(idx)*10. + iTime * .1)*(.4+.6*pow(noise1(cos(idx*1.-.3*iTime)+iTime*.1), 4.))*4.;\n\n    // Bump Mapping\n    vec3 sn = calcNormal(uv); // Surface normal\n    vec3 sp = vec3(uv, idx); // Surface position.\n    vec3 rd = normalize(vec3(uv-.5, 1.)); // Direction vector from the origin to the screen plane.\n    vec3 lp = vec3(-.5,-.5, -1.); // Light position\n \tvec3 ld = lp - sp; // Light direction\n\tfloat lDist = max(length(ld), 0.001);\n\tld /= lDist;  \n    float atten = 1./(1.0 + lDist*lDist*0.2);\n\n\tfloat diff = max(dot(-sn, ld), 0.); \n    vec3 ldf = vec3(-ld.xy, ld.z);\n    float fresnel = pow( 1.+ dot(sn, ldf), 5. );\n    \n    col = atten*col*vec3(diff+fresnel);\n    fragColor = vec4(vec3(col), .0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XclGR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 79, 371]], "test": "untested"}
{"id": "Xfs3z7", "name": "mode#2 membrane emission", "author": "FabriceNeyret2", "description": "( WIP: am I doing this right ?Â )\nshow the intensity field of the emission of an oscillating  membrane with 2 phase-opposed lobes.\n( 2D slice of the 3D field ).\nmouse controls the membrane radius.", "tags": ["dipolar"], "likes": 5, "viewed": 161, "published": 3, "date": "1702906920", "time_retrieved": "2024-07-30T17:15:53.870043", "image_code": "// continuous 2-lobes membrane variant of \"+- dipolar emission\" https://shadertoy.com/view/Xcl3z7\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2   R = iResolution.xy,\n           P = ( 2.*u - R ) / R.y;              // normalized coordinates\n    float  f = 10., \n           a = iMouse.z > 0.                    // distance between emitters\n                 ? .3*iMouse.x/R.x              //     mouse control\n                 : .15+.15*cos(iTime),          //     demo mode\n           t = 10.*iTime,\n           I = 0.;\n           \n   for( float k=-1.; k < 1.; k += .01 ) {         \n        float d  = length( P - vec2(k*a,0) );   // distance from P to emitter sample          \n        I +=  sin( 6.28*f*d - t ) / (d*d)       // wave\n            * sin( 3.14*k);                     // amplitude amplitude along the emitting segment\n    }     \n    O = I/100. * .2* vec4(-1,1,0,0);            // coloring ( red: negative green: positive ) \n   // O *= O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xfs3z7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 138, 138, 954]], "test": "untested"}
{"id": "Xcl3z7", "name": "+- dipolar emission", "author": "FabriceNeyret2", "description": "show the intensity field of a dipolar emission of  phase-opposed emitters.\n( 2D slice of the 3D field ).\nmouse controls distance between the emitters.", "tags": ["dipolar"], "likes": 9, "viewed": 221, "published": 3, "date": "1702905511", "time_retrieved": "2024-07-30T17:15:54.641979", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2   R = iResolution.xy,\n           P = ( 2.*u - R ) / R.y;            // normalized coordinates\n    float  f = 10., \n           a = iMouse.z > 0.                  // distance between emitters\n                 ? .3*iMouse.x/R.x            //     mouse control\n                 : .15+.15*cos(iTime),        //     demo mode\n           t = 10.*iTime,\n          d1 = length( P - vec2(a,0) ),       // distance from P to right emitter\n          d2 = length( P + vec2(a,0) );       // distance from P to left emitter\n    O = (  sin( 6.28*f*d1 - t ) / (d1*d1)     // right wave\n         - sin( 6.28*f*d2 - t ) / (d2*d2)     // left wave\n         )\n        * .2* vec4(-1,1,0,0);                 // coloring ( red: negative green: positive ) \n   // O *= O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xcl3z7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 795]], "test": "untested"}
{"id": "lfsGR4", "name": "Creepy roots", "author": "rcargou", "description": "Not as pretty as I wanted to, maybe because of the realistic feeling, but still a bit creept at least", "tags": ["sdf", "roots"], "likes": 6, "viewed": 133, "published": 3, "date": "1702897459", "time_retrieved": "2024-07-30T17:15:55.597425", "image_code": "#define AA 1   // make this 2 or 3 for antialiasing\n#define ROT mat3(cos(.7), 0., sin(.7), 0., 1., 0., -sin(.7), 0., cos(.7))\n#define ROT2 ROT*mat3(1., 0., 0., 0., cos(7.), sin(.7), 0., -sin(.7), cos(.7))\n#define ROT3 ROT2*mat3(cos(.7), sin(.7), 0., -sin(.7), cos(.7), 0., 0., 0., 1.)\n\nvec3 getcol2(float i) {\n//return vec3(0.573,0.135,0.663)/2.;\n\nreturn vec3(.5, .75, .4) * 1.;\nreturn 1.*pal( i, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n}\nvec3 getcol(float i) {\n//return vec3(0.573,0.135,0.663)/2.;\n\nreturn vec3(.2, .75, .8) * 1.;\nreturn 1.*pal( i, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n}\nfloat gyronoise(vec3 p){\n    return abs(dot(cos(p), sin(p.zxy)));\n}\n\nfloat ls() {\n//return .6;\nfloat a = .5 + cos(iTime) * .5;\nreturn a; \n}\nfloat ls2() {\nreturn 1.;\n    return 1.-ls();\n}\n\nfloat mat = 0.;\nfloat fbm(vec3 p){\n\n    float A = 1.;\n    float n = 0.;\n    float k = .6;\n    float f = 1.;\n    \n    // Nimitz gyroid noise: https://www.shadertoy.com/view/3l23Rh\n    for (int i=0; i<5; i++){\n        p += .1*sin(p.xzy*.75*f+iTime/4.);\n        n += gyronoise(p)*A-k; \n        A *= .7;\n        p *= 1.95*ROT3;\n        k -= .15;\n        f *= 3.;\n    }\n    return n*1.2;\n}\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\nfloat oui = 0.;\nfloat oui2 = 0.;\nfloat mapLight2(in vec3 p, out float mat, bool ll) {\n    vec3 pc = p;\n    pc.z+=iTime * 10.;\n    pc.z = mod(pc.z, 8.) - 4.;\n    //pc.xy *= rotate2d(.5 + iTime);\n    pc.y -=2.;\n    pc.x = abs(pc.x);\n     pc.x -=4.;\n     \n/*\n    pc = abs(pc);\n    pc.y+=1.;\n    pc = abs(pc);\n    pc.x+=1.;\n    pc.xy *= rotate2d(1.);\n    */\n   // pc = abs(pc);\n    \n    //pc.y*=2.;\n    //pc.x-=2.;\n    // pc.z /=4.5;\n    float sd = length(pc.xy) - .1;\n    float ss2 = length(pc) - .1;// * (ls2());\n    mat = 4.;\n    if (sd < ss2) {\n        mat = 3.;\n    }\n    if (ll)\n        return ss2;\n    return min( ss2, ss2);\n}\n\nfloat mapPillars(in vec3 p, out float mat, out float ll) {\n\n    vec3 pc = p;\n    float h = -.1;\n    float r = 5.;\n    float tt = hash(floor(p.x/5.) * 5.);\n  \n    p.x=mod(p.x, 5.) - 2.5;\n//    p.y+=cos(iTime);\n    float id = hash(floor(p.z/r) * r);\n    id += tt * 3.14;\n    ll = .5+sin(iTime + id * 3.14) * .5;\n //     p.xy *=rotate2d(iTime + id * 3.14);\n  \n    //p.z+=iTime * 2.;\n//    p.y = mod(p.x, 5.)-2.5;\n    oui = id;\n    p.z = mod(p.z, r) - r/2.;\n\n    //p.y += 2.5;\n   // p.y = mod(p.y, 5.) - 2.5;\n  //  p.x = abs(p.x);\n    \n//    p.x -= 2. + sin(id);\n  \n    p.y+=.94;\n\n    float sd = sdCylinder(p + vec3(.0, 1.2+ h, .0), vec2(.01, 1.1));\n    //p.y+=texture(iChannel0, p.xz / 20.).x / 6.;\n    float ss =length(p + vec3(.0, h, .0)) - .6  * ll;\n    mat = 4.;\n    if (sd < ss) {\n    //    mat = 5.;\n    }\n\n    pc.z = mod(pc.z, 8.) - 4.;\n    pc = abs(pc);\n    pc.xy *= rotate2d(.5);\n    pc = abs(pc);\n    pc.x+=1.;\n    pc.xy *= rotate2d(.5);\n   // pc = abs(pc);\n    \n    //pc.y*=2.;\n    pc.y -=4.;\n    //pc.x-=2.;\n    // pc.z /=4.5;\n    float ss2 = length(pc) - .5 * (ll);\n    return min(ss, ss);\n}\n\n\n\nfloat mapRings(in vec3 p) {\n     float r = 4.;\n     p/=2.;\n     float id = hash(floor(p.z / r) * r) * 2.;\n     vec3 p3 = p;\n     p3.x = abs(-p3.x);\n     p3.x += cos(p3.z / 2.) * 1.;\n     p3.x -= 2.;\n     p3.z = mod(p3.z, 20.)-10.;\n     p3.z /=4.5;\n     p.x += id / 2.;\n      p.y+= cos(p.z  * 11. + id * 23.) / 12.;\n    p.z+=iTime / 5.;\n     p.z = mod(p.z, r) - r/2.;\n     p.xz *=rotate2d(id / 15.);\n     vec3 p2 = p;\n     p2.x+=.5;\n     p2.x = mod(p2.x, 5.) - 2.5;\n     p2.y += 2.7;\n     p2.xz *= rotate2d(.4);\n  \n    float t1 = sdTorus(p.xzy, vec2(id/2.+1.5, .25+id / 20.));\n     float t2 = sdTorus(p2.xzy + vec3(.0, .0,.0), vec2(2.9 + id /4., .1));\n     float t3 = sdTorus(p3.yxz, vec2(2., .3));\n     float a = atan(p.y, p.x);\n     float off = 0.;\n     //off += sin(id-iTime*2.)*sin(a*20. + iTime * 5. * (1.+id)) / 20.;\n      off +=texture(iChannel0, .1*vec2(a, length(p.xy) )).r / 10.;\n     t1 += off;\n     t2 += off / 2.;// + b / 2.;\n    // p.y -= 1.;\n     p.y += 1.5;\n//     p.x-=.01;\n     float c =length(p) - .5;// sdCone(.5*p * vec3(-1., -1, 1.), vec3(.1, .1, .5));\n     //return min(t1, c);\n      return sminP(sminP(t1,t2),t3);\n}\nvec3 rmLight(vec3 ro, vec3 rd, float d, float m) {\n    float mat = 0.;\n    float t = 0.;\n    vec3 col = vec3(.0);\n    if (m > 3.)\n    return vec3(0.);\n    float ll;\n    for (int i = 0; i < 42; ++i) {\n        vec3 p = ro + rd * t;\n        float s = mapPillars(p, mat, ll);\n        float s2 = mapLight2(p, mat, true);\n        float a = 1.-step(1., s);\n        float l = length(ro - p);\n        if (t < d) {\n            col += ll * vec3(6./(s*s*s*s+.1) * .002)*getcol(oui);\n            col += ls2() * vec3(6./(s2*s2*s2*s2+.1) * .002)*getcol2(oui2);\n        }\n        t += .5;\n    }\n    return col;\n}\nfloat mapStructure(in vec3 p) {\n\n    float r= 1.;\n    float s = 1./2.;\n    p.y += 1.;\n    vec2 mp = mod(p.xz, r) - r/2.;\n    vec2 m_id = floor(p.xz / r) * r;\n    float h = hash22(m_id).x * .0;\n    \n    vec3 mp3 = vec3(mp.x, p.y, mp.y);\n    vec2 corners[4] = vec2[]( vec2(-.5, -.5), vec2(.5,-.5), vec2(-.5,.5), vec2(.5,.5) );\n    \n    for (int i = 0; i < 4; ++i) {\n    \n    }\n    h += texture(iChannel0, p.xz / 100.).r * 4.;\n    h += texture(iChannel0, p.xz / 20.).r / 2.;\n    float b1 = sdRoundBox(mp3, vec3(s, h/ 10. + .1, s), 0.);\n    float b2 = sdRoundBox(mp3 + vec3(0., h/10. + .1, 0.), vec3(s/1.5, 2.53, s/1.5), 0.);\n    return p.y - h / 10. - .1;\n    return min(b1, p.y -.2);\n}\n\nvec2 map( in vec3 pos )\n{\n    pos.y += .5;\n\n   // pos.xz = abs(pos.xz);\n    vec2 res = vec2( 1e10, 0.0 );\n    float d = 1e10;\n    float mat;\n   pos.y += sin(pos.z/2.) * .2;\n    if ((res.x = mapStructure(pos)) < .0f)\n        res.y = 1.0f;\n    /*if ( (d = mapRings(pos) ) < res.x) {\n        res.x = d;\n        res.y = 2.;\n    }*/\n    d = mapRings(pos);\n    res.x = sminP(res.x, d);\n    if ( ( d = pos.y + .75 ) < res.x)\n    {\n     //   res.x = d;\n        res.y = 3.;\n    }\n    float ll;\n    if ( (d = mapPillars(pos, mat, ll)) < res.x ) {\n        res.x = d;;\n        res.y =mat;\n    }\n    if ( (d = mapLight2(pos, mat, false)) < res.x ) {\n        res.x = d;;\n        res.y =mat;\n    }\n    return res;\n}\n\nconst float maxHei = 0.8;\n\n\n\nvec2 castRay( in vec3 ro, in vec3 rd , bool ref)\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = ref ? 5. : 40.0;\n    int num_step = ref ? 20 : 170;\n    // raymarch primitives   \n    {\n    \n        float t = tmin;\n        for( int i=0; i<num_step && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x * 1.;\n        }\n    }\n    \n    return res;\n}\n\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat fog(vec3 ro, vec3 rd) {\n     return 0.;\n    float ret = 0.;\n    for (int i = 0; i < 4; ++i) {\n        ret += fbm(ro * 1.) *.01 * pow(1.-ro.y, 2.);//* smoothstep(-.5, .5, -rd.y);\n        ro += rd * 2.1;\n    }\n    return ret;\n}\n\nvec3 background(vec2 uv) {\n    float a = smoothstep(.0, 2.12, sin( length(uv) * 53. + 15.*iTime));\n    a = .0;\n    //return vec3(a);\n    return .4*(vec3(.02, .01, .01) + vec3(.5,.6,.3) * (a/2.+.5) * (.1*vec3(fbm(vec3(uv.x * 3.,uv.y * 3., .1*iTime)) )\n        + .05 * vec3(fbm(vec3(uv.x * 13. + iTime / 10.,uv.y * 13., .1*iTime)) ) ));\n}\nvec3 getLight(vec3 p) {\n    float u;\n    float ll;\n    float d1 = mapPillars(p, u, ll);\n    float d2 = mapLight2(p, u, true);\n    vec3 c1 = getcol2(oui2);\n   \n    vec3 c2 = getcol(oui);\n   \n    \n    return c2 * .2/(.1+d1*d1)  * ll + c1 * .2/(.1+d2*d2) * ls2();\n}\n\nvec3 render( in vec3 ro, in vec3 rd, vec2 bg )\n{ \n    vec3 col = vec3(.0f);\n    vec2 res = castRay(ro,rd, false);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 p = ro + rd * t;\n    vec3 nor = calcNormal(p);\n    vec3 ref = reflect(rd, nor);\n    vec3 albedo = 1.5*vec3(.04 + cos(p.z * 0. + iTime * 0.) / 20., \n    .3212 +  3.*sin(p.z * 10. + iTime*1.) / 20., 1.0);\n    float ao = 1.0;//calcAO(p, nor);\n    albedo =  10.*vec3(0.171,0.686,0.686) * (.0+tex3D(iChannel2, p / 10., nor).xyz);\n    float tt = res.x > 0. ? 0. : 110.;\n    float u;\n    vec3 cLight = getLight(p);\n    \n    vec3 c = rmLight(ro, rd, res.x + tt, res.y);\n    if (res.x > .0f) {\n    \n            \n        if (res.y == 3.) {\n             //res = castRay(p, ref, true);\n             p = p + ref * res.y;\n             //nor = calcNormal(p);\n             return (cLight+1.5*vec3(.1, .3,.1) * 1.*background(p.xz / 2.) +.1*albedo* (1. *vec3(res.x) / 10. + .5 ));\n        }\n    \tcol = .5*vec3(.001, .05, .002) + 2.*cLight*albedo * vec3(.9f, .5f, .5f) * max(.1f, -dot(normalize((p) - normalize(vec3(100.0f, 1000.0f, 100.0f))), \n                             nor) );\n        if (res.y == 4.) {\n            col = 10.*getcol(oui);\n        }\n    } else {\n        col = background(bg);\n    }\n    \n    col += vec3(fog(ro, rd));\n    col += c;\n    col = mix(col, background(bg), min(1., res.x  / 50.));\n   \treturn vec3(col);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = vec2(0);//iMouse.xy/iResolution.xy;\n\tfloat time = .0f; //iTime;\n\n    // camera\t\n    vec3 ro = vec3(-0.0f, 0.0f, -4.0f + 2. * iTime);//vec3( 4.6*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.6*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 11., 0., 0. );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = normalize( vec3(p.xy,2.) );\n\n        // render\t\n        vec3 col = render( ro, rd, p );\n\n\t\t// gamma\n        col = pow( col * 2., vec3(.954545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 sphericalToCartesian(vec3 p) {\n    return vec3(p.x * sin(p.y) * cos(p.z),\n                p.x * sin(p.y) * sin(p.z),\n                p.x * cos(p.y));\n}\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\nvec3 cartestianToSpherical(vec3 p) {\n    float d = length(p);\n    return vec3 ( d, acos(p.z / d), sign(p.y) * acos(p.x / length(p.xy)) );\n}\n\nvec2 hash22( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(175.1,311.7)),\n             dot(p,vec2(260.5,752.3)));\n    return fract(sin(p+455.)*18.5453);\n}\n// Smooth minimum function. Hardcoded with the smoothing value \"0.25.\"\nfloat sminP(in float a, in float b ){\n    \n    float h = clamp(2.*(b - a) + 0.5, 0.0, 1.0);\n    return (b - 0.25*h)*(1. - h) + a*h;\n    \n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lfsGR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[286, 286, 309, 346, 475], [476, 476, 498, 535, 664], [665, 665, 689, 689, 732], [734, 734, 746, 759, 804], [805, 805, 818, 818, 851], [869, 869, 887, 887, 1237], [1440, 1440, 1492, 1492, 2036], [2038, 2038, 2096, 2096, 3139], [3143, 3143, 3170, 3170, 4281], [4282, 4282, 4332, 4332, 4878], [5564, 5564, 5589, 5589, 6264], [6295, 6295, 6345, 6345, 6824], [6827, 6872, 6950, 6973, 7314], [7316, 7362, 7394, 7394, 7604], [7606, 7606, 7648, 7648, 7964], [7967, 7967, 8019, 8019, 8196], [8198, 8198, 8227, 8227, 8429], [8431, 8431, 8457, 8457, 8767], [8768, 8768, 8791, 8791, 9030], [9032, 9032, 9080, 9080, 10409]], "test": "untested"}
{"id": "mlGBDR", "name": "[âª]A Journey To The Start", "author": "Catzpaw", "description": "Gradius2 (Nemesis2) - A Journey To The Start (Air Battle Theme)", "tags": ["music", "chiptune", "msx", "scc"], "likes": 44, "viewed": 820, "published": 3, "date": "1702897060", "time_retrieved": "2024-07-30T17:15:56.532924", "image_code": "//==================================================\n// GRADIUS2 - A JOURNEY TO THE START\n\n//----------------------------------------\n// Video Output\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //UV\n    vec2 scr=vec2(SCRW,SCRH);\n    vec2 uv=fragCoord/iResolution.xy;\n    uv.y=.5-uv.y;\n    uv*=scr.x/iResolution.x;\n    uv.y+=(scr.y/iResolution.y)*.5;\n\n    //Output\n    vec2 sp=vec2(-.25,.75)*(scr.x/(iResolution.x*iResolution.x));\n    vec4 col;\n    if(iMouse.z>0.){\n        col=texture(iChannel0,uv+sp.xx)+texture(iChannel0,uv+sp)+\n            texture(iChannel0,uv+sp.yx)+texture(iChannel0,uv+sp.yy);\n    }else{\n        col=texture(iChannel1,uv+sp.xx)+texture(iChannel1,uv+sp)+\n            texture(iChannel1,uv+sp.yx)+texture(iChannel1,uv+sp.yy);\n    }\n    fragColor=col*.25;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//==================================================\n// STARS\n\n#define ITER 200\n#define EPS 0.01\n#define NEAR 1.\n#define FAR 170.\n\nvec3 hsv(float h,float s,float v){\n    return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\n\nmat2 rot(float a){\n    float si=sin(a),co=cos(a);\n    return mat2(co,si,-si,co);\n}\n\nfloat map(vec3 p){vec3 p2=floor((p*1.+1.)*.5);p=mod(p*1.+1.,2.)-1.;\n    float v=fract(sin(p2.x*133.3)*19.9+sin(p2.y*177.7)*13.3+sin(p2.z*199.9)*17.7);\n    return v<.993?.9:length(p)-4.3+v*4.;\n}\n\nfloat trace(vec3 ro,vec3 rd,out float h){float t=NEAR,d;\n    vec3 p;\n    for(int i=0;i<ITER;i++){\n        p=ro+rd*t;\n        d=map(p);if(abs(d)<EPS+t*3e-4||t>FAR)break;\n        t+=d;\n    }\n    p=floor((p*2.+1.)*.5);\n    h=fract(p.x*.08+p.y*.09+p.z*.1)*.8+.4;\n    return min(t,FAR);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Screen coodinate\n    fc2msx(fragCoord);\n    if(isOut)discard;\n    vec2 uv=vec2(px,py)/vec2(SCRW,SCRH)-0.5;\n\n    //Blur\n    vec3 col=texture(iChannel0,fragCoord/iResolution.xy).rgb*.88;\n\n    //Raymarching\n    float h;\n    float ay=sin(iTime*.181)*.2;\n    float ax=sin(iTime*.331)*.2-.1;\n    vec3 ro=vec3(.5,.5,-iTime*40.);\n    vec3 rd=vec3(uv,-.8);\n    rd.xz*=rot(ay);\n    rd.yz*=rot(ax);\n    float d=trace(ro,rd,h)/FAR;\n    float v=1.-d;\n\n    //Output\n    col+=hsv(h,.9-d*.5,v*1.8);\n    fragColor=vec4(clamp(col,0.,1.),1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//==================================================\n// MSX SCREEN1.5 (TMS9918 Half-Bitmap Mode)\n\n//----------------------------------------\n// ROM\n\n// Characters\n//  i32x2:8x8pattern i32x2:2colorsx8lines\nconst int[170*4] chr=int[](\n    0x00000000,0x00000000,0x00000000,0x00000000, //00\n    0x001c3663,0x637f6363,0x00f1f1f1,0xf1f1f1f1, //01 A\n    0x007e6363,0x7e63637e,0x00f1f1f1,0xf1f1f1f1, //02 B\n    0x003e6360,0x6060633e,0x00f1f1f1,0xf1f1f1f1, //03 C\n    0x007c6663,0x6363667c,0x00f1f1f1,0xf1f1f1f1, //04 D\n    0x007f6060,0x7e60607f,0x00f1f1f1,0xf1f1f1f1, //05 E\n    0x007f6060,0x7e606060,0x00f1f1f1,0xf1f1f1f1, //06 F\n    0x003e6360,0x6763633e,0x00f1f1f1,0xf1f1f1f1, //07 G\n    0x00636363,0x7f636363,0x00f1f1f1,0xf1f1f1f1, //08 H\n    0x003c1818,0x1818183c,0x00f1f1f1,0xf1f1f1f1, //09 I\n    0x001f0606,0x0606063c,0x00f1f1f1,0xf1f1f1f1, //0a J\n    0x0063666c,0x787c6e67,0x00f1f1f1,0xf1f1f1f1, //0b K\n    0x00606060,0x6060607f,0x00f1f1f1,0xf1f1f1f1, //0c L\n    0x0063777f,0x7f6b6363,0x00f1f1f1,0xf1f1f1f1, //0d M\n    0x0063737b,0x7f6f6763,0x00f1f1f1,0xf1f1f1f1, //0e N\n    0x003e6363,0x6363633e,0x00f1f1f1,0xf1f1f1f1, //0f O\n    0x007e6363,0x637e6060,0x00f1f1f1,0xf1f1f1f1, //10 P\n    0x003e6363,0x636f663d,0x00f1f1f1,0xf1f1f1f1, //11 Q\n    0x007e6363,0x627c6663,0x00f1f1f1,0xf1f1f1f1, //12 R\n    0x003e6360,0x3e03633e,0x00f1f1f1,0xf1f1f1f1, //13 S\n    0x007e1818,0x18181818,0x00f1f1f1,0xf1f1f1f1, //14 T\n    0x00636363,0x6363633e,0x00f1f1f1,0xf1f1f1f1, //15 U\n    0x00636363,0x63361c08,0x00f1f1f1,0xf1f1f1f1, //16 V\n    0x0063636b,0x6b7f7722,0x00f1f1f1,0xf1f1f1f1, //17 W\n    0x0063763c,0x1c1e3763,0x00f1f1f1,0xf1f1f1f1, //18 X\n    0x0066667e,0x3c181818,0x00f1f1f1,0xf1f1f1f1, //19 Y\n    0x007f070e,0x1c38707f,0x00f1f1f1,0xf1f1f1f1, //1a Z\n    0x3c4299a1,0xa199423c,0xf1f1f1f1,0xf1f1f1f1, //1b c\n    0x00183818,0x1818187e,0x00f1f1f1,0xf1f1f1f1, //1c 1\n    0x007f6306,0x0c181818,0x00f1f1f1,0xf1f1f1f1, //1d 7\n    0x003e6363,0x3e63633e,0x00f1f1f1,0xf1f1f1f1, //1e 8\n    0x003e6363,0x3f03633e,0x00f1f1f1,0xf1f1f1f1, //1f 9\n\n    0x00000000,0x01030707,0x00000000,0x40404010, //20\n    0x00000080,0xa0bcbf1f,0x00000040,0x41414141, //21\n    0x00000000,0x0000c0ff,0x00000000,0x00004040, //22\n    0x00000000,0x000000e0,0x00000000,0x00000040, //23\n    0x00000000,0x00000007,0x00000000,0x00000040, //24\n    0x00000000,0x000007ff,0x00000000,0x00004040, //25\n    0x00000001,0x053dfdf8,0x00000040,0x41414141, //26\n    0x00000000,0x80c0e0e0,0x00000000,0x40404010, //27\n    0x03010100,0x00000000,0x40c040c0,0x00000000, //28\n    0xa3dcdfef,0x77773b3d,0x41c141c1,0x41c141c1, //29\n    0xff3fc0ff,0xffffffff,0x414141c1,0x41c141c1, //2a\n    0xffff1fe0,0xffffffff,0x414141c1,0x41c141c1, //2b\n    0xffffff00,0xffffffff,0x41414141,0x41c141c1, //2c\n    0x80f0fcfe,0x0df0fdff,0x40404041,0x41c141c1, //2d\n    0x000fffff,0xf00fffff,0x40404141,0x41c141c1, //2e\n    0x3fffffc0,0x3fffffff,0x40414141,0x41c141c1, //2f\n    0xfcffff03,0xfcffffff,0x40414141,0x41c141c1, //30\n    0x00f0ffff,0x0ff0ffff,0x40404141,0x41c141c1, //31\n    0x010f3f7f,0xb00fbfff,0x40404041,0x41c141c1, //32\n    0xfffff807,0xffffffff,0x414141c1,0x41c141c1, //33\n    0xfffc03ff,0xffffffff,0x414141c1,0x41c141c1, //34\n    0xc53bfbf7,0xeeeedcbc,0x41c141c1,0x41c141c1, //35\n    0xc0808000,0x00000000,0x40c04000,0x00000000, //36\n    0x1d1e0f07,0x03010000,0x41c140c0,0x50c00000, //37 \n    0xffff7fbf,0xdfe7f83f,0x41c141c1,0x51c151c0, //38\n    0xffffffff,0xffffff00,0x41c141c1,0x51c151c1, //39\n    0xe0f0f8fc,0xfeffff0f,0x41c141c1,0x51c151c1, //3a\n    0x0000ff7f,0x3f1f80c0,0x11116161,0x6161c1c1, //3b\n    0x0000ffff,0xffff0000,0x61616161,0x61616161, //3c\n    0x0000ffff,0xffff0103,0x61616161,0x61616161, //3d\n    0x00003f3f,0x3f3f040c,0x61616161,0x61616161, //3e\n    0x0000fcfc,0xfcfc3c7c,0x61616161,0x61616161, //3f\n    0x0000ffff,0xffff1030,0x61616161,0x61616161, //40\n    0x0000f3f3,0xf3f3f0f0,0x61616161,0x61616161, //41\n    0x0000ffff,0xffff43c3,0x61616161,0x61616161, //42\n    0x0000c1c3,0xc7cfc1c3,0x61616161,0x61616161, //43\n    0x00003c3c,0x3c3c040c,0x61616161,0x61616161, //44\n    0x00003c3c,0x3c3c3c3c,0x61616161,0x61616161, //45\n    0x0000fffe,0xfcf80103,0x61616161,0x6161c1c1, //46\n    0x040f1f3f,0x7ffffff0,0x41c141c1,0x51c151c1, //47\n    0x17727577,0xffffff00,0x41c141c1,0x51c151c1, //48\n    0x7f7f7e7d,0xfbe71ffc,0x41c141c1,0x51c151c0, //49\n    0xb878f0e0,0xc0800000,0x41c140c0,0x50c00000, //4a\n    0x0f030000,0x00000000,0x50c00000,0x00000000, //4b\n    0xdf9f6f6f,0x773b1c0f,0x51c171c1,0x71217120, //4c\n    0xffffffff,0xffffff00,0x51c171c1,0x71217121, //4d\n    0xffffffff,0xffffff00,0x51c171c1,0x71217121, //4e\n    0xffffffff,0xffffffff,0x51c171c1,0x71217121, //4f\n    0x070f0f0f,0x0f0f0f0f,0x61616161,0x61616161, //50\n    0x003f3f3f,0x3f0f0f0f,0x61616161,0x61616161, //51\n    0x1c3d3f3c,0x3c3c3c3c,0x61616161,0x61616161, //52\n    0xf8f0e03c,0x3c3c3c3c,0x61616161,0x61616161, //53\n    0x70ffffff,0xfff0f0f0,0x61616161,0x61616161, //54\n    0xf1f3f3f3,0xf3f3f3f3,0x61616161,0x61616161, //55\n    0xc3c3c3c3,0xc3c3c3c3,0x61616161,0x61616161, //56\n    0xc7cfcfcf,0xcfcfcfcf,0x61616161,0x61616161, //57\n    0x1c3c3c3c,0x3c3c3c3c,0x61616161,0x61616161, //58\n    0x3c3c3c3c,0x3c3c3c3c,0x61616161,0x61616161, //59\n    0x70ffffff,0xff000000,0x61616161,0x61616161, //5a\n    0x00f0f0f0,0xf0f0f0f0,0x61616161,0x61616161, //5b\n    0xffffffff,0xfffffff0,0x51c171c1,0x71217121, //5c\n    0xfbf9f6f6,0xeedc38f0,0x51c171c1,0x71217120, //5d\n    0xf0c00000,0x00000000,0x50c00000,0x00000000, //5e\n    0x07010000,0x00000000,0x70200000,0x00000000, //5f\n    0xefd73737,0x3b1c0f07,0x71217131,0x71317030, //60\n    0xffffffff,0xff7f00bf,0x71217131,0x713a7131, //61\n    0xffffffff,0xffffffff,0x71217131,0x71317131, //62\n    0x0f0f0f0f,0x0f0000ff,0x61616161,0x61616131, //63\n    0x0fffffff,0xff0000ff,0x61616161,0x61616131, //64\n    0x3c3c3c3c,0x3c0000ff,0x61616161,0x61616131, //65\n    0xf0f0f0f0,0xf00000ff,0x61616161,0x61616131, //66\n    0xf3f3f3f3,0xf30000ff,0x61616161,0x61616131, //67\n    0xc3ffffff,0xfe0000ff,0x61616161,0x61616131, //68\n    0xcfcf8f0f,0x0f0000ff,0x61616161,0x61616131, //69\n    0x3c3f3f3f,0x3f0000ff,0x61616161,0x61616131, //6a\n    0x3cfcfcfc,0xfc0000ff,0x61616161,0x61616131, //6b\n    0x00ffffff,0xff0000ff,0x61616161,0x61616131, //6c\n    0xffffffff,0xfffe00fd,0x71217131,0x713a7131, //6d\n    0xf7ebecec,0xdc38f0e0,0x71217131,0x71317030, //6e\n    0xe0800000,0x00000000,0x70200000,0x00000000, //6f\n    0x5fef733c,0x1f0f0300,0x71b1f151,0x50404000, //70\n    0xffffff00,0xffffff00,0x71b1f151,0x51414100, //71\n\n    0xffe0e020,0xe7e7e767,0x71b4f141,0x41414151, //72\n    0xffff0000,0xffffffff,0x71414141,0x41414151, //73\n    0xffff0000,0xffffff40,0x71414141,0x41414154, //74\n    0xffff0000,0xffffffff,0x71414141,0x41414141, //75\n    0xfffe0100,0xfeffffff,0x714a4141,0x41414141, //76\n    0xffff8060,0x1f8fcfc4,0x71b14f41,0x51414141, //77\n    0xffffff00,0x7fffff00,0x71b1f441,0x54414140, //78\n    0xfaf7ce3c,0xf8f0c000,0x71b1f141,0x50404040, //79\n    0x27272727,0x20202020,0x415171f1,0x41414141, //7a\n    0xffffffff,0x00000000,0x415171f1,0x41414141, //7b\n    0xfffdffff,0x00000000,0x415471f1,0x41414141, //7c\n    0xffffd0fc,0x01000001,0x414174f4,0x41414141, //7d\n    0xffffffff,0xffffffff,0x41414141,0x41414141, //7e\n    0xe4e4e4e4,0xe4e4e4e4,0x41414141,0x41414141, //7f\n    0x20202327,0x474f8f9f,0x41414141,0x41414141, //80\n    0x3fffffff,0xffffffff,0x41414141,0x41414141, //81\n    0xffffffff,0xffff177f,0x41414141,0x414174f4, //82\n    0xffffffff,0xffffffff,0x41414141,0x414171f1, //83\n    0xffffffff,0xfffffffe,0x41414141,0x414171f1, //84\n    0xe4e4e4e4,0xc4c88810,0x41414141,0x414171f1, //85\n    0x9f9f9f9f,0x9f9f9f9f,0x41414141,0x41414151, //86\n    0xffffffff,0xffffffff,0x41414141,0x41414151, //87\n    0x80000080,0xffffffff,0x41414141,0x41414151, //88\n    0x00000000,0xffffffff,0x41414141,0x41414151, //89\n    0x3f010101,0xf9f9f9f9,0x41414141,0x41414151, //8a\n    0x9f9f9f9f,0x8080ff00,0x415171f1,0x41414100, //8b\n    0xffffffff,0x0000ff00,0x415171f1,0x41414100, //8c\n    0xf9f9f9f9,0x0101ff00,0x415171f1,0x41414100, //8d\n\n    0xffe0e020,0xe7e7e767,0x71b2f121,0x21212131, //8e\n    0xffff0000,0xffffffff,0x71212121,0x21212131, //8f\n    0xffff0000,0xffffff40,0x71212121,0x21212132, //90\n    0xffff0000,0xffffffff,0x71212121,0x21212121, //91\n    0xfffe0100,0xfeffffff,0x712a2121,0x21212121, //92\n    0xffff8060,0x1f8fcfc4,0x71b12f21,0x31212121, //93\n    0xffffff00,0x7fffff00,0x71b1f441,0x54414140, //94\n    0xfaf7ce3c,0xf8f0c000,0x71b1f141,0x50404040, //95\n    0x27272727,0x20202020,0x213171f1,0x21212121, //96\n    0xffffffff,0x00000000,0x213171f1,0x21212121, //97\n    0xfffdffff,0x00000000,0x213271f1,0x21212121, //98\n    0xffffd0fc,0x01000001,0x212172f2,0x21212121, //99\n    0xffffffff,0xffffffff,0x21212121,0x21212121, //9a\n    0xe4e4e4e4,0xe4e4e4e4,0x21212121,0x21212121, //9b\n    0x20202327,0x474f8f9f,0x21212121,0x21212121, //9c\n    0x3fffffff,0xffffffff,0x21212121,0x21212121, //9d\n    0xffffffff,0xffff177f,0x21212121,0x212172f2, //9e\n    0xffffffff,0xffffffff,0x21212121,0x212171f1, //9f\n    0xffffffff,0xfffffffe,0x21212121,0x212171f1, //a0\n    0xe4e4e4e4,0xc4c88810,0x21212121,0x212171f1, //a1\n    0x9f9f9f9f,0x9f9f9f9f,0x21212121,0x21212131, //a2\n    0xffffffff,0xffffffff,0x21212121,0x21212131, //a3\n    0x80000080,0xffffffff,0x21212121,0x21212131, //a4\n    0x00000000,0xffffffff,0x21212121,0x21212131, //a5\n    0x3f010101,0xf9f9f9f9,0x21212121,0x21212131, //a6\n    0x9f9f9f9f,0x8080ff00,0x213171f1,0x21212100, //a7\n    0xffffffff,0x0000ff00,0x213171f1,0x21212100, //a8\n    0xf9f9f9f9,0x0101ff00,0x213171f1,0x21212100  //a9\n);\n\n// Text\nconst int[8*19] txt=int[](\n  0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,\n  0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,\n  0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,\n  0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,\n  0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,\n  0x00000020,0x21222300,0x00000000,0x00000000,0x00000000,0x00000000,0x00242526,0x27000000,\n  0x00000028,0x292a2b2c,0x2c2c2c2c,0x2c2d2e2f,0x3031322c,0x2c2c2c2c,0x2c333435,0x36000000,\n  0x00000000,0x3738393a,0x3b3c3d3c,0x3e3f4041,0x42434445,0x403c3c46,0x4748494a,0x00000000,\n  0x00000000,0x004b4c4d,0x4e4f5051,0x52535455,0x56575859,0x5a5b4f5c,0x4d5d5e00,0x00000000,\n  0x00000000,0x00005f60,0x61626364,0x65656667,0x68696a6b,0x6c66626d,0x6e6f0000,0x00000000,\n  0x00000000,0x00000000,0x70717171,0x72737373,0x74757677,0x78717179,0x00000000,0x00000000,\n  0x00000000,0x00000000,0x00000000,0x7a7b7b7b,0x7c7d7e7f,0x00000000,0x00000000,0x00000000,\n  0x00000000,0x00000000,0x00000000,0x80818283,0x83838485,0x00000000,0x00000000,0x00000000,\n  0x00000000,0x00000000,0x00000000,0x86878889,0x8989898a,0x00000000,0x00000000,0x00000000,\n  0x00000000,0x00000000,0x00000000,0x8b8c8c8c,0x8c8c8c8d,0x00000000,0x00000000,0x00000000,\n  0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,\n  0x00000000,0x0001000a,0x0f15120e,0x05190014,0x0f001408,0x05001314,0x01121400,0x00000000,\n  0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,\n  0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000\n);\n\n// Sprites\n//  i32x2:8x8pattern\nconst int[4] spr=int[](0x03030301,0x00000000,0x0f070700,0x00000000);\n\n//----------------------------------------\n// TMS9918 Palette (MSX1)\n\nconst vec4[16] pal=vec4[](\n  vec4(.00,.00,.00,0), vec4(.00,.00,.00,1), vec4(.13,.78,.26,1), vec4(.37,.86,.47,1),\n  vec4(.33,.34,.93,1), vec4(.49,.46,.99,1), vec4(.83,.32,.30,1), vec4(.26,.93,.96,1),\n  vec4(.99,.33,.33,1), vec4(1.0,.54,.47,1), vec4(.83,.75,.33,1), vec4(.90,.81,.50,1),\n  vec4(.13,.69,.23,1), vec4(.79,.36,.73,1), vec4(.80,.80,.80,1), vec4(1.0,1.0,1.0,1)\n);\n// 0 Transparent    8 Medium Red\n// 1 Black          9 Light Red\n// 2 Medium Green  10 Dark Yellow\n// 3 Light Green   11 Light Yellow\n// 4 Dark Blue     12 Dark Green\n// 5 Light Blue    13 Magenta\n// 6 Dark Red      14 Gray\n// 7 Cyan          15 White\n\n\n//----------------------------------------\n// Text\n\nint displayText(){\n    int a=addr%(32*19),x=px&7,y=py&7;\n    int t=(txt[a>>2]>>(24-((a&3)<<3)))&255;\n    t<<=2;\n    t+=(t>0x71*4)&&(t<0x8e*4)&&(mod(iTime,.3)>.15)?28*4:0;\n    t+=y<4?0:1;\n    int fg,bg;\n    fg=chr[t+2]>>(24-((y&3)<<3));\n    bg=fg&15;\n    fg=(fg>>4)&15;\n    return ((chr[t]>>(31-(x+((y&3)<<3))))&1)!=0?fg:bg;\n}\n\n//----------------------------------------\n// Sprite\n\nint putSprite(int x,int y,int n){\n    int c=0;\n    n<<=1;\n    x=px-x;\n    y=py-y;\n    if((x>=0)&&(x<8)&&(y>=0)&&(y<8)){\n        n+=y>3?1:0;\n        y&=3;\n        c=(spr[n]>>(31-x-y*8))&1;\n    }\n    return c;\n}\n\n//----------------------------------------\n// Convert iChannel0 to Graphic2\n\n//const int cr=8;const int[cr] cl=int[](1,2,3,10,11,12,14,15);\nconst int cr=12;const int[cr] cl=int[](1,4,5,6,7,8,9,10,11,13,14,15);\n//const int cr=15;const int[cr] cl=int[](1,2,3,4,5,6,7,8,9,10,11,12,13,14,15);\nint videoInput(int x,int y){\n    vec2 uv=(vec2(x,y)+.5)/iResolution.xy;\n    vec4 tx=texture(iChannel0,uv);\n    int c=0;\n    float l=2.;\n    for(int i=0;i<cr;i++){\n        float d=length(pal[cl[i]].rgb-tx.rgb);\n        if(d<l){l=d;c=cl[i];}\n    }\n    return c;\n}\nint getPixelColor(int x,int y){\n    int[16] hi=int[](0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n    int al=x&0xfff8;\n    int c=0;\n    for(int i=0;i<8;i++){\n        int v=videoInput(al+i,y);\n        hi[v]+=v==1?5:3;\n        c=i==(x&7)?v:c;\n    }\n    int c1=0,c2=0,n1=0,n2=0;\n    for(int i=0;i<16;i++){\n        int co=hi[i];\n        if(co>c1){\n            c1=co;\n            n1=i;\n        }else if(co>c2){\n            c2=co;\n            n2=i;\n        }\n    }\n    float d1=length(pal[n1]-pal[c]);\n    float d2=length(pal[n2]-pal[c]);\n    return d1<d2?n1:n2;\n}\n\n//----------------------------------------\n// Video Output\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Screen coodinate\n    fc2msx(fragCoord);\n    if(isOut)discard;\n\n    vec4 col=pal[1];\n\n    //Background\n    int v=getPixelColor(px,py);\n    col=v>0?pal[v]:col;\n\n    //Text\n    int c=displayText();\n    col=c>0?pal[c]:col;\n\n    //Sprite\n    col=putSprite(90,84,0)>0?pal[4]:col;\n    col=putSprite(152,84,1)>0?pal[4]:col;\n\n    //Output\n    fragColor=col;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//==================================================\n// MSX SCREEN2 SETTINGS\n\n#define SCRW 256\n#define SCRH 192\n\n//----------------------------------------\n// MSX Screen Coodinate\n\nint addr=0,px=0,py=0,sx=0,sy=0;\nbool isOut=true;\nvoid fc2msx(vec2 fc){\n    px=int(fc.x);\n    py=int(fc.y);\n    sx=SCRW;\n    sy=SCRH;\n    isOut=(px<0)||(py<0)||(px>=sx)||(py>=sy);\n    addr=(px/8)+(py/8)*32;\n}\n", "sound_code": "//==================================================\n// GRADIUS2 - A JOURNEY TO THE START\n\nconst float base=440.;//master tuning (Hz)\nconst float bpm=220.; //tempo\nconst float start=2.; //start count (beats)\nconst float fade=10.; //fade out time (sec)\nconst float sec=180.; //performance time (includes start and fade)\n\nconst float drive=.45;\nconst float pressure=1.;\nconst int   delayrepeat=4;\nconst float delaywet=.2;\nconst float delayfb=.6;\nconst float delaytime=.14;\n\n//----------------------------------------\n// SCC ROM\n\nconst int[64] wt=int[](\n  //0:Bass 1:Bell 2:Vibe 3:Saw 4:PSGSquare 5:HalfSaw 6:Noise1 7:Noise2\n    0x40404000,0x407F4000,0xC080C000,0x407F4000,0xC0004000,0xE0002000,0xF0001000,0xF8000800,\n    0x0B3A6178,0x7D6F4F23,0xF2C39C85,0x808EAEDA,0x0B48727D,0x6633F2B5,0x8B8097CA,0x0B5DF2B0,\n    0x1C4B563E,0x16FB0024,0x55757047,0x0DE1D5EB,0x10261AEE,0xB48B86A6,0xD7FB00E5,0xBDA5B0DF,\n    0x80889098,0xA1A9B1B9,0xC2CAD2DA,0xE3EBF3FB,0x040C141C,0x252D353D,0x464E565E,0x676F777F,\n    0x7F7F7F7F,0x7F7F7F7F,0x7F7F7F7F,0x7F7F7F7F,0x00000000,0x00000000,0x00000000,0x00000000,\n    0x7F6F5F4F,0x3F2F1F0F,0xFFEFDFCF,0xBFAF9F8F,0x80808080,0x80808080,0x80808080,0x80808080,\n    0xBDC612B7,0x54A92708,0x8E96239B,0x3FD371F9,0xCABC2A4F,0xEB463EA7,0x0688E1DB,0x85DF34C5,\n    0xFF92D8FC,0x0944FC8D,0xA1049D9A,0xF6547236,0xB7B15E45,0xFBE63E46,0x2413B8F7,0xF744F3C2\n);\n\n//----------------------------------------\n// Sequencer ROM\n\n//pattern parameters\n//  mode(1)       1:<reserved> 0:4bit note double speed\n//  instrument(3) 0:Bass 1:Bell 2:Vibe 3:Saw 4:PSGSquare 5:HalfSaw\n//  detune(1)     1:enable(+5cent)\n//  envelope(3)   0:env1 1:env2 2:env3 3:env4\n//  volume(4)     0:mute ... 15:max\n//  panpot(4)     1:-7 right 8:+0 center 15:+7 left 0:<reserved>\n//  lfo phase(2)  0:up 1:down 3,4:<reserved>\n//  lfo mode(2)   0:off 1:velocity 2:note 3:both\n//  lfo delay(4)  0:0tick 1:1tick ... 15:15tick\n//  lfo amount(4) velocity:(n+1)/16 note:(n+1)*25cent\n//  lfo pitch(4)  0:1/5sec 15:16/5sec\n//    lfo time resolution:1/20sec\n//    lfo waveform:triangle\nconst int[19] pp=int[](0x00080000,\n    0x41870000,                      //01       PSG bass\n    0x40870000,                      //01       PSG bass stacc.\n    0x01590000,                      //03       SCC bass\n    0x00590000,                      //03       SCC bass stacc.\n    0x22580000,0x2A4C0000,           //05       SCC vibe\n    0x12560000,0x12490000,           //07 08    SCC bell\n    0x51580000,0x59440000,0x513C0000,//09 0A 0B SCC halfsaw\n    0x3A770000,0x32650000,0x324B0000,//0C 0D 0E SCC saw    \n    0x23680000,0x235C0000,           //0F 10    SCC vibe stacc.\n    0x13560000,0x13490000            //11 12    SCC bell stacc.\n);\n\n//note pattern\n//  0:rest  1-F:note\nconst int[72] np=int[](0x00000000,\n  //   bs bass   PSGsquare / Bass\n  //   m1 melody Vibe / HalfSaw / Bell\n  //   m2 melody delay 1/16\n  //   m3 melody delay 1/8\n\n  //01 bs      02 bs      03 bs      04 bs      05 bs      06 bs      07 bs      08 bs\n    0x1110DDDD,0x1111DD11,0x1011DD11,0x88DDDDDD,0x88111111,0x1188DD11,0x11333333,0x113366AA,\n  //09 bs      0A bs      0B bs      0C bs      0D *       0E bs      0F m1      10 m1\n    0x99441199,0x11222222,0x88994411,0x55666611,0x11111111,0x11111166,0x10101010,0x00111111,\n  //11 m1      12 m1      13 m1      14 m1      15 m1      16 m1      17 m1      18 m1\n    0x11110011,0x88114411,0x88114488,0x00114411,0xDD884411,0xAA116611,0xAA1166AA,0x00116611,\n  //19 m1      1A m1      1B m1      1C m1      1D m1      1E m1      1F m1      20 m1\n    0xDDAA6611,0x885511DD,0x88551155,0x22222011,0x11111033,0x11111100,0x11001100,0x11111022,\n  //21 m1      22 m1      23 m1      24 m1      25 m1      26 m2      27 m2      28 m2\n    0x12346789,0xDD885511,0x1166AADD,0x00550011,0x00440011,0x08811441,0x18811448,0x80011441,\n  //29 m2      2A m2      2B m2      2C m2      2D m2      2E m2      2F m2      30 m2\n    0x1DD88441,0x18811441,0x3AA11661,0x1AA1166A,0xA0011661,0x1DDAA661,0x1AA7733F,0xFAA77337,  \n  //31 m3      32 m3      33 m3      34 m3      35 m3      36 m3      37 m3      38 m3\n    0x00881144,0x11881144,0x88001144,0x11DD8844,0x11881144,0x33AA1166,0x11AA1166,0xAA001166,    \n  //39 m3      3A m3      3B m3      3C m3      3D m3      3E m3      3F m3      40 m1 \n    0x11AA7733,0xFFAA7733,0x00111110,0x00111111,0x00110011,0x00123467,0x89BB00BB,0x11111011,\n  //41 m3      42 m3      43 m3      44 m3      45 m3      46 m1      47 m1\n    0x11DDAA66,0x00111110,0x33110011,0x00123467,0x89BB00BB,0x114499DD,0x00660011\n);\n//gate time pattern\n//  0:note on or rest start  1-F:time from last note on\nconst int[17] gp=int[](0x01234567,\n  //01         02         03         04         05         06         07         08\n    0x01230123,0x01010101,0x01234567,0x89AB0101,0x23012301,0x23010101,0x89ABCDEF,0x01012345,\n  //09         0A         0B         0C         0D         0E         0F m1      10 m2\n    0x23456789,0x01234501,0xABCDEF00,0x00000000,0x00000001,0x01234001,0x10101010,0x67010101\n);\n\n//note sequence\n//  key(8) A4:0x45 C2:0x24 C3:0x30 C4:0x3C C5:0x48 E2:0x28 E3:0x34 E4:0x40 E5:0x4C\n//  note pattern(8)\n//  gate pattern(8)\n//  parameters(8)\n\n//KEY (MIDI Note_Numbers)_    __    __ __    __    __ __    __    __    __ __    __    __ __    __    __    __\n//|C1|__|D1|__|E1|F1|__|G1|__|A1|__|B1|C2|__|D2|__|E2|F2|__|G2|__|A2|__|B2|C3|__|D3|__|E3|F3|__|G3|__|A3|__|B3|\n//|18 19 1A 1B 1C|1D 1E 1F 20 21 22 23|24 25 26 27 28|29 2A 2B 2C 2D 2E 2F|30 31 32 33 34|35 36 37 38 39 3A 3B|\n//|__    __    __ __    __    __    __|__    __    __ __    __    __    __|__    __    __ __    __    __    __|\n//|C4|__|D4|__|E4|F4|__|G4|__|A4|__|B4|C5|__|D5|__|E5|F5|__|G5|__|A5|__|B5|C6|__|D6|__|E6|F6|__|G6|__|A6|__|B6|\n//|3C 3D 3E 3F 40|41 42 43 44 45 46 47|48 49 4A 4B 4C|4D 4E 4F 50 51 52 53|54 55 56 57 58|59 5A 5B 5C 5D 5E 5F|\n\n//PSG3(bass)\nconst int sl2=64;const int[sl2] sq2=int[](\n    0x28010101,0x28020201,0x28030601,0x28020201,0x28010101,0x28020201,0x28030601,0x28020201,//bass\n    0x28010101,0x28020201,0x28030601,0x28020201,0x28010101,0x28020201,0x28030601,0x28020201,\n    0x29010101,0x29020201,0x29030601,0x29020201,0x2A010101,0x2A020201,0x2A030601,0x2A020201,\n    0x2B010101,0x2B020201,0x2B030601,0x2B020201,0x2A010101,0x2A020201,0x23040201,0x23050201,\n    0x28060202,0x26070202,0x26070202,0x26070202,0x28060202,0x26070202,0x26070202,0x26080202,\n    0x28090202,0x2F0A0202,0x2F0A0202,0x2F0A0202,0x2F0A0202,0x2F0A0202,0x2F0A0202,0x280B0202,\n    0x28060202,0x26070202,0x26070202,0x26070202,0x28060202,0x26070202,0x26070202,0x26080202,\n    0x28090202,0x2F0A0202,0x2F0A0202,0x2B0C0202,0x2A0D0301,0x2A0E0401,0x2F0D0501,0x2D070202\n);\n//SCC2(bass - bass&vibe - vibe)\nconst int sl3=64;const int[sl3] sq3=int[](\n    0x28010103,0x28020203,0x28030603,0x28020203,0x28010103,0x28020203,0x28030603,0x28020203,//bass\n    0x28010103,0x28020203,0x28030603,0x28020203,0x28010103,0x28020203,0x28030603,0x28020203,\n    0x29010103,0x29020203,0x29030603,0x29020203,0x2A010103,0x2A020203,0x2A030603,0x2A020203,\n    0x2B010103,0x2B020203,0x2B030603,0x2B020203,0x2A010103,0x2A020203,0x23040203,0x23050203,\n    0x28060204,0x451D0E05,0x470D0905,0x471E0B05,0x451F0205,0x451D0E05,0x470D0905,0x471E0B05,//bass-vibe\n    0x28090204,0x4A1D0E05,0x4C0D0905,0x40210C05,0x4A1F0205,0x4A1D0E05,0x4C0D0905,0x4C1E0B05,//bass-vibe\n    0x28060204,0x451D0E05,0x470D0905,0x471E0B05,0x451F0205,0x451D0E05,0x470D0905,0x471E0B05,//bass-vibe\n    0x28090204,0x4A1D0E05,0x4C0D0905,0x4C1E0B05,0x45220C0F,0x40230D0F,0x4524020F,0x3D25020F //bass-vibe\n);\n//SCC3(vibe - m3halfsaw - saw - m3vibe - vibe)\nconst int sl4=64;const int[sl4] sq4=int[](\n    0x490D0005,0x490D0705,0x490D020F,0x49100805,0x4A0D0005,0x4A0D0705,0x4A11020F,0x4A100805,//vibe\n    0x490D0005,0x490D0705,0x490D020F,0x49100805,0x4A0D0005,0x4A0D0705,0x4A11020F,0x4A100805,\n    0x4531020B,0x4532020B,0x4533020B,0x4534020B,0x4535020B,0x4532020B,0x4533020B,0x4534020B,//m3halfsaw\n    0x4336020B,0x4337020B,0x4338020B,0x4341020B,0x4339020B,0x433A020B,0x47400A0E,0x470D090E,//m3haflsaw-saw\n    0x45000006,0x453B0806,0x470D0306,0x470D0706,0x453D0206,0x453B0806,0x470D0306,0x470D0706,//m3vibe\n    0x4A000006,0x4A3B0806,0x4C0D0306,0x403E0806,0x403F1006,0x4A3B0806,0x4C0D0306,0x4C0D0706,\n    0x45000006,0x453B0806,0x470D0306,0x470D0706,0x453D0206,0x453B0806,0x470D0306,0x470D0706,\n    0x4A000006,0x4A3B0806,0x4C0D0306,0x4C0D0706,0x40190C10,0x3D460D10,0x40470210,0x39240210 //m3vibe-vibe\n);\n//SCC4(bell - halfsaw - saw - bell)\nconst int sl5=64;const int[sl5] sq5=int[](\n    0x460D0007,0x460D0707,0x460D0211,0x46100807,0x470D0007,0x470D0707,0x47110211,0x47100807,//bell\n    0x460D0007,0x460D0707,0x460D0211,0x46100807,0x470D0007,0x470D0707,0x47110211,0x47100807,\n    0x45120209,0x45130209,0x45140209,0x45150209,0x45120209,0x45130209,0x45140209,0x45150209,//halfsaw\n    0x43160209,0x43170209,0x43180209,0x43190209,0x451A0209,0x451B0209,0x4B1C0A0C,0x4B0D090C,//halfsaw-saw\n    0x4500000C,0x451D0E0C,0x470D090C,0x471E0B0C,0x451F020C,0x451D0E0C,0x470D090C,0x471E0B0C,//saw\n    0x4500000C,0x451D0E0C,0x470D090C,0x471E0B0C,0x451F020C,0x451D0E0C,0x470D090C,0x471E0B0C,\n    0x4500000C,0x451D0E0C,0x470D090C,0x471E0B0C,0x451F020C,0x451D0E0C,0x470D090C,0x471E0B0C,\n    0x4500000C,0x451D0E0C,0x470D090C,0x471E0B0C,0x490D0211,0x493D0211,0x493D0211,0x49110211 //saw-bell\n);\n//SCC5(bell - m2halfsaw - saw - bell)\nconst int sl6=64;const int[sl6] sq6=int[](\n    0x420D0008,0x420D0708,0x420D0212,0x42100808,0x430D0008,0x430D0708,0x43110212,0x43100808,//bell\n    0x420D0008,0x420D0708,0x420D0212,0x42100808,0x430D0008,0x430D0708,0x43110212,0x43100808,\n    0x45260F0A,0x45270F0A,0x45280F0A,0x45290F0A,0x452A0F0A,0x45270F0A,0x45280F0A,0x45290F0A,//m2halfsaw\n    0x432B0F0A,0x432C0F0A,0x432D0F0A,0x432E0F0A,0x432F0F0A,0x43300F0A,0x45400A0D,0x450D090D,//m2halfsaw-saw\n    0x4200000D,0x42200E0D,0x430D090D,0x431E0B0D,0x421F020D,0x42200E0D,0x430D090D,0x431E0B0D,//saw\n    0x4200000D,0x42200E0D,0x430D090D,0x431E0B0D,0x421F020D,0x42200E0D,0x430D090D,0x431E0B0D,\n    0x4200000D,0x42200E0D,0x430D090D,0x431E0B0D,0x421F020D,0x42200E0D,0x430D090D,0x431E0B0D,\n    0x4200000D,0x42200E0D,0x430D090D,0x431E0B0D,0x450D0212,0x453D0212,0x453D0212,0x45110212 //saw-bell\n);\n\n//rhythm pattern\n//  0:note on  1-E:time from last note on  F:rest\nconst int[33] rp=int[](0xFFFFFFFF,\n    0x01010100,0xFF010101,0x01FF0101,0x0100FFFF,0xFF01FFFF,0x01FF01FF,0x01FFFFFF,0xFFFFFF01, //01 clsd hihat\n    0x01FFFFFF,0xFFFF0123,0x01FF0123,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF, //09 open hihat\n    0x0123FFFF,0x0101FFFF,0x0001FF01,0x01010101,0xFF01FF01,0x01230123,0xFFFFFFFF,0xFFFFFFFF, //11 kick\n    0xFFFF0123,0xFFFF1201,0xFF00FF01,0x01FF1201,0x0123FFFF,0x010123FF,0xFF121201,0xFF121201  //19 snare\n);\n\n//percussion sequence\n//  gate pattern(8)x4\nconst int sl1=64;const int[sl1] sq1=int[](\n    0x01001119,0x02091219,0x01001119,0x02091219,0x01001119,0x02091219,0x01001119,0x02091219,\n    0x01001119,0x02091219,0x01001119,0x02091219,0x01001119,0x02091219,0x01001119,0x0209131A,\n    0x01001119,0x02091219,0x01001119,0x02091219,0x01001119,0x02091219,0x01001119,0x02091219,\n    0x01001119,0x02091219,0x01001119,0x02091219,0x01001119,0x02091219,0x0300131B,0x0209141C,\n    0x040A151D,0x050B151D,0x040A151D,0x050B151E,0x040A151D,0x050B151D,0x040A151D,0x050B151E,\n    0x040A151D,0x050B151D,0x040A151D,0x050B151E,0x040A151D,0x050B151D,0x040A151D,0x050B151F,\n    0x040A151D,0x050B151D,0x040A151D,0x050B151E,0x040A151D,0x050B151D,0x040A151D,0x050B151E,\n    0x040A151D,0x050B151D,0x040A151D,0x050B151E,0x07000000,0x0800161F,0x06001600,0x0209131B\n);\n\n//----------------------------------------\n// Amplifier\n//  vec3 p( drive, pressure, volume)\nvec2 amp(vec2 i,vec3 p){return clamp(sign(i)*pow(abs(i*p.x)*.01,vec2(1./p.y))*100.,-1.,1.)*p.z;}\n\n//----------------------------------------\n// Panpot\nfloat stereo=.5;\nvec2 panpot(int n){\n    float p=float(n-8);\n    float p1=.8-(abs(p)*.2)*stereo,p2=.8+(abs(p)*.06)*stereo;\n    return p<0.?vec2(p1,p2):vec2(p2,p1);\n}\n\n//----------------------------------------\n// Envelope\nfloat env1(float r,float t){float v=max(1.-t*r,0.);return v>0.?v*v:0.;}\nfloat env2(float r,float t){float v=max(1.-t*r,.75-t*r*.125);return v>0.?v*v:0.;}\nfloat env3(float r,float t){float v=max(1.-t*r,.5);return v>0.?v*v:0.;}\nfloat env4(float r,float t){float v=max(min(1.-t*r,6.-t*r*3.),.0);return v>0.?v*v:0.;}\n\n//----------------------------------------\n// SCC Oscillator\nconst float i128=1./128.;\nfloat scc(float x,int i){\n    int pos=int(mod(x*32.,32.));\n    return float((((wt[(i<<3)+(pos>>2)]>>(24-((pos&3)<<3)))&255)^128)-128)*i128;\n}\n\n//----------------------------------------\n// Percussion Oscillator\nfloat sd(float f,float t){\n    float o=scc(290.*t,6)*scc(270.*t,7)*env2(20.,t);\n    o+=clamp(sin((f-t*(f*.4))*t)*20.,-1.,1.)*env1(9.,t);\n    return o;\n}\nfloat bd(float f,float t){return clamp(sin((f-t*(f*1.5))*t)*20.,-1.,1.)*env1(14.,t);}\nfloat hh(float f,float t){return scc(f*t,6)*scc((f*.969)*t,7)*env1(20.,t);}\nfloat oh(float f,float t){return scc(f*t,6)*scc((f*.969)*t,7)*env1(4.,t);}\n\n//----------------------------------------\n// Triangle Wave\nfloat tri(float x){\n    x=fract(x+.25);\n    return x<.5?x*4.-1.:2.-x*4.;\n}\n\n//----------------------------------------\n// Frequency From MIDI Note Number\nconst float i12=1./12.;\nfloat freq(float n){return pow(2.,(n-69.)*i12)*base;}\n\n//----------------------------------------\n// Sequencer\nint bar;\nint tick;\nfloat tt;\nfloat tl;\nconst float i6=1./6.;\nconst float i15=1./15.;\nvec2 getNote(int sq){\n    vec2 o=vec2(0);\n    int n=(np[(sq>>16)&255]>>(28-(tick<<2)))&15;\n    if(n==0)return o;\n    int k=(sq>>24)&255,p=pp[sq&255],g=(gp[(sq>>8)&255]>>(28-(tick<<2)))&15;\n    int i=(p>>28)&7,e=(p>>24)&7,s=(p>>16)&15;\n    float v=float((p>>20)&15)*i15,t=tt+tl*float(g);\n    int l=(p>>12)&3;\n    float ln=0.;\n    if(l>0){\n        int lp=(p>>14)&1,ld=(p>>8)&15;\n        float la=float((p>>4)&15),ll=float(p&15)+1.;\n        if(g>=ld){\n            float lt=floor((t-tl*float(ld))*20.)*.05+.025;\n            float lv=tri(lt/(ll*.2));\n            lv=lp==0?lv:-lv;\n            v+=(l&1)==1?lv*(la+1.)*.0625:0.;\n            ln=(l&2)==2?lv*(la+1.)*.25:0.;\n        }\n    }\n    if((e&2)==0){v*=(e&1)==0?env1(3.5,t):env2(2.5,t);}\n            else{v*=(e&1)==0?env3(2.0,t):env4(3.5,t);}\n    float f=freq(float(k+n-1)+float((p>>27)&1)*.05+ln);\n    o+=panpot(s)*scc(f*t,i)*v;\n    return o;\n}\nvec2 getPerc(int sq){\n    vec2 o=vec2(0);\n    int c=(rp[(sq>>24)&255]>>(28-(tick<<2)))&15;\n    int h=(rp[(sq>>16)&255]>>(28-(tick<<2)))&15;\n    int b=(rp[(sq>>8)&255]>>(28-(tick<<2)))&15;\n    int s=(rp[sq&255]>>(28-(tick<<2)))&15;\n    o+=c<15?panpot(7)*hh(440.,tt+tl*float(c))*.3:vec2(0);\n    o+=h<15?panpot(7)*oh(440.,tt+tl*float(h))*.3:vec2(0);\n    o+=b<15?panpot(8)*bd(474.,tt+tl*float(b))*.5:vec2(0);\n    o+=s<15?panpot(10)*sd(853.,tt+tl*float(s))*.7:vec2(0);\n    return o;\n}\nvec2 sequencer(float time){\n    vec2 o=vec2(0);\n    if(time<0.)return o;\n    tl=15./bpm;\n    tick=int(time/tl);\n    tt=mod(time,tl);\n    bar=tick>>3;\n    tick&=7;\n    o+=getNote(sq2[bar%sl2]); //PSG3\n    o+=getNote(sq3[bar%sl3]); //SCC2\n    o+=getNote(sq4[bar%sl4]); //SCC3\n    o+=getNote(sq5[bar%sl5]); //SCC4\n    o+=getNote(sq6[bar%sl6]); //SCC5\n    o+=getPerc(sq1[bar%sl1]); //Percussion\n    return o;\n}\n\n//----------------------------------------\n// Master\nvec2 mainSound( int samp, float time )\n{\n    vec2 o=vec2(0);\n    float vol=1.;if(time>sec-fade){vol=(sec-min(time,sec))/fade;}\n    time-=start*60./bpm;if(time<0.)return o;\n    stereo=0.4;\n    o+=sequencer(time);\n    float d=delaywet,r=delaytime;\n    for(int i=0;i<delayrepeat;i++){\n        stereo+=0.2/float(delayrepeat);\n        time-=delaytime;if(time<0.)continue;\n        r+=delaytime;\n        o+=sequencer(time)*d;\n        d*=delayfb;\n    }\n    return amp(o,vec3(drive,pressure,vol));\n}\n", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlGBDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 150, 207, 216, 794]], "test": "untested"}
{"id": "MffGzM", "name": "Black metal music", "author": "jarble", "description": "A black metal song with a black metal pattern.", "tags": ["fractal", "music", "metal"], "likes": 7, "viewed": 296, "published": 3, "date": "1702867188", "time_retrieved": "2024-07-30T17:15:57.369686", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nvec3 fractal(vec2 uv){\n    vec3 col = vec3(0.);\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    vec3 col1 = col;\n    float c1=0.;\n    for(int k = 0; k < 12; k++){\n    \n        uv.y -= 1./4.;\n        \n        uv = (uv+t2)/scale;\n        \n        uv = (fract(vec2(uv+vec2(.5,1.5))*scale)-.5)/scale;\n        \n        t2 = triangle_wave(uv+.5);\n        uv =\n            //t2-triangle_wave(uv.yx)+fract(t2/2.)\n            \n            //looks better with more iterations\n            t2-triangle_wave(uv.yx)-fract(t2/2.)-vec2(floor(-uv.x),0.)\n        ;\n        \n        c1 =\n            //max(abs(uv.y-uv.x*sign(uv.x-uv.y))/2.,c1)\n            max(abs(uv.y+uv.x)/2.,c1)\n        ;\n        c1 =\n            1.-abs(2.*c1-1.)\n            \n            //more colorful\n            //abs(2.*c1-1.)\n            \n            //Spooky!\n            //max(abs(2.*c1-2.),c1/4.)/2.\n        ;\n        col.x =\n             col.x\n            \n            //blue and white\n            //c1\n            \n            //red and blue and white\n            //max(1.-abs(2.*c1-1.),c1/4.)\n\n            \n            //more colorful\n            //max(length(uv-t2-c1)/3.,1.-col.x)\n            \n            //blue and green\n            //max(length(uv-c1)/3.,col.x)\n           \n            //purple\n            //2. - max((abs(uv.y-uv.x))/3.,col.x)\n           \n            //black and white\n            //col.x\n        ;\n        col =\n            abs(col-(1.-(c1*col.x)));\n        col1 =\n            abs(col1*c1-col-1.).yzx\n            //abs(col1*c1-col*sign(t2.y-t2.x)-1.).yzx\n        ;\n    }\n    return col1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    float t1 = 6.;\n    \n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.xy += iTime/t1/12.;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec3 col1 = fractal(uv);\n    fragColor = vec4(col1/2.,1.0);\n}\n", "image_inputs": [], "sound_code": "float mod1(float a, float b){\n    return\n        mod(a,b)\n        //mod(a+mod(a,b+3.),b)\n    ;\n}\n\nfloat fmod(float a, float b){\n    //the modulus should be a prime number\n    //this makes some interesting rhythms\n    float modulus =\n        //3.\n        5.\n        //7.\n    ;\n    for(float i = 1.; i < mod(floor(a/b),modulus); i++){\n    //for(float i = 1.+mod(floor(a/b),3.); i < mod(floor(a/b),modulus); i++){\n        a += mod1(floor(a/2.),b)*i;\n    }\n    return\n        mod(floor(a),b)\n    ;\n}\n\n#define fract1(a) abs(1.-fract(-a)*fract(-a))\n//#define fract1(a) pow(fract(a),1.+log(2.)-log(1.+fract(a)))\n\nvec2 synth_(vec2 a1,vec2 a,vec2 a2,vec2 a3,vec2 nb,vec2 a4){\n    return log(a1+a*abs(a2-abs(.5-a3*vec2(fract1(nb.x*.998),fract1(nb.y)))*a4));\n}\n#define synth(a1,a,a2,a3,nb,a4) synth_(vec2(a1),vec2(a),vec2(a2),vec2(a3),vec2(nb),vec2(a4))\n\nvec2 sitar5(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n      -log(1./2.+a*a/2.*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n    ;\n}\n\nvec2 mainSound1(int samp, float time,float scale,float duration){\n  float tempo = .25;\n  time /= tempo;\n  float s1 =\n      8.;\n  vec3\n  rhythm =\n      vec3(1.)\n      \n      //more rhythms here!\n      //vec3(2.,1./2.,2.)\n      //vec3(2.,2.,1./2.)\n      //vec3(1.,fmod(time/8.,2.)+1.,1.)\n      //vec3(2.)\n      //vec3(1.+mod(floor(time/4.),2.))\n      //vec3(mod(floor(time/32./4.),2.),mod(floor(time/16./4.),2.),mod(floor(time/8./4.),2.))+1.\n      //vec3(2.,2.,1.)\n      //vec3(mod(floor(time/4.),2.)+1.,1.,1.)\n  ;\n  for(float i = 1.; i < mod(floor(time),5.); i++){\n      time += mod(floor(time*2./rhythm.x),s1)*i;\n      time /= 1.+fmod(floor(time/2./rhythm.y)*2.,2.);\n      tempo *= 1.+fmod(floor(time/rhythm.z)*2.,2.);\n  }\n  float s2 = 8.,\n  t=\n      time,\n  m4 = (1.+fmod(t/16.,2.)),\n  m1 =\n      fmod(t/m4,s2)\n  ,\n  m3 =\n      fmod(t,1.+m1)+fmod(t/8.,2.);\n  t /=\n      (1.+fmod(t/s1,2.))*4./s1/s1\n  ;\n  float m2 =\n      1. + fmod(t/s1,s1)\n  ;\n  \n  //duration /= m4;\n  \n  vec2 a=\n      //vec2((1.-sqrt(fract(t/s1)/1.25))*.2)\n      -vec2((log(1./64./4.+fract1(t/s1)/8./duration)))\n      \n      //-vec2((log(1./64./4.+fract1(mod(t/s1,duration*s1))/2.)))\n\n      //pow(1.-log(1./16./2.+fract(t/s1)/4.),2.)\n  ,\n  nb = vec2(time*tempo*pow(2.,floor((m3+m2)/2.)/5.+scale));\n  vec2 \n  sitar = synth(1./8.,a,1./8.,1.,nb*2.,1./2.)\n  ,gamelan = a/16./4.*abs(synth(1./4.,a,1./8.,1.,nb*2.,1./2.)\n  +.5*synth(1./4.,a,1./4.,1.,nb*2.,1./2.)) \n  ,steel_drum = a/16./4.*abs(synth(1./2.,a,1./8.,1.,nb*4.,1.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.))      \n  ,oud = a/16./2.*abs(log(.5+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      +.5*log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n  \n  ,synth_drum = a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./m2)\n  + synth(1./8.,a,1./4.,1.,nb*2.,m2/4.))\n  \n  ,harp = a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,2.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.))\n    ,guitar = a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,1.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1.))\n  \n  \n  \n  ;\n  return\n      //sitar\n      //oud\n      //synth_drum\n      //harp\n      \n      //steel_drum\n      abs(gamelan/2.-synth_drum)\n      \n      //abs(gamelan-steel_drum/2.)\n      //abs(gamelan/2.-oud*2.)*2.\n\n      //abs(gamelan-oud*3.)/3.\n      \n      //abs(gamelan-steel_drum/4.)\n      \n      \n      //oud\n      //abs(.5-vec2(fract(nb.x*.998*2.),fract(nb.y)))*a\n      \n      \n      //log(abs(a/4.-2.*abs(.5-vec2(fract(nb*.998*2.),fract(nb*2.)))*a))\n\n      //log(abs(a/8.-abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a))\n  ;\n}\n\nvec2 mainSound(int samp, float time){\n    return\n        \n        //mainSound1(samp,time,5.5,1./2.)\n        //abs(mainSound1(samp,time,5.5,1./2.)-mainSound1(samp,time,6.5,1./2.)/4.)\n\n        //black metal\n        abs(mainSound1(samp,time,7.,1./4.)-mainSound1(samp,time,6.5,1./4.))\n        \n        //amazing breakcore remix!\n        //abs(mainSound1(samp,time/8.,7.,1.)-mainSound1(samp,time,6.,1./8.))\n        \n        //snare drum\n        //abs(mainSound1(samp,time,6.,1./8.)-mainSound1(samp,time,6.5,1./8.))\n        //weird harp remix\n        //mainSound1(samp,time/2.,7.,1./4.)\n        \n        //another harp remix\n        //abs(mainSound1(samp,time,6.,1./4.)+mainSound1(samp,time,7.,1./2.)/2.+mainSound1(samp,time,8.,1.)/4.)\n\n        \n        //drum remix\n        //abs(mainSound1(samp,time,4.5,1./2.)-mainSound1(samp,time,5.5,1./2.)/2.)\n        \n\n    ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MffGzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 129], [131, 131, 153, 153, 1711], [1713, 1713, 1770, 1770, 2030]], "test": "untested"}
{"id": "ctGBWw", "name": "014 - Plot v2", "author": "PiGIon", "description": "Use mouse to zoom, change the #define eqy to input equation\n\nImprovements for the plot shader.\n\nI tried to improve the grid and line rendering.\n\nThere are some unexpected behavior in the plot, for example, pow(x, x) doesn't render correctly.", "tags": ["beginner", "plot"], "likes": 1, "viewed": 190, "published": 3, "date": "1702864304", "time_retrieved": "2024-07-30T17:15:58.114694", "image_code": "// 2022.08.02 rev 1\n// 2022.08.02 rev 2 - fix plot errors for pow when x and y < 0.\n// 2022.08.02 rev 3 - fix plot errors when result isinf\n// 2023.12.17 rev 4 - implement better grid and line thickness, add t constant for time\n\n//#define eqy sin(x)\n//#define eqy x*x*x\n//#define eqy pow(x, x)\n//#define eqy x\n//#define eqy x*x\n//#define eqy pow(x, 4.)\n//#define eqy cos(x-t)\n\n// from https://www.mzrg.com/math/graphs.shtml\n#define eqy div(sin(t*5.+pow(x, x)), pow(2., div((pow(x, x)-PI/2.), PI)))\n\n\n\n// tells if the result is undefined, e.g. pow(-1, -1)\nbool undefinedResult = false;\n\n// avoids undefined behavior when x < 0 && y < 0\nfloat safePow(float x, float y) {\n    if (x < 0. || (x == 0. && y <= 0.))\n        undefinedResult=true;\n    \n    float res = pow(x, y);\n    if (isinf(res))\n        undefinedResult=true;\n\n    return res;\n}\nfloat safeDiv(float x, float y) { return x/(y + 0.00000000001); }\n\n#define PI 3.14159265\n#define pow safePow\n#define div safeDiv\n#define t (iTime+iTimeDelta)\n\n// equation to plot that defines y based on x\n\n\nfloat invuv(float scale, vec2 uv, vec3 res) {\n    return 2. / scale;\n}\n\nfloat gridLine(vec2 c, vec2 fragCoord, float size) {\n    vec2 g = floor(mod(c - fragCoord, size));\n    return g.x*g.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 O;\n    // controls the scale, or, in another word, the zoom of the plot\n    float scale = (iMouse.x + iResolution.x/3.)/iResolution.x + 0.00001;\n    vec2 uv = ((2. * fragCoord - iResolution.xy) / iResolution.y) / scale;\n    \n    // determine the minimum size for a x pixels in the screen\n    float line = scale/iResolution.y * 10.;\n    float antiAlias = (scale * 1.5)/iResolution.y; // higher scale requires more antiAlias\n    \n    vec3 plot = vec3(.96, 0.1, 0.06);\n    vec3 bg = vec3(.993, .992, 0.995);\n    vec3 grid = vec3(0.53, 0.53, 0.53);\n    \n    // distance from center of screen, mod the grid size\n    vec2 ms = floor(vec2(iResolution.x/2., iResolution.y/2.));\n    float gs = (iResolution.y/2.)*scale;\n    float sg = scale > 0.7 ? 10.:5.;\n    float g = gridLine(ms, fragCoord, gs) *\n                gridLine(ms, fragCoord + 1., gs) *\n                gridLine(ms, fragCoord, gs/sg);\n    vec2 d = abs(floor(ms - fragCoord));\n    float h = gs/(sg*2.);\n    float dist = 5. * scale;\n    float dashs = step(h, d.y) + floor(mod(d.x, h)) * floor(mod(d.x+1., h));\n    dashs *= step(h, d.x) + floor(mod(d.y, h)) * floor(mod(d.y+1., h));\n    \n    // cool effect\n    //float g = normalize(floor(mod(abs(ms - fragCoord), gridSize))).y + iTime;\n    bg = mix(grid, bg, g*dashs);\n\n    // calculate function and distance to current pixel\n    float x = uv.x;\n    float yOfx = eqy;\n    vec2 p = vec2(uv.x, yOfx);\n    float delta = step(0.01/scale, distance(uv, p));\n\n    if (!undefinedResult) {\n        O = mix(plot, bg, smoothstep(line - antiAlias, line + antiAlias, delta));\n    } else {\n        O = bg;\n    }\n\n    // Output to screen\n    fragColor = vec4(O, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctGBWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[586, 635, 668, 668, 839], [840, 840, 873, 873, 905], [1047, 1047, 1092, 1092, 1117], [1119, 1119, 1171, 1171, 1239], [1241, 1241, 1298, 1298, 2965]], "test": "untested"}
{"id": "XfXGz7", "name": "GOL but it's RGB", "author": "rafa_br34", "description": "Originally I wanted to exploit the fact that GPU cores are asynchronous and acquire randomness but the buffer is swapped each frame(which I didn't know) so I decided to implement GOL.\nInitialization is done with a \"random\" state per pixel.", "tags": ["visualization", "random"], "likes": 5, "viewed": 189, "published": 3, "date": "1702856401", "time_retrieved": "2024-07-30T17:15:58.862694", "image_code": "void mainImage(out vec4 FragColor, in vec2 FragCoord) {\n    FragColor = READP_V4(C_StateBuffer, FragCoord) * vec4(1.0, 1.0, 1.0, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float Lives(float Neighbors, float Self) {\n    ///*\n    bool Lives = (\n        // Is alive and has 2 or 3 neighbors\n        (Self > 0.5 && (Neighbors == 2.0 || Neighbors == 3.0)) ||\n        // Or has 3 neighbors\n        (Neighbors == 3.0)\n    );\n    //*/\n    \n    /*\n    bool Lives = (\n        (Self > 0.5 && (Neighbors == 2.0 || Neighbors == 3.0 || Neighbors == 1.0)) ||\n        (Neighbors == 1.0 || Neighbors == 3.0)\n        \n    );\n    //*/\n    return Lives ? 1.0 : 0.0;\n}\n\n\n\nvoid mainImage(out vec4 FragColor, in vec2 FragCoord) {\n    #define N(DeltaX, DeltaY) round(READP_V4(C_StateBuffer, ivec2(FragCoord) + ivec2(DeltaX, DeltaY)))\n    \n    if (iFrame <= 1 || READP_V4(iChannel1, ivec2(32, 1)).x > 0.0) {\n        // Low entropy initialization\n        //uint S = RAND_STATE(FragCoord) * uint(iTimeDelta * float(0xFFFFFF)) * TIMESTAMP;\n        \n        // High entropy initialization\n        uint S = RAND_STATE(FragCoord); XORSHIFT32(S); S *= 0x9E3779B9u * TIMESTAMP; XORSHIFT32(S);\n        \n        \n        \n        FragColor = vec4(\n            FUI8((S >> 16) & 0xFFu),\n            FUI8((S >> 8) & 0xFFu),\n            FUI8((S >> 0) & 0xFFu),\n            1.0\n        );\n    }\n    else {\n        vec4 Self = N(0, 0);\n\n        \n        vec4 Neighbors = (\n            N(1,  1) + N(0,  1) + N(-1,  1) +\n            N(1,  0) +          + N(-1,  0) +\n            N(1, -1) + N(0, -1) + N(-1, -1)\n        );\n\n        FragColor = vec4(Lives(Neighbors.x, Self.x), Lives(Neighbors.y, Self.y), Lives(Neighbors.z, Self.z), 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define C_StateBuffer iChannel0\n\n\n#define RESX uint(iResolution.x)\n#define RESY uint(iResolution.y)\n\n#define FLATTEN_V2(Width, Vector) ((Width) * (Vector).y + (Vector).x)\n\n#define READP_V4(Buffer, Position) texelFetch(Buffer, ivec2(Position), 0)\n#define READP_F32(Buffer, Position) READP_V4(Buffer, ivec2(Position) / 4)[FLATTEN_V2(2, ivec2(Position)) % 4]\n#define READP_U8(Buffer, Position) READP_F32(Buffer, ivec2(Position) / 4)[FLATTEN_V2(2, ivec2(Position)) % 4]\n\n#define TIMESTAMP ((uint(iDate.x) - 1970u) * 31557600u) + (uint(iDate.y) * 2629800u) + (uint(iDate.z - 1.0) * 86400u) + uint(iDate.w)\n\n#define READI_V4(Buffer, Index) READP_V4(Buffer, ivec2(uint(Index) % RESX, uint(Index) / RESX))\n#define READI_F32(Buffer, Index) READI_V4(Buffer, uint(Index) / 4u)[uint(Index) % 4u]\n#define READI_U8(Buffer, Index) (uint(READI_F32(Buffer, uint(Index) / 4u)) & (0xFFu << ((Index % 4u) * 8u))) >> ((Index % 4u) * 8u)\n\n#define RAND_STATE(Coord) ((RESX * uint(Coord.y) + uint(Coord.x) + 1u) * (uint(iFrame) + 1u))\n\n#define UI8(V) uint(int(V) % 256)\n#define FUI8(V) float(UI8(V)) / 255.0\n\n#define XORSHIFT32(S) S ^= (S << 13); S ^= (S >> 17); S ^= (S << 5);", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XfXGz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 136]], "test": "untested"}
{"id": "4fs3zN", "name": "Appoximate Oklab Mixing", "author": "krax", "description": "An attempt at writing a faster oklab mixing function, while limiting obvious artefacts.\n", "tags": ["approximation", "colorspace", "oklab"], "likes": 0, "viewed": 137, "published": 3, "date": "1702829894", "time_retrieved": "2024-07-30T17:15:59.618673", "image_code": "/*\n\n    Appoximate Oklab mixing\n    -----------------------\n\n    Oklab is a perceptually coherant colourspace (and tends to blend colours nicely).\n    https://bottosson.github.io/posts/oklab/\n\n    Unfortunatley, it's not exactly cheap to adhoc mix and it's gamut is too akward to be able\n    to reliably store textures with it.\n    \n    This is an attempt to write a fast(er) mixing function, by swapping the cbrt for a sqrt.\n\n    For the most part, it does seem reasonaly similar (and is ~26% cheaper).\n\n    A lot of the presentation layout is based off\n    * GM Shaders: OkLab by Xor (https://www.shadertoy.com/view/ct3Bzj)\n    \n   Bars:\n   * abs(oklab - approx) per channel\n   * oklab\n   * approx oklab\n   * linear mixing\n    \n*/\n\n\n// https://bottosson.github.io/posts/oklab/\nvec3 toLMS(vec3 x)\n{\n    return vec3(\n        dot(x, vec3(0.4122214708f, 0.5363325363f, 0.0514459929f)),\n        dot(x, vec3(0.2119034982f, 0.6806995451f, 0.1073969566f)),\n        dot(x, vec3(0.0883024619f, 0.2817188376f, 0.6299787005f))\n    );\n}\n\nvec3 fromLMS(vec3 x)\n{\n    return vec3(\n        dot(x, vec3( 4.0767416621f, -3.3077115913f,  0.2309699292f)),\n        dot(x, vec3(-1.2684380046f,  2.6097574011f, -0.3413193965f)),\n        dot(x, vec3(-0.0041960863f, -0.7034186147f,  1.7076147010f))\n    );\n}\n\n// 6  x quater rate\n// 6  x half rate\n// 45 x full rate\n//    ~324 cycles\nvec3 oklabMix(vec3 a, vec3 b, float t)\n{\n    a = pow(toLMS(a), vec3(1./3.));\n    b = pow(toLMS(b), vec3(1./3.));\n    vec3 c = mix(a, b, t);\n    return fromLMS(c * c * c);\n}\n\n// 6  x quater rate\n// 36 x full rate\n//    ~240 cycles\nvec3 oklabMixApprox(vec3 a, vec3 b, float t)\n{\n    a = sqrt(toLMS(a));\n    b = sqrt(toLMS(b));\n    vec3 c = mix(a, b, t);\n    return fromLMS(c * c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // A lot of this is based on\n    // GM Shaders: OkLab by Xor\n    // https://www.shadertoy.com/view/ct3Bzj\n    vec3 rgb1 = cos(floor(iTime)*vec3(4,7,8))*+.5+.5;\n    vec3 rgb2 = cos(round(iTime)*vec3(4,7,8))*-.5+.5;\n    \n    vec3 lin1 = pow(rgb1, vec3(2.2));\n    vec3 lin2 = pow(rgb2, vec3(2.2));\n    \n    vec3 linm = pow(mix(lin1, lin2, uv.x), vec3(1./2.2));\n    vec3 oklm = pow(oklabMix(lin1, lin2, uv.x), vec3(1./2.2));\n    vec3 oklam = pow(oklabMixApprox(lin1, lin2, uv.x), vec3(1./2.2));\n    \n    vec3 c = vec3(0.);\n    if(uv.y > .75)\n    {\n        float y = (uv.y - .75) / .25;\n        vec3 err = abs(oklm - oklam);\n        c.x = err.x > y ? 1. : 0.;\n        c.y = err.y > y ? 1. : 0.;\n        c.z = err.z > y ? 1. : 0.;\n        \n    }\n    c = (uv.y < .75) ? oklm  : c;  // oklab\n    c = (uv.y < .50) ? oklam : c;  // approx oklab\n    c = (uv.y < .25) ? linm  : c;  // linear\n\n    //Add border lines for demo\n    c *= min(abs(uv.y-.25)*iResolution.y*.5,1.)*.5+.5;\n    c *= min(abs(uv.y-.5)*iResolution.y*.5,1.)*.5+.5;\n    c *= min(abs(uv.y-.75)*iResolution.y*.5,1.)*.5+.5;\n\n    // Output to screen\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fs3zN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[735, 779, 799, 799, 1025], [1027, 1027, 1049, 1049, 1284], [1286, 1360, 1400, 1400, 1532], [1534, 1590, 1636, 1636, 1740], [1743, 1743, 1800, 1850, 3028]], "test": "untested"}
{"id": "Xcs3zN", "name": "spirograph false-2", "author": "jorge2017a2", "description": "spirograph false-2", "tags": ["2d", "spirograph"], "likes": 25, "viewed": 219, "published": 3, "date": "1702829880", "time_retrieved": "2024-07-30T17:16:00.470396", "image_code": "//por jorge2017a2\n//spirograph false-2\n// 17-dic-2023-\n\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n\n\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordev2(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj+0.05,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj+0.05,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\n\nvec3 spiro(vec2 p, vec3 col)\n{  float d1,d2,d3;\n    vec2 pos=vec2(2.5,0.0);\n    vec2 pos2=vec2(2.5,0.65);\n    int n, nmax;\n    nmax=30;\n    float ang=360.0/float(nmax);\n    float angrad;\n    vec2 p2,p3;\n    float df=9999.9;\n    float df2=9999.9;\n    \n    for(n=0; n<nmax;n++)\n    {   float t=iTime*60.0;\n        \n        angrad=radians(ang*float(n)+t );\n        p2=Rotate(p, pos, angrad);\n        p3=Rotate(p, pos2+p2, angrad+radians(5.0+t));\n        \n        d3= sdCircle(p3,2.0);  //circulo chico\n        d3=abs(d3);\n        df2=min(df2,d3);\n    }\n    \n    col= DrawFigBordeCol(vec3(0.0,1.0,0.0),col,df2,vec3(1.0,0.0,0.0));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = ( 2. * fragCoord - iResolution.xy ) / iResolution.y;\n\tuv-=vec2(-0.5,0.0);\n    float esc=8.0;\n    uv*=esc;\n    vec2 uv0=uv;\n    vec3 col=vec3(1.0);\n    col= spiro(uv,col);\n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xcs3zN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[314, 314, 349, 349, 372], [374, 374, 436, 436, 566], [568, 568, 632, 632, 766], [769, 769, 850, 850, 983], [986, 1002, 1050, 1050, 1128], [1131, 1131, 1161, 1161, 1779], [1781, 1781, 1838, 1838, 2089]], "test": "untested"}
{"id": "Xfl3zN", "name": "spirograph false-1", "author": "jorge2017a2", "description": "spirograph false-1", "tags": ["2d", "spirograph"], "likes": 16, "viewed": 172, "published": 3, "date": "1702829876", "time_retrieved": "2024-07-30T17:16:01.320124", "image_code": "//por jorge2017a2\n//spirograph false-1\n// 17-dic-2023-\n\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordev2(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj+0.05,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj+0.05,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nvec3 spiro(vec2 p, vec3 col)\n{   float d1,d2,d3;\n    float angrad;\n    vec2 p2,p3;\n     int n, nmax;\n    nmax=30;\n    float ang=360.0/float(nmax);\n    vec2 pos=vec2(2.5,0.0);\n    \n    float df=9999.9;\n    float df2=9999.9;\n    \n    for(n=0; n<nmax;n++)\n    {\n        float t=iTime*60.0;\n        t=radians(t);\n        angrad=radians(ang*float(n) )+t;\n        p2=Rotate(p, pos, angrad);\n        d2= sdCircle(p2,3.5+1.5*sin(t)); \n        d2=abs(d2)-0.01;\n        df=min(df,d2);\n    }\n    \n    col= DrawFigBordeCol(vec3(0.0,1.0,0.0),col,df,vec3(0.0,0.15,0.5));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(-0.3,0.0);\n    float esc=8.0;\n    uv*=esc;\n    vec2 uv0=uv;\n    vec3 col=vec3(1.0);\n    col= spiro(uv,col);\n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xfl3zN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[313, 313, 348, 348, 371], [373, 373, 435, 435, 565], [567, 567, 631, 631, 765], [767, 767, 848, 848, 981], [983, 999, 1047, 1047, 1125], [1127, 1127, 1157, 1157, 1701], [1703, 1703, 1760, 1760, 2041]], "test": "untested"}
{"id": "4csGz4", "name": "Fork L spinner IAMDEAD 432", "author": "IAMDEAD", "description": "inspired by the lollipop spinner on android", "tags": ["spinnercircle"], "likes": 0, "viewed": 145, "published": 3, "date": "1702824612", "time_retrieved": "2024-07-30T17:16:02.158881", "image_code": "#define PI 3.14159265359\n#define TPI 6.28318530718\n\nfloat resize(float inputs, float factor, float offset)\n{ \n    return (inputs - 0.5f + offset) / factor + 0.5f - offset; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 screen_res = vec4(iResolution.xy, 1.0 / iResolution.xy);\n    vec2 texcoord = fragCoord * screen_res.zw;\n\n\n    //texcoord.x = resize(texcoord.x, screen_res.x / screen_res.y, 0.0);\n\tvec2 p = texcoord;\n    p -= 0.5;\n    p.x *= screen_res.x * screen_res.w;\n\n\n    float time = iTime / 1.0;\n    p.x = - p.x;\n    \n    float angle = -(time - sin(PI) * cos(time));\n    mat2 rot = mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n    p = rot * p * 1.35;\n    \n    vec3 col = vec3(0.);\n    float L = length(p);\n    float f = 0.;\n    \n    f = smoothstep(L-.007, L, .35);\n    f -= smoothstep(L,L + 0.007, .33);\n    //f = step(sin(L * 200. + iTime * p.x)*.5+.5,.25); // uncomment for a headache\n    \n    float t = mod(time,TPI) - PI;\n    float t1 = -PI;\n    float t2 = (PI );\n    float t3 = (PI - 6.1);\n    \n    float a = atan(p.x,p.y);\n    f = f * step(a,t2);\n    \n    float f_final = f * step(a,t3);\n    \n    \n    vec3 col2 = mix(col,vec3(0.1,0.1,0.1),f);\n    \n    vec3 col3 = mix(col,vec3(cos(time),cos(time + TPI / 3.),cos(time + 2.* TPI/3.)),f_final);\n\n    vec4 t_vp2 = texture(iChannel0, texcoord);\n\n\n    vec4 fragsColor = vec4(col2,0.0) + vec4(col3,0.0);\n\n    if (fragsColor.r > 0.1 || fragsColor.g > 0.1 || fragsColor.b > 0.1)\n        fragsColor.a = 1.0;\n\n\n    fragColor = fragsColor + t_vp2;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4csGz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 108, 108, 174], [176, 176, 233, 233, 1533]], "test": "untested"}
{"id": "XflGR4", "name": "Dancin Seaweet?", "author": "KingJ", "description": "Some Experimentation with the purple coridor shader code.\nWork in progress!!!", "tags": ["abstract", "vortex", "seaweed"], "likes": 2, "viewed": 116, "published": 3, "date": "1702824599", "time_retrieved": "2024-07-30T17:16:03.023569", "image_code": "vec3 seaweetColor = vec3(255., 53., 94.)/vec3(256.);\nvec3 oceanColor = vec3(79., 66., 181.)/vec3(255.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy/iResolution.xy-vec2(.5);\n    uv.y *= iResolution.y/iResolution.x;\n    //uv *= 3.;\n    \n    float dist = length(uv);\n    float angle = atan(uv.y,uv.x);\n    \n    vec2 ruv = uv;\n    uv = vec2(cos(angle+dist*3.),dist+(iTime*0.2));\n    \n    int lineAmount = 9;\n    float lineEndDist = .3;\n    float lineMaxWidth = 1.;\n    float lineSmoothWidth = .3;\n    float centerRotations = 30.;\n    float borderRotations = 10.;\n    float whobles = 10.;\n    \n    float rotations = mix(centerRotations, borderRotations, dist/lineEndDist);\n    \n    vec3 lines = vec3(smoothstep(lineMaxWidth+lineSmoothWidth, lineMaxWidth, .5*cos(angle * float(lineAmount) + cos(sin(iTime*1.5)*rotations) + iTime*borderRotations + sin(iTime*.9)*rotations)+.5 + dist/lineEndDist));\n    vec3 color = mix(oceanColor, seaweetColor, lines);\n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XflGR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 162, 162, 1016]], "test": "untested"}
{"id": "4fsGz4", "name": "Mirror ball projection", "author": "silica163", "description": "mirror ball projection", "tags": ["vfx", "projection", "ball", "mirror", "reflect", "mirrorball"], "likes": 0, "viewed": 160, "published": 3, "date": "1702823570", "time_retrieved": "2024-07-30T17:16:03.921170", "image_code": "vec2 center02lb0(vec2 p){\n    return p*vec2(.5/(iResolution.x/iResolution.y),.5)+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv *= 2.;\n    uv.x = fract(uv.x);\n    uv.y -= .5;\n\n    vec4 c0 = texture(iChannel0,uv);\n    vec4 c1 = texture(iChannel1,uv);\n    if(fragCoord.x < iResolution.x/2.){\n        fragColor = c0;\n    } else {\n        fragColor = c1;\n    }\n    //fragColor = texture(iChannel2,fragCoord/iResolution.xy);\n    \n    vec2 projUv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    vec2 m = (2.*iMouse.xy - iResolution.xy) / iResolution.y;\n    \n    vec2 ra = vec2(PI/2.+m.x*PI,m.y*PI);\n    \n    mat3 rx = mat3(\n    1,0,0,\n    0,sin(ra.y),cos(ra.y),\n    0,-cos(ra.y),sin(ra.y)\n    );\n    \n    mat3 ry = mat3(\n    sin(ra.x), 0, cos(ra.x),\n    0, 1, 0,\n    -cos(ra.x), 0, sin(ra.x)\n    );\n    \n    vec3 look3d = normalize(vec3(projUv,-1)*rx*ry - vec3(0,0,0)*rx*ry);\n    \n    vec2 look2d;\n    float l2dz = sqrt(2.*(look3d.z+1.));\n    look2d.x = look3d.x*(1./l2dz);\n    look2d.y = look3d.y*(1./l2dz);\n    \n    vec4 color2d = texture(iChannel0,center02lb0(look2d));\n    \n    fragColor = color2d;\n    if(fragCoord.x < iResolution.x/2.){\n        float mask = step(1.-length((uv*2.-1.)*vec2(iResolution.x/iResolution.y,1.)),0.);\n        fragColor *= mask;\n        fragColor += c0*(1.-mask);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "mat3 rotx(float a){\n    return mat3(1, 0, 0, 0, sin(a),cos(a),0,-cos(a),sin(a));\n}\n\nmat3 roty(float a){\n    return mat3(sin(a),0,cos(a),0,1,0,-cos(a),0,sin(a));\n}\n\nmat3 rotz(float a){\n    return mat3(sin(a),cos(a),0,-cos(a),sin(a),0,0,0,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv *2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    m = m*2.-1.;\n    m*= 0.;\n    \n    vec2 ra = vec2(PI/2.+m.x*PI,PI/2.+m.y*PI*.5);\n    \n    mat3 rx = mat3(\n    1,0,0,\n    0,sin(ra.y),cos(ra.y),\n    0,-cos(ra.y),sin(ra.y)\n    );\n    \n    mat3 ry = mat3(\n    sin(ra.x), 0, cos(ra.x),\n    0, 1, 0,\n    -cos(ra.x), 0, sin(ra.x)\n    );\n    \n    vec3 ref = vec3(0,0,0);\n    \n    float fb = length(uv);\n    \n    //ref.z = cos(fb*PI);\n    //ref.xy = normalize(uv)*sin(fb*PI);\n    \n    ref.xy = uv;\n    ref.z = sqrt(1.-fb*fb);\n    \n    //ref = reflect(vec3(0,0,-1),ref);\n    \n    ref.x = 2. * ref.z * ref.x;\n    ref.y = 2. * ref.z * ref.y;\n    ref.z = 2. * ref.z * ref.z - 1.;\n    \n    fragColor = vec4(fract(ref),1);\n    fragColor.rg = uv;\n    fragColor = texture(iChannel0,ref*rx*ry)* step(length(uv),1.);\n}", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265", "buffer_b_code": "float MAX = 10.,MIN = .001,STEP = 64.;\n\nfloat dist(vec3 rp){\n    return length(rp) -1.;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0,MIN*10.);\n    return normalize(vec3(\n        dist(p+e.yxx),\n        dist(p+e.xyx),\n        dist(p+e.xxy)\n    ));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv *2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    m = m*2.-1.;\n    m *= 0.;\n    \n    vec2 ra = vec2(PI/2.+m.x*PI,PI/2.+m.y*PI*.5);\n    \n    mat3 rx = mat3(\n    1,0,0,\n    0,sin(ra.y),cos(ra.y),\n    0,-cos(ra.y),sin(ra.y)\n    );\n    \n    mat3 ry = mat3(\n    sin(ra.x), 0, cos(ra.x),\n    0, 1, 0,\n    -cos(ra.x), 0, sin(ra.x)\n    );\n    \n    vec3 c = vec3(0);\n    \n    vec3 ro = vec3(uv,1)*rx*ry;\n    float rl = 0.;\n    float hit = 0.;\n    vec3 rd = normalize(vec3(uv,0)*rx*ry-vec3(ro));\n    vec3 rp = ro + rd*rl;\n    \n    for(float i = 0.; i < STEP; i++){\n        rp = ro + rd * rl;\n        float d = dist(rp);\n        \n        rl += d;\n        if(d >= MAX)break;\n        if(d <= MIN)hit = 1.;\n    }\n    vec3 N = normal(rp);\n    vec3 ref = reflect(rd,N);\n    fragColor = texture(iChannel0,ref)*hit;\n}", "buffer_b_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "struct Ray {\n\tvec3 o;\n\tvec3 p;\n\tvec3 dir;\n\tfloat dist;\n    float hit;\n};\n\nfloat dist(vec3 p){\n\tfloat d = 100.;\n   \n    d= min(d,length(p - 1.) -.5);\n    \n    vec3 cu = abs(p-vec3(0,0,0))-1.;\n    \n    d = (length(max(cu,0.)) + min(0.,max(cu.x,max(cu.y,cu.z))));\n\t\n\treturn -d;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0.,.01);\n    return normalize(vec3(\n        dist(p+e.yxx),\n        dist(p+e.xyx),\n        dist(p+e.xxy)\n    ));\n    \n}\nvoid march(inout Ray r){\n\tfor(int i = 0;i<64;i++){\n\t\tr.p = r.o + r.dist*r.dir;\n\t\tfloat d = dist(r.p);\n        r.dist += d;\n\t\tif(abs(d) <= .0001){\n            r.hit = 1.;\n            break;\n        }\n        if(d > 100.)break;\n\t}\n}\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(mod(rayDir,.5)*2.,1.0);\n    fragColor = vec4(fract(rayDir),1.0);\n    fragColor = vec4(rayDir,1.0);\n    \n    Ray r = Ray(vec3(0),vec3(0),rayDir,0.,0.);\n    march(r);\n    //fragColor = vec4(vec3(dist(rayDir)),1.0);\n    //fragColor = vec4(vec3(1./r.dist),1.0);\n    fragColor.rgb = normal(r.p)*.5+.5;\n    fragColor = texture(iChannel0,rayDir);\n}", "cube_a_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec2 center02lb0(vec2 p){\n    return p*vec2(.5/(iResolution.x/iResolution.y),.5)+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv *2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    m = m*2.-1.;\n    \n    vec2 ra = vec2(PI/2.+m.x*PI,m.y*PI);\n    \n    mat3 rx = mat3(\n    1,0,0,\n    0,sin(ra.y),cos(ra.y),\n    0,-cos(ra.y),sin(ra.y)\n    );\n    \n    mat3 ry = mat3(\n    sin(ra.x), 0, cos(ra.x),\n    0, 1, 0,\n    -cos(ra.x), 0, sin(ra.x)\n    );\n    \n    vec3 look3d = normalize(vec3(uv,-1)*rx*ry - vec3(0,0,0)*rx*ry);\n   \n    /*\n    float fb = length(uv);\n    vec3 ref = vec3(0);\n    ref.xy = uv;\n    ref.z = sqrt(1.-fb*fb);\n    \n    ref.x = 2. * ref.z * ref.x;\n    ref.y = 2. * ref.z * ref.y;\n    ref.z = 2. * ref.z * ref.z - 1.;\n    */\n    \n    vec2 look2d;\n    float l2dz = sqrt(2.*(look3d.z+1.));\n    look2d.x = look3d.x*(1./l2dz);\n    look2d.y = look3d.y*(1./l2dz);\n    \n    vec4 color2d = texture(iChannel0,center02lb0(look2d));\n    fragColor = color2d;\n    //fragColor = texture(iChannel1,look3d);\n}", "buffer_c_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fsGz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 86], [88, 88, 145, 145, 1377]], "test": "untested"}
{"id": "dtGcz3", "name": "Bahaus", "author": "Saimon", "description": "Animated reproduction of this image: https://desenio.fr/p/affiches/peintres-celebres/bauhaus/bauhaus-1923-affiche/", "tags": ["color", "circle", "reproduction", "bahaus"], "likes": 1, "viewed": 169, "published": 3, "date": "1702817606", "time_retrieved": "2024-07-30T17:16:04.747959", "image_code": "/* \"Bahaus\"\n * I wanted to practice GLSL and the primitives describe in https://thebookofshaders.com/07/\n * so I started looking for art images to try to reproduce.\n * This one is the first one of the serie, it follows Bauhaus esthetic, \n * and is based on: https://desenio.fr/p/affiches/peintres-celebres/bauhaus/bauhaus-1923-affiche/\n * (November 2023)(started with 1438 char - Updated 10/01/24)\n */\n\n#define R       iResolution.xy\n\nfloat sdCircle(vec2 p, float r){\n  float w = .8/R.y;\n  return smoothstep(-w,w, length(p) - r);\n}\n\n// r: radius\n// s: size of the border\n// Derived from: http://iquilezles.org/articles/distfunctions2d/\nfloat sdCircleBorder(vec2 p, float r, float s){\n    float d = length(p) - r, //signed distance of circle\n          d2 = abs(d) - s,\n          w = .8/R.y;\n    return smoothstep(-w,w,max(d,d2));\n}\n\n// Simplify version of code: https://thebookofshaders.com/edit.php?log=160909065147\n// and http://www.kynd.info\nfloat easeInOutExpo(float t) {\n  t = exp2(40.*t-10.);\n  return t < 1.\n      ?      .5 * t\n      : 1. - .5 / t;\n}\n\n#define tweenEIOE(t) easeInOutExpo(min(t, 1. -t))\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 st = ( fragCoord.xy*2. -R.xy ) /R.y ;\n  float t = fract((iTime+2.)/3.);\n\n  // Convert hexa color to glsl: https://airtightinteractive.com/util/hex-to-glsl/\n  vec3 YELLOW = vec3(0.941,0.588,(0.004));\n  vec3 ORANGE = vec3(0.914,0.349,0.141);\n  vec3 RED = vec3(0.902,0.118,(0.167));\n\n  // Here the division of the tween aren't random.\n  // Indeed, I want my yellow circle to have a radius of 0.7.\n  // To simulate this I divide tween out value between [0,1] by the number that could give me what I want:\n  // (1. / 1.25 = 0.8); it's the same logic applied to the other circles\n  float c1 = sdCircleBorder(st, tweenEIOE(t)/1.25, 0.251),\n        c2 = sdCircleBorder(st, tweenEIOE(t)/1.8, 0.23),\n        c3 = sdCircle(st, tweenEIOE(t)/3.);\n\n  vec3 col = mix(YELLOW, vec3(1.), c1);\n  col = mix(ORANGE, col, c2);\n  col = mix(RED, col, c3);\n  fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtGcz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[435, 435, 467, 467, 531], [533, 636, 683, 683, 830], [832, 944, 974, 974, 1056], [1109, 1109, 1163, 1163, 2032]], "test": "untested"}
{"id": "XffGRN", "name": "xl cool fonts", "author": "yasuo", "description": "my version of the cool fonts", "tags": ["font", "graphicdesign", "cineshader"], "likes": 30, "viewed": 768, "published": 3, "date": "1702791958", "time_retrieved": "2024-07-30T17:16:05.761250", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.5),-antialiasing(1.5),d - b)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define deg45 .707\n#define R45(p) (( p + vec2(p.y,-p.x) ) *deg45)\n#define Tri(p,s) max(R45(p).x,max(R45(p).y,B(p,s)))\n#define SkewX(a) mat2(1.0,tan(a),0.0,1.0)\n#define SkewY(a) mat2(1.0,0.0,tan(a),1.0)\n#define LINE_THICK 0.005\n#define char_A 10\n#define char_B 11\n#define char_C 12\n#define char_D 13\n#define char_E 14\n#define char_F 15\n#define char_G 16\n#define char_H 17\n#define char_I 18\n#define char_J 19\n#define char_K 20\n#define char_L 21\n#define char_M 22\n#define char_N 23\n#define char_O 24\n#define char_P 25\n#define char_Q 26\n#define char_R 27\n#define char_S 28\n#define char_T 29\n#define char_U 30\n#define char_V 31\n#define char_W 32\n#define char_X 33\n#define char_Y 34\n#define char_Z 35\n\nfloat random (vec2 p) {\n    return fract(sin(dot(p.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat coolFontBase(vec2 p){    \n    float d = abs(p.x)-LINE_THICK;\n    p.x = abs(p.x)-0.1;\n    float d2 = abs(p.x)-LINE_THICK;\n    d = min(d,d2);\n    d = max(abs(p.y)-0.15,d);\n    d = max(-(abs(p.y)-0.05),d);\n    return d;\n}\n\nfloat coolArrow(vec2 p){\n    float a = radians(-45.);\n    float d = abs(dot(p,vec2(cos(a),sin(a))))-LINE_THICK;\n    a = radians(45.);\n    float d2 = abs(dot(p,vec2(cos(a),sin(a))))-LINE_THICK;\n    d = min(d,d2);\n    return d;\n}\n\nfloat coolA(vec2 p){\n    vec2 prevP = p;\n    float d = coolFontBase(p);\n    p.y=abs(p.y)-0.25;\n    float d2 = coolArrow(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x)-0.1;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.15,d2);\n    d = min(d,d2);\n    p = prevP;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(p.y+0.05,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolB(vec2 p){\n    vec2 prevP = p;\n    float d = coolFontBase(p);\n    p.y=abs(p.y)-0.25;\n    float d2 = coolArrow(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x += 0.1;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.15,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    float a = radians(-45.);\n    p.y = abs(p.y)+0.05;\n    d2 = abs(dot(p,vec2(cos(a),sin(a))))-LINE_THICK;\n    d = min(d,d2);\n    \n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolC(vec2 p){\n    vec2 prevP = p;\n    float d = coolFontBase(p);\n    p.y=abs(p.y)-0.25;\n    float d2 = coolArrow(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x += 0.1;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.15,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    float a = radians(-60.);\n    p.y = abs(p.y)+LINE_THICK;\n    d2 = abs(dot(p,vec2(cos(a),sin(a))))-LINE_THICK;\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.1,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolD(vec2 p){\n    vec2 prevP = p;\n    float d = coolFontBase(p);\n    p.y=abs(p.y)-0.25;\n    float d2 = coolArrow(p);\n    p = prevP;\n    d2 = max(-p.x,d2);\n    d = min(d,d2);\n    p.x+=0.1;\n    d2 = abs(p.x)-LINE_THICK;\n    d = min(d,d2);\n    p = prevP;\n    p.y=abs(p.y)-0.25+LINE_THICK;\n    d2 = abs(p.y)-LINE_THICK;\n    d2 = max(p.x-LINE_THICK,d2);\n    d = min(d,d2);\n    p = prevP;\n    \n    p = prevP;\n    p.x = abs(p.x)-0.1;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.15,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.1,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolE(vec2 p){\n    vec2 prevP = p;\n    float d = coolFontBase(p);\n    p.y=abs(p.y)-0.25;\n    float d2 = coolArrow(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    float a = radians(45.);\n    p.y = abs(p.y)+0.05;\n    d2 = abs(dot(p,vec2(cos(a),sin(a))))-LINE_THICK;\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x-=0.05;\n    d2 = coolArrow(p);\n    d2 = max(-prevP.x-LINE_THICK,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolF(vec2 p){\n    vec2 prevP = p;\n    float d = coolFontBase(p);\n    p.y-=0.25;\n    float d2 = coolArrow(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x += 0.1;\n    p.y+=0.1;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.2,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    float a = radians(-45.);\n    p.y+=0.15;\n    d2 = abs(dot(p,vec2(cos(a),sin(a))))-LINE_THICK;\n    d2 = max(p.y-LINE_THICK,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = min(p.x-LINE_THICK,-p.y);\n    d = max(d2,d);\n    \n    p = prevP;\n    a = radians(-45.);\n    p.y+=0.05;\n    d2 = abs(dot(p,vec2(cos(a),sin(a))))-LINE_THICK;\n    d2 = max(-prevP.x-LINE_THICK,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y-=0.05+LINE_THICK;\n    d2 = abs(p.y)-LINE_THICK;\n    d2 = max(-p.x-LINE_THICK,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolG(vec2 p){\n    vec2 prevP = p;\n    float d = coolFontBase(p);\n    p.y=abs(p.y)-0.25;\n    float d2 = coolArrow(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x += 0.1;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.15,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    float a = radians(-60.);\n    p.y += LINE_THICK;\n    d2 = abs(dot(p,vec2(cos(a),sin(a))))-LINE_THICK;\n    d2 = max(-prevP.x,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.1,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y+=0.15;\n    d2 = min(p.x,-p.y);\n    d = max(d2,d);    \n    \n    p = prevP;\n    p.x -= 0.1;\n    p.y+=0.15;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.1,d2);\n    d = min(d,d2);    \n    \n    p = prevP;\n    \n    p.y+=0.15-LINE_THICK;\n    p.y = abs(p.y)-0.1;\n    d2 = abs(p.y)-LINE_THICK;\n    d2 = max(-p.x-LINE_THICK,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolH(vec2 p){\n    vec2 prevP = p;\n    float d = coolFontBase(p);\n    p.y=abs(p.y)-0.25;\n    float d2 = coolArrow(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x)-0.1;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.15,d2);\n    d = min(d,d2);\n    p = prevP;\n    \n    d2 = abs(p.x)-LINE_THICK;\n    \n    d2 = max(-(abs(p.y)-0.05),d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolI(vec2 p){\n    vec2 prevP = p;\n    float d = coolFontBase(p);\n    p.y=abs(p.y)-0.25;\n    float d2 = coolArrow(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x)-0.05;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.2,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = min(-(abs(p.x)-0.01),-(abs(p.y)-0.16));\n    d = max(d2,d);\n    \n    p = prevP;\n    return max(abs(p.x)-0.05-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolJ(vec2 p){\n    vec2 prevP = p;\n    float d = coolFontBase(p);\n    p.y=abs(p.y)-0.25;\n    float d2 = coolArrow(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x)-0.1;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.15,d2);\n    d = min(d,d2);\n    p = prevP;\n    p.y-=0.1;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.16,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = min(-p.x-LINE_THICK,p.y+0.05);\n    d = max(d2,d);    \n    \n    p = prevP;\n    float a = radians(-45.);\n    p.y-=0.05;\n    d2 = abs(dot(p,vec2(cos(a),sin(a))))-LINE_THICK;\n    d2 = max(prevP.x,d2);\n    d = min(d,d2);    \n    \n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolK(vec2 p){\n    vec2 prevP = p;\n    float d = coolFontBase(p);\n    p.y=abs(p.y)-0.25;\n    float d2 = coolArrow(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x += 0.1;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.15,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(-(abs(p.y)-0.05),d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    float a = radians(-45.);\n    p.y = abs(p.y)+0.05;\n    d2 = abs(dot(p,vec2(cos(a),sin(a))))-LINE_THICK;\n    d = min(d,d2);\n    \n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolL(vec2 p){\n    vec2 prevP = p;\n    float d = coolFontBase(p);\n    d = max(p.x-LINE_THICK,d);\n    d = max(-p.y-0.14,d);\n    \n    p.x += 0.1;\n    p.y+=0.1;\n    float d2 = abs(p.x)-LINE_THICK;\n    d = min(d,d2);\n    \n    p = prevP;\n    float a = radians(45.);\n    p.y-=0.15;\n    d2 = abs(dot(p,vec2(cos(a),sin(a))))-LINE_THICK;\n    d2 = max(prevP.x-LINE_THICK,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    a = radians(45.);\n    p.y+=0.14;\n    d2 = abs(dot(p,vec2(cos(a),sin(a))))-LINE_THICK;\n    d2 = max(-prevP.x-LINE_THICK,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y+=0.25-LINE_THICK;\n    d2 = abs(p.y)-LINE_THICK;\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max((abs(p.y)-0.06),d2);\n    d = min(d,d2);    \n    \n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolM(vec2 p){\n    vec2 prevP = p;\n    float d = coolFontBase(p);\n    d = max(p.y,d);\n    p.y+=0.25;\n    float d2 = coolArrow(p);\n    d = min(d,d2);\n    p = prevP;\n    p.y-=0.15;\n    d2 = coolArrow(p);\n    d2 = max(-p.y,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x)-0.1;\n    p.y-=0.05;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.2,d2);\n    d = min(d,d2);\n    p = prevP;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(p.y+0.05,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolN(vec2 p){\n    vec2 prevP = p;\n    float d = coolFontBase(p);\n    d = max(p.y,d);\n    p.y+=0.15;\n    float d2 = coolArrow(p);\n    d2 = max(p.y,d2);\n    d = min(d,d2);\n    p = prevP;\n    p.y-=0.25;\n    d2 = coolArrow(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x)-0.1;\n    p.y+=0.05;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.2,d2);\n    d = min(d,d2);\n    p = prevP;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.15-LINE_THICK,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolO(vec2 p){\n    vec2 prevP = p;\n    float d = coolFontBase(p);\n    p.y=abs(p.y)-0.25;\n    float d2 = coolArrow(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x)-0.1;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.15,d2);\n    d = min(d,d2);\n    p = prevP;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.1,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolP(vec2 p){\n    vec2 prevP = p;\n    float d = coolFontBase(p);\n    p.y-=0.25;\n    float d2 = coolArrow(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x += 0.1;\n    p.y+=0.1;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.2,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    float a = radians(-45.);\n    p.y+=0.15;\n    d2 = abs(dot(p,vec2(cos(a),sin(a))))-LINE_THICK;\n    d2 = max(p.y-LINE_THICK,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = min(p.x-LINE_THICK,-p.y);\n    d = max(d2,d);\n    \n    p = prevP;\n    a = radians(-45.);\n    p.y+=0.05;\n    d2 = abs(dot(p,vec2(cos(a),sin(a))))-LINE_THICK;\n    d2 = max(-prevP.x-LINE_THICK,d2);\n    d = min(d,d2);\n\n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolQ(vec2 p){\n    p*=vec2(1.2,1.);\n    vec2 prevP = p;\n    float d = coolO(p);\n    \n    p.x-=0.073;\n    float d2 = abs(p.x)-0.022;\n    p.y+=0.15;\n    d2 = max(abs(p.y)-0.03,d2);\n    d = max(-d2,d);\n    p = prevP;\n    p.y+=0.175;\n    d2 = abs(p.y)-0.019;\n    d2 = max(-(p.x-LINE_THICK),d2);\n    d = max(-d2,d);\n    \n    p = prevP;\n    d2 = max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n    d = min(d,d2);\n    \n    float a = radians(45.);\n    p.y+=0.051;\n    d2 = abs(dot(p,vec2(cos(a),sin(a))))-(LINE_THICK+0.002);\n    d2 = max(-prevP.x+0.095,d2);\n    d2 = max(prevP.x-0.15,d2);\n    d = min(d,d2);     \n    p = prevP;\n    \n    p.y+=0.2;\n    d2 = abs(p.y)-(LINE_THICK+0.001);\n    d2 = max(-p.x+0.05,d2);\n    d2 = max(p.x-0.15,d2);\n    d = min(d,d2);     \n    p = prevP;\n    \n    d = max(p.x-0.145,d);\n    \n    return d;\n}\n\nfloat coolR(vec2 p){\n    vec2 prevP = p;\n    float d = coolB(p);\n    \n    p = prevP;\n    p.y+=0.25;\n    float d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.1,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolS(vec2 p){\n    vec2 prevP = p;\n    float d = coolFontBase(p);\n    float a = radians(-45.);\n    p.y=abs(p.y)-0.25;\n    float d2 = coolArrow(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y+=0.05;\n    a = radians(45.);\n    d2 = max(prevP.x-LINE_THICK,abs(dot(p,vec2(cos(a),sin(a))))-LINE_THICK);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x-=0.1;\n    p.y+=0.05;\n    a = radians(45.);\n    d2 = max(-prevP.x-LINE_THICK,abs(dot(p,vec2(cos(a),sin(a))))-LINE_THICK);\n    d = min(d,d2);\n    \n    p = prevP;\n    a = radians(-62.);\n    d2 = abs(dot(p,vec2(cos(a),sin(a))))-LINE_THICK;\n    p = prevP;\n    a = radians(45.);\n    d2 = max(-(abs(dot(p,vec2(cos(a),sin(a))))-0.035),d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolT(vec2 p){\n    vec2 prevP = p;\n    float d = coolI(p);\n    d = max(p.y-0.15,d);\n    \n    p = prevP;\n    float a = radians(-45.);\n    \n    p.x = abs(p.x)-0.15;\n    p.x*=-1.;\n    p.y-=0.2;\n    p.y = abs(p.y)+0.05;\n    float d2 = abs(dot(p,vec2(cos(a),sin(a))))-LINE_THICK;\n    p = prevP;\n    d2 = max(-(abs(p.x)-(0.05-LINE_THICK)),d2);\n    d = min(d,d2);    \n    \n    p.y-=0.25-LINE_THICK;\n    d2 = abs(p.y)-LINE_THICK;\n    d2 = max((abs(p.x)-(0.05+LINE_THICK)),d2);\n    d = min(d,d2);  \n    \n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolU(vec2 p){\n    vec2 prevP = p;\n    float d = coolO(p);\n    p.y-=0.25;\n    float d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.1,d2);\n    d = min(d,d2);\n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolV(vec2 p){\n    vec2 prevP = p;\n    float d = coolFontBase(p);\n    p.y+=0.25;\n    float d2 = coolArrow(p);\n    d = min(d,d2);\n    p = prevP;\n    p.y-=0.15;\n    d2 = coolArrow(p);\n    d2 = max(-p.y,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y-=0.05;\n    p.x = abs(p.x)-0.1;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.2,d2);\n    d = min(d,d2);\n    p = prevP;\n    p.y-=0.01;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.15,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolW(vec2 p){\n    vec2 prevP = p;\n    float d = coolFontBase(p);\n    p.y+=0.15;\n    float d2 = coolArrow(p);\n    d2 = max(p.y,d2);\n    d = min(d,d2);\n    p = prevP;\n    p.y-=0.25;\n    d2 = coolArrow(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y+=0.05;\n    p.x = abs(p.x)-0.1;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.2,d2);\n    d = min(d,d2);\n    p = prevP;\n    p.y-=0.15;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(abs(p.y)-0.2,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y+=0.1;\n    d2 = min(-(abs(p.x)-0.03), -(abs(p.y)-0.05));\n    d = max(d2,d);\n    \n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolX(vec2 p){\n    vec2 prevP = p;\n    float d = coolFontBase(p);\n    p = prevP;\n    p.y=abs(p.y)-0.15;\n    float d2 = coolArrow(p);\n    d2 = max(-p.y,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    float a = radians(-45.);\n    p.y = abs(p.y)+0.05;\n    d2 = abs(dot(p,vec2(cos(a),sin(a))))-LINE_THICK;\n    d = min(d,d2);\n    \n    p = prevP;\n    a = radians(45.);\n    p.y = abs(p.y)+0.05;\n    d2 = abs(dot(p,vec2(cos(a),sin(a))))-LINE_THICK;\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x)-0.1;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(-(abs(p.y)-0.05),d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolY(vec2 p){\n    vec2 prevP = p;\n    float d = coolFontBase(p);\n    float a = radians(-45.);\n    p.y+=0.25;\n    float d2 = coolArrow(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y-=0.15;\n    d2 = coolArrow(p);\n    d2 = max(-p.y,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y+=0.05;\n    a = radians(45.);\n    d2 = max(prevP.x-LINE_THICK,abs(dot(p,vec2(cos(a),sin(a))))-LINE_THICK);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x -= 0.1;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max((abs(p.y)-0.05),d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    a = radians(-62.);\n    d2 = abs(dot(p,vec2(cos(a),sin(a))))-LINE_THICK;\n    p = prevP;\n    a = radians(45.);\n    d2 = max(-(abs(dot(p,vec2(cos(a),sin(a))))-0.035),d2);\n    d2 = max(p.x,d2);\n    d = min(d,d2);\n    \n    p.x = abs(p.x)-0.1;\n    d2 = abs(p.x)-LINE_THICK;\n    d2 = max(-p.y+0.05,d2);\n    d = min(d,d2);    \n    \n    p = prevP;\n    return max(abs(p.x)-0.1-LINE_THICK,max(abs(p.y)-0.25,d));\n}\n\nfloat coolZ(vec2 p){\n    vec2 prevP = p;\n    p.x*=-1.0;\n    float d = coolS(p);\n    return d;\n}\n\nfloat checkChar(int targetChar, int char){\n    return 1.-abs(sign(float(targetChar) - float(char)));\n}\n\nfloat drawFont(vec2 p, int char){\n    float dd=length(p*2.);\n    float z = sqrt(1.0 - dd * dd);\n    float r = atan(dd, z) / 3.14159;\n    float a = atan(p.y, p.x)*0.01;\n    \n    p *= vec2(r*cos(a)-0.65,r*sin(a)-0.95);\n    \n    float d = coolA(p)*checkChar(char_A,char);\n    d += coolB(p)*checkChar(char_B,char);\n    d += coolC(p)*checkChar(char_C,char);\n    d += coolD(p)*checkChar(char_D,char);\n    d += coolE(p)*checkChar(char_E,char);\n    d += coolF(p)*checkChar(char_F,char);\n    d += coolG(p)*checkChar(char_G,char);\n    d += coolH(p)*checkChar(char_H,char);\n    d += coolI(p)*checkChar(char_I,char);\n    d += coolJ(p)*checkChar(char_J,char);\n    d += coolK(p)*checkChar(char_K,char);\n    d += coolL(p)*checkChar(char_L,char);\n    d += coolM(p)*checkChar(char_M,char);\n    d += coolN(p)*checkChar(char_N,char);\n    d += coolO(p)*checkChar(char_O,char);\n    d += coolP(p)*checkChar(char_P,char);\n    d += coolQ(p)*checkChar(char_Q,char);\n    d += coolR(p)*checkChar(char_R,char);\n    d += coolS(p)*checkChar(char_S,char);\n    d += coolT(p)*checkChar(char_T,char);\n    d += coolU(p)*checkChar(char_U,char);\n    d += coolV(p)*checkChar(char_V,char);\n    d += coolW(p)*checkChar(char_W,char);\n    d += coolX(p)*checkChar(char_X,char);\n    d += coolY(p)*checkChar(char_Y,char);\n    d += coolZ(p)*checkChar(char_Z,char);\n    \n    return d;\n}\n\nfloat bg(vec2 p){\n    p.x+=iTime*0.125;\n    p = mod(p,0.03)-0.015;\n    return min(abs(p.y)-0.0001,abs(p.x)-0.0001);\n}\n\nfloat arrow(vec2 p){\n    vec2 prevPv = p;\n    p.x = abs(p.x)-0.35;\n    p.x+=iTime*0.1;\n    p.x = mod(p.x,0.1)-0.05;\n    p*=Rot(radians(-90.));\n    p.x*=1.5;\n    float d = Tri(p,vec2(0.05));\n    p = prevPv;\n    d = max(-(abs(p.x)-0.33),d);\n    d = max((abs(p.x)-0.45),d);\n    return d;\n}\n\nfloat fonts(vec2 p){\n    p*=4.0;\n    p.x+=iTime*0.5;\n    vec2 gv = fract(p)-0.5;\n    vec2 id = floor(p);\n\n    float n = random(id)*float(char_Z-char_A);\n    \n    float size = 0.7;\n    int char = int(mod(float(int(n)+char_A)+iTime*0.1*float(n),float(char_Z-char_A)+1.0))+char_A;\n    float d = drawFont(gv*size,char);\n    float d2 = arrow(gv);\n    d = min(d,d2);\n    return d;\n}\n\nfloat plus(vec2 p){\n    float d = B(p,vec2(0.004,0.05));\n    float d2 = B(p,vec2(0.05,0.004));\n    return min(d,d2);\n}\n\nfloat graphic(vec2 p){\n    p*=4.0;\n    p.x+=iTime*0.5;\n    p+=0.5;\n    vec2 gv = fract(p)-0.5;\n    vec2 id = floor(p);\n\n    float d = plus(gv);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 prevP = p;\n\n    vec3 col = vec3(0.0);\n    float d = bg(p);\n    col = mix(col,vec3(0.5),S(d,0.0));\n    d = fonts(p);\n    col = mix(col,vec3(1.),S(d,0.0));\n    d = graphic(p);\n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XffGRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[921, 921, 944, 944, 1017], [1019, 1019, 1046, 1046, 1243], [1245, 1245, 1269, 1269, 1472], [1474, 1474, 1494, 1494, 1916], [1918, 1918, 1938, 1938, 2407], [2409, 2409, 2429, 2429, 3004], [3006, 3006, 3026, 3026, 3704], [3706, 3706, 3726, 3726, 4192], [4194, 4194, 4214, 4214, 5082], [5084, 5084, 5104, 5104, 6073], [6075, 6075, 6095, 6095, 6535], [6537, 6537, 6557, 6557, 6977], [6979, 6979, 6999, 6999, 7689], [7691, 7691, 7711, 7711, 8284], [8286, 8286, 8306, 8306, 9129], [9131, 9131, 9151, 9151, 9694], [9696, 9696, 9716, 9716, 10274], [10276, 10276, 10296, 10296, 10722], [10724, 10724, 10744, 10744, 11479], [11481, 11481, 11501, 11501, 12312], [12314, 12314, 12334, 12334, 12583], [12585, 12585, 12605, 12605, 13372], [13374, 13374, 13394, 13394, 13953], [13955, 13955, 13975, 13975, 14199], [14201, 14201, 14221, 14221, 14764], [14766, 14766, 14786, 14786, 15430], [15432, 15432, 15452, 15452, 16109], [16111, 16111, 16131, 16131, 17073], [17075, 17075, 17095, 17095, 17170], [17172, 17172, 17214, 17214, 17274], [17276, 17276, 17309, 17309, 18615], [18617, 18617, 18634, 18634, 18734], [18736, 18736, 18756, 18756, 19022], [19024, 19024, 19044, 19044, 19400], [19402, 19402, 19421, 19421, 19520], [19522, 19522, 19544, 19544, 19681], [19683, 19683, 19740, 19740, 20058]], "test": "untested"}
{"id": "Mcl3zH", "name": "Great Fairy Fountain (chiptune)", "author": "aerowave", "description": "Multivoice chiptune synthesizer\nMusic: Great Fairy Fountain - by Koji Kondo\n\nupdate: added 2nd half of song and decay to main melody", "tags": ["sound", "chiptune"], "likes": 9, "viewed": 272, "published": 3, "date": "1702790428", "time_retrieved": "2024-07-30T17:16:06.516232", "image_code": "// Music: Great Fairy Fountain - by Koji Kondo\n\n// Main code is in Common tab\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    float height = texture(iChannel0, vec2(uv.x, 0.0)).x;\n    float alt = texture(iChannel0, vec2(uv.x + 1.0 / iResolution.y, 0.0)).x;\n    \n    if ((abs(height - uv.y) < 1.0 / iResolution.y) || (height > uv.y && alt < uv.y) || (height < uv.y && alt > uv.y))\n    col = vec3(1);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float TWO_PI = asin(1.0) * 4.0;\n\n// simple sawtooth is used as base for all chip waves\nfloat sawtooth(float t) {return mod(t, 1.0);}\nfloat pulseWidth(float t, float width) {return float(sawtooth(t) < 0.25);}\nfloat squareWave(float t) {return pulseWidth(sawtooth(t), 0.5);}\nfloat triangleWave(float t) {return abs(2.0 * sawtooth(t) - 1.0);}\n\n// note refers to the number of semitones away from middle c\nfloat getFreq(int note) {\n    return 440.0 * pow(2.0, float(note - 9) / 12.0);\n}\n\nfloat voice1(float time) {\n    int[] notes = int[](\n        33,26,22,19,31,26,22,19,30,26,22,19,31,26,22,19,\n        31,24,21,17,29,24,21,17,28,24,21,17,29,24,21,17,\n        29,22,19,16,28,22,19,16,27,22,19,16,28,22,19,16,\n        28,21,17,14,26,21,17,14,25,21,17,14,26,21,17,14,\n        33,26,22,19,31,26,22,19,30,26,22,19,31,26,22,19,\n        34,27,24,18,33,27,24,18,32,27,24,18,33,27,24,18,\n        36,26,22,19,34,26,22,19,33,26,22,19,34,26,22,19,\n        33,22,19,16,31,22,19,16,29,22,19,16,28,22,19,16\n    );\n\n    float prog = mod(time * 5.0, 1.0);\n\n    float phase = time * getFreq(notes[int(time * 5.0) % notes.length()]);\n\n    return pulseWidth(phase, 0.25) * (1.0 - prog);\n}\n\nfloat voice2(float time) {\n    int br = -99999; // silence\n\n    int[] notes = int[](\n        -14,-2,2,9,br,br,br,br,-14,2,9,7,12,9,7,2,\n        -15,-3,0,7,br,br,br,br,-15,-3,7,5,12,7,5,0,\n        -17,-5,-2,5,br,br,br,br,-17,-5,5,4,7,4,0,-2,\n        -19,-7,-3,4,br,br,br,br,-19,-7,4,2,7,5,12,10,\n        -14,-2,2,9,br,br,br,br,-14,2,9,7,14,9,7,2,\n        -15,-3,0,12,br,br,br,br,-10,2,12,9,15,14,12,9,\n        -17,-2,2,10,br,br,br,br,-17,-2,10,9,12,10,7,2,\n        -12,0,7,10,br,br,br,br,-12,0,10,7,16,14,19,16\n    );\n    \n    \n    int note = notes[int(time * 5.0) % notes.length()];\n    if (note == br) return 0.0;\n    \n    float prog = mod(time * 5.0, 1.0);\n    \n    float phase = time * getFreq(notes[int(time * 5.0) % notes.length()]);\n    \n    return sawtooth(phase);\n}", "sound_code": "const float VOLUME = 0.1;\n\nvec2 mainSound( int samp, float time ) {\n    return vec2(voice2(time) + voice1(time)) * VOLUME;\n}", "sound_inputs": [], "buffer_a_code": "// stores height values for wave render\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y > 1.0) return;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    if (uv.x < 0.5) {\n        uv.x *= 2.0;\n        col = vec3(voice1(iTime + uv.x * iTimeDelta / 4.0));\n    } else {\n        uv.x = 2.0 * (uv.x - 0.5);\n        col = vec3(voice2(iTime + uv.x * iTimeDelta / 4.0));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mcl3zH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 136, 187, 596]], "test": "untested"}
{"id": "lfs3R8", "name": "Mixed Together ", "author": "kilika", "description": "Mixed Together  ", "tags": ["mixedtogether"], "likes": 3, "viewed": 161, "published": 3, "date": "1702763828", "time_retrieved": "2024-07-30T17:16:07.264231", "image_code": "\n\nfloat grayscale(float x) {\n    // Apply a non-linear transformation to x to increase contrast\n    // This example uses a simple quadratic curve for the contrast effect\n    x = clamp(x, 0.0, 1.0); // ensure x is in the range [0, 1]\n    float contrastFactor = 3.5; // adjust this value to increase or decrease contrast\n    x = 0.5 - contrastFactor * (x - 1.5) * (x - 0.5);\n\n    return clamp(x, 0.0, 1.0); // re-clamp x to the range [0, 1]\n}\n\nvec4 colormap(float x) {\n    float gray = grayscale(x);\n    return vec4(gray, gray, gray, 1.0);\n}\n// https://iquilezles.org/articles/warp\n/*float noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = textureLod(iChannel0,(p+vec2(0.5,0.5))/256.0,0.0).x;\n\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))/256.0,0.0).x;\n\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))/256.0,0.0).x;\n\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))/256.0,0.0).x;\n    return mix(mix( a, b,f.x), mix( c, d,f.x),f.y);\n}*/\n\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.500000*noise( p + iTime  ); p = mtx*p*2.02;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.015625*noise( p + sin(iTime) );\n\n    return f/0.96875;\n}\n\nfloat pattern( in vec2 p )\n{\n\treturn fbm( p + fbm( p + fbm( p ) ) );\n}\n\nfloat glow(vec3 color, float baseRadius, float time, float alpha) {\n    // Calculate the brightness of the color\n    float brightness = dot(color, vec3(0.299, 0.587, 0.114));\n\n    // Sinusoidal variation of the radius\n    float radius = baseRadius + sin(time) * 0.5; // Adjust 0.5 to change the amplitude of the radius variation\n\n    // Adjust glow based on the alpha value from color3\n    float adjustedGlow = brightness * max(radius, 0.0) * alpha;\n\n    return adjustedGlow; // Return the adjusted glow intensity\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Get texture colors\n    vec4 color1 = texture(iChannel0, uv);\n    vec4 color2 = texture(iChannel1, uv);\n    vec4 color3 = texture(iChannel2, uv);\n\tfloat shade = pattern(uv);\n    fragColor = vec4(colormap(shade).rgb, shade);\n/*\n    vec2 uv2 =  (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    for(float i = 1.0; i < 10.0; i++){\n        uv2.x += 0.6 / i * cos(i * 2.5* uv2.y + iTime);\n        uv2.y += 0.6 / i * cos(i * 1.5 * uv2.x + iTime);\n    }\n    \n    vec4 fragColor2 = vec4(vec3(0.1)/abs(sin(iTime-uv2.y-uv2.x)),1.0);\n*/\n    // Mix the two colors based on noise alpha\n    vec4 mixedColor = mix(color1, color2, fragColor);\n\n    // Output the final color\n    // fragColor = mixedColor;\n    vec4 color = vec4(colormap(shade).rgb, shade);\n\n\n    // Calculate glow\n    // Apply the glow effect with sinusoidal radius\n    float glowStrength = glow(mixedColor.rgb, 0.5, iTime, shade ); // Using color3's alpha\n    float glowStrength2 = glow(mixedColor.rgb, 1.5, iTime*2.0, shade ); // Using color3's alpha\n\n    // Apply glow effect\n    vec3 glowColor = mixedColor.rgb + glowStrength *glowStrength2;\n\n    // Final color output\n    fragColor = vec4(glowColor, 1.0);\n    \n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lfs3R8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 28, 169, 440], [442, 442, 466, 466, 539], [997, 997, 1017, 1017, 1087], [1089, 1089, 1109, 1109, 1344], [1399, 1399, 1420, 1420, 1747], [1749, 1749, 1777, 1777, 1819], [1821, 1821, 1888, 1933, 2336], [2338, 2338, 2392, 2442, 3684]], "test": "untested"}
{"id": "lclGz8", "name": "Demonic Pinball Cluster", "author": "KanleyStubrick", "description": "I made this version a single color scheme and played with the movement a bit. Thanks to FabriceNeyret2 for this design!\nYou can download a wallpaper version here: https://steamcommunity.com/sharedfiles/filedetails/?id=3115634910", "tags": ["red", "gravity", "orbs"], "likes": 6, "viewed": 294, "published": 3, "date": "1702760425", "time_retrieved": "2024-07-30T17:16:08.023202", "image_code": "#define POINTS 100  \t\t // number of stars\n\n// --- GUI utils\n\nfloat t;\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\n\n// --- math utils\n\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\n\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\nvec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\n\t\n\n\n// === main ===================\n\n// motion of stars\nvec2 P(float i) {\n\tvec4 c = hash4(i);\n\treturn vec2(   cos(t*c.x-c.z)+.15*cos(0.765*t*c.y+c.w),\n\t\t\t\t ( sin(t*c.y-c.w)+.15*sin(1.893*t*c.x+c.z) )/0.5\t );\n}\n\n// ---\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime;\n\tvec2 uv    = 2.*(fragCoord.xy / iResolution.y - vec2(.8,.5));\n\tfloat m = (iMouse.z<=0.) ? .1*t/6.283 : .5*iMouse.x/iResolution.x;\n\tfloat my = (iMouse.z<=0.) ? .5*pow(.5*(1.-cos(.1*t)),3.) : iMouse.y/iResolution.y;\n\tint MODE = int(mod( (iMouse.z<=0.) ? 100.*m : 6.*m ,3.));\n\tfloat fMODE = (1.-cos(6.283*m))/2.;\n\n\tconst int R = 1;\n\t\n\tfloat v=0.; vec2 V=vec2(0.);\n\tfor (int i=1; i<POINTS; i++) { // sums stars\n\t\tvec2 p = P(float(i));\n\t\tfor (int y=-R; y<=R; y++)  // ghost echos in cycling universe\n\t\t\tfor (int x=-R; x<=R; x++) {\n\t\t\t\tvec2 d = p+2.*vec2(float(x),float(y)) -uv; // pixel to star\n\t\t\t\tfloat r2 = dot(d,d);\n\t\t\t\tr2 = clamp(r2,5e-2*my,1e3);\n\t\t\t\tV +=  d / r2;  // gravity force field\n\t\t\t}\n\t\t}\n\t\n\tv = length(V);\n\tv *= 1./(9.*float(POINTS));\n\t//v = clamp(v,0.,.1);\n\t\n\tv *= 2.+100.*fMODE;\n\tif (MODE==0) fragColor = vec4(.2*v)+smoothstep(.05,.0,abs(v-5.*my))*vec4(1,0,0,0);\n\tif (MODE==1) fragColor = vec4(.2*v)+smoothstep(.05,.0,abs(v-5.*my))*vec4(1,0,0,0);\n\tif (MODE==2) fragColor = vec4(.2*v)+smoothstep(.05,.0,abs(v-5.*my))*vec4(1,0,0,0);\n\n\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lclGz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 98, 98, 171], [193, 193, 224, 224, 257], [259, 259, 281, 281, 325], [326, 326, 348, 348, 383], [384, 384, 406, 406, 463], [501, 520, 537, 537, 673], [683, 683, 740, 740, 1803]], "test": "untested"}
{"id": "4fsGR8", "name": "game of life simulator", "author": "janpitokiala", "description": "press r to reset, change rules in common tab, click to randomize cells", "tags": ["gameoflife"], "likes": 1, "viewed": 87, "published": 3, "date": "1702760039", "time_retrieved": "2024-07-30T17:16:08.904845", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float heat = textureLod(iChannel0, uv, 3.).r-.01;\n    \n    fragColor = vec4(max(heat/fwidth(heat),0.),vec3(0.))+texture(iChannel1,uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define P(x,y) neighborhood+=S(x,y)\n#ifdef REPEAT\n#define S(x,y) int(texelFetch(iChannel0,ivec2(mod(fragCoord+vec2(x,y),iResolution.xy)),0).r)\n#else\n#define S(x,y) int(texelFetch(iChannel0,ivec2(fragCoord)+ivec2(x,y),0).r)\n#endif\n#define R(x) if(neighborhood==x){color=1.;}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame<=10||texelFetch(iChannel2, ivec2(82,1), 0).r>0.5||(distance(iMouse.xy,fragCoord)<10.&&iMouse.z>0.)) {\n      fragColor = vec4(vec3(step(1.-(SOUP_DENSITY),texture(iChannel1,fragCoord/iResolution.y+iDate.w).r)),1.);\n      return;\n    }\n    int neighborhood = 0;\n    P(-1,-1);P(0,-1);P(1,-1);\n    P(-1,0);         P(1,0);\n    P(-1,1); P(0,1); P(1,1);\n    float color = 0.;\n    if(S(0,0)==0) {\n      b\n    } else {\n      s\n    }\n    fragColor = vec4(vec3(color),1.0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define P(x,y) neighborhood+=S(x,y)\n#ifdef REPEAT\n#define S(x,y) int(texelFetch(iChannel0,ivec2(mod(fragCoord+vec2(x,y),iResolution.xy)),0).r)\n#else\n#define S(x,y) int(texelFetch(iChannel0,ivec2(fragCoord)+ivec2(x,y),0).r)\n#endif\n#define R(x) if(neighborhood==x){color=1.;}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int neighborhood = 0;\n    P(-1,-1);P(0,-1);P(1,-1);\n    P(-1,0);         P(1,0);\n    P(-1,1); P(0,1); P(1,1);\n    float color = 0.;\n    if(S(0,0)==0) {\n      b\n    } else {\n      s\n    }\n    fragColor = vec4(vec3(color),1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define P(x,y) neighborhood+=S(x,y)\n#ifdef REPEAT\n#define S(x,y) int(texelFetch(iChannel0,ivec2(mod(fragCoord+vec2(x,y),iResolution.xy)),0).r)\n#else\n#define S(x,y) int(texelFetch(iChannel0,ivec2(fragCoord)+ivec2(x,y),0).r)\n#endif\n#define R(x) if(neighborhood==x){color=1.;}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int neighborhood = 0;\n    P(-1,-1);P(0,-1);P(1,-1);\n    P(-1,0);         P(1,0);\n    P(-1,1); P(0,1); P(1,1);\n    float color = 0.;\n    if(S(0,0)==0) {\n      b\n    } else {\n      s\n    }\n    fragColor = vec4(vec3(color),1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = mix(vec4(vec3(abs(texture(iChannel0, uv).r-texture(iChannel1, uv).r)),1.),texture(iChannel2, uv),0.9);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define REPEAT\n#define SOUP_DENSITY 0.5\n#define b R(3)\n#define s R(2) else R(3)", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fsGR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 288]], "test": "untested"}
{"id": "Xcs3zH", "name": "rainbow color.flow", "author": "nide", "description": "Fork of https://www.shadertoy.com/view/DddGDs", "tags": ["colorful", "vortex", "polar", "calming"], "likes": 11, "viewed": 320, "published": 3, "date": "1702754685", "time_retrieved": "2024-07-30T17:16:09.691741", "image_code": "#define PI 3.14159265359\n#define TWO_PI 2. * PI\n#define ITERATIONS 30.\n\nvec4 k_orb(vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvec3 k_rainbow(float progress, float stretch, float offset) {\n  return vec3(cos(vec3(-2, 0, -1) * TWO_PI / 3. + TWO_PI * (progress * stretch) + offset) * 0.5 + 0.5);\n}\n\nmat2 k_rotate2d(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float time = iTime / 32.8;\n  vec2 uv = -1. + 2. * fragCoord.xy / iResolution.xy;\n  uv.x *= iResolution.x/iResolution.y;\n  uv *= 0.08;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(time); \n  fragColor = vec4(0.);\n  \n  // so slow :(\n  float s = 0.3;\n  for (float i = 0.; i < ITERATIONS; i++) {\n    uv.x += s*1.5 * cos(0.53 * uv.y);\n    uv.y += s*0.84 * cos(0.42 * uv.x + time/.015);\n    vec3 color = k_rainbow(i / (ITERATIONS * 25.0), sin(iTime*0.5+uv.y*0.15)*4., iTime*0.5);\n    fragColor += k_orb(uv, 2.2, vec2(0, 0), color, 0.7);\n  }\n\n   fragColor.xyz = 1. - abs(1.-log(abs(fragColor.xyz)));\n   fragColor.xyz = pow(fragColor.xyz, vec3(0.5));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xcs3zH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 148, 148, 228], [230, 230, 291, 291, 397], [399, 399, 425, 425, 475], [477, 477, 534, 534, 1175]], "test": "untested"}
{"id": "4fsGzH", "name": "RayMarching - Test 1", "author": "FabulousCodingFox", "description": "By https://github.com/FabulousCodingFox", "tags": ["raymarching"], "likes": 2, "viewed": 159, "published": 3, "date": "1702752233", "time_retrieved": "2024-07-30T17:16:10.525512", "image_code": "#define MAX_DISTANCE 100.\n#define SURFACE_DISTANCE .01\n\n////////////////////////////////////////////////////\nstruct Sphere{\n    vec3 pos;\n    float radius;\n};\nfloat dSphere(vec3 pos, Sphere obj){\n    return length(pos-obj.pos)-obj.radius;\n}\n////////////////////////////////////////////////////\nstruct Cube{\n    vec3 pos;\n    float side;\n};\nfloat dCube(vec3 pos, Cube obj){\n  vec3 q = abs(pos-obj.pos) - vec3(obj.side);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - .1;\n}\n////////////////////////////////////////////////////\nstruct Pyramid{\n    vec3 pos;\n    float height;\n    float side;\n};\nfloat dPyramid(vec3 pos, Pyramid obj){\n  pos = pos - obj.pos - vec3(0,-obj.height*.5,0);\n  float m2 = obj.height*obj.height + 0.25;\n    \n  pos.xz = abs(pos.xz);\n  pos.xz = (pos.z>pos.x) ?pos.zx : pos.xz;\n  pos.xz -= 0.5;\n\n  vec3 q = vec3( pos.z, obj.height*pos.y - 0.5*pos.x, obj.height*pos.x + 0.5*pos.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*pos.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-pos.y));\n}\n////////////////////////////////////////////////////\n\n#define SPHERE Sphere(vec3(0, 1, 10), 1.)\n#define CUBE Cube(vec3(3, 1, 10), 1.)\n#define PYRAMID Pyramid(vec3(-3, 1, 10), 2., 1.)\n\nfloat getDistance(vec3 position){\n    float dSPHERE = dSphere(position, SPHERE);\n    float dCUBE = dCube(position, CUBE);\n    float dPYRAMID = dPyramid(position, PYRAMID);\n    return min(min(min(position.y, dSPHERE), dCUBE), dPYRAMID);\n}\n\n\nstruct Ray{\n    vec3 origin, direction;\n};\n\n\nvec4 rayMarch(Ray ray){\n\tfloat distanceFromOrigin=0.;\n    while(true){\n    \tvec3 position = ray.origin + ray.direction * distanceFromOrigin;\n        float dist = getDistance(position);\n        distanceFromOrigin += dist;\n        if(distanceFromOrigin>MAX_DISTANCE || dist<SURFACE_DISTANCE) break;\n    }\n    return vec4(ray.origin + ray.direction * distanceFromOrigin, distanceFromOrigin);\n}\n\nvec3 getNormal(vec3 position) {\n\tfloat dist = getDistance(position);\n    vec2 e = vec2(.01, 0);\n    vec3 normal = dist - vec3(\n        getDistance(position-e.xyy),\n        getDistance(position-e.yxy),\n        getDistance(position-e.yyx));\n    return normalize(normal);\n}\n\nfloat getLight(vec3 position) {\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 light = normalize(lightPos-position);\n    vec3 normal = getNormal(position);\n    float dif = clamp(dot(normal, light), 0., 1.);\n    vec4 dist = rayMarch(Ray(position+normal*SURFACE_DISTANCE*2., light));\n    if(dist.w<length(lightPos-position)) dif *= .1;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    Ray ray = Ray(vec3(0, 1, 0), normalize(vec3(uv.x, uv.y, 1)));\n    vec4 result = rayMarch(ray);\n    float dif = getLight(result.xyz);\n    vec3 col = vec3(dif);\n    col = pow(col, vec3(.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fsGzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 195, 195, 240], [340, 340, 372, 372, 487], [608, 608, 646, 646, 1246], [1431, 1431, 1464, 1464, 1668], [1716, 1716, 1739, 1739, 2106], [2108, 2108, 2139, 2139, 2378], [2380, 2380, 2411, 2411, 2780], [2782, 2782, 2839, 2839, 3127]], "test": "untested"}
{"id": "XflGRH", "name": "Fork bump slit  POSTHELIOS 447", "author": "POSTHELIOS", "description": "oldschool bumpmapping with an emboss function applied to a slit scan tunnel.  \nthanks to roywig for the original slit scan tunnel.\n", "tags": ["2d", "tunnel", "oldschool", "slitscan", "bump", "emboss"], "likes": 1, "viewed": 224, "published": 3, "date": "1702745457", "time_retrieved": "2024-07-30T17:16:11.371251", "image_code": "// Original slit scan tunnel by Roywig : https://www.shadertoy.com/view/4dtSWS\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 color = vec3(0);\n    float rInv = 1./length(uv*2.);\n    uv = uv* rInv;\n    \n    float bump_height = 5.;\n    float v1 = texture(iChannel1,uv+vec2(0.005,0.0)-vec2(rInv+iTime,0.)).r;\n\tfloat v2 = texture(iChannel1,uv+vec2(-0.005,0.0)-vec2(rInv+iTime,0.)).r;\n\tfloat v3 = texture(iChannel1,uv+vec2(0.0,0.005)-vec2(rInv+iTime,0.)).r;\n\tfloat v4 = texture(iChannel1,uv+vec2(0.0,-0.005)-vec2(rInv+iTime,0.)).r;\n    float bumpx = (v2-v1)*bump_height;\n    float bumpy = (v3-v4)*bump_height;\n\n    float light = 1.-length(vec2(uv+rInv-1.)-vec2(bumpx,bumpy));\n    \n    color = texture(iChannel0,uv-vec2(rInv+iTime,0.)).rgb*light*3.;\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XflGRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 137, 137, 859]], "test": "untested"}
{"id": "4fs3R8", "name": "truchet hexagonal dodecahedron", "author": "cyperus", "description": "truchet 3d - toroidal hexagonal grid - spherical toroidal dodecahedron", "tags": ["3d", "sdf", "hexagon", "truchet", "dodecahedron", "schwarzchristoffel"], "likes": 6, "viewed": 220, "published": 3, "date": "1702737927", "time_retrieved": "2024-07-30T17:16:12.444381", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"truchet hexagonal dodecahedron\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n//\n// References & Inspiration:\n//\n// - quick guide for shadertoy by FabriceNeyret2\n//   https://shadertoyunofficial.wordpress.com/\n//\n// - \"Schwarz-Christoffel Mapping\" by mla\n//   https://www.shadertoy.com/view/tsfyRj\n//\n// - conformal mapping with confmap.m by Trefethen\n//   https://people.maths.ox.ac.uk/trefethen/lightning.html\n//\n// - signed distance functions & operations by iq\n//   https://iquilezles.org/articles/distfunctions/\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// ray casting bounding shape\nconst float\n    CAM_DIST = 7.,\n    CAM_FLE = 2.,\n    BB_DIST = 3.,\n    RAY_MIN_DIST = 0.1,\n    RAY_MAX_DIST = CAM_DIST+1.1*BB_DIST;   \n\nconst int MAX_MARCHING_STEPS = 600;\nconst float\n    RAY_STEP_FACTOR = 0.0095,\n    RAY_PRECISION = 1.E-1;\n\n// data from sdf\nvec3 mat_to = vec3(0);\nvec3 mat_to_id = vec3(0);\nvec4 mat_tc = vec4(0);\n\nfloat map(in vec3 p) {\n    float rxy = 0., au = 0.0, av = 0.0;\n    vec2 z = vec2(0.);\n    float d = -1.;\n           \n    /// map platonic solid cells to one cell\n    vec3 pn = normalize(p); \n  \n    // projection from n cells to 1 cell.\n    float cell_id = 0., sr = 0.; //sig(sr): sens of rotation, abs(sr) : number edges per face\n    pn = dodeca_cells(pn, cell_id, sr);\n\n    z = pn.xy/(1.-pn.z);\n    z = cDodecaPolyArc2disk(z);\n\n    // r-polygon-distribution\n    vec2 e = vec2(sqrt(2.), 0.5);\n    float en = 1.+( (8.<0.?e.x:e.y)-1. )*smoothstep(1.,5., abs(8.));        \n    float r = length(z); vec2 zn = z/r;\n    z = dist(r, en) * zn;   \n\n    // stereograpic projection    \n    pn = sp(vec3(z,sr));\n\n    // scale radius\n    p = length(p) * pn;\n    \n    p = p.yzx;\n\n    /// torus\n    z = vec2(length(p.zx), p.y);\n    au = atan(p.x, p.z);\n    \n    z = cmul(z,z); z.x -= 6.;\n    av = atan(z.y, z.x);\n    rxy = length(z);\n    \n    vec2 grid_hex_num = 10. * vec2(3.,1.);\n    p = vec3(grid_hex_num.x*au/PI, grid_hex_num.y* 0.5*sqrt(3.)* av/PI, log(rxy)-0.4);\n\n    /// regular hexagonal tiles\n    vec3 rpt_id = vec3(1.); vec3 p_hex;    \n    p.xy = hexgrid2hex(p.xy, rpt_id);    \n    p.xy = inversesc(p.xy, int(6.));\n    mat_to_id = rpt_id;\n\n    // torus,sphere,2spheres       \n    rxy = length(p.xy); au = atan(p.y, p.x);    \n    z = 2.*ccos(PI*vec2(rxy,2.*p.z));\n    z.x += (3. + 2. * sin(2.*PI*iTime/60.));\n            \n    p = vec3(log(length(z))-0.02, 0.5*au/PI, 0.5*atan(z.y,z.x)/PI);\n    \n    vec2 to_uv = p.yz;\n    float to_d = log(length(z)+0.8);\n    mat_to = vec3(to_uv,to_d);   \n\n    /// truchet 3D cube grid\n    vec3 tc_id = vec3(0.); float tc_a = 0.;   \n    p *= vec3(1.,18.,4.); // r,u,v\n    p.yzx = p.xyz;\n    \n    ivec3 l0 = -ivec3(2.,0,9.);\n    ivec3 l1 = ivec3(2.,1.,9.)-ivec3(1.);\n    tc_id = floor(p);\n    tc_id = clamp(tc_id, vec3(l0), vec3(l1));\n    vec3 q = p - tc_id -0.5;\n\n    // truchet 3D cube tiles\n    float rnd = hash21(tc_id.xz);\n    if(rnd<.5) q.x = -q.x;\n    if(fract(rnd*77.57+iTime/6.)>.75) {\n       vec3 q2 =  length(q.xz-.5)<length(q.xz+.5)\n                ? vec3(q.xz-.5,0.)  \n                : vec3(q.xz+.5,1.);\n       d = sdTorus( vec3(q2.x, q.y, q2.y) , vec2(0.5,0.125) );\n    }\n    else {\n       d = opSmoothUnion( sdCylinder( q.zxy, 0.125 ), sdCylinder( q.xzy, 0.125 ), 0.05 );\n    }\n    mat_tc = vec4(q,rnd);  \n   \n    // return\n    return min(d,to_d);\n}\n\n// intersect\nfloat intersect(in vec3 ro, in vec3 rd, in float px) {\n    float res = -1.0;\n    \n    // bb\n    vec2 dis = isphere( ro, rd , abs(BB_DIST));    \n    if( dis.y<0.0 ) return -1.0;\n    dis.x = max( dis.x, RAY_MIN_DIST );\n    dis.y = min( dis.y, RAY_MAX_DIST );\n\n    // raymarch signed distance field    \n\tfloat fh = RAY_STEP_FACTOR;\n    float t = dis.x;\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) {\n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t;\n        float h = map( pos);\n        if( t>dis.y || h<th ) break;\n        t += h*fh;\n    }\n    if( t<dis.y ) {\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) { \n\tif (iMouse.x > 0.0) {\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n    //p.yz = crot(p.yz,-1.*PI*(time+10.));\n    //p.zx = crot(p.zx,-2.*PI*(time+15.));\n\treturn p.xyz;\n}\n\n// textures\nfloat grid_uv(in vec2 uv) {\n    // uv grid alpha mask\n    vec2 sw = abs(fract(uv-0.25)-0.5)-0.25;\n    float sdf = min(sw.x,sw.y)*-max(sw.x,sw.y);\n    float pp = fwidth(sdf);\n    return smoothstep(+pp,-pp,sdf);\n}\n            \nvec4 cells(in vec2 uv, in float h) {\n    // sectors, uv-grid\n    vec4 C;\n    C.a = 1.;\n    C.rgb = h2rgb(h);                      // sector  -> hue\n    C.rgb *= (0.5+ 0.5 * grid_uv(uv))*0.7; // uv-grid -> value\n    return C;\n}\n\nvec4 ribbon(in float uv_x, in float time) {\n    float sdf = -(2.*pulsecollision(1.,1./3. * uv_x, time, 1./3.)-1.);\n    float px = fwidth(sdf); float a = smoothstep(px+0.1,-px-0.1,sdf+0.2);    \n    return vec4( h2rgb(sdf -2./6.),a );\n}\n\nvec4 truchet3D(in vec3 p, in float rnd ,in float time) {\n    float sdf = sdBox( p, vec3(0.5*0.9));\n    float px = fwidth(sdf); float a = smoothstep(px,-px,sdf);\n    return mix(vec4(1.), vec4(h2rgb( fract(abs(rnd)*22.93 + time)),1.), a);\n}\n\n// main\nvoid mainImage(out vec4 O, in vec2 fragCoord) {\n    // normalized time\n    float ntime = iTime/360.;\n\n    // anti-aliasing to take a picture\n    vec3 tot = vec3(0.0);\n    #define AA 1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {       \n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o) - iResolution.xy)/iResolution.y;\n        \n        // camera viewport --> worldspace\n        vec3 ro = vec3(0,0,-CAM_DIST);\n        vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n             ro = transform(ro,ntime);\n             rd = normalize(transform(rd,ntime));\n        \n        // distance hit ray surface\n        float px = 2.0/( iResolution.y*CAM_FLE );\n        float t = intersect( ro, rd, px );\n\n        // background\n        vec3 sky_col = vec3(0.);\n        vec4 C = vec4(sky_col,1.);\n        O = C;\n        \n        // object surface\n        if (t >= 0.) {\n            // surface properties\n            vec3 p = ro + rd * t;\n            vec3 n = calcNormal( p, 0.001);\n            \n            // draw textures\n            O = vec4(0);\n\n            if(O.a<1.) {          \n                float hue = (mat_to_id.x + 2.)/4. + (mat_to_id.z )/8.;\n                C = cells(mat_to.xy/2., hue);\n                C.a = mat_to.z>0.5 ? 0.5 : O.a;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n\n            if(O.a<1.) {\n                C =  mat_to.z<0.5 ? ribbon( 6.*3.* mat_to.x,  6.*ntime) : vec4(0.);\n                C.rgb *= 0.7;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n\n            if(O.a<1.) {\n                C = truchet3D(mat_tc.xyz, mat_tc.w, ntime);\n                C.a = 0.5; C.rgb *= 0.5;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n\n            C = O;\n                       \n            // lighting\n            vec3  came_li_o   = transform(vec3(-10.,10.,-10.),ntime); // origine\n            vec3  came_li_dir = normalize(p - came_li_o);             // direction\n            vec3  came_li_col = vec3(1.,1.,.5);                       // color\n            float came_li_shi = 10.;                                  // shininess            \n\n            float cosa = 1.;\n            O.rgb += 0.1 * cosa * C.rgb * sky_col;           // amb\n            cosa = clamp(dot(-came_li_dir, n), 0., 1.);\n            O.rgb += 0.5 * cosa * C.rgb * came_li_col;       // dif       \n            cosa = pow(clamp(dot(reflect(came_li_dir, n), -rd), 0., 1.), came_li_shi);           \n            O.rgb += 0.4 *(cosa>0.? cosa:0.) * came_li_col ; // spec\n            \n            // fog\n            O.rgb = mix(O.rgb, sky_col, 1.0 - exp(-2.5E-3 * pow(t,3.)));    \n        }\n        tot += O.rgb;\n    }\n    tot /= float(AA*AA);\n    \n    // gamma correction\n    O = vec4(rgb2srgb(tot),1.);\n}", "image_inputs": [], "common_code": "// const\nconst float PI = abs(atan(0.,-1.));\n\n// 1D transformations\nfloat pulsecollision(in float pf, in float x, in float x0, in float pw) {\n    float ntriw_p = abs( fract( pf*(x - x0) )-0.5);\n    float ntriw_n = abs( fract( pf*(x + x0) )-0.5);\n    float pp = smoothstep( 0.5*pw, 0., ntriw_p );\n    float pn = smoothstep( 0.5*pw, 0., ntriw_n );\n    return (pp+pn);\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);\n}\n\n// complex\nvec2 cmul(vec2 za,vec2 zb) {\n    return za*mat2(zb.x,-zb.y,zb.yx);\n}\n\nvec2 crot(vec2 z,float a) {\n    return cmul(vec2(cos(a),sin(a)),z);\n}\n\nvec2 cinv(vec2 z) {\n    return z*vec2(1,-1)/dot(z,z);\n}\n    \nvec2 cdiv(vec2 z, vec2 w) {\n    return cmul(z,cinv(w));\n}\n    \nvec2 cpow(vec2 z, int n) {\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));\n}\n  \nvec2 csqr(vec2 z) {\n    return vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y );\n}\n\nvec2 ccos(vec2 z) {\n    vec2 d=vec2(exp(z.y),exp(-z.y));\n\treturn vec2(cos(z.x)*(d.x+d.y)*.5,-sin(z.x)*(d.x-d.y)*.5);\n}\n\nfloat binomial(float a, int n) {\n   float s = 1.0;\n   for (int i = n; i >= 1; i--,a--) {\n     s *= float(a)/float(i);\n   }\n   return s;\n}\n\nvec2 expi(float x) {\n  return vec2(cos(x),sin(x));\n}\n\nfloat gamma(float z) {\n  const float[8] p = float[](\n    676.5203681218851,\n    -1259.1392167224028,\n    771.32342877765313,\n    -176.61502916214059,\n    12.507343278686905,\n    -0.13857109526572012,\n    9.9843695780195716e-6,\n    1.5056327351493116e-7\n  );\n  z -= 1.0;\n  float x = 0.99999999999980993;\n  for (int i = 0; i < 8; i++) {\n    float pval = p[i];\n    x += pval/(z+float(i+1));\n  }\n  float t = z + 8.0 - 0.5;\n  return sqrt(2.0*PI) * pow(t,z+0.5) * exp(-t) * x;\n}\n\n// beta function\nfloat B(float a, float b) {\n  return (gamma(a)*gamma(b))/gamma(a+b);\n}\n\nvec2 inversesc(vec2 z, int K) {\n  float cn[6];\n  for (int n = 1; n <= 5; n++) {\n    cn[n] = binomial(float(n)-1.0+2.0/float(K),n)/float(1+n*K);\n  }\n  float C = B(1.0/float(K),1.0-2.0/float(K))/float(K);\n  z *= C;\n  vec2 h = cpow(z,int(K));\n  float T1 = -cn[1];\n  float T2 = -cn[2]+float(K+1)*pow(cn[1],2.0);\n  float T3 = -cn[3]+float(3*K+2)*(cn[1]*cn[2]-float(K+1)/2.0*pow(cn[1],3.0));\n  float T4 = -cn[4]+float(2*K+1)*(2.0*cn[1]*cn[3]+pow(cn[2],2.0)-float(4*K+3)*\n                                  (pow(cn[1],2.0)*cn[2]-float(K+1)/3.0*pow(cn[1],4.0)));\n  float T5 = -cn[5]+float(5*K+2)*(cn[1]*cn[4]+cn[2]*cn[3]+float(5*K+3)*\n            (-0.5*pow(cn[1],2.0)*cn[3]-0.5*cn[1]*pow(cn[2],2.0)+float(5*K+4)*\n            (pow(cn[1],3.0)*cn[2]/6.0-float(K+1)*pow(cn[1],5.0)/24.0)));\n  vec2 X = vec2(1,0)+h/pow(C,float(K));\n  vec2 w = cmul(z,vec2(1,0) + T1*h + T2*cpow(h,2) + T3*cpow(h,3) + T4*cpow(h,4) + cdiv(T5*cpow(h,5),X));\n  return w;\n}\n\n// map spherical platonic solid pyramidal sectors to one sector located at -z-axis.\nvec2 hexgrid2hex(in vec2 Z, out vec3 U_id) {\n    const float\n        SQRT3 = sqrt(3.),\n        SQRT_3 = 1./SQRT3;\n\tconst mat2\n        M = mat2(SQRT_3,-1.,-SQRT_3,-1.),\n        iM = 0.5*mat2(SQRT3,-SQRT3,-1.,-1.);\n    Z = crot(Z,PI/6.);\n    Z = iM*Z/0.75;\n    vec3 U = vec3(Z.x,-Z.x-Z.y,Z.y);\n    U_id = 2.*floor(U*0.5+0.5);\n    vec3 U_lo = U-U_id;\n    vec3 aU_lo = abs(U_lo);\n    if (aU_lo.x > aU_lo.y && aU_lo.x > aU_lo.z) {\n        U_lo.x = -U_lo.y-U_lo.z;\n        U_id.x = -U_id.y-U_id.z;\n    }\n    if (aU_lo.y > aU_lo.z) {\n        U_lo.y = -U_lo.x-U_lo.z;\n        U_id.y = -U_id.x-U_id.z;\n    }\n    else {\n        U_lo.z = -U_lo.x-U_lo.y;\n        U_id.z = -U_id.x-U_id.y;\n    }\n    Z = U_lo.rb;\n    Z = M*Z*0.75;\n    return crot(Z,-PI/6.);\n}\n\n// regular circular arc triangle -> unitcircle conformal mapping by using a barycentric approximation\nvec2 cDodecaPolyArc2disk(vec2 z) {\n    // https://people.maths.ox.ac.uk/trefethen/lightning.html\n    const int NUM_j = 25; // poles\n    const vec2[] rf = vec2[NUM_j]\n    (vec2(-0.8260, - 0.5637)\n    ,vec2( 0.8091, + 0.5877)\n    ,vec2(-0.3090, - 0.9511)\n    ,vec2(-0.3089, - 0.9511)\n    ,vec2( 0.8089, - 0.5879)\n    ,vec2(-1.0000, + 0.0000)\n    ,vec2(-1.0000, + 0.0001)\n    ,vec2(-0.3090, + 0.9511)\n    ,vec2(-0.3089, + 0.9511)\n    ,vec2( 0.9996, - 0.0294)\n    ,vec2( 0.9103, + 0.4140)\n    ,vec2( 0.2242, + 0.9746)\n    ,vec2( 0.3369, - 0.9415)\n    ,vec2(-0.8576, + 0.5143)\n    ,vec2(-0.4307, - 0.9025)\n    ,vec2(-0.3567, + 0.9342)\n    ,vec2(-0.9988, - 0.0485)\n    ,vec2( 0.7796, + 0.6263)\n    ,vec2( 0.7796, - 0.6263)\n    ,vec2(-0.2828, - 0.9592)\n    ,vec2(-0.3161, + 0.9487)\n    ,vec2(-1.0000, + 0.0075)\n    ,vec2(-0.2187, + 0.9758)\n    ,vec2( 0.8366, - 0.5479)\n    ,vec2( 0.8134, + 0.5817));\n\n    const vec2[] rw = vec2[NUM_j]\n    (vec2(-0.1213, - 0.0   )\n    ,vec2( 0.0028, + 0.0187)\n    ,vec2( 0.0000, - 0.0000)\n    ,vec2(-0.0010, + 0.0008)\n    ,vec2(-0.0017, - 0.0008)\n    ,vec2(-0.0000, - 0.0000)\n    ,vec2(-0.0041, - 0.0007)\n    ,vec2(-0.0000, - 0.0000)\n    ,vec2( 0.0219, - 0.0012)\n    ,vec2(-0.2767, - 0.2629)\n    ,vec2( 0.2548, - 0.3937)\n    ,vec2( 0.4733, + 0.0936)\n    ,vec2(-0.0954, - 0.0232)\n    ,vec2(-0.1703, + 0.0600)\n    ,vec2(-0.0347, - 0.0277)\n    ,vec2(-0.3617, + 0.0048)\n    ,vec2(-0.0493, + 0.0086)\n    ,vec2( 0.1573, + 0.1009)\n    ,vec2(-0.0406, - 0.0040)\n    ,vec2(-0.0118, - 0.0116)\n    ,vec2( 0.0485, + 0.1712)\n    ,vec2(-0.0014, + 0.0204)\n    ,vec2( 0.1498, + 0.3189)\n    ,vec2(-0.0419, - 0.0255)\n    ,vec2( 0.1042, - 0.0471));\n\n    const vec2[] rz = vec2[NUM_j]\n    (vec2(-0.2339, - 0.1614)\n    ,vec2( 0.2737, + 0.1982)\n    ,vec2(-0.1045, - 0.3217)\n    ,vec2(-0.1039, - 0.3216)\n    ,vec2( 0.2731, - 0.1991)\n    ,vec2(-0.3383, + 0.0   )\n    ,vec2(-0.3379, + 0.0006)\n    ,vec2(-0.1045, + 0.3217)\n    ,vec2(-0.1039, + 0.3216)\n    ,vec2( 0.2841, - 0.0069)\n    ,vec2( 0.2810, + 0.1078)\n    ,vec2( 0.0682, + 0.2764)\n    ,vec2( 0.0943, - 0.2680)\n    ,vec2(-0.2418, + 0.1502)\n    ,vec2(-0.1496, - 0.2698)\n    ,vec2(-0.1287, + 0.2944)\n    ,vec2(-0.3202, - 0.0306)\n    ,vec2( 0.2411, + 0.2130)\n    ,vec2( 0.2411, - 0.2130)\n    ,vec2(-0.0808, - 0.3165)\n    ,vec2(-0.1114, + 0.3141)\n    ,vec2(-0.3331, + 0.0088)\n    ,vec2(-0.0510, + 0.3095)\n    ,vec2( 0.2770, - 0.1635)\n    ,vec2( 0.2747, + 0.1886));\n    \n    // polynomial barycentric representation\n    vec2 zn = vec2(0.); vec2 zd = vec2(0.);       \n    for(int j = 0; j<NUM_j; j++)\n    {\n        vec2 zj = cdiv( rw[j], (z-rz[j]));\n        zd += zj; // sum denominator\n        zn += cmul(rf[j], zj); // sum nominator\n    }\n    return cdiv(zn, zd);\n}\n\n// map spherical platonic solid pyramidal-face-cells to one cell located at -z-axis.\nvec3 dodeca_cells(in vec3 p, out float cell_id, out float sr) {\n    const float PI_2 = PI/2.;\n\t//// dodecaeder\n\tconst float gr0 = (1.+sqrt(5.))/2.; const float gr1 = 1./gr0; const float gr2 = gr0-gr1;\n\t// cell-wall-face-normals\n\tbool nx = dot(vec3( 1., 0., 0.),p)>=0.;\n\tbool ny = dot(vec3( 0., 1., 0.),p)>=0.;\n\tbool nz = dot(vec3( 0., 0., 1.),p)>=0.;\n\t//\n\tbool n0A = dot(vec3( gr2,-gr0, gr1),p)>=0.;\n\tbool n0B = dot(vec3( gr1, gr2,-gr0),p)>=0.;\n\tbool n0C = dot(vec3(-gr0, gr1, gr2),p)>=0.;\n\t//\n\tbool n1A = dot(vec3(-gr2,-gr0,-gr1),p)>=0.;\n\tbool n1B = dot(vec3(-gr1, gr2, gr0),p)>=0.;\n\tbool n1C = dot(vec3( gr0, gr1,-gr2),p)>=0.;\n\t//\n\tbool n2A = dot(vec3(-gr2, gr0, gr1),p)>=0.;\n\tbool n2B = dot(vec3(-gr1,-gr2,-gr0),p)>=0.;\n\tbool n2C = dot(vec3( gr0,-gr1, gr2),p)>=0.;\n\t//\n\tbool n3A = dot(vec3( gr2, gr0,-gr1),p)>=0.;\n\tbool n3B = dot(vec3( gr1,-gr2, gr0),p)>=0.;\n\tbool n3C = dot(vec3(-gr0,-gr1,-gr2),p)>=0.;\n\n\t// cells\n    float a = PI_2-atan((sqrt(5.)-1.)/2.);\n    float b = PI/10.; // 18Â°\n    float a_x = 0.; float a_y = 0.; float a_z = 0.;\n\t// ---------------------------------------------------------------\n\t//Fpxpy\n    if(ny && !n2B && n2C && !n0C && n0B)\t\n\t{\n\t\tcell_id = 0.;\n\t\ta_y = PI_2;\n        a_x = a-PI_2;\n\t\ta_z = b;\n\t}\n\t//Fnxny\n\telse if(!ny && n2B && !n2C && n0C && !n0B)\n\t{\n\t\tcell_id = 1.;\n\t\ta_y = PI_2;\n        a_x = a+PI_2;\n\t\ta_z = b;\n\t}\n\t// ---------------------------------------------------------------\n\t//Fpxny\n\telse if(ny && n1B && !n1C && n3C && !n3B)\n\t{\n\t\tcell_id = 2.;\n\t\ta_y = -PI_2;\n\t\ta_x =  a-PI_2;\n\t\ta_z =  b;\n\t}\n\t//Fnxpy\n\telse if(!ny && !n1B && n1C && !n3C && n3B)\n\t{\n\t\tcell_id = 3.;\n\t\ta_y = -PI_2;\n\t\ta_x =  a+PI_2;\n\t\ta_z =  b;\n\t}\n\t// ---------------------------------------------------------------\n\t//Fpypz\n\telse if(!nz && n3C && !n3A && n0A && !n0C)\n\t{\n\t\tcell_id = 4.;\n\t\ta_y =  0.;\n        a_x =  a;\n\t\ta_z =  b;\n\t}\n\t//Fnynz\n\telse if(nz && !n3C && n3A && !n0A && n0C)\n\t{\n\t\tcell_id = 5.;\n\t\ta_y =  0.; \n\t\ta_x =  a+PI;\n\t\ta_z =  b;\n\t}\n\n\t// ---------------------------------------------------------------\n\t//Fpynz\n\telse if(nz && n2C && !n2A && n1A && !n1C)\n\t{\n\t\tcell_id = 6.;\n\t\ta_y =  0.;\n        a_x = -a+PI;\n\t\ta_z = -b;        \n\t}\n\t//Fnypz\n\telse if(!nz && !n2C && n2A && !n1A && n1C)\n\t{\n\t\tcell_id = 7.;\n\t\ta_y =  0.;\n        a_x = -a;\n\t\ta_z = -b;       \n\t}\n\t// ---------------------------------------------------------------\n\t//Fpzpx\n\telse if(!nx && n1A && !n1B && n0B && !n0A)\n\t{\n\t\tcell_id = 8.;\n\t\ta_y =  a-PI_2;\n\t\ta_x =  0.;\n\t\ta_z =  0.;\n\t}\n\t//Fnznx\n\telse if( nx && !n1A && n1B && !n0B && n0A)\n\t{\n\t\tcell_id = 9.;\n\t\ta_y =  a+PI_2;\n\t\ta_x =  0.;\n\t\ta_z =  0.;\n\t}\n\t// ---------------------------------------------------------------\n\t//Fpznx\n\telse if(nx && n3A && !n3B && n2B && !n2A)\n\t{\n\t\tcell_id = 10.;\n\t\ta_y = -a+PI_2;\n\t\ta_x =  0.;\n\t\ta_z =  b+PI_2;\n\t}\n\t//Fnzpx\n\telse if(!nx && !n3A && n3B && !n2B && n2A )\n\t{\n\t\tcell_id = 11.;\n\t\ta_y = -a+PI_2;\n\t\ta_x =  PI;\n\t\ta_z =  b-PI_2;\n\t}\n\t// ---------------------------------------------------------------\n\t// cell orientation\n\tvec2 ei_y = vec2(cos(a_y),sin(a_y)); p.zx = cmul(p.zx,ei_y); // rotate around y-axis\n\tvec2 ei_x = vec2(cos(a_x),sin(a_x)); p.yz = cmul(p.yz,ei_x); // rotate around x-axis\n\tvec2 ei_z = vec2(cos(a_z),sin(a_z)); p.xy = cmul(p.xy,ei_z); // rotate around z-axis\n\t// non cyclic\n\tsr = 5.;\n    return p;\n}\n\n// distribution\nfloat sig(float x) {\n    return x < 0. ? -1. : +1.;\n}\n\nfloat dist(float x, float e) {\n    // e in [0., +inf]\n    return sign(x)*abs( pow(abs(x), abs(e)) );\n}\n   \nvec2 r_poly_dist(vec2 z, vec2 e, float sh_a) {   \n    /// r-polygon-distribution\n    float r = length(z); z = (r<0.)? vec2(0) : z/r; \n    float d0 = 0.5 *abs(e.y-e.x);\n    float e2 = e.x + d0 + d0 * (2.*smoothstep(-1., 1., -sh_a) - 1.);\n    return dist(r, e2) * z;\n}   \n\n// stereographic projection\nvec3 sp(vec3 zsr){\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // stereopraphic projection (complex plane to unit sphere)\n    float zz = dot(z,z); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(2. * z.x,  2. * z.y, -1. + zz);\n        }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(2. * z.x, -2. * z.y,  1. - zz);\n        }\n    pn /= 1.+zz;\n    return pn;\n}\n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// sdf\nfloat opIntersection( float d1, float d2 ) {\n    return max(d1,d2); }\n\nfloat opSmoothUnion( in float d1, in float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, float r ) {\n  return length(p.xz)-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// color\nvec3 h2rgb(float h) {\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n}\n\n// srgb <--> rgb (linear)\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4fs3R8.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1152, 1152, 1174, 1174, 3543], [3545, 3558, 3612, 3612, 4181], [4183, 4183, 4228, 4228, 4390], [4392, 4392, 4434, 4434, 4685], [4687, 4699, 4726, 4752, 4910], [4924, 4924, 4960, 4984, 5150], [5152, 5152, 5195, 5195, 5386], [5388, 5388, 5444, 5444, 5626], [5628, 5636, 5683, 5706, 8467]], "test": "untested"}
{"id": "Mff3zH", "name": "truchet hexagonal hexahedron", "author": "cyperus", "description": "truchet 3d - toroidal hexagonal grid - spherical toroidal hexahedron", "tags": ["3d", "sdf", "cube", "hexagon", "truchet", "schwarzchristoffel"], "likes": 3, "viewed": 128, "published": 3, "date": "1702733426", "time_retrieved": "2024-07-30T17:16:13.379880", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"truchet hexagonal hexahedron\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n//\n// References & Inspiration:\n//\n// - quick guide for shadertoy by FabriceNeyret2\n//   https://shadertoyunofficial.wordpress.com/\n//\n// - \"Schwarz-Christoffel Mapping\" by mla\n//   https://www.shadertoy.com/view/tsfyRj\n//\n// - conformal mapping with confmap.m by Trefethen\n//   https://people.maths.ox.ac.uk/trefethen/lightning.html\n//\n// - signed distance functions & operations by iq\n//   https://iquilezles.org/articles/distfunctions/\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// ray casting bounding shape\nconst float\n    CAM_DIST = 6.,\n    CAM_FLE = 2.,\n    BB_DIST = 2.6,\n    RAY_MIN_DIST = 0.1,\n    RAY_MAX_DIST = CAM_DIST+1.1*BB_DIST;   \n\nconst int MAX_MARCHING_STEPS = 600;\nconst float\n    RAY_STEP_FACTOR = 0.0095,\n    RAY_PRECISION = 1.E-1;\n\n// data from sdf\nvec3 mat_to = vec3(0);\nvec3 mat_to_id = vec3(0);\nvec4 mat_tc = vec4(0);\n\nfloat map(in vec3 p) {\n    float rxy = 0., au = 0.0, av = 0.0;\n    vec2 z = vec2(0.);\n    float d = -1.;\n           \n    /// map platonic solid cells to one cell\n    vec3 pn = normalize(p); \n  \n    // projection from n cells to 1 cell.\n    float cell_id = 0., sr = 0.;\n    pn = hexa_cells(pn, cell_id, sr);\n\n    z = pn.xy/(1.-pn.z);\n    z = cHexaPolyArc2disk(z);\n\n    // r-polygon-distribution\n    vec2 e = vec2(sqrt(2.), 0.5);\n    float en = 1.+( (8.<0.?e.x:e.y)-1. )*smoothstep(1.,5., abs(8.));        \n    float r = length(z); vec2 zn = z/r;\n    z = dist(r, en) * zn;   \n\n    // stereograpic projection    \n    pn = sp(vec3(z,sr));\n\n    // scale radius\n    p = length(p) * pn;\n    \n    p = p.yzx;\n\n    /// torus\n    z = vec2(length(p.zx), p.y);\n    au = atan(p.x, p.z);\n    \n    z = cmul(z,z); z.x -= 4.;\n    av = atan(z.y, z.x);\n    rxy = length(z);\n    \n    vec2 grid_hex_num = 8. * vec2(3.,1.);\n    p = vec3(grid_hex_num.x*au/PI, grid_hex_num.y* 0.5*sqrt(3.)* av/PI, log(rxy)-0.4);\n\n    /// regular hexagonal tiles\n    vec3 rpt_id = vec3(1.); vec3 p_hex;    \n    p.xy = hexgrid2hex(p.xy, rpt_id);    \n    p.xy = inversesc(p.xy, int(6.));\n    mat_to_id = rpt_id;\n\n    // torus,sphere,2spheres       \n    rxy = length(p.xy); au = atan(p.y, p.x);    \n    z = 2.*ccos(PI*vec2(rxy,2.*p.z));\n    z.x += (3. + 2. * sin(2.*PI*iTime/60.));\n            \n    p = vec3(log(length(z))-0.02, 0.5*au/PI, 0.5*atan(z.y,z.x)/PI);\n    \n    vec2 to_uv = p.yz;\n    float to_d = log(length(z)+0.8);\n    mat_to = vec3(to_uv,to_d);   \n\n    /// truchet 3D cube grid\n    vec3 tc_id = vec3(0.); float tc_a = 0.;   \n    p *= vec3(1.,18.,4.); // r,u,v\n    p.yzx = p.xyz;\n    \n    ivec3 l0 = -ivec3(2.,0,9.);\n    ivec3 l1 = ivec3(2.,1.,9.)-ivec3(1.);\n    tc_id = floor(p);\n    tc_id = clamp(tc_id, vec3(l0), vec3(l1));\n    vec3 q = p - tc_id -0.5;\n\n    // truchet 3D cube tiles\n    float rnd = hash21(tc_id.xz);\n    if(rnd<.5) q.x = -q.x;\n    if(fract(rnd*77.57+iTime/6.)>.75) {\n       vec3 q2 =  length(q.xz-.5)<length(q.xz+.5)\n                ? vec3(q.xz-.5,0.)  \n                : vec3(q.xz+.5,1.);\n       d = sdTorus( vec3(q2.x, q.y, q2.y) , vec2(0.5,0.125) );\n    }\n    else {\n       d = opSmoothUnion( sdCylinder( q.zxy, 0.125 ), sdCylinder( q.xzy, 0.125 ), 0.05 );\n    }\n    mat_tc = vec4(q,rnd);  \n   \n    // return\n    return min(d,to_d);\n}\n\n// intersect\nfloat intersect(in vec3 ro, in vec3 rd, in float px) {\n    float res = -1.0;\n    \n    // bb\n    vec2 dis = isphere( ro, rd , abs(BB_DIST));    \n    if( dis.y<0.0 ) return -1.0;\n    dis.x = max( dis.x, RAY_MIN_DIST );\n    dis.y = min( dis.y, RAY_MAX_DIST );\n\n    // raymarch signed distance field    \n\tfloat fh = RAY_STEP_FACTOR;\n    float t = dis.x;\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) {\n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t;\n        float h = map( pos);\n        if( t>dis.y || h<th ) break;\n        t += h*fh;\n    }\n    if( t<dis.y ) {\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) { \n\tif (iMouse.x > 0.0) {\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n    //p.yz = crot(p.yz,-1.*PI*(time+10.));\n    //p.zx = crot(p.zx,-2.*PI*(time+15.));\n\treturn p.xyz;\n}\n\n// textures\nfloat grid_uv(in vec2 uv) {\n    // uv grid alpha mask\n    vec2 sw = abs(fract(uv-0.25)-0.5)-0.25;\n    float sdf = min(sw.x,sw.y)*-max(sw.x,sw.y);\n    float pp = fwidth(sdf);\n    return smoothstep(+pp,-pp,sdf);\n}\n            \nvec4 cells(in vec2 uv, in float h) {\n    // sectors, uv-grid\n    vec4 C;\n    C.a = 1.;\n    C.rgb = h2rgb(h);                      // sector  -> hue\n    C.rgb *= (0.5+ 0.5 * grid_uv(uv))*0.7; // uv-grid -> value\n    return C;\n}\n\nvec4 ribbon(in float uv_x, in float time) {\n    float sdf = -(2.*pulsecollision(1.,1./3. * uv_x, time, 1./3.)-1.);\n    float px = fwidth(sdf); float a = smoothstep(px+0.1,-px-0.1,sdf+0.2);    \n    return vec4( h2rgb(sdf -2./6.),a );\n}\n\nvec4 truchet3D(in vec3 p, in float rnd ,in float time) {\n    float sdf = sdBox( p, vec3(0.5*0.9));\n    float px = fwidth(sdf); float a = smoothstep(px,-px,sdf);\n    return mix(vec4(1.), vec4(h2rgb( fract(abs(rnd)*22.93 + time)),1.), a);\n}\n\n// main\nvoid mainImage(out vec4 O, in vec2 fragCoord) {\n    // normalized time\n    float ntime = iTime/360.;\n\n    // anti-aliasing to take a picture\n    vec3 tot = vec3(0.0);\n    #define AA 1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {       \n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o) - iResolution.xy)/iResolution.y;\n        \n        // camera viewport --> worldspace\n        vec3 ro = vec3(0,0,-CAM_DIST);\n        vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n             ro = transform(ro,ntime);\n             rd = normalize(transform(rd,ntime));\n        \n        // distance hit ray surface\n        float px = 2.0/( iResolution.y*CAM_FLE );\n        float t = intersect( ro, rd, px );\n\n        // background\n        vec3 sky_col = vec3(0.);\n        vec4 C = vec4(sky_col,1.);\n        O = C;\n        \n        // object surface\n        if (t >= 0.) {\n            // surface properties\n            vec3 p = ro + rd * t;\n            vec3 n = calcNormal( p, 0.001);\n            \n            // draw textures\n            O = vec4(0);\n\n            if(O.a<1.) {          \n                float hue = (mat_to_id.x + 2.)/4. + (mat_to_id.z )/8.;\n                C = cells(mat_to.xy/2., hue);\n                C.a = mat_to.z>0.5 ? 0.5 : O.a;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n\n            if(O.a<1.) {\n                C =  mat_to.z<0.5 ? ribbon( 6.*3.* mat_to.x,  6.*ntime) : vec4(0.);\n                C.rgb *= 0.7;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n\n            if(O.a<1.) {\n                C = truchet3D(mat_tc.xyz, mat_tc.w, ntime);\n                C.a = 0.5; C.rgb *= 0.5;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n\n            C = O;\n                       \n            // lighting\n            vec3  came_li_o   = transform(vec3(-10.,10.,-10.),ntime); // origine\n            vec3  came_li_dir = normalize(p - came_li_o);             // direction\n            vec3  came_li_col = vec3(1.,1.,.5);                       // color\n            float came_li_shi = 10.;                                  // shininess            \n\n            float cosa = 1.;\n            O.rgb += 0.1 * cosa * C.rgb * sky_col;           // amb\n            cosa = clamp(dot(-came_li_dir, n), 0., 1.);\n            O.rgb += 0.5 * cosa * C.rgb * came_li_col;       // dif       \n            cosa = pow(clamp(dot(reflect(came_li_dir, n), -rd), 0., 1.), came_li_shi);           \n            O.rgb += 0.4 *(cosa>0.? cosa:0.) * came_li_col ; // spec\n            \n            // fog\n            O.rgb = mix(O.rgb, sky_col, 1.0 - exp(-5.E-3 * pow(t,3.)));    \n        }\n        tot += O.rgb;\n    }\n    tot /= float(AA*AA);\n    \n    // gamma correction\n    O = vec4(rgb2srgb(tot),1.);\n}", "image_inputs": [], "common_code": "// const\nconst float PI = abs(atan(0.,-1.));\n\n// 1D transformations\nfloat pulsecollision(in float pf, in float x, in float x0, in float pw) {\n    float ntriw_p = abs( fract( pf*(x - x0) )-0.5);\n    float ntriw_n = abs( fract( pf*(x + x0) )-0.5);\n    float pp = smoothstep( 0.5*pw, 0., ntriw_p );\n    float pn = smoothstep( 0.5*pw, 0., ntriw_n );\n    return (pp+pn);\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);\n}\n\n// complex\nvec2 cmul(vec2 za,vec2 zb) {\n    return za*mat2(zb.x,-zb.y,zb.yx);\n}\n\nvec2 crot(vec2 z,float a) {\n    return cmul(vec2(cos(a),sin(a)),z);\n}\n\nvec2 cinv(vec2 z) {\n    return z*vec2(1,-1)/dot(z,z);\n}\n    \nvec2 cdiv(vec2 z, vec2 w) {\n    return cmul(z,cinv(w));\n}\n    \nvec2 cpow(vec2 z, int n) {\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));\n}\n  \nvec2 csqr(vec2 z) {\n    return vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y );\n}\n\nvec2 ccos(vec2 z) {\n    vec2 d=vec2(exp(z.y),exp(-z.y));\n\treturn vec2(cos(z.x)*(d.x+d.y)*.5,-sin(z.x)*(d.x-d.y)*.5);\n}\n\nfloat binomial(float a, int n) {\n   float s = 1.0;\n   for (int i = n; i >= 1; i--,a--) {\n     s *= float(a)/float(i);\n   }\n   return s;\n}\n\nvec2 expi(float x) {\n  return vec2(cos(x),sin(x));\n}\n\nfloat gamma(float z) {\n  const float[8] p = float[](\n    676.5203681218851,\n    -1259.1392167224028,\n    771.32342877765313,\n    -176.61502916214059,\n    12.507343278686905,\n    -0.13857109526572012,\n    9.9843695780195716e-6,\n    1.5056327351493116e-7\n  );\n  z -= 1.0;\n  float x = 0.99999999999980993;\n  for (int i = 0; i < 8; i++) {\n    float pval = p[i];\n    x += pval/(z+float(i+1));\n  }\n  float t = z + 8.0 - 0.5;\n  return sqrt(2.0*PI) * pow(t,z+0.5) * exp(-t) * x;\n}\n\n// beta function\nfloat B(float a, float b) {\n  return (gamma(a)*gamma(b))/gamma(a+b);\n}\n\nvec2 inversesc(vec2 z, int K) {\n  float cn[6];\n  for (int n = 1; n <= 5; n++) {\n    cn[n] = binomial(float(n)-1.0+2.0/float(K),n)/float(1+n*K);\n  }\n  float C = B(1.0/float(K),1.0-2.0/float(K))/float(K);\n  z *= C;\n  vec2 h = cpow(z,int(K));\n  float T1 = -cn[1];\n  float T2 = -cn[2]+float(K+1)*pow(cn[1],2.0);\n  float T3 = -cn[3]+float(3*K+2)*(cn[1]*cn[2]-float(K+1)/2.0*pow(cn[1],3.0));\n  float T4 = -cn[4]+float(2*K+1)*(2.0*cn[1]*cn[3]+pow(cn[2],2.0)-float(4*K+3)*\n                                  (pow(cn[1],2.0)*cn[2]-float(K+1)/3.0*pow(cn[1],4.0)));\n  float T5 = -cn[5]+float(5*K+2)*(cn[1]*cn[4]+cn[2]*cn[3]+float(5*K+3)*\n            (-0.5*pow(cn[1],2.0)*cn[3]-0.5*cn[1]*pow(cn[2],2.0)+float(5*K+4)*\n            (pow(cn[1],3.0)*cn[2]/6.0-float(K+1)*pow(cn[1],5.0)/24.0)));\n  vec2 X = vec2(1,0)+h/pow(C,float(K));\n  vec2 w = cmul(z,vec2(1,0) + T1*h + T2*cpow(h,2) + T3*cpow(h,3) + T4*cpow(h,4) + cdiv(T5*cpow(h,5),X));\n  return w;\n}\n\n// map spherical platonic solid pyramidal sectors to one sector located at -z-axis.\n\nvec2 hexgrid2hex(in vec2 Z, out vec3 U_id) {\n    const float\n        SQRT3 = sqrt(3.),\n        SQRT_3 = 1./SQRT3;\n\tconst mat2\n        M = mat2(SQRT_3,-1.,-SQRT_3,-1.),\n        iM = 0.5*mat2(SQRT3,-SQRT3,-1.,-1.);\n    Z = crot(Z,PI/6.);\n    Z = iM*Z/0.75;\n    vec3 U = vec3(Z.x,-Z.x-Z.y,Z.y);\n    U_id = 2.*floor(U*0.5+0.5);\n    vec3 U_lo = U-U_id;\n    vec3 aU_lo = abs(U_lo);\n    if (aU_lo.x > aU_lo.y && aU_lo.x > aU_lo.z) {\n        U_lo.x = -U_lo.y-U_lo.z;\n        U_id.x = -U_id.y-U_id.z;\n    }\n    if (aU_lo.y > aU_lo.z) {\n        U_lo.y = -U_lo.x-U_lo.z;\n        U_id.y = -U_id.x-U_id.z;\n    }\n    else {\n        U_lo.z = -U_lo.x-U_lo.y;\n        U_id.z = -U_id.x-U_id.y;\n    }\n    Z = U_lo.rb;\n    Z = M*Z*0.75;\n    return crot(Z,-PI/6.);\n}\n\n// regular circular arc triangle -> unitcircle conformal mapping by using a barycentric approximation\nvec2 cHexaPolyArc2disk(vec2 z) {\n    // https://people.maths.ox.ac.uk/trefethen/lightning.html\n    const int NUM_j = 18; // poles\n    const vec2[] rf = vec2[NUM_j]\n    (vec2( 0.7072, -0.7070)\n    ,vec2(-0.7070,  0.7072)\n    ,vec2(-0.0377, -0.9993)\n    ,vec2( 0.7072,  0.7070)\n    ,vec2(-0.7072, -0.7070)\n    ,vec2(-0.0377,  0.9993)\n    ,vec2( 0.5452, -0.8383)\n    ,vec2( 0.9936,  0.1126)\n    ,vec2(-0.9936,  0.1126)\n    ,vec2(-0.7983, -0.6022)\n    ,vec2(-0.7563,  0.6542)\n    ,vec2( 0.6542,  0.7563)\n    ,vec2( 0.7563, -0.6542)\n    ,vec2(-0.6235,  0.7818)\n    ,vec2(-0.7167, -0.6974)\n    ,vec2(-0.6542, -0.7563)\n    ,vec2( 0.7342,  0.6790)\n    ,vec2( 0.7025, -0.7117));\n\n    const vec2[] rw = vec2[NUM_j]\n    (vec2( 0.0135,  0.0   )\n    ,vec2( 0.0008,  0.0001)\n    ,vec2(-0.5762,  0.1282)\n    ,vec2( 0.0013,  0.0002)\n    ,vec2(-0.0135, -0.0085)\n    ,vec2( 0.1239, -0.0601)\n    ,vec2(-0.2162, -0.3769)\n    ,vec2( 0.1197, -0.1327)\n    ,vec2( 0.2544,  0.0708)\n    ,vec2( 0.3228,  0.3050)\n    ,vec2( 0.0377, -0.0056)\n    ,vec2( 0.0362, -0.0135)\n    ,vec2( 0.1439, -0.0871)\n    ,vec2( 0.0551,  0.0066)\n    ,vec2(-0.0935,  0.1492)\n    ,vec2(-0.2397,  0.1216)\n    ,vec2( 0.0218, -0.0211)\n    ,vec2( 0.0077, -0.0763));\n\n    const vec2[] rz = vec2[NUM_j]\n    (vec2( 0.366242, -0.365216)\n    ,vec2(-0.365216,  0.366242)\n    ,vec2(-0.012767, -0.414156)\n    ,vec2( 0.366242,  0.365216)\n    ,vec2(-0.366242, -0.365216)\n    ,vec2(-0.012767,  0.414156)\n    ,vec2( 0.216186, -0.397592)\n    ,vec2( 0.413695,  0.038296)\n    ,vec2(-0.413695,  0.038296)\n    ,vec2(-0.391705, -0.251311)\n    ,vec2(-0.383838,  0.291533)\n    ,vec2( 0.291533,  0.383838)\n    ,vec2( 0.383838, -0.291533)\n    ,vec2(-0.266502,  0.388876)\n    ,vec2(-0.372411, -0.341303)\n    ,vec2(-0.291533, -0.383838)\n    ,vec2( 0.378349,  0.316470)\n    ,vec2( 0.350877, -0.369995));\n\n    // polynomial barycentric representation\n    vec2 zn = vec2(0.); vec2 zd = vec2(0.);       \n    for(int j = 0; j<NUM_j; j++) {\n        vec2 zj = cdiv( rw[j], (z-rz[j]));\n        zn += cmul(rf[j], zj); // sum nominator\n        zd += zj;              // sum denominator\n    }\n    return cdiv(zn, zd);\n}\n\n// map spherical platonic solid pyramidal-face-cells to one cell located at -z-axis.\nvec3 hexa_cells(in vec3 p, out float cell_id, out float sr) {\n\t//// hexagon\n    // cells +X, -X, +Y, -Y,+Z, -Z\n    // cell walls defined by the face_normals\n    bool nBA = dot(vec3( 1., 0.,-1.),p)>=0.;\n\tbool nCA = dot(vec3( 0., 1.,-1.),p)>=0.;\n\tbool nDA = dot(vec3( 1., 1., 0.),p)>=0.;\n\tbool nCB = dot(vec3(-1., 1., 0.),p)>=0.;\n\tbool nDB = dot(vec3( 0., 1., 1.),p)>=0.;\n\tbool nDC = dot(vec3( 1., 0., 1.),p)>=0.;\n    // map (+X, -X, +Y, -Y,+Z, -Z)-cells to (-Z)-cell by rotation\n    // rotation angles\n    const float a90 = PI/2.; // a = 90Â°       \n    const vec2 ei_a0   = vec2(1., 0.);             // a = 0Â° \n    const vec2 ei_a90  = vec2(cos(a90), sin(a90)); // a = 90Â°\n    \n    vec2 ei_y; vec2 ei_x;\n\t//inside cell +X: +X --> -Z\n\tif(nBA && nDA && !nCB && nDC) {\n\t\tcell_id = 0.;\n\t\tei_y = ei_a90;\n\t\tei_x = ei_a0;\n\t}\n\t//inside cell -X: -X --> -Z\n\telse if(!nBA && !nDA && nCB && !nDC) {\n\t\tcell_id = 1.;\n\t\tei_y = -ei_a90;\n\t\tei_x = ei_a0;\n\t}\n    //inside cell +Y: +Y --> -Z\n\telse if(nCA && nDA && nCB && nDB) {\n\t\tcell_id = 2.;\n\t\tei_y = -ei_a90;\n\t\tei_x = -ei_a90;\n\t}\n\t//inside cell -Y: -Y --> -Z\n\telse if(!nCA && !nDA && !nCB && !nDB ) {\n\t\tcell_id = 3.;\n\t\tei_y = ei_a90;\n\t\tei_x = ei_a90;\n\t}\n\t//inside cell +Z: +Z --> -Z\n\telse if(!nBA && !nCA && nDB && nDC) {\n\t\tcell_id = 4.;\n\t\tei_y = -ei_a0; // 180Â°\n\t\tei_x = ei_a0;\n\t}\n\t//inside cell -Z: -Z --> -Z\n\telse if(nBA && nCA && !nDB && !nDC) {\n\t\tcell_id = 5.;\n\t\tei_y = ei_a0;\n\t\tei_x = ei_a0;\n\t}        \n\t// cell orientation\n\tp.zx = cmul(p.zx,ei_y); // rotate around y-axis\n\tp.yz = cmul(p.yz,ei_x); // rotate around x-axis\n\t// non cyclic\n\tsr = 4.;\n    return p;\n}\n\n// distribution\nfloat sig(float x) {\n    return x < 0. ? -1. : +1.;\n}\n\nfloat dist(float x, float e) {\n    // e in [0., +inf]\n    return sign(x)*abs( pow(abs(x), abs(e)) );\n}\n   \nvec2 r_poly_dist(vec2 z, vec2 e, float sh_a) {   \n    /// r-polygon-distribution\n    float r = length(z); z = (r<0.)? vec2(0) : z/r; \n    float d0 = 0.5 *abs(e.y-e.x);\n    float e2 = e.x + d0 + d0 * (2.*smoothstep(-1., 1., -sh_a) - 1.);\n    return dist(r, e2) * z;\n}   \n\n// stereographic projection\nvec3 sp(vec3 zsr){\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // stereopraphic projection (complex plane to unit sphere)\n    float zz = dot(z,z); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(2. * z.x,  2. * z.y, -1. + zz);\n        }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(2. * z.x, -2. * z.y,  1. - zz);\n        }\n    pn /= 1.+zz;\n    return pn;\n}\n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// sdf\nfloat opIntersection( float d1, float d2 ) {\n    return max(d1,d2); }\n\nfloat opSmoothUnion( in float d1, in float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, float r ) {\n  return length(p.xz)-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// color\nvec3 h2rgb(float h) {\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n}\n\n// srgb <--> rgb (linear)\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mff3zH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1151, 1151, 1173, 1173, 3476], [3478, 3491, 3545, 3545, 4114], [4116, 4116, 4161, 4161, 4323], [4325, 4325, 4367, 4367, 4618], [4620, 4632, 4659, 4685, 4843], [4857, 4857, 4893, 4917, 5083], [5085, 5085, 5128, 5128, 5319], [5321, 5321, 5377, 5377, 5559], [5561, 5569, 5616, 5639, 8399]], "test": "untested"}
{"id": "lfXGzH", "name": "Simple buffered audio visualizer", "author": "rafa_br34", "description": "Just a simple audio visualizer that I did primarily to test the inputs.\nBuffer A: Audio processing\nBuffer B: IO\nA/D: Decrease/Increase size\nSet the audio in the Buffer A tab.", "tags": ["audio", "visualizer", "buffered"], "likes": 2, "viewed": 179, "published": 3, "date": "1702730812", "time_retrieved": "2024-07-30T17:16:14.160792", "image_code": "void mainImage(out vec4 FragColor, in vec2 FragCoord) {\n    FragColor = READP_V4(C_AudioBuffer, FragCoord);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Tracks:\n// https://soundcloud.com/azerkd/balaganazerkd-bootleg-skazi-free-download\n// https://soundcloud.com/nocopyrightsounds/oneeva-platform-9-ncs-release\n// https://soundcloud.com/monstercat/ephixa-dreamstate\n// https://soundcloud.com/alteza-records/whiteno1se-terra-astro-alteza-records\n\n\nvoid mainImage(out vec4 FragColor, in vec2 FragCoord) {\n    if (FragCoord.y <= 1.0) {\n        float Size = mix(512.0, float(RESX), READP_V4(C_DataBuffer, ivec2(1, 1)).x);\n        float X = (FragCoord.x / Size) * 512.0;\n        \n        FragColor = vec4(\n            READP_V4(C_AudioInput, ivec2(X, 0)).x,\n            0.0,\n            READP_V4(C_AudioInput, ivec2(X, 1)).x,\n            1.0\n        );\n    }\n    else {\n        FragColor = READP_V4(C_AudioBuffer, ivec2(FragCoord + vec2(0.0, -1.0)));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35518, "src": "https://soundcloud.com/monstercat/ephixa-dreamstate", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#define C_AudioBuffer iChannel0\n#define C_DataBuffer iChannel1\n#define C_AudioInput iChannel2\n#define C_Keyboard iChannel3\n\n\n#define RESX uint(iResolution.x)\n#define RESY uint(iResolution.y)\n\n#define FLATTEN_V2(Width, Vector) ((Width) * (Vector).y + (Vector).x)\n\n#define READP_V4(Buffer, Position) texelFetch(Buffer, ivec2(Position), 0)\n#define READP_F32(Buffer, Position) READP_V4(Buffer, ivec2(Position) / 4)[FLATTEN_V2(2, ivec2(Position)) % 4]\n#define READP_U8(Buffer, Position) READP_F32(Buffer, ivec2(Position) / 4)[FLATTEN_V2(2, ivec2(Position)) % 4]\n\n\n#define READI_V4(Buffer, Index) READP_V4(Buffer, ivec2(uint(Index) % RESX, uint(Index) / RESX))\n#define READI_F32(Buffer, Index) READI_V4(Buffer, uint(Index) / 4u)[uint(Index) % 4u]\n#define READI_U8(Buffer, Index) (uint(READI_F32(Buffer, uint(Index) / 4u)) & (0xFFu << ((Index % 4u) * 8u))) >> ((Index % 4u) * 8u)\n\n#define RAND_STATE(Coord) ((RESX * uint(Coord.y) + uint(Coord.x) + 1u) * uint(iFrame))\n\n#define UI8(V) uint(int(V) % 256)\n#define FUI8(V) float(UI8(V)) / 255.0", "buffer_b_code": "\n\n\nvoid mainImage(out vec4 FragColor, in vec2 FragCoord) {\n    float Size = READP_V4(C_DataBuffer, ivec2(0, 0)).x;\n    \n    // Keycode A\n    if (READP_V4(C_Keyboard, ivec2(65, 0)).x > 0.0 && Size > 0.0) Size -= 0.004;\n    \n    // Keycode D\n    if (READP_V4(C_Keyboard, ivec2(68, 0)).x > 0.0 && Size < 1.0) Size += 0.004;\n    \n    \n    FragColor = vec4(Size, 0.0, 0.0, 0.0);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lfXGzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 109]], "test": "untested"}
{"id": "lcfGRH", "name": "truchet hexagonal tetrahedron", "author": "cyperus", "description": "truchet 3d - toroidal hexagonal grid - spherical toroidal tetrahedron", "tags": ["3d", "sdf", "hexagon", "truchet", "tetrahedron", "schwarzchristoffel"], "likes": 4, "viewed": 194, "published": 3, "date": "1702727171", "time_retrieved": "2024-07-30T17:16:15.102274", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"truchet hexagonal tetrahedron\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n//\n// References & Inspiration:\n//\n// - quick guide for shadertoy by FabriceNeyret2\n//   https://shadertoyunofficial.wordpress.com/\n//\n// - \"Schwarz-Christoffel Mapping\" by mla\n//   https://www.shadertoy.com/view/tsfyRj\n//\n// - conformal mapping with confmap.m by Trefethen\n//   https://people.maths.ox.ac.uk/trefethen/lightning.html\n//\n// - signed distance functions & operations by iq\n//   https://iquilezles.org/articles/distfunctions/\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// ray casting bounding shape\nconst float\n    CAM_DIST = 6.,\n    CAM_FLE = 2.,\n    BB_DIST = 2.6,\n    RAY_MIN_DIST = 0.1,\n    RAY_MAX_DIST = CAM_DIST+1.1*BB_DIST;   \n\nconst int MAX_MARCHING_STEPS = 600;\nconst float\n    RAY_STEP_FACTOR = 0.0095,\n    RAY_PRECISION = 1.E-1;\n\n// data from sdf\nvec3 mat_to = vec3(0);\nvec3 mat_to_id = vec3(0);\nvec4 mat_tc = vec4(0);\n\nfloat map(in vec3 p) {\n    float rxy = 0., au = 0.0, av = 0.0;\n    vec2 z = vec2(0.);\n    float d = -1.;\n           \n    /// map platonic solid cells to one cell\n    vec3 pn = normalize(p); \n  \n    // projection from n cells to 1 cell.\n    float cell_id = 0., sr = 0.;\n    pn = tetra_cells(pn, cell_id, sr);\n    z = pn.xy/(1.-pn.z);\n    z = cTeraPolyArc2disk(z);\n\n    // r-polygon-distribution\n    vec2 e = vec2(sqrt(2.), 0.5);\n    float en = 1.+( (8.<0.?e.x:e.y)-1. )*smoothstep(1.,5., abs(8.));        \n    float r = length(z); vec2 zn = z/r;\n    z = dist(r, en) * zn;   \n\n    // stereograpic projection    \n    pn = sp(vec3(z,sr));\n\n    // scale radius\n    p = length(p) * pn;\n    \n    p = p.yzx;\n\n    /// torus\n    z = vec2(length(p.zx), p.y);\n    au = atan(p.x, p.z);\n    \n    z = cmul(z,z); z.x -= 4.;\n    av = atan(z.y, z.x);\n    rxy = length(z);\n    \n    vec2 grid_hex_num = 9. * vec2(3.,1.);\n    p = vec3(grid_hex_num.x*au/PI, grid_hex_num.y* 0.5*sqrt(3.)* av/PI, log(rxy)-0.4);\n\n    /// regular hexagonal tiles\n    vec3 rpt_id = vec3(1.); vec3 p_hex;    \n    p.xy = hexgrid2hex(p.xy, rpt_id);    \n    p.xy = inversesc(p.xy, int(6.));\n    mat_to_id = rpt_id;\n\n    // torus,sphere,2spheres       \n    rxy = length(p.xy); au = atan(p.y, p.x);    \n    z = 2.*ccos(PI*vec2(rxy,2.*p.z));\n    z.x += (3. + 2. * sin(2.*PI*iTime/60.));\n            \n    p = vec3(log(length(z))-0.02, 0.5*au/PI, 0.5*atan(z.y,z.x)/PI);\n    \n    vec2 to_uv = p.yz;\n    float to_d = log(length(z)+0.8);\n    mat_to = vec3(to_uv,to_d);   \n\n    /// truchet 3D cube grid\n    vec3 tc_id = vec3(0.); float tc_a = 0.;   \n    p *= vec3(1.,18.,4.); // r,u,v\n    p.yzx = p.xyz;\n    \n    ivec3 l0 = -ivec3(2.,0,9.);\n    ivec3 l1 = ivec3(2.,1.,9.)-ivec3(1.);\n    tc_id = floor(p);\n    tc_id = clamp(tc_id, vec3(l0), vec3(l1));\n    vec3 q = p - tc_id -0.5;\n\n    // truchet 3D cube tiles\n    float rnd = hash21(tc_id.xz);\n    if(rnd<.5) q.x = -q.x;\n    if(fract(rnd*77.57+iTime/6.)>.75) {\n       vec3 q2 =  length(q.xz-.5)<length(q.xz+.5)\n                ? vec3(q.xz-.5,0.)  \n                : vec3(q.xz+.5,1.);\n       d = sdTorus( vec3(q2.x, q.y, q2.y) , vec2(0.5,0.125) );\n    }\n    else {\n       d = opSmoothUnion( sdCylinder( q.zxy, 0.125 ), sdCylinder( q.xzy, 0.125 ), 0.05 );\n    }\n    mat_tc = vec4(q,rnd);  \n   \n    // return\n    return min(d,to_d);\n}\n\n// intersect\nfloat intersect(in vec3 ro, in vec3 rd, in float px) {\n    float res = -1.0;\n    \n    // bb\n    vec2 dis = isphere( ro, rd , abs(BB_DIST));    \n    if( dis.y<0.0 ) return -1.0;\n    dis.x = max( dis.x, RAY_MIN_DIST );\n    dis.y = min( dis.y, RAY_MAX_DIST );\n\n    // raymarch signed distance field    \n\tfloat fh = RAY_STEP_FACTOR;\n    float t = dis.x;\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) {\n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t;\n        float h = map( pos);\n        if( t>dis.y || h<th ) break;\n        t += h*fh;\n    }\n    if( t<dis.y ) {\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) { \n\tif (iMouse.x > 0.0) {\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n    //p.yz = crot(p.yz,-1.*PI*(time+10.));\n    //p.zx = crot(p.zx,-2.*PI*(time+15.));\n\treturn p.xyz;\n}\n\n// textures\nfloat grid_uv(in vec2 uv) {\n    // uv grid alpha mask\n    vec2 sw = abs(fract(uv-0.25)-0.5)-0.25;\n    float sdf = min(sw.x,sw.y)*-max(sw.x,sw.y);\n    float pp = fwidth(sdf);\n    return smoothstep(+pp,-pp,sdf);\n}\n            \nvec4 cells(in vec2 uv, in float h) {\n    // sectors, uv-grid\n    vec4 C;\n    C.a = 1.;\n    C.rgb = h2rgb(h);                      // sector  -> hue\n    C.rgb *= (0.5+ 0.5 * grid_uv(uv))*0.7; // uv-grid -> value\n    return C;\n}\n\nvec4 ribbon(in float uv_x, in float time) {\n    float sdf = -(2.*pulsecollision(1.,1./3. * uv_x, time, 1./3.)-1.);\n    float px = fwidth(sdf); float a = smoothstep(px+0.1,-px-0.1,sdf+0.2);    \n    return vec4( h2rgb(sdf -2./6.),a );\n}\n\nvec4 truchet3D(in vec3 p, in float rnd ,in float time) {\n    float sdf = sdBox( p, vec3(0.5*0.9));\n    float px = fwidth(sdf); float a = smoothstep(px,-px,sdf);\n    return mix(vec4(1.), vec4(h2rgb( fract(abs(rnd)*22.93 + time)),1.), a);\n}\n\n// main\nvoid mainImage(out vec4 O, in vec2 fragCoord) {\n    // normalized time\n    float ntime = iTime/360.;\n\n    // anti-aliasing to take a picture\n    vec3 tot = vec3(0.0);\n    #define AA 1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {       \n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o) - iResolution.xy)/iResolution.y;\n        \n        // camera viewport --> worldspace\n        vec3 ro = vec3(0,0,-CAM_DIST);\n        vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n             ro = transform(ro,ntime);\n             rd = normalize(transform(rd,ntime));\n        \n        // distance hit ray surface\n        float px = 2.0/( iResolution.y*CAM_FLE );\n        float t = intersect( ro, rd, px );\n\n        // background\n        vec3 sky_col = vec3(0.);\n        vec4 C = vec4(sky_col,1.);\n        O = C;\n        \n        // object surface\n        if (t >= 0.) {\n            // surface properties\n            vec3 p = ro + rd * t;\n            vec3 n = calcNormal( p, 0.001);\n            \n            // draw textures\n            O = vec4(0);\n\n            if(O.a<1.) {          \n                float hue = (mat_to_id.x + 2.)/4. + (mat_to_id.z )/8.;\n                C = cells(mat_to.xy/2., hue);\n                C.a = mat_to.z>0.5 ? 0.5 : O.a;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n\n            if(O.a<1.) {\n                C =  mat_to.z<0.5 ? ribbon( 6.*3.* mat_to.x,  6.*ntime) : vec4(0.);\n                C.rgb *= 0.7;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n\n            if(O.a<1.) {\n                C = truchet3D(mat_tc.xyz, mat_tc.w, ntime);\n                C.a = 0.5; C.rgb *= 0.5;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n\n            C = O;\n                       \n            // lighting\n            vec3  came_li_o   = transform(vec3(-10.,10.,-10.),ntime); // origine\n            vec3  came_li_dir = normalize(p - came_li_o);             // direction\n            vec3  came_li_col = vec3(1.,1.,.5);                       // color\n            float came_li_shi = 10.;                                  // shininess            \n\n            float cosa = 1.;\n            O.rgb += 0.1 * cosa * C.rgb * sky_col;           // amb\n            cosa = clamp(dot(-came_li_dir, n), 0., 1.);\n            O.rgb += 0.5 * cosa * C.rgb * came_li_col;       // dif       \n            cosa = pow(clamp(dot(reflect(came_li_dir, n), -rd), 0., 1.), came_li_shi);           \n            O.rgb += 0.4 *(cosa>0.? cosa:0.) * came_li_col ; // spec\n            \n            // fog\n            O.rgb = mix(O.rgb, sky_col, 1.0 - exp(-5.E-3 * pow(t,3.)));    \n        }\n        tot += O.rgb;\n    }\n    tot /= float(AA*AA);\n    \n    // gamma correction\n    O = vec4(rgb2srgb(tot),1.);\n}", "image_inputs": [], "common_code": "// const\nconst float PI = abs(atan(0.,-1.));\n\n// 1D transformations\nfloat pulsecollision(in float pf, in float x, in float x0, in float pw) {\n    float ntriw_p = abs( fract( pf*(x - x0) )-0.5);\n    float ntriw_n = abs( fract( pf*(x + x0) )-0.5);\n    float pp = smoothstep( 0.5*pw, 0., ntriw_p );\n    float pn = smoothstep( 0.5*pw, 0., ntriw_n );\n    return (pp+pn);\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);\n}\n\n// complex\nvec2 cmul(vec2 za,vec2 zb) {\n    return za*mat2(zb.x,-zb.y,zb.yx);\n}\n\nvec2 crot(vec2 z,float a) {\n    return cmul(vec2(cos(a),sin(a)),z);\n}\n\nvec2 cinv(vec2 z) {\n    return z*vec2(1,-1)/dot(z,z);\n}\n    \nvec2 cdiv(vec2 z, vec2 w) {\n    return cmul(z,cinv(w));\n}\n    \nvec2 cpow(vec2 z, int n) {\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));\n}\n  \nvec2 csqr(vec2 z) {\n    return vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y );\n}\n\nvec2 ccos(vec2 z) {\n    vec2 d=vec2(exp(z.y),exp(-z.y));\n\treturn vec2(cos(z.x)*(d.x+d.y)*.5,-sin(z.x)*(d.x-d.y)*.5);\n}\n\nfloat binomial(float a, int n) {\n   float s = 1.0;\n   for (int i = n; i >= 1; i--,a--) {\n     s *= float(a)/float(i);\n   }\n   return s;\n}\n\nvec2 expi(float x) {\n  return vec2(cos(x),sin(x));\n}\n\nfloat gamma(float z) {\n  const float[8] p = float[](\n    676.5203681218851,\n    -1259.1392167224028,\n    771.32342877765313,\n    -176.61502916214059,\n    12.507343278686905,\n    -0.13857109526572012,\n    9.9843695780195716e-6,\n    1.5056327351493116e-7\n  );\n  z -= 1.0;\n  float x = 0.99999999999980993;\n  for (int i = 0; i < 8; i++) {\n    float pval = p[i];\n    x += pval/(z+float(i+1));\n  }\n  float t = z + 8.0 - 0.5;\n  return sqrt(2.0*PI) * pow(t,z+0.5) * exp(-t) * x;\n}\n\n// beta function\nfloat B(float a, float b) {\n  return (gamma(a)*gamma(b))/gamma(a+b);\n}\n\nvec2 inversesc(vec2 z, int K) {\n  float cn[6];\n  for (int n = 1; n <= 5; n++) {\n    cn[n] = binomial(float(n)-1.0+2.0/float(K),n)/float(1+n*K);\n  }\n  float C = B(1.0/float(K),1.0-2.0/float(K))/float(K);\n  z *= C;\n  vec2 h = cpow(z,int(K));\n  float T1 = -cn[1];\n  float T2 = -cn[2]+float(K+1)*pow(cn[1],2.0);\n  float T3 = -cn[3]+float(3*K+2)*(cn[1]*cn[2]-float(K+1)/2.0*pow(cn[1],3.0));\n  float T4 = -cn[4]+float(2*K+1)*(2.0*cn[1]*cn[3]+pow(cn[2],2.0)-float(4*K+3)*\n                                  (pow(cn[1],2.0)*cn[2]-float(K+1)/3.0*pow(cn[1],4.0)));\n  float T5 = -cn[5]+float(5*K+2)*(cn[1]*cn[4]+cn[2]*cn[3]+float(5*K+3)*\n            (-0.5*pow(cn[1],2.0)*cn[3]-0.5*cn[1]*pow(cn[2],2.0)+float(5*K+4)*\n            (pow(cn[1],3.0)*cn[2]/6.0-float(K+1)*pow(cn[1],5.0)/24.0)));\n  vec2 X = vec2(1,0)+h/pow(C,float(K));\n  vec2 w = cmul(z,vec2(1,0) + T1*h + T2*cpow(h,2) + T3*cpow(h,3) + T4*cpow(h,4) + cdiv(T5*cpow(h,5),X));\n  return w;\n}\n\nvec2 hexgrid2hex(in vec2 Z, out vec3 U_id) {\n    const float\n        SQRT3 = sqrt(3.),\n        SQRT_3 = 1./SQRT3;\n\tconst mat2\n        M = mat2(SQRT_3,-1.,-SQRT_3,-1.),\n        iM = 0.5*mat2(SQRT3,-SQRT3,-1.,-1.);\n    Z = crot(Z,PI/6.);\n    Z = iM*Z/0.75;\n    vec3 U = vec3(Z.x,-Z.x-Z.y,Z.y);\n    U_id = 2.*floor(U*0.5+0.5);\n    vec3 U_lo = U-U_id;\n    vec3 aU_lo = abs(U_lo);\n    if (aU_lo.x > aU_lo.y && aU_lo.x > aU_lo.z) {\n        U_lo.x = -U_lo.y-U_lo.z;\n        U_id.x = -U_id.y-U_id.z;\n    }\n    if (aU_lo.y > aU_lo.z) {\n        U_lo.y = -U_lo.x-U_lo.z;\n        U_id.y = -U_id.x-U_id.z;\n    }\n    else {\n        U_lo.z = -U_lo.x-U_lo.y;\n        U_id.z = -U_id.x-U_id.y;\n    }\n    Z = U_lo.rb;\n    Z = M*Z*0.75;\n    return crot(Z,-PI/6.);\n}\n\n// regular circular arc triangle -> unitcircle conformal mapping by using a barycentric approximation\nvec2 cTeraPolyArc2disk(vec2 z) {\n    const int NUM_j = 15;\n    const vec2[NUM_j] rf = vec2[]\n    (vec2(-0.4534, -0.8913)\n    ,vec2( 0.5001,  0.8660)\n    ,vec2(-1.0000,  0.0001)\n    ,vec2( 0.5008, -0.8656)\n    ,vec2(-0.5452,  0.8383)\n    ,vec2( 0.1901,  0.9818)\n    ,vec2( 0.9875, -0.1576)\n    ,vec2(-0.9856, -0.1691)\n    ,vec2( 0.4224, -0.9064)\n    ,vec2( 0.5738,  0.8190)\n    ,vec2(-0.9995,  0.0311)\n    ,vec2( 0.4858,  0.8741)\n    ,vec2( 0.5760, -0.8175)\n    ,vec2(-1.0000, -0.0061)\n    ,vec2( 0.4959, -0.8684));\n    \n    const vec2[NUM_j] rw = vec2[]\n    (vec2( 0.2728,  0.0   )  \n    ,vec2( 0.0003,  0.0126)\n    ,vec2(-0.0016, -0.0121)\n    ,vec2(-0.0172,  0.0324)\n    ,vec2( 0.1417, -0.4629)\n    ,vec2(-0.4681, -0.2288)\n    ,vec2(-0.2433,  0.2822)\n    ,vec2( 0.1996, -0.0082)\n    ,vec2( 0.2884, -0.0353)\n    ,vec2(-0.0666,  0.1824)\n    ,vec2(-0.0357, -0.1136)\n    ,vec2(-0.1091,  0.0396)\n    ,vec2(-0.0831,  0.2627)\n    ,vec2( 0.0598, -0.0284)\n    ,vec2( 0.0597,  0.0760));\n\n    const vec2[NUM_j] rz = vec2[]\n    (vec2(-0.239570, -0.459171)\n    ,vec2( 0.354172,  0.611300)\n    ,vec2(-0.706487,  0.001072)\n    ,vec2( 0.356785, -0.606740)\n    ,vec2(-0.277869,  0.437059)\n    ,vec2( 0.047259,  0.573454)\n    ,vec2( 0.515842, -0.066306)\n    ,vec2(-0.591622, -0.166501)\n    ,vec2( 0.221135, -0.605193)\n    ,vec2( 0.413545,  0.494105)\n    ,vec2(-0.671697,  0.057599)\n    ,vec2( 0.309337,  0.611574)\n    ,vec2( 0.414577, -0.491758)\n    ,vec2(-0.695342, -0.019940)\n    ,vec2( 0.334074, -0.612218));\n\n    // polynomial barycentric representation\n    vec2 zn = vec2(0.); vec2 zd = vec2(0.);       \n    for(int j = 0; j<NUM_j; j++)\n    {\n        vec2 zj = cdiv( rw[j], (z-rz[j]));\n        zd += zj; // sum denominator\n        zn += cmul(rf[j], zj); // sum nominator\n    }\n    return cdiv(zn, zd);;\n}\n\n// map spherical platonic solid pyramidal sectors to one sector located at -z-axis.\nvec3 tetra_cells(in vec3 p, out float cell_id, out float sr) {\n\t//// tetrahedron (bounded by a cube)\n\t// cells: A,B,C,D\n\t// cell walls defined by the face_normal\n    bool nBA = dot(vec3( 1., 0.,-1.),p)>=0.;\n\tbool nCA = dot(vec3( 0., 1.,-1.),p)>=0.;\n\tbool nDA = dot(vec3( 1., 1., 0.),p)>=0.;\n\tbool nCB = dot(vec3(-1., 1., 0.),p)>=0.;\n\tbool nDB = dot(vec3( 0., 1., 1.),p)>=0.;\n\tbool nDC = dot(vec3( 1., 0., 1.),p)>=0.;\n    \n    // map n-cells to 1-cell by rotation\n    // rotation angles\n    const float a45 = PI/4.;             // 45Â° \n    const float a35 = atan(sqrt(8.))/2.; // 35.264Â°\n    const float a30 = PI/6.;             // 30Â°\n    \n    const vec2 ei_a45 = vec2(cos(a45), sin(a45));\n    const vec2 ei_a35 = vec2(cos(a35), sin(a35));\n    const vec2 ei_a30 = vec2(cos(a30), sin(a30));\n    \n    vec2 ei_y = ei_a45;   \n    vec2 ei_x = ei_a35;\n    vec2 ei_z = ei_a30;\n    // symmetries\n    if(nBA && nCA && nDA) //inside cell A\n\t{\n\t\tcell_id =  0.;\n        ei_x.y *= -1.; // a = -35.264Â°\n\t}\n\telse if( nCB && nDB && !nBA) //inside cell B\n\t{\n\t\tcell_id =  1.;\n\t\tei_y   *= -1.; // a = -3.*45Â°\n        ei_x.y *= -1.; // a = -35.264Â°\n\t}\n\telse if(!nCA && !nCB && nDC) //inside cell C\n\t{\n\t\tcell_id =  2.;\n\t\tei_y.x *= -1.; // a = +3.*45Â°\n\t\tei_z.y *= -1.; // a = -30Â°\n\t}\n\telse if(!nDA && !nDB && !nDC)//inside cell D\n\t{\n\t\tcell_id =  3.;\n\t\tei_y.y *= -1.; // a = -45Â°\n\t\tei_z.y *= -1.; // a = -30Â°\n\t}\n\tp.zx = cmul(p.zx,ei_y); // y-axis\n\tp.yz = cmul(p.yz,ei_x); // x-axis\n\tp.xy = cmul(p.xy,ei_z); // z-axis\n\t// 3 edges per face, non cyclic\n\tsr = 3.;\n    return p;\n}\n\n// distribution\nfloat sig(float x) {\n    return x < 0. ? -1. : +1.;\n}\n\nfloat dist(float x, float e) {\n    // e in [0., +inf]\n    return sign(x)*abs( pow(abs(x), abs(e)) );\n}\n\nvec3 sp(vec3 zsr){\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // stereopraphic projection (complex plane to unit sphere)\n    float zz = dot(z,z); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(2. * z.x,  2. * z.y, -1. + zz);\n        }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(2. * z.x, -2. * z.y,  1. - zz);\n        }\n    pn /= 1.+zz;\n    return pn;\n}\n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// sdf\nfloat opIntersection( float d1, float d2 ) {\n    return max(d1,d2); }\n\nfloat opSmoothUnion( in float d1, in float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, float r ) {\n  return length(p.xz)-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// color\nvec3 h2rgb(float h) {\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n}\n\n// srgb <--> rgb (linear)\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcfGRH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1152, 1152, 1174, 1174, 3477], [3479, 3492, 3546, 3546, 4115], [4117, 4117, 4162, 4162, 4324], [4326, 4326, 4368, 4368, 4619], [4621, 4633, 4660, 4686, 4844], [4858, 4858, 4894, 4918, 5084], [5086, 5086, 5129, 5129, 5320], [5322, 5322, 5378, 5378, 5560], [5562, 5570, 5617, 5640, 8400]], "test": "untested"}
{"id": "lcfGz8", "name": "Soddy circles - infinite zoom 3", "author": "FabriceNeyret2", "description": "golfing 974 chars version https://shadertoy.com/view/mdy3W3\nthat was simplifying 1979 chars \"Soddy circles - infinite zoom\" by DjinnKahn. https://shadertoy.com/view/ddyGRd\n", "tags": ["fractal", "zoom", "short", "golf", "gasket", "appollonian", "soddy"], "likes": 24, "viewed": 266, "published": 3, "date": "1702725679", "time_retrieved": "2024-07-30T17:16:15.851272", "image_code": "// golfing 974 \"Soddy circles - infinite zoom 2\" by FabriceNeyret2. https://shadertoy.com/view/mdy3W3\n// simplifying 1979 chars \"Soddy circles - infinite zoom\" by DjinnKahn. https://shadertoy.com/view/ddyGRd\n//    circle: use vec3 instead of struct(point,radius)\n//    inversion: use mat3 instead of vec3(mat2*p.xy, z)\n//    + more simplifs\n\n// -27 by SnoopethDuckDuck , -4 by Elsio, -4 by Fab\n\n#define I(c)     (c) / dot( c, (c) * w )            // inversion\n#define P(n)     cos( (n-i) * 2.237 -vec2(0,1.57) ) //\n#define L        length//\n#define v        vec3\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float n = 3., // v = -1., \n          z = iTime * n, \n          i = floor(z);\n      \n    vec2  D = iResolution.xy, \n          p = ( u+u - D ) / D.y * pow(2.89, i-z) * .4,\n          a = P(), b = P(1.)*2.89, c = P(2.)*8.35; // P(n)*pow(2.89,n)\n    \n    v     s = v(1,0,-1),\n          w = s.xxz, // v(1, 1, -1), \n          M = v( L(b-a), L(a-c), L(c-b) )\n            * mat3(w, w.xzy, w.zxy ) / 2.,\n           // mat3(1,1,-1, 1,-1,1, -1,1,1) / 2.,\n          A = v( a, M   ), \n          B = v( b, M.y ),\n          C = v( c, M.z ); \n  \n    for( ; n++ < 31. ;  ) {\n        D = (B - A).yx;  D /= L( D );\n        mat3 R = mat3( D.y, -D.x, 0, D, 0, 0,0,1 ); // rot_xy to AB \n        v    d = R * A + s* A.z,           // point of inversion (where a, b meet)\n             c = I( R * C - d ),   \n             e = c +   c.z*2. *s.yxy,      // + c.z*2. *v(0,1,0)\n             E = ( I( e ) + d ) * R;  \n             d = I( R * v(p,0) - d );   \n       // d.y < c.y ? n=99., A :           // p is not between a,b,c\n       if ( L( (d-e).xy ) < e.z ) break;\n          d.y > e.y ? C = E\n        : d.x > c.x ? A = E\n        :             B = E;               \n    }   \n \n    O.rgb = sin(( ( L(p-a) < M.x ? 3.      // black if v=-1: never happens\n                  : L(p-b) < M.y ? 2.\n                  : L(p-c) < M.z ? 1.\n                  : n )\n                + i )/2. + v(0,2,4) )*.4 + .6; \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcfGz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[564, 564, 602, 602, 1980]], "test": "untested"}
{"id": "lfX3R8", "name": "Glitch shaders", "author": "IAMDEAD", "description": "Shaders glitch for device", "tags": ["glitch"], "likes": 0, "viewed": 219, "published": 3, "date": "1702721697", "time_retrieved": "2024-07-30T17:16:16.666094", "image_code": "float segments = 0.5;     // Ð½Ð° Ð±ÑÐ´ÑÑÐµÐµ\nfloat radius = 0.6;       // ÑÐºÐµÐ¹Ð» ÑÐ°Ð´Ð¸ÑÑÐ°\nfloat brightnes = 1.0;    // Ð¿Ð¾ ÑÑÑÐ¸ ÑÑÐºÐ¾ÑÑÑ (ÐµÑÐ»Ð¸ Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ°ÐºÐ¾Ð²Ð¾Ð¹ Ð½Ð°Ð·Ð²Ð°ÑÑ)\nfloat tail_size = 0.3;   // ÑÐ°Ð±Ð¾ÑÐ°ÐµÑ ÑÐµÐ²ÐµÑÑÐ¸Ð²Ð½Ð¾, ÑÐµÐ¼ Ð±Ð¾Ð»ÑÑÐµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ - ÑÐµÐ¼ Ð¼ÐµÐ½ÑÑÐµ ÑÐ²Ð¾ÑÑ\nfloat snake_color = 2.0;  // 1.0 = red, 2.0 = green, 3.0 = blue; - ÐµÑÐ»Ð¸ harColour Ð¿Ð¾ Ð½ÑÐ»ÑÐ¼, ÑÐ°Ð±Ð¾ÑÐ°ÑÑ Ð±ÑÐ´ÐµÑ ÐºÐ°Ðº Ñ Ð·Ð°Ð¿Ð»Ð°Ð½Ð¸ÑÐ¾Ð²Ð°Ð» \n\nvec3 m_affects = vec3(0.2,0.1,1.0);\n\nfloat get_noise(vec2 co) { return (fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453)) * 0.5; }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 screen_res = vec4(iResolution.xy, 1.0 / iResolution.xy);\n    vec2 texcoord = fragCoord * screen_res.zw;\n\n\n    // ÑÐ·ÐºÐ°Ñ Ð¿Ð¾Ð»Ð¾ÑÐºÐ° Ð¸ÑÐºÐ°Ð¶ÐµÐ½Ð¸Ð¹\n    vec4 timers = vec4(iTime, iTime * 10.0, iTime / 10.0, sin(iTime));\n    float problems = fract(timers.z * 5.0 * (1.0 + 2.0 * m_affects.x));\n    \n    vec2 uv = texcoord;\n    uv.x += (m_affects.x > 0.09 && uv.y > problems - 0.01 && uv.y < problems) ? sin((uv.y - problems) * 5.0 * m_affects.y) : 0.0;\n\n    // ÑÐ¸ÑÐ¾ÐºÐ°Ñ Ð¿Ð¾Ð»Ð¾ÑÐºÐ° Ð¸ÑÐºÐ°Ð¶ÐµÐ½Ð¸Ð¹\n    float AMPL = 0.13;\n    problems = cos((fract(timers.z * 2.0) - 0.5) * 3.1416) * 2.0 - 0.8;\n    if (m_affects.x > 0.15 && uv.y > problems - AMPL && uv.y < problems + AMPL)\n        uv.x -= cos(4.71 * (uv.y - problems) / AMPL) * sin(fract(timers.z) * 6.2831 * 90.0) * 0.02 * (AMPL - abs(uv.y - problems)) / AMPL;\n    else\n        uv.x -= 0.0;\n\n    // ÑÑÑÑÐºÐ° Ð²Ð»ÐµÐ²Ð¾-Ð²Ð¿ÑÐ°Ð²Ð¾ Ð² ÑÐ¸Ð½Ð°Ð»ÑÐ½Ð¾Ð¹ ÑÑÐ°Ð´Ð¸Ð¸\n    uv.x += (m_affects.x > 0.38) ? (m_affects.y - 0.5) * 0.04 : 0.0;\n\n    \n    vec4 t_vp2 = texture(iChannel0, uv);\n\n    // Ð¨ÑÐ¼ Ð¿ÑÐ¸ Ð²ÑÐ±ÑÐ¾ÑÐµ\n    float noise = get_noise(uv * timers.z) * m_affects.x * m_affects.x * 10.0;\n    t_vp2.r += noise;\n    t_vp2.g += noise;\n    t_vp2.b += noise;\n\n    //Ð¾ÑÐºÐ»ÑÑÐµÐ½Ð¸Ðµ ÑÐºÑÐ°Ð½Ð°\n    t_vp2.rgb = m_affects.x > 0.41 ? vec3(0.0, 0.0, 0.0) : t_vp2.rgb;\n\n    fragColor = vec4(t_vp2.rgb, m_affects.z);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lfX3R8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[556, 556, 582, 582, 659], [661, 661, 716, 716, 2124]], "test": "untested"}
{"id": "4cXGzH", "name": "Purple and green rug", "author": "jarble", "description": "A fractal rug pattern with an ornate design.", "tags": ["fractal", "music", "mosaic", "rug", "sitar", "flute"], "likes": 7, "viewed": 266, "published": 3, "date": "1702708252", "time_retrieved": "2024-07-30T17:16:17.570675", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nconst float scale = 1.5;\n\n\nvoid transform(inout vec2 uv, inout vec2 t2, inout vec3 col,inout float c1){\n        //if(t2.x>t2.y)\n        uv.y -= 1./4.;\n        //uv -= vec2(.5,1.5);\n        //if(uv.y<-1./4.)\n        uv = (uv+t2)/scale;\n        \n        uv = (fract(vec2(uv+vec2(.5,1.5))*scale)-.5)/scale;\n        col.x =\n            max(length(uv-t2-c1)/3.,col.x);\n        \n        t2 = triangle_wave(uv+.5);\n        uv =\n            //t2-triangle_wave(uv.yx)+fract(t2/2.)\n            \n            //looks better with more iterations\n            t2-triangle_wave(uv.yx)-fract(t2/2.)\n        ;\n        //t2.x = (t2.x+1.5*sign(t2.y-t2.x));\n        //uv.x = (uv.x+1.5*sign(uv.y-uv.x)); \n        \n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\nvec3 fractal(vec2 uv){\n    vec3 col = vec3(0.);\n    vec2 t2 = vec2(0.);\n    vec3 col1 = col;\n    float c1=0.;\n    for(int k = 0; k < 12; k++){\n        float warp_scale = 16.*2.;\n        vec2 uv1 = uv;\n        //if(k>3) uv1 += iTime/8.;\n        vec2 warp =\n            \n            vec2(0.)\n            //vec2(sin((uv1.x)*warp_scale),cos((uv1.y)*warp_scale))/warp_scale\n            //1.-t2.yx*t2.yx\n            //uv1.yx/2.\n            //fract(t2)\n        ;\n        //if(k>3)\n        //warp = warp*warp*16.;\n        //else\n        //warp = vec2(0);\n        \n        vec2 uv_1 =\n            uv + warp.yx\n            //uv+warp*warp/2.\n            //uv/2.+warp.yx\n        ,\n        t2_1=\n            t2+warp.yx\n        ;\n        vec3 col_1 = col;\n        transform(uv_1,t2_1,col_1,c1);\n        //uv_1 = rotate(uv_1,uv.y/1.5);\n        //t2_1 = rotate(t2_1,uv.y/1.5);\n        transform(uv,t2,col,c1);\n        \n        c1 =\n            //max(abs(uv.y-uv.x*sign(uv.x-uv.y))/2.,c1)\n            //max(abs(uv_1.y-uv_1.x)*1.5,c1)\n            max(abs(uv_1.y+uv_1.x)/2.,c1)\n        ;\n        c1 =\n            max(1.-abs(2.*c1-1.),c1/4.)\n            \n            //more colorful\n            //abs(2.*c1-1.)\n            \n            //Spooky!\n            //max(abs(2.*c1-2.),c1/4.)/2.\n        ;\n        col.x =\n            max(length(uv_1-t2_1-c1)/3.,col.x)\n            \n            //blue and white\n            //c1\n            \n            //red and blue and white\n            //max(1.-abs(2.*c1-1.),c1/4.)\n\n            \n            //more colorful\n            //max(length(uv-t2-c1)/3.,1.-col.x)\n            \n            //blue and green\n            //max(length(uv-c1)/3.,col.x)\n           \n            //purple\n            //2. - max((abs(uv.y-uv.x))/3.,col.x)\n           \n            //black and white\n            //col.x\n        ;\n        col =\n            abs(col-(1.-(c1*col.x)));\n        col1 =\n            abs(col1*c1-col-1.).yzx\n            \n            //more like a mosaic\n            //abs(col1*c1-col*sign(t2.y-t2.x)-1.).yzx\n            //abs(col1*c1-col+sign(t2.y-t2.x)).yzx\n        ;\n    }\n    return col1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    float t1 = 6.;\n    \n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.xy += iTime/t1/12./2.;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec3 col1 = fractal(uv);\n    fragColor = vec4(col1/2.,1.0);\n}\n", "image_inputs": [], "sound_code": "//remix of https://www.shadertoy.com/view/mtSBzV\n\nint collatz(int initial, int steps){\n    //hailstone numbers\n    //makes some interesting rhythms\n    for(int i = 0; i < steps; i++){\n        if(initial%2==0) initial /= 2;\n        else initial = initial*3+1;\n    }\n    return initial;\n}\nfloat collatz(float initial, float steps){\n    return float(collatz(int(initial),int(steps)));\n}\n\nfloat mod1(float a,float b){\n    //a += mod(floor(a/16.),16.);\n\n    //a += collatz(mod(a/4.,b),8.);\n    //a += collatz(mod(a/4.,8.),b);\n    \n    return\n        mod(a,b)\n        //mod(a+mod(a,b+3.),b)\n        //mod(a+4.*floor(mod(a/4.,b)),b)\n    ;\n}\n\nvoid distort(inout float a, inout float b){\n    for(float i = 1.; i < mod(floor(a/b),5.); i++){\n        a /= 2.0;\n        //a /= 1.0+mod(floor(a),2.);\n        a += mod1(floor(a/2.),b)*i;\n    }\n}\n\nfloat fmod(float a, float b, float tempo){\n    //a += mod(floor(a/16.),16.);\n    \n    //distort(a,b);\n    \n    float\n    t1 =\n        mod1(floor(b/2.),tempo)\n        //mod1(floor(a/2.),tempo)\n        //mod1(floor(b/2.+a/4.),2.)\n        //mod1(floor(b/2.)+floor(a/2.),2.),\n    ,\n    a1 =\n        floor(a+t1),\n    a0 =\n        a1\n        //a1+floor(a1/2.)*4.\n        //a1+floor(a1/4.)*3.+floor(a1/3.)*4.\n    ,\n    a2 =\n        mod1(a0,3.)\n        //mod1(a1*2.,3.)\n    ,\n    a3 =\n        mod1(a0,4.)\n    ;\n    return\n        mod1(a0-a2-a3,b)\n        //mod1(a1-a2-a3+2.,b)\n    ;\n}\n\nfloat fmod(float a, float b){\n    return\n        fmod(a,b,2.)\n        //max(fmod(a/2.,b,2.),fmod(a,b,4.))\n    ;\n}\n\nfloat prime_rhythm(float time){\n    //time += mod(floor(time/16.),16.);\n\n    //time += floor(time/8.);\n    return (1.+fmod(time/4.,2.))/(1.+fmod(time/2.,2.));\n}\n\nfloat fmod1(float a, float b){\n\n    //a += collatz(a/8./8.,b);\n    return\n        fmod(a,b)\n        //fmod(a+4.+floor(a/4.)*4.,b)\n    ;\n}\n\n#define fract1(a) (1.-pow(fract(-a),2.))\n\nvec2 synth_(vec2 a1,vec2 a,vec2 a2,vec2 a3,vec2 nb,vec2 a4){\n    return log(a1+a*abs(a2-abs(.5-a3*vec2(fract1(nb.x*.998),fract1(nb.y)))*a4));\n}\n#define synth(a1,a,a2,a3,nb,a4) synth_(vec2(a1),vec2(a),vec2(a2),vec2(a3),vec2(nb),vec2(a4))\n\nvec2 banjo(vec2 a, vec2 nb){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./6.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,6./4.));\n}\n\nvec2 harp(vec2 a, vec2 nb){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,2.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.));\n}\n\nvec2 synth_drum(vec2 a, vec2 nb,float m2){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./m2)\n  + synth(1./8.,a,1./4.,1.,nb*2.,m2/4.));\n}\n\nvec2 oud(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(.5+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      +.5*log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 steel_drum(vec2 a, vec2 nb){\nreturn a/16./4.*abs(synth(1./2.,a,1./8.,1.,nb*4.,1.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.))\n;\n}\n\nvec2 gamelan(vec2 a, vec2 nb){\nreturn\na/16./4.*abs(synth(1./4.,a,1./8.,1.,nb*2.,1./2.)\n  +.5*synth(1./4.,a,1./4.,1.,nb*2.,1./2.)) \n;\n}\n\nvec2 sitar1(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      -log(1./4.+a*(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 sitar(vec2 a, vec2 nb){\nreturn a/16./2.*abs(log(1./8.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  -log(1./16.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2./4.)));\n}\n\nvec2 sitar3(vec2 a, vec2 nb){\nreturn a*a/16./4.*abs((.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  -(abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n;\n}\n\nvec2 sitar5(vec2 a, vec2 nb){\n    return a*a/16./4.*abs((abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n      -(a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n    ;\n}\n\nvec2 sitar6(vec2 a, vec2 nb){\n    return a/16./4.*abs(log(1./2.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n      -log(1./2.+a*a/2.*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n    ;\n}\n\nvec2 note1(vec2 rhythm,float attack,float duration)\n{\n\nreturn -vec2((log(attack+fract1(rhythm.x)/2./duration)),(log(attack+fract1(rhythm.y)/4./duration)));\n\n}\n\nvec2 mainSound1(int samp, float time,float scale,float duration){\n  //time += mod(floor(time/16.),16.);\n\n  float s1 =\n      8.,\n  tempo1 =\n      prime_rhythm(time)*prime_rhythm(time/2.)*2.\n      //prime_rhythm(time+floor(time/8.))*prime_rhythm(time/2.)*2.\n  ,t = s1*time/4./tempo1,\n  t7 =\n      (1.+fmod(t/8.,2.))\n      //(1.+fmod(t/8.+mod(t/8.,2.),2.))\n  ,\n  t4 = t/prime_rhythm(time+11.)/t7,\n  t1 =\n       fmod(t4,2.)\n       //fmod(t4+floor(time/8.),2.)\n  ,\n  t5 = t*2./prime_rhythm(time+7.),\n  t3 =\n      (1.+fmod(t5,2.))\n      //(1.+fmod(t5+floor(time/4./4./4.),2.))\n  ,\n  t6 = time*8./t3,\n  m3 =\n      floor(fmod1(t6,s1/2.)/2.)\n      //floor(fmod1(t6+floor(time/8./4.),s1/2.)/2.)\n\n  ,\n  m2 =\n      1. + fmod1(t/t3/2.,s1/2.)\n      //1. + fmod1(t/t3/2.+floor(time/4./4.),s1/2.)\n  ,note = (\n      (m3+m2-t1*4.)\n      //mod(m3+m2-t1*4.-floor(time/4.)*4.,8.)-4.\n      //(m3+m2-t1*4.+fmod(time/2.,2.))\n      //(m3+m2+t1*4.-2.)\n      //(m3+m2-t1*4.)+mod(m3,2.)\n  )/7.\n  ,attack=1./64.\n  ;\n  vec2\n  rhythm = vec2(t/2./prime_rhythm(time+14.),t/prime_rhythm(time+7.))\n  ,a=\n      note1(rhythm,attack,duration)\n      //note1(rhythm*2.,attack*2.,duration*2.)\n  ,\n  nb =\n      t*vec2(pow(2.,note+scale),pow(2.,note+scale))*tempo1\n      \n      //distortion\n      //t*vec2(pow(2.,note+scale),pow(2.,note+a.y/128./128./16.+scale))*tempo1/2.\n\n  ;\n  return\n      //oud\n      oud(a,nb)+oud(a,nb/2.)/2.+oud(a,nb/4.)/4.\n      //sitar1(a,nb)\n      \n\n      //sitar\n      //a/16./2.*abs(\n      //synth(1./4.,a,0.,1.,nb*2.,1./2.)\n      //-.5*synth(1./8.,a,1./8.,1.,nb,1./2.))/2.\n      \n      //sitar\n      //a/16./2.*abs(\n      //synth(1./4.,a,0.,1.,nb*2.,1./2.)\n      //+.5*synth(1./8.,a,1./8.,1./duration,nb,1./2.))/2.\n      \n      //sitar\n      //abs(oud(a,nb)-oud(a,nb*2.)/2.)\n      \n      //banjo\n      //a/16./4.*abs(\n      //synth(1./4.,a,1./8.,1.,nb*4.,4./6.)\n      //+ synth(1./8.,a,1./4.,1.,nb*2.,6./4.))\n      \n      //synth drum\n      //a/16./4.*abs(log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))*4.))\n      //+ log(1./8.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/4.)))\n  ;\n  \n}\n\nvec2 mainSound1(int samp, float time,float scale){\n    return mainSound1(samp,time,scale,1.);\n}\n\nvec2 mainSound(int a,float b){\n    float scale = 6.25;\n    return\n        //sounds like sitar (using oud)\n        \n        //abs(mainSound1(a,b,6.25,1./2.)-mainSound1(a,b,7.25)/2.)\n        \n        //abs(mainSound1(a,b,6.25,1./2.)-mainSound1(a,b,8.25,1./2.)/4.)\n        \n        (mainSound1(a,b,scale,1./2.)-(mainSound1(a,b,scale+1.,1.)/2.-mainSound1(a,b,scale+2.,2.)/4.))/2.\n        \n        //((mainSound1(a,b,scale,1.)/2.+mainSound1(a,b,scale+1.,2.)))\n        \n        //sounds like sitar (using synth drum)\n        //abs(mainSound1(a,b,5.5,1./2.)-mainSound1(a,b,6.5,1.)/2.)\n        \n        //sitar6\n        //64.*(mainSound1(a,b,8.,1./2.)/4.-mainSound1(a,b,7.,1.))\n\n    ;\n}\n", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4cXGzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 129], [158, 158, 234, 258, 824], [826, 826, 856, 856, 940], [942, 942, 964, 964, 3051], [3053, 3053, 3110, 3110, 3373]], "test": "untested"}
{"id": "Xcf3z8", "name": "Desert Goo Load Screen", "author": "KanleyStubrick", "description": "Slightly modded version of Pixel Blobs, huge thanks to SnoopethDuckDuck for all the cool designs.", "tags": ["blobs", "loading", "goo", "pixelart"], "likes": 4, "viewed": 227, "published": 3, "date": "1702698859", "time_retrieved": "2024-07-30T17:16:18.468276", "image_code": "#define cell(p) texelFetch(iChannel0, ivec2(p), 0 )\n\nvec3 pal(float t) {\n    vec3 d = 0.35 * vec3(1,3,5)/2.;\n    return 0.5 + 0.5 * cos(6.28319 * (0.5 * t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0. * iResolution.xy) / iResolution.y;\n    \n    // Zoom + distort\n    float zm = 0.7 - 0.5 * min(1., tanh(iTime * iTime));\n    //zm += 0.3 - 0.3 * tanh(24. - length(uv) * 50.);\n    \n    // Pixel + cells etc.  \n    vec2 px = zm * fragCoord + (1.-zm) * 0.5 * iResolution.xy;\n        \n    vec4 c = cell(px),\n         b = cell(px - vec2(0,1)),\n         t = cell(px + vec2(0,1)),\n         l = cell(px - vec2(1,0)),\n         r = cell(px + vec2(1,0)), \n         sum = b + t + l + r;\n      \n    // Lighten right side\n    float cn = 0.06 * smoothstep(-0.2, 0.2, uv.x); \n    \n    // Shade from bottom to top\n    float fl = clamp((uv.y + 2.), 0.125, 10.0);\n    \n    // Background\n    vec3 col = pal(0.001 * (uv.x + 5. * uv.y) + 0.9 * cn - 0.7);\n    \n    // Exterior outline\n    if (c.r == 0. && (sum.r == 1. || sum.r == 2.))\n        col = pal(fl + cn - 0.4);  \n    // Interior\n    else if (sum.r == 4.) \n        col = pal(fl + cn - 0.52 - 0.18 * c.g);    \n\n    fragColor.rgb = col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi 3.14159\n\n// From iq\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvoid mainImage( out vec4 col, in vec2 f )\n{\n    // Centre coords\n    f -= floor(0.5 * iResolution.xy);\n    \n    // Speed of time\n    float spd = 0.125;\n\n    // Number of blobs\n    float n = 50.;\n    \n    // Distance from blobs\n    float d = 1e5;\n    \n    for (float i = 0.; i < n; i++) {\n        // Offset each blob\n        float io = 2. * pi * i / n;\n        \n        // Time\n        float t = spd * iTime + 1. * pi * cos(0.5 * spd * iTime + io);\n        \n        // Motion of blobs (idk how this works)\n        float c = 1.8 + 0.1 * cos(7. * t + io); //first number controls how much blobs stick together (lower = stickier), second # controls affinity for center (higher = more concentrated on center), third # is how many nodes/folds they move between\n        d = smin(d, c * length(f - 30. * (c-0.5) * vec2(cos(t+io), sin(t+io))), 10.);  \n     }\n     \n     // Harsh shape\n     float r = step(d, 5.);\n     \n     // Soft shape (going inwards)\n     float s = smoothstep(0., 5., -d + 5.);\n     \n     col = vec4(r, s, 0, 0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xcf3z8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 72, 72, 163], [165, 165, 222, 222, 1221]], "test": "untested"}
{"id": "XcfGR8", "name": "a perfect circle", "author": "elenzil", "description": "boilerplate", "tags": ["boilerplate"], "likes": 10, "viewed": 254, "published": 3, "date": "1702693501", "time_retrieved": "2024-07-30T17:16:19.234227", "image_code": "/*\n    Roses are red and violets are blue,\n    I write this boilerplate every single time.\n*/\n\nconst float gZoom       = 0.8;\n      float gT;         // set in main\n      float gLineWidth; // set in main\n      float gAAEps;     // set in main\n      \nfloat len(vec2 p, float k) {\n    float x = pow(abs(p.x), k);\n    float y = pow(abs(p.y), k);\n    return    pow(x + y, 1.0 / k);\n    \n}\n\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    gT         = iTime;\n    gLineWidth = VIEWFROMSCREEN_DIST(4.0);\n    gAAEps     = VIEWFROMSCREEN_DIST(2.0);\n    vec2 p     = VIEWFROMSCREEN     (XY );\n    \n    vec3 rgb = v1 * 0.3;\n    \n    float d = abs(length(p) - 1.0) - gLineWidth;    \n    float c = smoothstep(gAAEps, -gAAEps, d);\n    \n    rgb = mix(rgb, vec3(1.0), c);\n    \n    RGBA.rgb  = rgb;\n    \n    // housekeeping\n    RGBA.rgb *= 1.0 - pow(LENGTHSQR(XY/RES - 0.5) * 1.5, 3.0);\n    RGBA.rgb  = pow(RGBA.rgb, vec3(1.0 / 2.2));\n    RGBA.a    = 1.0;\n}", "image_inputs": [], "common_code": "const vec2  v01 = vec2(0.0, 1.0);\nconst vec3  vX  = v01.yxx;\nconst vec3  vY  = v01.xyx;\nconst vec3  vZ  = v01.xxy;\nconst vec3  v0  = v01.xxx;\nconst vec3  v1  = v01.yyy;\nconst float pi  = 3.14159265359;\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\n#define VIEWFROMSCREEN_DIST(distance)                     \\\n        ( (distance) / MINRES / gZoom                     )\n#define VIEWFROMSCREEN(xy)                                \\\n        ( vec2(VIEWFROMSCREEN_DIST((xy).x * 2.0 - RES.x), \\\n               VIEWFROMSCREEN_DIST((xy).y * 2.0 - RES.y)) )\n               \n#define LENGTHSQR(a) ( dot((a), (a)) )\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XcfGR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 250, 278, 278, 384], [387, 387, 430, 430, 941]], "test": "untested"}
{"id": "4cXGz8", "name": "Forbidden Plum", "author": "KanleyStubrick", "description": "This is just a recolored version of Leon's Metal Melting Flavor. I'd like to add a stem but still need to learn more. Thanks to Leon for lots of inspiration", "tags": ["abstract", "melting", "ooze"], "likes": 23, "viewed": 522, "published": 3, "date": "1702693284", "time_retrieved": "2024-07-30T17:16:20.106894", "image_code": "\n// Metal Melting Flavor\n// nuclear summer vibes, also mouse interactive\n\n// main code is in Buffer A\n// Buffer B is a minimal temporal anti aliasing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float material;\nfloat glow;\nvec3 mouse;\n\n// fractal brownian motion https://thebookofshaders.com/13/\nvec3 fbm (vec3 p)\n{\n    vec3 result = vec3(.0);\n    float a = .5;\n    for (float i = 0.; i < 3.; ++i) {\n        p.y += iTime*.005/a;\n        result += sin(texture(iChannel1, p/a).xyz*6.28)*a;\n        a /= 2.;\n    }\n    return result;\n}\n\n// signed distance function\nfloat map(vec3 p)\n{\n    float dist = 100.;\n    float shape = 100.;\n    vec3 pp = p;\n    float c;\n    \n    // sphere\n    dist = length(p)-1.;\n    \n    // droplets\n    c = pModPolar(p.xz, 8.);\n    vec3 rng = hash31(c);\n    p.x -= 1.-.5;\n    rng.x += sign(p.x)*.5;\n    p.x = abs(p.x)-.2;\n    p.y *= -1.;\n    float time = iTime * .2 + rng.x;\n    float anim = fract(time);\n    float index = floor(time);\n    float wave = sin(anim*3.14);\n    float h = .7+.3*pow(wave, 4.);\n    float s = .03-.03*(1.-wave);\n    shape = sdSegment(p, h, s);\n    dist = smin(dist, shape, .2);\n    shape = length(p-vec3(0,pow(anim, 10.)*200.+h,0))-.05;\n    dist = smin(dist, shape, .3*pow(anim,0.5));\n    \n    // sphere mouse interaction\n    dist = smin(dist, length(pp+mouse)-.1, .6);\n    \n    // surface details\n    vec3 seed = pp*.1;\n    vec3 noise = fbm(seed);\n    dist -= noise.x*.01;\n    \n    return dist * .5;\n}\n\nvoid coloring (inout vec3 color, in vec3 pos, in vec3 normal, in vec3 ray, in vec2 uv, in float shade)\n{\n    // Inigo Quilez color palette\n    // https://iquilezles.org/www/articles/palettes/palettes.htm\n    vec3 tint = 1.5+.5*cos(vec3(1,.3,6)*6.283+iTime*.2+uv.y*3.);\n    \n    // lighting\n    color = tint * pow(dot(normal, vec3(0,-1,0))*.5+.5, 10.);\n    vec3 rf = reflect(ray, normal);\n    float top = dot(rf, vec3(0,1,0))*.4+.5;\n    float glow = dot(normal, ray)*.7+.5;\n    color += vec3(0.7,.2,0.7)*pow(clamp(top,0.,1.), 1.5); // edit sphere color\n    color += vec3(4,1,1)*pow(glow, 2.);\n    color *= pow(shade,.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    \n    // background\n    vec3 color = vec3(.2)*smoothstep(2.,.5,length(uv));\n    \n    // coordinates\n    vec3 pos = vec3(0,0,3);\n    vec3 at = vec3(0);\n    pos.zy *= rot(sin(iTime*.2)*.1);\n    vec3 ray = lookAt(pos, at, uv, 1.);\n    \n    // mouse interaction\n    if (iMouse.z > 0.5) {\n        vec2 uvm = (iMouse.xy-iResolution.xy/2.)/iResolution.y;\n        mouse = vectorAt(pos, at, uvm*2., -1.) * -1.;\n    }\n    else mouse = vec3(0);\n    \n    // noise\n    //vec3 blue = texture(iChannel0, fragCoord/1024.).xyz;\n    //vec3 white = hash33(vec3(fragCoord, iFrame));\n    \n    // materialing\n    material = 0.;\n    glow = 0.;\n    float maxDist = 4.;\n    \n    // raymarch\n    const float count = 50.;\n    float steps = 0.;\n    float total = 0.;\n    for (steps = count; steps > 0.; --steps) {\n        float dist = map(pos);\n        if (dist < total/iResolution.y || total > maxDist) break;\n        dist *= 0.9+0.1;\n        ray += total*.002;\n        pos += ray * dist;\n        total += dist;\n    }\n    \n    // NuSan https://www.shadertoy.com/view/3sBGzV\n    vec2 noff = vec2(.001,0);\n    vec3 normal = normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n    \n    // coloring\n    float shade = steps/count;\n    if (shade > .001 && total < maxDist) {\n        coloring(color, pos, normal, ray, uv, shade);\n    }\n    \n    fragColor = vec4(color, 1);\n}", "buffer_a_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define repeat(p,r) (mod(p,r)-r/2.)\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\nvec3 lookAt (vec3 from, vec3 at, vec2 uv, float fov)\n{\n  vec3 z = normalize(at-from);\n  vec3 x = normalize(cross(z, vec3(0,1,0)));\n  vec3 y = normalize(cross(x, z));\n  return normalize(z * fov + uv.x * x + uv.y * y);\n}\nvec3 vectorAt (vec3 from, vec3 at, vec2 uv, float fov)\n{\n  vec3 z = normalize(at-from);\n  vec3 x = normalize(cross(z, vec3(0,1,0)));\n  vec3 y = normalize(cross(x, z));\n  return (z * fov + uv.x * x + uv.y * y);\n}\n// Mercury\n// https://mercury.sexy/hg_sdf/\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 6.28/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdSegment( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\n// blackle\n// https://suricrasia.online/demoscene/functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\nvec3 rndrot(vec3 p, vec4 rnd) {\n  return erot(p, normalize(tan(rnd.xyz)), rnd.w*3.1415);\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n", "buffer_b_code": "// Temporal Anti Aliasing from:\n// https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/\n\n// but only the color clamping...\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    vec3 temporal = texture(iChannel1, uv).rgb;\n    vec3 minColor = vec3(9999.), maxColor = vec3(-9999.);\n    for(int x = -1; x <= 1; ++x){\n        for(int y = -1; y <= 1; ++y){\n            vec3 c = texture(iChannel0, uv + vec2(x, y) / iResolution.xy).rgb;\n            minColor = min(minColor, c);\n            maxColor = max(maxColor, c);\n        }\n    }\n    temporal = clamp(temporal, minColor, maxColor);\n    fragColor.rgb = mix(color, temporal, 0.9);\n    fragColor.a = 1.0;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4cXGz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 150, 207, 207, 289]], "test": "untested"}
{"id": "XffGR8", "name": "2d perspective-02", "author": "jorge2017a2", "description": "2d perspective-02", "tags": ["2dperspective02"], "likes": 16, "viewed": 171, "published": 3, "date": "1702691634", "time_retrieved": "2024-07-30T17:16:21.017459", "image_code": "//por jorge2017a2\n//2d perspective-02\n//--15-dic-2023-\n//\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(7.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nvec3 DrawFigBordev2(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj+0.05,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r); return (p - o) * mat2(c, -s, s, c) + o; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat tau = atan(1.0) * 8.0;\nvec2 opAngRep( vec2 p, float a )\n{\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    return vec2(polar.y * vec2(cos(polar.x),sin(polar.x)));\n}\n\nvec2 opAngRepFull( vec2 p, float numItem )\n{   vec2 rep2 = opAngRep(p, tau / numItem);  return rep2; }\n\nvec3 circulos(vec2 p, vec3 colOut,vec3 colIn ,float z)\n{float df=9999.9;\n    int x, y;\n    int xmax, ymax;\n    xmax=5;\n    ymax=5;\n    float d1,d2,d3;\n    \n    p=vec2(p.x/z, p.y/z);\n    d1=sdCircle(p, 1.0 );\n    d2=sdCircle(p, 1.5 );\n    d3=sdCircle(p, 2.0 );\n    vec2 p2=opAngRepFull( p, 5.);\n    vec2 p3=opAngRepFull( p, 8.);\n    vec2 p4=opAngRepFull( p, 8.);\n    vec2 tmp= Rotate(p, vec2(0.0), radians(iTime*30.0));\n    vec2 p5=opAngRepFull(tmp, 12.);\n \n    float d1a= sdBox(p2-vec2(0.5,0.0), vec2(0.2,0.5) );\n    float d2a= sdBox(p3-vec2(0.5+2.0*sin(iTime),0.2), vec2(0.4,0.2) );\n    float d3a= sdBox(p4-vec2(1.0+2.0*abs(sin(iTime-5.0)),0.2), vec2(0.3,0.5) );\n    float d4a= sdBox(p5-vec2(2.5,0.2), vec2(0.6,0.15) );\n    \n    colOut=DrawFigBordev2(vec3(0.75,0.0,0.2),colOut, d3);\n    colOut=DrawFigBordev2(vec3(0.0,0.75,0.2),colOut, d3a);\n    colOut=DrawFigBordev2(vec3(0.5,0.5,0.0),colOut, d4a);\n    colOut=DrawFigBordev2(vec3(0.5,0.1,0.2),colOut, d2);\n    colOut=DrawFigBordev2(colIn,colOut, d1);\n    colOut=DrawFigBordev2(vec3(0.3,0.5,0.2),colOut, d2a);\n    colOut=DrawFigBordev2(vec3(0.0,0.7,0.2),colOut, d1a);\n    return colOut;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.xy = vec2(uv.x*2.-1., uv.y*2.-1.);\n    uv.x *= iResolution.x/iResolution.y;\n    float esc=7.0;\n    uv*=esc;\n    vec2 uv0=uv;\n    vec3 col= vec3(0.2);\n    col= circulos(uv,col,vec3(1.0,0.0,0.0),2.0);\n    col= circulos(uv*3.0-vec2(20.0,0.0),col,vec3(1.0,0.0,0.5),2.2);\n    col= circulos(uv*3.0-vec2(-20.0,0.0),col,vec3(1.0,0.2,0.0),2.2);    \n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XffGR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[310, 310, 346, 346, 391], [397, 397, 461, 461, 595], [597, 613, 661, 661, 735], [737, 737, 774, 774, 848], [850, 850, 885, 885, 908], [939, 939, 973, 973, 1135], [1137, 1137, 1181, 1181, 1239], [1241, 1241, 1297, 1297, 2385], [2387, 2387, 2444, 2444, 2900]], "test": "untested"}
{"id": "4flGRn", "name": "2d perspective", "author": "jorge2017a2", "description": "2d perspective", "tags": ["2d", "2dperspective"], "likes": 9, "viewed": 188, "published": 3, "date": "1702682310", "time_retrieved": "2024-07-30T17:16:21.802361", "image_code": "//por jorge2017a2\n//2d perspective\n//--15-dic-2023-\n//\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nvec3 DrawFigBordev2(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj+0.05,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nvec3 escalera(vec2 p, vec3 colOut,vec3 colIn ,float z)\n{\n    float df=9999.9;\n    int x, y;\n    int xmax, ymax;\n    xmax=5; ymax=5;\n    float d1;    \n    p=vec2(p.x/z, p.y/z);\n    \n    float tam=0.75;\n    p.x+=5.0;\n    p.y+=4.0;\n    \n    for(y=0;y<ymax;y++)\n    {\n        for(x=0;x<xmax;x++)\n        {\n          d1=sdBox(p+vec2(float(x)*tam+tam*float(x-1),-float(y)*tam-tam*(float(y)) ),vec2(tam));\n          df=min(df, d1);\n        }\n\n    xmax=xmax-1;\n    }\n    colOut= DrawFigBordev2(colIn,colOut, df);\n    return colOut;\n}\n\nvec3 repcuadro(vec2 uv, vec3 col, float pz)\n{   float z=iTime*5.0+pz;\n    z=opRep1D(z, 10.0 );\n    col=escalera(vec2(-10.0-uv.x,3.0-uv.y),col,vec3(1.0,1.0,0.0),(6.9+z)/10.0);\n    col=escalera(vec2(-5.0+ uv.x,4.0-uv.y) ,col,vec3(0.0,0.2,1.0),(7.0+z)/10.0);\n    col=escalera(uv-vec2(5.0,1.0),col,vec3(1.0,0.0,0.0), (7.2+z)/10.0);\n    col=escalera(vec2(-9.0-uv.x,uv.y),col, vec3(0.0,1.0,0.0),(7.3+z)/10.0);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.xy = vec2(uv.x*2.-1., uv.y*2.-1.);\n    uv-=vec2(0.3,-0.25);\n    float esc=7.0;\n    uv*=esc;\n    vec2 uv0=uv;\n    uv= Rotate(uv, vec2(-2.0,2.0),radians(iTime*5.0)) ;    \n    vec3 col= vec3(0.0,0.0,0.0);\n   \n    col= repcuadro(uv, col,0.0);\n    if(sin(iTime)*3.0>0.0)\n    col= repcuadro(uv, col*0.5,-2.0);\n    \n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4flGRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[237, 237, 273, 273, 318], [324, 324, 388, 388, 522], [524, 540, 588, 588, 666], [668, 668, 705, 705, 779], [1308, 1308, 1353, 1353, 1729], [1731, 1731, 1788, 1788, 2215]], "test": "untested"}
{"id": "lcX3zr", "name": "Pink Warp Logo", "author": "KanleyStubrick", "description": "A slightly edited and recolored version of the very cool shimmering orb shader. ", "tags": ["ripples", "orb", "shimmering"], "likes": 3, "viewed": 223, "published": 3, "date": "1702680660", "time_retrieved": "2024-07-30T17:16:22.683006", "image_code": "void mainImage( out vec4 outputColor, in vec2 position)\n{\n    vec2 z = (position - .5 * iResolution.xy) / (.5*iResolution.y);\n    float pw = 2./iResolution.y;\n\n    float theta = iTime/60.0, c = cos(theta), s = sin(theta);\n    float theta2 = iTime/111.0, c2 = cos(theta2), s2 = sin(theta2);\n    mat3 spin = mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, s),\n        vec3(1, -s, c));\n    mat3 spin2 = mat3(\n        vec3( c2, s2,0),\n        vec3(-s2, c2,0),\n        vec3(0,0,0.1));\n\n    vec3 color = vec3(0.1,0.3,0);\n\n    if (length(z) < 1.0) {\n        float scale = (1.0 + iTime/3.0);\n        float scaled_pw = scale*pw;\n        vec3 w = vec3(z.x, z.y, sqrt(1.0-dot(z,z))) * scale;\n        vec3 w2 = vec3(w.x, w.y, -w.z);\n        // Points from the two halves of the sphere.\n\n        w = spin2 * spin * w;\n        w2 = spin2 * spin * w2;\n        #define F(p) ((.4 - length(p - round(p))) / scaled_pw)\n        color = mix(color, vec3(.8, .5, .9),  smoothstep(0., 1., F(w)));\n        color = mix(color, vec3(.9, .2, .6+color.b*.2),  smoothstep(0., 1., F(w2)));\n    }\n    outputColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcX3zr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1099]], "test": "untested"}
{"id": "lcXGzr", "name": "3D Fireworks", "author": "KanleyStubrick", "description": "This is a slightly edited version of https://www.shadertoy.com/view/NddSWs. You can click and drag to look around\nI have no idea what I'm doing from a mathematical or coding sense but am having fun messing with variables to make something cool looking. :)", "tags": ["colorful", "weird"], "likes": 7, "viewed": 252, "published": 3, "date": "1702679197", "time_retrieved": "2024-07-30T17:16:23.580606", "image_code": "\n// taste of noise 7 by leon denise 2021/10/14\n// result of experimentation with organic patterns\n// using code from Inigo Quilez, David Hoskins and NuSan\n// thanks to Fabrice Neyret for code reviews\n// licensed under hippie love conspiracy\n\n// return color from pixel coordinate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// taste of noise 7 by leon denise 2021/10/14\n// result of experimentation with organic patterns\n// using code from Inigo Quilez, David Hoskins and NuSan\n// thanks to Fabrice Neyret for code reviews\n// licensed under hippie love conspiracy\n\n// global variable\nfloat material;\nfloat rng;\n\n// sdf\nfloat map (vec3 p)\n{\n    // time stretched with noise\n    float t = iTime*1. + rng*0.9;\n    \n    // domain repetition\n    float grid = 5.;\n    vec3 cell = floor(p/grid);\n    p = repeat(p,grid);\n    \n    // distance from origin\n    float dp = length(p);\n    \n    // rotation parameter\n    vec3 angle = vec3(.1,-.5,.1) + dp*.5 + p*.1 + cell;\n    \n    // shrink sphere size\n    float size = sin(rng*3.14);\n    \n    // stretch sphere\n    float wave = sin(-dp*1.+t+hash13(cell)*6.28)*.5;\n    \n    // kaleidoscopic iterated function\n    const int count = 4;\n    float a = 1.0;\n    float scene = 1000.;\n    float shape = 1000.;\n    for (int index = 0; index < count; ++index)\n    {\n        // fold and translate\n        p.xz = abs(p.xz)-(.5+wave)*a;\n        \n        // rotate\n        p.xz *= rot(angle.y/a);\n        p.yz *= rot(angle.x/a);\n        p.yx *= rot(angle.z/a);\n        \n        // sphere\n        shape = length(p)-0.2*a*size;\n        \n        // material blending\n        material = mix(material, float(index), smoothing(shape, scene, 0.3*a));\n        \n        // add with a blend\n        scene = smin(scene, shape, 1.*a);\n        \n        // falloff transformations\n        a /= 1.9;\n    }\n        \n    return scene;\n}\n\n// return color from pixel coordinate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // reset color\n    fragColor = vec4(0,0,0,1);\n    material = 0.0;\n    \n    // camera coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 eye = vec3(1,1,1.);\n    vec3 at = vec3(0,0,0);\n    vec3 z = normalize(at-eye);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = cross(x, z);\n    vec3 ray = normalize(vec3(z + uv.x * x + uv.y * y));\n    vec3 pos = eye;\n    \n    // camera control\n    vec2 M = 6.28*(iMouse.xy-.5);\n    ray.xz *= rot(M.x), pos.xz *= rot(M.x);\n    ray.xy *= rot(M.y), pos.xy *= rot(M.y);\n    \n    // white noise\n    vec3 seed = vec3(fragCoord.xy, iTime);\n    rng = hash13(seed);\n    \n    // raymarch\n    const float steps = 30.0;\n    float index;\n    for (index = steps; index > 0.0; --index)\n    {\n        // volume estimation\n        float dist = map(pos);\n        if (dist < 0.01)\n        {\n            break;\n        }\n        \n        // dithering\n        dist *= 0.9 + .1 * rng;\n        \n        // raymarch\n        pos += ray * dist;\n    }\n    \n    // ambient occlusion from steps count\n    float shade = index/steps;\n\n    // compute normal by NuSan (https://www.shadertoy.com/view/3sBGzV)\n    vec2 off=vec2(.001,0);\n    vec3 normal = normalize(map(pos)-vec3(map(pos-off.xyy), map(pos-off.yxy), map(pos-off.yyx)));\n\n    // Inigo Quilez color palette (https://iquilezles.org/articles/palettes)\n    vec3 tint = 0.1+.6*cos(vec3(5,3,3)+material*.1+length(pos)*.5);\n\n    // lighting\n    float ld = dot(reflect(ray, normal), vec3(0,1,0))*0.5+0.5;\n    vec3 light = vec3(1.000,0.502,0.502) * sqrt(ld);\n    ld = dot(reflect(ray, normal), vec3(0,0,-1))*0.5+0.5;\n    light += vec3(0.700,0.714,0.145) * sqrt(ld)*.5;\n\n    // pixel color\n    fragColor.rgb = (tint + light) * shade;\n\n    // temporal buffer\n    fragColor = max(fragColor, texture(iChannel0, fragCoord/iResolution.xy) - 0.01);\n}\n\n", "buffer_a_inputs": [], "common_code": "\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat smoothing(float d1, float d2, float k) { return clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 ); }\n\n// rotation matrix\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n#define repeat(p,r) (mod(p,r)-r/2.)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lcXGzr.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[242, 280, 337, 337, 404]], "test": "untested"}
{"id": "MfXGRr", "name": "Rotating Vornoi Tiles", "author": "mgmbass", "description": "Interesting pattern created by rotating points. ", "tags": ["vornoirotation"], "likes": 1, "viewed": 130, "published": 3, "date": "1702676834", "time_retrieved": "2024-07-30T17:16:24.609854", "image_code": "#define PI 3.14159265359\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    \n    vec3 col = vec3(.0);\n    float rotation = sin(iTime)*PI;\n    \n     // Cell positions\n    vec2 point[9];\n    vec2 pos = vec2(0.650,0.650) - vec2(0.5);\n    point[0] = rotate2d( rotation ) * pos;\n    pos = vec2(0.650,0.350) - vec2(0.5);\n    point[1] = rotate2d( rotation ) * pos;\n    pos = vec2(0.350,0.650) - vec2(0.5);\n    point[2] = rotate2d( rotation ) * pos;\n    pos =  vec2(0.350,0.350) - vec2(0.5);\n    point[3] = rotate2d( rotation ) * pos;\n    point[4] = vec2(0.5,0.500) - vec2(0.5);\n    pos = vec2(0.90,0.500) - vec2(0.5);\n    point[5] = rotate2d( -1. * rotation ) * pos;\n    pos = vec2(0.10,0.500) - vec2(0.5);\n    point[6] = rotate2d( -1. * rotation ) * pos;\n    pos = vec2(0.500,0.900) - vec2(0.5);\n    point[7] = rotate2d( -1. * rotation ) * pos;\n    pos = vec2(0.500,0.100) - vec2(0.5);\n    point[8] = rotate2d( -1. * rotation ) * pos;\n\n    float m_dist = 1.;  // minimum distance\n    vec2 m_point;        // minimum position\n    \n     // Iterate through the points positions\n    for (int i = 0; i < 9; i++) {\n        float dist = distance(uv, point[i]);\n        if ( dist < m_dist ) {\n            // Keep the closer distance\n            m_dist = dist;\n\n            // Kepp the position of the closer point\n            m_point = point[i] + vec2(0.5);\n        }\n    }\n\n    // Add distance field to closest point center\n    col += m_dist*2.;\n    \n      // tint acording the closest point position\n    col.rb = m_point;\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MfXGRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 53, 53, 139], [142, 142, 199, 249, 1807]], "test": "untested"}
{"id": "lfXGzn", "name": "truchet3D hexagonal torus", "author": "cyperus", "description": "truchet3d - torodial hexagonal grid - torus", "tags": ["3d", "sdf", "torus", "hexagon", "truchet", "schwarzchristoffel"], "likes": 12, "viewed": 182, "published": 3, "date": "1702673541", "time_retrieved": "2024-07-30T17:16:25.783715", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"truchet3d hexagonal torus\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n// References, Inspiration:\n//\n// - \"Schwarz-Christoffel Mapping\" by mla\n//   https://www.shadertoy.com/view/tsfyRj\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// ray casting bounding shape\nconst float\n    CAM_DIST = 4.,\n    CAM_FLE = 2.,\n    BB_DIST = 8.,\n    RAY_MIN_DIST = 0.1,\n    RAY_MAX_DIST = CAM_DIST+1.1*BB_DIST;\n\nconst int   MAX_MARCHING_STEPS = 500;\nconst float\n    RAY_STEP_FACTOR = 0.0095,\n    RAY_PRECISION = 1.E-1;\n\n// data from sdf\nvec3 mat_to = vec3(0);\nvec3 mat_to_id = vec3(0);\nvec4 mat_tc = vec4(0);\n\nfloat map(in vec3 p) {\n    float rxy = 0., au = 0.0, av = 0.0;\n    vec2 z = vec2(0.);\n    float d = -1.;\n    \n    // torus\n    z = vec2(length(p.zx), p.y);\n    au = atan(p.x, p.z);\n    \n    z = cmul(z,z); z.x -= 4.;\n    av = atan(z.y, z.x)+ 0.03 * iTime;\n    rxy = length(z);\n    \n    p = vec3(vec2(24.,6.).x*au/PI, vec2(24.,6.).y* 0.5*sqrt(3.)* av/PI, log(rxy)-0.4);\n\n    // regular hexagonal tiles\n    vec3 rpt_id = vec3(1.); vec3 p_hex;    \n    p.xy = hexgrid2hex(p.xy, rpt_id);    \n    p.xy = inversesc(p.xy, int(6.));\n    mat_to_id = rpt_id;\n\n    // torus,sphere,2spheres       \n    rxy = length(p.xy); au = atan(p.y, p.x);    \n    z = 2.*ccos(PI*vec2(rxy,2.*p.z));\n    z.x += (3. + 2. * sin(2.*PI*iTime/60.));\n            \n    p = vec3(log(length(z))-0.02, 0.5*au/PI, 0.5*atan(z.y,z.x)/PI);\n    \n    vec2 to_uv = p.yz;\n    float to_d = log(length(z)+0.8);\n    mat_to = vec3(to_uv,to_d);   \n\n    // truchet 3D cube grid\n    vec3 tc_id = vec3(0.); float tc_a = 0.;   \n    p *= vec3(1.,18.,4.); // r,u,v\n    p.yzx = p.xyz;\n    \n    ivec3 l0 = -ivec3(4./2.,0,18./2.);\n    ivec3 l1 = ivec3(4./2.,1.,18./2.)-ivec3(1.);\n    tc_id = floor(p);\n    tc_id = clamp(tc_id, vec3(l0), vec3(l1));\n    vec3 q = p - tc_id -0.5;\n\n    // truchet 3D cube tiles\n    float rnd = hash21(tc_id.xz);\n    if(rnd<.5) q.x = -q.x;\n    float r0 = 0.5; float r1 = 0.125;\n\n    if(fract(rnd*77.57+iTime/6.)>.75) {\n       vec3 q2 =  length(q.xz-.5)<length(q.xz+.5)\n                ? vec3(q.xz-.5,0.)  \n                : vec3(q.xz+.5,1.);\n       d = sdTorus( vec3(q2.x, q.y, q2.y) , vec2(0.5,r1) );\n    }\n    else {\n       d = opSmoothUnion( sdCylinder( q.zxy, r1 ), sdCylinder( q.xzy, r1 ), 0.05 );\n    }\n    mat_tc = vec4(q,rnd);  \n   \n    // return\n    return min(d,to_d);\n}\n\n// intersect\nfloat intersect(in vec3 ro, in vec3 rd, in float px) {\n    float res = -1.0;\n    \n    // bb\n    vec2 dis = isphere( ro, rd , abs(BB_DIST));    \n    if( dis.y<0.0 ) return -1.0;\n    dis.x = max( dis.x, RAY_MIN_DIST );\n    dis.y = min( dis.y, RAY_MAX_DIST );\n\n    // raymarch signed distance field    \n\tfloat fh = RAY_STEP_FACTOR;\n    float t = dis.x;\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) {\n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t;\n        float h = map( pos);\n        if( t>dis.y || h<th ) break;\n        t += h*fh;\n    }\n    if( t<dis.y ) {\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) { \n\tif (iMouse.x > 0.0) {\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n    p.yz = crot(p.yz,-1.*PI*(time+10.));\n    p.zx = crot(p.zx,-2.*PI*(time+15.));\n\treturn p.xyz;\n}\n\n// textures\nfloat grid_uv(in vec2 uv) {\n    // uv grid alpha mask\n    vec2 sw = abs(fract(uv-0.25)-0.5)-0.25;\n    float sdf = min(sw.x,sw.y)*-max(sw.x,sw.y);\n    float pp = fwidth(sdf);\n    return smoothstep(+pp,-pp,sdf);\n}\n            \nvec4 cells(in vec2 uv, in float h) {\n    // sectors, uv-grid\n    vec4 C;\n    C.a = 1.;\n    C.rgb = h2rgb(h);                      // sector  -> hue\n    C.rgb *= (0.5+ 0.5 * grid_uv(uv))*0.7; // uv-grid -> value\n    return C;\n}\n\nvec4 ribbon(in float uv_x, in float time) {\n    float sdf = -(2.*pulsecollision(1.,1./3. * uv_x, time, 2./6.)-1.);\n    float px = fwidth(sdf); float a = smoothstep(px+0.1,-px-0.1,sdf+0.2);    \n    return vec4( h2rgb(sdf -2./6.),a );\n}\n\nvec4 truchet3D(in vec3 p, in float rnd ,in float time) {\n    float sdf = sdBox( p, vec3(0.5*0.9));\n    float px = fwidth(sdf); float a = smoothstep(px,-px,sdf);\n    return mix(vec4(1.), vec4(h2rgb( fract(abs(rnd)*22.93 + time)),1.), a);\n}\n\n// main\nvoid mainImage(out vec4 O, in vec2 fragCoord) {\n    // normalized time\n    float ntime = iTime/360.;\n\n    // anti-aliasing to take a picture\n    vec3 tot = vec3(0.0);\n    #define AA 1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {       \n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o) - iResolution.xy)/iResolution.y;\n        \n        // camera viewport --> worldspace\n        vec3 ro = vec3(0,0,-4.+ 1.4* sin(2.*PI*ntime));\n        vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n             ro = transform(ro,ntime);\n             rd = normalize(transform(rd,ntime));\n        \n        // distance hit ray surface\n        float px = 2.0/( iResolution.y*CAM_FLE );\n        float t = intersect( ro, rd, px );\n\n        // background\n        vec3 sky_col = rd*.2+.8;\n        vec4 C = vec4(sky_col,1.);\n        O = C;\n        \n        // object surface\n        if (t >= 0.) {\n            // surface properties\n            vec3 p = ro + rd * t;\n            vec3 n = calcNormal( p, 0.001);\n            \n            const float r0 = 0.5;\n            float a_rpt_tc = 0.5+0.5*sin(2.*PI*ntime);\n            \n            // draw textures\n            O = vec4(0);\n\n            if(O.a<1.) {          \n                float hue = (mat_to_id.x + 2.)/4. + (mat_to_id.z )/8.;\n                C = cells(mat_to.xy/2., hue);\n                C.a = mat_to.z>r0 ? 1.-a_rpt_tc : O.a;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n\n            if(O.a<1.) {\n                C =  mat_to.z<r0 ? ribbon( 6.*3.* mat_to.x,  6.*ntime) : vec4(0.);\n                C.rgb *= 0.7;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n\n            if(O.a<1.) {\n                C = truchet3D(mat_tc.xyz, mat_tc.w, ntime);\n                C.a = a_rpt_tc; C.rgb *= 0.5;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n            }\n\n            C = O;\n                       \n            // lighting\n            vec3  came_li_o   = transform(vec3(-10.,10.,-10.),ntime); // origine\n            vec3  came_li_dir = normalize(p - came_li_o);             // direction\n            vec3  came_li_col = vec3(1.,1.,.5);                       // color\n            float came_li_shi = 10.;                                  // shininess            \n\n            float cosa = 1.;\n            O.rgb += 0.1 * cosa * C.rgb * sky_col;           // amb\n            cosa = clamp(dot(-came_li_dir, n), 0., 1.);\n            O.rgb += 0.5 * cosa * C.rgb * came_li_col;       // dif       \n            cosa = pow(clamp(dot(reflect(came_li_dir, n), -rd), 0., 1.), came_li_shi);           \n            O.rgb += 0.4 *(cosa>0.? cosa:0.) * came_li_col ; // spec\n            \n            // fog\n            O.rgb = mix(O.rgb, sky_col, 1.0 - exp(-1.E-2 * pow(t,3.)));    \n        }\n        tot += O.rgb;\n    }\n    tot /= float(AA*AA);\n    \n    // gamma correction\n    O = vec4(rgb2srgb(tot),1.);\n}", "image_inputs": [], "common_code": "// const\nconst float PI = abs(atan(0.,-1.));\n\n// 1D transformations\nfloat pulsecollision(in float pf, in float x, in float x0, in float pw) {\n    float ntriw_p = abs( fract( pf*(x - x0) )-0.5);\n    float ntriw_n = abs( fract( pf*(x + x0) )-0.5);\n    float pp = smoothstep( 0.5*pw, 0., ntriw_p );\n    float pn = smoothstep( 0.5*pw, 0., ntriw_n );\n    return (pp+pn);\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);\n}\n\n// complex\nvec2 cmul(vec2 za,vec2 zb) {\n    return za*mat2(zb.x,-zb.y,zb.yx);\n}\n\nvec2 crot(vec2 z,float a) {\n    return cmul(vec2(cos(a),sin(a)),z);\n}\n\nvec2 cinv(vec2 z) {\n    return z*vec2(1,-1)/dot(z,z);\n}\n    \nvec2 cdiv(vec2 z, vec2 w) {\n    return cmul(z,cinv(w));\n}\n    \nvec2 cpow(vec2 z, int n) {\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));\n}\n  \nvec2 csqr(vec2 z) {\n    return vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y );\n}\n\nvec2 ccos(vec2 z) {\n    vec2 d=vec2(exp(z.y),exp(-z.y));\n\treturn vec2(cos(z.x)*(d.x+d.y)*.5,-sin(z.x)*(d.x-d.y)*.5);\n}\n\nfloat binomial(float a, int n) {\n   float s = 1.0;\n   for (int i = n; i >= 1; i--,a--) {\n     s *= float(a)/float(i);\n   }\n   return s;\n}\n\nvec2 expi(float x) {\n  return vec2(cos(x),sin(x));\n}\n\nfloat gamma(float z) {\n  const float[8] p = float[](\n    676.5203681218851,\n    -1259.1392167224028,\n    771.32342877765313,\n    -176.61502916214059,\n    12.507343278686905,\n    -0.13857109526572012,\n    9.9843695780195716e-6,\n    1.5056327351493116e-7\n  );\n  z -= 1.0;\n  float x = 0.99999999999980993;\n  for (int i = 0; i < 8; i++) {\n    float pval = p[i];\n    x += pval/(z+float(i+1));\n  }\n  float t = z + 8.0 - 0.5;\n  return sqrt(2.0*PI) * pow(t,z+0.5) * exp(-t) * x;\n}\n\n// beta function\nfloat B(float a, float b) {\n  return (gamma(a)*gamma(b))/gamma(a+b);\n}\n\nvec2 inversesc(vec2 z, int K) {\n  float cn[6];\n  for (int n = 1; n <= 5; n++) {\n    cn[n] = binomial(float(n)-1.0+2.0/float(K),n)/float(1+n*K);\n  }\n  float C = B(1.0/float(K),1.0-2.0/float(K))/float(K);\n  z *= C;\n  vec2 h = cpow(z,int(K));\n  float T1 = -cn[1];\n  float T2 = -cn[2]+float(K+1)*pow(cn[1],2.0);\n  float T3 = -cn[3]+float(3*K+2)*(cn[1]*cn[2]-float(K+1)/2.0*pow(cn[1],3.0));\n  float T4 = -cn[4]+float(2*K+1)*(2.0*cn[1]*cn[3]+pow(cn[2],2.0)-float(4*K+3)*\n                                  (pow(cn[1],2.0)*cn[2]-float(K+1)/3.0*pow(cn[1],4.0)));\n  float T5 = -cn[5]+float(5*K+2)*(cn[1]*cn[4]+cn[2]*cn[3]+float(5*K+3)*\n            (-0.5*pow(cn[1],2.0)*cn[3]-0.5*cn[1]*pow(cn[2],2.0)+float(5*K+4)*\n            (pow(cn[1],3.0)*cn[2]/6.0-float(K+1)*pow(cn[1],5.0)/24.0)));\n  vec2 X = vec2(1,0)+h/pow(C,float(K));\n  vec2 w = cmul(z,vec2(1,0) + T1*h + T2*cpow(h,2) + T3*cpow(h,3) + T4*cpow(h,4) + cdiv(T5*cpow(h,5),X));\n  return w;\n}\n\nvec2 hexgrid2hex(in vec2 Z, out vec3 U_id) {\n    const float\n        SQRT3 = sqrt(3.),\n        SQRT_3 = 1./SQRT3;\n\tconst mat2\n        M = mat2(SQRT_3,-1.,-SQRT_3,-1.),\n        iM = 0.5*mat2(SQRT3,-SQRT3,-1.,-1.);\n    Z = crot(Z,PI/6.);\n    Z = iM*Z/0.75;\n    vec3 U = vec3(Z.x,-Z.x-Z.y,Z.y);\n    U_id = 2.*floor(U*0.5+0.5);\n    vec3 U_lo = U-U_id;\n    vec3 aU_lo = abs(U_lo);\n    if (aU_lo.x > aU_lo.y && aU_lo.x > aU_lo.z) {\n        U_lo.x = -U_lo.y-U_lo.z;\n        U_id.x = -U_id.y-U_id.z;\n    }\n    if (aU_lo.y > aU_lo.z) {\n        U_lo.y = -U_lo.x-U_lo.z;\n        U_id.y = -U_id.x-U_id.z;\n    }\n    else {\n        U_lo.z = -U_lo.x-U_lo.y;\n        U_id.z = -U_id.x-U_id.y;\n    }\n    Z = U_lo.rb;\n    Z = M*Z*0.75;\n    return crot(Z,-PI/6.);\n}\n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// sdf\nfloat opIntersection( float d1, float d2 ) {\n    return max(d1,d2); }\n\nfloat opSmoothUnion( in float d1, in float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, float r ) {\n  return length(p.xz)-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// color\nvec3 h2rgb(float h) {\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n}\n\n// srgb <--> rgb (linear)\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lfXGzn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[823, 823, 845, 845, 2570], [2572, 2585, 2639, 2639, 3208], [3210, 3210, 3255, 3255, 3417], [3419, 3419, 3461, 3461, 3708], [3710, 3722, 3749, 3775, 3933], [3947, 3947, 3983, 4007, 4173], [4175, 4175, 4218, 4218, 4409], [4411, 4411, 4467, 4467, 4649], [4651, 4659, 4706, 4729, 7619]], "test": "untested"}
{"id": "mlKfWt", "name": "Testing Rhodium", "author": "sevenlabs", "description": "testing", "tags": ["noise", "fire", "demoscene", "volumetric", "spheretracing", "twister", "liquid"], "likes": 1, "viewed": 101, "published": 3, "date": "1702659275", "time_retrieved": "2024-07-30T17:16:26.673337", "image_code": "// ***********************************************************\n// Alcatraz / Rhodium 4k Intro liquid carbon\n// by Jochen \"Virgill\" FeldkÃ¶tter\n//\n// 4kb executable: http://www.pouet.net/prod.php?which=68239\n// Youtube: https://www.youtube.com/watch?v=YK7fbtQw3ZU\n// ***********************************************************\n\n#define time iTime\n#define res iResolution\n\nconst float GA =2.399; \nconst mat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n\n// \tsimplyfied version of Dave Hoskins blur\nvec3 dof(sampler2D tex,vec2 uv,float rad)\n{\n\tvec3 acc=vec3(0);\n    vec2 pixel=vec2(.002*res.y/res.x,.002),angle=vec2(0,rad);;\n    rad=1.;\n\tfor (int j=0;j<80;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/80.;\n}\n\n//-------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / res.xy;\n\tfragColor=vec4(dof(iChannel0,uv,texture(iChannel0,uv).w),1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ***********************************************************\n// Alcatraz / Rhodium 4k Intro liquid carbon\n// by Jochen \"Virgill\" FeldkÃ¶tter\n//\n// 4kb executable: http://www.pouet.net/prod.php?which=68239\n// Youtube: https://www.youtube.com/watch?v=YK7fbtQw3ZU\n// ***********************************************************\n\n#define time iTime\n#define res iResolution\n\nfloat bounce;\n\n// signed box\nfloat sdBox(vec3 p,vec3 b)\n{\n  vec3 d=abs(p)-b;\n  return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\n// rotation\nvoid pR(inout vec2 p,float a) \n{\n\tp=cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\n// 3D noise function (IQ)\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nfloat map(vec3 p)\n{\t\n\tp.z-=1.0;\n    p*=0.9;\n    pR(p.yz,bounce*1.+0.4*p.x);\n    return sdBox(p+vec3(0,sin(1.6*time),0),vec3(20.0, 0.05, 1.2))-.4*noise(8.*p+3.*bounce);\n}\n\n//\tnormal calculation\nvec3 calcNormal(vec3 pos)\n{\n    float eps=0.0001;\n\tfloat d=map(pos);\n\treturn normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));\n}\n\n\n// \tstandard sphere tracing inside and outside\nfloat castRayx(vec3 ro,vec3 rd) \n{\n    float function_sign=(map(ro)<0.)?-1.:1.;\n    float precis=.0001;\n    float h=precis*2.;\n    float t=0.;\n\tfor(int i=0;i<120;i++) \n\t{\n        if(abs(h)<precis||t>12.)break;\n\t\th=function_sign*map(ro+rd*t);\n        t+=h;\n\t}\n    return t;\n}\n\n// \trefraction\nfloat refr(vec3 pos,vec3 lig,vec3 dir,vec3 nor,float angle,out float t2, out vec3 nor2)\n{\n    float h=0.;\n    t2=2.;\n\tvec3 dir2=refract(dir,nor,angle);  \n \tfor(int i=0;i<50;i++) \n\t{\n\t\tif(abs(h)>3.) break;\n\t\th=map(pos+dir2*t2);\n\t\tt2-=h;\n\t}\n    nor2=calcNormal(pos+dir2*t2);\n    return(.5*clamp(dot(-lig,nor2),0.,1.)+pow(max(dot(reflect(dir2,nor2),lig),0.),8.));\n}\n\n//\tsoftshadow \nfloat softshadow(vec3 ro,vec3 rd) \n{\n    float sh=1.;\n    float t=.02;\n    float h=.0;\n    for(int i=0;i<22;i++)  \n\t{\n        if(t>20.)continue;\n        h=map(ro+rd*t);\n        sh=min(sh,4.*h/t);\n        t+=h;\n    }\n    return sh;\n}\n\n//\tmain function\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{    \n    bounce=abs(fract(0.05*time)-.5)*20.; // triangle function\n    \n\tvec2 uv=gl_FragCoord.xy/res.xy; \n    vec2 p=uv*2.-1.;\n   \n// \tbouncy cam every 10 seconds\n    float wobble=(fract(.1*(time-1.))>=0.9)?fract(-time)*0.1*sin(30.*time):0.;\n    \n//  camera    \n    vec3 dir = normalize(vec3(2.*gl_FragCoord.xy -res.xy, res.y));\n    vec3 org = vec3(0,2.*wobble,-3.);  \n    \n\n// \tstandard sphere tracing:\n    vec3 color = vec3(0.);\n    vec3 color2 =vec3(0.);\n    float t=castRayx(org,dir);\n\tvec3 pos=org+dir*t;\n\tvec3 nor=calcNormal(pos);\n\n// \tlighting:\n    vec3 lig=normalize(vec3(.2,6.,.5));\n//\tscene depth    \n    float depth=clamp((1.-0.09*t),0.,1.);\n    \n    vec3 pos2 = vec3(0.);\n    vec3 nor2 = vec3(0.);\n    if(t<12.0)\n    {\n    \tcolor2 = vec3(max(dot(lig,nor),0.)  +  pow(max(dot(reflect(dir,nor),lig),0.),16.));\n    \tcolor2 *=clamp(softshadow(pos,lig),0.,1.);  // shadow            \t\n       \tfloat t2;\n\t\tcolor2.rgb +=refr(pos,lig,dir,nor,0.9, t2, nor2)*depth;\n        color2-=clamp(.1*t2,0.,1.);\t\t\t\t// inner intensity loss\n\n\t}      \n  \n\n    float tmp = 0.;\n    float T = 1.;\n\n//\tanimation of glow intensity    \n    float intensity = 0.1*-sin(.209*time+1.)+0.05; \n\tfor(int i=0; i<128; i++)\n\t{\n        float density = 0.; float nebula = noise(org+bounce);\n        density=intensity-map(org+.5*nor2)*nebula;\n\t\tif(density>0.)\n\t\t{\n\t\t\ttmp = density / 128.;\n            T *= 1. -tmp * 100.;\n\t\t\tif( T <= 0.) break;\n\t\t}\n\t\torg += dir*0.078;\n    }    \n\tvec3 basecol=vec3(1./1. ,  1./4. , 1./16.);\n    T=clamp(T,0.,1.5); \n    color += basecol* exp(4.*(0.5-T) - 0.8);\n    color2*=depth;\n    color2+= (1.-depth)*noise(6.*dir+0.3*time)*.1;\t// subtle mist\n\n    \n//\tscene depth included in alpha channel\n    fragColor = vec4(vec3(1.*color+0.8*color2)*1.3,abs(0.67-depth)*2.+4.*wobble);\n}\n\n\n\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlKfWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[453, 497, 540, 540, 799], [801, 895, 949, 949, 1051]], "test": "untested"}
{"id": "DtVBWd", "name": "[phreax] neural programming", "author": "phreax", "description": "Experimental mashup of different effects and ideas of mine and others.\n\nbased on:\nFractal: https://shadertoy.com/view/dllcDM\nNeurons: https://www.shadertoy.com/view/dlGfWV\nDroste: https://www.shadertoy.com/view/MtGSzV", "tags": ["2d", "fractal"], "likes": 12, "viewed": 320, "published": 3, "date": "1702656051", "time_retrieved": "2024-07-30T17:16:27.571935", "image_code": "// Fork of \"N,N-Dimethyltryptamin Fade 1\" by POSTHELIOS. https://shadertoy.com/view/DltBD8\n// 2023-12-15 00:18:30\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Fork of \"[phreax] ordered chaos\" by phreax. https://shadertoy.com/view/dllcDM\n// 2023-12-15 01:00:30\n\n\n\n#define R1 0.15\n#define R2 1.0\n#define TAU 6.28318530718\n#define SIN(x) (.5+.5*sin(x))\n\nvec3 pal(float t) {\n\n    vec3 a = vec3(.6);\n    vec3 b = vec3(1.);\n    vec3 c = vec3(.5);\n    vec3 d = vec3(0.161,1.000,0.902);\n    \n    //d = vec3(0.216,0.14,0.545);\n    return a + b*cos(6.283*(c*t+d));\n}\n\n\nvec2 drosteSpiral(in vec2 uv, out vec2 zOut) {\n    //math from www.josleys.com/article_show.php?id=82\n\n    // cartesian coordinates -> z coords, (r, theta) = ( sqrt(x*x + y*y), atan(y/x) )\n    vec2 z = vec2(length(uv),atan(uv.y,uv.x));\n    // transform z-> log(z/R1)\n    z.x = log(z.x/R1);\n    //z.x += .1*iTime;\n    // ratio for the radia\n    float ratio = log(R2/R1);\n    // alpha = atan(log(r2/r1)/2pi)\n    float alpha = atan(ratio, TAU);\n    // lets make a rotation matrix\n    // remember that GLSL is right handed...\n    mat2 digamma = mat2(cos(alpha), sin(alpha),\n                        -sin(alpha), cos(alpha));\n    // Rotate\n    vec2 beta = digamma * z;\n    // Still don't get why we are adjusting this by the alpha... Looking at the math, this seems to be the isolation of\n    // the complex plane without the rotation in the form of e^ia since B = Fe^ia, e^ia = B/F...\n    beta = beta/cos(alpha);\n    // This is where we are duplicating, but I still don't understand how...\n    // Ok, I think I got it - we are shifting by the width of the transformed strip\n    // where the R2 radius circle ends up being a line on log(r2/r1). So we want to move up until we hit that width,\n    // then start again\n    beta.x = mod(beta.x, log(R2/R1));\n    // And lets twist this bad boy with the exponentiation and convert it back to cartesian coords.\n    // Polar -> Cartesian: (x,y) = r*(cos(theta), sin(theta))\n    // And also scale back by R1\n    beta = R1 * exp(beta.x) * vec2(cos(beta.y), sin(beta.y));\n    \n    zOut = z;\n    return beta;\n}\n\n\n\n// chebyshev distance\nfloat d2(vec2 v, float k) {\n    return pow(pow(abs(v.x), k)+pow(abs(v.y), k), 1./k);\n}\n\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat neurons(vec2 uv) {\n\n    float t = iTime*2.;\n    \n    vec2 n = vec2(0),q;\n    vec2 N = vec2(0);\n    vec2 p = uv + sin(t*0.1)/10.;\n    float S = 5.;\n    mat2 m = rot(1. - 0.0001);\n\n    for(float j=0.;j++<30.;){\n      p*=m;\n      n*=m;\n      q=p*S+j+n+t;\n      n+=sin(q+iMouse.x*0.001);\n      N+=cos(q+iMouse.y*0.001)/S;\n      S*=1.15;\n      \n    }\n    \n    float v = pow((N.x + N.y + 0.1)+.0001/length(N), 2.1);\n    \n   // v = pow(v*1.5, 2.);\n    return v;\n\n\n}\n\nvec3 fractalNeuron(vec2 uv, float N, float n, float l) {\n    \n\n    vec2 uv0 = uv;\n    vec2 uv2 = uv;\n\n    vec3 col = vec3(0);\n    \n    for(float i=0.; i<N; i++) {\n\n        uv = fract(uv*(1.9))-.5;\n        uv2 = fract(uv2*(1.+.5*sin(iTime*.1)))-.5;\n        \n        vec3 c = pal(length(uv0) + iTime*.4 + i*.9);\n        \n        \n        float d = (d2(uv, 1.2)+0.05/n+length(uv2)*exp(-length(uv0)));\n        \n        d = abs(.1*d+sin(d*(8.+2.*n))/10.)+0.001/n;\n        d = l*.1*pow((0.02)/d, 1.2) + smoothstep(.05, .0, d);\n   \n        d = max(0., d);\n\n        col += d*c;\n    \n    }\n    return col;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2. - iResolution.xy)/iResolution.y;\n    \n    float exp_droste_zoom = exp(-mod(iTime*.5, 10.));\n  \n    float n1 = neurons(uv);\n    vec2 zSpiral;\n    uv = drosteSpiral(uv*exp_droste_zoom, zSpiral);\n    \n    uv += vec2(.1, -.2)*sin(iTime*.2);\n    uv *= rot(iTime*.3);\n    float n2 = neurons(uv);\n    \n    vec3 colN = fractalNeuron(uv, 6., n1, 1.);\n    colN = mix(colN, fractalNeuron(uv, 6., n2, 1.),.5)*1.5;\n    \n    vec2 uv0 = uv;\n    vec2 uv2 = uv;\n    \n    vec3 colBg = fractalNeuron(uv, 6., 1., 0.);\n\n    \n    fragColor = vec4(mix(colN, colBg, mix(.2, .4*smoothstep(0.4, .5, length(uv)), .4)),1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtVBWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 172, 172, 300]], "test": "untested"}
{"id": "clGBWt", "name": "Hyperbolic Triangle Geometry", "author": "mla", "description": "Basic geometric operations in hyperboloid model using homogeneous coordinates. Drag with mouse, set triangle size with control ring, restart angle animation with 't'. See header for more info.", "tags": ["hyperbolic", "hyperboloid", "heptagon", "heptagon"], "likes": 11, "viewed": 269, "published": 3, "date": "1702644181", "time_retrieved": "2024-07-30T17:16:28.649054", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Hyperbolic Triangle Geometry, mla, 2023.\n//\n// Using the hyperboloid model for basic geometry operations, finding\n// midpoints, bisectors, doing reflections & so on. Find circumcentre,\n// orthocentre, centroid, incentre & outcentres, with the corresponding\n// lines. Figuring out what is what is left to reader.\n//\n// Circles don't appear if their centre is outside hyperbolic space,\n// though we could still show eg. the partial circle through the\n// triangle points.\n//\n// Set size of triangle with control blob (hide with 'x')\n// Mouse applies translation\n//\n// d: show region outside disc\n// l: scale width of lines (doesn't look good, a useful test though).\n// t: animation of angle\n// x: hide control blob\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Basic operations for hyperbolic (Minkowski) space\n\n// Inner product\nfloat hdot(vec3 p, vec3 q) {\n  return dot(vec3(1,1,-1)*p,q);\n}\n\nvec3 hcross(vec3 p, vec3 q) {\n  // hdot(p,hcross(p,q)) = hdot(q,hcross(p,q)) = 0\n  return cross(p,q)*vec3(1,1,-1);\n}\n\nfloat hnorm(vec3 p) {\n  return hdot(p,p);\n}\n\nfloat hlength(vec3 p) {\n  return sqrt(abs(hnorm(p)));\n}\n\n// Normalize a point or a line\nvec3 hnormalize(vec3 p) {\n  float t = hnorm(p);\n  if (t < 0.0 && p.z < 0.0) p = -p;\n  return p/sqrt(abs(t));\n}\n\nvec3 pnormalize(vec3 p) {\n  float t = hnorm(p);\n  if (t >= 0.0) return vec3(0); // Invalid point\n  if (p.z < 0.0) p = -p;\n  return p/sqrt(abs(t));\n}\n\n// Map point on plane to hyperboloid hnorm(p) = -1\nvec3 unproject(vec2 z) {\n  // kÂ²|z|Â²-(1-k)Â² = -1\n  // kÂ²|z|Â²-1+2k-kÂ² = -1\n  // k|z|Â²+2-k = 0\n  float k = 2.0/(1.0-dot(z,z));\n  return vec3(k*z,k-1.0);\n}\n\n// NB: sinh(x) = asinh(x) = tanh(x) = x (approximately) for\n// small values of x (eg. sinh 0.1 = 0.10017, tanh 0.1 = 0.0997)\n// Hyperbolic distance from line\nfloat hline(vec3 p, vec3 l) {\n  //return abs(hdot(p,l)); // Asymptotic approximation\n  return abs(asinh(hdot(p,l)));\n}\n\nbool hline(inout float d, inout int t, vec3 p, vec3 l, int type) {\n  float d0 = hline(p,l);\n  if (d0 > d) return false;\n  d = d0;\n  t = type;\n  return true;\n}\n\nfloat hcircle(vec3 p, vec3 centre, float radius) {\n  float d = 2.0*abs(asinh(0.5*hlength(p-centre)));\n  return abs(d-radius);\n}\n\nbool hcircle(inout float d, inout int t, vec3 p, vec3 centre, float radius, int type) {\n  if (centre == vec3(0)) return false;\n  float d0 = hcircle(p,centre,radius);\n  if (d0 > d) return false;\n  d = d0; t = type;\n  return true;\n}\n\n// Hyperbolic distance between points\nfloat hpoint(vec3 p, vec3 q) {\n  //return acosh(-hdot(p,q)); // Bad truncation error\n  return 2.0*abs(asinh(0.5*hlength(p-q)));\n}\n\nbool hpoint(inout float d, inout int t, vec3 p, vec3 q, int type) {\n  if (q == vec3(0)) return false;\n  float d0 = hpoint(p,q);\n  if (d0 > d) return false;\n  d = d0; t = type;\n  return true;\n}\n\nbool hpoint(inout float d, inout int t, vec3 p, vec3 q) {\n  return hpoint(d,t,p,q,0);\n}\n\n// Find a point on the line formed by the intersections\n// of planes l and m. Try to find point of form\n// (x,y,0), (x,0,z) or (0,y,z) by solving a 2x2\n// linear system. Construct three matrices & use the one\n// with largest determinant (it's possible for two\n// determinants to be zero, but not all three if the\n// planes aren't parallel).\nvec3 linepoint(vec3 l, vec3 m, float a, float b) {\n  vec2 A = vec2(1,-1); // adjust for metric\n  mat2 m0 = mat2(l.xy,m.xy);\n  mat2 m1 = mat2(A*l.xz,A*m.xz);\n  mat2 m2 = mat2(A*l.yz,A*m.yz);\n  float d0 = abs(determinant(m0));\n  float d1 = abs(determinant(m1));\n  float d2 = abs(determinant(m2));\n  float dmax = max(d0,max(d1,d2));\n  if (dmax == d1) m0 = m1;\n  else if (dmax == d2) m0 = m2;\n  vec3 p = vec3(vec2(a,b)*inverse(m0),0);\n  if (dmax == d1) p = p.xzy;\n  else if (dmax == d2) p = p.zxy;\n  assert(eq(hdot(p,l),a));\n  assert(eq(hdot(p,m),b));\n  return p;\n}\n\n// Given vectors l and m, return a normalized vector n\n// with l.n = a, m.n = b (all with Minkowski product)\n// sign parameter says if we want a line (spacelike) or a point (timelike)\nbool f(vec3 l, vec3 m, float a, float b, out vec3 n, float sign) {\n  // Want a line m with hdot(l,n) = A, hdot(m,n) = B\n  vec3 r = hcross(m,l); // Direction vector for intersection of planes l and m\n  // Now find p with hdot(p,l) = A, hdot(p,m) = B\n  vec3 p = linepoint(l,m,a,b);\n  // Now try to find a normalized point on that line ie. hnorm(p+tr) = <sign>\n  // (p+tr).(p+tr) - sign = 0\n  // p.p + 2t(p.r) + tÂ²(r.r) - 1 = 0\n  // Set p.r = 0, so B = 0 in quadratic formula\n  p -= hdot(p,r)/hdot(r,r)*r;\n  float A = hdot(r,r);\n  float C = hdot(p,p) - sign;\n  float D = -A*C;\n  if (D < 0.0) return false;\n  // Two solutions are eg. for complementary angles, opposite distances.\n  float t = sqrt(D)/A;\n  n = p+t*r;\n  return true;\n}\n\n// Find a (normalized) point p with l.p = a, m.p = b\n// l and m can be points or lines\nvec3 fpoint(vec3 l, vec3 m, float a, float b) {\n  vec3 p;\n  bool t = f(l,m,a,b,p,-1.0);\n  assert(t);\n  assert(p.z >= 0.0);\n  return p;\n}\n\n// Find a (normalized) line p with l.p = a, m.p = b\n// l and m can be points or lines\nvec3 fline(vec3 l, vec3 m, float a, float b) {\n  vec3 p;\n  bool t = f(l,m,a,b,p,1.0);\n  assert(t);\n  assert(p.z <= 0.0);\n  return p;\n}\n\n// Get point on line l, distance d from p, also on l.\n// Same as fpoint(p,l,-cosh(d),0) but less rounding error.\n// ie. get q such that q.l = 0, q.p = -cosh(d)\n// hcross(p,l) is perpendicular to l at p, \nvec3 pointatdistance(vec3 p, vec3 l, float d) {\n  //return fpoint(p,l,-cosh(d),0.0);\n  vec3 r = hcross(l,p); // Tangent vector\n  float k = tanh(d)/hlength(r); // Get right angle\n  vec3 q = p+k*r;\n  return hnormalize(q); // And normalize\n}\n\n// Reflect in a hyperbolic line\nint tryreflect(vec3 l, int i, inout vec3 p, inout uint h) {\n  float k = hdot(p,l);\n  if (k > 0.0) return 0;\n  p -= 2.0*k*l;\n  h = ihash(h^uint(i));\n  return 1;\n}\n\n// Reflect in a euclidean line\nint tryreflect(vec2 l, int i, inout vec2 z, inout uint h) {\n  float k = dot(z,l);\n  if (k > 0.0) return 0;\n  z -= 2.0*k*l;\n  h = ihash(h^uint(i));\n  return 1;\n}\n\n// Invert in a euclidean circle\nint tryinvert(vec3 c, int i, inout vec2 z, inout uint h) {\n  float r2 = c.z;\n  vec2 z1 = z-c.xy;\n  float l2 = dot(z1,z1);\n  if (l2 > r2) return 0;\n  z1 *= r2/l2;\n  z = z1+c.xy;\n  h = ihash(h^uint(i));\n  return 1;\n}\n\n// Convert hyperbolic line into a Euclidean circle.\n// z component is square of radius.\nvec3 tocircle(vec3 l) {\n  assert(l.z != 0.0);\n  l /= l.z;\n  l.z = dot(l.xy,l.xy)-1.0;\n  return l;\n}\n\n// Convert hyperbolic line into a Euclidean line.\nvec2 toline(vec3 l) {\n  assert(l.z == 0.0);\n  return l.xy;\n}\n\n// Given a Euclidean distance d, and a direction p, return\n// an hspace point that is at that distance and direction\n// from the centre in the Poincare disc.\nvec3 pointfromcentre(float d, vec2 p) {\n  float x = 2.0*d/(1.0-d*d);\n  float t = sqrt(1.0+x*x);\n  return vec3(x*p,t);\n}\n\nvec3 hreflect(vec3 p, vec3 m) {\n  p -= 2.0*hdot(p,m)*m;\n  return p;\n}\n\nvec3 hperp(vec3 p, vec3 m) {\n  p -= hdot(p,m)*m;\n  return pnormalize(p);\n}\n\nvec3 mpoint(vec3 A, vec3 B, vec3 C, float t) {\n  float d[] = float[](acosh(-hdot(A,B)),\n                      acosh(-hdot(B,C)),\n                      acosh(-hdot(C,A)));\n  float ttime = d[0]+d[1]+d[2];\n  t = mod(t,ttime);\n  vec3 P0 = A, P1 = B;\n  do {\n    // This seems a bit awkward\n    if (t < d[0]) break;\n    t -= d[0];\n    if (t < d[1]) { P0 = B; P1 = C; break; }\n    t -= d[1];\n    P0 = C, P1 = A;\n  } while(false);\n  // We could express P as aA+bB then\n  // |aA+bB|Â² = -1 and (aA+bB).P = cosh(-t)\n  vec3 P = pointatdistance(P0,hcross(P0,P1),t);\n  return P;\n}\n\nvec3 getcol(int t) {\n  if (t == 0) return vec3(0);\n  if (t == 1) return vec3(1,0,0);\n  if (t == 2) return vec3(0,1,0);\n  if (t == 3) return vec3(0,0,1);\n  if (t == 4) return vec3(1,1,0);\n  if (t == 5) return vec3(1);\n  return vec3(1,0,1);\n}\n\n// A+B is midpoint\n// A-B is perp bisector (a line)\n// a-b, a+b are internal & external bisectors (depending on orientation of the lines)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 z = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  vec2 w = defaultselection();\n  vec2 params = 2.0*abs(getselection(0));\n  float scale = 1.0;\n  scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  z *= scale;\n  w *= scale;\n  float lwidth = 0.02;\n  float pwidth = 3.0*lwidth;\n  if (!key(CHAR_L)) { lwidth = 0.0; pwidth = 0.02; }\n  \n  float px = fwidth(z.x);\n  bool dohalfplane = key(CHAR_H);\n  bool dozoom = key(CHAR_Z);\n  if (dohalfplane) z.y += scale;\n  // Conversion factor between hyperbolic and screen distances\n  float scalefactor = 1.0;\n  if (dohalfplane) {\n    if (dozoom) {\n      float k = exp(-iTime);\n      z *= k;\n      scalefactor /= k;\n    }\n    z.y += 1.0;\n    float k = 2.0/dot(z,z);\n    z *= k;\n    scalefactor /= k;\n    z.y -= 1.0;\n  }\n  scalefactor *= 0.5*abs(1.0 - dot(z,z)); // Scale factor for disc\n  if (true) {\n    // Invert to mouse position\n    vec2 c = w;\n    z -= c;\n    z *= (dot(c,c)-1.0)/dot(z,z);\n    z += c;\n    z /= -dot(z,z);\n  }\n  bool indisc = dot(z,z) <= 1.0;\n  if (!indisc) z /= dot(z,z);\n  vec3 p = unproject(z);\n  float theta = PI/3.0;\n  if (iMouse.x <= 0.0 || key(CHAR_T)) theta += 0.25*iTime;\n  // Three triangle points, A is at the origin,\n  // A,B,C are in clockwise order for theta < 180Â°\n  vec3 b = vec3(1,0,0);\n  vec3 c = vec3(-cos(theta),sin(theta),0);\n  vec3 A = vec3(0,0,1);\n  vec3 B = pointatdistance(A,c,params[0]); // Note line orientation!\n  vec3 C = pointatdistance(A,-b,params[1]);\n  vec3 a = hnormalize(hcross(B,C));\n  // Depending on orientation of the triangle, inside is either\n  // all positive or all negative.\n  bool intriangle = hdot(p,a) > 0.0 && hdot(p,b) > 0.0 && hdot(p,c) > 0.0;\n  bool outtriangle = hdot(p,a) < 0.0 && hdot(p,b) < 0.0 && hdot(p,c) < 0.0;\n  // Feet of altitudes\n  vec3 D = hperp(A,a);\n  vec3 E = hperp(B,b);\n  vec3 F = hperp(C,c);\n  // The altitude lines\n  vec3 dline = hnormalize(hcross(A,D));\n  vec3 e = hnormalize(hcross(B,E));\n  vec3 f = hnormalize(hcross(C,F));\n  // Orthocentre\n  vec3 ortho = pnormalize(hcross(dline,e));\n  vec3 circum = pnormalize(hcross(A-B,B-C));\n  vec3 incentre = pnormalize(hcross(a-b,b-c));\n  float inradius = hpoint(incentre,hperp(incentre,a));\n  vec3 out1 = pnormalize(hcross(a-b,b+c));\n  vec3 out2 = pnormalize(hcross(b-c,c+a));\n  vec3 out3 = pnormalize(hcross(c-a,a+b));\n  // Median points and lines\n  vec3 A1 = hcross(a,B-C);\n  vec3 B1 = hcross(b,C-A);\n  vec3 C1 = hcross(c,A-B);\n  vec3 a1 = hnormalize(hcross(A,B+C));\n  vec3 b1 = hnormalize(hcross(B,C+A));\n  vec3 c1 = hnormalize(hcross(C,A+B));\n  vec3 cent = pnormalize(hcross(a1,b1));\n  vec3 T = mpoint(D,E,F,0.5*iTime);\n#if 0\n  vec3 T1 = hreflect(hreflect(T,b),a);\n  vec3 t1 = hnormalize(hcross(T,T1));\n  vec3 t2 = hreflect(t1,a);\n  vec3 t3 = hreflect(t2,b);\n#endif\n  vec3 col = vec3(0.5);\n  if (!intriangle && !outtriangle) col *= 0.8;\n  {\n    float d = 1e8;\n    int t = -1;\n    hline(d,t,p,a,0);\n    hline(d,t,p,b,0);\n    hline(d,t,p,c,0);\n    // Internal and external bisectors\n    hline(d,t,p,hnormalize(a-b),1);\n    hline(d,t,p,hnormalize(b-c),1);\n    hline(d,t,p,hnormalize(c-a),1);\n    hcircle(d,t,p,incentre,inradius,0);\n    hcircle(d,t,p,out1,hpoint(out1,hperp(out1,a)),0);\n    hcircle(d,t,p,out2,hpoint(out2,hperp(out2,a)),0);\n    hcircle(d,t,p,out3,hpoint(out3,hperp(out3,a)),0);\n    hcircle(d,t,p,circum,hpoint(circum,A),0);\n    hline(d,t,p,hnormalize(hcross(D,E)),5);\n    hline(d,t,p,hnormalize(hcross(E,F)),5);\n    hline(d,t,p,hnormalize(hcross(F,D)),5);\n#if 1\n    hline(d,t,p,hnormalize(a+b),1);\n    hline(d,t,p,hnormalize(b+c),1);\n    hline(d,t,p,hnormalize(c+a),1);\n#endif\n    // Medians\n    hline(d,t,p,a1,2);\n    hline(d,t,p,b1,2);\n    hline(d,t,p,c1,2);\n\n#if 0\n    hline(d,t,p,t1,0);\n    hline(d,t,p,t2,0);\n    hline(d,t,p,t3,0);\n#endif\n#if 1\n    // Perp bisectors, intersecting at circumcentre\n    hline(d,t,p,hnormalize(A-B),3);\n    hline(d,t,p,hnormalize(B-C),3);\n    hline(d,t,p,hnormalize(C-A),3);\n    // Altitudes\n    hline(d,t,p,dline,4);\n    hline(d,t,p,e,4);\n    hline(d,t,p,f,4);\n#endif\n    vec3 lcol = getcol(t);\n    col = mix(lcol,col,smoothstep(0.0,px/scalefactor,d-lwidth));\n  }\n  {\n    float d = 1e8;\n    int t = 0;\n    //hpoint(d,t,p,pnormalize(A+B),3);\n    hpoint(d,t,p,A);\n    hpoint(d,t,p,B);\n    hpoint(d,t,p,C);\n    hpoint(d,t,p,ortho);\n    hpoint(d,t,p,circum);\n    hpoint(d,t,p,cent);\n    hpoint(d,t,p,incentre);\n    hpoint(d,t,p,out1);\n    hpoint(d,t,p,out2);\n    hpoint(d,t,p,out3);\n    hpoint(d,t,p,T,1);\n    //hpoint(d,t,p,T1,1);\n#if 0\n    hpoint(d,t,p,D);\n    hpoint(d,t,p,E);\n    hpoint(d,t,p,F);\n#endif\n    col = mix(getcol(t),col,smoothstep(0.0,px/scalefactor,d-pwidth));\n  }\n  if (!indisc) col *= !key(CHAR_D) ? 0.0 : 0.5;\n  if (showconfig) {\n    vec2 p = map(fragCoord);\n    float d = abs(distance(p,getselection(0))-0.03)-0.005;\n    col = mix(vec3(1,0,0),col,0.25+0.75*smoothstep(0.0,px,d));\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  //setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  vec4 t0 = texelFetch(iChannel2,ivec2(0),0); // Get current state   \n  if (t0 != vec4(1234.0)) {\n    t = vec4(0);\n  }  \n  if (j == 0) {\n    if (i == 0) t = vec4(1234.0);\n    else {\n      // First row - key count\n      // Do key repeat here as well?\n      float w1 = keystate(i,0).x;\n      if (w1 != t.w) {\n        t.w = w1;\n        // Don't count key changes when ALT pressed\n        if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n          t.x++; t.y = iTime;\n        }\n      }\n      // Key repeat - only when shader is running!\n      // Should have longer pause after first key press.\n      if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n        t.x++; t.y = iTime;\n      }\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (showconfig && t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        t.x = -1.0;\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < 0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n      if (t.x <= 0.0 && iMouse.z > 0.0) {\n        t.zw = iMouse.x < 20.0 ? vec2(0) : map(iMouse.xy);\n      }\n    } else if (t.w != 1234.0) {\n      t.xy = initselection(i-1); // Current coordinates\n      t.w = 1234.0;\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store((key),0).x))\n#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\n#define map(screenpos) ((2.0*(screenpos)-iResolution.xy)/iResolution.y)\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n//#define getselected() (texelFetch(iChannel2,ivec2(0,3),0))\n#define defaultselection() (texelFetch(iChannel2,ivec2(0,3),0).zw)\n//#define setscale() (scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP))))\n#define showconfig (!key(CHAR_X))\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst float PI =  3.141592654;\n\nconst int nselections = 1;\nvec2 initselection(int i) {\n  if (i == 0) return vec2(1,0.8);\n  if (i == 1) return vec2(0.75,0.25);\n  if (i == 2) return vec2(-2,-1.5);\n  if (i == 3) return vec2(0,-1);\n  if (i == 4) return vec2(0.25,0);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return mix(vec3(1),rgb,0.8);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nvec2 expi(float t) {\n  return normalize(vec2(cos(t),sin(t)));\n}\n\nbool eq(float a, float b) {\n  return abs(a-b) < 1e-4;\n}\n\nfloat COS[] =\n  float[](1.0,-1.0,0.0,0.5,0.7071067812,0.8090169944,0.8660254038,\n          0.9009688679,0.9238795325,0.9396926208,0.9510565163,0.9594929736,\n          0.9659258263,0.9709418174,0.9749279122,0.9781476007,0.9807852804,\n          0.9829730997,0.984807753,0.9863613034,0.9876883406,0.9888308262,\n          0.9898214419,0.990685946,0.9914448614,0.9921147013,0.9927088741,\n          0.9932383577,0.9937122099,0.9941379572,0.9945218954,0.9948693234);\n\nfloat icos(int p) {\n  // cos(PI/p)\n  if (p < COS.length()) return COS[p];\n  return cos(PI/float(p));\n}\n                        \nfloat isin(int p) {\n  // sin(PI/p)\n  float t = icos(p);\n  return sqrt(1.0-t*t);\n}\n\n// GPU cos might not be good enough for repeated reflections\n// Chebyshev might be better here, but these work pretty well.\nfloat mycos(float x) {\n  return cos(x);\n  int N = 14;\n  float x2 = x*x, y = 1.0;\n  for (int n = N; n > 0; n-=2) {\n    y = 1.0-x2*y/float(n*(n-1));\n  }\n  return y;\n}\n\nfloat mysin(float x) {\n  return sin(x);\n  int N = 12;\n  float x2 = x*x, y = 1.0;\n  for (int n = N; n > 0; n-=2) {\n    y = 1.0-x2*y/float(n*(n+1));\n  }\n  return x*y;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clGBWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[938, 955, 983, 983, 1017], [1019, 1019, 1048, 1099, 1135], [1137, 1137, 1158, 1158, 1180], [1182, 1182, 1205, 1205, 1237], [1239, 1270, 1295, 1295, 1380], [1382, 1382, 1407, 1407, 1530], [1532, 1583, 1607, 1682, 1742], [1744, 1902, 1931, 1986, 2020], [2022, 2022, 2088, 2088, 2180], [2182, 2182, 2232, 2232, 2309], [2311, 2311, 2398, 2398, 2541], [2543, 2581, 2611, 2665, 2710], [2712, 2712, 2779, 2779, 2904], [2906, 2906, 2963, 2963, 2993], [2995, 3336, 3386, 3386, 3897], [3899, 4083, 4149, 4202, 4812], [4814, 4901, 4948, 4948, 5037], [5039, 5125, 5171, 5171, 5259], [5261, 5465, 5512, 5549, 5703], [5705, 5737, 5796, 5796, 5898], [5900, 5931, 5990, 5990, 6091], [6093, 6125, 6183, 6183, 6339], [6341, 6429, 6452, 6452, 6528], [6530, 6580, 6601, 6601, 6640], [6642, 6800, 6839, 6839, 6919], [6921, 6921, 6952, 6952, 6990], [6992, 6992, 7020, 7020, 7066], [7637, 7637, 7657, 7657, 7877], [8018, 8018, 8075, 8075, 13009]], "test": "untested"}
{"id": "mtyfWd", "name": "ShaderToy_8_A/FM", "author": "tbx", "description": "A/FM", "tags": ["afm"], "likes": 3, "viewed": 154, "published": 3, "date": "1702631146", "time_retrieved": "2024-07-30T17:16:29.597518", "image_code": "#define PI 3.141592653\n#define COUNT 20.0\n\nfloat line(vec2 st, float width)\n{\n    return smoothstep(width, 0.0, abs(st.y - st.x));\n}\n\nfloat drawCoord(vec2 uv)\n{\n   float x = distance(vec2(uv.x, 0.0), vec2(0.0, 0.0));\n   float y = distance(vec2(0.0, uv.y), vec2(0.0, 0.0));\n   \n   return 1e-3 / x + 1e-3 / y;\n}\n\nfloat sphere(vec2 coord, vec2 p, float radius)\n{\n    float d = distance(p, coord);\n    d = abs(d - radius);\n    return 1e-3 / d;\n}\n\nfloat sphereShape(vec2 coord, vec2 p, float radius)\n{\n    float d = distance(p, coord);\n    d /= radius;\n    d = 1.0 - d;\n    d = clamp(d * 24.0, 0.0, 1.0);\n    return d;\n}\n\nfloat net(vec2 coord)\n{\n    float xline = cos(coord.x * PI * COUNT);\n    xline = step(1.0 - 1e-1, xline);\n    \n    float yline = cos(coord.y * PI * COUNT);\n    yline = step(1.0 - 1e-1, yline);\n    \n    return xline + yline;\n}\n\nfloat QuadrantIV(vec2 coord, float warp)\n{\n    float f = step(0.0, -coord.x);\n    f *= step(0.0, coord.y);\n    return abs(warp - f);\n}\n\nfloat QuadrantII(vec2 coord, float warp)\n{\n    float f = step(0.0, coord.x);\n    f *= step(0.0, -coord.y);\n    return abs(warp - f);\n}\n\nfloat noise(float x)\n{\n    return fract(sin(x * 43.3459 + 248.2435) * 545.344898);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float asp = iResolution.x / iResolution.y;\n    \n    vec2 coord = uv * 2.0 - 1.0;\n    \n    vec2 aspCoord = vec2(coord.x * asp, coord.y);\n    \n    vec2 spCoord = aspCoord;\n    \n    vec3 col = vec3(0.0);\n    \n    col += net(aspCoord) * 0.125;\n    \n    col += drawCoord(coord);\n    aspCoord.x += fract(iTime * 0.01) * 20.0 * PI;\n    float x = sin(aspCoord.x * PI * 4.0);\n    x += sin(aspCoord.x * 5.2995);\n    x += sin(aspCoord.x * 3.1245) * 0.5;\n    x += sin(aspCoord.x * 2.1245) * 0.66;\n    x += sin(aspCoord.x * 18.1245) * 0.42;\n    \n    col += line(vec2(x, aspCoord.y * 4.0), 0.09);\n    \n    col += sphereShape(spCoord * 4.0, vec2(-0.1, x + 0.3), 0.15);\n    col += sphereShape(spCoord * 4.0, vec2(0.0, x + 0.3), 0.3);\n    col += sphereShape(spCoord * 4.0, vec2(0.1, x + 0.3), 0.6);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtyfWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 77, 77, 132], [134, 134, 160, 160, 309], [311, 311, 359, 359, 441], [443, 443, 496, 496, 615], [617, 617, 640, 640, 842], [844, 844, 886, 886, 978], [980, 980, 1022, 1022, 1114], [1116, 1116, 1138, 1138, 1200], [1202, 1202, 1259, 1309, 2202]], "test": "untested"}
{"id": "DtKfRV", "name": "ShaderToy_7_TextureCoord", "author": "tbx", "description": "7", "tags": ["learning"], "likes": 1, "viewed": 146, "published": 3, "date": "1702631138", "time_retrieved": "2024-07-30T17:16:30.345519", "image_code": "#define PI 3.141592653\n\n#define COUNT 20.0\n\nfloat drawCoord(vec2 uv)\n{\n   float x = distance(vec2(uv.x, 0.0), vec2(0.0, 0.0));\n   float y = distance(vec2(0.0, uv.y), vec2(0.0, 0.0));\n   \n   return 1e-3 / x + 1e-3 / y;\n}\n\nfloat net(vec2 coord)\n{\n    float xline = cos(coord.x * PI * COUNT);\n    xline = step(1.0 - 1e-1, xline);\n    \n    float yline = cos(coord.y * PI * COUNT);\n    yline = step(1.0 - 1e-1, yline);\n    \n    return xline + yline;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float asp = iResolution.x / iResolution.y;\n    \n    vec2 coord = uv * 2.0 - 1.0;\n    \n    vec2 aspCoord = vec2(coord.x * asp, coord.y);\n    \n    float factor1 = coord.x * coord.y;\n    factor1 = step(1e-12, factor1);\n    float factor2 = -coord.x * coord.y;\n    factor2 = step(1e-12, factor2);\n    float factor3 = step(1e-12, coord.y); \n    float factor4 = step(1e-12, -coord.y);\n    \n    float f1 = factor1 * factor3;\n    float f2 = factor2 * factor4;\n    float f3 = factor1 * factor4;\n    float f4 = factor2 * factor3;\n    \n    vec3 col = vec3(0.0);\n    \n    col += net(aspCoord) * 0.125;\n    col += drawCoord(aspCoord);\n    \n    col += texture(iChannel0, coord).xyz * f1;\n    vec2 scale = iResolution.xy / 8.0;\n    col += texture(iChannel0, floor(coord * scale) * (1.0 / scale)).xyz * f2;\n    scale = iResolution.xy / 16.0;\n    col += texture(iChannel0, floor(coord * scale) * (1.0 / scale)).xyz * f3;\n    scale = iResolution.xy / 32.0;\n    col += texture(iChannel0, floor(coord * scale) * (1.0 / scale)).xyz * f4;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtKfRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 70, 70, 219], [221, 221, 244, 244, 446], [449, 449, 506, 556, 1659]], "test": "untested"}
{"id": "DlVBz1", "name": "ShaderToy_6_Random", "author": "tbx", "description": "random", "tags": ["random"], "likes": 2, "viewed": 125, "published": 3, "date": "1702631129", "time_retrieved": "2024-07-30T17:16:31.240127", "image_code": "#define PI 3.141592653\n#define COUNT 20.0\n\nfloat drawCoord(vec2 uv)\n{\n   float x = distance(vec2(uv.x, 0.0), vec2(0.0, 0.0));\n   float y = distance(vec2(0.0, uv.y), vec2(0.0, 0.0));\n   \n   return 1e-3 / x + 1e-3 / y;\n}\n\nfloat net(vec2 coord)\n{\n    float xline = cos(coord.x * PI * COUNT);\n    xline = step(1.0 - 1e-1, xline);\n    \n    float yline = cos(coord.y * PI * COUNT);\n    yline = step(1.0 - 1e-1, yline);\n    \n    return xline + yline;\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float asp = iResolution.x / iResolution.y;\n    \n    vec2 coord = uv * 2.0 - 1.0;\n    \n    vec2 aspCoord = vec2(coord.x * asp, coord.y);\n    \n    vec3 col = vec3(0.0);\n    \n    col += net(aspCoord) * 0.125;\n    \n    col += drawCoord(aspCoord);\n    \n    float x = aspCoord.x * COUNT * 0.5;\n    float y = aspCoord.y * COUNT * 0.5;\n    \n    x = floor(x);\n    y = floor(y);\n    \n    vec2 texcoord = vec2(x, y);\n    float r = random(texcoord);\n    float g = random(vec2(r));\n    float b = random(vec2(r,g));\n\n    col += vec3(r,g,b);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlVBz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 69, 69, 218], [220, 220, 243, 243, 445], [447, 447, 474, 474, 581], [583, 583, 640, 690, 1328]], "test": "untested"}
{"id": "mlyfWt", "name": "Fork fractal tr TritiumNeb 388", "author": "TritiumNebula", "description": "This but slower https://www.shadertoy.com/view/llXfRr", "tags": ["fractal", "raymarch", "cineshader"], "likes": 3, "viewed": 602, "published": 3, "date": "1702624639", "time_retrieved": "2024-07-30T17:16:31.997103", "image_code": "#define MAXDIST 50.\n\nstruct Ray {\n\tvec3 ro;\n    vec3 rd;\n};\n  \n// from netgrind\nvec3 hue(vec3 color, float shift) {\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI     = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ     = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR   = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG   = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB   = vec3 (1.0, -1.107, 1.704);\n\n    // Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    // Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    // Make the user's adjustments\n    hue += shift;\n\n    // Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    // Convert back to RGB\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\n\n// ------\n\n// by iq\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat length6( vec3 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y + p.z, 1.0/6.0 );\n}\n\n// ------\n\n// from hg_sdf \n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// -------\n\n\nfloat fractal(vec3 p)\n{\n    const int iterations = 20;\n\t\n    float d = iTime*1. - p.z;\n   \tp=p.yxz;\n    pR(p.yz, 1.570795);\n    p.x += 6.5;\n\n    p.yz = mod(abs(p.yz)-.0, 20.) - 10.;\n    float scale = 1.25;\n    \n    p.xy /= (1.+d*d*0.0005);\n    \n\tfloat l = 0.;\n\t\n    for (int i=0; i<iterations; i++) {\n\t\tp.xy = abs(p.xy);\n\t\tp = p*scale + vec3(-3. + d*0.0095,-1.5,-.5);\n        \n\t\tpR(p.xy,0.35-d*0.015);\n\t\tpR(p.yz,0.5+d*0.02);\n\t\t\n        l =length6(p);\n\t}\n\treturn l*pow(scale, -float(iterations))-.15;\n}\n\nvec2 map(vec3 pos) \n{\n    float dist = 10.; \n    dist = opU(dist, fractal(pos));\n    dist = smin(dist, fPlane(pos,vec3(0.0,1.0,0.0),10.), 4.6);\n    return vec2(dist, 0.);\n}\n\nvec3 vmarch(Ray ray, float dist)\n{   \n    vec3 p = ray.ro;\n    vec2 r = vec2(0.);\n    vec3 sum = vec3(0);\n    vec3 c = hue(vec3(0.,0.,1.),5.5);\n    for( int i=0; i<20; i++ )\n    {\n        r = map(p);\n        if (r.x > .01) break;\n        p += ray.rd*.015;\n        vec3 col = c;\n        col.rgb *= smoothstep(.0,0.15,-r.x);\n        sum += abs(col)*.5;\n    }\n    return sum;\n}\n\nvec2 march(Ray ray) \n{\n    const int steps = 50;\n    const float prec = 0.001;\n    vec2 res = vec2(0.);\n    \n    for (int i = 0; i < steps; i++) \n    {        \n        vec2 s = map(ray.ro + ray.rd * res.x);\n        \n        if (res.x > MAXDIST || s.x < prec) \n        {\n        \tbreak;    \n        }\n        \n        res.x += s.x;\n        res.y = s.y;\n        \n    }\n   \n    return res;\n}\n\nvec3 calcNormal(vec3 pos) \n{\n\tconst vec3 eps = vec3(0.005, 0.0, 0.0);\n                          \n    return normalize(\n        vec3(map(pos + eps).x - map(pos - eps).x,\n             map(pos + eps.yxz).x - map(pos - eps.yxz).x,\n             map(pos + eps.yzx).x - map(pos - eps.yzx).x ) \n    );\n}\n\nvec4 render(Ray ray) \n{\n    vec3 col = vec3(0.);\n\tvec2 res = march(ray);\n   \n    if (res.x > MAXDIST) \n    {\n        return vec4(col, 50.);\n    }\n    \n    vec3 pos = ray.ro+res.x*ray.rd;\n    ray.ro = pos;\n   \tcol = vmarch(ray, res.x);\n    \n    col = mix(col, vec3(0.), clamp(res.x/50., 0., 1.));\n   \treturn vec4(col, res.x);\n}\n\nmat3 camera(in vec3 ro, in vec3 rd, float rot) \n{\n\tvec3 forward = normalize(rd - ro);\n    vec3 worldUp = vec3(sin(rot), cos(rot), 0.0);\n    vec3 x = normalize(cross(forward, worldUp));\n    vec3 y = normalize(cross(x, forward));\n    return mat3(x, y, forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.y -= uv.x*uv.x*0.15;\n    vec3 camPos = vec3(3., -1.5, iTime*1.);\n    vec3 camDir = camPos+vec3(-1.25,0.1, 1.);\n    mat3 cam = camera(camPos, camDir, 0.);\n    vec3 rayDir = cam * normalize( vec3(uv, .8));\n    \n    Ray ray;\n    ray.ro = camPos;\n    ray.rd = rayDir;\n    \n    vec4 col = render(ray);\n    \n\tfragColor = vec4(1.-col.xyz,clamp(1.-col.w/MAXDIST, 0., 1.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlyfWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 80, 115, 115, 1064], [1087, 1087, 1120, 1120, 1145], [1147, 1147, 1187, 1187, 1280], [1282, 1282, 1307, 1307, 1371], [1401, 1401, 1457, 1457, 1499], [1501, 1501, 1533, 1533, 1575], [1590, 1590, 1613, 1613, 2091], [2093, 2093, 2114, 2114, 2265], [2267, 2267, 2301, 2301, 2641], [2643, 2643, 2665, 2665, 3031], [3033, 3033, 3061, 3061, 3328], [3330, 3330, 3353, 3353, 3656], [3658, 3658, 3707, 3707, 3919], [3921, 3921, 3978, 3978, 4462]], "test": "untested"}
{"id": "ctGBDz", "name": "how to make your eyes bleed", "author": "NikoAnimation", "description": "mandel brot set edition\n\nfloating point precision kinda fucks this up", "tags": ["mandelbrot"], "likes": 4, "viewed": 185, "published": 3, "date": "1702588442", "time_retrieved": "2024-07-30T17:16:32.770036", "image_code": "int iterations = 5000;\nfloat threshold = 1000.0;\nfloat baseScale = 5.0;\nvec2 centerPos = vec2(-1.5013347, 0.0009049);\nfloat colourConstant = 10.0;\n\nvec3 get_col(float iter) {\n    vec3 col;\n\n    float val = mod(iter, colourConstant)/colourConstant;\n    int val2 = int(floor(mod(iter, colourConstant*3.0)/colourConstant));\n    switch (val2) {\n        case 0: col = vec3(val, 0.0, 1.2-val); break;\n        case 1: col = vec3(1.2-val, val, 0.0); break;\n        case 2: col = vec3(0.0, 1.2-val, val); break;\n    }\n    \n    return col;\n}\n\nvec3 get_mandelbrot(vec2 c) {\n    vec2 z = c;\n    bool check = true;\n    float iter = 0.0;\n    for(int i; i<iterations; i++) {\n        vec2 m = z;\n        m.x = (z.x * z.x) - (z.y * z.y) + c.x;\n        m.y = 2.0 * z.x * z.y + c.y;\n        z = m;\n        if (abs(z.x) > float(threshold) || abs(z.y) > float(threshold)) {\n            check = false;\n            break;\n        } iter = float(i);\n    }\n    \n    vec3 col;\n    if (check) {\n        col = vec3(0.0, 0.0, 0.0);\n    } else {\n        col = get_col(iter);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime+6.0;\n    float scale = baseScale / pow(t/10.0, t);\n    vec2 uv = (fragCoord/iResolution.xy*scale)-(scale/2.0) + centerPos;\n    uv.y /= iResolution.x / iResolution.y;\n    vec3 col = get_mandelbrot(uv);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctGBDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 174, 174, 531], [533, 533, 562, 562, 1073], [1075, 1075, 1132, 1132, 1387]], "test": "untested"}
{"id": "cd2BR3", "name": "Tyler macht mandelbrot", "author": "Falafel", "description": "mandelbrot, coole stelle", "tags": ["mandelbrot"], "likes": 2, "viewed": 173, "published": 3, "date": "1702570003", "time_retrieved": "2024-07-30T17:16:33.600815", "image_code": "\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 misiurewicz_point = vec2(-0.34852764148007233, -0.6065922085831237) * iTime;\n    vec2 uv = ((fragCoord * 2.0 - iResolution.xy) / iResolution.y / (pow(0.1*iTime, 8.)) + misiurewicz_point / iTime);\n\n    vec2 z = uv;\n    \n    vec3 finalColor = vec3(0.,0.,0.);\n    \n    float iter = 0.;\n    for (int i=0; i<1500; i++) {\n        float len = length(z);\n        iter += .01;\n        // (a + ib) (c + id) = (ac - bd) + i(ad + bc)\n        z = vec2( uv.x + z.x*z.x - z.y*z.y, uv.y + z.x*z.y + z.x*z.y);\n        if (len > 2048.) {\n            finalColor = palette(iter);\n            break;\n        }\n        if (len < .01) {\n            finalColor = palette(iter);\n            break;\n        }\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2BR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 26, 26, 210], [213, 213, 270, 270, 1019]], "test": "untested"}
{"id": "DtVBWc", "name": "Old TV horizontal stripes", "author": "Kampfhund", "description": "Creates random thin white stripes, similar to how they might appear in historical footage.\n\nThe frequency of these stripes can be adjusted in the code.", "tags": ["tv", "effect", "old", "stripes"], "likes": 1, "viewed": 198, "published": 3, "date": "1702569446", "time_retrieved": "2024-07-30T17:16:34.354799", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //If speed is 1, noise will be sampled at the same coordinate every frame.\n    float speed = 10.0;\n    //A frequency of 1 will cause the effect to barely ever appear.\n    //A frequency of 0 will cause the effect to always appear\n    float frequency = 0.85;\n    \n    \n    \n    \n    vec4 noise = texture(iChannel0, vec2(sin(iTime - (speed * iTime)), sin(iTime - (speed * iTime))));\n    vec4 tex = texture(iChannel1, uv);\n    \n    \n    vec4 col = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    //Left condition serves as a clamp to reduce the frequency of the stripes\n    //Right condition serves to reduce the effect to only a small amount of y coordinates (with a somewhat random heigth).\n    if(noise.r >= frequency && abs(uv.y - abs(sin(iTime - (10.0 * iTime)))) <= abs(sin(noise.r * iTime)) * 0.005)\n    {\n      //Changes the intensity of the effect based on the x coordinate\n      //The math is somewhat randomly put together, just thought it looked decent\n      float randomizer = abs(sin(uv.x * noise.r + iTime) / 3.0);\n      \n      col = vec4(randomizer, randomizer, randomizer, 1.0); \n    }\n\n    \n    fragColor = tex + col;\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtVBWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1277]], "test": "untested"}
{"id": "mtGBW3", "name": "Aegishjalmur (280 chars)", "author": "FabriceNeyret2", "description": "references:\nhttps://shorturl.at/aknt9\nhttps://www.google.com/search?q=Aegishjalmur&tbm=isch\nAegishjalmur is an Icelandic magical stave. Used to protect warriors and instill fear in enemies. \n", "tags": ["2d", "2tweets", "short", "symbol", "golf", "reproduction", "rune", "ciking"], "likes": 19, "viewed": 267, "published": 3, "date": "1702547331", "time_retrieved": "2024-07-30T17:16:35.113770", "image_code": "/**/ // --- 291 chars    see golfed version below\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y;\n    float a = .393,                   // 2pi/16\n          l = length(U); \n    U = l * abs(cos( mod( atan(U.y,U.x)+a, a+a ) -a + vec2(0,11) )); // radial symmetry + mirror\n    a = min( min( U.y,                                               // rays\n                  abs(l-.2) ),                                       // central disk\n             min( abs(length(U-vec2(.8,0)) -.1),                     // outer C\n                  U.y < .1 && abs(U.x-.5) < .15                      // 3 strips\n                    ? abs( mod(U.x+.05,.1) - .05 ) : 9. \n           )    );\n    O = vec4( l < .8 ? R.y/3.*(a-.01) : 1. ) ;                       // AA draw\n}\n\n\n\n\n\n/**  // --- 280 chars -4 Greg\n\n #define L length\n \nvoid mainImage( out vec4 O, vec2 U )\n{\n    float a = .393,\n          l = L( U = ( U+U - (O.xy=iResolution.xy) ) / O.y ); \n    U = l * abs(cos( mod( atan(U.y,U.x)+a, a+a ) -a + vec2(0,11) ));\n    U.x -= .8;\n    O = O.yyyy/3.*( l < .8 \n                       ?  min( min( U.y, L(l-.2) ), \n                               min( L(L(U) -.1), U.y < .1 && L(U.x+.3) < .15 ? L( mod(U.x+.05,.1) - .05 ) : 9. \n                             )    )\n                          -.01 : 1. ) ;\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtGBW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 89, 89, 804]], "test": "untested"}
{"id": "mlGBW3", "name": "Train Ride with Tunnels", "author": "dr2", "description": "Special dedication to Fabrice Champollion III: may the AI be with you.", "tags": ["landscape", "train", "golf"], "likes": 14, "viewed": 352, "published": 3, "date": "1702546910", "time_retrieved": "2024-07-30T17:16:36.081184", "image_code": "#define YS min(FX,0)\n#define La(Yc)if(TU<Jp){LM=Yc;Jp=TU;}\n#define ML(Yc)if(TU<Jp){LM=Yc;BT=Ai;Jp=TU;}\nconst int Iq=1,XL=2,Wa=3,SE=4,EU=5,Up=6,Kb=7,QT=8,By=9,Dj=10,Zw=11,GF=12,ZN=13;const float KN=3.1415927,Bl=1.7320508;const int Oj=17,Em=4,Le=3;vec4 EQ[Em],HV[Oj],QX;vec3 BT,JO,VN;vec2 Ul,Zs,Pe,XH,MC;float TD,OV,QG[Oj+1],Uc,SV,Rk,Gb,GB,ON,CF,AU,Zj,Fh,KR,Lr;int FX,LM,ED;float WM(vec3 Ck,vec3 Yg,float Ha){return length(max(abs(Ck)-Yg,0.))-Ha;}float Vb(vec2 Ck,vec2 Yg,float Ha){return length(max(abs(Ck)-Yg,0.))-Ha;}float Yx(vec3 Ck,float Fp){return length(Ck)-Fp;}float Tq(vec3 Ck,float Fp,float GW){return max(length(Ck.xy)-Fp,abs(Ck.z)-GW);}float RF(vec3 Ck,vec2 JG,float Fp,float GW){float TU;TU=max(dot(vec2(length(Ck.xy)-Fp,Ck.z),JG),abs(Ck.z)-GW);GW/=JG.x*JG.x;Fp/=JG.x;TU=min(TU,min(length(vec3(Ck.xy,Ck.z+Fp*JG.y-GW))-Fp+GW*JG.y,length(vec3(Ck.xy,Ck.z+Fp*JG.y+GW))-Fp-GW*JG.y));return TU;}vec2 My(vec2 Ck){vec3 Wn,NS,Qh;Wn.xz=vec2((1./Bl)*Ck.x-(1./3.)*Ck.y,(2./3.)*Ck.y);Wn.y=-Wn.x-Wn.z;NS=floor(Wn+0.5);Qh=abs(NS-Wn);NS-=step(Qh.yzx,Qh)*step(Qh.zxy,Qh)*dot(NS,vec3(1.));return NS.xz;}vec2 Pz(vec2 GW){return vec2(Bl*(GW.x+0.5*GW.y),(3./2.)*GW.y);}float NO(vec2 Ck){Ck=abs(Ck);return(Bl/2.)-Ck.x+0.5*min(Ck.x-Bl*Ck.y,0.);}float Gs(float Nk){return(Nk!=0.)?sign(Nk):1.;}float OR(vec2 Ck){return min(Ck.x,Ck.y);}float Lv(vec2 Ck){return max(Ck.x,Ck.y);}float Ng(vec3 Ck){return max(Ck.x,max(Ck.y,Ck.z));}float QC(vec3 Ck){return min(Ck.x,min(Ck.y,Ck.z));}float Pm(float TL,float Vw,float Fp){float GW;GW=clamp(0.5+0.5*(Vw-TL)/Fp,0.,1.);return mix(Vw-GW*Fp,TL,GW);}float NB(float TL,float Vw,float Fp){return-Pm(-TL,-Vw,Fp);}float LQ(float JK,float UG,float Yg,float Nk){return(1.-smoothstep(UG-Yg,UG+Yg,Nk))*smoothstep(JK-Yg,JK+Yg,Nk);}mat3 Id(float Hn,float LZ){vec2 Az,XY,ZR;Az=vec2(Hn,LZ);XY=cos(Az);ZR=sin(Az);return mat3(XY.y,0.,-ZR.y,0.,1.,0.,ZR.y,0.,XY.y)*mat3(1.,0.,0.,0.,XY.x,-ZR.x,0.,ZR.x,XY.x);}vec2 SZ(vec2 Ai,float BL){vec2 JG;JG=sin(BL+vec2(0.5*KN,0.));return vec2(dot(Ai,vec2(JG.x,-JG.y)),dot(Ai.yx,JG));}vec2 Ro(vec2 Ai,vec2 JG){return vec2(dot(Ai,vec2(JG.x,-JG.y)),dot(Ai.yx,JG));}const float JX=43758.54;float IH(vec2 Ck){return fract(sin(mod(dot(Ck,vec2(37.,39.)),2.*KN))*JX);}vec2 Ks(vec2 Ck){vec2 LI=vec2(37.,39.);return fract(sin(mod(dot(Ck,LI)+vec2(0.,LI.x),2.*KN))*JX);}vec4 Md(vec3 Ck){vec3 Nt=vec3(37.,39.,41.);return fract(sin(mod(dot(Ck,Nt)+vec4(0.,Nt.xy,Nt.x+Nt.y),2.*KN))*JX);}float HI(vec2 Ck){vec2 Nk,Bh,UX;Bh=floor(Ck);UX=fract(Ck);UX=UX*UX*(3.-2.*UX);Nk=mix(Ks(Bh),Ks(Bh+vec2(0.,1.)),UX.y);return mix(Nk.x,Nk.y,UX.x);}float Jt(vec3 Ck){vec4 Nk;vec3 Bh,UX;Bh=floor(Ck);UX=fract(Ck);UX*=UX*(3.-2.*UX);Nk=mix(Md(Bh),Md(Bh+vec3(0.,0.,1.)),UX.z);return mix(mix(Nk.x,Nk.y,UX.x),mix(Nk.z,Nk.w,UX.x),UX.y);}float PQ(vec2 Ck){float Of,BL;Of=0.;BL=1.;for(int Go=0;Go<5;Go++){Of+=BL*HI(Ck);BL*=0.5;Ck*=2.;}return Of*(1./1.9375);}float RB(vec3 Ck){float Of,BL;Of=0.;BL=1.;for(int Go=0;Go<5;Go++){Of+=BL*Jt(Ck);BL*=0.5;Ck*=2.;}return Of*(1./1.9375);}float Tm(vec3 Ck,vec3 Zf){vec3 Yg;float BL;Yg=vec3(0.);BL=1.;for(int Go=0;Go<5;Go++){Yg+=BL*vec3(HI(Ck.yz),HI(Ck.zx),HI(Ck.xy));BL*=0.5;Ck*=2.;}return dot(Yg,abs(Zf));}vec3 Xh(vec3 Ck,vec3 Zf,float Of){vec4 Sa;vec3 GW;vec2 DR=vec2(0.1,0.);for(int Go=YS;Go<=3;Go++)Sa[Go]=Tm(Ck+((Go<2)?((Go==0)?DR.xyy:DR.yxy):((Go==2)?DR.yyx:DR.yyy)),Zf);GW=Sa.xyz-Sa.w;return normalize(Zf+Of*(GW-Zf*dot(Zf,GW)));}float DA(vec2 Ck){float Of,GS,ID;Ck*=0.25;Of=0.;GS=1.;ID=0.;for(int Go=0;Go<3;Go++){Of+=GS*HI(Ck);ID+=GS;GS*=0.4;Ck*=2.5;}return 3.5*Of/ID;}float Cx(vec2 Ck){return dot(Ck,Ck);}vec3 Eq(vec2 Ck){vec2 Hr,Jc,FG,Ow;float VF,Xq,TU,Qy,Fp,Dw,Yg,EH;int Nc;Nc=(ON==2.||ON==4.)?1:0;if(Nc>0){Hr=-vec2(0.,GB);Jc=vec2(Bl/2.*Gs(Ck.x),0.5*GB);VF=Cx(Ck-Hr);Xq=Cx(Ck-Jc);TU=min(VF,Xq);FG=(TU==VF)?Hr:Jc;Fp=0.5;TU=abs(sqrt(TU)-Fp);}else{if(GB!=0.)Ck=0.5*vec2(Ck.x-GB*Bl*Ck.y,GB*Bl*Ck.x+Ck.y);Hr=vec2(Bl/2.*Gs(Ck.x),0.);Jc=vec2(Bl*Gs(Ck.x),0.);VF=sqrt(Cx(Ck-Hr));Xq=abs(sqrt(Cx(Ck-Jc))-1.5);TU=min(VF,Xq);FG=(TU==VF)?Hr:Jc;Fp=(TU==VF)?0.:1.5;}Ow=Ck-FG;Qy=Pe.x-Pe.y;Yg=(Nc>0&&Qy<0.||Nc==0&&abs(Qy-2.)==1.)?-1.:1.;Dw=(0.5-atan(Ow.y,-Ow.x)/(2.*KN))*Yg;if(Nc==0&&abs(Qy-2.)<=1.)Dw+=1./6.;EH=Gs(length(Ow)-Fp);return vec3(TU*EH,Fp*EH*Yg,Dw);}int YO(vec2 w){vec2 PY,On;float Qy;bool Sj,Vs;Qy=Pe.x-Pe.y;Sj=(mod(Pe.y,2.)==1.);On=Ro(w,sin(-KN/3.+vec2(0.5*KN,0.)))-vec2(0.,0.3);PY=Ro(w,sin(KN/3.+vec2(0.5*KN,0.)));Vs=(Qy==-2.&&On.y>0.||!Sj&&(Qy==-3.&&w.y>-0.3||Qy==-2.||Qy==-1.&&On.y>0.||Qy==1.&&On.y<0.||(Qy==2.||Qy==3.)&&w.x<0.||Qy==4.||Qy==5.)||Sj&&(Qy==-3.||Qy==0.&&PY.x>0.||(Qy==1.||Qy==2.)&&w.x>0.||Qy==3.||Qy==4.&&On.x<0.||Qy==5.&&On.y<0.));return Vs?0:1;}float Pv(vec3 Ck){vec3 Ai,VW;float Jp,TU,Cg,Fp,Dw,BP,Ei,Yg;int Xd;Jp=TD;if(ON>0.){Ai=Ck;Ai.xz=(Ai.xz-XH)/Rk;Ei=Rk*NO(Ai.xz);VW=Eq(Ai.xz);Cg=Rk*abs(VW.x);Fp=abs(VW.y);Dw=18.*VW.z;Xd=(ON<=2.&&Fp!=0.&&YO(Ai.xz)>0)?1:0;TU=Ai.y-KR;La(XL);BP=DA(Ck.xz);TU=0.9*(Ai.y-BP);if(Xd>0){TU=0.8*NB(TU,-max(length(vec2(Cg,min(0.,Zj+0.05-Ai.y+0.1)))-AU,Zj-0.05-Ai.y),0.1);}La(Iq);if(Xd>0){TU=max(max(abs(Cg)-AU,Ai.y-Zj),-(length(vec2(abs(fract(9.*Fp*Dw+0.5)-0.5)/3.,Ai.y)-vec2(0.,min(Ai.y,Zj-0.3)))-0.12));La(Wa);TU=Vb(vec2(Cg-MC.x*CF,Ai.y-Zj-0.01),vec2(0.005,0.01),0.003);La(SE);TU=WM(vec3(Cg-MC.x*CF,Ai.y-Zj,(fract(36.*Fp*Dw+0.5)-0.5)/3.),vec3(0.015,0.005,0.002),0.001);La(SE);TU=min(length(vec2(Cg-AU+0.05,Ai.y-Zj-0.12))-0.008,max(Vb(vec2(Cg-AU+0.05,(fract(9.*Fp*Dw+0.5)-0.5)/3.),vec2(0.007,0.001),0.001),abs(Ai.y-Zj-0.06)-0.06));La(EU);if(VW.y<0.&&BP<Zj){Ai=vec3(Cg-0.22,Ai.y-Zj-0.4,Ei);Yg=length(Ai.xz);TU=min(max(Yg-0.012,abs(Ai.y+0.2)-0.2),max(Yg-0.022,abs(Ai.y+0.015)-0.016));La(QT);}}}return Jp;}void NK(){float GW,Qy;XH=Pz(Pe*Rk);GW=IH(Pe);if(IH(17.11*Pe)>0.4){GB=floor(3.*GW)-1.;ON=3.;}else{GB=2.*floor(2.*GW)-1.;ON=4.;}Qy=Pe.x-Pe.y;if(Qy==0.)ON=1.;else if(abs(Qy)==1.)ON=mod(Pe.x,2.)+1.;else if(Qy==-2.||Qy==-3.||Qy==5.)ON=2.;else if(Qy==2.||Qy==3.||Qy==4.)ON=1.;if(ON<=2.){if(ON==1.&&(Qy==1.||Qy==2.||Qy==3.))GB=0.;else if(ON==1.&&Qy==4.)GB=-1.;else if(ON==2.&&Qy==5.)GB=1.;else GB=2.*mod(Pe.x,2.)-1.;}}\nfloat SR(vec3 PD,vec3 Ha){vec3 Co,Wr,FK;vec2 FC[3],PU;float FT,TU,Yg,IY,KJ;int Bd;if(Ha.x==0.)Ha.x=1e-4;if(Ha.z==0.)Ha.z=1e-4;IY=5e-4;FC[0]=vec2(1.,0.);FC[1]=0.5*vec2(1.,Bl);FC[2]=0.5*vec2(1.,-Bl);for(int HZ=0;HZ<3;HZ++)FC[HZ]*=Gs(dot(FC[HZ],Ha.xz));FK=Rk/vec3(dot(Ha.xz,FC[0]),dot(Ha.xz,FC[1]),dot(Ha.xz,FC[2]));Co=0.5*Bl-vec3(dot(PD.xz,FC[0]),dot(PD.xz,FC[1]),dot(PD.xz,FC[2]))/Rk;FT=0.;Pe=My(PD.xz/Rk);PU=Pz(Pe);Bd=1;for(int Go=YS;Go<320;Go++){KJ=IY*(1.+Fh*FT);if(Bd>0){Wr=(Co+vec3(dot(PU,FC[0]),dot(PU,FC[1]),dot(PU,FC[2])))*FK;Yg=QC(Wr);NK();Bd=0;}TU=Pv(PD+FT*Ha);if(FT+TU<Yg){FT+=TU;}else{FT=Yg+KJ;Pe=My((PD.xz+FT*Ha.xz)/Rk);PU+=Bl*((Yg==Wr.x)?FC[0]:((Yg==Wr.y)?FC[1]:FC[2]));Bd=1;}if(TU<KJ||FT>TD)break;}if(TU>=KJ)FT=TD;return FT;}vec3 Rg(vec3 Ck){vec4 Sa;vec2 DR;DR=5e-4*vec2(1.,-1.);for(int Go=YS;Go<=3;Go++){Sa[Go]=Pv(Ck+((Go<2)?((Go==0)?DR.xxx:DR.xyy):((Go==2)?DR.yxy:DR.yyx)));}Sa.x=-Sa.x;return normalize(2.*Sa.yzw-dot(Sa,vec4(1.)));}float UC(vec3 PD,vec3 Ha){vec3 Ck;vec2 SA;float GJ,TU,GW;GJ=1.;TU=0.02;SA=vec2(-999.);for(int Go=YS;Go<30;Go++){Ck=PD+TU*Ha;Pe=My(Ck.xz/Rk);if(Pe!=SA){SA=Pe;NK();}GW=Pv(Ck);GJ=min(GJ,smoothstep(0.,0.05*TU,GW));TU+=max(GW,0.01);if(GJ<0.05||TU>Rk)break;}return 0.5+0.5*GJ;}void Dn(){vec2 GW;Zs=Pz(Ul*SV);GW=Ks(73.*Ul+1.1);VN=vec3(0.2*Bl*SV*(0.5+0.5*GW.x)*sin(2.*KN*GW.y+vec2(0.5*KN,0.)),GW.x+GW.y).xzy;}void BC(vec2 QP,vec2 Li){Pe=QP;NK();Lr=(Rk*abs(Eq((Li-XH)/Rk).x)<0.9||DA(Zs)<KR+0.1)?0.:0.01+0.99*IH(17.11*Ul);}float Ut(vec3 Ck){vec3 Ai;float Jp,TU,GW;Jp=TD;if(Lr>0.){Ai=Ck;Ai.xz=(Ai.xz-Zs)/SV;Ai.xz-=VN.xz;GW=0.15+0.15*VN.y;Ai.y-=GW+DA(Zs);TU=max(length(Ai.xz)-0.05,Ai.y-GW);La(Up);if(Lv(VN.xz)>0.){Ai.y-=GW+0.55;TU=RF(Ai.xzy,sin(0.085*KN+vec2(0.5*KN,0.)),0.18,0.4);}else{Ai.y-=GW+0.25;TU=Pm(Yx(Ai,0.25),Yx(vec3(Ai.x,abs(Ai.y)-0.25,Ai.z),0.17),0.2);}La(Kb);}return Jp;}float XP(vec3 PD,vec3 Ha){vec3 FK,Co,Wr;vec2 FC[3],PU,Li,QP;float FT,TU,Yg,IY;int Bd;if(Ha.x==0.)Ha.x=1e-4;if(Ha.z==0.)Ha.z=1e-4;IY=5e-4;FC[0]=vec2(1.,0.);FC[1]=0.5*vec2(1.,Bl);FC[2]=0.5*vec2(1.,-Bl);for(int HZ=0;HZ<3;HZ++)FC[HZ]*=Gs(dot(FC[HZ],Ha.xz));FK=SV/vec3(dot(Ha.xz,FC[0]),dot(Ha.xz,FC[1]),dot(Ha.xz,FC[2]));Co=0.5*Bl-vec3(dot(PD.xz,FC[0]),dot(PD.xz,FC[1]),dot(PD.xz,FC[2]))/SV;FT=0.;Ul=My(PD.xz/SV);PU=Pz(Ul);Bd=1;for(int Go=YS;Go<220;Go++){if(Bd>0){Wr=(Co+vec3(dot(PU,FC[0]),dot(PU,FC[1]),dot(PU,FC[2])))*FK;Yg=QC(Wr);Dn();}Li=Zs+VN.xz;QP=My(Li/Rk);if(Bd>0||Pe!=QP)BC(QP,Li);Bd=0;TU=Ut(PD+FT*Ha);if(FT+TU<Yg){FT+=TU;}else{FT=Yg+IY;Ul=My((PD.xz+FT*Ha.xz)/SV);PU+=Bl*((Yg==Wr.x)?FC[0]:((Yg==Wr.y)?FC[1]:FC[2]));Bd=1;}if(TU<IY||FT>TD)break;}if(TU>=IY)FT=TD;return FT;}vec3 We(vec3 Ck){vec4 Sa;vec2 DR;DR=1e-3*vec2(1.,-1.);for(int Go=YS;Go<=3;Go++){Sa[Go]=Ut(Ck+((Go<2)?((Go==0)?DR.xxx:DR.xyy):((Go==2)?DR.yxy:DR.yyx)));}Sa.x=-Sa.x;return normalize(2.*Sa.yzw-dot(Sa,vec4(1.)));}float ZA(vec3 PD,vec3 Ha){vec3 Ck;vec2 SA,Li;float GJ,TU,GW;GJ=1.;TU=0.02;SA=vec2(-999.);for(int Go=YS;Go<30;Go++){Ck=PD+TU*Ha;Ul=My(Ck.xz/SV);if(Ul!=SA){SA=Ul;Dn();}Li=Zs+VN.xz;BC(My(Li/Rk),Li);if(Lr>0.){GW=Ut(Ck);GJ=min(GJ,smoothstep(0.,0.1*TU,GW));TU+=GW;}else TU+=0.1*SV;if(GJ<0.05||TU>2.*SV)break;}return 0.5+0.5*GJ;}float Df(vec3 Ck,float Jp,float HE){vec3 Ai,DE;float TU,Yg,RS;Ai=Ck;Ai.xz=abs(Ai.xz);Ai.z=abs(Ai.z-MC.y);Ai-=vec3(MC.x,-0.6,0.2);TU=Tq(Ai.yzx,0.15,0.08);ML(Zw);Ai=Ck;DE=Ai;Yg=0.25;if(Ai.z*HE>0.5){RS=-0.25*(Ai.z*HE-0.5);Yg+=RS;DE.y-=RS;}TU=0.9*WM(DE,vec3(0.27,Yg,1.55),0.4);ML(By);Ai=Ck;Ai.z=(HE==0.)?abs(Ai.z)-1.8:Ai.z+1.8*HE;TU=Tq(Ai.xzy,0.3,0.5);ML(Dj);if(HE>0.){Ai=Ck;Ai.yz-=vec2(-0.25,1.9);TU=Tq(Ai,0.1,0.1);ML(GF);}else if(HE<0.){Ai=Ck;Ai.x=abs(Ai.x)-0.18;Ai.yz-=vec2(-0.25,-1.9);TU=Tq(Ai,0.08,0.1);ML(ZN);}return Jp;}float OA(vec3 Ck){vec3 Ai;float Jp;Jp=TD/CF;for(int HZ=YS;HZ<Em;HZ++){Ai=(Ck-EQ[HZ].xyz)/CF;Ai.xz=Ro(Ai.xz,sin(EQ[HZ].w+vec2(0.5*KN,0.)));Jp=Df(Ai,Jp,(HZ>0)?((HZ<Em-1)?0.:-1.):1.);}return Jp*CF;}float RW(vec3 PD,vec3 Ha){float FT,TU;FT=0.;for(int Go=YS;Go<160;Go++){TU=OA(PD+FT*Ha);FT+=TU;if(TU<0.0005||FT>TD)break;}return FT;}vec3 Ql(vec3 Ck){vec4 Sa;vec2 DR;DR=1e-3*vec2(1.,-1.);for(int Go=YS;Go<=3;Go++){Sa[Go]=OA(Ck+((Go<2)?((Go==0)?DR.xxx:DR.xyy):((Go==2)?DR.yxy:DR.yyx)));}Sa.x=-Sa.x;return normalize(2.*Sa.yzw-dot(Sa,vec4(1.)));}float TH(vec3 PD,vec3 Ha){float GJ,TU,GW;GJ=1.;TU=0.02;for(int Go=YS;Go<30;Go++){GW=OA(PD+TU*Ha);GJ=min(GJ,smoothstep(0.,0.05*TU,GW));TU+=max(GW,0.01);if(GJ<0.05||TU>TD)break;}return 0.5+0.5*GJ;}vec3 Kf(vec3 Ha){Ha.y=abs(Ha.y);return mix(vec3(0.3,0.35,0.7),vec3(0.8,0.8,0.8),clamp(2.*(PQ(4.*Ha.xz/Ha.y+0.1*OV)-0.1)*Ha.y,0.,1.));}\nvec4 Fl(vec3 Ck,vec3 DZ,inout vec2 Co){vec4 Ez;vec3 VW;vec2 w;float Cg,Fp,GW,Ae;int Xd,SI;SI=(ED>0&&DZ.y>0.1)?1:0;w=(Ck.xz-XH)/Rk;VW=Eq(w);Cg=Rk*abs(VW.x);Fp=abs(VW.y);Ae=DA(Ck.xz);if(LM==Wa){Ez=vec4(0.6,0.4,0.1,0.1);if(Ck.y>Zj-0.05&&Cg<AU-0.02){Ez=mix(Ez,vec4(0.5,0.5,0.4,0.)*(0.9+0.1*PQ(8.*Ck.xz)),step(0.,AU-0.02-Cg));if(Cg<0.12&&step(0.45,abs(fract(648.*Fp*abs(VW.z))-0.5))>0.)Ez=vec4(0.4,0.4,0.3,0.);}else Ez*=0.8+0.2*step(0.05,abs(fract(32.*Ck.y+0.5)-0.5));if(SI>0&&Cg<AU-0.001){if(Ck.y>Zj-0.05)Ez=mix(QX,Ez,smoothstep(0.4,0.5,Ae-Zj));else Ez=QX;}Co=(SI>0)?vec2(4.,0.5):vec2(32.,0.3);}else if(LM==Iq){Ez=(SI>0)?QX:vec4(0.,0.7,0.,0.)*(0.6+0.4*PQ(4.*Ck.xz));Xd=(ON<=2.&&Fp!=0.&&YO(w)>0)?1:0;if(Xd>0){Ez=mix((SI>0)?QX:vec4(0.5,0.55,0.5,0.)*(0.98+0.02*sin(128.*KN*(Ck.y-2.*PQ(0.25*Ck.xz)))),Ez,smoothstep(0.5,0.8,DZ.y));GW=Ae-Ck.y;if(Cg<AU+0.01){if(GW>0.3&&Ck.y<Zj+0.12)Ez.rgb=vec3(0.5,0.3,0.);if(GW>0.)Ez*=1.-0.3*smoothstep(0.,0.1,GW);}}if(Lr>0.&&length((Ck.xz-Zs)/SV-VN.xz)<0.06)Ez*=0.8;Co=vec2(2.,1.);}return Ez;}vec4 Bu(){vec4 Ez;Ez=(BT.y>0.)?vec4(0.9,0.,0.,0.3):vec4(0.,0.,0.9,0.3);if(LM==By){Ez=(abs(BT.y-0.22)<0.26)?vec4(0.3,0.3,0.5,0.3):((abs(abs(BT.y-0.22)-0.28)<0.02)?vec4(0.4,0.4,0.8,0.3):Ez);}else if(LM==Dj){Ez*=0.8;}else if(LM==Zw){Ez=(length(BT.yz)<0.07)?vec4(0.2,0.2,0.2,0.1):vec4(0.6,0.6,0.6,0.2);}else if(LM==GF){if(BT.z>0.08)Ez=vec4(1.,1.,0.,-1.);}else if(LM==ZN){if(BT.z<-0.08)Ez=vec4(1.,0.,0.,-1.);}return Ez;}vec4 MP(vec3 PD,vec3 DZ,inout vec2 Co){vec4 Ez;if(LM==Iq||LM==Wa){Ez=Fl(PD,DZ,Co);}else if(LM==XL){Ez=vec4(0.6,0.6,0.7,0.);}else if(LM==Up){Ez=vec4(0.5,0.3,0.1,0.1);Co=vec2(32.,1.);}else if(LM==Kb){Ez=vec4(0.3,0.6*min(1.,(1.2-0.4*Lr)),0.1,0.);if(ED>0)Ez=mix(Ez,QX,smoothstep(-0.8,-0.4,DZ.y));else Ez=mix(Ez,vec4(0.9,0.9,0.,0.1),step(0.7,RB(64.*PD.xzy)));Co=vec2(16.,2.);}else if(LM==EU){Ez=vec4(0.8,0.8,0.9,0.2);}else if(LM==QT){Ez=(PD.y<Zj+0.37)?vec4(0.8,0.8,0.9,0.2):vec4(1.,1.,0.4,-1.);}else if(LM==SE){Ez=vec4(0.7,0.7,0.75,0.1);}else if(LM>=By&&LM<=ZN){Ez=Bu();}return Ez;}void EY(){float HM,Sr;HM=1.;Sr=1.5;HV[0]=vec4(0.,0.,-1./6.,Sr);HV[1]=vec4(1.,0.,1./3.,-HM);HV[2]=vec4(0.,1.,5./6.,Sr);HV[3]=vec4(-1.,1.,-1./3.,HM);HV[4]=vec4(-1.,2.,1.,HM);HV[5]=vec4(0.,1.,-1./6.,Sr);HV[6]=vec4(1.,1.,1./6.,Sr);HV[7]=vec4(1.,2.,1.,HM);HV[8]=vec4(2.,1.,1./2.,-Sr);HV[9]=vec4(2.,0.,-1./2.,Sr);HV[10]=vec4(3.,-1.,-1./6.,Sr);HV[11]=vec4(4.,-1.,1./3.,-HM);HV[12]=vec4(3.,0.,-1./2.,-Sr);HV[13]=vec4(3.,1.,1./2.,Sr);HV[14]=vec4(2.,2.,5./6.,Sr);HV[15]=vec4(1.,2.,-1./3.,HM);HV[16]=vec4(1.,3.,1.,HM);QG[0]=0.;for(int HZ=0;HZ<=Oj-1;HZ++)QG[HZ+1]=QG[HZ]+abs(HV[HZ].w);Uc=QG[Oj];}vec2 Mu(float Nk){vec4 Gk;vec2 Xy,AD;float Jx,UK,BL,AM;Nk/=3.;Xy=floor(Nk/Uc)*vec2(2.);Nk=mod(Nk,Uc);for(int HZ=0;HZ<=Oj-1;HZ++){if(Nk>=QG[HZ]&&Nk<QG[HZ+1]){Gk=HV[HZ];Jx=2.*(Nk-QG[HZ])/(QG[HZ+1]-QG[HZ])-1.;break;}}Xy+=Gk.xy;if(abs(Gk.w)==1.5){UK=1.5;AM=Bl;BL=KN/6.;Jx*=Gs(Gk.w);}else{UK=0.5;AM=1.;BL=-Gs(Gk.w)*KN/3.;}AD=vec2(-1.,1.)*sin(KN*Gk.z+vec2(0.,0.5*KN));return(Pz(Xy)+AM*AD-UK*Ro(AD,sin(Jx*BL+vec2(0.5*KN,0.))))*Rk;}vec3 Iu(vec3 PD,vec3 Ha){vec4 Ez;vec3 CO,DZ,IL,Wv;vec2 Co,Li;float Av,WZ,YK,Vo,GJ,Kw;int Pi,Nx,CS;Kw=0.;YK=0.;QX=vec4(0.8,0.8,0.85,0.05);CO=Kf(Ha);Co=vec2(0.);for(int HZ=YS;HZ<=1;HZ++){Av=XP(PD,Ha);Pi=LM;WZ=SR(PD,Ha);Nx=LM;Vo=RW(PD,Ha);if(min(WZ,Av)<min(Vo,TD)){if(WZ<Av){Vo=WZ;LM=Nx;}else{Vo=Av;LM=Pi;}}if(HZ==0&&Vo<TD&&LM==XL){PD+=Vo*Ha;Ha=reflect(Ha,Xh(4.*PD,vec3(0.,1.,0.),0.1));PD+=0.01*Ha;YK=Vo;Kw=0.2;}else break;}CS=0;if(Vo<TD){PD+=Vo*Ha;if(Vo==WZ){Pe=My(PD.xz/Rk);NK();DZ=Rg(PD);}else if(Vo==Av){Ul=My(PD.xz/SV);Dn();Li=Zs+VN.xz;BC(My(Li/Rk),Li);DZ=We(PD);}else{DZ=Ql(PD);}Ez=MP(PD,DZ,Co);if(LM==By&&DA(PD.xz)<PD.y+0.1){IL=reflect(Ha,DZ);Kw=(abs(BT.y-0.22)<0.26)?0.6:0.2;}if(Ez.a>=0.){Wv=PD+0.01*DZ;if(Co.y>0.)DZ=Xh(Co.x*PD,DZ,Co.y);GJ=min(TH(Wv,JO),UC(Wv,JO));GJ=min(GJ,ZA(Wv,JO));CS=1;}else{CO=Ez.rgb*(0.4+0.6*max(-dot(Ha,DZ),0.));}}if(CS>0){CO=Ez.rgb*(0.3+0.2*max(dot(JO*vec3(-1.,1.,-1.),DZ),0.)+0.7*GJ*max(dot(DZ,JO),0.))+Ez.a*step(0.95,GJ)*pow(max(dot(reflect(JO,DZ),Ha),0.),32.);CO=mix(CO,Kf(Ha),1.-exp(min(0.,1.-5.*(YK+Vo)/TD)));}if(Kw>0.)CO=mix(0.9*CO,Kf(IL),Kw);return clamp(CO,0.,1.);}void mainImage(out vec4 WI,in vec2 Yt){mat3 Jg;vec4 TY,Zb;vec3 PD,Ha,CO,AD,DV;vec2 ZJ,OE,Qp,Sn[Le],MT[Le],VJ,Xu,FG[3];float Hn,LZ,RJ,Ko,CW,Im,Nk,CB;int Hv,Mh;bool Lz;\nFX=iFrame;ZJ=iResolution.xy;OE=2.*Yt.xy/ZJ-1.;OE.x*=ZJ.x/ZJ.y;OV=iTime;Zb=iDate;TY=iMouse;TY.xy=TY.xy/ZJ-0.5;\nOV=mod(OV,3600.)+30.*floor(Zb.w/3600.)+20.;Ko=ZJ.x/ZJ.y;Lz=true;if(Lz){VJ=(1./5.)*vec2(Ko,1.);Sn[0]=(1.-VJ.y)*vec2(Ko,-1.);Sn[1]=(1.-VJ.y)*vec2(Ko,1.);Sn[2]=(1.-VJ.y)*vec2(-Ko,1.);for(int HZ=0;HZ<Le;HZ++)MT[HZ]=abs(OE-Sn[HZ])-VJ;}Mh=-1;if(TY.z>0.){Mh=0;if(Lz){for(int HZ=0;HZ<Le;HZ++){Xu=2.*TY.xy-Sn[HZ]/vec2(Ko,1.);if(Lv(abs(Xu))<VJ.y){Mh=HZ+1;Xu/=2.*VJ.y;break;}}}if(Mh==0)Xu=TY.xy;}Hv=0;if(Lz){for(int HZ=0;HZ<Le;HZ++){if(Lv(MT[HZ])<0.){OE=(OE-Sn[HZ])/VJ.y;Hv=HZ+1;break;}}}if(Mh>0&&(Hv==0||Hv==Mh))Hv=Mh-Hv;Rk=24.;SV=1.;KR=1.;AU=0.25;Zj=2.;CF=0.2;EY();ED=(OE.x/Ko>-1.+2.*LQ(0.25,0.75,0.01,fract(0.02*(OV-10.))))?1:0;Im=(16./Rk)*0.74*CF;MC=vec2(0.45,0.8);Gb=0.2;LZ=0.;Hn=0.;if(TY.z>0.&&Hv==Mh){LZ+=2.*KN*Xu.x;Hn+=0.5*KN*Xu.y;}DV=vec3(0.);for(int HZ=YS;HZ<Em;HZ++){Nk=(OV+30.)*Gb-float(HZ)*Im;for(int Go=YS;Go<3;Go++)FG[Go]=Mu(Nk+((Go>0)?sign(float(Go)-1.5)*MC.y*CF:0.));EQ[HZ].xz=FG[0];EQ[HZ].y=Zj+0.9*CF;DV+=EQ[HZ].xyz;AD.xy=FG[2]-FG[1];EQ[HZ].w=0.5*KN-atan(AD.y,AD.x);}CB=float(Em);DV/=CB;Nk=(OV+30.)*Gb;Fh=0.;if(Hv==0||Hv==1){PD.xz=Mu(Nk-((Hv==0)?CB+2.:-3.)*Im);PD.y=Zj+0.3;AD=normalize(((Hv==0)?EQ[Em-2].xyz:EQ[1].xyz)-PD);LZ+=atan(AD.z,-AD.x)-0.5*KN;Hn+=asin(AD.y);Hn=clamp(Hn,-0.2*KN,0.15*KN);RJ=3.;TD=12.*Rk;Fh=1.;}else if(Hv==2){PD=vec3(0.,20.,(-1.5*Bl+(2./Uc)*Nk)*Rk);PD.xz=SZ(PD.xz,-KN/3.);PD.x-=1.5*Rk;AD=normalize(DV-PD);LZ=0.03*LZ+atan(AD.z,-AD.x)-0.5*KN;Hn=0.03*Hn+asin(AD.y);RJ=40.;TD=30.*Rk;}else if(Hv==3){PD=vec3(0.,40.,(-3.*Bl+(2./Uc)*Nk)*Rk);PD.xz=SZ(PD.xz,-KN/3.);PD.x+=1.6*Rk;LZ+=KN/3.;Hn-=0.15*KN;Hn=clamp(Hn,-0.4*KN,-0.1*KN);RJ=5.;TD=30.*Rk;}Jg=Id(Hn,LZ);JO=normalize(vec3(0.,1.5,-1.));JO.xz=SZ(JO.xz,-KN/3.);const float AQ=1.;CO=vec3(0.);CW=2.*mod(dot(mod(floor(0.5*(OE+1.)*ZJ),2.),vec2(1.)),2.)-1.;for(float BL=float(YS);BL<AQ;BL++){Qp=(OE+step(1.5,AQ)*SZ(vec2(0.5/ZJ.y,0.),CW*(0.667*BL+0.5)*KN))/RJ;Ha=Jg*normalize(vec3(2.*tan(0.5*atan(Qp.x/Ko))*Ko,Qp.y,1.));CO+=(1./AQ)*Iu(PD,Ha);}if(Lz){for(int HZ=0;HZ<Le;HZ++){if(Lv(MT[HZ])<0.&&OR(abs(MT[HZ]))*ZJ.y<3.)CO=vec3(0.7,0.3,0.3);}}WI=vec4(CO,1.);}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlGBW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[372, 372, 407, 407, 445], [445, 445, 480, 480, 518], [518, 518, 545, 545, 567], [567, 567, 603, 603, 646], [646, 646, 690, 690, 900], [900, 900, 917, 917, 1096], [1096, 1096, 1113, 1113, 1159], [1159, 1159, 1177, 1177, 1233], [1233, 1233, 1252, 1252, 1280], [1280, 1280, 1298, 1298, 1321], [1321, 1321, 1339, 1339, 1362], [1362, 1362, 1380, 1380, 1413], [1413, 1413, 1431, 1431, 1464], [1464, 1464, 1501, 1501, 1573], [1573, 1573, 1610, 1610, 1633], [1633, 1633, 1679, 1679, 1745], [1745, 1745, 1772, 1772, 1915], [1915, 1915, 1941, 1941, 2029], [2029, 2029, 2054, 2054, 2107], [2131, 2131, 2149, 2149, 2205], [2205, 2205, 2222, 2222, 2303], [2303, 2303, 2320, 2320, 2416], [2416, 2416, 2434, 2434, 2561], [2561, 2561, 2579, 2579, 2742], [2742, 2742, 2760, 2760, 2861], [2861, 2861, 2879, 2879, 2980], [2980, 2980, 3006, 3006, 3148], [3148, 3148, 3182, 3182, 3377], [3377, 3377, 3395, 3395, 3517], [3517, 3517, 3535, 3535, 3554], [3554, 3554, 3571, 3571, 4195], [4195, 4195, 4210, 4210, 4611], [4611, 4611, 4629, 4629, 5598], [5598, 5598, 5608, 5608, 6009], [6010, 6010, 6036, 6036, 6748], [6748, 6748, 6765, 6765, 6957], [6957, 6957, 6983, 6983, 7228], [7228, 7228, 7238, 7238, 7358], [7358, 7358, 7383, 7383, 7470], [7470, 7470, 7488, 7488, 7829], [7829, 7829, 7855, 7855, 8604], [8604, 8604, 8621, 8621, 8813], [8813, 8813, 8839, 8839, 9135], [9135, 9135, 9171, 9171, 9658], [9658, 9658, 9676, 9676, 9853], [9853, 9853, 9879, 9879, 9985], [9985, 9985, 10002, 10002, 10194], [10194, 10194, 10220, 10220, 10389], [10389, 10389, 10406, 10406, 10523], [10524, 10524, 10563, 10563, 11542], [11542, 11542, 11552, 11552, 11957], [11957, 11957, 11996, 11996, 12534], [12534, 12534, 12544, 12544, 13118], [13118, 13118, 13136, 13136, 13542], [13542, 13542, 13567, 13567, 14646], [14646, 14646, 14685, 14685, 16948]], "test": "untested"}
{"id": "DlGBW3", "name": "Silver and black rug (music)", "author": "jarble", "description": "A fractal rug pattern with an ornate design.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 8, "viewed": 244, "published": 3, "date": "1702528226", "time_retrieved": "2024-07-30T17:16:36.856111", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nvec3 fractal(vec2 uv){\n    vec3 col = vec3(0.);\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    vec3 col1 = col;\n    float c1=0.;\n    for(int k = 0; k < 12; k++){\n    \n        uv.y -= 1./4.;\n        \n        uv = (uv+t2)/scale;\n        \n        uv = (fract(vec2(uv+vec2(.5,1.5))*scale)-.5)/scale;\n        //col.x = max(length(uv-t2-c1)/3.,col.x);\n        t2 = triangle_wave(uv+.5);\n        uv =\n            //t2-triangle_wave(uv.yx)+fract(t2/2.)\n            \n            //looks better with more iterations\n            t2-triangle_wave(uv.yx)-fract(t2/2.)\n        ;\n        //t2.x = (t2.x+1.5*sign(t2.y-t2.x));\n        //uv.x = (uv.x+1.5*sign(uv.y-uv.x)); \n        \n        float f1 = 8.;\n        c1 =\n            //max(abs(uv.y-uv.x*sign(uv.x-uv.y))/2.,c1)\n            max(abs(uv.y+uv.x)/f1,c1)\n            //max(abs(uv.y-uv.x)*2./f1,c1)\n        ;\n        c1 =\n            max(1.-abs(2.*c1*f1-1.),c1/f1)\n            \n            //more colorful\n            //abs(2.*c1-1.)\n            \n            //Spooky!\n            //max(abs(2.*c1-2.),c1/4.)/2.\n        ;\n        col.x =\n            //max(1./3.,col.x)\n            max(length(uv-t2-c1)/3.,col.x)\n            \n            \n            //yellow and green\n            //max(length(uv-t2-c1)/3.,1.-col.x)\n\n            //purple and gold\n            //2. - max((abs(uv.y-uv.x))/3.,col.x)\n           \n            //black and white\n            //col.x\n        ;\n        col =\n            abs(col-(1.-(c1*col.x)));\n        col1 =\n            abs(col1*c1-col-1.).yzx\n            //abs(col1*c1-col-sign(t2.y-t2.x)).yzx\n            //abs(col1*c1-col*sign(t2.y-t2.x)-1.).yzx\n        ;\n    }\n    return col1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    float t1 = 6.;\n    \n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.xy += iTime/t1/12.;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec3 col1 = fractal(uv);\n    fragColor = vec4(col1/2.,1.0);\n}\n", "image_inputs": [], "sound_code": "float mod1(float a, float b){\n    return\n        mod(a,b)\n        //mod(a+floor(a/8.)*2.,b)\n        //mod(a+mod(a,b+3.),b)\n    ;\n}\n\nvoid distort(inout float a, inout float b){\n    for(float i = 1.; i < mod(floor(a/b),5.); i++){\n        //a /=2.0;\n        //a /=1.0+mod(floor(a),2.);\n\n        a += mod1(floor(a/2.),b)*i;\n    }\n}\n\nfloat fmod(float a, float b){\n    distort(a,b);\n    return\n        mod(floor(a),b)\n    ;\n}\n\n#define fract1(a) abs(1.-fract(-a)*fract(-a))\n//#define fract1(a) pow(fract(a),1.+log(2.)-log(1.+fract(a)))\n\nvec2 synth_(vec2 a1,vec2 a,vec2 a2,vec2 a3,vec2 nb,vec2 a4){\n    return log(a1+a*abs(a2-abs(.5-a3*vec2(fract1(nb.x*.998),fract1(nb.y)))*a4));\n}\n#define synth(a1,a,a2,a3,nb,a4) synth_(vec2(a1),vec2(a),vec2(a2),vec2(a3),vec2(nb),vec2(a4))\n\nvec2 banjo(vec2 a, vec2 nb){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./6.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,6./4.));\n}\n\nvec2 harp(vec2 a, vec2 nb){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,2.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.));\n}\n\nvec2 synth_drum(vec2 a, vec2 nb,float m2){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./m2)\n  + synth(1./8.,a,1./4.,1.,nb*2.,m2/4.));\n}\n\nvec2 oud(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(.5+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      +.5*log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 steel_drum(vec2 a, vec2 nb){\nreturn a/16./4.*abs(synth(1./2.,a,1./8.,1.,nb*4.,1.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.))\n;\n}\n\nvec2 gamelan(vec2 a, vec2 nb){\nreturn\na/16./4.*abs(synth(1./4.,a,1./8.,1.,nb*2.,1./2.)\n  +.5*synth(1./4.,a,1./4.,1.,nb*2.,1./2.)) \n;\n}\n\nvec2 sitar1(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      -log(1./4.+a*(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 sitar2(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+a*a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      -log(1./2.+(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 sitar(vec2 a, vec2 nb){\nreturn a/16./2.*abs(log(1./8.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  -log(1./16.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2./4.)));\n}\n\nvec2 mainSound1(int samp, float time,float scale,float duration){\n  float tempo = .25,\n  s1 =\n      8.;\n  time /= tempo;\n  vec3\n  rhythm =\n      vec3(1.)\n      //more rhythms here!\n      //vec3(2.)\n      //vec3(1.+mod(floor(time/4.),2.))\n      //vec3(mod(floor(time/8.),2.),mod(floor(time/4.),2.),mod(floor(time/2.),2.))+1.\n      //vec3(2.,2.,1.)\n      //vec3(2.,1.,1.)\n  ;\n  for(float i = 1.; i < mod(floor(time),5.); i++){\n      time += mod(floor(time*2./rhythm.x),s1)*i;\n      time /= 1.+fmod(floor(time/rhythm.y)*2.,2.);\n      tempo *= 1.+fmod(floor(time/rhythm.z)*2.,2.);\n  }\n  float s2 = 8.,\n  t=\n      time,\n  m4 = (1.+fmod(t/16.,2.)),\n  m1 =\n      fmod(t/m4,s2)\n  ,\n  m3 =\n      fmod(t,1.+m1)+fmod(t/8.,2.);\n  t /=\n      (1.+fmod(t/s1,2.))*4./s1/s1\n  ;\n  float m2 =\n      1. + fmod(t/s1,s1)\n  ;\n  \n  //duration /= m4;\n  \n  vec2 a=\n      //vec2((1.-sqrt(fract(t/s1)/1.25))*.2)\n      -vec2((log(1./64./4.+fract1(t/s1)/8./duration)))\n\n      //pow(1.-log(1./16./2.+fract(t/s1)/4.),2.)\n  ,\n  nb =\n      vec2(time*tempo*pow(2.,floor((m3+m2)/2.)/5.+scale))\n      //vec2(time*tempo*pow(2.,floor((m3)/2.)/5.+scale-floor(m2/4.)+1.))\n  ;\n  vec2 \n  sitar =\n      (oud(a,nb*2.)-oud(a,nb*4.)/4.)\n      //synth(1./8.,a,1./8.,1.,nb*2.,1./2.)\n  ,gamelan = gamelan(a,nb)\n  ,steel_drum = steel_drum(a,nb)    \n  ,oud = oud(a,nb)\n  \n  ,synth_drum = synth_drum(a,nb,m2)\n  \n  ,harp = harp(a,nb)\n  \n  ,banjo = banjo(a,nb)\n  ,sitar1 = sitar1(a,nb)\n  \n  \n  ;\n  return\n      //sitar\n      //oud\n      //synth_drum\n      //harp\n      //steel_drum\n      //sitar\n      abs(gamelan/2.-synth_drum)\n      \n      //abs(gamelan-steel_drum/2.)\n      //abs(gamelan/2.-oud*2.)*2.\n\n      //abs(gamelan-oud*3.)/3.\n      \n      //abs(gamelan-steel_drum/4.)\n      \n      \n      //oud\n      //abs(.5-vec2(fract(nb.x*.998*2.),fract(nb.y)))*a\n      \n      \n      //log(abs(a/4.-2.*abs(.5-vec2(fract(nb*.998*2.),fract(nb*2.)))*a))\n\n      //log(abs(a/8.-abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a))\n  ;\n}\n\nvec2 violin(int a,float b,float c){\n    return\n        //sounds like violin (using sitar3)\n        (mainSound1(a,b,5.+c,1./2.)-mainSound1(a,b,5.+c,1./4.))\n        -(mainSound1(a,b,4.+c,1./2.)-mainSound1(a,b,4.+c,1./4.))\n        \n        //sounds like sitar (using sitar3 or sitar4)\n        //(2.*mainSound1(a,b*2.,5.,1./2.,8.)-mainSound1(a,b*2.,5.,1./4.,8.))\n        //-(mainSound1(a,b*2.,4.,1./2.,8.)-mainSound1(a,b*2.,4.,1./4.,8.))\n        \n    ;\n}\n\nvec2 mainSound(int samp, float time){\n    return\n        \n        //mainSound1(samp,time,5.5,1./2.)\n        abs(mainSound1(samp,time,5.5,1./2.)-mainSound1(samp,time,6.5,1./2.)/4.)\n        //(mainSound1(samp,time,6.,1./4.)-mainSound1(samp,time,7.,1./8.))\n\n\n        //violin(samp,time,0.)\n\n        //flute\n        //abs(mainSound1(samp,time,6.5,1.)-mainSound1(samp,time,6.5,1./2.)/2.-mainSound1(samp,time,6.5,1./4.)/4.)\n\n        //black metal\n        //abs(mainSound1(samp,time,7.,1./4.)-mainSound1(samp,time,6.5,1./4.))\n        \n        //snare drum\n        //abs(mainSound1(samp,time,6.,1./8.)-mainSound1(samp,time,6.5,1./8.))\n        //weird harp remix\n        //mainSound1(samp,time/2.,7.,1./4.)\n        \n        //drum remix\n        //abs(mainSound1(samp,time,4.5,1./2.)-mainSound1(samp,time,5.5,1./2.)/2.)\n        \n        //drum remix (using oud)\n        //abs(mainSound1(samp,time,6.,1./4.)-mainSound1(samp,time,6.5,1./2.)/2.)\n\n\n    ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlGBW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 129], [131, 131, 153, 153, 1785], [1787, 1787, 1844, 1844, 2104]], "test": "untested"}
{"id": "dlVfDK", "name": "MathLollipop", "author": "ahsan2649", "description": "by combining tangents with radius and angles, we get a lollipop pattern. ", "tags": ["circular", "lollipopblackandwhite"], "likes": 7, "viewed": 139, "published": 3, "date": "1702518806", "time_retrieved": "2024-07-30T17:16:37.607103", "image_code": "mat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n      \n    uv = rotate2d((iTime * 0.25)) * uv;\n    \n    float r = sqrt(uv.x*uv.x + uv.y*uv.y);\n    \n    \n    float th = atan(uv.y/uv.x);\n    \n\n    float f = .5/tan(r*7. - iTime * 2.) + tan(8. * th);\n    f *= .75;\n    f = abs(f);\n    f = smoothstep(0.7,0.9,f);\n    // Output to screen\n    fragColor = vec4(vec3(f),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlVfDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 118], [120, 120, 177, 227, 613]], "test": "untested"}
{"id": "mlVBDK", "name": "Flowerseeds", "author": "ahsan2649", "description": "Changing a few functions from my Flowercomb shader yielded this, and it was different enought that I felt it needed its own place", "tags": ["math", "flower", "circular"], "likes": 7, "viewed": 157, "published": 3, "date": "1702517097", "time_retrieved": "2024-07-30T17:16:38.367071", "image_code": "mat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n  \n    uv = rotate2d((iTime * 0.25)) * uv;\n    \n    float r = sqrt(uv.x*uv.x + uv.y*uv.y);\n    float s = sqrt(uv.x*uv.y + uv.y*uv.x);\n    float t = sqrt(1./uv.x*uv.y + uv.y*uv.x);\n    \n    float th = atan(uv.y/uv.x);\n    \n    float f = .125/cos(r*8. - iTime * 2.5) - sin(8. * th);\n    f += sin(iTime);\n    f -= sin(f*2.);\n    f += cos(f*4.);\n    \n    f = smoothstep(0.5,0.999,f);\n\n    \n    // Output to screen\n    fragColor = vec4(f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlVBDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 118], [120, 120, 177, 227, 729]], "test": "untested"}
{"id": "dlVBWK", "name": "Tower of Powers III", "author": "domrally", "description": "Click & Drag!\n[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]", "tags": ["fractal", "orbit", "iteration", "trap", "exponential", "chaotic", "tetration", "hyperoperation"], "likes": 8, "viewed": 188, "published": 3, "date": "1702516496", "time_retrieved": "2024-07-30T17:16:39.120058", "image_code": "/*\nby Dom Mandy in 2023\n*/\nvoid mainImage(out vec4 P, vec2 V) {\n    vec2 R = iResolution.xy,\n         C = V = 4. * (V + V - R) / R.x;\n    C = mix(C, 4. * (2. * iMouse.xy - R) / R.x, max(0., sign(iMouse.z)));\n\n    float c, k, s, r = s = 9.,\n          a = atan(C.y, C.x), \n          d = dot(C, C);\n\n    for (int k; k < 222; k++)\n        c = dot(V, vec2(a, log(d) / 2.)),\n        V = exp(-a * V.y) * pow(d, V.x / 2.) * vec2(cos(c), sin(c)),\n        s = min(s, abs(V.y)),\n        r > (c = abs(V.x)) ? r = c, R = V : R;\n\n    s = smoothstep(-27., 1., log(r * s)) * smoothstep(1., -17., log(r * s));\n    vec3 S = s + s * cos(atan(R.y, R.x) - vec3(0, 2.1, 4.2));\n    P.rgb = isnan(c) ? vec3(0) : sqrt(S);\n}\n\n\n/*\nPOWER TOWER vs TETRATION\nThis power tower fractal has gone from a minor interest to one of my favorites. \nI often saw it posted in forums discussing tetration. However, I did not really consider it a hyperoperation.\nThe tetration hyperoperation is n^n^n... however many times you want. Ex: nÂ²â = nâ¿\nThe power tower is n^n^n... infinite times. This formula also has interesting convergence properties. Ex: nâ±â¿â = W(-log n) / -log n\nHowever, I personally would not call it tetration since I would not call n*n*n... infinite times the power function.\n\nORBIT TRAP RENDERING\nI did not expect the real and imaginary orbit traps to have such interesting line patterns. \nThe same traps for the Mandelbrot are quite spiky and scary looking. But in this case they have become quite gentle and web-like.\nI chose the real trap for the domain coloring because the color gradients were much smoother than the imaginary angle.\nNormally for these renders I will use the complex magnitude trap since it gives nice voronoi like patterns.\nBut in this case the hues matching with the lines looks better to me so this is what I came up with.\nSimilar logic for blacking out the interior. There is lots of interesting fractal escape structure inside the crab but this way I'm trying to draw attention to the nice exterior orbits.\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlVBWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 27, 63, 63, 698]], "test": "untested"}
{"id": "clKfDV", "name": "testtesttest", "author": "jonis", "description": "test", "tags": ["cineshader"], "likes": 3, "viewed": 624, "published": 3, "date": "1702507929", "time_retrieved": "2024-07-30T17:16:39.957818", "image_code": "void mainImage(out vec4 fragColor,in vec2 fragCoord){vec2 p=(2.*fragCoord.xy-iResolution.xy)/iResolution.y;fragColor=vec4((3.+2.*sin(iTime*5.)) / (40.*abs(2.*length(p)-1.)));}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clKfDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 175]], "test": "untested"}
{"id": "DlVfWK", "name": "Tower of Powers II 292", "author": "domrally", "description": "[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]", "tags": ["fractal", "orbit", "iteration", "trap", "exponential", "golf", "chaotic", "tetration", "hyperoperation"], "likes": 8, "viewed": 148, "published": 3, "date": "1702502844", "time_retrieved": "2024-07-30T17:16:40.923237", "image_code": "/*\nby Dom Mandy in 2023\n*/\nvoid mainImage(out vec4 P, vec2 V) {\n    vec2 R = iResolution.xy,\n         C = V = 4. * (V + V - R) / R.x;\n\n    float c, k, r = 9.,\n          a = atan(C.y, C.x), \n          d = dot(C, C);\n\n    for (; k++ < 99.; r > (c = abs(V.x)) ? r = c, R = V : R)\n        c = dot(V, vec2(a, log(d) / 2.)),\n        V = exp(-a * V.y) * pow(d, V.x / 2.) * vec2(cos(c), sin(c));\n\n    P = sqrt((log(r) + 9.) / 9. * (1. + cos(atan(R.y, R.x) - vec4(0, 2, 4, 0))));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlVfWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 27, 63, 63, 472]], "test": "untested"}
{"id": "DtVfWK", "name": "cube planet v1", "author": "dkaraush", "description": ".", "tags": ["cube", "space", "planet"], "likes": 7, "viewed": 188, "published": 3, "date": "1702496869", "time_retrieved": "2024-07-30T17:16:41.683205", "image_code": "float cube(vec3 p, float r) {\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat4 rotation3d(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n    oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n    0.0,                                0.0,                                0.0,                                1.0\n  );\n}\n\nvec3 scenerotate(vec3 pos) {\n    return (rotation3d(vec3(1.0, 0.5, 1.0), 1.0 + iTime / 10.0) * vec4(pos, 1.0)).xyz; \n}\nvec3 cubepos(vec3 pos) {\n    return scenerotate(pos - vec3(0.0, 0.0, 5.0));\n}\n\nfloat scene(vec3 pos) {\n    vec3 p = cubepos(pos);\n   return mix(cube(p, 1.5), length(p) - 2.0, (sin(iTime) + 1.0) / 2.0);\n}\n\nvec3 normal(vec3 p) {\n    float EPSILON = 0.001;\n    return normalize(vec3(\n        scene(p + vec3(EPSILON, 0.0, 0.0)),\n        scene(p + vec3(0.0, EPSILON, 0.0)),\n        scene(p + vec3(0.0, 0.0, EPSILON))\n    ) - scene(p));\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nvec3 world(vec3 pos) {\n    //if (iMouse.z <= 0.0) {\n    //    const float S = 100.;\n    //    pos = ceil((pos - 0.1) * S) / S;\n    //}\n    pos = mix(pos, normalize(pos), .5 * (1.0 - length(pos)));\n    \n    float height = 0.0;\n    float ns = 0.0;\n    \n    vec3 apos = abs(pos);\n    float mx = max(max(apos.x - apos.y - apos.z, apos.y - apos.x - apos.z), apos.z - apos.x - apos.y) / 1.5;\n    mx = mix(.8, 1., mx);\n    \n    height += (.08 + noise(pos * 1.0) * mx) * 3.; ns += 3.;\n    height += (.08 + noise(pos * 4.0) * mx) * 5.; ns += 5.;\n    height += (.1 + noise(pos * 4.5) * mx) * 4.; ns += 4.;\n    height += noise(pos * 5.0) * 2.; ns += 2.;\n    height += noise(pos * 10.0) * .5; ns += .5;\n    height += noise(pos * 20.0) * .5; ns += .5;\n    height += noise(pos * 30.0) * .5; ns += .5;\n    height += noise(pos * 40.0) * .5; ns += .5;\n    height += noise(pos * 50.0) * .5; ns += .5;\n    //height += noise(pos * 60.0) * .5; ns += .5;\n    //height += noise(pos * 70.0) * .5; ns += .5;\n    \n    height /= ns;\n    \n    const vec3 SNOW = vec3(1.0);\n    const vec3 STONE =  vec3(.68627, .68627, .68627); // #AFAFAF\n    const vec3 GRASS2 = vec3(.05098, .57254, .10196); // #0D921A\n    const vec3 GRASS1 = vec3(.07058, .79215, .14117); // #12CA24\n    const vec3 SAND =   vec3(.98431, .89411, .08627); // #12CA24\n    const vec3 WATER1 = vec3(.23921, .58431, .98823); // #3D95FC\n    const vec3 WATER2 = vec3(.17254, .43137, .73725); // #2C6EBC\n    \n    if (height < 0.5) {\n        return mix(WATER2, WATER1, height / .5);\n    } else if (height < 0.52) {\n        return SAND;\n    } else if (height > 0.9) {\n        return SNOW;\n    } else if (height > 0.85) {\n        return STONE;\n    }\n    return mix(GRASS1, GRASS2, (height - .5) / .52);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y;\n    uv.x -= .5 * (iResolution.x / iResolution.y - 1.);\n\n    vec3 pos = vec3(0.0);\n    vec3 dir = normalize(vec3(uv.x - .5, uv.y - .5, 1.));\n    \n    vec3 p = pos;\n    float dist = 0.0;\n    float lastdist = 0.0;\n    for (int i = 0; i < 42; ++i) {\n        lastdist = scene(p);\n        dist += lastdist;\n        if (lastdist <= 0.0) {\n            break;\n        }\n        p += dir * lastdist;\n    }\n    \n    if (lastdist <= 0.5) {\n        vec4 color = vec4(world(cubepos(p)), 1.0);\n        vec3 normal = normal(p);\n\n        const vec3 lightPos = vec3(0.0, 0.0, -5.0);\n        vec3 lightDir = normalize(scenerotate(lightPos) - scenerotate(p));\n        float ambient = 0.3;\n        float diffuse = 0.7 * max(dot(normal, lightDir), 0.0);\n\n        fragColor = color * (ambient + diffuse);\n    } else {\n        fragColor = vec4(0.0);\n        \n        float starnoise = noise(normalize(cubepos(pos - p)) * 550.0);\n        starnoise *= starnoise;\n        starnoise *= starnoise;\n        const float starthreshold = .85;\n        if (starnoise > starthreshold) {\n            fragColor = vec4(2.0 * (starnoise - starthreshold) / (1. - starthreshold));\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtVfWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 120], [122, 122, 163, 163, 749], [751, 751, 779, 779, 869], [870, 870, 894, 894, 947], [949, 949, 972, 972, 1073], [1075, 1075, 1096, 1096, 1302], [1304, 1304, 1326, 1326, 1371], [1372, 1372, 1392, 1392, 1437], [1438, 1438, 1456, 1456, 1495], [1497, 1497, 1517, 1517, 2008], [2010, 2010, 2032, 2144, 3741], [3743, 3743, 3798, 3798, 4996]], "test": "untested"}
{"id": "wsVcWw", "name": "3DKIFS spacecoral - golf", "author": "FabriceNeyret2", "description": "golfing 2327 chars \"3DKIFS spacecoral remix\" by iterationsteppa. https://shadertoy.com/view/ldS3zh\nremix of kali's de bird, after bird was in soup with coliflowers and condiments and an eel", "tags": ["fractal", "kifs"], "likes": 25, "viewed": 303, "published": 3, "date": "1702492813", "time_retrieved": "2024-07-30T17:16:42.461125", "image_code": "// golfing 2327 chars \"3DKIFS spacecoral remix\" by iterationsteppa. https://shadertoy.com/view/ldS3zh\n// 2020-10-18 16:00:03\n// http://www.fractalforums.com/movies-showcase-%28rate-my-movie%29/very-rare-deep-sea-fractal-creature/\n//kali gl code rmxed\n\n#define R(a)            mat2(cos( a + vec4(0,11,33,0)))\n#define N               normalize\n#define v               vec3\n\nfloat M(v p) {                                                     // === scene map()\n\tp = p.zxy;                                                     // global orientation\n\tp.xy *= R( 1.5 + sin(iTime*.5) *.5 );                          // oscillation\n\tp.x *= .75;\n\tfloat s = 1., i,\n          t = iTime * 1.3,                                         // Speed\n          a =  sin(t)*.175 +  1.73;                                // RotAngle\n    v     A = N(   v(.5,-.05,-.5)                                  // RotVector\n                 + v(sin(1.),sin(t*.133),cos(t*.2)) * .45          // aniso * Amplitude\n               );\n\tp += sin( p*3.+t*6. ) *.04;\n\n\tfor ( ; i++ < 24.; )                                           // Iterations\n\t\tp.xy = abs(p.xy),\n        s *= 1.27,\n\t\tp -= v(1.2,1.95,.6) / s,                                   // Julia / Scale\n        p  = mix( A*dot(p,A), p, cos(a) ) - sin(a)*cross(p,A);     // rot3( p, A, -a )\n\n\treturn length(p)*.9;\n}\n\nvoid mainImage( out vec4 O, vec2 u )                               // === render scene\n{\n\tfloat l,i, e = .0125, d = e;\n    v     R = iResolution, \n\t      P = v(0,-.7,-20),                                        // ray start at camera pos\n\t      D = N( v( u+u - R.xy , 1.4*R.x ) ),                      // ray direction\n          L =-N( v(1,2,1) ),                                       // light direction\n          n, E; E.y = e;\n\tD.yz *= R(-.5);                                                // rotate camera\n\tP.yz *= R(-.5);\n\n\tfor ( ; i++ < 70. && d >= e && l < 50. ;  )                    // --- raymarch(from,dir) \n\t\tl += d = M( P += d*D );\n        \n    P -= e*D;                                                      // --- light(p, D)\t\n    n =  N( v (  M(P +E.yxx) - M(P -E.yxx),                        // normal(p)\n                 M(P +E.xyx) - M(P -E.xyx),\n                 M(P +E.xxy) - M(P -E.xxy)\n          )   );\n\ti =            max(0., dot(L ,-n) )                            // diffuse\n        + .5* pow( max(0., dot(D, -reflect(L,n)) ) , 30. )         // specular\n        +.15*      max(0., dot(D,-n));\t                           // diffuse from cam\n    O = vec4( // d < eps ?\n                   mix( .5, i, exp(-pow(l/21.,3.5)) )              // fog\n              // : .5 // backg\n            );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVcWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[372, 372, 386, 457, 1331], [1333, 1333, 1421, 1421, 2647]], "test": "untested"}
{"id": "DlKfz3", "name": "Heightmap Lighting", "author": "soimn", "description": "an attempt at recreating the effect from https://www.youtube.com/watch?v=bMTeCqNkId8", "tags": ["lighting", "heightmap"], "likes": 3, "viewed": 154, "published": 3, "date": "1702491440", "time_retrieved": "2024-07-30T17:16:43.222090", "image_code": "#define PION2 1.57079632679f\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 texel = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec3 albedo  = texel.xyz;\n    float height = texel.w;\n    vec3 normal = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    \n    vec3 light = normalize(vec3(-0.5f, 0.5f, 0.5f));\n    float light_steepness = length(light-vec3(light.xy, 0.0f))/length(light.xy);\n    \n    bool in_shadow = false;\n    \n    ivec2 sstep = ivec2(sign(light));\n    ivec2 pos = ivec2(fragCoord);\n    while (pos.x >= 0 && pos.x < int(iResolution.x) && pos.y >= 0 && pos.y < int(iResolution.y))\n    {\n        float pos_height = texelFetch(iChannel0, pos, 0).w;\n    \n        if ((pos_height-height)/(length(vec2(pos) - fragCoord)*4.0f) > light_steepness)\n        {\n            in_shadow = true;\n        }\n    \n        float err_x = dot(vec2(pos + sstep.x) - fragCoord, light.xy); \n        float err_y = dot(vec2(pos + sstep.y) - fragCoord, light.xy);\n    \n        pos += sstep;\n    }\n    \n    float light_i = 0.3f;\n    if (!in_shadow)\n    {\n        light_i += 0.7f*max(0.0f, dot(normal, light));\n    }\n    \n    vec3 color = albedo*light_i;\n    \n    vec3 waves_color = vec3(ivec3(0x2F, 0x37, 0xE2))/(400.0f + 100.0f*(cos(fragCoord.y + 80.0f*cos(fragCoord.x)) + sin(fragCoord.x + (50.0f + 30.0f*cos(0.5f*iTime))*sin(fragCoord.y))));\n    \n    // NOTE: Forgot to divide color by 255 and the result was pretty cool\n    //if (height < 220.0f) color = mix(color, mix(vec3(ivec3(0x2F, 0x37, 0xE2)), waves_color, 1.5f + 0.5f*sin(fragCoord.y + cos(fragCoord.x))), 0.2f);\n    \n    if (height < 220.0f) color = mix(color, mix(vec3(ivec3(0x2F, 0x37, 0xE2))/255.0f, waves_color, 0.9f + 0.5f*sin(fragCoord.y/24.0f + iTime + cos(fragCoord.x/30.0f + iTime*3.0f))), 0.2f);\n    \n    fragColor = vec4(color, 1.0f);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Heavily inspired by the applicaiton of \"noise\" in https://www.shadertoy.com/playlist/fXlXzf&from=0&num=12\nfloat\nHeight(vec2 p, float r)\n{\n    mat2 m = mat2(1.1f, -0.8f, 0.7f, 1.2f);\n    p += vec2(0.8f);\n    float f = noise(0.6f*vec2(noise(-3.0f*p)));\n    p *= m;\n    f += 0.4f*noise(p*5.0f);\n    p *= m;\n    f += 0.1f*noise(p*10.0f);\n    p *= m;\n    f += 0.01f*noise(p*16.0f);\n    \n    f = exp(-f);\n\n    f *= exp(-r*r*4.0f);\n    \n    return (0.5f + 0.5f*f)*400.0f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 scale = vec2(1.0f/iResolution.y);\n    vec2 c = (fragCoord + iTime*30.0f)*scale;\n    vec2 dx = vec2(1.0f, 0.0f)*scale;\n    vec2 dy = vec2(0.0f, 1.0f)*scale;\n\n    float r = length(2.0f*fragCoord/iResolution.xy-1.0f);\n\n    float height = Height(c, r);\n    \n    float diff_x = Height(c - dx, r) - Height(c + dx, r);\n    float diff_y = Height(c - dy, r) - Height(c + dy, r);\n    \n    vec3 normal = normalize(vec3(diff_x, diff_y, 2.0f));\n\n    fragColor = vec4(normal, height);\n}", "buffer_d_inputs": [], "common_code": "// The MIT License\n// Copyright Â© 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n\n// Simplex Noise (http://en.wikipedia.org/wiki/Simplex_noise), a type of gradient noise\n// that uses N+1 vertices for random gradient interpolation instead of 2^N as in regular\n// latice based Gradient Noise.\n\n// All noise functions here:\n//\n// https://www.shadertoy.com/playlist/fXlXzf&from=0&num=12\n\n\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}", "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 normal  = texel.xyz;\n    float height = texel.w;\n    \n    vec3 albedo = vec3(0.0f);\n    \n    vec3 deep_sea_color = vec3(ivec3(0x22, 0x41, 0x8F));\n    vec3 shore_color    = vec3(ivec3(0x0C, 0xE1, 0xF5));\n    vec3 sand_color     = vec3(ivec3(0xF5, 0xD1, 0x91));\n    vec3 grass_color    = vec3(ivec3(0x06, 0x75, 0x59));\n    vec3 rock_color     = vec3(ivec3(0x6B, 0x5E, 0x8F));\n    vec3 snow_color     = vec3(ivec3(0xFE, 0xE8, 0xE8));\n    \n    float t = pow((height-200.0f)/10.0f, 0.3f);\n    vec3 sea_color = mix(deep_sea_color, shore_color, t);\n    sea_color = mix(sea_color, vec3(ivec3(0x1B, 0x37, 0xC2)), 0.5f - t*0.1f);\n    \n    albedo = mix(sea_color, sand_color, smoothstep(220.0f, 221.0f, height));\n    albedo = mix(albedo, grass_color, smoothstep(230.0f, 231.0f, height));\n    albedo = mix(albedo, rock_color, smoothstep(300.0f, 301.0f, height));\n    albedo = mix(albedo, snow_color, smoothstep(450.0f, 451.0f, height));\n    albedo /= 255.0f;\n    \n    fragColor = vec4(albedo, height);\n}", "buffer_c_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlKfz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 87, 87, 1819]], "test": "untested"}
{"id": "DtGfWV", "name": "Fourier Workflow 3 / phases info", "author": "FabriceNeyret2", "description": "space: show   module / phase / complex / real / imaginary     \nS: inset on/off  =spectrum before / after op\n     Set your signal in buf A, and your Fourier-space operations in buf C\nExample: keep only phases, module = |f] ^ -1.6 . So much info in phases !", "tags": ["fft", "fourier", "dft", "phase"], "likes": 13, "viewed": 358, "published": 3, "date": "1702481304", "time_retrieved": "2024-07-30T17:16:44.036913", "image_code": "// === Fourier analysis, Fourier operation ===================================\n// from a custom image or shader: set it in BufA, then put the Fourier filter in BufC\n// signal from custom spectrum:  set your module and phase in Buf C\n\n// ( new version of https://shadertoy.com/view/XtScWt )\n\n\n\n//Display modes\n#define MAGNITUDE 0.\n#define PHASE     1.\n#define COMPONENT 2.\n#define REAL      3.\n#define IMAG      4.\n\n//Scaling\n#define LOG 0\n#define LINEAR 1\n\n#define MAG_SCALE LOG\n\nvec4 rainbow(float x)  { return .5 + .5 * cos(6.283*(x - vec4(0,1,2,0)/3.)); }\nvec4 rainbow(vec2 C)   { return rainbow(atan(C.y,C.x)/PI + .5); }\n\nvec4 paintDFT(vec2 F, float mode) {\n    // F /= SIZE;\n    return \n         mode == MAGNITUDE \n     #if   MAG_SCALE == LOG\n                           ?  vec4(log(length(F)))\n     #elif MAG_SCALE == LINEAR\n                           ?  vec4(length(F))\n     #endif\n       : mode == PHASE     ?  rainbow(F)        \n       : mode == COMPONENT ?  .5+.5*vec4(F, 0,0)\n       : mode == REAL      ?  .5+.5*vec4(F.x)\n       : mode == IMAG      ?  .5+.5*vec4(F.y)\n       : vec4(-1); // error\n}\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    //O = texture(iChannel0,uv/R).xxxx; return;  // debug\n        \n    vec2 pixel = ( U - R/2.) / SIZE  + vec2(2,1)/2.,\n         tile  = floor(pixel),\n         stile = floor(mod(2.*pixel,2.));\n\n    O *= 0.;\n    if(tile.y>0.) O += texture(iChannel0, U/R).x; // displayed opt values in top margin \n    \n    U = fract(pixel) * SIZE / R ;\n   \n    \n    vec2 DISPLAY_MODE = floor(texture(iChannel3, .5/R).zw); // persistant key flag.\n    bool INSET =  texture(iChannel3,vec2(1.5,.5)/R).w == 0.;\n    \n    if (tile.y==-1. && abs(tile.x-.5)<1.) {                // buttons displaying current flags value\n        for (float i=0.; i<5.; i++) \n            O += smoothstep(.005,.0,abs(length(U*R/SIZE-vec2(.2+i/7.,.97))-.025));\n        float v = tile.x==0. ? DISPLAY_MODE[0] : DISPLAY_MODE[1];\n        O.b += smoothstep(.03,.02,length(U*R/SIZE-vec2(.2+v/7.,.97)));\n    }\n    \n    if(tile == vec2(0,0))                                             // --- Input + DFT (Left)\n        if (stile == vec2(0) && INSET )\n             O += paintDFT(texture(iChannel1, 2.*U).xy, DISPLAY_MODE[0]); // initial spectrum\n        else O += texture(iChannel0, U).x;                                // initial texture\n      //else O += length(texture(iChannel0, uv).rgb);\n\n    if(tile == vec2(1,0))                                            // --- Output +DFT (Right)\n        if (stile == vec2(0) && INSET)\n             O += paintDFT(texture(iChannel3, 2.*U).xy, DISPLAY_MODE[1]); // initial Fourier\n        else O += paintDFT(texture(iChannel2, U).xy, DISPLAY_MODE[1]);    // final texture\n    //  else O += paintDFT(texture(iChannel2, fract(.5+U*R/SIZE)*SIZE/R).xy, DISPLAY_MODE[1]); // fftshift\n        \n    if (tile != mod(tile,vec2(2,1))) O+=.3;    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === source signal : your generator or load here =========================\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n//  NB: out of frame image (e.g. counters & sliders ) will be transmitted to final display.\n    O *= 0.;\n    if ( U.x < SIZE && U.y < SIZE )  {\n        // --- your image in O.x . O.xy would be a complex.\n        O.x = length( texture( iChannel0, U/SIZE ).rb );\n    }\n    \n   \n#if 0        // --- mouse controled impulse, for tests\n    U += floor( vec2(3,1.8)/2.*SIZE - R/2. ), // why 3,1.8 and not 2,1?\n#define P(x,y)   10.* smoothstep(1.,0.,length( U - vec2(x,y)*SIZE - iMouse.xy ) )\n    O.x = P(0,0)+P(1,0)+P(1,1)+P(0,1);\n#endif\n\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// === Fourier transform of the input ==========================================\n\n// Horizontal + Vertical Discrete Fourier Transform of the input \n// 2 passes pipelined : in -> buf.zw -> buf.xy -> out\n// ( adapted from  Flyguy's https://www.shadertoy.com/view/MscGWS# )\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O *= 0.;\n    \n    if ( U.x > SIZE || U.y > SIZE ) return;\n    U -= .5;\n    for(float n = 0.; n < SIZE; n++)  {\n        vec2 xn = tex(iChannel0, n, U.y).xy,\n             yn = tex(iChannel1, U.x, n).zw,\n             a = - 2.*PI * (U -SIZE/2.) * n/SIZE;\n        \n        O.zw += cmul(xn, a.x);       // Fourier(x)\n        O.xy += cmul(yn, a.y);       // Fourier(y)\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// === do your operation in spectral domain here =========================\n\nbool keyPress( int ascii) { return (texture(iChannel2,vec2((.5+float(ascii))/256.,0.25)).x > 0.); }\nbool keyToggle(int ascii) { return (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.); }\nfloat rand( vec2 U )      { return fract(1e5*sin(dot(U,vec2(17.4,123.7)))); }\nfloat gauss(float x)      { return exp(-.5*x*x); }\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O *= 0.;\n    if ( U==vec2(.5)) {                             // --- GUI management ----------------\n        if (iFrame==0) O.zw = vec2(0,3);\n        else           O.zw = texture(iChannel1, U/R).zw;  \n        if ( keyPress(32) ) \n            if (iMouse.x/R.x<.5) O.z = mod(O.z+.1, 5.) ; // persistant key flag for left window\n            else                 O.w = mod(O.w+.1, 5.) ; // persistant key flag for right window\n        return;\n    }\n    if ( U==vec2(1.5,.5)) { O.w = float(keyToggle(64+19)); return; } // key S state\n\n    vec2 T = texture(iChannel0, U / R).xy;         // --- Spectral filter --------------\n    U -= .5;  // freq 0 must exist\n    vec2 X = 2.*U/SIZE - 1.;\n    float l = length(X), s = sign(-X.x), y = iMouse.y/R.y;\n    \n\n#if 0  // --- your custom Fourier-space filter here --------------------\n    float  \n       // F = 1.;                                  // 1: neutral\n       // F = l*10.;                               // 2: derivative\n       // F = .01/(.01+l);                         // 3: integral\n       // F = gauss(l/.125)*30.;                   // 4: gaussian blur   <---\n          F = smoothstep(.03,.0, abs(l-.3)) * 20.; // 5.1: ring filter   <---\n       // F = smoothstep(.2,.0, abs(l-.4)) * 20.;  // 5.2: ring filter   <---\n       // F = smoothstep(-.1,.1,l-y) * 20.;        // 6: kill LF (mouse tuning)\n       // F = float(fract(U.x/2.)*fract(U.y/2.)>0.);   // odd  freq only\n       // F = float(fract(U.x/2.)+fract(U.y/2.)==0.);  // even freq only\n       // F = SIZE/length(T);                      // 7: flat modulus\n                                                   // --- play with phases --------\n       // F = ang(6.2832*rand(U))*4.;              // 10: white noise\n       // F = gauss(l/.05)*10.;                    // 11: modulus profile : gauss\n       // F = gauss(abs(l-.12)/.005)*10.;          // 12: modulus profile : ring (blue noise)\n       // F = cmul(T,iTime*s);                     // 13: phase shift with time\n    \n    T *= F;\n    \n#else // --- direct tuning of the spectrum -----------------------------\n    \n      // if (length(T)/sqrt(SIZE)<1e-4) T = vec2(0);  // clamp almost empty spectrum regions\n      // if (length(T)/sqrt(SIZE)<3.) T = length(T)*ang(6.2832*rand(X)); \n    \n      // T = length(T) * vec2(1,0);                // keep modulus, kills phases\n      // T = length(T) * round(normalize(T));      // keep modulus, quantize phases: 9\n      // T = length(T) * sign(T);                  // keep modulus, quantize phases: 4\n      // T = length(T) * vec2(sign(T.x+T.y));      // keep modulus, quantize phases: 2\n      // T = length(T) * ang(6.2832*rand(X));      // keep modulus, random phases\n      // T = normalize(T)*100.;                    // keep phases only, mod = 1\n      // T = normalize(T) * rand(X) * 200.;        // keep phases only, random mod\n         T = normalize(T) * pow(l, -1.6) * 5.;     // keep phases only, mod = l^-1.6\n      // T = pow(l, -1.6) * vec2(sign(T.x+T.y)) * 5.; // quantize phase: 2 , mod = l^-1.6\n#endif\n\n\tif (l<1e-5) T=vec2(0);                         // cancels DC\n    O = vec4(T,0,0);\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// === invFourier transform ========================================\n\n// Horizontal + Vertical Discrete Fourier Transform of the input \n// 2 passes pipelined : in -> buf.zw -> buf.xy -> out\n// ( adapted from  Flyguy's https://www.shadertoy.com/view/MscGWS# )\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O *= 0.;\n    \n    if ( U.x > SIZE || U.y > SIZE ) return;\n    U -= .5;\n    for(float n = 0.; n < SIZE; n++)  {      \n        vec2 xn = tex(iChannel0, n, U.y).xy,\n             yn = tex(iChannel1, U.x, n).zw,\n             a =  2.*PI * U * (n - SIZE/2.)/SIZE;  // W() wrap 0,0 to mid-window.\n        \n        O.zw += cmul(xn, a.x);       // Fourier(x)\n        O.xy += cmul(yn, a.y);       // Fourier(y)\n    }\n    \n    O /= SIZE;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SIZE               ( 2.*floor(iResolution.x/4.*.8) ) \n#define R                   iResolution.xy\n#define PI                  3.14159265\n#define tex(ch,x,y)         texelFetch(ch, ivec2(x,y), 0)\n#define ang(a)              vec2( cos(a), sin(a) )\nvec2 cmul(vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\n", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtGfWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[480, 480, 504, 504, 558], [559, 559, 583, 583, 624], [1109, 1109, 1148, 1206, 2874]], "test": "untested"}
{"id": "mtVBDy", "name": "particles3d toroidal terahedron", "author": "cyperus", "description": "forked from https://www.shadertoy.com/view/ctffzN by  SnoopethDuckDuck\n- 3D particle simulation in the gravity field of an toroidal tetrahedron.", "tags": ["3d", "sdf", "particles", "tetrahedron", "buffer"], "likes": 9, "viewed": 222, "published": 3, "date": "1702467398", "time_retrieved": "2024-07-30T17:16:45.310508", "image_code": "void mainImage( out vec4 O, in vec2 px )\n{\n    O = texelFetch(iChannel0, ivec2(px), 0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159\n#define R iResolution.xy\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nconst int\n    BUF_PARTICLE_POSITION_PREV = 0,\n    BUF_PARTICLE_POSITION = 1,\n    BUF_PARTICLE_VELOCITY = 2;\n\nconst int PARTICLES_NUM = 32;\nconst float PARTICLE_RADIUS = .03;\n\n// Hash from BlackleMori\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(vec2 a) {\n    int x = FK(a.x), y = FK(a.y);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// complex\nvec2 cmul(vec2 za,vec2 zb) {\n    return za*mat2(zb.x,-zb.y,zb.yx);\n}\n\nvec2 crot(vec2 z,float a) {\n    return cmul(vec2(cos(a),sin(a)),z);\n}\n\nvec2 cinv(vec2 z) {\n    return z*vec2(1,-1)/dot(z,z);\n}\n    \nvec2 cdiv(vec2 z, vec2 w) {\n    return cmul(z,cinv(w));\n}\n\nvec2 cTeraPolyArc2disk(vec2 z) {\n    // https://people.maths.ox.ac.uk/trefethen/lightning.html\n    const int NUM_j = 15; // poles\n    const vec2[NUM_j] rf = vec2[]\n    (vec2(-0.4534, -0.8913)\n    ,vec2( 0.5001,  0.8660)\n    ,vec2(-1.0000,  0.0001)\n    ,vec2( 0.5008, -0.8656)\n    ,vec2(-0.5452,  0.8383)\n    ,vec2( 0.1901,  0.9818)\n    ,vec2( 0.9875, -0.1576)\n    ,vec2(-0.9856, -0.1691)\n    ,vec2( 0.4224, -0.9064)\n    ,vec2( 0.5738,  0.8190)\n    ,vec2(-0.9995,  0.0311)\n    ,vec2( 0.4858,  0.8741)\n    ,vec2( 0.5760, -0.8175)\n    ,vec2(-1.0000, -0.0061)\n    ,vec2( 0.4959, -0.8684));\n    \n    const vec2[NUM_j] rw = vec2[]\n    (vec2( 0.2728,  0.0   )  \n    ,vec2( 0.0003,  0.0126)\n    ,vec2(-0.0016, -0.0121)\n    ,vec2(-0.0172,  0.0324)\n    ,vec2( 0.1417, -0.4629)\n    ,vec2(-0.4681, -0.2288)\n    ,vec2(-0.2433,  0.2822)\n    ,vec2( 0.1996, -0.0082)\n    ,vec2( 0.2884, -0.0353)\n    ,vec2(-0.0666,  0.1824)\n    ,vec2(-0.0357, -0.1136)\n    ,vec2(-0.1091,  0.0396)\n    ,vec2(-0.0831,  0.2627)\n    ,vec2( 0.0598, -0.0284)\n    ,vec2( 0.0597,  0.0760));\n\n    const vec2[NUM_j] rz = vec2[]\n    (vec2(-0.239570, -0.459171)\n    ,vec2( 0.354172,  0.611300)\n    ,vec2(-0.706487,  0.001072)\n    ,vec2( 0.356785, -0.606740)\n    ,vec2(-0.277869,  0.437059)\n    ,vec2( 0.047259,  0.573454)\n    ,vec2( 0.515842, -0.066306)\n    ,vec2(-0.591622, -0.166501)\n    ,vec2( 0.221135, -0.605193)\n    ,vec2( 0.413545,  0.494105)\n    ,vec2(-0.671697,  0.057599)\n    ,vec2( 0.309337,  0.611574)\n    ,vec2( 0.414577, -0.491758)\n    ,vec2(-0.695342, -0.019940)\n    ,vec2( 0.334074, -0.612218));\n\n    // polynomial barycentric representation\n    vec2 zn = vec2(0.); vec2 zd = vec2(0.);       \n    for(int j = 0; j<NUM_j; j++)\n    {\n        vec2 zj = cdiv( rw[j], (z-rz[j]));\n        zd += zj; // sum denominator\n        zn += cmul(rf[j], zj); // sum nominator\n    }\n    return cdiv(zn, zd);;\n}\n\n// map spherical platonic solid pyramidal-face-cells to one cell located at -z-axis.\nvec3 tetra_cells(in vec3 p, out float cell_id, out float sr) {\n\t//// tetrahedron (bounded by a cube)\n\t// cells: A,B,C,D\n\t// cell walls defined by the face_normal\n    bool nBA = dot(vec3( 1., 0.,-1.),p)>=0.;\n\tbool nCA = dot(vec3( 0., 1.,-1.),p)>=0.;\n\tbool nDA = dot(vec3( 1., 1., 0.),p)>=0.;\n\tbool nCB = dot(vec3(-1., 1., 0.),p)>=0.;\n\tbool nDB = dot(vec3( 0., 1., 1.),p)>=0.;\n\tbool nDC = dot(vec3( 1., 0., 1.),p)>=0.;\n    \n    // map n-cells to 1-cell by rotation\n    // rotation angles\n    const float a45 = PI/4.;             // 45Â° \n    const float a35 = atan(sqrt(8.))/2.; // 35.264Â°\n    const float a30 = PI/6.;             // 30Â°\n    \n    const vec2 ei_a45 = vec2(cos(a45), sin(a45));\n    const vec2 ei_a35 = vec2(cos(a35), sin(a35));\n    const vec2 ei_a30 = vec2(cos(a30), sin(a30));\n    \n    vec2 ei_y = ei_a45;   \n    vec2 ei_x = ei_a35;\n    vec2 ei_z = ei_a30;\n    // symmetries\n    if(nBA && nCA && nDA) //inside cell A\n\t{\n\t\tcell_id =  0.;\n        ei_x.y *= -1.; // a = -35.264Â°\n\t}\n\telse if( nCB && nDB && !nBA) //inside cell B\n\t{\n\t\tcell_id =  1.;\n\t\tei_y   *= -1.; // a = -3.*45Â°\n        ei_x.y *= -1.; // a = -35.264Â°\n\t}\n\telse if(!nCA && !nCB && nDC) //inside cell C\n\t{\n\t\tcell_id =  2.;\n\t\tei_y.x *= -1.; // a = +3.*45Â°\n\t\tei_z.y *= -1.; // a = -30Â°\n\t}\n\telse if(!nDA && !nDB && !nDC)//inside cell D\n\t{\n\t\tcell_id =  3.;\n\t\tei_y.y *= -1.; // a = -45Â°\n\t\tei_z.y *= -1.; // a = -30Â°\n\t}\n\tp.zx = cmul(p.zx,ei_y); // y-axis\n\tp.yz = cmul(p.yz,ei_x); // x-axis\n\tp.xy = cmul(p.xy,ei_z); // z-axis\n\t// 3 edges per face, non cyclic\n\tsr = 3.;\n    return p;\n}\n\n// stereographic projection \nfloat sig(float x) {\n    return x < 0. ? -1. : +1.; \n}\n\nfloat dist(float x, float e) {\n    // e in [0., +inf]\n    return sign(x)*abs( pow(abs(x), abs(e)) );\n}\n\nvec3 sp(vec3 zsr) {\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // stereopraphic projection (complex plane to unit sphere)\n    float zz = dot(z,z); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(2. * z.x,  2. * z.y, -1. + zz);\n        }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(2. * z.x, -2. * z.y,  1. - zz);\n        }\n    pn /= 1.+zz;\n    return pn;\n}\n\n// data from sdf\nvec4 mat = vec4(0);\n\nfloat map1(in vec3 p, in float time) {\n    p.xy *= rot(.025*time);\n    //// sdf's\n    float rxy = 0., au = 0.0, av = 0.0;\n    float cell_id = 0., sr = 0.;\n    vec2 z = vec2(0.);\n           \n    //// map platonic solid cells to one cell\n    vec3 pn = normalize(p); \n  \n    // projection from n cells to 1 cell. \n    pn = tetra_cells(pn, cell_id, sr);\n    // invers stereographic projection\n    z = pn.xy/(1.-pn.z);\n    // complex plane   \n    z = cTeraPolyArc2disk(z);\n\n    /// r-polygon-distribution\n    vec2 e = vec2(sqrt(2.), 0.5);\n    float en = 1.+( (8.<0.?e.x:e.y)-1. )*smoothstep(1.,5., abs(8.));        \n    float r = length(z); vec2 zn = z/r;\n    z = dist(r, en) * zn;   \n\n    /// stereographic projection    \n    pn = sp(vec3(z,sr));\n\n    /// scale radius\n    p = length(p) * pn;\n    \n    float fracu = 1.0;\n    ////fractal level 0: Torus\n    au = atan(p.y, p.x);\n    rxy = length(p.xy); \n    z = vec2(rxy, p.z);\n    z = cmul(z,z); z.x -= 8.;\n\n    // distance estimation\n    float d = log(length(z));\n    \n    // torus complex plane, torus angle_u, platonic solid cell_id\n    mat.xy = z; // mat.z = au *fracu, mat.w = cell_id;\n    return d;\n}\n\n// color\nvec3 h2rgb(float h) {\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n}\n", "buffer_a_code": "\nvec3 grad1(vec3 p, float time) {\n\tfloat d = map1(p,time);\n    vec2 e = vec2(.001, 0);\n    vec3 g = d - vec3(\n        map1(p-e.xyy, time),\n        map1(p-e.yxy, time),\n        map1(p-e.yyx, time));    \n    return g;\n}\n\nvoid mainImage( out vec4 O, in vec2 px )\n{\n    //float dt = iTimeDelta; // less jitter, but not reproducible!\n    float dt = 1./50.;\n    ivec2 px_id = ivec2(px);\n    // init\n    if (iFrame < 1) {\n        vec3 p0 = vec3(hash(px), hash(px+.1), hash(px+.2));        \n        if (px_id.y == BUF_PARTICLE_POSITION)     \n            O.xyz = 3. * p0;\n            \n        if (px_id.y == BUF_PARTICLE_VELOCITY)\n            O.xyz = p0.zxy;\n    }\n    // update\n    else {\n        // get previous particle state\n        vec3 p = texelFetch(iChannel0, ivec2(px.x, BUF_PARTICLE_POSITION), 0).xyz;\n        vec3 v = texelFetch(iChannel0, ivec2(px.x, BUF_PARTICLE_VELOCITY), 0).xyz;\n        \n        // get gradientfield at the position of the particle \n        vec3 g = grad1(p, iTime);\n        vec3 n = normalize(g);\n        \n        //if (px_id.y == BUF_PARTICLE_POSITION_PREV) {\n        //    O.xyz = p;\n        //}        \n        if (px_id.y == BUF_PARTICLE_POSITION) {\n            // new position particle\n            p = v * dt + p;\n            \n            // clamp to sphere      \n            //const float r_sphere = 5.;\n            //float l = length(p);\n            //p *= l > r_sphere ? r_sphere / l : 1.;            \n            \n            O.xyz = p;\n        } \n        if (px_id.y == BUF_PARTICLE_VELOCITY) {\n            // collision particle\n            float collision_len = map1(p, iTime) - 4.* PARTICLE_RADIUS;\n            if (collision_len < 0.) {\n                vec3 v_n = dot(v,n)*n;\n                vec3 v_t = v-v_n;\n                v = 0.99*v_n + 1.001*v_t; // damping, amplifying, accumulate energy to escape the surface!\n                v = reflect(v,n);          // bound to surface\n            }    \n            else {\n                // ambient gradientfield --> velocity\n                g *= 4.* 50.* dt;\n                \n                // new particle velocity\n                v = v-g;\n                \n                v.xy = vec2(v.x - g.y\n                           ,v.y + g.x);\n                \n                v.yz = vec2(v.y - g.z\n                           ,v.z + g.y);\n                \n                v *= 0.99; // some drag while freeflying!\n            }\n            O.xyz = v;\n        }\n    }\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define EPS .001\n\nvec3 ro;\nvec3 rd;\n\nvec3 particle_coord[PARTICLES_NUM];\nvec3 particle_coord_prev[PARTICLES_NUM];\n\nvoid setOri() {\n    vec2 m = iMouse.xy / R;\n    ro = vec3(0, 0, -8);\n    ro.yz *= rot(-m.y* PI +1.);\n    ro.xz *= rot(-m.x*2.* PI );\n}\n\nvoid setDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n         r = normalize(cross(vec3(0,1,0), f)),\n         u = cross(f,r),\n         c = f*z,\n         i = c + uv.x*r + uv.y*u;\n    rd = normalize(i);\n}\n\nvec2 map(vec3 p) {\n    // max dist\n    float d = 1e5;\n    \n    // geometry    \n    d = min(d, map1(p, iTime)); float mat = 0.;\n    \n    // particles\n    for (int i = 0; i < PARTICLES_NUM; i++) {\n        //float dp = sdCapsule(p, particle_coord[i], particle_coord_prev[i], PARTICLE_RADIUS);\n        float dp = sdSphere( p - particle_coord[i], PARTICLE_RADIUS);\n        if (dp < d) {d = dp; mat = float(i)+1.;}\n    }           \n    return vec2(d, mat); // distance, 1.+particle_id\n}\n\nvec3 march(vec3 ro, vec3 rd, float z) {\t\n    float d = 0.;\n    int steps = 0;\n    float mat = 0.;\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = ro + rd * d;\n        vec2 m = map(p);\n        m.x *= .9 + .1 * hash(vec2(p.y, hash(p.xz)));\n        if (abs(m.x) < EPS || d > MAX_DIST) {\n            steps = i + 1;\n            mat = m.y; // particle_id\n            break;\n        }\n        d += m.x * 0.25;\n    }   \n    return vec3(min(d, MAX_DIST), steps, mat);\n}\n\nvec3 norm(vec3 p) {\n\tfloat d = map(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x);   \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 O, in vec2 px )\n{\n    vec2 uv = (px - 0.5 * R) / R.y;\n\t\n    setOri();\n    setDir(uv, ro, vec3(0), 1.);\n    \n    vec3 col = vec3(0);\n\n    for (int i = 0; i < PARTICLES_NUM; i++) {\n        particle_coord[i]      = texelFetch(iChannel0, ivec2(i, BUF_PARTICLE_POSITION), 0).xyz;\n        //particle_coord_prev[i] = texelFetch(iChannel0, ivec2(i, BUF_PARTICLE_POSITION_PREV), 0).xyz;\n    }  \n    \n    vec3 m = march(ro, rd, 1.);  \n    float d = m.x;    \n    vec3 p = ro + rd * d;\n\n    if (d<MAX_DIST) {        \n        vec3 n = norm(p); // normal\n        col = m.z == 0. ? vec3(0.5,0,0) \n            : m.z <= float(PARTICLES_NUM) ? h2rgb( (m.z-1.)/float(PARTICLES_NUM) )\n            : vec3(1,1,0); // TEST: color \n        \n         // fresnel\n         col += pow(clamp(1. - dot(n, -rd), 0., 1.), 5.) *vec3(1.); // from inside to conture\n    }  \n    // glow\n    col = max(col, vec3(1.-1./cosh(.01*m.y)));  // from inside && outside to conture\n    \n    \n    // gamma\n    col = sqrt(col);\n    \n    // motion blur (particle ghost tail)\n    #if 0\n    O = .94 * texelFetch(iChannel1, ivec2(px), 0);\n    O = max(O, vec4(col,1));\n    \n    #else\n    O = vec4(col,1);\n    #endif\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtVBDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 89]], "test": "untested"}
{"id": "mlVfWy", "name": "jon", "author": "jonis", "description": "cool", "tags": ["cineshader"], "likes": 1, "viewed": 895, "published": 3, "date": "1702464435", "time_retrieved": "2024-07-30T17:16:46.369675", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n    uv *= 1.0;    \n    uv = vec2(uv.x/iResolution.x,uv.y/iResolution.y);\n    uv = fract(uv);\n    \n    float d = length(uv-vec2(.5));\n    fragColor = texture(iChannel2,(uv-vec2(.5))*(1.+sin(d*80.-iTime*10.)*0.1)+vec2(0.5));\n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlVfWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 307]], "test": "untested"}
{"id": "dtVBDG", "name": "triangle area test", "author": "sheeptester", "description": "trying to figure out if I can get a distance of the triangle", "tags": ["triangle"], "likes": 0, "viewed": 131, "published": 3, "date": "1702454588", "time_retrieved": "2024-07-30T17:16:47.476715", "image_code": "const vec2 a = vec2(0.3, 0.3);\nconst vec2 b = vec2(0.7, 0.4);\nconst vec2 c = vec2(0.5, 0.7);\n\nfloat area(vec2 a, vec2 b, vec2 c)\n{\n    return cross(vec3(b - a, 0.0), vec3(c - a, 0.0)).z / 2.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = fragCoord / iResolution.xy;\n    //vec2 b = iMouse.xy;\n    float totalArea = area(a, b, c);\n    fragColor = vec4(area(p, b, c) / totalArea, area(a, p, c) / totalArea,\n                     area(a, b, p) / totalArea, 1.0);\n    if (sign(area(p, b, c)) == sign(area(a, p, c)) &&\n        sign(area(a, p, c)) == sign(area(a, b, p))) {\n        fragColor =\n            mix(fragColor, vec4(1, 1, 1, 1), (sin(iTime * 3.0) + 1.0) / 4.0);\n    }\n    if (iMouse.z > 0.0) {\n        //  fragColor =\n        //         mix(fragColor, vec4(1, 1, 0, 1), smoothstep(1.0, 0.0,\n        //         area(p, b, c) / totalArea+area(a, p, c) / totalArea+area(a, b, p) / totalArea));\n        fragColor = vec4(1.0 / ((abs(area(p, b, c)) + abs(area(a, p, c)) +\n                                 abs(area(a, b, p))) /\n                                totalArea),\n                         0.0, 0.0, 1.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtVBDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 130, 130, 194], [196, 196, 251, 251, 1142]], "test": "untested"}
{"id": "mttfWH", "name": "Ghost Noise", "author": "Real_NC", "description": "Playing around with additive/feedback sinusoidal noise", "tags": ["noise", "abstract", "sine"], "likes": 3, "viewed": 180, "published": 3, "date": "1702448918", "time_retrieved": "2024-07-30T17:16:48.394262", "image_code": "// iq hash modified for vec2\nconst uint k = 1103515245U;\n\nvec2 hash( uvec2 x)\n{\n    x = ((x>>8U)^x.yx)*k;\n    x = ((x>>8U)^x.yy)*k;\n    x = ((x>>8U)^x.xx)*k;\n    \n    return vec2(x)*(1.0/float(0xffffffffU));\n    //return hash(uvec3(x, 2)).xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y*8. + iTime*0.1;\n    uv -= uv.yx*0.25;\n    fragColor = vec4(0.2);\n    \n    for(int i = 0; i <= 16; i++)\n    {\n        vec2 h = hash(uvec2(i*3 + 104, 108 + i*4))*2. - 1.;\n        fragColor += cos(iTime*0.2 - dot(h,uv) * float(1+i))/float(1+i);\n        uv += fragColor.xy*0.3;\n    }\n    \n    fragColor *= 0.5;\n    fragColor *= fragColor;\n    fragColor += vec4(60,0,30,0)*pow(max(0.2-fragColor.x, 0.0), 3.);\n    //fragColor = abs(fragColor);\n    //fragColor = pow(fragColor, vec4(1./2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mttfWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 79, 79, 244], [246, 246, 303, 303, 829]], "test": "untested"}
{"id": "mlVBWG", "name": "Black and blue rug 2 (music)", "author": "jarble", "description": "A fractal rug pattern with an ornate design.\nIt looks even better with [url=https://www.shadertoy.com/view/4cXGzH]this color palette[/url].", "tags": ["fractal", "music", "mosaic", "rug", "sitar"], "likes": 7, "viewed": 235, "published": 3, "date": "1702447629", "time_retrieved": "2024-07-30T17:16:49.283884", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\n    float scale = 1.5;\n\n\nvoid transform(inout vec2 uv, inout vec2 t2, inout vec3 col,inout float c1){\n        uv.y -= 1./4.;\n        //uv.y -= sign(uv.x/4.-uv.y)/4.; //WOW!\n        \n        uv = (uv+t2)/scale;\n        \n        \n\n        uv = ((vec2(uv+vec2(.5,1.5))*scale)-.5)/scale;\n        \n        t2 = triangle_wave(uv+.5);\n        uv =\n            //t2-triangle_wave(uv.yx)+fract(t2/2.)\n            \n            //looks better with more iterations\n            t2/2.-triangle_wave(uv.yx)\n            //fract(t2*4.)/8.-triangle_wave(uv.yx)\n            //t2-triangle_wave(uv.yx)-fract(t2/2.)-vec2(floor(-uv.x),0.)\n        ;\n        \n        //green and gold\n        //{t2.x = (t2.x+sign(t2.y-.25)); }\n\n        \n        //{t2.x = (t2.x-sign(t2.y-t2.x)); }\n        //{t2.x = (t2.x+1.5*sign(t2.y-t2.x)); }\n        //{t2.x = (t2.x+1.*sign(t2.y-t2.x)); }\n\n        \n        //{uv.x = (uv.x+1.5*sign(uv.y-uv.x)); }\n\n}\n\nvec3 fractal(vec2 uv){\n    vec3 col = vec3(0.);\n    vec2 t2 = vec2(0.);\n    vec3 col1 = col;\n    float c1=0.;\n    for(int k = 0; k < 12; k++){\n        \n        vec2 uv_1 =\n            uv\n            //uv - fract(t2/2.)\n            //uv/2.\n        ;\n        vec2 t2_1 =\n            t2\n            //t2 - fract(t2/2.)\n            //t2*2.\n        ;\n        \n        transform(uv,t2,col,c1);\n        transform(uv_1,t2_1,col,c1);\n        \n        //uv_1 = triangle_wave((uv_1-.5)/1.5);\n        \n        c1 =\n            //max(abs(uv.y-uv.x*sign(uv.x-uv.y))/2.,c1)\n            //max(sign(uv_1.y+uv_1.x)/2.,c1)\n            max(abs(uv_1.y+uv_1.x)/2.,c1)\n        ;\n        c1 =\n            max(1.-abs(2.*c1-1.),c1/4.)\n            //max(1.-abs(2.*c1-1.),c1-.75)\n            \n            //more colorful\n            //abs(2.*c1-1.)\n            \n            //Spooky!\n            //max(abs(2.*c1-2.),c1/4.)/2.\n        ;\n        col.x =\n            max(length(uv_1-t2_1-c1)/3.,col.x)\n            \n            //blue and white\n            //c1\n            \n            //t2_1.x\n            //t2_1.y\n            \n            //red and blue and white\n            //max(1.-abs(2.*c1-1.),c1/4.)\n\n            \n            //more colorful\n            //max(length(uv-t2-c1)/3.,1.-col.x)\n            \n            //blue and green\n            //max(length(uv-c1)/3.,col.x)\n           \n            //purple\n            //2. - max((abs(uv.y-uv.x))/3.,col.x)\n           \n            //black and white\n            //col.x\n        ;\n        //if(uv.y<-.25)\n        //if(uv.y>-.25)\n        col =\n            abs(col-(1.-(c1*col.x)))\n            //1.-abs(col.yzx+c1*col.x)\n            //abs(col*c1-(1.-(col.x)))\n            //1.-abs(col-c1*col.x)\n            //c1*col.x-col\n        ;\n        col1 =\n            abs(col1*c1-col-1.).yzx\n        \n        \n            \n            //more like a mosaic\n            //abs(col1*c1-col*sign(t2.y-t2.x)-1.).yzx\n            \n            //abs(col1-col*c1-1.).yzx\n            //abs(col1*c1/2.-col).yzx*2.\n        ;\n        //k -= int(sign(uv.y-uv.x));\n    }\n    return col1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    float t1 = 6.;\n    \n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.xy += iTime/t1/12.;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec3 col1 = fractal(uv);\n    fragColor = vec4(col1/2.,1.0);\n}\n", "image_inputs": [], "sound_code": "//remix of https://www.shadertoy.com/view/mtSBzV\n\nint collatz(int initial, int steps){\n    //hailstone numbers\n    //makes some interesting rhythms\n    for(int i = 0; i < steps; i++){\n        if(initial%2==0) initial /= 2;\n        else initial = initial*3+1;\n    }\n    return initial;\n}\nfloat collatz(float initial, float steps){\n    return float(collatz(int(initial),int(steps)));\n}\n\nfloat mod1(float a,float b){\n    \n    //a += collatz(mod(a/4.,b),8.);\n    //a += collatz(mod(a/4.,8.),b);\n    \n    return\n        mod(a,b)\n        //mod(a+mod(a,b+3.),b)\n    ;\n}\n\nfloat fmod(float a, float b){\n    float\n    t1 = mod1(floor(b/2.),2.),\n    a1 =\n        floor(a+t1),\n    a0 =\n        a1\n        //a1+floor(a1/2.)*4.\n        //a1+floor(a1/4.)*3.+floor(a1/3.)*4.\n        //a1+mod(-a1/2.,3.)\n        //a1/2.\n        //a1/2.-(mod(floor(a1/4.),4.)-mod(floor(a1/2.),2.))*2.\n    ,a2 = mod1(a0,3.),\n    a3 =\n        mod1(a0,4.)\n    ;\n    return\n        mod1(a1-a2-a3,b)\n    ;\n}\n\nfloat prime_rhythm(float time){\n    return (1.+fmod(time/4.,2.))/(1.+fmod(time/2.,2.));\n}\n\nfloat fmod1(float a, float b){\n    //a += collatz(a/8./8.,b);\n    return fmod(a,b);\n}\n\n#define fract1(a) (1.-pow(fract(-a),2.))\n//#define fract1(a) (1.-pow(fract(-a),1.+fract(a)))\n\nvec2 synth_(vec2 a1,vec2 a,vec2 a2,vec2 a3,vec2 nb,vec2 a4){\n    return log(a1+a*abs(a2-abs(.5-a3*vec2(fract1(nb.x*.998),fract1(nb.y)))*a4));\n}\n#define synth(a1,a,a2,a3,nb,a4) synth_(vec2(a1),vec2(a),vec2(a2),vec2(a3),vec2(nb),vec2(a4))\n\nvec2 banjo(vec2 a, vec2 nb){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./6.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,6./4.));\n}\n\nvec2 harp(vec2 a, vec2 nb){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,2.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.));\n}\n\nvec2 synth_drum(vec2 a, vec2 nb,float m2){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./m2)\n  + synth(1./8.,a,1./4.,1.,nb*2.,m2/4.));\n}\n\nvec2 oud(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(.5+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      +.5*log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 steel_drum(vec2 a, vec2 nb){\nreturn a/16./4.*abs(synth(1./2.,a,1./8.,1.,nb*4.,1.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.))\n;\n}\n\nvec2 gamelan(vec2 a, vec2 nb){\nreturn\na/16./4.*abs(synth(1./4.,a,1./8.,1.,nb*2.,1./2.)\n  +.5*synth(1./4.,a,1./4.,1.,nb*2.,1./2.)) \n;\n}\n\nvec2 sitar(vec2 a, vec2 nb){\nreturn a/16./2.*abs(log(1./8.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  -log(1./16.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2./4.)));\n}\n\nvec2 sitar1(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      -log(1./4.+a*(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 sitar2(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+a*a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      -log(1./2.+(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 sitar3(vec2 a, vec2 nb){\nreturn a/16./4.*abs(log(1./2.+.5*a*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  -log(1./2.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n;\n}\n\nvec2 sitar5(vec2 a, vec2 nb){\n    return a/16./4.*abs(log(1./2.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n      -log(1./2.+a*a/2.*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n    ;\n}\n\nvec2 note1(vec2 t,float attack,float duration)\n{\n    return -vec2((log(attack+fract1(t.x)/2./duration)),(log(attack+fract1(t.y)/4./duration)));\n}\n\nvec2 mainSound1(int samp, float time,float scale,float duration){\n    \n  float\n  time1 =\n      time\n      //time+fmod(time,8.)\n      //time*2.\n  ,\n  s1 =\n      8.,\n  tempo1 =\n      prime_rhythm(time1)*prime_rhythm(time1/2.)*2.\n  ,t = s1*time/4./tempo1,\n  t4 = t/prime_rhythm(time1+11.)/(1.+fmod(t/8.,2.)),\n  t1 =\n       fmod(t4,2.)\n       //fmod(t4+floor(t4/2.),2.)\n       //fmod(t4+1.,2.)\n  ,\n  t5 =\n      t*2./prime_rhythm(time1+7.)\n      //t/(1.+t1)/prime_rhythm(time+7.)\n  ,\n  t3 =\n      (1.+fmod(t5,2.))\n      //(1.+fmod(t5+floor(t5/2.),2.))\n      //(1.+fmod(t5/(1.+t1),2.))\n  ,\n  t6 = time*8./t3,\n  m3 =\n      floor(fmod1(t6,s1/2.)/2.)\n      //floor(fmod1(t6+floor(t6/2.),s1/2.)/2.)\n      //floor(fmod1(t6+1.,s1/2.)/2.)\n  ,\n  m2 =\n      1. + fmod1(t/t3/2.,s1/2.)\n      //1. + fmod1(t/t3/2.+floor(t/t3/2./2.),s1/2.)\n      //1. + fmod1(t/t3/2.,s1/2.*t3)\n  ,note=\n      (m3+m2-t1*4.)/7.\n      //(m3+m2-t1*4.-fmod(time*2./tempo1,3.5)*2.)/7.\n  ,attack=1./64.*4.\n  ;\n  \n  vec2\n  rhythm = vec2(t/2./prime_rhythm(time+14.),t/prime_rhythm(time+7.))\n  ,\n  a=\n      note1(rhythm,attack,duration)\n      //duration/2.*note1(rhythm,attack,duration)\n      //note1(rhythm*2.,attack,duration)\n      //(note1(rhythm*2.,attack,duration).yx+note1(rhythm,attack,duration))/2.\n  ,\n  nb =\n      t*vec2(pow(2.,note+scale),pow(2.,note+scale))*tempo1\n      \n      //drum\n      //t*vec2(pow(2.,note-a.x/8.+scale-4.),pow(2.,note-a.x/8.+scale-4.))*tempo1\n\n  ;\n  //nb /= vec2(prime_rhythm(time+14.),prime_rhythm(time+7.));\n  return\n      //oud\n      oud(a,nb)\n      \n      //flute\n      //oud(a,nb)-oud(a,nb/2.)/2.-oud(a,nb/4.)/4.\n      \n      //oud(a,nb)+oud(a,nb/2.)/2.\n      \n      //oud(a,nb)*fract(-t)\n      \n      //sitar1(a,nb)\n      //sitar2(a,nb)\n      //sitar3(a,nb)\n      \n      \n      \n      //synth drum\n      //a/16./4.*abs(log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))*4.))\n      //+ log(1./8.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/4.)))\n  ;\n  \n}\n\nvec2 mainSound1(int samp, float time,float scale){\n    return mainSound1(samp,time,scale,1.);\n}\n\nvec2 violin(int a,float b,float c,float attack){\n    return\n        //sounds like violin (using sitar3)\n        (mainSound1(a,b*2.,5.+c,1./2.)-mainSound1(a,b*2.,5.+c,1./4.))\n        -(mainSound1(a,b*2.,4.+c,1./2.)-mainSound1(a,b*2.,4.+c,1./4.))\n    ;\n}\n\nvec2 mainSound(int a,float b){\n    float scale = 6.25;\n    return\n        //using sitar2\n        //(mainSound1(a,b,7.25,1./2.)-mainSound1(a,b,6.25,3./2.))\n        \n        //sounds like sitar (using oud)\n        8.*abs(mainSound1(a,b,scale,1./2.)-mainSound1(a,b,scale+1.,1.)/2.)\n        //8.*(mainSound1(a,b,scale,1./2.)-mainSound1(a,b,scale+1.,1.)/2.)\n\n        \n        //sounds like flute (using oud)\n        //2.*(mainSound1(a,b,scale+1.,1./2.)-mainSound1(a,b,scale+1.,1.))\n        \n        //sounds like sitar (using sitar5)\n        //violin(a,b/2.,1.25,1./64.*8.)\n\n        \n        \n        //sounds like violin (using sitar3)\n        //(mainSound1(a,b,6.25,1./2.)-mainSound1(a,b,6.25,1./4.))\n        //-(mainSound1(a,b,5.25,1./2.)-mainSound1(a,b,5.25,1./4.))\n    \n        //abs(mainSound1(a,b,6.5,1.)-mainSound1(a,b,6.5,2.)/2.)\n        \n        //sounds like sitar (using synth drum)\n        //abs(mainSound1(a,b,5.5,1./2.)-mainSound1(a,b,6.5,1.)/2.)\n        \n        //drum and bass\n        //abs(mainSound1(a,b/8.,7.25,1.)-mainSound1(a,b,7.25,1.))\n    \n        //violin (using sitar3)\n        //abs(mainSound1(a,b,6.,1.)-mainSound1(a,b,6.,1./2.))-abs(mainSound1(a,b,5.,1.)-mainSound1(a,b,5.,1./2.))\n\n        //black metal\n        //abs(mainSound1(a,b,scale,1./2.)-mainSound1(a,b,scale-.5,1./2.))\n\n    ;\n}\n", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlVBWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 129], [156, 156, 232, 232, 1043], [1045, 1045, 1067, 1067, 3132], [3134, 3134, 3191, 3191, 3451]], "test": "untested"}
{"id": "mtKBWG", "name": "HEPTANION transformation", "author": "ENDESGA", "description": "the goal was to compress a dual-quaternion down to 7 components instead of 8.\n\na \"heptanion\" can be blended with other heptanions\n\nclick to add a spinning transform to the heptanion applied to the gizmo", "tags": ["3d", "vector", "quaternion", "rotation", "transformation", "pga", "heptanion"], "likes": 4, "viewed": 236, "published": 3, "date": "1702446860", "time_retrieved": "2024-07-30T17:16:50.261271", "image_code": "// HEPTANION\n// compressing a dual-quaternion down to 7 elements\n// copyright @ENDESGA\n\n#define tau 6.283185307179586476925286766559\n\n// Euler Colourspace https://www.shadertoy.com/view/mtsBDl\n#define e (exp(1.))\n#define E(x) ((e - exp(1. - x)) / (e - 1.))\n\n#define quat vec4\n#define lquat vec3\n\nquat quat_add( quat a, quat b ) { return quat( a.xyz + b.xyz, a.w + b.w ); }\nquat quat_mul( quat a, quat b ) { return quat( a.w * b.xyz + b.w * a.xyz + cross( a.xyz, b.xyz ), a.w * b.w - dot( a.xyz, b.xyz ) ); }\n\nquat new_quat( vec3 axis, float angle )\n{\n\treturn quat( normalize( axis ) * sin( angle / 2. ), cos( angle / 2. ) );\n}\n\nlquat quat_to_lquat( quat q )\n{\n\tfloat a = acos( clamp( q.w, -1.0, 1.0 ) );\n\tfloat sina = sin( a );\n\tif( sina < .0001 ) return lquat( 0 );\n\treturn normalize( q.xyz ) * a;\n}\n\nquat lquat_to_quat( lquat lq )\n{\n\tfloat len = length( lq );\n\tif( len < .0001 ) return quat( 0, 0, 0, 1 );\n\treturn quat( normalize( lq ) * sin( len ), cos( len ) );\n}\n\n// the heptanion structure :: 3 + 4\nstruct hepta\n{\n\tlquat r;\n\tquat d;\n};\n\nlquat lquat_mul( lquat a, lquat b )\n{\n\tfloat l = length( a );\n\tquat q1 = quat( normalize( a ) * sin( l ), cos( l ) );\n\n\tl = length( b );\n\tvec3 axis2 = ( l < .0001 ) ? vec3( 0 ) : normalize( b );\n\tquat q2 = quat( axis2 * sin( l ), cos( l ) );\n\n\treturn normalize( q1.w * q2.xyz + q2.w * q1.xyz + cross( q1.xyz, q2.xyz ) ) *\n\t\tacos( clamp( q1.w * q2.w - dot( q1.xyz, q2.xyz ), -1.0, 1.0 ) );\n}\n\nhepta hepta_mul( hepta a, hepta b )\n{ // within functions the log-quat multiply can be simplied to a+b\n\treturn hepta( a.r + b.r, quat_add( quat_mul( lquat_to_quat( a.r ), b.d ), quat_mul( a.d, lquat_to_quat( b.r ) ) ) );\n}\n\nhepta hepta_trans( hepta a, hepta b )\n{\n\treturn hepta( lquat_mul( a.r, b.r ), quat_add( quat_mul( lquat_to_quat( a.r ), b.d ), quat_mul( a.d, lquat_to_quat( b.r ) ) ) );\n}\n\nvec3 vec_trans( vec3 p, hepta d )\n{\n\treturn hepta_mul( hepta_mul( d, hepta( lquat( 0 ), quat( p, 0 ) ) ), hepta( -d.r, quat( d.d.xyz, -d.d.w ) ) ).d.xyz;\n}\n\nhepta hepta_slerp( hepta dq1, hepta dq2, float t )\n{\n\tquat dq1r = lquat_to_quat( dq1.r );\n\tquat dq2r = lquat_to_quat( dq2.r );\n\n\tfloat dp = dot( dq1r, dq2r );\n\n\tif( dp < 0. )\n\t{\n\t\tdq1r = -dq1r;\n\t\tdq1.d = -dq1.d;\n\t\tdp = -dp;\n\t}\n\n\tfloat o = acos( clamp( dp, -1., 1. ) );\n\tfloat iso = 1./sin( o );\n\n\tif( iso > 10000. )\n\t{\n\t\tdq1r = mix( dq1r, dq2r, t );\n\t\tdq1.d = mix( dq1.d, dq2.d, t );\n\t}\n\telse\n\t{\n\t\tfloat s1 = sin( ( 1. - t ) * o ) * iso;\n\t\tfloat s2 = sin( t * o ) * iso;\n\n\t\tdq1r = s1 * dq1r + s2 * dq2r;\n\t\tdq1.d = s1 * dq1.d + s2 * dq2.d;\n\t}\n\n\tdq1.r = quat_to_lquat( dq1r );\n\n\treturn dq1;\n}\n\nhepta new_hepta_ypr( float yaw, float pitch, float roll, vec3 pos )\n{\n\tquat dir = quat_mul(\n\t\tnew_quat( vec3( 0, 0, 1 ), yaw ),\n\t\tquat_mul(\n            new_quat( vec3( 1, 0, 0 ), pitch ),\n\t\t\tnew_quat( vec3( 0, 1, 0 ), roll )\n\t\t)\n\t);\n\treturn hepta( quat_to_lquat( dir ), quat_mul( quat( pos, 0 ), dir ) * .5 );\n}\n\nhepta new_hepta( vec3 axis, float angle, vec3 pos )\n{\n\tquat dir = new_quat( axis, angle );\n\treturn hepta( quat_to_lquat( dir ), quat_mul( quat( pos, 0 ), dir ) * .5 );\n}\n\n//\n\nvec3 light_dir = vec3( 0 );\n\nvoid sphere( vec3 ro, vec3 rd, vec3 pos, float rad, vec3 rgb, inout vec4 rgbd )\n{\n\tvec3 oc = ro - pos;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - rad * rad;\n\tfloat h = b * b - c;\n\tif( h < 0. ) return;\n\n\th = sqrt( h );\n\tfloat t = -b - h;\n\tvec3 p = ro + t * rd;\n\tvec3 normal = normalize( p - pos );\n\n\tfloat diff = max( dot( normal, light_dir ), .2 );\n\tfloat d = 1. - ( 1. / distance( ro, p ) );\n\tif( d <= rgbd.w )\n\t{\n\t\trgbd.w = d;\n\t\trgbd.rgb = diff * rgb;\n\t}\n}\n\nvoid cylinder( vec3 ro, vec3 rd, vec3 pos_a, vec3 pos_b, float rad, vec3 rgb, inout vec4 rgbd )\n{\n\tvec3 ba = pos_b - pos_a;\n\tvec3 oa = ro - pos_a;\n\tvec3 ob = ro - pos_b;\n\n\tvec3 m0 = cross( rd, ba );\n\tvec3 m1 = cross( oa, ba );\n\tfloat md = dot( m0, m0 );\n\tfloat b = 2. * dot( m0, m1 );\n\tfloat bd = dot( ba, ba );\n\n\tfloat h = b * b - 4. * md * ( dot( m1, m1 ) - rad * rad * bd );\n\tif( h < 0. ) return;\n\n\th = sqrt( h );\n\tfloat t = ( -b - h ) / ( 2. * md );\n\tfloat y = dot( oa, ba ) + t * dot( rd, ba );\n\n\tif( y > 0. && y < bd )\n\t{\n\t\tvec3 p = ro + rd * t;\n\t\tfloat d = 1. - ( 1. / distance( ro, p ) );\n\t\tif( d <= rgbd.w )\n\t\t{\n\t\t\trgbd.w = d;\n\t\t\trgbd.rgb = max( dot( normalize( p - ( pos_a + ba * y / bd ) ), light_dir ), .2 ) * rgb;\n\t\t}\n\t}\n}\n\nvec4 hash( float n )\n{\n\tvec4 x = fract( sin( vec4( n + 1., n + 3., n + 5., n + 7. ) ) * 43758.5453 );\n\treturn 2. * x - 1.;\n}\n\nvoid mainImage( out vec4 C, in vec2 F, in float T )\n{\n\tfloat time = T;\n\tvec2 uv = ( F - iResolution.xy * .5 ) / iResolution.y;\n\tvec3 ro = vec3(cos(T * -.25) * 3.0, sin(T * -.25) * 3.0, 0.0);\n    vec3 center_dir = normalize(-ro);\n\n    vec3 right = normalize(cross(center_dir, vec3(0.0, 0.0, 1.0)));\n\n    float scale = tan(tau*.125);\n\n    vec3 rd = normalize(uv.x * scale * right + center_dir + uv.y * scale * vec3(0,0,1));\n\n\n\tlight_dir = normalize((-rd + ( vec3( -1, -1, 1 ) )) * .5);\n\n\t//\n\n    vec3 tlogquat00 = normalize( hash( floor( time ) ).xyz );\n    vec3 tlogquat0 = normalize( hash( floor( time ) + 1.).xyz );\n\tvec3 tlogquat1 = normalize( hash( floor( time ) + 2.).xyz );\n\tvec3 tlogquat2 = normalize( hash( floor( time ) + 3. ).xyz );\n\tvec3 tlogquat3 = normalize( hash( floor( time ) + 4. ).xyz );\n    vec3 tlogquat4 = normalize( hash( floor( time ) + 5. ).xyz );\n    vec3 tlogquat5 = normalize( hash( floor( time ) + 6.).xyz );\n    \n    vec3 logquat0 = (tlogquat00 + tlogquat1) * tau;\n    vec3 logquat1 = (tlogquat0 +  tlogquat2) * tau;\n    vec3 logquat2 = (tlogquat1 +  tlogquat3) * tau;\n    vec3 logquat3 = (tlogquat2 +  tlogquat4) * tau;\n    vec3 logquat4 = (tlogquat3 +  tlogquat5) * tau;\n    \n    vec3 tpos00 = normalize( hash( floor( time ) ).xyz );\n    vec3 tpos0 = normalize( hash( floor( time ) + 1. ).xyz );\n\tvec3 tpos1 = normalize( hash( floor( time ) + 2. ).xyz );\n\tvec3 tpos2 = normalize( hash( floor( time ) + 3. ).xyz );\n\tvec3 tpos3 = normalize( hash( floor( time ) + 4. ).xyz );\n    vec3 tpos4 = normalize( hash( floor( time ) + 5. ).xyz );\n    vec3 tpos5 = normalize( hash( floor( time ) + 6. ).xyz );\n    \n    vec3 pos0 = (tpos00 + tpos0 + tpos1) * .5;\n    vec3 pos1 = (tpos0 + tpos1 + tpos2) * .5;\n    vec3 pos2 = (tpos1 + tpos2 + tpos3) * .5;\n    vec3 pos3 = (tpos2 + tpos3 + tpos4) * .5;\n    vec3 pos4 = (tpos3 + tpos4 + tpos5) * .5;\n\n    hepta tdq0 = new_hepta_ypr( logquat0.x, logquat0.y, logquat0.z, pos0 );\n\thepta tdq1 = new_hepta_ypr( logquat1.x, logquat1.y, logquat1.z, pos1 );\n\thepta tdq2 = new_hepta_ypr( logquat2.x, logquat2.y, logquat2.z, pos2 );\n\thepta tdq3 = new_hepta_ypr( logquat3.x, logquat3.y, logquat3.z, pos3 );\n    hepta tdq4 = new_hepta_ypr( logquat4.x, logquat4.y, logquat4.z, pos4 );\n    \n    hepta dq1 = hepta_slerp( tdq0, tdq2, .5 );\n    hepta dq2 = hepta_slerp( tdq1, tdq3, .5 );\n    hepta dq3 = hepta_slerp( tdq2, tdq4, .5 );\n\n\tfloat smoothtime = (mod(time, 1.) + smoothstep( 0., 1., fract( time ) )) * .5;\n\n\thepta h1 = hepta_slerp(dq1, dq2, smoothtime);\n\thepta h15 = hepta_slerp( dq2, dq3, smoothtime * .5 );\n\thepta h2 = hepta_slerp( dq2, dq3, smoothtime );\n\n\tif( iMouse.z > 0. ) h1 = hepta_trans( h1, new_hepta( vec3( 1 ), time * 12., vec3( 0 ) ) );\n\n\tvec4 rgbd = vec4( 0, 0, 0, 1 );\n\n\tvec3 s1 = vec_trans( vec3( 0 ), h1 );\n\tvec3 s15 = vec_trans( vec3( 0 ), h15 );\n\tvec3 s2 = vec_trans( vec3( 0 ), h2 );\n\n\tvec3 ds1 = vec_trans( vec3( 0 ), dq1 );\n\tvec3 ds2 = vec_trans( vec3( 0 ), dq2 );\n\tvec3 ds3 = vec_trans( vec3( 0 ), dq3 );\n\n    vec3 ds15 = mix( ds1, ds2, smoothtime );\n\n\tsphere( ro, rd, ds15, .00625, vec3( 1, 1, 0 ), rgbd );\n\tcylinder( ro, rd, ds15, ds2, .0125, vec3( 1, 1, 0 ), rgbd );\n\tsphere( ro, rd, ds2, .025, vec3( 1, 1, 0 ), rgbd );\n\n\tcylinder( ro, rd, s1, ds15, .0125, vec3( 1, 1, 0 ), rgbd );\n\tsphere( ro, rd, ds15, .0125, vec3( 1, 1, 0 ), rgbd );\n\n\tcylinder( ro, rd, ds2, s15, .00625, vec3( 1, 0, 1 ), rgbd );\n\tsphere( ro, rd, s15, .00625, vec3( 1, 0, 1 ), rgbd );\n\tcylinder( ro, rd, s15, s2, .00625, vec3( 1, 0, 1 ), rgbd );\n\tsphere( ro, rd, s2, .00625, vec3( 1, 0, 1 ), rgbd );\n\n\tsphere( ro, rd, ds3, .025, vec3( 1,0,1 ), rgbd );\n\n\t//\n\n\tsphere( ro, rd, s1, .15, vec3( 1 ), rgbd );\n    \n    {\n        vec3 sx = vec_trans( vec3( .25, 0, 0 ), dq2 );\n        cylinder( ro, rd, ds2, sx, .0125, vec3( 1, 0, 0 ), rgbd );\n        sphere( ro, rd, sx, .025, vec3( 1., 0, 0 ), rgbd );\n\n        vec3 sy = vec_trans( vec3( 0, .25, 0 ), dq2 );\n        cylinder( ro, rd, ds2, sy, .0125, vec3( 0, 1, 0 ), rgbd );\n        sphere( ro, rd, sy, .025, vec3( 0, 1, 0 ), rgbd );\n\n        vec3 sz = vec_trans( vec3( 0, 0, .25 ), dq2 );\n        cylinder( ro, rd, ds2, sz, .0125, vec3( 0, 0, 1 ), rgbd );\n        sphere( ro, rd, sz, .025, vec3( 0, 0, 1 ), rgbd );\n    }\n\n    {\n        vec3 sx = vec_trans( vec3( .5, 0, 0 ), h1 );\n        cylinder( ro, rd, s1, sx, .05, vec3( 1, 0, 0 ), rgbd );\n        sphere( ro, rd, sx, .075, vec3( 1., 0, 0 ), rgbd );\n\n        vec3 sy = vec_trans( vec3( 0, .5, 0 ), h1 );\n        cylinder( ro, rd, s1, sy, .05, vec3( 0, 1, 0 ), rgbd );\n        sphere( ro, rd, sy, .075, vec3( 0, 1, 0 ), rgbd );\n\n        vec3 sz = vec_trans( vec3( 0, 0, .5 ), h1 );\n        cylinder( ro, rd, s1, sz, .05, vec3( 0, 0, 1 ), rgbd );\n        sphere( ro, rd, sz, .075, vec3( 0, 0, 1 ), rgbd );\n    }\n\n\t//\n\n\tC = vec4( E(rgbd.rgb), 1.0 );\n}\n", "image_inputs": [], "common_code": "int _N = 3;\n#define mainImage mainImage0(out vec4 O, vec2 U, float T);        \\\nvoid mainImage(out vec4 O, vec2 U) {                     \\\n    vec4 o; O = vec4(0);                                 \\\n    for (int k=0; k < _N*_N; k++ )                       \\\n      { mainImage0(o,U+vec2(k%_N-_N/2,k/_N-_N/2)/float(_N),iTime+sqrt(float(k)*.0001)); O += o; }  \\\n    O /= float(_N*_N);                                   \\\n} \\\nvoid mainImage0", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtKBWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[296, 296, 329, 329, 372], [373, 373, 406, 406, 507], [509, 509, 550, 550, 626], [628, 628, 659, 659, 800], [802, 802, 834, 834, 967], [1043, 1043, 1080, 1080, 1433], [1435, 1435, 1472, 1537, 1657], [1659, 1659, 1698, 1698, 1830], [1832, 1832, 1867, 1867, 1987], [1989, 1989, 2041, 2041, 2579], [2581, 2581, 2650, 2650, 2892], [2894, 2894, 2947, 2947, 3063], [3098, 3098, 3179, 3179, 3566], [3568, 3568, 3665, 3665, 4303], [4305, 4305, 4327, 4327, 4429], [4431, 4431, 4484, 4484, 9232]], "test": "untested"}
{"id": "DlVfDG", "name": "Blue and white rug 3", "author": "jarble", "description": "A fractal rug pattern with an ornate design.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 5, "viewed": 229, "published": 3, "date": "1702437251", "time_retrieved": "2024-07-30T17:16:51.219708", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nfloat scale = 1.5;\n\nvoid transform(inout vec2 uv, inout vec2 t2, inout vec3 col,inout float c1){\n        uv.y -= 1./4.;\n        \n        uv = (uv+t2)/scale;\n        \n        uv = ((vec2(uv+vec2(.5,1.5))*scale)-.5)/scale;\n        \n        t2 = triangle_wave(uv-.5);\n        uv =\n            //t2-triangle_wave(uv.yx)+fract(t2/2.)\n            \n            //looks better with more iterations\n            t2/2.-triangle_wave(uv.yx) //-vec2(floor(uv.y),0.)\n        ;\n        \n        //WOW!\n        //{uv = (uv+sign(uv-.25)); t2 = (uv+sign(t2-.25)); }\n        \n        //{t2.x = (t2.x+1.*sign(t2.y-t2.x)); }\n\n        //{t2.x = (t2.x+1.5*sign(t2.y-t2.x)); }\n        //{uv.x = (uv.x+1.5*sign(uv.y-uv.x)); }\n\n}\n\nvec3 fractal(vec2 uv){\n    vec3 col = vec3(0.);\n    vec2 t2 = vec2(0.);\n    vec3 col1 = col;\n    float c1=0.;\n    for(int k = 0; k < 12; k++){\n    \n        vec2 uv_1 =\n            uv\n            //uv/2.\n            //uv+sin(uv.x/4.)*4.+1.;\n            //uv*2.\n            //uv/2.+vec2(sin(uv.y*2.),cos(uv.x*2.))\n        ;\n        vec2 t2_1 =\n            t2\n            //t2*2.\n            //t2*2.\n            //t2/2. + vec2(sin(uv.y*2.),cos(uv.x*2.))\n            //sin(uv*2.)/2.\n        ;\n        \n        transform(uv,t2,col,c1);\n        transform(uv_1,t2_1,col,c1);\n        uv_1 =\n            uv\n            //triangle_wave((uv_1-.5)*1.5)+triangle_wave((uv_1.yx)/1.5)\n        ;\n\n        \n        c1 =\n            //max(abs(uv.y-uv.x*sign(uv.x-uv.y))/2.,c1)\n            max(abs(uv_1.y-uv_1.x)/2.,c1)\n        ;\n        c1 =\n            max(abs(2.*c1-1.),c1/4.)\n            \n            //more colorful\n            //abs(2.*c1-1.)\n            \n            //Spooky!\n            //max(abs(2.*c1-2.),c1/4.)/2.\n        ;\n        col.x =\n            //max(max(length(uv-t2-c1),abs(uv.y-uv.x))/3.,col.x)\n            max(max(length(uv_1-t2_1-c1),abs(uv_1.y-uv_1.x)),col.x)/3.\n           \n            //even more colorful   \n            //2.-max(max(length(uv-t2-c1),abs(uv.y-uv.x))/3.,col.x)\n\n            //blue and gold\n            //2. - max((abs(uv.y-uv.x))/3.,col.x)\n           \n            //black and white\n            //col.x\n        ;\n        //if(uv.x<-.25)\n        col =\n            abs(col-(1.-(c1*col.x)))\n            //abs(col*c1-(1.-(col.x)))\n            //1.-abs(col-c1*col.x)\n        ;\n        col1 =\n            abs(col1*c1-col-1.).yzx\n            \n            //more colorful\n            //abs(col1-col-1.).yzx\n            \n            //more like a mosaic\n            //abs(col1*c1+col*sign(t2.y-t2.x)-1.).yzx\n            //abs(col1*c1+col+sign(t2.y-t2.x)).yzx\n            \n            //abs(col1-col*c1-1.).yzx\n            //abs(col1*c1/2.-col).yzx*2.\n        ;\n        //k -= int(sign(uv.y-uv.x));\n        //t2 += fract(t2/2.);\n    }\n    return col1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    float t1 = 6.;\n    \n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.xy += iTime/t1/12.;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec3 col1 = fractal(uv);\n    fragColor = vec4(col1/2.,1.0);\n}\n", "image_inputs": [], "sound_code": "float mod1(float a, float b){\n    return\n        mod(a,b)\n        //mod(a+mod(a,b+3.),b)\n    ;\n}\n\nvoid distort(inout float a, inout float b){\n    for(float i = 1.; i < mod(floor(a/b),3.); i++){\n        //a /=2.0;\n        //a /=1.0+mod(floor(a),2.);\n        a += mod1(floor(a/2.),b)*i;\n    }\n}\n\nfloat fmod(float a, float b){\n    //distort(a,b);\n    \n    //the modulus should be a prime number\n    //this makes some interesting rhythms\n    float modulus =\n        //3.\n        5.\n        //7.\n    ;\n    for(float i = 1.; i < mod(floor(a/b),modulus); i++){\n        a += mod(floor(a/2.),b)*i;\n    }\n    float a1 = a;\n    return\n        mod(floor(a),b)\n    ;\n}\n\n#define fract1(a) pow(fract(a),1.+log(2.)-log(1.+fract(a)))\n\nvec2 synth(float a1,vec2 a,float a2,float a3,vec2 nb,float a4){\n    return log(a1+a*abs(a2-a3*abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))*a4));\n}\n\nvec2 banjo(vec2 a, vec2 nb){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./6.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,6./4.));\n}\n\nvec2 harp(vec2 a, vec2 nb){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,2.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.));\n}\n\nvec2 synth_drum(vec2 a, vec2 nb,float m2){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./m2)\n  + synth(1./8.,a,1./4.,1.,nb*2.,m2/4.));\n}\n\nvec2 oud(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(.5+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      +.5*log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 steel_drum(vec2 a, vec2 nb){\nreturn a/16./4.*abs(synth(1./2.,a,1./8.,1.,nb*4.,1.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.))\n;\n}\n\nvec2 gamelan(vec2 a, vec2 nb){\nreturn\na/16./4.*abs(log(1./4.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  +.5*log(1./4.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n;\n}\n\nvec2 sitar5(vec2 a, vec2 nb){\n    return a*a/16./4.*abs((abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n      -(a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n    ;\n}\n\nvec2 mainSound1(int samp, float time,float scale,float duration){\n  float tempo = .25;\n  time /= tempo;\n  float s1 =\n      8.;\n  vec3\n  rhythm =\n      vec3(1.)\n      \n      //more rhythms here!\n      //vec3(2.,1.,1.)\n      //vec3(2.)\n      //vec3(2.,2.,1.)\n  ;\n  for(float i = 1.; i < mod(floor(time),5.); i++){\n      time += mod(floor(time*2./rhythm.x),s1)*i;\n      time /= 1.+fmod(floor(time/rhythm.y)*2.,2.);\n      tempo *= 1.+fmod(floor(time/rhythm.z)*2.,2.);\n  }\n  float s2 = 8.,\n  t=\n      time,\n  m1 =\n      fmod(t,s2)\n      //fmod(t+fmod(t/2.,s2*2.),s2)\n  ,\n  m4=fmod(t/8.,2.),\n  m3 =\n      fmod(t,1.+m1)+m4\n  ;\n  t /=\n      (1.+fmod(t/s1,2.))*4./s1/s1\n  ;\n  float m2 =\n      1. + fmod(t/s1,s1)\n  ,note=floor((m3+m2)/2.)/5.\n  ,attack\n  =\n      //1./64./4.\n      1./64.\n  ;\n  vec2 a=\n      //vec2((1.-sqrt(fract(t/s1)/1.25))*.2)\n      -vec2((log(attack+fract1(t/s1)/8./duration)))\n\n      //pow(1.-log(1./16./2.+fract(t/s1)/4.),2.)\n  ,\n  nb =\n      vec2(time*tempo*pow(2.,note+scale))\n      \n      //scratching\n      //vec2(time*tempo*pow(2.,note-a.x/128./2.+scale))\n  ;\n  vec2 \n  sitar =\n      //log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y*2.)))/2.)),\n      sitar5(a,nb)\n  ,gamelan = gamelan(a,nb)\n  ,steel_drum = a/16./4.*abs(log(1./2.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))))\n  + log(1./8.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.)))      \n  ,oud = oud(a,nb)\n  ,synth_drum = a/16./4.*abs(log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))*4.))\n  + log(1./8.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/4.)))\n  ,synth_drum1 = a/16./4.*abs(log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))*4./m2))\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./4.))\n  ,harp = harp(a,nb)\n  ,banjo = a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./6.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,6./4.))\n\n\n\n  ;\n  return\n      //oud\n      //synth_drum\n      //abs(gamelan-synth_drum1*2.)\n      //harp\n      //abs(gamelan-synth_drum1/2.)\n      \n      //sitar\n      abs(gamelan/2.-oud*2.)*2.\n\n      //abs(gamelan-oud*3.)/3.\n      \n      //abs(gamelan-steel_drum/4.)\n      \n      \n      //oud\n      //abs(.5-vec2(fract(nb.x*.998*2.),fract(nb.y)))*a\n      \n      \n      //log(abs(a/4.-2.*abs(.5-vec2(fract(nb*.998*2.),fract(nb*2.)))*a))\n\n      //log(abs(a/8.-abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a))\n  ;\n}\n\nvec2 mainSound(int samp, float time){\n    float scale = 5.;\n    return\n        mainSound1(samp,time,scale,1./2.)-mainSound1(samp,time,scale+1.,1./2.)\n        \n        //using sitar2\n        //(mainSound1(samp,time,7.25,1./2.)-mainSound1(samp,time,6.25,3./2.))\n        \n        //sounds like violin (using sitar3)\n        //(mainSound1(samp,time,5.5,1./2.)-mainSound1(samp,time,5.5,1./4.))\n        //-(mainSound1(samp,time,4.5,1./2.)-mainSound1(samp,time,4.5,1./4.))\n\n        \n        //sqrt(mainSound1(samp,time,4.5,1.)*mainSound1(samp,time,5.5,1.))\n        \n        //abs(mainSound1(samp,time,4.5,1.)-mainSound1(samp,time,5.5,2.))\n        //2.*abs(mainSound1(samp,time,7.,4.)/2.-mainSound1(samp,time,6.,1.))\n\n    ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlVfDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 129], [151, 151, 227, 227, 834], [836, 836, 858, 858, 2902], [2904, 2904, 2961, 2961, 3221]], "test": "untested"}
{"id": "dtGBDG", "name": "MC Ripple Pool 2", "author": "Real_NC", "description": "Use the mouse to agitate the wave.", "tags": ["wave", "simulation", "feedback", "montecarlo", "ripple"], "likes": 3, "viewed": 187, "published": 3, "date": "1702424103", "time_retrieved": "2024-07-30T17:16:51.997627", "image_code": "void mainImage( out vec4 O, in vec2 U )\n{\n    O = tex(U).rrrr;\n    O.g *= sign(O.r)*.2+.8;\n    O = pow(abs(O)*22., vec4(.6));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Here red channel stores value and green channel stores delta\n\n#define DMPG 0.99\n#define RC(r) vec2(cos(r.x*6.2831853), sin(r.x*6.2831853))*sqrt(r.y)\n#define SAMPLES 80.\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    O *= 0.;\n    \n    if(iFrame > 0)\n    {\n        O = tex(U);\n        \n        // mouse monopole\n        if(length((iMouse.xy - U)/R.y) <= .01 && iMouse.z > 0.5) O.g = cos(iTime*16.)*6.;\n        \n        // starting dipole\n        if(length((U + U - R.xy)/R.y + vec2(0.4, 0.0)) <= .05) O.g = cos(iTime*16.1);\n        if(length((U + U - R.xy)/R.y - vec2(0.4, 0.0)) <= .05) O.g = cos(iTime*16.);\n        \n        \n        float v = 0.;\n        for(float n = 0.; n < SAMPLES; n++)\n        {\n            vec2 t = tex(U + R.y*.03*RC(pcg2(U + n*R.xy + float(iFrame*10)))).rg;\n            v += t.r + t.g - O.r - O.g*DMPG;\n        }\n        O.g += v/SAMPLES;\n        O.rg *= vec2(DMPG, DMPG); // damp\n        O.r += O.g; // change wave value by delta\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define tex(u) texelFetch(iChannel0, ivec2(u), 0)\n#define R iResolution\n\n// https://www.pcg-random.org/\nvec2 pcg2(vec2 p)\n{\n    uvec2 v = floatBitsToUint(p);// modified to accept float\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return vec2(v)*(1.0/float(0xffffffffU)); // modified to return float\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtGBDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 127]], "test": "untested"}
{"id": "mtGfDG", "name": "hypnodot", "author": "joshsundby", "description": "pulsing ball", "tags": ["basic", "hypnotic"], "likes": 0, "viewed": 110, "published": 3, "date": "1702422687", "time_retrieved": "2024-07-30T17:16:52.755601", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Time variable for pulsation effect\n    float time = sin(iTime * 0.5) * 0.5 + 0.5;\n\n    // Sphere parameters\n    float radius = 0.3 * time; // Radius varies with time for pulsation\n    vec3 sphereColor = vec3(1.0, 0.4, 0.3); // Warm color for the sphere\n\n    // Drawing the sphere\n    float dist = length(uv);\n    float sphere = smoothstep(radius, radius - 0.01, dist);\n\n    // Background color\n    vec3 bgColor = vec3(0.1, 0.1, 0.1); // Dark background for contrast\n\n    // Combining sphere and background\n    vec3 color = mix(sphereColor, bgColor, sphere);\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtGfDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 800]], "test": "untested"}
{"id": "mtGfWG", "name": "Stars and planets", "author": "vortmax", "description": "dummy desc)", "tags": ["dummytag"], "likes": 3, "viewed": 183, "published": 3, "date": "1702420521", "time_retrieved": "2024-07-30T17:16:53.523547", "image_code": "vec2 screen2uv(vec2 glCoord, vec2 glRes);\nvec2 angle2vec(float angle);\nvec2 angle2vec(float angle, float cx, float cy);\nvec3 rgb(int r, int g, int b);\n\nvec2 screen2uv(vec2 glCoord, vec2 glRes)\n{\n    return (glCoord.xy * 2.0 - glRes.xy) / glRes.y; \n}\n\nvec2 angle2vec(float angle, float cx, float cy)\n{\n    return vec2(cos(cx * angle), sin(cy * angle));\n}\n\nvec2 angle2vec(float angle)\n{\n    return angle2vec(angle, 1.0, 1.0);\n}\n\n\nvec3 rgb(int r, int g, int b)\n{\n    return vec3(r, g, b) / 255.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = screen2uv(fragCoord.xy, iResolution.xy); \n    vec2 uvM = screen2uv(iMouse.xy, iResolution.xy);\n    float t = iTime;\n    \n    vec3 finalColor = vec3(0.0);\n    vec2 uv = uv0 - uvM;    \n    \n    //star data\n    float starCount = 10.0;\n    float starRadius = 0.1;\n    float starOrbitRadius = 1.0;\n    float starSpeedScale = 0.5;\n    vec3 starCol = rgb(200, 200, 15);\n    \n    //planet data\n    float planetCount = 10.0;\n    float planetRadius = 0.05;\n    float planetOrbitRadius = 0.2;\n    float planetSpeedScale = 0.6;\n    vec3 planetCol = rgb(15, 190, 190);\n    \n    \n    //orbit pos - uv (0,0 center); \n    vec2 starOrbitPos = uv;\n\n    for(float i = 1.0; i <= starCount; ++i)\n    {\n        float starShift = radians(360.0 * i / starCount);\n        vec2 starOrbitVector = angle2vec(t * starSpeedScale + starShift) * starOrbitRadius;\n        vec2 starPos = starOrbitPos + starOrbitVector;\n        \n        float dStar = length(starPos);\n        \n        dStar = step(dStar, starRadius);\n        \n        finalColor += dStar * starCol;\n        \n\n        //orbit pos - starPos (star center); \n        vec2 planetOrbitPos = starPos;\n\n        for(float j = 1.0; j <= planetCount; ++j)\n        {\n            float planetShift = radians(360.0 * j / planetCount);\n            vec2 planetOrbitVector = angle2vec(-t * planetSpeedScale + planetShift) * planetOrbitRadius;\n            vec2 planetPos = planetOrbitPos + planetOrbitVector;\n            \n            float dPlanet = length(planetPos);\n\n            dPlanet = step(dPlanet, planetRadius);\n\n            \n            finalColor += dPlanet * planetCol;\n        } \n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtGfWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 152, 194, 194, 249], [251, 251, 300, 300, 353], [355, 355, 384, 384, 425], [428, 428, 459, 459, 495], [497, 497, 554, 554, 2229]], "test": "untested"}
{"id": "dtyBWG", "name": "Basic Voronoi Water", "author": "mgmbass", "description": "Slight variation on a basic voronoi pattern. Kind of looks like water from old Zelda games :)", "tags": ["voronoi"], "likes": 8, "viewed": 213, "published": 3, "date": "1702419225", "time_retrieved": "2024-07-30T17:16:54.366294", "image_code": "vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(0.670,0.330))))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(0.129,0.454,0.925);\n\n    // Scale\n    st *= 3.;\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 1.;  // minimum distance\n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            // Random position from current + neighbor place in the grid\n            vec2 point = random2(i_st + neighbor);\n\n\t\t\t// Animate the point\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n\n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point - f_st;\n\n            // Distance to the point\n            float dist = length(diff);\n\n            // Keep the closer distance\n            m_dist = min(m_dist, dist * m_dist);\n        }\n    }\n\n    // Draw the min distance (distance field)\n    color += m_dist;\n\n    // Show isolines\n     color += step(0.988,abs(sin(30.*m_dist)))*.5;\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtyBWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 117], [119, 119, 176, 176, 1284]], "test": "untested"}
{"id": "ctyBDy", "name": "Audio Shader: drum machine [WIP]", "author": "jakel101", "description": "I am learning to write audio shaders, inspiration from: https://youtu.be/3mteFftC7fE and https://youtu.be/zbBY7JL9nnQ", "tags": ["audio", "learning"], "likes": 1, "viewed": 185, "published": 3, "date": "1702415786", "time_retrieved": "2024-07-30T17:16:55.198070", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 -1.0;\n\n    \n    vec2 field = 3.0* vec2(uv.x*fract(-iTime*.5), uv.y -abs(sin(iTime*4.0))+1.0);\n    // fold it?\n    field *= 3.5* mod(abs(field), .5);\n    field.x /= 2.0*uv.x;\n    \n    vec3 col = vec3(0.0);\n    col.r += abs(field.y*field.x)*abs(sin(iTime/.2)+0.5);\n    col.g += abs(field.y*field.x)*abs(sin(iTime/.25)+0.3);\n    col.b += abs(field.y*field.x)*sin(iTime+1.25/.5)-0.1;\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "#define TAU 6.2831\n\n// helpers\nfloat hash21(float a, float b){\n    return fract((a*5.421)*(b+2.876)*b);\n}\n\nfloat noise1(float s, float t){\n    return mix(hash21(s, s*s), hash21(2.0*s, -1.0), abs(sin(t)));\n}\n\n//instruments\nfloat bell(float f, float a, float t){\n    return a*sin(TAU*f*t)*exp(-5.0*t);\n}\n\nfloat snare(float f, float a, float t, float d){\n    return a*sin(exp(-TAU*t*f))*exp(-d*t)*noise1(f,t);\n}\n\nfloat triangle(float f, float a, float t){\n    return (a*abs(4.0*f*mod(t,1.0/f)-2.0)-1.0)*exp(-7.0*t);\n}\n\n\n\nvec2 mainSound( int samp, float time )\n{\n    \n    // add on to this for a lazy mix\n    vec2 sig = vec2(0.0);\n    \n    sig += vec2(bell(660.0, 0.5, mod(time + 1.25, 2.0)));    \n    sig += vec2(bell(440.0, 0.3, mod(time + 1.00, 2.0)));\n    \n    \n    sig += vec2(triangle(22.0, .6, mod(time, 0.5)));\n    \n    sig += vec2(triangle(33.0, .8, mod(time, 2.0)));\n    \n    sig += vec2(snare(4.0, 0.3, mod(time + 1.75, 2.0), 1.0));\n    \n    \n    return sig;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctyBDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 545]], "test": "untested"}
{"id": "mlKfzd", "name": "4D SHARD NOISE", "author": "ENDESGA", "description": "a 4D version of my Shard Noise.\n---\nusing the splat-field (upgraded to 3D) to inject the tanh function, giving a unique metallic structure.\n'sharpness' parameter can be any value.\nclick to show the full octave-blend that's very perlin-like", "tags": ["3d", "noise", "gradient", "shard"], "likes": 8, "viewed": 341, "published": 3, "date": "1702408442", "time_retrieved": "2024-07-30T17:16:56.015884", "image_code": "#define R iResolution\n#define T (iTime * .1)\n\nvec4 hash(vec4 p) {\n    p = vec4(dot(p, vec4(127.1, 311.7, 74.7, 24.6)), \n             dot(p, vec4(269.5, 183.3, 246.1, 123.5)), \n             dot(p, vec4(113.5, 271.9, 124.6, 223.8)),\n             dot(p, vec4(222.3, 145.2, 211.3, 239.5)));\n    p = fract(sin(p) * 43758.5453123);\n    return p;\n}\n\n#define tau 6.283185307179586\n\nfloat shard_noise(in vec4 p, in float sharpness) {\n    vec4 ip = floor(p);\n    vec4 fp = fract(p);\n\n    float v = 0., t = 0.;\n    for (int w = -1; w <= 1; w++) {\n        for (int z = -1; z <= 1; z++) {\n            for (int y = -1; y <= 1; y++) {\n                for (int x = -1; x <= 1; x++) {\n                    vec4 o = vec4(x, y, z, w);\n                    vec4 io = ip + o;\n                    vec4 h = hash(io);\n                    vec4 r = fp - (o + h);\n\n                    float W = exp2(-tau*dot(r, r));\n                    float s = sharpness * dot(r, hash(io + vec4(11, 31, 47, 59)) - 0.5);\n                    v += W * s*inversesqrt(1.0+s*s);\n                    t += W;\n                }\n            }\n        }\n    }\n    return ((v / t) * .5) + .5;\n}\n\nvoid mainImage(out vec4 C, in vec2 F) {\n    vec2 p = F/R.y;\n    vec4 uv = vec4(p + T, T * .5, T * .25);\n    bool click = iMouse.z > 0.;\n\n    float fade = click ? 4. : pow(p.x, 2.) * 30.;\n    \n    if (p.y < 0.5 || click) {\n        C = vec4(vec3(\n            (shard_noise(64.0 * uv, fade) * .03125) +\n            (shard_noise(32.0 * uv, fade) * .0625) +\n            (shard_noise(16.0 * uv, fade) * .125) +\n            (shard_noise(8.0 * uv, fade) * .25) +\n            (shard_noise(4.0 * uv, fade) * .5)\n        ), 1.);\n    } else {\n        C = vec4(vec3(shard_noise(16.0 * uv, fade)), 1.);\n    }\n    if ((p.y > .875 || p.y < .125) && !click) C = round(C);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlKfzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 65, 65, 341], [374, 374, 424, 424, 1139], [1141, 1141, 1180, 1180, 1796]], "test": "untested"}
{"id": "mlKfzt", "name": "behind kaleidoscope", "author": "vortmax", "description": "overlapping circles)))", "tags": ["dummytag"], "likes": 5, "viewed": 154, "published": 3, "date": "1702405064", "time_retrieved": "2024-07-30T17:16:56.939414", "image_code": "vec2 screen2uv(vec2 glCoord, vec2 glRes);\nvec2 angle2vec(float angle);\nvec2 angle2vec(float angle, float cx, float cy);\nvec3 rgb(int r, int g, int b);\n\nvec2 screen2uv(vec2 glCoord, vec2 glRes)\n{\n    return (glCoord.xy * 2.0 - glRes.xy) / glRes.y; \n}\n\nvec2 angle2vec(float angle, float cx, float cy)\n{\n    return vec2(cos(cx * angle), sin(cy * angle));\n}\n\nvec2 angle2vec(float angle)\n{\n    return angle2vec(angle, 1.0, 1.0);\n}\n\n\nvec3 rgb(int r, int g, int b)\n{\n    return vec3(r, g, b) / 255.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = screen2uv(fragCoord.xy, iResolution.xy); \n    vec2 uvM = screen2uv(iMouse.xy, iResolution.xy);\n    float t = iTime * 0.4;\n     \n    vec3 finalColor = vec3(0.0);\n    vec2 uv = uv0 - uvM;    \n    \n    \n    float count = 25.0;\n    vec3 col = rgb(200, 100, 150);\n    float radius = 1.9;\n    \n    \n    for(float i = 1.0; i <= count; ++i)\n    {\n        float shift = radians(360.0 / count * i);\n        vec2 pos = angle2vec(t + shift) * radius;\n        float d = length(uv + pos);\n        \n        d = sin(d + t * 2.5) * 2.5;\n        d = abs(d);\n        d = pow(0.01 / d * 2.5, 1.2);\n        \n        finalColor += d * col;\n    }\n   \n    vec2 laser1 = uv * angle2vec(-t);\n    vec2 laser2 = uv * angle2vec(-t + radians(90.0));\n\n    \n    float laser = max(\n        pow(0.02 / abs(laser1.x + laser1.y), 1.4), \n        pow(0.02 / abs(laser2.x + laser2.y), 1.4)\n    ) * abs(sin(t));\n        \n    finalColor.r *= laser;\n    finalColor.g += laser;\n\n    \n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlKfzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 152, 194, 194, 249], [251, 251, 300, 300, 353], [355, 355, 384, 384, 425], [428, 428, 459, 459, 495], [498, 498, 555, 555, 1557]], "test": "untested"}
{"id": "4ttcDj", "name": "incredibles 2 portal ...kinda", "author": "skaven", "description": "kinda like portal from incredibles 2", "tags": ["incrediblesportal"], "likes": 9, "viewed": 310, "published": 3, "date": "1702386689", "time_retrieved": "2024-07-30T17:16:57.892865", "image_code": "#define PI 3.141592\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p, float freq ){\n\tfloat unit = 4.0/freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\t//xy = 3.*xy*xy-2.*xy*xy*xy;\n\txy = .5*(1.-cos(PI*xy));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pNoise(vec2 p, int res){\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 4.;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tif (iCount == res) break;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\t\n\nfloat distToCircle(vec2 uv, float radius, float phase, float ffly)\n{\n    float ng = atan(uv.y, uv.x) + phase + iTime*(0.1 + ffly);\n    float distDist = sin(ng*2.0) * cos(4.0*ng + sin(ng) - sin(ng*12.0)*0.1);// * (sin(ng*8.0))*1.5;\n\n    return abs(length(uv) - radius + distDist * 0.01) + abs(tan(ng + phase * 1.4))*0.004 * ffly;\n}\n\nfloat dToC(vec2 ngDist, float dradius)\n{\n    float ng = ngDist.x + iTime*10.0;\n    float noise = pNoise(vec2(cos(ng), sin(ng)) + vec2(0.5), 2);\n    ngDist.y += noise * 0.2 + dradius + (sin(iTime*5.171) * sin(ngDist.x*2.0)) * dradius - 0.1;\n    \n    float thick1 = 0.004;\n    float thick2 = 0.008;\n    return smoothstep(0.0, thick1, ngDist.y) - smoothstep(thick1, thick2, ngDist.y);\n}\n\n\nvec2 distoAngleDist(vec3 dir)\n{\n    vec2 dp = dir.xy/dir.z;\n    \n    float ng = atan(dp.y, dp.x);\n    float r = pNoise(vec2(cos(ng), sin(ng))+ vec2(iTime * 0.5), 1);\n    r = 0.5 + r*0.1;\n    \n    return vec2(ng, length(dp) - r); \n}\n\nfloat distToPortal(vec2 ngDist)\n{\n    return smoothstep(0.0,0.01, ngDist.y);\n}\n\nfloat aero(vec2 ngDist)\n{\n    ngDist.x += iTime*0.01;\n    float baseMask = min(1.0-max(ngDist.y*1.5,0.0),1.0) * smoothstep(0.0,0.01,ngDist.y);\n    \n    float bore = (sin(ngDist.x*4.0));\n    bore += (sin(ngDist.x*6.0+iTime*1.374));\n    bore += (sin(-ngDist.x*8.0+iTime*0.51)) * 0.1;\n    \n    //bore += sin(-ngDist.x * 3.0);\n    baseMask *= clamp(bore  *0.3 + 0.5, 0.3, 1.0);\n    //baseMask *= clamp((sin(-ngDist.x*4.0) + sin(-ngDist.x * 3.0) +sin(ngDist.x *12.0))  *0.3 + 0.5, 0.3, 1.0);\n\n    \n    return clamp(baseMask,0.0,1.0);\n}\n\nfloat lightning(vec2 ngDist, float time)\n{\n    float growth = fract(time*2.0) * 0.1;\n    \n    float ng = ngDist.x;\n    float noise = pNoise(vec2(cos(ng), sin(ng))*(6.0-growth*6.0)+ vec2(time * 0.5), 2);\n    noise += pNoise(vec2(cos(ng), sin(ng))*(4.0-growth * 4.0)+ vec2(time * 0.1), 2)*0.2;\n    \n    \n    float adist = abs(ngDist.y-noise * 0.2 - growth);\n    float diflum = min(sin(ng * 4.0 + time*1.1)+0.8, 1.0);\n    return clamp((1.0-smoothstep(0.0,0.01, adist)) * growth*10.0 * diflum,0.0,1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.y *= iResolution.y/iResolution.x;\n    \n\n    float col = 20.0;\n    for (float i = 0.0;i<1.0;i+=0.1)\n    {\n    \tcol -= smoothstep(0.0,0.002,distToCircle(uv, 0.17+i*0.01, i, 0.0));\n        col -= smoothstep(0.0,0.002,distToCircle(uv, 0.18+i*0.03, i, 1.0));\n    }\n\n    vec3 eyeSrc = normalize(vec3(uv*4.0, 1.0));\n    vec2 mouse = (iMouse.xy /iResolution.xy) * 0.8-0.4;\n    vec3 eye = rotateY(mouse.x) * rotateX(mouse.y) * eyeSrc;\n   \n    \n    vec2 ngDist = distoAngleDist(eye);\n    // Output to screen\n    fragColor = vec4(vec3(col) * vec3(0.4,0.8,1.0)*3.0, 1.0);\n    fragColor = mix(texture(iChannel1, eye), texture(iChannel0, eye), distToPortal(ngDist));\n    \n    //fragColor += vec4(lum);\n    fragColor += vec4(lightning(ngDist, iTime) + lightning(ngDist, iTime+12.37981));\n    \n    vec4 auraCol = mix(vec4(0.12,0.745,0.364,1.0), vec4(0.15,0.474,0.891,1.0), sin(iTime) *0.5+0.5);\n    fragColor += auraCol * aero(ngDist);\n    \n    float r1 = 0.0;\n     for (float i = 0.0;i<1.0;i+=0.1)\n    {\n        r1 += dToC(ngDist, i * 0.08);\n    }\n    fragColor += r1 * auraCol * 2.0;\n    \n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ttcDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 39, 39, 107], [109, 109, 142, 142, 504], [506, 506, 536, 536, 825], [827, 827, 854, 854, 1001], [1003, 1049, 1076, 1076, 1223], [1225, 1225, 1245, 1245, 1283], [1285, 1285, 1306, 1306, 1396], [1400, 1400, 1468, 1468, 1730], [1732, 1732, 1772, 1772, 2115], [2118, 2118, 2149, 2149, 2349], [2351, 2351, 2384, 2384, 2429], [2431, 2431, 2456, 2456, 2961], [2963, 2963, 3005, 3005, 3463], [3464, 3464, 3521, 3571, 4710]], "test": "untested"}
{"id": "dlyfRd", "name": "Try Out by berwt new", "author": "berwt", "description": "Here I tried out an introduction by kishimisu", "tags": ["tutorial"], "likes": 1, "viewed": 131, "published": 3, "date": "1702379685", "time_retrieved": "2024-07-30T17:16:58.899175", "image_code": "vec3 palette( float t  ) \n{\n    vec3 a = vec3(0.5,0.6,0.5);\n    vec3 b = vec3(0.5,0.6,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.263, 0.416,0557);\n\n    return a + b*cos( 6.28*(c*t+d) );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;    \n    vec3 finalColor = vec3(0.2);\n    \n    for (float i = 0.0; i < 5.0; i++) {\n    uv = fract(uv * 1.2) - 0.5;\n    \n    float d = length(uv) * exp(-length(uv0));\n    \n    vec3 col = palette(length(uv0) + i*.4 + iTime*.4);\n    \n    d = sin(d*8. + (0.7 * iTime))/6.;\n    d = abs(d);\n    \n    d = pow(0.01 / d, 1.2);\n    \n    finalColor += col * d;\n    \n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlyfRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 202], [206, 206, 263, 263, 754]], "test": "untested"}
{"id": "clGfzd", "name": "Hyperbolic Pentagons II", "author": "mla", "description": "More hyperbolic pentagonal tilings. This uses rotational symmetries around edge midpoints, so the tiles are all directly congruent. Mouse drags centre point. 'x' to enter \"configuration mode\". See header for more info, controls, etc.", "tags": ["tiling", "pentagon", "hyperbolic", "hyperboloid"], "likes": 11, "viewed": 244, "published": 3, "date": "1702377770", "time_retrieved": "2024-07-30T17:16:59.831681", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Hyperbolic Pentagonal Tilings II, mla, 2023.\n//\n// A convex hyperbolic polygon with angles adding up to 360Â° will\n// tile the hyperbolic plane with the basic symmetry of the tiling\n// being rotations about midpoints of edges (so the tiles are all\n// directly congruent). For pentagons, as well as the angles, two\n// side lengths can be specified, the rest are determined by the\n// construction.\n//\n// Set two of the angles in \"configuration mode\" by pressing 'x' or 'y'\n// and dragging the red ring. Not all combinations of angles and lengths\n// are possible. The screen may flash red for an invalid combination.\n//\n// When not in configuration mode, use the mouse to drag centre point.\n//\n// <up>,<down>: zoom in/out\n// c: don't colour tiles\n// d: don't shade area outside disc\n// h: half space projection\n// l: toggle line thickness\n// v: don't show vertices\n// x: config mode\n// y: show config dot\n// z: zoom in (only in half space projection)\n//\n// Calculations are done in the hyperboloid model, including folding into\n// the fundamental region (though errors accumulate faster than in\n// the disc model.\n//\n// Point A is the centre, (0,0,1), which lies on lines a and e, at angle\n// P to each other. Measuring along a and e from A gives two more\n// points, B and E and we construct lines b and d through them at angles \n// Q and T. Finally, a line c is constructed making angles R and S with b\n// and d. This line (if it exists) is unique and determines the length of\n// the final three segments.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int N = 5; // Number of sides. Currently must be 5\n\n// Basic operations for hyperbolic (Minkowski) space\n\n// Inner product\nfloat hdot(vec3 p, vec3 q) {\n  return dot(vec3(1,1,-1)*p,q);\n}\n\nvec3 hcross(vec3 p, vec3 q) {\n  // hdot(p,hcross(p,q)) = hdot(q,hcross(p,q)) = 0\n  return cross(p,q)*vec3(1,1,-1);\n}\n\nfloat hnorm(vec3 p) {\n  return hdot(p,p);\n}\n\nfloat hlength(vec3 p) {\n  return sqrt(abs(hnorm(p)));\n}\n\n// Normalize a point or a line\nvec3 hnormalize(vec3 p) {\n  return p/hlength(p);\n}\n\n// Map point on plane to hyperboloid hnorm(p) = -1\nvec3 unproject(vec2 z) {\n  // kÂ²|z|Â²-(1-k)Â² = -1\n  // kÂ²|z|Â²-1+2k-kÂ² = -1\n  // k|z|Â²+2-k = 0\n  float k = 2.0/(1.0-dot(z,z));\n  return vec3(k*z,k-1.0);\n}\n\n// NB: sinh(x) = asinh(x) = tanh(x) = x (approximately) for\n// small values of x (eg. sinh 0.1 = 0.10017, tanh 0.1 = 0.0997)\n// Hyperbolic distance from line\nfloat hline(vec3 p, vec3 l) {\n  return abs(asinh(hdot(p,l)));\n}\n\n// Hyperbolic distance between points\nfloat hpoint(vec3 p, vec3 q) {\n  //return acosh(-hdot(p,q)); // Bad truncation error\n  return 2.0*abs(asinh(0.5*hlength(p-q)));\n}\n\n// Find a point on the line formed by the intersections\n// of planes l and m. Try to find point of form\n// (x,y,0), (x,0,z) or (0,y,z) by solving a 2x2\n// linear system. Construct three matrices & use the one\n// with largest determinant (it's possible for two\n// determinants to be zero, but not all three if the\n// planes aren't parallel).\nvec3 linepoint(vec3 l, vec3 m, float a, float b) {\n  vec2 A = vec2(1,-1); // adjust for metric\n  mat2 m0 = mat2(l.xy,m.xy);\n  mat2 m1 = mat2(A*l.xz,A*m.xz);\n  mat2 m2 = mat2(A*l.yz,A*m.yz);\n  float d0 = abs(determinant(m0));\n  float d1 = abs(determinant(m1));\n  float d2 = abs(determinant(m2));\n  float dmax = max(d0,max(d1,d2));\n  if (dmax == d1) m0 = m1;\n  else if (dmax == d2) m0 = m2;\n  vec3 p = vec3(vec2(a,b)*inverse(m0),0);\n  if (dmax == d1) p = p.xzy;\n  else if (dmax == d2) p = p.zxy;\n  assert(eq(hdot(p,l),a));\n  assert(eq(hdot(p,m),b));\n  return p;\n}\n\n// Given vectors l and m, return a normalized vector n\n// with l.n = a, m.n = b (all with Minkowski product)\n// sign parameter says if we want a line (spacelike) or a point (timelike)\nbool f(vec3 l, vec3 m, float a, float b, out vec3 n, float sign) {\n  // Want a line m with hdot(l,n) = A, hdot(m,n) = B\n  vec3 r = hcross(l,m); // Direction vector for intersection of planes l and m\n  // Now find p with hdot(p,l) = A, hdot(p,m) = B\n  vec3 p = linepoint(l,m,a,b);\n  // Now try to find a normalized point on that line ie. hnorm(p+tr) = <sign>\n  // (p+tr).(p+tr) - sign = 0\n  // p.p + 2t(p.r) + tÂ²(r.r) - 1 = 0\n  // Set p.r = 0, so B = 0 in quadratic formula\n  p -= hdot(p,r)/hdot(r,r)*r;\n  float A = hdot(r,r);\n  float C = hdot(p,p) - sign;\n  float D = -A*C;\n  if (D < 0.0) return false;\n  // Two solutions are eg. for complementary angles, opposite distances.\n  float t = sqrt(D)/A;\n  n = p+t*r;\n  return true;\n}\n\n// Find a (normalized) point p with l.p = a, m.p = b\n// l and m can be points or lines\nvec3 fpoint(vec3 l, vec3 m, float a, float b) {\n  vec3 p;\n  bool t = f(l,m,a,b,p,-1.0);\n  assert(t);\n  assert(p.z >= 0.0);\n  return p;\n}\n\n// Find a (normalized) line p with l.p = a, m.p = b\n// l and m can be points or lines\nvec3 fline(vec3 l, vec3 m, float a, float b) {\n  vec3 p;\n  bool t = f(l,m,a,b,p,1.0);\n  assert(t);\n  assert(p.z <= 0.0);\n  return p;\n}\n\n// Get point on line l, distance d from p, also on l.\n// Same as fpoint(p,l,-cosh(d),0) but less rounding error.\nvec3 pointatdistance(vec3 p, vec3 l, float d) {\n  vec3 r = hcross(p,l); // Tangent vector\n  float k = tanh(d)/hlength(r); // Get right angle\n  vec3 q = p+k*r;\n  return hnormalize(q); // And normalize\n}\n\n// Assume l normalized\nvec3 hreflect(vec3 p, vec3 l) {\n  return p-2.0*hdot(p,l)*l;\n}\n\n// Reflect in a hyperbolic line\nint tryreflect(vec3 l, vec3 m, int i, inout vec3 p, inout vec3 h) {\n  float k = hdot(p,l);\n  if (k > 0.0) return 0;\n  p -= 2.0*k*l;\n  p = hreflect(p,m);\n  h = hreflect(h,l);\n  h = hreflect(h,m);\n  return 1;\n}\n\nvec3 fold(vec2 z, int MAX, vec3 edges[N], vec3 points[N], inout vec3 h) {\n  vec3 p = unproject(z);\n  vec3 bisectors[N];\n  for (int i = 0; i < N; i++) {\n    bisectors[i] = hnormalize(points[i]-points[(i+1)%N]);\n  }\n  for (int count = 0; count < MAX; count++) {\n    int k = 0;\n    for (int i = 0; i < N; i++) {\n      k += tryreflect(edges[i],bisectors[i],0,p,h);\n    }\n    if (k == 0) break;\n  }\n  return p;\n}\n\n// Given a Euclidean distance d, and a direction p, return\n// an hspace point that is at that distance and direction\n// from the centre in the Poincare disc.\nvec3 pointfromcentre(float d, vec2 p) {\n  float x = 2.0*d/(1.0-d*d);\n  float t = sqrt(1.0+x*x);\n  return vec3(x*p,t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Calculate sides and vertices of the polygon.\n  // All angles are given, as well as side lengths for a and e.\n  // A a B b C c D d E e A ..\n  // A is at origin, so a and e are straight lines in disc model\n  // and have t = 0 in hyperboloid model.\n  // Angle at A is PI/P, etc\n  // R = 0 means R = PI/infinity, also works for S\n  vec2 params = abs(getselection(0));\n  float angles[N];\n  angles[0] = angles[1] = angles[2] = angles[3] = 2.0*PI/5.0;\n  angles[0] = 2.0*params[0];\n  angles[1] = 2.0*params[1];\n  angles[N-1] = 2.0*PI;\n  for (int i = 0; i < N-1; i++) {\n    angles[N-1] -= angles[i];\n  }\n  assert(angles[N-1] >= 0.0);\n  vec3 edges[N], points[N];\n  {\n    // Need to sort this out for N != 5\n    vec3 a = vec3(1,0,0);\n    vec3 e = vec3(-mycos(angles[0]),mysin(angles[0]),0);\n    vec3 A = vec3(0,0,1);\n    vec3 B = pointfromcentre(0.7,vec2(0,1));\n    vec3 E = pointfromcentre(0.7,vec2(mysin(angles[0]),mycos(angles[0])));\n    vec3 b = fline(a,B,-mycos(angles[1]),0.0);\n    vec3 d = fline(E,e,0.0,-mycos(angles[N-1]));\n    vec3 c = fline(d,b,-mycos(angles[3]),-mycos(angles[2]));\n    vec3 C = hnormalize(hcross(b,c));\n    vec3 D = hnormalize(hcross(c,d));\n    edges = vec3[](a,b,c,d,e);\n    points = vec3[](A,B,C,D,E);\n  }\n  vec2 z = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  vec2 w = vec2(0);\n  if (!configmode) w = iMouse.x <= 10.0 ? 0.5*expi(0.25*iTime) : defaultselection();\n  float scale = 1.0;\n  if (!configmode) scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  z *= scale;\n  w *= scale;\n  float lwidth = 0.02;\n  float pwidth = 3.0*lwidth;\n  if (key(CHAR_L)) lwidth = 0.0;\n  \n  float px = fwidth(z.x);\n  bool dohalfplane = key(CHAR_H);\n  bool dozoom = key(CHAR_Z);\n  if (dohalfplane) z.y += scale;\n  // Conversion factor between hyperbolic and screen distances\n  float scalefactor = 1.0;\n  if (dohalfplane) {\n    if (dozoom) {\n      float k = exp(-iTime);\n      z *= k;\n      scalefactor /= k;\n    }\n    z.y += 1.0;\n    float k = 2.0/dot(z,z);\n    z *= k;\n    scalefactor /= k;\n    z.y -= 1.0;\n  }\n  scalefactor *= 0.5*abs(1.0 - dot(z,z));\n  if (!configmode) {\n    // Invert to mouse position\n    vec2 c = w;\n    z -= c;\n    z *= (dot(c,c)-1.0)/dot(z,z);\n    z += c;\n    z /= -dot(z,z);\n  }\n  bool indisc = dot(z,z) <= 1.0;\n  if (!indisc) z /= dot(z,z);\n  int NMAX = configmode ? 0 : 10;\n  vec3 h = vec3(0,0,1);\n  vec3 p = fold(z,NMAX,edges,points,h);\n  //vec3 p = fold(z,N,a,b,c,d,e,h);\n  vec3 col = vec3(0.5,1,1);\n  if (!configmode && !key(CHAR_C)) col = h2rgb(dot(h,vec3(1,2,3)));\n  {\n    float t = 1e8;\n    for (int i = 0; i < N; i++) {\n      t = min(t,hline(p,edges[i]));\n    }\n    vec3 lcol = vec3(0.1);\n    if (!configmode && key(CHAR_W)) lcol = vec3(1);\n    col = mix(lcol,col,smoothstep(0.0,px/scalefactor,t - lwidth));\n  }\n  {\n    float t = 1e8;\n    if (!key(CHAR_V)) {\n      for (int i = 0; i < N; i++) {\n        t = min(t,hpoint(p,points[i]));\n      }\n    }\n    col = mix(vec3(0),col,smoothstep(0.0,px/scalefactor,t - pwidth));\n  }\n  if (!key(CHAR_D) && !indisc) col *= 0.5;\n  if (showconfig) {\n    vec2 p = map(fragCoord);\n    float d = abs(distance(p,getselection(0))-0.03)-0.005;\n    col = mix(vec3(1,0,0),col,0.25+0.75*smoothstep(0.0,px,d));\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  //setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  vec4 t0 = texelFetch(iChannel2,ivec2(0),0); // Get current state   \n  if (iFrame == 0 || t0 != vec4(1234.0)) {\n    t = vec4(0);\n  }  \n  if (j == 0) {\n    if (i == 0) t = vec4(1234.0);\n    else {\n      // First row - key count\n      // Do key repeat here as well?\n      float w1 = keystate(i,0).x;\n      if (w1 != t.w) {\n        t.w = w1;\n        // Don't count key changes when ALT pressed\n        if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n          t.x++; t.y = iTime;\n        }\n      }\n      // Key repeat - only when shader is running!\n      // Should have longer pause after first key press.\n      if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n        t.x++; t.y = iTime;\n      }\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (showconfig && t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        t.x = -1.0;\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < 0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n      if (!configmode && t.x <= 0.0 && iMouse.z > 0.0) {\n        t.zw = iMouse.x < 20.0 ? vec2(0) : map(iMouse.xy);\n      }\n    } else if (iFrame == 0 || t.w != 1234.0) {\n      t.xy = initselection(i-1); // Current coordinates\n      t.w = 1234.0;\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store((key),0).x))\n#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\n#define map(screenpos) ((2.0*(screenpos)-iResolution.xy)/iResolution.y)\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n//#define getselected() (texelFetch(iChannel2,ivec2(0,3),0))\n#define defaultselection() (texelFetch(iChannel2,ivec2(0,3),0).zw)\n//#define setscale() (scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP))))\n#define configmode (key(CHAR_X))\n#define showconfig (configmode || key(CHAR_Y))\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst float PI =  3.141592654;\n\nconst int nselections = 1;\nvec2 initselection(int i) {\n  if (i == 0) return vec2(0.8,0.7);\n  if (i == 1) return vec2(0.75,0.25);\n  if (i == 2) return vec2(-2,-1.5);\n  if (i == 3) return vec2(0,-1);\n  if (i == 4) return vec2(0.25,0);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return mix(vec3(1),rgb,0.8);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nvec2 expi(float t) {\n  return normalize(vec2(cos(t),sin(t)));\n}\n\nbool eq(float a, float b) {\n  return abs(a-b) < 1e-4;\n}\n\nfloat COS[] =\n  float[](1.0,-1.0,0.0,0.5,0.7071067812,0.8090169944,0.8660254038,\n          0.9009688679,0.9238795325,0.9396926208,0.9510565163,0.9594929736,\n          0.9659258263,0.9709418174,0.9749279122,0.9781476007,0.9807852804,\n          0.9829730997,0.984807753,0.9863613034,0.9876883406,0.9888308262,\n          0.9898214419,0.990685946,0.9914448614,0.9921147013,0.9927088741,\n          0.9932383577,0.9937122099,0.9941379572,0.9945218954,0.9948693234);\n\nfloat icos(int p) {\n  // cos(PI/p)\n  if (p < COS.length()) return COS[p];\n  return cos(PI/float(p));\n}\n                        \nfloat isin(int p) {\n  // sin(PI/p)\n  float t = icos(p);\n  return sqrt(1.0-t*t);\n}\n\n// GPU cos might not be good enough for repeated reflections\n// Chebyshev might be better here, but these work pretty well.\nfloat mycos(float x) {\n  //return cos(x);\n  int N = 14;\n  float x2 = x*x, y = 1.0;\n  for (int n = N; n > 0; n-=2) {\n    y = 1.0-x2*y/float(n*(n-1));\n  }\n  return y;\n}\n\nfloat mysin(float x) {\n  //return sin(x);\n  int N = 12;\n  float x2 = x*x, y = 1.0;\n  for (int n = N; n > 0; n-=2) {\n    y = 1.0-x2*y/float(n*(n+1));\n  }\n  return x*y;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clGfzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1788, 1805, 1833, 1833, 1867], [1869, 1869, 1898, 1949, 1985], [1987, 1987, 2008, 2008, 2030], [2032, 2032, 2055, 2055, 2087], [2089, 2120, 2145, 2145, 2170], [2172, 2223, 2247, 2322, 2382], [2384, 2542, 2571, 2571, 2605], [2607, 2645, 2675, 2729, 2774], [2776, 3117, 3167, 3167, 3678], [3680, 3864, 3930, 3983, 4593], [4595, 4682, 4729, 4729, 4818], [4820, 4906, 4952, 4952, 5040], [5042, 5155, 5202, 5202, 5356], [5358, 5381, 5412, 5412, 5442], [5444, 5476, 5543, 5543, 5684], [5686, 5686, 5759, 5759, 6093], [6095, 6253, 6292, 6292, 6372]], "test": "untested"}
{"id": "ctyBRc", "name": "Bloomy shape", "author": "rubioh", "description": "Volumetric Bloom", "tags": ["volumetric", "bloom"], "likes": 10, "viewed": 205, "published": 3, "date": "1702374053", "time_retrieved": "2024-07-30T17:17:00.675425", "image_code": "float hash21(vec2 p){\n    vec2 d = vec2(17.256, 18.5679);\n    return fract(sin(dot(p,d)*3.3628)*17.256);\n\n}\nfloat hash(float h){\n    return fract(sin(h*173.456)*36.234);\n}\nfloat noise(vec2 p){\n    vec2 pt = floor(p);\n    vec2 pt1 = floor(p)+1.;\n    float h = hash21(pt);\n    float h1 = hash21(pt1);\n    return mix(h, h1, fract(p.x));\n}\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nfloat sdZ(vec2 p){\n    \n    p *= 2.;\n    float d = sdSegment(p, vec2(-.4,-.3), vec2(.4,-.3));\n    d = min(d, sdSegment(p, vec2(.4,-.3), vec2(-.4,.3)));\n    d = min(d, sdSegment(p, vec2(-.4,.3), vec2(.4,.3)));\n   \n    return d;\n}\nmat2 rot(float angle){\n    return mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n}\nvec4 palette(float t){\n    return mix(\n        mix(vec4(0.988,0.686,0.243,1), vec4(0.678,0.498,0.659,1), cos(t)*.5+.5), \n        mix(vec4(0.451,0.824,0.086,1), vec4(0.204,0.396,0.643,1), cos(t)*.5+.5), \n        cos(t*.07)*.5+.5);\n}\n#define R iResolution.xy\nvoid mainImage( out vec4 O,vec2 I)\n{\n    vec2 uv = (R*.5-I)/R.y;\n    float t=iTime*2.;\n    vec4 lum = vec4(0.);\n    for (float i=.5; i>0.3; i-=.0025){\n        vec2 p=(I+I-R)/R.y*i;\n        p *= 4.;\n        vec2 P = p;\n        p.x = p.x/.9;\n        float deltay = noise(vec2(t)*.02 + floor(p.x));\n        p.y += deltay*deltay*16.;\n        vec2 id = floor(p);\n        float go_id = noise(id*17. + t*.3);\n        go_id *= go_id;\n        float angle = noise(t*.001+vec2(go_id))*4.;\n        p = fract(p);\n        p -= .5;\n        p *= rot(angle*6.28);\n        p*=1.5;\n        vec2 q = p;\n        float L2 = smoothstep(.05, .0, abs(sdEquilateralTriangle(p, .4))-.01);\n        p = abs(p);\n        float L = abs(max(abs(p.x), abs(p.y)))*4.;\n        L = mix(abs(L - 1.), L2-1., .5+.5*cos(1.*t*(noise(vec2(hash21(id)))-.5)));\n        float dZ = sdZ(q);\n        float dO = abs(length(q)*4.-1.);\n        float zo =  mix(dZ, dO, .5+.5*cos(1.*t*(noise(vec2(hash21(id)))-.5)));\n        L = mix(L, zo, .5+.5*cos(.1*t + length(uv)*2.));\n        float d = L;\n        float LP = length(p);\n        LP = 1./(1.+150.*LP*LP);\n        vec4 c = palette(t*0.2 + i*6.2830*4.+ 3.14159*cos(.1*t + length(uv)*2.));\n        if (i==.5){\n            lum += c*exp(-d*d*1000.)*go_id/i*.5 * smoothstep(1., .0, length(uv))*4.* LP + c/(1.+400.*d*d)*go_id * LP;\n\n        }\n        else{\n            c *= exp(-d*d*1000.*i)*go_id;\n            float Di = abs(.5-i);\n            lum += c/i*.1 * smoothstep(1., .0, length(uv))/(1.+600.*Di*Di)*2.* LP;\n        }\n    }\n    lum = tanh(lum*lum*(30. + 10.*cos(t*.35)));\n    O=lum;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctyBRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 107], [108, 108, 128, 128, 171], [172, 172, 192, 192, 335], [336, 336, 390, 390, 599], [600, 600, 652, 652, 771], [772, 772, 790, 790, 1000], [1001, 1001, 1023, 1023, 1091], [1092, 1092, 1114, 1114, 1323], [1349, 1349, 1385, 1385, 2933]], "test": "untested"}
{"id": "mlKfR3", "name": "Flower Neon", "author": "vortmax", "description": "that should be stars and satelites, but something went wrong))) \np.s. i know how to draw stars with planets, i just modified them a bit and got this)", "tags": ["dummytag"], "likes": 4, "viewed": 136, "published": 3, "date": "1702368323", "time_retrieved": "2024-07-30T17:17:01.606935", "image_code": "vec2 screen2uv(vec2 glCoord, vec2 glRes);\nvec2 angle2vec(float angle);\nvec2 angle2vec(float angle, float cx, float cy);\nvec3 rgb(int r, int g, int b);\n\nvec2 screen2uv(vec2 glCoord, vec2 glRes)\n{\n    return (glCoord.xy * 2.0 - glRes.xy) / glRes.y; \n}\n\nvec2 angle2vec(float angle, float cx, float cy)\n{\n    return vec2(cos(cx * angle), sin(cy * angle));\n}\n\nvec2 angle2vec(float angle)\n{\n    return angle2vec(angle, 1.0, 1.0);\n}\n\n\nvec3 rgb(int r, int g, int b)\n{\n    return vec3(r, g, b) / 255.0;\n}\n\n\n\nvec3 palette(float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.6, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = screen2uv(fragCoord.xy, iResolution.xy); \n    vec2 uvM = screen2uv(iMouse.xy, iResolution.xy);\n    float t = iTime;\n    \n    vec3 finalColor = vec3(0.0);\n    vec2 uv = uv0 - uvM;    \n    \n    //star data\n    float starCount = 20.0;\n    float starRadius = 0.6;\n    float starOrbitRadius = 3.0;\n    float starSpeedScale = 0.5;\n    vec3 starCol = rgb(15, 190, 190);\n    \n    //planet data\n    float planetCount = 32.0;\n    float planetRadius = 0.5;\n    float planetOrbitRadius = 0.2;\n    float planetSpeedScale = 0.6;\n    vec3 planetCol = rgb(200, 200, 15);\n    \n    \n    //orbit pos - uv (0,0 center); \n    vec2 starOrbitPos = uv;\n\n    for(float i = 1.0; i <= starCount; ++i)\n    {\n        float starShift = radians(360.0 * i / starCount);\n        vec2 starOrbitVector = angle2vec(t * starSpeedScale + starShift) * starOrbitRadius;\n        vec2 starPos = starOrbitPos + starOrbitVector;\n        \n        float dStar = length(starPos);\n        \n        dStar = step(dStar, starRadius);\n        dStar = sin(dStar * 32.0 + t) / 32.0;\n        dStar = abs(dStar);\n        \n        finalColor += dStar * starCol;\n        \n\n        //orbit pos - starPos (star center); \n        vec2 planetOrbitPos = starPos;\n\n        for(float j = 1.0; j <= planetCount; ++j)\n        {\n            float planetShift = radians(360.0 * j / planetCount);\n            vec2 planetOrbitVector = angle2vec(-t * planetSpeedScale + planetShift) * planetOrbitRadius;\n            vec2 planetPos = planetOrbitPos + planetOrbitVector;\n            \n            float dPlanet = length(planetPos);\n\n            //dPlanet = step(dPlanet, planetRadius);\n\n            dPlanet = sin(dPlanet * 32.0 + t) / 32.0;\n\n            \n            finalColor += dPlanet * planetCol;\n        } \n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlKfR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 152, 194, 194, 249], [251, 251, 300, 300, 353], [355, 355, 384, 384, 425], [428, 428, 459, 459, 495], [499, 499, 522, 522, 714], [717, 717, 774, 774, 2579]], "test": "untested"}
{"id": "clKfzc", "name": "ordinary study", "author": "elenzil", "description": "ordinary study.\ni mean normal study!", "tags": ["2d", "sdf", "normals", "normal"], "likes": 22, "viewed": 273, "published": 3, "date": "1702363506", "time_retrieved": "2024-07-30T17:17:02.583324", "image_code": "const float gBoxSize       = 1.0;\nconst float gMarchEpsilon  = 0.4;\nconst float gNormalEpsilon = gMarchEpsilon * 0.5;\nconst float gUnderStepFac  = 1.0;\n\n#define VISUALIZE_NORMAL_DIRECTION 1\n\n\nfloat gZoom  = 0.6;\nfloat gLW    = 2.0; // line width.           scaled at runtime.\nfloat gSSEps = 4.0; // screen-space epsilon. scaled at runtime.\nvec2  gRd;          // ray direction\nfloat gT;\n\nfloat map(in vec2 p) {\n\n    float boxRad  = gBoxSize;\n    \n    float box     = sdBox   (p               , v1 * boxRad);\n    float circle  = sdCircle(p, vSE * boxRad * 0.5, 0.75 * boxRad); \n    \n    float d       = 1e9;\n    d = min(d, box);\n    d = max(d, -circle);\n  \n    if (false) {\n        d = length(p) - boxRad * 8.0;\n        d = max(d,  p.x - boxRad);\n        d = max(d, -p.x - boxRad);\n        d = max(d, -p.y - boxRad);\n        d = max(d,  p.y - boxRad);\n    }\n\n    \n    return d;\n}\n\nvoid drawCircle(inout vec3 c, in vec4 clr, in float a, in vec2 p, in vec2 cen, in float rad, bool dashed) {\n    vec2 v = (p - cen);\n    float d = length(v) - rad;\n    \n    float modulate = 1.0;\n    if (dashed) {\n        modulate = fract(atan(v.y, v.x) / 3.14159 * 10.0) * 2.0 - 1.0;\n        modulate = smoothstep(0.6, 0.5, abs(modulate));\n        \n    }\n    \n    \n    c = mix(c, clr.rgb, a * clr.a * smoothstep(gSSEps/2.0, -gSSEps/2.0, d + gLW * 1.5));\n    a *= modulate;\n    c = mix(c, clr.rgb, a *         smoothstep(gSSEps    , 0.0        , abs(d) - gLW));    \n}\n\nvoid drawCircle(inout vec3 c, in vec4 clr, in float a, in vec2 p, in vec2 cen, in float rad) {\n    drawCircle(\n        c, clr, a, p, cen, rad, false);\n}\n\n\nvoid drawSegment(inout vec3 c, in vec4 clr, in float a, in vec2 p, in vec2 p1, in vec2 p2) {\n    float d = sdSegment(p, p1, p2);\n    \n    c = mix(c, clr.rgb, a * smoothstep(gSSEps, 0.0, abs(d) - gLW));    \n}\n\nvoid drawRay(inout vec3 c, in vec4 clr, in float a, in vec2 p, in vec2 ro, in vec2 rd) {\n    float d = 1e9;\n    \n    vec2 rn = vec2(rd.y, -rd.x);\n    float width = gLW * 4.0;\n    \n    vec2 p1 = ro;\n    vec2 p2 = ro + rd;\n    \n    d = min(d, sdSegment(p, p1, p2));\n    d = min(d, sdSegment(p, p2, p2 + 0.2 * ( rn - rd)));\n    d = min(d, sdSegment(p, p2, p2 + 0.2 * (-rn - rd)));\n    d = min(d, sdCircle (p, p1, width));\n    \n    \n    d -= width;\n    c = mix(c, clr.rgb, a * clr.a * smoothstep(gSSEps/2.0, -gSSEps/2.0, d + gLW * 1.5));\n    c = mix(c, clr.rgb, a *         smoothstep(gSSEps    , 0.0        , abs(d) - gLW));\n}\n\nvoid drawMarch(inout vec3 col, in vec2 q, in vec2 ro, in vec2 rd) {\n    \n    uint maxSteps = 100u;\n    \n    vec2 pPrev = ro;\n    \n    const vec4 clr1 = vec4(0.0, 0.8, 0.2, 0.0);\n    const vec4 clr2 = vec4(0.5, 0.8, 0.2, 0.1);\n    \n    float t = 0.0;\n    for (uint n = 0u; n < maxSteps; ++n) {\n        vec2  p = ro + rd * t;\n        float d = map(p);\n        drawCircle (col, clr1, 0.2, q, p, d);\n        drawCircle (col, clr1, 0.6, q, p, gLW * 4.0);\n        drawSegment(col, clr1, 0.6, q, pPrev, p);\n        if (d < gMarchEpsilon) {\n            vec2 rdp = vec2(rd.y, -rd.x);\n            drawCircle (col, clr1, 0.6, q, p, d);\n            drawCircle (col, clr2, 0.6, q, p, gMarchEpsilon, true);\n            drawCircle (col, clr2, 0.6, q, p, gNormalEpsilon, true);\n            drawSegment(col, clr1, 0.6, q, p + rdp * d, p - rdp * d);\n            break;\n        }\n        t += d * gUnderStepFac;\n        if (t > gBoxSize * 6.0) {\n            break;\n        }\n        pPrev = p;\n    }\n    \n    \n}\n\n\nvec2 wrldFromScrn(in vec2 p) {\n    return (p * 2.0 - RES) / MINRES / gZoom;\n}\n\nvec1 wrldFromScrn(in vec1 p) {\n    return p / MINRES / gZoom;\n}\n\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    vec2  p = wrldFromScrn(XY);\n    vec2  m = wrldFromScrn(iMouse.xy);\n    \n    gLW     = wrldFromScrn(gLW);\n    gSSEps  = wrldFromScrn(gSSEps);\n    gT      = iTime;\n    \n    if (length(iMouse.xy) < 50.0) {\n        m.x = cos(gT * 0.13) / gZoom;\n        m.y = sin(gT * 0.13) / gZoom;\n    }\n    \n    gRd = normalize(m);\n    \n    float d = map(p);\n    \n    vec3  c    = vec3(1e9, 0.0, 1e9);\n    vec3  cIn  = vec3(0.3, 0.5, 0.8);\n    vec3  cOut = vec3(0.7, 0.4, 0.2);\n    vec4  cCrc = vec4(0.9, 1.0, 0.3, 0.3);\n    vec1  aCrc = 0.2;\n    vec1  aNrm = 0.8;\n    vec4  cRay = vec4(1.0, 0.4, 0.2, 0.6);\n    vec1  aRay = 0.8;\n    vec3  cBrd = vec3(0.0, 0.8, 1.0);\n        \n    // inside the SDF\n    c = mix(c, cIn , smoothstep( 0.0, gLW, -d));\n    \n    // outside the SDF\n    c = mix(c, cOut, smoothstep( 0.0, gLW,  d));\n    \n    // isolines\n    float isoT = gT * 0.03 / gZoom;\n    float iso = fract((d - isoT) * MINRES / 30.0 * gZoom) * 2.0 - 1.0;\n    c = mix(0.8 * c, c, smoothstep(0.5, 0.0, abs(iso)));\n    iso = fract((d - isoT) / 10. * MINRES / 30.0 * gZoom) * 2.0 - 1.0;\n    c = mix(c, 1.2 * c, smoothstep(0.5, 0.0, abs(iso + 0.5) * 10.0));\n    \n    #if VISUALIZE_NORMAL_DIRECTION\n    float dGdX     = (map(p + vX * gNormalEpsilon) - map(p - vX * gNormalEpsilon)) / 2.0;\n    float dGdY     = (map(p + vY * gNormalEpsilon) - map(p - vY * gNormalEpsilon)) / 2.0;\n    vec2  gradient = vec2(dGdX, dGdY);\n    vec2  normal   = normalize(gradient);\n    float ang      = atan(normal.y, normal.x);\n    float s        = smoothstep(-0.1, 0.1, sin(ang * 16.0));\n    c              = mix(c, c * 0.5, s);\n    #endif\n\n    // boundary of the SDF\n    c = mix(c, cBrd, smoothstep( gSSEps, 0.0,  abs(d) - gLW));\n    \n    // draw the distance at the mouse point,\n    drawCircle(c, cCrc, aCrc, p, m, abs(map(m)));\n    drawCircle(c, cCrc, aCrc, p, m, gLW);\n    \n\n    float spread = 10.0;\n    float num = 10.0;\n    vec2 rd = normalize(m);\n    for (float f = -gNormalEpsilon * spread; f <= gNormalEpsilon * spread; f += gNormalEpsilon * (spread * 2.0 / num)) {\n        vec2 ro = m - rd * gBoxSize * 5.0;\n        ro += f * vec2(rd.y, -rd.x);\n        drawMarch(c, p, ro, rd);\n    }\n        \n    \n    RGBA.rgb = c;\n    RGBA.a   = 1.0;\n}", "image_inputs": [], "common_code": "const vec2 vX  = vec2( 1.0,  0.0);\nconst vec2 vY  = vX.yx;\nconst vec2 v0  = vX.yy;\nconst vec2 v1  = vX.xx;\nconst vec2 vSE = vX - vY;\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n#define vec1   float\n\n\nfloat sdCircle( in vec2 p, in vec2 cen, in float r ) {\n    return length(p - cen) - r;\n}\n\n//-----------------------------------------------------------\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clKfzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[388, 388, 410, 410, 878], [880, 880, 987, 987, 1445], [1447, 1447, 1541, 1541, 1599], [1602, 1602, 1694, 1694, 1809], [1811, 1811, 1899, 1899, 2434], [2436, 2436, 2503, 2503, 3428], [3431, 3431, 3461, 3461, 3508], [3510, 3510, 3540, 3540, 3573], [3576, 3576, 3619, 3619, 5825]], "test": "untested"}
{"id": "clyfRt", "name": "Red and yellow rug", "author": "jarble", "description": "A fractal rug pattern with an ornate design.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 9, "viewed": 260, "published": 3, "date": "1702355820", "time_retrieved": "2024-07-30T17:17:03.404130", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nconst float scale = 1.5;\n\n\nvoid transform(inout vec2 uv, inout vec2 t2){\n    uv = (uv+t2)/scale;\n\n    uv = (fract(vec2(uv+vec2(.5,1.5))*scale)-.5)/scale;\n\n    t2 = triangle_wave(uv+.5);\n    uv =\n        t2-triangle_wave(uv.yx)-fract(t2/2.)\n    ;\n}\n\nvec3 fractal(vec2 uv){\n    vec3 col = vec3(0.);\n    vec2 t2 = vec2(0.);\n    vec3 col1 = col;\n    float c1=0.;\n    float warp_scale = 16.;\n    for(int k = 0; k < 12; k++){\n        vec2 t21 = t2;\n        vec2 warp =\n            vec2(0)\n            //abs(.5-fract(uv/3.))/3.\n            //vec2(sin((t2.x)*warp_scale),cos((t2.y)*warp_scale))/warp_scale\n            //vec2(sin((uv.x)*warp_scale),cos((uv.y)*warp_scale))/warp_scale\n        ;\n        warp = warp;\n        vec2\n        uv_1 = uv+warp.yx,\n        t2_1 = t2+warp.yx;\n        \n        \n        transform(uv,t2);\n        transform(uv_1,t2_1);\n        \n        c1 =\n            max(abs(uv_1.y-uv_1.x)/2.,c1)\n            //max(abs(uv_1.y+uv_1.x*sign(t2.y+t2.x))/2.,c1)\n            //max(abs(uv.y+uv.x)/2.,c1)\n        ;\n        c1 =\n            2.-max(abs(2.*c1-1.),c1/2.)\n        ;\n        col.x =\n            //max(length(uv-t2-c1)/3.,col.x)\n            //1.-max(c1,c1/3.)\n            1.-c1/3.\n            \n            //light blue pattern\n            //2.-max(length(uv-t2-c1)/3.,col.x)\n        ;\n        //if(uv.x>-.25)\n        col =\n            abs(col-(1.-(c1*col.x)));\n        col1 =\n            abs(col1*c1-col-1.).yzx\n            \n            //WOW!\n            //abs(col1*c1-col*sign(t2.y-t2.x)-1.).yzx\n            //abs(col1*c1-col+sign(t2.y-t2.x)).yzx\n        ;\n    }\n    return col1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    float t1 = 2.;\n    \n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.xy += iTime/t1/12.;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec3 col1 = fractal(uv);\n    fragColor = vec4(col1/2.,1.0);\n}\n", "image_inputs": [], "sound_code": "//remix of https://www.shadertoy.com/view/mtSBzV\n\nint collatz(int initial, int steps){\n    //makes some interesting rhythms\n    for(int i = 0; i < steps; i++){\n        if(initial%2==0) initial /= 2;\n        else initial = initial*3+1;\n    }\n    return initial;\n}\nfloat collatz(float initial, float steps){\n    return float(collatz(int(initial),int(steps)));\n}\n\n\nfloat fibonacci(float nthNumber_) {\n        int nthNumber = int(nthNumber_);\n        int previouspreviousNumber, previousNumber = 0, currentNumber = 1;\n        for (int i = 1; i < nthNumber ; i++) {\n\n            previouspreviousNumber = previousNumber;\n\n            previousNumber = currentNumber;\n\n            currentNumber = previouspreviousNumber + previousNumber;\n\n        }\n        return float(currentNumber);\n}\n\nfloat mod1(float a,float b){\n\n    //a += collatz(a/8./2.,b)*4.;\n    //a += mod(a/8.,2.) - mod(a/8.,3.);\n    \n    return \n        mod(a,b)\n        //mod(a+4.*floor(a/2.),b)\n        //mod(floor(a*8./b)/2.,b)*2.\n        //mod(a+mod(a,b+3.),b)\n        //mod(a+floor(a/2.)-floor(a/4.),b)\n        //mod(a+floor(a/2.),b)\n        //mod(a+floor(a/4.),b)\n        //mod(a-mod(a,5.)+mod(a,4.),b)\n        //mod(a+mod(a+mod(-a,3.),5.)+mod(a+mod(-a,5.),3.),b)\n        //mod(a+floor(floor(a/8.)/3.)-floor(floor(a/8.)/2.),b)\n        //mod(a+3.*floor(floor(a)/3.),b)\n    ;\n}\n\n\n\nfloat fmod(float a, float b){\n    \n    /*\n    for(float i = 1.; i < mod(floor(a/b),5.); i++){\n        a /= 2.0;\n        //a /= 1.0+mod(floor(a),2.);\n        a += mod1(floor(a),b)*i;\n    }\n    */\n    \n    //a *= (mod(a/8.,3.)-mod(a/8.,2.));\n\n    \n    //a += (mod(a/8.,3.)-mod(a/8.,2.));\n    \n    //a += floor(16.*fractal(vec2(floor(a),floor(a/2.))).y);\n    \n    float\n    t1 =\n        mod1(floor(b/2.),2.)\n        //mod1(floor((a/4.+b)/2.),2.)\n    ,\n    a1 =\n        floor(a+t1),\n    a2 = mod1(a1,3.),\n    a3 =\n        //mod(a1,4.+a2)\n        //mod1(a1+a1*sign(1.-t1),4.)\n        mod1(a1,4.)\n    ;\n    \n    return\n        //abs(mod(a1-mod(a1,3.+t1)-mod(a1,4.+t1),b+t1)-t1)\n        //mod(a1-mod(a1,3.+t1)-mod(a1,4.+t1),b)\n        //mod1(a1*sign(1.-t1)-a2-a3,b)\n        //floor(mod(a,b)-mod(a/2.,b)+1.)\n        mod1(a1-a2-a3,b)\n    ;\n}\n\nfloat prime_rhythm(float time){\n    \n    //time += mod(time,5.)-mod(time,3.);\n    //time += mod(time/8.,2.) - mod(time/8.,3.);\n    //time += collatz(time/4.,8.)*2.;\n    \n    return (1.+fmod(time/4.,2.))/(1.+fmod(time/2.,2.));\n}\n\nfloat fmod1(float a, float b){\n    //a += collatz(a,mod(a,b))*2.;\n    \n    //a += collatz(mod(floor(a),4.)+floor(a/8.),4.);\n    \n    //a += ((mod(a/2.,3.)-mod(a/2.,5.)));\n    \n    //a += fibonacci(mod(floor(a),64.));\n    //a -= floor((a)/8./8./2.);\n    //a += prime_rhythm(a);\n    return fmod(a,b);\n}\n\n\n//oud\n//#define fract1(a) (1.-pow(fract(-a),1./(2.-fract(-a))))\n\n//gamelan\n#define fract1(a) (1.-pow(fract(-a),2.))\n\n//#define fract1(a) fract(a)*fract(a)\n\n//#define fract1(a) pow(fract(a),1.+log(2.)-log(1.+fract(a)))\n//#define fract1(a) pow(fract(a),1.+atan(2.)-atan(1.+fract(a)))\n\n//#define fract1(a) log(1.+fract(a)*fract(a))/log(2.)\n\nvec2 synth_(vec2 a1,vec2 a,vec2 a2,vec2 a3,vec2 nb,vec2 a4){\n    return log(a1+a*abs(a2-abs(.5-a3*vec2(fract1(nb.x*.998),fract1(nb.y)))*a4));\n}\n#define synth(a1,a,a2,a3,nb,a4) synth_(vec2(a1),vec2(a),vec2(a2),vec2(a3),vec2(nb),vec2(a4))\n\nvec2 banjo(vec2 a, vec2 nb){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./6.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,6./4.));\n}\n\nvec2 harp(vec2 a, vec2 nb){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,2.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.));\n}\n\nvec2 synth_drum(vec2 a, vec2 nb,float m2){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./m2)\n  + synth(1./8.,a,1./4.,1.,nb*2.,m2/4.));\n}\n\nvec2 oud(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(.5+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      +.5*log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 steel_drum(vec2 a, vec2 nb){\nreturn a/16./4.*abs(synth(1./2.,a,1./8.,1.,nb*4.,1.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.))\n;\n}\n\nvec2 gamelan(vec2 a, vec2 nb){\nreturn\na/16./4.*abs(synth(1./4.,a,1./8.,1.,nb*2.,1./2.)\n  +.5*synth(1./4.,a,1./4.,1.,nb*2.,1./2.)) \n;\n}\n\nvec2 sitar(vec2 a, vec2 nb){\nreturn a/16./2.*abs(log(1./8.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  -log(1./16.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2./4.)));\n}\n\nvec2 sitar1(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      -log(1./4.+a*(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 sitar2(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+a*a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      -log(1./2.+(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 sitar3(vec2 a, vec2 nb){\n    return a/16./4.*abs(log(1./2.+.5*a*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n      -log(1./2.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n    ;\n}\n\nvec2 sitar4(vec2 a, vec2 nb){\n    return (1.+a)/16./8.*abs(log(1./2.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n      -log(1./2.+a*a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n    ;\n}\n\nvec2 mainSound1(int samp, float time,float scale,float duration){\n  //time += collatz(time,mod(time,8.));\n  \n  //time += mod(time/8.,2.) - mod(time/8.,3.);\n  \n  //time += prime_rhythm(time*8.);\n  float s1 =\n      8.,\n  tempo1 =\n      prime_rhythm(time)\n      //prime_rhythm(time)/prime_rhythm(time/2.)\n  ,\n  tempo2 =\n      prime_rhythm(time+7.)\n      //prime_rhythm(time+7.+tempo1)\n      //prime_rhythm(time+7.*floor(time/8.))\n  ,\n  tempo3=\n      prime_rhythm(time+11.)\n      //prime_rhythm(time+11.+tempo1)\n  ,\n  t = s1*time/4./tempo1,\n  t4 = t/tempo3/(1.+fmod(t/8.,2.)),\n  t1 =\n       fmod(t4,2.)\n       //fmod(t4,2.)-fmod(time,3.)/2.\n       //fmod(t4+fmod(t4/2.,2.),2.)\n  ,\n\n  t5 = t*2./tempo2,\n  t3 =\n      (1.+fmod(t5,2.))\n      //(1.+fmod(t5+fmod(t5/2.,2.),2.))\n  ,\n\n  t6 = time*8./t3,\n  m3 =\n      floor(fmod1(t6*2.,s1/2.)/2.),\n  m2 =\n      1. + fmod1(t/t3/2.,s1/2.)\n      //1. + fmod1(t/t3/2.+fmod1(time,8.),s1/2.)\n  ,note= m3+m2-t1*4.\n  ;\n  vec2 a=\n      //vec2(log(fract(t/2./prime_rhythm(time+14.))/8.)*log(fract(t/prime_rhythm(time+7.))/8.))\n      //vec2((1.-log(fract(t/2./prime_rhythm(time+14.))/2.))*(1.-log(fract(t/prime_rhythm(time+7.))/4.)))\n      //-vec2((log(1./128./4.+fract1(t/2./prime_rhythm(time+14.))/2./duration)),(log(1./128./4.+fract1(t/prime_rhythm(time+7.))/4./duration)))\n  \n      -vec2(log(1./128.*2.+fract1(t/tempo2)/4./duration))\n\n      //-vec2((log(1./128./4.+fract1(t/2./prime_rhythm(time+14.))/2./duration)))\n\n  ,\n  nb =\n      t*vec2(pow(2.,note/7.+scale))*tempo1\n      //vec2(t*pow(2.,(m3+m2-t1*4.*sign(1.-t3))/7.+6.)*tempo1)\n  ;\n  return\n      //log(abs(.5-vec2(fract1(nb.x+.5),fract1(nb.y)))*a)\n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb.x+.5),fract(nb.y)))*a))\n      //abs(log(a*abs(1./4.-abs(.5-vec2(fract1(nb.x+.5),fract1(nb.y*2.))))))\n      \n\n      //banjo\n      //a/16./8.*abs(log(1./8.+a*abs(1./8.-.5*abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))))\n      //-log(1./8.+.5*a*abs(abs(1./2.-vec2(fract1(nb.x*.998),fract1(nb.y))))))\n\n      //oud\n      oud(a,nb*2.)\n        \n      //sitar1(a,nb*2.)\n      //sitar\n      //a/16./2.*abs(log(1./8.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n      //-log(1./16.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2./4.))) \n        \n      \n      //sitar\n      //abs(oud(a,nb*2.)-oud(a,nb*4.)/2.)\n  \n      //a/16./4.*abs(\n      //synth(1./4.,a,1./8.,1.,nb*4.,4./6.)\n      //+ synth(1./8.,a,1./4.,1.,nb*2.,6./4.))\n  \n  ;\n}\n\nvec2 mainSound1(int samp, float time,float scale){\n    return mainSound1(samp,time,scale,1.);\n}\n\nvec2 violin(int a,float b,float c){\n    return\n        //sounds like violin (using sitar3)\n        (2.*mainSound1(a,b*2.,5.+c,1./2.)-mainSound1(a,b*2.,5.+c,1./4.))\n        -(mainSound1(a,b*2.,4.+c,1./2.)-mainSound1(a,b*2.,4.+c,1./4.))\n        \n        //sounds like sitar (using sitar3 or sitar4)\n        //(2.*mainSound1(a,b*2.,5.,1./2.,8.)-mainSound1(a,b*2.,5.,1./4.,8.))\n        //-(mainSound1(a,b*2.,4.,1./2.,8.)-mainSound1(a,b*2.,4.,1./4.,8.))\n        \n    ;\n}\n\nvec2 mainSound(int a,float b){\n    float scale = 5.5;\n    //b += mod(-b,3.)+mod(b,5.);\n    return\n        //sqrt(mainSound1(a,b,5.5)*mainSound1(a,b,6.5))\n        \n        //abs(mainSound1(a,b/2.,6.5,2./2.)+mainSound1(a,b/2.,8.5,2.)/4.)/2.\n        \n        //some really cool distortion!\n        //abs(mainSound1(a,b/2.,6.5,1.)-mainSound1(a,b/2.,7.5,8.)/2.)\n        \n        //oud (with distortion)\n        4.*(mainSound1(a,b/2.,scale,1./2.)-mainSound1(a,b/2.,scale+1.,4.)/4.)\n        \n        //oud\n        //mainSound1(a,b/2.,6.,1./2.)-mainSound1(a,b/2.,6.,1./4.)/4.\n        //mainSound1(a,b/2.,6.,1.)+mainSound1(a,(b+8.)/2.,6.-3./7.,1./2.)\n\n        \n        //violin(a,b/4.,2.)\n        \n        //using sitar2\n        //(mainSound1(a,b/2.,7.25,1./2.)-mainSound1(a,b/2.,6.25,2.))*2.\n\n        //flute\n        //abs(mainSound1(a,b/2.,8.25,1.)-mainSound1(a,b/2.,8.25,1./2.)/2.-mainSound1(a,b/2.,8.25,1./4.)/4.)\n\n\n        //sitar\n        //abs(mainSound1(a,b/2.,8.,1./2.)-mainSound1(a,b/2.,9.,1.)/4.)\n\n        \n        //abs(mainSound1(a,b,7.,2.)/4.+mainSound1(a,b,6.,1./2.))\n\n        //abs(mainSound1(a,b*2.,7.)-mainSound1(a,b,6.))\n        //abs(mainSound1(a,b,6.)-mainSound1(a,b,7.)/4.)\n        //(mainSound1(a,b,6.)+mainSound1(a,b/2.,5.))/2.\n    ;\n}\n", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clyfRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 129], [158, 158, 203, 203, 378], [380, 380, 402, 402, 1730], [1732, 1732, 1789, 1789, 2049]], "test": "untested"}
{"id": "dlVfzc", "name": "Hypsometric palette (âwiki-2.0)", "author": "FordPerfect", "description": "Unlike [url]https://www.shadertoy.com/view/dtGfRV[/url], handles negative heights as well.\n\nLeft - flat, right - hill-shaded.\nTop - discrete, bottom - continuous palette.", "tags": ["heightmap", "topography", "cartography", "hypsometric"], "likes": 4, "viewed": 149, "published": 3, "date": "1702353005", "time_retrieved": "2024-07-30T17:17:04.220946", "image_code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Hypsometric palette somewhat based on\n//     http://soliton.vm.bytemark.co.uk/pub/cpt-city/wkp/template/tn/wiki-2.0.png.index.html\n//     http://soliton.vm.bytemark.co.uk/pub/cpt-city/wkp/country/tn/wiki-france.png.index.html\n// with input data interpreted as sRGB color triplets.\n// NOTE: the original palette (wiki-2.0 by Eric Gaba (Sting)) is itself in\n// the public domain.\n// Range: -1..+1, discrete/continuous (corresponds roughly to -5000m .. +5000m).\n// NOTE: output colors are in linear RGB.\n// NOTE: nonlinear (sqrt) input transform tries to roughly match\n// the distribution of isovalues in wiki-france above.\nvec3 hypsometric(float x,bool discrete)\n{\n    x=clamp(x,-1.0,1.0);\n    if(x>0.0)\n    {\n        x=sqrt(x)*19.0;\n        if(discrete) x=floor(x)+0.5;\n        return vec3(0.471,0.686,0.435)\n            +max(x- 0.0,0.0)*vec3(-0.116,-0.110,-0.118)\n            +max(x- 1.5,0.0)*vec3( 0.230, 0.172, 0.172)\n            +max(x- 6.5,0.0)*vec3(-0.179,-0.146,-0.117)\n            +max(x-13.5,0.0)*vec3( 0.168, 0.217, 0.223);\n    }\n    else\n    {\n        x=-sqrt(-x)*10.0;\n        if(discrete) x=floor(x)+0.5;\n        return vec3(\n            0.75+0.1*x+0.004*x*x,\n            0.9+0.05*x,\n            min(min(1.135+x*0.047,0.985-0.015*x),1.0));\n    }\n}\n\n//==============================================================================\n// Terrain with derivatives, based on https://www.shadertoy.com/view/DtdyDl\n\n// https://www.shadertoy.com/view/dllSW7\nuint hash(uint x)\n{\n    x^=x>>15;\n    x^=(x*x)|1u;\n    x^=x>>17;\n    x*=0x9E3779B9u;\n    x^=x>>13;\n    return x;\n}\n\nfloat rnd2i(ivec2 v)\n{\n    return float(int(hash(uint(v.x+65536*v.y))))*4.6566129e-10;\n}\n\n// 2D value noise. Gradient in xy, value in z.\nvec3 noise2d(vec2 v)\n{\n    ivec2 i=ivec2(floor(v)),e=ivec2(0,1);\n    v=fract(v);\n    float A=rnd2i(i+e.xx);\n    float B=rnd2i(i+e.yx);\n    float C=rnd2i(i+e.xy);\n    float D=rnd2i(i+e.yy);\n    vec2 d=30.0*v*v*(v*(v-2.0)+1.0);\n    v=v*v*v*(v*(v*6.0-15.0)+10.0);\n    return vec3(\n        vec2(mix(B-A,D-C,v.y),mix(C-A,D-B,v.x))*d,\n        mix(mix(A,B,v.x),mix(C,D,v.x),v.y));\n}\n\n// Terrain function. Height in z, gradient in xy.\nvec3 f(vec2 v)\n{\n    vec3 ret=vec3(0);\n    float w=1.0;\n    mat2 m=mat2(0.6,0.8,-0.8,0.6),A=2.5*m;\n    for(int i=0;i<6;++i)\n    {\n        vec3 r=w*noise2d(A*v);\n        r.xy=r.xy*A;\n        ret+=r;\n        A*=1.75*m;\n        w*=0.49;\n    }\n    ret=0.25*ret+0.75*vec3(3.0*ret.z*ret.z*ret.xy,ret.z*ret.z*ret.z);\n    return ret;\n}\n\n//==============================================================================\n// Main function.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy=(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 h=f(xy+0.1*iTime);\n    if(false&&xy.y>0.0) // Debug derivatives.\n    {\n        float eps=1e-3;\n        float dx=(f(xy+0.1*iTime+vec2(eps,0.0)).z-f(xy+0.1*iTime-vec2(eps,0.0)).z)/(2.0*eps);\n        float dy=(f(xy+0.1*iTime+vec2(0.0,eps)).z-f(xy+0.1*iTime-vec2(0.0,eps)).z)/(2.0*eps);\n        h.xy=vec2(dx,dy);\n    }\n    vec3 col=hypsometric(h.z,(xy.y>0.0));\n    if(xy.x>0.0) col*=max(dot(normalize(vec3(h.xy,16.0)),normalize(vec3(1,-1,2))),0.0); // Hill-shading.\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlVfzc.jpg", "access": "api", "license": "public-domain", "functions": [[68, 692, 733, 733, 1330], [1490, 1531, 1550, 1550, 1645], [1647, 1647, 1669, 1669, 1735], [1737, 1784, 1806, 1806, 2159], [2161, 2211, 2227, 2227, 2538], [2640, 2640, 2697, 2697, 3344]], "test": "untested"}
{"id": "dlKBRc", "name": "piramide_ 2-1 ", "author": "jorge2017a2", "description": "piramide_ 2-1 ", "tags": ["piramide21"], "likes": 12, "viewed": 130, "published": 3, "date": "1702347058", "time_retrieved": "2024-07-30T17:17:05.337959", "image_code": "//----------image\n//por jorge2017a2-\n//piramide_ 2-1 \n//---11-dic-2023-\n//referencia iq funciones\n\n#define MAX_STEPS 100\n#define MAX_DIST 200.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nvec2 piramide(vec3 p, vec2 res, float r1, float r2, float he, float opcol)\n{   float d1a=sdTrapezoid(p.xy, r1, r2,he);\n    float d1b=sdTrapezoid(p.zy, r1, r2,he);\n    float df=Intersect(d1a,d1b);\n    res =opU2(res, vec2(df,opcol));\n    return res;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n     p.y=p.y+10.0;\n    vec3 p0=p;\n    float planeDist1 = p.y+10.0;  //piso inf\n    res =opU2(res, vec2(planeDist1,101.0));\n    res= piramide(p, res,30., 0.5, 30.0,100.0); //grande\n    p.x=abs(p.x)-8.0;\n    p.z=abs(p.z)-35.0;\n    res= piramide(p-vec3(35.0,0.0,-10.0), res,7., 1.0, 60.0,102.0);\n    p=p0;\n    res= piramide(p-vec3(-120.0,0.0,80.0), res,100., 1.0, 120.0,102.0);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n     vec3 V = normalize(ro - p);\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n    float shadow = getSoftShadow(worldPos, L);// shadows\n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.5)*specular*specular;\n    return colOut;\n}\n\n\nvec3 Getluz(vec3 ro,vec3 p, vec3 lp, vec3 lcol,vec3 n, float diffp, vec3 specp)\n{\n    vec3 v=normalize(ro-p);\n    vec3 h=normalize(lp+v);\n    vec3 l=normalize(lp-p);\n    float ndh=max(0.0,dot(n,h));\n    float ndl=max(0.0,dot(n,l));\n    float ndv=max(0.0,dot(n,v));\n    \n    float diff=ndl*diffp;\n    vec3  spec=0.8*pow(ndl,10.0)*specp;\n    vec3 col=(diff+spec*lcol);\n    return col;\n    \n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tvec3 col;\n    if (i==100 )\n    { col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel0, p/32., nor)*vec3(0.5,0.4,0.01)*2.5; }\n\tif (i==102 ) { return tex3D(iChannel0, p/64., nor).x*vec3(0.5)*2.5;; }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n    return vec3(0.0);\n}\n\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\n\n\n\nfloat N21 (vec2 p){\n    return fract( sin(p.x *  100. + p.y * 6574.) * 5647.);\n}\n\nfloat SmoothNoise(vec2 uv){\n    vec2 lv = smoothstep(0., 1., fract(uv));\n    vec2 id = floor(uv);\n    float bl = N21(id);\n    float br = N21(id + vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = N21(id + vec2(0, 1));\n    float tr = N21(id + vec2(1, 1));\n    float t = mix(tl, tr, lv.x);\n    return mix(b, t, lv.y);\n}\n\nfloat smoothNoise2(vec2 uv){ \n    float c = SmoothNoise(uv*4.);\n    c += SmoothNoise(uv*8.)* 0.5;\n    c += SmoothNoise(uv*16.) * 0.25;\n    c += SmoothNoise(uv*32.) * 0.125;\n    c += SmoothNoise(uv*64.) * 0.0625;\n    return c/2.;\n}\n\n///https://www.shadertoy.com/view/dttcDN\nvec3 nubes(vec2 uv )\n{float c = smoothNoise2(uv) + 0.2 + 0.4*sin(iTime);\n    vec3 col = vec3(c/1.5, c/1.2, c);\n    return col;\n}\n\n\nvec3 render_sky_color(vec3 rd)\n{   vec3 col=nubes(rd.xy);\n    vec3  sky = mix(col*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    float d1= sdCircle(rd.xy-vec2(0.0,0.15), 0.15 );\n    sky= DrawFigBorde(vec3(1.0,0.0,0.0), sky,d1 );\n    return sky;\n}\n\n\n//https://www.shadertoy.com/view/WdsGR7\nvec3 getColor(float v)\n{  float r = cos((v-0.78)*PI*1.66);\n   float g = cos((v-0.58)*PI*1.66);\n   float b = cos((v-0.28)*PI*1.66);\n   return vec3(r,g,b); \n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }\n    \n   if (id_color>=100 )\n   { return  getColorTextura( p, nor,id_color); }\n      \n  return vec3(0.0);\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n        result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n//https://www.shadertoy.com/view/7dKfRt\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nmat3 cameraToWorld(vec3 ro,vec3 lookAt){\n    vec3 a = normalize(lookAt - ro);\n    vec3 b = cross(vec3(0.,1.,0),a);\n    vec3 c = cross(a,b);\n    return mat3(b,c,a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n    float t0=iTime;\n    float t=mod(t0*5.0,500.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n      vec3 ro = vec3(40.* cos(t0),5.,40.* sin(t0));\n   vec3 rd;\n   \n   float va=5.0*sin(iTime);\n   \n    if(va>0.0)  \n    rd = cameraToWorld(ro,vec3(0.,0.,20.)) * vec3(uv,1.);\n    else\n    {\n    rd = cameraToWorld(ro-vec3(0.0,2.0,-10.0),vec3(0.,0.,40.)) * vec3(uv,1.);\n    rd= rotate_z(rd, radians(45.0));\n    \n    }\n    \n    if(va*12.0>0.0)\n    {\n       //rd= rotate_z(rd, radians(25.0)); \n       rd= rotate_x(rd, radians(15.0));\n       rd= rotate_y(rd, radians(45.0));\n     }\n    \n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\nstruct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.7333, 0.1412, 0.1412), //33\nvec3(0.1843, 0.3333, 0.1843), //34\n vec3(0.6549, 0.6549, 0.9922), //35\n vec3(0.8549, 0.8549, 0.8549)  //36\n);\n\nvec3 getColor(int i)\n{   //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 )  return Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlKBRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[483, 483, 527, 527, 554], [555, 555, 595, 595, 622], [623, 623, 668, 668, 696], [698, 698, 734, 734, 779], [781, 781, 815, 815, 911], [912, 912, 946, 946, 1037], [1038, 1038, 1072, 1072, 1163], [1164, 1164, 1198, 1198, 1289], [1291, 1291, 1316, 1316, 1335], [1336, 1336, 1361, 1361, 1380], [1381, 1381, 1417, 1417, 1445], [1447, 1447, 1512, 1512, 1821], [1823, 1823, 1899, 1899, 2072], [2074, 2074, 2099, 2099, 2524], [2526, 2526, 2550, 2550, 2712], [2714, 2714, 2762, 2762, 3041], [3043, 3043, 3087, 3087, 3408], [3410, 3410, 3447, 3447, 3704], [3706, 3706, 3796, 3796, 4753], [4756, 4756, 4837, 4837, 5145], [5147, 5147, 5196, 5196, 5510], [5676, 5676, 5738, 5738, 5868], [5870, 5870, 5905, 5905, 5928], [5933, 5933, 5952, 5952, 6013], [6015, 6015, 6042, 6042, 6347], [6349, 6349, 6377, 6377, 6579], [6581, 6622, 6644, 6644, 6750], [6753, 6753, 6785, 6785, 6992], [6995, 7035, 7059, 7059, 7191], [7193, 7193, 7263, 7263, 7461], [7463, 7463, 7490, 7490, 7579], [7581, 7581, 7639, 7639, 7687], [7689, 7689, 7712, 7712, 7824], [7826, 7826, 7857, 7857, 8476], [8478, 8518, 8565, 8565, 8777], [8779, 8779, 8819, 8819, 8944], [8946, 8946, 9003, 9003, 9849]], "test": "untested"}
{"id": "DtVfRc", "name": "ui tabs", "author": "ArmandB", "description": "another basic ui element for whatever you want\n", "tags": ["mouse", "sdf", "input"], "likes": 4, "viewed": 141, "published": 3, "date": "1702341417", "time_retrieved": "2024-07-30T17:17:07.981890", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //make sure your mouse coordinates in buffer A are in uv coords\n    vec2 uv = uv_transform(fragCoord,iResolution.xy);\n    float pxunit = 1.0/iResolution.y; //the size of a pixel for blending\n\n    //position of handle\n    int selected = int(texelFetch(iChannel0,ivec2(0,0),0).x);\n    //vec2 p = toggled ? vec2(-toggleRadius,0) : vec2(toggleRadius,0);\n    \n    vec3 col = mix(vec3(0.8),vec3(1),float(abs(mod(uv.x,0.1) - mod(uv.y,0.1)) > 0.05));\n    \n    bool isTab = false;\n    for (int i = 0; i < tabs; i++){\n        vec2 offset = vec2(float(i)*(tabSize.x*2.0 + 0.03),0);\n        if (uv.x < tabSize.x + offset.x + 0.015 && uv.x > -tabSize.x + offset.x - 0.015 && uv.y < tabSize.y + 0.015 && uv.y > -tabSize.y){\n            if (i == selected){\n                float innerdist = min(sdRoundBox(uv - offset, tabSize, vec4(tabCorner,0,tabCorner,0)), uv.y + tabSize.y - pxunit*2.0 - 0.002);\n                col = mix(col, vec3(0.6), smoothstep(0.0, pxunit, innerdist));\n                col = mix(col, vec3(0.2), smoothstep(0.0, pxunit, 0.002-abs(innerdist)));\n            } else {\n                float innerdist = sdRoundBox(uv - offset, tabSize, vec4(tabCorner,0,tabCorner,0));\n                float edgedist = uv.y + tabSize.y - pxunit*2.0 - 0.002;\n                vec3 tabcol = mix(vec3(0.8), vec3(0.6), smoothstep(0.0, pxunit, innerdist));\n                tabcol = mix(tabcol, vec3(0.2), smoothstep(0.0, pxunit, 0.002-abs(innerdist)));\n                col = mix(col, tabcol, smoothstep(0.0, pxunit, edgedist));\n                col = mix(col, vec3(0.2), smoothstep(0.0, pxunit, 0.002-abs(edgedist)));\n            }\n            isTab = true;\n        }\n    }\n    if (!isTab){\n        float edgedist = uv.y + tabSize.y - pxunit*2.0 - 0.002;\n        col = mix(col, vec3(0.6), smoothstep(0.0, pxunit, edgedist));\n        col = mix(col, vec3(0.2), smoothstep(0.0, pxunit, 0.002-abs(edgedist)));\n    }\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = vec4(0);\n    if (floor(fragCoord) == vec2(0,0)){\n        float index = texelFetch(iChannel0,ivec2(0,0),0).x;\n        vec2 mc = uv_transform(abs(iMouse.zw),iResolution.xy);\n        float idx = floor((mc.x + tabSize.x)/(tabSize.x*2.0 + 0.03));\n        vec2 offset = vec2(idx*(tabSize.x*2.0 + 0.03),0);\n        if (iMouse.w >= 0.0 && sdRoundBox(mc - offset, tabSize, vec4(tabCorner,0,tabCorner,0)) < 0.0){\n            index = idx;\n        }\n        \n        data = vec4(index,0,0,0);\n    }\n    fragColor = data;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const vec2 tabSize = vec2(0.15,0.12);\nconst float tabCorner = 0.05;\nconst int tabs = 5;\n\nvec2 uv_transform(vec2 uv, vec2 res){\n    return (uv - res/2.0)/res.y - vec2(-0.65,0);\n}\n\nvec2 pointOnLine(vec2 a, vec2 b, vec2 p){\n    vec2 ab = b - a;\n    return a + clamp(dot(p - a, ab)/dot(ab, ab),0.0,1.0)*ab;\n}\n\nfloat sdLine(vec2 a, vec2 b, vec2 p){\n    return distance(p,pointOnLine(a,b,p));\n}\n\n//https://www.shadertoy.com/view/4llXD7\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r ) {\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\n#define PI 3.14159", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtVfRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 124, 2019]], "test": "untested"}
{"id": "DtVBz3", "name": "simple toggle", "author": "ArmandB", "description": "another basic ui element for whatever you want\n", "tags": ["mouse", "sdf", "input"], "likes": 4, "viewed": 149, "published": 3, "date": "1702333826", "time_retrieved": "2024-07-30T17:17:09.118850", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //make sure your mouse coordinates in buffer A are in uv coords\n    vec2 uv = (fragCoord - iResolution.xy/2.0)/iResolution.y;\n    float pxunit = 1.0/iResolution.y; //the size of a pixel for blending\n\n    //position of handle\n    bool toggled = texelFetch(iChannel0, ivec2(0,0), 0).x > 0.0;\n    vec2 p = toggled ? vec2(-toggleRadius,0) : vec2(toggleRadius,0);\n    \n    vec3 col = mix(vec3(0.8),vec3(1),float(abs(mod(uv.x,0.1) - mod(uv.y,0.1)) > 0.05));\n    float innerdist = toggleRadius - sdLine(vec2(-toggleRadius,0), vec2(toggleRadius,0), uv);\n    float handledist = toggleRadius - distance(uv,p);\n    col = mix(col, toggled ? vec3(0.7) : vec3(0.9), smoothstep(0.0, pxunit, innerdist)); //slider background\n    col = mix(col, vec3(0.2), smoothstep(0.0, pxunit, 0.002-abs(innerdist))); //slider border\n    col = mix(col, vec3(1), smoothstep(0.0, pxunit, handledist)); //handle\n    col = mix(col, vec3(0.2), smoothstep(0.0, pxunit, 0.002-abs(handledist))); //handle border\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = vec4(0);\n    if (floor(fragCoord) == vec2(0,0)){\n        bool toggled = texelFetch(iChannel0,ivec2(0,0),0).x > 0.0;\n        vec2 mc = uv_transform(abs(iMouse.zw),iResolution.xy);\n        if (iMouse.w >= 0.0 && sdLine(vec2(-toggleRadius,0), vec2(toggleRadius,0), mc) < toggleRadius){\n            toggled = !toggled;\n        }\n        \n        data = vec4(toggled,0,0,0);\n    }\n    fragColor = data;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float toggleRadius = 0.1;\n\nvec2 uv_transform(vec2 uv, vec2 res){\n    return (uv - res/2.0)/res.y;\n}\n\nvec2 pointOnLine(vec2 a, vec2 b, vec2 p){\n    vec2 ab = b - a;\n    return a + clamp(dot(p - a, ab)/dot(ab, ab),0.0,1.0)*ab;\n}\n\nfloat sdLine(vec2 a, vec2 b, vec2 p){\n    return distance(p,pointOnLine(a,b,p));\n}\n\n#define PI 3.14159", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtVBz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 124, 1091]], "test": "untested"}
{"id": "mlGfzc", "name": "sweepy thingy (AA test)", "author": "hnh", "description": "I had originally designed this for testing filters - then started playing...\nIt's similar to the Siemens star put on steroids by ramping the duty cycle. \nFeel free to test your own filter function by replacing smoothstep.\nBest in full screen.", "tags": ["2d", "test", "filter", "antialiasing", "pattern", "fan"], "likes": 4, "viewed": 135, "published": 3, "date": "1702331674", "time_retrieved": "2024-07-30T17:17:10.114189", "image_code": "// I had originally designed this as a test pattern for filters - then started playing...\n// It is similar to the Siemens star (e.g. used in photography, printers) put on steroids \n// by ramping the duty cycle. Feel free to test your own filter function by\n// replacing smoothstep. Best in full screen.\n\n#define R iResolution\n\nvoid mainImage(out vec4 O, vec2 U) {\n    U = (R.xy*.5-U)/R.y;    \n    \n    float N = sqrt(R.y)*5.,  // # blades\n    r = length(U),\n    a = atan(U.x,U.y)/3.1415*.5 + .5,    \n    d = 1./(N*(1. + .3*sin(-iTime*.2))),  // breathe\n    s = fract(float(iFrame)/N);\n    a += float(a<s) - s;  // turn\n\n    a = abs(mod(a-d/4.,d)-d/2.) - a*d/2.;\n\n    a *= r;\n    a = -max(-a,r-.4);  // disc\n    \n    a = smoothstep(1.,-1.,a*R.y/.25);  // your filter here\n    \n    O = vec4(sqrt(a));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlGfzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[327, 327, 363, 363, 800]], "test": "untested"}
{"id": "mtGfRc", "name": "Weird Compiler Behavior", "author": "oneshade", "description": "Wut?", "tags": ["behavior", "compiler", "unusual"], "likes": 1, "viewed": 175, "published": 3, "date": "1702327043", "time_retrieved": "2024-07-30T17:17:10.920036", "image_code": "void mainImage(out vec4 o, vec2 u) {\n    float wtf = (0.0, 0.25, 0.5, 0.75, 1.0);\n    o = vec4(wtf);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtGfRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 102]], "test": "untested"}
{"id": "dtyczD", "name": "BC: Box Pattern", "author": "BackwardsCap", "description": "https://twitter.com/Pixelated_Donut/status/1724430051280568407/", "tags": ["pattern"], "likes": 13, "viewed": 197, "published": 3, "date": "1702322494", "time_retrieved": "2024-07-30T17:17:11.767768", "image_code": "#define TAU 6.283\n#define pow(a,b) pow(abs(a),b)\n//#define SHIFT\n\nvec2 f(vec2 p)\n{\n    vec2 t = vec2(pow(p.x,2.)-pow(p.y,2.), -2.*p.x*p.y);\n    float b = pow(p.x,4.) + pow(p.y,4.) + 2.*pow(p.x,2.)*pow(p.y,2.);\n    return (t/b)-(p/3.);\n}\n\nvec2 P(vec2 p, float i)\n{\n    vec2 v = f(f(f(f(f(f(p))))));\n    float ti = TAU * (i/3.0);\n    \n    #ifdef SHIFT\n    ti -= iTime - p.x * p.x * length(p);\n    #endif\n\n    return v - vec2(cos(ti),sin(ti));    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float[] p = float[3](length(P(uv, 1.0)), length(P(uv,2.0)), length(P(uv,3.0)));\n    \n    vec3 c = vec3(0);\n    \n    if(p[0] <= min(p[1],p[2])) c = vec3(0.557,0.286,0.961);\n    if(p[1] <= min(p[2],p[0])) c = vec3(0.000,0.114,0.643);\n    if(p[2] <= min(p[0],p[1])) c = vec3(0.129,0.376,0.780);\n    \n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtyczD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 82, 82, 236], [238, 238, 263, 263, 446]], "test": "untested"}
{"id": "cltBDl", "name": "Dithering with lines", "author": "Zhiting", "description": "Try to use functions to generate the matrix for order dithering", "tags": ["dithering"], "likes": 3, "viewed": 151, "published": 3, "date": "1702321831", "time_retrieved": "2024-07-30T17:17:12.515768", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float pi = 3.14159; \n    vec3 col = vec3(0.0,0.0,0.0);\n    vec4 img = texture(iChannel0, uv);\n    //float comp = /64.0\n    \n    \n    // grayscale = 0.299 â Red + 0.587 â Green + 0.114 â Blue\n    float grays = 0.299 * img.x + 0.587 * img.y + 0.114 * img.z;\n    \n    float period;\n    float numDis = 10.0;\n    float width = 10.0;\n    period= width/(1.0 - floor(grays*numDis)/numDis);\n    period = 20.0;\n    \n    float func;\n    float theta = 30.0 + 10.0*iTime;\n    vec2 po = vec2(0, 0);\n    vec2 dir = vec2(cos(theta*pi/180.0), sin(theta*pi/180.0));\n    func = dot((fragCoord-po), dir);// + 30.0*iTime;\n    \n    \n    \n    // func = func / T\n    func = func / period;\n    //func = sin(func*pi);//func - floor(func);\n    func = func - floor(func);\n    if (func > 0.5){\n        func = 1.0 - func;\n    }\n    func = func * 2.0;\n    \n    float r = 0.1;\n  \n    //col = vec3(ceil(grays - func));\n    \n    //col = vec3(ceil(grays - func + r*(random (fragCoord)-0.5)));\n    \n    float red, green,blue; \n    red = ceil(img.x - func + r*(random(fragCoord)-0.5));\n    green = ceil(img.y - func + r*(random(fragCoord)-0.5));\n    blue = ceil(img.z - func + r*(random(fragCoord)-0.5));\n    col = vec3(red,green,blue);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);//vec4(col,1.0); img;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltBDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 96], [98, 98, 155, 205, 1539]], "test": "untested"}
{"id": "DlVfRK", "name": "pentagram", "author": "LydianLights", "description": "Another experiment with animation/tweens. It's actually a pretty nice system to work with.", "tags": ["animation"], "likes": 8, "viewed": 175, "published": 3, "date": "1702319173", "time_retrieved": "2024-07-30T17:17:13.566958", "image_code": "const float loopTime = 4.5;\nconst float radius = 0.9;\nconst float lineWidth = 0.01;\n\nconst float tImpact = 2.25;\nconst float tActivate = tImpact + 0.15;\n\nfloat wiggle = 0.0; // calculated globally\n\n#define pentaPtAngle(i) i / 5.0 * 2.0 * PI + PI / 2.0\n#define pentaPt(i) vec2(radius * cos(pentaPtAngle(i)), radius * sin(pentaPtAngle(i)))\n\nconst vec2 pt1 = pentaPt(0.0);\nconst vec2 pt2 = pentaPt(1.0);\nconst vec2 pt3 = pentaPt(2.0);\nconst vec2 pt4 = pentaPt(3.0);\nconst vec2 pt5 = pentaPt(4.0);\n\nfloat tween(float t, float start, float duration) {\n    return saturate(map01(t, start, start + duration));\n}\n\nvoid calcWiggle(vec2 uv) {\n    float s = floor(mod(12.0 * iTime, 4.0));\n    wiggle = 0.004 * noise(uv, 5.0, s);\n}\n\nfloat drawLine(vec2 uv, float t, float startTime, float duration, vec2 p1, vec2 p2) {\n    if (t < startTime) return 99999.0;\n    float m = tween(t, startTime, duration); m = easeInOut(m, 8.0);\n    return sdSegment(uv, p1, mix(p1, p2, m)) - lineWidth + wiggle;\n}\n\nfloat drawCircle(vec2 uv, float t, float startTime, float duration) {\n    if (t < startTime) return 99999.0;\n    float m = tween(t, startTime, duration); m = easeInOut(m, 6.0);\n    const float a0 = pentaPtAngle(2.0);\n    float a = a0 - 2.0 * PI * m;\n    return sdArc(uv, radius, a, a0) - lineWidth + wiggle;\n}\n\nvec3 scene(vec2 uv, float t) {\n    float px = 2.0 / iResolution.y;\n    bool invert = false;\n    if (t > tImpact && t < tActivate) { invert = true; }\n    if (t > tActivate) { uv.y *= -1.0; }\n    \n    float d = drawLine(uv, t, 0.0, 0.4, pt3, pt1);\n    d = min(d, drawLine(uv, t, 0.3, 0.4, pt1, pt4));\n    d = min(d, drawLine(uv, t, 0.6, 0.4, pt4, pt2));\n    d = min(d, drawLine(uv, t, 0.9, 0.4, pt2, pt5));\n    d = min(d, drawLine(uv, t, 1.2, 0.6, pt5, pt3));\n    d = min(d, drawCircle(uv, t, 1.7, 0.7));\n    \n    d = smoothstep(0.0, 2.0 * px, d);\n    if (!invert) { d = 1.0 - d; }\n    \n    return vec3(d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    calcWiggle(uv);\n    float t = mod(iTime, loopTime);\n    \n    vec3 color = scene(uv, t);\n    \n    if (t > tActivate) {\n        float m = tween(t, tImpact + 0.15, 1.5);\n        float s = 1.0 + 1.2 * m;\n        float o = 0.5 * (1.0 - m);\n        vec3 afterimage = scene(uv / s, t);\n        color += o * afterimage;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "#define PI 3.1415927\n\nfloat map01 (float t, float t0, float t1) {return (t - t0) / (t1 - t0); }\nfloat saturate (float x) { return min(max(x, 0.0), 1.0); }\nfloat dot2(vec2 v) { return dot(v,v); }\nfloat cro(vec2 a, vec2 b) { return a.x * b.y - a.y * b.x; }\n\n// thx iq, as always:\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdArc(in vec2 p, in float r, in float a1, in float a2) {\n    vec2 p1 = vec2(r * cos(a1), r * sin(a1));\n    vec2 p2 = vec2(r * cos(a2), r * sin(a2));\n    float c = cro(p1, p2);\n    float c1 = cro(p, p1);\n    float c2 = cro(p, p2);\n    float d1 = min(length(p - p1), length(p - p2));\n    float d2 = abs(length(p) - r);\n    if (a1 == a2) return d1;\n    return c > 0.0\n        ? c1 < 0.0 && c2 > 0.0 ? d2 : d1\n        : c1 < 0.0 || c2 > 0.0 ? d2 : d1;\n}\n\n// easing\nfloat easeIn(float x, float q) {\n    return pow(x, q);\n}\n\nfloat easeOut(float x, float q) {\n    return 1.0 - pow(1.0 - x, q);\n}\n\nfloat easeInOut(float x, float q) {\n    return x < 0.5\n        ? pow(2.0 * x, q) / 2.0\n        : 1.0 - pow(2.0 * (1.0 - x), q) / 2.0;\n}\n\n// Authors: Stefan Gustavson (stefan.gustavson@gmail.com)\n// and Ian McEwan (ijm567@gmail.com)\n// Version 2021-12-02\n// Copyright (c) 2021 Stefan Gustavson and Ian McEwan. Published under MIT license.\nfloat psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient) {\n\tvec2 uv = vec2(x.x + x.y*0.5, x.y);\n\tvec2 i0 = floor(uv);\n\tvec2 f0 = fract(uv);\n\tfloat cmp = step(f0.y, f0.x);\n\tvec2 o1 = vec2(cmp, 1.0-cmp);\n\tvec2 i1 = i0 + o1;\n\tvec2 i2 = i0 + vec2(1.0, 1.0);\n\tvec2 v0 = vec2(i0.x - i0.y * 0.5, i0.y);\n\tvec2 v1 = vec2(v0.x + o1.x - o1.y * 0.5, v0.y + o1.y);\n\tvec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n\tvec2 x0 = x - v0;\n\tvec2 x1 = x - v1;\n\tvec2 x2 = x - v2;\n\tvec3 iu, iv;\n\tvec3 xw, yw;\n\tif(any(greaterThan(period, vec2(0.0)))) {\n\t\txw = vec3(v0.x, v1.x, v2.x);\n\t\tyw = vec3(v0.y, v1.y, v2.y);\n\t\tif(period.x > 0.0)\n\t\t\txw = mod(vec3(v0.x, v1.x, v2.x), period.x);\n\t\tif(period.y > 0.0)\n\t\t\tyw = mod(vec3(v0.y, v1.y, v2.y), period.y);\n\t\tiu = floor(xw + 0.5*yw + 0.5);\n\t\tiv = floor(yw + 0.5);\n\t} else {\n\t\tiu = vec3(i0.x, i1.x, i2.x);\n\t\tiv = vec3(i0.y, i1.y, i2.y);\n\t}\n\tvec3 hash = mod(iu, 289.0);\n\thash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);\n\thash = mod((hash*34.0 + 10.0)*hash, 289.0);\n\tvec3 psi = hash * 0.07482 + alpha;\n\tvec3 gx = cos(psi);\n\tvec3 gy = sin(psi);\n\tvec2 g0 = vec2(gx.x,gy.x);\n\tvec2 g1 = vec2(gx.y,gy.y);\n\tvec2 g2 = vec2(gx.z,gy.z);\n\tvec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n\tw = max(w, 0.0);\n\tvec3 w2 = w * w;\n\tvec3 w4 = w2 * w2;\n\tvec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n\tfloat n = dot(w4, gdotx);\n\tvec3 w3 = w2 * w;\n\tvec3 dw = -8.0 * w3 * gdotx;\n\tvec2 dn0 = w4.x * g0 + dw.x * x0;\n\tvec2 dn1 = w4.y * g1 + dw.y * x1;\n\tvec2 dn2 = w4.z * g2 + dw.z * x2;\n\tgradient = 10.9 * (dn0 + dn1 + dn2);\n\treturn 10.9 * n;\n}\n\nfloat noise(vec2 x, float freq, float t) {\n    vec2 grad;\n    return psrdnoise(freq * (x + 0.621 * t), vec2(0.0), 0.0, grad);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlVfRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[495, 495, 546, 546, 604], [606, 606, 632, 632, 719], [721, 721, 806, 806, 982], [984, 984, 1053, 1053, 1293], [1295, 1295, 1325, 1325, 1901], [1903, 1903, 1958, 1958, 2387]], "test": "untested"}
{"id": "clyBzc", "name": "Helical Ramps", "author": "dr2", "description": "Balls rolling endlessly - with gravity", "tags": ["ball", "dynamics", "roll"], "likes": 24, "viewed": 279, "published": 3, "date": "1702315872", "time_retrieved": "2024-07-30T17:17:14.501459", "image_code": "#define O589(O751)(sin((O751)+vec2(0.5*O294,0.)))\n#define O899(O550)if(O651<O868){O868=O651;O674=O550;}\n#define O930(O550)if(O651<O868){O868=O651;O674=O550;O542=O511;}\n#define O503 min(O046,0)\nconst int O984=29,O077=4;vec3 O341[O984],O403[O984],O542,O891;float O023,O255,O279,O635,O775,O147,O658,O837,O992,O860,O325,O333[2];int O046,O674,O186;const int O767=1,O736=2,O705=3,O643=4,O612=6,O581=7;const float O294=3.1415927;float O356(vec3 O263,vec3 O945){vec3 O651;O651=abs(O263)-O945;return min(max(O651.x,max(O651.y,O651.z)),0.)+length(max(O651,0.));}float O418(vec3 O263,vec3 O945,float O697){return length(max(abs(O263)-O945,0.))-O697;}float O387(vec3 O263,float O666,float O271){return max(length(O263.xy)-O666,abs(O263.z)-O271);}float O449(vec3 O263,float O728,float O666){return length(vec2(length(O263.xy)-O666,O263.z))-O728;}vec2 O852(vec2 O511,float O031){vec2 O620;O620=sin(O031+vec2(0.5*O294,0.));return vec2(dot(O511,vec2(O620.x,-O620.y)),dot(O511.yx,O620));}vec2 O821(vec2 O511,vec2 O620){return vec2(dot(O511,vec2(O620.x,-O620.y)),dot(O511.yx,O620));}mat3 O162(float O116,float O062){vec2 O232,O434,O976;O232=vec2(O116,O062);O434=cos(O232);O976=sin(O232);return mat3(O434.y,0.,-O976.y,0.,1.,0.,O976.y,0.,O434.y)*mat3(1.,0.,0.,0.,O434.x,-O976.x,0.,O976.x,O434.x);}vec4 O124(vec3 O790,vec3 O697){vec3 O410,O565;float O868,O651,O310,O689;O868=O023;for(int O488=O503;O488<O984;O488++){O410=O790-O341[O488];O310=dot(O697,O410);O689=O310*O310-dot(O410,O410)+O279*O279;if(O689>0.){O651=-O310-sqrt(O689);if(O651>0.&&O651<O868){O868=O651;O542=O410+O651*O697;O565=O542/O279;O186=O488;}}}return vec4(O868,O565);}float O155(vec3 O790,vec3 O697,float O759){vec3 O410;float O868,O651,O310,O689;O868=O023;for(int O488=O503;O488<O984;O488++){O410=O790-O341[O488];O310=dot(O697,O410);O689=O310*O310-dot(O410,O410)+O279*O279;if(O689>0.){O651=-O310-sqrt(O689);if(O651>0.&&O651<O868)O868=O651;}}return 0.6+0.4*smoothstep(0.,O759,O868);}float O108(vec3 O263){vec4 O806;vec3 O511,O604,O100;float O868,O651,O379,O364,O914,O883,O961,O720,O480,O496;O868=O023;O364=0.25;O914=0.3;O961=0.3;O720=0.1;O883=0.22*O914;O806=vec4(0.85,0.7,0.3,0.1)*O914;O480=O325+O635;O100=sign(O263);O511=O263-vec3(0.,-0.5*O147*O775-0.2,0.);O651=O418(O511,vec3(vec2(O325+2.4*O635),0.2).xzy-0.02,0.02);O930(O612)O511=O263;O511.xz-=O480*O100.xz;O604=O511;O604.xz=O100.z*(O604.xz+O100.x*O604.zx*vec2(-1.,1.))/sqrt(2.);O604.y-=0.5*(atan(O604.z,-O100.z*O100.x*O604.x)/O294-O147+0.25*O100.z+0.5)*O775-O364;O379=(length(O604.xz)-O635)/O658;for(int O798=O503;O798<=O077;O798++){O651=min(length(vec2(2.*(abs(O379)-O806.x),O604.y-O806.y)),length(vec2(2.*(abs(O379)-O806.z),O604.y-O806.w)))-O883;O651=max(O651,abs(O511.y)-(0.5*O147+0.2)*O775);if(O798==0)O651=max(O651,-max(O263.y+0.5*O147*O775-3.*O364,abs(O263.z)-O480));else if(O798==O077)O651=max(O651,-O100.x*O511.x);O899(O767);O604.y-=O775;}O511=O263;O511.y+=0.1*O775;for(int O829=O503;O829<=1;O829++){O604=O511;if(O829==0){O604.y-=0.5*O147*O775;}else{O604.xz=O604.zx;O604.y+=0.5*(O147-0.5)*O775;}O604.z=abs(O604.z)-O325;O379=O604.z/O658;O651=min(length(vec2(2.*(abs(O379)-O806.x),O604.y-O806.y)),length(vec2(2.*(abs(O379)-O806.z),O604.y-O806.w)))-O883;O651=max(O651,abs(O604.x)-O480);O899(O767);}O511=O263;O511.xz=abs(O511.xz)-O325-O635;O651=O387(O511.xzy,0.1*O635,0.51*O147*O775);O899(O736);O511.y-=(0.1-0.5*(O147-0.5))*O775;O496=0.5*(O635+0.3*O658);for(int O798=O503;O798<O077;O798++){O604=O511;O604.z-=O496;O604.y-=0.06*O635;O651=max(O356(O604,vec3(0.02*O635,0.06*O635,O496)),-max(-O604.y-0.01*O635,abs(O604.z-0.38*O635)-0.18*O635));O899(O736);O604.yz-=vec2(0.5*O775,-2.*O496);O651=max(O356(O604,vec3(0.02*O635,0.06*O635,O496)),-max(-O604.y-0.01*O635,abs(O604.z+0.38*O635)-0.18*O635));O899(O736);O511.y-=O775;}O511=O263;O511.y+=0.5*(O147*O775-O658);O511.x=abs(O511.x)-O325;O651=O449(O511,0.07*O635,0.5*O658);O899(O705);for(int O829=O503;O829<=1;O829++){O511=O263;O511.xy-=vec2(O325*sign(float(O829)-0.5),-0.5*(O147*O775-O658));O651=O387(O511,0.5*O658,0.03*O635);O511.y+=0.2*O658-0.7*O658*O333[O829];O651=max(O651,-O511.y);O930(O643+O829);}return O868;}float O170(vec3 O790,vec3 O697){float O744,O651;O744=0.;for(int O798=O503;O798<120;O798++){O651=O108(O790+O744*O697);O744+=O651;if(O651<0.001||O744>O023)break;}return O744;}vec3 O139(vec3 O263){vec4 O472;vec2 O085;O085=1e-3*vec2(1.,-1.);for(int O798=O503;O798<4;O798++){O472[O798]=O108(O263+((O798<2)?((O798==0)?O085.xxx:O085.xyy):((O798==2)?O085.yxy:O085.yyx)));}O472.x=-O472.x;return normalize(2.*O472.yzw-dot(O472,vec4(1.)));}float O201(vec3 O790,vec3 O697){float O038,O651,O271;O038=1.;O651=0.02;for(int O798=O503;O798<40;O798++){O271=O108(O790+O651*O697);O038=min(O038,smoothstep(0.,0.02*O651,O271));O651+=O271;if(O038<0.05)break;}return 0.6+0.4*O038;}vec4 O093(){vec3 O372,O527,O511;O372=O403[O674-O581];O511=O542;O511.xz=O821(O511.xz,O589(atan(O372.x,O372.y)));if(abs(O511.z)<0.07)O527=vec3(1.,1.,0.3);else O527=(O511.z*(mod(O294+atan(O511.x,O511.y)+O372.z,2.*O294)-O294)>0.)?vec3(0.,1.,1.):vec3(1.,0.,1.);return vec4(O527,0.2);}void O007(){O147=float(O077);O325=1.5;O635=3.;O775=2.5;O658=2.3;O837=2.*(O325+O635);O992=length(vec2(2.*O294*(O147-0.25)*O635,(O147-0.25)*O775));O860=4.*(O837+O992);O279=0.6;O279=O860/(2.*O294*floor(O860/(2.*O294*O279)));}void O248(int O519,out vec3 O341,out vec3 O403){float O426,O302,O457,O395,O480,O682,O651,O193,O348;float O596,O534,O240,O317,O224,O286;O302=0.5*O147*O775;O457=O302-0.25*O775;O426=O302+O457;O395=O426/O992;O480=O325+O635;O682=(2.*O147-0.5)*O294/O992;O596=1.;O534=6.;O240=(O534*O534-O596*O596)/(2.*O992);O317=O837/O596;O224=O837/O534;O286=(O240>0.)?(sqrt(O596*O596+2.*O240*O992)-O596)/O240:O992/O596;O348=2.*(O317+O224)+4.*O286;O193=mod(O255+(float(O519)/float(O984))*O348,O348);O651=0.;if(O193>=0.5*O348){O193-=0.5*O348;O651+=0.5*O860;}if(O193<O317){O651+=O193*O596;}else if(O193<O317+O286){O193-=O317;O651+=O837+O193*(O596+0.5*O240*O193);}else if(O193<O317+O286+O224){O193-=O317+O286;O651+=O837+O992+O193*O534;}else{O193-=O317+O286+O224;O651+=2.*O837+O992+O193*(O534-0.5*O240*O193);}O403=vec3(0.,0.,2.*O294*fract(O651/(2.*O294*O279)));O341=vec3(0.);if(O651<0.5*O860){if(O651<O837){O403.y=-1.;O341=vec3(-O480+O651,O457,O325);}else if(O651<0.25*O860){O651-=O837;O403.xy=O589(O651*O682-0.5*O294);O341=vec3(O480*vec2(1.)+O635*O403.xy,O457-O651*O395).xzy;}else if(O651<O837+0.25*O860){O651-=0.25*O860;O403.x=-1.;O341=vec3(O325,-O302,O480-O651);}else{O651-=O837+0.25*O860;O403.xy=O589(O651*O682+O294);O341=vec3(O480*vec2(1.,-1.)+O635*O403.xy,-O302+O651*O395).xzy;}}else{O651-=0.5*O860;if(O651<O837){O403.y=1.;O341=vec3(O480-O651,O457,-O325);}else if(O651<0.25*O860){O651-=O837;O403.xy=-O589(O651*O682-0.5*O294);O341=vec3(O480*vec2(-1.)+O635*O403.xy,O457-O651*O395).xzy;}else if(O651<O837+0.25*O860){O651-=0.25*O860;O403.x=1.;O341=vec3(-O325,-O302,-O480+O651);}else{O651-=O837+0.25*O860;O403.xy=-O589(O651*O682+O294);O341=vec3(O480*vec2(-1.,1.)+O635*O403.xy,-O302+O651*O395).xzy;}}O341.y+=1.75*O279;}\nvoid O217(){float O651[2];for(int O488=O503;O488<O984;O488++)O248(O488,O341[O488],O403[O488]);O651[0]=10.;O651[1]=O651[0];for(int O488=O503;O488<O984;O488++){for(int O829=O503;O829<=1;O829++){if(sign(O341[O488].x*(float(O829)-0.5))>0.&&O341[O488].y<-0.5*O147*O775+1.75*O279+0.11)O651[O829]=min(O651[O829],abs(O341[O488].z));}}for(int O829=O503;O829<=1;O829++)O333[O829]=1.-smoothstep(2.,8.,O651[O829]/O279);}vec3 O069(vec3 O790,vec3 O697){vec4 O558,O713;vec3 O527,O565,O573;float O054,O015,O038;O217();O713=O124(O790,O697);O573=O542;O054=O170(O790,O697);if(min(O054,O713.x)<O023){if(O713.x<O054){O054=O713.x;O674=O581+O186;O542=O573;}O790+=O054*O697;O565=(O674<O581)?O139(O790):O713.yzw;if(O674==O767)O558=vec4(0.8,0.8,0.9,0.2);else if(O674==O736)O558=vec4(0.7,0.5,0.,0.1);else if(O674==O705)O558=vec4(0.9,0.8,0.,0.1);else if(O674==O643||O674==O643+1)O558=mix(vec4(1.,0.,0.,-1.),vec4(0.9,0.8,0.3,0.1),step(0.5,fract(4.*O542.y)));else if(O674==O612)O558=vec4(0.5,0.5,0.45,0.2);else if(O674>=O581)O558=O093();if(O558.a>=0.){O015=max(dot(O565,O891),0.);O015*=O015;O038=(O054<O023)?min(O201(O790+0.01*O565,O891),O155(O790+0.01*O565,O891,15.)):1.;O527=O558.rgb*(0.15+0.2*max(dot(O565,normalize(O891*vec3(1.,0.,1.))),0.)+0.85*O038*O015)+O558.a*step(0.95,O038)*pow(max(dot(O891,reflect(O697,O565)),0.),32.);}else O527=O558.rgb*(0.5+0.5*max(-dot(O565,O697),0.));}else O527=vec3(0.6,0.6,1.)*(0.2+0.2*(O697.y+1.)*(O697.y+1.));return clamp(O527,0.,1.);}void mainImage(out vec4 O178,in vec2 O209){mat3 O627;vec4 O922;vec3 O790,O697,O527;vec2 O465,O441;float O116,O062,O782,O193,O131;\nO465=iResolution.xy;O441=2.*O209.xy/O465-1.;O441.x*=O465.x/O465.y;O255=iTime;O922=iMouse;O922.xy=O922.xy/O465-0.5;\nO062=0.;O116=-0.2*O294;O782=5.;if(O922.z>0.){O062+=2.5*O294*O922.x;O116+=0.5*O294*O922.y;O782+=2.*abs(O062);}else{O193=mod(0.007*O255,2.);O062=2.*O294*(abs((floor(12.*O193)+smoothstep(0.8,1.,fract(12.*O193)))/12.-1.)-0.5);}O116=clamp(O116,-0.45*O294,-0.01*O294);O627=O162(O116,O062);O007();O790=O627*vec3(0.,-0.5,-(20.+10.*O147));O023=200.;O891=O627*normalize(vec3(1.,2.,-1.));const float O953=3.;O527=vec3(0.);O131=2.*mod(dot(mod(floor(0.5*(O441+1.)*O465),2.),vec2(1.)),2.)-1.;for(float a=float(O503);a<O953;a++){O697=O627*normalize(vec3(O441+step(1.5,O953)*O852(vec2(0.5/O465.y,0.),O131*(0.667*a+0.5)*O294),O782));O527+=(1./O953)*O069(O790,O697);}O178=vec4(O527,1.);}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clyBzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[422, 422, 454, 454, 552], [552, 552, 595, 595, 639], [639, 639, 683, 683, 734], [734, 734, 778, 778, 833], [833, 833, 865, 865, 971], [971, 971, 1002, 1002, 1065], [1065, 1065, 1098, 1098, 1277], [1277, 1277, 1308, 1308, 1615], [1615, 1615, 1658, 1658, 1930], [1930, 1930, 1952, 1952, 4063], [4063, 4063, 4095, 4095, 4236], [4236, 4236, 4257, 4257, 4492], [4492, 4492, 4524, 4524, 4720], [4720, 4720, 4732, 4732, 4999], [4999, 4999, 5011, 5011, 5221], [7322, 7322, 7353, 7353, 8356], [8356, 8356, 8399, 8399, 9270]], "test": "untested"}
{"id": "ctyBR3", "name": "arc-between-angles-sdf", "author": "LydianLights", "description": "Arc sdf given in terms of start and end angle. Obviously less efficient, but more convenient for some cases.", "tags": ["2d", "sdf", "distance", "arc"], "likes": 6, "viewed": 181, "published": 3, "date": "1702314177", "time_retrieved": "2024-07-30T17:17:15.389086", "image_code": "#define PI 3.1415927\n\nfloat cro(vec2 a, vec2 b) { return a.x * b.y - a.y * b.x; }\n\nfloat sdArc(in vec2 p, in float r, in float a1, in float a2) {\n    vec2 p1 = vec2(r * cos(a1), r * sin(a1));\n    vec2 p2 = vec2(r * cos(a2), r * sin(a2));\n    float c = cro(p1, p2);\n    float c1 = cro(p, p1);\n    float c2 = cro(p, p2);\n    float d1 = min(length(p - p1), length(p - p2));\n    float d2 = abs(length(p) - r);\n    if (a1 == a2) return d1;\n    return c > 0.0\n        ? c1 < 0.0 && c2 > 0.0 ? d2 : d1\n        : c1 < 0.0 || c2 > 0.0 ? d2 : d1;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float t = 1.5 * iTime;\n    float a = floor(t / (2.0 * PI)) * 2.0 * PI / 5.0;\n    \n    // distance\n    float d = sdArc(p, 0.8, a, t + a);\n    \n    // coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)));\n\n    if(iMouse.z > 0.001) {\n        d = sdArc(m, 0.8, a, t + a);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctyBR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 49, 49, 81], [83, 83, 145, 145, 538], [540, 540, 595, 595, 1361]], "test": "untested"}
{"id": "DtKfzG", "name": "rotating_hearts", "author": "anmol", "description": "hearts", "tags": ["rotation"], "likes": 2, "viewed": 130, "published": 3, "date": "1702305061", "time_retrieved": "2024-07-30T17:17:16.362484", "image_code": "const float PI = 3.14;\nmat2 rotationMatrix(float angle)\n{\n\tangle *= PI / 180.0;\n    float s=sin(angle), c=cos(angle);\n    return mat2( c, -s, \n                 s,  c );\n}\n\nvec3 palette(float t)\n{    \n    vec3 a = vec3(0.049, 0.109, 0.662);\n    vec3 b = vec3(0.408, 0.456 ,0.077);\n    vec3 c = vec3(0.564, 0.367 ,0.556);\n    vec3 d = vec3(2.722, 2.609, 0.063);\n\n    return a + b*cos(3.14*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    uv *= rotationMatrix(iTime*25.0);\n    uv = (fract(uv * 2.0) * 3.0) - 1.5;\n    uv *= rotationMatrix(-1.0*iTime*100.0);    \n    float d = (pow(uv.x, 2.) + pow(uv.y, 2.) - uv.y * abs(uv.x));\n    d = exp(sin(d)) + iTime*0.8 + d;\n    vec3 col = smoothstep(0.0,9./iResolution.y,palette(d));\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtKfzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 57, 57, 170], [172, 172, 195, 195, 399], [401, 401, 458, 458, 854]], "test": "untested"}
{"id": "mlGfzV", "name": "Poincare Disc Animation", "author": "Shane", "description": "A CSG polygon driven Poincare tiling with an animated pattern overlay.", "tags": ["csg", "tile", "hyperbolic", "poincare"], "likes": 137, "viewed": 2048, "published": 3, "date": "1702300496", "time_retrieved": "2024-07-30T17:17:17.404696", "image_code": "/*\n\n\tPoincare Disc Animation\n\t-----------------------\n    \n    A CSG polygon driven Poincare tiling with an animated pattern overlay.\n    \n\tThis simple animation has been sitting around in my account for way too\n    long. I made it at the same time as one of my other hyperbolic related \n    postings. There are not a great deal of animated Poincare disc examples\n    around, so I wanted to make one. Like so many things I put together, it \n    was coded up without putting a great deal of thought into it. On a \n    personal level, I don't like producing code that involves \"magic\" numbers \n    and guesswork. However, there's a little bit of that in here. I'd imagine \n    experts in this area will probably roll their eyes at the sheer hackory \n    involved. :)\n    \n    In fact, I'm secretly hoping someone will see this and post an example \n    that shows me a better way to do it... Whilst I'm putting in requests, \n    one of those colored interwoven ribbon demonstrations on a Poincare disc\n    would be nice. :) \n    \n    In regard to the pattern itself, that was fairly easy. Rendering lines,\n    points, etc., on a hyperbolic plane is similar to that on a Euclidean\n    plane. However, you're using a coordinate system akin to polar coordinates,\n    which is fine, unless it's been a while and you try to position things\n    with Euclidean coordinates. In fact, the code up to that point is pretty \n    reliable. However, I really hacked around to render the arcs between side\n    midpoints, and to render the repeat animation objects, so I was left \n    thinking that there'd have to be a more elegant way to do this.\n    \n    Anyway, the purpose of this was to post something artistic rather than a \n    treatise on hyperbolic geometry, for which there are already plenty of \n    interesting examples on here. The next step would be to post some cool \n    looking hyperbolic patterns using more realiable code. :)\n    \n\n\n\n    Poincare disc examples:\n\n    // The hyperbolic transformation itself is based on STB's example here,\n    // which I'm assuming was in turn based on a slide presentation by\n    // Vladimir Bulatov: http://www.bulatov.org/math/1001/index.html\n\t//\n    Hyperbolic PoincarÃ© transformed - stb\n\thttps://www.shadertoy.com/view/3lscDf\n\n\n    // Another hyperbolic pattern example.\n    Hyperbolic Poincare Weave - Shane\n    https://www.shadertoy.com/view/tljyRR\n    \n\n*/\n\n\n// Because I was rushed, this particular pattern only works with two \n// arrangements, namely the \"3-8\" triangle setup and the \"4-6\" quad. \n// Next times, I'll try to get more to work.\n//\n// Polygon shape - 0: Triangle, 1: Quad.\n#define POLY 0\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's unsigned line distance formula.\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n\n\n// P represents the number of polygon vertices, and Q is the number of \n// adjacent polygons to each vertex within the Poincare disc.\n//\n// For tilings to work, the following must be true: (P â 2)*(Q â 2)>4.\n//\n// For instance, 3 and 7 will work, but 4 and 4 will not.\n//\n// 3-7, 3-8, 4-5, 5-4, 5-6, 6-4, 7-3, 8-3, 8-4, etc..\n//\n\n// Because I was rushed, this particular pattern only works with two \n// arrangements. Next time, I'll try to get more to work.\n#if POLY == 0\nconst int N = 3;\t// Polygon vertices.\nconst int Q = 8;\t// Polygons meeting at a vertex.\n#else\nconst int N = 4;\t// Polygon vertices.\nconst int Q = 6;\t// Polygons meeting at a vertex.\n#endif\n\n#define PI\t\t3.14159265\n#define TAU\t    6.28318531\n\n\n// Calculating the initial circular domain according to number of polygon\n// sides (N) and the number of adjacent polygons (Q): STB was clever enough to  \n// use repeat polar space to position the rest. Anyway, the idea is to use the\n// polygon geometry to set up the required geometrical diagram (see the line \n// below), then use a mixture of standard Euclidean and hyperbolic geometry (if\n// needed) to calculate the required values, which are described below.\n// \nvec3 initDomain(){\n    \n\t// There are quite a few ways to calculate the initial circular domain \n    // values, simply because there are several solutions to the same geometric \n    // problems, which is all this is. In fact, as geometric situations go,\n    // this is not a particularly difficult one to solve.\n\n    // The following is some highschool level circle and triangle geometry to \n    // get the values we're after.\n    //\n    // The Hyperbolic Chamber - Jos Leys\n    // http://www.josleys.com/article_show.php?id=83\n    //\n    // I also find the imagery on the following page helpful as well:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n   \n    // I can't for the life of me remember how I calculated these, but they're\n    // based on the diagrams you'll find in the links above. At the time, I was\n    // looking for the most concise solution I could, and forgot to write down what\n    // \"d2\" and \"r2\" represented on the diagrams... Either way, it was something \n    // simple. I'll locate the original code at some stage and expand on it.\n    //\n    float a = sin(PI/float(N)), b = cos(PI/float(Q)); // Polygon angle lengths.\n\tfloat d2 = cos(PI/float(N) + PI/float(Q))/a;\n\tfloat r2 = 1./(b*b/a/a - 1.); // Adjacent polygon radius (squared).\n\t\n    // Distance between adjacent polygon centers, the adjacent polygon radius,\n    // and the current polygon radius. We're assuming no negatives, but I'm \n    // capping things above zero, just in case.\n\treturn sqrt(max(vec3(1. + r2, r2, d2*d2*r2), 0.));  \n\n}\n\n\n\n// Count variable, which is seful for all kinds of things. It's a measure\n// of how many iterations were required to get to the current polygon.\n// The center polygon would have a count of one, and should increase as we \n// radiate outwards.\nfloat count;\n// Relates to the side number.\nfloat gIA; \n\n\n \n\n// Hyperbolically reflecting the polygon across each of it's edges\n// via an inverse Mobius transform.\nvec3 transform(vec2 p, vec3 domInfo){\n    \n    // Side number.\n    gIA = 0.;\n \n    \n    \n    \n    // Polygon value, set to the maximum. The surrounding circcles will\n    // be used to carve out the final value.\n    float gPoly = 1e5;\n   \n    \n    // Performing multiple reflective inversions to fill out the disk. Due \n    // to the nature of the hyperbolic transform, the polygon tiles get \n    // smaller as you approach the outer disk, and never reach the edge. \n    // There are a bunch of proofs in complex analysis that illustrate\n    // this, but nothing shows it as well as a computer program. :)\n    // Drop the number of iterations and you'll see the process unfold.\n    for(int i=0; i<24; i++){\n       \n        \n        // The following is a standard polar repeat operation. It works\n        // the same in hyperbolic space as it does in Euclidian space.\n        // If you didn't do this, you'd reflect across just the one\n        // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n        float na = floor(mod(atan(p.x, p.y), 6.2831589)/TAU*float(N));\n        float ia = (na + .5)/float(N);\n        vec2 vert = rot2(ia*TAU)*vec2(0, domInfo.x);\n\n        float rSq = domInfo.y*domInfo.y;\n\n       \n        // Circle inversion, which relates back to an inverse Mobius\n        // transformation. There are a lot of topics on just this alone, but \n        // the bottom line is, if you perform this operation on a point within\n        // the Poincare disk, it will be reflected. It's similar to the\n        // \"p /= dot(p, p)\" move that some may have used before.\n        vec2 pc = p - vert;\n        float lSq = dot(pc, pc);\n        \n        \n     \n\n        // If the distance (we're squaring for speed) from the current point to\n        // any vertex point is within the circle limits, hyperbolically reflect it.\n        if(lSq<rSq){\n\n            p = pc*rSq/lSq + vert;\n    \n            // Maintaining chirality. There are times when you need this.\n            p.x = -p.x;\n            \n            // If we have a hit, increase the counter. This value can be useful\n            // for coloring, and other things.\n            count++; \n\n        }\n        else {\n\n            // We're not inside, so render the last CSG polygon we have on record.\n            //\n            // I've lazily set it to a global, but there'd be cleaner ways to work \n            // the calculations in. Technically, you could wrap this in an else\n            // statement, but I think it's cleaner out here.\n            float poly = (length(p) - domInfo.z);\n            poly = max(poly, -(length(pc) - domInfo.y));\n            gPoly = min(gPoly, poly);\n            \n            // Side number.\n            gIA = na; \n            \n     \n            // We're outside of the domain, so break from the loop.\n            break;\n        }\n\n        \n    }\n    \n    // Local coordinates and polygon distance.\n    return vec3(p, gPoly);\n}\n\n\n// Mouse pointer inversion.\nvec2 mouseInversion(vec2 p){\n    \n    // Mouse coordinates.\n    vec2 m = vec2((2.*iMouse.xy - iResolution.xy)/iResolution.y);\n    // Hack for the zero case instance. If someone has a better way,\n    // feel free to let me know.\n    if(length(m) < 1e-3) m += 1e-3; \n    // A hack to stop some craziness occurring on the border.\n    //if(abs(m.x)>.98*.7071 || abs(m.y)>.98*.7071) m *= .98;\n    \n    // Taking the mouse point and inverting it into the circle domain.\n    // Feel free to check some figures, but all will get mapped to \n    // values that lie within circle radius.\n    float k = 1./dot(m, m);\n    vec2 invCtr = k*m; \n    float t = (k - 1.)/dot(p - invCtr, p - invCtr);\n    p = t*p + (1. - t)*invCtr;\n    p.x = -p.x; // Keep chirality. MLA does this. \n    \n    return p;\n    \n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    \n    // Aspect correct coordinates: Actually, \"fragCoord\" is already in \n    // aspect correct form, so shifting and scaling is all that is\n    // required in this particular pixelshader environment.\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n  \n    \n    /*\n    // Moving to the half plane model.\n    const float sc = 2.;\n    uv.y += sc/2. + 1.;\n    uv /= dot(uv, uv)/sc;\n    uv.y -= 1.; \n    */\n    \n    // Contracting things just a touch to fit the Poincare domain on \n    // the canvas.\n    uv *= 1.1;\n     \n     \n    // Hyperbolic the hyperbolic... I made that up, but it spherizes things \n    // a bit, which looks interesting.\n    //uv *= (.65 + dot(uv, uv)*.35);\n     \n    \n    // Poincare coordinates.\n    vec2 p = uv;\n    \n    \n    // Canvas rotation for a bit of variance.\n    p *= rot2(-iTime/8.);\n  \n\n\n    // A bit of mouse inversion and rotation to begin with. You'll\n    // see this a lot in various hyperbolic examples, and others.\n    p = mouseInversion(p);\n    \n    \n    vec2 oP = p;\n    \n    // Inversion count. It's used for all kinds of things, like \n    // random number production, etc.\n    count = 0.;\n  \n    \n    // Filling in the domain origin information: From left to right, it \n    // returns the distance between adjacent polygon centers, the adjacent \n    // polygon radius, and the current polygon radius. These values remain\n    // the same for all polygons throughout the hyperbolic plane, so this \n    // is all that's required to tile the disc.\n    //\n    // domInfo.x: Distance between adjacent polygon centers.\n    // domInfo.y: The adjacent polygon radius.\n    // domInfo.z: The current polygon radius.\n    vec3 domInfo = initDomain(); \n    \n    \n   \n    \n    // Handling the imagery outside the Poincare circle domain by inverting or\n    // mirroring it back into the circle so that it shows up.\n    //\n    // By the way, if you want to get more of an intuitive feel for circle \n    // inversion, I recommend Numberphile's \"Epic Circles\" video, here:\n    // https://www.youtube.com/watch?v=sG_6nlMZ8f4\n    if(length(p)> 1.) p /= dot(p, p); \n  \n\n    \n        \n\n    // Get local transformed polygon coordinates (p3.xy) and the polygonal \n    // distance field itself (p3.z).\n    vec3 pp3 = transform(p, domInfo);\n    \n    // Local coordinates and polygon distance field value.\n    p = pp3.xy;\n    float gPoly = pp3.z;\n    \n    // Flipping from reflection to reflection. Just as in Euclidean geometry,\n    // animated objects sometimes need their directions flipped from \n    // polygon to polygon.\n    float flip = mod(count, 2.)*2. - 1.; // Values: -1 and 1.\n    \n \n    // Setting a ring distance field, then using that to add more to the \n    // smoothing factor to alleviate aliasing around the borders. It's \n    // hacky, and no substitute for super sampling, but it works well \n    // enough here.\n    float ssf = (2. - smoothstep(0., .25, abs(length(uv) - 1.) - .25));\n    float sf = 2./iResolution.y*ssf*ssf;//(count*count + 1.);//fwidth(shape);// \n\n \n    \n    // Setting the color, according to the hyperbolic reflection count.\n    // IQ's versatile palette routine. It's one of my favorites.\n    vec3 oCol = .5 + .45*cos(TAU*count/12. + vec3(1, 0, 2));\n \n \n    \n    // The background color. It looks interesting enough like this, but the lines\n    // give it additional depth.\n    vec3 col = vec3(0.);\n    \n     \n    // For some reason, this setup gives nicer width edging, whereas the\n    // normal way I go about it does not... I'll look into it later. :)\n    col = mix(col, oCol, 1. - smoothstep(0., sf, gPoly + .01));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(gPoly) - .005));\n\n    \n    \n    // Polygon side debug.\n    //if(gIA==0.) col *= vec3(8, 2, 1);\n    //if(gIA==1.) col *= vec3(4, 1, 12);\n   \n    // Vertices and edges.\n    vec2[N] v, e;\n    \n    // The first vextex position.\n    vec2 r = vec2(0, domInfo.x - domInfo.y);\n    \n    // Vertices and edges.\n    float vert = 1e5, mid = 1e5;\n     \n    for(int i = 0; i<N; i++){\n       // Mulitples of v0.\n       v[i] = rot2(TAU/float(N)*float(i))*vec2(0, domInfo.z);\n       // Midpoint edges are rotated between successive vertices. \n       e[i] = rot2(TAU/float(N)*(float(i) + .5))*r;\n       \n       // Vertex and midpoint distances.\n       vert = min(vert, length(p - v[i]));\n       mid = min(mid, length(p - e[i])); // Not used, but they're here anyway.\n    }\n    \n     \n \n    // Saving the background color. \n    vec3 svOCol = oCol;\n    \n    \n    // Rendering the polygon vertex points.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, vert - .04));\n    \n    \n    float lw = .06; // Line width.\n    float cw = .07*3./float(N); // Moving rectangle width.\n     \n    // Going one extra to render the half of the first strip again.\n    for(int i = 0; i<=N; i++){\n    \n       \n        // On the last iteration we want to render half the \n        // first strip over the top to make the overlapping pattern.\n        if(i==N && (p.y + lw/2.*0.<0.)) break;\n\n    \n        // domInfo.x: Distance between adjacent polygon centers.\n        // domInfo.y: The adjacent polygon radius.\n        // domInfo.z: The current polygon radius.\n        // A magic radius related number for the \"3-8\" and \"4-6\" combinations.\n        // 3-8: .212 // 4-6: .405\n        float magic = N == 3? .212 : .405;\n        // Vertex center of the adjoining circle that creates the arc for this\n        // particular polygon side -- It's at an angle midway between the vertex\n        // points flanking the side and at a constant distance that was hacked in\n        // by trial and error. Obviously, it'd be better to calculate it properly.\n        vec2 vv = rot2(fract((float(i + 1))/float(N))*TAU)*vec2(0, domInfo.x + domInfo.z*magic);\n        \n        // The arc line itself.\n        float df = length(p - vv) - (domInfo.x);\n        df = abs(df) - lw;\n\n\n\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*10., df))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, df));\n        col = mix(col, vec3(.07), 1. - smoothstep(0., sf, df + .015));\n  \n \n        // Controls the number of animated squares.\n        // 3 and up will work, but the width \"cw\", will need adjusting.\n        float m = 3.; \n       \n        // Animated objects: More magic numbers. I'm not even sure what\n        // I was thinking to arrive at this... Sigh! :)\n        float aNum = (float(N) - .5)*float(Q)*m  + float(Q*2) + 1.;  \n        if(N == 4) aNum = float(N*Q)*m;\n        // Animation: Reversing each time a polygon is hyperbolically\n        // reflected across the side boundary. On a Euclidean plane, you'll\n        // do something similar.\n        float t2 = iTime;\n        if(flip<0.){ t2 = -t2; }\n     \n        // The center of the neighboring circle contributing to this \n        // polygon side arc.\n        vec2 cntr = p - vv;\n\n        // Reverse the direction on the outside of the disc.\n        float dir = (length(uv) > 1.)? -1. : 1.;\n        cntr *= rot2((fract(dir*t2/aNum))*TAU);\n\n        // Animated polar object stuff: Rotate the angle, then move\n        // along the radius to the appropriate distance.\n        float na = floor(atan(cntr.x, cntr.y)/6.2831*aNum);\n        float ia = (na + .5)/aNum;\n        cntr *= rot2(ia*6.2831);\n        cntr.y -= domInfo.x;\n\n        // The animated object (just a rectangle) and rendering.\n        float df3 = max(abs(cntr.x), abs(cntr.y)) - cw;\n        df3 = max(df3, df + .03);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, df3));\n        col = mix(col, svOCol*1.3 + .1, 1. - smoothstep(0., sf, df3 + .015)); \n      \n   \n    }\n    \n    \n    // Polygon edge debug.\n    //if(p.y + lw/2.*0.>0.) col *= .5;\n    \n    // Flipped polygon debug.\n    //if(flip<0.) col *= .5; // Area affected.\n    \n    \n    // At the last minute, I decided to render different colors on the\n    // outside of disc... I'm still not sure whether it worked or not. :D\n    col = mix(col, col.yxz, smoothstep(0., sf, length(uv) - 1.));\n    \n    // Outer ring.\n    //col = mix(col, vec3(0), 1. - smoothstep(0., sf*4., abs(length(uv) - 1.)));\n    float ring = abs(length(uv) - 1.) - .01;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*4., ring));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ring));\n    col = mix(col, vec3(.07), 1. - smoothstep(0., sf, ring + .01));\n\n \n    //vec3 gr = vec3(1)*dot(col, vec3(.299, .587, .114));\n    //col = mix(col, gr, smoothstep(0., sf, length(uv) - 1.));\n    \n    // Vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./16.);\n\n    \n    // Rough gamma correction, then present to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlGfzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2648, 2681, 2703, 2703, 2761], [2764, 2804, 2843, 2843, 2944], [3665, 4133, 4151, 5213, 5671], [5978, 6081, 6118, 6143, 8998], [9001, 9029, 9057, 9088, 9817]], "test": "untested"}
{"id": "clVfzV", "name": "clord gravity_field_3d", "author": "420bongrips247365", "description": "Simplified 'gravity field 2'.\nUse mouse.x to change coloring. ", "tags": ["field", "gravity"], "likes": 1, "viewed": 139, "published": 3, "date": "1702295863", "time_retrieved": "2024-07-30T17:17:18.161672", "image_code": "// Fork of \"gravity_field_3d\" by Crackhausen. https://shadertoy.com/view/MdyyzD\n// 2023-12-11 11:48:37\n\n// Fork of \"gravity_field_3\" by tholzer. https://shadertoy.com/view/lsGcRD\n// 2018-03-16 11:43:38\n\n//----------- gravity_field_3 ---------------\n\n// simplified https://www.shadertoy.com/view/4slSWN\n\n#define POINTS 20  \t\t // number of stars\n\n#define t iTime\n\nfloat hash (float i) { return 3.*fract(sin(i*7467.25)*1e5) - 1.; }\n//vec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\n\t\n\nvec2 P (int i)  // position of point[i]\n{\n  vec4 c = hash4(float(i));\n  return vec2( cos(t*c.x-c.z) +0.015*cos(12.765*t*c.y+c.w),\n\t\t\t ( tan(t*c.y+c.w) +0.00005 -sin(1.893*t*c.x+c.z)) / 2.5);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 R = iResolution.xy;\n  vec2 uv = (2.*fragCoord - R*1.7) / R.y;\n  vec2 mp = iMouse.xy / R;\n    \n  float my = -0.5*pow(.5*(1.-cos(1.1*t)),3.0);\n  float fMODE = (1.0-cos(8.1415*mp.x))-sin(iMouse.x/t);\n\n  vec2 V = vec2(0.1);\n  for (int i=1; i<POINTS; i++)\n  {\t\n    vec2 d = P(i) - uv;  // distance point->pixel\n\tV +=  d / dot(d,-361.5-d);  // gravity force field\n  }\n  float c = (length(V)* 1./(203.*float(POINTS)))*(2.+4210.*fMODE);\n  int MODE = int(5.*mp.x);\n  if (MODE==0) fragColor = vec4(0.25*c)+smoothstep(.005,.04,abs(c-5.*my))*vec4(1.000,0.835,0.000,0);\n  if (MODE==1) fragColor = vec4(.5+.5*sin(2.*c));\n  if (MODE==2) fragColor = vec4(sin(c),sin(c+2.),sin(c/4.),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clVfzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[362, 362, 384, 384, 428], [429, 489, 511, 511, 568], [572, 572, 613, 613, 764], [766, 766, 822, 822, 1502]], "test": "untested"}
{"id": "dlKBRK", "name": "clord 2 gravity_field_3d", "author": "420bongrips247365", "description": "Simplified 'gravity field 2'.\nUse mouse.x to change coloring. ", "tags": ["field", "gravity"], "likes": 1, "viewed": 151, "published": 3, "date": "1702295769", "time_retrieved": "2024-07-30T17:17:19.191918", "image_code": "// Fork of \"gravity_field_3d\" by Crackhausen. https://shadertoy.com/view/MdyyzD\n// 2023-12-11 11:48:37\n\n// Fork of \"gravity_field_3\" by tholzer. https://shadertoy.com/view/lsGcRD\n// 2018-03-16 11:43:38\n\n//----------- gravity_field_3 ---------------\n\n// simplified https://www.shadertoy.com/view/4slSWN\n\n#define POINTS 20  \t\t // number of stars\n\n#define t iTime\n\nfloat hash (float i) { return 3.*fract(sin(i*7467.25)*1e5) - 1.; }\n//vec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\nvec4  hash4(float i) { return vec4(hash(i),hash(i-9.1),hash(i-1.3),hash(i+.1)); }\n\t\n\nvec2 P (int i)  // position of point[i]\n{\n  vec4 c = hash4(float(i));\n  return vec2( cos(t*c.x-c.z) +0.015*cos(12.765*t*c.y+c.w),\n\t\t\t ( tan(t*c.y+c.w) +0.00005 -sin(1.893*t*c.x+c.z)) / 2.5);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 R = iResolution.xy;\n  vec2 uv = (4.*fragCoord - R*1.7) / R.y;\n  vec2 mp = iMouse.xy / R;\n    \n  float my = -0.5*pow(.5*(1.-cos(1.1*t)),33.0);\n  float fMODE = (1.0-cos(8.1415*mp.x))-sin(iMouse.x/t);\n\n  vec2 V = vec2(0.1);\n  for (int i=1; i<POINTS; i++)\n  {\t\n    vec2 d = P(i) - uv;  // distance point->pixel\n\tV +=  d / dot(d,-301.5-d);  // gravity force field\n  }\n  float c = (length(V)* 1./(203.*float(POINTS)))*(2.+4210.*fMODE);\n  int MODE = int(5.*mp.x);\n  if (MODE==0) fragColor = vec4(-0.25*c)+smoothstep(.005,.04,abs(c-15.*my))*vec4(0.882,0.000,1.000,0);\n  if (MODE==1) fragColor = vec4(.5+.5*sin(2.*c));\n  if (MODE==2) fragColor = vec4(sin(c),sin(c+2.),sin(c/4.),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlKBRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[362, 362, 384, 384, 428], [429, 489, 511, 511, 570], [574, 574, 615, 615, 766], [768, 768, 824, 824, 1507]], "test": "untested"}
{"id": "DlKfRK", "name": "Blue and white rug 2", "author": "jarble", "description": "A fractal rug pattern with an ornate design.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 23, "viewed": 307, "published": 3, "date": "1702280295", "time_retrieved": "2024-07-30T17:17:19.940915", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nvec3 fractal(vec2 uv){\n    vec3 col = vec3(0.);\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    vec3 col1 = col;\n    float c1=0.;\n    for(int k = 0; k < 9; k++){\n    \n        uv.y -= 1./4.;\n        \n        uv = (uv+t2)/scale;\n        \n        uv = ((vec2(uv+vec2(.5,1.5))*scale)-.5)/scale;\n        \n        t2 = triangle_wave(uv-.5);\n        uv =\n            t2*1.5-triangle_wave(uv.yx)\n            \n            //looks better with more iterations\n            //t2-triangle_wave(uv.yx)-fract(t2/2.)\n        ;\n        \n        c1 =\n            //max(abs(uv.y-uv.x*sign(uv.x-uv.y))/2.,c1)\n            max(abs(uv.y-uv.x)/2.,c1)\n        ;\n        c1 =\n            max(abs(2.*c1-1.),c1/4.)\n            \n            //more colorful\n            //abs(2.*c1-1.)\n            \n            //Spooky!\n            //max(abs(2.*c1-2.),c1/4.)/2.\n        ;\n        col.x =\n            max(max(length(uv-t2-c1),abs(uv.y-uv.x))/3.,col.x)\n            //max(max(length(uv-t2-c1),abs(uv.y-uv.x)),col.x)/3.\n           \n            //c1\n           \n            //blue and gold\n            //2. - max((abs(uv.y-uv.x))/3.,col.x)\n           \n            //black and white\n            //col.x\n        ;\n        //if(uv.x<-.25)\n        col =\n            abs(col-(1.-(c1*col.x)))\n            //abs(col*c1-(1.-(col.x)))\n        ;\n        col1 =\n            abs(col1*c1-col-1.).yzx\n            //abs(col1-col*c1-1.).yzx\n        ;\n        //k -= int(sign(t2.y-t2.x));\n    }\n    return col1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    float t1 = 6.;\n    \n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.xy += iTime/t1/12.;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec3 col1 = fractal(uv);\n    fragColor = vec4(col1/2.,1.0);\n}\n", "image_inputs": [], "sound_code": "float mod1(float a, float b){\n    return\n        mod(a,b)\n        //mod(a+mod(a,b+3.),b)\n    ;\n}\n\nfloat fmod(float a, float b){\n    //the modulus should be a prime number\n    //this makes some interesting rhythms\n    float modulus =\n        //3.\n        5.\n        //7.\n    ;\n    for(float i = 1.; i < mod(floor(a/b),modulus); i++){\n        //a /= 2.0;\n        //a /= 1.0+mod(floor(a),2.);\n        a += mod1(floor(a/2.),b)*i;\n    }\n    float a1 = a;\n    return\n        mod(floor(a),b)\n    ;\n}\n\n#define fract1(a) pow(fract(a),1.+log(2.)-log(1.+fract(a)))\n\nvec2 synth_(vec2 a1,vec2 a,vec2 a2,vec2 a3,vec2 nb,vec2 a4){\n    return log(a1+a*abs(a2-abs(.5-a3*vec2(fract1(nb.x*.998),fract1(nb.y)))*a4));\n}\n#define synth(a1,a,a2,a3,nb,a4) synth_(vec2(a1),vec2(a),vec2(a2),vec2(a3),vec2(nb),vec2(a4))\n\nvec2 banjo(vec2 a, vec2 nb){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./6.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,6./4.));\n}\n\nvec2 harp(vec2 a, vec2 nb){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,2.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.));\n}\n\nvec2 synth_drum(vec2 a, vec2 nb,float m2){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./m2)\n  + synth(1./8.,a,1./4.,1.,nb*2.,m2/4.));\n}\n\nvec2 oud(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(.5+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      +.5*log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 steel_drum(vec2 a, vec2 nb){\nreturn a/16./4.*abs(synth(1./2.,a,1./8.,1.,nb*4.,1.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.))\n;\n}\n\nvec2 gamelan(vec2 a, vec2 nb){\nreturn\na/16./4.*abs(synth(1./4.,.5*a,1./8.,1.,nb*4.,1./2.)\n  +.5*synth(1./4.,a,1./4.,1.,nb*2.,1./2.)) \n;\n}\n\nvec2 sitar1(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      -log(1./4.+a*(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 mainSound1(int samp, float time,float scale,float duration){\n  float tempo = .25;\n  time /= tempo;\n  float s1 =\n      8.;\n  vec3\n  rhythm =\n      vec3(1.)\n      \n      //more rhythms here!\n      //vec3(2.)\n      //vec3(2.,2.,1.)\n      //vec3(2.,1.,1.)\n  ;\n  for(float i = 1.; i < mod(floor(time),5.); i++){\n      time += mod(floor(time*2./rhythm.x),s1)*i;\n      time /= 1.+fmod(floor(time/rhythm.y)*2.,2.);\n      tempo *= 1.+fmod(floor(time/rhythm.z)*2.,2.);\n  }\n  float s2 = 8.,\n  t=\n      time,\n  m1 =\n      fmod(t,s2)\n      //fmod(t+fmod(floor(t/2.)/2.,s2*2.)/2.,s2)\n  ,m4 = fmod(t/8.,2.)\n  ,m3 =\n      fmod(t,1.+m1)+m4;\n  t /=\n      (1.+fmod(t/s1,2.))*4./s1/s1\n  ;\n  float m2 =\n      1. + fmod(t/s1,s1)\n      //1. + fmod(t/s1+fmod(floor(t/s1/8.)/2.,s2*2.)/2.,s1)\n  ,note=\n      floor((m3+m2)/2.)/5.\n      //floor((m3+m2+m4*4.)/2.)/5.\n  ,attack=1./64./4.;\n  vec2 a=\n      //vec2((1.-sqrt(fract(t/s1)/1.25))*.2)\n      -vec2((log(attack+fract1(t/s1)/8./duration)))\n\n      //pow(1.-log(1./16./2.+fract(t/s1)/4.),2.)\n  ,\n  nb =\n      vec2(time*tempo*pow(2.,note+scale))\n      \n      //scratching\n      //vec2(time*tempo*pow(2.,note+scale-a.x/128./2.))\n  ;\n  vec2 \n  sitar = log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y*2.)))/2.)),\n  \n  gamelan = gamelan(a,nb)\n  \n  \n  \n  ,steel_drum = steel_drum(a,nb)\n  ,oud = \n      a/16./2.*abs(\n      synth(1./2.,a,0.,1.,nb*2.,1./2.)\n      +.5*synth(1./8.,a,1./8.,1.,nb,1./2.))/2.\n  ,synth_drum = a/16./4.*abs(log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))*4.))\n  + log(1./8.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/4.)))\n  ,synth_drum1 = a/16./4.*synth(1./4.,a,1./8.,1.,nb*4.,m2/4.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,m2/4.)\n  ,banjo = a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./6.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,6./4.))\n  \n\n\n\n  ;\n  return\n      abs(gamelan-steel_drum/2.)\n      \n      //sitar1(a,nb)\n      \n      //abs(oud-steel_drum/8.)\n      \n      //abs(gamelan-steel_drum/4.)\n      \n      \n      //oud\n      //abs(.5-vec2(fract(nb.x*.998*2.),fract(nb.y)))*a\n      \n      \n      //log(abs(a/4.-2.*abs(.5-vec2(fract(nb*.998*2.),fract(nb*2.)))*a))\n\n      //log(abs(a/8.-abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a))\n  ;\n}\n\nvec2 mainSound(int samp, float time){\n    return\n        mainSound1(samp,time,6.5,1.)\n        \n        //flute\n        //abs(mainSound1(samp,time,7.25,1.)-mainSound1(samp,time,7.25,1./2.)/2.-mainSound1(samp,time,7.25,1./4.)/4.)\n        \n        //abs(mainSound1(samp,time,7.25,1.)-mainSound1(samp,time,7.25,2.)/2.-mainSound1(samp,time,7.25,4.)/4.)\n\n        \n        //metal remix\n        //abs(mainSound1(samp,time,6.,1./2.)-mainSound1(samp,time,6.5,1./2.))\n    ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlKfRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 129], [131, 131, 153, 153, 1595], [1597, 1597, 1654, 1654, 1914]], "test": "untested"}
{"id": "ctVBRK", "name": "Fork Hyperspace guvacode 133", "author": "guvacode", "description": "The Hyperspace Exit effect, ROTJ style. Based on https://www.shadertoy.com/view/MlKBWw. Use the mouse to look around.", "tags": ["hyperspace", "starwars", "trails"], "likes": 7, "viewed": 186, "published": 3, "date": "1702277140", "time_retrieved": "2024-07-30T17:17:20.720830", "image_code": "/*\n\tSimplified and adapted from:\n\thttps://www.shadertoy.com/view/MlKBWw\n*/\n\n#define TAU 6.28318\n\n// The way this shader works is by looking at the screen as if it were a disk and then\n// this disk is split into a number of slices centered at the origin. Each slice renders\n// a single trail. So this setting controls the overall density of the effect:\n#define NUM_SLICES 125.0\n//#define NUM_SLICES 50.0\n\n// Each trail is rendered within its slice; but to avoid generating regular patterns, we\n// randomly offset the trail from the center of the slice by this amount:\nconst float MAX_SLICE_OFFSET = 0.4;\n\n// This is the length of the effect in seconds:\nconst float T_MAX = 2.0;\n// T_JUMP is in normalized [0..1] time: this is the time when the trails zoom out of view\n// because we've jumped into hyperspace:\nconst float T_JUMP = 0.90;\n// This is the speed during the final jump:\nconst float jump_speed = 5.0;\n\n// I've noticed that the effect tends to have a bluish tint. In this shader, the blue color\n// is towards the start of the trail, and the white color towards the end:\nconst vec3 blue_col = vec3(0.3, 0.3, 0.6);\nconst vec3 white_col = vec3(0.8, 0.8, 0.95);\n\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, in float ring )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - ring;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color = vec3(0.0);\n    float time = mod(iTime, T_MAX);\n    float t = time / T_MAX;\n\n    vec2 mo = (2.0 * iMouse.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float p_len = length(p);    \n    p += vec2(0, -0.2); // In XWA the aiming HUD is not at the screen's center\n    \n    float ta = TAU * mod(iTime, 8.0) / 8.0;\n    //ta = 12.0 * 0.01745;\n    float ay = 0.0, ax = 0.0, az = 0.0;\n    if (iMouse.z > 0.0) {\n        ay = 3.0 * mo.x;\n        ax = 3.0 * mo.y;\n    }\n    //ay += 135.0;\n    mat3 mY = mat3(\n         cos(ay), 0.0,  sin(ay),\n         0.0,     1.0,      0.0,\n        -sin(ay), 0.0,  cos(ay)\n    );\n    \n    mat3 mX = mat3(\n        1.0,      0.0,     0.0,\n        0.0,  cos(ax), sin(ax),\n        0.0, -sin(ax), cos(ax)\n    );\n    mat3 m = mX * mY;\n    \n    vec3 v = vec3(p, 1.0);\n    v = m * v;\n    \n    float trail_start, trail_end, trail_length = 1.0, trail_x;\n    // Fade all the trails into view from black to a little above full-white:\n    float fade = mix(1.4, 0.0, smoothstep(0.65, 0.95, t));\n    //float fade = 1.2;\n    \n    // Each slice renders a single trail; but we can render multiple layers of\n    // slices to add more density and randomness to the effect:\n\tfor(float i = 0.0; i < 60.0; i++) \n    //float i = 1.0;\n    {\n        vec3 trail_color = vec3(0.0);\n\t\t//float angle = (atan(v.y, v.x) / 3.141592 / 3.0 + 0.5);\n        float angle = atan(v.y, v.x) / 3.141592 / 2.0 + 0.13 * i;\n        \n\t\tfloat slice = floor(angle * NUM_SLICES);\n        float slice_fract = fract(angle * NUM_SLICES);\n        // Don't center the trail in the slice: wiggle it a little bit:\n        float slice_offset = MAX_SLICE_OFFSET * \n            rand(vec2(slice, 4.0 + i * 25.0)) - (MAX_SLICE_OFFSET / 2.0);\n        // Without dist, all trails get stuck to the walls of the\n        // tunnel. Allowing dist to be negative gives a more homogeneous \n        // coverage of all the space, both in front and behind the \n        // camera.\n        float dist = 10.0 * rand(vec2(slice, 1.0 + i * 2.0)) - 5.0;\n        float z = dist * v.z / length(v.xy);\n        \n        // When dist is negative we have to invert a number of things:\n        float f = sign(dist);\n        if (f == 0.0) f = 1.0;\n        // This is the speed of the current slice\n        float fspeed = f * (rand(vec2(slice, 1.0 + i * 0.1)) + i * 0.01);\n        float fjump_speed = f * jump_speed;\n        float ftrail_length = f * trail_length;\n        \n        trail_end = 10.0 * rand(vec2(slice, i + 10.0)) - 5.0;\n\t\ttrail_end -= t * fspeed;\n        \n        // Adding to the trail pushes it \"back\": Z+ is into the screen\n        // away from the camera... unless f is negative, then we invert\n        // the rules\n        trail_start = trail_end + ftrail_length;\n        if (f >= 0.0) {\n            // Shrink the trails into their ends:\n            trail_start = max(trail_end,\n                              trail_start - (t * fspeed) - \n                                mix(0.0, fjump_speed, \n                                                smoothstep(0.5, 1.0, t))\n                              );\n            //float trail_x = smoothstep(trail_start, trail_end, p_len);\n        } else {\n            // Shrink the trails into their ends:\n            trail_start = min(trail_end,\n                              trail_start - (t * fspeed) -\n                                mix(0.0, fjump_speed, \n                                                smoothstep(0.5, 1.0, t))\n                              );\n        }\n        trail_x = smoothstep(trail_start, trail_end, z);\n        trail_color = mix(blue_col, white_col, trail_x);\n        \n        // This line computes the distance from the current pixel, in \"slice-coordinates\"\n        // to the ideal trail centered at the slice center. The last argument makes the lines\n        // a bit thicker when they reach the edges as time progresses.\n        float h = sdLine(\n            vec2(slice_fract + slice_offset, z),\n            vec2(0.5, trail_start), \n            vec2(0.5, trail_end),\n        \tmix(0.0, 0.015, z));\n        \n        // This threshold adds a \"glow\" to the line. This glow grows with\n        // time:\n        float threshold = mix(0.12, 0.0, smoothstep(0.5, 0.8, t));\n        //float threshold = 0.12;\n        h = (h < 0.01) ? 1.0 : 0.75 * smoothstep(threshold, 0.0, abs(h));\n        \n        trail_color *= fade * h;\n        // DEBUG\n        // This part displays the size of each slice.\n        //float r = 0.0;\n        //if (trail_start <= p_len && p_len <= trail_end)\n        //    r = 1.0;\n        //trail_color = vec3(h, h, h);\n        // DEBUG\n        \n        // Accumulate this trail with the previous ones\n        color = max(color, trail_color);\n\t}\n    // Whiteout\n    color += mix(1.0, 0.0, smoothstep(0.0, 0.2, t));\n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctVBRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1167, 1167, 1231, 1231, 1357], [1359, 1359, 1379, 1379, 1451], [1454, 1454, 1509, 1509, 6410]], "test": "untested"}
{"id": "ctKBRK", "name": "Fork Hyperspace guvacode 290", "author": "guvacode", "description": "Trying to make an effect that is closer to what we see in the original trilogies. Adapted from https://www.shadertoy.com/view/MlKBWw. Soon to be added to X-Wing Alliance. Use the mouse to look around.\n", "tags": ["tunnel", "starfield", "hyperspace", "starwars"], "likes": 4, "viewed": 177, "published": 3, "date": "1702275317", "time_retrieved": "2024-07-30T17:17:21.813908", "image_code": "/*\n\tSimplified and adapted from:\n\thttps://www.shadertoy.com/view/MlKBWw\n*/\n\n#define TAU 6.28318\n\n// Uncomment the following line to get a flare in the center (Disney-style)\n#define FLARE 1\n\n// The way this shader works is by looking at the screen as if it were a disk and then\n// this disk is split into a number of slices centered at the origin. Each slice renders\n// a single trail. So this setting controls the overall density of the effect:\n#define NUM_SLICES 125.0\n//#define NUM_SLICES 50.0\n\n// Each trail is rendered within its slice; but to avoid generating regular patterns, we\n// randomly offset the trail from the center of the slice by this amount:\nconst float MAX_SLICE_OFFSET = 0.4;\n\n// This is the length of the effect in seconds:\nconst float T_MAX = 2.0;\n// T_JUMP is in normalized [0..1] time: this is the time when the \n// trails zoom out of view because we've jumped into hyperspace:\nconst float T_JUMP = 0.75;\n// This is the speed during the final jump:\nconst float jump_speed = 15.0;\n\n// I've noticed that the effect tends to have a bluish tint. In this \n// shader, the blue color is towards the start of the trail, and the \n// white color towards the end:\nconst vec3 blue_col = vec3(0.3, 0.3, 0.5);\n//const vec3 white_col = vec3(0.95, 0.95, 1.0);\nconst vec3 white_col = vec3(0.85, 0.85, 0.9);\nconst vec3 flare_col = vec3(0.9, 0.9, 1.4);\n\nfloat array_mix(in float[4] array, in int n, float index)\n{\n    float dec = fract(index);\n    int i = int(floor(index));\n    if (i >= n - 1)\n        return array[i];\n    else\n    \treturn mix(array[i], array[i+1], dec);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, in float ring )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - ring;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n/*\n\tLens flare from: https://www.shadertoy.com/view/XdfXRX\n\tand: https://www.shadertoy.com/view/4sX3Rs \n*/\nvec3 lensflare(vec3 uv, vec3 pos, float flare_size, float ang_offset)\n{\n    float z = uv.z / length(uv.xy);\n\tvec2 main = uv.xy - pos.xy;\n    float dist = length(main);\n\tfloat num_points = 2.71;\n    float disk_size = 0.2;\n    float inv_size = 1.0 / flare_size;\n\tfloat ang = atan(main.y, main.x) + ang_offset;\n    float fade = (z < 0.0) ? -z : 1.0;\n    //if (z < 0.0) return vec3(0.0);\n    \n    float f0 = 1.0/(dist * inv_size + 1.0);\n    f0 = f0 + f0 * (0.1 * sin((sin(ang*2.0 + pos.x)*4.0 - cos(ang*3.0 + pos.y)) * num_points) + disk_size);\n    if (z < 0.0)\n\t\treturn clamp(mix(vec3(f0), vec3(0.0), 0.75 * fade), 0.0, 1.0);\n    else\n        return vec3(f0);\n}\n\nvec3 cc(vec3 color, float factor, float factor2) // color modifier\n{\n\tfloat w = color.x+color.y+color.z;\n\treturn mix(color, vec3(w) * factor, w * factor2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color = vec3(0.0);\n    float time = mod(iTime, T_MAX);\n    float t = time / T_MAX;\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 mo = (2.0 * iMouse.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    p += vec2(0, -0.2); // In XWA the aiming HUD is not at the screen's center\n    \n    float ta = TAU * mod(iTime, 8.0) / 8.0;\n    //ta = 12.0 * 0.01745;\n    \n    float ay = 0.0, ax = 0.0, az = 0.0;\n    if (iMouse.z > 0.0) {\n        ay = 3.0 * mo.x;\n        ax = 3.0 * mo.y;\n    }\n    mat3 mY = mat3(\n         cos(ay), 0.0,  sin(ay),\n         0.0,     1.0,      0.0,\n        -sin(ay), 0.0,  cos(ay)\n    );\n    \n    mat3 mX = mat3(\n        1.0,      0.0,     0.0,\n        0.0,  cos(ax), sin(ax),\n        0.0, -sin(ax), cos(ax)\n    );\n    \n    /*\n    mat3 mZ = mat3(\n        cos(az), sin(az), 0.0,\n       -sin(az), cos(az), 0.0,\n            0.0,     0.0, 1.0\n    );\n    */\n    mat3 m = mX * mY;\n    //p += vec2(0.0, -0.1); // + 12.0*m;\n    //p = (mX * vec3(p, 1.0)).xy;\n    \n    float p_len = length(p);\n    vec3 v = vec3(p, 1.0);\n    v = m * v;\n    \n    // The following line reverts the effect:\n    //t = 1.0 - t;\n    // DEBUG\n    //t = 0.5;\n    // DEBUG\n    \n    //float[4] flare_size;\n    //flare_size[0] = 0.0\n    \n    float trail_start, trail_end;\n    // Fade all the trails into view from black to a little above full-white:\n    float fade = clamp(mix(0.1, 1.1, t * 2.0), 0.0, 2.0);\n    //fade = 1.0;\n    \n    // Each slice renders a single trail; but we can render multiple layers of\n    // slices to add more density and randomness to the effect:\n\tfor(float i = 0.0; i < 80.0; i++) \n    //float i = 1.0;\n    {\n        vec3 trail_color = vec3(0.0);\n\t\t//float angle = (atan(v.y, v.x) / 3.141592 / 3.0 + 0.5);\n        float angle = atan(v.y, v.x) / 3.141592 / 2.0 + 0.13 * i;\n        \n\t\tfloat slice = floor(angle * NUM_SLICES);\n        float slice_fract = fract(angle * NUM_SLICES);\n        \n        // Don't center the trail in the slice: wiggle it a little bit:\n        float slice_offset = MAX_SLICE_OFFSET * \n            rand(vec2(slice, 4.0 + i * 25.0)) - (MAX_SLICE_OFFSET / 2.0);\n        \n        \n        // Without dist, all trails get stuck to the walls of the\n        // tunnel.\n        //float dist = rand(vec2(slice, 1.0 + i * 10.0)) * (2.0 + i);\n        float dist = 10.0 * rand(vec2(slice, 1.0 + i * 10.0)) - 5.0;\n        float z = dist * v.z / length(v.xy);\n        // When dist is negative we have to invert a number of things:\n        float f = sign(dist);\n        if (f == 0.0) f = 1.0;\n        // This is the speed of the current slice\n        float fspeed = f * (0.1 * rand(vec2(slice, 1.0 + i * 10.0)) + i * 0.01);\n        float fjump_speed = f * jump_speed;\n        \n\t\t//trail_start = 5.0 + 2.0 * rand(vec2(slice, 0.0 + i * 10.0));\n        trail_start = 10.0 * rand(vec2(slice, 0.0 + i * 10.0)) - 5.0;\n        \n        // Accelerate the trail_start:\n        trail_start -= mix(0.0, fjump_speed, smoothstep(T_JUMP, 1.0, t));\n        trail_end = trail_start - t * fspeed;\n        \n        //float trail_x = smoothstep(trail_start, trail_end, p_len);\n        float trail_x = smoothstep(trail_start, trail_end, z);\n        trail_color = mix(blue_col, white_col, trail_x);\n        \n        // This line computes the distance from the current pixel, in \"slice-coordinates\"\n        // to the ideal trail centered at the slice center. The last argument makes the lines\n        // a bit thicker when they reach the edges as time progresses.\n        float h = sdLine(\n            vec2(slice_fract + slice_offset, z),\n            vec2(0.5, trail_start), \n            vec2(0.5, trail_end),\n            //0.0);\n\t       \tmix(0.0, 0.015, t * z));\n        \n        //h = smoothstep(0.075, 0.01, abs(h) - 0.05);\n        // This threshold adds a \"glow\" to the line. This glow grows with\n        // time:\n        //float threshold = mix(0.04, 0.175, smoothstep(0.0, 0.5, t));\n        float threshold = 0.09;\n        h = (h < 0.01) ? 1.0 : 0.85 * smoothstep(threshold, 0.0, abs(h));\n        \n        trail_color *= fade * h;\n        // DEBUG\n        // This part displays the size of each slice.\n        //float r = 0.0;\n        //if (trail_start <= p_len && p_len <= trail_end)\n        //    r = 1.0;\n        //trail_color = vec3(h, h, h);\n        // DEBUG\n        \n        // Accumulate this trail with the previous ones\n        color = max(color, trail_color);\n\t}\n\n#ifdef FLARE\n    // Add the disk at the center to transition into the hyperspace\n    // tunnel\n    float flare_size = mix(0.0, 0.1, smoothstep(0.35, T_JUMP + 0.2, t));\n    flare_size += mix(0.0, 20.0, smoothstep(T_JUMP + 0.05, 1.0, t));\n    vec3 flare = flare_col * lensflare(v, vec3(0.0), flare_size, t);\n    color += cc(flare, 0.5, 0.1);\n    //color += flare;\n    // Whiteout\n    color += mix(0.0, 1.0, smoothstep(T_JUMP + 0.1, 1.0, t));\n#else\n    // Whiteout\n    color += mix(0.0, 1.0, smoothstep(T_JUMP - 0.0, 1.0, t));\n#endif\n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctKBRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1581, 1581, 1645, 1645, 1771], [1773, 1773, 1793, 1793, 1865], [1867, 1974, 2045, 2045, 2632], [2634, 2634, 2702, 2702, 2791], [2793, 2793, 2848, 2848, 7854]], "test": "untested"}
{"id": "dlyfzV", "name": "Fork Hyperspace guvacode 988", "author": "guvacode", "description": "Hyperspace Tunnel, v2.0. Using simplex noise to add more variety to the tunnel texture. See also: https://www.shadertoy.com/view/Wtd3Wr", "tags": ["tunnel", "hyperspace", "starwars"], "likes": 5, "viewed": 235, "published": 3, "date": "1702274994", "time_retrieved": "2024-07-30T17:17:22.576868", "image_code": "// Based on theGiallo's https://www.shadertoy.com/view/MttSz2\n// MIT License. Use freely; but attribution is expected.\n#define TAU 6.28318\n#define PI 3.141592\nconst float period = 1.0;\nconst float speed  = 2.0;\nconst float rotation_speed = 0.3;\nconst float t2 = 4.0; // Length in seconds of the effect\n\n// This effect fades in and out of white every t2 seconds\n// Remove the next def to get an infinite tunnel instead.\n//#define WHITEOUT 1\n\n// From https://www.shadertoy.com/view/4sc3z2\n// and https://www.shadertoy.com/view/XsX3zB\n#define MOD3 vec3(.1031,.11369,.13787)\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat simplexNoise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nfloat fBm3(in vec3 p)\n{\n    //p += vec2(sin(iTime * .7), cos(iTime * .45))*(.1) + iMouse.xy*.1/iResolution.xy;\n\tfloat f = 0.0;\n\t// Change starting scale to any integer value...\n\tfloat scale = 5.0;\n    p = mod(p, scale);\n\tfloat amp   = 0.75;\n\t\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tf += simplexNoise(p * scale) * amp;\n\t\tamp *= 0.5;\n\t\t// Scale must be multiplied by an integer value...\n\t\tscale *= 2.0;\n\t}\n\t// Clamp it just in case....\n\treturn min(f, 1.0);\n}\n\n// From: https://www.shadertoy.com/view/4dBcWy\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(0.1666666666666667, 0.3333333333333333) ; // 1.0/6.0, 1.0/3.0\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n// Original code ends here.\n\n\nfloat getnoise(int octaves, float persistence, float freq, vec3 coords) {\n\n    float amp= 1.; \n    float maxamp = 0.;\n    float sum = 0.;\n\n    for (int i=0; i < octaves; ++i) {\n\n        sum += amp * snoise(coords*freq); \n        freq *= 2.;\n        maxamp += amp;\n        amp *= persistence;\n    }\n    \n    return (sum / maxamp) * .5 + .5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = mod(iTime, t2);\n    t = t / t2; // Normalized time\n    \n    vec4 col = vec4(0.0);\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / min( iResolution.y, iResolution.x );\n    vec2 mo = (2.0 * iMouse.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    p += vec2(0.0, -0.1);\n    \n    //float ay = TAU * mod(iTime, 8.0) / 8.0;\n    //ay = 45.0 * 0.01745;\n    float ay = 0.0, ax = 0.0, az = 0.0;\n    if (iMouse.z > 0.0) {\n        ay = 3.0 * mo.x;\n        ax = 3.0 * mo.y;\n    }\n    mat3 mY = mat3(\n         cos(ay), 0.0,  sin(ay),\n         0.0,     1.0,      0.0,\n        -sin(ay), 0.0,  cos(ay)\n    );\n    \n    mat3 mX = mat3(\n        1.0,      0.0,     0.0,\n        0.0,  cos(ax), sin(ax),\n        0.0, -sin(ax), cos(ax)\n    );\n    mat3 m = mX * mY;\n    \n    vec3 v = vec3(p, 1.0);\n    v = m * v;\n    float v_xy = length(v.xy);\n    float z = v.z / v_xy;\n    \n    // The focal_depth controls how \"deep\" the tunnel looks. Lower values\n\t// provide more depth.\n\tfloat focal_depth = 0.15;\n    #ifdef WHITEOUT\n    focal_depth = mix(0.15, 0.015, smoothstep(0.65, 0.9, t));\n    #endif\n    \n    vec2 polar;\n    //float p_len = length(p);\n    float p_len = length(v.xy);\n    //polar.y = focal_depth / p_len + iTime * speed;\n    polar.y = z * focal_depth + iTime * speed;\n    //polar.y = z;\n    float a = atan(v.y, v.x);\n    //float a = atan(q.y, q.x);\n    // atan returns a value in the range -PI to PI, let's normalize\n    // that into the range [0..1]\n    a = 0.5 + 0.5 * a / (1.0 * PI);\n    a -= iTime * rotation_speed;\n    float x = fract(a);\n    // Remove the seam by reflecting the u coordinate around 0.5:\n    if (x >= 0.5) x = 1.0 - x;\n    polar.x = x;\n    \n    // Colorize blue\n    float val = 0.45 + 0.55 * fBm3(\n        vec3(vec2(2.0, 0.5) * polar, 0.15 * iTime));\n    //float val = getnoise(8, 0.65, 1.0, vec3(polar, 0));\n    val = clamp(val, 0.0, 1.0);\n    col.rgb = vec3(0.15, 0.4, 0.9) * vec3(val);\n    \n    // Add white spots\n    vec3 white = 0.35 * vec3(smoothstep(0.55, 1.0, val));\n    col.rgb += white;\n    col.rgb = clamp(col.rgb, 0.0, 1.0);\n    \n    float w_total = 0.0, w_out = 0.0;\n    #ifdef WHITEOUT\n    // Fade in and out from white every t2 seconds\n    float w_in = 0.0;\n    w_in = abs(1.0 - 1.0 * smoothstep(0.0, 0.25, t));\n    w_out = abs(1.0 * smoothstep(0.8, 1.0, t));\n    w_total = max(w_in, w_out);\n    #endif\n    \n    \n    // Add the white disk at the center\n    float disk_size = max(0.025, 1.5 * w_out);\n    //disk_size = 0.001;\n    float disk_col = exp(-(p_len - disk_size) * 4.0);\n    //col.rgb += mix(col.xyz, vec3(1,1,1), disk_col);\n    col.rgb += clamp(vec3(disk_col), 0.0, 1.0);\n    \n    \n    #ifdef WHITEOUT\n    col.rgb = mix(col.rgb, vec3(1.0), w_total);\n    #endif\n    \n    fragColor = vec4(col.rgb,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlyfzV.jpg", "access": "api", "license": "mit", "functions": [[571, 571, 593, 593, 745], [747, 747, 775, 775, 1435], [1437, 1437, 1460, 1547, 1888], [1938, 1938, 1959, 1959, 2008], [2010, 2010, 2031, 2031, 2080], [2082, 2082, 2104, 2104, 2144], [2146, 2146, 2174, 2174, 2226], [2228, 2228, 2252, 2252, 4296], [4328, 4328, 4401, 4401, 4669], [4671, 4671, 4728, 4728, 7530]], "test": "untested"}
{"id": "dtGfRV", "name": "usgs_gswa2 approximation", "author": "FordPerfect", "description": "Approximation of the USGS-GSWA2 hypsometric palette (by Dr. Richard L. Langford) used in cartography.", "tags": ["heightmap", "topography", "cartography", "hypsometric", "usgs"], "likes": 11, "viewed": 213, "published": 3, "date": "1702268531", "time_retrieved": "2024-07-30T17:17:23.437566", "image_code": "// Public Domain under http://unlicense.org, see link for details.\n// NOTE: while I place the *approximation* into the public domain,\n// the copyright status of the original palette is not obvious. Use\n// with caution.\n\n// usgs-gswa2 hypsometric palette approximation.\n// Source: http://soliton.vm.bytemark.co.uk/pub/cpt-city/usgs/index.html,\n// with input data interpreted as sRGB color triplets.\n// Range: 0..1, continuous (presumably corresponds to 0..10000 feet).\n// Only positive elevations are supported.\n// Approximation accuracy: max. abs. error is less than 0.034\n// in any color component, max. rel.error is less than 0.063 in\n// any color component.\n// NOTE: output colors are in linear RGB.\nvec3 usgs_gswa2(float x)\n{\n    x=clamp(x,0.0,1.0);\n    return vec3(\n        (x<0.524?0.212-x*(0.632-x*(27.562-x*(78.713-x*58.816))):-27.748+x*(144.705-x*(270.714-x*(221.135-x* 66.379)))),\n        (x<0.524?0.347+x*(0.588+x*(23.609-x*(95.574-x*91.712))): 24.117-x*(143.557-x*(314.521-x*(296.708-x*102.627)))),\n        (x<0.524?0.130-x*(0.442-x*(18.377-x*(67.714-x*67.014))):- 0.178+x*(  1.159-x*(  0.370+x*(  1.519-x*  1.906)))));\n}\n\n//==============================================================================\n// Terrain with derivatives, based on https://www.shadertoy.com/view/DtdyDl\n\n// https://www.shadertoy.com/view/dllSW7\nuint hash(uint x)\n{\n    x^=x>>15;\n    x^=(x*x)|1u;\n    x^=x>>17;\n    x*=0x9E3779B9u;\n    x^=x>>13;\n    return x;\n}\n\nfloat rnd2i(ivec2 v)\n{\n    return float(int(hash(uint(v.x+65536*v.y))))*4.6566129e-10;\n}\n\n// 2D value noise. Gradient in xy, value in z.\nvec3 noise2d(vec2 v)\n{\n    ivec2 i=ivec2(floor(v)),e=ivec2(0,1);\n    v=fract(v);\n    float A=rnd2i(i+e.xx);\n    float B=rnd2i(i+e.yx);\n    float C=rnd2i(i+e.xy);\n    float D=rnd2i(i+e.yy);\n    vec2 d=30.0*v*v*(v*(v-2.0)+1.0);\n    v=v*v*v*(v*(v*6.0-15.0)+10.0);\n    return vec3(\n        vec2(mix(B-A,D-C,v.y),mix(C-A,D-B,v.x))*d,\n        mix(mix(A,B,v.x),mix(C,D,v.x),v.y));\n}\n\n// Terrain function. Height in z, gradient in xy.\nvec3 f(vec2 v)\n{\n    vec3 ret=vec3(0);\n    float w=1.0;\n    mat2 m=mat2(0.6,0.8,-0.8,0.6),A=5.0*m;\n    for(int i=0;i<4;++i)\n    {\n        vec3 r=w*noise2d(A*v);\n        r.xy=r.xy*A;\n        ret+=r;\n        A*=2.0*m;\n        w*=0.5;\n    }\n    ret=0.75*ret+0.25*vec3(2.0*ret.z*ret.xy,ret.z*ret.z);\n    ret=0.5*ret+vec3(0.0,0.0,0.125);\n    return ret;\n}\n\n//==============================================================================\n// Main function.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy=(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 h=f(xy+0.1*iTime);\n    if(false&&xy.y>0.0) // Debug derivatives.\n    {\n        float eps=1e-3;\n        float dx=(f(xy+0.1*iTime+vec2(eps,0.0)).z-f(xy+0.1*iTime-vec2(eps,0.0)).z)/(2.0*eps);\n        float dy=(f(xy+0.1*iTime+vec2(0.0,eps)).z-f(xy+0.1*iTime-vec2(0.0,eps)).z)/(2.0*eps);\n        h.xy=vec2(dx,dy);\n    }\n    vec3 col=usgs_gswa2(h.z);\n    if(xy.x>0.0) col*=max(dot(normalize(vec3(h.xy,8.0)),normalize(vec3(1,-1,2))),0.0); // Hill-shading.\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtGfRV.jpg", "access": "api", "license": "public-domain", "functions": [[220, 703, 729, 729, 1133], [1293, 1334, 1353, 1353, 1448], [1450, 1450, 1472, 1472, 1538], [1540, 1587, 1609, 1609, 1962], [1964, 2014, 2030, 2030, 2364], [2466, 2466, 2523, 2523, 3157]], "test": "untested"}
{"id": "dlyBzK", "name": "Silver and gold rug", "author": "jarble", "description": "A fractal rug pattern.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 10, "viewed": 174, "published": 3, "date": "1702265445", "time_retrieved": "2024-07-30T17:17:24.264356", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 6.,c1=0.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.xy += iTime/t1/12.;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    vec3 col1 = col;\n    for(int k = 0; k < 9; k++){\n \n        uv = (uv+t2)/scale;\n        \n        uv = (fract(vec2(uv+vec2(.5,1.5))*scale)-.5)/scale;\n        \n        t2 = triangle_wave(uv+.5);\n        uv =\n            (t2+triangle_wave(uv.yx))\n        ;\n        c1 =\n            max(abs(uv.y-uv.x)/2.,c1)\n        ;\n        c1 =\n            abs(2.*c1-1.)\n        ;\n        col.x =\n            max(length(uv-t2-c1)/3.,col.x)\n            \n            //Blue and gold\n            //2.-max(length(uv-t2-c1)/3.,col.x)\n        ;\n        col =\n            abs(col-(1.-(c1*col.x)));\n        col1 =\n            abs(col1*c1-col-1.).yzx;\n    }\n    fragColor = vec4(col1/2.,1.0);\n}\n", "image_inputs": [], "sound_code": "\n//remix of https://www.shadertoy.com/view/DdyXz3\n\nfloat fmod(float a, float b){\n    for(float i = 1.; i < mod(floor(a/b/5.),5.); i++){\n        //a /= 2.;\n        a += mod(floor(a/5.),b)*i;\n    }\n    float a1 = a;\n    return\n        mod(floor(a),b)\n    ;\n}\n\n#define fract1(a) pow(fract(a),1.+log(2.)-log(1.+fract(a)))\n\nvec2 synth_(vec2 a1,vec2 a,vec2 a2,vec2 a3,vec2 nb,vec2 a4){\n    return log(a1+a*abs(a2-abs(.5-a3*vec2(fract1(nb.x*.998),fract1(nb.y)))*a4));\n}\n#define synth(a1,a,a2,a3,nb,a4) synth_(vec2(a1),vec2(a),vec2(a2),vec2(a3),vec2(nb),vec2(a4))\n\nvec2 mainSound(int samp, float time){\n  float tempo = .25;\n  time /= tempo;\n  float s1 =\n      8.;\n  for(float i = 1.; i < mod(floor(time/5.),5.); i++){\n      time += mod(floor(time/5.),s1)*i;\n      time /= 1.+fmod(floor(time/5.),2.);\n      tempo *= 1.+fmod(floor(time/5.),2.);\n  }\n  float s2 = 8.,\n  t=\n      time,\n  m1 =\n      fmod(t,s2)\n  ,\n  m3 =\n      fmod(t,1.+m1)+fmod(t/8.,2.);\n  t /=\n      (1.+fmod(t/s1,2.))*4./s1/s1\n  ;\n  float m2 =\n      1. + fmod(t/s1,s1)\n  ;\n  vec2 a=\n      //vec2((1.-sqrt(fract(t/s1)/1.25))*.2)\n      -vec2((log(1./64./2.+fract1(t/s1)/8.)))\n\n      //pow(1.-log(1./16./2.+fract(t/s1)/4.),2.)\n  ,\n  nb = vec2(time*tempo*pow(2.,floor((m3+m2)/2.)/5.+7.5));\n  vec2 \n  sitar = log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y*2.)))/2.)),\n  gamelan = a/16./4.*abs(log(1./4.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  +.5*log(1./4.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n  ,steel_drum = a/16./4.*abs(log(1./2.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))))\n  + log(1./8.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.)))      \n  ,oud = a/16./2.*abs(log(.5+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      +.5*log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n  \n  ,banjo =\n  a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./6.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,6./4.))\n  ;\n  return\n      abs(gamelan-steel_drum/2.)\n      //abs(banjo)\n      \n      //abs(gamelan-steel_drum/4.)\n      \n      \n      //oud\n      //abs(.5-vec2(fract(nb.x*.998*2.),fract(nb.y)))*a\n      \n      \n      //log(abs(a/4.-2.*abs(.5-vec2(fract(nb*.998*2.),fract(nb*2.)))*a))\n\n      //log(abs(a/8.-abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a))\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlyBzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 129], [131, 131, 188, 188, 1127]], "test": "untested"}
{"id": "ctyfRV", "name": "pared_2-1 wall", "author": "jorge2017a2", "description": "pared_2-1 wall", "tags": ["pared21wall"], "likes": 7, "viewed": 128, "published": 3, "date": "1702258812", "time_retrieved": "2024-07-30T17:17:25.111092", "image_code": "//----------image\n//por jorge2017a2-\n///pared_2-1 wall\n//10-dic-2023-\n//referencia iq funciones!!!\n#define MAX_STEPS 100\n#define MAX_DIST 255.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 estruct(vec3 p, vec2 res)\n{ vec3 p0=p;\n    p.y-=13.0;\n    p.y=abs(p.y)-30.0;\n    float d1=sdBox(p, vec3(10.0,20.0,10.0) );\n    p=p0;\n    float d2a=sdBox(p-vec3(0.0,12.0,10.0), vec3(15.0,50.0,5.0) );\n    float d2b=sdBox(p-vec3(0.0,12.0,17.0), vec3(18.0,50.0,1.0) );\n    res =opU2(res, vec2(d1,100.0));\n    res =opU2(res, vec2(d2a,100.0));\n    res =opU2(res, vec2(d2b,101.0));\n    p.y-=10.0;\n    float d3a= sdCylinderXZ( p, vec2(1.0,50.0) );\n    p.x=abs(p.x)-12.0;\n    float d3b= sdCylinderXZ(p-vec3(0.0,0.0,2.0), vec2(0.5,55.0) );\n    p=p0;\n    p.y-=14.0;\n    p.x=abs(p.x)-8.0;\n    float d3c= sdCylinderXZ(p-vec3(0.0,0.0,-10.5), vec2(0.5,55.0) );\n    res =opU2(res, vec2(d3a,102.0));\n    res =opU2(res, vec2(d3b,103.0));\n    res =opU2(res, vec2(d3c,101.0));\n    return res;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n     p.y=p.y+10.0;\n    vec3 p0=p;\n\tp.x=opRep1D(p.x, 36.0 );\n    res=estruct(p,res);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 pallete(float t) {\n    vec3 a = vec3(0.2);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c*t + d));\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n     vec3 V = normalize(ro - p);\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n    \n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.5)*specular*specular;\n    return colOut;\n}\n\nvec3 Getluz(vec3 ro,vec3 p, vec3 lp, vec3 lcol,vec3 n, float diffp, vec3 specp)\n{   vec3 v=normalize(ro-p);\n    vec3 h=normalize(lp+v);\n    vec3 l=normalize(lp-p);\n    float ndh=max(0.0,dot(n,h));\n    float ndl=max(0.0,dot(n,l));\n    float ndv=max(0.0,dot(n,v));\n    \n    float diff=ndl*diffp;\n    vec3  spec=0.8*pow(ndl,10.0)*specp;\n    vec3 col=(diff+spec*lcol);\n    return col;\n    \n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tvec3 col;\n    if (i==100 )\n    { col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel0, p/32., nor)*vec3(2.0,2.0,0.0); }\n\tif (i==102 ) { return tex3D(iChannel0, p/32., nor)*vec3(1.0,0.2,0.0)*3.0; }\n\tif (i==103 ) { return tex3D(iChannel0, p/32., nor)*vec3(0.5,0.2,1.0)*3.0; }\n    return vec3(0.0);\n}\n\n\nfloat N21 (vec2 p){\n    return fract( sin(p.x *  100. + p.y * 6574.) * 5647.);\n}\n\nfloat SmoothNoise(vec2 uv){\n    vec2 lv = smoothstep(0., 1., fract(uv));\n    vec2 id = floor(uv);\n    float bl = N21(id);\n    float br = N21(id + vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = N21(id + vec2(0, 1));\n    float tr = N21(id + vec2(1, 1));\n    float t = mix(tl, tr, lv.x);\n    return mix(b, t, lv.y);\n}\n\nfloat smoothNoise2(vec2 uv){ \n    float c = SmoothNoise(uv*4.);\n    c += SmoothNoise(uv*8.)* 0.5;\n    c += SmoothNoise(uv*16.) * 0.25;\n    c += SmoothNoise(uv*32.) * 0.125;\n    c += SmoothNoise(uv*64.) * 0.0625;\n    return c/2.;\n}\n\n///https://www.shadertoy.com/view/dttcDN\nvec3 nubes(vec2 uv )\n{float c = smoothNoise2(uv) + 0.2 + 0.4*sin(iTime);\n    vec3 col = vec3(c/1.5, c/1.2, c);\n    return col;\n}\n\n\n\n\nvec3 render_sky_color(vec3 rd)\n{ return nubes(rd.xz*0.5)*sin(iTime*20.0); } \n\n//https://www.shadertoy.com/view/WdsGR7\nvec3 getColor(float v)\n{  float r = cos((v-0.78)*PI*1.66);\n   float g = cos((v-0.58)*PI*1.66);\n   float b = cos((v-0.28)*PI*1.66);\n   return vec3(r,g,b); \n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }\n   if (id_color>=100 ){ return  getColorTextura( p, nor,id_color); }\n  return vec3(0.0);\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n        result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n        col=(col+col*sin(-iTime*10.0))/2.0;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    vec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n    vec2 mouseUV = iMouse.xy/iResolution.xy; // Range: <0, 1>\n   \n    float t0=iTime;\n    float t=mod(t0*5.0,500.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,7.0,-20.0);\n   ro.x=t0*5.0; \n   if(5.0*sin(t0)>0.0)\n       { ro.y-=5.0; ro.z+=5.0*sin(t0*0.25); }\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));  \n   if(7.0*sin(t0-10.0)>0.0)\n       {  rd= rotate_y(rd, radians(40.0)); rd= rotate_x(rd, radians(40.0)); }\n   else\n       {ro.z-=30.0;rd= rotate_x(rd, radians(-40.0));}\n   \n   \n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\nstruct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\n\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.7333, 0.1412, 0.1412), //33\nvec3(0.1843, 0.3333, 0.1843), //34\n vec3(0.6549, 0.6549, 0.9922), //35\n vec3(0.8549, 0.8549, 0.8549)  //36\n);\n\nvec3 getColor(int i)\n{   //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 )  return Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctyfRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[524, 524, 560, 560, 581], [582, 582, 614, 614, 698], [699, 699, 745, 745, 832], [833, 833, 867, 867, 929], [930, 930, 969, 969, 1064], [1065, 1065, 1104, 1104, 1199], [1202, 1202, 1246, 1246, 1273], [1274, 1274, 1314, 1314, 1341], [1342, 1342, 1387, 1387, 1415], [1417, 1417, 1453, 1453, 1498], [1500, 1500, 1534, 1534, 1630], [1631, 1631, 1665, 1665, 1756], [1757, 1757, 1791, 1791, 1882], [1884, 1884, 1916, 1916, 2663], [2665, 2665, 2690, 2690, 2824], [2826, 2826, 2850, 2850, 3012], [3014, 3014, 3062, 3062, 3341], [3344, 3344, 3388, 3388, 3709], [3711, 3711, 3748, 3748, 4005], [4007, 4007, 4030, 4030, 4185], [4187, 4187, 4277, 4277, 5249], [5251, 5251, 5332, 5332, 5638], [5640, 5640, 5689, 5689, 6025], [6028, 6028, 6047, 6047, 6108], [6110, 6110, 6137, 6137, 6442], [6444, 6444, 6472, 6472, 6674], [6676, 6717, 6739, 6739, 6845], [6850, 6850, 6882, 6882, 6925], [6928, 6968, 6992, 6992, 7124], [7126, 7126, 7196, 7196, 7378], [7380, 7380, 7407, 7407, 7496], [7498, 7498, 7556, 7556, 7604], [7606, 7606, 7629, 7629, 7741], [7744, 7744, 7775, 7775, 8438], [8440, 8440, 8497, 8497, 9268]], "test": "untested"}
{"id": "dtGBRG", "name": "Succulent (Any N)", "author": "Dain", "description": "Took jt's grass shader https://www.shadertoy.com/view/dtGBDz and modified it so that the repetition will work with any N value > 2, not just odd values\n\nIt has a curve applied to radius, this is not correct sdf, disable by setting SUCCULENT_RADIUS to 0", "tags": ["grass", "succulent"], "likes": 10, "viewed": 156, "published": 3, "date": "1702257505", "time_retrieved": "2024-07-30T17:17:25.926911", "image_code": "// https://www.shadertoy.com/view/dtGBDz orthogonal circles grassy plant, 2023 jt\n// based on https://www.shadertoy.com/view/ctyBzm orthogonal circles flower sdf 3d\n// based on https://www.shadertoy.com/view/clGBzm orthogonal circles flower sdf 2\n// based on https://www.shadertoy.com/view/dldBWl orthogonal circles flower sdf\n// exact sdf for shape related to https://www.shadertoy.com/view/cltfW2 orthogonal circles flower\n// SDF exactness using https://www.shadertoy.com/view/DdX3WH Interior Distance Detect Errors\n\n// Circle arcs orthogonal to unit sphere\n// with circle segment endpoints at equidistant latitude / longitude.\n// Reminds me of a clumpy grass variant I like.\n\n// TODO: Can something similar be done with spherical fibonacci instead?\n//       (see e.g. https://www.shadertoy.com/view/lllXz4 )\n\n// tags: sdf, flower, circle, grass, distance, conformal, disk, plant, loopless, exact, orthogonal\n\n// The MIT License\n// Copyright (c) 2023 Jakob Thomsen\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//succulent makes DF not so precise, so set to 0 if you want exact SDF\n//It doesn't appear to miss the surface, but it will jump further into the grass rather than landing on the 0 contour\n#define SUCCULENT_RADIUS .08\n\n//exact SDF radius, if somewhat boring looking\n#define GRASS_RADIUS 0.01\n\n#define pi 3.1415926\n\nfloat ortho_circle_flower_sdf(float n, vec2 p) // https://www.shadertoy.com/view/dldBWl orthogonal circle flower sdf (jt)\n{\n    p.x = abs(p.x);\n \n    n = 2.01+ abs(sin(iTime*.5)*10.0);//Any N > 2 will work now\n\n    float slice2 = (pi*2.0)/float(n);\n    \n    // endpoints\n    float phiReal = atan(p.x,p.y);\n\n    float endPtRound = fract(n*.5);\n    \n   //quantized phi--but do it so it works with any N value not just odd\n    float phi = (round(phiReal/slice2 - endPtRound)+endPtRound)*slice2;\n    \n    vec2 c = vec2(sin(phi),cos(phi));\n    \n    float d = length(p-c);//distance to endpoint\n    \n\n    bool wantCircle = dot(p,c)<1.0 \n                    ||  phi <0.0; //Without this sometimes you get a floating tip at center/top with non odd N :/\n    \n    \n    //we can skip this circle stuff when outside the shape\n    if(wantCircle){\n    \n        float slice = slice2*.5;\n        float a = (p.y*p.y+2.0*p.y+p.x*p.x+1.0);\n        float b = p.x*2.0;\n    \n        float ang1 = floor(atan(a,b)/slice)*slice;\n    \n        float r0 = tan(ang1);         // quantize floor angle\n        float r1 = tan(ang1 + slice); // quantize ceil angle\n \n        d =  min(abs(length(p-vec2(r0,-1))-r0),\n                 abs(length(p-vec2(r1,-1))-r1));\n    }\n    return d;\n }\n\nfloat dot2(vec2 a){\n   // return length(a);\n    return dot(a,a);\n}\nfloat fade(float f){\n   // return sin(f*pi);\n    f = 1.0-f*f;\n    f = 1.0-f*f;\n    return f;\n}\nfloat ortho_circle_flower_sdf(float m, float n, vec3 p) // https://www.shadertoy.com/view/dtGBDz orthogonal circles grassy plant (jt)\n{\n    float phi = round(atan(p.y,p.x)/(2.0*pi/float(m)))*(2.0*pi/float(m)); // polar & quantize\n  //  phi  = abs(phi);\n    p.xy = mat2(cos(phi),-sin(phi),sin(phi),cos(phi))*p.xy;\n   // p.x = abs(p.x);\n//    return length(vec2(ortho_circle_flower_sdf(n, vec2(p.xz)),p.y));\n    \n    float q = ortho_circle_flower_sdf(float(n), vec2(p.x,p.z));\n\n    return length(vec2(q,p.y))-SUCCULENT_RADIUS*fade(1.0-min(dot2(p.xz),1.0));;\n    \n}\n\nmat3 yaw_pitch_roll(float yaw, float pitch, float roll)\n{\n    mat3 R = mat3(vec3(cos(yaw), sin(yaw), 0.0), vec3(-sin(yaw), cos(yaw), 0.0), vec3(0.0, 0.0, 1.0));\n    mat3 S = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(pitch), sin(pitch)), vec3(0.0, -sin(pitch), cos(pitch)));\n    mat3 T = mat3(vec3(cos(roll), 0.0, sin(roll)), vec3(0.0, 1.0, 0.0), vec3(-sin(roll), 0.0, cos(roll)));\n\n    return R * S * T;\n}\n\nfloat map(vec3 p)\n{\n    float n = float(mix(3.0, 11.0, 0.5+0.5*cos(2.0*pi*iTime/10.0))); // animate number of leafs\n   // n = 5.0;\n    float m =2.01 + cos(iTime*.2)*10.0;\n   // m =3;\n    return ortho_circle_flower_sdf(m, n, p)-GRASS_RADIUS;\n}\n\n#define EPSILON 0.001\n#define DIST_MAX 50.0\n#define ITER_MAX 200u\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal( vec3 p )\n{\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) +\n                      k.yyx*map( p + k.yyx*h ) +\n                      k.yxy*map( p + k.yxy*h ) +\n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nfloat trace(vec3 ro, vec3 rd, float t0, float t1) // pass on running out of iterations\n{\n    // NOTE: Limited number of iterations to avoid stalling\n    //       when ray passes closely (just above EPSILON)\n    //       in parallel to a surface.\n    uint i;\n    float t;\n    for(t = t0, i = 0u; t < t1 && i < ITER_MAX; i++)\n    {\n        float h = map(ro + rd * t);\n        if(h < EPSILON)\n            return t;\n        t += h;\n    }\n\n    return t; // stop on running out of iterations\n    //return t1; // pass on running out of iterations\n}\n\n// NOTE: Don't forget to add +normal*EPSILON to the starting position\n//       to avoid artifacts caused by getting stuck in the surface\n//       due to starting at distance < EPSILON from the surface.\n//       (normal could be calculated here but that would most likely be redundant)\nfloat shadow(vec3 ro, vec3 rd, float t0, float t1)\n{\n    return trace(ro, rd, t0, t1) < t1 ? 0.0 : 1.0;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softshadow(vec3 ro, in vec3 rd, float t0, float t1, float k)\n{\n    float res = 1.0;\n    float ph = 1e20;\n    uint i;\n    float t;\n    for(t = t0, i = 0u; t < t1 && i < ITER_MAX; i++)\n    {\n        float h = map(ro + rd*t);\n        if( h < EPSILON )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) ;\n}\n\nvec3 material(vec3 p)\n{\n    return vec3(0.1,1.0,0.0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 I)\n{\n    bool demo = all(lessThan(iMouse.xy, vec2(10.0)));\n    vec2 R = iResolution.xy;\n    I = (2.0 * I - R) / R.y; // concise scaling thanks to Fabrice\n    float yaw = 2.0 * pi * float(iMouse.x) / float(R.x);\n    float pitch = pi - pi / 2.0 * float(iMouse.y) / float(R.y);\n    yaw = !demo ? yaw : 2.0 * pi * fract(iTime * 0.01);\n    pitch = !demo ? pitch : 4.0/3.0 * pi / 2.0;\n\n    vec3 ro = vec3(0.0, 0.0,-2.5);\n    vec3 rd = normalize(vec3(I.xy, 2.0)); // NOTE: omitting normalization results in clipped edges artifact\n\n    mat3 M = yaw_pitch_roll(yaw, pitch, 0.0);\n    ro = M * ro;\n    rd = M * rd;\n    //ro.z += 1.0;\n\n    vec3 color = vec3(1);\n    float dist = trace(ro, rd, 0.0, DIST_MAX);\n    if(dist < DIST_MAX)\n    {\n        vec3 dst = ro + rd * dist;\n        vec3 n = normal(dst);\n\n        //color *= (n * 0.5 + 0.5);\n        color *= material(dst);\n\n        vec3 lightdir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 ambient = vec3(0.4);\n        float brightness = max(dot(lightdir, n), 0.0);\n        if(brightness > 0.0)\n            brightness *= shadow(ro + rd * dist + n * 0.01, lightdir, 0.0, DIST_MAX);\n            //brightness *= softshadow(ro + rd * dist + n * 0.01, lightdir, 0.0, DIST_MAX, 20.0);\n        color *= (ambient * calcAO(dst, n) + brightness);\n\n        if(brightness > 0.0)\n        {\n            float specular = pow(max(0.0, dot(n, normalize(-rd + lightdir))), 250.0);\n            color += specular;\n        }\n\n        vec3 fog_color = vec3(0.2);\n        color = mix(fog_color, vec3(color), exp(-pow(dist/20.0, 2.0))); // fog\n    }\n    else\n    {\n        //color *= mix(vec3(0,0.5,0.5),vec3(0,0,1),abs(-rd.z)); // sky\n        color *= 0.0;\n    }\n\n    color = tanh(color); // roll-off overly bright colors\n    color = sqrt(color); // approximate gamma\n    fragColor = vec4(color, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtGBRG.jpg", "access": "api", "license": "mit", "functions": [[2307, 2307, 2430, 2430, 3560], [3562, 3562, 3581, 3605, 3628], [3629, 3629, 3649, 3673, 3723], [3724, 3724, 3859, 3859, 4286], [4288, 4288, 4345, 4345, 4691], [4693, 4693, 4712, 4712, 4935], [5004, 5070, 5093, 5093, 5352], [5354, 5354, 5442, 5599, 5895], [5897, 6182, 6234, 6234, 6287], [6289, 6334, 6402, 6402, 6777], [6779, 6843, 6885, 6885, 7175], [7177, 7177, 7200, 7200, 7232], [7234, 7234, 7278, 7278, 9093]], "test": "untested"}
{"id": "DtyBRV", "name": "snow flake tiles", "author": "ArmandB", "description": "some tiles", "tags": ["2d", "hexagon"], "likes": 10, "viewed": 162, "published": 3, "date": "1702256558", "time_retrieved": "2024-07-30T17:17:26.740736", "image_code": "#define PI 3.14159265\n\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat sdLine(vec2 a, vec2 b, vec2 p){\n    vec2 ab = b - a;\n    float t = dot(p - a, ab) / dot(ab, ab);\n    vec2 p2 = a + t*ab;\n    return length(p - p2);\n}\n\n//https://www.shadertoy.com/view/3sSGWt\nvec2 hexCoords(vec2 uv) {\n\tvec2 r = vec2(1, sqrt(3.0));\n    vec2 h = r*0.5;\n    \n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    \n    vec2 gv = uv - (dot(a,a) < dot(b,b) ? a : b);\n    \n    return gv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.y*3.0 + 1.0;\n    vec2 hexcoord = hexCoords(uv);\n    uv -= hexcoord;\n    \n    float a = floor(atan(uv.y,uv.x)*3.0/PI)*PI/3.0 + PI/6.0;\n    uvec2 uuv = uvec2(length(uv)*50.0,sdLine(vec2(0,0),vec2(cos(a),sin(a)),uv)*50.0 + floor(hash12(hexcoord)*200.0));\n    float i = fract(float(uuv.x & uuv.y)/9.0);\n    vec3 col = mix(vec3(0.784,0.933,0.996),vec3(0.357,0.557,0.745),i);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtyBRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 63, 84, 84, 201], [203, 203, 240, 240, 358], [360, 400, 425, 425, 613], [615, 615, 671, 671, 1111]], "test": "untested"}
{"id": "dlVfzy", "name": "1d noise exp", "author": "punpun", "description": "1d noise exp", "tags": ["noise", "experiment", "1d"], "likes": 2, "viewed": 110, "published": 3, "date": "1702246059", "time_retrieved": "2024-07-30T17:17:27.892655", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n\nfloat hash(float p) {\n    //43758.5453123\n    return fract(sin(p)*(43758.5453123+iTime));\n}\n\nfloat circle(in vec2 _st, in float _radius) {\n    vec2 dist = _st - vec2(0.5);\n\n    return 1. - smoothstep(_radius - (_radius * 0.01), _radius + (_radius * 0.01), dot(dist, dist) * 4.0);\n}\n\n\nfloat noise(in float x){\n    float i = floor(x);\n    float f = fract(x);\n    return mix(hash(i), hash(x+0.), smoothstep(0.0, 0.1, f));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y; // Aspect ratio\n    st.x -= .35;\n\n    vec3 color = vec3(circle(st, .7));\n    color = vec3(hash(st.x));\n    color = vec3(circle(st, noise(st.y)));\n    color = vec3(circle(st, noise(st.x+st.y)));\n    color = vec3(circle(st, noise(st.x-st.y)));\n    color = vec3(circle(st, noise(st.x*st.y)));\n    color = vec3(circle(st, noise(st.x/st.y)));\n    color = vec3(circle(st, noise(st.x*st.y+PI)));\n    //color = vec3(circle(st, noise(st.x*st.y-PI)));\n    //color = vec3(circle(st, noise(st.x*st.y/PI)));\n    //color = vec3(circle(st, noise(st.x*st.y*PI)));\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlVfzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 123, 143, 193], [195, 195, 240, 240, 383], [386, 386, 410, 410, 522], [524, 524, 581, 581, 1247]], "test": "untested"}
{"id": "dlVfzG", "name": "Dot Music", "author": "QuantumSuper", "description": "An auto-VJ of a rgb-shifted & morphing dot matrix displaying characters. Reactive to sound.\n\n- Use with music in iChannel0 -", "tags": ["2d", "music", "vj", "dotmatrix"], "likes": 12, "viewed": 289, "published": 3, "date": "1702238581", "time_retrieved": "2024-07-30T17:17:28.740388", "image_code": "// Dot Music v0.32.231210 by QuantumSuper\n// auto-vj of a rgb-shifted & morphing dot matrix reactive to sound & displaying characters\n// \n// - use with music in iChannel0 -\n\n#define PI 3.14159265359 \n#define aTime 150./60.*iTime\nvec4 fft, ffts; //compressed frequency amplitudes\nfloat warp; //screen warp factor\nfloat sc; //max scale factor\n\nvoid compressFft(){ //v1.2, compress sound in iChannel0 to simplified amplitude estimations by frequency-range\n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\n    for (int n=0;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 0-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(3,8,8,5); ffts /= vec4(2,3,3,23); //normalize\n\t\n\t//for (int n=0;n++<4;) fft[n] *= 1. + .3*pow(fft[n],5.); fft = clamp(fft,.0,1.); //limiter? workaround attempt for VirtualDJ\n}\n\nvec3 getCol(float id){ //v0.92, color definitions, for triplets\n    vec3 setCol = vec3(0);\n    id = mod(id,18.);\n         if (id< 1.) setCol = vec3(244,  0,204); //vw2 pink\n    else if (id< 2.) setCol = vec3(  0,250,253); //vw2 light blue\n    else if (id< 3.) setCol = vec3( 30, 29,215); //vw2 blue\n    else if (id< 4.) setCol = vec3(252,157,  0); //miami orange\n    else if (id< 5.) setCol = vec3( 26,246,138); //miami green\n    else if (id< 6.) setCol = vec3(131, 58,187); //nordic violet\n    else if (id< 7.) setCol = vec3(231, 15, 20); //arena red\n    else if (id< 8.) setCol = vec3( 35, 87, 97); //arena dark blue\n    else if (id< 9.) setCol = vec3(103,211,225); //arena blue\n    else if (id<10.) setCol = vec3(241,204,  9); //bambus2 yellow\n    else if (id<11.) setCol = vec3( 22,242,124); //bambus2 green\n    else if (id<12.) setCol = vec3( 30,248,236); //magic turquoise\n    else if (id<13.) setCol = vec3(123, 23,250); //cneon pink\n    else if (id<14.) setCol = vec3( 23,123,250); //cneon blue\n    else if (id<15.) setCol = vec3( 73, 73,250); //cneon white\n\telse if (id<16.) setCol = vec3(173,  0, 27); //matrix red\n    else if (id<17.) setCol = vec3( 28,142, 77); //matrix green\n    else if (id<18.) setCol = vec3( 66,120, 91); //matrix green 2\n    return setCol/256.;\n}\n\nfloat char(float c, vec2 p) { //get char from texture, source: https://www.shadertoy.com/view/MtySzd\n    return texture( iChannel1, clamp(p,0.,1.)/16. + fract(floor(vec2( c, 15.999-float(c)/16.))/16.)).x;\n}\n\nmat2 rotM(float r){float c = cos(r), s = sin(r); return mat2(c,s,-s,c);} //2D rotation matrix\n\nvec3 tmUnreal( vec3 c){return c / (c + .155) * 1.019;} //tone map, source: https://www.shadertoy.com/view/llXyWr\n\nfloat aaStep( float fun){return smoothstep( max(fwidth(fun),.2*(1.-fft.x)), .0, fun);} //simple conditional antialiasing\n\nfloat hash21(vec2 p){ //pseudorandom generator, cf. The Art of Code on youtu.be/rvDo9LvfoVE\n    p = fract(p*vec2(13.81, 741.76));\n    p += dot(p, p+42.23);\n    return fract(p.x*p.y);\n}\n\nfloat drawCirc( vec2 p, float s){ //draw circles of dot matrix\n    float aspect = length(iResolution.xy)/max(iResolution.x,iResolution.y); //aspect ratio corrector, 1..sqrt(2) for line..square\n    p *= rotM(sin(aTime/64.*PI)*.05); //rotation effect\n    float r = texelFetch( iChannel0, ivec2(512./aspect/cos(aspect*warp)*length(floor(p*s+.5)/s),0), 0 ).x; //grab audio amplitude\n    return aaStep( length(fract(p*s-.5)-.5)-.45*r) //circle    \n        //* (1.+9.*fft.y*step(fft.x,.92+fract(float(iFrame)*.5))*float( abs(floor(p.x*s+.5)*.5+floor(floor(p.y*s+.5)*sc)) ==  floor(fract(aTime/256.)*sc*sc*min(iResolution.x,iResolution.y)/max(iResolution.x,iResolution.y)) )) //running lights\n        * (1.+9.*fft.y*step(fft.x,.92)*float( abs(floor(p.x*s+.5)*.5+floor(floor(p.y*s+.5)*sc)) ==  floor(fract(aTime/256.)*sc*sc*min(iResolution.x,iResolution.y)/max(iResolution.x,iResolution.y)) )) //running lights\n        * step( .02, fract(p.x*s-.5)*fract(p.y*s-.5)*fract(-p.x*s-.5)*fract(-p.y*s-.5)); //ugly singularity fix\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    // General initialization\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1 to 1, square aspect ratio\n    vec2 v = vec2(1,0); //utility\n    compressFft(); //initializes fft, ffts\n        \n    // Base settings\n    warp = .5*fft.w; //warp factor\n    uv *= cos(length(uv*warp)); //screen warp effect\n    sc = 35.; //max scale factor\n    float scale = (.6-.4*cos(aTime/64.*PI)) * sc;\n\n    // Draw dot matrix\n    vec3 col = vec3(0) + \n        v.xyy * drawCirc( uv, scale     ) + //r\n        v.yxy * drawCirc( uv, scale*1.01) + //g\n        v.yxy * drawCirc( uv, scale*1.02);  //b\n    \n    // Overlay characters\n    vec2 offset = vec2(.5) + mix(.0,.01-.02*hash21(fft.yz),fft.z*fft.z*2.-1.); //char pos + shake\n    scale *= .04; //char scale\n    float myString = (fract(aTime/256.)<.5)?\n        char( 77., uv*scale+offset+v*1.) + \n        char( 65., uv*scale+offset+v*.5) +\n        char( 82., uv*scale+offset+v*.0) +\n        char( 73., uv*scale+offset-v*.5) +\n        char( 65., uv*scale+offset-v*1.) : //\"MARIA\"\n        char( 65., uv*scale+offset+v*.5) +\n        char( 68., uv*scale+offset+v*.0) +\n        char( 73., uv*scale+offset-v*.4) ; //\"ADI\"  \n    float amp = (fft.x>.97)? fract(float(iFrame)*.5)*22. : 1.; //char strobo\n    col *= .05 + .95*mix( 1., amp*myString, clamp(fft.x/.92,.0,1.)); //overlay string\n\n    // Finalization\n    float colId = 3. * floor(aTime/32.); //color set id\n    col = mat3( getCol( colId+0.), getCol( colId+1.), getCol( colId+2.)) * col * (.1+.9*ffts.xyz/max(.001,max(ffts.x,max(ffts.y,ffts.z)))); //remap colors\n    col = tmUnreal( col); //tone map & gamma\n\tcol -= length(uv) * fft.z * .2; //vignette\n    fragColor = vec4(col,1.); //output\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35536, "src": "https://soundcloud.com/garderecords/jkrs-echo-maneater-sped-up", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlVfzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[342, 342, 361, 452, 1574], [1576, 1576, 1598, 1639, 2856], [2858, 2858, 2887, 2958, 3064], [3066, 3066, 3085, 3085, 3138], [3161, 3161, 3184, 3184, 3215], [3275, 3275, 3300, 3300, 3361], [3397, 3397, 3418, 3488, 3581], [3583, 3583, 3616, 3645, 4599], [4601, 4601, 4656, 4686, 6375]], "test": "untested"}
{"id": "dtyfDh", "name": "Hyperbolic Pentagons", "author": "mla", "description": "Hyperbolic Pentagonal Tilings. Mouse drags centre point. 'x' to enter \"configuration mode\". See header for more info, controls, etc.", "tags": ["tiling", "pentagon", "hyperbolic", "hyperboloid"], "likes": 19, "viewed": 216, "published": 3, "date": "1702237291", "time_retrieved": "2024-07-30T17:17:29.912255", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Hyperbolic Pentagonal Tilings, mla, 2023.\n//\n// A convex hyperbolic pentagon with angles integral fractions of Ï will\n// tile the hyperbolic plane. As well as the angles, two side lengths\n// of the pentagon can be specified.\n//\n// Set side lengths in \"configuration mode\" by pressing 'x' and dragging\n// the red ring. Not all combinations of angles and lengths are possible.\n// The screen may flash red for an invalid combination.\n//\n// When not in configuration mode, use the mouse to drag centre point.\n//\n// <up>,<down>: zoom in/out\n// c: don't colour tiles\n// d: don't shade area outside disc\n// h: half space projection\n// i: set angles R and S to zero (overrides 'j')\n// j: set all angles to PI/3\n// l: use thick lines\n// t: don't show travelling point\n// v: don't show vertices\n// x: config mode\n// z: zoom in (only in half space projection)\n//\n// Most of the calculations are done in the hyperboloid model, with\n// the Poincare disc used for folding into the fundamental region.\n//\n// Point A is the centre, (0,0,1), which lies on lines a and e, at angle\n// P to each other. Measuring along a and e from A gives two more\n// points, B and E and we construct lines b and d through them at angles \n// Q and T. Finally, a line c is constructed making angles R and S with b\n// and d. This line (if it exists) is unique and determines the length of\n// the final three segments.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Polygon angles are PI/P etc. Can be overridden in mainImage.\nint P = 2, Q = 3, R = 4, S = 5, T = 6;\n\n// Basic operations for hyperbolic (Minkowski) space\n\n// Inner product\nfloat hdot(vec3 p, vec3 q) {\n  return dot(vec3(1,1,-1)*p,q);\n}\n\nvec3 hcross(vec3 p, vec3 q) {\n  // hdot(p,hcross(p,q)) = hdot(q,hcross(p,q)) = 0\n  return cross(p,q)*vec3(1,1,-1);\n}\n\nfloat hlength(vec3 p) {\n  return sqrt(abs(hdot(p,p)));\n}\n\n// Normalize a point or a line\nvec3 hnormalize(vec3 p) {\n  return p/hlength(p);\n}\n\n// Map point on plane to hyperboloid hnorm(p) = -1\nvec3 unproject(vec2 z) {\n  // kÂ²|z|Â²-(1-k)Â² = -1\n  // kÂ²|z|Â²-1+2k-kÂ² = -1\n  // k|z|Â²+2-k = 0\n  float k = 2.0/(1.0-dot(z,z));\n  return vec3(k*z,k-1.0);\n}\n\n// NB: sinh(x) = asinh(x) = tanh(x) = x (approximately) for\n// small values of x (eg. sinh 0.1 = 0.10017, tanh 0.1 = 0.0997)\n// Hyperbolic distance from line\nfloat hline(vec3 p, vec3 l) {\n  return abs(asinh(hdot(p,l)));\n}\n\n// Hyperbolic distance between points\nfloat hpoint(vec3 p, vec3 q) {\n  //return acosh(-hdot(p,q)); // Bad truncation error\n  return 2.0*abs(asinh(0.5*hlength(p-q)));\n}\n\n// Find a point on the line formed by the intersections\n// of planes l and m. Try to find point of form\n// (x,y,0), (x,0,z) or (0,y,z) by solving a 2x2\n// linear system. Construct three matrices & use the one\n// with largest determinant (it's possible for two\n// determinants to be zero, but not all three if the\n// planes aren't parallel).\nvec3 linepoint(vec3 l, vec3 m, float a, float b) {\n  vec2 A = vec2(1,-1); // adjust for metric\n  mat2 m0 = mat2(l.xy,m.xy);\n  mat2 m1 = mat2(A*l.xz,A*m.xz);\n  mat2 m2 = mat2(A*l.yz,A*m.yz);\n  float d0 = abs(determinant(m0));\n  float d1 = abs(determinant(m1));\n  float d2 = abs(determinant(m2));\n  float dmax = max(d0,max(d1,d2));\n  if (dmax == d1) m0 = m1;\n  else if (dmax == d2) m0 = m2;\n  vec3 p = vec3(vec2(a,b)*inverse(m0),0);\n  if (dmax == d1) p = p.xzy;\n  else if (dmax == d2) p = p.zxy;\n  assert(eq(hdot(p,l),a));\n  assert(eq(hdot(p,m),b));\n  return p;\n}\n\n// Given vectors l and m, return a normalized vector n\n// with l.n = a, m.n = b (all with Minkowski product)\n// sign parameter says if we want a line (spacelike) or a point (timelike)\nbool f(vec3 l, vec3 m, float a, float b, out vec3 n, float sign) {\n  // Want a line m with hdot(l,n) = A, hdot(m,n) = B\n  vec3 r = hcross(l,m); // Direction vector for intersection of planes l and m\n  // Now find p with hdot(p,l) = A, hdot(p,m) = B\n  vec3 p = linepoint(l,m,a,b);\n  // Now try to find a normalized point on that line ie. hnorm(p+tr) = <sign>\n  // (p+tr).(p+tr) - sign = 0\n  // p.p + 2t(p.r) + tÂ²(r.r) - 1 = 0\n  // Set p.r = 0, so B = 0 in quadratic formula\n  p -= hdot(p,r)/hdot(r,r)*r;\n  float A = hdot(r,r);\n  float C = hdot(p,p) - sign;\n  float D = -A*C;\n  if (D < 0.0) return false;\n  // Two solutions are eg. for complementary angles, opposite distances.\n  float t = sqrt(D)/A;\n  n = p+t*r;\n  return true;\n}\n\n// Find a (normalized) point p with l.p = a, m.p = b\n// l and m can be points or lines\nvec3 fpoint(vec3 l, vec3 m, float a, float b) {\n  vec3 p;\n  bool t = f(l,m,a,b,p,-1.0);\n  assert(t);\n  assert(p.z >= 0.0);\n  return p;\n}\n\n// Find a (normalized) line p with l.p = a, m.p = b\n// l and m can be points or lines\nvec3 fline(vec3 l, vec3 m, float a, float b) {\n  vec3 p;\n  bool t = f(l,m,a,b,p,1.0);\n  assert(t);\n  assert(p.z <= 0.0);\n  return p;\n}\n\n// Get point on line l, distance d from p, also on l.\n// Same as fpoint(p,l,-cosh(d),0) but less rounding error.\nvec3 pointatdistance(vec3 p, vec3 l, float d) {\n  vec3 r = hcross(p,l); // Tangent vector\n  float k = tanh(d)/hlength(r); // Get right angle\n  vec3 q = p+k*r;\n  return hnormalize(q); // And normalize\n}\n\n// Reflect in a hyperbolic line\nint tryreflect(vec3 l, int i, inout vec3 p, inout uint h) {\n  float k = hdot(p,l);\n  if (k > 0.0) return 0;\n  p -= 2.0*k*l;\n  h = ihash(h^uint(i));\n  return 1;\n}\n\n// Reflect in a euclidean line\nint tryreflect(vec2 l, int i, inout vec2 z, inout uint h) {\n  float k = dot(z,l);\n  if (k > 0.0) return 0;\n  z -= 2.0*k*l;\n  h = ihash(h^uint(i));\n  return 1;\n}\n\n// Invert in a euclidean circle\nint tryinvert(vec3 c, int i, inout vec2 z, inout uint h) {\n  float r2 = c.z;\n  vec2 z1 = z-c.xy;\n  float l2 = dot(z1,z1);\n  if (l2 > r2) return 0;\n  z1 *= r2/l2;\n  z = z1+c.xy;\n  h = ihash(h^uint(i));\n  return 1;\n}\n\n// Convert hyperbolic line into a Euclidean circle.\n// z component is square of radius.\nvec3 tocircle(vec3 l) {\n  assert(l.z != 0.0);\n  l /= l.z;\n  l.z = dot(l.xy,l.xy)-1.0;\n  return l;\n}\n\n// Convert hyperbolic line into a Euclidean line.\nvec2 toline(vec3 l) {\n  assert(l.z == 0.0);\n  return l.xy;\n}\n\nvec3 fold(vec2 z, int N, vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, inout uint h) {\n  // Using Poincare model for the fold seems to be more stable\n  // so convert hyperbolic lines to Euclidean lines or circles\n  vec2 A = toline(a);\n  vec3 B = tocircle(b);\n  vec3 C = tocircle(c);\n  vec3 D = tocircle(d);\n  vec2 E = toline(e);\n  for (int i = 0; i < N; i++) {\n    int k = 0;\n    k += tryreflect(A,0,z,h);\n    k += tryinvert(B,1,z,h);\n    k += tryinvert(C,2,z,h);\n    k += tryinvert(D,3,z,h);\n    k += tryreflect(E,4,z,h);\n    if (k == 0) break;\n  }\n  return unproject(z);\n}\n\nvec3 hfold(vec2 z, int N, vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, inout uint h) {\n  // Neat, but errors accumulate much more quickly\n  vec3 p = unproject(z);\n  for (int i = 0; i < N; i++) {\n    int k = 0;\n    k += tryreflect(a,0,p,h);\n    k += tryreflect(b,1,p,h);\n    k += tryreflect(c,2,p,h);\n    k += tryreflect(d,3,p,h);\n    k += tryreflect(e,4,p,h);\n    if (k == 0) break;\n  }\n  return p;\n}\n\n// Given a Euclidean distance d, and a direction p, return\n// an hspace point that is at that distance and direction\n// from the centre in the Poincare disc.\nvec3 pointfromcentre(float d, vec2 p) {\n  float x = 2.0*d/(1.0-d*d);\n  float t = sqrt(1.0+x*x);\n  return vec3(x*p,t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Calculate sides and vertices of the polygon.\n  // All angles are given, as well as side lengths for a and e.\n  // A a B b C c D d E e A ..\n  // A is at origin, so a and e are straight lines in disc model\n  // and have t = 0 in hyperboloid model.\n  // Angle at A is PI/P, etc\n  // R = 0 means R = PI/infinity, also works for S\n  if (key(CHAR_J)) P = Q = R = S = T = 3;\n  if (key(CHAR_I)) R = S = 0;\n  assert(P != 0 && Q != 0 && T != 0);\n  vec2 params = abs(getselection(0));\n  vec3 a = vec3(1,0,0);\n  vec3 e = vec3(-icos(P),isin(P),0);\n  vec3 A = vec3(0,0,1);\n  vec3 B = pointfromcentre(params[1],vec2(0,1));\n  vec3 E = pointfromcentre(params[0],vec2(isin(P),icos(P)));\n  vec3 b = fline(a,B,-icos(Q),0.0);\n  vec3 d = fline(E,e,0.0,-icos(T));\n  vec3 c = fline(d,b,-icos(S),-icos(R));\n  vec3 C = hnormalize(hcross(b,c));\n  vec3 D = hnormalize(hcross(c,d));\n  vec3 T = vec3(0); // This point will travel around the edges of the polygon\n  if (!configmode && !key(CHAR_T) && !key(CHAR_I)) {\n    // Set up the travelling point. If any points are ideal, this\n    // doesn't work too well, since the polygon perimeter is\n    // infinite, so don't do if 'i' pressed.\n    // Maybe I should have an array of points...\n    float k[] = float[](acosh(-hdot(A,B)),\n                        acosh(-hdot(B,C)),\n                        acosh(-hdot(C,D)),\n                        acosh(-hdot(D,E)),\n                        acosh(-hdot(E,A)));\n    float ttime = 0.0;\n    int N = k.length();\n    for (int i = 0; i < N; i++) ttime += k[i];\n    float etime = mod(iTime,ttime);\n    vec3 X = A, x = a;\n    for (int i = 0; i < N; i++) {\n      if (etime < k[i]) {\n        if (i == 1) X = B, x = b;\n        if (i == 2) X = C, x = c;\n        if (i == 3) X = D, x = d;\n        if (i == 4) X = E, x = e;\n        break;\n      }\n      etime -= k[i];\n    }\n    T = pointatdistance(X,x,etime);\n  }\n  vec2 z = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  vec2 w = vec2(0);\n  if (!configmode) w = defaultselection();\n  float scale = 1.0;\n  scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  z *= scale;\n  w *= scale;\n  float lwidth = 0.02;\n  float pwidth = 3.0*lwidth;\n  if (!key(CHAR_L)) lwidth = 0.0;\n  \n  float px = fwidth(z.x);\n  bool dohalfplane = key(CHAR_H);\n  bool dozoom = key(CHAR_Z);\n  if (dohalfplane) z.y += scale;\n  // Conversion factor between hyperbolic and screen distances\n  float scalefactor = 1.0;\n  if (dohalfplane) {\n    if (dozoom) {\n      float k = exp(-iTime);\n      z *= k;\n      scalefactor /= k;\n    }\n    z.y += 1.0;\n    float k = 2.0/dot(z,z);\n    z *= k;\n    scalefactor /= k;\n    z.y -= 1.0;\n  }\n  scalefactor *= 0.5*abs(1.0 - dot(z,z));\n  if (!configmode) {\n    // Invert to mouse position\n    vec2 c = w;\n    z -= c;\n    z *= (dot(c,c)-1.0)/dot(z,z);\n    z += c;\n    z /= -dot(z,z);\n  }\n  bool indisc = dot(z,z) <= 1.0;\n  if (!indisc) z /= dot(z,z);\n  int N = configmode ? 0 : 10;\n  uint h = 12345678u; // hash for region\n  vec3 p = fold(z,N,a,b,c,d,e,h);\n  vec3 col = vec3(0.5,1,1);\n  if (!configmode && !key(CHAR_C)) col = h2rgb(float(h)/exp2(32.0));\n  {\n    float t = 1e8;\n    t = min(t,hline(p,a));\n    t = min(t,hline(p,b));\n    t = min(t,hline(p,c));\n    t = min(t,hline(p,d));\n    t = min(t,hline(p,e));\n    vec3 lcol = vec3(0.1);\n    if (!configmode && key(CHAR_W)) lcol = vec3(1);\n    col = mix(lcol,col,smoothstep(0.0,px/scalefactor,t - lwidth));\n  }\n  {\n    float t = 1e8;\n    if (!key(CHAR_V)) {\n      t = min(t,hpoint(p,A));\n      t = min(t,hpoint(p,B));\n      t = min(t,hpoint(p,C));\n      t = min(t,hpoint(p,D));\n      t = min(t,hpoint(p,E));\n    }\n    if (T != vec3(0)) {\n      t = min(t,hpoint(p,T));\n    }\n    col = mix(vec3(0),col,smoothstep(0.0,px/scalefactor,t - pwidth));\n  }\n  if (!key(CHAR_D) && !indisc) col *= 0.5;\n  if (configmode) {\n    vec2 p = map(fragCoord);\n    float d = abs(distance(p,getselection(0))-0.03)-0.005;\n    col = mix(vec3(1,0,0),col,0.25+0.75*smoothstep(0.0,px,d));\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  //setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  vec4 t0 = texelFetch(iChannel2,ivec2(0),0); // Get current state   \n  if (iFrame == 0 || t0 != vec4(1234.0)) {\n    t = vec4(0);\n  }  \n  if (j == 0) {\n    if (i == 0) t = vec4(1234.0);\n    else {\n      // First row - key count\n      // Do key repeat here as well?\n      float w1 = keystate(i,0).x;\n      if (w1 != t.w) {\n        t.w = w1;\n        // Don't count key changes when ALT pressed\n        if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n          t.x++; t.y = iTime;\n        }\n      }\n      // Key repeat - only when shader is running!\n      // Should have longer pause after first key press.\n      if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n        t.x++; t.y = iTime;\n      }\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (configmode && t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        t.x = -1.0;\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < 0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n      if (!configmode && t.x <= 0.0 && iMouse.z > 0.0) {\n        t.zw = iMouse.x < 20.0 ? vec2(0) : map(iMouse.xy);\n      }\n    } else if (iFrame == 0 || t.w != 1234.0) {\n      t.xy = initselection(i-1); // Current coordinates\n      t.w = 1234.0;\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store((key),0).x))\n#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\n#define map(screenpos) ((2.0*(screenpos)-iResolution.xy)/iResolution.y)\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n//#define getselected() (texelFetch(iChannel2,ivec2(0,3),0))\n#define defaultselection() (texelFetch(iChannel2,ivec2(0,3),0).zw)\n//#define setscale() (scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP))))\n#define configmode (key(CHAR_X))\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst float PI =  3.141592654;\n\nconst int nselections = 1;\nvec2 initselection(int i) {\n  if (i == 0) return vec2(0.8,0.7);\n  if (i == 1) return vec2(0.75,0.25);\n  if (i == 2) return vec2(-2,-1.5);\n  if (i == 3) return vec2(0,-1);\n  if (i == 4) return vec2(0.25,0);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n  return mix(vec3(1),rgb,0.8);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nvec2 expi(float t) {\n  return normalize(vec2(cos(t),sin(t)));\n}\n\nbool eq(float a, float b) {\n  return abs(a-b) < 1e-4;\n}\n\nfloat COS[] =\n  float[](1.0,-1.0,0.0,0.5,0.7071067812,0.8090169944,0.8660254038,\n          0.9009688679,0.9238795325,0.9396926208,0.9510565163,0.9594929736,\n          0.9659258263,0.9709418174,0.9749279122,0.9781476007,0.9807852804,\n          0.9829730997,0.984807753,0.9863613034,0.9876883406,0.9888308262,\n          0.9898214419,0.990685946,0.9914448614,0.9921147013,0.9927088741,\n          0.9932383577,0.9937122099,0.9941379572,0.9945218954,0.9948693234);\n\nfloat icos(int p) {\n  // cos(PI/p)\n  if (p < COS.length()) return COS[p];\n  return cos(PI/float(p));\n}\n                        \nfloat isin(int p) {\n  // sin(PI/p)\n  float t = icos(p);\n  return sqrt(1.0-t*t);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtyfDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1711, 1728, 1756, 1756, 1790], [1792, 1792, 1821, 1872, 1908], [1910, 1910, 1933, 1933, 1966], [1968, 1999, 2024, 2024, 2049], [2051, 2102, 2126, 2201, 2261], [2263, 2421, 2450, 2450, 2484], [2486, 2524, 2554, 2608, 2653], [2655, 2996, 3046, 3046, 3557], [3559, 3743, 3809, 3862, 4472], [4474, 4561, 4608, 4608, 4697], [4699, 4785, 4831, 4831, 4919], [4921, 5034, 5081, 5081, 5235], [5237, 5269, 5328, 5328, 5430], [5432, 5463, 5522, 5522, 5623], [5625, 5657, 5715, 5715, 5871], [5873, 5961, 5984, 5984, 6060], [6062, 6112, 6133, 6133, 6172], [6174, 6174, 6254, 6380, 6742], [6744, 6744, 6825, 6876, 7139], [7141, 7299, 7338, 7338, 7418]], "test": "untested"}
{"id": "DtKBzy", "name": "Purple aurora", "author": "DKXLY", "description": "Pretty purple aurora", "tags": ["star", "stars", "aurora", "purple", "wallpaper", "lively", "livelywallpaper"], "likes": 6, "viewed": 427, "published": 3, "date": "1702227724", "time_retrieved": "2024-07-30T17:17:31.067167", "image_code": "// Original made by nimitz 2017 (twitter: @stormoid)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n// This is a modified purple version\n\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\nfloat tri(in float x){return clamp(abs(fract(x)-.5),0.01,0.49);}\nvec2 tri2(in vec2 p){return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));}\n\nfloat triNoise2d(in vec2 p, float spd)\n{\n    float z=1.8;\n    float z2=1.1;\n\tfloat rz = 0.;\n    p *= mm2(p.x*0.06);\n    vec2 bp = p;\n\tfor (float i=0.; i<5.; i++ )\n\t{\n        vec2 dg = tri2(bp*1.85)*.75;\n        dg *= mm2(time*spd);\n        p -= dg/z2;\n\n        bp *= 1.3;\n        z2 *= .45;\n        z *= .42;\n\t\tp *= 1.21 + (rz-1.0)*.02;\n        \n        rz += tri(p.x+tri(p.y))*z;\n        p*= -m2;\n\t}\n    return clamp(1./pow(rz*29., 1.3),0.,.55);\n}\n\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nvec4 aurora(vec3 ro, vec3 rd)\n{\n    vec4 col = vec4(0);\n    vec4 avgCol = vec4(0);\n    \n    for(float i=0.;i<50.;i++)\n    {\n        float of = 0.006*hash21(gl_FragCoord.xy)*smoothstep(0.,15., i);\n        float pt = ((.8+pow(i,1.4)*.002)-ro.y)/(rd.y*2.+0.4);\n        pt -= of;\n    \tvec3 bpos = ro + pt*rd;\n        vec2 p = bpos.zx;\n        float rzt = triNoise2d(p, 0.06);\n        vec4 col2 = vec4(0,0,0, rzt);\n        col2.rgb = (sin(2.-vec3(-10,-.7, 1.3)+i*0.03)*0.5+0.5)*rzt;\n        avgCol =  mix(avgCol, col2, .5);\n        col += avgCol*exp2(-i*0.065 - 2.5)*smoothstep(0.7,5., i);\n        \n    }\n    \n    col *= (clamp(rd.y*17.+.4,0.,1.));\n    \n    \n    //return clamp(pow(col,vec4(1.3))*1.5,0.,1.);\n    //return clamp(pow(col,vec4(1.7))*2.,0.,1.);\n    //return clamp(pow(col,vec4(1.5))*2.5,0.,1.);\n    //return clamp(pow(col,vec4(1.8))*1.5,0.,1.);\n    \n    //return smoothstep(0.,1.1,pow(col,vec4(1.))*1.5);\n    return col*1.8;\n    //return pow(col,vec4(1.))*2.\n}\n\n\n//-------------------Background and Stars--------------------\n\nvec3 nmzHash33(vec3 q)\n{\n    uvec3 p = uvec3(ivec3(q));\n    p = p*uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\n    p = p.yzx*(p.zxy^(p >> 3U));\n    return vec3(p^(p >> 16U))*(1.0/vec3(0xffffffffU));\n}\n\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.;\n    \n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = nmzHash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.1+0.9);\n        p *= 1.3;\n    }\n    return c*c*.8;\n}\n\nvec3 bg(in vec3 rd)\n{\n    float sd = dot(normalize(vec3(-0.5, -0.6, 0.9)), rd)*0.5+0.5;\n    sd = pow(sd, 5.);\n    vec3 col = mix(vec3(0.1,0.1,0.2), vec3(0.1,0.05,0.2), sd);\n    return col*.63;\n}\n//-----------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q - 0.5;\n\tp.x*=iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0,0,-6.7);\n    vec3 rd = normalize(vec3(p,1.3));\n    vec2 mo = iResolution.xy+1.4;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.1,0.1):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n    rd.yz *= mm2(mo.y);\n    //rd.xz *= mm2(mo.x + sin(time*0.05)*0.2);\n    \n    vec3 col = vec3(0.);\n    vec3 brd = rd;\n    float fade = smoothstep(0.,0.01,abs(brd.y))*0.1+0.9;\n    \n    col = bg(rd)*fade;\n    \n    if (rd.y > 0.){\n        vec4 aur = smoothstep(0.,1.5,aurora(ro,rd))*fade;\n        col += stars(rd);\n        col = col*(1.-aur.a) + aur.rgb;\n    }\n    else //Reflections\n    {\n        /*\n        rd.y = abs(rd.y);\n        col = bg(rd)*fade*0.6;\n        vec4 aur = smoothstep(0.0,2.5,aurora(ro,rd));\n        col += stars(rd)*0.1;\n        col = col*(1.-aur.a) + aur.rgb;\n        vec3 pos = ro + ((0.5-ro.y)/rd.y)*rd;\n        float nz2 = triNoise2d(pos.xz*vec2(.5,.7), 0.);\n        col += mix(vec3(0.2,0.25,0.5)*0.08,vec3(0.3,0.3,0.5)*0.7, nz2*0.4);\n\t\t*/\n    }\n    \n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtKBzy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[247, 247, 268, 268, 320], [374, 374, 396, 396, 438], [439, 439, 460, 460, 510], [512, 512, 552, 552, 960], [962, 962, 986, 986, 1051], [1052, 1052, 1083, 1083, 2020], [2086, 2086, 2110, 2110, 2301], [2303, 2303, 2326, 2326, 2748], [2750, 2750, 2771, 2771, 2944], [3009, 3009, 3066, 3066, 4161]], "test": "untested"}
{"id": "dlGBzy", "name": "Obligatory CRT", "author": "dean_the_coder", "description": "One of the first shaders I ever wrote; capturing it here for posterity. :)\n'Switches off' at 11 seconds.\n(I would Do Things Differently now.)", "tags": ["retro", "scanlines", "crt"], "likes": 10, "viewed": 259, "published": 3, "date": "1702214314", "time_retrieved": "2024-07-30T17:17:31.917893", "image_code": "// 'Obligatory CRT' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/dlGBzy\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// One of the first shaders I ever wrote; capturing it here for posterity. :)\n// 'Switches off' at 11 seconds.\n// (I would Do Things Differently now.)\n//\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Progress: 0.0 to 1.0\nfloat progress;\n\n// 0.0 (screen on) to 1.0 (screen off)\nfloat shutdown_progress;\n\n// Number of scanlines ('0' means 'off')\nfloat scanline_count;\n\n// Get the color of the target pixel, based on the scaled source.\n// Pixels outside the source area are rendered black.\nvec3 raw(vec2 p) {\n\tif (shutdown_progress == 0.0) return texture(iChannel0, p).rgb;\n\n\t// The x/y scale of the screen, calculated over time.\n\tvec2 scale = vec2(1.0) - vec2(smoothstep(0.15, 0.2, shutdown_progress), smoothstep(0.0, 0.2, shutdown_progress)) * 0.99;\n\n\t// Fade the color to white as time progresses...\n\tfloat whiteness = smoothstep(0.1, 0.3, shutdown_progress);\n\n\t// ...and fade to black as the cycle finishes.\n\tfloat bright = 1.0 - smoothstep(0.5, 1.0, shutdown_progress);\n\tvec2 srcXY = vec2(0.5 - (0.5 - p.x) / scale.x, 0.5 - (0.5 - p.y) / scale.y);\n\tif (srcXY.x < 0.0 || srcXY.x > 1.0 || srcXY.y < 0.0 || srcXY.y > 1.0) // Outside source area - Use black.\n\treturn vec3(0.0);\n\n\t// Use the source data, applying a variable amount of whiteness.\n\tvec3 sourceRGB = texture(iChannel0, srcXY).rgb;\n\treturn mix(sourceRGB, vec3(1.0), whiteness) * bright;\n}\n\n// Random number generator.\nfloat rand(vec2 co) { return fract(sin(dot(co, vec2(12.98, 78.2))) * 43758.5453); }\n\n// The equation of an ellipse.\nfloat ellipse(vec2 xy, float r1, float r2) { return pow(xy.x, 2.0) / pow(r1, 2.0) + pow(xy.y, 2.0) / pow(r2, 2.0) - 1.0; }\n\n// For a given point, how far within the screen bezel is it?\nfloat calcBezelDepth(vec2 xy, float r1, float r2) { return max(ellipse(xy, r2, r1), ellipse(xy, r1, r2)) / ellipse(vec2(0.5), r1, r2); }\n\n// Calculate the lighting effects to apply to the screen.\nvoid screenShine(vec2 xy, inout vec3 rgb) {\n\tfloat bright = smoothstep(1.0, 0.0, pow(distance(xy, vec2(0.1, 0.28)), 0.7));\n\tfloat shadow = smoothstep(0.51, 0.55, length(xy * vec2(0.5, 1.0) + vec2(0.0, 0.1)));\n\trgb += (1.0 - rgb) * mix(0.0, 0.5, max(0.0, (bright - shadow) * progress));\n}\n\n// Apply a sine wave travelling down the y axis to simulate scanlines.\nvoid scanlines(inout vec3 rgb, vec2 p) {\n\tfloat colorBoost = 0.5;\n\trgb *= 1.0 + progress * (colorBoost - abs(sin(p.y * 3.14159 * scanline_count)));\n}\n\n// Darken the corners of the screen imply roundness.\nvoid screenBulge(inout vec3 rgb, vec2 p) {\n\tfloat vignette = p.x * p.y * (1.0 - p.x) * (1.0 - p.y);\n\trgb *= mix(1.0, pow(abs(32.0 * vignette), 0.35), progress);\n}\n\n// Apply a slight mottling effect to the rgb value.\n// (Used to texture the bevel and screen 'glass'.)\nvoid addNoise(inout vec3 rgb, vec2 p) { rgb *= 1.0 - rand(p) * 0.2 * progress; }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 position = fragCoord;\n\tvec2 xy = fragCoord / iResolution.xy - 0.5;\n    float t = mod(iTime, 15.0);\n\tscanline_count = iResolution.y / 8.0;\n\tprogress = smoothstep(0.0, 4.0, t);\n\tshutdown_progress = smoothstep(11.0, 13.0, t);\n\n\t// Define the shape of the screen bevel.\n\tfloat r1 = mix(0.5, 0.47, progress);\n\tfloat r2 = mix(5.0, 1.4, progress);\n\n\t// Distort the screen pixels to give a 'bulge'.\n\tvec2 scaleXY = 0.5 * r2 / (r1 * vec2(sqrt((r2 + xy.y) * (r2 - xy.y)), sqrt((r2 + xy.x) * (r2 - xy.x))));\n\tvec2 bulgedXY = xy * scaleXY;\n\tvec3 rgb;\n\tfloat bevelDepth = calcBezelDepth(xy, r1, r2);\n\tif (bevelDepth > 0.0) {\n\t\t// Point is inside the bevel.\n\t\tvec3 bevelDark = vec3(0.1, 0.1, 0.05); // Bevel colors.\n\t\tvec3 bevelLight = vec3(0.6, 0.6, 0.54);\n\t\trgb = mix(bevelDark, bevelLight, bevelDepth);\n\t\taddNoise(rgb, fragCoord); // Add texture to the bevel.\n\t\t// Add a shadow.\n\t\tfloat shadow = smoothstep(0.55, 0.51, length(xy * vec2(0.5, 1.0) + vec2(0.0, 0.2)));\n\t\trgb *= mix(0.5, 1.0, shadow);\n\t}\n\telse {\n\t\t// 'Bulge' the screen.\n\t\tposition = bulgedXY + 0.5;\n\n\t\t// Get the source RGB pixel.\n\t\trgb = raw(position);\n\n\t\t// Scanlines?\n\t\tif (scanline_count > 0.0) scanlines(rgb, position);\n\n\t\t// Apply screen effects.\n\t\tscreenShine(xy, rgb);\n\t\tscreenBulge(rgb, position);\n\t\taddNoise(rgb, position);\n\t}\n\n\t// Output to screen\n\tfragColor = vec4(rgb * clamp(t, 0.0, 1.0), 1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlGBzy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[614, 734, 752, 752, 1595], [1597, 1625, 1646, 1646, 1708], [1710, 1741, 1785, 1785, 1863], [1865, 1926, 1977, 1977, 2062], [2064, 2122, 2165, 2165, 2409], [2411, 2482, 2522, 2522, 2631], [2633, 2686, 2728, 2728, 2848], [2850, 2953, 2992, 2992, 3033], [3035, 3035, 3090, 3090, 4460]], "test": "untested"}
{"id": "dlGBRy", "name": "random triangular grid circles-4", "author": "FabriceNeyret2", "description": "directly interpolating between random values along time  variant of  https://shadertoy.com/view/dlGfzG", "tags": ["circles", "grid", "triangle", "random", "2tweets", "triangular", "golf", "loopless"], "likes": 18, "viewed": 265, "published": 3, "date": "1702210253", "time_retrieved": "2024-07-30T17:17:32.792555", "image_code": "// variant of https://shadertoy.com/view/dlGfzG\n// golfing and messing with \"random triangular grid circles\" by jt. https://shadertoy.com/view/DtVBDm\n\n#define T(i) (2.*iTime+H(i,))\n#define H(i,o) fract(1e4*sin(dot( d+P[i] , o+R )))\n#define L(i)   1.73 * length( p-d - P[i] )                      \\\n             -   mix( H(i,floor(T(i))), H(i,ceil(T(i))) ,fract(T(i)))\n\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    vec3  R = iResolution,\n          p =    mat2x3( 7,-7, 0, 4,4,-8 )\n               * 4.*I / R.y + .33,               \n          d = floor(p); \n    mat3  P = mat3(1);\n    d.x+d.y+d.z < 0. ? P = 1.-P : P;\n    //  insert abs here  v  for bubbles\n    O = sqrt( R.yyyy/1e2* ( min(min(L(0),L(1)),L(2)) - .25 ));\n // O.r = -(d.x+d.y+d.z); // show tiling\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlGBRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[370, 370, 406, 406, 757]], "test": "untested"}
{"id": "dlGfzG", "name": "random triangular grid circles-2", "author": "FabriceNeyret2", "description": "golfing and messing with \"random triangular grid circles\" by jt. https://shadertoy.com/view/DtVBDm\n", "tags": ["circles", "grid", "triangle", "random", "2tweets", "triangular", "golf", "loopless"], "likes": 23, "viewed": 293, "published": 3, "date": "1702205379", "time_retrieved": "2024-07-30T17:17:33.659237", "image_code": "// golfing and messing with \"random triangular grid circles\" by jt. https://shadertoy.com/view/DtVBDm\n\n/**/\n#define T(i) (iTime+H(i,))\n#define H(i,o) fract(1e4*sin(dot( d+P[i] , o+R )))\n#define L(i)   1.73 * length( p-d - P[i] )                      \\\n             -    H(i,ceil(T(i))) * (.5-.5*cos(6.28*T(i)))\n\n/** // 258 chars golfing of jt's https://shadertoy.com/view/DtVBDm\n#define L(i)   1.73 * length( p-d - P[i] )          \\\n             - fract(1e4*sin(dot( d+P[i] , R )))\n/**/\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    vec3  R = iResolution,\n          p =    mat2x3( 7,-7, 0, 4,4,-8 )\n               * 2.*I / R.y + .33,               \n          d = floor(p); \n    mat3  P = mat3(1);\n    d.x+d.y+d.z < 0. ? P = 1.-P : P;\n    O = sqrt( R.yyyy/50.* abs( min(min(L(0),L(1)),L(2)) - .25 ));\n // O.r = -(d.x+d.y+d.z); // show tiling\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlGfzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[488, 488, 524, 524, 838]], "test": "untested"}
{"id": "dlccDl", "name": "Stylized Ray Marching", "author": "INCHMAN1900", "description": "Shadow? No!", "tags": ["raymarching", "sdf"], "likes": 1, "viewed": 135, "published": 3, "date": "1702185712", "time_retrieved": "2024-07-30T17:17:34.742341", "image_code": "#define PI 3.1415926\n#define STEPS 100\n#define R iResolution.xy\n\n//float cubeSDF(vec3 pos, vec3 center, float size) {\n//    vec3 q = abs(pos - round(pos)) - size;\n//    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.0);\n//}\n\n//float sdCone(vec3 p, vec2 c, float h) {\n//    float q = length(p.xz);\n//    return max(dot(c.yx, vec2(q, p.y)), -h - p.y);\n//}\n\nfloat coneSDF(vec3 p, vec2 c, float h) {\n    p-=round(p);\n    float q = length(p.xz);\n    return max(dot(c.yx, vec2(q, p.y)), -h - p.y);\n}\n\nfloat sphereSDF(vec3 pos, float size) {\n    return distance(pos,round(pos))-size;\n}\n\nfloat boxSDF(vec3 pos, float size) {\n    vec3 q = abs(pos - round(pos)) - size;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nvec3 rayMarching(vec2 uv) {\n    vec3 cameraPos = vec3(0.,0., -10000.+iTime*.5);\n    vec3 f = normalize(-cameraPos);\n    vec3 r = normalize(cross(vec3(0.0, 1.0, 0.0), f));\n    vec3 u = normalize(cross(f, r));\n    vec3 rayDir = normalize(r * uv.x + u * uv.y + f);\n    vec3 cubePos = vec3(0., 1.5, 0.);\n    float traveled = 0.;\n    for(int i = 0; i < STEPS; i++) {\n        float dist = coneSDF(cameraPos + traveled * rayDir-cubePos, vec2(sin(PI*.25), cos(PI*.25)), .2);\n        //dist = sphereSDF(cameraPos + traveled * rayDir - cubePos, .2);\n        dist = boxSDF(cameraPos + traveled * rayDir - cubePos, .2);\n        if(dist < 0.0001) {\n            return vec3(fract(dot(dist,124.5192)), fract(dot(dist,1852.145)), fract(dot(dist,935.17)));\n        }\n        traveled += dist;\n        if (traveled > 1000.) {\n            break;\n        }\n    }\n    return vec3(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 u) {\n    vec2 uv = (u + u - R) / R.y;\n    fragColor = vec4(rayMarching(uv), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlccDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[367, 367, 407, 407, 505], [507, 507, 546, 546, 590], [592, 592, 628, 628, 740], [742, 742, 769, 769, 1607], [1609, 1609, 1656, 1656, 1734]], "test": "untested"}
{"id": "DlyBRy", "name": "simple slider", "author": "ArmandB", "description": "a simple circular slider for your input needs\n", "tags": ["mouse", "sdf", "input"], "likes": 2, "viewed": 180, "published": 3, "date": "1702185008", "time_retrieved": "2024-07-30T17:17:35.895258", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //make sure your mouse coordinates in buffer A are in uv coords\n    vec2 uv = (fragCoord - iResolution.xy/2.0)/iResolution.y;\n    float pxunit = 1.0/iResolution.y; //the size of a pixel for blending\n\n    //position of handle\n    vec2 p = texelFetch(iChannel0, ivec2(0,0), 0).xy;\n    \n    vec3 col = mix(vec3(0.8),vec3(1),float(abs(mod(uv.x,0.1) - mod(uv.y,0.1)) > 0.05));\n    float innerdist = sliderRadius - sdLine(slider_start, slider_stop, uv);\n    float handledist = sliderRadius - distance(uv,p);\n    col = mix(col, vec3(0.8), smoothstep(0.0, pxunit, innerdist)); //slider background\n    col = mix(col, vec3(0.2), smoothstep(0.0, pxunit, 0.002-abs(innerdist))); //slider border\n    col = mix(col, vec3(1), smoothstep(0.0, pxunit, handledist)); //handle\n    col = mix(col, vec3(0.2), smoothstep(0.0, pxunit, 0.002-abs(handledist))); //handle border\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = vec4(0);\n    //xy: handle position\n    //zw: initial offset\n    if (floor(fragCoord) == vec2(0,0)){\n        vec2 handle = texelFetch(iChannel0,ivec2(0,0),0).xy;\n        vec2 offset = texelFetch(iChannel0,ivec2(0,0),0).zw;\n        vec2 m = uv_transform(iMouse.xy,iResolution.xy);\n        vec2 mc = uv_transform(abs(iMouse.zw),iResolution.xy);\n        if (distance(mc,handle) < sliderRadius){\n            if (iMouse.w >= 0.0){ //setup on click\n                offset = handle-mc;\n            }\n        }\n        if (iMouse.z >= 0.0 && offset != vec2(999.0)){\n            handle = m + offset;\n        }\n        \n        handle = pointOnLine(slider_start, slider_stop, handle);\n        \n        if (iMouse.z >= 0.0){\n            data = vec4(handle, offset);\n        } else {\n            data = vec4(handle, vec2(999.0));\n        }\n    }\n    fragColor = data;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float sliderRadius = 0.1;\nconst vec2 slider_start = vec2(-0.5,0);\nconst vec2 slider_stop = vec2(0.5,0);\n\nvec2 uv_transform(vec2 uv, vec2 res){\n    return (uv - res/2.0)/res.y;\n}\n\nvec2 pointOnLine(vec2 a, vec2 b, vec2 p){\n    vec2 ab = b - a;\n    return a + clamp(dot(p - a, ab)/dot(ab, ab),0.0,1.0)*ab;\n}\n\nfloat sdLine(vec2 a, vec2 b, vec2 p){\n    return distance(p,pointOnLine(a,b,p));\n}\n\n#define PI 3.14159", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlyBRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 124, 971]], "test": "untested"}
{"id": "mlKfWw", "name": "color wheel selector", "author": "ArmandB", "description": "a simple circular slider for your input needs\n", "tags": ["mouse", "sdf", "input"], "likes": 1, "viewed": 202, "published": 3, "date": "1702180943", "time_retrieved": "2024-07-30T17:17:36.954427", "image_code": "vec3 hsvToRgb(vec3 hsv){ //hsv.x = hue, hsv.y = saturation, hsv.z = value\n    vec3 col = vec3(hsv.x, hsv.x + 2.0/3.0, hsv.x + 4.0/3.0); //inputs for r, g, and b\n    col = clamp(abs(mod(col*2.0, 2.0)-1.0)*3.0 - 1.0, 0.0, 1.0)*hsv.z*hsv.y + hsv.z - hsv.z*hsv.y; //hue function (graph it on desmos)\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //make sure your mouse coordinates in buffer A are in uv coords\n    vec2 uv = (fragCoord - iResolution.xy/2.0)/iResolution.y;\n    float pxunit = 1.0/iResolution.y; //the size of a pixel for blending\n\n    //position of handle\n    vec2 p = texelFetch(iChannel0, ivec2(0,0), 0).xy;\n    //hue\n    float h = atan(p.y,p.x)/(2.0*PI);\n    //saturation\n    float s = length(p)/wheelRadius;\n    \n    vec3 col = mix(vec3(0.8),vec3(1),float(abs(mod(uv.x,0.1) - mod(uv.y,0.1)) > 0.05));\n    float innerdist = wheelRadius - length(uv);\n    float handledist = handleRadius - distance(uv,p);\n    col = mix(col, hsvToRgb(vec3(atan(uv.y,uv.x)/2.0/PI,length(uv)/wheelRadius,1.0)), smoothstep(0.0, pxunit, innerdist)); //slider background\n    col = mix(col, vec3(0.2), smoothstep(0.0, pxunit, 0.002-abs(innerdist))); //slider border\n    col = mix(col, hsvToRgb(vec3(h,s,1.0)), smoothstep(0.0, pxunit, handledist)); //handle\n    col = mix(col, vec3(0.2), smoothstep(0.0, pxunit, 0.002-abs(handledist))); //handle border\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = vec4(0);\n    //xy: handle position\n    //zw: initial offset\n    if (floor(fragCoord) == vec2(0,0)){\n        vec2 handle = texelFetch(iChannel0,ivec2(0,0),0).xy;\n        vec2 offset = texelFetch(iChannel0,ivec2(0,0),0).zw;\n        vec2 m = uv_transform(iMouse.xy,iResolution.xy);\n        vec2 mc = uv_transform(abs(iMouse.zw),iResolution.xy);\n        if (distance(mc,handle) < handleRadius){\n            if (iMouse.w >= 0.0){ //setup on click\n                offset = handle-mc;\n            }\n        }\n        if (iMouse.z >= 0.0 && offset != vec2(999.0)){\n            handle = m + offset;\n        }\n        \n        float l = length(handle);\n        handle = handle/l*clamp(l, 0.0, wheelRadius);\n        \n        if (iMouse.z >= 0.0){\n            data = vec4(handle, offset);\n        } else {\n            data = vec4(handle, vec2(999.0));\n        }\n    }\n    fragColor = data;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float wheelRadius = 0.35;\nconst float handleRadius = 0.05;\n\nvec2 uv_transform(vec2 uv, vec2 res){\n    return (uv - res/2.0)/res.y;\n}\n\n#define PI 3.14159", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlKfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 73, 313], [315, 315, 371, 439, 1432]], "test": "untested"}
{"id": "mlKfDw", "name": "infinite evolution", "author": "afl_ext", "description": "its pretty weird!", "tags": ["automata", "gameoflife"], "likes": 8, "viewed": 159, "published": 3, "date": "1702164618", "time_retrieved": "2024-07-30T17:17:37.977690", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv).rgba;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 position = fragCoord.xy / iResolution.xy;\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 color = vec3(0.0);\n\tcolor.r += (cos(iTime * 20.0) * 0.5 + 0.5) * (1.0 - smoothstep(0.0, 0.01, distance(position, vec2(sin(iTime * 0.1) * 0.5 + 0.5, sin(iTime * 0.13) * 0.5 + 0.5))));\n\tvec3 pixel = vec3(1.0 / iResolution.xy, 0.0);\n\tfloat a = texture(iChannel0, position + pixel.xz).r * 0.25;\n\tfloat b = texture(iChannel0, position - pixel.xz).r * 0.25;\n\tfloat c = texture(iChannel0, position + pixel.zy).r * 0.25;\n\tfloat d = texture(iChannel0, position - pixel.zy).r * 0.25;\n\tcolor -= (a+b+c+d) * 0.25 * 0.06;\n\tvec2 dfx = vec2(a-b, c-d);\n\tcolor.r += texture(iChannel0, position + pixel.xy * dfx * 7.0).r * 1.005; \n\tcolor = clamp(color.rrr, 0.0, 1.0);\n\tcolor = (ceil (color * 255.0) / 255.0 + floor (color * 255.0) / 255.0) * 0.5;\n    fragColor = color.rrrr;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlKfDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 143]], "test": "untested"}
{"id": "clKfWm", "name": "Overcast clouds", "author": "afl_ext", "description": "Some overcast clouds ", "tags": ["clouds", "overcast"], "likes": 49, "viewed": 626, "published": 3, "date": "1702158307", "time_retrieved": "2024-07-30T17:17:38.967045", "image_code": "// afl_ext 2017-2023\n// MIT License\n\n// Use your mouse to move the camera around! Press the Left Mouse Button on the image to look around!\n\n#define NormalizedMouse (iMouse.xy / iResolution.xy) // normalize mouse coords\n\n// settings for the shader\n#define STEP_SIZE_SCALE 500.0 // lower means more steps\n\n#define CloudsFloor 1000.0\n#define CloudsCeil 5000.0\n\n// decide how much clouds coverage there is, this can dramatically affect performance\n// basically this shader works better when there are more than less clouds\n#define COVERAGE_START 0.02\n#define COVERAGE_END 0.23\n\n#define CLOUDS_FBM_STEPS 5\n\n#define EXPOSURE 0.5\n\n\n// this shader supports view from inside and over the clouds too, \n// give it a try by uncommenting this line\n//#define FLYING_CAMERA\n\n#ifndef FLYING_CAMERA\n    #define CAMERA_HEIGHT (200.0)\n    #define FOG_COLOR vec3(0.04)\n#endif\n#ifdef FLYING_CAMERA\n    #define CAMERA_HEIGHT (10.0 + (0.5 + 0.5 * sin(iTime * 0.2)) * 7000.0)\n    #define FOG_COLOR vec3(0.00)\n#endif\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n  return mat3(\n    oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, \n    oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, \n    oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n  );\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord) {\n  vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n  // for fisheye, uncomment following line and comment the next one\n  //vec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);  \n  vec3 proj = normalize(vec3(uv.x, uv.y, 1.5));\n  if(iResolution.x < 600.0 || NormalizedMouse.x == 0.0) {\n    return proj * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), -0.6);\n  }\n  return createRotationMatrixAxisAngle(vec3(0.0, -1.0, 0.0), 3.0 * ((NormalizedMouse.x + 0.5) * 2.0 - 1.0)) \n    * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), 0.5 + 1.5 * ((NormalizedMouse.y * 1.5) * 2.0 - 1.0))\n    * proj;\n}\n\n// Standard 2d noise\nfloat rand2dTime(vec2 co){\n    co *= iTime;\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Hash for 3d vectors\nfloat rand3d(vec3 p){\n    return fract(4768.1232345456 * sin((p.x+p.y*43.0+p.z*137.0)));\n}\n\n// 3D value noise\nfloat noise3d(vec3 x){\n    vec3 p = floor(x);\n    vec3 fr = fract(x);\n    vec3 LBZ = p + vec3(0.0, 0.0, 0.0);\n    vec3 LTZ = p + vec3(0.0, 1.0, 0.0);\n    vec3 RBZ = p + vec3(1.0, 0.0, 0.0);\n    vec3 RTZ = p + vec3(1.0, 1.0, 0.0);\n\n    vec3 LBF = p + vec3(0.0, 0.0, 1.0);\n    vec3 LTF = p + vec3(0.0, 1.0, 1.0);\n    vec3 RBF = p + vec3(1.0, 0.0, 1.0);\n    vec3 RTF = p + vec3(1.0, 1.0, 1.0);\n\n    float l0candidate1 = rand3d(LBZ);\n    float l0candidate2 = rand3d(RBZ);\n    float l0candidate3 = rand3d(LTZ);\n    float l0candidate4 = rand3d(RTZ);\n\n    float l0candidate5 = rand3d(LBF);\n    float l0candidate6 = rand3d(RBF);\n    float l0candidate7 = rand3d(LTF);\n    float l0candidate8 = rand3d(RTF);\n\n    float l1candidate1 = mix(l0candidate1, l0candidate2, fr[0]);\n    float l1candidate2 = mix(l0candidate3, l0candidate4, fr[0]);\n    float l1candidate3 = mix(l0candidate5, l0candidate6, fr[0]);\n    float l1candidate4 = mix(l0candidate7, l0candidate8, fr[0]);\n\n\n    float l2candidate1 = mix(l1candidate1, l1candidate2, fr[1]);\n    float l2candidate2 = mix(l1candidate3, l1candidate4, fr[1]);\n\n\n    float l3candidate1 = mix(l2candidate1, l2candidate2, fr[2]);\n\n    return l3candidate1;\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p){\n\n\tfloat a =  noise3d(p);\n\tfloat b =  noise3d(p + 10.5);\n\treturn (a + b) * 0.5;\n}\n\n// Sphere raytracing\nstruct Ray { vec3 o; vec3 d; };\nstruct Sphere { vec3 pos; float rad; };\nfloat minhit = 0.0;\nfloat maxhit = 0.0;\nfloat raySphereIntersect(in Ray ray, in Sphere sphere)\n{\n    vec3 oc = ray.o - sphere.pos;\n    float b = 2.0 * dot(ray.d, oc);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float disc = b * b - 4.0 * c;\n    vec2 ex = vec2(-b - sqrt(disc), -b + sqrt(disc))/2.0;\n    minhit = min(ex.x, ex.y);\n    maxhit = max(ex.x, ex.y);\n    //return mix(ex.y, ex.x, step(0.0, ex.x));\n    //return max(ex.x, ex.y);\n    if(minhit < 0.0 && maxhit > 0.0)\n        return maxhit;\n    if(minhit < maxhit && minhit > 0.0)\n        return minhit;\n    return 0.0;    \n}\nfloat hitLimit = 678000.0;\nfloat higherHitLimit = 6780000.0;\n#define isHitBoolean(v) (v > 0.0 && v < hitLimit)\n#define isHitStep(v) step(0.0, v)\n\n// Clouds code\n\n#define VECTOR_UP vec3(0.0,1.0,0.0)\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p){\n    float a = 0.0;\n    float w = 0.5;\n    for(int i=0;i<CLOUDS_FBM_STEPS;i++){\n        float x = abs(0.5 - supernoise3d(p))*2.0;\n        a += x * w;\n        p = p * 2.9;\n        w *= 0.60;\n    }\n    return a;\n}\n\n\nfloat planetradius = 6378000.1;\n    \nfloat getHeightOverSurface(vec3 p){\n    return length(p) - planetradius;\n}\n\n// this function probes the clouds densite at a point\n// returns XY\n// X = coverage of clouds at this point, \n// Y = cloud color at this point, basically incoming radiance\nvec2 cloudsDensity3D(vec3 pos){\n    float h = getHeightOverSurface(pos);\n    pos -= vec3(0,planetradius,0);\n   \n    // make sure the clouds look like clouds by making the density\n    // scale with height between the layers, make it a height coefficent\n    // this coeff is 1.0 in between the layers, and 0.0 at the edges\n    float measurement = (CloudsCeil - CloudsFloor) * 0.5;\n    float mediana = (CloudsCeil + CloudsFloor) * 0.5;\n    float mlt = (( 1.0 - (abs( h - mediana ) / measurement )));\n    \n    // probe the fbm with moving position so the clouds move\n    float density = cloudsFBM(pos * 0.01 * 0.021 + vec3(iTime * 0.04, 0.0, 0.0));\n    \n    // calculate the radiance\n    float scattering = (h - CloudsFloor) / (CloudsCeil - CloudsFloor);\n    \n    return vec2(density * mlt, scattering);\n}\n     \nvec4 raymarchClouds(vec3 p1, vec3 p2, float randomValue){\n    // non constant step size, directly coupled to distance between points\n    // this is required to make in cloud rendering right\n    // also makes coverage calculation consistent with different distances raymarched\n    float stepsize = STEP_SIZE_SCALE / distance(p1, p2);\n    // coverage is inverted to have less calculations inside the loop\n    float coverageinv = 1.0;\n    vec3 color = vec3(0.0);\n    // start of the raymarching position is nudged by a bit with a random value to make\n    // the sampling better\n    float iter = randomValue * stepsize;\n    while(iter < 1.0 && coverageinv > 0.0){\n        vec2 density = cloudsDensity3D(mix(p1, p2, iter));\n        \n        // final coverage at point is calculated here\n        float clouds = smoothstep(COVERAGE_START, COVERAGE_END, clamp(density.x, 0.0, 1.0));\n        \n        // adjust the color taking into account the coverage left, this is basically alpha blending\n        color += clouds * max(0.0, coverageinv) * density.y;//vec3(pow(density.y * 1.0, 2.0));\n\n        // add coverage by subtracting from the inverted coverage, and subtract a bit more for fog rendering\n        coverageinv -= clouds + 0.001;\n        \n        // variable next step size\n        // if density is 0 then step should be larger to skip not interesting areas\n        // if density is higher then step lower to sample the interesting areas more\n        iter += stepsize * 0.1 + stepsize * 2.0 * max(0.0, 0.2 - density.x);\n    }\n    float coverage = 1.0 - clamp(coverageinv, 0.0, 1.0);  \n    return vec4(pow(color, vec3(2.0)) * 20.0, coverage);\n}\n\n    \n// very native rendering for the ground, shadow is basically clouds sampled directly above\n// this doesnt look that great, but at least look like something...\n// by adjusting the direction and smoothstepping the coverage, really nice sun shadows can be achieved\n// but with so high clouds coverage no light will peek through so its done like that here\nvec3 renderGround(vec3 point, float dist, float random){\n    float shadow = raymarchClouds(\n            point + vec3(0.0, CloudsFloor, 0.0), \n            point + vec3(0.0, CloudsCeil, 0.0), \n            random\n        ).x;\n\n    vec3 color = vec3(0.2, 0.2, 0.2) * vec3(0.8 + 0.2 * shadow);\n        \n    float fogIntensity = 1.0 - 1.0 / (0.001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n    \n// Straightforward, render raymarch, apply fog, alpha blend with the background, return\nvec3 renderClouds(vec3 pointStart, vec3 pointEnd, vec3 background, float dist, float random){\n    vec4 clouds = raymarchClouds(\n            pointStart,\n            pointEnd, \n            random\n        );\n    vec3 color = mix(background, clouds.xyz, clouds.a);\n    float fogIntensity = 1.0 - 1.0 / (0.0001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color) {  \n  mat3 m1 = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n  );\n  mat3 m2 = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n  );\n  vec3 v = m1 * color;  \n  vec3 a = v * (v + 0.0245786) - 0.000090537;\n  vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n  return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));  \n}\n\n// Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // get the ray direction\n    vec3 dir = getRay(fragCoord);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // sky color as the default initial color\n    vec3 C = vec3(0.5, 0.7, 0.8);\n    \n    // random for clouds raymarching\n    float random = fract(rand2dTime(uv));\n    \n    // define clouds height and planet ground\n    Sphere sphereCeilLayer = Sphere(vec3(0), planetradius + CloudsCeil);\n    Sphere sphereFloorLayer = Sphere(vec3(0), planetradius + CloudsFloor);\n    Sphere sphereGround = Sphere(vec3(0), planetradius);\n\n    // define camera origin relative to surface\n    vec3 origin = vec3(100.0, CAMERA_HEIGHT, 100.0);\n    // define camera origin relative to the planet\n    vec3 atmorg = vec3(0.0, planetradius, 0.0) + origin;\n    Ray ray = Ray(atmorg, dir);\n    \n    // adjust the ray hit detection if above the clouds, this could be done better\n    if(origin.y >= CloudsCeil){\n        hitLimit = higherHitLimit;\n    }\n    \n    // Intersections\n    float hitceil = raySphereIntersect(ray, sphereCeilLayer);\n    float hitfloor = raySphereIntersect(ray, sphereFloorLayer);\n    float hitGround = raySphereIntersect(ray, sphereGround);\n    \n    if(origin.y < CloudsFloor){\n        // below clouds\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            C = renderGround(groundHitPoint, hitGround, random);\n        } else {\n            vec3 cloudsPointStart = atmorg + (dir * min(hitfloor, hitceil));\n            vec3 cloudsPointEnd = atmorg + (dir * max(hitfloor, hitceil));\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, C, min(hitfloor, hitceil), random);\n        }\n    \n    } else if(origin.y >= CloudsFloor && origin.y < CloudsCeil){\n        // inside the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        vec3 cloudsPointStart = atmorg;\n        float targetDistance = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistance = max(hitfloor, hitceil);\n        } else if(isHitBoolean(hitfloor)){\n            targetDistance = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            targetDistance = hitceil;\n        }\n        vec3 cloudsPointEnd = atmorg + (dir * targetDistance);\n        C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        \n    } else if(origin.y >= CloudsCeil){\n        // above the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        float targetDistanceStart = 0.0;\n        float targetDistanceEnd = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistanceStart = hitceil;\n            targetDistanceEnd = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            raySphereIntersect(ray, sphereCeilLayer);\n            targetDistanceStart = minhit;\n            targetDistanceEnd = maxhit;\n        }        \n        if(isHitBoolean(targetDistanceStart) && isHitBoolean(targetDistanceEnd)){\n            vec3 cloudsPointStart = atmorg + (dir * targetDistanceStart);\n            vec3 cloudsPointEnd = atmorg + (dir * targetDistanceEnd);\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        }\n    }\n    \n    \n    // adjust exposure, tonemap and return\n    fragColor = vec4( aces_tonemap(C * EXPOSURE * vec3(1.0, 0.9, 0.8)),1.0);      \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clKfWm.jpg", "access": "api", "license": "mit", "functions": [[993, 1070, 1130, 1130, 1523], [1525, 1592, 1621, 1621, 2317], [2319, 2340, 2366, 2366, 2454], [2456, 2479, 2500, 2500, 2569], [2571, 2589, 2611, 2611, 3773], [3775, 3807, 3834, 3834, 3915], [4050, 4050, 4106, 4106, 4601], [4801, 4870, 4894, 4894, 5105], [5145, 5145, 5180, 5180, 5219], [5221, 5393, 5424, 5424, 6194], [6201, 6201, 6258, 6476, 7842], [7849, 8201, 8257, 8257, 8618], [8625, 8713, 8806, 8806, 9094], [9097, 9187, 9218, 9218, 9649], [9651, 9659, 9714, 9743, 13366]], "test": "untested"}
{"id": "ctVBDw", "name": "Cubic Bezier Self Intersection", "author": "oneshade", "description": "Finding the self-intersection point of a cubic bezier curve.", "tags": ["bezier", "intersection", "curve", "cubic", "selfintersection"], "likes": 15, "viewed": 312, "published": 3, "date": "1702152552", "time_retrieved": "2024-07-30T17:17:39.786853", "image_code": "// See https://www.desmos.com/calculator/huylfpq6ek\nbool cubicBezierSelfIntersection(in vec2 a, in vec2 b, in vec2 c, in vec2 d, out vec2 t) {\n    vec2 A = a - 3.0 * b + 3.0 * c - d;\n    vec2 B = a - 2.0 * b + c;\n    vec2 C = a - b;\n\n    float u = A.x * B.y - A.y * B.x;\n    float v = B.x * C.y - B.y * C.x;\n    float w = A.x * C.y - A.y * C.x;\n\n    float dis = 4.0 * u * v - w * w;\n    if (dis < 0.0) return false;\n    dis = sqrt(3.0 * dis);\n    t = vec2(w + dis, w - dis) / (2.0 * u);\n    return true;\n}\n\nvec2 cubicBezierPoint(in vec2 a, in vec2 b, in vec2 c, in vec2 d, in float t) {\n     return mix(mix(mix(a, b, t), mix(b, c, t), t), mix(mix(b, c, t), mix(c, d, t), t), t);\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    p -= a, b -= a;\n    return length(p - b * clamp(dot(p, b) / dot(b, b), 0.0, 1.0));\n}\n\n#define paint(sdf, color) fragColor.rgb = mix(fragColor.rgb, color, smoothstep(unit, 0.0, sdf))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 *  iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float time = iTime * 0.25;\n    float t1 = time * 0.5, t2 = time, t3 = time * 1.25;\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n    vec2 a = vec2(c2 * 2.0, s3 - 0.5);\n    vec2 b = vec2(-2.0, 1.0);\n    vec2 c = vec2(2.0, 1.0);\n    vec2 d = vec2(s2 * 2.0, c3 - 0.5);\n\n    paint(sdLine(uv, a, b), vec3(0.0, 0.0, 1.0));\n    paint(sdLine(uv, b, c), vec3(0.0, 0.0, 1.0));\n    paint(sdLine(uv, c, d), vec3(0.0, 0.0, 1.0));\n\n    vec2 p0 = a;\n    vec2 to = uv - a;\n    float sqr = dot(to, to);\n    for (float t = 0.02; t < 1.0; t += 0.02) {\n        vec2 p1 = cubicBezierPoint(a, b, c, d, t);\n        vec2 pa = uv - p0, ba = p1 - p0;\n        vec2 to = pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n        sqr = min(sqr, dot(to, to));\n        p0 = p1;\n    }\n\n    paint(sqrt(sqr), vec3(1.0, 0.8, 0.0));\n\n    paint(length(uv - a) - 0.05, vec3(1.0, 0.0, 0.0));\n    paint(length(uv - b) - 0.05, vec3(1.0, 0.0, 0.0));\n    paint(length(uv - c) - 0.05, vec3(1.0, 0.0, 0.0));\n    paint(length(uv - d) - 0.05, vec3(1.0, 0.0, 0.0));\n\n    vec2 t;\n    if (cubicBezierSelfIntersection(a, b, c, d, t)) {\n        if (t.x >= 0.0 && t.x <= 1.0 && t.y >= 0.0 && t.y <= 1.0) {\n            vec2 x = cubicBezierPoint(a, b, c, d, t.x);\n            paint(abs(length(uv - x) - 0.07), vec3(1.0));\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctVBDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 52, 142, 142, 505], [507, 507, 586, 586, 680], [682, 682, 729, 729, 818], [916, 916, 971, 971, 2486]], "test": "untested"}
{"id": "DlKBWw", "name": "More is more!!", "author": "misol101", "description": "No longer a faithful reproduction of Anarchy in the Kitchen...", "tags": ["2d", "amiga", "balls", "bounce", "font", "sinus", "scroller", "malmsteen"], "likes": 6, "viewed": 241, "published": 3, "date": "1702151268", "time_retrieved": "2024-07-30T17:17:40.538843", "image_code": "// \"Fireworks\" by Martijn Steinrucken aka BigWings - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n\n#define PI 3.141592653589793238\n#define TWOPI 6.283185307179586\n#define SS(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) SS(x-z, x+z, w)*SS(y+z, y-z, w)\n#define saturate(x) clamp(x,0.,1.)\n\n#define NUM_EXPLOSIONS 5.\n#define NUM_PARTICLES 15.\n\n\n// Noise functions by Dave Hoskins \n#define MOD3 vec3(.1031,.11369,.13787)\nvec3 hash31(float p) {\n   vec3 p3 = fract(vec3(p) * MOD3);\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat circ(vec2 uv, vec2 pos, float size) {\n\tuv -= pos;\n    \n    size *= size;\n    return SS(size*1.1, size, dot(uv, uv));\n}\n\nfloat light(vec2 uv, vec2 pos, float size) {\n\tuv -= pos;\n    \n    size *= size;\n    return size/dot(uv, uv);\n}\n\nvec3 explosion(vec2 uv, vec2 p, float seed, float t) {\n\t\n    vec3 col = vec3(0.);\n    \n    vec3 en = hash31(seed);\n    vec3 baseCol = en;\n    for(float i=0.; i<NUM_PARTICLES; i++) {\n    \tvec3 n = hash31(i)-.5;\n       \n\t\tvec2 startP = p-vec2(0., t*t*.1);        \n        vec2 endP = startP+normalize(n.xy)*n.z;\n        \n        \n        float pt = 1.-pow(t-1., 2.);\n        vec2 pos = mix(p, endP, pt);    \n        float size = mix(.01, .005, SS(0., .1, pt));\n        size *= SS(1., .1, pt);\n        \n        float sparkle = (sin((pt+n.z)*100.)*.5+.5);\n        sparkle = pow(sparkle, pow(en.x, 3.)*50.)*mix(0.01, .01, en.y*n.y);\n      \n    \tsize += sparkle*B(.6, 1., .1, t);\n        //size += sparkle*B(en.x, en.y, en.z, t);\n        \n        col += baseCol*light(uv, pos, size);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float shMv = iResolution.x * 0.0125;\n    vec4 shCol = texelFetch(iChannel0, ivec2(fragCoord.x - shMv, fragCoord.y + shMv), 0);\n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n\n    if (col.w == 0. && shCol.w != 0.) col = vec4(0.,0.,0.,1.);\n    fragColor = col;\n\n    if (col.w == 0.) {\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        uv.x -= .5;\n        uv.x *= iResolution.x/iResolution.y;\n\n        float n = hash12(uv+10.);\n        float t = iTime*.5;\n\n        vec3 c=col.xyz;\n\n        for(float i=0.; i<NUM_EXPLOSIONS; i++) {\n            float et = t+i*1234.45235;\n            float id = floor(et);\n            et -= id;\n\n            vec2 p = hash31(id).xy;\n            p.x -= .5;\n            p.x *= 1.6;\n            c += explosion(uv, p, id, et);\n        }\n        fragColor = vec4(c, 1.);\n     }\n}\n\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35478, "src": "https://soundcloud.com/yngwiemalmsteen/toccata", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// calculate positions of bouncing balls\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x > float(NOF_BALLS+1)) { return; }\n    if (int(fragCoord.x) == NOF_BALLS) { fragColor = vec4(iResolution.x); return; }\n    if (fragCoord.y >= 1.0) discard;\n    float PX = iResolution.x * 0.00125;\n    \n    vec4 ball = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float xres = texelFetch(iChannel0, ivec2(NOF_BALLS,0), 0).x;\n    \n    if (iFrame < 2 || xres != iResolution.x || SCROLL_TIME_MOD(iTime) > SCROLL_LEN - 2.) {\n        ball.x = iResolution.x + PX*1. - fragCoord.x * PX * (80./float(NOF_BALLS));\n        ball.y = iResolution.y - PX*6. - hash1(0.12*fragCoord.x) * PX*140.;\n        ball.z = ball.w = 0.;\n    }\n\n    pos = ball.xy / iResolution.xy;\n    uv = pos*2.0 - 1.0;\n    getTp(iTime);\n\n    ball.x += ball.z;\n    if (ball.x < 0.) ball.z = abs(ball.z);\n    if (ball.x > iResolution.x) ball.z = -abs(ball.z);\n\n    ball.w += -BALL_GRAVITY * PX;\n    ball.y += ball.w;\n    if (ball.y < iResolution.y-(tp.y*iResolution.y)+iResolution.y*FONT_SIZE+hash1(fragCoord.x*0.14)*PX*90. && ball.w < 0.) {\n        ball.w = -ball.w + 0.2;\n        vec2 refl = reflect(normalize(ball.zw)*1.5, normal);\n        ball.z = refl.y * PX * 2.;\n    }\n\n    fragColor = ball;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 pos = vec2(0), uv  = vec2(0), tp  = vec2(0), normal = vec2(0);\n\n#define SCROLL_LEN 33.\n#define SCROLL_SPEED 1.5\n#define SCROLL_TIME_MOD(t) mod(t*SCROLL_SPEED, SCROLL_LEN)\n\n#define FONT_SIZE 0.25\n#define FONT_SPACE 0.45\n#define SIN_FREQ 1.31\n#define SIN_SPEED 3.0\n#define SIN_AMP 0.75\n\n#define NOF_BALLS 250\n\n#define BALL_SIZE 0.008\n#define BALL_GRAVITY 0.1666\n//#define TWO_POINT_NORMAL\n\nvoid getTp(float time) {\n  tp = uv / FONT_SIZE;\n  float ty = tp.y;\n  tp.x = 2.0*(tp.x -4. + SCROLL_TIME_MOD(time));\n  tp.y = ty + 2.9 +SIN_AMP*sin(tp.x*SIN_FREQ +time*SIN_SPEED);\n\n#ifdef TWO_POINT_NORMAL\n  float x1=tp.x-0.5;\n  float x2=tp.x+0.5;\n  float y1 = ty + 2.9 +SIN_AMP*sin(x1*SIN_FREQ +time*SIN_SPEED);\n  float y2 = ty + 2.9 +SIN_AMP*sin(x2*SIN_FREQ +time*SIN_SPEED);\n  normal=vec2((x2-x1), -(y2-y1));\n#else\n  normal = vec2(-0.4, cos(tp.x*SIN_FREQ +time*SIN_SPEED));\n#endif  \n}\n\nfloat hash1(float n) {\n    return fract(sin(n)*138.5453123);\n}\n\n// Letters\n#define S(a) c+=char(float(a)); tp.x-=FONT_SPACE;\n\n#define _note  S(10);\n#define _star  S(28);\n#define _smily S(29);\n#define _    S(32);\n#define _exc S(33);\n#define _add S(43);\n#define _dot S(46);\n#define _col S(58);\n#define _que S(63);\n\n#define _A S(65);\n#define _B S(66);\n#define _C S(67);\n#define _D S(68);\n#define _E S(69);\n#define _F S(70);\n#define _G S(71);\n#define _H S(72);\n#define _I S(73);\n#define _J S(74);\n#define _K S(75);\n#define _L S(76);\n#define _M S(77);\n#define _N S(78);\n#define _O S(79);\n#define _P S(80);\n#define _Q S(81);\n#define _R S(82);\n#define _S S(83);\n#define _T S(84);\n#define _U S(85);\n#define _V S(86);\n#define _W S(87);\n#define _X S(88);\n#define _Y S(89);\n#define _Z S(90);\n\n#define _a S(97);\n#define _b S(98);\n#define _c S(99);\n#define _d S(100);\n#define _e S(101);\n#define _f S(102);\n#define _g S(103);\n#define _h S(104);\n#define _i S(105);\n#define _j S(106);\n#define _k S(107);\n#define _l S(108);\n#define _m S(109);\n#define _n S(110);\n#define _o S(111);\n#define _p S(112);\n#define _q S(113);\n#define _r S(114);\n#define _s S(115);\n#define _t S(116);\n#define _u S(117);\n#define _v S(118);\n#define _w S(119);\n#define _x S(120);\n#define _y S(121);\n#define _z S(122);\n\n#define _0 S(48);\n#define _1 S(49);\n#define _2 S(50);\n#define _3 S(51);\n#define _4 S(52);\n#define _5 S(53);\n#define _6 S(54);\n#define _7 S(55);\n#define _8 S(56);\n#define _9 S(57);\n", "buffer_b_code": "// AA Sinus Scroller, originally by gPlatl.\n\n// Boncing balls added by misol101\n\nfloat char(float ch) {\n    vec4 f = texture(iChannel0,clamp(tp,-0.05,0.96)/16.+fract(floor(vec2(ch,15.999-float(ch)/16.))/16.));\n    return f.x * (f.y+0.3)*(f.z+0.3)*2.0;   // 3d\n    //return f.x;\n}\n\nvec4 ScrollText() {\n  getTp(iTime);\n  float c = 0.0;\n    \n  _N _e _v _e _r _ _f _o _r _g _e _t _ _t _h _e _ _l _e _g _e _n _d _a _r _y _ _w _o _r _d _s _ \n  \n  _o _f _ _M _r _dot _ _Y _n _g _w _i _e _ _M _a _l _m _s _t _e _e _n   _col _ \n\n  _H _o _w _ _c _a _n _ _l _e _s _s _ _b _e _\n\n  _m _o _r _e _que _ _M _O _R _E _ _I _S _  _M _O _R _E \n      \n  _exc _exc _exc _ _smily _ _smily _ _smily \n\n  return c * vec4(pos, 0.5+0.5*sin(2.0*iTime),1.0) * 3.1;\n}\n\nvec3 ColorPalette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec4 sphere(vec2 fragCoord, vec2 ballPos, float rad, vec4 col, vec4 orgCol, float AA) {\n    float dist = distance(fragCoord, ballPos);\n    return mix(col, orgCol, smoothstep(rad-iResolution.x*AA, rad, dist));\n}\n\nvec4 drawBall(vec2 fragCoord, vec2 ballPos, vec4 col, float rad, int index) {\n//    vec4 ballCol = vec4(0.95, 0.19, 0.4, 1.);\n\tvec4 ballCol = vec4(ColorPalette(float(index)*0.13, vec3(0.5, 0.5, 0.5), \n                           vec3(0.5), \n                           vec3(0.6, 0.4, 0.3), \n                           vec3(0.6, 0.4, 0.3)) + 0.12, 1.) ;    \n    \n    col = sphere(fragCoord, ballPos, rad, ballCol * 0.55, col, 0.004);\n//    col = sphere(fragCoord, ballPos-vec2(rad*0.1,-rad*0.1), rad*0.65, ballCol * 3., col, 0.006);\n    col = sphere(fragCoord, ballPos-vec2(rad*0.1,-rad*0.1), rad*0.85, ballCol * 2., col, 0.011);\n    return sphere(fragCoord, ballPos-vec2(rad*0.2,-rad*0.2), rad*0.2, ballCol*6.5, col, 0.0015);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  pos = fragCoord.xy / iResolution.xy;\n  uv = pos*2.0 - 1.0;\n\n  vec4 col=vec4(0.06, 0.,0.22, 0.);\n  if (uv.y < -0.3 && uv.y > -0.9)\n      col  = max(ScrollText(), col);\n  vec4 oldCol = col;\n\n  // draw balls\n  for (int i=0; i < NOF_BALLS; i++) {\n      vec4 ball = texelFetch(iChannel1, ivec2(i,0), 0);\n      float ballSize = BALL_SIZE + hash1(float(i)*0.14)*0.01;\n      if (distance(fragCoord.xy, ball.xy) < iResolution.x * ballSize) {\n        col = drawBall(fragCoord,ball.xy, col, iResolution.x * ballSize, i);\n        // start/end ball fade\n        col = mix(oldCol, col, clamp(SCROLL_TIME_MOD(iTime), 0., 0.5) * 2.);\n        col = mix(oldCol, col, clamp(SCROLL_LEN-2.0-SCROLL_TIME_MOD(iTime), 0., 3.) * 0.333);\n      }\n  }\n\n  fragColor = col;\n}", "buffer_b_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlKBWw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[516, 516, 538, 538, 689], [690, 690, 711, 711, 827], [829, 829, 872, 872, 953], [955, 955, 999, 999, 1065], [1067, 1067, 1121, 1121, 1873], [1875, 1875, 1932, 1932, 2758]], "test": "untested"}
{"id": "dtKfDD", "name": "Grid Flow", "author": "harsh", "description": "Interplay of wave patterns and grid structures.", "tags": ["procedural", "waves", "grid"], "likes": 21, "viewed": 458, "published": 3, "date": "1702146897", "time_retrieved": "2024-07-30T17:17:41.575072", "image_code": "#define t iTime\n#define r iResolution.xy\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 c = vec3(0.0);\n    float l, z = t;\n    for (int i = 0; i < 3; i++) {\n        vec2 uv, p = fragCoord.xy / r;\n        uv = p;\n        p.x *= r.x / r.y;\n        p -= vec2(0.5, 1.1);\n        z += 0.05;\n        l = length(p);\n\n        float grid = 0.7 * sin(p.x * 20.0 + z) * cos(p.y * 20.0 + z + 25.);\n        \n        float wave = (sin(z) + 1.) * abs(sin(l * 7. - z * 1.));\n        \n        uv += (p / l) * wave * grid;\n        uv = mod(uv, 1.0);\n\n        float angle = atan(p.y, p.x);\n        float radius = length(p) * 2.;\n        uv += vec2(cos(angle * radius - z), sin(angle * radius - z)) * grid;\n\n        c[i] = 0.03 / length(mod(uv, 1.) - 0.5);\n    }\n\n    c = c / (l + 0.3);\n\n    fragColor = vec4(c, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtKfDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 97, 97, 818]], "test": "untested"}
{"id": "mlyfWw", "name": "columnas_2_1", "author": "jorge2017a2", "description": "columnas_2_1", "tags": ["columnas21"], "likes": 17, "viewed": 206, "published": 3, "date": "1702135103", "time_retrieved": "2024-07-30T17:17:42.620277", "image_code": "//----------image\n//por jorge2017a2-\n///---columnas_2_1-\n//--- 9-dic-2023-\n//----referencia Iq funciones\n\n#define MAX_STEPS 100\n#define MAX_DIST 255.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nvec2 columna(vec3 p, vec2 res)\n{   vec3 p0=p;\n    p.x=abs(p.x)-3.0;\n    p.z=abs(p.z)-3.0;\n    float d1= sdCylinderXZ(p,vec2(2.0,10.0) );\n    p=p0; p.y=abs(p.y)-7.0;\n    float d2=sdBox(p, vec3(6.0,0.5,6.0) );\n    p=p0; p.y=abs(p.y)-9.5;\n    float d3=sdBox(p, vec3(6.0,0.5,6.0) );\n    res =opU2(res, vec2(d1,100.0));\n    res =opU2(res, vec2(d2,100.0));\n    res =opU2(res, vec2(d3,100.0));\n    return res;    \n}\n\nvec2 puertaA(vec3 p,vec2 res)\n{\n    vec3 p0=p;\n    float d1=sdBox( p-vec3(0.0,-2.0,0.0), vec3(8.0,8.0,1.0) ); //bloque grande\n    p.y+=4.0;\n    float d2=sdBox( p, vec3(5.0,8.0,1.5) );  //puerta\n    float d2a=sdBox( p-vec3(-6.5,0.0,0.0), vec3(0.5,8.0,2.0) );  //puerta\n    float d2b=sdBox( p-vec3(6.5,0.0,0.0), vec3(0.5,8.0,2.0) );  //puerta\n    float df= Difference(d1, d2);    \n    float d3a= sdTrapezoid(p.xy-vec2(0.0,12.0), 7.0, 0.25, 3.0 );\n    float d3b1=sdBox( p-vec3(0.0,10.0,0.0), vec3(8.0,12.0,1.0) ); \n    float d3b2=sdBox( p-vec3(0.0,10.0,0.0), vec3(8.0,12.0,1.5) ); \n    float d3c= sdTrapezoid(p.xy-vec2(0.0,11.0), 6.0, 0.25, 2.5 );\n    d3a= Intersect(d3a, d3b1);\n    d3c= Intersect(d3c, d3b2);\n    res =opU2(res, vec2(df,100.0));\n    res =opU2(res, vec2(d3a,100.0));\n    res =opU2(res, vec2(d3c,100.0));\n    res =opU2(res, vec2(d2a,100.0));\n    res =opU2(res, vec2(d2b,100.0));\n    return res;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n     p.y=p.y+10.0;\n    vec3 p0=p;\n    float planeDist1 = p.y+10.0;  //piso inf\n    res =opU2(res, vec2(planeDist1,100.0));\n    vec3 pa=p;\n    vec3 pb=p;\n    pa.x=opRep1D(pa.x, 40.0 );\n    pb.x=opRep1D(pb.x+20.0, 40.0 );\n    res=columna(pa,res);\n    res=puertaA(pb,res);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 pallete(float t) {\n    vec3 a = vec3(0.2);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c*t + d));\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n     vec3 V = normalize(ro - p);\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);    \n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n    float shadow = getSoftShadow(worldPos, L);// shadows\n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.5)*specular*specular;\n    return colOut;\n}\n\n\nvec3 Getluz(vec3 ro,vec3 p, vec3 lp, vec3 lcol,vec3 n, float diffp, vec3 specp)\n{    vec3 v=normalize(ro-p);\n    vec3 h=normalize(lp+v);\n    vec3 l=normalize(lp-p);\n    float ndh=max(0.0,dot(n,h));\n    float ndl=max(0.0,dot(n,l));\n    float ndv=max(0.0,dot(n,v));   \n    float diff=ndl*diffp;\n    vec3  spec=0.8*pow(ndl,10.0)*specp;\n    vec3 col=(diff+spec*lcol);\n    return col;\n    \n}\n\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tvec3 col;\n    if (i==100 )\n    { col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n    return vec3(0.0);\n}\n\n\nfloat N21 (vec2 p){\n    return fract( sin(p.x *  100. + p.y * 6574.) * 5647.);\n}\n\nfloat SmoothNoise(vec2 uv){\n    vec2 lv = smoothstep(0., 1., fract(uv));\n    vec2 id = floor(uv);\n    float bl = N21(id);\n    float br = N21(id + vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = N21(id + vec2(0, 1));\n    float tr = N21(id + vec2(1, 1));\n    float t = mix(tl, tr, lv.x);\n    return mix(b, t, lv.y);\n}\n\nfloat smoothNoise2(vec2 uv){ \n    float c = SmoothNoise(uv*4.);\n    c += SmoothNoise(uv*8.)* 0.5;\n    c += SmoothNoise(uv*16.) * 0.25;\n    c += SmoothNoise(uv*32.) * 0.125;\n    c += SmoothNoise(uv*64.) * 0.0625;\n    return c/2.;\n}\n\n///https://www.shadertoy.com/view/dttcDN\nvec3 nubes(vec2 uv )\n{float c = smoothNoise2(uv) + 0.2 + 0.4*sin(iTime);\n    vec3 col = vec3(c/1.5, c/1.2, c);\n    return col;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col+nubes(rd.xy*3.0), vec3(.3, .6, .8), 1.0 - rd.y);\n    return sky;\n}\n\n//https://www.shadertoy.com/view/WdsGR7\nvec3 getColor(float v)\n{  float r = cos((v-0.78)*PI*1.66);\n   float g = cos((v-0.58)*PI*1.66);\n   float b = cos((v-0.28)*PI*1.66);\n   return vec3(r,g,b); \n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  vec3 colobj; \n   if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }\n   if (id_color==66) {return  .5 * texture( iChannel0, 0.6*p.xz).yyy; }\n   if (id_color>=100 ) { return  getColorTextura( p, nor,id_color); }   \n  return vec3(0.0);\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n        \n        result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        \n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n    vec2 mouseUV = iMouse.xy/iResolution.xy; // Range: <0, 1>   \n    float t0=iTime;\n    float t=mod(t0*5.0,500.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n  \n   vec3 ro=vec3(0.0,-12.0,-20.0);\n   float px=t0*5.0;\n   ro.x+=px;\n   \n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   if(3.0*sin(t0)>0.0)\n      ro=vec3(px,-12.0,-25.0);\n   else\n      rd= rotate_y(rd, radians(45.0));\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\nstruct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\nvec3 hsv(vec3 c)\n{ vec4 k=vec4(1.,2./3.,1./3.,3.);\n  vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n  return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.7333, 0.1412, 0.1412), //33\nvec3(0.1843, 0.3333, 0.1843), //34\n vec3(0.6549, 0.6549, 0.9922), //35\n vec3(0.8549, 0.8549, 0.8549)  //36\n);\n\nvec3 getColor(int i)\n{   //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 )  return Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlyfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[491, 491, 523, 523, 607], [608, 608, 647, 647, 742], [743, 743, 782, 782, 877], [878, 878, 917, 917, 1012], [1015, 1015, 1059, 1059, 1086], [1087, 1087, 1127, 1127, 1154], [1155, 1155, 1200, 1200, 1228], [1230, 1230, 1266, 1266, 1311], [1313, 1313, 1347, 1347, 1443], [1444, 1444, 1478, 1478, 1569], [1570, 1570, 1604, 1604, 1695], [1697, 1697, 1722, 1722, 1741], [1742, 1742, 1767, 1767, 1786], [1787, 1787, 1823, 1823, 1851], [1853, 1853, 1918, 1918, 2227], [2229, 2229, 2261, 2261, 2637], [2639, 2639, 2670, 2670, 3547], [3549, 3549, 3574, 3574, 3894], [3896, 3896, 3920, 3920, 4082], [4084, 4084, 4132, 4132, 4411], [4414, 4414, 4458, 4458, 4779], [4781, 4781, 4818, 4818, 5075], [5077, 5077, 5100, 5100, 5255], [5257, 5257, 5347, 5347, 6308], [6311, 6311, 6392, 6392, 6697], [6700, 6700, 6749, 6749, 7023], [7026, 7026, 7045, 7045, 7106], [7108, 7108, 7135, 7135, 7440], [7442, 7442, 7470, 7470, 7672], [7674, 7715, 7737, 7737, 7843], [7845, 7845, 7877, 7877, 8094], [8096, 8136, 8160, 8160, 8292], [8294, 8294, 8364, 8364, 8619], [8621, 8621, 8648, 8648, 8737], [8739, 8739, 8797, 8797, 8845], [8847, 8847, 8870, 8870, 8982], [8984, 8984, 9015, 9015, 9652], [9654, 9654, 9711, 9711, 10359]], "test": "untested"}
{"id": "dtGfWW", "name": "back off, normals - 3", "author": "elenzil", "description": "TL: No adjustment\nTR: Naive backoff\nBL: Frontface the Normal\nBR: Backoff to previous march step\n\nextension of [url]https://www.shadertoy.com/view/dtGfWW[/url] .", "tags": ["raymarching", "normals", "artifacts"], "likes": 10, "viewed": 169, "published": 3, "date": "1702133221", "time_retrieved": "2024-07-30T17:17:43.442080", "image_code": "// Fork of \"back off, normals.\" by elenzil. https://shadertoy.com/view/mlVcWV\n// 2023-11-28 17:12:59\n\n/*\n\n    back off, normals #3\n    --------------------\n\n    More exploration here.\n    This time the SDF is composed of just the simple Union\n    of three exact Box SDFs.  No subtractions or intersections.\n    In the entire SDF is exact.\n    \n    Top-Left:  No adjustment\n    Bot-Left:  \"Front-Face\" the normal after the fact.\n    Top-Right: Backoff along the ray by march epsilon * 4.\n    Bot-Right: Backoff along the ray to the previous sample point.\n    \n    At t = 0, with no mouse interaction yet,\n    only backing off by Epsilon * 4 is free from hot pixels.\n    \n    I don't really understand why the backoff needs to be so much (eps * 4),\n    nor why backing up to the previous sample point is not sufficient.\n    \n    I also don't understand why making the normal epsilon very tiny\n    (eg, marchEpsilon * 1e-4) doesn't fix this more.\n    \n    \n    Orion Elenzil 20231208\n*/\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\nconst float gSceneCenterY  = 3.0;\nconst float gFOVFac        = 0.3;\n\nconst uint  gMarchMaxSteps = 150u;\nconst float gMarchEps      =   0.002;\nconst float gNormEps       = gMarchEps * 1e-1;\n      float gNormBackoff   = gMarchEps * 5.0;\n      bool  gIsUpperHalf;\n      bool  gIsRightHalf;\n      vec3  gDebugRGB      = v0;\n\nconst vec3  gLightDir      = normalize(vec3(-2.2, 0.5, 4.0));\nconst vec3  gAmbient       = v1 * 0.05;\nconst float reflectAmt     = 0.05;\n      float gT;\n\nvec3 sky(in vec3 ro, in vec3 rd) {\n    vec3 c = vec3(1.0, 0.9, 0.8);\n    c = mix(c, vZ * 0.5, pow(rd.y, 0.3));\n    c = mix(c, v1, max(0.0, dot(rd, gLightDir)));\n    return c;\n}\n\nvec3 albedo(in vec3 p) {\n    if (p.y < gMarchEps) {\n        return v1;\n    }\n    if (p.x > 0.0) {\n        return vec3(1.0, 1.0, 0.0);\n    }\n    else {\n        return vec3(0.0, 1.0, 1.0);\n    }\n}\n\nfloat sdScene(in vec3 p) {\n    float d = 1e9;\n    \n    float rad = gSceneCenterY;\n    \n    vec3 q = (p - vY * rad).zyx;\n    opUnn(d, sdBox   (q                  , rad * (v1 - vX * 0.75)));\n    opUnn(d, sdBox   (q + vX * rad * 0.75, rad * (v1 - vX * 0.75)));\n    opUnn(d, sdBox   (q - vX * rad * 0.75, rad * (v1 - vX * 0.75)));\n    \n    return d;\n}\n\n// â(sdScene())\nvec3 gradScene(in vec3 p) {\n    float d = sdScene(p);\n    return vec3(\n        sdScene(p + vX * gNormEps) - d,\n        sdScene(p + vY * gNormEps) - d,\n        sdScene(p + vZ * gNormEps) - d\n    );\n}\n\nvec3 normScene(in vec3 p) {\n    return normalize(gradScene(p));\n}\n\nvec2 march(in vec3 ro, in vec3 rd) {\n    \n    float tPrev = 0.0;\n    float t = 0.0;\n    for (uint n = 0u; n < gMarchMaxSteps; ++n) {\n        vec3  p = ro + rd * t;\n        float d = sdScene(p);\n        if (d < gMarchEps) {\n            // a hit\n            return vec2(tPrev, t);\n        }\n        tPrev = t;\n        t += d;\n        if (t > 1e2) {\n            // too far away\n            return vec2(1e9, 1e9);\n        }\n    }\n    \n    return vec2(1e9, 1e9);\n}\n\nvec2 rayVsScene(in vec3 ro, in vec3 rd) {\n    vec2  tMarch = march(ro, rd);\n    float tTrace = rayVsPlane(ro, rd, vY, 0.0);\n    \n    if (tTrace < tMarch[1]) {\n        return vec2(tTrace);\n    }\n    else {\n        return tMarch;\n    }\n}\n\nvec3 runRaySegment(in vec3 ro, in vec3 rd, out vec3 p, out vec3 n) {\n\n    // returns t[1] = the final t the ray reached\n    //         t[0] = the t of the previous step\n\n    vec2 t = rayVsScene(ro, rd);\n    \n    if (t.y > 1e4) {\n        p = v1 * 1e9;\n        return sky(ro, rd);\n    }\n    \n    vec3 rgb = v0;\n    \n    p        = ro + rd * t.y;\n    // floor is not part of SDF, so we cheat\n    if (p.y < gMarchEps) {\n        n = vY;\n    }\n    else {\n    \n    \n    \n    \n    \n        ////////////////////////////////////////////////////////////////\n        // NORMAL CORRECTION HERE.\n        //\n        //\n        bool TL =  gIsUpperHalf && !gIsRightHalf;\n        bool TR =  gIsUpperHalf &&  gIsRightHalf;\n        bool BL = !gIsUpperHalf && !gIsRightHalf;\n        bool BR = !gIsUpperHalf &&  gIsRightHalf;\n        \n        vec3 normalSamplePoint;\n        \n        if (TL) {\n            // no adjustment\n            normalSamplePoint = p;\n        }\n        \n        if (TR) {\n            // naive backoff\n            normalSamplePoint = p - rd * gNormBackoff;\n        }\n        \n        if (BR) {\n            // backoff to previous raymarch step point\n            normalSamplePoint = ro + rd * t.x;\n        }\n        \n        if (BL) {\n            // no adjustment to sample point, but test after.\n            normalSamplePoint = p;\n        }\n        \n        n = normScene(normalSamplePoint);\n        \n        if (BL) {\n            // face forward\n            n *= sign(dot(n,-rd));\n\n        }\n        \n        //\n        //\n        ////////////////////////////////////////////////////////////////\n        \n        \n        \n    }\n    vec3 alb = albedo(p);\n    \n    rgb += gAmbient * alb;\n    float diffuseAmt = max(0.0, dot(n, gLightDir));\n    if (diffuseAmt > 0.0) {\n        float tShadow = rayVsScene(p + n * gMarchEps * 2.0, gLightDir).y;\n        if (tShadow > 1e4) {\n            rgb += alb * diffuseAmt;\n        }\n    }\n    \n    return rgb;\n}\n\nvec3 runRay(in vec3 ro, in vec3 rd) {\n    uint bouncesLeft = 4u;\n    \n    float rayAmt = 1.0;\n    \n    vec3 rgb = v0;\n    \n    while (bouncesLeft > 0u) {\n        vec3 p, n;\n        \n        vec3 c = runRaySegment(ro, rd, p, n);\n        \n        if (p.x < 1e8) {\n\n            rgb += c * rayAmt * (1.0 - reflectAmt);\n\n            // no fresnel\n            rayAmt *= reflectAmt;\n            ro = p + n * gMarchEps * 2.0;\n            rd = reflect(rd, n);\n\n            bouncesLeft -= 1u;\n        }\n        else {\n            rgb += c * rayAmt;\n            bouncesLeft = 0u;\n        }\n    }\n    \n    return rgb;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    gIsUpperHalf = XY.y * 2.0 > RES.y;\n    gIsRightHalf = XY.x * 2.0 > RES.x;\n    \n    vec2 xy = XY;\n    // split into four copies\n    vec2 halves = vec2(bvec2(gIsRightHalf, gIsUpperHalf));\n    xy = xy * 2.0 - RES * halves;\n    \n    \n    if (false) {\n        const float pixelate = 10.0;\n        xy = round(xy / pixelate) * pixelate;\n    }\n\n    gT     = iTime * pi / 30.0;\n    const float zoom = 1.0;\n    vec2 p = (xy        * 2.0 - RES) / MINRES / zoom;\n    vec2 m = (iMouse.xy * 2.0 - RES) / MINRES / zoom;\n    if (iMouse.x < 20.0) {\n        float q = smoothstep(-1.0, 1.0, sin(gT * 2.0 - 5.0)) * 2.0 - 1.0;\n        m = vec2(q * 0.03 + 0.01, 0.25);\n    }\n    \n    // compose ray\n    vec3 lf = vec3(0.0, 5.0, 20.0);\n    lf.yz  *= rot2(smoothstep(1.0, -1.0, m.y) - 0.2);\n    lf.xz  *= rot2(smoothstep(1.0, -1.0, m.x) * pi * 3.0);\n    vec3 lt = vY * gSceneCenterY;\n    vec3 fw = normalize(lt - lf);\n    vec3 rt = normalize(cross(fw, vY));\n    vec3 up = cross(rt, fw);\n    vec3 ro = lf;\n    vec3 rd = normalize(fw + (rt * p.x + up * p.y) * gFOVFac);\n    \n    vec3 rgb = runRay(ro, rd);\n    \n    float splitsD = 1e9;\n    opUnn(splitsD, abs(RES.y / 2.0 - XY.y));\n    opUnn(splitsD, abs(RES.x / 2.0 - XY.x));\n    rgb = mix(rgb, vY * 0.0, smoothstep(3.0, 2.0, splitsD));\n    \n    RGBA.rgb = pow(rgb, vec3(1.0 / 1.8));\n    RGBA.rgb += gDebugRGB;\n    RGBA.a   = 1.0;\n}", "image_inputs": [], "common_code": "const vec3  vX = vec3(1, 0 ,0);\nconst vec3  vY = vX.yxy;\nconst vec3  vZ = vX.yyx;\nconst vec3  v0 = vX.yyy;\nconst vec3  v1 = vX.xxx;\n\nconst float pi = 3.14159265359;\n\n//--------------------------------------------------------------------------------\n\n// A = âª(A, B)\nvoid opUnn(inout float A, in float B) {\n    A = min(A, B);\n}\n\n// A = A - B\nvoid opSub(inout float A, in float B) {\n    A = max(A, -B);\n}\n\n// A = â©(A, B)\nvoid opInt(inout float A, in float B) {\n    A = max(A, B);\n}\n\n//--------------------------------------------------------------------------------\n\nmat2  rot2    (float theta) { float c = cos(theta); float s = sin(theta); return mat2(c, s, -s, c); }\n\n//--------------------------------------------------------------------------------\n\nfloat sdSphere(in vec3 p, in float r) { return length(p) - r; }\nfloat sdCyl   (in vec2 p, in float r) { return length(p) - r; }\nfloat sdShell (in vec3 p, in float r, in float t) {\n    float d  = length(p);\n    float d1 = d - (r + t / 2.0);\n    float d2 = d - (r - t / 2.0);\n    opSub(d1, d2);\n    return d1;\n}\n\n// Inigo Quilez, https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b ){  vec3 q = abs(p) - b;  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0); }\n\n\n\n//--------------------------------------------------------------------------------\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nfloat rayVsPlane(in vec3 ro, in vec3 rd, in vec3 n, in float d) { float t = -(dot(ro, n) + d) / (dot(rd, n)); if (t < 0.0) { t = 1e9; } return t; }\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtGfWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1528, 1528, 1562, 1562, 1704], [1706, 1706, 1730, 1730, 1900], [1902, 1902, 1928, 1928, 2249], [2251, 2269, 2296, 2296, 2467], [2469, 2469, 2496, 2496, 2534], [2536, 2536, 2572, 2572, 2995], [2997, 2997, 3038, 3038, 3232], [3234, 3234, 3302, 3402, 5179], [5181, 5181, 5218, 5218, 5788], [5790, 5790, 5833, 5833, 7194]], "test": "untested"}
{"id": "DlGBDm", "name": "rotating_squares", "author": "anmol", "description": "rotating squares", "tags": ["sdboxrotation"], "likes": 4, "viewed": 131, "published": 3, "date": "1702127558", "time_retrieved": "2024-07-30T17:17:44.226981", "image_code": "// Ref - https://www.shadertoy.com/view/3lVGWt\nconst float PI = 3.14;\nmat2 rotationMatrix(float angle)\n{\n\tangle *= PI / 180.0;\n    float s=sin(angle), c=cos(angle);\n    return mat2( c, -s, \n                 s,  c );\n}\n\n// Red - https://www.shadertoy.com/view/4llXD7\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Using improvements suggested by - https://www.shadertoy.com/user/FabriceNeyret2\n    \n    vec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n    uv *= rotationMatrix(iTime*20.0);\n    uv = fract(uv*3.0) - 0.5;\n    float d =  smoothstep(9./iResolution.y,0.0,sdBox(uv, vec2(abs(sin(iTime))* 0.4)));\n    fragColor = vec4(d);\n    \n\n    /*\n    vec2 uv = (fragCoord/iResolution.xy * 2.0) - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n     \n    uv *= rotationMatrix(iTime*20.0);\n    uv = fract(uv*3.0) - 0.5;\n\n    //float d = smoothstep(0.0,0.01,sdBox(uv, vec2(0.5,0.5)));\n    float d =  smoothstep(-0.1,0.0,sdBox(uv, vec2(abs(sin(iTime))* 0.4, abs(sin(iTime)) * 0.4)));\n    vec3 col = (d <= 0.5 ? vec3(1.0,1.0,1.0) :vec3(0.0,0.0,0.0)) ;\n\n    fragColor = vec4(col,1.0);\n   \n    */\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlGBDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 104, 104, 217], [219, 266, 303, 303, 383], [385, 385, 442, 529, 1242]], "test": "untested"}
{"id": "mlKBDW", "name": "Code Vortex", "author": "harsh", "description": "This shader creates three rotating vortexes, each with its own unique rotation speed and scale.", "tags": ["grid", "glow", "vortex"], "likes": 7, "viewed": 227, "published": 3, "date": "1702100772", "time_retrieved": "2024-07-30T17:17:45.090672", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 a = (uv - 0.5) * 5.0;\n    float f = iTime * 1.3;\n\n    float angle1 = f * 0.35;\n    float angle2 = -f * 0.8;\n    float angle3 = f * 0.25;\n    float scale1 = 3.0;\n    float scale2 = 1.1;\n    float scale3 = 0.7;\n\n    vec2 a1 = vec2(\n        a.x * cos(angle1) - a.y * sin(angle1),\n        a.x * sin(angle1) + a.y * cos(angle1)\n    ) * scale1;\n\n    vec2 a2 = vec2(\n        a.x * cos(angle2) - a.y * sin(angle2),\n        a.x * sin(angle2) + a.y * cos(angle2)\n    ) * scale2;\n\n    vec2 a3 = vec2(\n        a.x * cos(angle3) - a.y * sin(angle3),\n        a.x * sin(angle3) + a.y * cos(angle3)\n    ) * scale3;\n\n    vec4 O = vec4(0.0);\n    float x;\n\n    for (float m = 0.0; m < 250.0; m += 0.55) {\n        vec2 p = vec2(cos(x = m * 0.05 - f), sin(x));\n        float wave = sin(m * mix(0.07, 0.07, sin(f) * 0.9 + 0.9) - f);\n\n        float d1 = length(a1 + abs(wave) * p * 0.5) - 2.0;\n        float d2 = length(a2 + abs(wave) * p * 0.5) - 2.0;\n        float d3 = length(a3 + abs(wave) * p * 0.5) - 2.0;\n\n        float dynamic = 1.35 + cos(m * 0.1 + length(a) * 0.5 - f);\n\n        vec3 color1 = 0.5 + 0.3 * cos(f + vec3(1.0, 2.0, 3.0) + a1.xyx * 0.25);\n        vec3 color2 = 0.5 + 0.3 * cos(f + vec3(4.0, 5.0, 6.0) + a2.xyx * 0.25);\n        vec3 color3 = 0.5 + 0.3 * cos(f + vec3(7.0, 8.0, 9.0) + a3.xyx * 0.25);\n\n        float glowStrength = 0.0004;\n        float glowRadius = 50.0;\n\n        float glowFactor1 = smoothstep(glowRadius, 0.1, abs(d1));\n        float glowFactor2 = smoothstep(glowRadius, 0.1, abs(d2));\n        float glowFactor3 = smoothstep(glowRadius, 0.1, abs(d3));\n\n        vec3 glowColor1 = color1 * glowFactor1;\n        vec3 glowColor2 = color2 * glowFactor2;\n        vec3 glowColor3 = color3 * glowFactor3;\n\n        vec3 color = mix(mix(glowColor1, glowColor2, step(d1, d2)), glowColor3, step(min(d1, d2), d3));\n\n        O += (glowStrength / (min(min(abs(d1), abs(d2)), abs(d3)) + 0.05)) * dynamic * vec4(color, 1.0);\n    }\n\n    fragColor = O;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlKBDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 2058]], "test": "untested"}
{"id": "dlKfWD", "name": "Fork Simple Motion Extraction", "author": "Cast_E", "description": "Based on Posy's Video\nhttps://www.youtube.com/watch?v=NSS6yAMZF78", "tags": ["backbuffer", "delay"], "likes": 1, "viewed": 200, "published": 3, "date": "1702098653", "time_retrieved": "2024-07-30T17:17:45.866598", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = mix(texture(iChannel0,uv), texture(iChannel1,uv), 0.5);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = mix(texture(iChannel0,uv), 1. - texture(iChannel1,uv), 0.5);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlKfWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 168]], "test": "untested"}
{"id": "mtKBWD", "name": "Portal to Another Dimension", "author": "HoosierTransfer", "description": ":D", "tags": ["fractal", "space", "portal"], "likes": 5, "viewed": 164, "published": 3, "date": "1702098074", "time_retrieved": "2024-07-30T17:17:46.731286", "image_code": "void mainImage(out vec4 f, in vec2 c){\n    vec2 u=(2.*c-iResolution.xy)/min(iResolution.y,iResolution.x);\n    vec2 v=u,z=vec2(.6),x=vec2(2e3,1.),g;\n    float i=0.;\n    for(float j=0.;j<x.x;j++){\n        z+=vec2(sin(z.y),cos(z.x))+v;\n        z+=vec2(cos(z.y),sin(z.x))+v;\n        if(length(z)>500.){i=j;break;}\n    }\n    g=vec2(i/10./length(z)*10.,0.);\n    vec3 b=vec3(.5+.5*cos(g.x*6.2),.5+.5*sin(g.x*6.2),.5-.5*cos(g.x*6.2));\n    i<300.?(b*=vec3(.1*sin(g.x*6.2)),b+=mix(vec3(.6,.2,.6)*.1,b,.1)):(b+=vec3(.2,.2,.6));\n    i<1.?(g.x=length(z),b=vec3(.1*sin(g.x*6.2))):b;\n    f=vec4(b,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtKBWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 588]], "test": "untested"}
{"id": "mtKfWD", "name": "Infinite roguelike dungeon 6", "author": "jarble", "description": "Another infinite roguelike dungeon map.", "tags": ["maze", "dungeon", "labyrinth", "roguelike"], "likes": 14, "viewed": 899, "published": 3, "date": "1702097751", "time_retrieved": "2024-07-30T17:17:47.519179", "image_code": "float threshold = .9;\nint iters = 8;\n\n#define noise2D(p) float((p.x * 68657387u ^ p.y * 361524851u + p.x) % 890129u) / 890128.\n\nbool labyrinth(uvec2 U,float n2,bool b1){\n    bvec2 b = bvec2(U & 1u);\n    return (b.x && b.y || b.x != b.y  && n2 < abs(float(b1)-threshold));\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    uvec2 I = uvec2( U/8.+ iTime*8.);\n    O = vec4(1);\n    bool b = false,l=false;\n    float n = 0.;\n    for(int i = 0; i++ < iters;\n    //Multiply and divide by prime numbers to get interesting patterns\n    I = (I)*2u/3u+uvec2(i)*2u\n    //I = (I)*7u/11u+uvec2(i)*2u\n    ){\n        //I.x += uint(!b);\n        //I += uint(i/2+1);\n        n =\n            //noise2D(I)\n            (noise2D(I)-n)/2.\n        ;\n        //I += uvec2(i); //another interesting pattern\n        l=labyrinth(I,n,b),\n        b =\n            !b || l\n            //!b||labyrinth(I,n,b)&&labyrinth(I/2u,n,b)\n            //!b || l && n < .5+sin(iTime)/2.\n            //!b && l\n        ;\n        O -= float(n > .125)/float(iters)/4.;\n        \n        //some random-looking distortion (using prime numbers)\n        //I += I.yx/(31u)-I.yx/(29u)+I.yx/(23u);\n    }\n    if (!b) O = 1.-O;\n}", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    return mod(floor(a),b);\n}\n\nvec2 mainSound1(int samp, float time){\n\n float t0=time, s1 =\n      8.\n ;\n  float f1 = floor(time*s1);\n  time *= 2.;\n  \n  float\n  t=\n      time\n  ,\n  m1 =\n      fmod(t,s1)\n  ,\n  m3 =\n      fmod(floor(t*m1/s1),s1)\n  ;\n\n  float m2 =\n      1. + fmod(t/s1,s1)\n  ;\n    \n  float a=sqrt((1.-sqrt(max(fract(t/s1/s1),fract(t/s1)))))*.2,\n\n  nb = 32.*pow(2.,(m3+m2)/5.+2.)/2.;\n\n  return abs(.5-vec2(fract(time*nb*.998)\n   ,fract(time*nb)))*a;\n\n}\n\nvec2 mainSound(int a,float b){\n    //b *= 4.;\n    return mainSound1(a,b)-mainSound1(a,b/2.)/2.-mainSound1(a,b/4.)/4.-mainSound1(a,b/8.)/8.;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtKfWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 169, 169, 273], [275, 275, 311, 311, 1163]], "test": "untested"}
{"id": "dtKBWD", "name": "Sky Projector", "author": "oneshade", "description": ".", "tags": ["sky", "projection", "stars"], "likes": 8, "viewed": 164, "published": 3, "date": "1702094318", "time_retrieved": "2024-07-30T17:17:48.364918", "image_code": "float iSphere(in vec3 ro, in vec3 rd, in float r) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - r * r;\n    float dis = b * b - c;\n    if (dis < 0.0) return -1.0;\n    return -b - sign(c) * sqrt(dis);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdStar(in vec2 p, in float r, in int n, in float m) {\n    float an = 3.141593 / float(n);\n    float en = 3.141593 / m; // m is between 2 and n\n    vec2 acs = vec2(cos(an), sin(an));\n    vec2 ecs = vec2(cos(en), sin(en)); // ecs = vec2(0, 1) for regular polygon\n    float bn = mod(atan(p.x, p.y), 2.0 * an) - an;\n    p = length(p) * vec2(cos(bn), abs(sin(bn)));\n    p -= r * acs;\n    p += ecs * clamp(-dot(p, ecs), 0.0, r * acs.y / ecs.y);\n    return length(p) * sign(p.x);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 Hash22(in vec2 p) {\n    vec3 p3 = fract(p.xyx * vec3(0.1031, 0.103, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat skyMap(in vec2 p) {\n    vec2 cell = floor(p / 0.2) * 0.2;\n    p -= cell + Hash22(cell) * 0.1 + 0.05;\n    return step(sdStar(p, 0.01, 5, 3.0), 0.0);\n}\n\nfloat projection(in vec3 d) {\n    const float PI = 3.1415926536;\n    const float R = 1.0;\n\n    float rot = 0.1 * iTime;\n    float co = cos(rot), si = sin(rot);\n    d.xy *= mat2(co, -si, si, co);\n    d.xz *= mat2(co, -si, si, co);\n\n    vec2 p = d.xz;\n    float r = length(p);\n    p *= asin(r / R) * (2.0 * R * sqrt(2.0)) / (PI * r);\n\n    float sky = skyMap(p);\n    sky += skyMap(p * 2.0) * 0.5;\n    sky += skyMap(p * 4.0) * 0.25;\n    return sky;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    if (iMouse.xy == vec2(0)) mouse = vec2(0.0);\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 projectorCenter = vec3(0.0, 1.0, 0.0);\n\n    vec3 ro = vec3(0.0, 2.0, 7.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    mouse *= 3.14;\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float t = -1.0;\n    if (abs(rd.y) > 1e-6) {\n        t = -ro.y / rd.y;\n        vec3 p = ro + rd * t;\n        float sky = projection(normalize(p - projectorCenter));\n        fragColor.rgb = mix(vec3(0.001, 0.0, 0.01), vec3(1.0), vec3(sky));\n    }\n\n    ro -= projectorCenter;\n    float projector = iSphere(ro, rd, 1.0);\n    ro += projectorCenter;\n    if (projector > 0.0 && (t < 0.0 || projector < t)) {\n        t = projector;\n        vec3 p = ro + rd * t;\n        float sky = projection(normalize(p - projectorCenter));\n        fragColor.rgb = mix(vec3(0.0, 0.1, 0.02), vec3(5.0), vec3(sky));\n    }\n\n    float dome = iSphere(ro, rd, 20.0);\n    if (dome > 0.0 && (t < 0.0 || dome < t)) {\n        t = dome;\n        vec3 p = ro + rd * t;\n        float sky = projection(normalize(p - projectorCenter));\n        fragColor.rgb = mix(vec3(0.0, 0.0, 0.004), vec3(1.0), vec3(sky));\n        if (p.y < 0.0) t = -1.0;\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.4545));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtKBWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 211], [213, 265, 324, 324, 745], [747, 788, 812, 812, 950], [952, 952, 977, 977, 1107], [1109, 1109, 1138, 1138, 1555], [1557, 1557, 1612, 1612, 3123]], "test": "untested"}
{"id": "mtKBDW", "name": "HyperSlime", "author": "tomachi", "description": "Virtual biological stuff, much slime, so wow *doge.png*", "tags": ["particles", "ca"], "likes": 3, "viewed": 152, "published": 3, "date": "1702091637", "time_retrieved": "2024-07-30T17:17:49.373223", "image_code": "// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    //border render\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n   \n    vec4 data = texel(ch0, pos);\n    particle P0 = getParticle(data, pos);\n\n    vec2 x0 = P0.X; //update position\n    //how much mass falls into this pixel\n    vec4 rho = vec4(P0.V, P0.M)*G((pos - x0)/0.75); \n    vec3 dx = vec3(-3., 0., 3.);\n \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1., 0.7, 0.7);\n    vec3 col1 = vec3(0., 0.9, 1.);\n    // Output to screen\n    col.xyz = vec3(0.2*a); \n    col.xyz += 0.5 - 0.5*cos(8.*vec3(0.2,0.8,0.6)*rho.w);\n    //col.xyz += vec3(1,1,1)*bord;\n    col.xyz = tanh(4.*pow(col.xyz,vec3(1.5)));\n    col.w=1.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//diffusion amount\n//#define dif 1.5\n#define dif 1.501\n#define h 1.00075\n#define maxspeed 17.\n#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n#define dt 0.99999\n#define border_h 10.\n#define mass 2.\n#define fluid_rho 0.2\n#define sense_ang 0.77\n#define sense_dis 0.1\n#define sense_force 0.01\n#define trailing 0.\n#define acceleration 0.009\n\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n\n\n\n\n//SPH stuff\nfloat Pf(vec2 rho)\n{\n   // return 1.*rho.x + 0.*rho.y; //gas\n    return 0.02*rho.x*(rho.x/fluid_rho - 1.); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(1.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0., 0.));\n    return max(drain,min(bound, box));\n}\n\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    P.X   *= 0.;\n    P.V   *= -0.02;\n    P.M.x *= 0.;\n    P.M.y *= 0.1;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n      \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n    }\n    //pheromone trail\n    P.M.y = P.M.x;\n}\n\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n   \t//sensors\n    float ang = atan(P.V.y, P.V.x);\n    vec4 dir = sense_dis*vec4(Dir(ang+sense_ang), Dir(ang - sense_ang));\n    vec2 sd = vec2(pixel(ch, P.X + dir.xy).w, pixel(ch, P.X + dir.zw).w);\n    F += sense_force * (Dir(ang+PI*0.5)*sd.x + Dir(ang-PI*0.5)*sd.y); \n    \n    //gravity\n    F -= 0.001*P.M.x*vec2(0,1);\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.1*dm*exp(-d*d);\n       // P.M.y += 0.9*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    P.V *= 1. + acceleration;\n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > maxspeed)?0.9*v:v;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        rand.z = distance(pos, R*0.5)/R.x;\n        if(rand.z < 0.1) \n        {\n            P.X = pos;\n            P.V = 0.5*(rand.xy-0.5) + 0.*vec2(sin(2.*pos.x/R.x), cos(2.*pos.x/R.x));\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtKBDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 197, 224, 224, 402], [404, 404, 440, 440, 490], [492, 492, 508, 508, 536], [538, 538, 583, 583, 1435]], "test": "untested"}
{"id": "mlVfWW", "name": "grid new", "author": "jakedowns", "description": "basic grid shader primitive", "tags": ["grid", "gpt"], "likes": 1, "viewed": 125, "published": 3, "date": "1702089132", "time_retrieved": "2024-07-30T17:17:50.384518", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Background color: dark purple\n    vec3 backgroundColor = vec3(0.1, 0.0, 0.2); // Dark purple\n\n    // Line color: slightly lighter purple\n    vec3 lineColor = vec3(0.2, 0.0, 0.4); // Slightly lighter purple\n\n    // Calculate grid lines\n    float lineThickness = 0.1; // Adjust line thickness here\n    float linesFrequency = 100.0; // Increase for more lines\n    float lineX = step(lineThickness, fract(uv.x * linesFrequency));\n    float lineY = step(lineThickness, fract(uv.y * linesFrequency));\n    float grid = min(lineX, lineY);\n\n    // Mix the colors based on grid value\n    vec3 col = mix(lineColor, backgroundColor, grid);\n\n    // Output to screen with half transparency\n    fragColor = vec4(col, 0.5); // Half transparent\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlVfWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 105, 885]], "test": "untested"}
{"id": "DtVfDD", "name": "Volume-etric Lines ", "author": "pxlmage", "description": "Volumetric lines", "tags": ["cineshader"], "likes": 0, "viewed": 575, "published": 3, "date": "1702080765", "time_retrieved": "2024-07-30T17:17:51.416758", "image_code": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nvec3 snoise3( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    return -1.0 + 2.0*mix( hash3(p+0.0), hash3(p+1.0), f );\n}\n\nfloat freqs[16];\n\nfloat dot2(in vec3 v ) { return dot(v,v); }\nvec2 usqdLineSegment( vec3 ro, vec3 rd, vec3 v0, vec3 v1 )\n{\n#if 1\n\tvec3 oa = ro - v0;\n    vec3 ob = ro - v1;\n\tvec3 va = rd*dot(oa,rd)-oa;\n    vec3 vb = rd*dot(ob,rd)-ob;\n    \n    vec3 w1 = va;\n    vec3 w2 = vb-w1;\n    float h = clamp( -dot(w1,w2)/dot(w2,w2), 0.0, 1.0 );\n\n    float di = dot2(w1+w2*h);\n    \n    return vec2(di,h);\n#else\n    vec3 ba = v1-v0, oa = ro-v0;\n\n    float a = dot(ba,ba);\n    float b = dot(rd,ba);\n    float c = dot(oa,ba);\n    float e = dot(oa,rd);\n\n    vec2 st = vec2( c-b*e, b*c-a*e)/(a-b*b);\n\n    st.x = min( max( st.x, 0.0), 1.0 );\n    st.y =      max( st.y, 0.0 );\n\n    return vec2( dot2( (v0+st.x*ba)-(ro+st.y*rd) ), st.x );\n#endif  \n}\n\nvec3 castRay( vec3 ro, vec3 rd, float linesSpeed )\n{\n\tvec3 col = vec3(0.0);\n\t\n\t\t\n\tfloat mindist = 10000.0;\n\tvec3 p = vec3(0.2);\n\tfloat h = 0.0;\n\tfloat rad = 0.04 + 0.15*freqs[0];\n\tfloat mint = 0.0;\n    for( int i=0; i<128; i++ )\n\t{\n\t\tvec3 op = p;\n\t\t\n\t\top = p;\n\t\tp  = 1.25*1.0*normalize(snoise3( 64.0*h + linesSpeed*0.015*iTime ));\n\t\t\n\t\tvec2 dis = usqdLineSegment( ro, rd, op, p );\n\t\t\n\t\tvec3 lcol = 0.6 + 0.4*sin( 10.0*6.2831*h + vec3(0.0,0.6,0.9) );\n\t\t\n\t\tfloat m = pow( texture( iChannel0, vec2(h*0.5,0.25) ).x, 2.0 )*(1.0+2.0*h);\n\t\t\n\t\tfloat f = 1.0 - 4.0*dis.y*(1.0-dis.y);\n\t\tfloat width = 1240.0 - 1000.0*f;\n\t\twidth *= 0.25;\n\t\tfloat ff = 1.0*exp(-0.06*dis.y*dis.y*dis.y);\n\t\tff *= m;\n\t\tcol += 0.3*lcol*exp( -0.3*width*dis.x )*ff;\n\t\tcol += 0.5*lcol*exp( -8.0*width*dis.x )*ff;\n\t\th += 1.0/128.0;\n\t}\n\n\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = iTime;\n\n\n\tfor( int i=0; i<16; i++ )\n\t    freqs[i] = clamp( 1.9*pow( texture( iChannel0, vec2( 0.05 + 0.5*float(i)/16.0, 0.25 ) ).x, 3.0 ), 0.0, 1.0 );\n\t\n\t// camera\t\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\nfloat isFast = smoothstep( 35.8, 35.81, iChannelTime[0] );\n\tisFast  -= smoothstep( 61.8, 61.81, iChannelTime[0] );\n\tisFast  += smoothstep( 78.0, 78.01, iChannelTime[0] );\n\tisFast  -= smoothstep(103.0,103.01, iChannelTime[0] );\n\tisFast  += smoothstep(140.0,140.01, iChannelTime[0] );\n\tisFast  -= smoothstep(204.0,204.01, iChannelTime[0] );\n\t\n    float camSpeed = 1.0 + 40.0*isFast;\t\n\n\n\tfloat beat = floor( max((iChannelTime[0]-35.7+0.4)/0.81,0.0) );\n\ttime += beat*10.0*isFast;\n\tcamSpeed *= mix( 1.0, sign(sin( beat*1.0 )), isFast );\n\n\t\nfloat linesSpeed =  smoothstep( 22.7, 22.71, iChannelTime[0] );\t\n\t  linesSpeed -= smoothstep( 61.8, 61.81, iChannelTime[0] );\n\t  linesSpeed += smoothstep( 78.0, 78.01, iChannelTime[0] );\n\t  linesSpeed -= smoothstep(140.0,140.01, iChannelTime[0] );\n\n\t\n\tta  = 0.2*vec3( cos(0.1*time), 0.0*sin(0.1*time), sin(0.07*time) );\n\n\tvec3 ro = vec3( 1.0*cos(camSpeed*0.05*time+6.28*mo.x), 0.0, 1.0*sin(camSpeed*0.05*time+6.2831*mo.x) );\n\tfloat roll = 0.25*sin(camSpeed*0.01*time);\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( sin(roll), cos(roll),0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 1.2*cw );\n\n\tfloat curve  = smoothstep( 61.8, 71.0, iChannelTime[0] );\n\t      curve -= smoothstep(103.0,113.0, iChannelTime[0] );\n    rd.xy += curve*0.025*vec2( sin(34.0*q.y), cos(34.0*q.x) );\n\trd = normalize(rd);\n\t\n\t\n\tro *= 1.0 - linesSpeed*0.5*freqs[1];\n    vec3 col = castRay( ro, rd, 1.0 + 20.0*linesSpeed );\n    col = col*col*2.4;\n\t\n\n\n\t// fade to black\n    col *= 1.0 - smoothstep(218.0,228.00, iChannelTime[0] );\n    col *=       smoothstep(  0.0,  4.00, iChannelTime[0] );\n\tif( iChannelTime[0]>61.8 && iChannelTime[0]<65.0 )\n\tcol *= vec3(1.0)*clamp( (iChannelTime[0]-61.8)/(65.0-61.8), 0.0, 1.0 );\n   \n\n    col *= 0.15+0.85*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtVfDD.jpg", "access": "api", "license": "proprietary-license", "functions": [[765, 765, 788, 788, 882], [884, 884, 912, 912, 1049], [1069, 1069, 1093, 1093, 1112], [1113, 1113, 1173, 1173, 1780], [1782, 1782, 1834, 1834, 2599], [2603, 2603, 2660, 2660, 4943]], "test": "untested"}
{"id": "mslyzj", "name": "Blue Lichen 4", "author": "tomachi", "description": "This has a life algorithm but is tainted by also allowing it to migrate to \"greener\" pixel pastures.", "tags": ["2d", "colors", "automata", "life", "cellular", "screensaver", "colours", "lichen", "amoeba"], "likes": 3, "viewed": 155, "published": 3, "date": "1702078431", "time_retrieved": "2024-07-30T17:17:52.714289", "image_code": "/* IMAGE */\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n#define tex3(pos) texture(iChannel3, pos).x\n\n#define amoeba(pos)  texture(iChannel0, pos)\n#define habitat(pos) texture(iChannel1, pos)\n#define bufferC(pos) texture(iChannel2, pos)\n#define therain(pos) texture(iChannel3, pos)\n/*\nchannels:\nBuffer A - Cells states\nBuffer B - background trails\nBuffer C - density mask ( used to fill blanks mid-game)\n*/\nvec4 sand(in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    vec4 part = texture(iChannel3,uv);\n\tfloat c = step(0.1,part.x);\n\tvec3 col=vec3(1.,.9,.8)*c*(1.-abs(uv.x-.5));\n    vec4 fragColor = vec4(col,1.);\n    return fragColor;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float rain = therain(uv).x*0.001575;\n    float bugpiss = amoeba(uv).y * 1.5;\n    float bug = amoeba(uv).x*1.;\n    float vege = habitat(uv).x;\n    float red =   rain + bug*1.95  + vege*0.002 + bugpiss *0.125;\n    float green = rain + vege* 0.91 + bug*0.1  + bugpiss*0.0625;\n    float blue = rain*1.3 + vege*0.13 + rain  - bugpiss  *0.0625 + bug*0.02;\n\n  \n    fragColor = vec4(red,green,blue,1.);// + therain(uv)*0.75;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* AMOEBA/LIFE */\n#define tex(pos) texture(iChannel0, pos).x\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n#define tex3(pos) texture(iChannel3, pos).z\n#define R iResolution.xy\n\n#define webcam(pos) texture(iChannel3, pos)\n\n#define amoeba(pos)  texture(iChannel0, pos)\n#define habitat(pos) texture(iChannel1, pos)\n#define bufferC(pos) texture(iChannel2, pos)\n#define therain(pos) texture(iChannel3, pos)\n/*float checkPixel(float col, float value) // mapping function\n{\n    if (value >= 0.90001) {\n        return col + value;\n    } else {\n        return 0.;\n    }\n}*/\nbool isHerbivore(vec2 uv) {\n    if (habitat(uv).x > 0.151) { return true; } else { return false; }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    vec3 p = vec3(vec2(1.)/iResolution.xy, 0.);\n    vec4 cam = webcam(uv);\n    float brightest = 0.;\n    float veges = tex1(uv);\n    float col = tex0(uv);\n    float D = tex3(uv);\n    vec4 colour = vec4(webcam(uv).r*1.1, 0.1, webcam(uv).r, 0.);\n\n    if(iFrame < 2 && length(vec2(0.5,0.5) - uv.xy) < 0.093) {\n        if (rand(uv) > 0.959) {\n            fragColor = vec4(1.0, 0.,0.,0.);\n            return;\n        } \n    } else {\n        colour = amoeba(uv);\n    }\n   // if (cam.x > 0.015) { fragColor = vec4(0.); return; }\n\n    int n = 0; // game of life logics\n    float amoeba = 0.; // amoeba logic\n    float onepix = p.x;\n    float twopix = onepix * 2.;\n\n    vec2 lup   = vec2(uv.x-p.x, uv.y-p.y);\n    vec2 ldown = vec2(uv.x-p.x, uv.y+p.y);\n    vec2 rup   = vec2(uv.x+p.x, uv.y-p.y);\n    vec2 rdown = vec2(uv.x+p.x, uv.y+p.y);\n\n    vec2 left = vec2(uv.x+p.x, uv.y);\n    vec2 right= vec2(uv.x-p.x, uv.y);\n    vec2 up   = vec2(uv.x, uv.y-p.y);\n    vec2 down = vec2(uv.x, uv.y+p.y);\n\n    // count neighbours\n    n += int(tex(lup));\n    n += int(tex(ldown));\n    n += int(tex(rup));\n    n += int(tex(rdown));\n\n    n += int(tex(left));\n    n += int(tex(right));\n    n += int(tex(up));\n    n += int(tex(down));\n    \n    if (habitat(uv).x > 0.1) colour.y -= 0.0625; // if the forest grows, it consumes the excrement\n\n    //if(col > 0.1 && colour.y == 0.){\n    if(col > 0.1 ){\n       if( n == 3) col += 1.; // rebirth\n    }\n    else if(col > .0991 && n > 5) { // death \n      // col = 0.; // overcrowd death\n       colour.y *= 1.1;// add to the cemetry\n     } \n   //  if (abs(col)>100.65)  { col = 0.; } \n       \n    // if the cell at 180 degrees around from herbi is not better move here\n    // if to the left, theh check 2 pixels to the left\n\n    if (isHerbivore(lup)) { // diagonal down\n      if(veges > tex1(vec2(uv.x - twopix, uv.y - twopix))) {\n          col -= tex1(vec2(uv.x - twopix, uv.y - twopix));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(ldown)) { // diagonal down\n      if(veges > tex1(vec2(uv.x - twopix, uv.y + twopix))) {\n          col -= tex1(vec2(uv.x - twopix, uv.y + twopix));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(rup)) { // diagonal up \n      if(veges > tex1(vec2(uv.x + twopix, uv.y - twopix))) {\n          col += tex1(vec2(uv.x + twopix, uv.y - twopix));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(rdown)) { // diagonal up \n      if(veges > tex1(vec2(uv.x + twopix, uv.y - twopix))) {\n          col += tex1(vec2(uv.x + twopix, uv.y - twopix));\n      } else { col = 0.; }\n    }\n\n    if (isHerbivore(left)) { // left\n      if(veges > tex1(vec2(uv.x - twopix, uv.y))) {\n         col += tex1(vec2(uv.x - twopix, uv.y));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(right)) { // right\n      if(veges > tex1(vec2(uv.x + twopix, uv.y))) {\n          col += tex1(vec2(uv.x + twopix, uv.y));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(up)) { // up\n      if(veges > tex1(vec2(uv.x, uv.y - twopix))) {\n          col += tex1(vec2(uv.x, uv.y - twopix));\n      } else { col = 0.; }\n    }\n    if (isHerbivore(down)) { // down\n      if(veges > tex1(vec2(uv.x, uv.y + twopix))) {\n          col += tex1(vec2(uv.x, uv.y + twopix));\n      } else { col = 0.; }\n    }\n    \n    fragColor = vec4(col, amoeba(uv).y, 0., 0.);\n  \n    if ((iMouse.z > 0. && length(iMouse.xy - fragCoord.xy) < 64.) ) {\n        float r = rand(uv);\n        if (r < 0.1) {\n         \tfragColor = vec4(rand(uv),0.,0,0.);\n        } else {\n          \tfragColor = vec4(1.,0.,0,0.);\n        }\n        fragColor.w = .1*(fragColor.x + R.x * fragColor.y + dot(iDate,vec4(1)));\n        return;\n    }\n\n    fragColor = colour;\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n/* HABITAT */\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos)\n#define tex3(pos) texture(iChannel3, pos).z\n\n#define amoeba(pos)  texture(iChannel0, pos)\n#define habitat(pos) texture(iChannel1, pos)\n#define bufferC(pos) texture(iChannel2, pos)\n#define therain(pos) texture(iChannel3, pos)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float A = tex0(uv);\n    vec4  B = tex1(uv);\n    float D = tex3(uv);\n\n    vec4 veges = vec4(0.);\n    vec4 herbivore = vec4(0.);\n    vec4 colour = habitat(uv);// + vec4(0., amoeba(uv).r*1.1, 0., 0.);\n    vec3 p = vec3(vec2(1.)/iResolution.xy, 0.);\n\n    if (A > 0.) {\n        colour = vec4(0.);\n        return;\n    }\n    if(iFrame < 2 ) {\n        if (rand(uv) + uv.y*0.5 > 0.1) {\n           // fragColor = vec4(rand(uv) * uv.y*0.79, 0.,0.,0.);\n            fragColor = vec4(uv.y*0.5, 0.,0.,0.);\n            return;\n        }\n    }\n    \n    //B-=A*1.8; // herb gets eaten by herivore\n    \n    if ((iMouse.z > 0. && length(iMouse.xy - fragCoord.xy) < 128.)) {\n        if (length(iMouse.xy - uv.xy) < 0.1) {    \n           fragColor += vec4(1., 0., 0., 0.) ; ///,0.1,uv);\n        } else {\n            fragColor += vec4(0.005,0.,0.,0.) ; \n        }\n       return;\n    }\n    \n  /*  if(iFrame < 5 && length(vec2(0.5,0.5) - uv.xy) < 0.081) // fill blank space with cells\n    {\n        if (rand(uv) > 0.9) {\n            fragColor = vec4(rand(uv)*uv.y);\n            return;\n        } \n    }*/\n\n   /* veges += amoeba(vec2(uv.x-p.x, uv.y-p.y)); // left up\n    veges += habitat(vec2(uv.x-p.x, uv.y+p.y)); // left down\n    veges += habitat(vec2(uv.x+p.x, uv.y-p.y)); // right up \n    veges += habitat(vec2(uv.x+p.x, uv.y+p.y)); // rigth down\n    veges += amoeba(vec2(uv.x+p.x, uv.y)); // right\n    veges += habitat(vec2(uv.x-p.x, uv.y)); // left \n    veges += habitat(vec2(uv.x, uv.y-p.y)); // up\n    veges += habitat(vec2(uv.x, uv.y+p.y)); // down   */\n\n    \n    // if i recall correct i was trying to make analog / floating point life\n    herbivore += amoeba(vec2(uv.x-p.x, uv.y-p.y)); // left up\n    herbivore += amoeba(vec2(uv.x-p.x, uv.y+p.y)); // left down\n    herbivore += amoeba(vec2(uv.x+p.x, uv.y-p.y)); // right up \n    herbivore += amoeba(vec2(uv.x+p.x, uv.y+p.y)); // rigth down\n    herbivore += amoeba(vec2(uv.x+p.x, uv.y)); // right\n    herbivore += amoeba(vec2(uv.x-p.x, uv.y)); // left \n    herbivore += amoeba(vec2(uv.x, uv.y-p.y)); // up\n    herbivore += amoeba(vec2(uv.x, uv.y+p.y)); // down\n   \n    veges += amoeba(vec2(uv.x-p.x, uv.y-p.y)); // left up\n    veges += habitat(vec2(uv.x-p.x, uv.y+p.y)); // left down\n    veges += habitat(vec2(uv.x+p.x, uv.y-p.y)); // right up \n    veges += habitat(vec2(uv.x+p.x, uv.y+p.y)); // rigth down\n    veges += habitat(vec2(uv.x+p.x, uv.y)); // right\n    veges += amoeba(vec2(uv.x-p.x, uv.y)); // left \n    veges += habitat(vec2(uv.x, uv.y-p.y)); // up\n    veges += habitat(vec2(uv.x, uv.y+p.y)); // down\n   \n    \n    float e = veges.x; // convenience\n    float h = herbivore.x; // convenience\n    if (h > 0.1) { fragColor = vec4(0.); return;}\n    \n    colour += abs(veges.x)*0.000951951 * D; // absorb the rain?\n    // growth function is clamped at 5\n    if (e > .999999998751001 && e < 5.) { colour += vec4(e*0.051, 0., 0., 0.); }\n    else { colour = vec4(0.); } \n    colour = abs(colour);\n  //  B = clamp(B, 0., 10.);\n    \n    if (e > 3.9905 || h > 120.91) colour = vec4(0.);\n    \n\n\n    fragColor = abs(colour);\n   // fragColor = colour;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\nfloat rand(vec2 p)\n{\n   return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat map(float v, float a1, float a2, float b1, float b2) // mapping function\n{\n    return (v-a1)/(a2-a1)*(b2-b1)+b1;\n}\nuint Hash(uint s)\n{\n    s ^= 2747636419u;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    return s;\n}\nuint seed2 = uint(0);\nfloat r(uint s)  // random float\n{\n    return float(Hash(s)) / 4294967295.0;\n}\nfloat r2(vec2 p) // random float for vec2\n{\n    if(p == vec2(0.)) return r(uint(p.x*100.));\n    else return fract(sin(dot(p, vec2(12.9898, 78.233))) * (43758.5453+float(seed2)));\n}\nfloat pixelNoise(vec2 uv) // uper left quadrant\n{\n    return r2(round(uv));\n}\n\nfloat smoothNoise(vec2 uv)\n{\n    float BL = pixelNoise(floor(uv)); // take samples of four surrounding squares\n    float TR = pixelNoise(ceil(uv));\n    float BR = pixelNoise(vec2(ceil(uv.x), floor(uv.y)));\n    float TL = pixelNoise(vec2(floor(uv.x), ceil(uv.y)));\n    \n    uv = fract(uv); // make uv fit in 0-1 to use it in interpolation\n    uv = smoothstep(0., 1., uv); // make interpolation smooth (try commenting it out, it will be uglier)\n    \n    return mix(mix(BL, BR, uv.x), mix(TL, TR, uv.x), uv.y); // interpolate between surrounding colors\n}\nfloat roughNoise1(vec2 uv, int depth, float roughness, uint s)\n{\n    float col = smoothNoise(uv);\n    float basis = 1./(roughness);\n    \n    for(int i = 1; i < depth; i++) //tweaking initial color by multiplying it by smaller scale noise\n    {\n        uv += vec2(4.3487*r(s), 5.754*r(s)); //move uv to avoid radial repetition effect\n        col *= map(smoothNoise(uv*pow(2., float(i))), 0., 1., 1.-1./pow(basis, float(i)), 1.+1./pow(basis, float(i)));\n    }\n\n    return col;\n}\n\nfloat roughNoise2(vec2 uv, int depth, float roughness, uint s)\n{\n    uv += vec2(27.238*r(s), 16.162*r(s+uint(1)));\n\n    float col = smoothNoise(uv);\n    float normalizer = 0.;\n    float basis = 1./(roughness);\n    \n    for(int i = 1; i < depth; i++) //tweaking initial color by adding it to smaller scale noise\n    {\n        uv += vec2(4.3487*r(s+uint(2)), 5.754*r(s+uint(3))); //move uv to avoid radial repetition effect\n        col += map(smoothNoise(uv*pow(2., float(i))), 0., 1., -1./pow(basis, float(i)), 1./pow(basis, float(i)));\n        normalizer += 1./pow(basis, float(i));\n    }\n\n    return smoothstep(0., 1., map(col, -normalizer, 1.+normalizer, 0., 1.)); // normalize the value\n}", "buffer_c_code": "#define tex(pos) texture(iChannel0, pos).x\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame <3 ) {\n        fragColor = vec4(0.75) -  vec4(fragCoord,fragCoord.x,fragCoord.y);\n        return;\n     }\n\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}", "buffer_c_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "/* THE RAIN */\n#define A 4\n\n#define rainSpeed 3. // float of A\n#define tex0(pos) texture(iChannel0, pos).x\n#define tex1(pos) texture(iChannel1, pos).x\n#define tex2(pos) texture(iChannel2, pos).x\n#define tex3(pos) texture(iChannel3, pos).x\n#define amoeba(pos)  texture(iChannel0, pos)\n#define habitat(pos) texture(iChannel1, pos)\n#define bufferC(pos) texture(iChannel2, pos)\n#define therain(pos) texture(iChannel3, pos)\n\nfloat hash(vec2 p)\n{\n   return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// check if there is an arriving particle at this pixel in next frame\nfloat arrivingParticle(vec2 coord, out vec4 partData) {\n\t// scan area from -D to D\n\tvec2 uv = coord / iResolution.xy;\n    vec4 veges = habitat(uv);\n    partData = veges;\n    float returnval = 0.;\n\t// scan area from -D to D\n    for (int i=-A; i<A; i++) {\n        for (int j=-A; j<A; j++) {\n            // position to check\n            vec2 arrCoord = coord + vec2(i,j);\n            vec4 data = texture(iChannel3, arrCoord/iResolution.xy);\n            vec4 amoeba = texture(iChannel0, arrCoord/iResolution.xy);\n            \n            // no particles here\n            if (dot(data,data)<1.9991 ) {\n              //  continue;\n            }\n            if (amoeba.x > 0.) {\n                partData = vec4(uv, 0., 0.);\n               // partData = 0.;\n                return 1.;\n            }\n            // get next position of particle\n            vec2 nextCoord = data.xy + data.zw;\n\n            // distance between next position and current pixel\n            vec2 offset = abs(coord - nextCoord);\n            // if the distance is within half a pixel pick this particle\n            // (other arriving particles are dismissed)\n            if (offset.x<.5 && offset.y<.5) {\n                partData += data;\n                returnval++;\n                return returnval;\n            }\n        }\n    }\n    \n    // no particles arriving here\n\treturn returnval;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    \n    if ((iMouse.z > 0. && length(iMouse.xy - fragCoord.xy) < 256.)) {\n       fragColor = vec4(0., 0., 0., 0.);\n       return;\n    }\n    \n \t// random particles at the top, xy is position, zw velocity\n    if (fragCoord.y > iResolution.y - float(A) || fragCoord.x > iResolution.x - float(A)) {\n        fragColor = vec4(fragCoord.xy, hash(vec2(uv.x , iTime)) * -rainSpeed, hash(vec2(uv.y , iTime)) * -rainSpeed); \n        return;\n    }\n   \n    // get the data of a particle arriving at this pixel \n    vec4 partData;\n    float p = arrivingParticle(fragCoord, partData);\n\n    // no particles, empty pixel\n    if (p < 1.) {\n    \tfragColor = vec4(p);\n        return;\n    }\n    \n    // update position with current velocity altered by channels r & b in the video\n    float vel = max(0.,1.-length(texture(iChannel0,fragCoord/iResolution.xy).rb));\n    partData.xy += partData.zw*vel;\n\n    //set particle data\n    fragColor = partData;\n}", "buffer_d_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mslyzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[369, 494, 525, 525, 736], [737, 737, 794, 794, 1260]], "test": "untested"}
{"id": "clKfWD", "name": "Space dust", "author": "pxlmage", "description": "synced", "tags": ["cineshader"], "likes": 6, "viewed": 788, "published": 3, "date": "1702076508", "time_retrieved": "2024-07-30T17:17:53.597926", "image_code": "/* original https://www.shadertoy.com/view/lslyRn  https://www.shadertoy.com/view/lscczl and orher*/\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000\n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n//get coords and direction\nvec3 dir=rd;\nvec3 from=ro;\n\n//volumetric rendering\nfloat s=0.1,fade=1.;\nvec3 v=vec3(0.);\nfor (int r=0; r<volsteps; r++) {\nvec3 p=from+s*dir*.5;\np = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\nfloat pa,a=pa=0.;\nfor (int i=0; i<iterations; i++) {\np=abs(p)/dot(p,p)-formuparam; // the magic formula\na+=abs(length(p)-pa); // absolute sum of average change\npa=length(p);\n}\nfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\na*=a*a; // add contrast\nif (r>6) fade*=1.1; // dark matter, don't render near\n//v+=vec3(dm,dm*.5,0.);\nv+=fade;\nv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\nfade*=distfading; // distance fading\ns+=stepsize;\n}\nv=mix(vec3(length(v)),v,saturation); //color adjust\nfragColor = vec4(v*.03,1.);\n}\nconst float pi = 3.14159265359;\nconst float triangleScale = 0.816497161855865; // ratio of edge length and height\nconst vec3 orange = vec3(0.937, 0.435, 0.0);\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec4 getTriangleCoords(vec2 uv) {\n    uv.y /= triangleScale;\n    uv.x -= uv.y / 2.0;\n    vec2 center = floor(uv);\n    vec2 local = fract(uv);\n   \n    center.x += center.y / 2.0;\n    center.y *= triangleScale;\n   \n    if (local.x + local.y > 1.0) {\n    local.x -= 1.0 - local.y;\n        local.y = 1.0 - local.y;\n        center.y += 0.586;\n        center.x += 1.0;\n    } else {\n        center.y += 0.287;\n    center.x += 0.5;\n    }\n   \n    return vec4(center, local);\n}\n\nvec4 getLoader(vec4 triangle) {\n    if (length(triangle.xy) > 1.6) {\n        return vec4(0.0);\n    }\n   \n    float angle = atan(triangle.x, triangle.y);\n    float seed = rand(triangle.xy);\n    float dst = min(triangle.z, min(triangle.w, 1.0 - triangle.z - triangle.w)) * 15.0;\n    float glow = dst < pi ? pow(sin(dst), 1.5) : 0.0;\n   \n    return vec4(mix(orange, vec3(1.0), glow * 0.07), pow(0.5 + 0.5 * sin(angle - iTime * 6.0 + seed), 2.0));\n}\n\nfloat getBackground(vec4 triangle) {\n    float dst = min(triangle.z, min(triangle.w, 1.0 - triangle.z - triangle.w)) - 0.05;\n\n    if (triangle.y > 1.9 || triangle.y < -2.4 || dst < 0.0) {\n        return 0.0;\n    }\n\n    float value = pow(0.5 + 0.5 * cos(-abs(triangle.x) * 0.4 + rand(triangle.xy) * 2.0 + iTime * 4.0), 2.0) * 0.08;    \n    return value * (dst > 0.05 ? 0.65 : 1.0);\n}\n\nvec3 getColor(vec2 uv) {\n    uv *= 2.0 / iResolution.y;\n   \n    vec3 background = vec3(getBackground(getTriangleCoords(uv * 6.0 - vec2(0.5, 0.3))));\n  vec4 loader = getLoader(getTriangleCoords(uv * 11.0));\n   \n    vec3 color = mix(background, loader.rgb, loader.a);\n    return color;\n}\n#define S(a, b, t) smoothstep(a, b, t)\n\nfloat distLine(vec2 p, vec2 a, vec2 b){\nvec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*t);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b){\nfloat d = distLine(p, a, b);\n    float m = S(0.03, 0.01, d);\n    float d2 =  length(a - b);\n    m *= S(1.2, 0.8, d2) * 0.5 + S(0.05, 0.03, abs(d2 - 0.75));\n    return m;\n}\n\nfloat distTriangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\nvec2 e0 = p1 - p0;\nvec2 e1 = p2 - p1;\nvec2 e2 = p0 - p2;\n\nvec2 v0 = p - p0;\nvec2 v1 = p - p1;\nvec2 v2 = p - p2;\n\nvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\nvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\nvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n   \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\nreturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat triangle(vec2 p, vec2 a, vec2 b, vec2 c){\nfloat d = distTriangle(p, a, b, c);\n    float m = S(0.03, 0.01, d);\n    float d2 =  length(a - b);\n    m *= S(1.2, 0.8, d2) * 0.5 + S(0.05, 0.03, abs(d2 - 0.75));\n    return m;\n}\n\nfloat N21(vec2 p){\np = fract(p * vec2(233.34, 851.73));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\nvec2 N22(vec2 p){\nfloat n = N21(p);\n    return vec2(n, N21(p + n));\n}\n\nvec2 getPos(vec2 id, vec2 offset){\n    vec2 n = N22(id + offset) * iTime;\n    return offset + sin(n) * 0.4;\n}\n\nfloat layer(vec2 uv){\nvec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n\n    vec2 p[9];\n    int i = 0;\n    for(float y = -1.0; y <= 1.0; y++){\n    for(float x = -1.0; x <= 1.0; x++){\n        p[i++] = getPos(id, vec2(x, y));\n    }    \n    }\n   \n   \n    float t = iTime * 10.0;\n    float m = 0.0;\n    for(int i = 0; i < 9; i++){\n    m += line(gv, p[4], p[i]);\n       \n        vec2 j = (p[i] - gv) * 20.0;\n        float sparkle = 1.0 / dot(j, j);\n       \n        m += sparkle * (sin(t + fract(p[i].x) * 10.0) * 0.5 + 0.5);\n       \n        for(int yi= i + 1; yi < 9; yi++){\n    for(int zi= yi + 1; zi < 9; zi++){\n               \n                float len1 = abs(length(p[i] - p[yi]));\n                float len2 = abs(length(p[yi] - p[zi]));\n                float len3 = abs(length(p[i] - p[zi]));\n               \n                if((len1 + len2 + len3) < 2.8){\n                m += triangle(gv, p[i], p[yi], p[zi]) * 0.8;\n                }\n    }\n    }\n    }\n    m += line(gv, p[1], p[3]);\n    m += line(gv, p[1], p[5]);\n    m += line(gv, p[7], p[3]);\n    m += line(gv, p[7], p[5]);\n\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//get coords and direction\nvec2 uv=fragCoord.xy/iResolution.xy-.5;\nuv.y*=iResolution.y/iResolution.x;\nvec3 dir=vec3(uv*zoom,(iTime*0.002));\nfloat time=iTime*speed+.25;\n float m = 0.0;\n    float t = iTime * 0.1;\n   \n    float gradient = uv.y;\n   \n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c);\n    uv *= rot;\n   \n    for(float i = 0.0; i < 1.0; i += 1.0 / 4.0){\n        float z = fract(i + t);\n        float size = mix(10.0, 0.5, z);\n        float fade = S(0.0, 0.5, z) * S(1.0, 0.8, z);\n       \n        m += layer(uv * size + i * 20.0) * fade;\n    }\n   \n   \n    vec3 base = sin(t * 5.0 * vec3(0.345, 0.456, 0.567)) * 0.4 + 0.6;\n    vec3 col = m * base;\n   \n    col -= gradient * base;\n   \n    //vec2 gv = fract(uv) - 0.5;\n    //if(gv.x > 0.48 || gv.y > 0.48){\n    // col = vec3(1.0, 0.0, 0.0);\n    //}\n   \n    fragColor = vec4(col,1.0);\nfragCoord = fragCoord - 0.5 * iResolution.xy;\nfragColor.rgb = 0.25 * (getColor(fragCoord)\n                            + getColor(fragCoord + vec2(0.5, 0.0))\n                            + getColor(fragCoord + vec2(0.5, 0.5))\n                            + getColor(fragCoord + vec2(0.0, 0.5)));\n\nvec3 from=vec3(1.,.5,0.5)+fragColor.rgb;\nfrom+=vec3(time*2.,time,-2.);\n\n\nmainVR(fragColor, fragCoord, from, dir);\n    fragColor*=vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clKfWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[357, 357, 435, 462, 1208], [1369, 1369, 1389, 1389, 1459], [1461, 1461, 1494, 1494, 1928], [1930, 1930, 1961, 1961, 2375], [2377, 2377, 2413, 2413, 2759], [2761, 2761, 2785, 2785, 3046], [3087, 3087, 3126, 3126, 3254], [3256, 3256, 3291, 3291, 3463], [3465, 3465, 3533, 3533, 4131], [4133, 4133, 4180, 4180, 4359], [4361, 4361, 4379, 4379, 4475], [4477, 4477, 4494, 4494, 4546], [4548, 4548, 4582, 4582, 4657], [4659, 4659, 4680, 4680, 5756], [5758, 5758, 5815, 5842, 7122]], "test": "untested"}
{"id": "DtVBDW", "name": "frosty", "author": "pxlmage", "description": "icey, soft ", "tags": ["cineshader"], "likes": 10, "viewed": 610, "published": 3, "date": "1702073030", "time_retrieved": "2024-07-30T17:17:54.358892", "image_code": "precision highp float;\n\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nconst float pi = acos(-1.0);\nconst float pi2 = pi*2.0;\n\nvec2 pmod(vec2 p, float r) {\n    float a = atan(p.x, p.y) + pi/r;\n    float n = pi2 / r;\n    a = floor(a/n)*n;\n    return p*rot(-a);\n}\n\nfloat box( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat ifsBox(vec3 p) {\n    for (int i=0; i<5; i++) {\n        p = abs(p) - 1.0;\n        p.xy *= rot(iTime*0.3);\n        p.xz *= rot(iTime*0.1);\n    }\n    p.xz *= rot(iTime);\n    return box(p, vec3(0.4,0.8,0.3));\n}\n\nfloat map(vec3 p, vec3 cPos) {\n    vec3 p1 = p;\n    p1.x = mod(p1.x-5., 10.) - 5.;\n    p1.y = mod(p1.y-5., 10.) - 5.;\n    p1.z = mod(p1.z, 16.)-8.;\n    p1.xy = pmod(p1.xy, 5.0);\n    return ifsBox(p1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 cPos = vec3(0.0,0.0, -3.0 * iTime);\n    // vec3 cPos = vec3(0.3*sin(iTime*0.8), 0.4*cos(iTime*0.3), -6.0 * iTime);\n    vec3 cDir = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 cUp  = vec3(sin(iTime), 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir);\n\n    // Phantom Mode https://www.shadertoy.com/view/MtScWW by aiekick\n    float acc = 0.0;\n    float acc2 = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < 99; i++) {\n        vec3 pos = cPos + ray * t;\n        float dist = map(pos, cPos);\n        dist = max(abs(dist), 0.02);\n        float a = exp(-dist*3.0);\n        if (mod(length(pos)+24.0*iTime, 30.0) < 3.0) {\n            a *= 2.0;\n            acc2 += a;\n        }\n        acc += a;\n        t += dist * 0.5;\n    }\n\n    vec3 col = vec3(acc * 0.01, acc * 0.011 + acc2*0.002, acc * 0.012+ acc2*0.005);\n    fragColor = vec4(col, 1.0 - t * 0.03);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtVBDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 44, 44, 107], [165, 165, 193, 193, 299], [301, 301, 330, 330, 421], [423, 423, 445, 445, 635], [637, 637, 667, 667, 839], [841, 841, 898, 898, 1897]], "test": "untested"}
{"id": "clVBDW", "name": "glittery", "author": "pxlmage", "description": "cosmic style", "tags": ["cineshader"], "likes": 26, "viewed": 1195, "published": 3, "date": "1702073007", "time_retrieved": "2024-07-30T17:17:55.137809", "image_code": "/* original https://www.shadertoy.com/view/lslyRn  https://www.shadertoy.com/view/lscczl and orher*/\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000\n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n//get coords and direction\nvec3 dir=rd;\nvec3 from=ro;\n\n//volumetric rendering\nfloat s=0.1,fade=1.;\nvec3 v=vec3(0.);\nfor (int r=0; r<volsteps; r++) {\nvec3 p=from+s*dir*.5;\np = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\nfloat pa,a=pa=0.;\nfor (int i=0; i<iterations; i++) {\np=abs(p)/dot(p,p)-formuparam; // the magic formula\na+=abs(length(p)-pa); // absolute sum of average change\npa=length(p);\n}\nfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\na*=a*a; // add contrast\nif (r>6) fade*=1.1; // dark matter, don't render near\n//v+=vec3(dm,dm*.5,0.);\nv+=fade;\nv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\nfade*=distfading; // distance fading\ns+=stepsize;\n}\nv=mix(vec3(length(v)),v,saturation); //color adjust\nfragColor = vec4(v*.03,1.);\n}\nconst float pi = 3.14159265359;\nconst float triangleScale = 0.816497161855865; // ratio of edge length and height\nconst vec3 orange = vec3(0.937, 0.435, 0.0);\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec4 getTriangleCoords(vec2 uv) {\n    uv.y /= triangleScale;\n    uv.x -= uv.y / 2.0;\n    vec2 center = floor(uv);\n    vec2 local = fract(uv);\n   \n    center.x += center.y / 2.0;\n    center.y *= triangleScale;\n   \n    if (local.x + local.y > 1.0) {\n    local.x -= 1.0 - local.y;\n        local.y = 1.0 - local.y;\n        center.y += 0.586;\n        center.x += 1.0;\n    } else {\n        center.y += 0.287;\n    center.x += 0.5;\n    }\n   \n    return vec4(center, local);\n}\n\nvec4 getLoader(vec4 triangle) {\n    if (length(triangle.xy) > 1.6) {\n        return vec4(0.0);\n    }\n   \n    float angle = atan(triangle.x, triangle.y);\n    float seed = rand(triangle.xy);\n    float dst = min(triangle.z, min(triangle.w, 1.0 - triangle.z - triangle.w)) * 15.0;\n    float glow = dst < pi ? pow(sin(dst), 1.5) : 0.0;\n   \n    return vec4(mix(orange, vec3(1.0), glow * 0.07), pow(0.5 + 0.5 * sin(angle - iTime * 6.0 + seed), 2.0));\n}\n\nfloat getBackground(vec4 triangle) {\n    float dst = min(triangle.z, min(triangle.w, 1.0 - triangle.z - triangle.w)) - 0.05;\n\n    if (triangle.y > 1.9 || triangle.y < -2.4 || dst < 0.0) {\n        return 0.0;\n    }\n\n    float value = pow(0.5 + 0.5 * cos(-abs(triangle.x) * 0.4 + rand(triangle.xy) * 2.0 + iTime * 4.0), 2.0) * 0.08;    \n    return value * (dst > 0.05 ? 0.65 : 1.0);\n}\n\nvec3 getColor(vec2 uv) {\n    uv *= 2.0 / iResolution.y;\n   \n    vec3 background = vec3(getBackground(getTriangleCoords(uv * 6.0 - vec2(0.5, 0.3))));\n  vec4 loader = getLoader(getTriangleCoords(uv * 11.0));\n   \n    vec3 color = mix(background, loader.rgb, loader.a);\n    return color;\n}\n#define S(a, b, t) smoothstep(a, b, t)\n\nfloat distLine(vec2 p, vec2 a, vec2 b){\nvec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*t);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b){\nfloat d = distLine(p, a, b);\n    float m = S(0.03, 0.01, d);\n    float d2 =  length(a - b);\n    m *= S(1.2, 0.8, d2) * 0.5 + S(0.05, 0.03, abs(d2 - 0.75));\n    return m;\n}\n\nfloat distTriangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\nvec2 e0 = p1 - p0;\nvec2 e1 = p2 - p1;\nvec2 e2 = p0 - p2;\n\nvec2 v0 = p - p0;\nvec2 v1 = p - p1;\nvec2 v2 = p - p2;\n\nvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\nvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\nvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n   \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\nreturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat triangle(vec2 p, vec2 a, vec2 b, vec2 c){\nfloat d = distTriangle(p, a, b, c);\n    float m = S(0.03, 0.01, d);\n    float d2 =  length(a - b);\n    m *= S(1.2, 0.8, d2) * 0.5 + S(0.05, 0.03, abs(d2 - 0.75));\n    return m;\n}\n\nfloat N21(vec2 p){\np = fract(p * vec2(233.34, 851.73));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\nvec2 N22(vec2 p){\nfloat n = N21(p);\n    return vec2(n, N21(p + n));\n}\n\nvec2 getPos(vec2 id, vec2 offset){\n    vec2 n = N22(id + offset) * iTime;\n    return offset + sin(n) * 0.4;\n}\n\nfloat layer(vec2 uv){\nvec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n\n    vec2 p[9];\n    int i = 0;\n    for(float y = -1.0; y <= 1.0; y++){\n    for(float x = -1.0; x <= 1.0; x++){\n        p[i++] = getPos(id, vec2(x, y));\n    }    \n    }\n   \n   \n    float t = iTime * 10.0;\n    float m = 0.0;\n    for(int i = 0; i < 9; i++){\n    m += line(gv, p[4], p[i]);\n       \n        vec2 j = (p[i] - gv) * 20.0;\n        float sparkle = 1.0 / dot(j, j);\n       \n        m += sparkle * (sin(t + fract(p[i].x) * 10.0) * 0.5 + 0.5);\n       \n        for(int yi= i + 1; yi < 9; yi++){\n    for(int zi= yi + 1; zi < 9; zi++){\n               \n                float len1 = abs(length(p[i] - p[yi]));\n                float len2 = abs(length(p[yi] - p[zi]));\n                float len3 = abs(length(p[i] - p[zi]));\n               \n                if((len1 + len2 + len3) < 2.8){\n                m += triangle(gv, p[i], p[yi], p[zi]) * 0.8;\n                }\n    }\n    }\n    }\n    m += line(gv, p[1], p[3]);\n    m += line(gv, p[1], p[5]);\n    m += line(gv, p[7], p[3]);\n    m += line(gv, p[7], p[5]);\n\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//get coords and direction\nvec2 uv=fragCoord.xy/iResolution.xy-.5;\nuv.y*=iResolution.y/iResolution.x;\nvec3 dir=vec3(uv*zoom,(iTime*0.002));\nfloat time=iTime*speed+.25;\n float m = 0.0;\n    float t = iTime * 0.1;\n   \n    float gradient = uv.y;\n   \n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c);\n    uv *= rot;\n   \n    for(float i = 0.0; i < 1.0; i += 1.0 / 4.0){\n        float z = fract(i + t);\n        float size = mix(10.0, 0.5, z);\n        float fade = S(0.0, 0.5, z) * S(1.0, 0.8, z);\n       \n        m += layer(uv * size + i * 20.0) * fade;\n    }\n   \n   \n    vec3 base = sin(t * 5.0 * vec3(0.345, 0.456, 0.567)) * 0.4 + 0.6;\n    vec3 col = m * base;\n   \n    col -= gradient * base;\n   \n    //vec2 gv = fract(uv) - 0.5;\n    //if(gv.x > 0.48 || gv.y > 0.48){\n    // col = vec3(1.0, 0.0, 0.0);\n    //}\n   \n    fragColor = vec4(col,1.0);\nfragCoord = fragCoord - 0.5 * iResolution.xy;\nfragColor.rgb = 0.25 * (getColor(fragCoord)\n                            + getColor(fragCoord + vec2(0.5, 0.0))\n                            + getColor(fragCoord + vec2(0.5, 0.5))\n                            + getColor(fragCoord + vec2(0.0, 0.5)));\n\nvec3 from=vec3(1.,.5,0.5)+fragColor.rgb;\nfrom+=vec3(time*2.,time,-2.);\n\n\nmainVR(fragColor, fragCoord, from, dir);\n    fragColor*=vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clVBDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[357, 357, 435, 462, 1208], [1369, 1369, 1389, 1389, 1459], [1461, 1461, 1494, 1494, 1928], [1930, 1930, 1961, 1961, 2375], [2377, 2377, 2413, 2413, 2759], [2761, 2761, 2785, 2785, 3046], [3087, 3087, 3126, 3126, 3254], [3256, 3256, 3291, 3291, 3463], [3465, 3465, 3533, 3533, 4131], [4133, 4133, 4180, 4180, 4359], [4361, 4361, 4379, 4379, 4475], [4477, 4477, 4494, 4494, 4546], [4548, 4548, 4582, 4582, 4657], [4659, 4659, 4680, 4680, 5756], [5758, 5758, 5815, 5842, 7122]], "test": "untested"}
{"id": "ctKBDW", "name": "Chase the light", "author": "workingclasshacker", "description": "Part of shadecember project, this time featuring fbm and Perlin noise.", "tags": ["noiseeffectsmoke"], "likes": 3, "viewed": 189, "published": 3, "date": "1702070918", "time_retrieved": "2024-07-30T17:17:55.994519", "image_code": "#define PI 3.1415926535897932384626433832795\nmat2 rotate2d(float _angle) {\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\nfloat noise(vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898f, 78.233f))) * 43758.5453123f);\n}\n\nfloat perlinNoise(vec2 uv) {\n  vec2 i = floor(uv);\n  vec2 f = fract(uv);\n  vec2 u = f * f * (3.0f - 2.0f * f);\n  return mix(mix(noise(i + vec2(0.0f, 0.0f)), noise(i + vec2(1.0f, 0.0f)), u.x), mix(noise(i + vec2(0.0f, 1.0f)), noise(i + vec2(1.0f, 1.0f)), u.x), u.y);\n}\n\nvec2 perlinNoise22(vec2 uv){\n  vec2 i = floor(uv);\n  vec2 f = fract(uv);\n  vec2 u = f * f * (3.0f - 2.0f * f);\n  return mix(mix(i + vec2(0.0f, 0.0f), i + vec2(1.0f, 0.0f), u.x), mix(i + vec2(0.0f, 1.0f), i + vec2(1.0f, 1.0f), u.x), u.y);\n}\n\n\n\nfloat ffbm(vec2 uv, float scale, float offset) {\n  float n = 0.0f;\n  float amp = 1.0f;\n  for(int i = 0; i < 4; i++) {\n    n += perlinNoise(uv * scale) * amp;\n    uv *= 2.0f;\n    amp *= 0.5f;\n  }\n  return n + offset;\n}\n\nfloat circleGradient(vec2 uv, float blur) {\n  float dist = length(uv);\n  return smoothstep(0.5f + blur, 0.5f - blur, dist);\n}\n\n// Function to apply a blur to a color\nvec3 applyBlur(vec3 color, float blurAmount, vec2 uv) {\n  vec3 accumulatedColor = vec3(0.0f);\n  float totalWeight = 0.0f;\n  for(int x = -1; x <= 1; x++) {\n    for(int y = -1; y <= 1; y++) {\n      vec2 sampleUv = uv + vec2(x, y) * blurAmount;\n      accumulatedColor += texture(iChannel0, sampleUv).rgb;\n      totalWeight += 1.0f;\n    }\n  }\n  return accumulatedColor / totalWeight;\n}\n\nfloat gaussian(float x, float sigma) {\n  return exp(-(x * x) / (2.0f * sigma * sigma));\n}\n\nvec2 lissajous(float t, float a, float b, float delta) {\n  return vec2(sin(a * t + delta), sin(b * t));\n}\n\nvec3 applyGlow(vec3 color, float distance, float glowStrength, float glowRadius) {\n  float glow = gaussian(distance, glowRadius) * glowStrength;\n  return color + glow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float scale = (sin(iTime)*.5+.5)+2.;\n  vec2 uv = scale * (2.0f * gl_FragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n  float t = mod(iTime * 0.1f, PI*2.0);\n  float bass = texture(iChannel0, vec2(0.00f, 0.0f)).r;\n  float b = pow(bass, 3.0f);\n  uv += lissajous(t, 1.0f, 2.0f, PI/2.0) ;\n  uv *= rotate2d(mod(t*2., PI*2.0));\n  vec2 ouv = uv;\n\n  float ilength = 1.0f / length(uv);\n  uv = uv * ilength - vec2(ilength+t, 0.5f);\n  vec3 finalColor = vec3(0.0f);\n  float noise = 0.0f;\n  for(int i = 0; i < 5; i++) {\n    float scale = 5.5f + float(i) * 0.5f;\n    float offset = float(i) * 0.5f;\n    uv *= rotate2d(mod(t*offset*.2, PI*2.0));\n    noise = ffbm(uv-t*0.7*float(i)-vec2(float(i*i), float(i)/2.0), scale, offset*2.) * ilength * 0.2f;\n    finalColor += vec3(noise/5.0);\n\n  }\n\n  finalColor.rg *= b;\n  finalColor.b += 0.4/(ffbm(uv*sin(mod(t, 3.0)*3.0)*0.5, 5.0f, 0.0f) * 0.5f + 0.5f);\n  finalColor.r += 0.2/(ffbm(uv*cos(mod(t, 4.0)*3.0)*0.5, 5.0f, 0.0f) * 0.5f + 0.5f);\n  finalColor = applyGlow(finalColor, length(ouv-uv), .3f, 3.1f);\n\n  float grad = circleGradient(uv, 0.5f);\n  finalColor -= (0.0001/length(uv)*0.5f + 0.5f)*sin(b*4.5f)*0.1f * grad;\n  finalColor -= (length(ouv))*.1;\n  // finalColor.g -= (ffbm(uv-t*2., b*5.0, t))*0.2;\n  fragColor = vec4(finalColor, 1.0f);\n}", "image_inputs": [{"id": 35477, "src": "https://soundcloud.com/espen-sande-larsen-365984601/to-the-light", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctKBDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 74, 74, 144], [145, 145, 167, 167, 244], [246, 246, 274, 274, 513], [515, 515, 543, 543, 754], [758, 758, 806, 806, 975], [977, 977, 1020, 1020, 1102], [1104, 1143, 1198, 1198, 1524], [1526, 1526, 1564, 1564, 1615], [1617, 1617, 1673, 1673, 1722], [1724, 1724, 1806, 1806, 1893], [1895, 1895, 1952, 1952, 3245]], "test": "untested"}
{"id": "ctKfWW", "name": "Truchet pattern - Punpun", "author": "punpun", "description": "Truchet Patterns", "tags": ["patterns", "truchet"], "likes": 5, "viewed": 113, "published": 3, "date": "1702069891", "time_retrieved": "2024-07-30T17:17:56.918049", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265358979323846\n\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 truchetPattern(in vec2 _st, in float _index){\n    _index = fract(((_index-0.5)*2.0));\n    if (_index > 0.75) {\n        _st = vec2(1.0) - _st;\n    } else if (_index > 0.5) {\n        _st = vec2(1.0-_st.x,_st.y);\n    } else if (_index > 0.25) {\n        _st = 1.0-vec2(1.0-_st.x,_st.y);\n    }\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    st *= 10.0;\n    \n    // Animation\n    st = (st-vec2(5.0))*(abs(sin(iTime*0.2))*5.);\n    st.x += iTime*3.0;\n\n    vec2 ipos = floor(st);  // integer\n    vec2 fpos = fract(st);  // fraction\n\n    vec2 tile = truchetPattern(fpos, random( ipos ));\n    // tile = ipos/fpos;\n\n    float color = 0.0;\n\n    // Maze\n    color = smoothstep(tile.x-0.3,tile.x,tile.y)-smoothstep(tile.x,tile.x+0.3,tile.y);\n\t\n    // Circles\n    color /= (step(length(tile),0.6) -\n             step(length(tile),0.4) ) +\n            (step(length(tile-vec2(1.)),0.6) -\n             step(length(tile-vec2(1.)),0.4) );\n\n    // Truchet (2 triangles)\n    color /= step(tile.x,tile.y);\n\n    fragColor = vec4(vec3(color, 0., 0.),1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctKfWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 110, 110, 218], [220, 220, 270, 270, 531], [533, 533, 590, 590, 1371]], "test": "untested"}
{"id": "DlyBzw", "name": "flower of life", "author": "ich", "description": "press 'L' in fullscreen to restart render.\n'max_bounces' and 'aa_level' can be modified to change render quality.", "tags": ["floweroflifelebensblumepathtracingmontecarloartreflectionmetal"], "likes": 11, "viewed": 247, "published": 3, "date": "1702034131", "time_retrieved": "2024-07-30T17:17:57.811660", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    // gamma\n    col = pow(col, vec3(1.0/2.2));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n * ************** quality **************\n */\n \n#define max_bounces 4\n#define aa_level 0\n\n/*\n * ************** constants **************\n */\n\n#define max_dist 100.\n#define min_dist .001\n#define max_it 1000\n#define pi 3.1415926\n\n/*\n * ************** util **************\n */ \n\nfloat n21(vec2 s) {\n\treturn fract(9876. * sin(dot(s, vec2(987, 654))));\n}\n\nvec2 n22(vec2 s) {\n\tfloat n = n21(s);\n    return vec2(n, n21(s + n));\n}\n\nvec3 n33(vec3 s) {\n    return vec3(n21(s.xy), n21(s.yz), n21(s.zx));\n}\n\nmat3 look_at(vec3 d) {\n    vec3 u = vec3(0, 1, 0);\n    \n    // if u and d are similar, then use different algorithm\n    \n    if (abs(dot(d, u)) < .5) {\n        vec3 r = normalize(cross(d, u));\n        u = normalize(cross(r, d));\n        return mat3(r, u, d);\n    }\n    \n    u = normalize(cross(d, vec3(1, 0, 0)));\n    vec3 r = normalize(cross(d, u));\n    return mat3(r, u, d);\n}\n\n/*\n * ************** 2D SDF operations **************\n */ \n\nfloat extrude(vec3 p, float l, float h) {\n    vec2 w = vec2(l, abs(p.z) - h);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\n/*\n * ************** 2D SDFs **************\n */ \n\nfloat circle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat ring(vec2 p, float r, float w) {\n    return abs(circle(p, r)) - w;\n}\n\nfloat infinite_hexagon(vec2 p, float r, float w) {\n    float l = 2.;\n    float h = r * cos(pi / 6.);\n    float v = r * sin(pi / 6.);\n    \n    p.x = abs(mod(p.x - h, h*2.) - h);\n    p.y = abs(mod(p.y - v, v*2.) - v);\n\n    l = min(l, ring(p - vec2(h, -v), r, w));\n    l = min(l, ring(p - vec2(0, r), r, w));\n    l = min(l, ring(p - vec2(-h, v), r, w));\n    l = min(l, ring(p - vec2(2.*h, 0), r, w));\n    \n    return l;\n}\n\nfloat lebensblume_region(vec2 p, float r, float w) {\n    float l = 2.;\n    float h = r * cos(pi / 6.);\n    float v = r * sin(pi / 6.);\n    \n    p = abs(p);\n    \n    l = min(l, circle(p, r));\n    l = min(l, circle(p - vec2(0, v*4.), r));\n    l = min(l, circle(p - vec2(h, v*3.), r));\n    l = min(l, circle(p - vec2(h*2., v*2.), r));\n    l = min(l, circle(p - vec2(h*2., 0), r));\n    \n    return l - w;\n}\n\nfloat lebensblume(vec2 p, float r, float w) {\n    return max(lebensblume_region(p, r, w), infinite_hexagon(p, r, w));\n}\n\n/*\n * ************** 3D SDFs **************\n */\n\nfloat plane(vec3 p, vec3 n) {\n    return dot(p, n);\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 r, float rc) {\n    vec3 q = abs(p) - r + rc;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.) - rc;\n}\n\n/*\n * ************** scene **************\n */\n\nstruct Material {\n    bool light;\n    float rough;\n    vec3 color;\n};\n\nMaterial materials[] = Material[] (\n    Material (false, 0.35, vec3(.7, .9, .7)),\n    Material (true,  0.0, vec3(1)),\n    Material (false, 0.01, vec3(1)),\n    Material (false, 0.9, vec3(1, .1, .2)),\n    Material (false, 0.5, vec3(1))\n);\n\n#define SCENE \\\n    xmin(0, -box(p, vec3(3, 3, 5), .2)); \\\n    xmin(2, sphere(p - vec3(2, -2, 1), 1.)); \\\n    xmin(3, sphere(p - vec3(-2, -2, .5), 1.)); \\\n    xmin(3, sphere(p - vec3(2, -2, 4), 1.)); \\\n    xmin(4, extrude(p - vec3(0, 0, -2), lebensblume(p.xy, .9, .04), .1)); \\\n    xmin(1, plane(p - vec3(0, 0, -2), normalize(vec3(0, 0, 1)))); \\\n   \nfloat scene(vec3 p) {\n    float l = max_dist;\n    \n    #define xmin(I, lo) l = min(l, lo)\n    SCENE\n    #undef xmin\n    \n    return l;\n}\n\nint material_index(vec3 p) {\n    float l = max_dist;\n    int i = 0;\n    \n    #define xmin(I, lo) if (lo < l) { l = lo; i = I; }\n    SCENE\n    #undef xmin\n    \n    return i;\n}\n\nMaterial material(vec3 p) {\n    return materials[material_index(p)];\n}\n\n/*\n * ************** algorithm **************\n */\n\nbool march(vec3 ro, vec3 rd, out float lo) {\n    lo = 0.;\n    \n    for (int i = 0; i < max_it && lo < max_dist; ++i) {\n        float l = scene(ro);\n        lo += l;\n        ro += rd * l;\n        \n        if (l < min_dist)\n            return true;\n    }\n    \n    return false;\n}\n\nvec3 normal(vec3 p) {\n\tfloat l = scene(p);\n\tvec2 e = vec2(0, min_dist * .5);\n\treturn normalize(\n\t\tl - vec3(\n\t\t\tscene(p - e.yxx),\n\t\t\tscene(p - e.xyx),\n\t\t\tscene(p - e.xxy)\n\t));\n}\n\nvec3 reflect_diffuse(vec3 rd, vec3 n, float rough) {\n    vec3 n3 = n33(rd + iTime);\n    //n3 = n33(vec3(iTime, iTime+.1, iTime+.2));\n    float axy = n3.x * pi * 2.;\n    float az = n3.y * pi * .5;\n    \n    float x = cos(axy) * cos(az);\n    float y = sin(axy) * cos(az);\n    float z = sin(az);\n    vec3 dir = vec3(x, y, z);\n    \n    vec3 diffuse = look_at(n) * dir;\n    vec3 mirror = reflect(rd, n);\n    \n    //return n3.z < rough ? diffuse : mirror;\n    return mix(mirror, diffuse, rough);\n}\n\nvec3 trace(vec3 ro, vec3 rd) {\n    vec3 col = vec3(1);\n    \n    for (int i = 0; i < max_bounces; ++i) {\n        float l, rough;\n        if (!march(ro, rd, l))\n            break;\n            \n        vec3 p = ro + rd * l;\n        vec3 n = normal(p);\n        Material m = material(p);\n            \n        float atten = 1.0;\n        \n        // fade out into distance\n        //atten *= smoothstep(max_dist, max_dist*.5, l);\n        \n        // view normals\n        //return atten * abs(n);\n        \n        // view roughness\n        //return vec3(atten * m.rough);\n        \n        col *= m.color;\n        \n        if (m.light)\n            return col;\n        \n        ro = p + n * min_dist * 2.;\n        rd = reflect_diffuse(rd, n, m.rough);\n    }\n    \n    return vec3(0);\n}\n\nvec3 emit(vec3 view_pos, vec3 view_dir, float fov, vec2 fragCoord) {\n    vec3 col = vec3(0);\n    \n    float pixel = 1. / iResolution.y;\n    vec3 ro = view_pos;\n    \n    int aa = 1 << aa_level;\n    \n    for (int i = 0; i < aa; ++i) {\n        float a = float(i) / float(aa) * pi * 2.;\n        vec2 fragOffset = vec2(cos(a), sin(a)) * .5;\n        \n        vec2 uv = (fragCoord - fragOffset - iResolution.xy*.5) / iResolution.y;\n        vec3 rd = look_at(view_dir) * normalize(vec3(uv, fov));\n        \n        col += trace(ro, rd);\n    }\n    \n    return col / float(aa);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = vec3(0);\n    \n    vec3 view_pos = vec3(0, -1, 4);\n    vec3 view_dir = normalize(vec3(0, 0, -1));\n    \n    col = emit(view_pos, view_dir, .7, fragCoord);\n    \n    const int KEY_L = 76;\n    bool reset = .5 < texelFetch(iChannel1, ivec2(KEY_L, 0), 0).r;\n    if (!reset)\n        col = mix(col, texture(iChannel0, uv).rgb, 0.99);\n    //col = col / (float(iFrame) + 1.) + texture(iChannel0, uv).rgb * (1. - 1. / (float(iFrame) + 1.));\n    \n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlyBzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 239]], "test": "untested"}
{"id": "mtGfDh", "name": "Heart_For_LJM", "author": "tbx", "description": "A Christmas gift for the best girl in the world.", "tags": ["heart"], "likes": 10, "viewed": 222, "published": 3, "date": "1702022234", "time_retrieved": "2024-07-30T17:17:58.768103", "image_code": "#define PI 3.141592653\n#define COUNT 20.0\n\nfloat line(vec2 st, float width)\n{\n    return smoothstep(width, 0.0, abs(st.y - st.x));\n}\n\nfloat drawCoord(vec2 uv)\n{\n   float x = distance(vec2(uv.x, 0.0), vec2(0.0, 0.0));\n   float y = distance(vec2(0.0, uv.y), vec2(0.0, 0.0));\n   \n   return 1e-3 / x + 1e-3 / y;\n}\n\nfloat sphere(vec2 coord, vec2 p, float radius)\n{\n    float d = distance(p, coord);\n    d = abs(d - radius);\n    return 1e-3 / d;\n}\n\nfloat sphereShape(vec2 coord, vec2 p, float radius)\n{\n    float d = distance(p, coord);\n    d /= radius;\n    d = 1.0 - d;\n    d = clamp(d * 24.0, 0.0, 1.0);\n    return d;\n}\n\nfloat net(vec2 coord)\n{\n    float xline = cos(coord.x * PI * COUNT);\n    xline = step(1.0 - 1e-1, xline);\n    \n    float yline = cos(coord.y * PI * COUNT);\n    yline = step(1.0 - 1e-1, yline);\n    \n    return xline + yline;\n}\n\nfloat QuadrantIV(vec2 coord, float warp)\n{\n    float f = step(0.0, -coord.x);\n    f *= step(0.0, coord.y);\n    return abs(warp - f);\n}\n\nfloat QuadrantII(vec2 coord, float warp)\n{\n    float f = step(0.0, coord.x);\n    f *= step(0.0, -coord.y);\n    return abs(warp - f);\n}\n\nfloat getX(float i)\n{\n    float r = acos(i);\n    return r;\n}\n\n// Heart curve suggested by IQ, improved by Dave_Hoskins.\nfloat heart(vec2 p) {\n    // Center it more, vertically:\n    p.y += 0.6;\n    // This offset reduces artifacts on the center vertical axis.\n    const float offset = 0.3;\n    // (x^2+(1.2*y-sqrt(abs(x)))^2â1)\n    float k = 1.2 * p.y - sqrt(abs(p.x) + offset);\n    float r = p.x * p.x + k * k - 1.0;\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float asp = iResolution.x / iResolution.y;\n    \n    vec2 coord = uv * 2.0 - 1.0;\n    \n    vec2 aspCoord = vec2(coord.x * asp, coord.y);\n    \n    vec3 col = vec3(0.0);\n    \n    col += net(aspCoord) * 0.125;\n    \n    col += drawCoord(coord);\n    aspCoord *= 1.5;\n    \n    //https://www.shadertoy.com/view/XsfGRn\n    //Thanks to IQ\n    float tt = mod(iTime, 1.5)/1.5;\n    float ss = pow(tt, 0.2) * 0.5 + 0.5;\n    ss = 1.0 + ss * 0.5 * sin(tt * 6.2831 * 3.0 + aspCoord.y * 0.5) * exp(-tt * 4.0);\n    aspCoord *= vec2(0.5, 1.5) + ss * vec2(0.5,-0.5);\n    \n    col += vec3(abs(1e-1/heart(aspCoord)) * vec3(1.0, 0.2, 0.2));\n    /*\n    float time = iTime * 0.5;\n    float animate = tan(time + abs(sin(time)));\n    float f = clamp(animate - aspCoord.y, 0.0, 1.0);\n    \n    col += f * clamp(1.0 - heart(aspCoord), 0.0, 1.0) * vec3(1.0, 0.2, 0.2);\n    */\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtGfDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 77, 77, 132], [134, 134, 160, 160, 309], [311, 311, 359, 359, 441], [443, 443, 496, 496, 615], [617, 617, 640, 640, 842], [844, 844, 886, 886, 978], [980, 980, 1022, 1022, 1114], [1116, 1116, 1137, 1137, 1176], [1178, 1236, 1257, 1292, 1550], [1552, 1552, 1609, 1659, 2609]], "test": "untested"}
{"id": "mtKfWz", "name": "Angular Derivative", "author": "bcourter", "description": "Taking the angular derivative with respect to an axis, which is an orthogonal field to the original SDF.  From there, we can make a pencil of surfaces through the intersection of the SDF and the derivative.", "tags": ["sdf", "derivative", "pencil", "differential", "ugf"], "likes": 5, "viewed": 654, "published": 3, "date": "1702002136", "time_retrieved": "2024-07-30T17:17:59.766434", "image_code": "// Derivative of a field with respect to a rotation axis\n// See blog post at: https://www.blakecourter.com/2024/04/12/differential-engineering.html\n\n\n// Sliders thanks to https://www.shadertoy.com/view/XlG3WD\n\nfloat pi = 3.1415926535;\n\nvec2 mouse = vec2(-180.0, 250.0);\n\nvec2 center = vec2(0.0);\nfloat wobble = 0.0;\nint shapeIndex = 0;\n\nvec4 colorWarm = vec4(1, 0, 0, 1);\nvec4 colorCool = vec4(0, 0, 1, 1);\nvec4 colorBlack = vec4(0, 0, 0, 1);\n\n// Sliders\nfloat readFloat(float address) { return texture(iChannel0, (floor(vec2(address, 1))+0.5) / iChannelResolution[0].xy).r; }\nvec4 readVec4(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\n\nvec4 strokeImplicit(Implicit a, float width, vec4 base) {\n    vec4 color = vec4(a.Color.rgb * 0.25, a.Color.a);\n    \n    float interp = clamp(width * 0.5 - abs(a.Distance) / length(a.Gradient), 0.0, 1.);\n    return mix(base, color, color.a * interp);\n    \n    return base;\n}\n\nvec4 drawImplicit(Implicit a, vec4 base) {\n    float bandWidth = 20.0;\n    float falloff = 150.0;\n    float widthThin = 2.0;\n    float widthThick = 4.0;\n\n    vec4 color = a.Distance > 0.0 ? colorWarm : colorCool;\n    vec4 opColor = mix(base, color, 0.1);\n    Implicit wave = TriangleWaveEvenPositive(a, bandWidth, a.Color);  \n\n    wave.Color.a = max(0.2, 1.0 - abs(a.Distance) / falloff);\n    opColor = strokeImplicit(wave, widthThin, opColor);\n    opColor = strokeImplicit(a, widthThick, opColor);\n    \n    return opColor;\n}\n\nvec4 drawLine(Implicit a, vec4 opColor) {\n    a.Color.a = 0.75;\n    return strokeImplicit(a, 2.0, opColor);\n}\n\nvec4 drawFill(Implicit a, vec4 opColor) {\n    float clamped = 0.5 - clamp(a.Distance / length(a.Gradient), -0.5, 0.5);\n    return mix(opColor, a.Color, a.Color.a * clamped);\n\n    return opColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 opColor = vec4(1.0);\n    \n    wobble = readFloat(0.); \n    shapeIndex = int(readFloat(1.) * 3.);\n\n    float halfGolden = 0.5*0.618;\n    vec2 size = iResolution.x * 0.2 * vec2(1.0 + halfGolden * (1.0 + cos(iTime) * wobble), 1.0) + vec2(160.0 * wobble * cos(iTime * 0.5));\n\n    vec2 p = (fragCoord - 0.5 * iResolution.xy); // * iResolution.xy;\n    if (iMouse.x > bounds.x + bounds.z + 20.0 || iMouse.y > bounds.y + bounds.w + 20.0)\n        mouse = iMouse.xy - 0.5 * iResolution.xy;\n    else\n        mouse = shapeIndex == 0 ? vec2(0.0) : vec2(size.x * 0.5, 0.0);\n        \n    if (iMouse.xy == vec2(0.0)) \n        mouse = vec2(0.0);\n    \n    vec3 p3 = vec3(p, 0.0);\n\n    Implicit shape;\n    if (shapeIndex == 0) {\n        shape = RectangleCenterRotated(p - mouse, vec2(0.0), size, 0.0, colorBlack);\n    } else if (shapeIndex == 1){\n        shape = Circle(p - mouse, center, size.x * 0.5, colorBlack);\n    } else {\n        shape = Plane(p - mouse, center, mouse - center, colorBlack);\n    }\n    \n    // uncomment for squared Euclidean metric\n    // shape.Distance = shape.Distance * shape.Distance * sign(shape.Distance) * 0.01;\n    \n    vec2 pRot = vec2(p.y, -p.x);\n    vec3 gradRot = vec3(shape.Gradient.y, -shape.Gradient.x, 0.0);\n    \n    //    opColor = drawImplicit(shape, opColor);    \n    Implicit grad = Implicit(dot(pRot, shape.Gradient.xy), gradRot, vec4(0., 0., 0., 1));\n    float rotateTime = iTime * 0.25;\n    Implicit pencilA = Add(Multiply(cos(rotateTime), shape), Multiply(sin(rotateTime), grad));\n    Implicit pencilB = Add(Multiply(-sin(rotateTime), shape), Multiply(cos(rotateTime), grad));\n    \n    opColor = drawImplicit(pencilA, opColor);\n    opColor = drawImplicit(pencilB, opColor);\n    opColor = strokeImplicit(shape, 5.0, opColor);\n    \n    Implicit axis = Circle(p, center, 5.0, colorBlack);\n    opColor = drawFill(axis, opColor);    \n\n    vec4 ui = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    opColor = mix(opColor, ui, ui.a);\n    \n    fragColor = opColor;\n}\n\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 bounds = vec4(30,70,160,18);\n\n//////////////////\n\nstruct Implicit {\n\tfloat Distance;\n\tvec3 Gradient;\n\tvec4 Color;\n};\n\nImplicit CreateImplicit() { return Implicit(0.0, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue) { return Implicit(iValue, vec3(0.0), vec4(0.0)); }\nImplicit CreateImplicit(float iValue, vec4 iColor) { return Implicit(iValue, vec3(0.0), iColor); }\n\nImplicit Negate(Implicit iImplicit) {\n\treturn Implicit(-iImplicit.Distance, -iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Add(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance + b.Distance, a.Gradient + b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Subtract(Implicit a, Implicit b)  {\n\treturn Implicit(a.Distance - b.Distance, a.Gradient - b.Gradient, (a.Color + b.Color) * 0.5);\n}\n\nImplicit Add(float iT, Implicit iImplicit) {\n\treturn Implicit(iT + iImplicit.Distance, iImplicit.Gradient, iImplicit.Color);\n}\nImplicit Add(Implicit iImplicit, float iT) { return Add(iT, iImplicit); }\nImplicit Subtract(float iT, Implicit iImplicit) { return Add(iT, Negate(iImplicit)); }\nImplicit Subtract(Implicit iImplicit, float iT) { return Add(-iT, iImplicit); }\n\nImplicit Multiply(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance * b.Distance, a.Distance * b.Gradient + b.Distance * a.Gradient, (a.Color + b.Color) * 0.5);\n}\nImplicit Multiply(float iT, Implicit iImplicit) { return Implicit(iT * iImplicit.Distance, iT * iImplicit.Gradient, iImplicit.Color); }\nImplicit Multiply(Implicit iImplicit, float iT) { return Multiply(iT, iImplicit); }\n\nImplicit Square(Implicit iA) { return Multiply(iA, iA); }\n\nImplicit Divide(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance / b.Distance, (b.Distance * a.Gradient - a.Distance * b.Gradient) / (b.Distance * b.Distance), (a.Color + b.Color) * 0.5);\n}\nImplicit Divide(Implicit a, float b) { return Implicit(a.Distance / b, a.Gradient / b, a.Color); }\n\nImplicit Min(Implicit a, Implicit b) \n{\n\tif (a.Distance <= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nImplicit Max(Implicit a, Implicit b) {\n\tif (a.Distance >= b.Distance)\n\t\treturn a;\n\t\n\treturn b;\n}\n\nfloat mix11(float a, float b, float t) {\n    return mix(a, b, t * 0.5 + 0.5);\n}\n\nImplicit Exp(Implicit iImplicit)\n{\n\tfloat exp = exp(iImplicit.Distance);\n\treturn Implicit(exp, exp * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Log(Implicit iImplicit)\n{\n\treturn Implicit(log(iImplicit.Distance), iImplicit.Gradient / iImplicit.Distance, iImplicit.Color);\n}\n\nImplicit Sqrt(Implicit iImplicit)\n{\n\tfloat sqrt = sqrt(iImplicit.Distance);\n\treturn Implicit(sqrt, iImplicit.Gradient / (2.0 * sqrt), iImplicit.Color);\n}\n\nImplicit Abs(Implicit iImplicit)\n{\n\treturn Implicit(abs(iImplicit.Distance), sign(iImplicit.Distance) * iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Mod(Implicit iImplicit, float iM)\n{\n\treturn Implicit(mod(iImplicit.Distance, iM), iImplicit.Gradient, iImplicit.Color);\n}\n\nImplicit Shell(Implicit iImplicit, float thickness, float bias) \n{\n\tthickness *= 0.5;\n\treturn Subtract(Abs(Add(iImplicit, bias * thickness)), thickness);\n}\n\nImplicit EuclideanNorm(Implicit a, Implicit b) {\n    return Sqrt(Add(Multiply(a, a), Multiply(b, b)));\n}\nImplicit EuclideanNorm(Implicit a, Implicit b, Implicit c) {\n    return Sqrt(Add(Add(Multiply(a, a), Multiply(b, b)), Multiply(c, c)));\n}\n\n// Booleans\n// https://mercury.sexy/hg_sdf/\nImplicit IntersectionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit maxab = Max(a, b);\n    Implicit r = CreateImplicit(radius, maxab.Color);\n    \n    Implicit ua = Implicit(Max(Add(a, r), CreateImplicit()).Distance, a.Gradient, a.Color);\n    Implicit ub = Implicit(Max(Add(b, r), CreateImplicit()).Distance, b.Gradient, b.Color);\n    \n\tImplicit op = Add(Min(Negate(r), maxab), EuclideanNorm(ua, ub));\n    \n    if (maxab.Distance <= 0.0)\n        op.Gradient = maxab.Gradient;\n        \n    if (min(a.Distance, b.Distance) > 0.)\n        op.Color = mix(a.Color, b.Color, 0.5 + 0.5 * (b.Distance - a.Distance)/(a.Distance + b.Distance));\n        \n    return op;\n}\n\n// https://iquilezles.org/articles/smin/\nImplicit IntersectionExponential(Implicit a, Implicit b, float radius) {\n//    float res = exp2( -a/k ) + exp2( -b/k );\n//    return -k*log2( res );\n\n    a = Exp(Divide(a, radius));\n    b = Exp(Divide(b, radius));\n    Implicit res = Add(a, b);\n    \n    return Multiply(Log(res), radius);\n}\n\n// https://mercury.sexy/hg_sdf/\nImplicit UnionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit ab = Min(a, b);\n    Implicit r = CreateImplicit(radius, ab.Color);\n    \n    Implicit ua = Max(Subtract(r, a), CreateImplicit(0.0, a.Color));\n    Implicit ub = Max(Subtract(r, b), CreateImplicit(0.0, b.Color));\n    \n\tImplicit op = Subtract(Max(r, ab), EuclideanNorm(ua, ub));\n    \n    if (ab.Distance > 0.0)\n        op.Gradient = ab.Gradient;\n        \n    return op;\n}\n\n// https://mercury.sexy/hg_sdf/\nImplicit UnionEuclidean(Implicit a, Implicit b, Implicit c, float radius) {\n    Implicit zero = CreateImplicit(0.0);\n    Implicit r = CreateImplicit(radius);\n    Implicit ua = Max(Subtract(r, a), zero);\n    Implicit ub = Max(Subtract(r, b), zero);\n    Implicit uc = Max(Subtract(r, c), zero);\n    \n    Implicit abc = Min(a, Min(b, c));\n\n\tImplicit op = Subtract(Max(r, abc), EuclideanNorm(ua, ub, uc));\n    \n    if (abc.Distance > 0.0)\n        op.Gradient = abc.Gradient;\n        \n    return op;\n}\n\nImplicit UnionChamfer(Implicit iA, Implicit iB, float k)\n{\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(h, 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    float param = h2.Distance;\n    result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\n// Polynomial Smooth Min 2 from https://iquilezles.org/articles/smin/ and https://iquilezles.org/articles/distgradfunctions2d/\nImplicit UnionSmoothMedial(Implicit a, Implicit b, float k) \n{\n    float h = max(k-abs(a.Distance-b.Distance),0.0);\n    float m = 0.25*h*h/k;\n    float n = 0.50 * h/k;\n    float dist = min(a.Distance,  b.Distance) - m; \n                 \n    float param = (a.Distance < b.Distance) ? n : 1.0 - n;\n    vec3 grad = mix(a.Gradient, b.Gradient, param);\n    vec4 color = mix(a.Color, b.Color, param);\n\n\n    return Implicit(dist, grad, color);\n}\n\nImplicit UnionSmooth(Implicit a, Implicit b, float k){\n    a.Distance -= k;\n    b.Distance -= k;\n\n //   if (min(a.Distance, b.Distance) >= 0.)\n //       return (Min(a, b));\n\n    return Add(UnionSmoothMedial(a, b, abs(a.Distance + b.Distance) * abs(1.-dot(a.Gradient, b.Gradient))), k);\n}\n\n\nImplicit IntersectionSmoothMedial(Implicit iA, Implicit iB, float k){\n    return Negate(UnionSmoothMedial(Negate(iA), Negate(iB), k));\n}\n\n\nImplicit IntersectionSmooth(Implicit iA, Implicit iB, float k){\n    return Negate(UnionSmooth(Negate(iA), Negate(iB), k));\n}\n\n\n\n// R0 fro, https://www.cambridge.org/core/journals/acta-numerica/article/abs/semianalytic-geometry-with-rfunctions/3F5E061C35CA6A712BE338FE4AD1DB7B\nImplicit UnionRvachev(Implicit iA, Implicit iB, float k)\n{\n    Implicit result = Subtract(Add(iA, iB), Sqrt(Add(Square(iA), Square(iB))));\n  //  float param = 0.5;\n  //  result.Color = mix(iA.Color, iB.Color, iA.Distance < iB.Distance ? param : (1.0 - param));\n\n    return result;\n}\n\nImplicit IntersectionRvachev(Implicit iA, Implicit iB, float k){\n    return Negate(UnionRvachev(Negate(iA), Negate(iB), k));\n}\n\n\n// Primitives\n\nImplicit Plane(vec3 p, vec3 origin, vec3 normal, vec4 color) \n{\n    vec3 grad = normalize(normal);\n    float v = dot(p - origin, grad);\n    return Implicit(v, grad, color);\n}\nImplicit Plane(vec2 p, vec2 origin, vec2 normal, vec4 color) \n{\n    return Plane(vec3(p, 0.0), vec3(origin, 0.0), vec3(normal, 0.0), color);\n}\n\n\nImplicit Circle(vec2 p, vec2 center, float iRadius, vec4 color)\n{\n\tvec2 centered = p - center;\n    float len = length(centered);\n\tfloat length = len - iRadius;\n\treturn Implicit(length, vec3(centered / len, 0.0), color);\n}\n \nmat2 Rotate2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        vec2(c, -s),\n        vec2(s, c)\n    );\n}\n\nImplicit RectangleCenterRotated(vec2 p, vec2 center, vec2 size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n    centered = rot * centered;\n    \n\tvec2 b = size * 0.5;\n\tvec2 d = abs(centered)-b;\n\tfloat dist = length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);\n\n\tvec2 grad = d.x > d.y ? vec2(1.0, 0.0) : vec2 (0.0, 1.0);\n\tif (d.x > 0. && d.y > 0.)\n\t\tgrad = d / length(d);\n\n\tgrad *= -sign(centered);\n\n\treturn Implicit(dist, vec3(grad * rot, 0.0), color);\n}\n\n\n\nImplicit RectangleCenterRotatedExp(vec2 p, vec2 center, vec2 size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n    centered = rot * centered;\n    size = size * 0.5;\n    Implicit xPlane = Subtract(Abs(Implicit(centered.x, vec3(1, 0, 0), color)), size.x);\n    Implicit yPlane = Subtract(Abs(Implicit(centered.y, vec3(0, 1, 0), color)), size.y);\n\n\n    \n\treturn IntersectionExponential(xPlane, yPlane, 20.0);\n}\n\nImplicit RectangleUGFSDFCenterRotated(vec2 p, vec2 center, float size, float angle, vec4 color)\n{\n\tvec2 centered = p - center;\n    mat2 rot = Rotate2(-angle);\n //   centered = rot * centered;\n    size *= 0.5;\n    \n    Implicit x = Plane(centered, vec2(0.), rot * vec2(-1., 0.), color);\n    Implicit y = Plane(centered, vec2(0.), rot * vec2(0., -1.), color);\n    Implicit cornerA = Subtract(Max(x, y), size);\n    Implicit cornerB = Subtract(Max(Negate(x), Negate(y)), size);\n   \n\treturn IntersectionEuclidean(cornerA, cornerB, 0.);\n}\n\nImplicit TriangleWaveEvenPositive(Implicit param, float period, vec4 color)\n{\n\tfloat halfPeriod = 0.5 * period;\n    float wave = mod(param.Distance, period) - halfPeriod;\n\tfloat dist = halfPeriod - abs(wave);\n\tvec3 grad = -sign(wave) * param.Gradient;\n\treturn Implicit(dist, grad, color);\n}\n\n\n// Viz\nvec4 DrawVectorField(vec3 p, Implicit iImplicit, vec4 iColor, float iSpacing, float iLineHalfThick)\n{\n\tvec2 spacingVec = vec2(iSpacing);\n\tvec2 param = mod(p.xy, spacingVec);\n\tvec2 center = p.xy - param + 0.5 * spacingVec;\n\tvec2 toCenter = p.xy - center;\n\n\tfloat gradParam = dot(toCenter, iImplicit.Gradient.xy) / length(iImplicit.Gradient);\n\tfloat gradLength = length(iImplicit.Gradient);\n\t\n\tbool isInCircle = length(p.xy - center) < iSpacing * 0.45 * max(length(iImplicit.Gradient.xy) / gradLength, 0.2);\n\tbool isNearLine = abs(dot(toCenter, vec2(-iImplicit.Gradient.y, iImplicit.Gradient.x))) / gradLength < iLineHalfThick + (-gradParam + iSpacing * 0.5) * 0.125;\n\t\n\tif (isInCircle && isNearLine)\n\t\treturn vec4(iColor.rgb * 0.5, 1.);\n\n\treturn iColor;\n}", "buffer_a_code": "#define UI_COLOR vec3(0.0,0.0,0.0)\n\n//8x8 font \n#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); \n#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);\n#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);\n#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);\n#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);\n#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);\n#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);\n#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);\n#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);\n#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);\n#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);\n#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);\n#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);\n#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);\n#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);\n#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);\n#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);\n#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);\n#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);\n#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);\n#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);\n#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);\n#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);\n#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);\n\n#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);\n#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);\n#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);\n#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);\n#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);\n#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);\n#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);\n#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);\n#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);\n#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);\n#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);\n#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);\n#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);\n#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);\n#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);\n#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);\n#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);\n#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);\n#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);\n#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);\n#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);\n#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);\n#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);\n#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);\n#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);\n#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);\n\n#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);\n#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);\n#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);\n#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);\n#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);\n#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);\n#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);\n#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);\n#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);\n#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);\n#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);\n#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);\n#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);\n#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);\n\n#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); \n#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;\n\n// Backwards at https://github.com/dhepper/font8x8/blob/master/font8x8_basic.h\n#define RPAREN text.w += char(0x180C, 0x0606, 0x060C, 0x1800);\n#define LPAREN text.w += char(0x060C, 0x1818, 0x180C, 0x0600);\n#define SLASH  text.w += char(0x0306, 0x0C18, 0x3060, 0x4000);\n#define BSLASH text.w += char(0x6030, 0x180C, 0x0603, 0x0100);\n#define PLUS   text.w += char(0x000C, 0x0C3F, 0x0C0C, 0x0000);\n\n#define SP text.z+=4.;\n#define _ text.z+=4.;\n#define NL text.z=0.; text.y-=9.0;\n\nvec2 pixel;\nvec4 text;//x y index result\nfloat ui = 0.0;\nvec4 result;    \n\nfloat char(int b1, int b2, int b3, int b4){\n  int bin; \n  vec2 p = pixel - text.xy - vec2(text.z, 0); \n  text.z += 9.0; \n  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n  p = floor(8.0-p);    int c = int(p.y / 2.0);\n  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}\n  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\nvoid digit(float d){\n    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4\n    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        \n}\nvoid drawNumber(float val, float fractPrecision){  \n    if(sign(val)==-1.0) MINUS //draw minus sign if needed\n    val = abs(val);    \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    // log10(val) = log(val)/2.302585    \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    val = floor(val); // strip the fractional part   \n    float count = intCount + fractPrecision; //totla number of digits to print    \n    if(count > 8.){ E R R O R return;} //show error if count > 8 \n    float pw = pow(10., count-1.);\n    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number\n        if(count<i){ continue;} //skip unnecessary loops\n        if(i-fractPrecision == 0.){STP} //draw decimal point        \n        float d = floor(val/pw); //get one digit\n        digit( d ); //draw digit\n        val -= d*pw; pw /= 10.; //prepare for next iteration\n    }\n}\n\n\nvoid newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}\nvoid moveCursor(in vec2 o){text.xy = o; text.z=0.0;}\nfloat outputText(){return text.w;}\n\nfloat printFloatCentered(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val, prec); return outputText();\n}\n\nfloat printFloat(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val, prec); return outputText();\n}\n\nfloat printVec2(vec2 val, float prec, vec2 p, vec2 o){ \n    newText(p, o);\n    float str = 0.0;\n    drawNumber(val.x, prec);\n    _ COM _\n    drawNumber(val.y, prec);    \n    str += outputText();    \n    return str;\n}\n\n\n\n// distance functions\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat fillMask(float dist){return clamp(-dist, 0.0, 1.0);}\n\n\n// read/write\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    \nvoid setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}\n\n//slider\nvoid drawSlider(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 5.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val,.4,0,1);\n        setPixel(vec2(id,1), data);\n    }    \n    \n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    ui = mix(ui, 0., printFloatCentered(data.r, 1., p, b.xy + vec2(8., 5.)));\n    text = tmp;\n}\n\n//boolean\nvoid drawBoolean(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy, b) <= gap && iMouse.w > 0.0){\n     //   float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x + b.z) - b.x;\n      //  data.r = round(distanceFromLeftEdege / b.z);        \n        //data.a=1.0;\n        data.r = round(1.0 - data.r);\n        setPixel(vec2(id, 1), data);\n        \n        b.w = 35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    moveCursor(b.xy + vec2(8., 5.));\n    if (data.r > 0.5) {\n        _T R U E\n    }\n    else {\n        _F A L S E\n    }\n    ui = mix(ui, 0., text.w);\n    text = tmp;\n}\n\n//chooser\nvoid drawChooser(int id, float val, inout float ui, vec2 p, vec4 b, int count){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    float increment = 1. / float(count);\n    moveCursor(b.xy + vec2(8., 5.));\n    if (data.r < 1. * increment) {\n        _R E C T A N G L E\n    }\n    else if (data.r < 2. * increment) {\n        _C I R C L E\n    } else {\n        _L I N E\n    }\n   \n    ui = mix(ui, 0., text.w);\n\n    text = tmp;\n}\n\n\n#define EASYSLIDER(id,val) drawSlider(id, val, ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYBOOLEAN(id,val) drawBoolean(id, round(val), ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYCHOOSER(id,val,count) drawChooser(id, val, ui, pixel, bounds, count); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p = fragCoord.xy;\n    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);\n    newText(p,vec2(0)); //for labels\n    \n    //define sliders    \n    EASYCHOOSER(1,0.0,3)  _S H A P E      \n    EASYSLIDER(0,0.5)  _W O B B L E  \n//    EASYSLIDER(2,0.75)  _A N G L E   \n          \n    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders\n    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels\n    \n    \n    fragColor=result;    \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtKfWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[444, 455, 487, 487, 576], [577, 577, 606, 606, 684], [686, 686, 743, 743, 960], [962, 962, 1004, 1004, 1487], [1489, 1489, 1530, 1530, 1598], [1600, 1600, 1641, 1641, 1796], [1798, 1798, 1853, 1853, 3854]], "test": "untested"}
{"id": "mlKfDR", "name": "raymarcher example", "author": "LuckyLMJ", "description": "raymarcher example\nwith shadows, diffuse lighting, and object colouring", "tags": ["raymarcher"], "likes": 1, "viewed": 21, "published": 3, "date": "1701995266", "time_retrieved": "2024-07-30T17:18:00.578263", "image_code": "//constants\n#define MAX_DISTANCE 100\n#define MAX_STEPS 1000\n\n#define AMBIENT 0.25\n\n//shader values\nvec3 cameraPosition = vec3(0, 0, -20);\nvec3 cameraDirection = vec3(0, 0, 0);\n\n//this is a vector of where the light is coming from. \n//this is normalized later (made into a 1-length vector)\nvec3 lightDirection = vec3(1, 1.5, 0);\n\n//rotates a point p by angles a\n//angles are in radians\nvec3 rotatePoint(vec3 p, vec3 a) {\n    a = a.yxz;\n\n    p.yz = vec2(\n        p.y*cos(a.y) + p.z*sin(a.y),\n       -p.y*sin(a.y) + p.z*cos(a.y)\n    );\n    p.xz = vec2(\n        p.x*cos(a.x) + p.z*sin(a.x),\n      -(p.x*sin(a.x) - p.z*cos(a.x))\n    );\n    p.xy = vec2(\n        p.x*cos(a.z) - p.y*sin(a.z),\n        p.x*sin(a.z) + p.y*cos(a.z)\n    );\n    \n    return p;\n}\n\n//Gets the signed distance from point p to the surface of a sphere at point sp with radius r\nfloat sphereSDF(vec3 p, vec3 sp, float r) {\n    return distance(p, sp) - r;\n}\n\n//gets the signed distance from point p to the surface of a box at sp with size b\nfloat boxSDF(vec3 p, vec3 sp, vec3 b){\n  vec3 q = abs(p-sp) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//more SDFs can be found at https://iquilezles.org/articles/distfunctions/\n\n//gets the distance to the closest object in the scene from a point p\nfloat map(vec3 p) {\n    float dist = float(MAX_DISTANCE);\n    \n    //a ground plane\n    \n    dist = p.y + 4.0;\n    \n    //two spheres\n    //one bobs up and down\n    dist = min(dist, sphereSDF(p, vec3(0, -1, 0), 3.0));\n    dist = min(dist, sphereSDF(p, vec3(7, 3.0 + sin(iTime*3.0), 3), 2.0));\n    \n    //a cube\n    dist = min(dist, boxSDF(p, vec3(4, -3, -4), vec3(1, 1, 1)));\n    \n    //a wacky cube with a cutout sphere in it\n    dist = min(dist, max(\n        boxSDF(p, vec3(-3, 0, 5), vec3(1, 1, 1)),\n        -sphereSDF(p, vec3(-3, 0, 5), 1.3)\n    ));\n    \n    //an intersection of two spheres\n    dist = min(dist, max(\n        sphereSDF(p, vec3(3, -3, 5), 1.0),\n        sphereSDF(p, vec3(3, -2, 5), 1.0)\n    ));\n    \n    return dist;\n}\n\nvec3 getColour(vec3 p) {\n    vec3 colour = vec3(1);\n    if (p.y + 4.0 < 1e-4) {\n        //checkerboard pattern on the floor\n        vec3 fp = floor(p);\n        colour = vec3(mod(fp.x + fp.y + fp.z, 2.f)) + vec3(0.5f);\n    } else if (sphereSDF(p, vec3(0, -1, 0), 3.0) < 1e-4) {\n        colour = vec3(1, 0, 0);\n    } else if (sphereSDF(p, vec3(7, 3.0 + sin(iTime*3.0), 3), 2.0) < 1e-4) {\n        colour = vec3(1, 0, 1);\n    } else if (boxSDF(p, vec3(4, -3, -4), vec3(1, 1, 1)) < 1e-4) {\n        colour = vec3(1, 0.5, 0);\n    } else if (max(\n      boxSDF(p, vec3(-3, 0, 5), vec3(1, 1, 1)),\n      -sphereSDF(p, vec3(-3, 0, 5), 1.3)) < 1e-4) {\n        colour = vec3(0, 1, 0);\n    } else if (max(\n      sphereSDF(p, vec3(3, -3, 5), 1.0),\n      sphereSDF(p, vec3(3, -2, 5), 1.0)) < 1e-4) {\n        colour = vec3(0.5, 0.6, 1);\n    }\n    \n    return colour;\n}\n\n//gets the normal at a point\n//required for nice smooth lighting\nvec3 getNormal(vec3 p) {\n    const vec2 h = vec2(1e-5, 0);\n    float mapP = map(p);\n    return normalize(vec3(\n        map(p+h.xyy) - mapP,\n        map(p+h.yxy) - mapP,\n        map(p+h.yyx) - mapP\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //normalized screen coordinate, (-1, -1) is bottom left, (1, 1) is top right\n    vec2 screenCoordinate = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    \n    //rotate the light\n    lightDirection = rotatePoint(lightDirection, vec3(0, iTime, 0));\n    lightDirection = normalize(lightDirection); //makes the light direction a unit vector\n    \n    \n    //rotate the camera\n    cameraDirection = vec3(0, -iTime * 0.1, 0);\n    \n    //move the camera\n    cameraPosition = rotatePoint(cameraPosition, cameraDirection);\n    \n    //where the fragment's ray is facing. this is a vector direction\n    vec3 rayDirection = rotatePoint(\n        normalize(vec3(screenCoordinate, 1.5)),\n        cameraDirection\n    );\n    \n    //actual raymarching\n    float t = 0.0; //total distance traveled\n    vec3 colour = vec3(0, 0, 0);\n    \n    float light = 1.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = map(cameraPosition + t*rayDirection);\n        t += dist;\n        \n        //check if we hit an object\n        if (dist < 1e-5) {\n            //get diffuse lighting\n            vec3 normal = getNormal(cameraPosition + t*rayDirection);\n            light = max(dot(normal, lightDirection), 0.0);\n            light = (light * (1.0-AMBIENT)) + AMBIENT; //ambient lighting\n            \n            //cast shadow\n            float shadowT = 0.0;\n            vec3 shadowBaseP = (cameraPosition + (t-1e-3)*rayDirection);\n            for (int j = 0; j < MAX_STEPS; j++) {\n                float dist = map(shadowBaseP + shadowT*lightDirection);\n                shadowT += dist;\n                if (dist < 1e-5) { //in shadow \n                    light = AMBIENT;\n                    break;\n                }\n                if (shadowT > float(MAX_DISTANCE)) {\n                    break;\n                }\n            }\n            \n            light *= 1.0-(t / float(MAX_DISTANCE)); //add a depth fog effect\n            \n            //get the colour\n            colour = getColour(cameraPosition + t*rayDirection);\n            //colour = (normal + 1.0) / 2.0; //this will show the normals of the objects\n            \n            break;\n        }\n        //check if we've gone outside of the maximum distance\n        if (t > float(MAX_DISTANCE)) {\n            break;\n        }\n    }\n    \n    //Output to the screen\n    fragColor = vec4(colour, 1);\n    fragColor.rgb *= light;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlKfDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[329, 385, 419, 419, 748], [750, 843, 886, 886, 920], [922, 1004, 1042, 1042, 1132], [1210, 1280, 1299, 1299, 2018], [2020, 2020, 2044, 2044, 2870], [2872, 2937, 2961, 2961, 3143], [3145, 3145, 3202, 3283, 5583]], "test": "untested"}
{"id": "mlGBRm", "name": "Orthogonal Spheres Flower (iter)", "author": "Real_NC", "description": "based on https://www.shadertoy.com/view/clGBzm", "tags": ["raymarching", "math", "sdf", "sphere", "tracing", "iterative"], "likes": 15, "viewed": 187, "published": 3, "date": "1701984534", "time_retrieved": "2024-07-30T17:18:01.469879", "image_code": "#define LAYERS\n\n#define EPS 0.001\n\n// the basis here is that the two spheres always intersect at a ring. We can use the ring to create a correct sdf exterior\nfloat sdDoubleSphere(vec3 p, vec4 s1, vec4 s2) \n{\n    float d1 = abs(distance(p, s1.xyz) - s1.w);\n    //float d2 = max(d1, s2.w - distance(p, s2.xyz)); // this gives us the correct shape but without the rounded edge.\n    float d2 = distance(p, s2.xyz) - s2.w;\n    \n    float ringX = 0.5*(s1.w*s1.w - s2.w*s2.w)/distance(s1.xyz, s2.xyz) - 0.5*distance(s1.xyz, s2.xyz);\n    vec3 ringPos = s2.xyz + normalize(s2.xyz - s1.xyz)*ringX;\n    float ringRad = sqrt(s1.w*s1.w - dot(s1.xyz - ringPos, s1.xyz - ringPos));\n    \n    vec3 tnorm = normalize(s2.rgb - s1.rgb);\n    vec3 p2 = p + tnorm*dot(ringPos.xyz - p, tnorm);\n    p2 = normalize(p2 - ringPos)*(ringRad) + ringPos;\n    \n    vec3 closests1 = normalize(p - s1.xyz) * s1.w;\n    \n    //return max(d1,d2); // shape debugger\n    if (dot(p2 - s2.xyz, p - p2) < 0.0 ) return d1;\n    return distance(p, p2);\n}\n\nfloat sdFlower(vec3 p)\n{\n    p.x = abs(p.x);\n    float d = length(p);\n    float r = 1.0;\n    for(r; r <= 20.0; r *= 2.0)\n    {\n        \n        d = min(d, sdDoubleSphere(p, vec4(r,0,0,r), vec4(0,4,0,4)));\n    }\n    \n    return d;\n    \n}\n\nfloat map(vec3 p)\n{\n    return sdFlower(p + vec3(0,4,0)) - 0.1;\n}\n\nvec3 normal(vec3 p) // tetrahedral SDF normal\n{\n    vec2 q = vec2(EPS,0);\n    return normalize(vec3(\n    map(p + q.xyy) - map(p - q.xyy),\n    map(p + q.yxy) - map(p - q.yxy),\n    map(p + q.yyx) - map(p - q.yyx)\n    ));\n}\n\nfloat checker(vec3 p)\n{\n    //p.xz = vec2(atan(p.x,p.z)*1.27323954474, length(p.xz)); // magic number is 8/tau\n    p = fract(p) - 0.5;\n    return 0.6 + 0.4 * sign(p.x*p.y*p.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0,0,-14);\n    vec3 rd = normalize(vec3(uv,1.7));\n    \n    float yaw = iTime;\n    if(iMouse.z > 0.) yaw = iMouse.x/iResolution.x*6.28 - 3.14;\n    float pitch = iMouse.y/iResolution.y*3.14 - 1.57;\n    mat2 rot = mat2(cos(yaw), sin(yaw),\n                    sin(yaw), -cos(yaw));\n    \n    mat2 rotp = mat2(cos(pitch), -sin(pitch),\n                     sin(pitch), cos(pitch));\n    \n    rd.zy = -(-rd.zy*rotp);\n    ro.zy *= rotp;\n    \n    rd.xz = -(-rd.xz*rot);\n    ro.xz *= rot;\n    \n    float d = 9.; // do not increase this past 10, otherwise it brokie\n    for(int i = 0; i <= 200; i++)\n    {\n        if (map(ro + rd*d) < EPS) break;\n        d += map(ro + rd*d);\n        if (d >= 18.1) \n        {\n            d = -1.0;\n            break;\n        }\n    }\n    vec3 ri = ro + rd*d;\n    fragColor = vec4(0);\n    \n    fragColor.rgb = vec3(checker(ri*1.));\n    \n    vec3 norm = normal(ri);\n    vec3 light = normalize(vec3(1,1,-1));\n    fragColor *= 0.5 + 0.5 * dot(norm, light);\n    fragColor *= 0.6;\n    fragColor += pow(max(dot(reflect(rd, norm), light), 0.), 28.0); // add specular\n    \n    if(d <= 0.) fragColor *= 0.;\n    \n    vec3 ps = ro - rd*dot(rd, ro);\n    float ds = -dot(rd,ro) - sqrt(16.0 - dot(ps,ps));\n    ri = ro + rd*ds;\n    \n    float sphereMesh;\n    if(dot(ps, ps) <= 16.0)\n    {\n        float d2 = -dot(rd + rd, ro) - ds; // backface distance\n        vec3 ri2 = ro + rd*d2;\n        if(d <= 0.|| d2 < d)\n        {\n            vec3 ri2 = ro + rd*(-dot(rd + rd, ro) - ds);\n            sphereMesh = smoothstep(0.15,0.1,length(ri2.xz)*abs(fract(atan(ri2.x, ri2.z)*4.77464829276)-0.5));\n            sphereMesh = mix(sphereMesh,1.0, smoothstep(0.15, 0.1, 3.14*abs(fract(acos(ri2.y/4.0)*4.77464829276)-0.5)));\n            fragColor = mix(fragColor, vec4(0.6,0.2,0.1,1), sphereMesh*0.4);\n        }\n    \n        sphereMesh = smoothstep(0.15,0.1,length(ri.xz)*abs(fract(atan(ri.x, ri.z)*4.77464829276)-0.5));\n        sphereMesh = mix(sphereMesh,1.0, smoothstep(0.15, 0.1, 3.14*abs(fract(acos(ri.y/4.0)*4.77464829276)-0.5)));\n        \n        if(ds < d || d <= 0.) fragColor = mix(fragColor, vec4(0.8,0,0,1), sphereMesh*0.4);\n    }\n    \n    fragColor = pow(fragColor, vec4(1./2.2));\n    /*\n    uv *= 12.0;\n    uv.y += 4.0;\n    float dist = map(vec3(uv, 0)) - 0.1;\n    fragColor = vec4(0.8+0.2*sin(dist*30.))*vec4(1,0.5,0,1);\n    if(dist <= 0.0) fragColor = 0.7 - 0.7*fragColor;\n    fragColor = mix(fragColor, vec4(0.5,0.5,1,1), .01/(dist*dist + .01));\n    */\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlGBRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 158, 207, 207, 1009], [1011, 1011, 1035, 1035, 1247], [1249, 1249, 1268, 1268, 1314], [1316, 1316, 1363, 1363, 1536], [1538, 1538, 1561, 1648, 1716], [1718, 1718, 1775, 1775, 4323]], "test": "untested"}
{"id": "dlGfDz", "name": "Sum Tetrabrot III 2Ì¶7Ì¶7Ì¶ 275", "author": "domrally", "description": "[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]", "tags": ["fractal", "mandelbrot", "orbit", "trap", "short", "tweet", "golf", "tetration", "hyperoperation", "tetrate"], "likes": 8, "viewed": 173, "published": 3, "date": "1701983833", "time_retrieved": "2024-07-30T17:18:02.367479", "image_code": "/*\n275 characters by Dom Mandy in 2023\n*/\nvoid mainImage(out vec4 P, vec2 V) {\n    float a, c, k, v, r = 9.;\n    vec2 R = iResolution.xy,\n         C = V + V - R;\n\n    for (V = C /= R.y; k++ < 99.; V = C + exp(-a * V.y) * pow(v, V.r / 2.) * vec2(cos(c), sin(c)))\n        c = dot(V, vec2(a = atan(V.y, V.x), log(v = dot(V, V)) / 2.)),\n        r > v ? r = v, R = V : R;\n\n    P = isnan(v) ? P : sqrt(r + r * cos(atan(R.y, R.x) - vec4(0, 2, 4, 0)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlGfDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 42, 78, 78, 446]], "test": "untested"}
{"id": "DlVfWR", "name": "Math Visualizer", "author": "rafa_br34", "description": "Something that you can view formulas on, just like a graphing calculator but more interesting(and much more useless).\nKeybinds:\n V/B: Set antialiasing mode(x1, x2, x4, x8, x16, x32)\n Z/X: Zoom +/-\n Q/E: Change view\n Space: Reset view\n WASD: Move camera", "tags": ["fractal", "math", "interactive", "visualization"], "likes": 1, "viewed": 176, "published": 3, "date": "1701982840", "time_retrieved": "2024-07-30T17:18:03.154375", "image_code": "float Function(in vec2 Coord) {\n    float X = Coord.x, Y = Coord.y;\n    uint ID = RESX * uint(Y) + uint(X) + 1u;\n    \n    // Use any formula/algorithm that you'd like.\n    \n    //return (sin(X) + cos(Y)) * tan(X * Y);\n    //return (sinh(X) * cosh(Y)) / (sqrt(X) * sqrt(X + Y));\n    //return (sin(X) * cos(Y)) * sqrt(Y);\n    //return (sin(X) * cos(Y)) * sqrt(Y*cos(X));\n    //return (sin(X) + cos(Y)) * sqrt(sin(Y)*cos(X));\n    //return (sin(X) + cos(Y)) / sqrt(sin(Y)*cos(X));\n    return (sin(X) + cos(Y)) * sqrt(sin(Y)*cos(X)) * (tanh(Y) * tan(X));\n    //return float(int(X) % int(Y));\n    //return pow(X + 1.0, X)/Y;\n}\n\n\nvec3 ToColor(in float V, in uint T) {\n    int Multiplier = (int[](\n        0x300,\n        0x600,\n        0xFFFFFF,\n        0xFFFFFF,\n        0xFFFFFF\n    ))[T];\n    \n    int VI = int(V * float(Multiplier)) % Multiplier;\n    \n    #define U24ToRGB(A) vec3(FUI8((A >> 0) & 0xFF), FUI8((A >> 8) & 0xFF), FUI8((A >> 16) & 0xFF))\n    switch (T) {\n        case 0u:\n            return vec3(\n                FUI8(int(VI < 256) * VI),\n                FUI8(int(VI >= 256 && VI < 512) * (VI - 256)),\n                FUI8(int(VI >= 512 && VI < 768) * (VI - 512))\n            );\n            \n        case 1u:\n            if (VI < 768) {\n                return vec3(\n                    FUI8(int(VI < 256) * VI),\n                    FUI8(int(VI >= 256 && VI < 512) * (VI - 256)),\n                    FUI8(int(VI >= 512 && VI < 768) * (VI - 512))\n                );\n            }\n            else {\n                VI -= 768;\n                return vec3(\n                    FUI8(255 - int(VI < 256) * VI),\n                    FUI8(255 - int(VI >= 256 && VI < 512) * (VI - 256)),\n                    FUI8(255 - int(VI >= 512 && VI < 768) * (VI - 512))\n                );\n            }\n\n        case 2u:\n            return U24ToRGB(VI);\n            \n        case 3u:\n            return vec3(FUI8((VI*VI*0xFFF) >> 16), FUI8((VI*VI*0xFF) >> 8), FUI8((VI*VI*0xF) >> 0));\n        case 4u:\n            VI = ((VI >> 16) & 0xFF) + 5381;\n            VI = ((VI >> 8) & 0xFF) + (VI * 33);\n            VI = ((VI >> 0) & 0xFF) + (VI * 33);\n            return U24ToRGB(VI);\n    }\n}\n\n\n\nvoid mainImage(out vec4 FragColor, in vec2 FragCoord) {\n    Config C = ParseConfig(READP_V4(C_Storage, vec2(0, 0)));\n    \n    vec2 Ratio = vec2(\n        (RESY > RESX) ? float(RESY) / float(RESX) : 1.0,\n        (RESX > RESY) ? float(RESX) / float(RESY) : 1.0\n    );\n    \n    vec2 UV = (FragCoord / iResolution.xy) - vec2(0.5, 0.5);\n    vec2 PixelSize = 1.0 / iResolution.xy;\n    float Samples = pow(2.0, float(C.AA) * 2.0);\n    \n    \n    if (C.AA == 0u)\n        FragColor = vec4(ToColor(Function(((UV / vec2(C.Zoom)) / Ratio) + C.Offset), C.Mode), 1.0);\n    else {\n        vec3 Color = vec3(0.0);\n        \n        float R = 1.0 / sqrt(Samples);\n        \n        for (float X = -0.5; X < 0.5; X+=R)\n            for (float Y = -0.5; Y < 0.5; Y+=R)\n                Color += ToColor(Function((((UV + (PixelSize * vec2(X, Y))) / vec2(C.Zoom)) / Ratio) + C.Offset), C.Mode);\n            \n        FragColor = vec4(Color / float(Samples), 1.0);\n    }\n    \n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define C_Storage iChannel0\n#define C_Keyboard iChannel3\n\n#define RESX uint(iResolution.x)\n#define RESY uint(iResolution.y)\n\n#define READP_V4(Buffer, Position) texelFetch(Buffer, ivec2(Position), 0)\n\n#define RAND_STATE(Coord) ((RESX * uint(Coord.y) + uint(Coord.x) + 1u) * uint(iFrame))\n\n#define UI8(V) uint(int(V) % 256)\n#define FUI8(V) float(UI8(V)) / 255.0\n\n\nstruct Config {\n    vec2 Offset;\n    float Zoom;\n    uint Mode;\n    uint AA;\n};\n\nConfig ParseConfig(in vec4 Data) {\n    Config NC;\n    NC.Offset = Data.xy;\n    NC.Zoom = Data.z > 0.0 ? Data.z : 1.0;\n    NC.Mode = uint(Data.w) & 0xFFu;\n    NC.AA = (uint(Data.w) >> 8) & 0xFFu;\n    \n    return NC;\n}\n\nvec4 SetConfig(in Config Data) {\n    return vec4(Data.Offset, Data.Zoom, float(Data.Mode + (Data.AA << 8)));\n}\n", "buffer_a_code": "void mainImage(out vec4 FragColor, in vec2 FragCoord) {\n    Config C = ParseConfig(READP_V4(C_Storage, vec2(0, 0)));\n    \n    // Initial config\n    if (iFrame == 0) {\n        C.AA = 2u;\n        C.Mode = 1u;\n        C.Zoom = 0.1;\n        C.Offset = vec2(0.0);\n    }\n    \n    // Keycode Space\n    if (READP_V4(C_Keyboard, ivec2(32, 1)).x > 0.0) { C.Offset = vec2(0.0, 0.0); C.Zoom = 0.1; }\n    \n    // Keycode Q\n    if (C.Mode > 0u && READP_V4(C_Keyboard, ivec2(81, 1)).x > 0.0)\n        C.Mode--;\n        \n    // Keycode E\n    if (C.Mode < 4u && READP_V4(C_Keyboard, ivec2(69, 1)).x > 0.0)\n        C.Mode++;\n    \n    \n    // Keycode V\n    if (C.AA > 0u && READP_V4(C_Keyboard, ivec2(86, 1)).x > 0.0)\n        C.AA--;\n    \n    // Keycode B\n    if (C.AA < 4u && READP_V4(C_Keyboard, ivec2(66, 1)).x > 0.0)\n        C.AA++;\n\n    \n    float ZoomDelta = C.Zoom / 2.0;\n    float CameraDelta = 0.25 / ZoomDelta;\n    float Multiplier = float(iTimeDelta);\n    \n    float Zoom = ZoomDelta * Multiplier;\n    // Keycode Z\n    if (READP_V4(C_Keyboard, ivec2(90, 0)).x > 0.0)\n        C.Zoom += Zoom;\n        \n    // Keycode X\n    if (READP_V4(C_Keyboard, ivec2(88, 0)).x > 0.0)\n        C.Zoom -= Zoom;\n    \n    \n    float Camera = CameraDelta * Multiplier;\n    // Keycode W\n    if (READP_V4(C_Keyboard, ivec2(87, 0)).x > 0.0)\n        C.Offset.y += Camera;\n    \n    // Keycode S\n    if (READP_V4(C_Keyboard, ivec2(83, 0)).x > 0.0)\n        C.Offset.y -= Camera;\n        \n    // Keycode D\n    if (READP_V4(C_Keyboard, ivec2(68, 0)).x > 0.0)\n        C.Offset.x += Camera;\n    \n    // Keycode A\n    if (READP_V4(C_Keyboard, ivec2(65, 0)).x > 0.0)\n        C.Offset.x -= Camera;\n\n        \n    FragColor = SetConfig(C);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlVfWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 620], [2178, 2178, 2233, 2233, 3127]], "test": "untested"}
{"id": "dltfWX", "name": "Lagrange Projection", "author": "mla", "description": "Combining Mercator and complex atan gives a nice conformal projection of the entire globe (failing only at the two poles). Apparently first described by Lambert in 1772 and further developed by Lagrange.\n\nMouse to move centre of projection.", "tags": ["projection", "conformal", "lagrange"], "likes": 21, "viewed": 337, "published": 3, "date": "1701979493", "time_retrieved": "2024-07-30T17:18:04.476840", "image_code": "// Lagrange Projection, mla, 2023.\n// Combining Mercator and complex atan gives a nice conformal\n// projection of the entire globe (failing only at the two poles).\n// Apparently first described by Lambert in 1772 and further\n// developed by Lagrange and named after him (the Lambert projection\n// is different).\n//\n// <mouse>: move centre of projection.\n// a: morph between Lagrange and Mercator\n// c: don't clip to sphere\n// m: fix mouse action\n// x: use cubemap\n// g: grid lines\n// z: zoom in\n\nvec3 sphere(float phi, float lambda) {\n  float y = sin(phi);\n  float x = cos(phi)*cos(lambda);\n  float z = cos(phi)*sin(lambda);\n  return vec3(x,y,z);\n}\n\nvec3 getcol(vec2 z) {\n  float phi = z.y, lambda = z.x;\n  vec3 p = sphere(phi,lambda);\n  float width = float(WIDTH);\n  float height = float(HEIGHT);\n  if (width <= iResolution.x) p.zx = rotate(p.zx,0.1*PI*iTime);\n  if (key(CHAR_M) || iMouse.z > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  vec3 col;\n  lambda = atan(p.z,p.x);\n  phi = asin(p.y);\n  if (key(CHAR_X)) {\n    col = texture(iChannel1,p).xyz; // Cubemap\n    col = pow(col,vec3(2.2));\n    //col = texture(iChannel0,vec2(0.5+lambda/TWOPI,0.5+phi/PI)).xyz;\n  } else {\n    float u = 0.5+lambda/TWOPI;\n    float v = 0.5+phi/PI;\n    v = 1.0-v;\n    u *= width/iResolution.x;\n    v *= height/iResolution.y;\n    col = (texture(iChannel2,vec2(u,v)).xyz);\n  }\n  if (!key(CHAR_G)) {\n    // Draw grid lines\n    phi *= 12.0/PI;\n    vec3 lcol = vec3(0);\n    // Avoid fwidth discontinuity at lambda = 2Ï\n    float px = abs(lambda) < 0.5*PI ? fwidth(lambda) : fwidth(mod(lambda,TWOPI));\n    float k = 12.0/PI;\n    lambda *= k, px *= k;\n    col = mix(lcol,col,0.5+0.5*smoothstep(0.0,px,abs(lambda-round(lambda))));\n    //if (round(phi) == 0.0) lcol = vec3(0.8,0,0);\n    col = mix(lcol,col,0.5+0.5*smoothstep(0.0,fwidth(phi),abs(phi-round(phi))));\n  }\n  return col;\n}\n\nvec2 catan(vec2 z) {\n  vec2 iz = vec2(-z.y,z.x);\n  vec2 t = clog(cdiv(vec2(1,0)-iz,vec2(1,0)+iz));\n  return 0.5*vec2(-t.y,t.x);\n}\n\nvec2 imercator(vec2 uv) {\n  float lam = uv.x, y = uv.y;\n  float phi = 2.0*atan(exp(y)) - 0.5*PI;\n  return vec2(lam, phi);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n    vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    if (key(CHAR_Z)) z *= 2.0;\n    vec2 z0 = z;\n    vec3 col = vec3(0);\n    z = catan(z);\n    if (key(CHAR_A)) z = mix(z0,z,0.5*cos(iTime)+0.5); // Image of disc is strip with Re(z) in Â±PI/4\n    //assert(abs(z.x) <= 0.25*PI);\n    z *= 4.0; // So put in range Â±PI\n    z = imercator(z);\n    float lam = z.x;\n    //assert(abs(z.x)<PI);\n    col = getcol(z);\n    if (!key(CHAR_C)) col *= 1.0-smoothstep(0.0,fwidth(lam),abs(lam)-PI);\n    col = pow(col,vec3(0.4545));\n    if (alert) col.r = 1.0;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "///////////////////////////////////////////////////////////////////////////////\n//\n// 16 color GIF, cropped, run length encoded and packed into an array of uvec4s\n// Upper 4 bits of each byte is the runlength-1 (we don't need 0 length runs,\n// obviously), lower 4 bits is the color index.\n//\n// Original image by NASA.\n//\n// Does basic coloring here rather than in Image tab to get the benefit\n// of texture filtering.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst uvec4 data[] = uvec4[](\nuvec4(0x2170f0f0u,0xf0f06110u,0xf130f0f0u,0xc0211071u),\nuvec4(0x00610061u,0x10512021u,0x00710061u,0x00610051u),\nuvec4(0xf1f1f1f1u,0x209100d1u,0xf1f16061u,0xf2f0f051u),\nuvec4(0x42713231u,0xf2317261u,0x00a2c332u,0x24f43012u),\nuvec4(0x21020130u,0x01208120u,0x01001110u,0x204120f0u),\nuvec4(0xf1f1f1f1u,0x05e10551u,0xb1f1f1f1u,0x506400f0u),\nuvec4(0x13721162u,0x81927312u,0xf0f01130u,0x001170f0u),\nuvec4(0xe2b0f001u,0x14f42200u,0x11022160u,0xa1f180f0u),\nuvec4(0xf1102110u,0x30611531u,0x30211001u,0x00110021u),\nuvec4(0xf1f13061u,0x110521f1u,0x31007115u,0x2220e460u),\nuvec4(0x21107103u,0x41400140u,0xf1201180u,0x0201c011u),\nuvec4(0x102460f0u,0x60f0f0e4u,0x000412d4u,0x01001102u),\nuvec4(0x102100f0u,0x20010081u,0x15917031u,0x30113021u),\nuvec4(0x30111041u,0x02410231u,0x13050243u,0x52210205u),\nuvec4(0x00310523u,0x10410021u,0x00111001u,0x9581f1f1u),\nuvec4(0x22010211u,0x0004f430u,0xf050f021u,0x0044b0f0u),\nuvec4(0x14f40074u,0x34008420u,0xf4107400u,0x0014d644u),\nuvec4(0xf0f02132u,0x61800130u,0x11001100u,0x32202100u),\nuvec4(0x02330100u,0x02130201u,0x05010541u,0x001120b1u),\nuvec4(0x00011001u,0x81f14061u,0x00b1f115u,0x32b18041u),\nuvec4(0x122400a4u,0x3040f001u,0x605400e4u,0xf0242034u),\nuvec4(0x10f46012u,0x64000234u,0xf4000460u,0xe0019294u),\nuvec4(0x512244f4u,0x01303100u,0x01221110u,0x05432223u),\nuvec4(0x21031501u,0x21005105u,0xe0f0f0f0u,0x25110001u),\nuvec4(0x10612501u,0x15610001u,0x00a10001u,0x50213001u),\nuvec4(0x22206432u,0xb050f001u,0x50120012u,0xd011a002u),\nuvec4(0x90114031u,0x00348012u,0x10041214u,0x14f42002u),\nuvec4(0xf624f416u,0x321416f6u,0x20110213u,0x10215011u),\nuvec4(0x10111221u,0xf0810001u,0xf0f0f0f0u,0x003100f0u),\nuvec4(0x40f001f1u,0x00240014u,0x12040012u,0xf0110410u),\nuvec4(0x00616060u,0x02610251u,0xf001e021u,0xa6b490f0u),\nuvec4(0x17e6f647u,0x97086706u,0x04064446u,0x03024031u),\nuvec4(0x12112322u,0x20510503u,0xf0f0f001u,0xf0f014a0u),\nuvec4(0x911001b0u,0x10f03100u,0xf012c034u,0x0150f070u),\nuvec4(0x010001c0u,0x11c01140u,0x200120f0u,0x0607d654u),\nuvec4(0x0a270927u,0x09170907u,0x29272917u,0x16173617u),\nuvec4(0x0b070b27u,0x47092b09u,0x07692718u,0x04863719u),\nuvec4(0x20021406u,0x90010311u,0x10020074u,0xf0010312u),\nuvec4(0xf6840004u,0xf4260496u,0xf0240064u,0x40150170u),\nuvec4(0xf034f001u,0xe0f080f0u,0x00f0f0c1u,0x0417b664u),\nuvec4(0x0907091bu,0x09470907u,0x08074907u,0x06274917u),\nuvec4(0x08173827u,0xca282a27u,0x0c290758u,0x270b0709u),\nuvec4(0x462a070bu,0x00212014u,0x36140001u,0x24302234u),\nuvec4(0x64062406u,0xd607e6f6u,0x0496f604u,0x10f03426u),\nuvec4(0x10f00123u,0x60f0f044u,0x00140004u,0x4001f004u),\nuvec4(0x01e0f001u,0x37f68480u,0x472b7708u,0x19171a18u),\nuvec4(0x570a0627u,0x3afafa08u,0x29070937u,0x20049637u),\nuvec4(0x34221001u,0xf6f62406u,0x04270486u,0xf6470426u),\nuvec4(0x566736f6u,0x70f0f024u,0x2480f0d4u,0x60f02400u),\nuvec4(0x21b0f011u,0x04b62480u,0x87260436u,0x47091709u),\nuvec4(0xfa569708u,0x4708dafau,0x014024c6u,0x14000223u),\nuvec4(0x670a5726u,0xf6f6f60au,0x670496f6u,0x2486070au),\nuvec4(0xf644d0f0u,0x34d05416u,0x40040044u,0x12141654u),\nuvec4(0xf0f00100u,0x07764440u,0x2b36040bu,0x170b1627u),\nuvec4(0x570b4716u,0x570a0809u,0x070a3604u,0x3afafafau),\nuvec4(0x0406f607u,0x161402b0u,0x47190b37u,0xf6f6f6f6u),\nuvec4(0x061726f6u,0xf0546667u,0x54f6f654u,0x14001400u),\nuvec4(0x20642400u,0x04035624u,0x14101412u,0xc0f00302u),\nuvec4(0x1b14a604u,0x04460b0du,0x0b070b16u,0x1b070604u),\nuvec4(0x16141617u,0x18270b27u,0x57361437u,0xeafafa08u),\nuvec4(0x4012e637u,0x12043001u,0x29172624u,0xf6271607u),\nuvec4(0xf6f6f6f6u,0x17060446u,0xf6f6d4e6u,0x703494d6u),\nuvec4(0x14060402u,0x02041206u,0x13240214u,0x4614b0f0u),\nuvec4(0x040d3b07u,0x07860407u,0x26277604u,0x29371607u),\nuvec4(0x47246627u,0x08bafafau,0xb6470819u,0x04803204u),\nuvec4(0x14023002u,0xf6f62716u,0xf60476f6u,0x1b4604c6u),\nuvec4(0x16171b07u,0x06f6f627u,0x36f6f60au,0x04002454u),\nuvec4(0x04365410u,0x00020402u,0x01030234u,0x561490f0u),\nuvec4(0x0b472b04u,0x071b1627u,0x1b060706u,0x17160b47u),\nuvec4(0x37163706u,0xc6042706u,0xfa273427u,0x1a183afau),\nuvec4(0x14862709u,0x00210223u,0x40026011u,0xf6f6f624u),\nuvec4(0x57260a16u,0x0b27a6f6u,0x2b0d1b17u,0x47080709u),\nuvec4(0xf6071b09u,0x060b3796u,0x46f6f607u,0x0406f624u),\nuvec4(0x03023420u,0xd604b0f0u,0x070b0d57u,0x040b070bu),\nuvec4(0x07260406u,0x0b06170bu,0x08170617u,0x0a173817u),\nuvec4(0x94460b17u,0xfa262436u,0x19074afau,0x040b070bu),\nuvec4(0x02230436u,0x22017001u,0x60011021u,0xc6f6f604u),\nuvec4(0x14271807u,0x1b2796f6u,0x1b470827u,0x0b270807u),\nuvec4(0x17290709u,0x0796f60bu,0x162b2d1bu,0x06f6f63bu),\nuvec4(0x122426f6u,0xc0f00103u,0x470b5604u,0x07c61466u),\nuvec4(0x37461726u,0x245004f4u,0xdafa0756u,0x09072937u),\nuvec4(0x13044607u,0x1001c002u,0x20221011u,0xa6f6f644u),\nuvec4(0xf6270907u,0x0d0b07c6u,0x18070847u,0x1b077b09u),\nuvec4(0x1a371b07u,0x07c63aa6u,0xf6f60a26u,0x2446f666u),\nuvec4(0x4604e0f0u,0x66970b07u,0x26070b17u,0x1b070b07u),\nuvec4(0x27080716u,0x09671826u,0x14508417u,0x17061426u),\nuvec4(0x3c07cafau,0x0436072bu,0x04000203u,0x011001a0u),\nuvec4(0x10011240u,0xa6f6f644u,0x170c0907u,0x0a070bd6u),\nuvec4(0x0d2b4776u,0x0d0b0d2bu,0x0d2b07ebu,0x2d26177bu),\nuvec4(0x1b07c62bu,0xf686f6f6u,0x60f01496u,0x0b074634u),\nuvec4(0x0b870997u,0x0d1b1607u,0x061b0d0bu,0x08173617u),\nuvec4(0x09070407u,0x26472908u,0x46148024u,0x9afa0817u),\nuvec4(0x090c0927u,0x02043627u,0xc0010014u,0xf6445062u),\nuvec4(0xc63786f6u,0x0b2d070au,0x1b160b16u,0x0d7b1704u),\nuvec4(0x0d4b3dcbu,0x1d1b0d2bu,0x260b3d7bu,0x061a160au),\nuvec4(0x474b071au,0xf6f60a06u,0x34c6f627u,0x47865490u),\nuvec4(0x07583716u,0x0d1b0d0bu,0x04071b46u,0x1b472637u),\nuvec4(0x09170957u,0x0406170bu,0x14402406u,0x0c1b1746u),\nuvec4(0x076afa08u,0x1b07090cu,0x02041627u,0x14104400u),\nuvec4(0x02000410u,0xb0014220u,0x66f6f614u,0x27090b04u),\nuvec4(0x0d0b07a6u,0x1d171d0bu,0x8b2d1b07u,0x4b1d2b0du),\nuvec4(0x58073b0du,0x09071b07u,0x0918278bu,0x070a0617u),\nuvec4(0xbd4b170bu,0xf6f6f60bu,0x2d2b0746u,0x2466472bu),\nuvec4(0x0a460406u,0x04360736u,0x57096746u,0x0a46071bu),\nuvec4(0x17180706u,0x09072b26u,0x0b070b27u,0x27195809u),\nuvec4(0x14101416u,0x070b2766u,0x1c175afau,0x0b17061bu),\nuvec4(0xa4000416u,0x11320302u,0x460420f0u,0x0486f697u),\nuvec4(0x96070b17u,0x1d1b1d0bu,0x0b2d0b0au,0xab1d0b1du),\nuvec4(0x17095b09u,0x0708c7a8u,0x27080719u,0x1d2b0d0bu),\nuvec4(0x2d0b7d3bu,0x070b4d1bu,0xf646f60au,0x2b0dbb26u),\nuvec4(0x0b275687u,0x07063b0du,0x0817760bu,0x0b071b47u),\nuvec4(0x1b1d0b07u,0x070b0716u,0x171b070bu,0x070b3746u),\nuvec4(0x38470b04u,0x24062719u,0x07461410u,0x0b070b09u),\nuvec4(0x07186afau,0x0709070au,0x00042604u,0x02040054u),\nuvec4(0x10020400u,0xf0110201u,0x07161410u,0x08270849u),\nuvec4(0x0a86f657u,0x160b0726u,0x0b071617u,0x0b0d1b0du),\nuvec4(0x2d1b0d0au,0x3d0b0d1bu,0x8889270bu,0x07091709u),\nuvec4(0x17188708u,0x170b0d0bu,0x07093729u,0x27080738u),\nuvec4(0x270b0d2bu,0x5d0b0d0bu,0x1706470bu,0x1b27061bu),\nuvec4(0xd6173617u,0xe8070817u,0x27296c09u,0x1b0d0b1du),\nuvec4(0x68170827u,0x0b071b27u,0x0b170b47u,0x3b160a27u),\nuvec4(0x170d0b06u,0x0807262bu,0x0a070b07u,0x17160706u),\nuvec4(0x0718071bu,0x1416170bu,0x14561410u,0x1afa0706u),\nuvec4(0x84172947u,0x04104402u,0x11100120u,0x041614d0u),\nuvec4(0x190c1917u,0x370b6748u,0x16070bc6u,0x0b271617u),\nuvec4(0x1b171b07u,0x0d0b0617u,0x170b0d0bu,0x0d4b0d5bu),\nuvec4(0x091b080bu,0x77c8197cu,0x0d0b1718u,0x1c09170bu),\nuvec4(0x09270809u,0x08092817u,0x1b1d7b07u,0x174d2b1du),\nuvec4(0x0d0b1749u,0x1959170bu,0x17a6071bu,0x17290b09u),\nuvec4(0x07399c19u,0x0d0c1948u,0xa817380bu,0x3b571637u),\nuvec4(0x2b070b27u,0x08170b17u,0x28170627u,0x0d0b3617u),\nuvec4(0x070b170bu,0x17090728u,0x07463426u,0x0afa170bu),\nuvec4(0x14071c09u,0x14020436u,0x64005426u,0x00643140u),\nuvec4(0x29074614u,0x0748090cu,0x27285748u,0x070b0d36u),\nuvec4(0x1d2b0716u,0x071b071bu,0x070b170bu,0x0b190708u),\nuvec4(0x160d1b1du,0x4b1d0b2du,0xb9172b07u,0x371807b8u),\nuvec4(0x071b2718u,0x092c0908u,0x49470908u,0x08074b07u),\nuvec4(0x4b0d6b07u,0x49270b0du,0x190c3937u,0x071b0927u),\nuvec4(0x0a56070bu,0x0d3b0716u,0x390c091bu,0x28372907u),\nuvec4(0x07093809u,0x1709172bu,0x27c80768u,0x0d6b2708u),\nuvec4(0x0b076809u,0x36170827u,0x0b1a0617u,0x18090b0du),\nuvec4(0x16170b27u,0x09072634u,0x08ba0817u,0x0d0c0907u),\nuvec4(0xc614660bu,0x30213054u,0x29075664u,0x5738090cu),\nuvec4(0x070b0728u,0x1708470bu,0x0b0d0a16u,0x2b070b17u),\nuvec4(0x2b270b0du,0x19271b07u,0x0d0b1d0bu,0x2b07060bu),\nuvec4(0x3b3d0b1du,0x0789470du,0x1b0768f8u,0x1c090807u),\nuvec4(0x17081729u,0x281c0918u,0x07091729u,0x170b074bu),\nuvec4(0x37081708u,0x07490708u,0x07392708u,0x1b271b07u),\nuvec4(0x260b0907u,0x070a1b17u,0x0b09073bu,0x09071827u),\nuvec4(0x28293847u,0x0b173809u,0x07380709u,0x17a80736u),\nuvec4(0x37180748u,0x0b182738u,0x072a5637u,0x0b093b0du),\nuvec4(0x040b2917u,0x07560406u,0x08090709u,0x0c0b279au),\nuvec4(0x3614660bu,0x26571617u,0x20040614u,0x76246011u),\nuvec4(0x17283907u,0x2728173bu,0x0d4b771bu,0x279b271bu),\nuvec4(0x1d3b3d1bu,0x2d1b0d3bu,0x28171d3bu,0x88076907u),\nuvec4(0x0d27b807u,0x1c09080bu,0x2c690829u,0x17390819u),\nuvec4(0x070b0d0bu,0x17083708u,0x59070819u,0x170b1918u),\nuvec4(0x1709070bu,0x06070607u,0x460b0927u,0x1b291b07u),\nuvec4(0x09072b18u,0x07290b17u,0x17392ce9u,0x07080709u),\nuvec4(0x28f80706u,0x0b0748a7u,0x560a1b07u,0x0a273b17u),\nuvec4(0x04060718u,0x06044617u,0x09071614u,0x178a0807u),\nuvec4(0x42043614u,0x0b173604u,0x09182917u,0x0204360bu),\nuvec4(0x24702200u,0x48390766u,0x0716070bu,0x3708171bu),\nuvec4(0x070a361bu,0x0d0b070bu,0x176b373bu,0x2b090709u),\nuvec4(0x2b2d3b2du,0x3b1d2b1du,0x08070b0du,0x39172807u),\nuvec4(0x1738f817u,0x0d0b0718u,0x2c090807u,0x1c094c99u),\nuvec4(0x07090c09u,0x1709171bu,0x17690738u,0x0d0b1d09u),\nuvec4(0x070b1d1bu,0x7617560bu,0x06070607u,0x18572b27u),\nuvec4(0x09071817u,0x29dc291cu,0x38f80718u,0x1b0d2b67u),\nuvec4(0x06171b07u,0x07090b0du,0x1726070bu,0x1758172bu),\nuvec4(0x07165456u,0x36177a19u,0x24203204u,0x18190746u),\nuvec4(0x00243637u,0x04700103u,0x07461400u,0x4829070bu),\nuvec4(0x060a0b07u,0x08371b07u,0x0b172b27u,0x5b0d0b07u),\nuvec4(0x0b072827u,0x0d0b0957u,0xeb1d0b17u,0x0b0d5b0du),\nuvec4(0x07396718u,0x87982738u,0x794c492bu,0x291c091cu),\nuvec4(0x07291857u,0x0d0b0779u,0x0b0d170bu,0x06070b1du),\nuvec4(0x36041786u,0x0a07160au,0x28372b07u,0x08096c09u),\nuvec4(0x08096ca9u,0x07580709u,0x2b2728f8u,0x17261b1du),\nuvec4(0x0b07061bu,0x04071607u,0x08170436u,0x26040937u),\nuvec4(0x02043024u,0x5a170604u,0x070b0907u,0x44502224u),\nuvec4(0x442b0736u,0x84201456u,0x07194726u,0x17090728u),\nuvec4(0x0b0d0b06u,0x0b0d3be7u,0x070908f7u,0x074b1d3bu),\nuvec4(0x175b072bu,0x68071d4bu,0x08070927u,0xc8070817u),\nuvec4(0x49372bb7u,0x290c392cu,0x0817390cu,0x0c190809u),\nuvec4(0x1b090759u,0x18070807u,0x0d0b0927u,0x0bf6060bu),\nuvec4(0x0b090b1du,0x08070b0du,0x2c090817u,0x09081c09u),\nuvec4(0x791c0908u,0x195c291cu,0x28175817u,0x2b27b817u),\nuvec4(0x1b86070du,0x07060416u,0x04260726u,0x12143657u),\nuvec4(0x12010220u,0x074a1706u,0x0204070bu,0x140094a0u),\nuvec4(0x56641002u,0x56140004u,0x28392c17u,0x07260b07u),\nuvec4(0x470bc70bu,0x0d0b070bu,0x1708d71bu,0x074b0d0bu),\nuvec4(0x071b57dbu,0x0708070bu,0x78f80718u,0x0b07a827u),\nuvec4(0x18270817u,0x290c294cu,0x1807290cu,0x07290c29u),\nuvec4(0x072b170bu,0x29072908u,0x5d07e647u,0x070b170bu),\nuvec4(0x091d0908u,0x1c0d0c1bu,0x0c0d0c09u,0x1c393c0du),\nuvec4(0x08096c19u,0x16570807u,0x0b27e817u,0x0604e60du),\nuvec4(0x0738070bu,0x04063466u,0x06028002u,0x08170a17u),\nuvec4(0x90120617u,0x00140244u,0x46546004u,0x66140204u),\nuvec4(0x38195c07u,0x0b36070bu,0x1b071b67u,0x0b070b07u),\nuvec4(0x09070b57u,0x2708b71bu,0x0d0b370bu,0x19971bfbu),\nuvec4(0xf8070807u,0x381728f8u,0x999c0927u,0x0706170cu),\nuvec4(0x07060719u,0x0c29171bu,0x02042709u,0xe6041604u),\nuvec4(0x370b3d07u,0x0c090708u,0x0c09170du,0x1c09070bu),\nuvec4(0x5c0d0c19u,0x1c190c09u,0x0c191c09u,0x28076809u),\nuvec4(0x0d27f807u,0x1b06f607u,0x86174807u,0x1402a002u),\nuvec4(0x070b270bu,0x34900204u,0x0654b012u,0x09079644u),\nuvec4(0x2817192cu,0x26070b07u,0x0d6b0d07u,0x1b0a060bu),\nuvec4(0x090897f7u,0x677bfb17u,0x0758070bu,0x0788f8f8u),\nuvec4(0x0c190708u,0x0c190c19u,0x0c090c79u,0x06074609u),\nuvec4(0x0b071b0au,0x041b1927u,0x04122302u,0x07c60402u),\nuvec4(0x070b0706u,0x2b09070bu,0x060b0917u,0x07090c0au),\nuvec4(0x370b0436u,0x290c0d3cu,0x0768591cu,0x1b0758f8u),\nuvec4(0x0706f60au,0x360b670du,0xd0042617u,0x070b1402u),\nuvec4(0x34900204u,0x0264a002u,0xb6240204u,0x390c0b07u),\nuvec4(0x1b170917u,0x1607061du,0x2b171637u,0xf7180b0du),\nuvec4(0x07090877u,0x67eb0d8bu,0x1738071bu,0x290718f8u),\nuvec4(0x07080718u,0x079908f8u,0x1b29072bu,0x09070a56u),\nuvec4(0x120b270bu,0x21030204u,0x02000240u,0x271ad614u),\nuvec4(0x160c073bu,0x040a1604u,0x04121123u,0x092c0716u),\nuvec4(0x092c191cu,0x1988091cu,0x07c81a48u,0x06f6070bu),\nuvec4(0x28270b0du,0x16070b07u,0x260b0917u,0x1204f004u),\nuvec4(0x12248001u,0x0746c490u,0x0b290786u,0x36072b57u),\nuvec4(0x47f7ab07u,0x17183718u,0xf877bbfbu,0x190c2948u),\nuvec4(0x07980958u,0x08290809u,0x37861719u,0x0b0c1746u),\nuvec4(0x03120706u,0x04020001u,0x10700102u,0x04030213u),\nuvec4(0x070d16f6u,0x060b170bu,0x1302060au,0x02015001u),\nuvec4(0x090b0714u,0x0d5c092cu,0x07a8090cu,0x0b1708f8u),\nuvec4(0x17f60a0du,0x170b2748u,0x16070918u,0x12e00204u),\nuvec4(0x90221490u,0x16340604u,0x07261014u,0x17a61706u),\nuvec4(0x370b2604u,0x0704460bu,0x07f78b06u,0x3718370bu),\nuvec4(0x17cb0738u,0xa77b071bu,0x0c5918f8u,0x17491cb9u),\nuvec4(0x16f60739u,0x09070b07u,0x0306070du,0x04021120u),\nuvec4(0x11307012u,0x1b07f602u,0x16170604u,0x05030d03u),\nuvec4(0x0b0704b0u,0x199c0b07u,0x88f81918u,0x072b0d17u),\nuvec4(0x076807d6u,0x16070958u,0xa021c004u,0x70011022u),\nuvec4(0x20032654u,0x29072604u,0x060a9607u,0x18170a1bu),\nuvec4(0x07060b09u,0x2b0d0716u,0x1b070b27u,0x0bb71807u),\nuvec4(0xbb2748b7u,0x0b070b77u,0x98071867u,0x0c195807u),\nuvec4(0x2c498c19u,0x08390c29u,0xd6070c09u,0x0b071614u),\nuvec4(0x0c090807u,0x20010217u,0x01031211u,0x02015070u),\nuvec4(0x76140203u,0x36071b17u,0x030e0d07u,0x40512005u),\nuvec4(0x17060402u,0x08099c09u,0x0768f829u,0x171b1708u),\nuvec4(0x1617762bu,0x58076807u,0x02360b07u,0x202100f0u),\nuvec4(0x00040214u,0x26646001u,0x04300304u,0x0b190726u),\nuvec4(0x061b0db6u,0x0b071b07u,0x1b0d2b46u,0x7b772857u),\nuvec4(0x48171b47u,0x1b271b37u,0x0b675b07u,0xc8074837u),\nuvec4(0x2c090819u,0x4c092c09u,0x0c290c29u,0x0c191c09u),\nuvec4(0xf6070c39u,0x070b1604u,0x032b1c19u,0x11001100u),\nuvec4(0x80800302u,0x27561211u,0x02160a06u,0x20050e13u),\nuvec4(0x60312011u,0x070b0604u,0x1c093c09u,0xf8091c09u),\nuvec4(0x37081788u,0x074b170bu,0xf817460bu,0x26070b07u),\nuvec4(0x2230f024u,0x22200160u,0x30222400u,0x96771604u),\nuvec4(0x171b071bu,0x2b0d0b66u,0x0bd73877u,0x28070b57u),\nuvec4(0x5bb70807u,0x28091897u,0x0829c807u,0x695c0709u),\nuvec4(0x095c7908u,0x76447607u,0x090c080bu,0x0d090c07u),\nuvec4(0x0114031eu,0x90030100u,0x00048001u,0x07161402u),\nuvec4(0x03020426u,0x05031e0du,0x21021501u,0x01701105u),\nuvec4(0x16070620u,0x08392c09u,0xf8491c09u,0x0d2b47a8u),\nuvec4(0x07060a0bu,0x47f8170bu,0x01300246u,0x12500150u),\nuvec4(0x31000160u,0x50121410u,0x162b1716u,0x76070b17u),\nuvec4(0x0b0d070au,0x07160b17u,0x274b270bu,0x57185708u),\nuvec4(0x1917f70bu,0x670b2718u,0x370b076bu,0x090c0748u),\nuvec4(0x2c191708u,0x07593819u,0x1c090c08u,0x273948e9u),\nuvec4(0x34001466u,0x0c090b56u,0x0b070907u,0x1e050e03u),\nuvec4(0x51050122u,0x01021413u,0x07061480u,0x4e03020bu),\nuvec4(0x00110503u,0x11100175u,0x17101160u,0x1c090706u),\nuvec4(0x0c0d1c59u,0x080af829u,0x27980a06u,0x070b263bu),\nuvec4(0x265718f8u,0x21200204u,0x01002140u,0x01502200u),\nuvec4(0x12202110u,0x46041100u,0x0d2b263bu,0x2d2b0756u),\nuvec4(0x170b0d2bu,0x0807f71bu,0x18870807u,0x28273b07u),\nuvec4(0x38473809u,0x38676b17u,0x28090c09u,0x2c0d1c09u),\nuvec4(0x07293809u,0x590c190au,0x0758390cu,0x09082918u),\nuvec4(0x070b190cu,0x0b06071bu,0x07368406u,0x07090c09u),\nuvec4(0x050e0302u,0x131e0110u,0x11200200u,0x02001100u),\nuvec4(0x06242001u,0x3e030224u,0x8511051fu,0x05010503u),\nuvec4(0xa0210503u,0x07160b02u,0x0c491c0bu,0x0c1d0c0du),\nuvec4(0xb81af829u,0x0b0d1b17u,0xf81b0a06u,0x04360b68u),\nuvec4(0x1302b130u,0x31021302u,0x13003120u,0x04160011u),\nuvec4(0x17163b26u,0x0d0b070bu,0x0b0a160bu,0x9b0d2b3du),\nuvec4(0x080708e7u,0x3b071877u,0x58170827u,0x68170807u),\nuvec4(0x18373b17u,0x4c294807u,0x0c1d1c19u,0x08092809u),\nuvec4(0xc91c0907u,0x19880908u,0x170b090cu,0x1b090d09u),\nuvec4(0x0716a407u,0x03020b19u,0x0103051eu,0x0f000500u),\nuvec4(0x0406131eu,0x00010002u,0x04021414u,0x0f5e2312u),\nuvec4(0x003155f5u,0x16028011u,0x0c1d0907u,0x292d2c39u),\nuvec4(0x2b27b8f8u,0x0b06070du,0x18096807u,0x56377817u),\nuvec4(0x10812002u,0x02031241u,0x00010061u,0x04012503u),\nuvec4(0x16040206u,0x0726170bu,0x070d2b09u,0x1d0b060au),\nuvec4(0x172b371bu,0x570bd70bu,0x074b8718u,0x0768372bu),\nuvec4(0x393857a8u,0x098c196cu,0x49f90708u,0x29280728u),\nuvec4(0x0b27090cu,0x070b170du,0x060406a4u,0x1e130709u),\nuvec4(0x0005032fu,0x032e2311u,0x06040302u,0x051fae04u),\nuvec4(0x952f350fu,0x0531250fu,0x04124071u,0x1d1c0706u),\nuvec4(0x0d0c0d5cu,0xd8f8190cu,0x3b070b07u,0x08078807u),\nuvec4(0x07061789u,0x3014460bu,0x25212531u,0x22010203u),\nuvec4(0x05210061u,0x0001050fu,0x66040012u,0x0b173b07u),\nuvec4(0x38170b1du,0x38273807u,0x0b273827u,0x1d3b0df7u),\nuvec4(0x2778270bu,0x093817c8u,0x2c0d4c0du,0x0c0d2c29u),\nuvec4(0x18895c09u,0x17180789u,0x09081918u,0x0b07090cu),\nuvec4(0x06171629u,0x0d0b16b4u,0x1f0e3f0eu,0x15130201u),\nuvec4(0x4f0e5e2fu,0x25cf0305u,0x650f451fu,0x00310001u),\nuvec4(0x00010011u,0x07121021u,0x0d0c0719u,0x0d2c091cu),\nuvec4(0x18190d0cu,0xf8090819u,0x07281a38u,0x17980708u),\nuvec4(0x27062728u,0x56172614u,0x10112004u,0x25012501u),\nuvec4(0x12030251u,0x45210541u,0x07d61402u,0x2728071bu),\nuvec4(0x09280728u,0x2b17c807u,0x0b170b87u,0x0b5d0b0du),\nuvec4(0xf8475817u,0x0d3c0928u,0x0d0c0d0cu,0x4c29ac39u),\nuvec4(0x28092819u,0x18373829u,0x0b0d0b29u,0x09161907u),\nuvec4(0x0274160bu,0x0d031604u,0x0e032f0eu,0x03050e1fu),\nuvec4(0x130f030eu,0x1f03350fu,0x0f031f23u,0x8f459f03u),\nuvec4(0x71150165u,0x20021012u,0x09070602u,0x899c0b07u),\nuvec4(0x78f80aa8u,0x16570817u,0x0b373607u,0x30042604u),\nuvec4(0x95110004u,0x02010501u,0x05511200u,0x14006501u),\nuvec4(0x2b270b96u,0x38171807u,0x59380907u,0x1b375807u),\nuvec4(0x1b370b37u,0x38070b9du,0x98271b17u,0x0c293839u),\nuvec4(0xbc093c3du,0x68294c29u,0x08175829u,0x071d1b19u),\nuvec4(0x070b1629u,0x03124416u,0x1d070402u,0x2f0e4f0eu),\nuvec4(0x1e03050eu,0x0e430e03u,0x15df231fu,0x008195cfu),\nuvec4(0x11000102u,0x09070620u,0x391c090bu,0x0ad8493cu),\nuvec4(0x07161748u,0x271817f8u,0x27081756u,0x0624460bu),\nuvec4(0x95010204u,0x75112241u,0x0433350fu,0x2b070b36u),\nuvec4(0x28170b17u,0x47294817u,0x090c071bu,0x471b8708u),\nuvec4(0x170b9d4bu,0x07080718u,0x2998072bu,0x09081918u),\nuvec4(0x09280a08u,0x290c2d0cu,0x393c299cu,0x58172968u),\nuvec4(0x0b1d1b17u,0x090c0907u,0x07060407u,0x22030416u),\nuvec4(0x04000203u,0x0e0d0402u,0x2e022e9fu,0x0f130e03u),\nuvec4(0x1f130e03u,0x05ffff0eu,0x2071351fu,0x06025001u),\nuvec4(0x090c091bu,0x494c0928u,0x160708f8u,0x19d8360au),\nuvec4(0x07081708u,0x0b07860bu,0x04560b07u,0x45011226u),\nuvec4(0x00110031u,0x55213201u,0x0433650fu,0x2b0d0b26u),\nuvec4(0x08071807u,0x1c190807u,0x37091c1du,0x0918071bu),\nuvec4(0x8b09070cu,0x1b0d2b17u,0x2bad0b07u,0xf8073b37u),\nuvec4(0x290c0908u,0x0908090cu,0x091c1d0cu,0x193c3d2cu),\nuvec4(0x0938791cu,0x3708091cu,0x084b1918u,0x06140729u),\nuvec4(0x02130407u,0x12000130u,0x6f150e0du,0x130e1f1eu),\nuvec4(0x2f0e0f2eu,0x1f1e032eu,0x65dfff0eu,0x40121081u),\nuvec4(0x091c1704u,0x495c2918u,0x28f81908u,0x38171817u),\nuvec4(0x071b1807u,0x172b1728u,0x14c61706u,0x11651302u),\nuvec4(0x11100115u,0x25310022u,0x0413c501u,0x071b0a06u),\nuvec4(0x3d090748u,0x090c1d0cu,0x09072b37u,0x2b071918u),\nuvec4(0x071d0b17u,0x0d0b0a06u,0x060b3d5bu,0x271b2d2au),\nuvec4(0x68471b06u,0x480a281au,0x1c28191cu,0x5c090c1du),\nuvec4(0x18993c1du,0x09670849u,0x19171b27u,0x16040207u),\nuvec4(0x40020407u,0x1e030214u,0x1e5f250fu,0x030f0e1fu),\nuvec4(0x5f1e0f0eu,0xff8e5f0eu,0x0031754fu,0x40024001u),\nuvec4(0x190b0706u,0x699c0918u,0x060708f8u,0x280a2618u),\nuvec4(0x070d2b07u,0x07091708u,0x073b071bu,0x030213c6u),\nuvec4(0x21650f05u,0x01220140u,0x0fc52100u,0x06040345u),\nuvec4(0x08070d07u,0x0d090829u,0x0d0b170cu,0x2709170bu),\nuvec4(0x0d49073bu,0x1a060d0bu,0x06071b07u,0x370b1d07u),\nuvec4(0x1b362d0bu,0x26072b1du,0x0a58373bu,0x0d0c0948u),\nuvec4(0x08090c09u,0x0c19180au,0x8c0d0c19u,0x290809f9u),\nuvec4(0x09085708u,0x1b070807u,0x020b1907u,0x16041604u),\nuvec4(0x04021002u,0x0d0b0406u,0x0f250f1eu,0x0f4e3f03u),\nuvec4(0x0f0e130eu,0xae1f5f1eu,0x21756fffu,0x06400170u),\nuvec4(0x5c090c17u,0x090d4c0du,0x07f8391cu,0x0a162806u),\nuvec4(0x17083728u,0x06042b19u,0x04070b07u,0x13020436u),\nuvec4(0x0a260402u,0x00010302u,0x11034501u,0x11100105u),\nuvec4(0x02212230u,0x13151321u,0x050f1315u,0x06113501u),\nuvec4(0x08071b07u,0x0c090c09u,0x0b09170du,0x060a0b0du),\nuvec4(0x19372907u,0x0b0d1b17u,0x04020416u,0x0b220b07u),\nuvec4(0x1d073817u,0x1d072607u,0x170b080bu,0x3b160a08u),\nuvec4(0x1d0ca837u,0x4978190cu,0xf95c090cu,0x08090c19u),\nuvec4(0x08191847u,0x030b1937u,0x06040200u,0x02040617u),\nuvec4(0x0e2d1604u,0x130e232fu,0x03055f3eu,0x1e030f0eu),\nuvec4(0x4e031e4fu,0x1e0f0e0fu,0x01456fffu,0x02606105u),\nuvec4(0x07061001u,0x0c290c09u,0x1c0d0c19u,0x2c0d1c09u),\nuvec4(0xf8090c19u,0x081a3816u,0x08171607u,0x070b1719u),\nuvec4(0x160b0726u,0x2314060au,0x02130102u,0x05110326u),\nuvec4(0x01007503u,0x42102110u,0x01030210u,0x00010305u),\nuvec4(0x04011543u,0x14270806u,0x28070b06u,0x070b0709u),\nuvec4(0x0706021du,0x07160719u,0x07491c09u,0x1204271bu),\nuvec4(0x04000110u,0x02000400u,0x071c0d0cu,0x0a1d0708u),\nuvec4(0x080b0716u,0x1b071817u,0x08372b07u,0x09580907u),\nuvec4(0x19081918u,0x090c2d1cu,0x08095c0du,0x1c090c49u),\nuvec4(0x0c790849u,0x18271819u,0x09071907u,0x19070b07u),\nuvec4(0x0102030bu,0x29060203u,0x0d040617u,0x8f150f1eu),\nuvec4(0x5f0e0f0eu,0x0f0e0305u,0x0e0f2e03u,0x0f7e0e0fu),\nuvec4(0x0e4f2e03u,0x758f134fu,0x10113091u,0x092c1906u),\nuvec4(0x390c090cu,0x07d8497cu,0x48073806u,0x17091807u),\nuvec4(0x0456070bu,0x01053312u,0x13120135u,0x00651f11u),\nuvec4(0x10310511u,0x01002132u,0x2f330513u,0x07041002u),\nuvec4(0x3c491c08u,0x12030407u,0x17061400u,0x0426070cu),\nuvec4(0x37391c09u,0x34200204u,0x2c2d1430u,0x04060a09u),\nuvec4(0x071b1706u,0x073b170bu,0x19380728u,0x091c190cu),\nuvec4(0x0d0c9d1cu,0x08070807u,0x0c090c09u,0x0c290c09u),\nuvec4(0x08092c09u,0x38090c99u,0x29380b07u,0x031b040bu),\nuvec4(0x04012002u,0x07090b07u,0x0e1d030bu,0x0eaf151fu),\nuvec4(0x03251f03u,0x0f0e0305u,0x1f1e5e13u,0x0f2e0f0eu),\nuvec4(0xaf0e0f0eu,0x7195af03u,0x06110230u,0xfc091c09u),\nuvec4(0x17b8491cu,0x0617180au,0x0709280au,0x2b070918u),\nuvec4(0x43060a26u,0x0f350f25u,0x00010315u,0x150f0501u),\nuvec4(0x1501451fu,0x22011011u,0x31002100u,0x1f050f33u),\nuvec4(0x07041205u,0x18192819u,0x30030b29u,0x07140b04u),\nuvec4(0x06170c09u,0x1c070604u,0x27091c09u,0x34373406u),\nuvec4(0x2c070600u,0x090d0c09u,0x17160406u,0x1d090708u),\nuvec4(0x0938373bu,0x2c3d1c6du,0x18490c29u,0x08292c09u),\nuvec4(0x0c390c59u,0x07193c29u,0x18070d0bu,0x030d0c29u),\nuvec4(0x04401112u,0x1e032407u,0x03052fffu,0x1f03053fu),\nuvec4(0x3f3e1f1eu,0xff0eaf2eu,0x0210a195u,0x0c090410u),\nuvec4(0x8c198c09u,0xb8278839u,0x071b2709u,0x4f451356u),\nuvec4(0x21052f05u,0x652f2510u,0x22011011u,0x01152100u),\nuvec4(0x04133f63u,0x69080907u,0x02030407u,0x07063004u),\nuvec4(0x07190b32u,0x0c070604u,0x072b0c09u,0x2c09470bu),\nuvec4(0x0d0b2729u,0x0c08092cu,0x3726090du,0x0708472bu),\nuvec4(0x180c0948u,0x3d0c0d0cu,0x8948190cu,0x290c893cu),\nuvec4(0x291c094cu,0x0b0d0b07u,0x032c2907u,0x07040280u),\nuvec4(0xff1e0314u,0x053f034fu,0x2f250e02u,0x1e1f1e2eu),\nuvec4(0x23bf5e4fu,0x0f03153fu,0x05131523u,0x65030513u),\nuvec4(0x07040001u,0x0dac090cu,0x98490d4cu,0x2709a827u),\nuvec4(0x060a0b0du,0x25230224u,0x110543bfu,0x11650f25u),\nuvec4(0x02000410u,0x05210214u,0x01051f93u,0x18192706u),\nuvec4(0x02071c09u,0x01040604u,0x0b070410u,0x04022103u),\nuvec4(0x0914021bu,0x0b07090cu,0x2c192716u,0x0c0d2c29u),\nuvec4(0x091d3c0du,0x1604071du,0x474b070bu,0x29181918u),\nuvec4(0x991c2d1cu,0x491c4948u,0x091c892cu,0x071b0d0bu),\nuvec4(0x1b090706u,0x030b1c09u,0x00122430u,0x04070914u),\nuvec4(0x7fff0e03u,0x0f3e0f0eu,0x2e1f5f15u,0x2f3e034fu),\nuvec4(0x030e3f13u,0x033e031eu,0x1305030fu,0x0021957fu),\nuvec4(0x0d090601u,0x4c091c09u,0x2c1d5c09u,0x68578829u),\nuvec4(0x0d0b0719u,0x2213160bu,0x35ff6501u,0x0503151fu),\nuvec4(0x20010503u,0x02142204u,0x03052100u,0x13055305u),\nuvec4(0x0b070405u,0x09180938u,0x04060407u,0x04100112u),\nuvec4(0x00020b07u,0x0b061211u,0x090c1412u,0x0706140bu),\nuvec4(0x2c096c99u,0x0b09070du,0x0b0a0614u,0x28375b0du),\nuvec4(0x1d0c5d09u,0x3c1918b9u,0x2c3d0c0du,0x2d0b2ca9u),\nuvec4(0x060a070bu,0x170b260bu,0x32101214u,0x1b071400u),\nuvec4(0xff0e0304u,0x1e23152fu,0x030f3e0fu,0x0e2f3f15u),\nuvec4(0x2e133f03u,0x130e332fu,0x0f3e030eu,0x0f030f1eu),\nuvec4(0x133f0305u,0x853f030fu,0x04010001u,0x090b0d07u),\nuvec4(0x4c0d6c0du,0xa8390c1du,0x0c074857u,0x06072b07u),\nuvec4(0x21000203u,0xff231f35u,0x0521352fu,0x12140011u),\nuvec4(0x05202204u,0x0e050f23u,0x01030f05u,0x04130503u),\nuvec4(0x09172807u,0x020b090cu,0x04025013u,0x030b4406u),\nuvec4(0x090c0732u,0x0b071407u,0x5c291c19u,0x090d2c19u),\nuvec4(0x0406072cu,0x0c180d26u,0x0d285709u,0xa96d0c19u),\nuvec4(0x096c2d1cu,0x291c1d0cu,0x190c590cu,0x0a072d0bu),\nuvec4(0x1b260a16u,0x00020419u,0x00031402u,0x0b090624u),\nuvec4(0x4f1e0406u,0x01058f2eu,0x0f130500u,0x0e032f03u),\nuvec4(0x0500052fu,0x0e331f2fu,0x0e0f0e23u,0x2e0f7e3fu),\nuvec4(0xa5bf235fu,0x09040100u,0x0d0c090bu,0x392c1dacu),\nuvec4(0x19484798u,0x070d0b17u,0x0002030au,0x4f250115u),\nuvec4(0x15df0315u,0x00014503u,0x32041011u,0x11233203u),\nuvec4(0x00031523u,0x01150302u,0x081b1704u,0x020b1c09u),\nuvec4(0x06442001u,0x0b172607u,0x00120103u,0x0b090203u),\nuvec4(0x06040604u,0x193c0907u,0x18090c1du,0x091d0c29u),\nuvec4(0x360b0d2cu,0x073c090du,0x2c2d0998u,0x2c491c1du),\nuvec4(0x0c0d8c0du,0x2c1d1c1du,0x0c192c09u,0x3d0b0c19u),\nuvec4(0x361b070bu,0x0207091bu,0x00120610u,0x19070406u),\nuvec4(0x0e030407u,0x555f2e5fu,0x1f030f13u,0x2f031f05u),\nuvec4(0x15010005u,0x0f250f0fu,0x2f030f03u,0x2fffff9eu),\nuvec4(0x02000145u,0x0d1b0904u,0x095c192cu,0x192c0d0cu),\nuvec4(0x07380748u,0x1938271bu,0x0d0b0718u,0x0003060bu),\nuvec4(0x453f1521u,0x03bf230fu,0x31050125u,0x11420410u),\nuvec4(0x33053302u,0x00050f0eu,0x04025302u,0x03121b06u),\nuvec4(0x39171402u,0x0b170907u,0x04020406u,0x11000306u),\nuvec4(0x440b1310u,0x1d0b032du,0x78090704u,0x2c1b0d6cu),\nuvec4(0x19681c29u,0x1c5d0c08u,0x37094c2du,0x0d0c0709u),\nuvec4(0x090c0d5cu,0x0b595c2du,0x0b170b0du,0x1b46070du),\nuvec4(0x16140217u,0x2c070604u,0x1e03040du,0x0e0f0e5fu),\nuvec4(0x052f0e0fu,0x050f0510u,0x131f0e13u,0x130f0305u),\nuvec4(0x0503051fu,0x05011500u,0x03010001u,0x7e1f8e0fu),\nuvec4(0x0145dfffu,0x27040100u,0x39bc390cu,0x072b4738u),\nuvec4(0x19080728u,0x1d0b0718u,0x05210317u,0x3f13457fu),\nuvec4(0x00018523u,0x03220021u,0x00010022u,0x23050301u),\nuvec4(0x0004014fu,0x20013503u,0x04061706u,0x08191716u),\nuvec4(0x070b0759u,0x04060416u,0x03121021u,0x20130224u),\nuvec4(0x07580744u,0x094c0918u,0x390c0d0cu,0x0908093cu),\nuvec4(0x170cbd1cu,0x5c199739u,0x4c0d0c1du,0x07091c09u),\nuvec4(0x66273b19u,0x361b0907u,0x0b2c0927u,0x5e5f1e04u),\nuvec4(0x0503152fu,0x0e130501u,0x0304055fu,0x11050f15u),\nuvec4(0x11030105u,0x4f7e1302u,0xff0e1f1eu,0x1503353fu),\nuvec4(0x350f251fu,0x04110501u,0x9c590c07u,0x08075839u),\nuvec4(0x18172b07u,0x08190807u,0x071d0b17u,0x25020306u),\nuvec4(0x130f359fu,0x0501932fu,0x03121021u,0x2f533132u),\nuvec4(0x11130015u,0x01050125u,0x190b0604u,0x1d086917u),\nuvec4(0x460b0719u,0x40110204u,0x0b502302u,0x07040203u),\nuvec4(0x07380908u,0x4c08070bu,0x38090809u,0x3c3d2c69u),\nuvec4(0x0c09e75du,0x1c191c09u,0x08192c4du,0x1d4b0729u),\nuvec4(0x26071b66u,0x170b0907u,0x2e022b09u,0x5e1f0e1fu),\nuvec4(0x0110054fu,0x132f5e03u,0x0115110eu,0x0e430520u),\nuvec4(0x0f030e6fu,0xff3e3f0eu,0x000185bfu,0x090b1402u),\nuvec4(0x0807090cu,0x48397c19u,0x1b0d3b17u,0x0b173817u),\nuvec4(0x0a060b0du,0x5f250203u,0x03150365u,0x05732f0eu),\nuvec4(0x02310511u,0x10110213u,0x53000201u,0x0100013fu),\nuvec4(0x11050110u,0x06000500u,0x0908070au,0x0b18790cu),\nuvec4(0x26170b2du,0x01200204u,0x01126002u,0x07140220u),\nuvec4(0x0748090cu,0x6c0b0d0bu,0x08090c69u,0x0c0d0c09u),\nuvec4(0x0c0d0c3du,0x3d090809u,0x1907193cu,0x092c3967u),\nuvec4(0x1d1c0d1cu,0x2b07096cu,0x27860a4du,0x0b170b09u),\nuvec4(0x03040213u,0x1f0e0f1eu,0x3f0e0f4eu,0x13000105u),\nuvec4(0x130e2f6eu,0x00310305u,0x0f030f03u,0x132e7f23u),\nuvec4(0x2e0f1e0fu,0x01a55fffu,0x04023115u,0x0d090400u),\nuvec4(0x0c28070bu,0x1c091c09u,0x2b274829u,0x1b070b0du),\nuvec4(0x071d1b37u,0x05030416u,0x5501157fu,0x633f0e13u),\nuvec4(0x02004105u,0x00115203u,0x01000301u,0x01052f23u),\nuvec4(0x03120100u,0x06200115u,0x2c091807u,0x38190c19u),\nuvec4(0x08070b17u,0x170b0d07u,0x04200406u,0x02040716u),\nuvec4(0x44200110u,0x07680906u,0x190b1d0bu,0x592c0d0cu),\nuvec4(0x0d0c291cu,0x0d1c0d1cu,0x1d092817u,0x07095c09u),\nuvec4(0x07190719u,0x07090709u,0x0d3c0d1cu,0x091c1d1cu),\nuvec4(0x0b27190cu,0x071d1b2du,0x090b760au,0x01231407u),\nuvec4(0x1e031400u,0x2e1f0e0fu,0x0110056fu,0x131f8e13u),\nuvec4(0x0e130f05u,0x1e3f0323u,0x3e132e6fu,0x33df1e0fu),\nuvec4(0x21e50305u,0x04121105u,0x070d0c07u,0x391c0918u),\nuvec4(0x2748290cu,0x2b170d2bu,0x160d1b27u,0x01000214u),\nuvec4(0x03256f05u,0x0e5f3325u,0x05010543u,0x32031211u),\nuvec4(0x25010511u,0x4f130400u,0x00010075u,0x09180a14u),\nuvec4(0x48490c0du,0x0b174837u,0x06140604u,0x14070837u),\nuvec4(0x0c561400u,0x07380928u,0x0c090b3du,0x3c090c0du),\nuvec4(0x0c090809u,0x4c192809u,0x0c2d2837u,0x3c890c39u),\nuvec4(0x096d0c0du,0x093c0907u,0x3d3b170bu,0x07046607u),\nuvec4(0x21131209u,0x1e031200u,0x2e0f2e0fu,0x051f1e0fu),\nuvec4(0x02010001u,0x2f4e3f13u,0x034f0513u,0x133f0503u),\nuvec4(0x0e030e8fu,0x8f3e1f03u,0x13453f2eu,0x01050195u),\nuvec4(0x12011015u,0x06070904u,0x2c090809u,0x08190c19u),\nuvec4(0x3b073819u,0x4b1d2b0du,0x240a0b0du,0x05000103u),\nuvec4(0x2e13557fu,0x0e0f0e1fu,0x12112543u,0x05031213u),\nuvec4(0x13011543u,0x0501057fu,0x04100230u,0x08093c07u),\nuvec4(0x68377809u,0x16170b07u,0x0708271bu,0x07040708u),\nuvec4(0x280c272du,0x4d074809u,0x5c0d0c09u,0x19381918u),\nuvec4(0x0908573cu,0x27090c1du,0x27090739u,0x2d0c1d19u),\nuvec4(0x28093d0cu,0x3b2c0907u,0x1b1d0b07u,0x1456070du),\nuvec4(0x03020706u,0x22110325u,0x0f6e0f1eu,0x33051f2eu),\nuvec4(0x034f3e4fu,0x053f031fu,0x1e5fff03u,0x131f0e0fu),\nuvec4(0x151f032eu,0xd513452fu,0x16171241u,0x2c193c18u),\nuvec4(0x0b173809u,0x27060b5du,0x0b1d0b0du,0x03022406u),\nuvec4(0x0f257f25u,0x2e033e13u,0x02212543u,0x020015b3u),\nuvec4(0x0f155f03u,0x01000105u,0x04000410u,0x191c0706u),\nuvec4(0x0b0798f8u,0x07083b1du,0x1b070b1du,0x18291807u),\nuvec4(0x0b075809u,0x09070b0du,0x1908076cu,0x091c2928u),\nuvec4(0x1847090cu,0x190c3d07u,0x190b0927u,0x2d0c090du),\nuvec4(0x2d0c0d1cu,0x0917280cu,0x3b0d1b1cu,0x0b0d1709u),\nuvec4(0x06145607u,0x25030e02u,0x12010503u,0x8e1f0e13u),\nuvec4(0x0e0f0e3fu,0x0e2f1e0fu,0x134f1e0fu,0x051f155fu),\nuvec4(0x038e13efu,0x4523a54fu,0x00314513u,0x04030102u),\nuvec4(0x0b070907u,0x3c090807u,0x0b271839u,0x0726070du),\nuvec4(0x0204070bu,0x0a060a06u,0x24061d07u,0x01150f02u),\nuvec4(0x1f057f05u,0x05439e03u,0x25c31211u,0x40355f03u),\nuvec4(0x190a1614u,0x7b17b8f8u,0x1b08071du,0x19080708u),\nuvec4(0x17980908u,0x090b060au,0x0c181d4cu,0x191c0809u),\nuvec4(0x1b19070du,0x0c094827u,0x0c092c1du,0x0c1d0c2du),\nuvec4(0x092d0c6du,0x291c0718u,0x09070b0du,0x070b072bu),\nuvec4(0x3446070bu,0x05020513u,0x1201150fu,0x0f1e0003u),\nuvec4(0x0f1e2f5eu,0x3f0e0f1eu,0x2f2e1f0eu,0x2f0e0f0eu),\nuvec4(0x050f1f15u,0x652f0213u,0x9f2e433fu,0x130513f5u),\nuvec4(0x31150125u,0x04030002u,0x0b04170au,0x093c0907u),\nuvec4(0x180c090cu,0x0b0d0b07u,0x02030466u,0x0b0a1614u),\nuvec4(0x24060b0du,0xaebf151fu,0x02010553u,0x154f25f3u),\nuvec4(0x00220011u,0xf8171602u,0x570b27f8u,0x070b0708u),\nuvec4(0x0b090708u,0x68190839u,0x090b260bu,0x292c090cu),\nuvec4(0x1c09281cu,0x1748074bu,0x2d0c0718u,0x090c092cu),\nuvec4(0x7d1c1d1cu,0x491c190cu,0x0d0b070bu,0x560b291bu),\nuvec4(0x03020614u,0x03053300u,0x03000105u,0x1f0e0300u),\nuvec4(0x0f1e0f4eu,0x1f2e1f6eu,0x031f7f6eu,0x2f0e0305u),\nuvec4(0x33750115u,0x650345dfu,0x75230503u,0x05030521u),\nuvec4(0x0b040301u,0x070b1409u,0x090c192cu,0x0d17180cu),\nuvec4(0x2032340au,0x0b160401u,0x04160b0du,0x6f151f02u),\nuvec4(0x63be2f03u,0x0ec30201u,0x1f050f23u,0x01151f05u),\nuvec4(0x06220110u,0xf8f8070bu,0x17088738u,0x07040718u),\nuvec4(0x0b095869u,0x0c290726u,0x09071809u,0x1908090cu),\nuvec4(0x48172b1cu,0x09070b67u,0x070c7d0cu,0x5d0c0d08u),\nuvec4(0x0907392cu,0x1b070b07u,0x560c2907u,0x3e031402u),\nuvec4(0x02013315u,0x0e030003u,0x8e4f030fu,0x2e1f3e0fu),\nuvec4(0x1f6f5e0fu,0x00050315u,0x03050135u,0x43050f35u),\nuvec4(0xd503a5efu,0x17040351u,0x3c090b14u,0x17090c19u),\nuvec4(0x04060d0bu,0x26504200u,0x0503241du,0x137f1500u),\nuvec4(0x0273ae0fu,0x4f335e93u,0x06400115u,0x3817d817u),\nuvec4(0x4817e819u,0x08092817u,0x0c071409u,0x361b5859u),\nuvec4(0x0c070617u,0x0b790809u,0x08070b0du,0xdb374807u),\nuvec4(0x3d191c07u,0x592c0d0cu,0x19171917u,0x0436070cu),\nuvec4(0x02040203u,0x1315030eu,0x130e0305u,0x00020005u),\nuvec4(0x1f030213u,0x0f9e0f1eu,0x0f1e0f1eu,0x2f5e0f3eu),\nuvec4(0x054f0f03u,0x02041213u,0x1f150310u,0xcf250325u),\nuvec4(0x51d503a5u,0x06030200u,0x0b040217u,0x192c0d09u),\nuvec4(0x0d0b081cu,0x01030206u,0x01201100u,0x070a1620u),\nuvec4(0x0b06040du,0x038f2502u,0x0f0e0f0eu,0x1105339eu),\nuvec4(0x038e8302u,0x152f130fu,0x0b163001u,0x0c3928f8u),\nuvec4(0xf8091819u,0x07180728u,0x07140708u,0x1b782918u),\nuvec4(0x170a1607u,0x0b275b04u,0x68271d17u,0x294d4b17u),\nuvec4(0x080d0c07u,0x0d2c1d19u,0x290c192cu,0x29170c17u),\nuvec4(0x1422260bu,0x050e0d03u,0x051e5301u,0x0e131220u),\nuvec4(0x0e2f0e23u,0x0e3f0e1fu,0x4e0fbe0fu,0x53054f1fu),\nuvec4(0xcfb50312u,0x11c503a5u,0x04054105u,0x04020417u),\nuvec4(0x080d6c0bu,0x50030417u,0x20040001u,0x06142604u),\nuvec4(0x1502060bu,0x0e0f1e8fu,0x7e0f0e1fu,0x83020133u),\nuvec4(0x40156f8eu,0x48f80716u,0xf8090869u,0x07081728u),\nuvec4(0x07140708u,0x070b6869u,0x04170416u,0x23120312u),\nuvec4(0x1d070602u,0x07080d1bu,0x4d0b5788u,0x09270c09u),\nuvec4(0x394c0d1cu,0x09173917u,0x07160b0cu,0x1e02340bu),\nuvec4(0x02000500u,0x03050e43u,0x03020001u,0x0e1f030eu),\nuvec4(0x032f0e0fu,0x4f8e038fu,0x456f3f1eu,0x05011223u),\nuvec4(0x1f050100u,0x9f251105u,0x15f52f13u,0x14111071u),\nuvec4(0x04000307u,0x12177c07u,0x04160450u,0x16142210u),\nuvec4(0x03020614u,0xaee36effu,0x2001156fu,0xf8170604u),\nuvec4(0x590c1948u,0x072819d8u,0x07180718u,0x08690b14u),\nuvec4(0x0d0b3809u,0x0709072bu,0x01000204u,0x16121002u),\nuvec4(0xd8173d0bu,0x073d0b07u,0x17080c09u,0x0b27198cu),\nuvec4(0x0d191b19u,0x07060a0bu,0xb32e331du,0x2e120005u),\nuvec4(0x0e030e2fu,0x03050f03u,0x230f032fu,0x0f6e0f05u),\nuvec4(0x2f0e2f0eu,0x756f0f0eu,0x00330513u,0x2f250125u),\nuvec4(0x2e030f03u,0x05033f23u,0x0513852fu,0x00010091u),\nuvec4(0x02010312u,0x5c0d0904u,0x0100021bu,0x04000110u),\nuvec4(0x24000436u,0x1236041bu,0x737edf03u,0x037e5302u),\nuvec4(0x01058f0eu,0x07060420u,0x0c0958f8u,0x28191829u),\nuvec4(0x58092809u,0x38172819u,0x59072407u,0x17280908u),\nuvec4(0x081b071bu,0x12200229u,0x17061400u,0x780b0d1bu),\nuvec4(0x08190809u,0x1c0b4d17u,0x197c1917u,0x0b170b17u),\nuvec4(0x1a071b1du,0x030d0706u,0x2e13055eu,0x05030f23u),\nuvec4(0x22010503u,0x3f0e1f2eu,0x130e1f03u,0x2e2f033fu),\nuvec4(0x433f0e03u,0x5f130f1fu,0x01550345u,0x13000302u),\nuvec4(0x131e2305u,0x030f030fu,0xb59f031eu,0x10012091u),\nuvec4(0x5c070401u,0x020b0d09u,0x060a4630u,0x061b0402u),\nuvec4(0x1b070d0bu,0x00320402u,0x2f1e9f03u,0x2305331eu),\nuvec4(0x135e4322u,0x01156f35u,0x170b0620u,0x481958f8u),\nuvec4(0x08091819u,0x08f80c19u,0x07140709u,0x1b075859u),\nuvec4(0x07182b07u,0x1203100du,0x16020400u,0x0d09070bu),\nuvec4(0x0928170bu,0x07080718u,0x0b080708u,0x0b06072du),\nuvec4(0x0b07090cu,0x090b6c19u,0x02465b17u,0x330b0203u),\nuvec4(0x2e050f1eu,0x2305132fu,0x03020105u,0x2f0e0312u),\nuvec4(0x0f034f0eu,0x0f031f03u,0x1f0e2f13u,0x01032f1eu),\nuvec4(0x00050300u,0x5f230305u,0x13753305u,0x0e030402u),\nuvec4(0x01958fffu,0x0120a105u,0x09060300u,0x0407095cu),\nuvec4(0x16011001u,0x020b2d07u,0x07120133u,0x0b02042bu),\nuvec4(0x01030403u,0x052f0e7fu,0x1325231fu,0x63020305u),\nuvec4(0x4f25135eu,0x04300115u,0x170b0d06u,0x2809c8f8u),\nuvec4(0x28f8092cu,0x0c09140bu,0x5b275839u,0x02000307u),\nuvec4(0x07041240u,0x980b170bu,0x160a1b27u,0x171c071au),\nuvec4(0x0b391c29u,0x0706071du,0x0304660du,0x13020100u),\nuvec4(0x0f031e0fu,0x3e0f0e03u,0x0115331fu,0x05120302u),\nuvec4(0x1e1f050eu,0x030f0e0fu,0x0e5f7305u,0x0302032fu),\nuvec4(0x03031210u,0x2f030f05u,0x2f431205u,0x13010035u),\nuvec4(0x8fff0204u,0x1122b1b5u,0x07097c04u,0x06141002u),\nuvec4(0x030b1d1bu,0x14201115u,0x0002032bu,0x4f6e0322u),\nuvec4(0x15530e03u,0x03120100u,0x1f5e2305u,0x50116513u),\nuvec4(0x270b0706u,0x1c09f8f8u,0x0718f809u,0x1c07140bu),\nuvec4(0x1b277819u,0x90020327u,0x07580736u,0x0d0b0738u),\nuvec4(0x2402040bu,0x07090b06u,0x190c0908u,0x090c2907u),\nuvec4(0x0b26070du,0x04020436u,0x03122103u,0x5e032e0fu),\nuvec4(0x0005432fu,0x05120302u,0x2305030eu,0x050f0e1fu),\nuvec4(0x13051f03u,0x056f1305u,0x02030103u,0x05023301u),\nuvec4(0x00031033u,0x4f130503u,0x01151f03u,0x0e0d0203u),\nuvec4(0x8fff050fu,0x01109165u,0x01130112u,0x0d4c0703u),\nuvec4(0x140c0d0cu,0x0b060a16u,0x030d0b07u,0x3e231015u),\nuvec4(0x27041203u,0x1f2e020bu,0x1e0f033eu,0x13250f03u),\nuvec4(0x01220125u,0x032e3305u,0x4503051fu,0x0d069001u),\nuvec4(0x58f8072bu,0xf8098819u,0x06070928u,0x1c070602u),\nuvec4(0x04577819u,0x70010003u,0x0b260401u,0x19280758u),\nuvec4(0x1004220bu,0x071b0612u,0x190c090cu,0x072c090cu),\nuvec4(0x0b09160au,0x02031416u,0x03010203u,0x13040201u),\nuvec4(0x6e03051eu,0x1105431fu,0x13010203u,0x2f0e430eu),\nuvec4(0x0e030f13u,0x030f1305u,0x051f1305u,0x02210301u),\nuvec4(0x13030513u,0x02000115u,0x6f030f53u,0x050f2325u),\nuvec4(0x21559fffu,0x10026105u,0x01000102u,0x0c131203u),\nuvec4(0x1c090c29u,0x1d0b170bu,0x031b080bu,0x031e2301u),\nuvec4(0x02140005u,0x0c1b0204u,0x06241b0du,0x4f2e0214u),\nuvec4(0x01252315u,0x1f033e73u,0x06900165u,0xf8071b1du),\nuvec4(0x09e81958u,0x14070cd8u,0x191c0906u,0x030607a8u),\nuvec4(0x02800110u,0x27580926u,0x20031b09u,0x00041004u),\nuvec4(0x090b0604u,0x1907190bu,0x0c070907u,0x070b260bu),\nuvec4(0x13020304u,0x04110011u,0x0f0e0317u,0x4e031e13u),\nuvec4(0x0f43050fu,0x00130001u,0x1f0e0302u,0x139f0301u),\nuvec4(0x101f331fu,0x02010001u,0x01131523u,0x0f053302u),\nuvec4(0x4f050f03u,0xff454f03u,0x0513056fu,0x00513523u),\nuvec4(0x00210001u,0x01001102u,0x0b231002u,0x0b0d3b4cu),\nuvec4(0x020b0807u,0x06240043u,0x0e532204u,0x04030e23u),\nuvec4(0x0f1e0406u,0x231e0f0eu,0x63121315u,0x1f05132eu),\nuvec4(0x01150335u,0x073b0690u,0x18f80728u,0x28079809u),\nuvec4(0x0c07d829u,0x0b160406u,0x0b98190cu,0x00011302u),\nuvec4(0x20015001u,0x07060402u,0x2b075809u,0x04018003u),\nuvec4(0x090b1d0bu,0x17181907u,0x12260709u,0x00030204u),\nuvec4(0x04111001u,0x05030b0cu,0x1e130500u,0x031f2e03u),\nuvec4(0x050f330fu,0x02001300u,0x010f0e03u,0x05030513u),\nuvec4(0x1f055f1eu,0x1f130e03u,0x03011553u,0x0e132f05u),\nuvec4(0x0f031f03u,0x3f030503u,0x0e0fff13u,0xc18533bfu),\nuvec4(0x01130112u,0x1b330210u,0x090c292cu,0x02070807u),\nuvec4(0x36140203u,0x02041214u,0x03010503u,0x20250110u),\nuvec4(0x1e050314u,0x15230e1fu,0x2f631223u,0x453f1305u),\nuvec4(0x04020301u,0x1d143002u,0x1708072bu,0x1908f8f8u),\nuvec4(0x06070cf8u,0x1c070604u,0x1b090859u,0x02030113u),\nuvec4(0x01600110u,0x17060420u,0x0b0d0748u,0x06a0030du),\nuvec4(0x090d071du,0x0827191bu,0x04060709u,0x04021402u),\nuvec4(0x05110302u,0x0b0c0702u,0x2302100eu,0x0305034eu),\nuvec4(0x15230e0fu,0x13001300u,0x0e03050eu,0x030f0e03u),\nuvec4(0x3f1e1f0eu,0x0e030f03u,0x0f131f23u,0x05110503u),\nuvec4(0x3e132f13u,0xff0e8f53u,0x2503355fu,0x1501550fu),\nuvec4(0x02110061u,0x32131203u,0x13110011u,0x0906041du),\nuvec4(0x0b09071cu,0x01322647u,0x02000513u,0x05011001u),\nuvec4(0x1200011fu,0x6f150304u,0x256f33f3u,0x03020401u),\nuvec4(0x0d070430u,0x170b0d1bu,0x0938f8f8u,0x09b81918u),\nuvec4(0x0704160bu,0x4908091cu,0x21300207u,0x01600105u),\nuvec4(0x02000100u,0x38090604u,0xa0131b07u,0x060b0604u),\nuvec4(0x1b09070au,0x070c0957u,0x03021406u,0x01150204u),\nuvec4(0x0d1b0205u,0x0e030e33u,0x15733e0fu,0x03041301u),\nuvec4(0x0f2e030eu,0x1e030f1eu,0x130f0e0fu,0x031f030fu),\nuvec4(0x1f130e3fu,0x03051105u,0x030e030fu,0x4e030e0fu),\nuvec4(0x9f0e1f43u,0x3f137f0eu,0xb1752f85u,0x10510302u),\nuvec4(0x03510001u,0x1d0b0602u,0x1b07093cu,0x04120406u),\nuvec4(0x00110302u,0x25110001u,0x0400011fu,0x01120402u),\nuvec4(0x23055f03u,0x73120302u,0x23254f5eu,0x06200105u),\nuvec4(0xf8075b0du,0xa85928f8u,0x160d0c19u,0x0c0d0c07u),\nuvec4(0x0b0d0c29u,0x00120002u,0x05030112u,0x10117001u),\nuvec4(0x38070604u,0x01020b07u,0x360401a0u,0x0d0b0907u),\nuvec4(0x19271807u,0x2204060cu,0x03010503u,0x04010305u),\nuvec4(0x1f1e260bu,0x1563055eu,0x04020300u,0x1e1f9e03u),\nuvec4(0x0f131f13u,0x050f0e03u,0x1f0e0f1eu,0x0e330105u),\nuvec4(0x4e2f150fu,0x035e9f43u,0xa53fa56fu,0x03211041u),\nuvec4(0x03813031u,0x1907040eu,0x0d07191cu,0x04020607u),\nuvec4(0x01000312u,0x05032100u,0x100f2503u,0x02000204u),\nuvec4(0x5f030204u,0x33223315u,0x030e0305u,0x01752f6eu),\nuvec4(0x0b060100u,0xf8173b0du,0xb84928f8u,0x071d1c09u),\nuvec4(0x2c0d0906u,0x0002030bu,0x13120132u,0x00316005u),\nuvec4(0x07160204u,0xb0030b38u,0x16140214u,0x0b1d0b09u),\nuvec4(0x07092b0du,0x12030709u,0x03010503u,0x04031001u),\nuvec4(0x03070b17u,0x534e230eu,0x00050f0eu,0x03000302u),\nuvec4(0x1f2e031eu,0x1f031f5eu,0x03050305u,0x0e2f1305u),\nuvec4(0x13050e0fu,0x0e0e0f0eu,0x231f1503u,0xff231f2eu),\nuvec4(0x750f158fu,0x0571b52fu,0x02050103u,0x20112001u),\nuvec4(0x00110511u,0x07021301u,0x090b0706u,0x22160d07u),\nuvec4(0x02344011u,0x00010513u,0x03040102u,0x2f451204u),\nuvec4(0x83052305u,0x01755f6eu,0x2b0d0b06u,0x48f8f817u),\nuvec4(0x094cc829u,0x521b0907u,0x15020410u,0x00011302u),\nuvec4(0x00311031u,0x06040204u,0x0908090bu,0x01020b07u),\nuvec4(0x32040190u,0x070b0716u,0x071b1d1bu,0x00020b18u),\nuvec4(0x20012513u,0x1b140b02u,0x4e031f0eu,0x0005630fu),\nuvec4(0x0e0d0312u,0x2f3e030fu,0x15332f3eu,0x1f030f13u),\nuvec4(0x030e2f0eu,0x05030e2eu,0x1f030f13u,0x2f030e03u),\nuvec4(0x1f030503u,0x031fff03u,0x550f451fu,0x3501950fu),\nuvec4(0x052160a1u,0x13051041u,0x070b0704u,0x0302070bu),\nuvec4(0x40010001u,0x14061704u,0x24000122u,0x45020412u),\nuvec4(0x0201254fu,0x031f0543u,0x1e0f2e0fu,0x150f057fu),\nuvec4(0x1d060401u,0xf8f8170bu,0x19b81968u,0x08090d0cu),\nuvec4(0x22140907u,0x06040624u,0x03111304u,0x00059115u),\nuvec4(0x06000204u,0x0b072907u,0x0601a003u,0x16001204u),\nuvec4(0x0917161bu,0x0c08071du,0x0113020bu,0x20050105u),\nuvec4(0x06140604u,0x3f0e0d17u,0x02530f2eu,0x0e032e33u),\nuvec4(0x3e1f2e1fu,0x03051e03u,0x0510150fu,0x3e1e7f23u),\nuvec4(0x2f05233fu,0x3f050305u,0x051fff03u,0xf52f150fu),\nuvec4(0x61350105u,0x01302100u,0x11032100u,0x01100105u),\nuvec4(0x06040330u,0x31020b07u,0x1b072420u,0x06140b17u),\nuvec4(0x04004604u,0x6f151103u,0x13154305u,0x137e3305u),\nuvec4(0x0401154fu,0x170d0706u,0xf817b819u,0x0c1948f8u),\nuvec4(0x09080c1du,0x02374407u,0x02130213u,0x05812501u),\nuvec4(0x00020001u,0x090b0602u,0x020d0b08u,0x0206a001u),\nuvec4(0x16040103u,0x07260b07u,0x061b2d0bu,0x11050302u),\nuvec4(0x04020612u,0x1b071b26u,0x0e1f031eu,0x430f0e0fu),\nuvec4(0x153e030eu,0x5f0e2f13u,0x1f030f03u,0x03150302u),\nuvec4(0x6f053312u,0x53158e1eu,0x0f050315u,0x053f0513u),\nuvec4(0x2f35ef03u,0x311501b5u,0x33121103u,0x00111001u),\nuvec4(0x10210521u,0x20011001u,0x0c0b0403u,0x1001040bu),\nuvec4(0x4b061004u,0x0b090729u,0x06071b17u,0x25201204u),\nuvec4(0x152f051fu,0x05031553u,0x2f630e33u,0x10050f05u),\nuvec4(0x0b060a16u,0x27a80907u,0x09380988u,0x4c1958f8u),\nuvec4(0x17081918u,0x0708091cu,0x15010302u,0x15130213u),\nuvec4(0x00012551u,0x07040012u,0x070b0709u,0x04a00504u),\nuvec4(0x04000302u,0x36070b16u,0x161d0b07u,0x52001304u),\nuvec4(0x02140b06u,0x1e061b07u,0x3e0f0e0fu,0x13051301u),\nuvec4(0x05000204u,0x0f13000fu,0x05af0305u,0x23150322u),\nuvec4(0x4f051301u,0x331f7e3eu,0x33252305u,0x55ef033fu),\nuvec4(0x3521953fu,0x40110061u,0x00310001u,0x07127011u),\nuvec4(0x07240b0cu,0x0d2b0714u,0x0b071c07u,0x07080b17u),\nuvec4(0x0206071du,0x950f0540u,0x12030103u,0x059f6501u),\nuvec4(0x02011501u,0x0b0d1614u,0x073827a8u,0x37191809u),\nuvec4(0x0d4c68f8u,0x08592c19u,0x33350e07u,0x0400b501u),\nuvec4(0x06040102u,0x050b062bu,0x04018001u,0x1b160422u),\nuvec4(0x0d0b0a36u,0x52001226u,0x04030b06u,0x07021b13u),\nuvec4(0x3e0f0e0du,0x1305030fu,0x00022300u,0x01031501u),\nuvec4(0x00030205u,0x054f000fu,0x050f332fu,0x03020103u),\nuvec4(0x2f150302u,0x3f2e030eu,0x032f2e03u,0x2513053fu),\nuvec4(0x156f1503u,0x851f65bfu,0x05812503u,0x00210041u),\nuvec4(0x30010051u,0x04023001u,0x0a0b091bu,0x0b070b06u),\nuvec4(0x071d1b1du,0x0d2b173bu,0x20040607u,0x55211514u),\nuvec4(0x03050143u,0x13050315u,0x254f0305u,0x02231513u),\nuvec4(0x19181b0au,0x170b0758u,0x29a87748u,0x497c0998u),\nuvec4(0x030d0728u,0x0503250fu,0x85030112u,0x02040011u),\nuvec4(0x0b070410u,0x01020b14u,0x04001170u,0x16040102u),\nuvec4(0x36070d0bu,0x00143607u,0x03020412u,0x04020604u),\nuvec4(0x1b071423u,0x232e0f0eu,0x03120302u,0x01042302u),\nuvec4(0x00010200u,0x02030214u,0x4f051f03u,0x05031f33u),\nuvec4(0x01050103u,0x1f4e3f03u,0x0e030005u,0x053f0e3fu),\nuvec4(0x3503050fu,0x4f030503u,0xf5bf1503u,0xe1050135u),\nuvec4(0x41100120u,0x04000290u,0x1b070402u,0x290d0b04u),\nuvec4(0x2b07091cu,0x18070b2du,0x0a0b0d07u,0x02161406u),\nuvec4(0x45113003u,0x150315e3u,0x35010211u,0x07040501u),\nuvec4(0x0928070du,0x57180728u,0x49083728u,0x0d4c58f8u),\nuvec4(0x0b48390cu,0x13052f03u,0x02012205u,0x04000185u),\nuvec4(0x06041002u,0x09040204u,0x0180030bu,0x00020403u),\nuvec4(0x0a1b1614u,0x00020476u,0x04031402u,0x05030416u),\nuvec4(0x0b070403u,0x0e0d090cu,0x01151f13u,0x0e030e02u),\nuvec4(0x13021002u,0x03120332u,0x02250005u,0x0f050115u),\nuvec4(0x3f030f03u,0x01030215u,0x031f0502u,0x0e0e1f1eu),\nuvec4(0x2e03000fu,0x352f2e1fu,0x35030002u,0x350f251fu),\nuvec4(0x1501857fu,0x15415501u,0x05010531u,0x20110021u),\nuvec4(0xa0312001u,0x12030204u,0x04030203u,0x09071c0bu),\nuvec4(0x073b170du,0x2718070bu,0x0a161a1bu,0x01500204u),\nuvec4(0x33120395u,0x01051301u,0x01051105u,0x2f050300u),\nuvec4(0x0b020315u,0x18274807u,0x0b074b17u,0x09070b07u),\nuvec4(0x48f8490cu,0x091c0d3cu,0x130b0758u,0x0513052fu),\nuvec4(0x33120112u,0x00013305u,0x04100204u,0x09040012u),\nuvec4(0x0180030bu,0x14120405u,0x24761b26u,0x04030400u),\nuvec4(0x13061706u,0x020d0706u,0x0e0d0b09u,0x0e251f13u),\nuvec4(0x11050305u,0x05730223u,0x02012523u,0x250f1503u),\nuvec4(0x0501053fu,0x1e031f13u,0x1f0e0e1fu,0x2e0f1e23u),\nuvec4(0x0301252fu,0x03150302u,0x4f250f55u,0x015511d5u),\nuvec4(0x31152100u,0x11106100u,0x11300100u,0x04600120u),\nuvec4(0x01320112u,0x091c0700u,0x072b171du,0x39070819u),\nuvec4(0x072b1d0bu,0x01400216u,0x11750100u,0x15010302u),\nuvec4(0x20014511u,0x151f1503u,0x04020001u,0x1708070bu),\nuvec4(0x170b071bu,0x0402031du,0x092b0d0bu,0x1928090cu),\nuvec4(0x3c2938f8u,0x1b074819u,0x03051f13u,0x11051305u),\nuvec4(0x01058302u,0x20021400u,0x02030501u,0x12700103u),\nuvec4(0x24020001u,0x0b090b26u,0x02060486u,0x0c070604u),\nuvec4(0x0706041bu,0x0b130503u,0x2f030e03u,0x03552305u),\nuvec4(0x01152310u,0x03051302u,0x02100500u,0x25012511u),\nuvec4(0x1503151fu,0x0f1e1f13u,0x134f0e1eu,0x030f0e2fu),\nuvec4(0x1203351fu,0x450f6501u,0xf501c51fu,0x10312031u),\nuvec4(0xc0013011u,0x03020402u,0x03220310u,0x0d2c0b00u),\nuvec4(0x07091b37u,0x7b390819u,0x11201416u,0x02415500u),\nuvec4(0x01552103u,0x0f451310u,0x3b042005u,0x0b072b0du),\nuvec4(0x04000113u,0x191b1d0au,0x78f80938u,0x48290c09u),\nuvec4(0x03070807u,0x031f0501u,0x1503051fu,0x21034203u),\nuvec4(0x00010513u,0x01000204u,0x05010510u,0x10013001u),\nuvec4(0x05010011u,0x2b040200u,0x070c0716u,0x0b07b60bu),\nuvec4(0x03070b19u,0x0f05030eu,0x0e031203u,0x05030f05u),\nuvec4(0x00111553u,0x23250112u,0x01201135u,0x25030120u),\nuvec4(0x3503050fu,0x3f4e1f03u,0x0225cf15u,0x354f6501u),\nuvec4(0x05010551u,0xa5010511u,0x5001a071u,0x50210011u),\nuvec4(0x01030204u,0x04010002u,0x04020302u,0x0d090c0bu),\nuvec4(0x1b370807u,0x09073907u,0x260d671bu,0x00212004u),\nuvec4(0x02015501u,0x45111213u,0x4f051311u,0x01001105u),\nuvec4(0x12010543u,0x01101113u,0x090b3604u,0x080958f8u),\nuvec4(0x39380c09u,0x030b1738u,0x051f1302u,0x1243051fu),\nuvec4(0x00011203u,0x01051301u,0x11000214u,0x00110500u),\nuvec4(0x00010521u,0x01031011u,0x0d0c2405u,0x090d160bu),\nuvec4(0x1c1ba60bu,0x2513040bu,0x0322050fu,0x0503050eu),\nuvec4(0x02105523u,0x50251355u,0x35312001u,0x03010511u),\nuvec4(0x2f0e031fu,0xef05033fu,0x55031105u,0x750f150fu),\nuvec4(0xf021e571u,0x01121120u,0x12145002u,0x00320100u),\nuvec4(0x09070403u,0x1b47082cu,0x07180917u,0x0718071bu),\nuvec4(0x070b2708u,0x00010226u,0x12217511u,0x45111203u),\nuvec4(0xf50f2503u,0x01350305u,0x04320110u,0x1948f807u),\nuvec4(0x09382908u,0x0d0b1748u,0x05030102u,0x151f051fu),\nuvec4(0x52030523u,0x04002513u,0x01002102u,0x02049105u),\nuvec4(0x03050005u,0x0b0c0b24u,0x0b0d070au,0x091b0786u),\nuvec4(0x330b090cu,0x0402151fu,0x01030203u,0x01552305u),\nuvec4(0x23352310u,0x1011a005u,0x00110511u,0x03150311u),\nuvec4(0x5f031f0eu,0x05039f0eu,0x1300251fu,0x113501d5u),\nuvec4(0x11c50135u,0x307220f0u,0x52202204u,0x0d0c0b04u),\nuvec4(0x1b37380cu,0x1b080917u,0x0b176807u,0x00020426u),\nuvec4(0x00c14531u,0x35030501u,0xa51f030fu,0x3001254fu),\nuvec4(0xf8070614u,0x38078938u,0x1b070807u,0x3f15030du),\nuvec4(0x43350f05u,0x23220302u,0x02000105u,0x51450110u),\nuvec4(0x02100105u,0x13051105u,0x0c090604u,0x0b0d170bu),\nuvec4(0x171b0a56u,0x03040b29u,0x0e03150fu,0x14020402u),\nuvec4(0x25110553u,0x35011001u,0x0f130501u,0x0031a005u),\nuvec4(0x00010511u,0x15130105u,0xcf031f0eu,0x13056f03u),\nuvec4(0x21c51302u,0x01550115u,0x20f001d5u,0x20111241u),\nuvec4(0x00114002u,0x07060211u,0x280c0d09u,0x1b370807u),\nuvec4(0x273b0907u,0x0b0d1748u,0x41020426u,0x32003135u),\nuvec4(0x05130201u,0x550f0563u,0x05130503u,0x2001157fu),\nuvec4(0x07040204u,0x2948f809u,0x191c0908u,0x0d2b0728u),\nuvec4(0x5f250103u,0x00023355u,0x01021302u,0x12040015u),\nuvec4(0x25016501u,0x05030421u,0x02030521u,0x0d1b0704u),\nuvec4(0x460b070bu,0x070b592bu,0x12074403u,0x22030704u),\nuvec4(0x00210523u,0x05212001u,0x130e0501u,0x04200105u),\nuvec4(0x01006140u,0x00050105u,0x2f131503u,0x231f13bfu),\nuvec4(0x0503152fu,0x25317513u,0x25011531u,0x10619501u),\nuvec4(0x1270f001u,0x10110240u,0x0d090704u,0x18070a09u),\nuvec4(0x08078b47u,0x08072817u,0x26070d0bu,0x0102060au),\nuvec4(0x43850100u,0x05113302u,0x01130523u,0x15131503u),\nuvec4(0x11257f13u,0x06000210u,0x38f80b07u,0x3c390c09u),\nuvec4(0x0b070809u,0x2511032du,0x4503055fu,0x11030503u),\nuvec4(0x15121302u,0x03020400u,0x01550165u,0x05013513u),\nuvec4(0x2b060403u,0x1b46071du,0x0b290b0du,0x02030b0du),\nuvec4(0x06120d4bu,0x1302140bu,0x01151301u,0x01000140u),\nuvec4(0x0f030e25u,0x04200105u,0x81050140u,0x031f1315u),\nuvec4(0x4f0e3f2fu,0x0e030f0eu,0x5f030e03u,0x31f52315u),\nuvec4(0x01250105u,0x11209195u,0x020110f0u,0x14302406u),\nuvec4(0x0c080702u,0x8b77180du,0x0d171847u,0x06171d0bu),\nuvec4(0x0102060au,0x41456110u,0x12017302u,0x03151105u),\nuvec4(0x01553f35u,0x04000100u,0x28f81b06u,0x06090c29u),\nuvec4(0x0d0c090au,0x0708090cu,0x00021d0bu,0x152f3501u),\nuvec4(0x0213850fu,0x00131223u,0x0300f512u,0x09141355u),\nuvec4(0x070d0b07u,0x0d0b0a36u,0x1b17090bu,0x04020b0du),\nuvec4(0x0407060bu,0x02040203u,0x06020704u,0x0207040bu),\nuvec4(0x01150214u,0x01030120u,0x0e030523u,0x30110e03u),\nuvec4(0x01052004u,0x01050105u,0x01151105u,0x033f4f35u),\nuvec4(0x2e1f2305u,0xc5337f23u,0x25310501u,0x0501b501u),\nuvec4(0x10110041u,0xe0110001u,0x10521001u,0x07040214u),\nuvec4(0x67080c1du,0x07ab070bu,0x3d0b072bu,0x160b1d1bu),\nuvec4(0x25033002u,0x05033501u,0x01232193u,0x05032102u),\nuvec4(0x551f0523u,0x0d062021u,0x08f80709u,0x0a072c19u),\nuvec4(0x08192c07u,0x00020d1bu,0xb53f3501u,0x22030213u),\nuvec4(0x03000123u,0x00951f25u,0x02135513u,0x0b070914u),\nuvec4(0x3607060du,0x172b170bu,0x090c0412u,0x1406070cu),\nuvec4(0x04020402u,0x090b0706u,0x0416140cu,0x03120102u),\nuvec4(0x13125400u,0x02201420u,0x20152100u,0x23250011u),\nuvec4(0x1e033f2fu,0x0e03150fu,0x0305af33u,0x9125f5f5u),\nuvec4(0x21b00160u,0x07320170u,0x87080c1du,0x3d2b3dbbu),\nuvec4(0x170b0d1bu,0x11020426u,0x0f650100u,0x05030e03u),\nuvec4(0x15130e43u,0x03011201u,0x03350385u,0x07042115u),\nuvec4(0xc809380bu,0x07093c09u,0x0c090c19u,0x031b0809u),\nuvec4(0x0f150110u,0x03053f05u,0x02335531u,0x03000143u),\nuvec4(0x0f051f15u,0x0f050395u,0x04020365u,0x0d0b090bu),\nuvec4(0x0a16071bu,0x070b4d0bu,0x0d070406u,0x03020b09u),\nuvec4(0x1402230eu,0x06071b16u,0x07090b07u,0x02030204u),\nuvec4(0x02241244u,0x30241003u,0x20012511u,0x05110001u),\nuvec4(0x4e032f23u,0x1e33051fu,0x156f050fu,0xf50f053fu),\nuvec4(0x2150a1e5u,0x01000160u,0x01302100u,0x02034002u),\nuvec4(0x090d0c06u,0x170b3708u,0x271b4d9bu,0x1d0b074bu),\nuvec4(0x0102144bu,0x11000100u,0x23154f15u,0x0102550fu),\nuvec4(0x85111302u,0x04212533u,0x07091827u,0x2c393cc8u),\nuvec4(0x02070809u,0x1f351001u,0x12051f05u,0x05010521u),\nuvec4(0x13010501u,0x11233201u,0x0f150f03u,0x00650135u),\nuvec4(0x13650f03u,0x0b090604u,0x04060b1du,0x0d2b0726u),\nuvec4(0x0406070bu,0x0b090c0bu,0x02042302u,0x1b141b07u),\nuvec4(0x090b0709u,0x2417081bu,0x00120002u,0x20241052u),\nuvec4(0x05313041u,0x1f05031fu,0x0e130f3eu,0x0e030e13u),\nuvec4(0x0301051fu,0x053f2305u,0x0f030503u,0x00b1e5f5u),\nuvec4(0x02210051u,0x00110211u,0x00411051u,0x04030001u),\nuvec4(0x090d0c07u,0x072b4708u,0x1d0b0d6bu,0x1b47092bu),\nuvec4(0x1b0d0b27u,0x00041b27u,0x5f151312u,0x0e031e03u),\nuvec4(0x12313503u,0x35011511u,0x10012563u,0x0b070402u),\nuvec4(0x0c1908f8u,0x07290c49u,0x45110204u,0x0201053fu),\nuvec4(0x11040a06u,0x03053105u,0x01132211u,0x150f0310u),\nuvec4(0x0301053fu,0x1f050f05u,0x450f1300u,0x0413150fu),\nuvec4(0x0b0d1907u,0x070a660au,0x0b061216u,0x0e070b04u),\nuvec4(0x12045315u,0x0c3d0c0bu,0x00043b09u,0x00120004u),\nuvec4(0x02030b04u,0x04003400u,0x01000410u,0x33250160u),\nuvec4(0x0f0e0f0eu,0x0f2e032eu,0x051f0e03u,0x051f8300u),\nuvec4(0x03151f03u,0x25f51175u,0x100100d1u,0x00b10231u),\nuvec4(0x03310021u,0x0d0c0704u,0x670b2709u,0x180b179bu),\nuvec4(0x18271817u,0x18070b27u,0x06071b07u,0x535f3502u),\nuvec4(0x01003115u,0x00010203u,0x43016311u,0x0b063025u),\nuvec4(0xa8092807u,0x0c590719u,0x31120b29u,0x1f150f25u),\nuvec4(0x06041205u,0x01354104u,0x04002312u,0x03057f13u),\nuvec4(0x1f050f05u,0x351f1305u,0x0305030fu,0x0204020eu),\nuvec4(0x14a60a2bu,0x07020b07u,0x2205020bu,0x06040e23u),\nuvec4(0x1d0b2603u,0x021b3c0bu,0x0d070634u,0x04020403u),\nuvec4(0x22003400u,0x0f030570u,0x1f7e1e33u,0x051f0e03u),\nuvec4(0x33051301u,0x052f030fu,0x653f050fu,0x9115f531u),\nuvec4(0x01000100u,0x31000100u,0x11020302u,0x0105e105u),\nuvec4(0x0c0b0403u,0x7ba70c1du,0x08072837u,0x38173837u),\nuvec4(0x0b070b07u,0x150f0503u,0x25133e4fu,0x11021041u),\nuvec4(0x13150305u,0x1f231115u,0x07063025u,0x88491809u),\nuvec4(0x0c090709u,0x02040869u,0x0f051120u,0x13050115u),\nuvec4(0x02031200u,0x05510204u,0x01130223u,0x05030406u),\nuvec4(0x053f053fu,0x1f03114fu,0x1f132f15u,0x2724020eu),\nuvec4(0x120b04b6u,0x01331203u,0x0b020e03u,0x0a160b02u),\nuvec4(0x0c2b0d0bu,0x041b1c0du,0x0d0b070bu,0x0022141eu),\nuvec4(0x21120004u,0x11000102u,0x2f0e0302u,0x13030f23u),\nuvec4(0x1f05133eu,0x050f0e03u,0x23051311u,0x3f13055fu),\nuvec4(0x01002145u,0x15f50105u,0x00211501u,0x13414021u),\nuvec4(0x15a10021u,0x05010501u,0x1d0b0603u,0x1807090cu),\nuvec4(0x68376b67u,0x68173827u,0x25030b07u,0x15231e5fu),\nuvec4(0x02010041u,0x65010203u,0x01153f43u,0x04000100u),\nuvec4(0x49180706u,0x09280958u,0x0c084907u,0x040b0709u),\nuvec4(0x25211001u,0x03150302u,0x00120011u,0x15011021u),\nuvec4(0x00131203u,0x05030204u,0x0f1301efu,0x3f033f15u),\nuvec4(0x0402030eu,0x170b091bu,0x0416170bu,0x02041326u),\nuvec4(0x15030503u,0x0e030503u,0x04061400u,0x1b1d0a26u),\nuvec4(0x0c0d1c07u,0x01052e1du,0x00140b1eu,0x02040013u),\nuvec4(0x43111001u,0x030f233fu,0x0e1f1e03u,0x2305030fu),\nuvec4(0x00010315u,0x0e131103u,0x0503155fu,0x0001354fu),\nuvec4(0x0115f531u,0x11505125u,0x91051300u,0x41052110u),\nuvec4(0x1d0a060eu,0x4807090cu,0x78276b37u,0x78070807u),\nuvec4(0x04073809u,0x2513af13u,0x02030231u,0x05032521u),\nuvec4(0x3f330513u,0x00110025u,0x19080704u,0x59082918u),\nuvec4(0x390c0908u,0x070c190cu,0x0001021bu,0x05010001u),\nuvec4(0x05030201u,0x11031503u,0x04001200u,0x03112002u),\nuvec4(0x03020105u,0x13020001u,0x4f033f05u,0x012f0305u),\nuvec4(0x3f031f13u,0x031e3f13u,0x1b073b12u,0x14020407u),\nuvec4(0x01001233u,0x14032203u,0x5d0b560bu,0x021c070bu),\nuvec4(0x05231103u,0x12140203u,0x01020403u,0x05210210u),\nuvec4(0x0f033f03u,0x15034f33u,0x05030503u,0x03110513u),\nuvec4(0x05030100u,0x03050f0eu,0x0f05032fu,0x451f1503u),\nuvec4(0x00011201u,0x0511b501u,0x25014501u,0x00213001u),\nuvec4(0x03150321u,0x51251105u,0x01150125u,0x06030e05u),\nuvec4(0x08091d07u,0x3b374807u,0xd8077847u,0x03020709u),\nuvec4(0x0f1e8f05u,0x41050305u,0x01120112u,0x33450105u),\nuvec4(0x01253f1eu,0x07060410u,0x08890829u,0x090c390cu),\nuvec4(0x070c090cu,0x40030b18u,0x02250311u,0x04003123u),\nuvec4(0x11100206u,0x01230103u,0x057f0322u,0x1f03150fu),\nuvec4(0x1f130105u,0x0f051f03u,0x030e5f13u,0x1b0d1b52u),\nuvec4(0x07040b17u,0x1b04121bu,0x66141203u,0x072d1607u),\nuvec4(0x0b0d140au,0x02100426u,0x02140223u,0x25331203u),\nuvec4(0x0f331f03u,0x250f1523u,0x02010001u,0x01000123u),\nuvec4(0x03011013u,0x0e030f0eu,0x350f752fu,0x21020311u),\nuvec4(0x31000185u,0x01050155u,0x35135140u,0x15210021u),\nuvec4(0x0e037511u,0x1d0c0a04u,0xb7480708u,0x17c81778u),\nuvec4(0x6f15130bu,0x1125230eu,0x11121105u,0x63251102u),\nuvec4(0x0410256fu,0xc9080b06u,0x090c290cu,0x0728092cu),\nuvec4(0x13014002u,0x04000305u,0x11000123u,0x21022410u),\nuvec4(0x03220133u,0x131f037fu,0x2301051fu,0x030f031fu),\nuvec4(0x1f0e030fu,0x032e3f03u,0x33121312u,0x00121702u),\nuvec4(0x020d0b06u,0x2607e604u,0x0c0b0002u,0x120b040bu),\nuvec4(0x1b330213u,0x02000233u,0x15030501u,0x050f053fu),\nuvec4(0x01150213u,0x33056300u,0x4f132005u,0x85030f03u),\nuvec4(0x0001150fu,0x11650302u,0x11154115u,0x11305105u),\nuvec4(0x35032100u,0x15310031u,0x030e7511u,0x191d0706u),\nuvec4(0x27183758u,0x09881798u,0x130b0728u,0x0f0e6f15u),\nuvec4(0x1305330eu,0x02001102u,0x05830001u,0x01259f03u),\nuvec4(0x09f90714u,0x1907390cu,0x40021718u,0x00031501u),\nuvec4(0x02032513u,0x04000105u,0x05110416u,0x03021302u),\nuvec4(0x7f130200u,0x03051f03u,0x2300031fu,0x153f030fu),\nuvec4(0x0e03050fu,0x5e03051fu,0x05110533u,0x020b3403u),\nuvec4(0x140246f6u,0x141b0200u,0x22030022u,0x03020e03u),\nuvec4(0x00221302u,0x65001305u,0x11100201u,0x231f4503u),\nuvec4(0x23200105u,0x031f135fu,0x35020395u,0x00a10051u),\nuvec4(0x10016001u,0x15030511u,0x10110513u,0x05010531u),\nuvec4(0x000e6521u,0x0c0d1c0au,0x07c85758u,0x09380948u),\nuvec4(0x030b0718u,0x3f1e5f45u,0x02100135u,0x05031103u),\nuvec4(0x7f730503u,0x04002115u,0x0cf92c07u,0x09070908u),\nuvec4(0x02031728u,0x01200200u,0x03451310u,0x02000105u),\nuvec4(0x02230604u,0x00011213u,0x456f0513u,0x00150f03u),\nuvec4(0x0f1e130eu,0x15232503u,0x012f1e23u,0x4e030510u),\nuvec4(0x66140223u,0x96070607u,0x04020a0bu,0x13120012u),\nuvec4(0x10030214u,0x03000102u,0x030e032eu,0x02010302u),\nuvec4(0x01001203u,0x10010200u,0x25034202u,0x00130e5fu),\nuvec4(0x8f130004u,0x03050345u,0xd1153135u,0x11101102u),\nuvec4(0x11201100u,0xa1451110u,0x01050115u,0x07040375u),\nuvec4(0x18091c2du,0x4807b877u,0x08291809u,0x25011317u),\nuvec4(0x0e035f03u,0x0211452fu,0x01051203u,0x7f532513u),\nuvec4(0x06300f05u,0x0c192c08u,0x08791c39u,0x3809080cu),\nuvec4(0x01020309u,0x12000203u,0x65010316u,0x13020421u),\nuvec4(0x13120302u,0x159f2311u,0x0103050fu,0x2e030e02u),\nuvec4(0x0f13150fu,0x05130e03u,0x15230e03u,0x15230002u),\nuvec4(0x20051f03u,0x3b0d1b86u,0x061b0a36u,0x15031203u),\nuvec4(0x14132503u,0x13220310u,0x03041301u,0x13010312u),\nuvec4(0x03020105u,0x01431222u,0x032f1500u,0x0001130fu),\nuvec4(0x4f050302u,0x03150f05u,0x01352315u,0xf1551100u),\nuvec4(0x05416051u,0x00110501u,0x85010581u,0x0c06030fu),\nuvec4(0x6728094du,0x180918f8u,0x0708090cu,0x4501030du),\nuvec4(0x030e034fu,0x350f130eu,0x05114201u,0x33010501u),\nuvec4(0x057f031eu,0x0401100fu,0x092c0908u,0x080cb91cu),\nuvec4(0x380c0819u,0x01100207u,0x00010300u,0x030b0706u),\nuvec4(0x04000175u,0x23121103u,0x6f231102u,0x03150f03u),\nuvec4(0x02011305u,0x0f0e030eu,0x05131f0eu,0x1e331e0fu),\nuvec4(0x1e030513u,0x10054f23u,0x070a6604u,0x08090b0du),\nuvec4(0x1b360a2bu,0x01100207u,0x02041065u,0x12030113u),\nuvec4(0x22030410u,0x00620001u,0x33042212u,0x03020302u),\nuvec4(0x5f05434fu,0x00120125u,0x00012521u,0x00b15511u),\nuvec4(0x10310031u,0x03050361u,0x01100315u,0x01b56103u),\nuvec4(0x5d080203u,0x19c8871cu,0x19280908u,0x01030b07u),\nuvec4(0x1f030f65u,0x01650f33u,0x11020302u,0x15031100u),\nuvec4(0x0f058f43u,0x08041001u,0x0ca95c09u,0x09082908u),\nuvec4(0x02030738u,0x0c070440u,0x0085030du,0x11050306u),\nuvec4(0x05230142u,0x0113355fu,0x130f3320u,0x0f2e230fu),\nuvec4(0x0e0f1e13u,0x0e030503u,0x4f03051fu,0x46040005u),\nuvec4(0x1b060a17u,0x1b070807u,0x170b4607u,0x00041004u),\nuvec4(0x01130165u,0x02030200u,0x02030503u,0x03020403u),\nuvec4(0x10021152u,0x02000202u,0x0e031210u,0x3f0e0305u),\nuvec4(0x05130f1eu,0x0503051fu,0x1402550fu,0x01030210u),\nuvec4(0x03000400u,0x00e13501u,0x05615031u,0x00410311u),\nuvec4(0x0105f501u,0x07040500u,0x0c0d4c0du,0x27183708u),\nuvec4(0x18399809u,0x0b071809u,0x3f451103u,0x020021b3u),\nuvec4(0x23051341u,0x20159f05u,0x190c0906u,0x1829f91cu),\nuvec4(0x03071809u,0x04110002u,0x090b0406u,0x1165030cu),\nuvec4(0x11030604u,0x0e135203u,0x2f050f03u,0x05130f35u),\nuvec4(0x0e0f3320u,0x0f0e0503u,0x4e032e13u,0x1f0e030fu),\nuvec4(0x0e3f1305u,0x17360401u,0x272b0708u,0x0a0b0d0bu),\nuvec4(0x063b0a36u,0x01003402u,0x01030125u,0x05230200u),\nuvec4(0x03041311u,0x00022110u,0x02012201u,0x0e020452u),\nuvec4(0x050f050fu,0x0e2f0e03u,0x331f150fu,0x00010305u),\nuvec4(0x40240321u,0x81551102u,0x21001120u,0x11003160u),\nuvec4(0x01032205u,0x01050102u,0x100105f5u,0x1c1d0b13u),\nuvec4(0x07182c07u,0x39584748u,0x02172928u,0x2e3f2531u),\nuvec4(0x01450f13u,0x05212220u,0x0f530113u,0x01056f0eu),\nuvec4(0x08070400u,0x194819f9u,0x07080907u,0x0002030bu),\nuvec4(0x1b040604u,0x03070908u,0x00050155u,0x02030406u),\nuvec4(0x01033203u,0x050f0573u,0x00430e2fu,0x030f0e23u),\nuvec4(0x0e2f0e0fu,0x0e1f7e03u,0x0301051fu,0x0f0e1f0eu),\nuvec4(0x280b3614u,0x0718073bu,0x0a070d0bu,0x0b0d0a16u),\nuvec4(0x10416427u,0x01051301u,0x10020b33u,0x11021001u),\nuvec4(0x04141302u,0x04020022u,0x050f0e02u,0x0e0f0e1fu),\nuvec4(0x151f153fu,0x00031233u,0x03520511u,0x71551110u),\nuvec4(0x01b04100u,0x33052302u,0x1045f501u,0x0e030103u),\nuvec4(0x0d0c0702u,0x680c1d1cu,0x58171b07u,0x17392829u),\nuvec4(0x15210302u,0x2305335fu,0x03022115u,0x03050122u),\nuvec4(0x1f131501u,0x156f0e13u,0x08040001u,0x390809f9u),\nuvec4(0x08070918u,0x10031b07u,0x070b0604u,0x0719070bu),\nuvec4(0x04006503u,0x11020306u,0x01020322u,0x0f031573u),\nuvec4(0x1f031f05u,0x03040105u,0x030f130fu,0x0e0f0e05u),\nuvec4(0x3e030e0fu,0x054f1e1fu,0x00050210u,0x07360405u),\nuvec4(0x1728070bu,0x07380708u,0x070a072bu,0x08070b0du),\nuvec4(0x04063407u,0x02300406u,0x15030201u,0x03052301u),\nuvec4(0x32112012u,0x02140b16u,0x04000200u,0x03050e03u),\nuvec4(0x11c55f05u,0x15010200u,0x02030223u,0x10010001u),\nuvec4(0x81250105u,0x01007100u,0x41002100u,0x01050100u),\nuvec4(0x01f50145u,0x0e152310u,0x2d3c0702u,0x0b174809u),\nuvec4(0x08192817u,0x08391829u,0x31030617u,0x1f150f15u),\nuvec4(0x15430e03u,0x02230221u,0x05130541u,0x0e130503u),\nuvec4(0x01056f03u,0x0c080400u,0x0c1908f9u,0x2b070819u),\nuvec4(0x04200302u,0x29180706u,0x04115513u,0x12210203u),\nuvec4(0x02000203u,0x15031573u,0x0401054fu,0x0f030f13u),\nuvec4(0x1f1e0305u,0x7f3e0f1eu,0x00040003u,0x0b460014u),\nuvec4(0xc8070b0du,0x1d070d0bu,0x07091807u,0x12140624u),\nuvec4(0x03110210u,0x03210001u,0x00220e15u,0x03120012u),\nuvec4(0x020b0704u,0x00020402u,0x1e020402u,0x2f13150fu),\nuvec4(0x35034513u,0x03021513u,0x23050145u,0x01120305u),\nuvec4(0x61056110u,0x01201130u,0x0345b100u,0x11251115u),\nuvec4(0x25031045u,0x020e1503u,0x092d3c06u,0x170b1738u),\nuvec4(0x29380918u,0x0b171918u,0x21000316u,0x3f150100u),\nuvec4(0x2305432eu,0x00012201u,0x25030501u,0x01058f53u),\nuvec4(0x0c090704u,0x171c29f9u,0x02040b0du,0x04000220u),\nuvec4(0x0b290807u,0x01251f13u,0x21031200u,0x05013022u),\nuvec4(0x05330503u,0x2f051f03u,0x23101f05u,0x0e050f0eu),\nuvec4(0x4e1f0e0fu,0x3401256fu,0x070b2756u,0x1d0b07c8u),\nuvec4(0x0b09280bu,0x0014060au,0x12000214u,0x10020001u),\nuvec4(0x03040001u,0x22042301u,0x02000100u,0x04002213u),\nuvec4(0x1e020422u,0x0f23050fu,0x03252f05u,0x03254375u),\nuvec4(0x13050325u,0x05113215u,0xe0010551u,0x35110591u),\nuvec4(0x15010501u,0x00113521u,0x45031502u,0x0d09040eu),\nuvec4(0x38091d2cu,0x68072b07u,0x17191829u,0x0204060bu),\nuvec4(0x25101110u,0x332e031fu,0x22411305u,0x23252315u),\nuvec4(0x00155f1eu,0xf9081604u,0x06070d69u,0x06044002u),\nuvec4(0x090c190bu,0x1f15030bu,0x13020025u,0x00012205u),\nuvec4(0x53022102u,0x2f151315u,0x10050f05u,0x4f030533u),\nuvec4(0x054f035eu,0x56340001u,0x2be8371bu,0x07080918u),\nuvec4(0x0004460bu,0x02141211u,0x04061103u,0x040e0112u),\nuvec4(0x01000302u,0x22000102u,0x04000203u,0x03040012u),\nuvec4(0x0f233f0eu,0x45234523u,0x25133523u,0x01150123u),\nuvec4(0xb0811543u,0x050105c1u,0x15112503u,0x00211501u),\nuvec4(0x23050301u,0x01050f05u,0x2c09040eu,0x1718092du),\nuvec4(0x1988171bu,0x19071908u,0x0304020bu,0x21000102u),\nuvec4(0x0e132f25u,0x01130533u,0x22031105u,0x130e7305u),\nuvec4(0x0210253fu,0x39160400u,0x0709f90cu,0x0203060bu),\nuvec4(0x0b140130u,0x090c0908u,0x350f0503u,0x13020100u),\nuvec4(0x02030501u,0x23620001u,0x23450325u,0x13020015u),\nuvec4(0x03050305u,0x1e0f4e3fu,0x0f052f03u,0x26240005u),\nuvec4(0xf8272b07u,0x09181728u,0x070b0918u,0x20010236u),\nuvec4(0x02040214u,0x13002411u,0x00011204u,0x00020332u),\nuvec4(0x14120400u,0x033f0e0du,0x23d5033fu,0x01150345u),\nuvec4(0x41220315u,0x21105125u,0x01101100u,0x81100100u),\nuvec4(0x11652145u,0x15033005u,0x25030503u,0x08040e01u),\nuvec4(0x0d1c0d0cu,0x1718090cu,0x4998071bu,0x00041b08u),\nuvec4(0x23050302u,0x0f434f25u,0x03350325u,0x83052300u),\nuvec4(0x0001153fu,0x00110302u,0x08070604u,0x38d90c09u),\nuvec4(0x02040b07u,0x14013001u,0x0b190807u,0x250f0503u),\nuvec4(0x05630200u,0x15236211u,0x05134513u,0x13020113u),\nuvec4(0x4f050305u,0x00050f4eu,0x1f250301u,0x0b160213u),\nuvec4(0xf8170b07u,0x07280738u,0x04360b68u,0x24000102u),\nuvec4(0x01021400u,0x12040b02u,0x00012203u,0x03020002u),\nuvec4(0x22041102u,0x9f0e0304u,0x03450f05u,0x23850325u),\nuvec4(0x13022325u,0x00e14011u,0x00010201u,0x057135a1u),\nuvec4(0x05110511u,0x85030201u,0x09040e01u,0x070c1d2cu),\nuvec4(0x071b1718u,0x060b49a8u,0x21000204u,0x030e5f45u),\nuvec4(0x030f030eu,0x23021145u,0x43053305u,0x0320152fu),\nuvec4(0x16042005u,0xa91c1908u,0x020b2738u,0x02010001u),\nuvec4(0x07040001u,0x130d1918u,0x9335031fu,0x33120012u),\nuvec4(0x45130501u,0x00131513u,0x5e4f2513u,0x03000203u),\nuvec4(0x05030105u,0x0604051fu,0x78f80b0du,0x3617a807u),\nuvec4(0x04221012u,0x00020400u,0x02140201u,0x2322030eu),\nuvec4(0x12040021u,0x0e0d0400u,0x0f132e5fu,0x03051f55u),\nuvec4(0x03050305u,0x01652335u,0x12130105u,0x00713031u),\nuvec4(0x03010211u,0x00e10001u,0x35010011u,0x75330021u),\nuvec4(0x040e0300u,0x090d3c09u,0x071b2718u,0x0b0729a8u),\nuvec4(0x0003040au,0x436f1541u,0x02010355u,0x05430523u),\nuvec4(0x052f0e33u,0x03021001u,0x04100105u,0x1c090816u),\nuvec4(0x180918a9u,0x020b071bu,0x02000130u,0x010d3907u),\nuvec4(0x03010533u,0x03256315u,0x23112322u,0x03050325u),\nuvec4(0x11051305u,0x051f0533u,0x1e134f03u,0x03000223u),\nuvec4(0x1b06001fu,0x58f80928u,0x38071837u,0x04261b07u),\nuvec4(0x02200402u,0x02044014u,0x1e030204u,0x10012513u),\nuvec4(0x03041204u,0x2f0e2f0eu,0x031f0e03u,0x1355132fu),\nuvec4(0x13052305u,0x12055185u,0x00310201u,0x00510061u),\nuvec4(0x00510041u,0x05910011u,0x01650133u,0x09040e15u),\nuvec4(0x08071d2cu,0x48072b37u,0x17191809u,0x03020416u),\nuvec4(0x11001110u,0x032e5f15u,0x11122165u,0x230e4325u),\nuvec4(0x0400152fu,0x20011502u,0x09080604u,0x0708e90cu),\nuvec4(0x2001023bu,0x04010001u,0x030b0918u,0x151f1305u),\nuvec4(0x15030503u,0x15330503u,0x11132203u,0x65011513u),\nuvec4(0x01000503u,0x132f1523u,0x05030e2fu,0x10051e1fu),\nuvec4(0x04000103u,0xf8070d06u,0x17381918u,0x070b070bu),\nuvec4(0x17480708u,0x0206070bu,0x24300213u,0x02040120u),\nuvec4(0x11650310u,0x14020400u,0x1e3f0e03u,0x030f0e4fu),\nuvec4(0x03050f05u,0x63250335u,0xa1150155u,0x01020312u),\nuvec4(0x00120112u,0x10010012u,0x20011011u,0x12211001u),\nuvec4(0x05021301u,0x01021102u,0x01131203u,0x01351100u),\nuvec4(0x0e150200u,0x0c0d3c0bu,0x3b270809u,0x0b393807u),\nuvec4(0x03021607u,0x00011012u,0x4f250011u,0x1305531eu),\nuvec4(0x03022105u,0x13150102u,0x032f5325u,0x03020402u),\nuvec4(0x04001115u,0x0c090806u,0x08090cd9u,0x12070b0du),\nuvec4(0x02410001u,0x0b070807u,0x1f050f13u,0x0f050f03u),\nuvec4(0x93050f05u,0x13020312u,0x03051115u,0x10550105u),\nuvec4(0x032f0533u,0x1f251e1fu,0x00030233u,0x070d1604u),\nuvec4(0x3b1768f8u,0x08073827u,0x070b0807u,0x01022304u),\nuvec4(0x01103400u,0x00120400u,0x13050103u,0x02001035u),\nuvec4(0x03051e14u,0x3f137f3eu,0x03450325u,0x55030501u),\nuvec4(0x05211511u,0x420102c1u,0x43226140u,0x43021302u),\nuvec4(0x11053322u,0x15132105u,0x0d1c070eu,0x180c0d0cu),\nuvec4(0x38073b27u,0x070c0819u,0x04030416u,0x35410220u),\nuvec4(0x0523257fu,0x02030231u,0x0e338501u,0x0314011fu),\nuvec4(0x04000135u,0x0c090a06u,0x0b071cd9u,0x04020406u),\nuvec4(0x05010302u,0x07040021u,0x63af2302u,0x42131205u),\nuvec4(0x11151103u,0x03050105u,0x03020015u,0x3f050335u),\nuvec4(0x2f031203u,0x00052315u,0xf81b1604u,0x275b0758u),\nuvec4(0x03060b88u,0x02000125u,0x22101134u,0x55030503u),\nuvec4(0x02041211u,0x132f051eu,0x3f0e0f1eu,0x031f0513u),\nuvec4(0x1135132fu,0x55111203u,0x00310391u,0x31105231u),\nuvec4(0x01220372u,0x02031200u,0x31020031u,0x03010502u),\nuvec4(0x03210321u,0x2d1c080eu,0x0807080cu,0x18074b07u),\nuvec4(0x160b3907u,0x01300304u,0x831f9503u,0x31222125u),\nuvec4(0x23550105u,0x02040115u,0x10013513u,0x990c0816u),\nuvec4(0x040b095cu,0x15131400u,0x12040021u,0xd39f1300u),\nuvec4(0x01020112u,0x05010302u,0x02004521u,0x0513a503u),\nuvec4(0x0e0f052fu,0x1600131fu,0x58f8070bu,0x2b2d0b07u),\nuvec4(0x04078817u,0x00111513u,0x00110234u,0x03020302u),\nuvec4(0x12314501u,0x051e0304u,0x0e0f132fu,0x0523056fu),\nuvec4(0x35232f03u,0x15033213u,0x15410501u,0x41127103u),\nuvec4(0x03623100u,0x31120122u,0x12003123u,0x030125a1u),\nuvec4(0x0d1c0805u,0x6b17181cu,0x16391817u,0x30010003u),\nuvec4(0xc3651301u,0x41124105u,0x01050f85u,0x151f2300u),\nuvec4(0x0001050fu,0x39070604u,0x191c8908u,0x5503340bu),\nuvec4(0x15320001u,0x0105a37fu,0x12010205u,0x02030201u),\nuvec4(0x35010513u,0x13010501u,0x00151145u,0x13550301u),\nuvec4(0x00030e2fu,0x0768f816u,0x0d0b1d0bu,0x0708271bu),\nuvec4(0x13070b58u,0x01000105u,0x01023400u,0x00031210u),\nuvec4(0x03151001u,0x00020021u,0x1f0e0302u,0x0f131f03u),\nuvec4(0x2f635f0eu,0x13552305u,0x05112512u,0x00b12531u),\nuvec4(0x22111011u,0xe1004201u,0x21000115u,0x15034105u),\nuvec4(0x07040e11u,0x090c092du,0x48077b17u,0x04060b0cu),\nuvec4(0x31157102u,0x05000200u,0x01450f53u,0x01322105u),\nuvec4(0x130001b5u,0x0f052f15u,0x16041005u,0x19083907u),\nuvec4(0x191c390cu,0x0204020bu,0x1f030200u,0x00121035u),\nuvec4(0x252f1304u,0x0305b30fu,0x01130205u,0x03020103u),\nuvec4(0x35013512u,0x01151103u,0x00050120u,0x15010304u),\nuvec4(0x050e3f43u,0xf8070604u,0x3d1b0748u,0x770b070bu),\nuvec4(0x030b0918u,0x20050f05u,0x00020024u,0x01020001u),\nuvec4(0x02001200u,0x05030501u,0x04020011u,0x1f0e0302u),\nuvec4(0x1f031f03u,0x0f035f03u,0x033f330eu,0x230501a5u),\nuvec4(0x41254115u,0x21023100u,0x01301110u,0x6103f172u),\nuvec4(0x0e052115u,0x1c1d0c06u,0x277b2708u,0x0b090b09u),\nuvec4(0x10011216u,0x01052001u,0x02131130u,0x030f2501u),\nuvec4(0x0221650fu,0x05210203u,0x01035511u,0x155f0310u),\nuvec4(0x07260420u,0x0c590829u,0x04091c0du,0x04000102u),\nuvec4(0x10251f13u,0x1f133002u,0x73050345u,0x01122335u),\nuvec4(0x03020112u,0x01250105u,0x11a00305u,0x5f233512u),\nuvec4(0x17060305u,0x37680798u,0x0d0b1d0bu,0x670b070bu),\nuvec4(0x031b0918u,0x00050f05u,0x00240001u,0x04100102u),\nuvec4(0x03022012u,0x04002025u,0x131f1e03u,0x031f033fu),\nuvec4(0x132f030fu,0x050f0305u,0x0f35033fu,0x21450305u),\nuvec4(0x31008165u,0x01001122u,0x21100130u,0x91124102u),\nuvec4(0x01456103u,0x0c060305u,0x28190c0du,0x272b0d3bu),\nuvec4(0x06070d2bu,0x01401204u,0x34000105u,0x01050110u),\nuvec4(0x85031502u,0x11020021u,0x03352110u,0x00050305u),\nuvec4(0x03020103u,0x01252f05u,0x07160420u,0x0c0d0c99u),\nuvec4(0x10120b09u,0x1f030204u,0x10042025u,0x05038503u),\nuvec4(0x43254301u,0x12112205u,0x31051103u,0x34200422u),\nuvec4(0x03050140u,0x6f050315u,0x07060305u,0x370847c8u),\nuvec4(0x0d08070bu,0x271b171bu,0x030b2918u,0x44120115u),\nuvec4(0x04010002u,0x04220302u,0x10310302u,0x0f1e0204u),\nuvec4(0x030e0f03u,0x1f030e2fu,0x031f0e33u,0x335f030fu),\nuvec4(0x35230f05u,0x15113521u,0x00112021u,0x20110241u),\nuvec4(0x10011001u,0x00310001u,0x05e11261u,0x05011501u),\nuvec4(0x0d0c0703u,0x0807190cu,0x1d0b1709u,0x0708071bu),\nuvec4(0x070b0718u,0x20021306u,0x00211001u,0x04021402u),\nuvec4(0x11050102u,0x12302185u,0x45310001u,0x00131503u),\nuvec4(0x151f1503u,0x3001050fu,0x0c590726u,0x0d092c09u),\nuvec4(0x10010002u,0x251f1302u,0x13021410u,0x02052355u),\nuvec4(0x25130e13u,0x05031533u,0x05010041u,0x04001341u),\nuvec4(0x14004302u,0x02101400u,0x05130f13u,0x052f052fu),\nuvec4(0x57880704u,0x091b373bu,0x1b180b0du,0x28170807u),\nuvec4(0x25030b09u,0x44000200u,0x04000102u,0x04020322u),\nuvec4(0x02102113u,0x032e0300u,0x3f0e1f1eu,0x0e3f1e13u),\nuvec4(0x333f053fu,0x1155231fu,0x01051305u,0xc1050305u),\nuvec4(0x01000100u,0x0305b162u,0x03220105u,0x15610041u),\nuvec4(0x07030501u,0x19280c1du,0x0d0b0708u,0x370b0d1bu),\nuvec4(0x0206070du,0x35611001u,0x05330200u,0x00351110u),\nuvec4(0x40110001u,0x21021302u,0x01050105u,0x12010305u),\nuvec4(0x2f130005u,0x30052f15u,0x59071604u,0x071c090cu),\nuvec4(0x0100030du,0x1f130420u,0x01241115u,0x15132530u),\nuvec4(0x05030e33u,0x15330503u,0x21031503u,0x03510210u),\nuvec4(0x03020001u,0x12131521u,0x03101200u,0x053f131fu),\nuvec4(0x1704151fu,0x072b0778u,0x172b0726u,0x1718070bu),\nuvec4(0x0718071bu,0x070c1718u,0x12002503u,0x01122400u),\nuvec4(0x02010324u,0x01120001u,0x4e020230u,0x0e2f132fu),\nuvec4(0x5f030e03u,0x0e037f0eu,0xc5131503u,0x05110211u),\nuvec4(0x01220133u,0x22001132u,0x00110203u,0x02510011u),\nuvec4(0x00710241u,0x03011561u,0x0d0c0602u,0x08191809u),\nuvec4(0x0b3d0b17u,0x070d0b17u,0x21201216u,0x11050165u),\nuvec4(0x01200100u,0x11101165u,0x21020312u,0x01051105u),\nuvec4(0x01020013u,0x03010302u,0x2f053f05u,0x01001115u),\nuvec4(0x190b0604u,0x0749080cu,0x1440030du,0x053f0503u),\nuvec4(0x11102400u,0x03050325u,0x23154312u,0x10013355u),\nuvec4(0x13023112u,0x15210210u,0x0f831501u,0x030e030eu),\nuvec4(0x0500050fu,0x07060411u,0x1b961778u,0x08070b08u),\nuvec4(0x28174b07u,0x0e0b0719u,0x02050315u,0x02340003u),\nuvec4(0x04020410u,0x00110230u,0x03120001u,0x1f030f1eu),\nuvec4(0x1e2f131eu,0x0eff0e03u,0x0f231513u,0x01000185u),\nuvec4(0x13111312u,0x31020305u,0x22000122u,0x037105c1u),\nuvec4(0x05010061u,0x00051302u,0x07040e11u,0x48090d09u),\nuvec4(0x2b1d1b17u,0x0a0b0d07u,0x01021306u,0x020311f5u),\nuvec4(0x12a11513u,0x03055103u,0x01030011u,0x13050302u),\nuvec4(0x01455f15u,0x07060100u,0x030d2759u,0x03023021u),\nuvec4(0x0001054fu,0x25210014u,0x85531213u,0x05030501u),\nuvec4(0x01003113u,0x03010002u,0x00010301u,0x23a52103u),\nuvec4(0x05032f1eu,0x06041014u,0x06572807u,0x14023302u),\nuvec4(0x0b170b26u,0x28076b07u,0x050e0b19u,0x0113250fu),\nuvec4(0x02302400u,0x20240004u,0x03120011u,0x0f033f1eu),\nuvec4(0x0f033f13u,0x0f032f0eu,0x13059f03u,0x13150305u),\nuvec4(0x05018395u,0x11104113u,0x01006112u,0xb1006100u),\nuvec4(0x11005100u,0x07060103u,0x380c0d0cu,0x0b0d3b17u),\nuvec4(0x16170b07u,0xf5030213u,0x15130125u,0x02033281u),\nuvec4(0x01004125u,0x45031503u,0x652f052fu,0x07160200u),\nuvec4(0x23040726u,0x12002501u,0x4f0e0300u,0x22000105u),\nuvec4(0x13050311u,0x03357302u,0x01150135u,0x10210305u),\nuvec4(0x00121102u,0x31030011u,0x030e03b5u,0x22033f0eu),\nuvec4(0x37040203u,0x4312130bu,0x14000215u,0x27060716u),\nuvec4(0x0928076bu,0x03650e07u,0x20240211u,0x06240002u),\nuvec4(0x02040604u,0x02000200u,0x034f0e03u,0x1f15130fu),\nuvec4(0xaf036f03u,0x75530f23u,0x11232521u,0x15021115u),\nuvec4(0x30010211u,0x22030231u,0x02110041u,0x10710551u),\nuvec4(0x06030511u,0x190c0d17u,0x2d2b1728u,0x02260a07u),\nuvec4(0x0f350103u,0x0f250f15u,0x81550175u,0x11105122u),\nuvec4(0x01050102u,0x4f150315u,0x11353f25u,0x13260402u),\nuvec4(0x3155030eu,0x054f0e03u,0x11031211u,0x75631223u),\nuvec4(0x31034501u,0x00120100u,0x00051102u,0x2f3ea581u),\nuvec4(0x1e030e13u,0x2f331e33u,0x04331e23u,0x0b06070au),\nuvec4(0x074b070du,0x030d2908u,0x0001750fu,0x40240002u),\nuvec4(0x04060b24u,0x03000112u,0x1f0e3f05u,0x05030503u),\nuvec4(0x5f03050fu,0x0f23cf03u,0x35138543u,0x00211543u),\nuvec4(0x21103201u,0x03050110u,0x05512251u,0x05911511u),\nuvec4(0x09070600u,0x28091c0du,0x1b071b17u,0x0302261du),\nuvec4(0x255f2501u,0x3501950fu,0x32211521u,0x10110011u),\nuvec4(0x21030201u,0x4f250315u,0x4f050305u,0x01150f05u),\nuvec4(0x130b1413u,0x30351105u,0x353f0e05u,0x02032210u),\nuvec4(0x2f630211u,0x00550175u,0x21220011u,0x01001100u),\nuvec4(0x23856100u,0x231e232eu,0x13151f05u,0x02132e9fu),\nuvec4(0x1b0a0604u,0x0c090847u,0x01250319u,0x10010355u),\nuvec4(0x0b341044u,0x10120607u,0x1f030110u,0x13451f0eu),\nuvec4(0x03cf056fu,0x1f45530eu,0x01052145u,0x61150305u),\nuvec4(0x01100122u,0x11036110u,0x31057122u,0x04036105u),\nuvec4(0x0c0d0917u,0x38074809u,0x160b0d07u,0x25010304u),\nuvec4(0x350f25bfu,0x00410531u,0x03212231u,0x23411001u),\nuvec4(0x2f051f05u,0x15031f05u,0x0e03554fu,0x010f0e03u),\nuvec4(0x03051100u,0x13001115u,0x0f030f0eu,0x01121025u),\nuvec4(0x63120012u,0x1503255fu,0x15011501u,0x12041021u),\nuvec4(0x20110011u,0x451f5571u,0x4e130fb3u,0x031e03afu),\nuvec4(0x08171b04u,0x090c0917u,0x0f050317u,0x001400a5u),\nuvec4(0x161b0674u,0x01100304u,0x353f0503u,0x4f150302u),\nuvec4(0x2f63cf25u,0x01452f15u,0x10316500u,0x00013011u),\nuvec4(0x02510571u,0x00010001u,0x15411321u,0x03010001u),\nuvec4(0x1c080704u,0x171b4809u,0x04262b09u,0x1fff1503u),\nuvec4(0x81251145u,0x10010022u,0x01120021u,0x05031502u),\nuvec4(0x052f051fu,0x4503355fu,0x10013f03u,0x33310301u),\nuvec4(0x0115230fu,0x01020100u,0x355f6352u,0x00112541u),\nuvec4(0x30120004u,0x20112001u,0xb5310011u,0x05033503u),\nuvec4(0x0f230e13u,0x0e033f03u,0x8f030e03u,0x37040203u),\nuvec4(0x1302062bu,0x0f150f55u,0x02100125u,0x16242604u),\nuvec4(0x0b170807u,0x85210003u,0x1f230f13u,0x0f450315u),\nuvec4(0x030e4f05u,0x031f131fu,0x0305034fu,0x03052185u),\nuvec4(0x01502115u,0x21059100u,0x21001120u,0x11030500u),\nuvec4(0x03020105u,0x15010501u,0x1c090704u,0x0b272809u),\nuvec4(0x0446170du,0x6fff0513u,0x12307135u,0x11120011u),\nuvec4(0x02000200u,0x1f130501u,0x2f051f05u,0x03154f03u),\nuvec4(0x0f053f35u,0x15212005u,0x230f3301u,0x12001105u),\nuvec4(0x03020300u,0x03051322u,0x03055f25u,0x21053125u),\nuvec4(0x03021100u,0x01001170u,0x11002120u,0x0ff51105u),\nuvec4(0x13050345u,0x138f035fu,0x13560412u,0x01250f95u),\nuvec4(0x14010204u,0x17162406u,0x00030719u,0x01050120u),\nuvec4(0x03150f55u,0x1f05030fu,0x4f035fa5u,0x01754f33u),\nuvec4(0x21153100u,0x11001130u,0x51156100u,0x00010200u),\nuvec4(0x05010001u,0x33010501u,0x06210305u,0x290c0907u),\nuvec4(0x1d1b0718u,0x0204460au,0x256fff13u,0x22011091u),\nuvec4(0x05020391u,0x151f0503u,0x454f050fu,0x03010003u),\nuvec4(0x40052f35u,0x05012501u,0x03150f03u,0x04000115u),\nuvec4(0x05221322u,0x256f4523u,0x02010071u,0x11601201u),\nuvec4(0x31300110u,0x01351105u,0x03d50305u,0x05030f15u),\nuvec4(0x156f134fu,0x0001051fu,0x25030256u,0x65032503u),\nuvec4(0x44020302u,0x07090736u,0x60000203u,0x03010011u),\nuvec4(0x3f050335u,0x25030f05u,0x238f133fu,0x3f0e130eu),\nuvec4(0x03053175u,0x10211021u,0x00110011u,0x41231511u),\nuvec4(0x13021312u,0x51052302u,0x09070620u,0x1718390cu),\nuvec4(0x0446070bu,0x656fff23u,0x05010511u,0x00010011u),\nuvec4(0x13711022u,0x01101115u,0x1f050f25u,0x05130255u),\nuvec4(0x2001055fu,0x23250302u,0x3011150fu,0x02031203u),\nuvec4(0x35610201u,0x0021354fu,0x70011051u,0x60011001u),\nuvec4(0x05110551u,0xf5011501u,0x5f134f25u,0x15030f15u),\nuvec4(0x03470201u,0x03650f05u,0x01050355u,0x06171634u),\nuvec4(0x02030b07u,0x80010210u,0x050f1511u,0x056f0513u),\nuvec4(0x2e9f133fu,0x11555f13u,0x01028105u,0x11001140u),\nuvec4(0x03053365u,0x03421102u,0x31101102u,0x09070604u),\nuvec4(0x6617490cu,0x4f130204u,0x752fff0eu,0x22013021u),\nuvec4(0x05811001u,0x12040011u,0x650f0503u,0x00013f83u),\nuvec4(0x05131501u,0x2503150fu,0x02300103u,0x01002203u),\nuvec4(0x01053120u,0x61451f55u,0x11300150u,0x41900120u),\nuvec4(0x11050115u,0x35f50105u,0x4f030f03u,0x03150f15u),\nuvec4(0x0704250fu,0xc5030719u,0x1001350fu,0x1c070614u),\nuvec4(0x0430130bu,0x22006406u,0x03052f13u,0x03051f25u),\nuvec4(0x0e030fffu,0x653f1533u,0x20110071u,0x00111001u),\nuvec4(0x15010011u,0x10514511u,0x40212201u,0x0c091704u),\nuvec4(0x07190c19u,0x0446070bu,0x959fff23u,0x02031251u),\nuvec4(0x05510211u,0x65531501u,0x45230533u,0x0f53150fu),\nuvec4(0x25030f03u,0x01001103u,0x70130402u,0x02010001u),\nuvec4(0x452f4511u,0x30015051u,0x0031e011u,0x11053105u),\nuvec4(0x0f0335f5u,0x012503a5u,0x07190700u,0x15010003u),\nuvec4(0x1501a50fu,0x07061400u,0x3602071cu,0x22044614u),\nuvec4(0x4f230e03u,0x03051305u,0xff050315u,0x45130e1fu),\nuvec4(0x6071650fu,0x013305a1u,0x51151125u,0x04402100u),\nuvec4(0x38191c17u,0x03044607u,0x9fff1302u,0x215251a5u),\nuvec4(0x03150100u,0x65012315u,0x130f3513u,0x7f250365u),\nuvec4(0x01050305u,0x90032220u,0x45110011u,0x1001154fu),\nuvec4(0x40212021u,0x80210011u,0x00310001u,0xc5313571u),\nuvec4(0x2513a513u,0x07040201u,0x02040003u,0x0f450f15u),\nuvec4(0x11351f05u,0x1c090400u,0x22343607u,0x05430204u),\nuvec4(0x2f055f03u,0x13151f05u,0x230fff05u,0x210501d5u),\nuvec4(0x01600100u,0x11000102u,0x05033100u,0x00415501u),\nuvec4(0x12210001u,0x06200100u,0x07191c17u,0x14560718u),\nuvec4(0xafff1302u,0x02034195u,0x00711203u,0x01020301u),\nuvec4(0x03250105u,0x03050302u,0x9f551375u,0x03050f03u),\nuvec4(0x44100452u,0x11600100u,0x41401195u,0x61100100u),\nuvec4(0x41200150u,0x31002110u,0x33a55115u,0x11351395u),\nuvec4(0x01001302u,0x05033513u,0x0f052f03u,0x1c070035u),\nuvec4(0x32440709u,0x6f056302u,0x03155f03u,0x1f150305u),\nuvec4(0x0f059f35u,0x0031a523u,0x10118021u,0x31133581u),\nuvec4(0x03050302u,0x00010301u,0x00110211u,0x0c090706u),\nuvec4(0x66172809u,0x3f051204u,0xc56fff1eu,0x32010201u),\nuvec4(0x02311001u,0x03211501u,0x01052315u,0x03551365u),\nuvec4(0x130f0e6fu,0x03120305u,0x02240032u,0x00021400u),\nuvec4(0x20040604u,0x20018521u,0x10411001u,0x10011051u),\nuvec4(0x10210011u,0x10014011u,0x35b10031u,0x85430503u),\nuvec4(0x0f251311u,0x05111005u,0x15035513u,0x0501251fu),\nuvec4(0x0c090b00u,0x44020709u,0x01011002u,0xff051335u),\nuvec4(0x1f252fc5u,0x81a53305u,0x01501110u,0x11659100u),\nuvec4(0x03050305u,0x11020351u,0x090b0702u,0x0728090cu),\nuvec4(0x15020476u,0x7fff4e1fu,0x10125185u,0x03210001u),\nuvec4(0x31000102u,0x0f050315u,0x45100305u,0x45133513u),\nuvec4(0x0f030e2fu,0x00010503u,0x42001213u,0x52100203u),\nuvec4(0x00110204u,0x05013511u,0x04062001u,0x00020110u),\nuvec4(0x20510001u,0x00110001u,0x90310011u,0x00010001u),\nuvec4(0x35910011u,0x55131503u,0x45130561u,0xe5012401u),\nuvec4(0x14020301u,0x04003427u,0x03040130u,0xff150f05u),\nuvec4(0x0f25f51fu,0xa5131f05u,0x30010021u,0x25319021u),\nuvec4(0x31650103u,0x11003105u,0x01000113u,0x1c070600u),\nuvec4(0x04562739u,0xae1f0512u,0x1e1f0e2fu,0x0521458fu),\nuvec4(0x20011011u,0x00221022u,0x22014581u,0x05136503u),\nuvec4(0x050e531fu,0x0243050fu,0x11030503u,0x11001100u),\nuvec4(0x02032102u,0x11000113u,0x20251105u,0x06043604u),\nuvec4(0x22000204u,0x40c15001u,0x20011011u,0x00510011u),\nuvec4(0x05110001u,0x05011503u,0x91051133u,0x01340155u),\nuvec4(0x1301c503u,0x04b42602u,0x4fff0503u,0x03b51f05u),\nuvec4(0x71851375u,0x51700130u,0x111513c5u,0x41030125u),\nuvec4(0x1c0b0704u,0x070b1729u,0x01003456u,0x1e0fbe0fu),\nuvec4(0x0503257fu,0x15012503u,0x10110061u,0x03013204u),\nuvec4(0x05110091u,0x21020302u,0x13152345u,0x030f0305u),\nuvec4(0x1125830fu,0x05031105u,0x35710531u,0x46143001u),\nuvec4(0x40017012u,0x30010061u,0x10010001u,0x10210211u),\nuvec4(0x00210011u,0x15011351u,0x05210513u,0x40010001u),\nuvec4(0x01350301u,0x04220003u,0x05236502u,0x02030513u),\nuvec4(0x06c40604u,0x05000513u,0x05bf031fu,0x253f050fu),\nuvec4(0x65035503u,0x65031503u,0x01400521u,0x11504110u),\nuvec4(0x01155100u,0x03050365u,0x01050165u,0x04000110u),\nuvec4(0x091c090bu,0x0024b637u,0x038e0305u,0x130f2325u),\nuvec4(0x5503054fu,0x022142b1u,0x02012051u,0x05211300u),\nuvec4(0x05430503u,0x05433503u,0x55031553u,0x05010513u),\nuvec4(0x15013501u,0x02004511u,0x24170644u,0x21000130u),\nuvec4(0x0100f110u,0x31200100u,0x00010200u,0x03211001u),\nuvec4(0x33110331u,0x11000105u,0x35210580u,0x12010503u),\nuvec4(0x13150195u,0x34564402u,0x00050302u,0x15df0304u),\nuvec4(0x231f151fu,0x41e50185u,0x02500130u,0xf50105c1u),\nuvec4(0x01202145u,0x0c0b0704u,0x070b1719u,0x544054c6u),\nuvec4(0x851f0501u,0x35010503u,0x32912501u,0x11200150u),\nuvec4(0x03051312u,0x85130531u,0x01030513u,0x11130563u),\nuvec4(0x15000105u,0x65130501u,0x14235511u,0x16340002u),\nuvec4(0xa1500214u,0x01101100u,0x01203100u,0x01000100u),\nuvec4(0x13024110u,0x43110321u,0x3103c001u,0x95130145u),\nuvec4(0x03001501u,0x04160401u,0x14061416u,0x13252312u),\nuvec4(0x2385af1eu,0x805195f5u,0x10010001u,0x85012551u),\nuvec4(0x0501951fu,0x04111011u,0x07090c17u,0x44d60708u),\nuvec4(0x14201430u,0x00010302u,0x25300335u,0x55031001u),\nuvec4(0x20011271u,0x01225004u,0x15210502u,0x11220021u),\nuvec4(0x03353100u,0x430e0001u,0x01051305u,0x01750170u),\nuvec4(0x12216503u,0x34020004u,0x01020416u,0x61002120u),\nuvec4(0x01007100u,0x2100f130u,0x51130523u,0x05124110u),\nuvec4(0x21050341u,0x11153105u,0x23020115u,0x44262402u),\nuvec4(0x0e5f1523u,0x13658f03u,0x45130115u,0x15110501u),\nuvec4(0x0501a511u,0x90110021u,0x05010071u,0xb51f9501u),\nuvec4(0x04111011u,0x090b0706u,0x76070b18u,0x06071b07u),\nuvec4(0x10017024u,0x40010312u,0x01100105u,0x02011520u),\nuvec4(0x50617503u,0x41423012u,0x22031210u,0x10410001u),\nuvec4(0x13001305u,0x35230e05u,0x01600110u,0x01050f45u),\nuvec4(0x13a50103u,0x04360422u,0x05014002u,0x05113511u),\nuvec4(0x109100b1u,0x35210001u,0x05030513u,0x02510031u),\nuvec4(0x00111200u,0x21031001u,0x11053105u,0x11030500u),\nuvec4(0x24110513u,0x1f133426u,0xa5ff0305u,0x00716513u),\nuvec4(0x13050305u,0x11b09105u,0x11000130u,0x652f05f5u),\nuvec4(0x02012001u,0x0b271b16u,0x14060476u,0x01021062u),\nuvec4(0x11100440u,0x01200210u,0x02010002u,0x31351325u),\nuvec4(0x01000120u,0x02000140u,0x50021004u,0x23022011u),\nuvec4(0x03020312u,0x11220312u,0x23020302u,0x35030f2eu),\nuvec4(0x14000130u,0x03021002u,0x01050305u,0x0f251305u),\nuvec4(0x160400b5u,0x13101234u,0x00119501u,0x310021f1u),\nuvec4(0x03451305u,0x2103c115u,0x01000110u,0x31054105u),\nuvec4(0x01030125u,0x00050105u,0x16041624u,0x1f052304u),\nuvec4(0x35df0305u,0x05012513u,0x03051100u,0x01208125u),\nuvec4(0x15032100u,0x00013031u,0x20116001u,0x55410001u),\nuvec4(0x45132501u,0x1503154fu,0x03011011u,0x470b0706u),\nuvec4(0x10022476u,0x12130234u,0x02143203u,0x00010234u),\nuvec4(0x450f4511u,0x40311511u,0x00022001u,0x10023022u),\nuvec4(0x23120002u,0x43426312u,0x0e0f1305u,0x4015032fu),\nuvec4(0x03020301u,0x10130205u,0x13250204u,0x01050195u),\nuvec4(0x24220410u,0x11a55302u,0x71000100u,0x81000100u),\nuvec4(0x010291e5u,0x01101120u,0x61031105u,0x05430105u),\nuvec4(0x35130274u,0x31c59f1fu,0x41051130u,0x11001110u),\nuvec4(0x01100210u,0x02130203u,0x31502100u,0x01458130u),\nuvec4(0x131e0325u,0x1f050335u,0x41250315u,0x07060402u),\nuvec4(0x1617191bu,0x16041624u,0x01630204u,0x03223305u),\nuvec4(0x06071604u,0x0f6e0304u,0x05010005u,0x00111523u),\nuvec4(0x00224041u,0x03020012u,0xa3321322u,0x33050331u),\nuvec4(0x00255f0eu,0x21020001u,0x23150105u,0x0f152302u),\nuvec4(0x44127175u,0x13051110u,0x110011c5u,0x0135d100u),\nuvec4(0x0160a1d5u,0x00810005u,0x00230513u,0x1e034402u),\nuvec4(0x457f6f03u,0x15030503u,0x15110503u,0x90110001u),\nuvec4(0x70010301u,0x63212001u,0x02113002u,0x151365a1u),\nuvec4(0x532f0e03u,0x13053185u,0x06270602u,0x43153302u),\nuvec4(0x01004112u,0x02101105u,0x22011001u,0x12030204u),\nuvec4(0x051e3305u,0x13050100u,0x01004195u,0x63423322u),\nuvec4(0x0305231fu,0x02010305u,0x8f430501u,0x45330115u),\nuvec4(0x050f331fu,0x01107513u,0x02100145u,0x00021001u),\nuvec4(0x1521b501u,0x03010531u,0x15110511u,0x1175f521u),\nuvec4(0x21506105u,0x11102100u,0x35030100u,0x2e231213u),\nuvec4(0x03253f8fu,0x23150325u,0x11106125u,0x02130170u),\nuvec4(0x01120011u,0x51102110u,0x41152305u,0x11753100u),\nuvec4(0x336f1345u,0x120511b5u,0x02030416u,0x00111005u),\nuvec4(0x02155311u,0x01002113u,0x02400103u,0x10410203u),\nuvec4(0x951e0304u,0x12034503u,0x12131201u,0x01130503u),\nuvec4(0x1f131e73u,0x05030513u,0xbf330213u,0xaf450315u),\nuvec4(0x10350f55u,0x80042014u,0x10750301u,0x15030561u),\nuvec4(0xf5010511u,0x051115f5u,0x20110001u,0x10211001u),\nuvec4(0x13054001u,0x73010001u,0x53350fbfu,0x31250355u),\nuvec4(0x01d01100u,0x01500223u,0x83055130u,0x131513e5u),\nuvec4(0x233f351fu,0x23054195u,0x01100305u,0x13020100u),\nuvec4(0x25231501u,0x10010001u,0x00011001u,0x00010001u),\nuvec4(0x22010211u,0x02000100u,0x03051e01u,0x11050195u),\nuvec4(0x03020312u,0x01030112u,0x134e7335u,0x0305030fu),\nuvec4(0x030e2305u,0x456fffffu,0x02041223u,0x10243013u),\nuvec4(0x00019501u,0xf5030531u,0x0031a5f5u,0x00010001u),\nuvec4(0x10110201u,0x20010001u,0x1003000eu,0x05130501u),\nuvec4(0x532513ffu,0x01a06195u,0x11102130u,0x23a54140u),\nuvec4(0x333503e5u,0x25136f05u,0x1041451fu,0x33221305u),\nuvec4(0x80110071u,0x00041001u,0x01020122u,0x02000220u),\nuvec4(0x2503250eu,0x73f31503u,0x0e0f0315u,0x031f032fu),\nuvec4(0x0e051305u,0x8fffff13u,0x01053375u,0x44001400u),\nuvec4(0x01c50110u,0x11051105u,0x01250105u,0x1105f5f5u),\nuvec4(0x01104105u,0x01200102u,0x43021330u,0x1515df15u),\nuvec4(0x35231533u,0x25030503u,0x2001b041u,0xf5031581u),\nuvec4(0x154f1305u,0x0f15231fu,0x13051325u,0x03055f85u),\nuvec4(0x1021452fu,0x02132112u,0x00018001u,0x03000421u),\nuvec4(0x01800102u,0x12201102u,0x01250e03u,0xf3157302u),\nuvec4(0x037f152fu,0xffff2305u,0x5401d5afu,0xf5002420u),\nuvec4(0x25013531u,0x11c5f501u,0x21003135u,0x13300130u),\nuvec4(0x9f550311u,0x05014535u,0x35132521u,0x80510503u),\nuvec4(0x20111001u,0xb5212531u,0x159f2503u,0x2f557f03u),\nuvec4(0x4f150325u,0x100103a5u,0x02510201u,0x01301103u),\nuvec4(0x03010003u,0x130e1302u,0x10021400u,0x02004214u),\nuvec4(0x050e1314u,0x01020501u,0x630e7312u,0x1f033fffu),\nuvec4(0xffff0315u,0x050185bfu,0x10011501u,0x44000132u),\nuvec4(0x05712503u,0x0021b501u,0xf5413521u,0x01050105u),\nuvec4(0x01207125u,0x05210240u,0x03e50103u,0x21201105u),\nuvec4(0x31050305u,0x00010513u,0x60310011u,0x2523a5d1u),\nuvec4(0x057f5503u,0x450f25efu,0x051f350fu,0x0511551fu),\nuvec4(0x01020311u,0x02230520u,0x36044244u,0x14230204u),\nuvec4(0x03121302u,0x0543f302u,0x9fff2503u,0x7fffff35u),\nuvec4(0x81750f15u,0x02030102u,0x03124001u,0x6511a001u),\nuvec4(0x10110521u,0xc17511f1u,0x01203100u,0x21000130u),\nuvec4(0xd5031112u,0x00110541u,0x00110011u,0x20011001u),\nuvec4(0x03717001u,0x01050105u,0x051f15f5u,0xbfff051fu),\nuvec4(0x41e51f55u,0x03020100u,0x14020311u,0x14021416u),\nuvec4(0x04022022u,0x10122406u,0x83f30543u,0xff051305u),\nuvec4(0x2503050fu,0xffff353fu,0x2061758fu,0x10210011u),\nuvec4(0x12010014u,0x7501a001u,0x00013021u,0x00010001u),\nuvec4(0x20010011u,0x50212571u,0x00712011u,0x22044011u),\nuvec4(0x45113210u,0x11112503u,0x02504105u,0x11400210u),\nuvec4(0x91122120u,0x3f851355u,0xf5ffff05u,0x03505125u),\nuvec4(0x34160402u,0x21300426u,0x05232243u,0x95231573u),\nuvec4(0x7f05afffu,0xff051f15u,0x152f358fu,0x350f153fu),\nuvec4(0xb0310001u,0x01301211u,0x01901100u,0xb0f00120u),\nuvec4(0x50215061u,0x50011041u,0x13a20001u,0x20010501u),\nuvec4(0x0001d001u,0x00413032u,0x01052321u,0x01000105u),\nuvec4(0xffa51355u,0x01a54fffu,0x51050100u,0x04260470u),\nuvec4(0x16141726u,0x05212204u,0x75011301u,0x251f7533u),\nuvec4(0x01056fffu,0x2f250110u,0x151f3523u,0x058f150fu),\nuvec4(0x0100558fu,0x01050145u,0x11004125u,0x001100f0u),\nuvec4(0x0234d021u,0xf0010001u,0x01800190u,0x01e00110u),\nuvec4(0x60020100u,0x04520001u,0x01003132u,0x11400102u),\nuvec4(0x13020160u,0x13252112u,0x03113321u,0x01050115u),\nuvec4(0xff350f95u,0xe52f05afu,0x50112041u,0x14373614u),\nuvec4(0x03041607u,0x0f753112u,0x2f950f05u,0x159fff05u),\nuvec4(0x01001410u,0x03150305u,0x7f950145u,0x0f051105u),\nuvec4(0x11050155u,0x05300120u,0x11001100u,0xf0f01100u),\nuvec4(0x34060440u,0x04003406u,0x14c03470u,0x80f02400u),\nuvec4(0x90010011u,0x10220352u,0x00016001u,0x00111201u),\nuvec4(0x02110001u,0x05310253u,0x13013513u,0xf5110521u),\nuvec4(0x3f35bf15u,0x13750f05u,0x11202195u,0x37461450u),\nuvec4(0x14162406u,0x21000140u,0x1f551f65u,0x159fff25u),\nuvec4(0x01020330u,0x01053105u,0x01050130u,0x0f053f75u),\nuvec4(0x03041005u,0x30011075u,0x02142002u,0x04b0f004u),\nuvec4(0x061a5480u,0x16042604u,0x20740684u,0x16340654u),\nuvec4(0x0220f074u,0x2231a011u,0x21020203u,0x31120312u),\nuvec4(0x11330542u,0x65015503u,0xf5f5f531u,0x31250195u),\nuvec4(0x17660490u,0x0624062au,0x41702204u,0x153f35f5u),\nuvec4(0x0311858fu,0x05310002u,0x10011001u,0x15012511u),\nuvec4(0x14416501u,0x11450103u,0x4a063440u,0x04001406u),\nuvec4(0x24000480u,0x04162450u,0xaa561446u,0x2a160426u),\nuvec4(0x04063416u,0x24360416u,0x0634567au,0xc012c054u),\nuvec4(0x05110311u,0x02031223u,0x13210203u,0x35613511u),\nuvec4(0x75414511u,0x15010551u,0x00118511u,0x1035f501u),\nuvec4(0x10011011u,0x46048001u,0x14063a47u,0xb0120406u),\nuvec4(0xf5410001u,0x1f452f05u,0x41450195u,0x02000120u),\nuvec4(0x00610001u,0x01401135u,0x03020400u,0x11001110u),\nuvec4(0x6a262410u,0x14961a07u,0x24161466u,0xfafafa16u),\nuvec4(0x94363afau,0x12000260u,0x11003130u,0x01300330u),\nuvec4(0x05816315u,0x0561c531u,0x30010041u,0x01002521u),\nuvec4(0x01050100u,0x11000120u,0x31050100u,0x01151155u),\nuvec4(0x01300120u,0x21001110u,0x44161400u,0x14163a27u),\nuvec4(0x11c01406u,0x1fc56110u,0x011500c5u,0x01150110u),\nuvec4(0x01102125u,0x21300410u,0x16a00120u,0x16241034u),\nuvec4(0x3406cafau,0xfa162406u,0xaafafafau,0x04461446u),\nuvec4(0x32000260u,0x50121100u,0x00410201u,0x05033511u),\nuvec4(0x15110501u,0x05010521u,0x05d12511u,0x00011071u),\nuvec4(0x00110521u,0x00110001u,0x10013011u,0x25313005u),\nuvec4(0x00011011u,0x34900103u,0x14161426u,0x07080716u),\nuvec4(0x04161a08u,0x60020416u,0x00015031u,0x0f35f541u),\nuvec4(0x11301135u,0x14801130u,0x04002400u,0x01300110u),\nuvec4(0x14200100u,0x24062a16u,0x07fafa06u,0x0624063au),\nuvec4(0xfafafafau,0x34266afau,0x11a00400u,0x41000130u),\nuvec4(0x31154100u,0xf1056125u,0x00610541u,0x00010021u),\nuvec4(0x10011011u,0x20214001u,0x00211021u,0x10113001u),\nuvec4(0x36044664u,0x4a06270au,0x14160a17u,0x11120406u),\nuvec4(0x314571f0u,0x01750105u,0x54264460u,0x44365a66u),\nuvec4(0xaafafa16u,0xfafafa17u,0x5afafafau,0x04302446u),\nuvec4(0x01401480u,0xf1003100u,0x00a10021u,0x00013021u),\nuvec4(0x1470f041u,0x64063430u,0x24362426u,0x4a074a26u),\nuvec4(0x14361a17u,0x303180f0u,0x20112541u,0xfafa2614u),\nuvec4(0xfafafafau,0xfafafafau,0x2a07aafau,0x0a060a07u),\nuvec4(0x00803416u,0x10010034u,0x00010001u,0x70f140f1u),\nuvec4(0x30011001u,0x16441654u,0x76240604u,0x3614b614u),\nuvec4(0x075a0614u,0x560a274au,0x6170f084u,0xfa261410u),\nuvec4(0xfafafafau,0xfafa077au,0xfafafafau,0x080a079au),\nuvec4(0x1416370au,0x34202400u,0xc0210302u,0x70115041u),\nuvec4(0x56845071u,0x16141614u,0x06141604u,0x362a367au),\nuvec4(0x06145654u,0x0a08079au,0x44b60406u,0x113021d0u),\nuvec4(0xfa160420u,0xfafafafau,0xfafa07bau,0xfafafafau),\nuvec4(0x070917dau,0x4446040bu,0x50121406u,0x0120f001u),\nuvec4(0x01000100u,0x64507100u,0x54660706u,0x44260406u),\nuvec4(0xfa160406u,0x2afa362au,0xf6140627u,0x1400f054u),\nuvec4(0xfafafa06u,0xfafafafau,0xfafafafau,0x0b27bafau),\nuvec4(0x26962417u,0x1130f004u,0x01000150u,0x00121305u),\nuvec4(0x34020402u,0x1a06fa96u,0xfa077406u,0x24478afau),\nuvec4(0x06d456f6u,0xfafafafau,0xfafafafau,0x4afafafau),\nuvec4(0x092d0b07u,0x34472afau,0x707426b6u,0x15410011u),\nuvec4(0x76243001u,0xfafafafau,0x764a37fau,0x2426f604u),\nuvec4(0xfafafa66u,0xfafafafau,0xfafafafau,0x076d074au),\nuvec4(0x070a08fau,0x96044624u,0x14860406u,0x11206426u),\nuvec4(0xfa461402u,0xfafafafau,0x0708274au,0x6406f6dau),\nuvec4(0xfafafa46u,0xfafafafau,0xfafafafau,0x0b371d7au),\nuvec4(0x162afa0du,0xf6448684u,0xfa460a56u,0xfafafafau),\nuvec4(0x660afafau,0xfafa2674u,0xfafafafau,0xfafafafau),\nuvec4(0x090ddafau,0x0d070907u,0x27ea071au,0x24369416u),\nuvec4(0x164406f6u,0xfafafafau,0xfafa17fau,0x063446bau),\nuvec4(0xfafafafau,0xfafafafau,0xeafafafau,0x4d070a17u),\nuvec4(0x07ca170au,0x04364708u,0xf6165436u,0xfafafa26u),\nuvec4(0x083afafau,0xfafafa27u,0xfa17085au,0xfafafafau),\nuvec4(0xfafafafau,0x07aafafau,0x070a070bu,0x0b070a2du),\nuvec4(0x6a47da07u,0x46760a16u,0xfafa061au,0xfafafafau),\nuvec4(0xfafa072au,0xfafa08aau,0xfafafafau,0xfafafafau),\nuvec4(0x176afafau,0x070a0709u,0x09070a0bu,0xfa578a17u),\nuvec4(0xfafa460au,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0xfafafafau,0x09271a37u,0xfa07ba07u),\nuvec4(0xfafafa7au,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0x0afafafau,0x17092709u,0x27ca0709u),\nuvec4(0xfafa5afau,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0xfafafafau,0x2709170au,0x08aa0709u),\nuvec4(0x2afa472au,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0xfafafafau,0x472afafau,0x17081afau),\nuvec4(0xfada172au,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0xfafafafau,0x57eafafau,0x070a081au),\nuvec4(0x0a3a070au,0x1a171a17u,0xfafafa17u,0x077afafau),\nuvec4(0xfafafafau,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0x671afafau,0x0847da2au,0x8a371a17u,0x270afa17u),\nuvec4(0xfafafafau,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0xfafa4afau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0xfafafafau,0x0000fafau,0x00000000u));\nconst int rowindex[] = int[](\n0,47,103,168,251,327,407,481,541,630,714,780,840,914,990,1069,1165,1264,1341,1431,1528,1639,1755,1906,2055,2204,2364,2516,2677,2816,2958,3097,3230,3356,3482,3595,3714,3837,3971,4088,4230,4383,4537,4669,4802,4952,5081,5219,5365,5509,5670,5841,6046,6218,6387,6525,6682,6846,7029,7205,7382,7538,7693,7865,8053,8220,8391,8557,8722,8874,9027,9170,9325,9466,9606,9765,9942,10099,10254,10435,10602,10781,10961,11129,11295,11463,11621,11791,11957,12133,12295,12471,12655,12842,13033,13207,13380,13539,13691,13852,14017,14190,14353,14514,14680,14865,15034,15215,15400,15589,15781,15953,16121,16297,16469,16649,16821,17004,17187,17382,17572,17758,17930,18112,18290,18450,18624,18805,19006,19169,19331,19494,19674,19846,20028,20228,20426,20619,20795,20968,21127,21288,21446,21605,21772,21931,22085,22227,22365,22491,22628,22779,22922,23063,23204,23353,23486,23618,23770,23921,24069,24210,24353,24489,24625,24735,24837,24957,25060,25175,25265,25370,25480,25594,25698,25805,25912,26030,26113,26179,26247,26312,26371,26425,26472,26518,26560,26603,26647,26690,26721,26754,26788,26819,26851,26885,26918,26943,26968,26993,27018);\n\nconst vec3 colors[] = vec3[](\nvec3(0x20,0xa0,0xe0),\nvec3(0x10,0x90,0xd0),\nvec3(0x20,0x90,0xb0),\nvec3(0x10,0x60,0xb0),\nvec3(0x60,0xc0,0xd0),\nvec3(0x10,0x70,0xd0),\nvec3(0xa0,0xe0,0xf0),\nvec3(0xb0,0xc0,0x90),\nvec3(0xe0,0xd0,0xa0),\nvec3(0xb0,0xa0,0x60),\nvec3(0xe0,0xe0,0xe0),\nvec3(0x50,0xa0,0x60),\nvec3(0x90,0x70,0x30),\nvec3(0x50,0x60,0x30),\nvec3(0x10,0x40,0xb0),\nvec3(0x10,0x60,0xd0));\n\nvec3 getcolor(int i) {\n  return colors[i%colors.length()]/255.0;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n  float ires = iResolution.x*10000.0 + iResolution.y;\n  if (iFrame != 0 && fragColor.w == ires) return; // Check for resize\n  fragColor = vec4(0,0,0,ires);\n  int row = int(fragCoord.y); // Desired row\n  row = min(row,HEIGHT-1); // Clamp at edges\n  int col = int(fragCoord.x); // Desired column\n  col = min(col,WIDTH-1); // Clamp at edges\n  // Find the index of the start of the row\n  int rstart = rowindex[row];\n  // And of the next row\n  int rend = rowindex[row+1];\n  int c = -1;\n  int colcount = 0; // column count\n  for (int index = rstart; index < rend; index++) {\n    int i = index;\n    uvec4 entry = data[i/16];\n    i %= 16;\n    uint t = entry[i/4];\n    i %= 4;\n    t >>= 8*i;\n    int count = (int(t >> 4)&15)+1;\n    colcount += count;\n    if (col < colcount) {\n      c = int(t)&15; // Found it!\n      break;\n    }\n  }\n  if (c < 0) fragColor.r = 1.0; // Shouldn't happen\n  else {\n    vec3 col = getcolor(c);\n    col = pow(col,vec3(2.2));\n    fragColor.rgb = col;\n  }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\n\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n  \nconst float PI = 3.14159;\nconst float TWOPI = 2.0*PI;\nconst int WIDTH = 400;\nconst int HEIGHT = 200;\n\nvec2 expi(float t) {\n  return normalize(vec2(cos(t),sin(t)));\n}\n\nvec2 cmul(vec2 z0, vec2 z1) {\n  float x0 = z0.x; float y0 = z0.y; \n  float x1 = z1.x; float y1 = z1.y;\n  return vec2(x0*x1-y0*y1,x0*y1+x1*y0);\n}\n\n// Reciprocal\nvec2 cinv(vec2 z) {\n  float x = z.x; float y = z.y;\n  float n = 1.0/(x*x + y*y);\n  return vec2(n*x,-n*y);\n}\n\n// Division\nvec2 cdiv(vec2 z0, vec2 z1) {\n  return cmul(z0,cinv(z1));\n}\n\nvec2 clog(vec2 z) {\n  return vec2(log(length(z)),atan(z.y,z.x));\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cmul(p,expi(t));\n}\n\n// const int KEY_SHIFT = 16;\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\n// const int CHAR_B = 66;\nconst int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\nconst int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\nconst int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\n// const int CHAR_R = 82;\n// const int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dltfWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[496, 496, 534, 534, 648], [650, 650, 671, 671, 2013], [2015, 2015, 2035, 2035, 2144], [2146, 2146, 2171, 2171, 2269], [2271, 2271, 2325, 2325, 2908]], "test": "untested"}
{"id": "clGBDz", "name": "Earthbound type shader", "author": "Trixelized", "description": "comment line 27 to really notice the artifacting I was going for", "tags": ["earthbound"], "likes": 5, "viewed": 194, "published": 3, "date": "1701968054", "time_retrieved": "2024-07-30T17:18:05.349507", "image_code": "#define pixel_scale 5.0\n#define pi 3.141592\n#define tau 6.283185\n\n// Rounded sin\nfloat rsin(float val, float scale) {\n    return round(sin(tau * val) * scale);\n}\n\n// Rounded cos\nfloat rcos(float val, float scale) {\n    return round(cos(tau * val) * scale);\n}\n\n// Scanline function\nfloat scanline(float val) {\n    return floor(mod(val, 2.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Resize the fragment coordinate and round it down\n    // This artificially downscales all coordinates\n    vec2 uv = floor(fragCoord / pixel_scale);\n    \n    // Distort the UV using even patterns\n    uv.x += rsin(uv.y / 128.0 + iTime / 6.0, mix(-16.0, 16.0, scanline(uv.y)));\n    uv.y += rsin(uv.y / 48.0 + iTime / 8.0, 8.0);\n    \n    // Pattern (would be a custom texture)\n    vec3 col = step(length(uv / 32.0 - round(uv / 32.0)), 0.46) * vec3(0.3, 0.1, 0.1);\n    col += scanline(uv.x / 32.0) * vec3(0.2, 0.0, 0.0);\n    col += vec3(0.3, 0.05, 0.2);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clGBDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 81, 117, 117, 161], [163, 178, 214, 214, 258], [260, 281, 308, 308, 343], [345, 345, 400, 513, 1024]], "test": "untested"}
{"id": "ctGBDR", "name": "PerfTest GPU Branching", "author": "gehtsiegarnixan", "description": "Performance Test to see how one can sample different amount of textures for different pixels.", "tags": ["test", "texture", "performance", "sample", "speed"], "likes": 1, "viewed": 256, "published": 3, "date": "1701966396", "time_retrieved": "2024-07-30T17:18:06.408674", "image_code": "// The MIT License\n// Copyright Â© 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis performance test aims to check methods for variable sample count \nbetween pixels. I find the results below a bit surprising, I would have\nexpected \"if\" to be worse than 3 samples since I read that both sides \nare executed, but apparently not. Branch prediction may be the reason.\nFeel free to correct mistakes or add notes. \n\nAlso, don't be hasty comparing the non-branching tests to branching \nones, as the distribution of samples changes the performance will \nchange a lot so it may or may not work for your application, so testing\nis adviced.\n\nThe test works by measuring frames per second (FPS) on Shadertoy. To \nensure valid results, we repeat the test function with varying values, \naccumulating their results into a final image.\n\nSteps:\n- Increase REPEAT until the FPS are below your monitors refreshrate \n    (probably somewhere around 60-144 fps)\n- Modify TEST value to switch between test cases\n- The highest FPS indicates the fastest implementation\n- Congratulate yourself for doing SCIENCE\n*/\n\n// Number of repeats of the test, 5000 should be enough for RTX3080\n#define REPEAT 1\n    \n// switch between the test cases\n//  0 = sample 1 texture                             ~ 112 fps\n//  1 = sample 2 textures                            ~  56 fps\n//  2 = sample 3 textures                            ~  39 fps\n//  3 = sample 1-3 textures using if (broken mips)   ~  51 fps\n//  4 = sample 1-3 textures using if with chess mask ~   8 fps\n//  5 = sample 1-3 textures using for (broken mips)  ~  47 fps\n//  6 = sample 1 textureGrad                         ~  56 fps\n//  7 = sample 3 textureGrad                         ~  20 fps\n//  8 = sample 1-3 textureGrad using if              ~  26 fps\n//  9 = sample 1 texture using LOD 0                 ~ 106 fps\n// 10 = first sample 3 texture, then use 1-3 tex     ~  38 fps\n// 11 = 3, but quantizing 2x2                        ~  51 fps\n// 12 = 3, but fwidth||branch 2x2 (?broken mips?)    ~  49 fps\n// 13 = sample 1-3 textures with switch (broken mips)~  51 fps\n#define TEST 13\n\n// Debug view visualing the mip level. Disable for Testing!\n//#define SHOWMIPLEVEL\n\n// 1. / sqrt(2. * pi) ratio between a square and a cirle area\n// See: https://www.desmos.com/calculator/l7nqvcpajk\n#define INFSQRTHLFPI 0.398942280401\n\n// samples a Texture with some debug features\nvec3 sampleTex(sampler2D sam, vec2 uv) {\n    #ifdef SHOWMIPLEVEL\n        return visualizeMips(sam, uv);      \n        \n    #else\n        return texture(sam, uv).xyz;\n    #endif\n}\n\n// samples a Texture with some debug features\nvec3 sampleTex(sampler2D sam, vec2 uv, vec2 duvdx, vec2 duvdy) {\n    #ifdef SHOWMIPLEVEL\n        return visualizeMips(sam, uv, duvdx, duvdy);\n        \n    #else\n        return textureGrad(sam, uv, duvdx, duvdy).xyz;\n    #endif\n}\n\n// samples a Texture with some debug features\nvec3 sampleTex(sampler2D sam, vec2 uv, float mipLevel) {\n    #ifdef SHOWMIPLEVEL\n        return visualizeMips(sam, uv, mipLevel);\n        \n    #else\n        return textureLod(sam, uv, mipLevel).xyz;\n    #endif\n}\n\n// sample 1 texture\nvec3 singleTex(vec2 uv) {\n    return sampleTex(iChannel0, uv);\n}\n\n// sample two textures\nvec3 doubleTex(vec2 uv) {\n    // sample two textures with different uvss\n    vec3 a = sampleTex(iChannel0, uv);\n    vec3 b = sampleTex(iChannel0, uv.yx);\n    \n    // 50/50 lerp between them\n    return mix(a,b,0.5);\n}\n\n// sample three textures\nvec3 tripleTex(vec2 uv) {\n    // sample three textures with different uv rotations\n    vec3 a = sampleTex(iChannel0, uv);\n    vec3 b = sampleTex(iChannel0, uv.yx);\n    vec3 c = sampleTex(iChannel0, -uv);\n\n    // 1/3 lerp between them\n    float weight = 1./3.;\n    return a * weight + b * weight + c * weight;\n}\n\n// switch 50/50 between 1 and 3 samples using if\nvec3 ifTex(vec2 uv) {\n    if (length(uv) < INFSQRTHLFPI * 5.) {\n        // rotating this texture to make even harder\n        return singleTex(vec2(uv.y, -uv.x));//uv);\n        \n    } else {    \n        return tripleTex(uv);\n    }\n}\n\n// switch 50/50 between 1 and 3 samples using if and chess pattern\nvec3 ifChessTex(vec2 uv, vec2 fragCoord) {\n    // amplify the pixels for debugging\n    //fragCoord = floor(fragCoord /16.); \n\n    // chess mask\n    float chess = mod(fragCoord.x+fragCoord.y,2.);\n    \n    if (chess < 0.5) {\n        // rotating this texture to make even harder\n        return singleTex(vec2(uv.y, -uv.x));\n        \n    } else {    \n        return tripleTex(uv);\n    }\n}\n\n// switch 50/50 between 1 and 3 samples using for\nvec3 forTex(vec2 uv) {\n    // alternate between 1 and 3 repeats\n    int n =  length(uv) < INFSQRTHLFPI * 5. ? 1 : 3;\n    \n    // weight for interpolation\n    float weight = 1./float(n); \n\n    // repeat this n times\n    vec3 result;\n    for (int i=0; i<n ; i++) { \n        // sample texture\n        vec3 color = sampleTex(iChannel0, uv);\n        \n        // interpolate the result\n        result += color * weight;\n        \n        // mutate the uvs\n        uv = vec2(uv.y, -uv.x);\n    }    \n    return result;\n}\n\n// sample 1 texture with partial derivatives mips\nvec3 singleTexGrad(vec2 uv) {\n    // Mip caculation for testing\n    vec2 duvdx = dFdx( uv );\n    vec2 duvdy = dFdy( uv );\n\n    return sampleTex(iChannel0, uv, duvdx, duvdy);\n}\n\n// sample three textures with partial derivatives mips\nvec3 tripleTexGrad(vec2 uv) {\n    // Mip calculation for testing\n    vec2 duvdx = dFdx(uv);\n    vec2 duvdy = dFdy(uv);\n\n    // sample three textures with different uv rotations\n    vec3 a = sampleTex(iChannel0, uv, duvdx, duvdy);\n    vec3 b = sampleTex(iChannel0, uv.yx, duvdx, duvdy);\n    vec3 c = sampleTex(iChannel0, -uv, duvdx, duvdy);\n\n    // 1/3 lerp between them\n    float weight = 1./3.;\n    return a * weight + b * weight + c * weight;\n}\n\n// switch 50/50 between 1 and 2 samples using if with partial derivatives mips\nvec3 ifTexGrad(vec2 uv) {\n    // Mip caculation for testing\n    vec2 duvdx = dFdx( uv );\n    vec2 duvdy = dFdy( uv );    \n\n    if (length(uv) < INFSQRTHLFPI * 5.) {\n        // rotating this texture to make even harder\n        return sampleTex(iChannel0, vec2(uv.y, -uv.x), duvdx, duvdy);        \n    } else {    \n        // sample three textures with different uv rotations\n        vec3 a = sampleTex(iChannel0, uv, duvdx, duvdy);\n        vec3 b = sampleTex(iChannel0, uv.yx, duvdx, duvdy);\n        vec3 c = sampleTex(iChannel0, -uv, duvdx, duvdy);\n\n        // 1/3 lerp between them\n        float weight = 1./3.;\n        return a * weight + b * weight + c * weight;\n    }\n}\n\n// sample 1 texture with Texture LOD\nvec3 singleTexLOD(vec2 uv) {\n    vec2 miplevel = getMipLevel(iChannel0, uv);\n    return sampleTex(iChannel0, uv, miplevel.x);\n}\n\n// First sample three textures but only use one or three\nvec3 retroactiveTex(vec2 uv) {\n    // sample three textures with different uv rotations\n    vec3 a = sampleTex(iChannel0, uv);\n    vec3 b = sampleTex(iChannel0, uv.yx);\n    vec3 c = sampleTex(iChannel0, -uv);\n    \n    if (length(uv) < INFSQRTHLFPI * 5.) {\n        // use only one texture\n        return a;\n        \n    } else {\n        // 1/3 lerp between the three\n        float weight = 1./3.;\n        return a * weight + b * weight + c * weight;\n    }\n}\n\n// switch 50/50 between 1 and 3 samples using if in 2x2 segemnts\nvec3 ifTex2x2(vec2 uv, vec2 fragCoord) {    \n    // Round UV coordinates to the nearest 2x2 segment\n    fragCoord = floor(fragCoord / 2.) * 2.;\n    vec2 roundedUV = fragCoord / iResolution.xy - 0.5;\n        \n    if (length(roundedUV) < 1. * INFSQRTHLFPI) {\n        // rotating this texture to make even harder\n        return singleTex(vec2(uv.y, -uv.x));//uv);\n        \n    } else {    \n        return tripleTex(uv);\n    }\n}\n\n// switch 50/50 between 1 and 3 samples using fwidth to check neighbor branches\nvec3 ifTex2x2Width(vec2 uv, vec2 fragCoord) {\n    // Arbitary condition for branching\n    bool condition = length(uv) < INFSQRTHLFPI * 5.;\n    \n    // Check difference of neighbors with fwidth\n    float fWidthTest = fwidth(float(condition));\n    \n    vec3 color;\n    // Branching but border cases become 1 samples\n    if (fWidthTest > 0.5 || condition) { \n        // rotating this texture to make even harder\n        color = singleTex(vec2(uv.y, -uv.x));//uv);\n        \n    } else {\n        color = tripleTex(uv);\n    }\n        \n    return color;\n}\n\n// use switch case to switch between 1 and 3 samples\nvec3 switchTex(vec2 uv) {\n    vec3 color;    \n    switch(int(length(uv) < INFSQRTHLFPI * 5.)) {\n    \n        case 0: // Equivalent to 'else' in your original function\n            color = tripleTex(uv);\n            break;\n            \n        case 1: // Equivalent to 'if' in your original function\n            color = singleTex(vec2(uv.y, -uv.x));\n            break;\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    \n    // The mip level breaking is not visible at lower scales\n    uv *= 5.;\n\n    // if you get around 144 fps use a higher repeat value\n    vec3 test;\n    for(int i=0; i<REPEAT; i++) {\n    \n        // unique permutation each iteration\n        float mut = (float(i)/float(REPEAT)); \n          \n        // use which ever you wish to test\n        #if TEST == 0\n            test += singleTex(uv + mut);\n        #elif TEST == 1\n            test += doubleTex(uv + mut);\n        #elif TEST == 2\n            test += tripleTex(uv + mut);\n        #elif TEST == 3\n            test += ifTex(uv + mut);\n        #elif TEST == 4\n            test += ifChessTex(uv + mut, fragCoord);            \n        #elif TEST == 5\n            test += forTex(uv + mut);         \n        #elif TEST == 6\n            test += singleTexGrad(uv + mut);\n        #elif TEST == 7\n            test += tripleTexGrad(uv + mut);            \n        #elif TEST == 8       \n            test += ifTexGrad(uv + mut);\n        #elif TEST == 9\n            test += singleTexLOD(uv + mut);  \n        #elif TEST == 10   \n            test += retroactiveTex(uv + mut);\n        #elif TEST == 11\n            test += ifTex2x2(uv + mut, fragCoord);\n        #elif TEST == 11\n            test += ifTex2x2Width(uv + mut, fragCoord);\n        #else \n            test += switchTex(uv + mut);\n        #endif   \n    }\n    \n    #if REPEAT > 1\n        // Ensure test vector stays in visible range\n        test = fract(test);\n    #endif\n\n    // Output to screen\n    fragColor = vec4(test, 1.);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Generic Function ________________________________________________________________\n\n// makes rainbow colormap with polynimal 6\nvec3 rainbow(float t) {\n    const vec3 c0 = vec3(0.503560,-0.002932,1.000009);\n    const vec3 c1 = vec3(-1.294985,3.144463,0.001872);\n    const vec3 c2 = vec3(-16.971202,0.031355,-1.232219);\n    const vec3 c3 = vec3(97.134102,-5.180126,-0.029721);\n    const vec3 c4 = vec3(-172.585487,-0.338714,0.316782);\n    const vec3 c5 = vec3(131.971426,3.514534,-0.061568);\n    const vec3 c6 = vec3(-37.784412,-1.171512,0.003376);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// rotates UV by direction\nvec2 rotateUV(vec2 uv, vec2 direction) {\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2(\n        -direction.x, direction.y,\n        direction.y, direction.x\n    );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n// Mip Functions __________________________________________________________________\n\n// Function to calculate the highest mip level based on texture size\nfloat getHighestMipLevel (vec2 texSize) {\n    // Find the maximum dimension of the texture\n    float maxDimension = max(texSize.x, texSize.y);\n    \n    // Calculate the highest mip level using the logarithm base 2\n    float highestMipLevel = log2(maxDimension);\n\n    // Return the highest mip level\n    return highestMipLevel;\n}\n\n// Function to calculate the mip level and the maximum mip level for a texture\n// Based on Unreal Engines ComputeMipLevel Material Function \nvec2 getMipLevel(sampler2D sam, vec2 uv, vec2 duvdx, vec2 duvdy) {\n    // Adjust mip level based on your texture size\n    vec2 texSize = vec2(textureSize(sam, 0));\n\n    // Scale the partial derivatives by the texture size\n    vec2 scaledDDX = duvdx * texSize;\n    vec2 scaledDDY = duvdy * texSize;\n\n    // Find the largest rate of change\n    float maxDDLength = max(dot(scaledDDX, scaledDDX), dot(scaledDDY, scaledDDY));\n\n    // Calculate the mip level based on the rate of change\n    float mipLevel = log2(sqrt(maxDDLength));\n\n    // Calculate the highest possible mip level for the texture\n    float maxMipLevel = getHighestMipLevel(texSize);\n\n    // Clamp the mip level between 0 and the maximum mip level\n    mipLevel = clamp(mipLevel, 0.0, maxMipLevel);\n\n    // Return both the mip level and the maximum mip level\n    return vec2(mipLevel, maxMipLevel);\n}\n\n// Function to calculate the mip level and the maximum mip level for a texture\nvec2 getMipLevel(sampler2D sam, vec2 uv) {\n    // Mip calculation for testing\n    vec2 duvdx = dFdx(uv);\n    vec2 duvdy = dFdy(uv);\n    \n    // Caculate Mip level\n    return getMipLevel(sam, uv, duvdx, duvdy);\n}\n\n// Visualizes Mip level based on UV coordinates and texture size\nvec3 visualizeMips(sampler2D sam, vec2 uv) {\n    // Caculate Mip level\n    vec2 mipLevel = getMipLevel(sam, uv);\n\n    // colorize Mip level with colormap\n    return rainbow(mipLevel.x / mipLevel.y);\n}\n\n// Visualizes Mip level based on UV coordinates, texture size, and DDX/DDY\nvec3 visualizeMips(sampler2D sam, vec2 uv, vec2 duvdx, vec2 duvdy) {\n    // Caculate Mip level\n    vec2 mipLevel = getMipLevel(sam, uv, duvdx, duvdy);\n    \n    // colorize Mip level with colormap\n    return rainbow(mipLevel.x / mipLevel.y);\n}\n\n// Visualizes Mip level based on miplevel and texture size\nvec3 visualizeMips(sampler2D sam, vec2 uv, float mipLevel) {\n    // Adjust mip level based on your texture size\n    vec2 texSize = vec2(textureSize(sam, 0));\n    \n    // colorize Mip level with colormap\n    return rainbow(mipLevel / getHighestMipLevel(texSize));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctGBDR.jpg", "access": "api", "license": "mit", "functions": [[3352, 3398, 3438, 3438, 3576], [3578, 3624, 3688, 3688, 3852], [3854, 3900, 3956, 3956, 4111], [4113, 4133, 4158, 4158, 4197], [4199, 4222, 4247, 4294, 4438], [4440, 4465, 4490, 4547, 4775], [4777, 4826, 4847, 4847, 5057], [5059, 5126, 5168, 5269, 5510], [5512, 5562, 5584, 5625, 6073], [6075, 6125, 6154, 6188, 6300], [6302, 6357, 6386, 6421, 6803], [6805, 6884, 6909, 6943, 7557], [7559, 7596, 7624, 7624, 7723], [7725, 7782, 7812, 7869, 8238], [8240, 8305, 8345, 8404, 8729], [8731, 8811, 8856, 8896, 9359], [9361, 9414, 9439, 9439, 9811]], "test": "untested"}
{"id": "ctGfWR", "name": "Scroller with bouncing balls", "author": "misol101", "description": "Sinus scroller ball bouncing similar to \"In the kitchen\" by Anarchy, as seen here: https://www.youtube.com/watch?v=iY1bt9864sU&t=01m35s", "tags": ["amiga", "balls", "bounce", "font", "sinus", "scroller", "reproduction", "anarchy"], "likes": 6, "viewed": 264, "published": 3, "date": "1701965275", "time_retrieved": "2024-07-30T17:18:07.193576", "image_code": "// AA Sinus Scroller, originally by gPlatl.\n\n// Boncing balls added by misol101\n\nfloat char(float ch) {\n    vec4 f = texture(iChannel0,clamp(tp,0.,1.)/16.+fract(floor(vec2(ch,15.999-float(ch)/16.))/16.));\n    return f.x;\n}\n\nvec4 ScrollText() {\n  getTp(iTime);\n  float c = 0.0;\n    \n  _H _e _l _l _o _  _s _h _a _d _e _r _t _o _y _ _exc _exc\n\n  _ _G _u _e _s _s _ _I _ _a _m _ _j _u _s _t\n\n  _ _a _ _s _u _c _k _e _r _ _f _o _r \n\n  _ _o _l _d _ _A _m _i _g _a _ _s _c _e _n _e\n\n  _ _e _f _f _e _c _t _s _exc _ _W _i _s _h _ _I \n      \n  _ _h _a _d _ _t _h _e _  _m _u  _s _i _c _ _t _o _o\n      \n  _ _smily _ _dot _dot _dot _dot \n\n  return c * vec4(0.36, 0.27, 0.5, 1.) * 1.75;\n}\n\nvec4 sphere(vec2 fragCoord, vec2 ballPos, float rad, vec4 col, vec4 orgCol, float AA) {\n    float dist = distance(fragCoord, ballPos);\n    return mix(col, orgCol, smoothstep(rad-iResolution.x*AA, rad, dist));\n}\n\nvec4 drawBall(vec2 fragCoord, vec2 ballPos, vec4 col, float rad) {\n    vec4 ballCol = vec4(0.95, 0.19, 0.4, 1.);\n    col = sphere(fragCoord, ballPos, rad, ballCol * 0.55, col, 0.004);\n    col = sphere(fragCoord, ballPos-vec2(rad*0.1,-rad*0.1), rad*0.65, ballCol * 3., col, 0.006);\n    return sphere(fragCoord, ballPos-vec2(rad*0.2,-rad*0.2), rad*0.2, ballCol*6.5, col, 0.0015);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  pos = fragCoord.xy / iResolution.xy;\n  uv = pos*2.0 - 1.0;\n\n  vec4 col=vec4(0.05, 0.,0.18, 1.);\n  if (uv.y < -0.3 && uv.y > -0.9)\n      col  = max(ScrollText(), col);\n  vec4 oldCol = col;\n\n  // draw balls\n  for (int i=0; i < NOF_BALLS; i++) {\n      vec4 ball = texelFetch(iChannel1, ivec2(i,0), 0);\n      if (distance(fragCoord.xy, ball.xy) < iResolution.x * BALL_SIZE) {\n        col = drawBall(fragCoord,ball.xy, col, iResolution.x * BALL_SIZE);\n        // start/end ball fade\n        col = mix(oldCol, col, clamp(SCROLL_TIME_MOD(iTime), 0., 0.5) * 2.);\n        col = mix(oldCol, col, clamp(SCROLL_LEN-2.0-SCROLL_TIME_MOD(iTime), 0., 3.) * 0.333);\n      }\n  }\n\n  fragColor = col;\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35467, "src": "https://soundcloud.com/virgill/amiga-interference-vite-and-plack", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// calculate positions of bouncing balls\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x > float(NOF_BALLS+1)) { return; }\n    if (int(fragCoord.x) == NOF_BALLS) { fragColor = vec4(iResolution.x); return; }\n    if (fragCoord.y >= 1.0) discard;\n    float PX = iResolution.x * 0.00125;\n    \n    vec4 ball = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float xres = texelFetch(iChannel0, ivec2(NOF_BALLS,0), 0).x;\n    \n    if (iFrame < 2 || xres != iResolution.x || SCROLL_TIME_MOD(iTime) > SCROLL_LEN - 2.) {\n        ball.x = iResolution.x - PX*40. - fragCoord.x * PX * (30./float(NOF_BALLS));\n        ball.y = iResolution.y - PX*10. - fragCoord.x * PX * (88./float(NOF_BALLS));\n        ball.z = ball.w = 0.;\n    }\n\n    pos = ball.xy / iResolution.xy;\n    uv = pos*2.0 - 1.0;\n    getTp(iTime);\n\n    ball.x += ball.z;\n    if (ball.x < 0.) ball.z = abs(ball.z);\n    if (ball.x > iResolution.x) ball.z = -abs(ball.z);\n\n    ball.w += -BALL_GRAVITY * PX;\n    ball.y += ball.w;\n    if (ball.y < iResolution.y-(tp.y*iResolution.y)+iResolution.y*FONT_SIZE && ball.w < 0.) {\n        ball.w = -ball.w + 0.2;\n        vec2 refl = reflect(normalize(ball.zw)*1.5, normal);\n        ball.z = refl.y * PX * 2.;\n    }\n\n    fragColor = ball;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 pos = vec2(0), uv  = vec2(0), tp  = vec2(0), normal = vec2(0);\n\n#define SCROLL_LEN 33.\n#define SCROLL_SPEED 1.5\n#define SCROLL_TIME_MOD(t) mod(t*SCROLL_SPEED, SCROLL_LEN)\n\n#define FONT_SIZE 0.25\n#define FONT_SPACE 0.45\n#define SIN_FREQ 1.31\n#define SIN_SPEED 3.0\n#define SIN_AMP 0.75\n\n#define NOF_BALLS 35\n#define BALL_SIZE 0.009\n#define BALL_GRAVITY 0.1666\n//#define TWO_POINT_NORMAL\n\nvoid getTp(float time) {\n  tp = uv / FONT_SIZE;\n  float ty = tp.y;\n  tp.x = 2.0*(tp.x -4. + SCROLL_TIME_MOD(time));\n  tp.y = ty + 2.9 +SIN_AMP*sin(tp.x*SIN_FREQ +time*SIN_SPEED);\n\n#ifdef TWO_POINT_NORMAL\n  float x1=tp.x-0.5;\n  float x2=tp.x+0.5;\n  float y1 = ty + 2.9 +SIN_AMP*sin(x1*SIN_FREQ +time*SIN_SPEED);\n  float y2 = ty + 2.9 +SIN_AMP*sin(x2*SIN_FREQ +time*SIN_SPEED);\n  normal=vec2((x2-x1), -(y2-y1));\n#else\n  normal = vec2(-0.4, cos(tp.x*SIN_FREQ +time*SIN_SPEED));\n#endif  \n}\n\n\n// Letters\n#define S(a) c+=char(float(a)); tp.x-=FONT_SPACE;\n\n#define _note  S(10);\n#define _star  S(28);\n#define _smily S(29);\n#define _    S(32);\n#define _exc S(33);\n#define _add S(43);\n#define _dot S(46);\n\n#define _A S(65);\n#define _B S(66);\n#define _C S(67);\n#define _D S(68);\n#define _E S(69);\n#define _F S(70);\n#define _G S(71);\n#define _H S(72);\n#define _I S(73);\n#define _J S(74);\n#define _K S(75);\n#define _L S(76);\n#define _M S(77);\n#define _N S(78);\n#define _O S(79);\n#define _P S(80);\n#define _Q S(81);\n#define _R S(82);\n#define _S S(83);\n#define _T S(84);\n#define _U S(85);\n#define _V S(86);\n#define _W S(87);\n#define _X S(88);\n#define _Y S(89);\n#define _Z S(90);\n\n#define _a S(97);\n#define _b S(98);\n#define _c S(99);\n#define _d S(100);\n#define _e S(101);\n#define _f S(102);\n#define _g S(103);\n#define _h S(104);\n#define _i S(105);\n#define _j S(106);\n#define _k S(107);\n#define _l S(108);\n#define _m S(109);\n#define _n S(110);\n#define _o S(111);\n#define _p S(112);\n#define _q S(113);\n#define _r S(114);\n#define _s S(115);\n#define _t S(116);\n#define _u S(117);\n#define _v S(118);\n#define _w S(119);\n#define _x S(120);\n#define _y S(121);\n#define _z S(122);\n\n#define _0 S(48);\n#define _1 S(49);\n#define _2 S(50);\n#define _3 S(51);\n#define _4 S(52);\n#define _5 S(53);\n#define _6 S(54);\n#define _7 S(55);\n#define _8 S(56);\n#define _9 S(57);\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctGfWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 103, 103, 222], [680, 680, 767, 767, 890], [892, 892, 958, 958, 1271], [1273, 1273, 1330, 1330, 2015]], "test": "untested"}
{"id": "DtGfWR", "name": "Sphere Phong 2", "author": "alexmalyutndev", "description": "Sphere Phong lighting.\nhttps://alexmalyutindev.github.io/posts/blinn-phong-lighting/", "tags": ["3d", "sphere"], "likes": 1, "viewed": 156, "published": 3, "date": "1701962322", "time_retrieved": "2024-07-30T17:18:09.509384", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nvec3 sphNormal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    c, 0.0, -s,\n    0.0, 1.0, 0.0,\n    s, 0.0, c\n  );\n}\n\nmat3 rotation3dX(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    1.0, 0.0, 0.0,\n    0.0, c, s,\n    0.0, -s, c\n  );\n}\n\n//=====================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.z > 0.0) ? (iMouse.xy / iResolution.xy - 0.5) * 2.0 : vec2(0.0);\n    \n    mat3 rot = rotation3dY(-m.x * M_PI) * rotation3dX(m.y * M_PI);\n    \n\tvec3 ro = rot * vec3(0.0, 0.0, 4.0 );\n\tvec3 rd = rot * normalize( vec3(p, -2.0) );\n    \n\n    vec4 sph = vec4( 0.0, 0.0, 0.0, 1.0 );\n    \n    vec3 lig = normalize( vec3(0.5,0.5,0.5) );\n    vec3 col = vec3(0.2);\n\n    float tmin = 1e10;\n    vec3 nor;\n\n\n    float t2 = sphIntersect( ro, rd, sph );\n    if (t2 > 0.0 && t2 < tmin)\n    {\n        tmin = t2;\n        vec3 pos = ro + t2*rd;\n        nor = sphNormal( pos, sph );\n\t}\n\n    if (tmin < 1000.0)\n    {\n        vec3 pos = ro + tmin*rd;\n        \n\t\tcol = vec3(1.0);\n        col *= clamp(dot(nor, lig), 0.0, 1.0);\n    }\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtGfWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 107, 107, 270], [272, 272, 316, 316, 353], [355, 355, 386, 386, 506], [508, 508, 539, 539, 659], [718, 718, 775, 775, 1602]], "test": "untested"}
{"id": "mtKBRm", "name": "Broken TV Noise (horror etc)", "author": "mazureofficial", "description": "Simple noise script for use in horror type setting", "tags": ["noise", "screen", "tv", "monitor", "static"], "likes": 1, "viewed": 198, "published": 3, "date": "1701953018", "time_retrieved": "2024-07-30T17:18:10.417955", "image_code": "// Fork of \"Visuals for VJ\" by mazureofficial. https://shadertoy.com/view/ctyfRD\n// 2023-12-06 14:39:44\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to \n    vec2 uv = ((1./fragCoord+iResolution.xx)+(1./(-fragCoord+iResolution.xy))/iTime);\n\n\n    // me varying pixel color with more complex manipulation\n    vec3 col = (uv.xyx / vec3(0,2,4));//highter iTime-X stronger effect\n    \n    // Enhanced fractal noise based on time and space\n    float noise = 0.0;\n    float scale = 1.0;\n    for (int i = 0; i < 10; i++) {\n        noise += (0.5 - 0.5 * cos(dot(uv * scale, vec2(12.9898, 78.233)) + iTime)) / scale;\n        scale *= 1.8;\n    }\n\n    // More complex transformation for evolving visuals\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    float angle = cos(iTime * 0.5) * 0.3;\n    uv = mat2(cos(angle), -sin(angle), -sin(angle), cos(angle)) * uv;\n\n    // Intricate pattern of moving shapes with fractal noise\n    float dist = distance(uv, vec2(sin(iTime * 0.1), cos(iTime * 0.1)));\n    float pattern = sin(dist * 12.0 - iTime * 3.0) + cos(dist * 12.0 - iTime * 3.0);\n    pattern *= noise;\n\n    // Advanced color manipulation\n    col = (sin(2.0001)-(0.6/(0.2-sin(col))))/(iTime * pattern);\n    // Output to screen with dynamic alpha based on pattern and noise\n    fragColor = vec4(col, col / 6.0 * pattern - noise);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtKBRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 163, 211, 1399]], "test": "untested"}
{"id": "clVBzm", "name": "Pan Tilt toward a Point", "author": "rubioh", "description": "Pan Tilt", "tags": ["pantilt"], "likes": 2, "viewed": 87, "published": 3, "date": "1701945544", "time_retrieved": "2024-07-30T17:18:11.303587", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    \n    vec3 ro = vec3(0.,.0, 0.);\n    vec3 rd = normalize(vec3(uv, .5));\n    \n    vec3 N = vec3(0.);\n    vec2 bI = boxIntersection(ro, rd, vec3(2,1,4), N, vec3(0, 0, 0));\n    vec3 p = ro +rd * bI.x;\n    vec3 ld = normalize(p-vec3(0.,.3,0.));\n    float dotLN = clamp(dot(ld, N), 0., 1.);\n    vec4 col = vec4(.3,.3,.3, .0)*dotLN;\n        \n        \n        \n    vec3 target = vec3(0., -.2, 4.);\n    target += vec3(2.*cos(iTime*.9+3.), .8*cos(iTime*.2+3.), 2.*sin(iTime*.7+3.));\n    N = vec3(0.);\n    bI = boxIntersection(ro, rd, vec3(.2,.2,.2), N, target);\n    p = ro + rd * bI.x;\n    ld = normalize(p-vec3(0.,.3,0.));\n    dotLN = clamp(dot(-ld, N), 0., 1.);\n    if (bI != vec2(-1)){\n        col.rgb = vec3(.7,.1,.7)*dotLN;\n    }\n    /*    \n    N = vec3(0.);\n    bI = boxIntersection(ro, rd, vec3(.08,.08,.08*100.), N, target);\n    p = ro + rd * bI.x;\n    ld = normalize(p-vec3(0.,.3,0.));\n    dotLN = clamp(dot(-ld, N), 0., 1.);\n    if (bI != vec2(-1))\n        col += vec3(.3,.3,.7)*dotLN;\n    N = vec3(0.);\n    bI = boxIntersection(ro, rd, vec3(.08*100.,.08,.08), N, target);\n    p = ro + rd * bI.x;\n    ld = normalize(p-vec3(0.,.3,0.));\n    dotLN = clamp(dot(-ld, N), 0., 1.);\n    if (bI != vec2(-1))\n        col += vec3(.3,.3,.7)*dotLN;\n    N = vec3(0.);\n    bI = boxIntersection(ro, rd, vec3(.08,.08*100.,.08), N, target);\n    p = ro + rd * bI.x;\n    ld = normalize(p-vec3(0.,.3,0.));\n    dotLN = clamp(dot(-ld, N), 0., 1.);\n    if (bI != vec2(-1))\n        col += vec3(.3,.3,.7)*dotLN;\n    */\n    \n    //Obj pos\n    vec3 pos = vec3(.5,.5,2.5); \n    //pos +=  vec3(.3*sin(iTime),cos(iTime)*.5,cos(iTime*1.7));\n    float pan = .0;  // Angle pour la rotation Pan autour de l'axe y\n    float tilt = .0;        // Angle pour la rotation Tilt autour de l'axe x\n    panTiltAngles(pos, vec3(0,1,0), target, pan, tilt);\n    N = vec3(0.);\n    bI = boxIntersectionRot(ro, rd, vec3(.08,.13,.08), pos, N,  pan, tilt);\n    p = ro + rd * bI.x;\n    ld = normalize(p-vec3(0.,.3,0.));\n    dotLN = clamp(dot(-ld, N), 0., 1.);\n    if (bI != vec2(-1)){\n        col.rgb = vec3(.2,.4,.3)*dotLN;\n    }\n        \n    float goLine = rayMarchLine(ro, rd, pos, target, pan, tilt, 3.14159/16.);\n    vec3 colLine = goLine*vec3(1.,0.,0.);\n    col.rgb += colLine;\n    \n    // Output to screen\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "#define PI 3.14159\n\n\nmat3 rot3D(float t, float phi, float psi, float theta){\n    float ca = cos(phi+t);\n    float sa = sin(phi+t);\n    float cb = cos(psi+t);\n    float sb = sin(psi+t);\n    float cg = cos(theta+t);\n    float sg = sin(theta+t);\n\n    return mat3(cb*cg, sa*sb*cg-ca*sg, ca*sb*cg+sa*sg,\n                cb*sg, sa*sb*sg+ca*cg, ca*sb*sg-sa*cg,\n                -sb,   sa*cb,           ca*cb);\n}\nvec2 boxIntersectionRot( in vec3 ro, in vec3 rd, vec3 boxSize, vec3 pos, out vec3 outNormal, float pan, float tilt)\n{\n\n    ro -= pos;\n\n    float zoom = 0.;\n    mat3 txx = rot3D(0., tilt,pan,zoom);\n    mat3 txi = inverse(txx);\n\n    ro = txx*ro;\n    rd = txx*rd;\n\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = (tN>0.0) ? step(vec3(tN),t1) : // ro ouside the box\n                           step(t2,vec3(tF));  // ro inside the box\n    outNormal *= -sign(rd);\n    outNormal = txi*outNormal;\n    return vec2( tN, tF );\n}\n\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal, vec3 pos) \n{\n    ro -= pos;\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = (tN>0.0) ? step(vec3(tN),t1) : // ro ouside the box\n                           step(t2,vec3(tF));  // ro inside the box\n    outNormal *= -sign(rd);\n    return vec2( tN, tF );\n}\n\n\nvoid panTiltAngles(vec3 P, vec3 v, vec3 T, out float pan, out float tilt) {\n    // Calculer le vecteur direction vers T dans l'espace local de P -> (T-P) - P\n    vec3 directionToT = normalize(T - 2.*P);\n    vec3 vLocal = normalize(v);\n    // Calculer l'angle de rotation autour de l'axe y (pan)\n    pan = atan(directionToT.x, directionToT.z)- atan(vLocal.x, vLocal.z);\n    tilt = -asin(directionToT.y)+ asin(vLocal.y);\n}\n\n\n\n\nfloat sdLine(vec3 p, float pan, float tilt)\n{\n    // c is the sin/cos of the angle\n    vec3 c = vec3(0.);\n    c.z = .01;\n    mat3 txx = rot3D(0., tilt,pan,0.);\n    p = txx*p;\n    return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat mapBox(vec3 p, vec3 pos, vec3 target, float pan, float tilt){\n    vec3 p1 = p-pos;\n    p1 = rot3D(0., tilt,pan,0.)*p1;\n    float d = sdBox(p1, vec3(.08,.13,.08));\n   \n    vec3 p2 = p-target;\n    d = min(d,sdBox(p2, vec3(.2,.2,.2)));\n    return d;\n}\n\n\nfloat rayMarchLine(vec3 ro, vec3 rd, vec3 pos, vec3 target, float pan, float tilt, float angle){\n    float depth = 0.;\n    float hit = 0.;\n    vec3 pL = vec3(0.);\n    vec3 pB = vec3(0.);\n    for (int i = 0; i<20; i++){\n        pL = ro + rd*depth;\n        if (abs(pL.y) > 1. || abs(pL.z)>4. || abs(pL.x)>2.) break;\n        float d = sdLine(pL-pos, pan, tilt);\n        if (d<.001){\n            hit = 1.;\n            break;\n        }\n        depth += d;\n    }\n    if (hit == 1.){\n        for (int i = 0; i<20; i++){\n            pB = ro + rd*depth;\n            float d = mapBox(pB, pos, target, pan, tilt);\n            if (d<.001){\n                if (pB.z < pL.z){\n                    hit = 0.;\n                    break;\n                }\n            }\n            depth += d;\n        }\n    }\n    return hit;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clVBzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 2460]], "test": "untested"}
{"id": "dlGfRh", "name": "bound-heart", "author": "LydianLights", "description": "Practicing intentionally timed animation with easing.", "tags": ["animation"], "likes": 7, "viewed": 140, "published": 3, "date": "1701923337", "time_retrieved": "2024-07-30T17:18:12.091480", "image_code": "const float loopTime = 5.5;\nconst vec2 daggerPivot = vec2(0.0, -0.8);\n\nconst float tDag1 = 0.5;\nconst float tDag2 = tDag1 + 0.9;\nconst float tDag3 = tDag2 + 0.9;\n\nconst float impact1 = tDag1 + 0.6;\nconst float impact2 = tDag2 + 0.6;\nconst float impact3 = tDag3 + 0.9;\n\nconst float tScaleOut = impact3 + 1.0;\nconst float tScaleIn = tScaleOut + 0.5;\n\nfloat motion(float t, float start, float duration) {\n    return saturate(map01(t, start, start + duration));\n}\n\nfloat shake(float t, float start, float duration, float freq, float decay) {\n    float q = map01(t, start, start + duration);\n    if (q < 0.0 || q > 1.0) return 0.0;\n    return exp(-decay * q) * sin(freq * PI * q);\n}\n\nfloat sdDagger(in vec2 p) {\n    p *= 1.4;\n    const float width = 0.025;\n    const float blade = 1.25;\n    const float point = 0.4;\n    const float guard = 0.15;\n    const float handle = 0.1;\n    const float flare = 1.7;\n    \n    float d = sdBox(p + vec2(0.0, blade / 2.0 - point / 2.0 - handle), vec2(width, blade / 2.0 - point / 2.0 + handle));\n    d = min(d, sdTriangleIsosceles(p + vec2(0.0, blade), vec2(width, point)));\n    d = min(d, sdBox(p + vec2(0.0, 0.0), vec2(guard, width)));\n    d = min(d, sdTrapezoid((p + vec2(guard + width, 0.0)).yx, flare * width, width, width));\n    d = min(d, sdTrapezoid((p - vec2(guard + width, 0.0)).yx, width, flare * width, width));\n    d = min(d, sdTrapezoid((p - vec2(0.0, 2.0 * handle + width)), width, flare * width, width));\n    return d;\n}\n\nfloat dagger1(vec2 uv, float t) {\n    float m1 = motion(t, tDag1, 0.5); m1 = easeInOut(m1, 4.0);\n    float m2 = motion(t, tDag1 + 0.55, 0.1); m2 = easeInOut(m2, 4.0);\n    \n    vec3 a = vec3(-0.3, -0.4, -0.6);\n    a = mix(a, vec3(0.0, -1.1, 0.0), m1);\n    a = mix(a, vec3(0.0, -0.22, 0.0), m2);\n    \n    uv += a.xy;\n    uv = rotate(uv, a.z, daggerPivot);\n    return sdDagger(uv);\n}\n\nfloat dagger2(vec2 uv, float t) {\n    float m1 = motion(t, tDag2, 0.5); m1 = easeOut(m1, 4.0);\n    float m2 = motion(t, tDag2 + 0.55, 0.1); m2 = easeInOut(m2, 4.0);\n    \n    vec3 a = vec3(-0.7, 0.5, 0.0);\n    a = mix(a, vec3(0.2, -0.37, -0.7), m1);\n    \n    vec2 b = vec2(0.0, -0.9);\n    b = mix(b, vec2(0.0, 0.025), m2);\n    \n    uv += a.xy;\n    uv = rotate(uv, a.z, daggerPivot);\n    uv += b.xy;\n    return sdDagger(uv);\n}\n\nfloat dagger3(vec2 uv, float t) {\n    float m1 = motion(t, tDag3, 0.8); m1 = easeOut(m1, 6.0);\n    float m2 = motion(t, tDag3 + 0.85, 0.1); m2 = easeInOut(m2, 4.0);\n    \n    vec3 a = vec3(0.7, 0.5, 0.0);\n    a = mix(a, vec3(-0.2, -0.37, 0.7), m1);\n    \n    vec2 b = vec2(0.0, -0.9);\n    b = mix(b, vec2(0.0, 0.025), m2);\n    \n    uv += a.xy;\n    uv = rotate(uv, a.z, daggerPivot);\n    uv += b.xy;\n    return sdDagger(uv);\n\n}\n\nfloat drip(vec2 uv, float t, float start, vec2 pos, vec2 slideTo) {\n    const float cycleTime = 2.0;\n    const float slideTime = 0.5;\n    const float overlapTime = 0.15;\n    \n    float dripT = mod(t - start, cycleTime);\n    float m = motion(dripT, 0.0, slideTime); m = easeOut(m, 2.0);\n    \n    vec2 o = mix(pos, slideTo, m);\n    if (dripT > slideTime - overlapTime) {\n        float fallT = dripT - slideTime + overlapTime;\n        o.y += 2.0 * fallT * fallT;\n    }\n    \n    uv += o;\n    uv *= 30.0;\n    return sdEgg(uv, 1.0, -3.0);\n}\n\nfloat heart(vec2 uv0, float t) {\n    vec2 uv = uv0;\n    uv.y += 0.2;\n    uv = 2.0 * uv + vec2(0.0, 0.5);\n    uv.y *= 0.9;\n    uv = scale(uv, 0.1 * (0.2 * sin(PI * t * loopTime / 6.0) + 0.5) + 1.0, vec2(0.0, 0.5));\n    float d = sdHeart(uv);\n    \n    if (t < tScaleIn) {\n        d = smin(d, drip(uv0, t, 0.0, vec2(0.13, 0.22), vec2(0.10, 0.35)), 0.9);\n        d = smin(d, drip(uv0, t, 0.4, vec2(-0.23, 0.10), vec2(-0.15, 0.25)), 0.9);\n    }\n    \n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float px = 2.0 / iResolution.y;\n    vec2 uv0 = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    uv0.y += -0.1;\n    uv0 *= 0.7;\n    vec2 uv = uv0;\n    \n    float t = mod(iTime, loopTime);\n    \n    vec2 s1 = 0.3 * shake(t, impact1, 0.7, 20.0, 5.0) * vec2(0.0, 1.0);\n    vec2 s2 = 0.3 * shake(t, impact2, 0.7, 20.0, 5.0) * vec2(HALF_ROOT_2, HALF_ROOT_2);\n    vec2 s3 = 0.3 * shake(t, impact3, 0.7 + 0.3, 30.0, 5.0) * vec2(-HALF_ROOT_2, HALF_ROOT_2);\n    vec2 s = s1 + s2 + s3;\n    uv += s;\n    \n    if (t > tScaleOut) {\n        float tScale = t - tScaleOut;\n        uv = scale(uv0, 1.0 / (1.0 + 20.0 * tScale), vec2(0.0, -0.1));\n    }\n    if (t > tScaleIn) {\n        float tScale = t - tScaleIn;\n        float s = motion(tScale, 0.0, 0.5); s = easeOut(s, 3.0);\n        uv = scale(uv0, 1.0 / s, vec2(0.0, -0.1));\n    }\n    \n    float d = heart(uv, t);\n    if (t > tDag1 && t < tScaleIn) { d = min(d, dagger1(uv, t)); }\n    if (t > tDag2 && t < tScaleIn) { d = min(d, dagger2(uv, t)); }\n    if (t > tDag3 && t < tScaleIn) { d = min(d, dagger3(uv, t)); }\n    \n    bool invert = false;\n    if (t > impact1 - 0.01 && t < impact1 - 0.01 + 0.05) { invert = true; }\n    if (t > impact2 - 0.01 && t < impact2 - 0.01 + 0.05) { invert = true; }\n    if (t > impact3 && t < tScaleIn) { invert = true; }\n    \n    // antialias\n    d = smoothstep(0.0, 2.0 * px, d);\n    vec3 color;\n    if (invert) { color = vec3(d); }\n    else { color = vec3(1.0 - d); }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "#define PI 3.141592654\n#define ROOT_2 1.4142135\n#define HALF_ROOT_2 0.7071068\n\nfloat map01 (float t, float t0, float t1) {return (t - t0) / (t1 - t0); }\nfloat saturate (float x) { return min(max(x, 0.0), 1.0); }\nfloat dot2(vec2 v) { return dot(v,v); }\n\n// thx iq, as always:\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdTriangleIsosceles(in vec2 p, in vec2 q) {\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdTrapezoid(in vec2 p, in float r1, in float r2, in float he) {\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdHeart(in vec2 p) {\n    p.x = abs(p.x);\n    if (p.y+p.x>1.0) return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat sdEgg(in vec2 p, in float ra, in float rb) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    float r = ra - rb;\n    return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n            (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\n\n// sdf union\nfloat smin(float a, float b, float k) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n\n// easing\nfloat easeIn(float x, float q) {\n    return pow(x, q);\n}\n\nfloat easeOut(float x, float q) {\n    return 1.0 - pow(1.0 - x, q);\n}\n\nfloat easeInOut(float x, float q) {\n    return x < 0.5\n        ? pow(2.0 * x, q) / 2.0\n        : 1.0 - pow(2.0 * (1.0 - x), q) / 2.0;\n}\n\n// transform\nvec2 rotate(vec2 v, float angle, vec2 pivot) {\n    v -= pivot;\n    v *= mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n    v += pivot;\n    return v;\n}\n\nvec2 scale(vec2 v, float s, vec2 pivot) {\n    v -= pivot;\n    v *= s;\n    v += pivot;\n    return v;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlGfRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[349, 349, 401, 401, 459], [461, 461, 537, 537, 677], [679, 679, 706, 706, 1466], [1468, 1468, 1501, 1501, 1848], [1850, 1850, 1883, 1883, 2274], [2276, 2276, 2309, 2309, 2700], [2702, 2702, 2769, 2769, 3236], [3238, 3238, 3270, 3270, 3698], [3700, 3700, 3755, 3755, 5238]], "test": "untested"}
{"id": "dtyfRw", "name": "Tonemapping Testing", "author": "GabeRundlett", "description": "Playground for testing tonemapping\n\nFrom Right to Left:\nNo tonemapping, Aces, Agx, Uncharted2, Simple Reinhard, Luma-based Reinhard, White-preserving luma-based Reinhard, \"RomBinDaHouse\"", "tags": ["tonemapping", "filmic", "aces", "agx"], "likes": 1, "viewed": 423, "published": 3, "date": "1701918152", "time_retrieved": "2024-07-30T17:18:12.939214", "image_code": "\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 base_uv = fragCoord/iResolution.xy;\n    base_uv *= vec2(8.0, 1.0);\n\n    vec2 uv = fract(base_uv);\n    vec3 col = hsv2rgb(vec3(uv.y, 1.0, uv.x * 5.0));\n\n    if (base_uv.x < 1.0) {\n        // do nothing (show default)\n    } else if (base_uv.x < 2.0) {\n        aces(col);\n    } else if (base_uv.x < 3.0) {\n        agx(col);\n        agxLook(col);\n        // agxEotf(col);\n    } else if (base_uv.x < 4.0) {\n        col = Uncharted2ToneMapping(col);\n    } else if (base_uv.x < 5.0) {\n        col = simpleReinhardToneMapping(col);\n    } else if (base_uv.x < 6.0) {\n        col = lumaBasedReinhardToneMapping(col);\n    } else if (base_uv.x < 7.0) {\n        col = whitePreservingLumaBasedReinhardToneMapping(col);\n    } else if (base_uv.x < 8.0) {\n        col = RomBinDaHouseToneMapping(col);\n    }\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + k.xyz) * 6.0 - k.www);\n    return c.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), c.y);\n}\n\nconst mat3 SRGB_2_XYZ_MAT = mat3(\n    0.4124564, 0.3575761, 0.1804375,\n    0.2126729, 0.7151522, 0.0721750,\n    0.0193339, 0.1191920, 0.9503041);\nconst float SRGB_ALPHA = 0.055;\n\nfloat luminance(vec3 color) {\n    vec3 luminanceCoefficients = SRGB_2_XYZ_MAT[1];\n    return dot(color, luminanceCoefficients);\n}\n\nconst mat3 agxTransform = mat3(\n    0.842479062253094, 0.0423282422610123, 0.0423756549057051,\n    0.0784335999999992, 0.878468636469772, 0.0784336,\n    0.0792237451477643, 0.0791661274605434, 0.879142973793104);\n\nconst mat3 agxTransformInverse = mat3(\n    1.19687900512017, -0.0528968517574562, -0.0529716355144438,\n    -0.0980208811401368, 1.15190312990417, -0.0980434501171241,\n    -0.0990297440797205, -0.0989611768448433, 1.15107367264116);\n\nvec3 agxDefaultContrastApproximation(vec3 x) {\n    vec3 x2 = x * x;\n    vec3 x4 = x2 * x2;\n    return +15.5 * x4 * x2 - 40.14 * x4 * x + 31.96 * x4 - 6.868 * x2 * x + 0.4298 * x2 + 0.1191 * x - 0.00232;\n}\n\nvoid agx(inout vec3 color) {\n    const float minEv = -12.47393;\n    const float maxEv = 4.026069;\n    color = agxTransform * color;\n    color = clamp(log2(color), minEv, maxEv);\n    color = (color - minEv) / (maxEv - minEv);\n    color = agxDefaultContrastApproximation(color);\n}\n\nvoid agxEotf(inout vec3 color) {\n    color = agxTransformInverse * color;\n}\n\nvoid agxLook(inout vec3 color) {\n    // Punchy\n    const vec3 slope = vec3(1.1);\n    const vec3 power = vec3(1.2);\n    const float saturation = 1.3;\n    float luma = luminance(color);\n    color = pow(color * slope, power);\n    color = max(luma + saturation * (color - luma), vec3(0.0));\n}\n\n\n\n// ACES fitted\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v) {\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvoid aces(inout vec3 color) {\n    color = color * ACESInputMat;\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n    color = clamp(color, 0.0, 1.0);\n}\n\nfloat gamma = 2.4;\n\nvec3 simpleReinhardToneMapping(vec3 color)\n{\n\tfloat exposure = 1.5;\n\tcolor *= exposure/(1. + color / exposure);\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 lumaBasedReinhardToneMapping(vec3 color)\n{\n\tfloat luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat toneMappedLuma = luma / (1. + luma);\n\tcolor *= toneMappedLuma / luma;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 whitePreservingLumaBasedReinhardToneMapping(vec3 color)\n{\n\tfloat white = 2.;\n\tfloat luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat toneMappedLuma = luma * (1. + luma / (white*white)) / (1. + luma);\n\tcolor *= toneMappedLuma / luma;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 RomBinDaHouseToneMapping(vec3 color)\n{\n    color = exp( -1.0 / ( 2.72*color + 0.15 ) );\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 Uncharted2ToneMapping(vec3 color) {\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n\tfloat exposure = 2.;\n\tcolor *= exposure;\n\tcolor = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n\tfloat white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n\tcolor /= white;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtyfRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 57, 57, 890]], "test": "untested"}
{"id": "dlGBzW", "name": "Menger Sponge Pathtracer 2", "author": "joteakus", "description": "Thanks Inigo Quilez for the intuitive explanation of the menger sponge!  I didn't use his code though, it didn't make enough sense to me so I spent like two days making my own ", "tags": ["raymarching", "fractal", "menger", "pathtracing"], "likes": 2, "viewed": 162, "published": 3, "date": "1701907561", "time_retrieved": "2024-07-30T17:18:13.872718", "image_code": "int s = 3;\n\nvec3 sample_texture(vec2 p){\n    vec4 temp = texture(iChannel0, p/iResolution.xy);\n    return temp.xyz/temp.w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame <= -1){\n        fragColor = postprocess(vec4(sample_texture(fragCoord), 0.));\n    }else{\n        vec3 total = vec3(0.);\n        float max_magnitude = 1.+length(vec2(s));\n        float magnitude_total = 0.;\n        for(int x = -s; x <= s; x++){\n            for(int y = -s; y <= s; y++){\n                vec3 temp = (max_magnitude-length(vec2(x, y)))*sample_texture(fragCoord+vec2(x, y));\n                magnitude_total += max_magnitude-length(vec2(x,y));\n                total += temp*length(temp)*0.02;\n            }\n        }\n        fragColor = postprocess(vec4(sample_texture(fragCoord)+total/magnitude_total, 0.)); \n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "Ray ray;\n\nfloat sde;\nfloat intersect_result;\nvec2 uv;\nvec2 uv2;\nvec3 col;\n\nvec3 camera_pos = vec3(6., 6., -15.);\nvec3 camera_rot = degree_to_rad*vec3(-25., -25., 0.);\n\n//settings\nconst int bounces = 4;\nconst int pass_per_frame = 1;\n\nconst bool ambient_light_enabled = true;\nconst bool use_three_light_model = false;\nconst bool camera_is_light = true;\n\nvec3 rotate(vec3 base, float rotation, int type){\n    vec3 temp = base;\n    if(type == 2){\n        temp.x = base.x*cos(rotation) - base.z*sin(rotation);\n        temp.z = base.x*sin(rotation) + base.z*cos(rotation);\n    }else if(type == 1){\n        temp.z = base.z*cos(rotation) - base.y*sin(rotation);\n        temp.y = base.z*sin(rotation) + base.y*cos(rotation);\n    }\n    return temp;\n}\n\nvec3 camera_transform(vec3 base){\n\n    vec3 temp = base;\n    temp = rotate(temp.xyz, camera_rot.x, 1); //rotation about x\n    temp = normalize(temp);\n    temp = rotate(temp.xyz, -camera_rot.y, 2); //rotation about y axis\n    temp = normalize(temp);\n    return temp;\n}\n\nvoid intersect(float max_len){\n    sde = inf;\n    //ray.pos += ray.dir*eps;\n    while(sde > eps || ray.len < max_len){\n        sde = get_scene_distance(ray.pos, false);\n        if(sde > eps && ray.len < max_len){\n            ray.pos += ray.dir*sde;\n            ray.len += sde;\n        }else{\n            intersect_result = (sde <= eps) ? HIT : MISS;\n            break;\n        }\n    }\n}\n\nvec3 apply_light(vec3 light_dir, vec3 light_col, bool ambient, bool falloff){\n\n    vec3 n_dir = normalize(light_dir);\n    vec3 fresnel1 = (scene_surface == matte) ? scene_col : vec3(0.5);\n    \n    vec3 half_not_illegal = normalize(n_dir-ray.dir);\n    float diffuse = max(0., dot(n_dir, normal));\n    \n    float specular = 0.;//(1.-scene_roughness)*pow(clamp(dot(n_dir,reflect(ray.dir, normal)),0.,1.),10.*(1.-scene_roughness));\n    vec3  fresnel = fresnel1 + (1.-fresnel1)*pow(clamp(1.-dot(half_not_illegal,n_dir),0.,1.),50.);\n    \n    \n    float shadow_strength = 1.;\n    float d = 1.;\n    if(diffuse >= 0. && !ambient){\n        d = length(light_dir);\n        Ray ray2 = ray;\n        ray.dir = n_dir;\n        ray.len = 0.;\n        intersect(d);\n        shadow_strength = (intersect_result == HIT) ? 0. : 1.;\n        ray = ray2;\n    }else{\n        shadow_strength = 1.;\n    }\n    vec3 back = vec3(0.);\n    if(scene_surface == matte){\n        back += diffuse*scene_col*light_col;\n        back += diffuse*light_col*fresnel*(1.+specular);\n    }else if(scene_surface == metal){\n        back += diffuse*light_col*fresnel*(1.+specular);\n    }else{\n        \n    }\n    back *= shadow_strength;\n    return back;\n\n}\n\nvec3 apply_lighting(){\n\n    vec3 temp = vec3(0.);\n    float distance_to_center = hash13(cross(ray.pos, ray.dir)*2.3+iTime*500.);\n    vec3 offset = random_equal_vec3(cross(ray.pos, ray.dir)*(iTime+500.));\n    //temp += apply_light(normalize((distance_to_center*offset+vec3(100., 1000., 0.))-ray.pos), vec3(5., 5., 2.5)); \n    //temp += apply_light(normalize(vec3(-1., 10., 0.)), vec3(1., 1., 3.)); \n    temp += apply_light((100.*offset+vec3(1000., 10000., -500.)-ray.pos), vec3(10., 10., 5.), false, false); \n    if(ambient_light_enabled){\n        temp += apply_light((normalize(offset)), vec3(0.5, 0.5, 0.5), true, false); \n        temp += apply_light((100.*normalize(vec3(1., 3., 1.))), sky_col, false, false); \n    }\n    if(camera_is_light){\n        temp += apply_light((distance_to_center*0.25*offset+camera_pos-ray.pos), vec3(5., 5., 2.5), false, true); \n    }\n    if(use_three_light_model){\n        temp += apply_light((distance_to_center*0.5*offset+vec3(-7., 9., -1.)-ray.pos), vec3(1., 1., 1.), false, true); \n        temp += apply_light((distance_to_center*0.5*offset+vec3(7., 9., -1.)-ray.pos), vec3(1., 1., 1.), false, true); \n    }\n    \n    return temp;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 total_color = vec3(0.);\n\n    for(int pass = 0; pass <= pass_per_frame; pass++){\n        uv = fragCoord/iResolution.xy;\n        uv2 = (uv-0.5)*2.;\n        uv2.x *= iResolution.x/iResolution.y;\n        vec2 uv3 = uv2+(hash31(iTime*1234.5).xy/(iResolution.xy-10.));\n        col = vec3(0.);\n        vec3 ray_col = vec3(1.);\n        vec3 accumulated = vec3(0.);\n        float depth = 0.;\n        \n        ray = Ray(camera_pos, normalize(vec3(uv3, 2.)), 0.);\n        ray.dir = camera_transform(ray.dir);\n        \n\n        for(int i = 0; i <= bounces; i++){\n            intersect(max_t);\n            if(intersect_result == HIT){\n                if(i == 0){\n                    depth = ray.len;\n                }\n                get_scene_distance(ray.pos, true);\n                get_normal(ray.pos);\n                ray.pos += normal*eps;\n                //lighting goes here??? maybe???\n                vec3 scene_color2 = scene_col;\n                scene_col *= ray_col;\n                vec3 temp_col = apply_lighting();\n                ray_col *= scene_color2;\n                accumulated += temp_col;\n                //tint *= temp_col;\n                vec3 specular_dir = reflect(ray.dir, normal);\n                vec3 diffuse_dir = vec3_near(cross(ray.pos, ray.dir)*(iTime+500.), normal, 1.-scene_diffuse);\n                ray.dir = mix(specular_dir, diffuse_dir, scene_roughness);\n                ray.len = 0.;\n            }else{\n                accumulated += sky_col*ray_col;\n                break;\n            }\n            if(depth != 0.){\n                accumulated = mix(accumulated, fog_col, depth/fog_dist);\n            }\n        }\n    \n        \n        col = accumulated/float(bounces+1);\n        total_color += col;\n    }\n\n    vec4 total = texture(iChannel0, uv);\n    total += vec4(total_color, pass_per_frame);\n    if(iTime <2.){\n        fragColor = vec4(0.);\n    }else{\n        fragColor = total;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float HIT = 1.;\nconst float MISS = 2.;\nconst float inf = 9999999.;\nconst float eps = 0.01;\nconst float max_t = 100.;\nconst float pi = 3.14159265359;\nconst float degree_to_rad = pi/180.;\nconst float rad_to_degree = 180./pi;\nconst int matte = 1;\nconst int metal = 2;\nfloat sde_v_1;\nfloat sde_v_2;\nvec3 normal;\nconst vec3 sky_col = vec3(4., 4., 12.);\nconst vec3 fog_col = vec3(4., 4., 12.);\nconst float fog_dist = 500.;\n\nvec3 scene_col;\nfloat scene_diffuse;\nfloat scene_roughness;\nint scene_surface;\n\nvec4 postprocess(vec4 og){\n    vec4 temp = og;\n    temp *= 0.8;\n    temp = temp/(temp+1.);\n    temp = 1.1*(temp-0.5)+0.5-0.;\n    temp = pow(temp, vec4(1.5));\n    return temp;\n\n}\n\nstruct Ray{\n    vec3 pos;\n    vec3 dir;\n    float len;\n};\n\nvoid object(bool update_surface, float sde, vec3 col, float diffuse, float roughness, int surface_type){\n    if(sde <= sde_v_1){\n        sde_v_1 = sde;\n        if(update_surface){\n            scene_col = col;\n            scene_diffuse = diffuse;\n            scene_roughness = roughness;\n            scene_surface = surface_type;\n        }\n    }\n}\n\nfloat sphere(vec3 from, vec3 pos, float radius){\n    return distance(from, pos)-radius;\n}\n\nfloat plane(vec3 from, vec3 normal, float offset){\n    return(dot(normalize(normal), from)-offset);\n}\n\nfloat box(vec3 from, vec3 pos, vec3 dimensions)\n{\n  vec3 q = abs(from-pos) - dimensions;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat cross_but_not_reserved(vec3 from, vec3 pos, float radius, float len){\n    float d1 = box(from, pos, vec3(len, radius, radius));\n    float d2 = box(from, pos, vec3(radius, len, radius));\n    float d3 = box(from, pos, vec3(radius, radius, len));\n    return min(d1, min(d2, d3));\n}\n\nvec2 menger(vec3 from, vec3 pos, float size, float iterations){\n    float dist = box(from, pos, vec3(size));\n    float break_i = 0.;\n    vec3 cross_pos = pos;\n    for(float i = 1.; i<=iterations; i+=1.){\n        float m = 3.*(size/pow(3., i-1.));\n        cross_pos = floor((0.5*m+1.5*from)/m)*m/1.5;\n        float cross_size = size/pow(3., i);      \n        float cross_dist = cross_but_not_reserved(from, cross_pos, cross_size/1., inf);\n        if(-cross_dist > dist) break_i = i;\n        dist = max(dist, -cross_dist);\n        \n    }    \n    return vec2(dist, break_i);\n}\n\nfloat get_scene_distance(vec3 pos, bool colors){\n\n    sde_v_1 = inf;\n    vec2 menger_dist = menger(pos, vec3(0.), 5., 3.);\n    \n    vec3 menger_col = vec3(0.1);\n    if(menger_dist.y == 0.){\n        menger_col = vec3(0.7);\n    }else if(menger_dist.y == 1.){\n        menger_col = vec3(0.6, 0.5, 0.5);\n    }else if(menger_dist.y == 2.){\n        menger_col = vec3(0.1, 0.2, 0.6);\n    }else if(menger_dist.y == 3.){\n        menger_col = vec3(0.7, 0.4, 0.3);\n    }else{\n        menger_col = vec3(0.1, 0.1, 0.1);\n    }\n    object(colors,\n           menger_dist.x,\n           vec3(menger_col), 0.2, 0.1, matte);   \n\n    return sde_v_1;\n}\n\nvoid get_normal(vec3 pos){\n    vec2 oz = vec2(1., 0.);\n    normal = vec3(0.);\n    normal.x += get_scene_distance(pos+eps*oz.xyy, false)-get_scene_distance(pos-eps*oz.xyy, false);\n    normal.y += get_scene_distance(pos+eps*oz.yxy, false)-get_scene_distance(pos-eps*oz.yxy, false);\n    normal.z += get_scene_distance(pos+eps*oz.yyx, false)-get_scene_distance(pos-eps*oz.yyx, false);\n    normal = normalize(normal);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   vec3 temp = fract((p3.xxy+p3.yzz)*p3.zyx); \n   return (temp-0.5)*2.;\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 random_equal_vec3(vec3 seed){\n    float azimuth = hash13(seed)*360.;\n    float polar = hash13(seed*2.5+103.)*360.;\n    vec3 temp = vec3(0.);\n    temp.x = sin(polar)*cos(azimuth);\n    temp.y = sin(polar)*sin(azimuth);\n    temp.z = cos(polar);\n    return temp;\n}\n\n\n//    normalize(hash31(abs(time*50.+100.+abs(seed.x*25.)+abs(seed.y*1234.)+abs(seed.z*100.))));\n\n\nvec3 vec3_near(vec3 seed, vec3 dir, float threshold){\n    if(threshold > 0.9){\n        return dir;\n    }else{\n        float modify = 100.;\n        vec3 temp = random_equal_vec3(seed+modify*10.);\n        while(dot(temp, dir) <= threshold){\n            modify += 0.5;\n            temp = random_equal_vec3(seed+modify*10.);\n        }\n        return temp;\n    }\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlGBzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[12, 12, 40, 40, 124], [126, 126, 183, 183, 826]], "test": "untested"}
{"id": "mlVBzD", "name": "Shadecember Horizon ", "author": "workingclasshacker", "description": "Part of my #ShadeCember series on linkedIn where I post one new shader every day.", "tags": ["blackhole"], "likes": 3, "viewed": 304, "published": 3, "date": "1701899675", "time_retrieved": "2024-07-30T17:18:14.644654", "image_code": "float hue2rgb(float p, float q, float t) {\n  if(t < 0.0) t += 1.0;\n  if(t > 1.0) t -= 1.0;\n  if(t < 1.0/6.0) return p + (q - p) * 6.0 * t;\n  if(t < 1.0/2.0) return q;\n  if(t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;\n  return p;\n}\nvec3 hsl2rgb(float h, float s, float l) {\n  float r, g, b;\n\n  if (s == 0.0) {\n    r = g = b = l; // Achromatic\n    } else {\n    float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;\n    float p = 2.0 * l - q;\n    r = hue2rgb(p, q, h + 1.0/3.0);\n    g = hue2rgb(p, q, h);\n    b = hue2rgb(p, q, h - 1.0/3.0);\n  }\n\n  return vec3(r, g, b);\n}\n\n\n// Function to create a 2D rotation matrix\nmat2 rotate2D(float angle){\n  float cosAngle = cos(angle);\n  float sinAngle = sin(angle);\n  return mat2(cosAngle, -sinAngle, sinAngle, cosAngle);\n}\n\nfloat noise(vec2 uv) {\n  return fract(sin(dot(uv.xy, vec2(112.9898, 78.233))) * 43758.5453);\n}\nfloat noise23(vec2 uv) {\n  return fract(sin(dot(uv.xy, vec2(13.9898, 121783.233))) * 1758.5453);\n}\nvec2 noise2(vec2 uv){\n  return vec2(noise(uv), noise23(fract(uv*12312.123123)+vec2(11234.2, 112123.4343110)));\n}\n\nfloat perlinNoise(vec2 c){\n  vec2 i = floor(c);\n  vec2 f = fract(c);\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  return mix(mix(dot( noise2(i + vec2(0.0, 0.0) ), f - vec2(0.0, 0.0)), \n  dot( noise2(i + vec2(1.0, 0.0) ), f - vec2(1.0, 0.0)), u.x),\n  mix( dot( noise2(i + vec2(0.0, 1.0) ), f - vec2(0.0, 1.0)), \n  dot( noise2(i + vec2(1.0, 1.0) ), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n// Modified FBM function for smoother output\nfloat fbm(vec2 p) {\n  float total = 0.0;\n  float persistence = 0.5;\n  float amplitude = 1.0;\n  float maxValue = 0.0;  // Used for normalizing result to 0.0 - 1.0\n  for(int i = 0; i < 12; i++) {\n    total += perlinNoise(p) * amplitude;\n    maxValue += amplitude;\n    \n    amplitude *= persistence;\n    p *= 2.0;\n  }\n  return total/maxValue;\n}\n\n// Function to calculate brightness factor based on distance to event horizon\nfloat calculateBrightnessFactor(float distance, float eventHorizonRadius, float influenceZoneRadius) {\n  if (distance <= eventHorizonRadius) {\n    return 1.0; // Maximum brightness inside event horizon\n    } else if (distance <= influenceZoneRadius) {\n    float normalizedDistance = (distance - eventHorizonRadius) / (influenceZoneRadius - eventHorizonRadius);\n    return pow(1.0 - normalizedDistance, 3.0); // Cubic falloff for smoothness\n    } else {\n    return 0.0; // No additional brightness outside influence zone\n  }\n}\n\n// Modified nebulaColor function to include brightness factor calculation\nvec3 nebulaColor(float fbmValue, float hue, float distanceToEventHorizon, float eventHorizonRadius) {\n  // Define the radius of the influence zone where the nebula will start to brighten\n  float influenceZoneRadius = eventHorizonRadius + 2.1; // Adjust this value as needed\n\n  // Calculate the brightness factor\n  float brightnessFactor = calculateBrightnessFactor(distanceToEventHorizon, eventHorizonRadius, influenceZoneRadius);\n\n  // Calculate the final lightness based on FBM value and brightness factor\n  float lightness = mix(fbmValue/1.4, 2.5, fbmValue * brightnessFactor); // Mix to avoid exceeding 1.0\n\n\n  // Convert HSL to RGB using the given hue and calculated lightness\n  vec3 color = hsl2rgb(hue, 1.0, lightness);\n  color += brightnessFactor * 0.1; // Add a bit of brightness to the nebula\n  return color;\n}\n\n// Function to create an anisotropic scaling matrix\nmat2 anisotropicScale(float xScale, float yScale) {\n  return mat2(xScale, 0.0, 0.0, yScale);\n}\n\nfloat Star(vec2 uv, float flare){\n  float d = length(uv);\n  float m = .02/d;\n  float rays = max(0., 1.-abs(uv.x*uv.y*1000.))*0.1;\n  m+=rays * flare;\n  uv *= rotate2D(3.1415/4.);\n  rays = max(0., 1.-abs(uv.x*uv.y*100000.))*0.9;\n  m += rays*0.3*flare;\n  m *= smoothstep(0.6,.01, d);\n  return m;\n}\n\nvec3 starLayer(vec2 uv, float time, float scale, vec2 off){\n  \n  uv += off;\n  uv *= scale;\n  vec3 color = vec3(0);\n  vec2 gv = fract(uv) - 0.5;\n  vec2 id = floor(uv);\n  for (int y = -1; y <= 1; y++) {\n    for (int x = -1; x <= 1; x++) {\n      vec2 offset = vec2(x, y);\n      float n = noise(id + offset);\n      float size = fract(n * 1343.32*250.);\n      float star = Star(gv - offset - vec2(n, fract(n * 3334.)) + 0.5, smoothstep(.3, 0.9, size));\n      vec3 starColor = sin(vec3(0.5, 0.5, .5) * fract(n * 2345.2) * 123.12) * .5 + .5;\n      starColor *= vec3(.4, 0.4, .1 + size);\n      star *= sin(time * n * 6.3) * 0.5 + 1.;\n      color += star * size * starColor;\n    }\n  }\n  return color;\n}\n\nvec2 lensingEffect(vec2 uv, vec2 center, float radius, float strength) {\n  vec2 toCenter = center - uv;\n  float distance = length(toCenter);\n  float effect = smoothstep(radius, radius * 0.5, distance) * strength;\n\n  // This will distort the UVs to create a stretching effect towards the center\n  toCenter = normalize(toCenter) * effect;\n  uv += toCenter;\n\n  return uv;\n}\n\nvec2 gravitationalLensing(vec2 uv, vec2 blackHoleCenter, float mass) {\n  vec2 delta = uv - blackHoleCenter;\n  float r = length(delta)*2.0;\n  float lensingStrength = mass / (r * r);\n  return uv + lensingStrength * normalize(delta);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord-iResolution.xy) / min(iResolution.x, iResolution.y);\n  uv *= rotate2D(3.14159/3.0);\n     float time = iTime * 0.2;\n  // Set the black hole parameters\n  vec2 blackHoleCenter = vec2(0.0, 0.0); // Center of the black hole in UV space\n  float blackHoleRadius = 0.5; // Radius of black hole effect in UV space\n  float lensStrength = 2.0; // Strength of the lensing effect\n\n  // Apply gravitational lensing to UV coordinates\n  vec2 lensedUv = uv;\n  lensedUv = lensingEffect(uv, blackHoleCenter, blackHoleRadius, lensStrength);\n  lensedUv += gravitationalLensing(uv, blackHoleCenter, 0.42);\n\n  lensedUv.y += time;\n  blackHoleCenter.y += time;\n  float distanceToEventHorizon = length(lensedUv - blackHoleCenter);\n  // Calculate the distance from the center of the black hole\n  float distanceFromCenter = length(lensedUv - blackHoleCenter);\n\n  // Calculate the angle between the UV coordinates and a reference direction (e.g., x-axis)\n  float angle = atan(lensedUv.y - blackHoleCenter.y, lensedUv.x - blackHoleCenter.x);\n\n  // Define scaling factors for the X and Y axes (adjust as needed)\n  float xScale = 1.0; // No stretching in the X-axis\n  float yScale = 1.0; // No stretching in the Y-axis\n  \n  // Apply angle-based bias to the stretching (e.g., stretching more in the vertical direction)\n  float angleBias = sin(angle * 5.0); // Adjust the factor for the desired bias\n  vec2 nebulaUv = lensedUv;\n  // Apply the anisotropic scaling to the UV coordinates\n  nebulaUv = (anisotropicScale(xScale, yScale + angleBias) * (nebulaUv - blackHoleCenter)) + blackHoleCenter;\n\n  float fbmValue = fbm(nebulaUv * 0.5 + iTime * 0.1); // You can play with these values\n  vec3 nebula = nebulaColor(fbmValue, 1.0*.3+.8, distanceToEventHorizon, blackHoleRadius);\n  fbmValue = fbm(nebulaUv * 0.25 + iTime * 0.05); // You can play with these values\n  vec3 nebula2 = nebulaColor(fbmValue, .6, distanceToEventHorizon, blackHoleRadius);\n  // red nebulae\n  fbmValue = fbm(nebulaUv * 0.5 + iTime * 0.1+4.0); // You can play with these values\n  vec3 nebula3 = nebulaColor(fbmValue, 0.01, distanceToEventHorizon, blackHoleRadius);\n  vec3 color = vec3(0);\n  color += nebula2*4.;\n  color += starLayer(lensedUv*rotate2D(3.14159/4.0), time, 4.0, vec2(time * 0.1, 0.0))*vec3(1., 1.2, sin(time*0.1)*0.5+0.5);\n  color += nebula;\n  color += starLayer(lensedUv+vec2(0.5, 0.5), time*3.0, 8.0, vec2(time * 0.08, 0.0))*vec3(1.6, 1.1, 0.02*sin(time*0.1)*0.5+0.5);\n  color += nebula3;\n  color += starLayer(lensedUv, time*2.0, 12.0, vec2(time * 0.05, 0.0))*vec3(1.5, 1., sin(time*0.01)*0.5+0.5);\n  //color = nebula3;\n  // create black hole\n  float hole = length(uv);\n  hole = smoothstep(0.33, 0.34, hole);\n  color *= vec3(hole);\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 35456, "src": "https://soundcloud.com/espen-sande-larsen-365984601/black-hole-horizon", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlVBzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 240], [241, 241, 282, 282, 575], [578, 621, 648, 648, 768], [770, 770, 792, 792, 864], [865, 865, 889, 889, 963], [964, 964, 985, 985, 1076], [1078, 1078, 1104, 1104, 1452], [1453, 1498, 1517, 1517, 1839], [1841, 1919, 2021, 2021, 2444], [2446, 2520, 2621, 2706, 3340], [3342, 3394, 3445, 3445, 3488], [3490, 3490, 3523, 3523, 3784], [3786, 3786, 3845, 3845, 4479], [4481, 4481, 4553, 4553, 4851], [4853, 4853, 4923, 4923, 5085], [5087, 5087, 5144, 5194, 7967]], "test": "untested"}
{"id": "mtKBzD", "name": "Deeper It Goes (Dare to Stare)", "author": "mazureofficial", "description": "Interesting illusion based on basics", "tags": ["vfx", "illusion", "depth", "vj", "visuals", "stare"], "likes": 0, "viewed": 91, "published": 3, "date": "1701898983", "time_retrieved": "2024-07-30T17:18:15.531283", "image_code": "// Fork of \"Visuals for VJ\" by mazureofficial. https://shadertoy.com/view/ctyfRD\n// 2023-12-06 14:39:44\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv=cos(0.9*fragCoord/iResolution.xx)-(0.1*cos(iResolution.xx-iTime));\n\n\n    // Time varying pixel color with more complex manipulation\n    vec3 col = (iTime-20.*iTime * uv.xyx - vec3(0,2,4));//highter iTime-X stronger effect\n    \n    // Enhanced fractal noise based on time and space\n    float noise = 0.0;\n    float scale = 1.0;\n    for (int i = 0; i < 10; i++) {\n        noise += (0.5 - 0.5 * cos(dot(uv * scale, vec2(12.9898, 78.233)) + iTime)) / scale;\n        scale *= 1.8;\n    }\n\n    // More complex transformation for evolving visuals\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    float angle = cos(iTime * 0.5) * 0.3;\n    uv = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * uv;\n\n    // Intricate pattern of moving shapes with fractal noise\n    float dist = distance(uv, vec2(sin(iTime * 0.1), cos(iTime * 0.1)));\n    float pattern = sin(dist * 12.0 - iTime * 3.0) + cos(dist * 12.0 - iTime * 3.0);\n    pattern *= noise;\n\n    // Advanced color manipulation\n    col = (cos(0.5*angle)-(0.6*(2.-sin(col))))/(iTime * pattern);\n    // Output to screen with dynamic alpha based on pattern and noise\n    fragColor *=vec4(col,0.1/pattern - noise);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtKBzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 163, 213, 1406]], "test": "untested"}
{"id": "DlKfRW", "name": "britney dither basic", "author": "ninofiliu", "description": "dithering", "tags": ["dithering"], "likes": 3, "viewed": 176, "published": 3, "date": "1701886376", "time_retrieved": "2024-07-30T17:18:16.334136", "image_code": "const float size = 3.;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    float l = (color.r+color.g+color.b)/3.;\n    \n    float tx = mod(fragCoord.x*1.5, size);\n    float ty = mod(fragCoord.y*1.5, size);\n    float t = (tx/size+ty)/size;\n    \n    float bw = l < t ? 0. : 1.;\n    \n    fragColor = vec4(bw,bw,bw, 0.);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlKfRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 79, 79, 408]], "test": "untested"}
{"id": "DtKfRW", "name": "Sierpinski Carpet Animation", "author": "INCHMAN1900", "description": "Sierpinski carpet from https://zh.wikipedia.org/wiki/%E8%B0%A2%E5%B0%94%E5%AE%BE%E6%96%AF%E5%9F%BA%E5%9C%B0%E6%AF%AF", "tags": ["fractal", "sierpinski", "carpet"], "likes": 1, "viewed": 158, "published": 3, "date": "1701886324", "time_retrieved": "2024-07-30T17:18:17.368371", "image_code": "#define R iResolution.xy\n#define PI 3.1415926\n#define rev3 0.33333333\n#define W (3./R.y)\n\nfloat grids(vec2 uv,vec2 g1,vec2 g2) {\n    return step(g1.x,uv.x)*(1.-step(g2.x,uv.x))*step(g1.y,uv.y)*(1.-step(g2.y,uv.y));\n}\n\nvoid mainImage( out vec4 c, in vec2 uv )\n{\n    // not very smooth\n    float t=1.-pow(abs(fract(iTime*.2)-1.),.9);\n    uv*=(t*2.+1.)/R.y;\n    for (int i=0;i<7;i++) {\n        c+=grids(mod(uv,3.),vec2(1.,1.),vec2(2.,2.));\n        c+=grids(uv=fract(uv),vec2(rev3,rev3*2.),vec2(rev3,rev3*2.));\n        uv*=3.;\n    }\n    c=1.-c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtKfRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 128, 128, 216], [218, 218, 260, 283, 542]], "test": "untested"}
{"id": "clyfzD", "name": "Flowercomb", "author": "ahsan2649", "description": "Experimenting with getting a squiggly circle working resulted in this beautiful rotating petal pattern. Might not be for the trypophobic though.", "tags": ["flower", "circle", "wavy", "rotating"], "likes": 5, "viewed": 183, "published": 3, "date": "1701876701", "time_retrieved": "2024-07-30T17:18:18.133326", "image_code": "mat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n  \n    uv = rotate2d((iTime * 0.25)) * uv;\n    \n    float r = sqrt(uv.x*uv.x + uv.y*uv.y);\n    float th = atan(uv.y/uv.x);\n    \n    float f = cos(r*24. - iTime * .125) - sin(16. * th);\n    f = sin(f + iTime * 0.5);\n    f = abs(f);    \n    f += sin(f*5.);\n    f = smoothstep(0.5,0.999,f);\n    // Output to screen\n    fragColor = vec4(vec3(f),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clyfzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 118], [120, 120, 177, 227, 641]], "test": "untested"}
{"id": "dlcfDS", "name": "White Hallway", "author": "KingJ", "description": "A simple shadert that makes you feel like walking down an infinite hallway", "tags": ["hallway"], "likes": 4, "viewed": 157, "published": 3, "date": "1701874078", "time_retrieved": "2024-07-30T17:18:19.028931", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 orgUv = uv;\n    \n    // setup Uv\n    uv *= 20.;\n    uv = abs(uv);\n    \n    // central time variable\n    float time = iTime;\n    time *= 3.;\n    \n    //periodically blur uv\n    uv *= 1. + .02 * cos(iTime*5.);\n    \n    //actual distance to the center\n    float dCenter = max(uv.x, uv.y);\n    // warp distance\n    dCenter *= 1. + .2 * cos(iTime*3.);\n    \n    // repeating distance\n    float d = (1. + cos(dCenter - time))/0.5;\n\n    // black lines\n    vec3 col = vec3(smoothstep(0.1, 0.15, d));\n    // black lines grey\n    col = max(col, vec3(0.3, 0.3, 0.3));\n    \n    // center box\n    col = mix(col, vec3(1., 0., 0.4), smoothstep(2., 1.7, max(uv.x, uv.y)) - .015);\n    \n    // footsteps\n    /*vec2 stepUv = abs(orgUv * 20.);\n    stepUv = sin(stepUv - time);\n    vec2 stepPos = vec2(.7, -1.2);\n    float radius = .4;\n    col = mix(col, vec3(.2), smoothstep(.1, .0, length(stepUv-stepPos) -radius));*/\n    // TODO Unfinished. Might add in the future\n    \n    // shade\n    if (uv.x > uv.y) col *= pow(0.995, length(dCenter));\n    else if (orgUv.y < 0.) col *= pow(0.97, length(dCenter));\n    \n    // apply color\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlcfDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1321]], "test": "untested"}
{"id": "clyfRD", "name": "Purple Corridor", "author": "KingJ", "description": "Guess what it is", "tags": ["vortex"], "likes": 5, "viewed": 172, "published": 3, "date": "1701873936", "time_retrieved": "2024-07-30T17:18:19.879657", "image_code": "float height(in vec2 uv) {\n    return texture(iChannel0,uv).b*texture(iChannel1,uv+vec2(0.0,iTime*0.1)).b;\n}\n\nconst vec2 NE = vec2(0.05,0.0);\nvec3 normal(in vec2 uv) {\n    return normalize(vec3(height(uv+NE.xy)-height(uv-NE.xy),\n                          0.0,\n                          height(uv+NE.yx)-height(uv-NE.yx)));\n}\n\n\nconst vec4 waterColor = vec4(0.1,0.1,0.32,1.0);\nvec3 lightDir = normalize(vec3(10.0,15.0,5.0));\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy/iResolution.xy-vec2(.5);\n    uv.y *= iResolution.y/iResolution.x;\n    //uv *= 3.;\n    \n    float dist = length(uv);\n    float angle = atan(uv.y,uv.x);\n    \n    vec2 ruv = uv;\n    uv = vec2(cos(angle+dist*3.),dist+(iTime*0.2));\n\n    float h = height(uv);\n    vec3 norm = normal(uv);\n    \n    int lineAmount = 30;\n    float lineEndDist = .7;\n    float lineMaxWidth = .8;\n    float lineSmoothWidth = .2;\n    float curving = 8.;\n    float rotations = 1.;\n    \n    vec3 lines = vec3(smoothstep(lineMaxWidth, lineMaxWidth+lineSmoothWidth, .5*cos(angle * float(lineAmount) + iTime*rotations + curving/dist*1.1+2.)+.5 + dist/lineEndDist));\n    vec3 color = lines * smoothstep(.1, .3, dist) * smoothstep(.7, .0, dist) * .2 + vec3(.1, .01, .2);\n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clyfRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 108], [142, 142, 167, 167, 324], [425, 425, 482, 482, 1273]], "test": "untested"}
{"id": "ctyfRD", "name": "Visuals for VJ", "author": "mazureofficial", "description": "Basic code to build visuals from for VJ'ing etc", "tags": ["techno", "vj", "visuals", "deephouse"], "likes": 4, "viewed": 202, "published": 3, "date": "1701873515", "time_retrieved": "2024-07-30T17:18:20.820142", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = cos(4.9*fragCoord/iResolution.xy)*(0.1*cos(iResolution.xx-iTime));\n\n    // Time varying pixel color\n    vec3 col = 0.5 / 0.5/cos(iTime + uv.xyx + vec3(0,2,4));\n    // Fractal noise based on time and space\n    float noise = 0.0;\n    float scale = 1.0;\n    for (int i = 0; i < 8; i++) {\n        noise += (sin(dot(uv * scale, vec2(12.9898,78.233)) + iTime) * 0.5 + 0.5) / scale;\n        scale *= 2.0;\n    }\n\n    // Complex transformation for evolving visuals\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    float angle = sin(iTime) * 0.2;\n    uv = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * uv;\n\n    // Creating a pattern of moving circles with fractal noise\n    float dist = distance(uv, vec2(0.0, 0.0));\n    float pattern = sin(dist * 10.0 - iTime * 2.0) * cos(dist * 10.0 - iTime * 2.0);\n    pattern *= noise;\n\n    // Combining the color and the pattern\n    col = (0.5-(0.6*(2.-sin(col))))/(iTime * pattern);\n\n    // Output to screen\n    fragColor = vec4(col, pattern/noise/1.3*iTime);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctyfRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 108, 1147]], "test": "untested"}
{"id": "mtVfR1", "name": "Zebra pool", "author": "ahsan2649", "description": "A rippling lotion effect i stumbled upon while playing around with sine and cosine", "tags": ["blackandwhite", "ripple"], "likes": 3, "viewed": 163, "published": 3, "date": "1701864081", "time_retrieved": "2024-07-30T17:18:21.730708", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    \n    \n    \n    float d = sin(length(uv) * 12. - iTime);\n    d = abs(d);\n    d = sin(d + (cos(uv.x)) + (sin(uv.y) + iTime));\n    d = pow(d,2.);\n    d = 1.-d;\n    \n    \n    // Output to screen\n    fragColor = vec4(vec3(d), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtVfR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 406]], "test": "untested"}
{"id": "mlKfR1", "name": "Generated plasma", "author": "andreasjansson", "description": "https://replicate.com/andreasjansson/plasma", "tags": ["plasma", "generated"], "likes": 2, "viewed": 338, "published": 3, "date": "1701863917", "time_retrieved": "2024-07-30T17:18:22.530569", "image_code": "float resolution = 3.0;\nfloat speed = 0.1;\nint depth = 4;\n\nvec3 color1 = vec3(235.0/255.0, 231.0/255.0, 92.0/255.0);\nvec3 color2 = vec3(223.0/255.0, 72.0/255.0, 67.0/255.0);\nvec3 color3 = vec3(235.0/255.0, 64.0/255.0, 240.0/255.0);\n\n// Replace this with the generated effect() function\nvec2 effect(vec2 p, float i, float time) {\n  return vec2(cos(i * sin(p.x * p.y) + time), sin(length(p.y - p.x) * i + time));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (2.0 * gl_FragCoord.xy - iResolution.xy) / max(iResolution.x, iResolution.y);\n    p *= float(resolution);\n    for (int i = 1; i < depth; i++) {\n        float fi = float(i);\n        p += effect(p, fi, iTime * float(speed));\n    }\n    vec3 col = mix(mix(color1, color2, 1.0-sin(p.x)), color3, cos(p.y+p.x));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlKfR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[233, 286, 328, 328, 412], [414, 414, 469, 469, 822]], "test": "untested"}
{"id": "clKBzh", "name": "Burning Effect", "author": "INCHMAN1900", "description": "Based on https://www.youtube.com/watch?v=i0NcvJtTZG8&list=LL&index=1&ab_channel=CBaileyFilm. Still trying to implement emission...", "tags": ["vfx", "burning"], "likes": 6, "viewed": 227, "published": 3, "date": "1701863246", "time_retrieved": "2024-07-30T17:18:23.591732", "image_code": "#define R iResolution.xy\n#define PI 3.1415926\nfloat random(vec2 st) {\n    return fract(sin(dot(st,vec2(94.23,48.127))+14.23)*1124.23);\n}\n\nfloat noise(vec2 st) {\n    vec2 ip=floor(st);\n    vec2 fp=fract(st);\n    float a=random(ip);\n    float b=random(ip + vec2(1., 0.));\n    float c=random(ip + vec2(0., 1.));\n    float d=random(ip + vec2(1., 1.));\n    vec2 u=smoothstep(0.,1.,fp);\n    return mix(mix(a,b,u.x),mix(c,d,u.x),u.y);\n}\n\nfloat fractalNoise(vec2 uv) {\n    uv*=30.;\n    float amp=.6,n=0.;\n    for (int i=0;i<6;i++) {\n        n+=noise(uv)*amp;\n        uv*=2.;\n        amp*=.5;\n    }\n    return n;\n}\n\nfloat displace(vec2 uv) {\n    uv=mix(uv,vec2(fractalNoise(uv)),.08);\n    float d=-.1+mod(iTime*.1,1.5);\n    vec2 d1=vec2(.5,.5)+noise(uv*3.)-.5;\n    return smoothstep(d,d+.08,distance(uv,d1));\n}\n\nvec3 burn(vec3 col, vec2 uv) {\n    float a=displace(uv);\n    vec3 b=(1.-a)*vec3(1.,.14,.016)*a*100.;\n    return col*a+b;\n}\n\nvoid mainImage( out vec4 c, in vec2 u )\n{\n    vec2 uv=u/R;\n    c=vec4(burn(texture(iChannel1,uv).rgb,uv*vec2(R.x/R.y,1.)),1.);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clKBzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 69, 69, 136], [138, 138, 160, 160, 429], [431, 431, 460, 460, 605], [607, 607, 632, 632, 801], [803, 803, 833, 833, 925], [927, 927, 968, 968, 1055]], "test": "untested"}
{"id": "DtKfzh", "name": "Green and brown Persian rug", "author": "jarble", "description": "A fractal pattern that resembles a Persian rug.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 11, "viewed": 178, "published": 3, "date": "1701840715", "time_retrieved": "2024-07-30T17:18:24.571113", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nconst float scale = 1.5;\n\nvoid transform(inout vec2 uv, inout vec2 t2){\n    uv.y += 1./4.;\n\n    uv = (uv+t2)/scale;\n\n\n    t2 = triangle_wave(uv+.5);\n    uv =\n        (t2-triangle_wave(uv.yx))\n\n        //WOW!\n        //(t2-triangle_wave(uv.yx)+fract(t2/1.5))\n    ;\n\n    uv.y -= 1./4.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.,c1=0.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.xy += iTime/t1/12./2.;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    \n    vec2 t2 = vec2(0.);\n    vec3 col1 = col;\n    float warp_scale=16.;\n    for(int k = 0; k < 9; k++){\n        \n        vec2 warp =\n            vec2(0.)\n            //vec2(sin((t2.x)*warp_scale),cos((t2.y)*warp_scale))\n            //vec2(sin((uv.x)*warp_scale),cos((uv.y)*warp_scale))\n            //vec2(fract(uv/1.5)-.5)\n        ;\n        vec2 uv_1 = uv+warp,t2_1=t2+warp;\n        \n        transform(uv,t2);\n        transform(uv_1,t2_1);\n        \n        c1 =\n            max(abs(uv_1.y+uv_1.x*sign(t2_1.y-t2_1.x)),c1)\n        ;\n        c1 =\n            2.*abs(c1-1.)\n            \n            //even more colorful!\n            //2.-abs(2.*c1-2.)\n        ;\n        //uv = (fract(vec2(uv+vec2(.5,1.5))*2.)-.5)/2.;\n        col.x =\n            length(uv-t2-c1)/3.\n            \n            //purple rug\n            //2.-col.x\n\n            //more patterns!\n            //1.\n            //1.-length(uv-t2-c1)\n            //c1\n            //length(t2)\n            //1.-length(uv-t2-c1)/3.\n            //max(length(uv-t2-c1)/3.,col.x)\n            //max(max(length(uv-t2-c1),abs(uv.y-uv.x))/3.,col.x)\n        ;\n        //if(uv.x>-.25)\n        col =\n            abs(col-(1.-(c1*col.x)))/2.\n            //abs(col-(1.*sign(uv.y-uv.x)/2.-(c1*col.x)))/2.\n        ;\n        col1 =\n            abs(col1*c1-col-1.).yzx\n            //abs(col1*c1+col*sign(uv.y-uv.x)-1.).yzx\n        ;\n        \n    }\n    fragColor = vec4(col1/2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtKfzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 129], [157, 157, 202, 202, 416], [418, 418, 475, 475, 2121]], "test": "untested"}
{"id": "clKBRh", "name": "Blue and white Persian rug", "author": "jarble", "description": "A fractal pattern that resembles a Persian rug.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 14, "viewed": 212, "published": 3, "date": "1701832574", "time_retrieved": "2024-07-30T17:18:25.482676", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 16.,c1=0.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.xy += iTime/t1/12./2.;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    vec3 col1 = col;\n    for(int k = 0; k < 9; k++){\n    \n        uv.y -= 1./4.;\n        \n        uv = (uv+t2)/scale;\n        \n        uv = 1.+(fract(vec2(uv+vec2(.5,1.5))*scale)-.5)/scale;\n        \n        //WOW!\n        //uv += fract(t2/2.)/2.;\n        \n        //uv = (fract(vec2(uv+vec2(.5,1.5))*scale)-.5)/scale;\n        \n        t2 = triangle_wave(uv-.5);\n        uv =\n            (t2-triangle_wave(uv.yx))\n        ;\n        c1 =\n            max(abs(uv.y+uv.x*sign(t2.y-t2.x)),c1)\n        ;\n        c1 =\n            abs(2.*c1-1.)\n            //1.-col.x-c1\n            //col.x\n            //1.-abs(2.*c1-1.);\n        ;\n        col.x =\n            //c1\n            max(max(length(uv-t2-c1),abs(uv.y-uv.x))/3.,col.x)\n        ;\n            \n        col =\n            abs(col-(1.-(c1*col.x)));\n        col1 =\n            abs(col1*c1-col-1.).yzx;\n    }\n    fragColor = vec4(col1/2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clKBRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 129], [131, 131, 188, 188, 1349]], "test": "untested"}
{"id": "msKBRz", "name": "Year of Truchets #063 unreleased", "author": "byt3_m3chanic", "description": "Hope everyone has a happy holiday - thanks to everyone here, and everyone I've learned a little something from! ð\n", "tags": ["2d", "truchet"], "likes": 27, "viewed": 239, "published": 3, "date": "1701826343", "time_retrieved": "2024-07-30T17:18:26.292511", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #063\n    12/05/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    Just saying thanks - learned a lot from everyone over the year doing truchets\n    \n    see all https://www.shadertoy.com/user/byt3_m3chanic/sort=newest\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n// only the good parts\n// Fabrice Neyret https://www.shadertoy.com/view/llySRh\nint CAPS=0;\n#define spc  U.x-=.44;\n#define C(c) spc O+= char(U,64+c);\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n    p/=16.;\n\treturn textureGrad(iChannel0,p+fract(vec2(c,15-c/16)/16.),dFdx(p),dFdy(p));\n}\n\n// string text\nfloat scale = 5.;\nconst int txt[188]=int[188](\n52, 40, 33, 46, 43,-32, 57, 47, 53,-32, 52, 47,-32, 34, 44, 33, 35, 43, 44, 37, \n-20, 4, 33, 54, 37, 31,  8, 47, 51, 43, 41, 46, 51,-20, 36, 37, 33, 46, 31, 52, \n40, 37, 31, 35, 47, 36, 37, 50,-20,  9, 17,-20, 41, 25, 15, 25, 41,-20, 42, 52,\n-20,43, 33, 45, 47, 51, 40, 41, 43, 33,-20,  6, 33, 34, 50, 41, 35, 37, 14, 37, \n57, 50, 37, 52,-20, 48, 33, 46, 46, 33, 31, 48, 53, 36, 41,-20, 19, 40, 33, 46, \n37,-20, 51, 52, 34,-20, 51, 53, 43, 53, 48, 33, 48, 37, 50,-20, 52, 47, 52, 37, \n52, 45, 33, 52, 52,-20, 57, 33, 51, 53, 47,-20, 24, 47, 50,-32, 33, 46, 36,-32, \n51, 47,-32, 45, 33, 46, 57,-32, 45, 47, 50, 37,-31,-31,-32,-32,-32, 34, 57, 52,\n-13,-32,45,-13, 35, 40, 33, 46, 41, 35,-32,-32, 40, 33, 48, 48, 57,-32, 40, 47, \n44 ,41, 36, 33, 57, 51,-32,-32\n);\n\n\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(27.619,57.583)))*43758.5453);}\n\n// @Shane\n// An offset grid pattern with some random subdivision.\nvec4 distField(vec2 p, inout float sc){    \n    vec2 q = p;\n    vec2 ip = floor(p/sc);\n    p -= (ip + .5)*sc;\n\n    for(int i = 0; i<5; i++){\n        if(hash21(ip + float(i + 1)*.01)<.235){\n            sc /= 2.;\n            p = q;\n            ip = floor(p/sc);\n            p -= (ip + .5)*sc;\n        }\n    }\n    return vec4(p, ip);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 F ){\n\n    vec2 uv = (F.xy - R.xy*.5)/R.y;\n    vec2 vv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    float cale = .1591;\n    if(vv.y<.333 && vv.y>-.333) {\n\n        uv.x -= .25;\n        uv /= uv.x*uv.x + uv.y*uv.y;\n        uv.x += 2.;\n\n        uv *= rot(-T*.05);\n        uv = vec2(log(length(uv)), atan(uv.y, uv.x))*cale;\n        uv.x -= T*.025;\n    }else{\n        uv.y-=.15*sin(uv.x*3.+T*.5);\n        uv.x-= T*.05;\n    }\n    vec2 p = uv;\n    //\n    \n    float oSc = 1./4.;\n    float sc = oSc; \n    \n    vec4 d4 = distField(p, sc);\n    float px = fwidth(p.x)*.8;\n\n    vec2 dv = d4.xy;\n    vec2 id = d4.zw;   \n\n    float ch = mod(id.x+id.y,2.)*2.-1.;\n\n    vec3 col = vec3(.0);\n\n    float rnd = hash21(id);\n    float bnd = fract((rnd*147.32)+(T*.025));\n    \n    vec3 h  = .45 + .45*cos(4.5*(uv.y+(rnd*.5)) + vec3(0, 1, 2));\n    \n    if(rnd<.45) dv.x = -dv.x;\n    rnd = fract(rnd*247.32);\n    \n    float sx = .5*sc;\n    \n    vec2 gx = length(dv-sx)<length(dv+sx) ? vec2(dv-sx) : vec2(dv+sx);\n    float cx = length(gx)-sx;\n\n    if(rnd>.85 && bnd<.4) cx = min(length(dv.x),length(dv.y))-(.001*sc);\n\n    if (bnd<.25) { \n        cx = smoothstep(px,-px, abs(abs(abs(cx)-(.2*sc))-(.1*sc))-(.05*sc));\n    } else if (bnd>.4) {\n        cx = (ch>.5 ^^ rnd<.45) ? smoothstep(px,-px,cx):smoothstep(-px,px,cx);\n    } else {\n        cx = smoothstep(-px,px, abs(cx)-(.125*sc));\n    }\n\n    col = mix(h,col,cx);\n    px = fwidth(vv.x);\n    float bl = length(abs(vv.y)-.34)-.02;\n    col = mix(col,vec3(.0),smoothstep(px,-px,bl));\n    \n    // text overlay\n    vec4 O = vec4(0);\n    vv.x += T*.25;\n    vec2 dd = floor(vec2(vv.x,1)*scale);\n    vv.x = fract(vv.x*scale)-.5;\n    vv.y *= scale;\n    \n   \n\n    float ph = .25;\n\n    float ss = ph*sin(.2*dd.x*PI+T)+.25;\n    vv =(vv*.25)+vec2(.48,ss);\n    \n    float ds=(26.*R.x/R.y);\n    vv = floor(vv*ds)/ds;\n    vec2 U = vv;\n    px = 255./R.x;\n     \n    int mid = int(mod(floor(dd.x),187.));\n    U = (vv)/.5;\n    C(txt[mid]);\n\n    col = mix(col,vec3(1),smoothstep(px,px+.9,O.x));\n    \n    fragColor = vec4(pow(col, vec3(.4545)),1.);\n    }\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35442, "src": "https://soundcloud.com/alldayidream/shai-t-summer-oclock", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msKBRz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[617, 617, 643, 643, 802], [1629, 1629, 1647, 1647, 1691], [1692, 1692, 1713, 1713, 1771], [1773, 1839, 1878, 1878, 2171]], "test": "untested"}
{"id": "DlyfRh", "name": "Matrix Plot 3D", "author": "domrally", "description": "3D volumetric plot of 4D split quaternion (2D matrix) function.\nClick & Drag!\n[url=https://www.shadertoy.com/playlist/fXjyRd]GEOMETRY PLAYLIST[/url]", "tags": ["math", "volumetric", "4d", "orbit", "quaternion", "matrix", "hyperbolic", "split", "density"], "likes": 11, "viewed": 209, "published": 3, "date": "1701813074", "time_retrieved": "2024-07-30T17:18:27.133263", "image_code": "/*\nby Dom Mandy in 2023\n*/\nvoid mainImage(out vec4 p, vec2 v) {\n    // coordinates\n    vec2 i = iResolution.xy;\n    v += v - i;\n    vec3 E = 2. * vec3(v / i.y, -1),\n         R = normalize(vec3(0, -1, 3));\n\n    // camera\n    float m = 9., d, k,\n          t = mix(iTime / 9., -iMouse.x / 2e2, max(0., sign(iMouse.z))),\n          e = t + atan(E.z, E.x),\n          r = t + atan(R.z, R.x);\n    E.xz = length(E.xz) * vec2(cos(e), sin(e));\n    R.xz = length(R.xz) * vec2(cos(r), sin(r));\n\n    mat2 M, F,\n         // real\n         c = mat2(1),\n         // imaginary\n         b = mat2(0, 1,-1, 0),\n         // hyperbolic\n         a = mat2(0, 1, 1, 0);\n\n    // volumetric\n    vec3 X = E;\n    for (; k++ < 50.; X += R * .08) {\n        mat2 D = a + b + c,\n             C = F = X.x * a + X.y * b + X.z * c;\n        D = D * F + F * D;\n        F = F * F + C;\n        vec2 G = log(abs(F[0])),\n             H = log(abs(F[1]));\n\n        // density\n        d += 1. / (1. + k * smoothstep(.0, .2, abs(determinant(mat2(G, H) * F * inverse(D)))));\n\n        // orbit trap\n        if ((m = min(d, m)) == d) M = F;\n    }\n\n    // coloring\n    d = smoothstep(0., 25., d);\n    p.rgb = sqrt(d + .12 * d * vec3(8, 3, 9) * cos(atan(M[0].y - M[1].x, M[1].y + M[0].x) - vec3(0, 2, 4)));\n}\n\n\n/*\nSEE ALSO\n\nhttps://en.wikipedia.org/wiki/Split-quaternion\nhttps://en.wikipedia.org/wiki/Volume_rendering\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlyfRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 27, 63, 82, 1255]], "test": "untested"}
{"id": "DtyfRh", "name": "Sample Brownian Motion", "author": "iuhf", "description": "Fractional Brownian Motion Function\nstandalone, returns vec3\nX, Y: 2D normal calculated with -cosine\nZ: noise return value", "tags": ["fbm"], "likes": 1, "viewed": 163, "published": 3, "date": "1701803271", "time_retrieved": "2024-07-30T17:18:27.992965", "image_code": "vec3 fbm(in vec2 po, in float oct, in float f, in float a, in float p) {\n    float v = 0.;\n    vec2 n = po;\n    \n    for (float o = 0.; o < oct; o++) {\n        float r1 = fract(sin(o * 12.9898) * 43758.5453);\n        float r2 = fract(sin(o * 12.9898) * 43758.5453);\n        float r3 = fract(sin(o * 12.9898) * 43758.5453);\n        float r4 = fract(sin(o * 12.9898) * 43758.5453);\n        v += sin((po.x*f*(r1+39.) + cos(o * 3984.43)+r3)*sin(r2*2.+482.)*(o*r1/3.) + (po.y*2.*f*(r4*134.31) + (r1*452.+24.) + sin(o + 433.3))*cos(r2*555.5)*(o/20.*r4) + p*sin(o*r2*433.343 + r4*34859.));\n        n += vec2(-cos((po.x*f*(r1+39.) + cos(o * 3984.43)+r3)*sin(r2*2.+482.)*(o*r1/3.) + (po.y*2.*f*(r4*134.31) + (r1*452.+24.) + sin(o + 433.3))*cos(r2*555.5)*(o/20.*r4) + p*sin(o*r2*433.343 + r4*34859.)));\n    }\n    \n    return vec3(normalize(n), (v/oct)*a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv *= 2.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    fragColor = vec4(vec3(dot(fbm(uv, 10., .3, 1., iTime).xy, vec2(cos(iTime*0.5), sin(iTime*0.5)))), 1.);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtyfRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 72, 72, 847], [849, 849, 906, 956, 1195]], "test": "untested"}
{"id": "clyBzh", "name": "Disk MIS", "author": "BeardThings", "description": "Experimenting with using multiple importance sampling to improve convergence on a bright sun disk composited on top of an image.", "tags": ["sampling", "mis", "disk", "fibonacci", "radiance", "multiple", "importance"], "likes": 0, "viewed": 108, "published": 3, "date": "1701803155", "time_retrieved": "2024-07-30T17:18:28.864634", "image_code": "#define ROUGHNESS 0.1\n#define Pi 3.14159265359\n#define DISK_ANGLE 0.1\n#define DISK_DIR normalize(vec3(0.707, -1.0, 0.3))\n\n#define BRDF_N 64u\n#define DISK_N 16u\n\n// #define RANDOM_ROTATION\n// #define FIBONACCI\n\n// https://schuttejoe.github.io/post/arealightsampling/\nvec3 sphere_cap(float angle, float r1, float r2)\n{\n    float t = acos(1.0 - r1 + r1 * cos(angle));\n    float p = r2 * Pi * 2.0;\n    \n    return vec3(cos(p) * sin(t), sin(p) * sin(t), cos(t));\n}\n\nfloat sphere_cap_pdf(float angle, vec3 v, vec3 l)\n{\n    float a = acos(dot(v, l));\n    return a <= angle ? 1.0 / (2.0 * Pi * (1.0 - cos(angle))) : 0.0;\n}\n\nvec3 srgb_to_linear(vec3 srgb)\n{\n    return pow(srgb, vec3(2.2));\n}\n\nfloat rcp(float v)\n{\n    return 1.0 / v;\n}\n\nfloat ggx_d(float roughnessSq, float hdotn)\n{\n\t// https://jcgt.org/published/0003/02/03/paper.pdf\n\tfloat hdotnSq = hdotn * hdotn;\n\tfloat t = (hdotnSq * (roughnessSq - 1.0f) + 1.0f);\n\treturn roughnessSq * rcp(t * t) / Pi;\n}\n\nfloat ggx_lambda(float roughnessSq, float cosTheta)\n{\n\treturn 0.5f * (sqrt(roughnessSq * (rcp(cosTheta * cosTheta) - 1.0f) + 1.0f) - 1.0f);\n}\n\nvec3 spherical_cap_VNDF_sampling(vec3 v, float r1, float r2)\n{\n\t// sample a spherical cap in (-v.z, 1]\n\tfloat phi = 2.0f * Pi * r1;\n\tfloat z = (1.0f - r2) * (1.0f + v.z) - v.z;\n\tfloat sinTheta = sqrt(min(max(1.0f - z * z, 0.0f), 1.0f));\n\tfloat x = sinTheta * cos(phi);\n\tfloat y = sinTheta * sin(phi);\n\tvec3 c = vec3(x, y, z);\n\t// compute halfway direction;\n\tvec3 h = c+v;\n\t// return without normalization (as this is done later)\n\treturn h;\n}\n\nvec3 hemisphere_surface_random_ggx_h(vec3 view, float r1, float r2, float roughness)\n{\n\t// Sampling routine from https://hal.science/hal-01509746/document\n\t// https://jcgt.org/published/0007/04/01/paper.pdf\n\t// Improvement: https://arxiv.org/pdf/2306.05044.pdf\n\n\t// stretch view\n\tvec3 V = normalize(vec3(roughness * view.x, roughness * view.y, view.z));\n\n\tvec3 N = spherical_cap_VNDF_sampling(V, r1, r2);\n\t// unstretch\n\tN = normalize(vec3(roughness*N.x, roughness*N.y, max(0.0f, N.z)));\n\treturn N;\n}\n\nfloat microfacet_g(float lambda)\n{\n\treturn rcp(1.0f + lambda);\n}\n\nfloat ggx_pdf(float roughness, float hdotn, float vdotn)\n{\n\t// https://jcgt.org/published/0007/04/01/paper.pdf\n\tfloat roughnessSq = roughness*roughness;\n\t// Base formulation is:\n\t// VNDF (Visible normal distribution function)\n\t// Dv = D*G1*v.h/v.n\n\t// PDF = Dv/(4*v.h)\n\t// Simplifying:\n\t// PDF = D*G1*v.h/(4*v.n*v.h)\n\t// PDF = D*G1/(4*v.n)\n\treturn ggx_d(roughnessSq, hdotn) * microfacet_g(ggx_lambda(roughnessSq, vdotn)) / (4.0f * vdotn);\n}\n\nvec3 ggx(float roughness, float hdotn, float vdotn, float ldotn, vec3 fresnel)\n{\n\tvec3 F = fresnel;\n\n\t// Generalized form:\n\t/*float roughnessSq = roughness*roughness;\n\tfloat D = ggxD(roughnessSq, hdotn) * (hdotn > 0.0f ? 1.0f : 0.0f);\n\tfloat maskingLambda = ggxLambda(roughnessSq, vdotn);\n\tfloat shadowingLambda = ggxLambda(roughnessSq, ldotn);\n\tfloat G = maskingShadowingCorrelatedG(maskingLambda, shadowingLambda);\n\treturn F * (G * D / (4.0f * vdotn * ldotn));*/\n\n\t// Shadowing Masking Simplified Form:\n\tfloat roughnessSq = roughness*roughness;\n\tfloat D = ggx_d(roughnessSq, hdotn) * (hdotn > 0.0f ? 1.0f : 0.0f);\n\n\t// Algebraically merged shadowingLambda and maskingLambda\n\tfloat t0 = vdotn * sqrt((1.0f - roughnessSq) * ldotn * ldotn + roughnessSq);\n\tfloat t1 = ldotn * sqrt((1.0f - roughnessSq) * vdotn * vdotn + roughnessSq);\n\tfloat simplifiedG = rcp(t0 + t1);\n\treturn F * (simplifiedG * D * 0.5f);\n}\n\n// Orthonormal basis from Naive https://backend.orbit.dtu.dk/ws/portalfiles/portal/126824972/onb_frisvad_jgt2012_v2.pdf\nmat3x3 basis_from_normal(vec3 n)\n{\n    vec3 i, j;\n    // If n is near the x - axis , use the y - axis . Otherwise use the x - axis .\n    if (n.x > 0.9 ) i = vec3(0.0, 1.0, 0.0 );\n    else i = vec3(1.0, 0.0, 0.0 );\n    i -= n * dot(i, n); // Make b1 orthogonal to n\n    i *= 1.0/sqrt(dot(i, i)); // Normalize b1\n    j = cross(n, i); // Construct b2 using a cross product\n\treturn mat3x3(i, j, n);\n}\n\n// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\nfloat radicalInverse_VdC(uint bits) {\n     bits = (bits << 16u) | (bits >> 16u);\n     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n     return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n }\n\nvec2 hammersley2d(uint i, uint N) {\n    return vec2(float(i)/float(N), radicalInverse_VdC(i));\n}\n\nconst float golden = (1.0 + sqrt(5.0))/2.0;\nvec2 fibonacci_2d(float i, float N)\n{\n    return vec2(fract(i/golden),i/N);\n}\n\nvec2 stratify(uint i, uint N)\n{\n#ifdef FIBONACCI\n    return fibonacci_2d(float(i), float(N));\n#else\n    return hammersley2d(i, N);\n#endif // FIBONACCI\n}\n\nvec3 disk(vec3 d)\n{\n    vec3 v = DISK_DIR;\n    return acos(dot(d, v)) < DISK_ANGLE ? vec3(1.0, 1.0, 1.0) * 10.0 : vec3(0.0, 0.0, 0.0);\n}\n\nvec3 scene(vec3 d)\n{\n    return texture(iChannel0, d).rgb + disk(d);\n}\n\n// https://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader\nfloat random( vec2 p )\n{\n    vec2 K1 = vec2(\n        23.14069263277926, // e^pi (Gelfond's constant)\n         2.665144142690225 // 2^sqrt(2) (GelfondÃ¢â¬âSchneider constant)\n    );\n    return fract( cos( dot(p,K1) ) * 12345.6789 );\n}\n\nvec3 lighting(vec3 n, vec3 v, vec3 l, float weight)\n{\n    vec3 r = vec3(0.0, 0.0, 0.0);\n\n    vec3 h = normalize(l + v);\n    float NoL = dot(n, l);\n    float HoN = dot(h, n);\n    float VoN = dot(h, v);\n    if(NoL > 0.0)\n    {\n        vec3 brdf = ggx(ROUGHNESS, HoN, VoN, NoL, vec3(1.0, 1.0, 1.0));\n        r = scene(l) * brdf * NoL * weight;\n    }\n    \n    return r;\n}\n\nvec3 radiance(vec3 n, float pr)\n{\n    vec3 v = n;\n    mat3x3 b = basis_from_normal(n);\n    \n    vec3 acc = vec3(0.0, 0.0, 0.0);\n    \n#ifdef RANDOM_ROTATION\n    vec3 t = vec3(cos(pr), -sin(pr), 0.0);\n    vec3 bit = vec3(sin(pr), cos(pr), 0.0);\n    mat3x3 rot = mat3x3(t, bit, vec3(0.0, 0.0, 1.0));\n#else\n    mat3x3 rot = mat3x3(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0));\n#endif // RANDOM_ROTATION\n    \n    uint brdfN = BRDF_N;\n    uint diskN = DISK_N;\n    uint totalN = brdfN + diskN;\n    \n    for(uint i = 0u; i < brdfN; i++)\n    {\n        vec2 r = stratify(i, brdfN);\n        \n        vec3 h = b*rot*hemisphere_surface_random_ggx_h(v*b, r.x, r.y, ROUGHNESS);\n        vec3 l = reflect(-v,h);\n        float pdf = ggx_pdf(ROUGHNESS, dot(h, n), dot(v, h));\n        float diskPDF = sphere_cap_pdf(DISK_ANGLE, l, DISK_DIR);\n        \n        float weight = 1.0 / (float(brdfN) * pdf + float(diskN) * diskPDF);\n\n        acc += lighting(n, v, l, weight);\n    }\n    \n    \n    for(uint i = 0u; i < diskN; i++)\n    {\n        vec2 r = stratify(i, diskN);\n    \n        mat3x3 b = basis_from_normal(DISK_DIR);\n        vec3 l = b * sphere_cap(DISK_ANGLE, r.x, r.y);\n        vec3 h = normalize(l + v);\n        \n        float pdf = sphere_cap_pdf(DISK_ANGLE, l, DISK_DIR);\n        float ggxPDF = ggx_pdf(ROUGHNESS, dot(h, n), dot(v, h));\n        \n        float weight = 1.0 / (float(brdfN) * ggxPDF + float(diskN) * pdf);\n\n        acc += lighting(n, v, l, weight);\n    }\n    \n    return acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    float aspect = iResolution.y / iResolution.x;\n    vec3 v=vec3(0.,1.,0.)+vec3(uv.x,0.,0.)+vec3(0.,0.,uv.y*aspect);\n    vec3 o=vec3(0.,-1.5,0.);\n    float r=0.5;\n\n    float a=dot(v,v);\n    float b=2.*dot(v,o);\n    float c=dot(o,o)-r*r;\n    float d=b*b-4.*a*c;\n    \n    fragColor.rgb = disk(normalize(v));\n    if(d>=0.)\n    {\n        float t=(-b-sqrt(d))/(2.*a);\n        vec3 n=normalize(o+v*t);\n        \n#ifdef RANDOM_ROTATION\n        vec2 s = vec2(acos(n.z), atan(n.y, n.x));\n        float rand = random(s) * 2.0 * Pi;\n#else\n        float rand = 0.0;\n#endif // RANDOM_ROTATION\n\n        \n        fragColor.rgb=radiance(n, rand);\n    }  \n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clyBzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 266, 316, 316, 459], [461, 461, 512, 512, 614], [616, 616, 648, 648, 683], [685, 685, 705, 705, 727], [729, 729, 774, 826, 951], [953, 953, 1006, 1006, 1094], [1096, 1096, 1158, 1198, 1537], [1539, 1539, 1625, 1817, 2038], [2040, 2040, 2074, 2074, 2104], [2106, 2106, 2164, 2216, 2546], [2548, 2548, 2628, 2628, 3454], [3456, 3576, 3610, 3610, 3972], [3974, 4044, 4081, 4081, 4486], [4488, 4488, 4523, 4523, 4584], [4630, 4630, 4667, 4667, 4707], [4709, 4709, 4740, 4740, 4861], [4863, 4863, 4882, 4882, 4999], [5001, 5001, 5021, 5021, 5071], [5073, 5173, 5197, 5197, 5409], [5411, 5411, 5464, 5464, 5778], [7279, 7279, 7336, 7336, 8023]], "test": "untested"}
{"id": "mttfRH", "name": "Matrix Fractal II", "author": "domrally", "description": "Attempt at a 3D volumetric density plot of 4D split quaternion (2D matrix) fractal. Tensor fractal?\nClick & Drag!\n[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]\n[url=https://www.shadertoy.com/playlist/fXjyRd]GEOMETRY PLAYLIST[/url]", "tags": ["fractal", "math", "4d", "orbit", "quaternion", "matrix", "hyperbolic", "split", "chaotic"], "likes": 11, "viewed": 249, "published": 3, "date": "1701794218", "time_retrieved": "2024-07-30T17:18:29.637567", "image_code": "/*\nby Dom Mandy in 2023\n*/\n\n\n/*\npastel colors\nhttps://www.shadertoy.com/view/mltyRN\n*/\nvec3 palette(float l, float h) { return l + 1.4 * l * vec3(.7874, .2848, .9278) * cos(h - vec3(0, 2.1, 4.2)); }\n\n\nvoid mainImage(out vec4 pixel, vec2 v) {\n    vec2 i = iResolution.xy;\n    v = (v + v - i) / i.y;\n\n    float t = mix(iTime / 9., -iMouse.x / 180., max(0., sign(iMouse.z)));\n    vec3 ray = normalize(vec3(0, -1, 2)),\n         eye = 1.6 * vec3(v, -1);\n\n    float a = t + atan(eye.z, eye.x),\n          b = t + atan(ray.z, ray.x);\n    eye.xz = length(eye.xz) * vec2(cos(a), sin(a));\n    ray.xz = length(ray.xz) * vec2(cos(b), sin(b));\n    \n    vec3 point = eye;\n    t = 1.6 * .02;\n    float density, k, m = 9.;\n    mat2 M;\n    for (; k++ < 100.; ) {\n        const mat2[4] basis = mat2[](\n            mat2(1),\n            mat2(0, 1, -1, 0),\n            mat2(0, 1, 1, 0),\n            mat2(1, 0, 0, -1)\n        );\n\n        float i, f, d;\n        mat2 F, D = basis[0] + basis[1] + basis[2] + basis[3], C = F = point.y * basis[0] + point.x * basis[2] + point.z * basis[3];\n        C += .5 * cos(iTime / 2.) * basis[1];\n        for (; i++ < 3.;) {\n            D = D * F + F * D;\n            F = F * F + C;\n            if ((f = abs(determinant(F))) > 2.) break;\n            if ((m = min(m, f)) == f) M = F;\n        }\n        vec2 G = log(abs(F[0])),\n             H = log(abs(F[1]));\n\n        point += ray * t;\n        density += 1. / (1. + 999. * smoothstep(0., 2., abs(determinant(mat2(G, H) * F / D))));\n    }\n    float hue = atan(M[0].y, M[0].x);\n\n    pixel.rgb = pow(palette(smoothstep(0., 99., density), hue), vec3(1) / 2.2);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mttfRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 87, 119, 119, 198]], "test": "untested"}
{"id": "mlVBzR", "name": "Bayer CFA and Debayering", "author": "Zi7ar21", "description": "Bayer CFA", "tags": ["filter", "color", "array"], "likes": 1, "viewed": 186, "published": 3, "date": "1701794004", "time_retrieved": "2024-07-30T17:18:30.911163", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    const float zoom = 0.125;\n\n    fragCoord = zoom*((fragCoord-0.5*iResolution.xy)/(0.5*iResolution.xy))+vec2(0.5,0.5);\n    fragColor = vec4(texture(iChannel0,fragCoord).rgb, 1.0); // original\n    //fragColor = vec4(texture(iChannel1,fragCoord).rgb, 1.0); // cfa color\n    fragColor = vec4(texture(iChannel2,fragCoord).rgb, 1.0); // debayered\n    //fragColor = vec4(texture(iChannel3,fragCoord).rgb, 1.0); // blurred\n    fragColor = vec4(abs(fragColor.rgb),1.0); // change debayer to subtract for difference view\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_a_code": "#define num_samples 13\n\n// HRAA\nconst vec2 sample_offset[13] = vec2[](\n    vec2(-1.000, 1.000),\n    vec2( 0.000, 1.000),\n    vec2( 1.000, 1.000),\n\n    vec2(-0.500, 0.500),\n    vec2( 0.500, 0.500),\n\n    vec2(-1.000, 0.000),\n    vec2( 0.000, 0.000),\n    vec2( 1.000, 0.000),\n\n    vec2(-0.500,-0.500),\n    vec2( 0.500,-0.500),\n\n    vec2(-1.000,-1.000),\n    vec2( 0.000,-1.000),\n    vec2( 1.000,-1.000)\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0);\n\n    fragCoord += vec2(cos(3.0*iTime),sin(3.0*iTime));\n\n    for(int i = 0; i < num_samples; i++) {\n    //for(int i = 0; i < 1; i++) {\n        vec2 dithCoord = fragCoord+0.5*sample_offset[i];\n        //vec2 dithCoord = fragCoord+2.0*(texelFetch(iChannel1,ivec2(i+1,iFrame%256),0).xy-0.5);\n\n        vec2 uv = (dithCoord-0.5*iResolution.xy)/(0.5*16.0);\n\n        float th = 0.03*cos(3.1*iTime);\n\n        //uv *= 0.5;\n\n        uv *= mat2(cos(th),-sin(th), sin(th), cos(th));\n\n        float a = dot(uv,uv) <= 1.0 ? 1.0 : 0.0;\n\n        fragColor += vec4(mix(texture(iChannel0,8.0*0.001953125*uv+0.5).rgb,vec3(1),a),1.0);\n        \n        fragColor += vec4(mix(texture(iChannel1,2.0*0.001953125*uv+0.5).rgb,vec3(1),a),1.0);\n    }\n\n    fragColor = vec4(fragColor.a != 0.0 ? fragColor.rgb/fragColor.a : fragColor.rgb, 1.0);\n\n    //fragColor.rgb = log(fragColor.rgb+1.0);\n\n    fragColor.rgb = clamp(fragColor.rgb, 0.0, 1.0);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    /*\n\n    CFA Pattern:\n    +---+---+\n    | 0 | 1 |\n    +---+---+\n    | 2 | 3 |\n    +---+---+\n\n    */\n\n    int cfa = (int(fragCoord.x)%2)+(2*(((int(iResolution.y)-1)-int(fragCoord.y))%2));\n\n    fragColor.rgb *= 1.0-0.0*texture(iChannel1,(fragCoord+1024.0*texture(iChannel2,vec2(iFrame%256,iFrame/256)/256.0).xy)/1024.0).rgb;\n\n    if(cfa == 0) fragColor.rgb *= vec3(1.0, 0.0, 0.0);\n    if(cfa == 1) fragColor.rgb *= vec3(0.0, 1.0, 0.0);\n    if(cfa == 2) fragColor.rgb *= vec3(0.0, 1.0, 0.0);\n    if(cfa == 3) fragColor.rgb *= vec3(0.0, 0.0, 1.0);\n}", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // standard linear method\n    // sharpest but also subject to false color and zippering\n    fragColor = vec4(\n    0.250*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2(-1, 1)).r+\n    0.500*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 0, 1)).r+\n    0.250*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 1, 1)).r+\n    0.500*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2(-1, 0)).r+\n    1.000*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 0, 0)).r+\n    0.500*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 1, 0)).r+\n    0.250*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2(-1,-1)).r+\n    0.500*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 0,-1)).r+\n    0.250*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 1,-1)).r,\n\n    0.250*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 0, 1)).g+\n    0.250*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2(-1, 0)).g+\n    1.000*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 0, 0)).g+\n    0.250*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 1, 0)).g+\n    0.250*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 0,-1)).g,\n\n    0.250*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2(-1, 1)).b+\n    0.500*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 0, 1)).b+\n    0.250*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 1, 1)).b+\n    0.500*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2(-1, 0)).b+\n    1.000*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 0, 0)).b+\n    0.500*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 1, 0)).b+\n    0.250*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2(-1,-1)).b+\n    0.500*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 0,-1)).b+\n    0.250*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 1,-1)).b,\n\n    1.0);\n\n    //fragColor.rgb = fragColor.rrr;\n    //fragColor.rgb = fragColor.ggg;\n    //fragColor.rgb = fragColor.bbb;\n\n    // mipmap method\n    //fragColor.rgb = vec3(4.0,2.0,4.0)*texelFetch(iChannel0,ivec2(fragCoord)/2,1).rgb;\n    //fragColor.rgb = mix(fragColor.rgb,vec3(4.0,2.0,4.0)*textureLod(iChannel0,fragCoord/iResolution.xy,1.0).rgb,0.5);\n\n    // alternate linear method (smooths green)\n    vec3 color = vec3(\n    0.5*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2(-1, 1))+\n    texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 0, 1))+\n    0.5*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 1, 1))+\n    texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2(-1, 0))+\n    2.0*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 0, 0))+\n    texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 1, 0))+\n    0.5*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2(-1,-1))+\n    texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 0,-1))+\n    0.5*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 1,-1)));\n\n    // blend alternate method\n    //fragColor.rgb = mix(fragColor.rgb, vec3(0.5, 0.25, 0.5)*color, 0.5);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(\n    1.000*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 0, 1)).rgb+\n    1.000*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2(-1, 0)).rgb+\n    8.000*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 0, 0)).rgb+\n    1.000*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 1, 0)).rgb+\n    1.000*texelFetchOffset(iChannel0,ivec2(fragCoord),0,ivec2( 0,-1)).rgb,\n    1.0);\n\n    fragColor.rgb /= 12.0;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlVBzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 571]], "test": "untested"}
{"id": "mlcBWl", "name": "Height Switch", "author": "gehtsiegarnixan", "description": "This shader showcases a method to alternate between samples using a height and weight value. ", "tags": ["mix", "contrast", "barycentric", "lerp", "blend", "linear", "height", "interpolation", "bilinear", "heightblend"], "likes": 3, "viewed": 349, "published": 3, "date": "1701765041", "time_retrieved": "2024-07-30T17:18:31.995263", "image_code": "// The MIT License\n// Copyright Â© 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis shader demonstrates a cost-effective height blend method. It alternates \nbetween samples based on the combination of weights and heights. It requires \nonly one sample, but it would be desirable to have a smooth variant of this, \neven if it requires more samples.\n\nHeight interpolation is a common technique in computer graphics used to blend\nsamples (typically texture colors) based on their height information. Heightmaps\nassociated with each sample introduce a bias to the blending weight, resulting\nin a more natural transition between textures. Regardless of height at 100% \nweight, a sample is fully visible, and at 0% weight, it's entirely hidden.\n\nThe three columns from left to right demonstrate linear (2 value), barycentric \n(3 value), and bilinear (4 value) interpolation. This shader allows mouse control \nfor you to enlarge one of the columns by moving the X-axis to the column center. \nGlobal constants below further enhance control and alternate views.\n\nFor background reading, consider reading my source at:\nhttps://playerunknownproductions.net/news/stochastic-texturing\n\nOr see my biom texture shuffle for a shader where this could be used:\nhttps://www.shadertoy.com/view/dsVyRw\n*/\n\n// Switch values around to show different things\n// 0 = Interpolated unique Textures\n// 1 = Interpolated identical Textures\n// 2 = Weight/Alpha values\n#define SHOWVALUES 2\n\n// Uncomment and set height values; heights should be in the range of 0-1\n// Linear interpolation is XY, barycentric is XYZ, and bilinear is XYZW\n//#define HEIGHT vec4(1.0, 1.0, 1.0, 1.0)\n\n// Make switch when one weight with bias from heights is larger than the other\nbool heightSwitch(float weight, vec2 heights) {\n    \n    // Split the weight into two components\n    vec2 weights = vec2(1.0 - weight, weight);\n\n    // add bounds to height so nothing odd happens at 0. or 1.\n    heights = clamp(heights, 0.01, 0.99);\n    \n    // scale heights with their weight\n    heights = heights * weights;\n    \n    // return when to switch\n    return heights.x > heights.y;\n}\n\n// switch between 2 samples using height bias\n// https://www.desmos.com/calculator/3yoqgulaww\nvec3 heightSwitch(vec2 gridUV, vec2 detailUV) {\n\n    // Choose between using constant height values or sampling heightmaps\n    #ifdef HEIGHT\n        // Use constant height values\n        vec2 height = HEIGHT.xy;\n        \n    #else\n        #if SHOWVALUES == 1\n            // Sample the same offset heightmap\n            float heightA = texture(iChannel1, detailUV).x;\n            float heightB = texture(iChannel1, vec2(-detailUV.y, detailUV.x)).x;\n        \n        #else        \n            // Sample unique heightmaps\n            float heightA = texture(iChannel0, detailUV).x;\n            float heightB = texture(iChannel1, detailUV).x;\n        #endif\n        \n        // Combine heights\n        vec2 heights = vec2(heightA, heightB);\n    #endif\n    \n    // Calculate zigzag linear weight\n    float weight = abs(fract(gridUV.y * 0.5) * 2.0 - 1.0);\n    \n    // Find out when to do height switch\n    bool heightSwitcher = heightSwitch(weight, heights);\n    \n    #if SHOWVALUES == 0\n        // For Mip caculation\n        vec2 duvdx = dFdx( detailUV );\n        vec2 duvdy = dFdy( detailUV );\n        \n        // Alternate the textures\n        return heightSwitcher ? textureGrad(iChannel0, detailUV, duvdx, duvdy).xyz : \n                                bone(textureGrad(iChannel1, detailUV, duvdx, duvdy).x);\n                                       \n    #elif SHOWVALUES == 1\n        /*\n        // Normally do this but here the height and textures are the same here\n        // Mip caculation\n        vec2 duvdx = dFdx( detailUV );\n        vec2 duvdy = dFdy( detailUV );\n    \n        // Alternate the UVs\n        vec2 uv = alternate ? detailUV : vec2(-detailUV.y, detailUV.x);\n        \n        // Sample texture\n        return bone( textureGrad(iChannel1, uv, duvdx, duvdy).x );\n        */\n        \n        // Aternate the results based on heightSwitcher\n        return bone( heightSwitcher ? heights.x : heights.y );\n        \n    #else\n        // Alternate the colors\n        return heightSwitcher ? vec3(1,0,0) : vec3(0,0,0);\n    #endif\n}\n\n// Make switch when one weight with bias from heights is larger than the other\nbvec2 heightSwitch(vec3 weights, vec3 heights) {\n\n    // add bounds to height so nothing odd happens at 0. or 1.\n    heights = clamp(heights, 0.01, 0.99);\n    \n    // scale heights with their weight\n    heights = heights * weights;\n    \n    // return when to switch\n    return bvec2(heights.x > max(heights.y, heights.z), heights.y > heights.z);\n}\n\n// switch between 3 samples using height bias\nvec3 baryHeightSwitch(vec2 gridUV, vec2 detailUV) {\n\n    // Choose between using constant height values or sampling heightmaps\n    #ifdef HEIGHT\n        // Use constant height values\n        vec3 height = HEIGHT.xyz;\n        \n    #else\n        #if SHOWVALUES == 1\n            // Sample the same offset heightmap\n            float heightA = texture(iChannel1, detailUV).x;\n            float heightB = texture(iChannel1, vec2(-detailUV.y, -detailUV.x)).x;\n            float heightC = texture(iChannel1, vec2(-detailUV.y, detailUV.x)).x;\n        \n        #else        \n            // Sample unique heightmaps\n            float heightA = texture(iChannel0, detailUV).x;\n            float heightB = texture(iChannel1, detailUV).x;\n            float heightC = texture(iChannel2, detailUV).y;\n        #endif\n        \n        // Combine heights\n        vec3 heights = vec3(heightA, heightB, heightC);\n    #endif\n    \n    // Calculate barycentric weights for a square pattern\n    vec3 weights = baryWeights(gridUV);\n    \n    // Find out when to do height switch\n    bvec2 heightSwitcher = heightSwitch(weights, heights);\n\n    #if SHOWVALUES == 0\n        // Mip caculation\n        vec2 duvdx = dFdx( detailUV );\n        vec2 duvdy = dFdy( detailUV );\n    \n        // Height switch to alternate texture sample\n        return heightSwitcher.x ? textureGrad(iChannel0, detailUV, duvdx, duvdy).xyz : \n               heightSwitcher.y ? bone(textureGrad(iChannel1, detailUV, duvdx, duvdy).x) : \n                                  textureGrad(iChannel2, detailUV, duvdx, duvdy).xyz;\n\n    #elif SHOWVALUES == 1\n        /* \n        // Normally do this but here the height and textures are the same here\n        // Mip caculation\n        vec2 duvdx = dFdx( detailUV );\n        vec2 duvdy = dFdy( detailUV );\n    \n        // Height switch rotated texture sample\n        vec2 uv = heightSwitcher.x ? detailUV : \n                  heightSwitcher.y ? vec2(-detailUV.y, -detailUV.x) : \n                                     vec2(-detailUV.y, detailUV.x);\n        \n        // Sample texture\n        return bone( textureGrad(iChannel1, uv, duvdx, duvdy).x );\n        */\n        \n        // Aternate the results based on heightSwitcher\n        return bone( heightSwitcher.x ? heights.x : \n                     heightSwitcher.y ? heights.y : \n                                        heights.z );\n        \n    #else\n        // Debug view of the height switch\n        return heightSwitcher.x ? vec3(1., 0., 0.) : \n               heightSwitcher.y ? vec3(0., 1., 0.) : \n                                  vec3(0., 0., 1.);\n    #endif  \n}\n\n// Make switch when one weight with bias from heights is larger than the other\nbvec3 heightSwitch(vec4 weights, vec4 heights) {\n\n    // add bounds to height so nothing odd happens at 0. or 1.\n    heights = clamp(heights, 0.01, 0.99);\n    \n    // scale heights with their weight\n    heights = heights * weights;\n    \n    // Partial result to reuse\n    float maxHeightCD = max(heights.z, heights.w);\n    \n    // return when to switch\n    return bvec3(heights.x > max(maxHeightCD, heights.y), \n                 heights.y > maxHeightCD,\n                 heights.z > heights.w);\n}\n\n// switch between 4 samples using height bias\nvec3 bilinearHeightSwitch(vec2 gridUV, vec2 detailUV) {   \n    \n    // Choose between using constant height values or sampling heightmaps\n    #ifdef HEIGHT\n        // Use constant height values\n        vec4 height = HEIGHT;\n        \n    #else    \n        #if SHOWVALUES == 1\n            // Sample the same offset heightmap\n            float heightA = texture(iChannel1, detailUV).x;\n            float heightB = texture(iChannel1, vec2(-detailUV.y, -detailUV.x)).x;\n            float heightC = texture(iChannel1, vec2(-detailUV.y, detailUV.x)).x;\n            float heightD = texture(iChannel1, vec2(detailUV.x, -detailUV.y)).x;\n        \n        #else        \n            // Sample unique heightmaps\n            float heightA = texture(iChannel0, detailUV).x;\n            float heightB = texture(iChannel1, detailUV).x;\n            float heightC = texture(iChannel2, detailUV).y;\n            float heightD = texture(iChannel3, detailUV).x;\n        #endif\n        \n        // Combine heights\n        vec4 heights = vec4(heightA, heightB, heightC, heightD);\n    #endif\n    \n    // Calculate vanilla bilinear weights\n    vec4 weights = bilinearWeights(gridUV);\n        \n    // Find out when to do height switch\n    bvec3 heightSwitcher = heightSwitch(weights, heights);\n        \n    #if SHOWVALUES == 0\n        // Mip caculation\n        vec2 duvdx = dFdx( detailUV );\n        vec2 duvdy = dFdy( detailUV );\n    \n        // Height switch to alternate texture sample\n        return heightSwitcher.x ? textureGrad(iChannel0, detailUV, duvdx, duvdy).xyz : \n               heightSwitcher.y ? bone(textureGrad(iChannel1, detailUV, duvdx, duvdy).x) : \n               heightSwitcher.z ? textureGrad(iChannel2, detailUV, duvdx, duvdy).xyz : \n                                  textureGrad(iChannel3, detailUV, duvdx, duvdy).xyz;\n               \n    #elif SHOWVALUES == 1\n        /* \n        // Normally do this but here the height and textures are the same here\n        // Mip caculation\n        vec2 duvdx = dFdx( detailUV );\n        vec2 duvdy = dFdy( detailUV );\n    \n        // Height switch to rotated texture sample\n        vec2 uv = heightSwitcher.x ? detailUV : \n                  heightSwitcher.y ? vec2(-detailUV.y, -detailUV.x) : \n                  heightSwitcher.z ? vec2(-detailUV.y, detailUV.x) : \n                                     vec2(detailUV.x, -detailUV.y);\n        \n        // Sample texture\n        return bone( textureGrad(iChannel1, uv, duvdx, duvdy).x );\n        */\n        \n        // Height switch to alternate texture sample\n        return bone( heightSwitcher.x ? heights.x : \n                     heightSwitcher.y ? heights.y : \n                     heightSwitcher.z ? heights.z : \n                                        heights.w );\n    #else\n        // Debug view of the height switch\n        return heightSwitcher.x ? vec3(1., 0., 0.) : \n               heightSwitcher.y ? vec3(0., 1., 0.) : \n               heightSwitcher.z ? vec3(0., 0., 1.) : \n                                  vec3(0., 0., 0.);\n    #endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {   \n    // Calculate UVs for the x-axis of the window\n    vec2 uv = fragCoord / iResolution.x;\n    \n    // Calculate UVs for the blend grids\n    vec2 gridUV = uv * 6.0;\n    \n    // Calculate UVs for the detail texture\n    vec2 detailUV = uv * 7.0;\n    \n    // Create a float to divide into sections for comparisons\n    float comparisonX = uv.x * 3.0;\n\n    // Enable mouse controls when clicked; otherwise, animate\n    float pointer;\n    if (iMouse.x > 0.0) {\n        // Mouse controls\n        vec2 mouse = iMouse.xy / iResolution.xy;\n        pointer = mouse.x * 3.0;\n    } else {\n        // Animation when no mouse input is used\n        //pointer = fract(iTime * 0.1) * 3.0;\n    }\n    \n    // Create zigzag weights\n    float weight = abs(fract(pointer - 0.5) * 2.0 - 1.0);\n    \n    // make transitions deadzones for easier use\n    weight = straightContrast(weight, 2.);\n            \n    // Define default edge locations for the columns\n    vec2 columnEdges = vec2(1.0, 2.0); \n    \n    // Mouse-controlled animations to zoom into the columns    \n    vec2 zoomColumnEdges = columnEdges;\n    if (pointer <= 1.0) {\n        // Zoom into the left side        \n        zoomColumnEdges = vec2(2.8, 2.9);\n    } else if (pointer <= 2.0) {\n        // Zoom into the center column\n        zoomColumnEdges = vec2(0.1, 2.9);\n    } else {\n        // Zoom into the right column\n        zoomColumnEdges = vec2(0.1, 0.2);\n    }\n\n    // Interpolate between default column edge positions and zoom\n    columnEdges = mix(columnEdges, zoomColumnEdges, weight);    \n    \n    // Choose interpolation method based on the x-coordinate\n    vec3 color;\n    if (comparisonX <= columnEdges.x) {\n        // Left side\n        color = heightSwitch(gridUV, detailUV);\n                        \n    } else if (comparisonX <= columnEdges.y) {\n        // Center section\n        color = baryHeightSwitch(gridUV, detailUV);\n        \n    } else {\n        // Right side        \n        color = bilinearHeightSwitch(gridUV, detailUV);\n    }\n    \n    // Add lines between columns\n    float BorderThickness = 0.004;    \n    color += step(abs(comparisonX - columnEdges.x), BorderThickness);\n    color += step(abs(comparisonX - columnEdges.y), BorderThickness);\n    \n    // Add arrows pointing at the center of columns\n    color += step(uv.y + abs(fract(comparisonX)-0.5), BorderThickness*5.);\n        \n    // Set the output color\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//_____________________________Generic Functions________________________________\n\n// Linearly increases contrast of Alpha\n// See: https://www.desmos.com/calculator/k1g3naqoue\nfloat straightContrast(float alpha, float contrast) {\n    return clamp(contrast * (alpha - 0.5) + 0.5, 0., 1.);\n}\n\n// makes viridis colormap with polynimal 6\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes bone colormap with polynimal 6\nvec3 bone(float t) {\n    const vec3 c0 = vec3(-0.005007,-0.003054,0.004092);\n    const vec3 c1 = vec3(1.098251,0.964561,0.971829);\n    const vec3 c2 = vec3(-2.688698,-0.537516,2.444353);\n    const vec3 c3 = vec3(12.667310,-0.657473,-8.158684);\n    const vec3 c4 = vec3(-27.183124,8.398806,10.182004);\n    const vec3 c5 = vec3(26.505377,-12.576925,-5.329155);\n    const vec3 c6 = vec3(-9.395265,5.416416,0.883918);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// Interpolation ________________________________________________________________\n\n// Make tiling bilinear weights\nvec4 bilinearWeights(vec2 uv) {\n    // Generate zigzag pattern\n    vec2 zigZag = abs(fract(uv * 0.5) * 2.0 - 1.0);\n    \n    // Invert zigzag as a partial of the weights\n    vec2 infZigZag = 1.0 - zigZag;\n\n    // Generate alpha values (weights) for bilinear interpolation.\n    float weightA = zigZag.x * zigZag.y;\n    float weightB = zigZag.x * infZigZag.y;\n    float weightC = infZigZag.x * zigZag.y;\n    float weightD = infZigZag.x * infZigZag.y;\n    \n    // Combine weight/alpha values. \n    return vec4(weightA, weightB, weightC, weightD);\n}\n\n// Make square tiling barycentric weights\nvec3 baryWeights(vec2 uv) {\n    // Create zigzag tiling for UVs\n    vec2 zigZag = abs(fract(uv * 0.5) * 2.0 - 1.0);\n\n    // make individual weights for pattern\n    float weightA = min(zigZag.x, zigZag.y);\n    float weightB = min(1.-zigZag.x, 1.-zigZag.y);\n    float weightC = 1. - weightA - weightB;\n    \n    // when to alternate the 2 C samples\n    //float switchC = float(zigZag.x < zigZag.y);\n    \n    // Join weights together\n    return vec3(weightA, weightB, weightC);//, switchC);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlcBWl.jpg", "access": "api", "license": "mit", "functions": [[2650, 2729, 2776, 2825, 3125], [3127, 3221, 3268, 3343, 5257], [5259, 5338, 5386, 5450, 5685], [5687, 5733, 5784, 5859, 8334], [8336, 8415, 8463, 8527, 8911], [8913, 8959, 9014, 9096, 11990], [11992, 11992, 12047, 12100, 14464]], "test": "untested"}
{"id": "dtGfRR", "name": "Plasma wavy shit", "author": "SovietSalman", "description": "Cool wavy shit", "tags": ["waves", "plasma"], "likes": 2, "viewed": 167, "published": 3, "date": "1701764348", "time_retrieved": "2024-07-30T17:18:32.820058", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    uv *= 5.0;\n    uv.x -= 1.0;\n    // Time varying pixel color\n    vec3 col = vec3(\n        0.7 * sin(2.0 * (uv.x + 0.2) + 0.7 * iTime) + 1.3 * sin( 1.2 * (uv.y - 2.3) - 0.4 * iTime) - 1.4 * cos(0.7 * (uv.x + 0.3) * (uv.y + 1.4) + 4.0 * iTime) + 2.0,\n        cos(1.2 * (uv.x - 1.4) + 2.2 * iTime) + 1.1 * cos(-1.3 * (uv.y + 1.7) - 1.4 * iTime) - 2.2 * sin(0.3 * (uv.x + 2.3) * (uv.y + 0.9) - 1.8 * iTime) + 2.3,\n        cos(1.7 * (uv.x - 2.3) + 1.3 * iTime) + 2.4 * sin( 0.4 * (uv.y - 2.3) - 0.6 * iTime) - 2.1 * cos(0.43 * (uv.x - 2.1) * (uv.y - 2.2) + 2.7 * iTime) + 2.4\n    \n    ) / 5.0;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtGfRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 811]], "test": "untested"}
{"id": "ctyfzR", "name": "VGA Palette", "author": "iq", "description": "The palette of my teenage. [url]https://en.wikipedia.org/wiki/Mode_13h[/url].", "tags": ["2d", "palette", "vga", "13h"], "likes": 31, "viewed": 955, "published": 3, "date": "1701757342", "time_retrieved": "2024-07-30T17:18:33.588005", "image_code": "// The default VGA palette\n// https://en.wikipedia.org/wiki/Mode_13h\n\n// Really it fits in 576 bytes (256 colors x 18 bits/color).\n// But I'm making my life easy here by using 1024 bytes.\n\nconst uint kVGAPalette[256] = uint[256](\n0x00000u,0x0002au,0x00a80u,0x00aaau,0x2a000u,0x2a02au,0x2a540u,0x2aaaau,0x15555u,0x1557fu,0x15fd5u,0x15fffu,0x3f555u,0x3f57fu,0x3ffd5u,0x3ffffu,\n0x00000u,0x05145u,0x08208u,0x0b2cbu,0x0e38eu,0x11451u,0x14514u,0x18618u,0x1c71cu,0x20820u,0x24924u,0x28a28u,0x2db6du,0x32cb2u,0x38e38u,0x3ffffu,\n0x0003fu,0x1003fu,0x1f03fu,0x2f03fu,0x3f03fu,0x3f02fu,0x3f01fu,0x3f010u,0x3f000u,0x3f400u,0x3f7c0u,0x3fbc0u,0x3ffc0u,0x2ffc0u,0x1ffc0u,0x10fc0u,\n0x00fc0u,0x00fd0u,0x00fdfu,0x00fefu,0x00fffu,0x00bffu,0x007ffu,0x0043fu,0x1f7ffu,0x277ffu,0x2f7ffu,0x377ffu,0x3f7ffu,0x3f7f7u,0x3f7efu,0x3f7e7u,\n0x3f7dfu,0x3f9dfu,0x3fbdfu,0x3fddfu,0x3ffdfu,0x37fdfu,0x2ffdfu,0x27fdfu,0x1ffdfu,0x1ffe7u,0x1ffefu,0x1fff7u,0x1ffffu,0x1fdffu,0x1fbffu,0x1f9ffu,\n0x2db7fu,0x31b7fu,0x36b7fu,0x3ab7fu,0x3fb7fu,0x3fb7au,0x3fb76u,0x3fb71u,0x3fb6du,0x3fc6du,0x3fdadu,0x3feadu,0x3ffedu,0x3afedu,0x36fedu,0x31fedu,\n0x2dfedu,0x2dff1u,0x2dff6u,0x2dffau,0x2dfffu,0x2debfu,0x2ddbfu,0x2dc7fu,0x0001cu,0x0701cu,0x0e01cu,0x1501cu,0x1c01cu,0x1c015u,0x1c00eu,0x1c007u,\n0x1c000u,0x1c1c0u,0x1c380u,0x1c540u,0x1c700u,0x15700u,0x0e700u,0x07700u,0x00700u,0x00707u,0x0070eu,0x00715u,0x0071cu,0x0055cu,0x0039cu,0x001dcu,\n0x0e39cu,0x1139cu,0x1539cu,0x1839cu,0x1c39cu,0x1c398u,0x1c395u,0x1c391u,0x1c38eu,0x1c44eu,0x1c54eu,0x1c60eu,0x1c70eu,0x1870eu,0x1570eu,0x1170eu,\n0x0e70eu,0x0e711u,0x0e715u,0x0e718u,0x0e71cu,0x0e61cu,0x0e55cu,0x0e45cu,0x1451cu,0x1651cu,0x1851cu,0x1a51cu,0x1c51cu,0x1c51au,0x1c518u,0x1c516u,\n0x1c514u,0x1c594u,0x1c614u,0x1c694u,0x1c714u,0x1a714u,0x18714u,0x16714u,0x14714u,0x14716u,0x14718u,0x1471au,0x1471cu,0x1469cu,0x1461cu,0x1459cu,\n0x00010u,0x04010u,0x08010u,0x0c010u,0x10010u,0x1000cu,0x10008u,0x10004u,0x10000u,0x10100u,0x10200u,0x10300u,0x10400u,0x0c400u,0x08400u,0x04400u,\n0x00400u,0x00404u,0x00408u,0x0040cu,0x00410u,0x00310u,0x00210u,0x00110u,0x08210u,0x0a210u,0x0c210u,0x0e210u,0x10210u,0x1020eu,0x1020cu,0x1020au,\n0x10208u,0x10288u,0x10308u,0x10388u,0x10408u,0x0e408u,0x0c408u,0x0a408u,0x08408u,0x0840au,0x0840cu,0x0840eu,0x08410u,0x08390u,0x08310u,0x08290u,\n0x0b2d0u,0x0c2d0u,0x0d2d0u,0x0f2d0u,0x102d0u,0x102cfu,0x102cdu,0x102ccu,0x102cbu,0x1030bu,0x1034bu,0x103cbu,0x1040bu,0x0f40bu,0x0d40bu,0x0c40bu,\n0x0b40bu,0x0b40cu,0x0b40du,0x0b40fu,0x0b410u,0x0b3d0u,0x0b350u,0x0b310u,0x00000u,0x00000u,0x00000u,0x00000u,0x00000u,0x00000u,0x00000u,0x00000u);\n\nvec3 GetColor_VGAPalette( int index )\n{\n    uint c = kVGAPalette[index];\n    return vec3(ivec3(c>>12,c>>6,c>>0)&63)/63.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.2);\n    \n    // grid coords\n    fragCoord.x -= 0.5*(iResolution.x-iResolution.y);\n    int x = int( floor(16.0*fragCoord.x/iResolution.y) );\n    int y = int( floor(16.0*fragCoord.y/iResolution.y) );\n    \n    if( x>=0 && x<=15 ) \n    {\n        int color_index = (15-y)*16 + x;\n        \n        col = GetColor_VGAPalette( color_index );\n\n        // grid lines\n        {\n        int nx = int( floor(16.0*(fragCoord.x+1.0)/iResolution.y));\n        int ny = int( floor(16.0*(fragCoord.y+1.0)/iResolution.y));\n        if( (nx!=x) || (ny!=y) ) col = vec3(0.4);\n        }\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctyfzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2552, 2552, 2591, 2591, 2675], [2677, 2677, 2734, 2734, 3363]], "test": "untested"}
{"id": "dttfDB", "name": "Djanco's path tracer", "author": "djancool", "description": "My first attempt at a path tracer. enjoyed creating this and Learned a lot", "tags": ["raytracer", "pathtracer"], "likes": 0, "viewed": 60, "published": 3, "date": "1701719962", "time_retrieved": "2024-07-30T17:18:35.699359", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 tex = texture(iChannel1, uv);\n    tex.rgb /= tex.a;\n    \n    // reinhard tonemapping \n    tex /= tex + vec4(1.0);\n \n    fragColor = tex;\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159263535\n\n#define NUM_SPHERES 1\n#define NUM_BOXES 6\n#define NUM_PLANES 2\n\n//#define RENDER_PLANES\n//#define PHONE\n\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;    \n};\n\nstruct Material\n{\n    vec3 col;\n    float roughness;\n    vec3 emission;\n    bool metallic;\n};\n\nstruct HitInfo\n{\n    bool hit;\n    vec3 normal;\n    vec3 pos;\n    float dist;\n    Material mat;\n};\n\n\nstruct Sphere\n{\n    vec3 pos;\n    float radius;\n    Material mat;\n};\n\nstruct Box\n{\n    vec3 pos;\n    vec3 size;\n    Material mat;\n};\n\nstruct Plane\n{\n    vec3 pos;\n    vec3 normal;\n    vec2 size;\n    Material mat;\n};\n\nHitInfo testSphere(Ray ray, Sphere sphere)\n{\n    float t = max(dot(sphere.pos - ray.pos, ray.dir), 0.001);     // Length along RD that is closest to sphere centre/origin\n    vec3 tpos = ray.pos + ray.dir * t;                            // pos along RD that is closest to sphere centre/origin\n    float tdis = distance(tpos, sphere.pos);                      // Distance from tpos to sphere centre/origin\n    float x1 = sqrt(sphere.radius * sphere.radius - tdis * tdis); // Get length of sphere surface to tpos\n    float tx1 = t - x1;                                           // Distance along RD to sphere surface\n    float tx2 = t + x1;                                           // Distance along RD to sphere backface\n    vec3 tx1Pos = ray.pos + ray.dir * tx1;                        // pos of sphere surface\n    vec3 tx2Pos = ray.pos + ray.dir * tx2;                        // pos of sphere backface\n    \n    // Calculate normal\n    vec3 normal = normalize(sphere.pos - tx1Pos);\n    \n    HitInfo hitInfo;\n    \n    hitInfo.hit = tdis < sphere.radius;\n    hitInfo.pos = tx1Pos;\n    hitInfo.dist = tx1;\n    hitInfo.normal = normal;\n    hitInfo.mat = sphere.mat;\n    \n    return hitInfo;\n}\n\n\nHitInfo testBox(Ray ray, Box box)\n{\n    vec3 roo = ray.pos - box.pos;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/ray.dir;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*box.size;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x,t1.y),t1.z);\n    float tF = min(min(t2.x,t2.y),t2.z);\n    \n    HitInfo hitInfo;\n    hitInfo.dist = 10000.0;\n    hitInfo.hit = false;\n    hitInfo.mat = box.mat;\n    \n    // no intersection\n\tif( tN>tF || tF<0.0 ) return hitInfo;\n\n    #if 1\n    // this works as long as the ray origin is not inside the box\n    vec4 res = vec4(tN, step(tN,t1) );\n    #else\n    // use this instead if your rays origin can be inside the box\n    vec4 res = (tN>0.0) ? vec4( tN, step(vec3(tN),t1)) :\n                          vec4( tF, step(t2,vec3(tF)));\n    #endif\n    \n    // add sign to normal and convert to ray space\n\tres.yzw = (vec4(sign(ray.dir)*res.yzw,0.0)).xyz;\n    \n    hitInfo.normal = res.yzw;\n    hitInfo.dist = res.x;\n    hitInfo.pos = ray.dir * (res.x - 0.00001) + ray.pos;\n    hitInfo.hit = true;\n\n\treturn hitInfo;\n}\n\n\nHitInfo testPlane(Ray ray, Plane plane)\n{\n    HitInfo hitInfo;\n    hitInfo.dist = 100000.0;\n    hitInfo.mat = plane.mat;\n    hitInfo.hit = false;\n    \n    if(dot(ray.dir, plane.normal) > 0.0) return hitInfo;\n    float t = dot(plane.pos - ray.pos, plane.normal) / dot(ray.dir, plane.normal);\n    if(t > 0.001)\n    {\n        hitInfo.pos = ray.dir * t + ray.pos;\n        \n        vec3 planeTangent = normalize(cross(plane.normal, vec3(0.0, 1.0, 0.0)));\n        vec3 planeBiTangent = cross(plane.normal, planeTangent);\n        mat3 TBN = mat3(planeTangent, planeBiTangent, plane.normal);\n        vec3 localPoint = (hitInfo.pos - plane.pos) * TBN;\n        \n        if(abs(localPoint.x) < plane.size.x && abs(localPoint.y) < plane.size.y)\n        {\n            hitInfo.dist = length(ray.dir * t);\n            hitInfo.hit = true;\n            hitInfo.normal = -plane.normal;\n        }\n    }\n    \n    return hitInfo;\n}\n\n\nHitInfo testScene(Ray ray, Sphere sphere[NUM_SPHERES], Box box[NUM_BOXES], Plane plane[NUM_PLANES])\n{\n    HitInfo hitInfo;\n    hitInfo.dist = 100000.0;\n    \n    // Loop over spheres\n    for(int i = 0; i < sphere.length(); i++)\n    {\n        HitInfo tempHitInfo;\n        tempHitInfo = testSphere(ray, sphere[i]);\n        \n        if(tempHitInfo.dist < hitInfo.dist) hitInfo = tempHitInfo;\n    }\n    // Loop over boxes\n    for(int i = 0; i < box.length(); i++)\n    {\n        HitInfo tempHitInfo;\n        tempHitInfo = testBox(ray, box[i]);\n        \n        if(tempHitInfo.dist < hitInfo.dist) hitInfo = tempHitInfo;\n    }\n    // Loop over planes\n    #ifdef RENDER_PLANES\n    for(int i = 0; i < plane.length(); i++)\n    {\n        HitInfo tempHitInfo;\n        tempHitInfo = testPlane(ray, plane[i]);\n        \n        if(tempHitInfo.dist < hitInfo.dist) hitInfo = tempHitInfo;\n    }\n    #endif\n\n\n    return hitInfo;\n}\n\n\nvec3 hash3( uvec3 x )\n{\n    const uint k = 1103515245U;\n\n    x = ((x >> 8U) ^ x.yzx) * k;\n    x = ((x >> 8U) ^ x.yzx) * k;\n    x = ((x >> 8U) ^ x.yzx) * k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\nvec3 randDir(vec3 dir, uvec3 index)\n{\n    vec3 rnd = 2.0 * (0.5 - hash3(index));\n    rnd = tan(rnd);\n    rnd = normalize(rnd);\n    \n    // Uniform distribution\n    //return rnd * sign(dot(dir, rnd));\n    \n    // Cosine weighted distribution // We will have les samples on angles, wich makes them darker, wich simulates lambertian\n    return normalize(dir + rnd);\n}\n\nvec3 randDirSpec(vec3 dir, uvec3 index, float roughness)\n{\n    vec3 rnd = 2.0 * (0.5 - hash3(index));\n    rnd = tan(rnd);\n    rnd = normalize(rnd);\n    \n    // Uniform distribution\n    return normalize(dir + roughness * rnd * sign(dot(dir, rnd)));\n}\n\nvec2 uniformDiscSample(float radius, vec2 randomSeed)\n{\n    // Convert polar coordinates to Cartesian coordinates\n    float theta = 2.0 * 3.1415926535897932384626433832795 * randomSeed.x;\n    float r = radius * sqrt(randomSeed.y);\n\n    // Cartesian coordinates\n    float x = r * cos(theta);\n    float y = r * sin(theta);\n\n    return vec2(x, y);\n}\n\n\n//// ROTATION AMTRIX ////\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n            vec3(1, 0, 0),\n            vec3(0, c, -s),\n            vec3(0, s, c));\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c));\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n            vec3(c, -s, 0),\n            vec3(s, c, 0),\n            vec3(0, 0, 1));\n}\n\n\nvoid rotateCamera(inout Ray ray, vec2 rot)\n{\n    ray.pos *= rotateX(rot.x);\n    ray.pos *= rotateY(rot.y);\n    \n    ray.dir *= rotateX(rot.x);\n    ray.dir *= rotateY(rot.y);\n}", "buffer_a_code": "\n#define SPP 15\n#define Bounces 8\n\nvec3 getEnv(vec3 dir)\n{\n    vec3 sunDir = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 sunCol = vec3(1.0, 0.8, 0.6) * 300.0;\n    vec3 sun = pow(max(dot(dir, sunDir), 0.0), 100.0) * sunCol;\n    \n    vec3 tex = texture(iChannel0, dir).rgb * 1.0;\n    return max(tex + sun, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n// Resets render based on mouse movement\n    bool reset = iFrame == 0;\n    \n    // Check for mouse movement\n    reset = iMouse.z > 0.0;\n\n\n\n// ALL SPHERES IN SCENE //\n    Sphere sphere1;\n    sphere1.pos = vec3(-0.7, -1.9, -1.3);\n    sphere1.radius = 1.0;\n    sphere1.mat.col = vec3(0.96);\n    sphere1.mat.roughness = 0.0;\n    sphere1.mat.metallic = false;\n    \n    Sphere sphere2;\n    sphere2.pos = vec3(-15.0, 0.0, 0.0);\n    sphere2.radius = 1.0;\n    sphere2.mat.col = vec3(0.96);\n    sphere2.mat.roughness = 0.4;\n    sphere2.mat.metallic = false;\n    \n    Sphere sphereCollection[NUM_SPHERES];\n    sphereCollection[0] = sphere1;\n    //sphereCollection[1] = sphere2;\n    \n// ALL BOXES IN SCENE //\n    // Floor\n    Box box1;\n    box1.pos = vec3(0.0, -3.0, 0.0);\n    box1.size = vec3(3.0, 0.1, 3.1);\n    box1.mat.col = vec3(1.0);\n    box1.mat.roughness = 1.0;\n    box1.mat.metallic = false;\n    // Left\n    Box box2;\n    box2.pos = vec3(0.0, 0.0, -3.0);\n    box2.size = vec3(3.0, 2.9, 0.1);\n    box2.mat.col = vec3(1.0, 0.0, 0.0);\n    box2.mat.roughness = 0.02;\n    box2.mat.metallic = false;\n    // Right\n    Box box3;\n    box3.pos = vec3(0.0, 0.0, 3.0);\n    box3.size = vec3(3.0, 2.9, 0.1);\n    box3.mat.col = vec3(0.0, 1.0, 0.0);\n    box3.mat.roughness = 0.02;\n    box3.mat.metallic = false;\n    // Back\n    Box box4;\n    box4.pos = vec3(-3.0, 0.0, 0.0);\n    box4.size = vec3(0.1, 3.0, 3.0);\n    box4.mat.col = vec3(0.9, 0.96, 0.925) * 0.9;\n    box4.mat.roughness = 0.02;\n    box4.mat.metallic = false;\n    // Top\n    Box box5;\n    box5.pos = vec3(0.0, 3.0, 0.0);\n    box5.size = vec3(3.0, 0.1, 3.1);\n    box5.mat.col = vec3(1.0);\n    box5.mat.roughness = 1.0;\n    box5.mat.metallic = false;\n    \n    Box box6;\n    box6.pos = vec3(0.7, -1.9, 1.3);\n    box6.size = vec3(1.0);\n    box6.mat.col = vec3(0.96);\n    box6.mat.roughness = 0.8;\n    box6.mat.metallic = false;\n\n    Box boxCollection[NUM_BOXES];\n    boxCollection[0] = box1;\n    boxCollection[1] = box2;\n    boxCollection[2] = box3;\n    boxCollection[3] = box4;\n    boxCollection[4] = box5;\n    boxCollection[5] = box6;\n    \n// ALL PLANES IN SCENE //\n    Plane plane1;\n    plane1.pos = vec3(2.9, 0.0, 0.0);\n    plane1.size = vec2(3.0);\n    plane1.normal = normalize(vec3(-1.0, 0.0, 0.00));\n    plane1.mat = box4.mat;\n    \n    Plane plane2;\n    plane2.pos = vec3(0.0, 2.88, 0.0);\n    plane2.size = vec2(1.0);\n    plane2.normal = normalize(vec3(-0.001, -10.0, 0.0));\n    plane2.mat.col = vec3(0.9);\n    plane2.mat.emission = vec3(1.0, 0.86666666666, 0.74509803921) * 20.0;\n    plane2.mat.emission = vec3(20.0);\n\n    Plane planeCollection[NUM_PLANES];\n    planeCollection[0] = plane1;\n    planeCollection[1] = plane2;\n\n    \n\n// Camera\n    Ray ray;\n    HitInfo hitInfo;\n\n    // ViewDir and fov\n    float a = 0.5/max(iResolution.x, iResolution.y);\n    ray.dir = normalize(vec3((fragCoord - iResolution.xy * 0.5) * a, 0.5));\n    // Translate camera position and direction\n    vec2 mouseRotation = vec2( iMouse.y / iResolution.y * -PI * 0.35 + PI * 0.175,\n                              -iMouse.x / iResolution.x * PI * -0.5 - 0.75 * PI);\n    #ifdef PHONE\n        mouseRotation = vec2(0.01, 1.50) * PI;\n    #endif\n    ray.pos = vec3(0.0, 0.0, -15.0);\n    rotateCamera(ray, mouseRotation);\n\n\n    // Calculate camera forward, up and right vector // This is used for DOF\n    Ray forwardRay;\n    forwardRay.dir = vec3(0.0, 0.0, 1.0);\n    rotateCamera(forwardRay, mouseRotation);\n    vec3 cam_forward = forwardRay.dir;\n    vec3 cam_right = normalize(cross(cam_forward, vec3(0.0, 1.0, 0.0)));\n    vec3 cam_up = cross(cam_forward, cam_right);\n\n\n// START OF RT //\n    vec3 totalIncomingLight = vec3(0.0);\n\n    for(int i = 0; i < SPP; i++)\n    {\n \n\n\n    // DOF //\n        // Uniform disc sampling aligned with camera forward vector\n        vec2 rnd = hash3(uvec3(i + iFrame * int(!reset)) * uvec3(1, 5712, 91120891)).rg;\n        vec2 discSample = uniformDiscSample(0.1, rnd);\n        vec3 offset = discSample.x * cam_right + discSample.y * cam_up;\n        \n        // Focus distance\n        float focusDist = 14.0;\n        // Calculate focus point position\n        vec3 focusPoint = ray.pos + ray.dir * focusDist;\n        // Offset ray start pos\n        ray.pos += offset;\n        // recalculate ray direction taking in account DOF\n        ray.dir = normalize(focusPoint - ray.pos);\n\n    // AA\n        vec2 supPixelSize = 2.0 / iResolution.xy;\n        ray.pos += supPixelSize.x * (rnd.x - 0.5) * cam_right + supPixelSize.y * (rnd.y - 0.5) * cam_up;\n        \n\n        Ray sampleRay;\n        sampleRay = ray;\n\n\n        vec3 diffuseIncomingLight = vec3(0.0);\n        vec3 rayColor = vec3(1.0);\n\n        for(int j = -1; j <= Bounces; j++)\n        {\n        \n            hitInfo = testScene(sampleRay, sphereCollection, boxCollection, planeCollection);\n            \n            // Fresnel calculations\n            float fresnel = 0.04 + 0.96 * pow(1.0 - dot(sampleRay.dir, hitInfo.normal), 5.0);\n            if(hitInfo.mat.metallic) fresnel = 1.0;\n            \n            // Objects become less rough on angles\n            hitInfo.mat.roughness *= dot(sampleRay.dir, hitInfo.normal) * 0.75 + 0.25;\n            \n            // Select random ray to sample specular reflection instead of diffusion\n            float randomSpec = hash3(uvec3(fragCoord.xy + 1000.0, i + j * 20 + iFrame * 200)).x;\n            float specProbability = float(randomSpec < fresnel);\n            \n            if(hitInfo.hit)\n            {\n\n                // If hit something emissive, add it to total light multiplied by diffuse color\n                diffuseIncomingLight += hitInfo.mat.emission * rayColor;\n                \n                if(hitInfo.mat.metallic == false) rayColor *= mix(hitInfo.mat.col, vec3(1.0), specProbability);\n                else rayColor *= hitInfo.mat.col;\n                \n                \n                // Set the new start sample pos \n                sampleRay.pos = hitInfo.pos;\n                // Get random directions\n                uvec3 index = uvec3(fragCoord.xy, i + j * 10 + iFrame * 100);\n                \n                vec3 diffuseDir = randDir(-hitInfo.normal, index);\n                vec3 specularDir = reflect(sampleRay.dir, hitInfo.normal);\n                sampleRay.dir = mix(diffuseDir, specularDir, specProbability * (1.0 - hitInfo.mat.roughness));\n            }\n            else // if we didnt hit anything, we hit the void aka skybox\n            {\n                // Get environment lighting\n                uvec3 index = uvec3(fragCoord.xy, i + j * 30 + iFrame * 300);\n                vec3 diffuseDir = randDir(-hitInfo.normal, index);\n                vec3 specularDir = reflect(sampleRay.dir, hitInfo.normal);\n                sampleRay.dir = mix(diffuseDir, specularDir, specProbability);\n                \n                diffuseIncomingLight += getEnv(sampleRay.dir) * rayColor;\n                break;\n            }   \n        }\n        totalIncomingLight += diffuseIncomingLight;\n    }\n    \n    totalIncomingLight /= float(SPP);\n    \n    \n// The alpha channel is the amount of frames that have passed, when it gets reset it is set back to 1\n    // Get current calculated frame\n    vec4 currentRender = vec4(totalIncomingLight, 1.0);\n    // Get previous frame from buffer\n    vec4 prevRender = texture(iChannel1, fragCoord.xy / iResolution.xy).rgba;\n    // Add them toghetter to get avarage\n    vec4 accumulateRender = prevRender + currentRender;\n    \n    // if you need to reset set buffer to current frame\n    if(reset) accumulateRender = currentRender;\n    \n    fragColor = vec4(accumulateRender);\n    //fragColor = vec4(vec3(hitInfo.dist / 10.0), 1.0);\n}", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dttfDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 256]], "test": "untested"}
{"id": "dt3fDs", "name": "line voronoi", "author": "shuyuwang99", "description": "self defined voronoi values with lines", "tags": ["voronoi", "line"], "likes": 1, "viewed": 140, "published": 3, "date": "1701719781", "time_retrieved": "2024-07-30T17:18:36.629872", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 originalcol = vec3(uv.x, uv.y, 0.5);\n    \n    //vec2 origin = vec2(0, 50);\n    vec2 origin[3];\n    origin[0] = vec2(0,50);\n    origin[1] = vec2(1200,850);\n    origin[2] = vec2(500,500);\n    \n    vec2 nvec[3];\n    nvec[0] = vec2(0.6, 0.8);\n    nvec[1] = vec2(0.8, 0.6);\n    nvec[2] = vec2(-0.6, 0.8);\n    \n\n    float dis = 99999999999999.99;\n    int closer = -1;\n    float t0 = 20.0;\n    float t1 = 20.0;\n    float i_idx = 0.0;\n    float j_idx = 0.0;\n    int counts = 0;\n    while (i_idx < 1.0){\n        j_idx = 0.0;\n        while (j_idx < 1.0){\n            float x_idx = float(fragCoord.x) + i_idx;\n            float y_idx = float(fragCoord.y) + j_idx;\n            dis = 99999999999999.99;\n            for (int k = 0; k<3; k++){\n                float d = pow((pow(x_idx-origin[k].x,2.0)+pow(y_idx-origin[k].y,2.0)),0.5);\n                if (d < dis){\n                   dis = d;\n                   closer = k;\n                }\n            }\n            vec2 pminusp0 = vec2(x_idx-origin[closer].x, y_idx-origin[closer].y);\n            float T = 10.0;\n                    \n            float func = dot(nvec[closer],pminusp0)/T;\n            func = func - floor(func);\n            if (func < originalcol.x){\n                counts ++;\n            }\n            j_idx += 1.0/t1;\n        }\n        i_idx += 1.0/t0;\n    }\n\n    vec3 finalcol = vec3(float(counts)/t0/t1, float(counts)/t0/t1, float(counts)/t0/t1);\n    fragColor = vec4(finalcol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt3fDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1601]], "test": "untested"}
{"id": "dt3BDs", "name": "Lines with same width", "author": "Zhiting", "description": "Making the line with same width", "tags": ["dithering"], "likes": 1, "viewed": 131, "published": 3, "date": "1701719335", "time_retrieved": "2024-07-30T17:18:37.510517", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float fre;\n    float numDis = 50.0;\n    float width = 5.0;\n    fre= width/(1.0 - floor(uv.x*numDis)/numDis);\n    \n    float func;\n    vec2 pos = vec2(0, 50);\n    vec2 dir = vec2(0.6, 0.8);\n    func = dot((fragCoord-pos), dir);\n    \n    // func = func / T\n    func = func / fre;\n    func = func - floor(func);\n    \n    vec3 color;\n    color = vec3(ceil(uv.x - func), ceil(uv.x - func), ceil(uv.x - func));\n    \n    \n    \n    \n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt3BDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 734]], "test": "untested"}
{"id": "dt3fWl", "name": "GeneralizedSoftClip", "author": "TinyTexel", "description": "A soft clip that generalizes 3 commonly used soft clip functions (tanh, exp, Reinhard).", "tags": ["function", "tonemapping", "clip", "transfer"], "likes": 12, "viewed": 314, "published": 3, "date": "1701714899", "time_retrieved": "2024-07-30T17:18:38.579659", "image_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n// https://twitter.com/Mirko_Salm\n\n/*\n    A soft clip that generalizes 3 commonly used soft clip functions (tanh, exp, Reinhard):\n    \n                   1\n    1 + ------------------------\n        (1 - exp(x / s)) * s - 1\n    \n    \n    s = 1/2 ->   tanh(x) // blue\n    \n    s =   1 -> 1-exp(-x) // green\n    \n    s = inf ->   x/(x+1) // red\n    \n    \n    related: \n    \n            https://www.shadertoy.com/view/wdtfRS | SoftClip\n            https://www.shadertoy.com/view/tltyR2 | SoftClip2\n*/\n\nfloat ExpClip (float x) { return 1.0 - exp(-x); }\nfloat Reinhard(float x) { return x / (x + 1.0); }\n\n// s: [0.5, inf] | s = 0.5 -> tanh(x) | s = 1.0 -> 1-exp(-x) | s = inf -> x/(x+1)\nfloat GeneralizedSoftClip(float x, float s)\n{\n    return 1.0 + 1.0 / ((1.0 - exp(x / s)) * s - 1.0);\n}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{    \n    vec2 tex = uv0;\n    tex -= iResolution.yy * vec2(0.125, 0.25);\n    tex /= iResolution.xx * 0.25;\n\n    vec3 col = vec3(0.0);\n    \n\tcol = mix(vec3(1.0), vec3(0.9  ),  Grid(tex.xy * 4.0, 0.0));        \n\tcol = mix(      col, vec3(0.5  ),  Grid(tex.xy * 1.0, 0.0));        \n\tcol = mix(      col, vec3(0.125), Cross(tex.xy * 1.0, 0.0)); \t\n    \n    \n    // relevant plotting code:\n    \n    // grey - special case references\n    col = mix(col, vec3(0.5), Graph(    tanh(tex.x) -tex.y, 4.) * 0.35);  \n    col = mix(col, vec3(0.5), Graph( ExpClip(tex.x) -tex.y, 4.) * 0.35);  \n    col = mix(col, vec3(0.5), Graph(Reinhard(tex.x) -tex.y, 4.) * 0.35);      \n    \n    // blue - tanh\n    col = mix(col, vec3(0.125, 0.5, 1.0), Graph(GeneralizedSoftClip(tex.x,    0.5) -tex.y, 1.));  \n    // green - exp\n    col = mix(col, vec3(0.125, 1.0, 0.5), Graph(GeneralizedSoftClip(tex.x,    1.0) -tex.y, 1.));\n    // red - Reinhard\n    col = mix(col, vec3(1.0, 0.125, 0.5), Graph(GeneralizedSoftClip(tex.x, 1024.0) -tex.y, 1.));\n    \n    // black - animated curve\n    {\n        float t = clamp(sin(iTime) * 0.5 + 0.5, 0.0, 1.0);\n        \n        float s = clamp(1.0/(1.0 - t) - 0.5, 0.5, 4096.0);\n        \n        col = mix(col, vec3(0.0, 0.0, 0.0), Graph(GeneralizedSoftClip(tex.x, s) -tex.y, 0.25));\n    }\n    \n    #if 1\n    vec2 s = (uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n    #endif\n    \n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \n\n}", "image_inputs": [], "common_code": "\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define rsqrt inversesqrt\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\nconst float RcpPi= 1.0 / Pi;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\n\nfloat Line(float u, float b) { return Graph(u, b); }\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\n\nfloat Grid(vec2 uv, float b)\n{\n    float xl = Lines(uv.x, b);    \n    float yl = Lines(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Cross(vec2 uv, float b)\n{\n    float xl = Line(uv.x, b);    \n    float yl = Line(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Dot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    if(v > dr) return 0.0;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt3fWl.jpg", "access": "api", "license": "cc0-1.0", "functions": [[566, 566, 591, 591, 615], [616, 616, 641, 641, 665], [667, 749, 794, 794, 851], [853, 853, 901, 901, 2424]], "test": "untested"}
{"id": "dl3fDl", "name": "xor-confetti", "author": "LydianLights", "description": "just a weird idea I had", "tags": ["confetti"], "likes": 5, "viewed": 154, "published": 3, "date": "1701714684", "time_retrieved": "2024-07-30T17:18:39.686699", "image_code": "#define GRID 32.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float px = 2.0 / iResolution.y;\n    vec2 uv0 = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 uv1 = mat2(cos(PI / 6.0), sin(PI / 6.0), -sin(PI / 6.0), cos(PI / 6.0)) * uv0;\n    vec2 uv2 = mat2(cos(PI / 3.0), sin(PI / 3.0), -sin(PI / 3.0), cos(PI / 3.0)) * uv0;\n    \n    const int N = 3;\n    vec2 uvs[] = vec2[](uv0, uv1, uv2);\n    \n    float hash;\n    for (int i = 0; i < N; i++) {\n        vec2 uv = uvs[i];\n        uv.y += 0.1 * iTime;\n        \n        vec2 id = floor(uv * GRID) + vec2(42 * i, -69 * i);\n        uv = mod(uv, 1.0 / GRID);\n        \n        float h = hash12(id);\n        hash = intBitsToFloat(floatBitsToInt(hash) ^ floatBitsToInt(h));\n    }\n    \n    vec3 color = hash31(hash);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "#define PI 3.1415927\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash31(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.192, .594, .137));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl3fDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "dt3fDl", "name": "hash-confetti", "author": "LydianLights", "description": "just a weird idea I had", "tags": ["confetti"], "likes": 4, "viewed": 187, "published": 3, "date": "1701714440", "time_retrieved": "2024-07-30T17:18:40.747861", "image_code": "#define GRID 32.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float px = 2.0 / iResolution.y;\n    vec2 uv0 = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 uv1 = mat2(cos(PI / 6.0), sin(PI / 6.0), -sin(PI / 6.0), cos(PI / 6.0)) * uv0;\n    vec2 uv2 = mat2(cos(PI / 3.0), sin(PI / 3.0), -sin(PI / 3.0), cos(PI / 3.0)) * uv0;\n    \n    const int N = 3;\n    vec2 uvs[] = vec2[](uv0, uv1, uv2);\n    \n    float hash;\n    for (int i = 0; i < N; i++) {\n        vec2 uv = uvs[i];\n        uv.y += 0.1 * iTime;\n        \n        vec2 id = floor(uv * GRID) + vec2(42 * i, -69 * i);\n        uv = mod(uv, 1.0 / GRID);\n        \n        float h = hash12(id);\n        if (h > hash) {\n            hash = h;\n        }\n    }\n    \n    vec3 color = hash31(hash);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "#define PI 3.1415927\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash31(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.192, .594, .137));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt3fDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "DlcBWs", "name": "2224037", "author": "2224037", "description": "å¾æ¥è©¦ããã¨ãããã¢ã«ã¦ã³ãä½æãã§ãã¾ããã®ã§æåºããã¦é ãã¾ãã", "tags": ["2224037"], "likes": 0, "viewed": 123, "published": 3, "date": "1701705888", "time_retrieved": "2024-07-30T17:18:41.510823", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n { // Normalized pixel coordinates (from 0 to 1) \nvec2 uv = fragCoord; uv -=vec2 (0.5,0.5)* iResolution.xy; \n// Time varying pixel color \nvec3 col = vec3(uv.x,uv.y,0); \nfloat r =200.0; \nif(uv.x * uv.x + uv.y * uv.y < r * r){ float z = sqrt(r * r - uv.x * uv.x - uv.y * uv.y);\n vec3 normal = normalize(vec3(uv.x,uv.y,z));\n vec3 light = normalize(vec3(1.0,1.0,1.0)); \nfloat diffuse = clamp(dot(normal, light),0.0,1.0);\n float I = diffuse * 0.7 + 0.3;\n vec3 d =vec3(-6.0,3.0,-1.0); \nvec3 reflection = reflect (d, normal);\n col = vec3(1.0,3.0,2.0) * I + vec3(1.0,1.0,1.0)*pow(clamp (dot(reflection,light),0.0,1.0),10.0); }\n // Output to screen \nfragColor = vec4(col,1.0); }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlcBWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 105, 725]], "test": "untested"}
{"id": "Dt3fWl", "name": "Sure, but can we fractal? 2", "author": "joteakus", "description": "I mean it isn't terrible right", "tags": ["raytracing", "raymarching", "pathtracing"], "likes": 1, "viewed": 87, "published": 3, "date": "1701704159", "time_retrieved": "2024-07-30T17:18:42.292732", "image_code": "int s = 3;\n\nvec3 sample_texture(vec2 p){\n    vec4 temp = texture(iChannel0, p/iResolution.xy);\n    return temp.xyz/temp.w;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame <= -1){\n        fragColor = postprocess(vec4(sample_texture(fragCoord), 0.));\n    }else{\n        vec3 total = vec3(0.);\n        float max_magnitude = 1.+length(vec2(s));\n        float magnitude_total = 0.;\n        for(int x = -s; x <= s; x++){\n            for(int y = -s; y <= s; y++){\n                vec3 temp = (max_magnitude-length(vec2(x, y)))*sample_texture(fragCoord+vec2(x, y));\n                magnitude_total += max_magnitude-length(vec2(x,y));\n                total += temp*length(temp)*0.02;\n            }\n        }\n        fragColor = postprocess(vec4(sample_texture(fragCoord)+total/magnitude_total, 0.)); \n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "Ray ray;\n\nfloat sde;\nfloat intersect_result;\nvec2 uv;\nvec2 uv2;\nvec3 col;\nconst vec3 sky_col = vec3(0.);\n\n//settings\nconst int bounces = 2;\nconst int pass_per_frame = 1;\nconst vec3 camera = vec3(0., 0., -16.);\n\nconst bool ambient_light_enabled = true;\nconst bool use_three_light_model = false;\n\nvoid intersect(float max_len){\n    sde = inf;\n    steps = 0;\n    //ray.pos += ray.dir*eps;\n    while(sde > eps || ray.len < max_len){\n        sde = get_scene_distance(ray.pos, false);\n        if(sde > eps && ray.len < max_len){\n            ray.pos += ray.dir*sde;\n            ray.len += sde;\n        }else{\n            intersect_result = (sde <= eps) ? HIT : MISS;\n            break;\n        }\n    }\n}\n\nvec3 apply_light(vec3 light_dir, vec3 light_col, bool ambient){\n\n    vec3 n_dir = normalize(light_dir);\n    vec3 fresnel1 = (scene_surface == matte) ? scene_col : vec3(0.5);\n    \n    vec3 half_not_illegal = normalize(n_dir-ray.dir);\n    float diffuse = max(0., dot(n_dir, normal));\n    \n    float specular = 0.;//(1.-scene_roughness)*pow(clamp(dot(n_dir,reflect(ray.dir, normal)),0.,1.),10.*(1.-scene_roughness));\n    vec3  fresnel = fresnel1 + (1.-fresnel1)*pow(clamp(1.-dot(half_not_illegal,n_dir),0.,1.),50.);\n    \n    \n    float shadow_strength = 1.;\n    if(diffuse >= 0. && !ambient){\n        float d = length(light_dir);\n        Ray ray2 = ray;\n        ray.dir = n_dir;\n        ray.len = 0.;\n        intersect(d);\n        shadow_strength = (intersect_result == HIT) ? 0. : 1.;\n        ray = ray2;\n    }else{\n        shadow_strength = 1.;\n    }\n    vec3 back = vec3(0.);\n    if(scene_surface == matte){\n        back += diffuse/**shadow_strength*/*scene_col*light_col;\n        back += diffuse/**shadow_strength*/*light_col*fresnel*(1.+specular);\n    }else if(scene_surface == metal){\n        back += diffuse/**shadow_strength*/*light_col*fresnel*(1.+specular);\n    }else{\n        \n    }\n    back *= shadow_strength;\n    return back;\n\n}\n\nvec3 apply_lighting(){\n\n    vec3 temp = vec3(0.);\n    float distance_to_center = hash13(cross(ray.pos, ray.dir)*2.3+iTime*500.);\n    vec3 offset = random_equal_vec3(cross(ray.pos, ray.dir)*(iTime+500.));\n    //temp += apply_light(normalize((distance_to_center*offset+vec3(100., 1000., 0.))-ray.pos), vec3(5., 5., 2.5)); \n    //temp += apply_light(normalize(vec3(-1., 10., 0.)), vec3(1., 1., 3.)); \n    temp += apply_light((0.75*offset+vec3(0., 4.23, -4.23)-ray.pos), vec3(5., 5., 3.), false); \n    temp += apply_light((0.5*offset+camera-ray.pos), vec3(1., 1., 1.), false); \n    if(ambient_light_enabled){\n        temp += apply_light((normalize(offset)), vec3(0.5, 0.5, 0.5), true); \n    }\n    if(use_three_light_model){\n        temp += apply_light((distance_to_center*0.5*offset+vec3(-7., 9., -1.)-ray.pos), vec3(1., 1., 1.), false); \n        temp += apply_light((distance_to_center*0.5*offset+vec3(7., 9., -1.)-ray.pos), vec3(1., 1., 1.), false); \n    }\n    \n    return temp;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 total_color = vec3(0.);\n\n    for(int pass = 0; pass <= pass_per_frame; pass++){\n        uv = fragCoord/iResolution.xy;\n        uv2 = (uv-0.5)*2.;\n        uv2.x *= iResolution.x/iResolution.y;\n        vec2 uv_offset = (hash31(iTime*1234.5).xy/iResolution.xy)*2.;\n        vec2 uv3 = uv2+uv_offset;\n        col = vec3(0.);\n        vec3 ray_col = vec3(1.);\n        vec3 accumulated = vec3(0.);\n    \n        ray = Ray(camera, normalize(vec3(uv3, 2.)), 0.);\n        for(int i = 0; i <= bounces; i++){\n            intersect(max_t);\n            if(intersect_result == HIT){\n                get_scene_distance(ray.pos, true);\n                get_normal(ray.pos);\n                ray.pos += normal*eps;\n                //lighting goes here??? maybe???\n                vec3 scene_color2 = scene_col;\n                scene_col *= ray_col;\n                vec3 temp_col = apply_lighting();\n                ray_col *= scene_color2;\n                accumulated += temp_col;\n                //tint *= temp_col;\n                vec3 specular_dir = reflect(ray.dir, normal);\n                vec3 diffuse_dir = vec3_near(cross(ray.pos, ray.dir)*(iTime+500.), normal, 1.-scene_diffuse);\n                ray.dir = mix(specular_dir, diffuse_dir, scene_roughness);\n                ray.len = 0.;\n            }else{\n                accumulated += ray_col*vec3(0., 0., 0.);\n                break;\n            }\n        }\n    \n    \n        col = accumulated/float(bounces+1);\n        total_color += col;\n    }\n\n    vec4 total = texture(iChannel0, uv);\n    total += vec4(total_color, pass_per_frame);\n    if(iTime > 2.5){\n        fragColor = total;\n    }else{\n        fragColor = vec4(0.);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float HIT = 1.;\nconst float MISS = 2.;\nconst float inf = 9999999.;\nconst float eps = 0.01;\nconst float max_t = 25.;\nconst int matte = 1;\nconst int metal = 2;\nint steps;\nfloat sde_v_1;\nfloat sde_v_2;\nvec3 normal;\n\nvec3 scene_col;\nfloat scene_diffuse;\nfloat scene_roughness;\nint scene_surface;\n\nconst float Power = 3.;\n\nvec4 postprocess(vec4 og){\n    vec4 temp = og;\n    temp *= 0.8;\n    temp = temp/(temp+1.);\n    temp = 1.1*(temp-0.5)+0.5-0.;\n    temp = pow(temp, vec4(1.5));\n    return temp;\n\n}\n\nstruct Ray{\n    vec3 pos;\n    vec3 dir;\n    float len;\n};\n\nvoid object(bool update_surface, float sde, vec3 col, float diffuse, float roughness, int surface_type){\n    if(sde <= sde_v_1){\n        sde_v_1 = sde;\n        if(update_surface){\n            scene_col = col;\n            scene_diffuse = diffuse;\n            scene_roughness = roughness;\n            scene_surface = surface_type;\n        }\n    }\n}\n\nfloat sphere(vec3 from, vec3 pos, float radius){\n    return distance(from, pos)-radius;\n}\n\nfloat plane(vec3 from, vec3 normal, float offset){\n    return(dot(normalize(normal), from)-offset);\n}\n\nfloat box(vec3 from, vec3 pos, vec3 dimensions)\n{\n  vec3 q = abs(from-pos) - dimensions;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat mandelbulb(vec3 pos, out int steps) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 10 ; i++) {\n\t\tr = length(z);\n        steps = i;\n\t\tif (r>2.0) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = 0.1+acos(z.z/r);\n\t\tfloat phi = 0.78539816+atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nfloat get_scene_distance(vec3 pos, bool colors){\n\n    sde_v_1 = inf;\n    object(colors,\n            mandelbulb(pos/2.5+vec3(0., 0.5, 0.), steps), \n            vec3(0.9), 0.4, 0.5, matte);\n            \n    object(colors,\n            box(pos, vec3(-5., 0., 0.), vec3(eps, 5.+eps, 5.+eps)), \n            vec3(0.1, 0.1, 0.9), 0.5, 0.5, matte);\n    object(colors,\n            box(pos, vec3(5., 0., 0.), vec3(eps, 5.+eps, 5.+eps)), \n            vec3(0.9, 0.1, 0.1), 0.5, 0.5, matte);\n    object(colors,\n            box(pos, vec3(0., -5., 0.), vec3(5.+eps, eps, 5.+eps)), \n            vec3(0.6), 0.1, 0.1, metal);\n    object(colors,\n            box(pos, vec3(0., 5., 0.), vec3(5.+eps, eps, 5.+eps)), \n            vec3(0.6), 0.1, 0.1, metal);\n    object(colors,\n            box(pos, vec3(0., 0., 5.), vec3(5.+eps, 5.+eps, eps)), \n            vec3(0.6), 0.7, 0.7, matte);\n\n    return sde_v_1;\n}\n\nvoid get_normal(vec3 pos){\n    vec2 oz = vec2(1., 0.);\n    normal = vec3(0.);\n    normal.x += get_scene_distance(pos+eps*oz.xyy, false)-get_scene_distance(pos-eps*oz.xyy, false);\n    normal.y += get_scene_distance(pos+eps*oz.yxy, false)-get_scene_distance(pos-eps*oz.yxy, false);\n    normal.z += get_scene_distance(pos+eps*oz.yyx, false)-get_scene_distance(pos-eps*oz.yyx, false);\n    normal = normalize(normal);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   vec3 temp = fract((p3.xxy+p3.yzz)*p3.zyx); \n   return (temp-0.5)*2.;\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 random_equal_vec3(vec3 seed){\n    float azimuth = hash13(seed)*360.;\n    float polar = hash13(seed*2.5+103.)*360.;\n    vec3 temp = vec3(0.);\n    temp.x = sin(polar)*cos(azimuth);\n    temp.y = sin(polar)*sin(azimuth);\n    temp.z = cos(polar);\n    return temp;\n}\n\n\n//    normalize(hash31(abs(time*50.+100.+abs(seed.x*25.)+abs(seed.y*1234.)+abs(seed.z*100.))));\n\n\nvec3 vec3_near(vec3 seed, vec3 dir, float threshold){\n    if(threshold > 0.9){\n        return dir;\n    }else{\n        float modify = 100.;\n        vec3 temp = random_equal_vec3(seed+modify*10.);\n        while(dot(temp, dir) <= threshold){\n            modify += 0.5;\n            temp = random_equal_vec3(seed+modify*10.);\n        }\n        return temp;\n    }\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt3fWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[12, 12, 40, 40, 124], [127, 127, 184, 184, 827]], "test": "untested"}
{"id": "7dSyWm", "name": "Anamorphic Illusion cmarangu", "author": "cmarangu", "description": "rewrote some older code that turns 3D raytraced scenes into anamorphic illusion from scratch\n// using this as a late excuse for Genuary Day 26 \"Perspective\" submission", "tags": ["illusion", "perspective", "anamorphic"], "likes": 6, "viewed": 334, "published": 3, "date": "1701675850", "time_retrieved": "2024-07-30T17:18:43.295051", "image_code": "// 2023 12 04 2:44am ET Note: I made this code in Spring 2022.\n// I'm just setting this to un- unlisted today.\n//\n// Title: Anamorphic Illusion WIP\n// Started: 2022 January 29th\n// Tags: anamorphic, perspective, illusion\n// Description: rewrote some older code that turns 3D raytraced scenes into anamorphic illusion from scratch\n// using this as a late excuse for Genuary Day 26 \"Perspective\" submission\n\n//\n// universal constants\n// (I know 300+ digits PI)\n//\n#define PI 3.14159265358979323846264\n#define TAU 6.283185307\n\n\n\n//\n// optional settings\n//\n#define cam_mouse 1\n#define cam_perspective 1\n\n//\n// more settings\n#define ana_w 5.\n#define ana_off vec3(20., 0., 0.)\n\n// 0 - webcam\n// 1 - scene with a little sphere\n#define scene 1\n\n\n//\n// cube map\n//\nvec3 sky_map (vec3 d) {\n    //return vec3(0.);\n    //return vec3(.0, .0, 100./255.);\n    //return vec3(0., 1., 0.);\n\t//\n    /*#if 0\n    d.y = -d.y;\n\tfloat phi = asin(d.y);\n\tfloat th = mod(atan(d.x, d.z)+TAU*9.+PI*.25*.05, TAU);\n\treturn texture(\n\t  iChannel2,\n\t  vec2(th/TAU, ( phi/(PI*.5) )*-.5+.5 )\n\t).rgb;\n    #endif*/\n    return texture(iChannel2, d).rgb;\n}\n\n\n\n//\n// inter_sky is used when no intersection with a shape exists\n//\nvec4 inter_sky = vec4(0., 0., 0., 1e6);\n\n\n//\n// ray intersection with sphere.\n//\nvec4 inter_sphere (vec3 p, vec3 d, float r) {\n    bool insideout = length(p) < r+.001;\n    //\n\tvec3 camp = p;\n\tfloat SDFp = length(p)-r;\n\tp += d*abs(SDFp)*.2;\n\tint hits = 0;\n\tfor (int mrch=0; mrch<260; ++mrch) {\n\t\tSDFp = length(p)-r;\n\t\tif (mrch > 5 && SDFp > 10.) {\n\t\t\tbreak;\n\t\t}\n\t\tif (abs(SDFp) < 1e-3) {\n\t\t\tif (insideout && hits < 1) {\n\t\t\t\thits++;\n\t\t\t\tp += d*SDFp;\n\t\t\t\tp += d*1e-2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn vec4(\n\t\t\t\t\tnormalize(p),\n\t\t\t\t\tlength(p-camp)//*sign(length(p-c)-r)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tp += d*abs(SDFp)*.99;\n\t}\n\treturn inter_sky;\n}\n\n\n//\n// Signed/Spherical Distance Function/Field for a plane. point p, plane normal n.\n//\n#define SDF_plane(p, n) ( dot(normalize(p), n)*length(p) )\n//\n// ray intersection with plane. ray origin p, ray direction d, plane normal n\n//\n#define inter_plane_short(p, d, n) (\\\n    dot(-n, d) > 1e-6 ? vec4(n, dot(-p, -n)/dot(-n, d)) : inter_sky\\\n)\nvec4 inter_plane (vec3 p, vec3 d, vec3 n) {\n    vec4 inter_plane1;\n    inter_plane1 = inter_plane_short(p, d, n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    inter_plane1 = inter_plane_short(p, d, -n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    return inter_sky;\n}\n\n//\n// ray intersection with weird quadrilateral thing\n//\nvec4 inter_squad (vec3 p, vec3 d, vec3 n) {\n    vec4 inter_current = inter_plane(p, d, n);\n    if (inter_current.w >= inter_sky.w) {\n        return inter_sky;\n    }\n    p += d*inter_current.w;\n    if (max(abs(p.x), abs(p.z)) >= ana_w && p.y >= 0.) {\n        return inter_sky;\n    }\n    return inter_current;\n}\n\n\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    //\n    // screen coordinates. For this one I am doing a \"splitscreen\"\n    //\n    // //\n    //\n    // The trick is to first make regular screen coordinates, with y from -1 to 1 and x scaled to aspect ratio\n    //\n    //\n    vec2 screen = (fragCoord - iResolution.xy/2.)/(iResolution.y/2.);\n    vec2 mouse  = (iMouse.xy - iResolution.xy/2.)/(iResolution.y/2.);\n    //\n    // then decide which \"screen_number\" we are in\n    //\n    int screen_number = 0;\n    if (screen.x > 0.) { screen_number = 1; }\n    //\n    // then center each mini screen's coordinates\n    //\n    if (screen_number == 0) {\n        screen.xy *= iResolution.y/(iResolution.x/2.);\n        screen.x += 1.;\n        mouse.xy *= iResolution.y/(iResolution.x/2.);\n        mouse.x += 1.;\n    }\n    else {\n        screen.xy *= iResolution.y/(iResolution.x/2.);\n        screen.x -= 1.;\n        mouse.xy *= iResolution.y/(iResolution.x/2.);\n        mouse.x -= 1.;\n    }\n    //\n    // set initial color to 0,0,0. Will add color for each intersection/reflection/refraction\n    //\n    fragColor = vec4(0., 0., 0., 1.);\n    //\n    // set the transparency of the screen to 100%\n    //\n    float shiny = 1.;\n    //\n    // set the initial ray origin p, direction d.\n    // rotate by angles theta and phi.\n    //\n    vec3 p; vec3 d; vec3 bestp;\n    float theta = 0.; float phi = 0.;\n    mat2 azimuth; mat2 zenith;\n    if (true) {\n        //\n        // camera ray origin/direction for the right-side screen\n        //\n        #if cam_perspective\n        p = vec3(screen.x, screen.y, 0.);\n        // subtract the point on the screen minus the viewer's head position to get the ray direction\n        d = normalize(p-vec3(0., 0., -2.));\n        //p = vec3(0.);\n        //d = normalize(vec3(screen.x, screen.y, 2.));\n        #else\n        // orthogonal camera\n        p = vec3(screen.x, screen.y, 0.)*14.;\n        d = normalize(vec3(0., 0., 1.));\n        #endif\n        //\n        // (optional) move the camera back from the center of the 3D scene\n        //\n        p += vec3(0., 0., -16.);\n        //\n        // (optional) rotate theta and phi based on mouse coords\n        //\n        #if cam_mouse\n        theta += mouse.x*PI;\n        phi   += mouse.y*PI;\n        #endif\n        //\n        // create the rotation matricies from the angles\n        //\n        azimuth = transpose(mat2(\n            cos(theta), cos(PI*.5+theta),\n            sin(theta), sin(PI*.5+theta)\n        ));\n        zenith = transpose(mat2(\n            cos(phi), cos(PI*.5+phi),\n            sin(phi), sin(PI*.5+phi)\n        ));\n        //\n        // appply rotation matricies to camera ray position and direction\n        //\n        p.yz = zenith*p.yz;\n        d.yz = zenith*d.yz;\n        p.xz = azimuth*p.xz;\n        d.xz = azimuth*d.xz;\n        //\n        // (optional) move the camera back and up from the center of the 3D scene\n        //\n        //p += vec3(0., 4., -3.);\n        //p += vec3(0., 1., -3.);\n        //\n        #if 0\n        //\n        // (optional) center the camera around both the square and the anamorphic portal\n        //\n        p *= 2.;\n        p.xy += ana_off.xz/2.;\n        //mouse *= 2.;\n        //mouse.xy += ana_off.xz/2.;\n        #elif 1\n        //\n        // (optional) center the camera around the anamorphic portal\n        //\n        p.xy += ana_off.xz;\n        //mouse.xy += ana_off.xz;\n        #endif\n    }\n    //\n    // store that as bestp, the point from which the illusion works best\n    // bestp will be used later, to compute the anamorphic illusion on both screens and to be the\n    // camera position on the right side screen\n    //\n    bestp = p;\n    if (screen_number == 0) {\n        //\n        // camera ray origin/direction for the left-side screen\n        //\n        //p = vec3(screen.x*6., 0., screen.y*6.);\n        //d = normalize(p-vec3(0., 2., 0.));\n        //p = vec3(0., 6.1, 0.);\n        p = vec3(0., ana_w+.01, 0.);\n        d = normalize(vec3(screen.x, -1., screen.y));\n        p += vec3(0., 0.001, 0.);\n        //p -= d*6.;\n        //\n        #if 1\n        //\n        // (optional) center the camera around both the square and the anamorphic portal\n        //\n        p *= 2.;\n        p.xy += ana_off.xz/2.;\n        p.y += 6.;\n        //mouse *= 2.;\n        //mouse.xy += ana_off.xz/2.;\n        #elif 1\n        //\n        // (optional) center the camera around the anamorphic portal\n        //\n        p.xy += ana_off.xz;\n        //mouse.xy += ana_off.xz;\n        #endif\n    }\n    //\n    // start the loop of reflections/refractions\n    //\n    for (float bounces=0.; bounces<30.; ++bounces) {\n    //for (float bounces=0.; bounces<3.; ++bounces) {\n        //\n        // if the last-hit object is effectively opaque, end the ray's journey\n        //\n        if (shiny < .1) { break; }\n        //\n        // inter_closest is the closest object. inter_current is the current checked object\n        //\n        vec4 inter_closest = inter_sky; vec4 inter_current;\n        #if scene == 1\n        inter_current = inter_sphere(p-vec3(0., 0., 0.), d, 1.);\n        if (inter_current.w < inter_closest.w) { inter_closest = inter_current; }\n        #endif\n        inter_current = inter_plane(p-vec3(0., 0., 0.), d, normalize(vec3(0., 1., 0.)) );\n        if (inter_current.w < inter_closest.w) { inter_closest = inter_current; }\n        #if scene == 0\n        inter_current = inter_squad(p-vec3(0., 0., 0.), d, normalize(ana_off-bestp) );\n        if (inter_current.w < inter_closest.w) { inter_closest = inter_current; }\n        #endif\n        //\n        // now shading\n        //\n        p += d*inter_closest.w;\n        if (inter_closest.w < inter_sky.w) {\n            if (abs(p.y) < .0001) {\n                //\n                // hits ground\n                //\n                if (max(abs(p.x-ana_off.x), abs(p.z-ana_off.z)) < ana_w) {\n                    //\n                    // hits anamorphic portal\n                    //\n                    /*if (screen_number == 1) {\n                        p.xyz -= ana_off.xyz;\n                        p -= d*30.;\n                    }*/\n                    d = normalize(p-bestp);\n                    p.xyz -= ana_off.xyz;\n                    p -= d*30.;\n                }\n                else if (max(abs(p.x), abs(p.z)) < ana_w) { \n                    //\n                    // hits ground inside normal scene\n                    //\n                    vec3 texcolor;\n                    texcolor = vec3(0.);\n                    //texcolor = vec3(0., 1., 1.);\n                    //texcolor = .1*vec3(0., 1., 1.);\n                    /*#define tiny .0001\n                    texcolor = mix(\n                      texcolor,\n                      vec3(1.)*mod(floor(p.x+tiny)+floor(p.y+tiny)+floor(p.z+tiny), 2.),\n                      .1\n                    );\n                    #undef tiny*/\n                    fragColor.rgb += shiny*texcolor;\n                    //\n                    // amount reflected/transmitted varies 0-1 based on how much is absorbed\n                    //\n                    //shiny *= .99;\n                    shiny *= 1.;\n                    //\n                    // update ray position based on surface properties\n                    //\n                    //d = reflect(d, inter_closest.xyz);\n                    p += d*1e-3;\n                }\n                else {\n                    //\n                    // hits ordinary plain\n                    // fake diffuse with texture map\n                    //\n                    vec3 texcolor;\n                    texcolor = vec3(0.);\n                    #define tiny .0001\n                    texcolor = mix(\n                        texcolor,\n                        vec3(1.)*mod(floor(p.x+tiny)+floor(p.y+tiny)+floor(p.z+tiny), 2.),\n                        .5\n                    );\n                    #undef tiny\n                    fragColor.rgb += shiny*texcolor;\n                    //\n                    // amount reflected/transmitted varies 0-1 based on how much is absorbed\n                    //\n                    shiny *= .2;\n                    //\n                    // update ray position based on surface properties\n                    //\n                    d = reflect(d, inter_closest.xyz);\n                    p += d*1e-3;\n                }\n            }\n            #if scene == 1\n            else if (abs(length(p)-1.) <= .01) {\n                //\n                // hits sphere\n                //\n                // //\n                //\n                // fake diffuse with texture map\n                //\n                vec3 texcolor;\n                //texcolor = vec3(1., 0., 0.);\n                texcolor = vec3(abs(inter_closest.xyz));\n                //texcolor = clamp(.5+.5*inter_closest.xyz, 0., 1.);\n                fragColor.rgb += shiny*texcolor;\n                //\n                // amount reflected/transmitted varies 0-1 based on how much is absorbed\n                //\n                shiny *= .2;\n                //\n                // update ray position based on surface properties\n                //\n                d = reflect(d, inter_closest.xyz);\n                p += d*1e-3;\n            }\n            #endif\n            else {\n                //\n                // hits image plane quadrilateral thing\n                //\n                // //\n                //\n                // fake diffuse with texture map\n                //\n                vec3 texcolor;\n                //texcolor = vec3(1., 0., 0.);\n                texcolor = vec3(abs(inter_closest.xyz));\n                //texcolor = clamp(.5+.5*inter_closest.xyz, 0., 1.);\n                /*#define tiny .0001\n                #define tmp1 6.\n                texcolor = mix(\n                    texcolor,\n                    vec3(1.)*mod(floor(p.x*tmp1+tiny)+floor(p.y*tmp1+tiny)+floor(p.z*tmp1+tiny), 2.),\n                    .5\n                );\n                #undef tmp1\n                #undef tiny*/\n                vec3 p2 = p;\n                p2.xz = inverse(azimuth)*p2.xz;\n                p2.yz = inverse(zenith)*p2.yz;\n                texcolor = texture(iChannel1, (p2.xy/ana_w/2.)*vec2(1., iResolution.x/iResolution.y)+.5).rgb;\n                fragColor.rgb += shiny*texcolor;\n                //\n                // amount reflected/transmitted varies 0-1 based on how much is absorbed\n                //\n                shiny *= .0;\n                //\n                // update ray position based on surface properties\n                //\n                //d = reflect(d, inter_closest.xyz);\n                p += d*1e-3;\n            }\n        }\n       \n    }\n    //\n    // optional: if this is a camera ray and not a reflected ray, use blue background instead of actual cube map\n    //\n    if (shiny == 1.) {\n        fragColor.rgb = vec3(0., 0., 100./255.);\n        shiny = 0.;\n    }\n    //\n    // add the cube map\n    //\n    fragColor.rgb += shiny*sky_map(d);\n    shiny *= 0.;\n    //\n    // fix fragColor\n    //\n    fragColor.rgb = clamp(fragColor.rgb, 0., 1.);\n    fragColor.a = 1.;\n}\n\n\n\n\n\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dSyWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[738, 756, 779, 1076, 1116], [1230, 1269, 1314, 1314, 1809], [2152, 2152, 2195, 2195, 2533], [2535, 2592, 2635, 2635, 2901]], "test": "untested"}
{"id": "cl3fWX", "name": "metalhead", "author": "aerowave", "description": "use the mouse to stare off into the distance\n\nHead SDF and base raymarcher graciously stolen from https://www.shadertoy.com/view/wlf3WX\neverything else (skybox, uhh thats about it lol) is me", "tags": ["head"], "likes": 1, "viewed": 150, "published": 3, "date": "1701644060", "time_retrieved": "2024-07-30T17:18:44.256481", "image_code": "// Fork of \"Head\" by tdhooper. https://shadertoy.com/view/wlf3WX\n// 2023-12-03 21:12:37\n\n// hi Ã¦ro here\n// i have no clue how some of these functions work (namely calcNormal, mHead), all i know is that they work\n// any comments here are simply notes to myself on how they work\n// \n\nfloat sstep(float t) {\n\treturn sin(t * PI - PI / 2.) * .5 + .5;\n}\n\nfloat sceneSDF(vec3 p) {\n    float scale = 1.0;\n    \n    // translation\n    //p += vec3(-0.5, 0, 0);\n    \n    // rotation\n    if (iMouse.z < 1.0) {\n        pR(p.xz, iTime); // around vertical axis\n    } else {\n        pR(p.yz, 0.5 - (iMouse.y / iResolution.y)); // around horizontal axis\n        pR(p.xz, 0.5 - (iMouse.x / iResolution.x)); // around vertical axis\n    }\n   \n    p /= scale;\n    \n    float dist = mHead(p) * scale;\n\n   \treturn dist;\n}\n\nconst int NORMAL_STEPS = 6;\nvec3 calcNormal(vec3 pos){\n    vec3 eps = vec3(.0005,0,0);\n    vec3 nor = vec3(0);\n    float invert = 1.;\n    for (int i = 0; i < NORMAL_STEPS; i++){\n        nor += sceneSDF(pos + eps * invert) * eps * invert;\n        eps = eps.zxy;\n        invert *= -1.;\n    }\n    return normalize(nor);\n}\n\nvec3 skybox(vec3 n) {\n    vec3 col = vec3(0);\n    if (n.y > 0.0) {\n        col = mix(vec3(1), vec3(0,0,1), dot(n, vec3(0,1,0)));\n    } else {\n        col = mix(vec3(0), vec3(1,0,1), dot(n, vec3(0,-1,0)));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // centered uv coordinates\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    \n    // border\n    if (abs(p.x) > 1.0) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    // perspective projection\n    vec3 camPos = vec3(0,0,4);\n    vec3 rayDirection = normalize(vec3(p,-6));\n    \n    // orthographic projection\n    //vec3 camPos = vec3(p.xy,3);\n    //vec3 rayDirection = vec3(0,0,-1);\n    \n    vec3 rayPosition = camPos;\n    float rayLength = 0.;\n    float dist = 0.;\n    bool bg = true;\n    vec3 col = vec3(p*0.5+0.5, 1);\n\n    for (int i = 0; i < 64; i++) {\n        rayLength += dist;\n        rayPosition = camPos + rayDirection * rayLength;\n        dist = sceneSDF(rayPosition);\n\n        // hit object\n        if (abs(dist) < .001) {\n            bg = false;\n        \tbreak;\n        }\n        \n        // render distance\n        if (rayLength > 10.) {\n            break;\n        }\n    }\n    \n    if ( ! bg) {\n        if (!isEye) {\n            vec3 n = calcNormal(rayPosition);\n        \n            // reflection direction - https://math.stackexchange.com/questions/13261/how-to-get-a-reflection-vector\n            vec3 r = rayDirection - (2.0 * dot(rayDirection, n) * n);\n\n            col = skybox(r);\n        } else {\n            col = vec3(sin(iTime * PI * 2.0) * 0.5 + 0.5);\n        }\n    } else {\n        col = skybox(rayDirection);\n    }\n    \n    fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "/*\n\nHead\n----\n\nThis was painstakingly hand modeled by 'tracing' a polygonal model\nexported from Daz 3D.\n\nThe initial approach is to smooth blend small ellipses with a large\nblend radius, a technique I took from Ink Drawing by lnae\n(https://www.shadertoy.com/view/MltcDB)\n\nThe brow and jawline are formed by blending planes and spheres.\nThe nose is, of course, a few capsules.\nThe ears are various extruded and warped 2D layers, they were by\nfar the hardest part.\n\nI encourage you to comment parts out and see how it all adds up.\n\nUses a few primitives and tools from HG_SDF and IQ.\n\nApologies for the boring shading, you can see some more interesting\napplications in the GIF and 4K that this was created for:\n\n* Fractal Polycephaly https://media.giphy.com/media/J2xwceb3Kk50fGXWdj/giphy.gif\n* á´ s á´ Ê á´ Ê á´¡ á´ á´  á´ https://www.shadertoy.com/view/wtf3RM\n\n\nLicense: Creative Commons Attribution-NonCommercial\nhttps://creativecommons.org/licenses/by-nc/4.0/\n\n*/\n\n#define PI 3.14159265359\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 pRi(vec2 p, float a) {\n    pR(p, a);\n    return p;\n}\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat vmin(vec3 v) {\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec2 v) {\n    return min(v.x, v.y);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCorner2(vec2 p) {\n    return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\nfloat fDisc(vec3 p, float r) {\n    float l = length(p.xz) - r;\n    return l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// IQ https://www.shadertoy.com/view/Xds3zN\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat smin2(float a, float b, float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat smax2(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat smin3(float a, float b, float k){\n    return min(\n        smin(a, b, k),\n        smin2(a, b, k)\n    );\n}\n\nfloat smax3(float a, float b, float k){\n    return max(\n        smax(a, b, k),\n        smax2(a, b, k)\n    );\n}\n\n\nfloat ellip(vec3 p, vec3 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nfloat ellip(vec2 p, vec2 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nbool isEye = false;\n\n\nfloat mHead(vec3 p) {\n\n    pR(p.yz, -.1);\n    p.y -= .11;\n\n    vec3 pa = p;\n    vec3 ps = p;\n    ps.x = sqrt(ps.x * ps.x + .0005);\n    p.x = abs(p.x);\n    vec3 pp = p;\n\n    float d = 1e12;\n\n    // skull back\n    p += vec3(0,-.135,.09);\n    d = ellip(p, vec3(.395, .385, .395));\n\n    // skull base\n    p = pp;\n    p += vec3(0,-.135,.09) + vec3(0,.1,.07);\n    d = smin(d, ellip(p, vec3(.38, .36, .35)), .05);\n\n    // forehead\n    p = pp;\n    p += vec3(0,-.145,-.175);\n    d = smin(d, ellip(p, vec3(.315, .3, .33)), .18);\n\n    p = pp;\n    pR(p.yz, -.5);\n    float bb = fBox(p, vec3(.5,.67,.7));\n    d = smax(d, bb, .2);\n\n    // face base\n    p = pp;\n    p += vec3(0,.25,-.13);\n    d = smin(d, length(p) - .28, .1);\n\n    // behind ear\n    p = ps;\n    p += vec3(-.15,.13,.06);\n    d = smin(d, ellip(p, vec3(.15,.15,.15)), .15);\n\n    p = ps;\n    p += vec3(-.07,.18,.1);\n    d = smin(d, length(p) - .2, .18);\n\n    // cheek base\n    p = pp;\n    p += vec3(-.2,.12,-.14);\n    d = smin(d, ellip(p, vec3(.15,.22,.2) * .8), .15);\n\n    // jaw base\n    p = pp;\n    p += vec3(0,.475,-.16);\n    pR(p.yz, .8);\n    d = smin(d, ellip(p, vec3(.19,.1,.2)), .1);\n    \n    // brow\n    p = pp;\n    p += vec3(0,-.0,-.18);\n    vec3 bp = p;\n    float brow = length(p) - .36;\n    p.x -= .37;\n    brow = smax(brow, dot(p, normalize(vec3(1,.2,-.2))), .2);\n    p = bp;\n    brow = smax(brow, dot(p, normalize(vec3(0,.6,1))) - .43, .25);\n    p = bp;\n    pR(p.yz, -.5);\n    float peak = -p.y - .165;\n    peak += smoothstep(.0, .2, p.x) * .01;\n    peak -= smoothstep(.12, .29, p.x) * .025;\n    brow = smax(brow, peak, .07);\n    p = bp;\n    pR(p.yz, .5);\n    brow = smax(brow, -p.y - .06, .15);\n    d = smin(d, brow, .06);\n\n    // jaw\n\n    vec3 jo = vec3(-.25,.4,-.07);\n    p = ps + jo;\n    float jaw = dot(p, normalize(vec3(1,-.2,-.05))) - .069;\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,-.25,.35))) - .13, .12);\n    jaw = smax(jaw, dot(p, normalize(vec3(-.0,-1.,-.8))) - .12, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(.98,-1.,.15))) - .13, .08);\n    jaw = smax(jaw, dot(p, normalize(vec3(.6,-.2,-.45))) - .19, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,.1,-.5))) - .26, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(1,.2,-.3))) - .22, .15);\n\n    p = pp;\n    p += vec3(0,.63,-.2);\n    pR(p.yz, .15);\n    float cr = .5;\n    jaw = smax(jaw, length(p.xy - vec2(0,cr)) - cr, .05);\n\n    p = pp + jo;\n    jaw = smax(jaw, dot(p, normalize(vec3(0,-.4,1))) - .35, .1);\n    jaw = smax(jaw, dot(p, normalize(vec3(0,1.5,2))) - .3, .2);\n    jaw = max(jaw, length(pp + vec3(0,.6,-.3)) - .7);\n\n    p = pa;\n    p += vec3(.2,.5,-.1);\n    float jb = length(p);\n    jb = smoothstep(.0, .4, jb);\n    float js = mix(0., -.005, jb);\n    jb = mix(.01, .04, jb);\n\n    d = smin(d, jaw - js, jb);\n\n    // chin\n    p = pp;\n    p += vec3(0,.585,-.395);\n    p.x *= .7;\n    d = smin(d, ellip(p, vec3(.028,.028,.028)*1.2), .15);\n\n    // nose\n    p = pp;\n    p += vec3(0,.03,-.45);\n    pR(p.yz, 3.);\n    d = smin(d, sdRoundCone(p, .008, .05, .18), .1);\n\n    p = pp;\n    p += vec3(0,.06,-.47);\n    pR(p.yz, 2.77);\n    d = smin(d, sdRoundCone(p, .005, .04, .225), .05);\n\n    // cheek\n\n    p = pp;\n    p += vec3(-.2,.2,-.28);\n    pR(p.xz, .5);\n    pR(p.yz, .4);\n    float ch = ellip(p, vec3(.1,.1,.12)*1.05);\n    d = smin(d, ch, .1);\n\n    p = pp;\n    p += vec3(-.26,.02,-.1);\n    pR(p.xz, .13);\n    pR(p.yz, .5);\n    float temple = ellip(p, vec3(.1,.1,.15));\n    temple = smax(temple, p.x - .07, .1);\n    d = smin(d, temple, .1);\n\n    p = pp;\n    p += vec3(.0,.2,-.32);\n    ch = ellip(p, vec3(.1,.08,.1));\n    d = smin(d, ch, .1);\n\n    p = pp;\n    p += vec3(-.17,.31,-.17);\n    ch = ellip(p, vec3(.1));\n    d = smin(d, ch, .1);\n\n    // mouth base\n    p = pp;\n    p += vec3(-.0,.29,-.29);\n    pR(p.yz, -.3);\n    d = smin(d, ellip(p, vec3(.13,.15,.1)), .18);\n\n    p = pp;\n    p += vec3(0,.37,-.4);\n    d = smin(d, ellip(p, vec3(.03,.03,.02) * .5), .1);\n\n    p = pp;\n    p += vec3(-.09,.37,-.31);\n    d = smin(d, ellip(p, vec3(.04)), .18);\n\n    // bottom lip\n    p = pp;\n    p += vec3(0,.455,-.455);\n    p.z += smoothstep(.0, .2, p.x) * .05;\n    float lb = mix(.035, .03, smoothstep(.05, .15, length(p)));\n    vec3 ls = vec3(.055,.028,.022) * 1.25;\n    float w = .192;\n    vec2 pl2 = vec2(p.x, length(p.yz * vec2(.79,1)));\n    float bottomlip = length(pl2 + vec2(0,w-ls.z)) - w;\n    bottomlip = smax(bottomlip, length(pl2 - vec2(0,w-ls.z)) - w, .055);\n    d = smin(d, bottomlip, lb);\n    \n    // top lip\n    p = pp;\n    p += vec3(0,.38,-.45);\n    pR(p.xz, -.3);\n    ls = vec3(.065,.03,.05);\n    w = ls.x * (-log(ls.y/ls.x) + 1.);\n    vec3 pl = p * vec3(.78,1,1);\n    float toplip = length(pl + vec3(0,w-ls.y,0)) - w;\n    toplip = smax(toplip, length(pl - vec3(0,w-ls.y,0)) - w, .065);\n    p = pp;\n    p += vec3(0,.33,-.45);\n    pR(p.yz, .7);\n    float cut;\n    cut = dot(p, normalize(vec3(.5,.25,0))) - .056;\n    float dip = smin(\n        dot(p, normalize(vec3(-.5,.5,0))) + .005,\n        dot(p, normalize(vec3(.5,.5,0))) + .005,\n        .025\n    );\n    cut = smax(cut, dip, .04);\n    cut = smax(cut, p.x - .1, .05);\n    toplip = smax(toplip, cut, .02);\n\n    d = smin(d, toplip, .07);\n\n    // seam\n    p = pp;\n    p += vec3(0,.425,-.44);\n    lb = length(p);\n    float lr = mix(.04, .02, smoothstep(.05, .12, lb));\n    pR(p.yz, .1);\n    p.y -= smoothstep(0., .03, p.x) * .002;\n    p.y += smoothstep(.03, .1, p.x) * .007;\n    p.z -= .133;\n    float seam = fDisc(p, .2);\n    seam = smax(seam, -d - .015, .01); // fix inside shape\n    d = mix(d, smax(d, -seam, lr), .65);\n\n    // nostrils base\n    p = pp;\n    p += vec3(0,.3,-.43);\n    d = smin(d, length(p) - .05, .07);\n\n    // nostrils\n    p = pp;\n    p += vec3(0,.27,-.52);\n    pR(p.yz, .2);\n    float nostrils = ellip(p, vec3(.055,.05,.06));\n\n    p = pp;\n    p += vec3(-.043,.28,-.48);\n    pR(p.xy, .15);\n    p.z *= .8;\n    nostrils = smin(nostrils, sdRoundCone(p, .042, .0, .12), .02);\n\n    d = smin(d, nostrils, .02);\n\n    p = pp;\n    p += vec3(-.033,.3,-.515);\n    pR(p.xz, .5);\n    d = smax(d, -ellip(p, vec3(.011,.03,.025)), .015);\n\n    //return d;\n\n    // eyelids\n    p = pp;\n    p += vec3(-.16,.07,-.34);\n    float eyelids = ellip(p, vec3(.08,.1,.1));\n\n    p = pp;\n    p += vec3(-.16,.09,-.35);\n    float eyelids2 = ellip(p, vec3(.09,.1,.07));\n\n    // edge top\n    p = pp;\n    p += vec3(-.173,.148,-.43);\n    p.x *= .97;\n    float et = length(p.xy) - .09;\n\n    // edge bottom\n    p = pp;\n    p += vec3(-.168,.105,-.43);\n    p.x *= .9;\n    float eb = dot(p, normalize(vec3(-.1,-1,-.2))) + .001;\n    eb = smin(eb, dot(p, normalize(vec3(-.3,-1,0))) - .006, .01);\n    eb = smax(eb, dot(p, normalize(vec3(.5,-1,-.5))) - .018, .05);\n\n    float edge = max(max(eb, et), -d);\n\n    d = smin(d, eyelids, .01);\n    d = smin(d, eyelids2, .03);\n    d = smax(d, -edge, .005);\n\n    // eyeball\n    p = pp;\n    p += vec3(-.165,.0715,-.346);\n    float eyeball = length(p) - .088;\n\tisEye = eyeball < d;\n    d = min(d, eyeball);\n\n    // tear duct\n    p = pp;\n    p += vec3(-.075,.1,-.37);\n    d = min(d, length(p) - .05);\n\n    \n \t// ear\n    p = pp;\n    p += vec3(-.405,.12,.10);\n    pR(p.xy, -.12);\n    pR(p.xz, .35);\n    pR(p.yz, -.3);\n    vec3 pe = p;\n\n    // base\n    float ear = p.s + smoothstep(-.05, .1, p.y) * .015 - .005;\n    float earback = -ear - mix(.001, .025, smoothstep(.3, -.2, p.y));\n\n    // inner\n    pR(p.xz, -.5);\n    float iear = ellip(p.zy - vec2(.01,-.03), vec2(.045,.05));\n    iear = smin(iear, length(p.zy - vec2(.04,-.09)) - .02, .09);\n    float ridge = iear;\n    iear = smin(iear, length(p.zy - vec2(.1,-.03)) - .06, .07);\n    ear = smax2(ear, -iear, .04);\n    earback = smin(earback, iear - .04, .02);\n\n    // ridge\n    p = pe;\n    pR(p.xz, .2);\n    ridge = ellip(p.zy - vec2(.01,-.03), vec2(.045,.055));\n    ridge = smin3(ridge, -pRi(p.zy, .2).x - .01, .015);\n    ridge = smax3(ridge, -ellip(p.zy - vec2(-.01,.1), vec2(.12,.08)), .02);\n\n    float ridger = .01;\n\n    ridge = max(-ridge, ridge - ridger);\n\n    ridge = smax2(ridge, abs(p.x) - ridger/2., ridger/2.);\n\n    ear = smin(ear, ridge, .045);\n\n    p = pe;\n\n    // outline\n    float outline = ellip(pRi(p.yz, .2), vec2(.12,.09));\n    outline = smin(outline, ellip(p.yz + vec2(.155,-.02), vec2(.035, .03)), .14);\n\n    // edge\n    float eedge = p.x + smoothstep(.2, -.4, p.y) * .06 - .03;\n\n    float edgeo = ellip(pRi(p.yz, .1), vec2(.095,.065));\n    edgeo = smin(edgeo, length(p.zy - vec2(0,-.1)) - .03, .1);\n    float edgeoin = smax(abs(pRi(p.zy, .15).y + .035) - .01, -p.z-.01, .01);\n    edgeo = smax(edgeo, -edgeoin, .05);\n\n    float eedent = smoothstep(-.05, .05, -p.z) * smoothstep(.06, 0., fCorner2(vec2(-p.z, p.y)));\n    eedent += smoothstep(.1, -.1, -p.z) * .2;\n    eedent += smoothstep(.1, -.1, p.y) * smoothstep(-.03, .0, p.z) * .3;\n    eedent = min(eedent, 1.);\n\n    eedge += eedent * .06;\n\n    eedge = smax(eedge, -edgeo, .01);\n    ear = smin(ear, eedge, .01);\n    ear = max(ear, earback);\n\n    ear = smax2(ear, outline, .015);\n\n    d = smin(d, ear, .015);\n\n    // targus\n    p = pp;\n    p += vec3(-.34,.2,.02);\n    d = smin2(d, ellip(p, vec3(.015,.025,.015)), .035);\n    p = pp;\n    p += vec3(-.37,.18,.03);\n    pR(p.xz, .5);\n    pR(p.yz, -.4);\n    d = smin(d, ellip(p, vec3(.01,.03,.015)), .015);\n    \n    return d;\n}\n\n/*\nhash functions\n*/\n\nuint murmurHash11(uint src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 1 input\nfloat hash11(float src) {\n    uint h = murmurHash11(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nuvec2 murmurHash22(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 2 outputs, 2 inputs\nvec2 hash22(vec2 src) {\n    uvec2 h = murmurHash22(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl3fWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[283, 283, 305, 305, 348], [350, 350, 374, 374, 799], [829, 829, 855, 855, 1119], [1121, 1121, 1142, 1142, 1349], [1351, 1351, 1408, 1439, 2821]], "test": "untested"}
{"id": "mldBD2", "name": "Binary search sqrt()", "author": "isaacchurchill", "description": "Uses binary search to approximate the square root function.", "tags": ["2d", "graph", "sqrt", "binarysearch"], "likes": 0, "viewed": 168, "published": 3, "date": "1701634397", "time_retrieved": "2024-07-30T17:18:45.359531", "image_code": "// Isaac Churchill\n// CC0 license\n\n#define MAX_ITERS 20\n#define TOLERANCE 0.001\n#define GRAPH_SCALE (2.0 + mod(iTime * 4.0, 30.0))\n\nfloat fake_sqrt(float x)\n{\n    if (x >= 0.0) {\n        // Binary search\n        float lower = 0.0;\n        float upper = max(x, 1.0);\n        float s = 0.0;\n        for (int i = 0; i < MAX_ITERS; i++) {\n            s = mix(lower, upper, 0.5);\n            float s_sqrd = s * s;\n            if (abs(s_sqrd - x) < TOLERANCE) {\n                return s;\n            } else if (s_sqrd < x) {\n                lower = s;\n            } else {\n                upper = s;\n            }\n        }\n        return s;\n    } else {\n        return 0.0;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n\n    \n    float aa_dist = 2.0 / iResolution.y;\n    const float line_thickness = 0.005;\n    float l = fract((uv.y + line_thickness) * GRAPH_SCALE);\n    float lines = smoothstep(0.0, aa_dist * GRAPH_SCALE, l)\n                  * smoothstep((line_thickness + aa_dist * 2.0) * -GRAPH_SCALE,\n                               (aa_dist + line_thickness) * -GRAPH_SCALE,\n                               -l);\n    l = fract((uv.x + line_thickness) * GRAPH_SCALE);\n    lines += smoothstep(0.0, aa_dist * GRAPH_SCALE, l)\n           * smoothstep((line_thickness + aa_dist * 2.0) * -GRAPH_SCALE,\n                               (aa_dist + line_thickness) * -GRAPH_SCALE,\n                        -l);\n    lines = min(lines, 1.0);\n    vec3 col = vec3(lines * 0.3);\n    \n    float s = fake_sqrt(uv.x * GRAPH_SCALE);\n    float d = abs(s - uv.y * GRAPH_SCALE);\n    float plotline_thickness = 0.002;\n    float plot = smoothstep((plotline_thickness + aa_dist * 2.0) * -GRAPH_SCALE,\n                     plotline_thickness * -GRAPH_SCALE, -d);\n    col = mix(col, vec3(1.0, 0.0, 0.0), plot);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mldBD2.jpg", "access": "api", "license": "cc0-1.0", "functions": [[132, 132, 158, 158, 676], [678, 678, 735, 735, 1877]], "test": "untested"}
{"id": "mltBD2", "name": "Shattered circles", "author": "ahsan2649", "description": "A mix of wavy lines breaking up concentric circles making for a nice trippy outline effect. My first foray into shader coding!", "tags": ["2d", "circle", "outlines"], "likes": 3, "viewed": 225, "published": 3, "date": "1701632994", "time_retrieved": "2024-07-30T17:18:49.128455", "image_code": "mat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    uv = rotate2d(iTime*0.5) * uv;\n    float waves1 = sin(uv.x * -7. + sin(uv.y * 7.1) + iTime * 1.5);\n \n    float waves2 = sin(uv.y * 5. + cos(uv.x * -3.9) + iTime * 5.5);\n    float circles = length(uv) - 0.5;\n    circles = sin(circles * 11. + iTime*2.);\n    circles = abs(circles);\n    circles = smoothstep(0.002,1.,circles);\n    circles = 0.05/circles;\n    circles = pow(circles, 0.95);\n    float d = (waves1 + (waves2)) * circles;\n    \n\n    // Output to screen\n    fragColor = vec4(vec3(d,d,d),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mltBD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 118], [120, 120, 177, 227, 804]], "test": "untested"}
{"id": "DldfWj", "name": "Anime Speed Lines", "author": "Peace", "description": "Anime speed lines", "tags": ["lines", "speed", "anime"], "likes": 22, "viewed": 499, "published": 3, "date": "1701614014", "time_retrieved": "2024-07-30T17:18:51.186950", "image_code": "// Modified From: https://www.shadertoy.com/view/WtfXRj\n\nfloat rand(vec2 p) { return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123); }\n\nfloat noise(vec2 p) \n{\n    vec2 i = floor(p); \n    vec2 f = fract(p);\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    float a = rand(i + vec2(0, 0));\n\tfloat b = rand(i + vec2(1, 0));\n\tfloat c = rand(i + vec2(0, 1));\n\tfloat d = rand(i + vec2(1, 1));\n    return float(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y)/4.;\n}\n\nfloat mirror(float t, float r) \n{\n    t = fract(t+r);\n    return 2.*abs(t-0.5);\n}\n\nfloat radialNoise(float t, float d)\n{\n    const mat2 m2 = mat2(0.90,0.44,-0.44,0.90);\n    const float SCALE = 45.;\n    d = pow(d, 0.01);\n    float doff = -iTime*0.07;\n    vec2 p = vec2(mirror(t,0.1),d+doff);\n    float f1 = noise(p * SCALE);\n    p = 2.1*vec2(mirror(t,0.4),d+doff);\n    float f2 = noise(p * SCALE);\n    p = 3.7*vec2(mirror(t,0.8),d+doff);\n    float f3 = noise(p * SCALE);\n    p = 5.8*vec2(mirror(t,0.0),d+doff);\n    float f4 = noise(p * SCALE);\n    return pow((f1+0.5*f2+0.25*f3+0.125*f4)*3., 1.);\n}\n\nvec3 colorize(float x)\n{\n    x = clamp(x,0.0,1.0);\n    vec3 c = mix(vec3(0,0,1.1), vec3(0,1,1), x);\n    c = mix(c, vec3(1,1,1), x*4.-3.0) * x;\n    c = max(c, vec3(0));\n    c = mix(c, vec3(1, .25, 1), smoothstep(1.0, 0.2, x) * smoothstep(0.15, 0.9, x));\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y * 0.5;\n    float d = dot(uv, uv);\n    float t = atan(uv.y, uv.x) / 6.28318530718;\n    float v = radialNoise(t, d);\n    v = v * 2.5 - 1.4;\n    v = mix(0., v, .8 * smoothstep(0.0, 0.8, d));\n    fragColor.rgb = colorize(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DldfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 77, 77, 138], [140, 140, 162, 162, 436], [438, 438, 471, 471, 519], [521, 521, 558, 558, 1035], [1037, 1037, 1061, 1061, 1305], [1307, 1307, 1361, 1361, 1648]], "test": "untested"}
{"id": "dt3BD2", "name": "don't know", "author": "anmol", "description": "something something I made", "tags": ["somethingsomething"], "likes": 0, "viewed": 45, "published": 3, "date": "1701604575", "time_retrieved": "2024-07-30T17:18:52.214204", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy * 2.0) - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    // vec2 col = 0.5 * length(uv) *  sin(iTime * -uv.xy);\n    // vec2 col = length(uv * sin(iTime * 2.0)) * tan(uv.yx * iTime);\n    vec2 col = fract(sin(uv.xy * iTime * 0.5) * cos(uv.yx * iTime * 0.5)) * length(uv);\n    for(float i = 0.0; i < 2.0; i++){\n        col += abs(length(uv) * i  / iTime);\n    }\n    fragColor = vec4(col,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt3BD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 663]], "test": "untested"}
{"id": "mlcfW2", "name": "Acid blossom visualizer (Sound!)", "author": "Forthro", "description": "Simple trigonometry-based visualizer", "tags": ["sound", "music", "abstract", "visualizer", "trigonometry"], "likes": 3, "viewed": 324, "published": 3, "date": "1701604356", "time_retrieved": "2024-07-30T17:18:53.142722", "image_code": "const float segmentsNumVariants[] = float[](1.0, 3.0, 7.0, 11.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 centerCoord = iResolution.xy / 2.0; /*iMouse.xy*/\n\n    float normalDist = distance( fragCoord.xy, centerCoord )\n                     / ( sqrt( 2.0 * iResolution.x * iResolution.x ) * 1.25);\n    float reverseNormalDist = 1.0 - normalDist;\n    vec2 normalCoord = normalize( fragCoord.xy - centerCoord );\n    \n    float sound = texture( iChannel0, vec2( cos( normalDist ), 0.25 )).r \n                + texture( iChannel0, vec2( sin( normalDist ), 0.25 )).r;\n                \n    float segmentsNum = segmentsNumVariants[ int( floor( sound * 2.0 + normalDist )) ];\n                \n    float radialWave = 0.5 + cos( atan( normalCoord.x, normalCoord.y ) * segmentsNum + iTime * 3.0 + cos( sound * 10.0 ) * sound );\n    \n    float shiftedTime = iTime - ( normalDist * 7.0 ) \n                      + radialWave * sin( pow( reverseNormalDist, reverseNormalDist ) * 50.0 + iTime + sound * sound * 2.0 );\n    \n    float waveModulator = 0.35 + sin( normalDist * 20.0 - shiftedTime * 4.0 ) * sound;\n    \n    float red = ( 0.25 + cos( shiftedTime + sound * 4.0) / 2.5 ) * waveModulator;\n    float green = 0.75 * waveModulator * ( 0.5 + sin(sound * 7.0 ) / 2.0 );\n    float blue = ( 0.25 + sin( shiftedTime + sound * 4.0 ) / 2.5 ) * waveModulator;\n    \n    fragColor = vec4( red, green, blue, 1.0 );\n}", "image_inputs": [{"id": 35431, "src": "https://soundcloud.com/flux-pavilion/never-see-the-light-feat-andrea-martin?in=flux-pavilion/sets/flux-pavilion-tesla", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlcfW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 124, 124, 1420]], "test": "untested"}
{"id": "dl3fW2", "name": "Towers and Domes", "author": "dr2", "description": "Includes traversal and external views; also cross sections and pano view.\nLots of domes, arches, buttresses, columns, bridges, reflections, ogives.", "tags": ["architecture"], "likes": 12, "viewed": 246, "published": 3, "date": "1701601187", "time_retrieved": "2024-07-30T17:18:54.246770", "image_code": "#define O177 min(O224,0)\n#define O527(x)(sin((x)+vec2(0.5*O689,0.)))\n#define O620 O589(O627,O682);\n#define O899(O705){O620 if(O682<O868){O868=O682; O077=O705; O844=O813;}}\n#define O379 4\n\nvec4 O371,O511;vec3 O743,O844,O651,O487,O394;float O867,O054,O580,O611,O549,O248,O999,O247[3],O596[3];int O224,O077,O806;const int O767=1,O984=2,O015=3,O418=4,O449=5,O891=6,O922=7,O829=8,O387=9,O356=10,O201=11,O232=12,O263=13,O294=14,O139=15,O325=16,O860=17,O953=18,O046=19,O798=20,O170=21,O736=22;const float O689=3.1415927;const int O286=17;struct O751{vec2 O976[O286];ivec2 O217[O286];float O898[O286+1],O216[6],O093[7];};O751 O720;float O945(vec2 O627){return min(O627.x,O627.y);}float O852(vec2 O627){return max(O627.x,O627.y);}float O883(vec3 O627){return max(O627.x,max(O627.y,O627.z));}float O588(float O759,float O674,float O673,float O704){return(1.-smoothstep(O674-O673,O674+O673,O704))*smoothstep(O759-O673,O759+O673,O704);}mat3 O712(vec2 O208){vec2 O310,O340;O310=cos(O208);O340=sin(O208);return mat3(O310.x,0.,-O340.x,0.,1.,0.,O340.x,0.,O310.x)*mat3(1.,0.,0.,0.,O310.y,-O340.y,0.,O340.y,O310.y);}vec2 O185(vec2 O813,float O031){vec2 O558;O558=sin(O031+vec2(0.5*O689,0.));return vec2(dot(O813,vec2(O558.x,-O558.y)),dot(O813.yx,O558));}vec2 O154(vec2 O813,vec2 O558){return vec2(dot(O813,O558*vec2(1.,-1.)),dot(O813.yx,O558));}const float O372=43758.54;float O581(vec2 O627){return fract(sin(mod(dot(O627,vec2(37.,39.)),2.*O689))*O372);}vec2 O612(float O627){return fract(sin(mod(O627+vec2(0.,1.),2.*O689))*O372);}vec2 O643(vec2 O627){vec2 O403=vec2(37.,39.);return fract(sin(mod(dot(O627,O403)+vec2(0.,O403.x),2.*O689))*O372);}float O317(float O627){vec2 O805;float O542,O457;O542=floor(O627);O457=fract(O627);O457=O457*O457*(3.-2.*O457);O805=O612(O542);return mix(O805.x,O805.y,O457);}float O348(vec2 O627){vec2 O805,O542,O457;O542=floor(O627);O457=fract(O627);O457=O457*O457*(3.-2.*O457);O805=mix(O643(O542),O643(O542+vec2(0.,1.)),O457.y);return mix(O805.x,O805.y,O457.x);}float O271(float O627){float O240,O550;O240=0.;O550=1.;for(int O666=0;O666<5;O666++){O240+=O550*O317(O627);O550*=0.5;O627*=2.;}return O240*(1./1.9375);}float O302(vec2 O627){float O240,O550;O240=0.;O550=1.;for(int O666=0;O666<5;O666++){O240+=O550*O348(O627);O550*=0.5;O627*=2.;}return O240*(1./1.9375);}float O333(vec3 O627,vec3 O131){vec3 O309;float O550;O309=vec3(0.);O550=1.;for(int O666=0;O666<5;O666++){O309+=O550*vec3(O348(O627.yz),O348(O627.zx),O348(O627.xy));O550*=0.5;O627*=2.;}return dot(O309,abs(O131));}vec3 O146(vec3 O627,vec3 O131,float O240){vec4 O115;vec3 O550;vec2 O209=vec2(0.1,0.);for(int O666=O177;O666<4;O666++)O115[O666]=O333(O627+((O666<2)?((O666==0)?O209.xyy:O209.yxy):((O666==2)?O209.yyx:O209.yyy)),O131);O550=O115.xyz-O115.w;return normalize(O131+O240*(O550-O131*dot(O131,O550)));}void O589(vec3 O627,inout float O682){if(O806>0)O682=max(O682,dot(O627,O651));}\nfloat O441(vec3 O627){vec3 O813,O875,O906,O937,O968;float O868,O682,O092,O031,O278,O642,O681,O992,O147,O565,O782,O178,O961,O930;O565=0.07*O580;O868=O054;O092=length(O627.xz);O782=O627.y;O031=(O092>0.)?atan(O627.z,-O627.x)/(2.*O689):0.;O875=O627;O875.xz=O185(O875.xz,2.*O689*(floor(6.*O031)+0.5)/6.);O906=O875;O906.xz=O185(vec2(O906.x,abs(O906.z)),O689/12.);O937=O906;O937.xz=O185(vec2(O937.x,abs(O937.z)),O689/12.);O968=O875;O968.xz=O185(vec2(O968.x,abs(O968.z)),O689/6.);O642=1.5;O681=sqrt(O642*O642-1.);O371.xy=vec2(0.45*O580,0.5*O549);O371.zw=vec2(O371.y-O681*O371.x,O642*O371.x);O961=O642*O580;O930=O549-O681*O580;O147=length(vec2(O092,O782-O930))-O961;O511.z=length(vec2(abs(O875.z)+0.15,max(O782-0.3,0.)))-0.3;O813=O875;O813.x+=O580;O278=length(O813.xz);O511.x=max(O278-O371.x,length(vec2(O278,O782-O371.z))-O371.w);O682=max(max(abs(O511.x)-O611,-max(O092-O580,length(vec2(O092,O782-O930))-O961)-O611+0.001),-O511.z);O682=max(O682,-max(length(vec2(abs(O185(vec2(O813.x,abs(O813.z)),O689/24.).y)+0.13,max(O782-0.75,0.)))-0.2,0.65-O782));O682=max(max(O682,-max(length(vec2(abs(O813.x)+0.12,max(O782-0.7,0.)))-0.2,0.6-O782)),0.02-O782);O899(O418);O682=max(max(max(abs(O511.z)-0.018,abs(O092-1.35*O580)-0.35*O580),O371.x-O278-O611),0.02-O782);O899(O891);O813=O937;O813.xy-=vec2(0.15-O580,1.43);O682=length(O813)-0.04;O899(O953);O813=O627;O511.y=max(O092-O580,O147);O178=max(max(-O511.x-O611,O565+0.01-O092),0.02-O782);O682=max(max(abs(O511.y)-O611,-max(length(vec2(abs(O906.z)+0.1,max(O782-O549+0.25,0.)))-0.2,O549-0.4-O782)),O178);O899(O984);O682=max(length(vec2(abs(max(O092-O580,O147))-O611,O937.z))-0.03,O178);O899(O015);O682=min(max(min(O092-O580,O278-O371.x),abs(O782-0.04)-0.02),max(max(O092-1.69*O580,abs(O875.z)-0.15),abs(O782-0.025)-0.015));O899(O922);O813=O627;O682=max(O092-0.04,abs(O782-0.5*O999)-0.5*O999);O899(O170);O813.y=O782-O999;O682=length(O813)-0.1;O899(O736);O813=O875;O813.y=O782-O930-O961+0.13;O511.w=length(vec2(O092+0.1,max(O813.y-0.43,0.)))-O565-0.12;O682=max(max(abs(O511.w)-0.02,-O813.y),-max(length(vec2(abs(O813.z)+0.1,max(O813.y-0.48,0.)))-0.15,0.28-O813.y));O899(O449);O813.xz=O627.xz;O813.y-=0.58;O682=length(O813)-0.05;O899(O953);O813=O968;O682=max(abs(abs(O813.z)-0.08)-0.03,max(O813.x+O580,0.01-O782));O813.xy-=vec2(0.5-O580,-0.2);O682=max(O682,abs(length(O813.xy)-O549-0.12)-0.08);O899(O860);O813=O968;O682=max(abs(abs(O813.z)-0.05)-0.015,max(O565+0.02-O092,1.3-O813.y));O813.xy-=vec2(0.15,0.75);O682=max(O682,abs(length(O813.xy)-1.95)-0.04);O899(O829);O813=O968;O813.xy-=vec2(-O247[1],2.22);O682=length(O813)-0.05;O899(O953);O813=O906;O992=abs(O092-O247[0])-0.06;O682=max(O992,abs(O782-1.39)-0.2);O813.y=O782-1.2;O682=max(O682,0.3-length(O813.yz));O899(O387);O813.xz=O627.xz;O682=max(O992-0.01,abs(O782-1.6)-0.01);O899(O356);O813=O906;O992=abs(O092-O247[0]-0.02)-0.03;O813.yz=vec2(O782-1.6,abs(O906.z)+0.2);O682=max(O992,max(abs(length(O813.yz)-O596[0])-0.03,-O813.y));O899(O201);O813.xz=O627.xz;O682=max(O992-0.01,max(O147,2.17-O782));O899(O356);O682=max(length(vec2(O782-1.5,O937.z))-0.05,max(O092-O580,O247[0]+0.02-O092));O813.y=O782-0.08;O682=min(O682,max(O092-0.12,abs(O813.y)-0.03));O899(O325);O813=O937;O813.x+=O247[2];O682=max(length(O813.xz)-0.02,abs(O782-0.46)-0.38);O899(O139);O992=abs(O092-O247[2])-0.02;O813.y=O782-0.46;O682=max(O992,abs(abs(O813.y)-0.385))-0.01;O899(O325);O813.yz=vec2(O782-0.86,abs(O906.z)+0.06);O682=max(abs(O092-O247[2])-0.03,max(abs(length(O813.yz)-O596[2])-0.015,-O813.y));O899(O263);O813.xz=O627.xz;O682=max(O992-0.01,abs(O813.y-0.14)-0.01);O899(O356);O813=O937;O813.x+=O247[1];O682=max(length(O813.xz)-0.025,abs(O782-0.66)-0.58);O899(O139);O992=abs(O092-O247[1])-0.025;O813.y=O782-0.66;O682=max(O992,abs(abs(O813.y)-0.585))-0.01;O899(O325);O813.yz=vec2(O782-1.26,abs(O906.z)+0.1);O682=max(abs(O092-O247[1])-0.04,max(abs(length(O813.yz)-O596[1])-0.018,-O813.y));O899(O232);O813.xz=O627.xz;O682=max(O992-0.01,abs(O813.y-0.33)-0.013);O899(O356);O813=O937;O813.x+=O247[0];O813.xz=abs(O813.xz)-0.04;O682=max(length(O813.xz)-0.025,abs(O782-0.63)-0.55);O899(O139);O813.y=O782-0.63;O682=max(abs(O092-O247[0])-0.07,abs(abs(O813.y)-0.56)-0.02);O899(O325);O813=O937;O813.xy-=vec2(-O247[1],0.64);O682=max(max(abs(length(O813.xy)-0.6)-0.012,abs(O813.z)-0.025),max(0.195-O813.y,-O813.x));O899(O294);O813=O937;O813.xy-=vec2(-O247[0],0.75);O682=max(max(abs(length(O813.xy)-0.83)-0.02,abs(O813.z)-0.03),max(0.485-O813.y,-O813.x));O899(O294);O813=O906;O813.x+=2.2*O580;O278=length(O813.xz);O682=abs(length(vec2(O278+0.1,max(O782-1.2*O549,0.))))-0.09*O580;O682=min(O682,max(O278-0.07*O580,abs(O782-O549)-0.1));O682=min(O682,max(O278-0.12*O580,abs(O782-0.03)-0.03));O682=max(O682,0.01-O782);O899(O046);O813=O627;O682=max(min(min(O092-2.*O580,O278-0.3*O580),abs(O092-3.05*O580)-0.13*O580),abs(O782-0.01)-0.01);O899(O767);O813=O875;O813.x+=O248;O278=length(vec2(O813.x,O813.y+2.3))-2.5;O682=min(max(abs(O278)-0.03,abs(O813.z)-0.2),length(vec2(O278-0.2,abs(O813.z)-0.18))-0.01);O682=max(min(O682,max(length(vec2(0.1*(fract(O813.x/0.1+0.5)-0.5),abs(O813.z)-0.18))-0.008,abs(O278-0.1)-0.1)),-O782);O682=max(O682,abs(O813.x)-1.05);O899(O798);return O868;}\nfloat O503(vec3 O123,vec3 O030){float O775,O682;O775=0.;for(int O666=O177;O666<120;O666++){O682=O441(O123+O775*O030);if(O682<0.0002||O775>O054)break;O775+=O682;}return O775;}vec3 O472(vec3 O627){vec4 O115;vec2 O209;O209=1e-4*vec2(1.,-1.);for(int O666=O177;O666<4;O666++){O115[O666]=O441(O627+((O666<2)?((O666==0)?O209.xxx:O209.xyy):((O666==2)?O209.yxy:O209.yyx)));}O115.x=-O115.x;return normalize(2.*O115.yzw-dot(O115,vec4(1.)));}float O534(vec3 O123,vec3 O030){float O464,O682,O550;int O108;O108=O077;O464=1.;O682=0.02;for(int O666=O177;O666<24;O666++){O550=O441(O123+O682*O030);O464=min(O464,smoothstep(0.,0.07*O682,O550));O682+=max(O550,0.01);if(O464<0.05||O682>O054)break;}O077=O108;return 0.6+0.4*O464;}float O619(vec3 O115,float O131){vec4 O550;vec3 O270;vec2 O395,O279;float O658,O426,O744,O031,O766,O255;O658=1.618034;O255=1./O131;O426=pow(O658,max(2.,floor(log(O131*O689*sqrt(5.)*dot(O115.xy,O115.xy))/log(O658+1.))))/sqrt(5.);O395=vec2(floor(O426+0.5),floor(O426*O658+0.5));O550=vec4(O395*O255,O689*(fract((O395+1.)*O658)-(O658-1.)));O279=floor((0.5*mat2(O550.y,-O550.x,O550.w,-O550.z)/(O550.y*O550.z-O550.x*O550.w))*vec2(atan(O115.y,O115.x),O115.z-(1.-O255)));O744=4.1;for(int O666=O177;O666<4;O666++){O031=dot(O395,vec2(O666-2*(O666/2),O666/2)+O279);O766=1.-(2.*O031+1.)*O255;O270=vec3(sin(2.*O689*fract(O658*O031)+vec2(0.5*O689,0.))*sqrt(1.-O766*O766),O766);O744=min(O744,dot(O270-O115,O270-O115));}return sqrt(O744);}vec4 O410(out vec2 O270){vec4 O496;vec2 O062,O991;float O031,O278,O309,O774;O496=vec4(0.);O270=vec2(0.);O062=vec2(0.);if(O077==O922||O077==O767){O278=length(O844.xz);O062=O844.zx;}else if(O077==O387||O077==O201||O077==O263||O077==O232){O062=O844.yz;}else if(O077==O294||O077==O829||O077==O860){O062=O844.yx;}else if(O077==O984||O077==O418||O077==O356){O062=O844.zx;}if(O062!=vec2(0.))O031=atan(O062.x,-O062.y)/(2.*O689);if(O077==O984||O077==O418||O077==O891)O774=0.5*step(0.5,fract(4.*O844.y+0.25));if(O077<=O922){if(O077==O767){O496=vec4(0.5,0.5,0.5,0.);if(O278<2.*O580)O496*=0.9+0.1*step(0.05,min(fract(16.*O278),fract(128.*O031+0.5*step(0.5,mod(floor(16.*O278),2.)))));}else if(O077==O984){if(O511.y>0.){if(O844.y>O549+0.01){O496=vec4(0.8,0.8,0.6,0.05);}else{O991=abs(fract(vec2(8.*O844.y+0.5,60.*O031+O774)));O496=vec4(0.8,0.8,0.9,0.05)*(0.93+0.07*smoothstep(0.01,0.05,O945(O991)));}}else{O496=(O844.y>O549+0.01)?vec4(0.1,0.1,1.,0.):vec4(0.8,0.8,0.8,0.);}}else if(O077==O015){O496=vec4(0.9,0.9,0.9,0.05);}else if(O077==O418){if(O511.x>0.){if(O844.y>O371.y+0.01){O496=vec4(0.8,0.8,0.6,0.05);if(O844.y>O371.y&&length(vec2(length(O844.xz),O844.y-O371.z))>O371.w)O496*=0.7+0.3*smoothstep(0.,0.01,min(abs(length(vec2(abs(O844.x+0.5)+0.2,O844.z))-0.3)-0.02,length(vec2(O844.x+0.5,O844.z))-0.05));}else{O991=abs(fract(vec2(8.*O844.y+0.5,30.*O031+O774)));O496=vec4(0.8,0.9,0.8,0.05)*(0.93+0.07*smoothstep(0.01,0.05,O945(O991)));}}else{O496=(O844.y<O371.y-0.02)?vec4(0.8,0.8,0.8,0.)*(0.93+0.07*smoothstep(0.01,0.05,abs(fract(30.*O031)))):vec4(0.1,0.1,1.,0.);}}else if(O077==O449){if(O511.w>0.&&O844.y>0.1)O496=vec4(0.8,0.4,0.2,0.2);else O496=vec4(0.8,0.8,0.8,0.);}else if(O077==O891){if(O511.z<0.&&length(O844.xz)<1.39){O496=vec4(0.8,0.8,0.8,0.)*(0.93+0.07*smoothstep(0.03,0.035,abs(fract(16.*O844.x+0.5))));}else{O991=abs(fract(vec2(8.*O844.y+0.5,8.*O844.x+O774)));O496=vec4(0.8,0.9,0.8,0.05)*(0.93+0.07*smoothstep(0.01,0.05,O945(O991)));}}else if(O077==O922){O496=vec4(0.5,0.7,0.9,0.1)*(0.8+0.2*step(0.05,min(fract(32.*O278),fract(((O278>O247[1])?((O278>O247[0])?256.:128.):((O278>O247[2])?64.:32.))*O031+0.5*step(0.5,mod(floor(32.*O278),2.))))));}}else if(O077<=O139){if(O077==O829){O496=vec4(0.8,0.7,0.8,0.1)*(0.8+0.2*step(0.1,fract(128.*O031)));}else if(O077==O387){O496=vec4(0.7,0.8,0.6,0.1);if(length(O844.yz)<0.35)O496*=0.6+0.4*step(0.5,fract(31.*O031));}else if(O077==O356){O496=vec4(0.8,0.7,0.6,0.1)*(0.6+0.4*step(0.5,fract(128.*O031)));}else if(O077==O201){O309=length(O844.yz)-O596[0];O496=vec4(0.8,0.7,0.6,0.1)*(1.-0.4*step(0.001,abs(O309))*step(0.5,fract(63.*O031+0.25*sign(O309))));}else if(O077==O232){O309=length(O844.yz)-O596[1];O496=vec4(0.8,0.7,0.6,0.1)*(1.-0.4*step(0.001,abs(O309))*step(0.5,fract(47.*O031+0.25*sign(O309))));}else if(O077==O263){O309=length(O844.yz)-O596[2];O496=vec4(0.8,0.7,0.6,0.1)*(1.-0.4*step(0.001,abs(O309))*step(0.5,fract(31.*O031+0.25*sign(O309))));}else if(O077==O294){O496=vec4(0.8,0.7,0.6,0.1)*(0.6+0.4*step(0.5,fract(128.*O031)));}else if(O077==O139){O496=vec4(0.6,0.6,0.7,0.1);}}else{if(O077==O325){O496=(O844.y>0.)?vec4(0.6,0.6,0.7,0.1):vec4(0.4,0.6,0.8,0.1);}else if(O077==O860){O496=vec4(0.8,0.7,0.8,0.1)*(0.8+0.2*step(0.1,fract(128.*O031)));}else if(O077==O953){O496=vec4(0.9,0.9,0.7,-1.);}else if(O077==O170){O496=vec4(0.2,0.6,0.2,-1.);}else if(O077==O736){O496=vec4(0.5,0.5,0.4,-1.);}else if(O077==O046){O496=vec4(0.8,0.7,0.6,0.1);}else if(O077==O798){O496=vec4(0.5,0.3,0.1,0.);}}if(O077!=O953&&O077!=O449&&O077!=O170)O270=vec2(256.,0.3);if((O077==O984||O077==O418)&&O496==vec4(0.1,0.1,1.,0.)){if(O619(normalize(O844),((O077==O418)?1024.:2048.))<0.005)O496=vec4(1.,1.,0.,-1.);}return O496;}\nvec3 O557(vec3 O123,vec3 O030){vec3 O465,O434,O526;vec2 O813;float O240,O364,O395,O402;if(O030.y>-0.02&&O030.y<0.03*O271(16.*atan(O030.z,-O030.x))){O465=vec3(0.3,0.4,0.5);}else{O813=0.01*(O123.xz+2.*O867+((100.-O123.y)/O030.y)*O030.xz);O395=O302(O813);O240=smoothstep(0.2,0.8,O395);O364=smoothstep(0.2,0.8,O302(O813+0.01*O743.xz))-O240;O434=(0.7+0.5*O395)*(vec3(0.7)-0.7*vec3(0.3,0.3,0.2)*sign(O364)*smoothstep(0.,0.05,abs(O364)));O402=max(dot(O030,O743),0.);O526=vec3(0.3,0.4,0.8)+step(0.1,O402)*vec3(1.,1.,0.9)*min(0.3*pow(O402,64.)+0.5*pow(O402,2048.),1.);O465=mix(O526,O434,0.1+0.9*O240*smoothstep(0.01,0.1,O030.y));}return O465;}vec4 O155(vec3 O123,vec3 O030,vec3 O627,float O278){vec3 O115,O301;float O550,O682,O309;O115=O123-O627;O550=dot(O030,O115);O309=O550*O550+O278*O278-dot(O115,O115);O682=O054;if(O309>0.){O682=-O550-sqrt(O309);O301=(O115+O682*O030)/O278;}return vec4(O682,O301);}float O929(vec2 O627){vec2 O363;float O836,O992,O147,O837;int O728;O837=O054;O728=0;for(int O821=O177;O821<180;O821++){O836=float(O821)/180.;for(int O697=O728;O697<O286;O697++){if(O836<O720.O898[O697+1]){O728=O697;break;}}O147=(O836-O720.O898[O728])/(O720.O898[O728+1]-O720.O898[O728]);O992=O720.O093[O720.O217[O728+1].y]-O720.O093[O720.O217[O728].y];O363=(O992==0.)?O720.O976[O728]+O147*(O720.O976[O728+1]-O720.O976[O728]):O185(vec2(0.,O720.O216[O720.O217[O728].x]),(O689/12.)*(O720.O093[O720.O217[O728].y]+O147*O992));O837=min(O837,length(O627-O363));}if(length(O627-O487.xz)<0.1)O837*=-1.;return O837;}vec3 O495(vec3 O123,vec3 O030){vec4 O496,O713;vec3 O790,O465,O301,O332,O309;vec2 O270;float O116,O085,O023,O464,O031,O186,O193;bool O480,O573,O635;O085=O054;O464=1.;O573=false;O480=false;O635=false;O713=O155(O123,O030,vec3(0.,O999,0.),0.15);O023=(O713.x>0.)?O713.x:O054;for(int O697=O177;O697<2;O697++){O116=O503(O123,O030);if(O697==0&&O806==0){if(O023<min(O116,O054)){O123+=O023*O030;O301=O713.yzw;O635=true;}else if(O116>=O054&&O030.y<0.){O309=O123+(-O123.y/O030.y)*O030;O186=length(O309.xz);if(O186<3.*O580){O123=O309;O301=normalize(vec3(0.01*O185(O123.xz/O186,O689*(0.5+0.2*fract(4.*O186-O867))),1.)).xzy;O301=O146(8.*O123+0.2*O867,O301,0.1);O635=true;}}if(O635){O030=reflect(O030,O301);O123+=0.01*O030;}}if(!O635)break;}if(O116<O054){O123+=O116*O030;O301=O472(O123);O480=((O077==O922||O077==O891&&O511.z<0.)&&length(O123.xz)<1.69*O580||O077>=O829&&O077<=O325||O077==O418&&O511.x<0.||(O077==O984||O077==O015)&&O511.y<0.||O077==O449&&(O511.w<0.||O844.y<0.1));O496=O410(O270);if(O077==O922&&O301.y<0.99)O496.rgb*=0.6;if(O077==O139||O077==O170||O077==O046){O031=fract(16.*(atan(O844.z,-O844.x)/(2.*O689)+0.5));O301.xz=O185(O301.xz,-0.15*O689*sin(O689*O031*O031));}if(O123.y<0.5&&O301.y>0.5){O186=O929(O123.xz);if(abs(O186)<0.007)O496=(O186>0.)?vec4(1.,1.,0.,-1.):vec4(1.,0.,0.,-1.);}}else if(O030.y<0.&&O806==0){O085=-O123.y/O030.y;O123+=O085*O030;O301=vec3(0.,1.,0.);O270=vec2(16.,1.-smoothstep(0.5,0.8,O085/O054));O496=vec4(0.5*mix(vec3(0.8,1.,0.5),vec3(0.7,0.9,0.5),0.2+0.8*smoothstep(0.3,0.7,O302(4.*O123.xz))),0.05);}else{O573=true;O465=(O806==0)?O557(O123,O030):vec3(0.3,0.4,0.5)*(0.7+0.3*O030.y);}if(!O573){if(O496.a>=0.){O332=O301;if(O270.y>0.)O301=O146(O270.x*O123,O301,O270.y);if(!O480){O464=O534(O123+0.01*O301,O743);O465=O496.rgb*(0.2+0.2*max(-dot(O301,O743),0.)+0.8*O464*max(dot(O301,O743),0.))+O496.a*step(0.95,O464)*pow(max(dot(reflect(O743,O301),O030),0.),32.);if(O116>=O054)O465=mix(O465,vec3(0.3,0.4,0.5),pow(1.+O030.y,16.));}else{float O279;O279=0.05+0.1*max(dot(normalize(vec3(O123.xz,0.).xzy),O301),0.);for(int O697=0;O697<5;O697++){O193=dot(normalize(vec3(0.,0.2*float(O697+1)*O549,0.)-O123),O301);O279+=0.07*max(O193,0.)+0.12*max(-O193,0.);}O279+=0.12*max(-O301.y,0.);if(O077==O891&&length(O123.xz)>1.435*O580)O279+=0.1+0.2*smoothstep(0.8,0.85,-O332.y);O465=O496.rgb*O279;}}else{O465=O496.rgb*(0.55-0.45*dot(O030,O301));}}if(O635)O465*=0.9;return clamp(O465,0.,1.);}void O433(){float O992,O147;O611=0.03;O580=2.;O549=2.;O247[0]=0.85*O580;O247[1]=0.5*O580;O247[2]=0.2*O580;O248=2.46*O580;O596[0]=0.6;O596[1]=0.33;O596[2]=0.14;O720.O216[0]=O248+1.2;O720.O216[1]=O248-1.2;O720.O216[2]=O247[0]+0.2;O720.O216[3]=0.5*(O247[0]+O247[1]);O720.O216[4]=0.6*O247[1]+0.4*O247[2];O720.O216[5]=0.75*O247[2];O720.O093[0]=0.;O720.O093[1]=3.;O720.O093[2]=5.;O720.O093[3]=11.;O720.O093[4]=17.;O720.O093[5]=20.;O720.O093[6]=24.;O720.O217[0]=ivec2(0,0);O720.O217[1]=ivec2(1,0);O720.O217[2]=ivec2(2,0);O720.O217[3]=ivec2(2,1);O720.O217[4]=ivec2(3,1);O720.O217[5]=ivec2(4,1);O720.O217[6]=ivec2(4,2);O720.O217[7]=ivec2(5,2);O720.O217[8]=ivec2(5,3);O720.O217[9]=ivec2(4,3);O720.O217[10]=ivec2(4,4);O720.O217[11]=ivec2(3,4);O720.O217[12]=ivec2(2,4);O720.O217[13]=ivec2(2,5);O720.O217[14]=ivec2(1,5);O720.O217[15]=ivec2(0,5);O720.O217[16]=ivec2(0,6);for(int O697=0;O697<O286;O697++)O720.O976[O697]=O185(vec2(0.,O720.O216[O720.O217[O697].x]),(O689/12.)*O720.O093[O720.O217[O697].y]);O720.O898[0]=0.;for(int O697=0;O697<O286;O697++){O992=O720.O093[O720.O217[O697+1].y]-O720.O093[O720.O217[O697].y];O720.O898[O697+1]=O720.O898[O697]+((O992==0.)?abs(O720.O216[O720.O217[O697+1].x]-O720.O216[O720.O217[O697].x]):(O689/12.)*O720.O216[O720.O217[O697].x]*abs(O992));}for(int O697=0;O697<O286;O697++)O720.O898[O697+1]/=O720.O898[O286];}\nvoid O518(float O805){vec3 O363[2];float O836,O992,O147,O309;int O728;for(int O666=0;O666<2;O666++){O836=fract(O805+0.005*float(O666));for(int O697=0;O697<O286;O697++){if(O836<O720.O898[O697+1]){O728=O697;break;}}O147=(O836-O720.O898[O728])/(O720.O898[O728+1]-O720.O898[O728]);O992=O720.O093[O720.O217[O728+1].y]-O720.O093[O720.O217[O728].y];O363[O666].xz=(O992==0.)?O720.O976[O728]+O147*(O720.O976[O728+1]-O720.O976[O728]):O185(vec2(0.,O720.O216[O720.O217[O728].x]),(O689/12.)*(O720.O093[O720.O217[O728].y]+O147*O992));O363[O666].y=0.2;if(O728==3||O728==O286-7)O363[O666].y+=0.9*smoothstep(0.1,0.5,O147);else if(O728==4||O728==O286-6)O363[O666].y+=0.9*(1.-smoothstep(0.1,0.5,O147));else if(O728==0||O728==O286-3){O309=length(O363[O666].xz)-O248;O363[O666].y+=max(sqrt(2.5*2.5-O309*O309)-2.3,0.);}}O487=0.5*(O363[0]+O363[1]);O394=normalize(O363[1]-O363[0]);}void mainImage(out vec4 O488,in vec2 O519){mat3 O456;vec4 O038;vec3 O123,O030,O465,O239;vec2 O341,O053,O084,O007[O379],O022[O379],O069,O100,O914,O208;float O735,O124,O650,O805,O960;int O425,O061;bool O604;\nO224=iFrame;O341=iResolution.xy;O053=2.*O519.xy/O341-1.;O053.x*=O341.x/O341.y;O867=iTime;O038=iMouse;O038.xy=O038.xy/O341-0.5;\nO124=O341.x/O341.y;O069=(1./5.)*vec2(O124,1.);O007[0]=(1.-O069.y)*vec2(O124,1.);O007[1]=(1.-O069.y)*vec2(-O124,1.);O007[2]=(1.-O069.y)*vec2(-O124,-1.);O007[3]=(1.-O069.y)*vec2(O124,-1.);for(int O697=0;O697<O379;O697++)O022[O697]=abs(O053-O007[O697])-O069;O061=-1;if(O038.z>0.){O061=0;for(int O697=0;O697<O379;O697++){O100=2.*O038.xy-O007[O697]/vec2(O124,1.);if(O852(abs(O100))<O069.y){O061=O697+1;O100/=2.*O069.y;break;}}if(O061==0)O100=O038.xy;}O425=0;for(int O697=0;O697<O379;O697++){if(O852(O022[O697])<0.){O053=(O053-O007[O697])/O069.y;O425=O697+1;break;}}if(O061>0&&(O425==0||O425==O061))O425=O061-O425;O914=(O038.z>0.&&O425==O061)?vec2(2.,1.)*O689*O100:vec2(0.);O806=0;O604=false;O433();O999=0.7+0.4*sin(0.3*O867);O518(0.015*O867);if(O425==0){O123=O487;O123.y+=0.15;if(O038.z>0.){O208=vec2(-0.5*O689+atan(O394.z,-O394.x)+O914.x,clamp(asin(O394.y)+O914.y,-0.4*O689,0.4*O689));}else{O239=normalize(vec3(-O487.xz,0.).xzy);O208=vec2(-0.5*O689+atan(O239.z,-O239.x),0.);}O735=1.5;}else if(O425==1){O123=vec3(0.,1.,-20.);if(O038.z<=0.){O805=mod(0.04*O867,2.);O805=(abs((floor(8.*O805)+smoothstep(0.8,1.,fract(8.*O805)))/8.-1.)-0.5);}else O805=0.;O208=vec2(O689+1.1*O914.x+0.4*O689*O805,clamp(-0.1*O689+O914.y,-0.4*O689,0.));O735=4.5+3.*abs(O914.x);}else if(O425==2){O123=vec3(0.,1.1+0.5*O914.y,-0.6);O208=vec2(1.1*O914.x+O689/12.,0.);O735=0.5;O604=true;}else if(O425==3){O123=vec3(0.,1.2,-10.);O208=vec2(1.3*O914.x,min(O914.y,0.));O735=4.5;O806=2;}else if(O425==4){O123=vec3(0.,1.3,-10.);O208=vec2(-0.5*O689+1.1*O914.x,min(O914.y,0.));O735=4.5;O806=1;}O456=O712(O208);if(O425!=0)O123=O456*O123;if(O806==1){O651=vec3(1.,0.,0.);}else if(O806==2){O651=vec3(0.,0.,-1.);O651.xz=O185(O651.xz,-O208.x);}O743=O456*normalize(vec3(1.,1.,-1.));O054=80.;const float O162=3.;O465=vec3(0.);O650=2.*mod(dot(mod(floor(0.5*(O053+1.)*O341),2.),vec2(1.)),2.)-1.;for(float a=float(O177);a<O162;a++){O084=(O053+step(1.5,O162)*O185(vec2(0.5/O341.y,0.),O650*(0.667*a+0.5)*O689))/O735;O030=O456*normalize(O604?vec3(2.*sin(O084.x/O124+vec2(0.,0.5*O689)),O084.y).xzy:vec3(2.*tan(0.5*atan(O084/vec2(O124,1.)))*vec2(O124,1.),1.));O465+=(1./O162)*O495(O123,O030);}for(int O697=0;O697<O379;O697++){if(O852(O022[O697])<0.&&O945(abs(O022[O697]))*O341.y<3.)O465=vec3(0.7,0.3,0.3);}O488=vec4(O465,1.);}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl3fW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[623, 623, 645, 645, 672], [672, 672, 694, 694, 721], [721, 721, 743, 743, 782], [782, 782, 838, 838, 924], [924, 924, 945, 945, 1098], [1098, 1098, 1130, 1130, 1236], [1236, 1236, 1267, 1267, 1327], [1353, 1353, 1375, 1375, 1437], [1437, 1437, 1459, 1459, 1514], [1514, 1514, 1535, 1535, 1628], [1628, 1628, 1651, 1651, 1787], [1787, 1787, 1809, 1809, 1976], [1976, 1976, 1999, 1999, 2128], [2128, 2128, 2150, 2150, 2279], [2279, 2279, 2311, 2311, 2491], [2491, 2491, 2533, 2533, 2783], [2783, 2783, 2821, 2821, 2862], [2863, 2863, 2885, 2885, 7971], [7972, 7972, 8004, 8004, 8146], [8146, 8146, 8167, 8167, 8402], [8402, 8402, 8434, 8434, 8680], [8680, 8680, 8713, 8713, 9403], [9403, 9403, 9428, 9428, 13047], [13048, 13048, 13079, 13079, 13682], [13682, 13682, 13734, 13734, 13941], [13941, 13941, 13963, 13963, 14546], [14546, 14546, 14577, 14577, 16936], [16936, 16936, 16948, 16948, 18270], [18271, 18271, 18293, 18293, 19129], [19129, 19129, 19172, 19172, 21729]], "test": "untested"}
{"id": "Dl3fD2", "name": "julia-flame-postprocess", "author": "LydianLights", "description": "Playing around with some of the techniques discussed here: https://iquilezles.org/articles/ftrapsgeometric/\nAdded some trippy postprocessing effects.", "tags": ["fractal", "julia"], "likes": 11, "viewed": 193, "published": 3, "date": "1701587555", "time_retrieved": "2024-07-30T17:18:55.198225", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n   fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float dot2(vec2 v) { return dot(v, v); }\n\nvec2 cplxSquare(vec2 c) {\n    return vec2(c.x * c.x - c.y * c.y, 2.0 * c.x * c.y);\n}\n\nvec3 gamma(in vec3 color) {\n    return pow(max(color, 0.0), vec3(1.0 / 2.2));\n}\n\nvec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}", "buffer_a_code": "const float MAX_ITER = 100.0;\nconst float AA = 0.0;\n\nvec3 palette(in float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5) - 0.15;\n    vec3 b = vec3(0.5, 0.5, 0.5) + 0.15;\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.4, 0.6, 0.7);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nstruct Result {\n    float iterations;\n    float d;\n};\n\nResult map(in vec2 z, in vec2 c) {\n    Result r;\n    r.d = 9999.0;\n    \n    for (r.iterations = 0.0; r.iterations < MAX_ITER; r.iterations++) {\n        z = cplxSquare(z) + c;\n        \n        float t = 0.1 * iTime;\n        float d = 0.1 / (z.x * sin(t) + z.y * cos(t));\n        if (d < r.d) {\n            r.d = d;\n        }\n    }\n    return r;\n}\n\nvec3 mainPass(in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= 0.95;\n    \n    float t = 1.0 * iTime;\n    vec2 c = vec2(-0.8, 0.16);\n    c += 0.01 * vec2(cos(t), sin(t));\n    Result r = map(uv, c);\n    \n    vec3 color = palette(atan(r.d));\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color = mainPass(fragCoord);\n    for (float i = 1.0; i <= AA; i++) {\n        color += mainPass(fragCoord + hash21(i) - 0.5);\n    }\n    color /= (AA + 1.0);\n    color = gamma(color);\n    \n    vec3 prevFrame = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    float f = 0.02;\n    color = f * color + (1.0 - f) * prevFrame;\n    fragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl3fD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 120]], "test": "untested"}
{"id": "clcBD2", "name": "julia-flame", "author": "LydianLights", "description": "Playing around with some of the techniques discussed here: https://iquilezles.org/articles/ftrapsgeometric/", "tags": ["fractal", "julia"], "likes": 8, "viewed": 211, "published": 3, "date": "1701583292", "time_retrieved": "2024-07-30T17:18:56.150679", "image_code": "const float MAX_ITER = 80.0;\nconst float AA_STR = 1.0;\nconst float AA_MAX = 6.0;\n\nvec3 palette(in float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5) - 0.15;\n    vec3 b = vec3(0.5, 0.5, 0.5) + 0.15;\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.4, 0.6, 0.7);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nstruct Result {\n    float iterations;\n    float d;\n};\n\nResult map(in vec2 z, in vec2 c) {\n    Result r;\n    r.d = 9999.0;\n    \n    for (r.iterations = 0.0; r.iterations < MAX_ITER; r.iterations++) {\n        z = cplxSquare(z) + c;\n        \n        float t = 0.05 * iTime;\n        float d = 0.1 / (z.x * sin(t) + z.y * cos(t));\n        if (d < r.d) {\n            r.d = d;\n        }\n    }\n    return r;\n}\n\nvec3 mainPass(in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= 0.95;\n    \n    float t = 0.5 * iTime;\n    vec2 c = vec2(-0.8, 0.16);\n    c += 0.01 * vec2(cos(t), sin(t));\n    Result r = map(uv, c);\n    \n    vec3 color = palette(atan(r.d));\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color = mainPass(fragCoord);\n    \n    // adaptive AA\n    float aaLevel = min(floor(AA_STR * dot2(fwidth(color))), AA_MAX);\n    for (float i = 1.0; i <= AA_MAX; i++) {\n        if (i > aaLevel) break;\n        color += mainPass(fragCoord + hash21(i) - 0.5);\n    }\n    color /= (aaLevel + 1.0);\n    color = gamma(color);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "float dot2(vec2 v) { return dot(v, v); }\nfloat dot2(vec3 v) { return dot(v, v); }\n\nvec2 cplxSquare(vec2 c) {\n    return vec2(c.x * c.x - c.y * c.y, 2.0 * c.x * c.y);\n}\n\nvec3 gamma(in vec3 color) {\n    return pow(max(color, 0.0), vec3(1.0 / 2.2));\n}\n\nvec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clcBD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 108, 108, 307], [364, 364, 398, 398, 710], [712, 712, 746, 746, 1023], [1025, 1025, 1080, 1080, 1442]], "test": "untested"}
{"id": "mldBWB", "name": "zooming rainbow mandelbrot", "author": "janpitokiala", "description": "rainbow mandelbrot set (z to zoom out, mouse to zoom in, x to zoom straight in, r to reset zoom)", "tags": ["mandelbrot", "rainbow"], "likes": 0, "viewed": 89, "published": 3, "date": "1701576364", "time_retrieved": "2024-07-30T17:18:57.205858", "image_code": "//too slow, looks bad, or want to change fractal? go to the common tab\n\n//float getChar(int char, vec2 p) {\n//  char=255-char;\n//  return texture(iChannel3, (p+vec2((15-char)%16,char/16))/16.).r;\n//}\nbool inUnit(vec2 p) {\n  return p.x<1.0&&p.x>0.0&&p.y<1.0&&p.y>0.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv1 = fragCoord/iResolution.xy;\n    vec2 uv2 = uv1;\n    vec2 uv3 = uv1;\n    vec4 transform = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 oldTransform = texelFetch(iChannel1, ivec2(0,0), 0);\n    vec4 oldTransform2 = texelFetch(iChannel3, ivec2(0,0), 0);\n    uv2 *= transform.xz;\n    uv2 -= transform.yw;\n    uv2 += oldTransform.yw;\n    uv2 /= oldTransform.xz;\n    \n    uv3 *= transform.xz;\n    uv3 -= transform.yw;\n    uv3 += oldTransform2.yw;\n    uv3 /= oldTransform2.xz;\n    #ifdef NEAREST\n    ivec2 position = ivec2(uv3/REDUCE_RESOLUTION*vec2(textureSize(iChannel3, 0)));\n    vec4 col2 = texelFetch(iChannel3, position, 0);\n    #else\n    vec4 col2 = texture(iChannel3, uv3/REDUCE_RESOLUTION);\n    #endif\n    if(col2.a==1.&&inUnit(uv3)) {\n      fragColor = vec4(pow(col2.xyz,vec3(1./2.2)),1.0);\n      return;\n    }\n    if(!inUnit(uv2)) {\n      #ifdef NEAREST\n      ivec2 position = ivec2(uv1*vec2(textureSize(iChannel2, 0)));\n      vec3 col = texelFetch(iChannel2, position, 0).rgb;\n      #else\n      vec3 col = texture(iChannel2, uv1).rgb;\n      #endif\n      fragColor = vec4(pow(col,vec3(1./2.2)),1.0);\n    } else {\n      #ifdef NEAREST\n      ivec2 position = ivec2(uv2/REDUCE_RESOLUTION*vec2(textureSize(iChannel1, 0)));\n      vec3 col = texelFetch(iChannel1, position, 0).rgb;\n      #else\n      vec3 col = texture(iChannel1, uv2/REDUCE_RESOLUTION).rgb;\n      #endif\n      fragColor = vec4(col,1.0);\n    }\n    if(col2.a>0.&&inUnit(uv3)) {\n      fragColor = mix(fragColor, vec4(col2.rgb/col2.a,1.), col2.a);\n    }\n    fragColor = vec4(pow(fragColor.xyz,vec3(1./2.2)),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define ZOOM pow(ZOOM_SPEED,iTimeDelta)\n//Input handler\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.y==0.5) {\n      if(fragCoord.x==0.5) {\n        if(iFrame==0) {\n          fragColor = vec4(5.0,2.5,3.0,1.5);\n        } else {\n          vec4 v = texelFetch(iChannel0, ivec2(0,0), 0);\n          mat3 transform = mat3(\n            v.x, 0, 0,\n            0, v.z, 0,\n            v.y, v.w, 1\n          );\n          if(iMouse.z>0.) {\n            vec2 uv = iMouse.xy/iResolution.xy;\n            transform = transform*mat3(\n               1./ZOOM, 0, 0,\n               0, 1./ZOOM, 0,\n               (1.-ZOOM)*uv.x, (1.-ZOOM)*uv.y, 1\n            );\n          }\n          if(texelFetch(iChannel1, ivec2(90,0), 0).r>0.5) {\n            transform = transform*mat3(\n              ZOOM, 0, 0,\n              0, ZOOM, 0,\n              (ZOOM-1.)/2., (ZOOM-1.)/2., 1\n            );\n          }\n          if(texelFetch(iChannel1, ivec2(88,0), 0).r>0.5) {\n            transform = transform*mat3(\n              1./ZOOM, 0, 0,\n              0, 1./ZOOM, 0,\n              (1./ZOOM-1.)/2., (1./ZOOM-1.)/2., 1\n            );\n          }\n          if(texelFetch(iChannel1, ivec2(82,0), 0).r>0.5) {\n            transform = mat3(\n              5.0, 0, 0,\n              0, 3.0, 0,\n              2.5, 1.5, 1\n            );\n          }\n          fragColor = vec4(transform[0][0],transform[2][0],transform[1][1],transform[2][1]);\n        }\n      } else if(fragCoord.x==1.5) {\n        #ifdef CHANGING_FPS\n        if(iFrame==0) {\n          fragColor = vec4(START_SKIP_FRAMES);\n        } else {\n          float skip_frames = texelFetch(iChannel0, ivec2(1,0), 0).r;\n          skip_frames += clamp((TARGET_FPS-iFrameRate)*ADJUSTMENT_RATE,-MAX_ADJUSTMENT,MAX_ADJUSTMENT);\n          skip_frames = clamp(skip_frames,MIN_SKIP_FRAMES,MAX_SKIP_FRAMES);\n          fragColor = vec4(skip_frames);\n        }\n        #else\n        fragColor = vec4(SKIP_FRAMES);\n        #endif\n      }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Main renderer\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef BUFFER_C\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*REDUCE_RESOLUTION)/iResolution.xy;\n    if(uv.x>1.||uv.y>1.) {\n      fragColor = texelFetch(iChannel1, ivec2(clamp(fragCoord,vec2(0.),(iResolution.xy/REDUCE_RESOLUTION-vec2(1.)))),0);\n      return;\n    }\n    int skip_frames = int(texelFetch(iChannel0, ivec2(1,0), 0).r);\n    vec4 transform;\n    if(skip_frames==1) {\n      transform = texelFetch(iChannel0, ivec2(0,0), 0);\n    } else {\n      transform = texelFetch(iChannel1, ivec2(0,0), 0);\n      float bayer = texelFetch(iChannel2, ivec2(fragCoord/2.)%ivec2(8), 0).r;\n      if(iFrame%skip_frames==1) {\n        transform = texelFetch(iChannel0, ivec2(0,0), 0);\n        if(fragCoord.x==0.5&&fragCoord.y==0.5) {\n          fragColor = transform;\n          return;\n        }\n        fragColor=vec4(0.);\n        return;\n      }\n      float minBayer = float((iFrame-1)%skip_frames)/float(skip_frames);\n      float maxBayer = float(iFrame%skip_frames)/float(skip_frames);\n      if((iFrame%skip_frames>0)&&(minBayer>bayer||maxBayer<bayer)) {\n        fragColor=texture(iChannel1, uv/REDUCE_RESOLUTION);\n        return;\n      }\n    }\n    if(fragCoord.x==0.5&&fragCoord.y==0.5) {\n      fragColor = transform;\n      return;\n    }\n    vec3 color = vec3(0.);\n    for(int i=0;i<UPSAMPLE;i++) {\n        vec2 uv = (fragCoord*REDUCE_RESOLUTION)/iResolution.xy;\n        uv.x = transform.x*uv.x-transform.y;\n        uv.y = transform.z*uv.y-transform.w;\n        vec3 col = render(uv, HIGH_ITERATIONS);\n        // Output to screen\n        color += pow(col,vec3(2.2))*(1./float(UPSAMPLE));\n        fragCoord += 1./float(UPSAMPLE);\n        \n    }\n    fragColor = vec4(color, 1.);\n    #endif\n}", "buffer_c_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//performance things\n//#define CHANGING_FPS //try to keep fps at a certain amount, causes lag spikes due to bug\n\n#ifdef CHANGING_FPS\n\n#define TARGET_FPS 50. //what fps to try to run at\n#define START_SKIP_FRAMES 100 //how many frames to skip at the beginning\n#define ADJUSTMENT_RATE 0.03 //how fast to adjust fps, too high will make it bounce between high and low fps\n#define MAX_ADJUSTMENT 1.0 //fps adjustment limit\n#define MIN_SKIP_FRAMES 10. //minimum amount of frames to skip\n#define MAX_SKIP_FRAMES 500. //maximum amount of frames to skip\n\n#else\n\n#define SKIP_FRAMES 10 //how many frames between renders, will not cause lag spikes because it renders continuously\n\n#endif\n\n#define HIGH_ITERATIONS 255 //how many iterations to do\n#define REDUCE_RESOLUTION 1. //how much to reduce resolution by. setting this to 2 would mean it would render in 2x2 blocks\n#define LOW_ITERATIONS 100 //iterations to do while zooming out, you can't see it if SKIP_FRAMES is 1\n#define BUFFER_C //main renderer, if you turn it off it shows what you see when zooming out\n#define UPSAMPLE 5 //upsampling, makes it sparkle less next to the edges\n#define ZOOM_SPEED 2. //how fast to zoom\n//#define NEAREST //makes it less blurry and more pixelated\nvec2 square(in vec2 num) {\n    num = vec2(num.x*num.x-num.y*num.y,2.*num.x*num.y);\n    return num;\n}\nvec2 mul(in vec2 one, in vec2 two) {\n    vec2 result = vec2(one.x*two.x-one.y*two.y,one.x*two.y+one.y*two.x);\n    return result;\n}\nvec2 power(vec2 num, int power) {\n    vec2 final = vec2(1.,0.);\n    for(int i = 0;i<power;i=i+1) {\n        final=vec2(num.x*final.x-num.y*final.y,num.x*final.y+num.y*final.x);\n    }\n    return final;\n}\n\nvec2 mandelbrot(vec2 z, vec2 c) {\n    return square(z)+c;\n}\n\n\nvec3 render(vec2 c, int iterations) {\n    vec2 z = vec2(0.,0.);\n    vec3 col = vec3(0.,0.,0.);\n    for(int i = 0; i < iterations; i++) {\n        z = mandelbrot(z,c);\n        if (length(z) > 2.) {\n            col = pow(max(sin(float(i)/5.0+vec3(0.,2.,4.)),0.),vec3(1./2.2));\n            break;\n        }\n    }\n    return col;\n}", "buffer_d_code": "//Holds rendered image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    int skip_frames = int(texelFetch(iChannel2, ivec2(1,0), 0).r);\n    if((iFrame)%skip_frames>0) {\n      fragColor=texture(iChannel1, uv);\n    } else {\n      fragColor=texture(iChannel0, uv);\n    }\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//renders while zooming out\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv1 = fragCoord/iResolution.xy;\n    vec2 uv2 = uv1;\n    vec2 uv3 = uv1;\n    vec4 transform = texelFetch(iChannel1, ivec2(0,0), 0);\n    if(fragCoord.x==0.5&&fragCoord.y==0.5) {\n      fragColor = transform;\n      return;\n    }\n    vec4 oldTransform = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 oldTransform2 = texelFetch(iChannel2, ivec2(0,0), 0);\n    uv2 *= transform.xz;\n    uv2 -= transform.yw;\n    uv2 += oldTransform.yw;\n    uv2 /= oldTransform.xz;\n    \n    uv3 *= transform.xz;\n    uv3 -= transform.yw;\n    uv3 += oldTransform2.yw;\n    uv3 /= oldTransform2.xz;\n    if(uv3.x<1.0&&uv3.x>0.0&&uv3.y<1.0&&uv3.y>0.0) {\n      #ifdef NEAREST\n      ivec2 position = ivec2(uv3/REDUCE_RESOLUTION*vec2(textureSize(iChannel2, 0)));\n      vec3 col = texelFetch(iChannel2, position, 0).rgb;\n      #else\n      vec3 col = texture(iChannel2, uv3/REDUCE_RESOLUTION).rgb;\n      #endif\n      fragColor = vec4(col,1.0);\n    } else if(uv2.x>1.0||uv2.x<0.0||uv2.y>1.0||uv2.y<0.0) {\n      vec4 transform = texelFetch(iChannel1, ivec2(0,0), 0);\n      uv1.x = transform.x*uv1.x-transform.y;\n      uv1.y = transform.z*uv1.y-transform.w;\n      vec3 col = render(uv1, LOW_ITERATIONS);\n      // Output to screen\n      fragColor = vec4(pow(col,vec3(1./0.45)),1.0);\n    } else {\n      vec4 transform = texelFetch(iChannel1, ivec2(0,0), 0);\n      uv1.x = transform.x*uv1.x-transform.y;\n      uv1.y = transform.z*uv1.y-transform.w;\n      vec3 col = render(uv1, LOW_ITERATIONS);\n      // Output to screen\n      fragColor = vec4(pow(col,vec3(1./0.45)),1.0);\n      //#ifdef NEAREST\n      //ivec2 position = ivec2(uv2*vec2(textureSize(iChannel0, 0)));\n      //col = texelFetch(iChannel0, position, 0).rgb;\n      //#else\n      col = texture(iChannel0, uv2).rgb;\n      //#endif\n      col = pow(col,vec3(1./2.2));\n      fragColor = mix(fragColor,vec4(col,1.0),0.9);\n    }\n    fragColor = vec4(pow(fragColor.rgb,vec3(2.2)),1.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mldBWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 200, 221, 221, 268], [269, 269, 326, 326, 1916]], "test": "untested"}
{"id": "dtdfWB", "name": "Sphere-pinski", "author": "isaacchurchill", "description": "KIFS experiment part 2", "tags": ["3d", "raymarching", "fractal", "raymarcher"], "likes": 7, "viewed": 178, "published": 3, "date": "1701567904", "time_retrieved": "2024-07-30T17:18:58.055586", "image_code": "const int MAX_MARCHES = 300;\nconst float RAYMARCH_THRESHOLD = 0.001;\nconst float NORMAL_EPSILON = 0.001;\n\nmat2 rot_xy(float theta)\n{\n    return mat2(cos(theta), sin(theta),\n                -sin(theta), cos(theta));\n}\n\nvec3 palette(float iter)\n{\n    return 0.5 + 0.5 * sin(iter + vec3(0, 1, 2));\n}\n\nvec4 union_de(vec4 a, vec4 b)\n{\n    if (b.w < a.w) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nfloat box3d_de(vec3 p, vec3 sizes)\n{\n    vec3 temp = abs(p) - sizes;\n    return length(max(temp, 0.0)) + min(max(max(temp.x, temp.y), temp.z), 0.0);\n}\n\nfloat fractal_de(vec3 p, out float iter)\n{\n    float scale = 2.0;\n    float max_i = floor(mod(iTime + 6.0, 6.99)) + 1.0;\n    float s = 1.0;\n    float d = 1e6;\n\n    const float width = 1.0;\n    const float thickness = 0.05;\n    const float r = thickness / 2.0;\n    const float a = (width - thickness) / 2.0;\n    for (float i = 0.0; i < max_i; i++) {\n        p = abs(p);\n        if (p.x > p.y) {\n            p.xy = p.yx;\n        }\n        if (p.y < p.z) {\n            p.yz = p.zy;\n        }\n        if (p.x > p.z) {\n            p.xz = p.zx;\n        }\n        float d1 = (length(p) - 0.5) * s;\n        if (d1 < d) {\n            iter = i;\n        }\n        d = min(d, d1);\n        p -= vec3(0.0, 0.5, 0.0);\n        p *= scale;\n        s /= scale;\n    }\n    return d;\n}\n\nfloat dist_estim(vec3 p, out vec3 col)\n{\n    float iter = 0.0;\n    float scale = 0.4;\n    float fractal = fractal_de(p / scale, iter) * scale;\n    vec3 plane_col = vec3(0.5);\n    if ((mod(p.x, 1.0) > 0.5) != (mod(p.z, 1.0) > 0.5)) {\n        plane_col = vec3(1.0);\n    }\n\n    vec4 de = vec4(palette(iter), fractal);\n    de = union_de(de, vec4(plane_col, abs(p.y + 0.4)));\n\n    col = de.xyz;\n    return de.w;\n}\n\nvec3 calc_normal(vec3 p)\n{\n    const vec2 eps = vec2(0.0, NORMAL_EPSILON);\n    vec3 temp = vec3(0.0);\n    return normalize(vec3(\n        dist_estim(p + eps.yxx, temp),\n        dist_estim(p + eps.xyx, temp),\n        dist_estim(p + eps.xxy, temp)\n        ) - dist_estim(p, temp));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    if (m.x < 0.01 && m.y < 0.01) {\n        m = vec2(0.3, 0.45);\n    }\n    vec2 rot = (m - 0.5) * 4.0;\n    vec3 ray_dir = normalize(vec3(uv, 2.0));\n    mat2 yz_mat = rot_xy(rot.y);\n    mat2 xz_mat = rot_xy(rot.x);\n    ray_dir.yz *= yz_mat;\n    ray_dir.xz *= xz_mat;\n    vec3 ray_endpoint = vec3(0.0, 0.0, -1.0);\n    ray_endpoint.yz *= yz_mat;\n    ray_endpoint.xz *= xz_mat;\n    \n    vec3 light_dir = normalize(vec3(0.3, 1.0, -0.5));\n    \n    for (int march = 0; march < MAX_MARCHES; march++) {\n        vec3 surface_col = vec3(0.0);\n        float dist = dist_estim(ray_endpoint, surface_col);\n        if (dist < RAYMARCH_THRESHOLD) {\n\t\t\tvec3 norm = calc_normal(ray_endpoint);\n            float intensity = max(dot(norm, light_dir), 0.0);\n            vec3 light_col = vec3(0.9);\n            vec3 ambient = vec3(0.1);\n            col = surface_col * (light_col * intensity + ambient);\n            break;\n        }\n        ray_endpoint += ray_dir * dist * 0.5;\n    }\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtdfWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 132, 132, 216], [218, 218, 244, 244, 296], [298, 298, 329, 329, 407], [409, 409, 445, 445, 559], [561, 561, 603, 603, 1325], [1327, 1327, 1367, 1367, 1735], [1737, 1737, 1763, 1763, 2017], [2019, 2019, 2076, 2076, 3255]], "test": "untested"}
{"id": "WsdGz2", "name": "pictures on a shiny plane", "author": "samuelotherion", "description": "some pictures on a plane.\nuse your mouse!", "tags": ["raytracing", "light", "textures"], "likes": 3, "viewed": 166, "published": 3, "date": "1701566077", "time_retrieved": "2024-07-30T17:18:59.115751", "image_code": "const V1 pi16 = 6.283 / 16.;\n\nV2\tP;\nV0 bkg( ) {\n\n    V2\ts = V2( lessThan( _.ww, N ) );\n    V1\tn = s.x + 2. * s.y;\n    \n    O = .25 * tx( n, mod( 2. * N, _.yy ) );\n}\n\nBO hit_rect( V3 eye, V3 ray, V3 pos, V3 x, V3 y, V3 n, V1 id, inout V1 idbest, inout V3 abl, inout V3 hit  ) {\n    \n    V3\td = pos - eye;\n    \n    V1\tl = dot( d, n ) / dot( ray, n );\n    \n    if( 0. < l && l < abl.z ) {\n        \n        V3\th = eye + l * ray,\n            c = h - pos;\n     \n        V1\tcx = dot( c, x ),\n            xx = dot( x, x ),\n            cy = dot( c, y ),\n            yy = dot( y, y );\n            \n        if( abs( cx ) < xx && abs( cy ) < yy ) {\n            \n            idbest = id;\n            \n            abl = V3( cx / xx, cy / yy, l );\n            \n            hit = h;\n            \n            RT\n        }\n    }\n    \n    RF\n}\n\n\nBO hit_light( V3 eye, V3 ray, V3 pos, V1 rad, V1 id, inout V1 idbest, inout V1 len, inout V3 hit ) {\n    \n    V3\td  = eye - pos;\n    V1\tab = dot( ray, d ),\n        bb = dot( d, d ),\n        ds = rad * rad - bb + ab * ab;\n\n    if( 0. <= ds ) {\n\n        V1\tl = -ab - sqrt( ds );\n\n        if( 0. < l && l < len ) {\n            \n            idbest = id;\n            \n            len = l;\n            \n            hit = eye + l * ray;\n            \n            RT\n\t\t}\n\t}\n    \n    RF\n}\n\n\nV1 hit_obj( V3 eye, V3 ray, V1 nid, out V3 hit, out V3 n, out V3 abl ) {\n    \n    V1\tid     = -1.,\n        idbest = -1.,\n    \tbeta,\n        c,\n        s;\n    \n    V3\tpos, x, y, z;\n    \n    abl = V3( 0, 0, 1.e3 );\n    \n    //plane\n    if( nid != ID_PLANE ) {\n\n        id = ID_PLANE;\n\n        pos = rd( id, 0. );\n        x   = rd( id, 1. );\n        y   = rd( id, 2. );\n        z   = rd( id, 3. );\n\n        hit_rect( eye, ray, pos, x, y, z, id, idbest, abl, hit );\n    }\n    \n    id = ID_MIN_PHOTO + 0.;\n    \n    while( id <= ID_MAX_PHOTO ) {\n     \n        if( nid != id ) { \n                   \n        \tpos = rd( id, 0. );\n        \tx   = rd( id, 1. );\n        \ty   = rd( id, 2. );\n            z\t= rd( id, 3. );\n        \n\t\t\thit_rect( eye, ray, pos, x, y, z, id, idbest, abl, hit );\n        }\n        \n        ++ id;\n    }\n    \n    //light\n\tid = ID_LIGHT;\n\n    if( id != nid ) {\n    \n        pos = rd( id, 0. );\n        \n\t\thit_light( eye, ray, pos, .5, id, idbest, abl.z, hit );\n    }\n    \n    RN idbest;\n}\n\n\nV0 mainImage( out V4 o, V2 i ) {\n    \n    INIT\n        \n    P = ( 2. * N - 1. ) * V2( iR.x * Ri.y, 1. ); \n    \n    //bkg( );\n\t\n    V1\tg = .25 * 3.142 * ( iMouse.y * Ri.y - 1. );\n\t\n\tV3\teye = rot( V3( 0, 0., 25. ), V3( 1, 0, 0 ), g ),\n        scn = rot( V3( P, 22. ), V3( 1, 0, 0 ), g ),\n        ray = normalize( scn - eye ),\n        light = rd( ID_LIGHT, 0. ),\n        hit, n, abl;\n\n    V1\tid = hit_obj( eye, ray, -1., hit, n, abl );\n    \n    if( id == ID_LIGHT ) {\n        \n        O.xyz = V3( 1. );\n    }\n    \n    if( ID_PLANE == id ) {\n        \n        V3\tn    = rd( ID_PLANE, 3. ),\n            _ray = light - hit,\n            _abl = V3( 0., 0., 1.e3 ),\n            _hit,\n            _n,\n            _c = V3( .25 ) + .75 * tx( 2., V2( .75, .75 ) + .25 * abl.xy ).rgb;\n        \n        O.rgb = _c;\n        \n        V1\td =\n            ID_LIGHT == hit_obj( hit, normalize( _ray ), ID_PLANE, _hit, _n, _abl )\n            \t? clamp( 2. * dot( n, _ray ) * pow( dot( _ray, _ray ), -1. ), 0., 1. )\n            \t: 0.;\n        \n        O.rgb *= clamp( .25 + .75 * d, 0., 1. );\n        \n        _abl.z = 1.e3;\n        \n        V3\tv = reflect( ray, n );\n        \n        V1  w = hit_obj( hit, normalize( v ), ID_PLANE, _hit, _n, _abl );        \n        \n        if( ID_MIN_PHOTO <= w && w <= ID_MAX_PHOTO ) {\n\n            V1 cl = mod( w, 4. );\n\n            V2 off = .25 + .5 * V2( mod( cl, 2. ), mod( floor( cl / 2. ), 2. ) );\n\n            V2 j = off + V2( .25 ) * _abl.xy;\n\n            if( dot( v, rd( w, 3. ) ) < 0. ) {\n\n                O.rgb = .1 * tx( mod( w / 4., 4. ), j ).rgb + .9 * O.rgb;\n            }\n            else {\n\n                O.rgb = .9 * O.rgb;\n            }\n        }\n\n        if( w == ID_LIGHT ) {\n\n            O.rgb = .75 * O.rgb + V3( .25 );\n        }\n    }\n    \n    if( ID_MIN_PHOTO <= id && id <= ID_MAX_PHOTO ) {\n        \n        V3\tn    = rd( id, 3. ),\n            _ray = light - hit,\n            _abl = V3( 0., 0., 1.e3 ),\n            _hit,\n            _n;\n                                \n        V1 cl = mod( id, 4. );\n        \n        V2 off = .25 + .5 * V2( mod( cl, 2. ), mod( floor( cl / 2. ), 2. ) );\n        \n        V2 j = off + V2( .25 ) * abl.xy;\n        \n        if( dot( ray, n ) < 0. ) {\n        \n            O.rgb = tx( mod( id / 4., 4. ), j ).rgb;\n        }\n        else {\n            \n            n = -n;\n            \n            O.rgb = V3( .75 );\n        }\n        \n    \tV1\td =\n            ID_LIGHT == hit_obj( hit, normalize( _ray ), id, _hit, _n, _abl )\n            \t? clamp( 2. * dot( n, _ray ) * pow( dot( _ray, _ray ), -.5 ), 0., 1. )\n            \t: 0.;\n\n\t\tO.rgb *= clamp( .25 + .75 * d, 0., 1. );\n\t    \n    }\n\n    O.rgb +=  pow( 1000., - acos( dot( ray, normalize( light - eye ) ) ) );\n    O.rgb = clamp( O.rgb, 0., 1. );\n    \n\n    FIN\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define BO bool\n#define IN int\n#define V0 void\n#define V1 float\n#define V2 vec2\n#define V3 vec3\n#define V4 vec4\n#define M3 mat3\n\n#define RN return\n#define RF RN false;\n#define RT RN true;\n\n#define iT iTime\n#define iR (iResolution.xy)\n\nconst V4 _  = V4( 0, 1, 255., .5 );\n\nV2 I, N, Ri;\nV4 O;\n\n#define ID_MIN_PHOTO  0.\n#define ID_MAX_PHOTO  15.\n#define ID_PLANE      16.\n#define ID_LIGHT      17.\n\n#define INIT N = ( I = i ) * ( Ri = 1. / iR );    \n#define FIN  o = O;\n#define TX( n, i ) texture( n, i )\n#define tx( n, i ) ( \\\n\tn < 2. \\\n        ? n < 1. \\\n        \t? TX( iChannel0, i ) \\\n        \t: TX( iChannel1, i ) \\\n\t\t: n < 3. \\\n            ? TX( iChannel2, i ) \\\n            : TX( iChannel3, i ) )\n\nV3 rot( V3 r, V3 axe, V1 alpha ) {\n    \n    axe = normalize( axe );\n    \n    V3\tz = dot( r, axe ) * axe,\n        x = r - z,\n        y = cross( axe, x );\n    \n    RN cos( alpha ) * x + sin( alpha ) * y + z;\n}\n\n#define R4( n, x, y ) tx( n, Ri * ( .5 + V2( x, y ) ) )\n#define R3( n, x, y ) R4( n, x, y ).xyz\n#define rd( x, y ) R3( 0., x, y )\n#define REP V0 mainImage( out V4 o, V2 i ) { \\\n\tINIT \\\n\tV2 s = V2( lessThan( _.ww, N ) ); \\\n    V1 n = s.x + 2. * s.y; \\\n    N = mod( 2. * N, _.yy ); \\\n    O = tx( n, N ); \\\n\tFIN }\n", "buffer_a_code": "const V1 pi16 = 6.283 / 16.;\nV1\talpha;\n\n\nV0 mainImage( out V4 o, V2 i ) {\n\n    INIT\n    \n    if(  i.y < 4. ) {\n        \n\t    alpha = -4. * 6.283 * ( .5 - iMouse.x * Ri.x + .01 * iT );\n        \n        V1\tid = floor( i.x ),\n            beta = id * pi16,\n            gamma = .1 * iT,\n            c = cos( alpha + beta ),\n            s = sin( alpha + beta );\n        \n        if( i.x < 16. ) {\n            \n            O.xyz = \n                i.y < 2.\n                \t? i.y < 1.\n                \t\t? V3( 7. * s, 1., 7. * c ) //pos\n                \t\t: V3( c, 0, -s ) //x\n                \t: i.y < 3.\n                        ? V3( 0, 1, 0 ) // y\n                        : V3( s, 0., c ); // n\n        }\n        else {\n            \n            if( i.x < 17. ) { // plane\n            \n                O.xyz = \n                    i.y < 2.\n                    \t? i.y < 1.\n                    \t\t? V3(  0, 0,  0 )\n                    \t\t: 10. * V3( s, 0, c )\n                    \t: i.y < 3.\n                            ? 10. * V3( c, 0,  -s )\n                            : V3(  0, 1,  0 );\n            }\n            else {\n                \n                O.xyz = i.x < 18. ? M3(s,0,c,0,1,0,c,0,-s)*rot( V3( 0, 4.2 - 2. * sin( gamma ), 13.1 * cos( gamma ) ), V3(0,1,0), .51 * cos( 10.*gamma ) ) : V3( 0 ); // light\n            }\n        }\n    }\n    else {\n\n        V2 s = V2( lessThan( _.ww, N ) );\n        V1 n = s.x + 2. * s.y;\n        N = mod( 2. * N, _.yy );\n        O = tx( n, N );\n    }  \n    \n\tFIN \n}\n        \n", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\t\t\t\t\t\t\t\t\t\t\tREP\n", "buffer_b_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\t\t\t\t\t\t\t\t\t\t\tREP\n", "buffer_c_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\t\t\t\t\t\t\t\t\t\t\tREP\n", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdGz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 47, 47, 164], [1308, 1308, 1380, 1380, 2311]], "test": "untested"}
{"id": "DldfWB", "name": "Motion Extraction (cmarangu)", "author": "cmarangu", "description": "âª Go to \"Image\" tab and quickly pause/play iChannel0 to increase the delay and see the effect.\n\nâª Press the left arrow thing below the shader to reset everything.\n\nBased on [url]https://www.youtube.com/watch?v=NSS6yAMZF78p[/url]\n", "tags": ["video", "motion", "computervision", "motionextraction"], "likes": 5, "viewed": 246, "published": 3, "date": "1701552670", "time_retrieved": "2024-07-30T17:19:00.094135", "image_code": "// Chase Marangu\n// 2023 12 02\n// Started 3:34pm ET\n// Finished 4:35pm ET\n// Updated 6:01pm ET - 6:22pm ET\n// Upadated 2023 12 03 7:18pm ET based on a friend's feedback to make it more like the Posy's solution\n// Thank you so much @Posy !\n// Posy - Motion Extraction - https://www.youtube.com/watch?v=NSS6yAMZF78\n//\n// 1) Duplicate Video (maybe time shift it 1 frame or 1 second or maybe keep the first frame)\n// 2) invert the the duplicate\n// 3) show the duplicate 50% transparent over the original\n//\n// 7:15pm ET my friend said it's something about \"sobel operator\"\n// 2023 12 03 12:23am ET I had this idea\n// motion extraction is basically a function f:ðâð\n// ð = ([0, 1)^3)^(w x h x duration) = the set of all videos\n// - [0, 1)^3 = the set of all vectors with 0â¤r<1 0â¤g<1 0â¤b<1\n// - ([0, 1)^3)^(w x h x duration) = the set of all tensors(?) where each entry is a color\n// - - and where width=w, height=h, duration=duration\n// - - I'm kind of making up this notation based on Cartesian power. However I hope you get the gist\n// - - A video assigns a color (3-dimensional point) to every point in a 3-dimensional space\n// - - Motion extraction assigns an output video to each input video\n//\n// f could be implemented with several platforms/technologies/apis including but not limited to\n// - OpenGL/WebGL/GLSL/fragment shader/shadertoy (this)\n// - AfterEffects\n// - HTML/CSS + JavaScript Web APIs using stuff like HTMLVideoElement.currentTime and CSS filter:url(...) and SVG filters\n\n// 0 = just the motion (change in brightness across frames)\n// 1 = motion + color video below it\n#define mode 0\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screen = fragCoord / iResolution.xy;\n    vec3 c; c = vec3(0.); // accumulator, not used for accumulation really\n    vec3 currentFrame = texture(iChannel0, screen).rgb; // original video, current time\n    vec3 prevFrame = texture(iChannel3, screen).rgb; // last frame, assuming time shifted\n    # if mode == 1\n    c += currentFrame*.5;\n    #endif\n    currentFrame = vec3(0.0) - currentFrame; // invert colors; it is negative to act more like phases in audio\n    // sum the two\n    c += (currentFrame + prevFrame);\n    fragColor = vec4(c.r, c.g, c.b, 1.);\n}\n\n/*\n// 0 = just the motion (change in brightness across frames)\n// 1 = motion + color video below it\n#define mode 0\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screen = fragCoord / iResolution.xy;\n    vec3 c; c = vec3(0.);\n    vec3 currentFrame = texture(iChannel0, screen).rgb; // original video\n    vec3 prevFrame = texture(iChannel3, screen).rgb;\n    //\n    //c += currentFrame*1.0 +(currentFrame - prevFrame)*0.5;\n    // update 6:01pm ET - add mode for black/white\n    # if mode == 1\n    c += currentFrame*.5;\n    #endif\n    c += vec3(.5);\n    // c += vec3(length(currentFrame - prevFrame))*1.5;\n    //c += vec3(\n    //    currentFrame.r - prevFrame.r +\n    //    currentFrame.g - prevFrame.g +\n    //    currentFrame.b - prevFrame.b)*1.5;\n    //c += vec3( length(currentFrame) - length(prevFrame) )*3.; // just test brightness\n    c += vec3( length(currentFrame) - length(prevFrame) )*.1;\n    fragColor = vec4(c.r, c.g, c.b, 1.);\n}\n*/", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screen = fragCoord / iResolution.xy;\n    fragColor.rgb = texture(iChannel0, screen).rgb;\n    fragColor.a = 1.;\n}", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screen = fragCoord / iResolution.xy;\n    fragColor.rgb = texture(iChannel1, screen).rgb;\n    fragColor.a = 1.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screen = fragCoord / iResolution.xy;\n    fragColor.rgb = texture(iChannel2, screen).rgb;\n    fragColor.a = 1.;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DldfWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1618, 1618, 1674, 1674, 2239]], "test": "untested"}
{"id": "DttBDS", "name": "fastinvsmoothstep performance", "author": "fishy", "description": "Performance test of fast inverse smoothstep by user iradicator", "tags": ["fast", "animation", "function", "smoothstep"], "likes": 1, "viewed": 130, "published": 3, "date": "1701544798", "time_retrieved": "2024-07-30T17:19:01.434551", "image_code": "// --- Set the function to test here ---\n#define FUNCTION FAST_3\n// -------------------------------------\n\n// All fps values tested without any additional steps\n// 80 fps\n#define ORIGINAL f0\n\n// 110 fps\n#define FAST_1 f1\n\n// 90 fps\n#define FAST_2 f2\n\n// 98 fps\n#define FAST_3 f3\n\n// Original comment:\n// ---\n// \n// For more details, check out my blog post: \n// https://iradicator.com/fast-inverse-smoothstep/\n//\n// fastinvsmoothstep implementation: https://www.shadertoy.com/view/wtXfzS\n// fastinvsmoothstep-based animations: https://www.shadertoy.com/view/wtlfz2\n//\n// ---\n\n#define IS_SECOND_UPDATE_STEP 0\n#define IS_TWO_ADDITIONAL_UPDATE_STEPS 0\n\n#define EPSILON 0.00001\n\nfloat f0(in float y)\n{\n    return 0.5 - sin(asin(1.0-2.0*y)/3.0);\n}\n\nfloat f1(in float y)\n{\n  float yn = 2.0*y-1.0;\n  float t = 0.45*yn;\n  t -= (t*(4.0*t*t-3.0)+yn) / (12.0*t*t-3.0);\n#if IS_SECOND_UPDATE_STEP\n  t -= (t*(4.0*t*t-3.0)+yn) / (12.0*t*t-3.0-EPSILON);\n#endif\n#if IS_TWO_ADDITIONAL_UPDATE_STEPS\n  t -= (t*(4.0*t*t-3.0)+yn) / (12.0*t*t-3.0-EPSILON);\n  t -= (t*(4.0*t*t-3.0)+yn) / (12.0*t*t-3.0-EPSILON);\n#endif\n  return t + 0.5;     \n}\n\nfloat f2(in float y)\n{\n  float yn = 2.0*y-1.0;\n  float t = 0.5*abs(yn)*yn*yn*yn;\n  t -= (t*(4.0*t*t-3.0)+yn) / (12.0*t*t-3.0-EPSILON);\n#if IS_SECOND_UPDATE_STEP\n  t -= (t*(4.0*t*t-3.0)+yn) / (12.0*t*t-3.0-EPSILON);\n#endif\n#if IS_TWO_ADDITIONAL_UPDATE_STEPS\n  t -= (t*(4.0*t*t-3.0)+yn) / (12.0*t*t-3.0-EPSILON);\n  t -= (t*(4.0*t*t-3.0)+yn) / (12.0*t*t-3.0-EPSILON);\n#endif\n    return t + 0.5;     \n}\n\nfloat f3(in float y)\n{\n  float yn = 2.0*y-1.0;\n  float t = -0.25*yn*yn*yn;\n  t -= (t*(4.0*t*t-3.0)+yn) / (12.0*t*t-3.0);\n#if IS_SECOND_UPDATE_STEP\n  t -= (t*(4.0*t*t-3.0)+yn) / (12.0*t*t-3.0-EPSILON);\n#endif\n#if IS_TWO_ADDITIONAL_UPDATE_STEPS\n  t -= (t*(4.0*t*t-3.0)+yn) / (12.0*t*t-3.0-EPSILON);\n  t -= (t*(4.0*t*t-3.0)+yn) / (12.0*t*t-3.0-EPSILON);\n#endif\n  return t + 0.5;     \n}\n\nfloat f4(in float y)\n{\n  float yn = 2.0*y-1.0;\n  float absyn3 = abs(yn)*yn*yn;\n  float t = 0.45*yn+0.5*yn*(absyn3*absyn3-0.9*absyn3);\n  t -= (t*(4.0*t*t-3.0)+yn) / (12.0*t*t-3.0-EPSILON);\n#if IS_SECOND_UPDATE_STEP\n  t -= (t*(4.0*t*t-3.0)+yn) / (12.0*t*t-3.0-EPSILON);\n#endif\n#if IS_TWO_ADDITIONAL_UPDATE_STEPS\n  t -= (t*(4.0*t*t-3.0)+yn) / (12.0*t*t-3.0-EPSILON);\n  t -= (t*(4.0*t*t-3.0)+yn) / (12.0*t*t-3.0-EPSILON);\n#endif\n  return t + 0.5;     \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0*uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 1.1;\n    \n    float size = asin(sin(iTime))/3.1415926+0.5;\n    for(int i = min(0, iFrame); i < 10000; i++)\n    {\n        size = mix(size, FUNCTION(size), 0.0001);\n    }\n    \n    vec3 col = vec3(1)*smoothstep(size + 3.0/iResolution.y, size, length(uv));\n    \n    col = pow(col,vec3(1.0/2.2));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DttBDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[674, 674, 696, 696, 741], [743, 743, 765, 765, 1118], [1120, 1120, 1142, 1142, 1518], [1520, 1520, 1542, 1542, 1902], [1904, 1904, 1926, 1926, 2353], [2355, 2355, 2412, 2412, 2857]], "test": "untested"}
{"id": "dt3BDB", "name": "morphing / interpolating f_n_sd", "author": "jonasfrey", "description": "shapes can be morphed easily", "tags": ["morphing"], "likes": 4, "viewed": 127, "published": 3, "date": "1701536954", "time_retrieved": "2024-07-30T17:19:02.311207", "image_code": "#define n_tau 6.2831\nfloat f_n_sd_circle(vec2 o_trn, float n_radius){\n    return length(o_trn)-n_radius;\n}\nfloat f_n_sd_square(vec2 o_trn, float n_radius){\n    return max(abs(o_trn.x),abs(o_trn.y))-n_radius;\n}\nfloat f_n_sd_min(vec2 o_trn, float n_radius){\n    return min(abs(o_trn.x),abs(o_trn.y))-n_radius;\n}\nfloat f_n_sd_wigglycircle(vec2 o_trn, float n_radius, float n_wiggles ){\n    float n_circ = f_n_sd_circle(o_trn, n_radius);\n    float n_radians_nor = fract((atan(o_trn.y,o_trn.x)/n_tau)-.25);\n    return n_circ+sin(n_radians_nor*n_tau*n_wiggles)*0.02;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_trn_pixel = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trn_mouse = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    o_trn_pixel*=1.8;\n    o_trn_mouse*=1.8;\n    //fragColor = vec4(f_n_sd_wigglycircle(o_trn_pixel, 0.2));\n    //return;\n    \n    vec2 o_trn_shape_point = vec2(\n        sin(iTime)*0.25,\n        cos(iTime)*0.25\n    );\n    vec2 o_v_pixel_shape_point = o_trn_pixel - o_trn_shape_point;\n    vec2 o_v_mouse_shape_point = o_trn_mouse - o_trn_shape_point;\n    float n_radius = 0.3;\n    \n    vec2[] a_o = vec2[](\n        vec2(\n            f_n_sd_circle(o_v_pixel_shape_point, n_radius), \n            f_n_sd_circle(o_v_mouse_shape_point, n_radius)\n        ),\n        vec2(\n            f_n_sd_square(o_v_pixel_shape_point, n_radius),\n            f_n_sd_square(o_v_mouse_shape_point, n_radius)\n        ),\n        vec2(\n            f_n_sd_min(o_v_pixel_shape_point, n_radius),\n            f_n_sd_min(o_v_mouse_shape_point, n_radius)\n        ),\n        vec2(\n            f_n_sd_wigglycircle(o_v_pixel_shape_point, n_radius,9.),\n            f_n_sd_wigglycircle(o_v_mouse_shape_point, n_radius,9.)\n        )\n    );\n    float n_idx = (\n        fract(iTime*0.1)*float(a_o.length())\n    );\n    int n_idx_int = int(n_idx);\n    int n_idx_int_next = int(mod(n_idx+1., float(a_o.length())));\n    //n_idx = 3;\n    vec2 o_shapeinfo = a_o[n_idx_int];\n    vec2 o_shapeinfo_next = a_o[n_idx_int_next];\n    \n    vec2 o_shapeinfo_interpolated = vec2(\n        o_shapeinfo * fract(n_idx)\n        + o_shapeinfo_next * (1.-fract(n_idx))\n    );\n    float n_sd = o_shapeinfo_interpolated[0];\n\n    float n_sd2 = f_n_sd_circle(\n        o_trn_pixel - o_trn_mouse, \n        abs(o_shapeinfo_interpolated[1])\n    );\n    float n_sd_abs = pow(abs(n_sd), n_radius);\n    vec3 o_color = (n_sd < 0.)\n        ? vec3(0.878,0.106,0.141)\n        : vec3(0.976,0.941,0.420);\n    \n\n    float n_amp = sin(n_tau * n_sd*20.)*0.2;\n    n_amp = pow(n_amp, 1.);\n    o_color = vec3(\n        n_amp+o_color.x,\n        n_amp+o_color.y, \n        n_amp+o_color.z\n    ); \n    o_color += 1.-smoothstep(0.001, 0.009, abs(n_sd2));\n    // Output to screen\n    fragColor = vec4(abs(n_sd_abs)*o_color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt3BDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 69, 69, 106], [107, 107, 155, 155, 209], [210, 210, 255, 255, 309], [310, 310, 382, 382, 562]], "test": "untested"}
{"id": "dtcfzl", "name": "SH Harmonics", "author": "Peace", "description": "SH harmonics test", "tags": ["spherical", "harmonics", "sh"], "likes": 1, "viewed": 149, "published": 3, "date": "1701529279", "time_retrieved": "2024-07-30T17:19:03.160935", "image_code": "const float PI = 3.14159265358;\n\nvec3 numColor(float x) {\n    float x01 = smoothstep(-1., 1., x);\n    float ax = abs(x);\n    return ax * (mix(vec3(0.2, 0, 1), vec3(1, 0, 0.2), x01) + vec3(0, .8, 0) * ax * ax) * (0.9 + sin(x * PI * 8.) * 0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy) / iResolution.y * 1.1;   \n    fragColor = vec4(0,0,0,1);\n    \n    float l = dot(uv, uv);\n    vec2 p = vec2(atan(-sqrt(1.-l), uv.x) - iTime, acos(-uv.y));\n    float x = cos(p.y*4.)*cos(p.x*3.);\n    vec3 col = numColor(x);\n    \n    float w = fwidth(uv).x * 4.;\n    col *= smoothstep(1., 1.-w, l);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtcfzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 57, 57, 244], [246, 246, 303, 303, 676]], "test": "untested"}
{"id": "DlcBDB", "name": "Motion Extraction Demo", "author": "Quentin765", "description": "Emphasizes movements", "tags": ["webcam", "motion"], "likes": 4, "viewed": 478, "published": 3, "date": "1701520269", "time_retrieved": "2024-07-30T17:19:03.936861", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    float a = 5./iResolution.y;\n    // Output to screen\n    fragColor = (\n    (texture(iChannel0,uv)+\n    texture(iChannel0,uv-vec2(a,a))+\n    texture(iChannel0,uv-vec2(-a,a))+\n    texture(iChannel0,uv-vec2(a,-a))+\n    texture(iChannel0,uv-vec2(-a,-a))\n    -2.5)*.6+\n    texture(iChannel1,uv)\n    );\n}\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = (\n    texture(iChannel0,uv)*vec4(1. , -.2, -.6, 0.)+\n    texture(iChannel1,uv)*vec4(0.5, 0.7, .1 , 0.)+\n    texture(iChannel2,uv)*vec4(.1 , 0.7, 0.5, 0.)+\n    texture(iChannel3,uv)*vec4(-.6, -.2, 1. , 0.)+\n    (vec4(.5)-texture(iChannel0,uv))\n    );\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,uv);\n}", "buffer_b_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,uv);\n}", "buffer_c_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,uv);\n}", "buffer_d_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlcBDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 451]], "test": "untested"}
{"id": "ctcBWB", "name": "ShaderToy_5_R/T/S", "author": "tbx", "description": "5", "tags": ["learning"], "likes": 1, "viewed": 159, "published": 3, "date": "1701512317", "time_retrieved": "2024-07-30T17:19:04.828477", "image_code": "#define PI 3.141592653\n#define COUNT 20.0\n\nfloat drawCoord(vec2 uv)\n{\n   float x = distance(vec2(uv.x, 0.0), vec2(0.0, 0.0));\n   float y = distance(vec2(0.0, uv.y), vec2(0.0, 0.0));\n   \n   return 1e-3 / x + 1e-3 / y;\n}\n\nfloat net(vec2 coord)\n{\n    float xline = cos(coord.x * PI * COUNT);\n    xline = step(1.0 - 1e-1, xline);\n    \n    float yline = cos(coord.y * PI * COUNT);\n    yline = step(1.0 - 1e-1, yline);\n    \n    return xline + yline;\n}\n\nmat2 toRotate(float angle)\n{\n    mat2 rotate = mat2(cos(angle), -sin(angle),\n                    sin(angle), cos(angle));\n    return rotate;\n}\n\nfloat start(vec2 uv, vec2 p, float rotate, float scale)\n{\n    mat2 rotateMat = toRotate(rotate);\n    \n    uv -= p;\n    uv = rotateMat * uv;\n    uv *= (1.0 + 1e-1/scale);\n    uv += p;\n\n    float dx = 1.0 - distance(vec2(uv.x, 0.0), vec2(p.x, 0.0));\n    float dy = 1.0 - distance(vec2(0.0, uv.y), vec2(0.0, p.y));\n    \n    dx = clamp(dx, 0.0, 1.0);\n    dy = clamp(dy, 0.0, 1.0);\n    \n    dx *= dx;\n    dy *= dy;\n    \n    dx *= dx;\n    dy *= dy;\n    \n    dx *= dx;\n    dy *= dy;\n    \n    return dx * dy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float asp = iResolution.x / iResolution.y;\n    \n    vec2 coord = uv * 2.0 - 1.0;\n    \n    vec2 aspCoord = vec2(coord.x * asp, coord.y);\n    \n    vec3 col = vec3(0.0);\n    \n    col += net(aspCoord) * 0.125;\n    \n    col += drawCoord(aspCoord);\n    \n    vec3 baseCol = vec3(0.1, 0.3, 0.6) * 4.0;\n    \n    col += start(aspCoord, vec2(0.5), iTime * 0.5, 1.0) * baseCol;\n    col += start(aspCoord, vec2(-0.5, 0.5), iTime * 1.0, 0.5) * baseCol;\n    col += start(aspCoord, vec2(-0.5), iTime * 1.5, 0.25) * baseCol;\n    col += start(aspCoord, vec2(0.5, -0.5), iTime * 2.0, 0.125) * baseCol;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctcBWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 69, 69, 218], [220, 220, 243, 243, 445], [447, 447, 475, 475, 589], [591, 591, 648, 648, 1093], [1095, 1095, 1152, 1202, 1896]], "test": "untested"}
{"id": "Dl3BWB", "name": "litte pathtracing reflections", "author": "ich", "description": "just some simple pathtracing with a very straightforward material model.", "tags": ["pathtracingreflectionsmirrordiffuse"], "likes": 3, "viewed": 195, "published": 3, "date": "1701512076", "time_retrieved": "2024-07-30T17:19:05.950477", "image_code": "#define pi 3.141\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n\tvec4 c = texture(iChannel0, uv);\n    \n    c.rgb = pow(c.rgb, vec3(1./3.));\n    fragColor = c;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi 3.141\n\nfloat n31(vec3 n)\n{\n\treturn fract(sin(dot(n, vec3(12.9898,78.233,12.5429))) * 43758.5453);\n}\n\nfloat n11(float n)\n{\n\treturn n31(vec3(n + 259.753, n * 87.231, (n - 2.97) * 754.234));\n}\n\nvec3 n33(vec3 n)\n{\n\t\tfloat r0 = n31(n);\n\t\tfloat r1 = n31(n + r0);\n\t\tfloat r2 = n31(n + r1);\n\t\treturn vec3(sin(r0), sin(r1), sin(r2));\n}\n\nfloat sphere(vec3 ro, vec3 rd, vec3 c, float r)\n{   \n    vec3 a = rd * (ro - c);\n    float b = dot(rd, rd);\n    float p = dot(a, vec3(2)) / b;\n    a = ro - c;\n    float q = (dot(a, ro - c) - r * r) / b;\n    p = p / 2.;\n    q = p * p - q;\n    \n    if (q < 0.)\n        return 0.;\n    \n    q = sqrt(q);\n    float l1 = -p + q;\n    float l2 = -p - q;\n    \n    if (l1 > 0. && l2 > 0.)\n        return min(l1, l2);\n    else\n        return max(l1, l2);\n}\n\nfloat plane(vec3 ro, vec3 rd, vec3 o, vec3 n)\n{\n\treturn (dot(n, o) - dot(n, ro)) / dot(n, rd);\n}\n\nstruct material_t {\n\tbool light;\n\tbool metal;\n\tfloat roughness;\n\tvec3 color;\n};\n\nbool scene(vec3 ro, vec3 rd, out vec3 p, out vec3 n, out material_t m)\n{\n\tint si = -1;\n\tfloat lmin;\n\n\tconst int sz = 9;\n\tvec3 sc[sz] = vec3[sz] (\n\t\t\tvec3(0, 0, 5),\n\t\t\tvec3(-1, 0, 5),\n\t\t\tvec3(1, 0, 5),\n\t\t\tvec3(1, 1, 5),\n\t\t\tvec3(1, -1, 5),\n\t\t\tvec3(0, -1, 5),\n\t\t\tvec3(0, 1, 5),\n\t\t\tvec3(-1, 1, 5),\n\t\t\tvec3(-1, -1, 5)\n\t);\n\n\tfor (int i = 0; i < sz; ++i) {\n\t\tfloat l = sphere(ro, rd, sc[i], .5);\n\t\tif (l > 0. && (si == -1 || l < lmin)) {\n\t\t\tlmin = l;\n\t\t\tsi = i;\n\t\t}\n\t}\n\n\tconst int pz = 6;\n\tvec3 pc[pz] = vec3[pz] (\n\t\tvec3(0, 0, 6.5),\n\t\tvec3(0, 0, -1), \n\t\tvec3(-1.5, 0, 0),\n\t\tvec3(1.5, 0, 0),\n\t\tvec3(0, -1.5, 0),\n\t\tvec3(0, 1.5, 0)\n\t);\n\tvec3 pn[pz] = vec3[pz] (\n\t\tvec3(0, 0, -1),\n\t\tvec3(0, 0, 1),\n\t\tvec3(1, 0, 0),\n\t\tvec3(-1, 0, 0),\n\t\tvec3(0, 1, 0),\n\t\tvec3(0, -1, 0)\n\t);\n\tbool b = false;\n\tfor (int i = 0; i < pz; ++i) {\n\t\tfloat l = plane(ro, rd, pc[i], pn[i]);\n\t\tif (l > 0. && (si == -1 || l < lmin)) {\n\t\t\tlmin = l;\n\t\t\tsi = sz + i;\n\t\t\tb = true;\n\t\t}\n\t}\n\n\tif (si == -1)\n\t\treturn false;\n\n\tp = ro + rd * lmin;\n\tm.color = mix(n33(vec3(si + 1)), vec3(1), .5);\n\tm.metal = false;\n\t/* m.metal = n11(floor(iTime * .2) + si + 5) < .2; */\n\tm.roughness = n11(floor(iTime * .2) + float(si) + 10.);\n\tm.light = n11(floor((iTime) * .2 + 1.) + float(si) + 2.) < .13;\n\n\tif (si < sz)\n\t\tn = normalize(p - sc[si]);\n\telse\n\t\tn = pn[si - sz];\n\n\treturn true;\n}\n\nvec3 rotate(vec3 v, float r, vec3 n)\n{\n\tvec3 v0 = ((v * n) / (v * n)) * n;\n\tvec3 v1 = v - v0;\n\tvec3 w = cross(n, v1);\n\tfloat x0 = cos(r) / length(v1);\n\tfloat x1 = sin(r) / length(w);\n\treturn length(v1) * (x0 * v1 + x1 * w);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 dims = iResolution.xy;\n    vec2 pixel_coord = fragCoord;\n\n\t//float t = iTime * pi * 2.;\n\tvec2 uv = (pixel_coord - dims * .5) / dims.y;\n\tvec3 c = vec3(0);\n\n\tvec3 ro = vec3(0);\n\tvec3 rd = normalize(vec3(vec2(-uv.x, uv.y), 1));\n\t/* vec3 rd = normalize(vec3(uv, 1)); */\n\n\t//vec3 b = vec3(cos(t) * 3., 3, sin(t) * 1.83);\n\n\tbool hl = false;\n\tvec3 rc = vec3(1, 1, 1);\n\tfloat rl = 0.;\n\tvec3 p = ro;\n\tvec3 n;\n\tmaterial_t m;\n\n\tfor (int i = 0; i < 10; ++i) {\n\t\tif (scene(ro, rd, p, n, m)) {\n\t\t\tif (m.light) {\n\t\t\t\thl = true;\n\t\t\t\trc *= m.color;\n\t\t\t\trc /= pow((rl * .05 + 1.), 2.);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!m.metal)\n\t\t\t\trc *= m.color;\n\n\t\t\trl += length(p - ro);\n\t\t\tro = p;\n\n\t\t\tvec3 rr = normalize(reflect(rd, n));\n\t\t\tvec3 rn = normalize(n + n33(p + mod(iTime, 1.)) - .5);\n\n\t\t\trd = normalize(mix(rr, rn, m.roughness));\n\t\t\tro += rd * .001;\n\n\t\t} else {\n\t\t\trc = vec3(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* rc += n; */\n\n\tif (!hl)\n\t\trc = vec3(0, 0, 0);\n\n\t/* c += mix(rc, imageLoad(img_output, ivec2(pixel_coord)).rgb, max(0., 1. - delta_time)); */\n\tc = rc;\n\n    {\n        vec2 uv = fragCoord / iResolution.xy;\n        vec3 storedC = texture(iChannel0, uv).rgb;\n        c = mix(storedC, c, vec3(.05));\n    }\n    \n    fragColor = vec4(c, 1);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl3BWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 75, 75, 214]], "test": "untested"}
{"id": "ct3BWB", "name": "ShaderToy_4_Try", "author": "tbx", "description": "4", "tags": ["learning"], "likes": 4, "viewed": 218, "published": 3, "date": "1701510655", "time_retrieved": "2024-07-30T17:19:06.777266", "image_code": "#define PI 3.141592653\n#define COUNT 20.0\n#define CR\n\nfloat line(vec2 st, float width)\n{\n    return smoothstep(width, 0.0, abs(st.y - st.x));\n}\n\nfloat drawCoord(vec2 uv)\n{\n   float x = distance(vec2(uv.x, 0.0), vec2(0.0, 0.0));\n   float y = distance(vec2(0.0, uv.y), vec2(0.0, 0.0));\n   \n   return 1e-3 / x + 1e-3 / y;\n}\n\nfloat sphere(vec2 coord, vec2 p, float radius)\n{\n    float d = distance(p, coord);\n    d = abs(d - radius);\n    return 1e-3 / d;\n}\n\nfloat sphereShape(vec2 coord, vec2 p, float radius)\n{\n    float d = distance(p, coord);\n    d /= radius;\n    d = 1.0 - d;\n    d = clamp(d * 24.0, 0.0, 1.0);\n    return d;\n}\n\nfloat net(vec2 coord)\n{\n    float xline = cos(coord.x * PI * COUNT);\n    xline = step(1.0 - 1e-1, xline);\n    \n    float yline = cos(coord.y * PI * COUNT);\n    yline = step(1.0 - 1e-1, yline);\n    \n    return xline + yline;\n}\n\nfloat QuadrantIV(vec2 coord, float warp)\n{\n    float f = step(0.0, -coord.x);\n    f *= step(0.0, coord.y);\n    return abs(warp - f);\n}\n\nfloat QuadrantII(vec2 coord, float warp)\n{\n    float f = step(0.0, coord.x);\n    f *= step(0.0, -coord.y);\n    return abs(warp - f);\n}\n\nfloat flare( vec2 U )                            \n{\t\n    vec2 A = sin(vec2(0, 1.57) + 0.0);\n    U = abs(U * mat2(A, -A.y, A.x)) * mat2(2,0,1,1.7); \n    return 0.2/max(U.x,U.y);                      // glowing-spiky approx of step(max,.2)\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float asp = iResolution.x / iResolution.y;\n    \n    vec2 coord = uv * 2.0 - 1.0;\n    \n    vec2 aspCoord = vec2(coord.x * asp, coord.y);\n    \n    vec3 col = vec3(0.0);\n    \n    col += net(aspCoord) * 0.125;\n    \n    col += drawCoord(coord);\n    \n    aspCoord *= 6.0;\n    \n    float result = 0.0;\n    float stepSize = 0.152;\n    int maxPointCount = 24;\n    float maxPointCount_f = float(maxPointCount);\n    for(int i = 0; i < maxPointCount; i++)\n    {\n        float istep = float(i);\n        vec2 p = vec2(sin(iTime - istep * stepSize), \n                        cos(iTime * 0.5 - istep * stepSize)) * 3.0;\n        float d = 1.0 - distance(aspCoord, p);\n        d = max(d, 0.0);\n        d = d * d * d * d;\n        float attenuation = (maxPointCount_f - istep) / maxPointCount_f;\n        d *= attenuation;\n        result += d;\n        \n        vec2 pf = aspCoord - p;\n        \n        float flare = flare(pf) * attenuation;\n        result += flare;\n    }\n    \n    col += result * vec3(0.1, 0.3, 0.6);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct3BWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 88, 88, 143], [145, 145, 171, 171, 320], [322, 322, 370, 370, 452], [454, 454, 507, 507, 626], [628, 628, 651, 651, 853], [855, 855, 897, 897, 989], [991, 991, 1033, 1033, 1125], [1127, 1127, 1178, 1178, 1366], [1368, 1368, 1425, 1475, 2583]], "test": "untested"}
{"id": "mtdfzl", "name": "Inercia 2023 jam", "author": "kostik1337", "description": "livecoded in ~45 min", "tags": ["livecoding", "inercia"], "likes": 12, "viewed": 368, "published": 3, "date": "1701501424", "time_retrieved": "2024-07-30T17:19:07.660905", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define BPM 130.\n#define INF (1e10)\n#define time iTime\n#define beat (time*BPM/60.)\n#define PI 3.1415926536\n#define rep(p,s) (mod(p,s)-s/2.)\n#define rep2(p,s) (abs(rep(p,2.*s))-s/2.)\n\nfloat hash(float t) {return fract(sin(t)*35628.54654);}\nfloat hash(vec2 t) {return hash(dot(t, vec2(12.6456, 32.63456345)));}\nfloat hash(vec3 t) {return hash(dot(t, vec3(12.6456, 32.63456345, 48.546984)));}\n\nvec3 back(vec2 uv){return texture(iChannel0, uv).rgb;}\nfloat ffts(float t) {return 0.;}\n\nvec3 ct(vec3 p) {\n  if(p.x<p.y) p.xy = p.yx;\n  if(p.y<p.z) p.yz = p.zy;\n  if(p.x<p.y) p.xy = p.yx;\n  return p;\n}\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  float m=max(p.x, max(p.y,p.z));\n  return m>0.? length(p): m;\n}\n\nmat2 mr(float t) {float c=cos(t),s=sin(t); return mat2(c,s,-s,c);}\n\nfloat beatstep(float t, float a) {return floor(t) + smoothstep(0., a, fract(t));}\n\nvec2 polar(vec2 p, float n) {\n  p = vec2(length(p), atan(p.y, p.x));\n  p.y = rep(p.y, PI/n);\n  return p.x * vec2(cos(p.y), sin(p.y));\n}\n\n#define quant(t,s) (floor(t/s)*s)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    vec3 c = vec3(0.);\n    vec3 O=vec3(0.,0.,-1.);\n    vec3 D = vec3(uv, 1.);\n    D.z *= 1.-.8*length(D.xy);\n    D=normalize(D);\n    float I=64.;\n    for(float i=0.; i<I; ++i) {\n        float d = mix(0.1, 5., i/I + hash(uv+time+i));\n        d /= D.z;\n        vec3 op = O+D*d;\n\n        {\n          vec3 p=op;\n          p.z += time;\n          vec3 pos=floor(p-.5);\n          p = rep(p, 1.);\n          p.xz *= mr(beat+hash(pos*1.17));\n          p = ct(abs(p));\n          float m = box(p, vec3(.1, vec2(.01)));\n          float amp = 1.+exp(-fract(beat+quant(hash(pos), .8)));\n          c += amp * .003 / abs(m) * exp(-d*.5);\n        }\n\n        {\n          vec3 p=op;\n          p.z += time;\n          float pz = floor(p.z);\n          p.xy *= mr(p.z + PI/4.*beatstep(beat/4. + quant(hash(pz*1.886), .5) + hash(uv+i+time)*.2, .1));\n          p.z = rep(p.z, 1.);\n          vec3 s=vec3(.2, .2, .02);\n          p = mix(p, ct(abs(p))-.2, .5+.5*cos(PI*beatstep(beat/8., .3)));\n          float m = box(p, s);\n          m = max(m, -box(p, vec3(s.xy-.02, INF)));\n          float amp = 1.+exp(-fract(beat+quant(hash(pz), .8)));\n          c += amp * .008 / abs(m) * exp(-d*.5);\n        }\n\n        {\n          vec3 p=op;\n          p.z += time;\n          float phaseoff = 0.;\n          phaseoff = hash(uv+i+.17*time) * (.5+.5*sin(beat/4.));\n          p.xy *= mr(beatstep(p.z*.2 + phaseoff, .8));\n          p.xy = polar(p.xy, 5.);\n          p.x -= 1.5;\n          float m = length(p.xy)-.05;\n          c += .005 / abs(m) * exp(-d*.5);\n        }\n    }\n    uv = gl_FragCoord.xy / iResolution.xy;\n    vec2 e=vec2(.002, .0);\n    e *= 1.+3.*exp(-3.*fract(beat));\n    vec3 prev = vec3(\n        back(uv-e).r,\n        back(uv).g,\n        back(uv-e).b\n    );\n    prev = min(prev, vec3(2.));\n    c = mix(c, prev.xyz, .7);\n\n    fragColor = vec4(c, 0.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtdfzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 122]], "test": "untested"}
{"id": "ctdfzs", "name": "Frame House", "author": "isaacchurchill", "description": "KIFS experiment. Code isn't the best", "tags": ["3d", "raymarching", "fractal", "raymarcher"], "likes": 6, "viewed": 177, "published": 3, "date": "1701491731", "time_retrieved": "2024-07-30T17:19:08.604381", "image_code": "const int MAX_MARCHES = 300;\nconst float RAYMARCH_THRESHOLD = 0.001;\nconst float NORMAL_EPSILON = 0.001;\n\nmat2 rot_xy(float theta)\n{\n    return mat2(cos(theta), sin(theta),\n                -sin(theta), cos(theta));\n}\n\nvec3 palette(float iter)\n{\n    return 0.5 + 0.5 * sin(iter + vec3(0, 1, 2));\n}\n\nvec4 union_de(vec4 a, vec4 b)\n{\n    if (b.w < a.w) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nfloat box3d_de(vec3 p, vec3 sizes)\n{\n    vec3 temp = abs(p) - sizes;\n    return length(max(temp, 0.0)) + min(max(max(temp.x, temp.y), temp.z), 0.0);\n}\n\nfloat fractal_de(vec3 p, out float iter)\n{\n    float scale = 2.0;\n    float max_i = floor(mod(iTime + 5.0, 5.99)) + 1.0;\n    float s = 1.0;\n    float d = 1e6;\n\n    const float width = 1.0;\n    const float thickness = 0.05;\n    const float r = thickness / 2.0;\n    const float a = (width - thickness) / 2.0;\n    for (float i = 0.0; i < max_i; i++) {\n        vec3 b = abs(p);\n        p.xz = b.xz;\n        if (b.x < b.y) {\n            b.xy = b.yx;\n        }\n        if (b.y < b.z) {\n            b.yz = b.zy;\n        }\n        if (b.x < b.z) {\n            b.xz = b.zx;\n        }\n        float d1 = box3d_de(b - vec3(a, a, width / 4.0), vec3(r, r, width / 4.0)) * s;\n        if (d1 < d) {\n            iter = i;\n        }\n        d = min(d, d1);\n        p -= vec3(0.5, -0.3, 0.5);\n        p *= scale;\n        s /= scale;\n    }\n    return d;\n}\n\nfloat dist_estim(vec3 p, out vec3 col)\n{\n    float iter = 0.0;\n    float scale = 0.4;\n    float fractal = fractal_de(p / scale, iter) * scale;\n    vec3 plane_col = vec3(0.5);\n    if ((mod(p.x, 1.0) > 0.5) != (mod(p.z, 1.0) > 0.5)) {\n        plane_col = vec3(1.0);\n    }\n\n    vec4 de = vec4(palette(iter), fractal);\n    de = union_de(de, vec4(plane_col, abs(p.y + 0.25)));\n\n    col = de.xyz;\n    return de.w;\n}\n\nvec3 calc_normal(vec3 p)\n{\n    const vec2 eps = vec2(0.0, NORMAL_EPSILON);\n    vec3 temp = vec3(0.0);\n    return normalize(vec3(\n        dist_estim(p + eps.yxx, temp),\n        dist_estim(p + eps.xyx, temp),\n        dist_estim(p + eps.xxy, temp)\n        ) - dist_estim(p, temp));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    if (m.x < 0.01 && m.y < 0.01) {\n        m = vec2(0.4, 0.4);\n    }\n    vec2 rot = (m - 0.5) * 4.0;vec3 ray_dir = normalize(vec3(uv, 2.0));\n    mat2 yz_mat = rot_xy(rot.y);\n    mat2 xz_mat = rot_xy(rot.x);\n    ray_dir.yz *= yz_mat;\n    ray_dir.xz *= xz_mat;\n    vec3 ray_endpoint = vec3(0.0, 0.0, -1.0);\n    ray_endpoint.yz *= yz_mat;\n    ray_endpoint.xz *= xz_mat;\n    \n    vec3 light_dir = normalize(vec3(0.3, 1.0, -0.5));\n    \n    for (int march = 0; march < MAX_MARCHES; march++) {\n        vec3 surface_col = vec3(0.0);\n        float dist = dist_estim(ray_endpoint, surface_col);\n        if (dist < RAYMARCH_THRESHOLD) {\n\t\t\tvec3 norm = calc_normal(ray_endpoint);\n            float intensity = max(dot(norm, light_dir), 0.0);\n            vec3 light_col = vec3(0.9);\n            vec3 ambient = vec3(0.1);\n            col = surface_col * (light_col * intensity + ambient);\n            break;\n        }\n        ray_endpoint += ray_dir * dist * 0.5;\n    }\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdfzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 132, 132, 216], [218, 218, 244, 244, 296], [298, 298, 329, 329, 407], [409, 409, 445, 445, 559], [561, 561, 603, 603, 1397], [1399, 1399, 1439, 1439, 1808], [1810, 1810, 1836, 1836, 2090], [2092, 2092, 2149, 2149, 3322]], "test": "untested"}
{"id": "cltfzs", "name": "Fork f Fork Barf  420bongrip 861", "author": "420bongrips247365", "description": "trippy blippy", "tags": ["gradient", "psychedelic", "rainbow", "trippy", "strobe"], "likes": 1, "viewed": 169, "published": 3, "date": "1701486671", "time_retrieved": "2024-07-30T17:19:09.379310", "image_code": "float square(float n)\n{\n    return n*n;   \n}\nfloat bounce = 0.25;\nfloat bounce2 = 0.25;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 res = vec2(1.0, 8.0);\n    vec2 iuv = floor( uv * res )/res;\n    \n    \n    float ww = iResolution.x;\n    float hh = iResolution.y;\n    float sound = texture( iChannel0, vec2(iuv.y, 1.0) ).x*1.0;\n    if (bounce2 < sound*5.0){bounce2 += sound*5.0;}\n    if (bounce2 > sound*13.0){bounce2 -= sound*13.0;}\n    bounce2 /= 2.0;\n    if (bounce < bounce2){bounce += bounce2/5.0;}\n    if (bounce > bounce2){bounce -= bounce2/5.0;}\n    bounce = clamp(bounce, 1.0, 233.0);\n    float time2 = iTime+2.0*(sin(square(1.0*(uv.x-0.5)) + square(1.0*(uv.y-0.5))));\n    \n    float r = sin(time2/2.0)*20.0*bounce;\n    float p = (square(fragCoord.x-ww/2.0) + square(fragCoord.y-hh/5.0))*((sin(time2/8.0)+1.0)/2.0)*((time2-2.0)*5.0)*(bounce/8.0);\n    \n    fragColor.r = sin(p/500.0)+1.0*bounce/2.0;\n    fragColor.g = sin(p/300.0+r/0.5)+1.*bounce/2.0;\n    fragColor.b = sin(p/300.0+r/0.2)+1.0*bounce/3.0;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35408, "src": "https://soundcloud.com/aya_yco/in-memory-of-reelle?si=444bf5b43d0d4eb293e7b292afe1ba51&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltfzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 44], [89, 89, 146, 146, 1084]], "test": "untested"}
{"id": "cltBzs", "name": "egg house", "author": "jorge2017a2", "description": "egg house", "tags": ["egghouse"], "likes": 17, "viewed": 167, "published": 3, "date": "1701485736", "time_retrieved": "2024-07-30T17:19:10.399582", "image_code": "//----------image\n//por jorge2017a2-\n//referencia de funciones IQ.\n// ---1 de dic-2023\n\n#define MAX_STEPS 100\n#define MAX_DIST 255.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n//Ellipsoid - bound (not exact!)   (https://www.shadertoy.com/view/tdS3DG)\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\nfloat sdRhombus( vec3 p, float la, float lb, float h, float ra )\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n    p.y=p.y+10.0;\n    vec3 p0=p;\n\t\n    float planeDist1 = p.y+10.0;  //piso inf\n    res =opU2(res, vec2(planeDist1,100.0));\n    \n    //p.y=p.y-5.0;\n    p.z=opRep1D( p.z, 150.0 );\n    \n    vec3 pos=vec3(-10.0,0.0,10.0);\n    float d1= sdEllipsoid(p-pos, vec3(40.0,65.0,40.0)  );\n    float d2= sdEllipsoid(p-pos, vec3(30.0,60.0,30.0)  );\n    float df=Difference(d1,d2);\n    \n    float d3a= sdBox( p-pos, vec3(10.0,20.0,45.0));\n    float d3b= sdBox( p-pos, vec3(45.0,20.0,10.0));\n    \n    vec2 p2a=vec2(-2.0,20.0);\n    vec2 p2b=vec2( 2.0,20.0);\n    float d5a=sdCircle(p.xy-pos.xy-p2a, 10.0 );\n    float d5b=sdCircle(p.xy-pos.xy-p2b, 10.0 );\n    float d5f= Intersect(d5a,d5b);\n    \n    \n    df=Difference(df, d3a);\n    df=Difference(df, d3b);\n    df=Difference(df, d5f);\n    \n    float t=iTime;\n    \n    float d4=sdSphere(p-pos-vec3(0.0,65,0.0),15.0 );\n    \n    df=Difference(df, d4);\n    \n    res =opU2(res, vec2(df,100.0));\n    \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{ vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{   vec4 mPtr = iMouse;\n    mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n     float tCur = iTime;\n     float az = 0.;\n     float el = -0.15 * PI;\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n     mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 pallete(float t) {\n    vec3 a = vec3(0.2);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c*t + d));\n}\n\n//iq cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    \n     vec3 V = normalize(ro - p);\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n    \n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.5)*specular*specular;\n    \n    return colOut;\n}\n\n\nvec3 Getluz(vec3 ro,vec3 p, vec3 lp, vec3 lcol,vec3 n, float diffp, vec3 specp)\n{\n    vec3 v=normalize(ro-p);\n    vec3 h=normalize(lp+v);\n    vec3 l=normalize(lp-p);\n    float ndh=max(0.0,dot(n,h));\n    float ndl=max(0.0,dot(n,l));\n    float ndv=max(0.0,dot(n,v));\n    \n    float diff=ndl*diffp;\n    vec3  spec=0.8*pow(ndl,10.0)*specp;\n    vec3 col=(diff+spec*lcol);\n    return col;\n    \n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tvec3 col;\n    if (i==100 )\n    { col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n    return vec3(0.0);\n}\n\n\n\nfloat N21 (vec2 p){\n    return fract( sin(p.x *  100. + p.y * 6574.) * 5647.);\n}\n\nfloat SmoothNoise(vec2 uv){\n    vec2 lv = smoothstep(0., 1., fract(uv));\n    vec2 id = floor(uv);\n    \n    float bl = N21(id);\n    float br = N21(id + vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    \n    \n    float tl = N21(id + vec2(0, 1));\n    float tr = N21(id + vec2(1, 1));\n    float t = mix(tl, tr, lv.x);\n   \n    return mix(b, t, lv.y);\n}\n\nfloat smoothNoise2(vec2 uv){ \n    float c = SmoothNoise(uv*4.);\n    c += SmoothNoise(uv*8.)* 0.5;\n    c += SmoothNoise(uv*16.) * 0.25;\n    c += SmoothNoise(uv*32.) * 0.125;\n    c += SmoothNoise(uv*64.) * 0.0625;\n    \n    return c/2.;\n}\n\n///https://www.shadertoy.com/view/dttcDN\nvec3 nubes(vec2 uv )\n{float c = smoothNoise2(uv) + 0.2 + 0.4*sin(iTime);\n    vec3 col = vec3(c/1.5, c/1.2, c);\n    return col;\n}\n\n\n\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col+nubes(rd.xz+rd.xz)*1.2, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }\n     \n     if (id_color==41)\n     { \n         vec3 colp = palette( sin(21.29*0.25), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n        return colp;\n     }  \n    \n   if (id_color>=100 )\n   { return  getColorTextura( p, nor,id_color); }\n      \n  return vec3(0.0);\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n        \n        result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        \n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n        \n        \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n     vec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n    vec2 mouseUV = iMouse.xy/iResolution.xy; // Range: <0, 1>\n   \n    float t0=iTime;\n    float t=mod(t0*5.0,500.0);\n    float py=60.0*sin(t0*0.5);\n \tlight_pos1= vec3(-10.0, 120.0+py, -10.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 120.0+py, 10.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n  \n   float t2=iTime;\n   float pz=t0*10.0;\n   vec3 ro=vec3(-10.0,-10.0,-70.0+pz);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, clamp(sin(t0),-2.2,0.1));\n   \n      float tr=mod(t0,5.0);\n      if(20.*sin(t*0.025)>0.0)\n      rd= rotate_y(rd, sin(t0));\n      else\n      rd= rotate_y(rd, -sin(t0));\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\nstruct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\nvec3 hsv(vec3 c)\n{ vec4 k=vec4(1.,2./3.,1./3.,3.);\n  vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n  return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random(vec2 uv) \n{ return fract(sin(dot(uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.7333, 0.1412, 0.1412), //33\nvec3(0.1843, 0.3333, 0.1843), //34\n vec3(0.6549, 0.6549, 0.9922), //35\n vec3(0.8549, 0.8549, 0.8549)  //36\n);\n\nvec3 getColor(int i)\n{   //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 )  return Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltBzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[513, 513, 549, 549, 570], [571, 571, 603, 603, 687], [689, 689, 724, 724, 747], [749, 749, 793, 793, 820], [821, 821, 861, 861, 888], [889, 889, 934, 934, 962], [963, 963, 999, 999, 1044], [1046, 1046, 1080, 1080, 1176], [1177, 1177, 1211, 1211, 1302], [1303, 1303, 1337, 1337, 1428], [1431, 1431, 1456, 1456, 1475], [1476, 1476, 1501, 1501, 1520], [1521, 1521, 1557, 1557, 1585], [1663, 1663, 1700, 1700, 1783], [1786, 1786, 1852, 1852, 2103], [2106, 2106, 2131, 2131, 3107], [3109, 3109, 3133, 3133, 3295], [3297, 3297, 3345, 3345, 3624], [3627, 3698, 3734, 3734, 3937], [3938, 4009, 4033, 4033, 4282], [4284, 4284, 4328, 4328, 4649], [4651, 4651, 4688, 4688, 4945], [4947, 4947, 4970, 4970, 5125], [5127, 5168, 5240, 5240, 5283], [5286, 5286, 5376, 5376, 6359], [6362, 6362, 6443, 6443, 6751], [6753, 6753, 6802, 6802, 7076], [7080, 7080, 7099, 7099, 7160], [7162, 7162, 7189, 7189, 7508], [7510, 7510, 7538, 7538, 7745], [7747, 7788, 7810, 7810, 7916], [7921, 7921, 7953, 7953, 8173], [8176, 8176, 8246, 8246, 8635], [8637, 8637, 8664, 8664, 8753], [8755, 8755, 8813, 8813, 8861], [8863, 8863, 8886, 8886, 8998], [9001, 9001, 9032, 9032, 9687], [9689, 9689, 9746, 9746, 10531]], "test": "untested"}
{"id": "DldfRs", "name": "[live] Inercia 2023 shader jam", "author": "w23", "description": "Ran out of time to clean artifacts, add AO and other things.", "tags": ["raymarching", "sdf", "smin"], "likes": 11, "viewed": 212, "published": 3, "date": "1701484732", "time_retrieved": "2024-07-30T17:19:11.294189", "image_code": "float t, tt;\nconst vec3 e=vec3(0.,1.,.001);\nfloat ha(float f){return fract(sin(f)*26374.236);}\nfloat ha(vec2 v){return ha(dot(v,vec2(17.5326,57.3224)));}\nfloat no(vec2 v){vec2 V=floor(v);v-=V;v*=v*(3.-2.*v);\n  return mix(\n    mix(ha(V+e.xx), ha(V+e.xy), v.y),\n    mix(ha(V+e.yx), ha(V+e.yy), v.y), v.x);\n}\n#define rm(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nfloat vmax(vec2 v){return max(v.x,v.y);}\n#define box(p,s) vmax(abs(p)-(s))\n#define PT(t,p) (floor(t)+pow(fract(t),p))\n#define PTN(t,p) (floor(t)+1.-pow(1.-fract(t),p))\n\nfloat h(vec2 p){\n  //float ht=\n  float d =\n    sin(6.28*no(p)+PT(tt/4.,2.))*.4;\n  d -= .5*no(p*.45-2.*e.yx*PTN(tt/2.,2.));\n  return d;\n}\n\nfloat smin(float a,float b,float k){\n  float h=max(0.,1.-abs(b-a)/k);\n  return min(a,b)-h*h*k/4.;\n}\n\nfloat w(vec3 p) {\n  float d = abs(p.y - h(p.xz)) - .02;\n  d*=.5;\n  //d = min(d, length(p)-1.);\n  \n  float sc=1.;\n  vec2 C=floor(p.xz*sc),cc=fract(p.xz*sc)-.5;\n  vec3 pc=vec3(cc,p.y).xzy;\n  float r=.05+.2*ha(C);\n  float pt=PT(tt,3.);\n  pc.y-=.5-.3*sin(ha(C+.2)*6.283+pt*2.);\n  pc.x+=.6*(ha(C+.3)-.5);\n  pc.z+=.6*(ha(C+.4)-.5);\n  d=smin(d,(length(pc)-r)*.3,.3);\n  d=max(d,box(p.xz,4.));\n  return d;\n}\nvec3 no(vec3 p){\n  return normalize(w(p)-vec3(\n    w(p-e.zxx),\n    w(p-e.xzx),\n    w(p-e.xxz)\n  ));\n}\n\nfloat tr(vec3 ro,vec3 rd,float l,float L){\n  for(float i=0.;i<200.;++i){\n    float d=w(ro+rd*l);l+=d;\n    if(d<l*.001||l>L)break;\n  }\n  return l;\n}\n\n\n// LOL COPYPASTE THANKS IQ!!11cos(0.)\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 pal(float t){\n  return palette(t,\n    vec3(.5),\n    vec3(.5),\n    vec3(2.,.8,.3),\n    vec3(.5,.25,.2));\n}\n\nfloat ao(vec3 p,vec3 n,float N,float L){\n  float k=0.;\n  for (float i=0.;i<N;i++){\n    float l=(i+1.)*L/N;\n    float d=w(p+n*l)*3.;\n    k+=step(l,d);\n  }\n  return k/N;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy-.5);\n    uv.x *=iResolution.x/iResolution.y;\n    t=iTime;\n    tt=t*140./60.;\n\n\t//vec2 uv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n\t//uv -= 0.5;\n\t//uv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n  \n  vec3 C=vec3(0.),ro=vec3(0.,0.,10.),rd=normalize(vec3(uv,-1.5));\n  mat2 X=rm(.5),Y=rm(.6+t*.2);\n  rd.yz*=X;ro.yz*=X;\n  rd.xz*=Y;ro.xz*=Y;\n  float L=20.,l=tr(ro,rd,0.,L);\n  \n  if (l<L){\n    vec3 p=ro+rd*l,n=no(p);\n    vec3 sd=normalize(vec3(.3,.5,.1));\n    float pp=floor(p.y*30./1.5)/30.;\n    pp+=.2*ha(pp*3.);\n    vec3 m=pal(pp);\n    C=m*vec3(.03);//*ao(p,n,5.,1.);\n    float sh=step(5.,tr(p,sd,.05,5.));\n    C+=m*max(0.,dot(n,sd))*.7*sh;\n    C+=m*pow(max(0.,dot(n,normalize(n+sd))), 150.)*.7*sh;\n  }else{\n    C=vec3(.6,.8,.9);\n  }\n  \n  C*=smoothstep(1.,.5,length(uv));\n\n\tfragColor = vec4(sqrt(C),0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DldfRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 62, 62, 94], [95, 95, 112, 112, 153], [154, 154, 171, 171, 305], [355, 355, 374, 374, 395], [524, 524, 540, 554, 660], [662, 662, 698, 698, 761], [763, 763, 780, 780, 1161], [1162, 1162, 1178, 1178, 1263], [1265, 1265, 1307, 1307, 1412], [1415, 1453, 1525, 1525, 1568], [1569, 1569, 1587, 1587, 1679], [1681, 1681, 1721, 1721, 1850], [1852, 1852, 1909, 1959, 2836]], "test": "untested"}
{"id": "DldfRl", "name": "Inercia DemoParty #062 (YOT)", "author": "byt3_m3chanic", "description": "My code from the Shader Jam / Inercia DemoParty - https://2023.inercia.pt/", "tags": ["raymarching", "truchet", "demoparty", "inercia"], "likes": 25, "viewed": 212, "published": 3, "date": "1701480361", "time_retrieved": "2024-07-30T17:19:12.580750", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Inercia DemoParty Shader Jam!! Making my last Truchet for the year!!\n    \n    Year of Truchets #062\n    12/01/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MIN_DIST .001\n#define MAX_DIST 90.\n#define SCALE .775\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\n\nfloat box(vec3 p, vec3 b, float r) {\n  vec3 q = abs(p)-b;\n  return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.)-r;\n}\nfloat trs(vec3 p, vec2 t){\n  vec2 q=vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nvec3 shp,fhp;\nvec2 sip,bid;\nfloat thsh;\n\nconst float sz = 1./SCALE;\nconst float hf = sz/2.;\nconst float bs = hf*.82;\nconst float cs = (hf*1.15);\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0);\n  p.z += 4.;\n  p.x -= T*.2;\n  \n  vec2 qid = floor((p.xy+hf)/sz);\n  vec3 qm = vec3(mod(p.xy+hf,sz)-hf,p.z);\n  \n  float hs = hash21(qid);\n  if(hs>.5) qm.x=-qm.x;\n  \n  vec2 q = length(qm.xy-hf)<length(qm.xy+hf)?qm.xy-hf:qm.xy+hf;\n  vec3 q3 = vec3(q,qm.z);\n  \n  float thx = .125+.11*sin(3.5+p.y*.75);\n  float t = trs(q3,vec2(hf,thx));\n\n  sip = qid;\n  thsh = hs;\n  \n  if(t<res.x) {\n    res = vec2(t,1.);\n    shp = qm;\n  }\n\n  float bx = box(qm+vec3(0,0,1.45),vec3(bs),.04);\n  if(bx<res.x) {\n    res = vec2(bx,2.);\n  }\n  \n  float cx = box(qm,vec3(bs),.04);\n  float sx = length(qm)-cs;\n  float nx = max(cx,-sx);\n  if(nx<res.x&&hs>.82) {\n      res = vec2(nx,3.);\n  }\n  return res;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\nvec3 thp,ghp;\nvec2 tip,fid;\nfloat hsh;\nvec4 FC = vec4(.30,.33,.35,0.);\nvec3 hue(float a){\n  return  .45 + .45 * cos(PI2* a * vec3(1.,.15,.25));\n}\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec3 p = ro;\n    \n    for(int i=0;i<164;i++) {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<62? ray.x*.25: ray.x*.75;\n        m  = ray.y;\n    } \n \n    thp = shp;\n    tip = sip;\n    hsh = thsh;\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(1,8,0);\n        vec3 l = normalize(lpos-p);\n\n        float diff = clamp(dot(n,l),0.,1.);\n        \n        float shdw = 1.0;\n        for( float t=.05; t < 18.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  .75 * pow(max(dot(view, ret), 0.), 25.);\n        vec3 h = vec3(.05);\n\n        if(m==1.) {\n            thp /= 1./SCALE;\n            float dir = mod(tip.x + tip.y,2.) * 2. - 1.;  \n            vec2 uv = thp.xy-sign(thp.x+thp.y+.001)*.5;\n            float angle = atan(uv.x, uv.y);\n            float a = sin( dir * angle * 6. + T * 2.25);\n            a = abs(abs(a)-.45)-.35;\n            \n            vec3 nz = hue((p.x*.5+(T*.12))*.25);\n            h = mix(nz, vec3(1), smoothstep(.01, .02, a)); \n\n            ref= h==vec3(1)? vec3(0) : h ;\n        }\n        \n        if(m==2.) {\n            h=vec3(hsh*.5);\n            ref=h;\n        }\n  \n        if(m==3.) {   \n            h = hue((p.x*.5+(T*.12))*.25)*.3;\n            ref=h;\n        }\n        \n        C = h*diff+min(spec,shdw);\n        C = mix(FC.rgb,C,  exp(-.00005*d*d*d));\n    \n        ro = p+n*.001;\n        rd = reflect(rd,n);\n    \n    }else{\n        C = FC.rgb;\n    } \n    return vec4(C,d);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    \n    float zoom = 6.;\n    vec3 ro = vec3(uv*zoom,-(zoom+10.));\n    vec3 rd = vec3(0,0,1.);\n\n    mat2 rx = rot(.4), ry = rot(2.8);\n    ro.yz *= rx,ro.xz *= ry;\n    rd.yz *= rx,rd.xz *= ry;\n\n    vec3 C = vec3(0),ref=vec3(0),fil=vec3(1);\n    \n    float d = 0.,a = 0.;\n    float numBounces = 2.;\n    \n    for(float i=0.; i<numBounces; i++) {\n        d =0.;\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.) a = d;\n    }\n\n    float ff = hash21(uv);\n    if(ff>.5) C = mix(C,clamp(C-.05,vec3(0),vec3(1)),ff);\n    C = mix(FC.rgb,C,  exp(-.000001*a*a*a));\n\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DldfRl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[451, 451, 471, 471, 516], [517, 517, 541, 541, 599], [601, 601, 637, 637, 720], [721, 721, 747, 747, 810], [957, 957, 975, 975, 1677], [1679, 1679, 1709, 1709, 1948], [2020, 2020, 2038, 2038, 2094], [2095, 2095, 2180, 2180, 4037], [4039, 4039, 4080, 4080, 4803]], "test": "untested"}
{"id": "cttBRs", "name": "integer fractal (115 chars)", "author": "ArmandB", "description": "a simple fractal I discovered while trying to create a hash function", "tags": ["fractal"], "likes": 1, "viewed": 140, "published": 3, "date": "1701480046", "time_retrieved": "2024-07-30T17:19:13.916179", "image_code": "#define u uvec2(c/iResolution.y*99.)\nvoid mainImage(out vec4 o, vec2 c){\n    o = vec4(fract(float(u.x & u.y)/9.),.4,.4,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cttBRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 72, 72, 124]], "test": "untested"}
{"id": "ctdBRl", "name": "Estonia", "author": "sp4ghet", "description": "https://maps.app.goo.gl/BowjuLFbas8QUeTR8\n\nInercia 2023 Shader Jam ", "tags": ["bollard"], "likes": 3, "viewed": 175, "published": 3, "date": "1701473238", "time_retrieved": "2024-07-30T17:19:14.938446", "image_code": "const float PI = acos(-1.);\nconst float TAU = PI*2.;\nvec3 up = vec3(0,1,0);\nmat2 r2d(float t){\n  float s = sin(t), c = cos(t);\n  return mat2(c,s,-s,c);\n}\n\nfloat sdb(vec3 p, float radius, float roundness, float height){\n  vec2 d = vec2(length(p.xz) - 2.*radius + roundness, abs(p.y) - height);\n  return min(max(d.x,d.y), 0.0) + length(max(d,0.0)) - roundness;\n}\n\nvec4 mapp(vec3 q){\n  vec3 p = q;\n  float d = 10000.0;\n  vec3 mat = vec3(1);\n  \n  float sp = sdb(p, 0.05, 0.02, 1.);\n  mat2 rot = r2d(PI * .15);\n  p.xy *= rot;\n  vec3 upslant = up;\n  upslant.xy *= rot;\n  float sub = sdb(p-upslant*.7, 0.1, 0.01, 0.15);\n  sp = max(sp, -sub);\n  d = min(sp, d);\n  \n  p = q;\n  float bl = sdb(p-up*.7, 0.04, 0.02, 0.25);\n  vec3 blk = vec3(0.01);\n  if(abs(dot(normalize(p.xz), vec2(0,1))) > 0.9 && abs(p.y - .7) < .14){\n    blk = vec3(.8, .8, .01);\n  }\n  mat = bl < d ? blk : mat;\n  d = min(d,bl);\n  \n  return vec4(d, mat);\n}\n\nvec4 mapt(vec3 p){\n  float t = iTime;\n  float x = length(p.xz) - .25;\n  float y = p.y;\n  float th = atan(y,x);\n  float ph = atan(p.z, p.x);\n  float r = length(vec2(x,y)) - 1.5;\n  p = vec3(r, th+t, ph);\n  p = p.yzx;\n  p.y = mod(p.y, 2.) - 1.;\n  p.x = mod(p.x, .25) - .125;\n  \n  return mapp(p);\n}\n\nvec4 map(vec3 q){\n  vec3 p = q;\n  float time = iTime;\n  float t = fract(time * .03);\n  p -= vec3(-.1, 0., -.2);\n  p.xy *= r2d(TAU * .1);\n  \n  for(int i=0; i<10; i++){\n    p.zy *= r2d(TAU * t + .01);\n    p.xz *= r2d(-TAU * .5 * t);\n    p.z -= .1;\n    p = abs(p);\n  }\n  float bpm = 135.;\n  float beat = time * bpm / 60.;\n  \n  if(mod(floor(beat * .5),3.) < 1.){\n    return mapt(q);\n  }\n  if(mod(floor(beat * .5),3.) < 2.){\n    return mapp(q);\n  }\n  \n  return mapp(p);\n}\n\nvec3 normal(vec3 p){\n  vec2 d = vec2(0.001, 0.);\n  return normalize(vec3(\n    map(p + d.xyy).x - map(p-d.xyy).x,\n    map(p + d.yxy).x - map(p-d.yxy).x,\n    map(p + d.yyx).x - map(p-d.yyx).x\n  ));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = iTime;\n\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord/iResolution.xy;\n    \n  vec2 pt = uv - 0.5;\n  pt /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec3 f = vec3(0);\n  f = uv.y < 1./3. ? vec3(1) : f;\n  f = uv.y > 2./3. ? vec3(0,114./255., 206./255.) : f;\n  \n  vec3 c = vec3(uv,0.);\n  \n  vec3 ro = vec3(0,1,-4);\n  ro.xz *= r2d(time);\n  vec3 fo = vec3(0);\n  vec3 rov = normalize(fo-ro);\n  vec3 cu = normalize(cross(rov,up));\n  vec3 cv = cross(cu,rov);\n  vec3 rd = mat3(cu,cv,rov) * normalize(vec3(pt,1.));\n  vec3 p = ro;\n  vec4 d = vec4(0.);\n  float t = 0.;\n  float th = 0.001;\n  for(int i=0; i<128; i++){\n    p = ro + rd*t;\n    d = map(p);\n    t += d.x * .7;\n    if(abs(d.x) < th){break;}\n  }\n  \n  vec3 l = normalize(vec3(1.));\n  vec3 l2 = normalize(vec3(1.,1.,-1.));\n  if(abs(d.x) < th) {\n    vec3 n = normal(p);\n    c = d.gba * max(dot(n,l),0.01);\n    c += d.gba * max(dot(n,l2),0.01);\n    c = pow(c, vec3(.4545));\n  }else{\n    c = f;\n  }\n  \n  \n  fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdBRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 94, 94, 153], [155, 155, 218, 218, 360], [362, 362, 380, 380, 913], [915, 915, 933, 933, 1209], [1211, 1211, 1228, 1228, 1677], [1679, 1679, 1699, 1699, 1876], [1880, 1880, 1937, 1937, 2953]], "test": "untested"}
{"id": "dldBR7", "name": "Another more better pathtracer", "author": "joteakus", "description": "I mean it isn't terrible right", "tags": ["raytracing", "raymarching", "pathtracing"], "likes": 2, "viewed": 209, "published": 3, "date": "1701468857", "time_retrieved": "2024-07-30T17:19:15.770222", "image_code": "int s = 3;\n\nvec3 sample_texture(vec2 p){\n    vec4 temp = texture(iChannel0, p/iResolution.xy);\n    return temp.xyz/temp.w;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame <= -1){\n        fragColor = postprocess(vec4(sample_texture(fragCoord), 0.));\n    }else{\n        vec3 total = vec3(0.);\n        float max_magnitude = 1.+length(vec2(s));\n        float magnitude_total = 0.;\n        for(int x = -s; x <= s; x++){\n            for(int y = -s; y <= s; y++){\n                vec3 temp = (max_magnitude-length(vec2(x, y)))*sample_texture(fragCoord+vec2(x, y));\n                magnitude_total += max_magnitude-length(vec2(x,y));\n                total += temp*length(temp)*0.02;\n            }\n        }\n        fragColor = postprocess(vec4(sample_texture(fragCoord)+total/magnitude_total, 0.)); \n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "Ray ray;\n\nfloat sde;\nfloat intersect_result;\nvec2 uv;\nvec2 uv2;\nvec3 col;\n\n//camera\nvec3 camera_pos = vec3(4., 4., -15.);\nvec3 camera_rot = degree_to_rad*vec3(-10., -15., 0.);\n\nvec3 camera_transform(vec3 base){\n\n    vec3 temp = base;\n    temp = rotate(temp.xyz, camera_rot.x, 1); //rotation about x\n    temp = normalize(temp);\n    temp = rotate(temp.xyz, -camera_rot.y, 2); //rotation about y axis\n    temp = normalize(temp);\n    return temp;\n}\n\nvoid intersect(float max_len){\n    sde = inf;\n    //ray.pos += ray.dir*eps;\n    while(sde > eps || ray.len < max_len){\n        sde = get_scene_distance(ray.pos, false);\n        if(sde > eps && ray.len < max_len){\n            ray.pos += ray.dir*sde;\n            ray.len += sde;\n        }else{\n            intersect_result = (sde <= eps) ? HIT : MISS;\n            break;\n        }\n    }\n}\n\nvec3 apply_light(vec3 light_dir, vec3 light_col, bool ambient){\n\n    vec3 n_dir = normalize(light_dir);\n    vec3 fresnel1 = (scene_surface == matte) ? scene_col : vec3(0.5);\n    \n    vec3 half_not_illegal = normalize(n_dir-ray.dir);\n    float diffuse = max(0., dot(n_dir, normal));\n    \n    float specular = 0.;//(1.-scene_roughness)*pow(clamp(dot(n_dir,reflect(ray.dir, normal)),0.,1.),10.*(1.-scene_roughness));\n    vec3  fresnel = fresnel1 + (1.-fresnel1)*pow(clamp(1.-dot(half_not_illegal,n_dir),0.,1.),50.);\n    \n    float d = length(light_dir);\n    float shadow_strength = 1.;\n    if(diffuse >= 0. && !ambient){\n        Ray ray2 = ray;\n        ray.dir = n_dir;\n        ray.len = 0.;\n        intersect(d);\n        shadow_strength = (intersect_result == HIT) ? 0. : 1.;\n        ray = ray2;\n    }else{\n        shadow_strength = 1.;\n    }\n    vec3 back = vec3(0.);\n    \n    if(scene_surface == matte){\n        back += diffuse*scene_col*light_col;\n        back += diffuse*light_col*fresnel*(1.+specular);\n    }else if(scene_surface == metal){\n        back += diffuse*light_col*fresnel*(1.+specular);\n    }else{\n        \n    }\n    back *= shadow_strength;\n    return back;\n\n}\n\nvec3 apply_lighting(){\n\n    vec3 temp = vec3(0.);\n    float distance_to_center = hash13(cross(ray.pos, ray.dir)*2.3+iTime*500.);\n    vec3 offset = random_equal_vec3(cross(ray.pos, ray.dir)*(iTime+500.));\n    \n\n    temp += apply_light((0.75*offset+vec3(0., 9., 0.)-ray.pos), vec3(5., 5., 2.5), false); \n    \n    if(ambient_light_enabled){\n        temp += apply_light((normalize(offset)), vec3(0.5, 0.5, 0.5), true); \n    }\n    if(use_sky_light){\n        temp += apply_light(100.*normalize(vec3(1000., 10000., -500.)), sky_col, false); \n    }\n    if(use_three_light_model){\n        temp += apply_light((distance_to_center*0.5*offset+vec3(-7., 9., -1.)-ray.pos), vec3(1., 1., 1.), false); \n        temp += apply_light((distance_to_center*0.5*offset+vec3(7., 9., -1.)-ray.pos), vec3(1., 1., 1.), false); \n    }\n    if(camera_is_light){\n        temp += apply_light((distance_to_center*0.25*offset+camera_pos-ray.pos), vec3(0.5, 0.5, 0.5), false); \n    }\n    \n    return temp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 total_color = vec3(0.);\n\n    for(int pass = 0; pass <= pass_per_frame; pass++){\n        uv = fragCoord/iResolution.xy;\n        uv2 = (uv-0.5)*2.;\n        uv2.x *= iResolution.x/iResolution.y;\n        vec2 uv3 = uv2+(hash31(iTime*1234.5).xy/(iResolution.xy-10.));\n        col = vec3(0.);\n        vec3 ray_col = vec3(1.);\n        vec3 accumulated = vec3(0.);\n        float pixel_depth = 0.;\n        \n        ray = Ray(camera_pos, normalize(vec3(uv3, 2.)), 0.);\n        ray.dir = camera_transform(ray.dir);\n        for(int i = 0; i <= bounces; i++){\n            pixel_depth = 0.;\n            intersect(max_t);\n            if(intersect_result == HIT){\n                if(true){\n                    pixel_depth += ray.len;\n                }\n                get_scene_distance(ray.pos, true);\n                get_normal(ray.pos);\n                ray.pos += normal*eps;\n                //lighting goes here??? maybe???\n                vec3 scene_color2 = scene_col;\n                scene_col *= ray_col;\n                vec3 temp_col = apply_lighting();\n                ray_col *= scene_color2;\n                accumulated += temp_col;\n                //tint *= temp_col;\n                vec3 specular_dir = reflect(ray.dir, normal);\n                vec3 diffuse_dir = vec3_near(cross(ray.pos, ray.dir)*(iTime+500.), normal, 1.-scene_diffuse);\n                ray.dir = mix(specular_dir, diffuse_dir, scene_roughness);\n                ray.len = 0.;\n            }else{\n                accumulated += sky_col*ray_col;\n                break;\n            }\n            accumulated = mix(accumulated, fog_col, pow(min(pixel_depth/fog_dist, 1.), 3.)*fog_intensity);\n\n        }\n    \n        col = accumulated/float(bounces+1);\n        total_color += col;\n    }\n\n    vec4 total = texture(iChannel0, uv);\n    total += vec4(total_color, pass_per_frame);\n    if(iTime <2.){\n        fragColor = vec4(0.);\n    }else{\n        fragColor = total;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float HIT = 1.;\nconst float MISS = 2.;\nconst float inf = 9999999.;\nconst float eps = 0.01;\nconst float max_t = 100.;\nconst float pi = 3.14159265359;\nconst float degree_to_rad = pi/180.;\nconst float rad_to_degree = 180./pi;\nconst int matte = 1;\nconst int metal = 2;\nconst vec3 sky_col = vec3(4., 4, 12.);\nconst vec3 fog_col = vec3(6.);\nconst float fog_dist = 100.;\nconst float fog_intensity = 0.2;\n\nfloat sde_v_1;\nfloat sde_v_2;\nvec3 normal;\n\nvec3 scene_col;\nfloat scene_diffuse;\nfloat scene_roughness;\nint scene_surface;\n\n//settings\nconst int bounces = 4;\nconst int pass_per_frame = 1;\n\nconst bool ambient_light_enabled = false;\nconst bool use_three_light_model = false;\nconst bool use_sky_light = false;\nconst bool camera_is_light = false;\n\nvec4 postprocess(vec4 og){\n    vec4 temp = og;\n    temp *= 0.8;\n    temp = temp/(temp+1.);\n    temp = 1.2*(temp-0.5)+0.5-0.05;\n    temp = pow(temp, vec4(1.6));\n    return temp;\n\n}\n\nvec3 rotate(vec3 base, float rotation, int type){\n    vec3 temp = base;\n    if(type == 2){\n        temp.x = base.x*cos(rotation) - base.z*sin(rotation);\n        temp.z = base.x*sin(rotation) + base.z*cos(rotation);\n    }else if(type == 1){\n        temp.z = base.z*cos(rotation) - base.y*sin(rotation);\n        temp.y = base.z*sin(rotation) + base.y*cos(rotation);\n    }\n    return temp;\n}\n\nstruct Ray{\n    vec3 pos;\n    vec3 dir;\n    float len;\n};\n\nvoid object(bool update_surface, float sde, vec3 col, float diffuse, float roughness, int surface_type){\n    if(sde <= sde_v_1){\n        sde_v_1 = sde;\n        if(update_surface){\n            scene_col = col;\n            scene_diffuse = diffuse;\n            scene_roughness = roughness;\n            scene_surface = surface_type;\n        }\n    }\n}\n\nfloat sphere(vec3 from, vec3 pos, float radius){\n    return distance(from, pos)-radius;\n}\n\nfloat plane(vec3 from, vec3 normal, float offset){\n    return(dot(normalize(normal), from)-offset);\n}\n\nfloat box(vec3 from, vec3 pos, vec3 dimensions)\n{\n  vec3 q = abs(from-pos) - dimensions;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat get_scene_distance(vec3 pos, bool colors){\n\n    sde_v_1 = inf;\n    object(colors, //sphere1\n           sphere(pos, vec3(-10., -1., 0.), 2.),\n           vec3(0.9, 0.9, 0.9), 0.9, 0.9, matte);\n    object(colors, //sphere2\n           sphere(pos, vec3(-5., -1., 0.), 2.),\n           vec3(0.9, 0.9, 0.9), 0.6, 0.6, matte);\n    object(colors, //sphere3\n           sphere(pos, vec3(0., -1., 0.), 2.),\n           vec3(0.9, 0.9, 0.9), 0.4, 0.4, matte);\n    object(colors, //sphere4\n           sphere(pos, vec3(5., -1., 0.), 2.),\n           vec3(0.9, 0.9, 0.9), 0.3, 0.3, metal);\n    object(colors, //sphere5\n           sphere(pos, vec3(10., -1., 0.), 2.),\n           vec3(0.9, 0.9, 0.9), 0.1, 0.1, metal);\n\n    object(colors, //floor\n           plane(pos, vec3(0., 1., 0.), -2.5),\n           vec3(0.9, 0.9, 0.9), 0.1, 0.05, matte);\n    object(colors, //right wall\n           plane(pos, vec3(-1., 0., 0.), -20.),\n           vec3(0.9, 0.1, 0.1), 0.9, 0.9, matte);\n    object(colors, //left wall\n           plane(pos, vec3(1., 0., 0.), -20.),\n           vec3(0.1, 0.1, 0.6), 0.9, 0.9, matte);\n    object(colors, //back wall\n           plane(pos, vec3(0., 0., -1.), -20.),\n           vec3(0.9, 0.9, 0.9), 0., 0., metal);\n    object(colors, //front wall\n           plane(pos, vec3(0., 0., 1.), -20.),\n           vec3(0.9, 0.9, 0.9), 0., 0., metal);\n    object(colors, //ceiling\n           plane(pos, vec3(0., -1., 0.), -10.),\n           vec3(0.6, 0.6, 0.6), 0.5, 0.4, matte);\n\n    return sde_v_1;\n}\n\nvoid get_normal(vec3 pos){\n    vec2 oz = vec2(1., 0.);\n    normal = vec3(0.);\n    normal.x += get_scene_distance(pos+eps*oz.xyy, false)-get_scene_distance(pos-eps*oz.xyy, false);\n    normal.y += get_scene_distance(pos+eps*oz.yxy, false)-get_scene_distance(pos-eps*oz.yxy, false);\n    normal.z += get_scene_distance(pos+eps*oz.yyx, false)-get_scene_distance(pos-eps*oz.yyx, false);\n    normal = normalize(normal);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   vec3 temp = fract((p3.xxy+p3.yzz)*p3.zyx); \n   return (temp-0.5)*2.;\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 random_equal_vec3(vec3 seed){\n    float azimuth = hash13(seed)*360.;\n    float polar = hash13(seed*2.5+103.)*360.;\n    vec3 temp = vec3(0.);\n    temp.x = sin(polar)*cos(azimuth);\n    temp.y = sin(polar)*sin(azimuth);\n    temp.z = cos(polar);\n    return temp;\n}\n\n\n//    normalize(hash31(abs(time*50.+100.+abs(seed.x*25.)+abs(seed.y*1234.)+abs(seed.z*100.))));\n\n\nvec3 vec3_near(vec3 seed, vec3 dir, float threshold){\n    if(threshold > 0.9){\n        return dir;\n    }else{\n        float modify = 100.;\n        vec3 temp = random_equal_vec3(seed+modify*10.);\n        while(dot(temp, dir) <= threshold){\n            modify += 0.5;\n            temp = random_equal_vec3(seed+modify*10.);\n        }\n        return temp;\n    }\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dldBR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[12, 12, 40, 40, 124], [127, 127, 184, 184, 827]], "test": "untested"}
{"id": "dtcBzl", "name": "Black Ball", "author": "QuantumSuper", "description": "Glowing 2D orb centered in square shape with lighting and coloring reactive to music.\n\n - use with music in iChannel0 -", "tags": ["2d", "music"], "likes": 3, "viewed": 223, "published": 3, "date": "1701464701", "time_retrieved": "2024-07-30T17:19:16.647875", "image_code": "// Black Ball v0.5.231203 by QuantumSuper\n// glowing 2d orb centered in square shape with lighting and coloring reactive to music\n// \n// - use with music in iChannel0 -\n\n#define PI 3.14159265359 \n#define aTime 150./60.*iTime\nvec4 fft, ffts; //compressed frequency amplitudes\n\n\nvoid compressFft(){ //v1.2, compress sound in iChannel0 to simplified amplitude estimations by frequency-range\n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\n    for (int n=0;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 0-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(3,8,8,5); ffts /= vec4(2,3,3,23); //normalize\n\t\n\t//for (int n=0;n++<4;) fft[n] *= 1. + .3*pow(fft[n],5.); fft = clamp(fft,.0,1.); //limiter? workaround attempt for VirtualDJ\n}\n\nmat2 rotM(float r){float c = cos(r), s = sin(r); return mat2(c,s,-s,c);} //2D rotation matrix\n\nvec3 tmUnreal( vec3 c){return c / (c + .155) * 1.019;} //tone map, source: https://www.shadertoy.com/view/llXyWr\n\nfloat aaStep( float fun){return smoothstep( fwidth(fun), .0, fun);} //simple antialiasing\n\nfloat glow( float sd, float amp){return clamp( amp / max( amp, sd), .0 ,1.);} //simple glow\n\nfloat sdBox( vec2 p, vec2 b){ //source: https://iquilezles.org/articles/distfunctions2d/\n    vec2 d = abs(p) - b;\n    return length(max(d,.0)) + min(max(d.x,d.y),.0);\n}\n\nvec3 getCol(float id){ //fork of v0.8, color definitions, for pairs, with color shift\n    vec3 setCol = vec3(0);\n    id = fract(id/8.)*8.;// mod(id,8.);\n         if (id< 1.) setCol = vec3( 23,123,250); //cneon blue\n    else if (id< 2.) setCol = vec3( 30, 29,215); //vw2 blue\n    else if (id< 3.) setCol = vec3(244,  0,204); //vw2 pink\n    else if (id< 4.) setCol = vec3(131, 58,187); //nordic violet\n    else if (id< 5.) setCol = vec3(  0,250,253); //vw2 light blue\n    else if (id< 6.) setCol = vec3( 66,120, 91); //matrix green 2\n    else if (id< 7.) setCol = vec3(252,157,  0); //miami orange\n    else if (id< 8.) setCol = vec3(231, 15, 20); //arena red\n    setCol *= abs(cos(.06*aTime + PI/vec3(.5,2.,4.) + ffts.xyz)); //color shift\n    return setCol/256.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1 to 1, square aspect ratio \n    compressFft(); //initializes fft, ffts\n    vec2 uv0=uv;\n    \n    \n    // Design\n    float size = 1./exp(cos(aTime/8.)*2.+3.);\n    uv *= mix( 1., .5 + 1.*texelFetch( iChannel0, ivec2(mod(dot(floor((uv)/size),vec2(1,1./size)),512.),0), 0).x, fft.w*fft.w*fft.w); //pixel shift\n    \n    float mySd = sdBox( uv*rotM( PI/4.), vec2(.66*(.97+.03*fft.z))); //square definition\n    vec3 col = vec3(glow( mySd, .01) - aaStep( mySd)) * (1.3-fft.y) \n        * texelFetch( iChannel0, ivec2((floor(abs(uv.y)*22.)+floor(abs(uv.x)*22.)/22.)/22.*512.,0), 0).x * 2. ; //square visualization bw\n    \n    if (fft.x<.94) uv = uv0; //conditional pixel shift\n    mySd = length(uv)-.3*(.4+.6*fft.x*fft.x*fft.x); //circle definition\n    col += (glow( mySd, .01) - aaStep( mySd)) * (.2+.8*fft.x); //circle visualization bw\n    \n    float colId = floor(aTime/32.)*2.; //color identifier\n    float amp = (aaStep( mySd)*.93 + .07); //colorization intensities \n    col += clamp( uv.y+(fft.y*fft.y-.5)*.2, .0, 1.) * getCol(colId+0.) * amp * ffts.w; //top light color\n    col += clamp( sign(fract(aTime/64.-.25)-.5)*uv.x + sin(aTime/64.*PI*2.)*.6 + .3, .0, 1.) * getCol(colId+1.) * amp * fft.w; //\"rotating\" moonrise light color\n    \n    mySd = abs(mySd+.001) - (1.-uv.y*uv.y*111.)*.001; //edge ring definition\n    col += col * glow( mySd, .01)  * 9.; //edge ring visualization\n    \n    if (fft.x>.97) //max bass\n        col += col * fract(float(iFrame)*.5)*9.; //strobo\n    \n    \n    // Finalization\n\tcol -= length(uv) * .01; //vignette\n    col = tmUnreal( col); //tone map incl. gamma\n    \n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": 35422, "src": "https://soundcloud.com/nakt_records/nakt-061-obstn", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtcBzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 277, 296, 387, 1509], [1511, 1511, 1530, 1530, 1583], [1606, 1606, 1629, 1629, 1660], [1720, 1720, 1745, 1745, 1787], [1811, 1811, 1844, 1844, 1888], [1904, 1904, 1933, 1992, 2072], [2074, 2074, 2096, 2159, 2836], [2839, 2839, 2894, 2894, 4612]], "test": "untested"}
{"id": "mt3BRl", "name": "Test Shader Public Api Test", "author": "jpe230", "description": "Testing public api", "tags": ["test"], "likes": 0, "viewed": 127, "published": 3, "date": "1701461289", "time_retrieved": "2024-07-30T17:19:17.719012", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt3BRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "untested"}
{"id": "cl3fzl", "name": "laserbat-CA-variation", "author": "LydianLights", "description": "infinite-state CA inspired by laserbat's series: https://www.shadertoy.com/view/DsVBDw", "tags": ["cellularautomata"], "likes": 2, "viewed": 227, "published": 3, "date": "1701455612", "time_retrieved": "2024-07-30T17:19:18.493940", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float val = texelFetch(iChannel0, ivec2(fragCoord / ZOOM), 0).x;\n    vec3 color = ihash3(floatBitsToUint(val));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define GET(d) texelFetch(iChannel0, ivec2(mod(fragCoord + d, bounds)), 0).x\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // bounds check\n    vec2 bounds = iResolution.xy / ZOOM;\n    if (fragCoord.x > bounds.x || fragCoord.y > bounds.y) return;\n    // noise seed\n    if (iFrame <= 0 || iMouse.w > 0.0) {\n        fragColor.x = hash13(vec3(fragCoord.xy, iDate.w));\n        return;\n    }\n    // main CA computation\n    uint vals[9];\n    uint hash = 0u;\n    int i = 0;\n    for(float y = -1.0; y <= 1.0; y++) {\n        for(float x = -1.0; x <= 1.0; x++) {\n            uint v = floatBitsToUint(GET(vec2(x,y)));\n            vals[i] = v;\n            hash += v % 9u;\n            i++;\n        }\n    }\n    uint next = vals[hash % 9u];\n    fragColor.x = uintBitsToFloat(next);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ZOOM 2.0\n\nuint ihash(uint n) {\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n & uint(0x7fffffffU);\n}\n\nvec3 ihash3(uint n) {\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n, n * 16807U, n * 48271U);\n    return vec3(k & uvec3(0x7fffffffU)) / float(0x7fffffff);\n}\n\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl3fzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 207]], "test": "untested"}
{"id": "cl3Bzl", "name": "shadertoy iChannel test", "author": "jakel101", "description": "testing iChannel/sampler behaviour for implementing it in wgpu-py", "tags": ["test", "development"], "likes": 0, "viewed": 138, "published": 3, "date": "1701454047", "time_retrieved": "2024-07-30T17:19:19.766537", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 c0 = texture(iChannel0, uv/(1.0+sin(iTime)));\n    vec4 c1 = texture(iChannel1, uv/(1.0+sin(-iTime)));\n    \n    fragColor = mix(c0,c1,0.5);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl3Bzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 252]], "test": "untested"}
{"id": "td3cRs", "name": "CharactersTexture", "author": "samuelotherion", "description": "Characters", "tags": ["ascii", "characters"], "likes": 5, "viewed": 187, "published": 3, "date": "1701452729", "time_retrieved": "2024-07-30T17:19:20.625241", "image_code": "#define VO void\n#define I1 int\n#define I2 ivec2\n#define F1 float\n#define F2 vec2\n#define F3 vec3\n#define F4 vec4\n\n// check if u between 0,0 and 1,1\n#define in1(u) all(lessThan(abs(u - .5), F2(.5)))\n\nconst F1\nby16 = 1. / 16.;\n\n// print at pixel n character c at position p in size s at coord n\nF4\npC(F2 n, F2 p, F2 s, F2 c) {\n    \n    p = (n - p) / s;\n    \n    return in1(p)\n        ? texture(iChannel0, (c + p) * by16)\n        : F4(0);\n}\n\nF4\npN(F2 n, F2 p, F2 s, F1 num) {\n\n    F2\n    c = 0. <= num && num <= 9.\n        ? F2(num, 12.)\n        : 10. <= num && num <= 16.\n            ? F2(num - 9., 11.)\n            : F2(0, 13);\n    \n    return pC(n, p, s, c);\n}\n\n\nVO\nmainImage(out F4 o, F2 v) {\n    \n\tF2\n    r   = iResolution.xy,\n    s   = 1. / r,\n    t   = s * F2(r.x * s.y, 1),\n    u   =               v * t,\n    m   = clamp(iMouse.xy * t, F2(0), F2(15. * by16)),\n    u16 = floor(16. * u),\n    m16 = floor(16. * m);\n    \n    o = in1(u)\n        ? (all(equal(u16, m16))\n              ? pN(u, u16 * by16, F2(.5 * by16, by16), floor(15. - m16.y)).xxxx +\n                pN(u, (u16 + F2(.5,.0)) * by16, F2(.5 * by16, by16), floor(m16.x)).xxxx\n              : pC(u, u16 * by16, F2(by16), u16).xxww\n          )\n        : pC(u, F2(1., 0.), F2((r.x - r.y) * s.x * r.x * s.y), m16);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td3cRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 293, 324, 324, 437], [439, 439, 472, 472, 660], [663, 663, 693, 693, 1275]], "test": "untested"}
{"id": "ctdBRB", "name": "Quaternion Averaging", "author": "domrally", "description": "a demo of a proper (as of 2007) weighted rotation averaging\n[url=https://www.shadertoy.com/playlist/fXjyRd]GEOMETRY PLAYLIST[/url]", "tags": ["quaternion", "rotation", "interpolation", "average", "smoothing", "orientation"], "likes": 7, "viewed": 229, "published": 3, "date": "1701449245", "time_retrieved": "2024-07-30T17:19:21.512868", "image_code": "/*\nby Dom Mandy in 2023\n*/\n\n\n/*\nQuaternion Averaging (18) by Markley, Cheng, Crassidis, and Oshman in 2007\nhttps://www.acsu.buffalo.edu/~johnc/ave_sfm07.pdf\nhttps://ntrs.nasa.gov/api/citations/20070017872/downloads/20070017872.pdf\n*/\nvec4 qmix(vec4 start, vec4 end, float weight) {\n    float w = 1. - weight - weight,\n          d = dot(start, end);\n    return normalize(2.*weight*end*d + start*(w + sqrt(w*w + 4.*d*d*(weight*(1. - weight)))));\n}\n\n\n/*\nrandom orientation quaternion\nhttps://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation\n*/\nvec4 quaternion(float x) {\n    float q = 3. * texelFetch(iChannel0, ivec2(x, 2), 0).r - 1.5;\n    return vec4(cos(q), normalize(texelFetch(iChannel0, ivec2(x, 1), 0).rgb - .5) * sin(q));\n}\n\n\n/*\npastel colors\nhttps://www.shadertoy.com/view/mltyRN\n*/\nvec3 palette(float l, float h) { return l + l * vec3(.7874, .2848, .9278) * cos(h - vec3(0, 2.1, 4.2)); }\n\n\nvoid mainImage(out vec4 pixel, vec2 uv) {\n    // quaternions\n    float t = mod(1e-9 + iTime / 2., 256.),\n          f = floor(t),\n          m = ceil(t);\n    vec4 Q = qmix(quaternion(f), quaternion(mod(m, 256.)), smoothstep(f, m, t));\n\n    // animation\n    vec2 i = iResolution.xy;\n    uv += uv - i;\n    vec3 eye = vec3(0, 0, -3),\n         ray = normalize(vec3(uv * .4 / i.y, 1)),\n         up = vec3(0, 1, 0),\n         z = normalize(Q.yzw);\n    float angle = 2. * atan(length(Q.yzw), Q.x),\n          c = cos(angle),\n          s = sin(angle);\n    eye = cross(z, eye) * s + mix(z * dot(z, eye), eye, c);\n    ray = cross(z, ray) * s + mix(z * dot(z, ray), ray, c);\n\n    // lighting\n    float d = dot(ray, eye);\n    vec3 normal = eye - ray * (d + sqrt(1. + d * d - dot(eye, eye))),\n         r = reflect(ray, normal);\n    pixel.rgb = sqrt(\n        isnan(normal.x)\n            ? palette(pow(.5 + .5 * dot(up, ray), 2.), atan(ray.z, ray.x))\n            : mix(vec3(max(0., .5 + .5 * dot(up, normal))), palette(2. * pow(.5 + .5 * dot(up, r), 2.) * mix(pow(1. + dot(normal, ray), 5.), 1., .04), atan(r.z, r.x)), .9)\n    );\n}\n\n\n/*\nSEE ALSO\n\nrotation\nhttps://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n\nlighting\nhttps://en.wikipedia.org/wiki/Schlick%27s_approximation\nhttps://developer.nvidia.com/gpugems/gpugems/part-iii-materials/chapter-16-real-time-approximations-subsurface-scattering\n\nsphere\nhttps://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection#Calculation_using_vectors_in_3D\n*/\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdBRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 234, 281, 281, 445], [448, 547, 573, 573, 734], [737, 795, 827, 827, 900], [903, 903, 944, 963, 2015]], "test": "untested"}
{"id": "dtdBRf", "name": "scrape foam", "author": "silica163", "description": "accidently happend when I try to create fbm.", "tags": ["pattern"], "likes": 11, "viewed": 225, "published": 3, "date": "1701446552", "time_retrieved": "2024-07-30T17:19:22.317716", "image_code": "#define rot2(a) mat2(sin(a),cos(a),-cos(a),sin(a))\n#define PI 3.14159265\n\n#define time iTime\n#define resolution iResolution\n\nfloat rand(vec2 uv){\n\treturn fract(sin(dot(uv ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec4 blurRand(vec2 uv){\n\tvec4 c = vec4(0.);\n\tuv = uv * 4.;\n\tvec2 uf = fract(uv);\n\tvec2 u = floor(uv);\n\t//uf = uf*uf*(3.-2.*uf);\n\tfloat h = rand(u);\t\n\tfloat i = rand(u + vec2(1,0));\n\tfloat j = rand(u + vec2(0,1));\n\tfloat k = rand(u + vec2(1,1));\n\t\n\tfloat hl = length(uf);\n\tfloat il = length(uf-vec2(1,0));\n\tfloat jl = length(uf-vec2(0,1));\n\tfloat kl = length(uf - vec2(1));\n\t\n\t//c.x = mix(mix(h,i,uf.x),mix(j,k,uf.x),uf.y);\n\tc.x = max(max(h * (1.-hl) , i * (1.-il)),max(j*(1.-jl), k*(1.-kl)));\n\t//c.x = min(min(h*hl,i*il),min(j*jl,k*kl));\n\t//c.x = mix(h,k,hl)+mix(i,j,jl);\n\n\t//c = vec4(hl,il,jl,kl);\n\t//c = vec4(h,i,j,k);\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // old version\n\t//vec2 uv = (( gl_FragCoord.xy / resolution.xy )*2.-1.) * vec2(1,resolution.y/resolution.x);\n    \n    // from FabriceNeyret2\n    vec2 uv = ( 2.*fragCoord -  resolution.xy ) / resolution.x ;\n\n\tfloat color = 0.0;\n\tfor(float i = 0.;i<7.;i++){\n\t\tcolor += blurRand(uv+color*.2+time*.1).x;\n\t\tuv *= 1.4;\n\t\tuv *= rot2(PI/5.);\n\t}\n\tfragColor = vec4(vec3(1./color), 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtdBRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 145, 145, 211], [213, 213, 236, 236, 846], [848, 848, 904, 1050, 1290]], "test": "untested"}
{"id": "DttBRf", "name": "some fur", "author": "ich", "description": "fur", "tags": ["fur"], "likes": 3, "viewed": 199, "published": 3, "date": "1701443320", "time_retrieved": "2024-07-30T17:19:23.086660", "image_code": "float gray(vec3 c) {\n    return 1./4. * dot(vec3(1, 2, 1), c);\n}\n\nvec2 surface_uv(vec2 p, float dist) {\n    p /= dist + 1.;\n    p.x += dist * abs(.5 + .5*cos(p.x*3.)*sin(p.y*2.));\n    p.y += .1 * dist * pow(dist + 1., 2.);\n    p.x += dist * sin(p.x + iTime);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aa = 2. / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    \n    vec3 col = vec3(0);\n    p *= iResolution.y/360.;\n    \n    float bc = gray(texture(iChannel0, p).rgb);\n    col.g = bc;\n    \n    const float layers = 20.;\n    const float extrusion = .002;\n    \n    for (float i = 0.; i < layers; ++i) {\n        vec2 suv = surface_uv(p, i * extrusion);\n        float sc = gray(texture(iChannel0, suv / 10.).rgb);\n        \n        //float fur = gray(texture(iChannel0, suv).rgb);\n        float fur = gray(texture(iChannel1, suv).rgb);\n        \n        fur = smoothstep(.1, .2, fur);\n        //fur = step(.1, fur);\n        //col.r = fur;\n        \n        float fc = fur * sc;\n        \n        col.g = mix(col.g, fc, fur) * (.8+.2*sqrt((i+1.)/layers));\n        //col.g += (fc * fur) / (i + 2.);\n        //col.r = fur;\n    }\n    \n    col = vec3(1, .9, .8) * sqrt(col.g)/2.;\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DttBRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 64], [66, 66, 103, 103, 274], [276, 276, 333, 333, 1316]], "test": "untested"}
{"id": "cldBzX", "name": "gradation ball", "author": "e2213008", "description": "aaaa", "tags": ["a", "a"], "likes": 0, "viewed": 111, "published": 3, "date": "1701441053", "time_retrieved": "2024-07-30T17:19:24.123887", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 center = vec2(0.5, 0.5);\n    vec2 uvShifted = uv - center;\n    uvShifted.x *= iResolution.x / iResolution.y;\n    float r = 0.3;\n    float dist = length(uvShifted);\n\n    if (dist < r){\n        vec3 normal = normalize(vec3(uvShifted, sqrt(r * r - dot(uvShifted, uvShifted))));\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = clamp(dot(normal, lightDir), 0.0, 1.0);\n        vec3 reflectionDir = reflect(-lightDir, normal);\n        vec3 viewDir = normalize(vec3(0.0, 0.0, 1.0));\n        float specular = pow(clamp(dot(reflectionDir, viewDir), 0.0, 1.0), 32.0);\n        float shininess = 16.0;\n        float specularIntensity = 0.5;\n        vec3 baseColor = vec3(0.5 + 0.5 * cos(iTime + uvShifted.xyx + vec3(0, 2, 4))) * smoothstep(0.4, r, r - dist);\n        vec3 litColor = baseColor * (diffuse + specularIntensity * specular);\n        fragColor = vec4(litColor, 1.0);\n    }\n    else{\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cldBzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 1073]], "test": "untested"}
{"id": "DldBRX", "name": "ããã¯ãã³ã®ç´å¾", "author": "yoshi44444", "description": "ãªãã¨ãªãã§æä½ãã¦ããããä½ããççºãã¦ããããªå½¢ã«ãªããèæ¯ãé»ã¨ãããã¨ã§ãå®å®ãæãã¤ããããã¯ãã³ãèµ·ãã£ãç´å¾ã¨ããã¿ã¤ãã«ã«ãã", "tags": ["bigbang"], "likes": 0, "viewed": 85, "published": 3, "date": "1701440917", "time_retrieved": "2024-07-30T17:19:25.014506", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if (uv.x > 0.01 && uv.x < 0.99&& uv.y > 0.01&& uv.y < 0.99) {\n        vec2 centeredUV = uv - 0.5;\n        float dist = length(centeredUV);\n        float depth = 0.9- smoothstep(0.1, 0.5, dist);\n        vec3 color = vec3(1.0, 3, 6.5) * depth;\n        fragColor = vec4(color, 1.0);\n    } else {\n        fragColor = vec4(0, 0, 0, 0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DldBRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 105, 491]], "test": "untested"}
{"id": "cttfRX", "name": "cngaouvtieedaatnce", "author": "alivebone", "description": "ä¸ã«æµããããã«ããã", "tags": ["cngaouvtieedaatnce"], "likes": 0, "viewed": 84, "published": 3, "date": "1701440292", "time_retrieved": "2024-07-30T17:19:26.013834", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float color = fract(uv.y * 10.0 + iTime * 2.0);\n    \n    fragColor = vec4(color,color, 0.0, 1.0)*texture(iChannel0, uv);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cttfRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 229]], "test": "untested"}
{"id": "ctcfRf", "name": "çä¼¼", "author": "Kosaku", "description": "ãã¿ã¾ãããè¨ãè¨³ã«ãªãã¾ãããã­ã°ã©ãã³ã°ã¨ãããã®ã«äººçã§è§¦ãããã¨ããªããã£ã±ãåããã¾ããã§ããã\nä½ã¨ãåçã®ä½ããããã­ã°ã©ã ã¯åç¾ããã®ã§ããããããç¬èªæ§ãçã¿åºãã«ã¯ä½ãã©ãããã°ããã®ãçç®è¦å½ã¤ããªãã£ãã®ã§ãã®ç¶æã§æåºãã¾ãã\nææ¥­åå®¹ã¯è¨ç®ãªã©ã¯çè§£ãããã¦ãã¾ããããåã¯é»ç£ã¨ã®å¯æ¥ãªé¢ä¿æ§ãããã¨ãããã¨ã«å ãã¦ããã¬ãã«ã®å¼ã¨ããåã®åå°ç­ãåç¾ããããã§ã³ã¹ãããã©ã¼ãã³ã¹ã®é¢ã§éè¦ãªã®ã ã¨ãããã¾ããã", "tags": ["sorry"], "likes": 0, "viewed": 164, "published": 3, "date": "1701435601", "time_retrieved": "2024-07-30T17:19:26.912431", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    \n    uv-= vec2(0.5, 0.5) * iResolution.xy;\n    \n    vec3 col = vec3(0, 0, 0);\n    \n    float r =300.0;\n    if(uv.x * uv.x + uv.y * uv.y < r * r){\n        float z = sqrt(r * r - uv.x * uv.x - uv.y * uv.y);\n        vec3 normal = normalize(vec3(uv.x, uv.y, z));\n        vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = clamp(dot(normal, light), 0.0, 1.0);\n        float I = diffuse * 0.7 + 0.3;\n        \n        vec3 d = vec3(0.0, 0.0, -1.0);\n        vec3 reflection = reflect(d, normal);\n        \n        col = vec3(1.0, 0.0, 0.0) * I +\n            vec3(1.0, 1.0, 1.0)*pow(clamp(dot(reflection, light), 0.0, 1.0), 10.0);\n    }\n\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctcfRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 843]], "test": "untested"}
{"id": "cldBz2", "name": "Dexa Logo", "author": "transitive_bs", "description": "https://dexa.ai", "tags": ["study"], "likes": 0, "viewed": 132, "published": 3, "date": "1701422466", "time_retrieved": "2024-07-30T17:19:28.056373", "image_code": "// Dexa logo: https://dexa.ai\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = iResolution.xy * 0.5;\n    \n    vec2 pixel = fragCoord.xy;\n    \n    float size = 0.75;\n    float height = size * iResolution.y;\n    float width = size * iResolution.y;\n    \n    vec2 diffR = abs(pixel - center);\n    \n    // inside of rectangle\n    float insideRX = step(diffR.x, width / 2.0);\n    float insideRY = step(diffR.y, height / 2.0);\n    float insideR = insideRX * insideRY;\n    \n    // outside of circle\n    vec2 centerC = center - vec2(width * 0.5, 0);\n    float radiusC = height * 0.25;\n    vec2 diffC = pixel - centerC;\n    float outsideC = step(radiusC, sqrt(diffC.x * diffC.x + diffC.y * diffC.y));\n    \n    // inside of rectangle and outside of circle\n    float inside = insideR * outsideC;\n    \n    fragColor = vec4(inside, inside, inside, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cldBz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 30, 87, 87, 868]], "test": "untested"}
{"id": "cltfR2", "name": "ShaderToy_3_Animate", "author": "tbx", "description": "3", "tags": ["learning"], "likes": 4, "viewed": 158, "published": 3, "date": "1701419830", "time_retrieved": "2024-07-30T17:19:29.420725", "image_code": "#define PI 3.141592653\n#define COUNT 20.0\n#define CR\n\nfloat line(vec2 st, float width)\n{\n    return smoothstep(width, 0.0, abs(st.y - st.x));\n}\n\nfloat drawCoord(vec2 uv)\n{\n   float x = distance(vec2(uv.x, 0.0), vec2(0.0, 0.0));\n   float y = distance(vec2(0.0, uv.y), vec2(0.0, 0.0));\n   \n   return 1e-3 / x + 1e-3 / y;\n}\n\nfloat sphere(vec2 coord, vec2 p, float radius)\n{\n    float d = distance(p, coord);\n    d = abs(d - radius);\n    return 1e-3 / d;\n}\n\nfloat sphereShape(vec2 coord, vec2 p, float radius)\n{\n    float d = distance(p, coord);\n    d /= radius;\n    d = 1.0 - d;\n    d = clamp(d * 24.0, 0.0, 1.0);\n    return d;\n}\n\nfloat net(vec2 coord)\n{\n    float xline = cos(coord.x * PI * COUNT);\n    xline = step(1.0 - 1e-1, xline);\n    \n    float yline = cos(coord.y * PI * COUNT);\n    yline = step(1.0 - 1e-1, yline);\n    \n    return xline + yline;\n}\n\nfloat QuadrantIV(vec2 coord, float warp)\n{\n    float f = step(0.0, -coord.x);\n    f *= step(0.0, coord.y);\n    return abs(warp - f);\n}\n\nfloat QuadrantII(vec2 coord, float warp)\n{\n    float f = step(0.0, coord.x);\n    f *= step(0.0, -coord.y);\n    return abs(warp - f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float asp = iResolution.x / iResolution.y;\n    \n    vec2 coord = uv * 2.0 - 1.0;\n    \n    vec2 aspCoord = vec2(coord.x * asp, coord.y);\n    \n    vec3 col = vec3(0.0);\n    \n    col += net(aspCoord) * 0.125;\n    \n    col += drawCoord(coord);\n    \n    float posX = sin(iTime) * asp;\n    float size = 0.25;\n    \n#ifdef CR\n    float scale = 0.9;\n    for(int i = 9;i-->0;)\n    {\n        size *= scale;\n        posX = sin(iTime * float(i + 1) * 0.1) * asp;\n\n        col += sphere(aspCoord, vec2(posX, sin(posX)), size);\n        col += sphere(aspCoord, vec2(posX, 0.0), size);\n    }\n#else\n    col += sphere(aspCoord, vec2(posX, sin(posX)), size);\n#endif\n    col += line(vec2(sin(aspCoord.x), aspCoord.y), 0.01);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltfR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 88, 88, 143], [145, 145, 171, 171, 320], [322, 322, 370, 370, 452], [454, 454, 507, 507, 626], [628, 628, 651, 651, 853], [855, 855, 897, 897, 989], [991, 991, 1033, 1033, 1125], [1127, 1127, 1184, 1234, 2049]], "test": "untested"}
{"id": "DttfR2", "name": "ShaderToy_2_Shape", "author": "tbx", "description": "2", "tags": ["learning"], "likes": 0, "viewed": 92, "published": 3, "date": "1701419679", "time_retrieved": "2024-07-30T17:19:30.344255", "image_code": "#define PI 3.141592653\n#define COUNT 20.0\n\nfloat drawCoord(vec2 uv)\n{\n   float x = distance(vec2(uv.x, 0.0), vec2(0.0, 0.0));\n   float y = distance(vec2(0.0, uv.y), vec2(0.0, 0.0));\n   \n   return 1e-3 / x + 1e-3 / y;\n}\n\nfloat net(vec2 coord)\n{\n    float xline = cos(coord.x * PI * COUNT);\n    xline = step(1.0 - 1e-1, xline);\n    \n    float yline = cos(coord.y * PI * COUNT);\n    yline = step(1.0 - 1e-1, yline);\n    \n    return xline + yline;\n}\n\nfloat sphereLine(vec2 coord, vec2 p, float radius)\n{\n    float d = distance(p, coord);\n    d = abs(d - radius);\n    return 1e-3 / d;\n}\n\nfloat sphereShape(vec2 coord, vec2 p, float radius)\n{\n    float d = distance(p, coord);\n    d /= radius;\n    d = 1.0 - d;\n    d = clamp(d * 24.0, 0.0, 1.0);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float asp = iResolution.x / iResolution.y;\n    \n    vec2 coord = uv * 2.0 - 1.0;\n    \n    vec2 aspCoord = vec2(coord.x * asp, coord.y);\n    \n    vec3 col = vec3(0.0);\n    \n    col += net(aspCoord) * 0.125;\n    \n    col += drawCoord(aspCoord);\n    \n    float sp = sphereShape(aspCoord, vec2(-0.1, 0.5), 0.25);\n    sp += sphereShape(aspCoord, vec2(0.1, 0.5), 0.25);\n    \n    col += sp;\n    \n    sp = sphereShape(aspCoord, vec2(-0.1, -0.5), 0.25);\n    sp *= sphereShape(aspCoord, vec2(0.1, -0.5), 0.25);\n    \n    col += sp;\n    \n    sp = sphereShape(aspCoord, vec2(1.0, 0.5), 0.25);\n    sp -= sphereShape(aspCoord, vec2(0.9, 0.5), 0.2);\n    col += sp;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DttfR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 69, 69, 218], [220, 220, 243, 243, 445], [447, 447, 499, 499, 581], [583, 583, 636, 636, 755], [757, 757, 814, 864, 1624]], "test": "untested"}
{"id": "DldBR2", "name": "ShaderToy_1_2DSDF", "author": "tbx", "description": "1", "tags": ["learning"], "likes": 0, "viewed": 105, "published": 3, "date": "1701419370", "time_retrieved": "2024-07-30T17:19:31.900095", "image_code": "#define PI 3.141592653\n#define COUNT 20.0\n\nfloat drawCoord(vec2 uv)\n{\n   float x = distance(vec2(uv.x, 0.0), vec2(0.0, 0.0));\n   float y = distance(vec2(0.0, uv.y), vec2(0.0, 0.0));\n   \n   return 1e-3 / x + 1e-3 / y;\n}\n\nfloat net(vec2 coord)\n{\n    float xline = cos(coord.x * PI * COUNT);\n    xline = step(1.0 - 1e-2, xline);\n    \n    float yline = cos(coord.y * PI * COUNT);\n    yline = step(1.0 - 1e-2, yline);\n    \n    return xline + yline;\n}\n\nfloat sphereLine(vec2 coord, vec2 p, float radius)\n{\n    float d = distance(p, coord);\n    d = abs(d - radius);\n    return 1e-3 / d;\n}\n\nfloat sphereShape(vec2 coord, vec2 p, float radius)\n{\n    float d = distance(p, coord);\n    d /= radius;\n    d = 1.0 - d;\n    d = clamp(d * 24.0, 0.0, 1.0);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float asp = iResolution.x / iResolution.y;\n    \n    vec2 coord = uv * 2.0 - 1.0;\n    \n    vec2 aspCoord = vec2(coord.x * asp, coord.y);\n    \n    vec3 col = vec3(0.0);\n    \n    col += net(aspCoord) * 0.25;\n    \n    col += drawCoord(aspCoord);\n    \n    col += sphereLine(aspCoord, vec2(0.5), 0.25);\n    \n    col += sphereShape(aspCoord, vec2(-0.5, 0.5), 0.25);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DldBR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 69, 69, 218], [220, 220, 243, 243, 445], [447, 447, 499, 499, 581], [583, 583, 636, 636, 755], [757, 757, 814, 864, 1334]], "test": "untested"}
{"id": "cldBR2", "name": "ShaderToy_0_Start", "author": "tbx", "description": "0", "tags": ["learning"], "likes": 0, "viewed": 133, "published": 3, "date": "1701419160", "time_retrieved": "2024-07-30T17:19:37.563952", "image_code": "#define PI 3.141592653\n#define COUNT 20.0\n\nfloat drawCoord(vec2 uv)\n{\n   float x = distance(vec2(uv.x, 0.0), vec2(0.0, 0.0));\n   float y = distance(vec2(0.0, uv.y), vec2(0.0, 0.0));\n   \n   return 1e-3 / x + 1e-3 / y;\n}\n\nfloat net(vec2 coord)\n{\n    float xline = cos(coord.x * PI * COUNT);\n    xline = step(1.0 - 1e-1, xline);\n    \n    float yline = cos(coord.y * PI * COUNT);\n    yline = step(1.0 - 1e-1, yline);\n    \n    return max(xline, yline);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float asp = iResolution.x / iResolution.y;\n    \n    vec2 coord = uv * 2.0 - 1.0;\n    \n    vec2 aspCoord = vec2(coord.x * asp, coord.y);\n    \n    vec3 col = vec3(0.0);\n    \n    col += net(aspCoord) * 0.125;\n    \n    col += drawCoord(aspCoord);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cldBR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 69, 69, 218], [220, 220, 243, 243, 449], [451, 451, 508, 558, 912]], "test": "untested"}
{"id": "cltBRj", "name": "laserbat-CA-random-hash", "author": "LydianLights", "description": "infinite-state CA inspired by laserbat's series: https://www.shadertoy.com/view/DsVBDw", "tags": ["cellularautomata"], "likes": 2, "viewed": 165, "published": 3, "date": "1701414680", "time_retrieved": "2024-07-30T17:19:38.755766", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float val = texelFetch(iChannel0, ivec2(fragCoord / ZOOM), 0).x;\n    vec3 color = ihash3(floatBitsToUint(val));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define GET(d) texelFetch(iChannel0, ivec2(mod(fragCoord + d, bounds)), 0).x\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // bounds check\n    vec2 bounds = iResolution.xy / ZOOM;\n    if (fragCoord.x > bounds.x || fragCoord.y > bounds.y) return;\n    // noise seed\n    if (iFrame <= 0 || iMouse.w > 0.0) {\n        fragColor.x = hash13(vec3(fragCoord.xy, iDate.w));\n        return;\n    }\n    // main CA computation\n    uint vals[9];\n    uint hash = 0u;\n    int i = 0;\n    for(float y = -1.0; y <= 1.0; y++) {\n        for(float x = -1.0; x <= 1.0; x++) {\n            uint v = floatBitsToUint(GET(vec2(x,y)));\n            vals[i] = v;\n            hash = ihash(hash ^ v);\n            i++;\n        }\n    }\n    uint next = vals[hash % 9u];\n    fragColor.x = uintBitsToFloat(next);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ZOOM 2.0\n\nuint ihash(uint n) {\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n & uint(0x7fffffffU);\n}\n\nvec3 ihash3(uint n) {\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n, n * 16807U, n * 48271U);\n    return vec3(k & uvec3(0x7fffffffU)) / float(0x7fffffff);\n}\n\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltBRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 207]], "test": "untested"}
{"id": "dl3fz2", "name": "laserbat-CA-or-hash", "author": "LydianLights", "description": "infinite-state CA inspired by laserbat's series: https://www.shadertoy.com/view/DsVBDw\nTends to either crystalize or become one massive glider. High resolution / fullscreen recommended.", "tags": ["cellularautomata"], "likes": 2, "viewed": 140, "published": 3, "date": "1701413577", "time_retrieved": "2024-07-30T17:19:39.908683", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float val = texelFetch(iChannel0, ivec2(fragCoord / ZOOM), 0).x;\n    vec3 color = ihash3(floatBitsToUint(val));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define GET(d) texelFetch(iChannel0, ivec2(mod(fragCoord + d, bounds)), 0).x\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // bounds check\n    vec2 bounds = iResolution.xy / ZOOM;\n    if (fragCoord.x > bounds.x || fragCoord.y > bounds.y) return;\n    // noise seed\n    if (iFrame <= 0 || iMouse.w > 0.0) {\n        fragColor.x = hash13(vec3(fragCoord.xy, iDate.w));\n        return;\n    }\n    // main CA computation\n    uint vals[9];\n    uint hash = 0u;\n    int i = 0;\n    for(float y = -1.0; y <= 1.0; y++) {\n        for(float x = -1.0; x <= 1.0; x++) {\n            uint v = floatBitsToUint(GET(vec2(x,y)));\n            vals[i] = v;\n            hash |= v;\n            i++;\n        }\n    }\n    uint next = vals[hash % 9u];\n    fragColor.x = uintBitsToFloat(next);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ZOOM 1.0\n\nuint ihash(uint n) {\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n & uint(0x7fffffffU);\n}\n\nvec3 ihash3(uint n) {\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n, n * 16807U, n * 48271U);\n    return vec3(k & uvec3(0x7fffffffU)) / float(0x7fffffff);\n}\n\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl3fz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 207]], "test": "untested"}
{"id": "mtcfz2", "name": "kadaie2313152", "author": "e2313152", "description": "kadai", "tags": ["blue"], "likes": 0, "viewed": 85, "published": 3, "date": "1701413126", "time_retrieved": "2024-07-30T17:19:41.080550", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\nvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float distance = length(uv);\n    vec3 gradientColor = vec3(uv, 1.0);\n    if (distance < 1.0)\n    {\n        fragColor = vec4(gradientColor, 1.0);\n    }\n    else\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtcfz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 321]], "test": "untested"}
{"id": "mt3fz2", "name": "laserbat-CA-xor-hash", "author": "LydianLights", "description": "infinite-state CA inspired by laserbat's series: https://www.shadertoy.com/view/DsVBDw\nI changed some stuff to use uint math.", "tags": ["cellularautomata"], "likes": 1, "viewed": 151, "published": 3, "date": "1701412988", "time_retrieved": "2024-07-30T17:19:42.039985", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float val = texelFetch(iChannel0, ivec2(fragCoord / ZOOM), 0).x;\n    vec3 color = ihash3(floatBitsToUint(val));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define GET(d) texelFetch(iChannel0, ivec2(mod(fragCoord + d, bounds)), 0).x\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // bounds check\n    vec2 bounds = iResolution.xy / ZOOM;\n    if (fragCoord.x > bounds.x || fragCoord.y > bounds.y) return;\n    // noise seed\n    if (iFrame <= 0 || iMouse.w > 0.0) {\n        fragColor.x = hash13(vec3(fragCoord.xy, iDate.w));\n        return;\n    }\n    // main CA computation\n    uint vals[9];\n    uint hash = 0u;\n    int i = 0;\n    for(float y = -1.0; y <= 1.0; y++) {\n        for(float x = -1.0; x <= 1.0; x++) {\n            uint v = floatBitsToUint(GET(vec2(x,y)));\n            vals[i] = v;\n            hash ^= v;\n            i++;\n        }\n    }\n    uint next = vals[hash % 9u];\n    fragColor.x = uintBitsToFloat(next);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ZOOM 2.0\n\nuint ihash(uint n) {\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n & uint(0x7fffffffU);\n}\n\nvec3 ihash3(uint n) {\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n, n * 16807U, n * 48271U);\n    return vec3(k & uvec3(0x7fffffffU)) / float(0x7fffffff);\n}\n\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt3fz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 207]], "test": "untested"}
{"id": "mlcfR2", "name": "éª¸é¾ãªã¹ãã¬ã­ã¢ã®èä¸­ã«ããå¼±ç¹", "author": "Sazanami", "description": "MHXã«ç»å ´ããéª¸é¾ãªã¹ãã¬ã­ã¢ã®å¼±ç¹é¨ä½ã¿ãããªã·ã§ã¼ãã¼ãä½ãã¾ããã", "tags": ["3"], "likes": 0, "viewed": 100, "published": 3, "date": "1701409456", "time_retrieved": "2024-07-30T17:19:43.286651", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float color = fract(uv.y * 20.0 + iTime * 10.0);\n\n    // Output to screen\n    fragColor = vec4(uv.x, uv.y , abs(sin(iTime)),1.0)* texture(iChannel0, uv);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlcfR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 312]], "test": "untested"}
{"id": "dltfzB", "name": "Log(n) Sawtooth Wave", "author": "ArmandB", "description": "A simple sawtooth wave in log(n) time (worst case)\nbinary searches the sdf of the sawtooth to find the value of the sawtooth efficiently\nfeel free to golf it and shade with i", "tags": ["joke"], "likes": 2, "viewed": 156, "published": 3, "date": "1701385547", "time_retrieved": "2024-07-30T17:19:44.058587", "image_code": "//this is needed\nfloat sdLine(vec2 a, vec2 b, vec2 p){\n    vec2 ab = b - a;\n    float t = dot(p - a, ab) / dot(ab, ab);\n    vec2 p2 = a + clamp(t,0.0,1.0) * ab;\n    return length(p - p2);\n}\n\n//define the sdf\nfloat getDist(vec2 p){\n    float fp = 2.0*floor((p.x+1.0)/2.0); //get the point\n    return sign(p.x-fp-p.y)*min(sdLine(vec2(fp-1.0,-1),vec2(fp+1.0,1),p),min(sdLine(vec2(fp-3.0,-1),vec2(fp-1.0,1),p),sdLine(vec2(fp+1.0,-1),vec2(fp+3.0,1),p)));\n}\n\n//binary search the sdf to find the value\n//log(n) time\nfloat sawtooth(float x){\n    int maxsteps = 100;\n    vec2 p = vec2(x,maxsteps);\n    float k = float(maxsteps)*2.0;\n    for (int i = 0; i < maxsteps; i++){\n        float d = getDist(p);\n        if (abs(d) == 0.0){\n            return p.y; //found the value\n        }\n        k /= 2.0;\n        p = vec2(p.x,p.y + k*sign(d));\n    }\n    return 2.0; //sawtooth is undefined\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - vec2(iResolution.xy/2.0))/iResolution.y*3.0;\n\n    vec3 col = vec3(uv.y < sawtooth(uv.x));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dltfzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 17, 54, 54, 189], [191, 208, 230, 230, 451], [453, 509, 533, 533, 878], [880, 880, 937, 937, 1112]], "test": "untested"}
