{"id": "ftGXzV", "name": "X-Ray KIFS", "author": "wyatt", "description": "Fractal ", "tags": ["kifs", "xray"], "likes": 11, "viewed": 406, "published": 3, "date": "1640988390", "time_retrieved": "2024-07-30T18:39:07.301598", "image_code": "// Fork of \"Microscopy 101\" by wyatt. https://shadertoy.com/view/NlKSzG\n// 2021-12-31 17:42:39\n\n\nMain \n{\n    R = iResolution.xy;\n    T = iTime;\n    Q =vec4(0);\n    for (float i = -100.; i < 100.;i++){\n        vec4 u = vec4(U,i/150.,0);\n        u.xy = 1.*(u.xy-.5*R.xy)/R.y;\n    \n        Q += map(u)/30.;\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R;\nfloat T;\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nfloat ln (vec4 p, vec4 a, vec4 b) {\n    float l = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n    return mix(.8,1.,l)*length(p-a-(b-a)*l);\n}\nvec4 map (vec4 u) {\n    \n    u.xz *= ei(T);\n    u.xy *= ei(1.5);\n    float d = 1e9;\n    vec4 c;\n    float sg = 1e9;\n    float l = .2;\n    u.y = abs(u.y);\n    u.y+=.2;\n    for (float i = 0.; i < 12.; i++)\n    {\n        sg = ln(u,vec4(0),vec4(0,l,0,0))/l;\n        d = min(d,sg);\n        u.y -= l;\n        u.xz *= ei(2.);\n        u.xz = abs(u.xz);\n        u.xy *= ei(.3);\n        l *= .8;\n            \n    }\n    return vec4(1.)*smoothstep(.1,0.,abs(d-.5));;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGXzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NlGSzV", "name": "3D grid 3", "author": "FabriceNeyret2", "description": "3D grid + random walls. \nI'm still bad at managing continuity at borders.\n\nMouse controls, camera.", "tags": ["raymarching", "sdf", "maze", "short"], "likes": 23, "viewed": 479, "published": 3, "date": "1640985823", "time_retrieved": "2024-07-30T18:39:08.198200", "image_code": "// variant of https://shadertoy.com/view/NtySRV\n\n#define rot(a)    mat2(cos(a+vec4(0,11,33,0)))        // rotation\n#define H(p)      fract(sin(dot(p, R-13.7)) * 4e5 )   // hash\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.; \n    \n    vec3  R = iResolution, Y = vec3(0,1,0),\n          D = normalize(vec3((U+U-R.xy)/R.y, -3.)),   // ray direction\n          p = vec3(0,0,25), q,a,i,d,                  // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(10,12,0)/1e2*cos(iTime+vec3(0,11,0))+vec3(0,.12,0); \n\n    for ( O=vec4(1); O.x > 0. && t > .005; O-=.01 ) {\n        q = p,\n        q.yz *= rot(.5-6.3*M.y),                      // rotations\n        q.xz *= rot(-6.3*M.x), // t = 9.,\n        a = abs(q), i=floor(q),\n        q = fract(q)-.5;                              // cells\n     // t = length(q)-.2;                             // spheres\n     // for( int k=0; k<27; k++)\n     //     d = vec3(k%3,(k/3)%3,k/9)-1.,\n     //     t = min(t, abs((q+d)[int(3.*H(i+d))])-.01 );\n         t = min( t, abs(q[int(3.*H(i))])-.01 ),      // random wall\n         t = max( t, length(a) - 8. ) ,               // clamp to sphere\n     \n        p += .4*t*D;                                  // step forward = dist to obj\n    }\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGSzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 214, 214, 1251]], "test": "untested"}
{"id": "flGSzV", "name": "3D grid b", "author": "FabriceNeyret2", "description": "3D grid / array of cubes, just to please jorge2017a2 :-p .\nuncomment 21 for the axis.\n\nMouse controls, camera.", "tags": ["raymarching", "sdf", "short"], "likes": 14, "viewed": 436, "published": 3, "date": "1640985188", "time_retrieved": "2024-07-30T18:39:09.051917", "image_code": "// variant of https://shadertoy.com/view/flGSRV\n\n#define rot(a)          mat2(cos(a+vec4(0,11,33,0)))  // rotation\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.; \n    \n    vec3  R = iResolution, Y = vec3(0,1,0),\n          D = normalize(vec3((U+U-R.xy)/R.y, -3.)),   // ray direction\n          p = vec3(0,0,25), q,a,                      // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(10,12,0)/1e2*cos(iTime+vec3(0,11,0))+vec3(0,.12,0); \n\n    for ( O=vec4(1); O.x > 0. && t > .005; O-=.01 ) {\n        q = p,\n        q.yz *= rot(.5-6.3*M.y),                      // rotations\n        q.xz *= rot(-6.3*M.x), // t = 9.,\n        a = abs(q), \n        q = fract(q)-.5,                              // cells\n        q = abs(q), t = max(q.x,max(q.y,q.z)) - .2,   // cubes\n     // t = min( t, min(length(q.xy),min(length(q.yz),length(q.xz)))-.01), // axis\n        t = max( t, max(a.x, max(a.y,a.z))-6. ),      // clamp to cube\n     \n        p += .4*t*D;                                  // step forward = dist to obj\n    }\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGSzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 152, 152, 1056]], "test": "untested"}
{"id": "NtySRV", "name": "3D grid 2", "author": "FabriceNeyret2", "description": "3D grid + random walls. \nI'm still bad at managing continuity at borders.\n\nMouse controls, camera.", "tags": ["raymarching", "sdf", "maze", "short"], "likes": 19, "viewed": 392, "published": 3, "date": "1640984873", "time_retrieved": "2024-07-30T18:39:09.908627", "image_code": "// variant of https://www.shadertoy.com/view/flGSRV\n\n#define rot(a)    mat2(cos(a+vec4(0,11,33,0)))        // rotation\n#define H(p)      fract(sin(dot(p, R-13.7)) * 4e5 )   // hash\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.; \n    \n    vec3  R = iResolution, Y = vec3(0,1,0),\n          D = normalize(vec3((U+U-R.xy)/R.y, -3.)),   // ray direction\n          p = vec3(0,0,25), q,a,i,d,                  // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(10,12,0)/1e2*cos(iTime+vec3(0,11,0))+vec3(0,.12,0); \n\n    for ( O=vec4(1); O.x > 0. && t > .005; O-=.01 ) {\n        q = p,\n        q.yz *= rot(.5-6.3*M.y),                      // rotations\n        q.xz *= rot(-6.3*M.x), // t = 9.,\n        a = abs(q), i=floor(q),\n        q = fract(q)-.5;                              // cells\n     // t = length(q)-.2;                             // spheres\n     // for( int k=0; k<27; k++)\n     //     d = vec3(k%3,(k/3)%3,k/9)-1.,\n     //     t = min(t, abs((q+d)[int(3.*H(i+d))])-.01 );\n         t = min(t, abs(q[int(3.*H(i))])-.01 ),       // random wall\n         t = max( t, max(a.x, max(a.y,a.z))-6. ),     // clamp to cube\n     \n        p += .4*t*D;                                  // step forward = dist to obj\n    }\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtySRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 182, 218, 218, 1253]], "test": "untested"}
{"id": "NtV3RD", "name": "Happy New 2022 Year", "author": "yurka", "description": "Happy New 2022 Year!", "tags": ["happynewyear"], "likes": 5, "viewed": 300, "published": 3, "date": "1640980413", "time_retrieved": "2024-07-30T18:39:10.667598", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = data;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/(iResolution.y / 2.0);\n    vec3 col = vec3(0.0, 0.0, 0.0);    \n    for (int i = 0; i < min(int(iResolution.y), 300); i++) {\n        vec4 V_o = texelFetch(iChannel1, ivec2(0, i), 0);\n        vec4 V_c = texelFetch(iChannel1, ivec2(1, i), 0);\n\n        vec2 obj = V_o.xy;\n\n        float dist = len2(uv - obj);\n\n        float glow = 0.0;\n        dist *= 40000.0;\n        if (dist < 1e-3)\n            glow = 1000.0;\n        else\n            glow += 1.0/dist;\n        col = col + V_c.xyz * glow;\n    }\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = 0.9*data + vec4(col, 1.0);\n    //fragColor = V_c;\n    if (fragCoord.x < 0.1 || fragCoord.y < 0.1) {\n           fragColor = vec4(1.0, 0.0, 0.0, 0.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 o = vec2(0, 0);\nvec2 v = vec2(0.009, 0.003);\n\nfloat len2(vec2 v)\n{\n    return v.x*v.x + v.y*v.y;\n}\n\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat random (in float _st) {\n    return fract(sin(dot(vec2(_st, 0.0),\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 V_o = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    vec2 obj = V_o.xy;\n    vec2 vel = V_o.zw;\n    \n    if (fragCoord.x < 0.501) {\n        if (iTime < 0.1) {\n            float fact = 0.01;\n            //fragColor = vec4(random(vec2(1, fragCoord.y))*2.0 - 1.0, random(vec2(2, fragCoord.y))*2.0 - 1.0, fact*(random(vec2(3, fragCoord.y)) - 0.5), fact*(random(vec2(4, fragCoord.y)) - 0.5));\n            float ang = random(vec2(5, fragCoord.y)) * 3.141592653 * 2.0;\n            float mag = sqrt(random(vec2(7, fragCoord.y)));\n            fragColor = vec4(0.0, 0.0, fact*(sin(ang) * mag), fact*(cos(ang) * mag));\n        }  else {\n            obj = obj + vel;\n\n            if (obj.y > 1.0) {\n                obj.y = 1.0;\n                vel = reflect(vel, vec2(0.0, -1.0));\n            }\n            if (obj.x > iResolution.x * 1.0/iResolution.y) {\n                obj.x = iResolution.x * 1.0/iResolution.y;\n                vel = reflect(vel, vec2(-1.0, 0));\n            }\n            if (obj.y < -1.0) {\n                obj.y = -1.0;\n                vel = reflect(vel, vec2(0.0, 1.0));\n            }\n            if (obj.x < -iResolution.x * 1.0/iResolution.y) {\n                obj.x = -iResolution.x * 1.0/iResolution.y;\n                vel = reflect(vel, vec2(1.0, 0));\n            }\n            fragColor = vec4(obj.x, obj.y, vel.x, vel.y);\n        }\n    }\n     else \n        if (fragCoord.x < 1.501) {\n            float fact = 1.00;\n            fragColor = vec4(fact*random(vec2(1, fragCoord.y)), fact*random(vec2(2, fragCoord.y)), fact*random(vec2(3, fragCoord.y)), fact*random(vec2(4, fragCoord.y)));\n        }\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtV3RD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 139]], "test": "untested"}
{"id": "NtySR1", "name": "mile-long piano", "author": "CubeyTheCube", "description": "the", "tags": ["the"], "likes": 5, "viewed": 270, "published": 3, "date": "1640977302", "time_retrieved": "2024-07-30T18:39:11.478429", "image_code": "#define aces_input mat3(0.59719, 0.35458, 0.04823,0.07600, 0.90834, 0.01566,0.02840, 0.13383, 0.83777)\n#define aces_output mat3(1.60475, -0.53108, -0.07367, -0.10208, 1.10813, -0.00605, -0.00327, -0.07276, 1.07602)\n#define object(sd, mat) dist = sd; if (dist < minDist) { minDist = dist; material = mat; }\n\n#define anti_aliasing 2\n\nstruct Material {\n  vec3 albedo;\n  float ior;\n};\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat sdPlane (vec3 p, vec3 n, float h) {\n  return dot(p, n) + h;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat scene ( vec3 pos, inout Material material ) {\n  float minDist = 1e10;\n  float dist;\n  vec3 col;\n  object(sdBox(pos.xyz - vec3(-1.0, 0.0, 0.0), vec3(0.5, 0.7, 1e10)), Material(vec3(0.5, 0.3, 0.0), 1.5));\n  object(sdBox(pos.xyz - vec3(-0.5, 0.0, 0.0), vec3(0.5, 0.0, 1e10)), Material(vec3(0.2), 1.0));\n  object(sdBox(vec3(pos.xy - vec2(-0.5, 0.05), mod(pos.z, 0.05) - 0.025), vec3(0.4, 0.05, 0.02)) - 0.005, Material(vec3(2.0), 2.5));\n  object(sdBox(vec3(pos.xy - vec2(-0.4, 0.15), mod(pos.z + 0.0125, 0.35) - 0.1), vec3(0.2, 0.03, 0.01)), Material(vec3(0.0), 3.5));\n  object(sdBox(vec3(pos.xy - vec2(-0.4, 0.15), mod(pos.z + 0.0625, 0.35) - 0.1), vec3(0.2, 0.03, 0.01)), Material(vec3(0.0), 3.5));\n  object(sdBox(vec3(pos.xy - vec2(-0.4, 0.15), mod(pos.z + 0.1625, 0.35) - 0.1), vec3(0.2, 0.03, 0.01)), Material(vec3(0.0), 3.5));\n  object(sdBox(vec3(pos.xy - vec2(-0.4, 0.15), mod(pos.z + 0.2125, 0.35) - 0.1), vec3(0.2, 0.03, 0.01)), Material(vec3(0.0), 3.5));\n  object(sdBox(vec3(pos.xy - vec2(-0.4, 0.15), mod(pos.z + 0.2625, 0.35) - 0.1), vec3(0.2, 0.03, 0.01)), Material(vec3(0.0), 3.5));\n  object(sdPlane(pos, vec3(0.0, 1.0, 0.0), .5), Material(int(mod(pos.x, 0.3) < 0.15) + int(mod(pos.z, 0.3) < 0.15) == 1 ? vec3(0.0) : vec3(1.0), 1.5));\n  object(sdPlane(pos, vec3(0.0, -1.0, 0.0), 3.0), Material(vec3(0.4), 1.2));\n  return minDist;\n}\n\nvec2 raymarch ( vec3 ro, vec3 rd, inout Material material ) {\n  float t = 0.0005;\n  float dist;  \n  for (int i = 0; i < 250; i++) {\n    dist = scene(ro + rd * t, material);\n    if (dist < 0.0001) {\n      break;\n    }\n    t += dist;\n  }\n  \n  return vec2(t, dist);\n}\n\nfloat raymarchShadow ( vec3 ro, vec3 rd, float maxt, float k ) {\n  float res = 1.0;\n  Material tmp;\n  for (float t = 0.0005; t < maxt; ) {\n    float h = scene(ro + rd * t, tmp);\n    if (h < 0.0001) {\n      return 0.0;\n    }\n    res = min(res, k * h / t);\n\n    t += h;\n  }\n  \n  return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)* 0.0001;\n    Material material;\n    return normalize( e.xyy*scene( pos + e.xyy, material ) + \n\t\t\t\t\t  e.yyx*scene( pos + e.yyx, material ) + \n\t\t\t\t\t  e.yxy*scene( pos + e.yxy, material ) + \n\t\t\t\t\t  e.xxx*scene( pos + e.xxx, material ) );\n}\n\nvec3 aces(in vec3 c) {\n    vec3 v = c * aces_input; // ref https://64.github.io/tonemapping/\n    vec3 b = v * (v + 0.0245786) - 0.000090537;\n    vec3 d = v * (0.983729 * v + 0.4329510) + 0.238081;\n    v = b/d;\n    return v * aces_output;\n}\n\nfloat ggxDist( in float roughness, in float cosine) {\n  float a2 = roughness * roughness * roughness * roughness;\n  float cosine2 = cosine * cosine;\n  float den = cosine2 * (a2 - 1.0) + 1.0;\n  return (a2 * (cosine > 0.0 ? 1.0 : 0.0)) / (3.14159265 * den * den);\n}\n\nfloat ggxGeometrySchlick (float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfloat ggxGeometrySmith(vec3 n, vec3 v, vec3 l, float roughness)\n{\n    float NdotV = max(dot(n,v), 0.0);\n    float NdotL = max(dot(n, l), 0.0);\n    float ggx2  = ggxGeometrySchlick(NdotV, roughness);\n    float ggx1  = ggxGeometrySchlick(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\n\nfloat fresnelSchlick (float ior, float cosine) {\n  float r0 = (1.0 - ior) / (1.0 + ior);\n  r0 *= r0;\n  return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);\n}\n\n\nfloat cookTorrance(vec3 toLight, vec3 normal, vec3 halfway, vec3 v, float roughness, float ior) {\n  float NDF = ggxDist(roughness, dot(normal, halfway));\n  float G = ggxGeometrySmith(normal, v, toLight, roughness);\n  float F = fresnelSchlick(ior, dot(halfway, v));\n  float numerator = NDF * G * F;\n  float denominator = 4.0 * max(dot(normal, v), 0.0) * max(dot(normal, toLight), 0.0) + 0.0001;\n  \n  return clamp(numerator / denominator, 0.0, 1.0);\n}\n\nvec3 bg(vec3 ro, vec3 rd) {\n  return vec3(0.4);\n}\n\nvec3 getCol(vec3 ro, vec3 rd, float t, Material mat, inout vec3 normal) {\n  vec3 col;\n  vec3 pos = ro + rd * t;\n  normal = calcNormal(pos);\n  vec3 light = vec3(2.0, 2.0, -1.0);\n  vec3 toLight = normalize(light - pos);\n  float shade = max(0.0, dot(normal, toLight));\n  col = shade * mat.albedo;\n  vec3 halfway = normalize(normalize(light - pos) - rd);\n  col += vec3(1.0) * vec3(cookTorrance(toLight, normal, halfway, -rd, 0.1, mat.ior));\n  \n  float shadow = raymarchShadow(pos, toLight, length(light - pos), 5.);\n  col *= shadow;\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float AA = float(anti_aliasing);\n    vec3 finalCol = vec3(0.0);\n    mat4 rot = rotationMatrix(vec3(1.0, 0.0, 0.0), 0.) * rotationMatrix(vec3(0.0, 1.0, 0.0), 0.4);\n    \n    for (float i = 0.0; i < 1.0; i += 1.0 / AA) {\n    for (float j = 0.0; j < 1.0; j += 1.0 / AA) {\n    float aspectRatio = iResolution.x / iResolution.y;\n    float fov = 89.0;\n    float Px = (2. * ((fragCoord.x + i + 0.5) / iResolution.x) - 1.) * tan(fov / 2. * 3.1415 / 180.) * aspectRatio; \n    float Py =  2. * ((fragCoord.y + j + 0.5) / iResolution.y) * tan(fov / 2. * 3.1415 / 180.0) - 1.0; \n    \n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    \n    vec3 rd = normalize((rot * vec4(Px, Py, 1.0, 1.0)).xyz);\n    vec3 ro = vec3(iMouse.xy / iResolution.xy, -2.0);\n    \n    Material material;\n    vec2 result = raymarch(ro, rd, material);\n    float t = result.x;\n    \n    vec3 col;\n    if (result.y < 0.0001) {\n      vec3 normal;\n      col = getCol(ro, rd, t, material, normal);\n      if (material.ior != 1.0) {\n        vec3 ref = reflect(rd, normal);\n        float fresnel = fresnelSchlick(material.ior, dot(ref, normal));\n        Material reflectedMaterial;\n        vec2 reflected = raymarch(ro + rd * t, ref, reflectedMaterial);\n        vec3 reflectedCol = reflected.y >= 0.0001 ? bg(ro + rd * t, ref) : getCol(ro + rd * t, ref, reflected.x, reflectedMaterial, normal);\n        col = mix(col, reflectedCol, fresnel);\n      }\n      col = aces(col);\n      col = pow(col, vec3(0.454545));\n    } else {\n      col = bg(ro, rd);\n    }\n    finalCol += col / (AA * AA);\n    }\n    }\n    \n    \n    fragColor = vec4(finalCol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtySR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[382, 382, 427, 427, 1055], [1057, 1057, 1098, 1098, 1124], [1126, 1126, 1155, 1155, 1242], [1244, 1244, 1295, 1295, 2591], [2593, 2593, 2654, 2654, 2857], [2859, 2859, 2923, 2923, 3149], [3151, 3151, 3183, 3183, 3448], [3450, 3450, 3472, 3472, 3689], [3691, 3691, 3744, 3744, 3954], [3956, 3956, 4013, 4013, 4168], [4170, 4170, 4235, 4235, 4452], [4455, 4455, 4503, 4503, 4608], [4611, 4611, 4708, 4708, 5060], [5062, 5062, 5089, 5089, 5111], [5113, 5113, 5186, 5186, 5660], [5662, 5662, 5719, 5719, 7323]], "test": "untested"}
{"id": "flGSRV", "name": "3D grid", "author": "FabriceNeyret2", "description": "3D grid / array of spheres.  uncomment 19 for the axis.\n\nMouse controls, camera.", "tags": ["raymarching", "sdf", "short"], "likes": 15, "viewed": 375, "published": 3, "date": "1640976383", "time_retrieved": "2024-07-30T18:39:12.335139", "image_code": "#define rot(a)          mat2(cos(a+vec4(0,11,33,0)))  // rotation\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.; \n    \n    vec3  R = iResolution, Y = vec3(0,1,0),\n          D = normalize(vec3((U+U-R.xy)/R.y, -3.)),   // ray direction\n          p = vec3(0,0,25), q,a,                      // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(10,12,0)/1e2*cos(iTime+vec3(0,11,0))+vec3(0,.12,0); \n\n    for ( O=vec4(1); O.x > 0. && t > .005; O-=.01 ) {\n        q = p,\n        q.yz *= rot(.5-6.3*M.y),                      // rotations\n        q.xz *= rot(-6.3*M.x), // t = 9.,\n        a = abs(q), \n        q = fract(q)-.5,                              // cells\n        t = length(q)-.2,                             // spheres\n     // t = min( t, min(length(q.xy),min(length(q.yz),length(q.xz)))-.01), // axis\n        t = max( t, max(a.x, max(a.y,a.z))-6. ),      // clamp to cube\n     \n        p += .4*t*D;                                  // step forward = dist to obj\n    }\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGSRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 103, 103, 1009]], "test": "untested"}
{"id": "NlyXRK", "name": "Causality", "author": "zovox", "description": "Trying to draw a sphere made of points which can be zoomed in on to reveal spheres that repeat this pattern when also zoomed on, forever. Please let me know if anyone has posted anything close to attempting this. Thank you Shadertoy community!", "tags": ["reason"], "likes": 0, "viewed": 104, "published": 3, "date": "1640968761", "time_retrieved": "2024-07-30T18:39:13.218776", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //coordinate system\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec4 t1 = marchScene(uv, iTime);\n    vec4 t2 = marchScene(vec2(atan(t1.x, t1.z)/PI*2., t1.y), iTime);\n    fragColor = t1+t2;\n}", "image_inputs": [], "common_code": "//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define FAR (10.)\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define saw(x) fract( sign( 1.- mod( abs(x), 2.) ) * abs(x) )\n\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdSphere( vec3 p, vec3 s, float r )\n{\n    return length(p-s)-r;\n}\nfloat smooth_floor(float x) {\n    return smoothstep(0.5, 1., fract(x))+floor(x);\n}\n\nfloat dfScene(in vec3 z0){\n    float mind = 1E32;\n    \n    const float detail = 8.;\n    for(float vert = 0.; vert < detail; vert += 1.) {\n        for(float horiz = 0.; horiz < detail; horiz += 1.) {\n            float alpha = (vert/detail)*PI;\n            float omega = (horiz/detail*2.-1.)*PI;\n            \n            vec3 o = vec3(sin(alpha)*cos(omega), sin(alpha)*sin(omega), cos(alpha));\n            float d = sdSphere(z0, o, .125);\n            if(d < mind) mind = d;\n        }\n    }\n    \n\treturn mind;\n}\n\nvec3 surfaceNormal(vec3 p) { \n    vec2 e = vec2(5.0 / 1024., 0);\n\tfloat d1 = dfScene(p + e.xyy), d2 = dfScene(p - e.xyy);\n\tfloat d3 = dfScene(p + e.yxy), d4 = dfScene(p - e.yxy);\n\tfloat d5 = dfScene(p + e.yyx), d6 = dfScene(p - e.yyx);\n\tfloat d = dfScene(p) * 2.0;\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n//main march\nvec4 marchScene(vec2 uv, float time) {\n    \n    float movement = time/PI;\n    //camera\n    vec3 rd = normalize(vec3(uv, -2.+cos(movement)));\n    vec3 ro = vec3(0.0, 0., 2.);\n    \n    //rotate camera\n    rd.xz *= rot(-movement);\n    ro.xz *= rot(-movement);\n    ro += rd/512.;\n    \n    float d = 0.0; //distance marched\n    vec3 rp = vec3(0.0); //ray position\n   \tfloat ns;\n    vec3 p;\n    for (int i = 0; i <16; i++) {\n        rp = ro + rd * d;\n        p = rp;\n        ns = dfScene(p);\n        d += ns;\n        if(d > FAR)\n        {\n            break;\n        }\n        \n    }\n    float fog = smoothstep(.75, .9, d/FAR);\n    vec3 n = surfaceNormal(p);\n    return vec4(n, 1.)*(1.-fog);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlyXRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 81, 335]], "test": "untested"}
{"id": "NtGSzK", "name": "sphere cup by a plane2", "author": "z0rg", "description": "https://twitter.com/iquilezles/status/1476870651071713283", "tags": ["sdf", "sphere", "intersection", "marching", "csg", "implicit", "surface", "subtraction", "roundness"], "likes": 9, "viewed": 251, "published": 3, "date": "1640966058", "time_retrieved": "2024-07-30T18:39:13.998691", "image_code": "// Fork of \"sphere cup by a plane\" by panna_pudi. https://shadertoy.com/view/stKXzy\n// 2021-12-31 15:52:22\n\n// Edit : I think I got the interior right by adding this line 10\n// return max(length(p) - r, -p.y);\n\n// Edit2 : iq arbitrary cut version\n// https://www.shadertoy.com/view/ftVXRc\n\nfloat splane( in vec2 p, in float r ) {\n    p.x = abs(p.x);\n    if (p.y > 0.) {\n        return max(length(p) - r, -p.y);\n    }\n    return p.x < r ? -p.y: length(p - vec2(r, 0.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    float roundness = .5*(sin(iTime)*.5+.5);\n\tfloat d = splane(p,0.5)-roundness;\n    \n\t// coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = splane(m,0.5)-roundness;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGSzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[289, 289, 328, 328, 469], [472, 472, 529, 529, 1215]], "test": "untested"}
{"id": "7tGXzG", "name": "ReFractance", "author": "PsyPhi", "description": "Raymarching with Refractance", "tags": ["raymarching"], "likes": 4, "viewed": 210, "published": 3, "date": "1640965001", "time_retrieved": "2024-07-30T18:39:14.884323", "image_code": "#define MAX_STEPS 50\n#define MAX_DIST 25.\n#define SURF_DIST .001\n#define FRACT_STEPS 1\n#define PI 3.14159\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n    vec3 MOD3 = vec3(443.8975, 397.2973, 491.1871);\n    vec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat map(float x, float inMin, float inMax, float outMin, float outMax) {\n    return (x - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n}\n\nvec3 hs(vec3 c, float s){\n    vec3 m=vec3(cos(s),s=sin(s)*.5774,-s);\n    return c*mat3(m+=(1.-m.x)/3.,m.zxy,m.yzx);\n}\n\nmat2 rotate(float a) {\n\tfloat c = cos(a),\n\ts = sin(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ){  //smooth merges two objects\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\n\n//_+_+_+_+_+_+_SHAPING FUNCTIONS_+_+_+_+_+_+_+_\n\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n//DIST\nfloat GetDist(vec3 p) {\n    vec3 pUnaltered = p;\n\nfor (int i = 0; i < FRACT_STEPS ; i++){\n\n    int mirrorX = 1;\n    int mirrorY = 1;\n    int mirrorZ = 0;\n    vec3 trans = vec3(1,0.001,0.);\n    vec3 rot = vec3(0.5,0.5,0.5);\n    float twist = 0.1;\n    float range = 0.1;\n    float stepAmt = 0.01;\n    float even = -1.+floor(mod(float(i),2.))*2.;\n    float fifth = 1.+floor(mod(float(i),2.))*-2.;\n\n    if(mirrorX == 1) p.x = abs(p.x); //Mirror X\n    if(mirrorY == 1 && fifth == -1.) p.y = abs(p.y); //Mirror Y\n    if(mirrorZ == 1) p.z = abs(p.z); //Mirror Z\n\n\n    //TRANSFORM\n    //Transform X\n    p.x -= trans.x;\n    +(iMouse.x/iResolution.x)*range\n    +sin(iTime*0.2)\n    +((float(FRACT_STEPS)-float(i))*stepAmt)\n    ;\n    //Transform Y\n    p.y -= trans.y+(iMouse.x/iResolution.x)*range\n    +(iMouse.x/iResolution.x)*range\n    +cos(iTime*0.1)\n    +((float(FRACT_STEPS)-float(i))*stepAmt)\n    ;\n    //Transform Z\n    p.z -= trans.z;\n\n\n    //ROTATE\n    p.xy *= rotate(rot.x+sin(iTime*0.02)*p.z*0.001);\n    p.xz *= rotate(rot.y+cos(iTime*0.01))*even;\n    p.yz *= rotate(rot.z\n    +(float(FRACT_STEPS)-float(i))*stepAmt\n    );\n    \n    //SCALE\n    //p * vec3(20.);\n\n    //Twist\n    p.xz *= rotate(twist);\n}\n\n    //Rotate object w mouse\n    p.xz *= rotate(1.-(iMouse.x/iResolution.x)*5.);\n    p.yz *= rotate((iMouse.y/iResolution.y)*5.);\n\n\tfloat d = 1.; //Just to have the d var declaired\n\tvec4 rec = vec4(0.0, 0.0, 0.0, 5.*abs(sin(iTime*0.25))+2.);\n\tfloat recDist = length(max(abs(p) - rec.w, 0.));\n\n    //Dimond\n    float dimond = sdOctahedron(p+vec3(0.,0.,0.),10.);\n    float boxFrame = sdBoxFrame(p, vec3(5.,5.,5.), 0.5);\n    \n    //Sphere\n    //float sphere = sdSphere( pUnaltered, 5.);\n    \n    d = dimond;\n    d = opSmoothUnion( dimond,boxFrame, 1.);\n    d = fOpUnionStairs(dimond,boxFrame, 1., 4.);\n    //d = opIntersection( recDist, dimond );\n    //d = opSubtraction( dimond, recDist);\n    //d = opSmoothUnion( d,sphere, 1.);\n\n\n    return d;\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd, float side) {//Side 1 = outside -1 = inside\n\tvec3 dO = vec3(0.,0.,10.);  //  x = distance ray has traveled, y = Iterations to hit, z = Closest distance to surface\n\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO.x;\n        float dS = GetDist(p)*side;\n        dO.x += dS;\n\t\t\t\tdO.z = min(dS, dO.z);\n\t\t\t\tdO.y = float(i);\n        if(dO.x>MAX_DIST || dS<SURF_DIST) break;\n    }\n\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.1, 0);//Set to .001 for relistic, increase to soften edges.\n\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 1, -6);\n    //lightPos.xz += vec2(sin(TIME), cos(TIME))*2.; //light movement\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l,1.).x;\n    if(d<length(lightPos-p)) dif *= .1;\n\n    return dif;\n}\n\nvec3 render(vec3 ro, vec3 rd){\n    vec3 col = texture(iChannel0, rd).rgb;\n    float IOR = 1.45;\n    \n    vec3 d = RayMarch(ro, rd, 1.);//raymarch outside\n    \n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;//get closest point?\n        vec3 n = GetNormal(p)\n            //+hash12(p.xy)*0.005//Texture on normals\n            ;\n            \n        vec3 r = reflect(rd,n);//reflected ray direction\n        vec3 reflTex = texture(iChannel0, r).rgb;//reflected Texture\n        vec3 refCol = vec3(0.0,1.,1.0);\n        \n        vec3 rdIn = refract(rd, n, 1./IOR);//Ray direction after being refracted into the object\n       \n        vec3 pEnter = p- n*SURF_DIST*3.;//Point that enters the object\n        vec3 dIn = RayMarch(pEnter, rdIn, -1.);//raymarch inside\n        \n        vec3 pExit = pEnter + rdIn * dIn.x;//get closest point?\n        vec3 nExit = -GetNormal(pExit);\n        \n        vec3 refraTex = vec3(0.);//refracted Texture\n        vec3 rdExit = vec3(0.);\n        \n        float chromaticAbberation = 0.01;\n        float dens = 0.07; //Density of the object\n        vec3 densCol = vec3(1.0,0.5,0.9); // color of the object\n      \n        //red\n        rdExit = refract(rdIn, nExit, IOR-chromaticAbberation);//Ray direction after being refracted out of the object\n        if(dot(rdExit,rdExit) == 0.) rdExit = reflect(rdIn, nExit);\n        refraTex.r = texture(iChannel0, rdExit).r;\n        \n        //green\n        rdExit = refract(rdIn, nExit, IOR);//Ray direction after being refracted out of the object\n        if(dot(rdExit,rdExit) == 0.) rdExit = reflect(rdIn, nExit);\n        refraTex.g = texture(iChannel0, rdExit).g;\n        \n        //blue\n        rdExit = refract(rdIn, nExit, IOR+chromaticAbberation);//Ray direction after being refracted out of the object\n        if(dot(rdExit,rdExit) == 0.) rdExit = reflect(rdIn, nExit);\n        refraTex.b = texture(iChannel0, rdExit).b;\n        \n        float fresnel = pow(1.+dot(rd,n), 5.);\n        \n        float optDist = exp(-dIn.x*dens); \n\n        float light = GetLight(p); //lighting\n        float diffuse = dot(n,normalize(vec3(1,2,3)))*.5+.5;//diffuse Mat\n        \n\n        refraTex = refraTex*optDist*densCol;//absorbs light and colors it as it passed through the object.\n        //col = vec3(fresnel);p[\n        //col = n*0.5+0.5;\n        //col = vec3(1.-d.x*0.04);\n        \n        col = mix(refraTex, reflTex*refCol, fresnel);\n        col = mix(col,n*0.5+0.5,floor(mod(d.x,2.0)));\n    }\n    \n    return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n\n{\n    vec2 uv = (fragCoord+fragCoord - (iResolution.xy) ) / iResolution.y ;\n    vec3 color = vec3(0);\n    vec3 iterationsColor;\n\tvec3 proxColor;\n    vec3 distColor;\n    vec3 normalColor = vec3(0.);\n\n    vec3 ro = vec3(0, 0, -30);\n     //rd.xz *= rotate((iMouse.x/iResolution.x)*5.);\n    //rd.yz *= rotate((iMouse.y/iResolution.y)*5.);\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n\n    \n    //color = texture(iChannel0,rd).rgb;\n    \n    color = render(ro,rd);\n\n    color = pow(color, vec3(0.454));\n    fragColor = vec4(color,1.0);\n\n}\n\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGXzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 169, 191, 191, 361], [364, 364, 438, 438, 511], [513, 513, 538, 538, 630], [632, 632, 654, 654, 715], [717, 717, 768, 797, 896], [898, 898, 956, 956, 1066], [1068, 1068, 1111, 1111, 1133], [1135, 1135, 1179, 1179, 1200], [1253, 1253, 1298, 1298, 1578], [1580, 1580, 1618, 1618, 1898], [1900, 1900, 1935, 1935, 1959], [3916, 3916, 3961, 3991, 4352], [4354, 4354, 4378, 4378, 4611], [4613, 4613, 4637, 4637, 4957], [4959, 4959, 4989, 4989, 7449], [7452, 7452, 7509, 7509, 8047]], "test": "untested"}
{"id": "stKXRG", "name": "Super S SDF", "author": "celyk", "description": "My Signed Distance Function for the legendary symbol.", "tags": ["s", "graffitis", "stussys", "supers", "supermans", "universals", "pointys", "middleschools"], "likes": 5, "viewed": 187, "published": 3, "date": "1640963237", "time_retrieved": "2024-07-30T18:39:15.654264", "image_code": "//MIT license\n\nconst float PI = 3.1415962;\n\nfloat line(vec2 p,vec2 a,vec2 b){\n  return length(clamp(dot(b-=a,p-=a)/dot(b,b),0.,1.)*b-p);\n}\n\nvec2 rot90(vec2 a){return vec2(-a.y,a.x);}\n\nfloat shape0(vec2 p,vec2 d){\n    p=abs(p);\n    vec2 a = vec2(1,0);\n    vec2 b = vec2(1,d.y);\n    vec2 c = vec2(0,d.y+d.x);\n    return sign(max(dot(p-b,rot90(a-b)),dot(p-c,rot90(b-c))))*\n    min(\n        line(p,a,b),\n        line(p,b,c)\n    );\n}\n\nfloat SuperS(vec2 p,vec2 a){\n    p*=step(0.,p.y)*2.-1.;\n    p.y=p.y-a.y-a.x*.5;\n    float d = shape0(p,a);\n    d = max(d,-line(p,vec2(0,a.y),vec2(0,-a.y)));\n    d = max(d,-line(p,vec2(0,-a.y),vec2(1,-a.y-a.x)));\n    return d;\n}\n\nvoid mainImage(out vec4 O, vec2 U){\n    float z = 7.;\n    vec2 uv = (2.*U - iResolution.xy)/iResolution.y*z;\n    vec2 j = floor(uv*.4);\n    uv.x = (uv.x*.4-j.x-.5)/.4;\n    vec2 m = (2.*iMouse.xy - iResolution.xy)/iResolution.y;\n    float AA = .5/z*iResolution.y;\n    \n    float d = SuperS(uv,vec2(cos(iTime*1.73+j.x)+1.,cos(iTime+j.x)*.3+.7));\n    \n    O = vec4(1);\n    O.xyz *= min(1.,abs(d)*AA-AA*.05);\n    \n    if(iMouse.z>0.) \n        O.xyz *= .8 + .4*cos(d*PI*10.);\n        \n    O.xyz *= mix(vec3(0.000,0.357,0.522),vec3(1,sin(j.x)*.5+.5,.3),step(d,0.));\n    \n    //O = vec4(abs(d));\n    //O.xyz=1.-exp(-O.xyz);\n    O.xyz=sqrt(O.xyz);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKXRG.jpg", "access": "api", "license": "mit", "functions": [[44, 44, 77, 77, 138], [140, 140, 159, 159, 182], [184, 184, 212, 212, 428], [430, 430, 458, 458, 657], [659, 659, 694, 694, 1300]], "test": "untested"}
{"id": "NtySRK", "name": "other tests 01", "author": "jorge2017a2", "description": "other tests 01", "tags": ["othertests01"], "likes": 8, "viewed": 181, "published": 3, "date": "1640962781", "time_retrieved": "2024-07-30T18:39:16.420216", "image_code": "//----------image\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 120.\n#define MIN_DIST 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    //p= rotate_x(p, radians(45.0));\n    p= rotate_y(p, radians(60.0));\n    \n    vec3 p0=p;\n    \n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   res =opU3(res, vec3(planeDist1,-1.0,7.0));\n   \n    p.x= opRep1D( p.x, 30.0 );\n    p.z= opRep1D( p.z, 20.0 );\n    \n    float d1= sdCylinderXY(p-vec3(0.0,3.0,0.0), vec2(1.0,3.5) );\n    vec3 p1=rotate_z(p-vec3(0.0,4.0,0.0), radians(75.0*sin(iTime)));\n    vec3 a,b;\n    a=vec3(0.0,0.0,0.0);\n    b=vec3(0.0,7.0,0.0);\n    float d1a= sdCapsule( p1, a, b,1.0 );\n    float d2a= sdCylinderXY(p1-vec3(0.0,7.0,0.0), vec2(4.5,1.0) );\n    float d2b= sdBox( p1-vec3(0.0,4.5,0.0), vec3(5.5,2.2,2.0) );\n    d2a= differenceSDF(d2a, d2b);\n    \n    p.z=abs(p.z)-2.0;\n    float d3a= sdCylinderXY(p-vec3(0.0,3.0,0.0), vec2(3.0,0.5) );\n    float d3b= sdCylinderXY(p-vec3(0.0,3.0,0.0), vec2(3.0,0.5) );\n    \n    res =opU3(res, vec3(d1,3.0,-1.0));\n    res =opU3(res, vec3(d2a,13.0,-1.0));\n    res =opU3(res, vec3(d1a,10.0,-1.0));\n    res =opU3(res, vec3(d3a,18.0,-1.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x*0.5;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col*(dif+.35 +vec3(.35,.45,.5)*spe) + vec3(.7,.9,1)*spe*spe;\n    color*=occ;\n    return color;\n}\n\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==7.0)\n        {return pattern( p.xz );}\n    if (id_material==8.0)\n        {return pattern( p.xy );}\n    if (id_material==9.0)\n        {return pattern( p.zy );}\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3( 20.0, 20.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3(-20.0, 30.0,10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0+t,15.0,-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n    rd= rotate_y(rd, radians(60.0));\n    rd= rotate_x(rd, radians(45.0));\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    //col = exposureToneMapping(2.0, col);\n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtySRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[459, 459, 491, 491, 575], [576, 576, 615, 615, 710], [711, 711, 750, 750, 845], [846, 846, 885, 885, 980], [982, 1026, 1073, 1073, 1100], [1101, 1101, 1144, 1144, 1171], [1172, 1172, 1220, 1220, 1248], [1249, 1287, 1323, 1323, 1368], [1369, 1434, 1468, 1468, 1564], [1565, 1565, 1599, 1599, 1690], [1691, 1691, 1725, 1725, 1816], [1817, 1817, 1851, 1851, 1946], [1949, 1949, 2001, 2001, 2122], [2124, 2124, 2149, 2149, 3189], [3191, 3191, 3215, 3215, 3377], [3379, 3379, 3428, 3428, 4063], [4066, 4066, 4102, 4102, 4347], [4349, 4349, 4386, 4386, 4660], [4662, 4662, 4745, 4745, 5319], [5322, 5322, 5415, 5415, 5545], [5547, 5547, 5579, 5579, 5776], [5778, 5826, 5854, 5854, 6042], [6044, 6044, 6091, 6091, 6322], [6324, 6324, 6417, 6417, 6758], [6760, 6760, 6791, 6791, 7390], [7392, 7392, 7418, 7418, 7528], [7530, 7530, 7588, 7588, 7640], [7642, 7642, 7699, 7699, 8361]], "test": "untested"}
{"id": "ftKSzy", "name": "SDF roundness and hard csg", "author": "toomuchvoltage", "description": "How to combat roundness issues with hard CSG ops on implicit surfaces:\n\nUse smooth intersection/subtraction with your roundness value instead of regular subtraction/intersection and finally subtract the roundness.", "tags": ["sdf", "sphere", "intersection", "marching", "csg", "implicit", "surface", "subtraction", "roundness"], "likes": 3, "viewed": 365, "published": 3, "date": "1640920808", "time_retrieved": "2024-07-30T18:39:17.183177", "image_code": "/* \n   How to combat roundness issues with hard subtractions/intersections...\n   Adapted from iq's example: https://www.shadertoy.com/view/3ltSW2\n   twitter.com/toomuchvoltage\n*/\n\n// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Signed distance to a disk\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat sdHalfCircle( in vec2 p, in float r ) \n{\n    float roundness = sin(iTime) * 0.5;\n    if ( roundness < 0.0 )\n    {\n        roundness = abs(roundness);\n        return opSmoothIntersection (length(p)-r, p.y, roundness) - roundness;\n    }\n    else\n        return max (length(p)-r, p.y) - roundness;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n\tfloat d = sdHalfCircle(p,0.5);\n    \n\t// coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdHalfCircle(m,0.5);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKSzy.jpg", "access": "api", "license": "mit", "functions": [[1418, 1418, 1477, 1477, 1576], [1578, 1578, 1624, 1624, 1880], [1883, 1883, 1940, 1940, 2573]], "test": "untested"}
{"id": "ftKXzG", "name": "LineOP", "author": "Del", "description": "playing with sampling SDF distances along a line", "tags": ["sdf", "line", "extrude"], "likes": 15, "viewed": 343, "published": 3, "date": "1640915450", "time_retrieved": "2024-07-30T18:39:18.010963", "image_code": "// playing with sampling various SDF distances along a line segment\n\nfloat lengthN(vec2 v, float n)\n{\n    vec2 tmp = pow(abs(v), vec2(n));\n    return pow(tmp.x+tmp.y, 1.0/n);\n} \nfloat roundBox(vec3 p, vec3 size, float r)\n{\n    return length(p-clamp(p,-size,size))-r;\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e)\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// distance in ret.z\nvec3 closestPtSegWithDist(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p-a;\n    vec2 ba = b-a;\n    float _ddd = dot(pa,ba)/dot(ba,ba);\n    float dal = _ddd/length(ba);\n\treturn vec3(a + ba*clamp(_ddd, 0., 1.),dal);\n}\n// r.w = distance along line (unclamped)\nvec4 opLine(vec3 p, vec3 a, vec3 b, vec3 up)\n{\n   \tvec3 w = normalize(cross(a-b, b-up));\n\tvec3 v = normalize(cross(w, a-b));\n\tvec3 u = cross(w,v);\n    mat3 m = mat3(u,v,w);\n    a *= m;\n    b *= m;\n    p *= m;\n    vec3 bz = closestPtSegWithDist(p.xy,a.xy,b.xy);\n    float az = (a.z+b.z)*0.5;    \n    return vec4(p.z-az,bz.yx-p.yx,bz.z);\n}\n\n\n\nfloat map( in vec3 p )\n{\n\n\n    vec3 upvec = vec3(0.0,1.0,0.0);\n    vec3 a = vec3(-1.0, -0.5, 0.0);\n    vec3 b = vec3(1.0,  0.5, 0.0);\n\tvec4 bz=opLine(p,a,b,upvec);\n\n\n    bz.x -= 4.5;\n\n  \tfloat dd=abs(lengthN(bz.xy,3.0)-(.5+sin(bz.w*120.0)*0.02))-.05;\n    dd = length(max(vec2(dd,abs(bz.z)),0.0))-0.05;\n    float d = min(1000.0,dd);\n\n    bz.x += 1.5;\n\n    dd = length(bz.xyz)-(0.25+bz.w*0.75);\n    d = min(d,dd);\n\n    bz.x += 1.5;\n        \n    dd = roundBox(bz.xyz,vec3(0.1+bz.w,0.1+bz.w,0.1),0.1);\n    d = min(dd,d);\n\n    bz.x += 1.5;\n\n    dd = sdTorus(bz.xyz,vec2(0.2+(bz.w*0.5),0.1));\n    d = min(dd,d);\n    \n    bz.x += 1.5;\n\n    dd = sdBoundingBox(bz.xyz,vec3(0.2+bz.w,0.2,0.2),0.025);\n    d = min(dd,d);\n\n    bz.x += 1.5;\n    \n    dd = sdCylinder(bz.xyz,vec2(0.1+bz.w,0.1));\n    d = min(dd,d);\n\n    bz.x += 1.5;\n\n    dd = roundBox(bz.xyz,vec3(0.2,0.2,0.1),0.1);\n    d = min(dd,d);\n\n    return d*0.9;\n \n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n    float yy = sin(iTime*.2)*1.5;\n\tvec3 ro = vec3( 6.0*cos(an), 2.0+yy, 6.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 30.0;\n        float t = 0.0;\n        for( int i=0; i<128; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKXzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 101, 101, 176], [178, 178, 222, 222, 268], [270, 270, 317, 317, 599], [601, 601, 634, 634, 699], [701, 701, 737, 737, 836], [838, 859, 910, 910, 1066], [1067, 1108, 1154, 1154, 1445], [1449, 1449, 1473, 1473, 2357], [2359, 2405, 2437, 2437, 2675]], "test": "untested"}
{"id": "NlKSzG", "name": "Microscopy 101", "author": "wyatt", "description": "Fractal with interference pattern", "tags": ["interference"], "likes": 27, "viewed": 405, "published": 3, "date": "1640910354", "time_retrieved": "2024-07-30T18:39:18.837753", "image_code": "\nMain \n{\n    R = iResolution.xy;\n    Q.x = length(A(U).xy);\n    Q.y = length(B(U).xy);\n    Q.z = length(C(U).xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Wavelengths of Each Color\n#define _A (10000./600.)\n#define _B (10000./500.)\n#define _C (10000./400.)\n// Depth of Bubbles\n#define D 1.\n// Iterations\n#define I 8.\n\n\n// Window of Samples\n#define W 80.\n// Number of Samples\n#define N 30.\n\n// Brightness Decay\n#define Z mix(0.,.999,step(.01,mod(T*.2,1.)))\n// Adjust for Brightness\n#define F .06\n\n\n\nvec2 R;\nfloat T;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pi 3.14159265359\n#define _sin(a) sin(mod(a,2.*pi))\n#define _cos(a) cos(mod(a,2.*pi))\nfloat map (vec2 u) {\n    u = 4.*(u-.5*R)/R.y;\n    float d = 0.;\n    float s = 1.;\n    for (float i = 1.; i < I; i++)\n    {\n        \n        u *= (1.7+.5*sin(1.74*floor(.2*T)))*ei(1.-floor(.2*T));\n        u = abs(u)-2.;\n        \n        float l = 1.-length(u);\n        if (l>0.)\n            d += exp2(-i)*sqrt(l);\n        \n        \n    }\n    \n        \n    return D*d;\n}\n// Dave H\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n", "buffer_a_code": "Main \n{\n    R = iResolution.xy;\n    T = iTime;\n    Q = A(U);\n    vec3 eye = vec3(U,R.y);\n    for (float i = 0.; i<N; i++)\n    {\n        vec2 v = U+W*(hash22(vec2(i,iFrame))-.5);\n        vec3 u = vec3(v,map(v));\n        float l = _A*(length(eye-u));\n        Q.xy += F*vec2(_cos(l),_sin(l))/N;\n    }\n    Q *= Z;\n    if (iFrame < 1) Q = vec4(0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main \n{\n    R = iResolution.xy;\n    T = iTime;\n    Q = A(U);\n    vec3 eye = vec3(U,R.y);\n    for (float i = 0.; i<N; i++)\n    {\n        vec2 v = U+W*(hash22(vec2(i,iFrame))-.5);\n        vec3 u = vec3(v,map(v));\n        float l = _B*length(eye-u);\n        Q.xy += F*vec2(_cos(l),_sin(l))/N;\n    }\n    Q *= Z;\n    if (iFrame < 1) Q = vec4(0);\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main \n{\n    R = iResolution.xy;\n    T = iTime;\n    Q = A(U);\n    vec3 eye = vec3(U,R.y);\n    for (float i = 0.; i<N; i++)\n    {\n        vec2 v = U+W*(hash22(vec2(i,iFrame))-.5);\n        vec3 u = vec3(v,map(v));\n        float l = _C*length(eye-u);\n        Q.xy += F*vec2(_cos(l),_sin(l))/N;\n    }\n    Q *= Z;\n    if (iFrame < 1) Q = vec4(0);\n}", "buffer_c_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKSzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7lVSDh", "name": "Raymarched lava lamp", "author": "nyri0", "description": "Trying to make a cool organic lava lamp with raymarching and randomness.\nIf it's too slow, turn down AA to 1. If you have a really good GPU, you can set it to 3 or 4.", "tags": ["raymarching", "lava", "lamp"], "likes": 11, "viewed": 641, "published": 3, "date": "1640887477", "time_retrieved": "2024-07-30T18:39:19.660553", "image_code": "const float EPS = 0.001;\nconst float L = 10.0;\nconst int FSAA = 2;\n\n// Some colors\nconst vec3 Y1 = vec3(1, 0.9, 0.15);\nconst vec3 Y2 = vec3(1., 0.6, 0.1);\nconst vec3 Y3 = vec3(.9, .6, .1);\nconst vec3 R0 = vec3(.9, .3, .1);\nconst vec3 R1 = vec3(.2, .08, 0.);\nconst vec3 O1 = vec3(.7, .3, 0.);\nconst vec3 O2 = vec3(.2, .07, 0.);\nconst vec3 O3 = vec3(.13, .04, 0.);\n\nfloat sq(float x) {\n    return x * x;\n}\n\n// Copyright  2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nvec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D\n    int n = z.x+z.y*11111;\n    // Hugo Elias hash\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));\n}\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat gradient_noise(in vec2 uv) {\n    float f = 0.;\n    uv *= 8.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n    return 0.5 + 0.5*f;\n}\n\nfloat simple_gradient_noise(in vec2 uv) {\n    float f = 0.;\n    uv *= 8.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\t//f += 0.1250*noise( uv ); uv = m*uv;\n\t//f += 0.0625*noise( uv ); uv = m*uv;\n    return f;\n}\n\n// From https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat random(int i, float lo, float hi) {\n    return (hi - lo) * 0.5 * (sin(float(997*i)) + 1.) + lo;\n}\n\nfloat add_ball(int id, vec3 pos, float radius, float period) {\n    int i_period = int(iTime / period);\n    float t = mod(iTime, period) / period;\n    \n    float o = random(id + 13 * i_period, 0., .2);\n    float y = mix(-1., 1., smoothstep(o+0., o+.2, t));\n    y = mix(y, -1., smoothstep(o+.5, o+.8, t));\n    \n    float xlo0 = random(id + 17 * i_period, -0.4, 0.4);\n    float xlo1 = random(id + 17 * (i_period + 1), -0.4, 0.4);\n    float xhi = random(id + 29 * i_period, -0.25, 0.25);\n    float x = mix(xlo0, xhi, smoothstep(o+0., o+.2, t));\n    x = mix(x, xlo1, smoothstep(o+.5, o+.8, t));\n    \n    float zlo0 = random(id + 23 * i_period, -0.2, 0.2);\n    float zlo1 = random(id + 23 * (i_period + 1), -0.2, 0.2);\n    float zhi = random(id + 31 * i_period, -0.2, 0.2);\n    float z = mix(zlo0, zhi, smoothstep(o+0., o+.2, t));\n    z = mix(z, zlo1, smoothstep(o+.5, o+.8, t));\n    \n    vec3 center = vec3(x, y, 2.+z);\n    \n    return length(pos - center) - radius;\n}\n\n// Signed distance function that defines the scene.\nfloat sdf(in vec3 pos) {\n    float sph0_sdf = add_ball(0, pos, 0.2, 40.);\n    float sph1_sdf = add_ball(1, pos, 0.3, 50.);\n    float sph2_sdf = add_ball(2, pos, 0.35, 60.);\n\n    return smin(smin(sph0_sdf, sph1_sdf, .15), sph2_sdf, .15);\n}\n\n// Ray marching engine.\nvoid rayMarcher(in vec2 uv, out bool hit, out float min_dist, out vec3 nml) {\n    uv = uv + vec2(0, .3*simple_gradient_noise(.2*uv));\n\n    float t = 0.0;\n    float dist;\n    vec3 pos;\n    min_dist = L;\n    do {\n        // Orthographic camera\n        pos = vec3(uv, t);\n        dist = sdf(pos);\n        t += dist;\n        min_dist = min(dist, min_dist);\n    } while(t < L && dist > EPS);\n    \n    nml = normalize(vec3(\n        dist - sdf(pos - vec3(EPS, 0, 0)),\n        dist - sdf(pos - vec3(0, EPS, 0)),\n        dist - sdf(pos - vec3(0, 0, EPS))\n    ));\n    \n    hit = dist <= EPS;\n    if(hit) min_dist = 0.;\n}\n\nfloat lamp_sdf(vec2 uv) {\n    float dl = sqrt(0.04*sq(uv.y+0.7)+0.005)-0.75 - uv.x;\n    float dr = sqrt(0.04*sq(uv.y+0.7)+0.005)-0.75 + uv.x;\n    return max(dl, dr);\n}\n\nfloat inner_sdf(vec2 uv) {\n    float dl = 0.08*sq(uv.x) - 0.96 - uv.y;\n    float dh = uv.y + 0.17*sq(uv.x) - 0.97;\n    return max(dl, dh);\n}\n\nvec4 sampleColor(in vec2 sampleCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = 2.0 * sampleCoord / iResolution.xy - 1.0;\n    // Normalized but keeping aspect ratio\n    vec2 uva = vec2(uv.x * aspectRatio, uv.y);\n    \n    // TODO: change shape + gradient behind\n    float d_lamp = lamp_sdf(uva);\n    float d_inner = inner_sdf(uva);\n    \n    vec3 nml;\n    bool hit;\n    float min_dist;\n    rayMarcher(uva, hit, min_dist, nml);\n    \n    float bg_halo_micro = smoothstep(0., .05, min_dist);\n    float bg_halo_macro = smoothstep(0., .6, min_dist);\n    float halo_sides = smoothstep(0., 1., min_dist);\n    float bg_noise = gradient_noise(.2 * uv);\n    float bg_mix = clamp(0.4 * bg_halo_macro + 0.6 * bg_noise, 0., 1.);\n    vec3 bg = mix(O1, O2, bg_mix);\n    bg = mix(R0, bg, bg_halo_micro);\n    bg = mix(mix(Y3, bg, .6 + .4 * smoothstep(0., -0.06+0.01*sin(20.*uva.x+10.*uva.y), d_lamp)),\n             bg, 0.8 * halo_sides);\n    \n    vec3 lightDir = vec3(0, -1, 0);\n    vec3 fg = mix(Y1, Y2, smoothstep(0.1, -0.9, dot(lightDir, nml)));\n    \n    vec3 col = mix(fg, bg, step(EPS, min_dist));\n\n    vec3 back_gradient = mix(R1, vec3(0), smoothstep(.6, 2.5, length(uva)));\n    col = mix(col, vec3(0), smoothstep(0., .005, d_inner));\n    col = mix(col, back_gradient, smoothstep(0., .01, d_lamp));\n\n    // Output to screen\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 colSum = vec4(0);\n    for(int i = 0; i < FSAA; i++) {\n        for(int j = 0; j < FSAA; j++) {\n            colSum += sampleColor(fragCoord + vec2(float(i) / float(FSAA), float(j) / float(FSAA)));\n        }\n    }\n    fragColor = colSum / colSum.w;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVSDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[364, 364, 383, 383, 403], [405, 1463, 1540, 1556, 1749], [1750, 1750, 1776, 1776, 2151], [2152, 2152, 2186, 2186, 2440], [2442, 2442, 2483, 2483, 2731], [2733, 2778, 2819, 2819, 2903], [2905, 2905, 2946, 2946, 3008], [3010, 3010, 3072, 3072, 3973], [3975, 4027, 4051, 4051, 4265], [4267, 4291, 4368, 4368, 4901], [4903, 4903, 4928, 4928, 5070], [5072, 5072, 5098, 5098, 5212], [5214, 5214, 5254, 5254, 6635], [6637, 6637, 6694, 6694, 6951]], "test": "untested"}
{"id": "7tVXDw", "name": "In Air", "author": "wyatt", "description": "Attempt to show why bubbles form when you pour water", "tags": ["fluid", "automata"], "likes": 22, "viewed": 528, "published": 3, "date": "1640838943", "time_retrieved": "2024-07-30T18:39:21.041860", "image_code": "// Fork of \"Water Fall\" by wyatt. https://shadertoy.com/view/NtKGWD\n// 2021-12-30 04:31:49\n\nMain \n{\n    vec4 f = A(U),b=B(U);\n    vec4 m = vec4(0);\n    box if(x!=0&&y!=0) {m+=1./4.*A(U+vec2(x,y));}\n    Q = max(1.-30.*(f-m).wwww,0.);\n    Q -= f.w*(1.-sin((1.+.5*f.z)*vec4(.5,.7,1,1)));\n    Q -= .3*b.wwww;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define r2 0.70710678118\n// oneshade:\n//https://www.shadertoy.com/view/7sKSRh\nfloat std;\nfloat erf(in float x) {\n    x *= std;\n    //return sign(x) * sqrt(1.0 - exp(-1.239192 * x * x));\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x)); // likely faster version by @spalmer\n}\nfloat erfstep (float a, float b, float x) {\n    return .5*(erf(b-x)-erf(a-x));\n}", "buffer_a_code": "// Forces \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u),b=B(U+u);\n        float f = 0.05*(a.w*(a.w-.8)+b.w);\n        dQ.xy -= f*u;\n    }\n    Q += dQ;\n    Q.y -= .2/R.y;\n    Q = clamp(Q,-2.,2.);\n    vec2 M = 1.5*R;\n    if (iMouse.z>0.) M = iMouse.xy;\n    if(length(U-M)<.02*R.y)Q = vec4(0,0,0.*sin(iTime),1.);\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1) Q = vec4(0);\n    if (U.x<3.&&U.y>.9*R.y)Q.w=1.;\n    \n    if (R.x-U.x<3.&&U.y>.9*R.y)Q.w=1.;\n    if (U.x<1.||U.y<1.||R.y-U.y<1.) Q.xy*=0.;\n    if(R.x-U.x<1.)Q.xy *= 0.;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       {\n           float j = 1.;\n           float k = 1.;\n           float wa = 0.25*Q.w*min(i,j)/j;\n           float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n            dQ.w += wa+wb;\n      }\n      {\n           float j = 1.;\n           float k = 1.;\n           float wa = 0.25*Q.w*min(i,j)/j;\n           float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n            dQ.xyz += Q.xyz*wa+q.xyz*wb;\n      }\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Forces \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u),b=B(U+u);\n        float f = 0.1*(a.w+b.w);\n        dQ.xy -= f*u;\n    }\n    Q += dQ;\n    Q = clamp(Q,-2.,2.);\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1) Q = vec4(0,0,0,.1);\n    if (U.x<1.||U.y<1.||R.y-U.y<1.) Q.xy*=0.;\n    if(R.x-U.x<1.)Q.xy *= 0.;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .6;\n       float k = .6;\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVXDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "slKXWw", "name": "plane waves", "author": "medium_fi", "description": "Randomly evolving plane waves", "tags": ["raymarching", "repetition", "tensorfield"], "likes": 2, "viewed": 260, "published": 3, "date": "1640832362", "time_retrieved": "2024-07-30T18:39:21.824768", "image_code": "const int MAX_ITER = 100;\nconst float EPSILON = 1E-5;\n\nvec3 rotate(vec3 v, vec3 k, float angle){\n    k = normalize(k);\n    float c = cos(angle);\n    float s = sin(angle);\n    return v * c + cross(k, v) * s + k * dot(k, v) * (1. - c);\n}\n\nvec3 rotateAxes(vec3 v, vec3 a1, vec3 a2) {\n    vec3 n1 = normalize(a1);\n    vec3 n2 = normalize(cross(a2, a1));\n    vec3 n3 = normalize(cross(n2, n1));\n    mat3 R = mat3(n1, n2, n3);\n    return v*R;\n}\n\nvoid field(in vec3 x, out vec3 a1, out vec3 a2, out vec3 l) {\n    float t = iTime * 2.;\n    \n    // x = x * 0.5;\n    int K = 3;\n    vec3 v = vec3(0.);\n    for (int i = 0; i < 3; i++) {\n        float j = float(i) + t/7721.;\n        // Random direction\n        vec3 n = normalize(vec3(cos(j*71.), cos(j*31.), cos(j*141.)));\n        // Random frequency\n        float c = cos(j*37.);\n        float f = cos(j*17.);\n        float p = cos(j*139.);\n        v = v + n * sin(f * (dot(n, x) - c * t) + p);\n    }\n    \n    a1 = -normalize(v);\n    a2 = normalize(cross(a1, vec3(1.,0.,0.)));\n    float s = pow(3., 2. * clamp(length(v) / float(K), 0., 1.) - 1.);\n    l = 2. * vec3(0.1 * s, 0.03 / s, 0.03 / s);\n}\n\nfloat sdB( vec3 p, vec3 l) // IQ\n{\n    vec3 q = abs(p) - l;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sceneD(vec3 x, out vec3 col) {\n    float t = iTime;\n    \n    float rep = 0.5;\n    vec3 xf = mod(x + 0.5 * rep, rep) - 0.5 * rep;\n    vec3 xi = x - xf; \n    \n    vec3 a1 = vec3(0.);\n    vec3 a2 = vec3(0.);\n    vec3 l = vec3(0.);\n    field(xi, a1, a2, l);\n    l = clamp(l, 0., rep/4.);\n    \n    vec3 xfr = rotateAxes(xf, a1, a2);\n    float d = sdB(xfr, l);\n    col = abs(a1);\n    return d;\n}\n\nvec3 sceneNormal(vec3 p) {\n  vec2 dx = vec2(1.0, -1.0) * EPSILON;\n  vec3 col = vec3(0.);\n  return normalize(\n    dx.xyy * sceneD(p + dx.xyy, col) + dx.yxy * sceneD(p + dx.yxy, col) +\n    dx.yyx * sceneD(p + dx.yyx, col) + dx.xxx * sceneD(p + dx.xxx, col)\n   );\n}\n\nfloat tf(float d) {\n    return 0.7 / (1. + exp(10. * abs(d - 0.1))); \n}\n\n\nvec4 rayMarch(vec3 x, vec3 u, float stopDistance, out vec3 col) {\n\n    vec4 fragColor = vec4(0.);\n    vec3 acc = vec3(0.);\n\n    // Ray marching\n    float dp = 0.;\n    float depth = 0.;\n    float iter = 0.;\n    for (int i = 0; i < MAX_ITER; i++) {\n        vec3 xi = x + depth * u;\n        float d = sceneD(xi, col);\n        \n        //d = max(d, 1.);\n        float clip = 0.3;\n        if (depth < clip && d  < clip) d = clip;\n        \n        depth += d;\n        iter += 1.;\n        \n        // Accumulate\n        acc = acc + (col * tf(d) - 0.1) * (dp + d)/ 2.;\n        \n        if (d <= stopDistance) break;\n        dp = d;\n    }\n    vec3 xf = x + depth * u;\n    fragColor = vec4(acc, 0.);\n    \n    if (true) {\n    // Compute boring lighting\n    vec3 n = sceneNormal(xf);\n    vec3 lightPosition = vec3(2., 2. , 7.);\n    vec3 lightDirection =  normalize(lightPosition - xf);\n    float light = clamp(dot(n,lightDirection), 0., 1.);\n    light = (0.5 * light + 0.5) * clamp(100. / pow(depth, 3.), 0., 1.);\n    //fragColor = fragColor + vec4( vec3(light) * col, 1.);\n\n    // Compute fun lighting\n    fragColor = 0.5 * fragColor + 1. * vec4( (1. - vec3(iter)/100.) * col, 1.);\n    }\n    return fragColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 camera = vec3(0, 0, 5.);\n    vec3 direction = normalize(vec3(uv, -1.));\n    \n    float t = 0.1 * iTime * 0.5 + 10.;\n    vec3 transform = vec3(cos(t) * 2., sin(t) * 1.2, 0.1);\n    float angle = t;\n    camera = rotate(camera, transform, angle);\n    direction = rotate(direction, transform, angle);\n    \n    // Find surface and normal\n    vec3 col = vec3(0.);\n    fragColor = rayMarch(camera, direction, 0.001, col);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKXWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 96, 96, 235], [237, 237, 280, 280, 438], [440, 440, 501, 501, 1136], [1138, 1138, 1172, 1172, 1263], [1266, 1266, 1302, 1302, 1661], [1663, 1663, 1689, 1689, 1925], [1927, 1927, 1946, 1946, 1998], [2001, 2001, 2066, 2066, 3201], [3204, 3204, 3261, 3261, 3752]], "test": "untested"}
{"id": "stVSWw", "name": "code123456789", "author": "JuanDeager", "description": "The Universe Within - Live Coding follow along thingy (with GPVM).\n\nNo audio thingy though.", "tags": ["universe"], "likes": 5, "viewed": 404, "published": 3, "date": "1640829674", "time_retrieved": "2024-07-30T18:39:22.711396", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n\n// distance to a line segment, by projecting your point onto the line\nfloat DistLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    \n    return length(pa - ba * t);\n}\n\n// 2-to-1 hash\nfloat N21(vec2 p)\n{\n    p = fract(p * vec2( 233.34, 851.73));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\n// 2-to-2 hash\nvec2 N22(vec2 p)\n{\n    float n = N21(p);\n    return vec2(n, N21(p + n));\n}\n\n// get the position for a given grid id, and offset for the neighbor cells\nvec2 GetPos(vec2 id, vec2 offset)\n{\n    vec2 n = N22(id + offset) * iTime;\n    return offset + vec2(sin(n.x), cos(n.y)) * 0.4; \n}\n\n// distance to a line, but with the mapping applied\nfloat Line(vec2 p, vec2 a, vec2 b)\n{\n    float d = DistLine(p, a, b);\n    float m = S(0.03, 0.01, d);\n    float d2 = distance(a, b);\n    m *= S(1.2, .8, d2) * 0.5 + S(0.05, 0.03, abs(d2 - 0.75));\n    return m;\n}\n\nfloat Layer(vec2 uv)\n{\n    float m = 0.0; // initial value of mapped distance\n    \n    // creating grid cells across the screen\n    vec2 gv = fract(uv) - 0.5; // position within the grid cell\n    vec2 id = floor(uv);      // the id of the grid cell\n    \n    vec2 p[9]; // randomly moving points, for the neighboring cells\n    \n    int i = 0; // loop across these neighbors\n    for(float y = -1.0; y <= 1.0; y++)\n    {\n        for(float x = -1.0; x <= 1.0; x++)\n        {\n            p[i++] = GetPos(id, vec2(x, y)); // get the random position for all neigbhors\n        }\n    }\n\n    // create lines between neighboring cells\n    float t = iTime * 10.0;\n    for(int i = 0; i < 9; i++)\n    {\n        m += Line(gv, p[4], p[i]);\n        vec2 j = (p[i] - gv) * 10.0;\n        float sparkle = 1.0 / dot(j, j);\n        m += sparkle * (sin(t + fract(p[i].x) * 10.0) * .5 + .5);\n    }\n    \n    m += Line(gv, p[1], p[3]);\n    m += Line(gv, p[1], p[5]);\n    m += Line(gv, p[5], p[7]);\n    m += Line(gv, p[7], p[3]);\n    \n    return m;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 mouse = (iMouse.xy / iResolution.xy) - 0.5;\n    \n    float gradient = uv.y;\n    float m = 0.0;\n    float t = iTime * 0.1;\n    \n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c);\n    \n    uv *= rot;\n    mouse *= rot;\n    \n    for (float i = 0.0; i < 1.0; i += 1.0 / 4.0)\n    {\n        float z = fract(i + t);\n        float size = mix(10.0, 0.5, z);\n        float fade = S(0.0, 0.5, z) * S(1.0, 0.8, z);\n        m += Layer(uv * size + i * 20.0 - mouse) * fade;\n    }\n    \n    vec3 base = sin(t * 5.0 * vec3(.345, .456, .657)) * .4 + .6;\n    vec3 col = base * m;\n    col -= gradient * base;\n\n    // red line between grid cells\n    //if(gv.x > 0.48 || gv.y > 0.48)\n    {\n        //col = vec3( 1.0, 0.0, 0.0 ); // color red on the boundary\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVSWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 110, 150, 150, 285], [287, 302, 321, 321, 422], [424, 439, 457, 457, 513], [515, 590, 625, 625, 719], [721, 773, 809, 809, 984], [986, 986, 1008, 1008, 2009], [2011, 2011, 2066, 2066, 2968]], "test": "untested"}
{"id": "ftKSDm", "name": "Simple Gravitational Lensing", "author": "pancakespeople", "description": "A simple way of making a gravitational lensing effect for a black hole.", "tags": ["blackhole", "gravitationallensing"], "likes": 8, "viewed": 450, "published": 3, "date": "1640819457", "time_retrieved": "2024-07-30T18:39:23.613982", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x + vec2(0.5);\n    vec2 mousePos = (iMouse.xy-0.5*iResolution.xy)/iResolution.x + vec2(0.5);\n    \n    // The position of the black hole\n    vec2 pos = vec2(cos(iTime)*0.25+0.5, sin(iTime)*0.1+0.5);\n    //vec2 pos = mousePos;\n    \n    // The distance of the pixel from the black hole\n    float radius = length(uv - pos);\n    \n    // The angle between the pixel and the black hole\n    float angle = atan(uv.y - pos.y, uv.x - pos.x);\n    \n    // How much the light is bent\n    float bend = 0.05 / radius;\n    \n    // Bend the light towards the black hole\n    uv += -bend * vec2(cos(angle), sin(angle));\n\n    // Sample the texture\n    vec4 col = texture(iChannel0, uv);\n    \n    // The black part of the black hole\n    col *= smoothstep(1.0, 0.9, bend);\n    \n    // A little fade on the right\n    col *= smoothstep(1.0, 0.0, uv.x);\n\n    // Output to screen\n    fragColor = vec4(col);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKSDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 996]], "test": "untested"}
{"id": "NtVXDw", "name": "rotate vector around mouse", "author": "ersteller", "description": "use mouse to move the dot.\nvector rotation with offset\n", "tags": ["sin", "vector", "rotation", "translation", "cosin", "offset"], "likes": 3, "viewed": 250, "published": 3, "date": "1640812093", "time_retrieved": "2024-07-30T18:39:24.537514", "image_code": "\nvec3 rotateZ(vec3 center, vec3 p, float rot ){\n    vec3 cp = p - center;\n    return vec3(\n            cp.x*cos(rot)-cp.y*sin(rot),\n            cp.x*sin(rot)+cp.y*cos(rot),\n            cp.z*1.\n        ) + center;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdLine(vec2 p, vec2 a, vec2 b){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n    // return abs((b.x-a.x)*(a.y-p.y)-(a.x-p.x)*(b.y-a.y))/length(b-a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 tr = vec3((iMouse.x-0.5*iResolution.x)/iResolution.y , \n                   (iMouse.y-0.5*iResolution.y)/iResolution.y, \n                   0 );\n    vec3 p = vec3(0.3 , 0.3, 0)+tr;\n    \n    p = rotateZ(tr, p, iTime*1.);\n    \n    float d = length(vec3(uv,0) - p); \n    vec3 col = vec3(d/3.);\n    if (d < .1) col = vec3(1);\n    \n    \n    d = sdLine(uv,vec2(tr.x,tr.y),vec2(p.x,p.y));\n    if (d < 0.01) col = vec3(1,0,0);  // red line\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtVXDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 47, 47, 214], [216, 267, 304, 304, 495], [497, 497, 554, 604, 1162]], "test": "untested"}
{"id": "slyXDm", "name": "Spaced Pulses Example", "author": "SnoopethDuckDuck", "description": "Hope you find it useful, could probably be improved!\n\n+ not sure if it's continuous (but looks good enough)", "tags": ["e"], "likes": 3, "viewed": 223, "published": 3, "date": "1640807175", "time_retrieved": "2024-07-30T18:39:25.396217", "image_code": "#define pi 3.14159\n\nfloat func(float a, float b) { return tanh(a * b) / tanh(a); }\nfloat thc(float a, float b) { return func(a, cos(b)); }\nfloat ths(float a, float b) { return func(a, sin(b)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    float zoom = 5. + 2. * thc(2., 0.8 * iTime);\n    \n    // Height of pulses (in [-0.5, 0.5] range)\n    float h = 1. / zoom;// + 0.05 * cos(10. * uv.x + iTime);   \n    \n    // Width of pulses\n    float w = 1.5 + 0.5 * ths(4., iTime);\n    \n    // Spacing of pulses\n    float sp = 3. + thc(4., iTime);\n    \n    // Sharpness / squareness of pulses (larger numbers -> squarer pulses)\n    float shrp = 3.;\n    \n    // Translate x\n    float t = 0.; // iTime;\n    \n    // x value (works well with polar co-ordinates)\n    float x = zoom * uv.x;\n    \n    // y value\n    float y = w * (mod(x + t, sp) - 0.5 * sp);\n    y = clamp(y, -1., 1.);\n    y = 0.5 * y * (3. - y * y);\n    \n    // (y = 0.5 * cos(pi * y) works well on it's own)\n    y = 0.5 * cos(pi * y) + 0.5;\n    // (smoothstep makes the base of the pulses smoother (I think))\n    y = smoothstep(0., 1., y); \n    y = func(shrp, y) - 0.5;\n    \n    // Shape (ty fabrice) \n    float v = -uv.y + 2. * h * y;\n    float s = 0.5 * smoothstep(-.7,.7, v/fwidth(v) );\n    //float px = 2./iResolution.y;\n    //s = 0.5 * smoothstep(-px, px, -uv.y + 2. * h * y);\n           \n    // Red lines\n    float s2 = 0.75 * (1. + thc(2., iTime)) * smoothstep(-0.005, 0.005, -abs(abs(uv.y)-h) + 0.001);\n    \n    fragColor = vec4(s2, s, s, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyXDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 50, 50, 82], [83, 83, 112, 112, 138], [139, 139, 168, 168, 194], [196, 196, 253, 253, 1583]], "test": "untested"}
{"id": "stGXDm", "name": "MIDI Synth - smaller data", "author": "PiN", "description": "Generating music with GLSL using preprocessed MIDI events.", "tags": ["sound", "music", "synth", "synthesizer", "midi"], "likes": 4, "viewed": 353, "published": 3, "date": "1640799379", "time_retrieved": "2024-07-30T18:39:26.461369", "image_code": "//----------------------------------------------------------------------------------------------\nconst vec3 programColors[8] = vec3[](\n    vec3(1.0, 0.0, 0.0),\n    vec3(0.0, 1.0, 0.0),\n    vec3(0.0, 0.0, 1.0),\n    vec3(0.0, 1.0, 1.0),\n    vec3(1.0, 0.0, 1.0),\n    vec3(1.0, 1.0, 0.0),\n    vec3(1.0, 1.0, 1.0),\n    vec3(0.5, 0.5, 0.5)\n);\n\n//----------------------------------------------------------------------------------------------\nivec2 GetUsableEventRange(in float time)\n{\n    int loopSec = int(floor(time)) % songLengthSeconds;\n    return ivec2(timeEventRanges[loopSec].x, timeEventRanges[loopSec + 3].y);\n}\n\n//----------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0, 0, 0, 1);\n\n    float y = (fragCoord.y / iResolution.y);\n    float time = mod(iTime, float(songLengthSeconds));\n    \n    float noteDist = 0.5 + 0.5 * sin(y * 3.14159265358);\n    float fragNote = floor((fragCoord.x / iResolution.x) * 127.0 * noteDist + 63.5*(1.0 - noteDist));\n    float fragTime = 3.0 * y - 1.5 + time;\n\n    ivec2 eventRange = GetUsableEventRange(time - 1.5);\n    for (int i = eventRange.x; i < eventRange.y; ++i)\n    {\n        vec4 e = noteEvents[i];\n       \n        if (fragTime >= e.x && fragTime < e.y)\n        {\n            if (floor(e.w) == fragNote && fragTime >= e.x && fragTime < e.y - 0.025)\n            {\n                fragColor.xyz = programColors[int(e.z) % 8] * noteDist * noteDist;\n            }\n        }\n    }\n    \n    if (abs(y - 0.5) < 0.002)\n        fragColor.xyz = vec3(0.25, 0.25, 0.25);\n}\n", "image_inputs": [], "sound_code": "//----------------------------------------------------------------------------------------------\nfloat GetNoteFrequency(float note)\n{\n\treturn 440.0 * pow(2.0, (note - 69.0) / 12.0);\n}\n\n//----------------------------------------------------------------------------------------------\nfloat CalculateADSRVolume(in float time, in vec4 adsr, in float noteDuration)\n{\n    float result = 1.0;\n    \n    float t = min(time, noteDuration);\n    \n    if (t < adsr.x)\n        result = t / adsr.x;\n    else if (t < adsr.x + adsr.y)\n        result = adsr.z + (1.0 - adsr.z) * (1.0 - (t - adsr.x) / adsr.y);\n    else\n        result = adsr.z;\n        \n    if (time > noteDuration)\n    {\n        if (adsr.w > 0.0)\n            result *= max(1.0 - ((time - noteDuration) / adsr.w), 0.0);\n        else\n            result = 0.0;\n    }\n    \n    return result;\n}\n\n//----------------------------------------------------------------------------------------------\nvec2 RenderNoteEvent(in float time, vec4 e)\n{\n    Instrument instr = instruments[int(e.z)];\n\n    float vibrato = instr.fx.x * sin(e.w + time * 4.0 * 6.28);\n    float freq = GetNoteFrequency(floor(e.w) + vibrato);\n    float s = 0.0;\n    \n    for (int i = 0; i < 4; ++i)\n    {\n        float oscilatorVolume = fract(instr.oscilators[i]);\n        if (oscilatorVolume > 0.0)\n        {\n            int oscilatorType = int(instr.oscilators[i]);\n            float oscilatorOctave = instr.octaves[i];\n            \n            if (oscilatorType == 0)\n                s += oscilatorVolume * sin(oscilatorOctave * 6.2831 * time * freq);\n            else if (oscilatorType == 1)\n                s += oscilatorVolume * (2.0 * fract(oscilatorOctave * time * freq) - 1.0);\n            else if (oscilatorType == 2)\n                s += oscilatorVolume * sign(sin(oscilatorOctave * 6.2831 * time * freq));\n        }\n    }\n    \n    float volume = CalculateADSRVolume(time, instr.adsr, e.y - e.x);\n    s *= volume * (1.0 - fract(e.w));\n\n    float pan = fract(e.z);\n    return vec2(s * sqrt(pan), s * sqrt(1.0 - pan));\n}\n\n//----------------------------------------------------------------------------------------------\nvec2 ProcessEvents(in float time, in ivec2 eventRange)\n{\n    vec2 stereoSample = vec2(0, 0);\n    \n    for (int i = eventRange.x; i < eventRange.y; ++i)\n    {\n        vec4 e = noteEvents[i];\n       \n        if (time >= e.x && time < e.y + 1.0)\n            stereoSample += RenderNoteEvent(time - e.x, e);\n    }\n    \n    return stereoSample;\n}\n\n//----------------------------------------------------------------------------------------------\nivec2 GetUsableEventRange(in float time)\n{\n    int loopSec = int(floor(time)) % songLengthSeconds;\n    return timeEventRanges[loopSec];\n}\n\n//----------------------------------------------------------------------------------------------\nvec2 mainSound( int samp, float time )\n{\n    // Usable range, where to look for events\n    ivec2 eventRange = GetUsableEventRange(time);\n\n    return ProcessEvents(mod(time, float(songLengthSeconds)), eventRange);\n}\n", "sound_inputs": [], "common_code": "struct Instrument { vec4 oscilators, octaves, adsr, fx; };\n\nconst Instrument instruments[6] = Instrument[](\n    // 0: \"Acoustic Bass\" (program 32)\n    Instrument( vec4(0.99, 0.5, 0, 0), vec4(1, 2, 1, 1), vec4(0.002, 0.001, 0.75, 0.1), vec4(0, 0, 0, 0) ),\n\n    // 1: \"Clarinet\" (program 71)\n    Instrument( vec4(0.5, 1.25, 2.25, 0), vec4(1, 1, 1.001, 1), vec4(0.001, 0.01, 0.5, 0.05), vec4(0.02, 0, 0, 0) ),\n\n    // 2: \"Acoustic Guitar (nylon)\" (program 24)\n    Instrument( vec4(0.99, 0.5, 1.5, 0), vec4(2, 1.001, 1, 1), vec4(0.001, 0.001, 0.1, 0.2), vec4(0, 0, 0, 0) ),\n\n    // 3: \"Tenor Sax\" (program 66)\n    Instrument( vec4(1.5, 1.25, 2.25, 0), vec4(1, 0.5, 0.501, 1), vec4(0.01, 0.01, 0.5, 0.1), vec4(0.025, 0, 0, 0) ),\n\n    // 4: \"SynthStrings 1\" (program 50)\n    Instrument( vec4(0.125, 1.0625, 0, 0), vec4(1, 2.00001, 1.001, 1), vec4(0.5, 0.5, 0.75, 0.5), vec4(0, 0, 0, 0) ),\n\n    // 5: \"Synth Bass 2\" (program 39)\n    Instrument( vec4(0.99, 0.5, 0, 0), vec4(1, 2, 1, 1), vec4(0.002, 0.001, 0.75, 0.1), vec4(0, 0, 0, 0) )\n);\n\n// Tuples of: [time begin, time end, program + panning, note + invVelocity]...\nconst vec4 noteEvents[874] = vec4[](\n    vec4(3.947, 4.104, 0.50, 36.17), vec4(4.263, 4.420, 0.50, 36.37), vec4(4.421, 4.578, 0.50, 36.30), vec4(4.579, 4.736, 0.50, 36.27), vec4(4.895, 5.051, 0.50, 36.42), \n    vec4(5.053, 5.209, 0.50, 36.33), vec4(5.211, 5.367, 0.50, 36.27), vec4(5.526, 5.683, 0.50, 36.25), vec4(5.684, 5.841, 0.50, 38.17), vec4(6.000, 6.157, 0.50, 40.23), \n    vec4(6.316, 6.472, 0.50, 41.13), vec4(6.316, 6.495, 1.32, 69.27), vec4(6.632, 6.687, 1.32, 69.34), vec4(6.789, 6.946, 0.50, 36.17), vec4(6.789, 6.836, 1.32, 69.35), \n    vec4(6.947, 7.104, 0.50, 41.16), vec4(6.947, 7.184, 1.32, 69.23), vec4(7.263, 7.420, 0.50, 48.09), vec4(7.263, 7.451, 1.32, 69.25), vec4(7.579, 7.736, 0.50, 46.06), \n    vec4(7.579, 7.924, 1.32, 70.17), vec4(8.053, 8.367, 0.50, 46.12), vec4(8.053, 8.451, 1.32, 70.09), vec4(8.368, 8.525, 0.50, 45.20), vec4(8.526, 8.586, 1.32, 70.33), \n    vec4(8.526, 8.683, 0.50, 43.18), vec4(8.684, 8.841, 0.50, 41.17), vec4(8.684, 8.745, 1.32, 69.48), vec4(8.842, 8.999, 0.50, 36.16), vec4(8.842, 9.091, 1.32, 67.23), \n    vec4(9.158, 9.261, 1.32, 67.27), vec4(9.316, 9.384, 1.32, 67.27), vec4(9.316, 9.472, 0.50, 43.12), vec4(9.474, 9.630, 0.50, 36.17), vec4(9.474, 9.742, 1.32, 67.20), \n    vec4(9.789, 9.878, 1.32, 67.36), vec4(9.789, 9.946, 0.50, 43.20), vec4(9.947, 10.012, 1.32, 65.22), vec4(10.105, 10.262, 1.32, 64.22), vec4(10.105, 10.262, 0.50, 36.16), \n    vec4(10.263, 10.578, 1.32, 65.18), vec4(10.579, 11.051, 1.32, 67.20), vec4(10.579, 11.051, 0.50, 38.09), vec4(11.053, 11.367, 0.50, 40.17), vec4(11.368, 11.525, 0.50, 41.13), \n    vec4(11.368, 11.594, 1.32, 69.18), vec4(11.684, 11.741, 1.32, 69.25), vec4(11.842, 11.898, 1.32, 69.25), vec4(11.842, 11.999, 0.50, 36.17), vec4(12.000, 12.157, 0.50, 41.16), \n    vec4(12.000, 12.258, 1.32, 69.16), vec4(12.316, 12.472, 0.50, 48.17), vec4(12.316, 12.553, 1.32, 69.20), vec4(12.632, 12.946, 1.32, 70.12), vec4(12.632, 12.788, 0.50, 46.06), \n    vec4(13.105, 13.420, 0.50, 46.12), vec4(13.105, 13.578, 1.32, 70.08), vec4(13.421, 13.578, 0.50, 45.20), vec4(13.579, 13.641, 1.32, 69.37), vec4(13.579, 13.736, 0.50, 43.18), \n    vec4(13.737, 13.789, 1.32, 69.30), vec4(13.737, 13.893, 0.50, 41.17), vec4(13.895, 14.051, 0.50, 36.12), vec4(13.895, 14.118, 1.32, 67.22), vec4(14.211, 14.423, 1.32, 67.22), \n    vec4(14.368, 14.525, 0.50, 43.12), vec4(14.526, 14.683, 0.50, 36.17), vec4(14.526, 14.745, 1.32, 65.17), vec4(14.842, 15.076, 1.32, 64.20), vec4(14.842, 14.999, 0.50, 36.12), \n    vec4(15.158, 15.314, 0.50, 41.16), vec4(15.158, 15.815, 1.32, 65.13), vec4(15.316, 15.788, 0.50, 36.17), vec4(15.789, 15.946, 0.50, 38.13), vec4(16.105, 16.262, 0.50, 40.06), \n    vec4(16.421, 16.578, 0.50, 41.06), vec4(16.421, 16.660, 1.32, 60.18), vec4(16.579, 16.736, 2.16, 53.26), vec4(16.737, 16.893, 2.16, 60.20), vec4(16.737, 16.976, 1.32, 65.22), \n    vec4(16.895, 17.051, 2.16, 69.17), vec4(16.895, 17.367, 0.50, 45.08), vec4(17.053, 17.303, 1.32, 69.37), vec4(17.211, 17.367, 2.16, 53.22), vec4(17.368, 17.525, 0.50, 48.06), \n    vec4(17.368, 17.525, 2.16, 60.17), vec4(17.368, 17.616, 1.32, 65.18), vec4(17.526, 17.683, 2.16, 69.16), vec4(17.684, 17.841, 0.50, 43.09), vec4(17.684, 18.157, 1.32, 67.03), \n    vec4(17.842, 17.999, 2.16, 55.23), vec4(18.000, 18.157, 2.16, 62.06), vec4(18.158, 18.472, 1.32, 70.06), vec4(18.158, 18.630, 0.50, 46.08), vec4(18.158, 18.314, 2.16, 70.22), \n    vec4(18.474, 18.537, 1.32, 69.22), vec4(18.474, 18.630, 2.16, 55.22), vec4(18.632, 18.684, 1.32, 67.23), vec4(18.632, 18.788, 0.50, 50.02), vec4(18.632, 18.788, 2.16, 62.17), \n    vec4(18.789, 18.843, 1.32, 65.39), vec4(18.789, 18.946, 2.16, 70.17), vec4(18.947, 19.104, 0.50, 36.17), vec4(18.947, 19.199, 1.32, 64.13), vec4(19.105, 19.262, 2.16, 55.25), \n    vec4(19.263, 19.420, 2.16, 64.06), vec4(19.263, 19.322, 1.32, 67.36), vec4(19.421, 19.893, 0.50, 40.09), vec4(19.421, 19.578, 2.16, 70.17), vec4(19.421, 19.480, 1.32, 64.22), \n    vec4(19.579, 19.766, 1.32, 60.22), vec4(19.737, 19.893, 2.16, 55.27), vec4(19.895, 20.051, 0.50, 43.12), vec4(19.895, 20.051, 2.16, 64.17), vec4(19.895, 20.132, 1.32, 64.13), \n    vec4(20.053, 20.209, 2.16, 70.47), vec4(20.053, 20.209, 2.16, 67.33), vec4(20.210, 20.367, 0.50, 41.12), vec4(20.210, 20.683, 1.32, 65.02), vec4(20.368, 20.525, 2.16, 53.23), \n    vec4(20.526, 20.683, 2.16, 60.06), vec4(20.684, 21.472, 1.32, 69.13), vec4(20.684, 20.841, 2.16, 69.06), vec4(20.684, 20.841, 0.50, 36.12), vec4(20.842, 20.999, 0.50, 38.13), \n    vec4(21.000, 21.157, 2.16, 53.25), vec4(21.158, 21.314, 0.50, 40.12), vec4(21.158, 21.314, 2.16, 60.12), vec4(21.316, 21.472, 2.16, 69.16), vec4(21.474, 21.630, 0.50, 41.06), \n    vec4(21.474, 21.703, 1.32, 60.25), vec4(21.632, 21.788, 2.16, 53.26), vec4(21.789, 21.946, 2.16, 60.20), vec4(21.789, 22.028, 1.32, 65.26), vec4(21.947, 22.104, 2.16, 69.17), \n    vec4(21.947, 22.420, 0.50, 45.08), vec4(22.105, 22.335, 1.32, 69.25), vec4(22.263, 22.420, 2.16, 53.22), vec4(22.421, 22.578, 0.50, 48.06), vec4(22.421, 22.578, 2.16, 60.17), \n    vec4(22.421, 22.669, 1.32, 65.16), vec4(22.579, 22.735, 2.16, 69.16), vec4(22.737, 22.893, 0.50, 43.09), vec4(22.737, 23.209, 1.32, 67.03), vec4(22.895, 23.051, 2.16, 55.23), \n    vec4(23.053, 23.209, 2.16, 62.06), vec4(23.210, 23.525, 1.32, 70.06), vec4(23.210, 23.683, 0.50, 46.08), vec4(23.210, 23.367, 2.16, 70.22), vec4(23.526, 23.589, 1.32, 69.22), \n    vec4(23.526, 23.683, 2.16, 55.22), vec4(23.684, 23.737, 1.32, 67.23), vec4(23.684, 23.841, 0.50, 50.02), vec4(23.684, 23.841, 2.16, 62.17), vec4(23.842, 23.896, 1.32, 65.39), \n    vec4(23.842, 23.999, 2.16, 70.17), vec4(24.000, 24.157, 0.50, 36.17), vec4(24.008, 24.244, 1.32, 64.17), vec4(24.158, 24.314, 2.16, 55.25), vec4(24.316, 24.472, 2.16, 64.06), \n    vec4(24.316, 24.369, 1.32, 67.43), vec4(24.474, 24.946, 0.50, 40.09), vec4(24.474, 24.630, 2.16, 70.17), vec4(24.474, 24.531, 1.32, 64.34), vec4(24.632, 24.871, 1.32, 60.17), \n    vec4(24.789, 24.946, 2.16, 55.27), vec4(24.947, 25.104, 0.50, 43.12), vec4(24.947, 25.104, 2.16, 64.17), vec4(24.947, 25.182, 1.32, 64.12), vec4(25.105, 25.262, 2.16, 70.47), \n    vec4(25.105, 25.262, 2.16, 67.33), vec4(25.263, 26.392, 1.32, 65.09), vec4(25.421, 25.578, 2.16, 53.39), vec4(25.421, 25.578, 2.16, 60.49), vec4(25.421, 25.578, 0.50, 36.12), \n    vec4(25.437, 25.593, 2.16, 69.47), vec4(25.714, 25.870, 2.16, 53.27), vec4(25.730, 25.886, 2.16, 60.37), vec4(25.737, 25.893, 0.50, 36.12), vec4(25.737, 25.893, 2.16, 69.43), \n    vec4(25.887, 26.043, 2.16, 53.34), vec4(25.895, 26.051, 2.16, 69.33), vec4(25.895, 26.209, 0.50, 38.17), vec4(25.903, 26.059, 2.16, 60.26), vec4(26.172, 26.328, 2.16, 52.30), \n    vec4(26.210, 26.367, 0.50, 40.22), vec4(26.210, 26.367, 2.16, 60.34), vec4(26.234, 26.390, 2.16, 70.16), vec4(26.526, 26.743, 1.32, 60.33), vec4(26.526, 26.683, 0.50, 41.06), \n    vec4(26.684, 26.841, 2.16, 53.26), vec4(26.842, 26.999, 2.16, 60.20), vec4(26.842, 27.061, 1.32, 65.27), vec4(27.000, 27.157, 2.16, 69.17), vec4(27.000, 27.472, 0.50, 45.08), \n    vec4(27.158, 27.387, 1.32, 69.20), vec4(27.316, 27.472, 2.16, 53.22), vec4(27.474, 27.630, 0.50, 48.06), vec4(27.474, 27.630, 2.16, 60.17), vec4(27.474, 27.722, 1.32, 65.18), \n    vec4(27.632, 27.788, 2.16, 69.16), vec4(27.789, 27.946, 0.50, 43.09), vec4(27.789, 28.262, 1.32, 67.03), vec4(27.947, 28.104, 2.16, 55.23), vec4(28.105, 28.262, 2.16, 62.06), \n    vec4(28.263, 28.420, 2.16, 70.22), vec4(28.263, 28.578, 1.32, 70.06), vec4(28.263, 28.735, 0.50, 46.08), vec4(28.579, 28.642, 1.32, 69.22), vec4(28.579, 28.735, 2.16, 55.22), \n    vec4(28.737, 28.789, 1.32, 67.23), vec4(28.737, 28.893, 0.50, 50.02), vec4(28.737, 28.893, 2.16, 62.17), vec4(28.895, 28.949, 1.32, 65.39), vec4(28.895, 29.051, 2.16, 70.17), \n    vec4(29.053, 29.209, 0.50, 36.17), vec4(29.053, 29.313, 1.32, 64.37), vec4(29.210, 29.367, 2.16, 55.25), vec4(29.368, 29.429, 1.32, 67.33), vec4(29.368, 29.525, 2.16, 64.06), \n    vec4(29.526, 29.584, 1.32, 64.18), vec4(29.526, 29.683, 2.16, 70.17), vec4(29.526, 29.999, 0.50, 40.09), vec4(29.684, 29.926, 1.32, 60.23), vec4(29.842, 29.999, 2.16, 55.27), \n    vec4(30.000, 30.157, 0.50, 43.12), vec4(30.000, 30.157, 2.16, 64.17), vec4(30.000, 30.247, 1.32, 64.13), vec4(30.158, 30.314, 2.16, 70.47), vec4(30.158, 30.314, 2.16, 67.33), \n    vec4(30.316, 30.472, 0.50, 41.12), vec4(30.316, 30.788, 1.32, 65.02), vec4(30.474, 30.630, 2.16, 53.23), vec4(30.632, 30.788, 2.16, 60.06), vec4(30.789, 30.946, 0.50, 36.12), \n    vec4(30.789, 30.946, 2.16, 69.06), vec4(30.789, 31.578, 1.32, 69.13), vec4(30.947, 31.104, 0.50, 38.13), vec4(31.105, 31.262, 2.16, 53.25), vec4(31.263, 31.420, 0.50, 40.12), \n    vec4(31.263, 31.420, 2.16, 60.12), vec4(31.421, 31.578, 2.16, 69.16), vec4(31.579, 31.735, 0.50, 41.06), vec4(31.579, 31.806, 1.32, 60.25), vec4(31.737, 31.893, 2.16, 53.26), \n    vec4(31.895, 32.131, 1.32, 65.22), vec4(31.895, 32.051, 2.16, 60.20), vec4(32.053, 32.209, 2.16, 69.17), vec4(32.053, 32.525, 0.50, 45.08), vec4(32.210, 32.461, 1.32, 69.18), \n    vec4(32.368, 32.525, 2.16, 53.22), vec4(32.526, 32.683, 0.50, 48.06), vec4(32.526, 32.683, 2.16, 60.17), vec4(32.526, 32.777, 1.32, 65.17), vec4(32.684, 32.841, 2.16, 69.16), \n    vec4(32.842, 32.999, 0.50, 43.09), vec4(32.842, 33.314, 1.32, 67.03), vec4(33.000, 33.157, 2.16, 55.23), vec4(33.158, 33.314, 2.16, 62.06), vec4(33.316, 33.788, 0.50, 46.08), \n    vec4(33.316, 33.472, 2.16, 70.22), vec4(33.316, 33.630, 1.32, 70.06), vec4(33.632, 33.695, 1.32, 69.22), vec4(33.632, 33.788, 2.16, 55.22), vec4(33.789, 33.842, 1.32, 67.23), \n    vec4(33.789, 33.946, 0.50, 50.02), vec4(33.789, 33.946, 2.16, 62.17), vec4(33.947, 34.001, 1.32, 65.39), vec4(33.947, 34.104, 2.16, 70.17), vec4(34.105, 34.262, 0.50, 36.17), \n    vec4(34.105, 34.359, 1.32, 64.09), vec4(34.263, 34.420, 2.16, 55.25), vec4(34.421, 34.578, 2.16, 64.06), vec4(34.421, 34.486, 1.32, 67.30), vec4(34.579, 34.632, 1.32, 64.17), \n    vec4(34.579, 34.735, 2.16, 70.17), vec4(34.579, 35.051, 0.50, 40.09), vec4(34.737, 34.956, 1.32, 60.17), vec4(34.895, 35.051, 2.16, 55.27), vec4(35.053, 35.209, 0.50, 43.12), \n    vec4(35.053, 35.209, 2.16, 64.17), vec4(35.053, 35.278, 1.32, 64.12), vec4(35.210, 35.367, 2.16, 70.47), vec4(35.210, 35.367, 2.16, 67.33), vec4(35.368, 36.306, 1.32, 65.12), \n    vec4(35.526, 35.683, 2.16, 60.49), vec4(35.526, 35.683, 0.50, 41.09), vec4(35.526, 35.683, 2.16, 53.39), vec4(35.542, 35.699, 2.16, 69.47), vec4(35.819, 35.976, 2.16, 53.27), \n    vec4(35.835, 35.991, 2.16, 60.37), vec4(35.842, 35.999, 0.50, 41.20), vec4(35.842, 35.999, 2.16, 69.43), vec4(35.992, 36.149, 2.16, 53.34), vec4(36.000, 36.157, 0.50, 41.13), \n    vec4(36.000, 36.157, 2.16, 69.33), vec4(36.008, 36.164, 2.16, 60.26), vec4(36.632, 36.811, 1.32, 69.27), vec4(36.632, 36.788, 0.50, 41.13), vec4(36.632, 36.848, 3.70, 60.18), \n    vec4(36.789, 36.946, 2.16, 53.39), vec4(36.947, 37.003, 1.32, 69.34), vec4(36.947, 37.028, 3.70, 60.17), vec4(36.947, 37.104, 2.16, 60.17), vec4(37.105, 37.151, 1.32, 69.35), \n    vec4(37.105, 37.183, 3.70, 60.22), vec4(37.105, 37.262, 0.50, 36.17), vec4(37.105, 37.262, 2.16, 69.22), vec4(37.263, 37.405, 3.70, 60.22), vec4(37.263, 37.420, 0.50, 41.16), \n    vec4(37.263, 37.500, 1.32, 69.23), vec4(37.421, 37.578, 2.16, 53.35), vec4(37.579, 37.770, 3.70, 60.12), vec4(37.579, 37.767, 1.32, 69.25), vec4(37.579, 37.735, 2.16, 60.22), \n    vec4(37.579, 37.735, 0.50, 48.09), vec4(37.737, 37.893, 2.16, 69.17), vec4(37.895, 38.051, 0.50, 46.06), vec4(37.895, 38.239, 1.32, 70.17), vec4(37.895, 38.252, 3.70, 62.09), \n    vec4(38.053, 38.209, 2.16, 53.27), vec4(38.210, 38.367, 2.16, 62.17), vec4(38.368, 38.525, 2.16, 70.22), vec4(38.368, 38.683, 0.50, 46.12), vec4(38.368, 38.752, 3.70, 62.06), \n    vec4(38.368, 38.767, 1.32, 70.09), vec4(38.684, 38.841, 2.16, 53.32), vec4(38.684, 38.841, 0.50, 45.20), vec4(38.842, 38.902, 1.32, 70.33), vec4(38.842, 38.932, 3.70, 62.26), \n    vec4(38.842, 38.999, 0.50, 43.18), vec4(38.842, 38.999, 2.16, 62.30), vec4(39.000, 39.061, 1.32, 69.48), vec4(39.000, 39.073, 3.70, 60.17), vec4(39.000, 39.157, 0.50, 41.17), \n    vec4(39.000, 39.157, 2.16, 70.24), vec4(39.158, 39.314, 0.50, 36.16), vec4(39.158, 39.338, 3.70, 58.16), vec4(39.158, 39.407, 1.32, 67.23), vec4(39.316, 39.472, 2.16, 52.34), \n    vec4(39.474, 39.555, 3.70, 58.27), vec4(39.474, 39.577, 1.32, 67.27), vec4(39.474, 39.630, 2.16, 60.22), vec4(39.632, 39.700, 1.32, 67.27), vec4(39.632, 39.714, 3.70, 58.36), \n    vec4(39.632, 39.788, 0.50, 43.12), vec4(39.632, 39.788, 2.16, 67.23), vec4(39.789, 39.946, 0.50, 36.17), vec4(39.789, 40.001, 3.70, 58.27), vec4(39.789, 40.058, 1.32, 67.20), \n    vec4(39.947, 40.104, 2.16, 52.27), vec4(40.105, 40.262, 0.50, 43.20), vec4(40.105, 40.262, 2.16, 60.23), vec4(40.105, 40.194, 1.32, 67.36), vec4(40.105, 40.224, 3.70, 58.47), \n    vec4(40.263, 40.328, 1.32, 65.22), vec4(40.263, 40.347, 3.70, 57.26), vec4(40.263, 40.420, 2.16, 67.25), vec4(40.421, 40.578, 1.32, 64.22), vec4(40.421, 40.578, 0.50, 36.16), \n    vec4(40.421, 40.578, 3.70, 55.29), vec4(40.579, 40.735, 2.16, 52.32), vec4(40.579, 40.735, 3.70, 57.33), vec4(40.579, 40.893, 1.32, 65.18), vec4(40.737, 40.893, 2.16, 58.25), \n    vec4(40.895, 41.683, 1.32, 67.17), vec4(40.895, 41.051, 2.16, 64.17), vec4(40.895, 41.367, 0.50, 38.09), vec4(40.895, 41.498, 3.70, 58.39), vec4(41.210, 41.367, 2.16, 52.29), \n    vec4(41.368, 41.683, 0.50, 40.17), vec4(41.368, 41.525, 2.16, 58.36), vec4(41.526, 41.683, 2.16, 64.18), vec4(41.684, 41.841, 0.50, 41.13), vec4(41.684, 41.910, 1.32, 69.18), \n    vec4(41.684, 41.963, 3.70, 60.27), vec4(41.842, 41.999, 2.16, 53.39), vec4(42.000, 42.057, 1.32, 69.25), vec4(42.000, 42.075, 3.70, 60.25), vec4(42.000, 42.157, 2.16, 60.17), \n    vec4(42.158, 42.314, 2.16, 69.22), vec4(42.158, 42.314, 0.50, 36.17), vec4(42.158, 42.235, 3.70, 60.26), vec4(42.158, 42.214, 1.32, 69.25), vec4(42.316, 42.420, 3.70, 60.34), \n    vec4(42.316, 42.472, 0.50, 41.16), vec4(42.316, 42.574, 1.32, 69.16), vec4(42.474, 42.630, 2.16, 53.35), vec4(42.632, 42.781, 3.70, 60.22), vec4(42.632, 42.788, 0.50, 48.17), \n    vec4(42.632, 42.788, 2.16, 60.22), vec4(42.632, 42.869, 1.32, 69.20), vec4(42.789, 42.946, 2.16, 69.17), vec4(42.947, 43.420, 1.32, 70.12), vec4(42.947, 43.276, 3.70, 62.23), \n    vec4(42.947, 43.104, 0.50, 46.06), vec4(43.105, 43.262, 2.16, 53.27), vec4(43.263, 43.420, 2.16, 62.17), vec4(43.421, 43.578, 2.16, 70.22), vec4(43.421, 43.735, 0.50, 46.12), \n    vec4(43.421, 43.778, 3.70, 62.23), vec4(43.421, 43.893, 1.32, 70.08), vec4(43.737, 43.893, 0.50, 45.20), vec4(43.737, 43.893, 2.16, 53.32), vec4(43.895, 44.051, 2.16, 62.30), \n    vec4(43.895, 43.957, 1.32, 69.37), vec4(43.895, 44.030, 3.70, 60.22), vec4(43.895, 44.051, 0.50, 43.18), vec4(44.053, 44.209, 2.16, 70.24), vec4(44.053, 44.209, 0.50, 41.17), \n    vec4(44.053, 44.105, 1.32, 69.30), vec4(44.210, 44.344, 3.70, 58.27), vec4(44.210, 44.367, 0.50, 36.12), vec4(44.210, 44.433, 1.32, 67.22), vec4(44.368, 44.525, 2.16, 52.34), \n    vec4(44.526, 44.675, 3.70, 58.25), vec4(44.526, 44.683, 2.16, 60.22), vec4(44.526, 44.739, 1.32, 67.22), vec4(44.684, 44.841, 0.50, 43.12), vec4(44.684, 44.841, 2.16, 67.23), \n    vec4(44.842, 45.009, 3.70, 58.25), vec4(44.842, 45.061, 1.32, 65.17), vec4(44.842, 44.999, 0.50, 36.17), vec4(45.000, 45.157, 2.16, 52.27), vec4(45.158, 45.301, 3.70, 58.27), \n    vec4(45.158, 45.314, 0.50, 36.12), vec4(45.158, 45.314, 2.16, 60.23), vec4(45.158, 45.391, 1.32, 64.20), vec4(45.316, 45.472, 2.16, 67.25), vec4(45.474, 46.131, 1.32, 65.13), \n    vec4(45.474, 45.630, 0.50, 41.16), vec4(45.474, 46.363, 3.70, 57.16), vec4(45.632, 45.788, 2.16, 72.25), vec4(45.632, 46.104, 0.50, 36.17), vec4(45.789, 45.946, 2.16, 71.18), \n    vec4(45.947, 46.104, 2.16, 72.22), vec4(46.105, 46.262, 2.16, 74.17), vec4(46.105, 46.262, 0.50, 38.13), vec4(46.263, 46.420, 2.16, 72.16), vec4(46.421, 46.578, 0.50, 40.06), \n    vec4(46.421, 46.578, 2.16, 70.25), vec4(46.579, 46.735, 2.16, 67.09), vec4(46.737, 46.893, 0.50, 41.06), vec4(46.737, 46.893, 2.16, 57.40), vec4(46.737, 46.893, 2.16, 53.43), \n    vec4(46.737, 46.893, 2.16, 60.22), vec4(46.737, 46.893, 2.16, 65.20), vec4(46.737, 46.976, 3.70, 60.18), vec4(46.737, 47.999, 4.31, 53.43), vec4(46.737, 47.999, 4.31, 65.29), \n    vec4(46.737, 47.999, 4.31, 60.22), vec4(46.737, 47.999, 4.31, 57.29), vec4(47.053, 47.291, 3.70, 65.22), vec4(47.210, 47.683, 0.50, 45.08), vec4(47.368, 47.618, 3.70, 69.37), \n    vec4(47.684, 47.841, 0.50, 48.06), vec4(47.684, 47.932, 3.70, 65.18), vec4(48.000, 49.262, 4.31, 55.34), vec4(48.000, 48.157, 0.50, 43.09), vec4(48.000, 48.472, 3.70, 67.03), \n    vec4(48.000, 49.262, 4.31, 58.50), vec4(48.000, 49.262, 4.31, 65.34), vec4(48.000, 49.262, 4.31, 62.27), vec4(48.474, 48.788, 3.70, 70.06), vec4(48.474, 48.946, 0.50, 46.08), \n    vec4(48.789, 48.853, 3.70, 69.22), vec4(48.947, 49.104, 0.50, 50.02), vec4(48.947, 49.000, 3.70, 67.23), vec4(49.105, 49.159, 3.70, 65.39), vec4(49.263, 50.525, 4.31, 60.35), \n    vec4(49.263, 49.420, 0.50, 36.17), vec4(49.263, 49.515, 3.70, 64.13), vec4(49.263, 50.525, 4.31, 58.58), vec4(49.263, 50.525, 4.31, 64.34), vec4(49.263, 50.525, 4.31, 55.35), \n    vec4(49.579, 49.638, 3.70, 67.36), vec4(49.737, 50.209, 0.50, 40.09), vec4(49.737, 49.796, 3.70, 64.22), vec4(49.895, 50.082, 3.70, 60.22), vec4(50.210, 50.367, 0.50, 43.12), \n    vec4(50.210, 50.447, 3.70, 64.13), vec4(50.526, 51.788, 4.31, 57.51), vec4(50.526, 51.788, 4.31, 65.49), vec4(50.526, 51.788, 4.31, 53.43), vec4(50.526, 51.788, 4.31, 60.30), \n    vec4(50.526, 50.999, 3.70, 65.02), vec4(50.526, 50.683, 0.50, 41.12), vec4(51.000, 51.788, 3.70, 69.13), vec4(51.000, 51.157, 0.50, 36.12), vec4(51.158, 51.314, 0.50, 38.13), \n    vec4(51.474, 51.630, 0.50, 40.12), vec4(51.789, 53.051, 4.31, 53.43), vec4(51.789, 51.946, 0.50, 41.06), vec4(51.789, 52.018, 3.70, 60.25), vec4(51.789, 53.051, 4.31, 65.29), \n    vec4(51.789, 53.051, 4.31, 60.22), vec4(51.789, 53.051, 4.31, 57.29), vec4(52.105, 52.343, 3.70, 65.26), vec4(52.263, 52.735, 0.50, 45.08), vec4(52.421, 52.651, 3.70, 69.25), \n    vec4(52.737, 52.893, 0.50, 48.06), vec4(52.737, 52.985, 3.70, 65.16), vec4(53.053, 54.314, 4.31, 58.50), vec4(53.053, 54.314, 4.31, 65.34), vec4(53.053, 54.314, 4.31, 62.27), \n    vec4(53.053, 54.314, 4.31, 55.34), vec4(53.053, 53.525, 3.70, 67.03), vec4(53.053, 53.209, 0.50, 43.09), vec4(53.526, 53.999, 0.50, 46.08), vec4(53.526, 53.841, 3.70, 70.06), \n    vec4(53.842, 53.905, 3.70, 69.22), vec4(54.000, 54.053, 3.70, 67.23), vec4(54.000, 54.156, 0.50, 50.02), vec4(54.158, 54.212, 3.70, 65.39), vec4(54.316, 55.578, 4.31, 58.58), \n    vec4(54.316, 54.472, 0.50, 36.17), vec4(54.316, 55.578, 4.31, 55.35), vec4(54.316, 55.578, 4.31, 60.35), vec4(54.316, 54.552, 3.70, 64.17), vec4(54.316, 55.578, 4.31, 64.34), \n    vec4(54.631, 54.685, 3.70, 67.43), vec4(54.789, 54.847, 3.70, 64.34), vec4(54.789, 55.262, 0.50, 40.09), vec4(54.947, 55.187, 3.70, 60.17), vec4(55.263, 55.497, 3.70, 64.12), \n    vec4(55.263, 55.420, 0.50, 43.12), vec4(55.579, 56.708, 3.55, 65.09), vec4(55.579, 56.841, 4.31, 60.30), vec4(55.579, 56.841, 4.31, 53.43), vec4(55.579, 56.841, 4.31, 57.51), \n    vec4(55.579, 56.841, 4.31, 65.49), vec4(55.737, 55.893, 0.50, 36.12), vec4(56.053, 56.209, 0.50, 36.12), vec4(56.210, 56.525, 0.50, 38.17), vec4(56.526, 56.683, 0.50, 40.22), \n    vec4(56.842, 58.104, 4.31, 60.22), vec4(56.842, 58.104, 4.31, 65.29), vec4(56.842, 58.104, 4.31, 57.29), vec4(56.842, 58.104, 4.31, 53.43), vec4(56.842, 57.058, 3.55, 60.33), \n    vec4(56.842, 56.999, 0.50, 41.06), vec4(57.158, 57.377, 3.55, 65.27), vec4(57.316, 57.788, 0.50, 45.08), vec4(57.474, 57.703, 3.55, 69.20), vec4(57.789, 57.946, 0.50, 48.06), \n    vec4(57.789, 58.037, 3.55, 65.18), vec4(58.105, 58.262, 0.50, 43.09), vec4(58.105, 58.578, 3.55, 67.03), vec4(58.105, 59.367, 4.31, 58.50), vec4(58.105, 59.367, 4.31, 65.34), \n    vec4(58.105, 59.367, 4.31, 55.34), vec4(58.105, 59.367, 4.31, 62.27), vec4(58.579, 58.893, 3.55, 70.06), vec4(58.579, 59.051, 0.50, 46.08), vec4(58.895, 58.958, 3.55, 69.22), \n    vec4(59.053, 59.209, 0.50, 50.02), vec4(59.053, 59.105, 3.55, 67.23), vec4(59.210, 59.264, 3.55, 65.39), vec4(59.368, 60.630, 4.31, 64.34), vec4(59.368, 60.630, 4.31, 58.58), \n    vec4(59.368, 60.630, 4.31, 55.35), vec4(59.368, 60.630, 4.31, 60.35), vec4(59.368, 59.629, 3.55, 64.37), vec4(59.368, 59.525, 0.50, 36.17), vec4(59.684, 59.745, 3.55, 67.33), \n    vec4(59.842, 60.314, 0.50, 40.09), vec4(59.842, 59.900, 3.55, 64.18), vec4(60.000, 60.241, 3.55, 60.23), vec4(60.316, 60.472, 0.50, 43.12), vec4(60.316, 60.563, 3.55, 64.13), \n    vec4(60.631, 60.788, 0.50, 41.12), vec4(60.631, 61.104, 3.55, 65.02), vec4(60.631, 61.893, 4.31, 65.49), vec4(60.631, 61.893, 4.31, 57.51), vec4(60.631, 61.893, 4.31, 53.43), \n    vec4(60.631, 61.893, 4.31, 60.30), vec4(61.105, 61.262, 0.50, 36.12), vec4(61.105, 61.893, 3.55, 69.13), vec4(61.263, 61.420, 0.50, 38.13), vec4(61.579, 61.735, 0.50, 40.12), \n    vec4(61.895, 63.156, 4.31, 60.22), vec4(61.895, 63.156, 4.31, 53.43), vec4(61.895, 63.156, 4.31, 65.29), vec4(61.895, 63.156, 4.31, 57.29), vec4(61.895, 62.051, 0.50, 41.06), \n    vec4(61.895, 62.122, 3.55, 60.25), vec4(62.210, 62.447, 3.55, 65.22), vec4(62.368, 62.841, 0.50, 45.08), vec4(62.526, 62.777, 3.55, 69.18), vec4(62.842, 62.999, 0.50, 48.06), \n    vec4(62.842, 63.093, 3.55, 65.17), vec4(63.158, 64.420, 4.31, 55.34), vec4(63.158, 63.314, 0.50, 43.09), vec4(63.158, 63.630, 3.55, 67.03), vec4(63.158, 64.420, 4.31, 58.50), \n    vec4(63.158, 64.420, 4.31, 65.34), vec4(63.158, 64.420, 4.31, 62.27), vec4(63.631, 63.946, 3.55, 70.06), vec4(63.631, 64.104, 0.50, 46.08), vec4(63.947, 64.010, 3.55, 69.22), \n    vec4(64.105, 64.158, 3.55, 67.23), vec4(64.105, 64.262, 0.50, 50.02), vec4(64.263, 64.317, 3.55, 65.39), vec4(64.421, 64.578, 0.50, 36.17), vec4(64.421, 65.683, 4.31, 58.58), \n    vec4(64.421, 65.683, 4.31, 64.34), vec4(64.421, 65.683, 4.31, 55.35), vec4(64.421, 65.683, 4.31, 60.35), vec4(64.421, 64.675, 3.55, 64.09), vec4(64.737, 64.802, 3.55, 67.30), \n    vec4(64.895, 65.367, 0.50, 40.09), vec4(64.895, 64.948, 3.55, 64.17), vec4(65.053, 65.272, 3.55, 60.17), vec4(65.368, 65.525, 0.50, 43.12), vec4(65.368, 65.593, 3.55, 64.12), \n    vec4(65.684, 66.946, 4.31, 65.49), vec4(65.684, 66.946, 4.31, 57.51), vec4(65.684, 66.946, 4.31, 53.43), vec4(65.684, 66.622, 3.55, 65.12), vec4(65.684, 66.946, 4.31, 60.30), \n    vec4(65.842, 65.999, 0.50, 41.09), vec4(66.158, 66.314, 0.50, 41.20), vec4(66.316, 66.472, 0.50, 41.13), vec4(66.947, 67.104, 5.50, 41.22), vec4(66.947, 67.127, 3.55, 69.27), \n    vec4(66.947, 67.164, 3.55, 60.18), vec4(67.105, 67.262, 5.50, 41.20), vec4(67.263, 67.344, 3.55, 60.17), vec4(67.263, 67.318, 3.55, 69.34), vec4(67.421, 67.467, 3.55, 69.35), \n    vec4(67.421, 67.499, 3.55, 60.22), vec4(67.421, 67.578, 5.50, 36.22), vec4(67.579, 67.720, 3.55, 60.22), vec4(67.579, 67.735, 5.50, 41.22), vec4(67.579, 67.816, 3.55, 69.23), \n    vec4(67.737, 67.893, 5.50, 41.22), vec4(67.895, 68.083, 3.55, 69.25), vec4(67.895, 68.086, 3.55, 60.12), vec4(68.053, 68.209, 5.50, 33.09), vec4(68.210, 68.568, 3.55, 62.09), \n    vec4(68.210, 68.555, 3.55, 70.17), vec4(68.210, 68.367, 5.50, 34.22), vec4(68.368, 68.525, 5.50, 34.16), vec4(68.684, 68.841, 5.50, 41.13), vec4(68.684, 69.068, 3.55, 62.06), \n    vec4(68.684, 69.083, 3.55, 70.09), vec4(68.842, 68.999, 5.50, 34.27), vec4(69.000, 69.156, 5.50, 46.08), vec4(69.158, 69.218, 3.55, 70.33), vec4(69.158, 69.247, 3.55, 62.26), \n    vec4(69.158, 69.314, 5.50, 34.19), vec4(69.316, 69.472, 5.50, 35.13), vec4(69.316, 69.377, 3.55, 69.48), vec4(69.316, 69.389, 3.55, 60.17), vec4(69.474, 69.723, 3.55, 67.23), \n    vec4(69.474, 69.654, 3.55, 58.16), vec4(69.474, 69.630, 5.50, 36.25), vec4(69.631, 69.788, 5.50, 36.17), vec4(69.789, 69.870, 3.55, 58.27), vec4(69.789, 69.893, 3.55, 67.27), \n    vec4(69.947, 70.016, 3.55, 67.27), vec4(69.947, 70.030, 3.55, 58.36), vec4(69.947, 70.104, 5.50, 43.16), vec4(70.105, 70.262, 5.50, 36.18), vec4(70.105, 70.316, 3.55, 58.27), \n    vec4(70.105, 70.374, 3.55, 67.20), vec4(70.263, 70.420, 5.50, 36.09), vec4(70.421, 70.539, 3.55, 58.47), vec4(70.421, 70.510, 3.55, 67.36), vec4(70.579, 70.643, 3.55, 65.22), \n    vec4(70.579, 70.663, 3.55, 57.26), vec4(70.579, 70.735, 5.50, 43.09), vec4(70.737, 70.893, 3.55, 55.29), vec4(70.737, 70.893, 3.55, 64.22), vec4(70.737, 70.893, 5.50, 36.03), \n    vec4(70.895, 71.051, 3.55, 57.33), vec4(70.895, 71.051, 5.50, 48.12), vec4(70.895, 71.209, 3.55, 65.18), vec4(71.053, 71.209, 5.50, 34.13), vec4(71.210, 71.999, 3.55, 67.17), \n    vec4(71.210, 71.814, 3.55, 58.39), vec4(71.210, 71.367, 5.50, 46.16), vec4(71.368, 71.525, 5.50, 33.06), vec4(71.526, 71.683, 5.50, 45.09), vec4(71.684, 71.841, 5.50, 31.09), \n    vec4(71.842, 71.999, 5.50, 43.08), vec4(72.000, 72.156, 5.50, 29.22), vec4(72.000, 72.226, 3.55, 69.18), vec4(72.000, 72.279, 3.55, 60.27), vec4(72.158, 72.314, 5.50, 41.20), \n    vec4(72.316, 72.373, 3.55, 69.25), vec4(72.316, 72.391, 3.55, 60.25), vec4(72.474, 72.529, 3.55, 69.25), vec4(72.474, 72.551, 3.55, 60.26), vec4(72.474, 72.630, 5.50, 36.22), \n    vec4(72.631, 72.889, 3.55, 69.16), vec4(72.631, 72.736, 3.55, 60.34), vec4(72.631, 72.788, 5.50, 41.22), vec4(72.789, 72.946, 5.50, 41.22), vec4(72.947, 73.097, 3.55, 60.22), \n    vec4(72.947, 73.185, 3.55, 69.20), vec4(73.105, 73.262, 5.50, 33.09), vec4(73.263, 73.420, 5.50, 34.22), vec4(73.263, 73.592, 3.55, 62.23), vec4(73.263, 73.735, 3.55, 70.12), \n    vec4(73.421, 73.578, 5.50, 34.16), vec4(73.737, 74.093, 3.55, 62.23), vec4(73.737, 73.893, 5.50, 41.13), vec4(73.737, 74.209, 3.55, 70.08), vec4(73.895, 74.051, 5.50, 34.27), \n    vec4(74.053, 74.209, 5.50, 46.08), vec4(74.210, 74.272, 3.55, 69.37), vec4(74.210, 74.346, 3.55, 60.22), vec4(74.210, 74.367, 5.50, 34.19), vec4(74.368, 74.421, 3.55, 69.30), \n    vec4(74.368, 74.525, 5.50, 35.13), vec4(74.526, 74.660, 3.55, 58.27), vec4(74.526, 74.683, 5.50, 36.12), vec4(74.526, 74.749, 3.55, 67.22), vec4(74.684, 74.841, 5.50, 36.12), \n    vec4(74.842, 74.991, 3.55, 58.25), vec4(74.842, 75.054, 3.55, 67.22), vec4(75.000, 75.156, 5.50, 48.16), vec4(75.158, 75.377, 3.55, 65.17), vec4(75.158, 75.314, 5.50, 36.13), \n    vec4(75.158, 75.325, 3.55, 58.25), vec4(75.316, 75.472, 5.50, 36.17), vec4(75.474, 75.617, 3.55, 58.27), vec4(75.474, 75.630, 5.50, 38.17), vec4(75.474, 75.707, 3.55, 64.20), \n    vec4(75.631, 75.788, 5.50, 40.13), vec4(75.789, 75.946, 5.50, 41.17), vec4(75.789, 76.447, 3.55, 65.13), vec4(75.789, 76.679, 3.55, 57.16), vec4(75.947, 76.104, 5.50, 41.06), \n    vec4(76.263, 76.420, 5.50, 36.26), vec4(76.421, 76.578, 5.50, 41.06), vec4(76.579, 76.735, 5.50, 41.12), vec4(76.895, 77.051, 5.50, 36.06), vec4(77.053, 77.209, 5.50, 41.22), \n    vec4(77.053, 77.232, 3.55, 69.27), vec4(77.053, 77.269, 3.55, 60.18), vec4(77.210, 77.367, 5.50, 41.20), vec4(77.368, 77.424, 3.55, 69.34), vec4(77.368, 77.449, 3.55, 60.17), \n    vec4(77.526, 77.572, 3.55, 69.35), vec4(77.526, 77.604, 3.55, 60.22), vec4(77.526, 77.683, 5.50, 36.22), vec4(77.684, 77.826, 3.55, 60.22), vec4(77.684, 77.841, 5.50, 41.22), \n    vec4(77.684, 77.921, 3.55, 69.23), vec4(77.842, 77.999, 5.50, 41.22), vec4(78.000, 78.188, 3.55, 69.25), vec4(78.000, 78.191, 3.55, 60.12), vec4(78.158, 78.314, 5.50, 33.09), \n    vec4(78.316, 78.472, 5.50, 34.22), vec4(78.316, 78.660, 3.55, 70.17), vec4(78.316, 78.673, 3.55, 62.09), vec4(78.474, 78.630, 5.50, 34.16), vec4(78.789, 78.946, 5.50, 41.13), \n    vec4(78.789, 79.173, 3.55, 62.06), vec4(78.789, 79.188, 3.55, 70.09), vec4(78.947, 79.104, 5.50, 34.27), vec4(79.105, 79.262, 5.50, 46.08), vec4(79.263, 79.420, 5.50, 34.19), \n    vec4(79.263, 79.323, 3.55, 70.33), vec4(79.263, 79.353, 3.55, 62.26), vec4(79.421, 79.482, 3.55, 69.48), vec4(79.421, 79.494, 3.55, 60.17), vec4(79.421, 79.578, 5.50, 35.13), \n    vec4(79.579, 79.735, 5.50, 36.25), vec4(79.579, 79.759, 3.55, 58.16), vec4(79.579, 79.828, 3.55, 67.23), vec4(79.737, 79.893, 5.50, 36.17), vec4(79.895, 79.976, 3.55, 58.27), \n    vec4(79.895, 79.998, 3.55, 67.27), vec4(80.053, 80.135, 3.55, 58.36), vec4(80.053, 80.209, 5.50, 43.16), vec4(80.053, 80.121, 3.55, 67.27), vec4(80.210, 80.367, 5.50, 36.18), \n    vec4(80.210, 80.422, 3.55, 58.27), vec4(80.210, 80.479, 3.55, 67.20), vec4(80.368, 80.525, 5.50, 36.09), vec4(80.526, 80.615, 3.55, 67.36), vec4(80.526, 80.645, 3.55, 58.47), \n    vec4(80.684, 80.749, 3.55, 65.22), vec4(80.684, 80.768, 3.55, 57.26), vec4(80.684, 80.841, 5.50, 43.09), vec4(80.842, 80.999, 5.50, 36.03), vec4(80.842, 80.999, 3.55, 55.29), \n    vec4(80.842, 80.999, 3.55, 64.22), vec4(81.000, 81.314, 3.55, 65.18), vec4(81.000, 81.156, 3.55, 57.33), vec4(81.000, 81.156, 5.50, 48.12), vec4(81.158, 81.314, 5.50, 34.13), \n    vec4(81.316, 81.472, 5.50, 46.16), vec4(81.316, 81.919, 3.55, 58.39), vec4(81.316, 82.104, 3.55, 67.17), vec4(81.474, 81.630, 5.50, 33.06), vec4(81.631, 81.788, 5.50, 45.09), \n    vec4(81.789, 81.946, 5.50, 31.09), vec4(81.947, 82.104, 5.50, 43.08), vec4(82.105, 82.384, 3.55, 60.27), vec4(82.105, 82.331, 3.55, 69.18), vec4(82.105, 82.262, 5.50, 29.22), \n    vec4(82.263, 82.420, 5.50, 41.20), vec4(82.421, 82.478, 3.55, 69.25), vec4(82.421, 82.496, 3.55, 60.25), vec4(82.579, 82.635, 3.55, 69.25), vec4(82.579, 82.656, 3.55, 60.26), \n    vec4(82.579, 82.735, 5.50, 36.22), vec4(82.737, 82.841, 3.55, 60.34), vec4(82.737, 82.893, 5.50, 41.22), vec4(82.737, 82.995, 3.55, 69.16), vec4(82.895, 83.051, 5.50, 41.22), \n    vec4(83.053, 83.202, 3.55, 60.22), vec4(83.053, 83.290, 3.55, 69.20), vec4(83.210, 83.367, 5.50, 33.09), vec4(83.368, 83.525, 5.50, 34.22), vec4(83.368, 83.841, 3.55, 70.12), \n    vec4(83.368, 83.697, 3.55, 62.23), vec4(83.526, 83.683, 5.50, 34.16), vec4(83.842, 83.999, 5.50, 41.13), vec4(83.842, 84.199, 3.55, 62.23), vec4(83.842, 84.314, 3.55, 70.08), \n    vec4(84.000, 84.156, 5.50, 34.27), vec4(84.158, 84.314, 5.50, 46.08), vec4(84.316, 84.378, 3.55, 69.37), vec4(84.316, 84.451, 3.55, 60.22), vec4(84.316, 84.472, 5.50, 34.19), \n    vec4(84.474, 84.526, 3.55, 69.30), vec4(84.474, 84.630, 5.50, 35.13), vec4(84.631, 84.854, 3.55, 67.22), vec4(84.631, 84.765, 3.55, 58.27), vec4(84.631, 84.788, 5.50, 36.12), \n    vec4(84.789, 84.946, 5.50, 36.12), vec4(84.947, 85.096, 3.55, 58.25), vec4(84.947, 85.160, 3.55, 67.22), vec4(85.105, 85.262, 5.50, 48.16), vec4(85.263, 85.420, 5.50, 36.13), \n    vec4(85.263, 85.430, 3.55, 58.25), vec4(85.263, 85.482, 3.55, 65.17), vec4(85.421, 85.578, 5.50, 36.17), vec4(85.579, 85.735, 5.50, 38.17), vec4(85.579, 85.812, 3.55, 64.20), \n    vec4(85.579, 85.722, 3.55, 58.27), vec4(85.737, 85.893, 5.50, 40.13), vec4(85.895, 86.051, 5.50, 41.17), vec4(85.895, 86.552, 3.55, 65.13), vec4(85.895, 86.784, 3.55, 57.16), \n    vec4(86.053, 86.209, 5.50, 41.06), vec4(86.368, 86.525, 5.50, 36.26), vec4(86.526, 86.683, 5.50, 41.06), vec4(86.684, 86.841, 5.50, 41.12), vec4(87.000, 87.156, 5.50, 33.06), \n    vec4(87.158, 87.472, 5.50, 36.12), vec4(87.316, 87.472, 3.55, 60.20), vec4(87.316, 87.472, 3.55, 64.13), vec4(87.474, 87.630, 3.55, 63.19), vec4(87.474, 87.630, 3.55, 59.09), \n    vec4(87.631, 87.788, 3.55, 64.22), vec4(87.631, 87.788, 3.55, 60.23), vec4(87.789, 87.946, 3.55, 65.12), vec4(87.789, 87.946, 3.55, 61.17), vec4(87.947, 88.104, 3.55, 66.17), \n    vec4(87.947, 88.104, 3.55, 62.13), vec4(88.105, 88.262, 3.55, 67.12), vec4(88.105, 88.262, 3.55, 63.09), vec4(88.263, 88.420, 3.55, 68.12), vec4(88.263, 88.420, 3.55, 64.12), \n    vec4(88.421, 90.947, 3.55, 65.16), vec4(88.421, 90.947, 3.55, 69.13), vec4(90.631, 90.788, 0.50, 29.06), vec4(90.631, 90.946, 5.50, 29.06) );\n\n// First usable noteEvent index for every second\nconst ivec2 timeEventRanges[93] = ivec2[](\n    ivec2(0, 0), ivec2(0, 0), ivec2(0, 0), ivec2(0, 1), ivec2(0, 5), ivec2(0, 10), ivec2(0, 17), ivec2(4, 21), ivec2(9, 30), ivec2(15, 38), ivec2(21, 43), ivec2(29, 51), ivec2(37, 55), ivec2(41, 64), ivec2(49, 70), ivec2(55, 74), ivec2(62, 82), ivec2(68, 92), ivec2(74, 104), ivec2(80, 115), ivec2(89, 126), ivec2(102, 136), ivec2(112, 145), ivec2(121, 157), ivec2(133, 169), ivec2(143, 184), ivec2(156, 195), ivec2(166, 204), ivec2(171, 215), ivec2(192, 228), \n    ivec2(202, 238), ivec2(214, 247), ivec2(225, 258), ivec2(236, 269), ivec2(245, 279), ivec2(256, 296), ivec2(267, 304), ivec2(276, 320), ivec2(284, 336), ivec2(301, 351), ivec2(317, 369), ivec2(332, 380), ivec2(348, 396), ivec2(365, 408), ivec2(377, 424), ivec2(393, 436), ivec2(404, 452), ivec2(420, 463), ivec2(429, 468), ivec2(448, 479), ivec2(457, 489), ivec2(457, 497), ivec2(469, 502), ivec2(481, 513), ivec2(491, 524), ivec2(491, 532), ivec2(502, 541), ivec2(514, 546), ivec2(526, 555), ivec2(535, 568), \n    ivec2(535, 576), ivec2(548, 586), ivec2(558, 591), ivec2(571, 600), ivec2(580, 612), ivec2(580, 621), ivec2(591, 626), ivec2(604, 638), ivec2(615, 648), ivec2(623, 663), ivec2(636, 678), ivec2(644, 689), ivec2(660, 701), ivec2(675, 710), ivec2(686, 723), ivec2(699, 735), ivec2(706, 739), ivec2(721, 754), ivec2(732, 763), ivec2(738, 776), ivec2(752, 794), ivec2(760, 802), ivec2(776, 815), ivec2(791, 826), ivec2(797, 838), ivec2(814, 850), ivec2(823, 855), ivec2(836, 866), ivec2(847, 872), ivec2(854, 872), \n    ivec2(864, 874), ivec2(870, 874), ivec2(870, 874) );\n\nconst int songLengthSeconds = 92;\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGXDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 435, 477, 477, 613], [615, 712, 769, 769, 1622]], "test": "untested"}
{"id": "ftySWm", "name": "MIDI Synth", "author": "PiN", "description": "Generating music with GLSL using preprocessed MIDI events.", "tags": ["sound", "music", "synth", "synthesizer", "midi"], "likes": 4, "viewed": 453, "published": 3, "date": "1640795862", "time_retrieved": "2024-07-30T18:39:28.000255", "image_code": "//----------------------------------------------------------------------------------------------\nconst vec3 programColors[8] = vec3[](\n    vec3(1.0, 0.0, 0.0),\n    vec3(0.0, 1.0, 0.0),\n    vec3(0.0, 0.0, 1.0),\n    vec3(0.0, 1.0, 1.0),\n    vec3(1.0, 0.0, 1.0),\n    vec3(1.0, 1.0, 0.0),\n    vec3(1.0, 1.0, 1.0),\n    vec3(0.5, 0.5, 0.5)\n);\n\n//----------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0, 0, 0, 1);\n\n    float y = (fragCoord.y / iResolution.y);\n    float time = mod(iTime, float(songLengthSeconds));\n    \n    float noteDist = 0.5 + 0.5 * sin(y * 3.14159265358);\n    float fragNote = floor((fragCoord.x / iResolution.x) * 127.0 * noteDist + 63.5 * (1.0 - noteDist));\n    float fragTime = (y - 0.5) * 4.0 + time;\n\n    ivec2 eventRange = timeEventRanges[int(fragTime) % songLengthSeconds];\n    for (int i = eventRange.x; i < eventRange.y; ++i)\n    {\n        vec4 e = noteEvents[i];\n       \n        if (fragTime >= e.x && fragTime < e.y)\n        {\n            if (floor(e.w) == fragNote && fragTime >= e.x && fragTime < e.y - 0.025)\n            {\n                fragColor.xyz = programColors[int(e.z) % 8] * (1.0 - abs(y - 0.5) / 0.5);\n                \n                if (time < e.x)\n                    fragColor.xyz *= 0.25;\n                else if (time >= e.y)\n                    fragColor.xyz *= max(1.0 - (time - e.y) * 4.0, 0.25);\n            }\n        }\n    }\n    \n    if (abs(y - 0.5) < 0.002)\n        fragColor.xyz = vec3(0.25, 0.25, 0.25);\n}\n", "image_inputs": [], "sound_code": "//----------------------------------------------------------------------------------------------\nfloat GetNoteFrequency(float note)\n{\n\treturn 440.0 * pow(2.0, (note - 69.0) / 12.0);\n}\n\n//----------------------------------------------------------------------------------------------\nfloat CalculateADSRVolume(in float time, in vec4 adsr, in float noteDuration)\n{\n    float result = 1.0;\n    \n    float t = min(time, noteDuration);\n    \n    if (t < adsr.x)\n        result = t / adsr.x;\n    else if (t < adsr.x + adsr.y)\n        result = adsr.z + (1.0 - adsr.z) * (1.0 - (t - adsr.x) / adsr.y);\n    else\n        result = adsr.z;\n        \n    if (time > noteDuration)\n    {\n        if (adsr.w > 0.0)\n            result *= max(1.0 - ((time - noteDuration) / adsr.w), 0.0);\n        else\n            result = 0.0;\n    }\n    \n    return result;\n}\n\n//----------------------------------------------------------------------------------------------\nvec2 RenderNoteEvent(in float time, vec4 e)\n{\n    Instrument instr = instruments[int(e.z)];\n\n    float vibrato = instr.fx.x * sin(e.w + time * 4.0 * 6.28);\n    float freq = GetNoteFrequency(floor(e.w) + vibrato);\n    float s = 0.0;\n    \n    for (int i = 0; i < 4; ++i)\n    {\n        float oscilatorVolume = fract(instr.oscilators[i]);\n        if (oscilatorVolume > 0.0)\n        {\n            int oscilatorType = int(instr.oscilators[i]);\n            float oscilatorOctave = instr.octaves[i];\n            \n            if (oscilatorType == 0)\n                s += oscilatorVolume * sin(oscilatorOctave * 6.2831 * time * freq);\n            else if (oscilatorType == 1)\n                s += oscilatorVolume * (2.0 * fract(oscilatorOctave * time * freq) - 1.0);\n            else if (oscilatorType == 2)\n                s += oscilatorVolume * sign(sin(oscilatorOctave * 6.2831 * time * freq));\n        }\n    }\n    \n    float volume = CalculateADSRVolume(time, instr.adsr, e.y - e.x);\n    s *= volume * (1.0 - fract(e.w));\n\n    float pan = fract(e.z);\n    return vec2(s * sqrt(pan), s * sqrt(1.0 - pan));\n}\n\n//----------------------------------------------------------------------------------------------\nvec2 mainSound( int samp, float time )\n{\n    vec2 stereoSample = vec2(0, 0);\n\n    time = mod(time, float(songLengthSeconds));\n    ivec2 eventRange = timeEventRanges[int(time)];\n\n    for (int i = eventRange.x; i < eventRange.y; ++i)\n    {\n        vec4 e = noteEvents[i];\n        if (time < e.x || time >= e.y + 1.0)\n            continue;\n       \n        stereoSample += RenderNoteEvent(time - e.x, e);\n    }\n    \n    return stereoSample;\n}\n", "sound_inputs": [], "common_code": "struct Instrument { vec4 oscilators, octaves, adsr, fx; };\n\nconst Instrument instruments[8] = Instrument[](\n    // 0: \"Electric Bass (finger)\" (program 33)\n    Instrument( vec4(0.99, 0.5, 0, 0), vec4(1, 2, 1, 1), vec4(0.002, 0.001, 0.75, 0.1), vec4(0, 0, 0, 0) ),\n\n    // 1: \"Orchestral Harp\" (program 46)\n    Instrument( vec4(1.25, 1.0625, 0, 0), vec4(1, 2.00001, 1.001, 1), vec4(0.001, 0.01, 0.75, 0.5), vec4(0, 0, 0, 0) ),\n\n    // 2: \"Alto Sax\" (program 65)\n    Instrument( vec4(0.5, 1.25, 2.25, 0), vec4(1, 1, 1.001, 1), vec4(0.001, 0.01, 0.5, 0.05), vec4(0.02, 0, 0, 0) ),\n\n    // 3: \"Acoustic Guitar (steel)\" (program 25)\n    Instrument( vec4(0.99, 0.5, 1.5, 0), vec4(2, 1.001, 1, 1), vec4(0.001, 0.001, 0.1, 0.2), vec4(0, 0, 0, 0) ),\n\n    // 4: \"Choir Aahs\" (program 52)\n    Instrument( vec4(0.125, 1.0625, 0, 0), vec4(1, 2.00001, 1.001, 1), vec4(0.5, 0.5, 0.75, 0.5), vec4(0, 0, 0, 0) ),\n\n    // 5: \"String Ensemble 1\" (program 48)\n    Instrument( vec4(0.125, 1.0625, 0, 0), vec4(1, 2.00001, 1.001, 1), vec4(0.5, 0.5, 0.75, 0.5), vec4(0, 0, 0, 0) ),\n\n    // 6: \"Overdriven Guitar\" (program 29)\n    Instrument( vec4(0.99, 0.5, 1.5, 0), vec4(2, 1.001, 1, 1), vec4(0.001, 0.001, 0.1, 0.2), vec4(0, 0, 0, 0) ),\n\n    // 7: \"SynthStrings 1\" (program 50)\n    Instrument( vec4(0.125, 1.0625, 0, 0), vec4(1, 2.00001, 1.001, 1), vec4(0.5, 0.5, 0.75, 0.5), vec4(0, 0, 0, 0) )\n);\n\n// Tuples of: [time begin, time end, program + panning, note + invVelocity]...\nconst vec4 noteEvents[3806] = vec4[](\n    vec4(3.588, 3.671, 1.50, 100.36), vec4(3.650, 3.746, 1.50, 97.52), vec4(3.734, 3.828, 1.50, 95.50), vec4(3.806, 3.884, 1.50, 93.50), vec4(3.865, 3.944, 1.50, 92.51), \n    vec4(3.934, 4.015, 1.50, 88.46), vec4(3.996, 4.078, 1.50, 85.46), vec4(4.063, 4.140, 1.50, 83.46), vec4(4.121, 4.190, 1.50, 81.54), vec4(4.178, 4.246, 1.50, 80.49), \n    vec4(4.238, 4.321, 1.50, 76.50), vec4(4.303, 4.388, 1.50, 73.53), vec4(4.381, 4.471, 1.50, 71.48), vec4(4.453, 4.534, 1.50, 69.54), vec4(4.515, 4.603, 1.50, 68.48), \n    vec4(4.596, 4.709, 1.50, 64.48), vec4(4.713, 4.790, 1.50, 61.58), vec4(4.806, 4.909, 1.50, 59.50), vec4(4.806, 4.990, 3.82, 59.31), vec4(4.806, 4.946, 3.82, 68.36), \n    vec4(4.806, 4.931, 3.82, 64.35), vec4(4.806, 4.950, 3.19, 56.31), vec4(4.806, 4.969, 3.19, 59.35), vec4(4.806, 4.981, 3.19, 64.39), vec4(4.806, 4.959, 0.50, 28.09), \n    vec4(5.256, 5.328, 3.19, 56.33), vec4(5.256, 5.350, 3.19, 64.38), vec4(5.256, 5.346, 3.19, 59.34), vec4(5.256, 5.356, 0.50, 28.10), vec4(5.256, 5.325, 3.82, 68.36), \n    vec4(5.256, 5.350, 3.82, 59.31), vec4(5.256, 5.338, 3.82, 64.36), vec4(5.406, 5.534, 3.82, 68.35), vec4(5.406, 5.521, 3.82, 64.35), vec4(5.406, 5.540, 3.19, 59.34), \n    vec4(5.406, 5.540, 0.50, 28.10), vec4(5.406, 5.525, 3.19, 64.41), vec4(5.406, 5.553, 3.82, 59.33), vec4(5.406, 5.540, 3.19, 56.33), vec4(6.006, 6.113, 3.82, 64.35), \n    vec4(6.006, 6.153, 3.82, 68.34), vec4(6.006, 6.159, 3.19, 64.38), vec4(6.006, 6.138, 0.50, 28.13), vec4(6.006, 6.169, 3.82, 59.31), vec4(6.006, 6.140, 3.19, 59.33), \n    vec4(6.006, 6.156, 3.19, 56.35), vec4(6.456, 6.546, 0.50, 28.10), vec4(6.456, 6.546, 3.82, 68.35), vec4(6.456, 6.544, 3.82, 59.32), vec4(6.456, 6.525, 3.19, 56.33), \n    vec4(6.456, 6.540, 3.82, 64.28), vec4(6.456, 6.544, 3.19, 59.35), vec4(6.456, 6.531, 3.19, 64.32), vec4(6.606, 6.713, 3.19, 64.32), vec4(6.606, 6.725, 3.19, 56.35), \n    vec4(6.606, 6.734, 3.19, 59.35), vec4(6.606, 6.740, 3.82, 64.31), vec4(6.606, 6.753, 3.82, 59.34), vec4(6.606, 6.759, 3.82, 68.36), vec4(6.606, 6.744, 0.50, 28.13), \n    vec4(7.206, 7.331, 3.19, 56.35), vec4(7.206, 7.334, 3.19, 64.33), vec4(7.206, 7.344, 3.19, 59.37), vec4(7.206, 7.303, 3.82, 64.29), vec4(7.206, 7.350, 3.82, 68.32), \n    vec4(7.206, 7.359, 0.50, 28.06), vec4(7.206, 7.381, 3.82, 59.33), vec4(7.656, 7.740, 3.82, 64.30), vec4(7.656, 7.734, 3.19, 59.37), vec4(7.656, 7.731, 3.19, 64.36), \n    vec4(7.656, 7.746, 3.82, 59.34), vec4(7.656, 7.728, 3.19, 56.35), vec4(7.656, 7.731, 3.82, 68.35), vec4(7.656, 7.753, 0.50, 28.13), vec4(7.806, 7.946, 0.50, 28.13), \n    vec4(7.806, 7.925, 3.82, 68.36), vec4(7.806, 7.903, 3.82, 64.32), vec4(7.806, 7.934, 3.19, 56.36), vec4(7.806, 7.934, 3.19, 64.35), vec4(7.806, 7.915, 3.19, 59.31), \n    vec4(7.806, 7.934, 3.82, 59.28), vec4(8.388, 8.471, 1.50, 100.33), vec4(8.406, 8.546, 0.50, 28.02), vec4(8.406, 8.525, 3.82, 64.31), vec4(8.406, 8.546, 3.82, 68.36), \n    vec4(8.406, 8.553, 3.19, 64.32), vec4(8.406, 8.550, 3.19, 59.29), vec4(8.406, 8.565, 3.82, 59.26), vec4(8.406, 8.565, 3.19, 56.34), vec4(8.450, 8.546, 1.50, 97.56), \n    vec4(8.534, 8.628, 1.50, 95.48), vec4(8.606, 8.684, 1.50, 93.54), vec4(8.665, 8.744, 1.50, 92.54), vec4(8.734, 8.815, 1.50, 88.43), vec4(8.796, 8.878, 1.50, 85.49), \n    vec4(8.856, 8.956, 3.82, 59.28), vec4(8.856, 8.946, 0.50, 28.13), vec4(8.856, 8.944, 3.19, 59.32), vec4(8.856, 8.925, 3.19, 56.37), vec4(8.856, 8.913, 3.19, 64.39), \n    vec4(8.856, 8.928, 3.82, 64.32), vec4(8.856, 8.934, 3.82, 68.38), vec4(8.863, 8.940, 1.50, 83.43), vec4(8.921, 8.990, 1.50, 81.50), vec4(8.978, 9.046, 1.50, 80.52), \n    vec4(9.006, 9.134, 0.50, 28.13), vec4(9.006, 9.106, 3.82, 64.31), vec4(9.006, 9.134, 3.19, 59.32), vec4(9.006, 9.146, 3.82, 68.39), vec4(9.006, 9.138, 3.82, 59.28), \n    vec4(9.006, 9.119, 3.19, 56.38), vec4(9.006, 9.131, 3.19, 64.35), vec4(9.038, 9.121, 1.50, 76.46), vec4(9.103, 9.188, 1.50, 73.50), vec4(9.181, 9.271, 1.50, 71.52), \n    vec4(9.253, 9.334, 1.50, 69.51), vec4(9.315, 9.403, 1.50, 68.51), vec4(9.396, 9.509, 1.50, 64.51), vec4(9.513, 9.590, 1.50, 61.55), vec4(9.606, 11.794, 3.19, 59.32), \n    vec4(9.606, 11.828, 3.82, 64.33), vec4(9.606, 11.850, 3.82, 68.32), vec4(9.606, 11.856, 3.82, 59.30), vec4(9.606, 9.709, 1.50, 59.54), vec4(9.606, 11.796, 0.50, 35.09), \n    vec4(9.606, 11.794, 3.19, 56.31), vec4(9.606, 11.796, 3.19, 64.35), vec4(9.906, 10.146, 2.43, 59.07), vec4(10.206, 10.544, 2.43, 64.12), vec4(10.506, 10.819, 2.43, 68.15), \n    vec4(10.806, 11.128, 2.43, 73.08), vec4(11.106, 11.440, 2.43, 71.15), vec4(11.406, 11.703, 2.43, 68.10), vec4(11.706, 12.019, 2.43, 64.15), vec4(12.006, 12.156, 3.82, 63.33), \n    vec4(12.006, 12.128, 3.19, 63.41), vec4(12.006, 12.140, 3.19, 59.33), vec4(12.006, 12.153, 3.19, 54.33), vec4(12.006, 12.140, 3.82, 71.29), vec4(12.006, 12.131, 3.82, 66.36), \n    vec4(12.006, 13.644, 2.43, 66.23), vec4(12.006, 12.203, 0.50, 35.07), vec4(12.456, 12.540, 3.19, 54.33), vec4(12.456, 12.534, 3.19, 59.31), vec4(12.456, 12.509, 3.19, 63.41), \n    vec4(12.456, 12.534, 0.50, 35.14), vec4(12.456, 12.521, 3.82, 71.31), vec4(12.456, 12.525, 3.82, 66.39), vec4(12.456, 12.509, 3.82, 63.36), vec4(12.606, 12.713, 3.19, 59.31), \n    vec4(12.606, 12.709, 3.19, 63.40), vec4(12.606, 12.719, 3.82, 66.37), vec4(12.606, 12.728, 3.82, 71.30), vec4(12.606, 12.731, 3.82, 63.35), vec4(12.606, 12.744, 3.19, 54.36), \n    vec4(12.606, 12.753, 0.50, 35.07), vec4(13.206, 13.331, 3.82, 63.34), vec4(13.206, 13.306, 3.82, 66.37), vec4(13.206, 13.363, 3.19, 54.34), vec4(13.206, 13.303, 3.19, 63.30), \n    vec4(13.206, 13.300, 3.19, 59.31), vec4(13.206, 13.321, 3.82, 71.29), vec4(13.206, 13.350, 0.50, 35.05), vec4(13.656, 13.728, 3.82, 71.33), vec4(13.656, 13.765, 3.82, 63.34), \n    vec4(13.656, 13.771, 3.82, 66.33), vec4(13.656, 13.859, 3.19, 59.34), vec4(13.656, 13.796, 3.19, 54.39), vec4(13.656, 13.753, 3.19, 63.34), vec4(13.656, 13.746, 0.50, 35.12), \n    vec4(13.806, 14.290, 3.82, 70.34), vec4(13.806, 14.321, 3.82, 65.29), vec4(13.806, 14.371, 3.82, 62.33), vec4(13.806, 14.338, 3.19, 53.34), vec4(13.806, 14.294, 0.50, 34.09), \n    vec4(13.806, 14.321, 3.19, 62.31), vec4(13.806, 14.338, 3.19, 58.42), vec4(14.406, 14.531, 3.19, 61.39), vec4(14.406, 14.484, 3.82, 64.35), vec4(14.406, 14.600, 0.50, 33.03), \n    vec4(14.406, 14.521, 3.82, 69.31), vec4(14.406, 14.559, 3.82, 61.40), vec4(14.406, 14.559, 3.19, 57.40), vec4(14.406, 14.553, 3.19, 52.33), vec4(14.706, 14.981, 2.43, 59.02), \n    vec4(14.856, 14.909, 3.82, 61.38), vec4(14.856, 14.956, 3.82, 69.31), vec4(14.856, 14.946, 3.19, 52.32), vec4(14.856, 14.928, 3.19, 57.27), vec4(14.856, 14.925, 3.19, 61.33), \n    vec4(14.856, 14.953, 0.50, 33.04), vec4(14.856, 14.931, 3.82, 64.34), vec4(15.006, 15.115, 3.19, 57.28), vec4(15.006, 15.115, 3.19, 61.35), vec4(15.006, 15.128, 3.82, 64.32), \n    vec4(15.006, 15.134, 3.82, 69.30), vec4(15.006, 15.159, 3.19, 52.38), vec4(15.006, 15.121, 3.82, 61.35), vec4(15.006, 15.234, 2.43, 61.12), vec4(15.006, 15.159, 0.50, 33.02), \n    vec4(15.306, 15.584, 2.43, 64.16), vec4(15.606, 15.734, 3.82, 64.33), vec4(15.606, 15.740, 3.82, 69.32), vec4(15.606, 15.756, 3.82, 61.29), vec4(15.606, 15.765, 3.19, 52.33), \n    vec4(15.606, 15.728, 3.19, 57.28), vec4(15.606, 15.721, 3.19, 61.33), vec4(15.606, 15.888, 2.43, 69.06), vec4(15.606, 15.790, 0.50, 33.09), vec4(15.906, 16.203, 2.43, 68.16), \n    vec4(16.056, 16.134, 0.50, 33.06), vec4(16.056, 16.125, 3.19, 61.38), vec4(16.056, 16.144, 3.19, 52.36), vec4(16.056, 16.138, 3.82, 69.32), vec4(16.056, 16.134, 3.82, 64.31), \n    vec4(16.056, 16.128, 3.82, 61.31), vec4(16.056, 16.125, 3.19, 57.31), vec4(16.206, 16.381, 0.50, 33.07), vec4(16.206, 16.353, 3.19, 52.35), vec4(16.206, 16.515, 2.43, 66.22), \n    vec4(16.206, 16.369, 3.82, 69.35), vec4(16.206, 16.359, 3.82, 61.31), vec4(16.206, 16.340, 3.82, 64.33), vec4(16.206, 16.321, 3.19, 57.29), vec4(16.206, 16.321, 3.19, 61.34), \n    vec4(16.506, 16.800, 2.43, 73.15), vec4(16.806, 18.476, 2.43, 71.13), vec4(16.806, 16.975, 0.50, 40.10), vec4(16.806, 16.931, 3.19, 59.31), vec4(16.806, 16.969, 3.82, 59.31), \n    vec4(16.806, 16.946, 3.82, 68.30), vec4(16.806, 16.925, 3.82, 64.33), vec4(16.806, 16.934, 3.19, 64.34), vec4(16.806, 16.934, 3.19, 56.30), vec4(17.256, 17.359, 3.82, 59.31), \n    vec4(17.256, 17.315, 3.82, 68.35), vec4(17.256, 17.338, 3.82, 64.35), vec4(17.256, 17.328, 3.19, 56.33), vec4(17.256, 17.346, 3.19, 59.31), vec4(17.256, 17.340, 0.50, 40.11), \n    vec4(17.256, 17.325, 3.19, 64.38), vec4(17.406, 17.528, 3.82, 68.32), vec4(17.406, 17.519, 3.19, 59.32), vec4(17.406, 17.525, 3.19, 64.35), vec4(17.406, 17.534, 3.19, 56.31), \n    vec4(17.406, 17.546, 0.50, 40.12), vec4(17.406, 17.550, 3.82, 59.31), vec4(17.406, 17.515, 3.82, 64.36), vec4(18.006, 18.128, 3.19, 59.31), vec4(18.006, 18.131, 3.19, 56.30), \n    vec4(18.006, 18.134, 0.50, 40.10), vec4(18.006, 18.115, 3.19, 64.28), vec4(18.006, 18.115, 3.82, 68.34), vec4(18.006, 18.109, 3.82, 64.35), vec4(18.006, 18.165, 3.82, 59.31), \n    vec4(18.456, 18.528, 3.82, 68.35), vec4(18.456, 18.534, 0.50, 40.12), vec4(18.456, 18.534, 3.82, 64.30), vec4(18.456, 18.556, 3.19, 64.29), vec4(18.456, 18.550, 3.82, 59.31), \n    vec4(18.456, 18.553, 3.19, 59.32), vec4(18.456, 18.538, 3.19, 56.32), vec4(18.606, 18.759, 3.19, 56.35), vec4(18.606, 18.746, 3.19, 59.33), vec4(18.606, 18.728, 3.19, 64.32), \n    vec4(18.606, 18.740, 3.82, 59.33), vec4(18.606, 18.709, 3.82, 64.29), vec4(18.606, 18.738, 0.50, 40.10), vec4(18.606, 18.719, 3.82, 68.36), vec4(19.206, 19.346, 0.50, 40.10), \n    vec4(19.206, 19.350, 3.82, 59.32), vec4(19.206, 19.331, 3.82, 68.34), vec4(19.206, 19.344, 3.19, 64.30), vec4(19.206, 19.340, 3.19, 56.33), vec4(19.206, 19.334, 3.19, 59.33), \n    vec4(19.206, 19.306, 3.82, 64.29), vec4(19.506, 19.759, 2.43, 59.07), vec4(19.656, 19.740, 3.82, 59.35), vec4(19.656, 19.734, 3.82, 64.32), vec4(19.656, 19.700, 3.82, 68.41), \n    vec4(19.656, 19.738, 0.50, 40.09), vec4(19.656, 19.728, 3.19, 56.35), vec4(19.656, 19.731, 3.19, 59.35), vec4(19.656, 19.734, 3.19, 64.33), vec4(19.806, 19.934, 3.82, 59.33), \n    vec4(19.806, 20.096, 2.43, 64.11), vec4(19.806, 19.950, 3.19, 56.37), vec4(19.806, 19.931, 3.82, 68.37), vec4(19.806, 19.934, 3.19, 59.35), vec4(19.806, 19.931, 0.50, 40.13), \n    vec4(19.806, 19.928, 3.19, 64.34), vec4(19.806, 19.915, 3.82, 64.33), vec4(20.106, 20.394, 2.43, 68.12), vec4(20.406, 20.553, 3.82, 68.36), vec4(20.406, 20.515, 3.19, 59.28), \n    vec4(20.406, 20.528, 3.19, 64.31), vec4(20.406, 20.534, 3.19, 56.34), vec4(20.406, 20.540, 3.82, 59.28), vec4(20.406, 20.509, 3.82, 64.31), vec4(20.406, 20.525, 0.50, 40.02), \n    vec4(20.406, 20.746, 2.43, 73.06), vec4(20.706, 21.006, 2.43, 71.10), vec4(20.856, 20.919, 3.82, 68.37), vec4(20.856, 20.921, 3.82, 64.32), vec4(20.856, 20.953, 0.50, 40.07), \n    vec4(20.856, 20.934, 3.19, 59.28), vec4(20.856, 20.928, 3.19, 56.36), vec4(20.856, 20.925, 3.19, 64.32), vec4(20.856, 20.931, 3.82, 59.28), vec4(21.006, 21.309, 0.50, 35.12), \n    vec4(21.006, 21.296, 2.43, 68.14), vec4(21.006, 21.150, 3.19, 56.37), vec4(21.006, 21.103, 3.82, 64.34), vec4(21.006, 21.140, 3.82, 68.38), vec4(21.006, 21.144, 3.82, 59.29), \n    vec4(21.006, 21.134, 3.19, 64.31), vec4(21.006, 21.131, 3.19, 59.30), vec4(21.306, 21.534, 0.50, 40.09), vec4(21.306, 21.619, 2.43, 64.11), vec4(21.606, 21.734, 0.50, 35.07), \n    vec4(21.606, 21.719, 3.19, 63.35), vec4(21.606, 21.738, 3.19, 59.29), vec4(21.606, 23.374, 2.43, 66.17), vec4(21.606, 21.740, 3.82, 63.33), vec4(21.606, 21.738, 3.82, 71.27), \n    vec4(21.606, 21.713, 3.82, 66.33), vec4(21.606, 21.765, 3.19, 54.38), vec4(22.056, 22.128, 3.19, 63.39), vec4(22.056, 22.140, 3.19, 54.33), vec4(22.056, 22.140, 0.50, 35.13), \n    vec4(22.056, 22.119, 3.82, 63.36), vec4(22.056, 22.125, 3.82, 71.29), vec4(22.056, 22.128, 3.82, 66.37), vec4(22.056, 22.128, 3.19, 59.32), vec4(22.206, 22.315, 3.19, 59.31), \n    vec4(22.206, 22.338, 3.19, 63.34), vec4(22.206, 22.359, 3.19, 54.35), vec4(22.206, 22.325, 3.82, 71.30), vec4(22.206, 22.315, 0.50, 35.05), vec4(22.206, 22.325, 3.82, 63.34), \n    vec4(22.206, 22.315, 3.82, 66.36), vec4(22.806, 22.934, 3.82, 63.35), vec4(22.806, 22.906, 3.82, 71.30), vec4(22.806, 22.894, 3.82, 66.38), vec4(22.806, 22.919, 3.19, 63.35), \n    vec4(22.806, 22.928, 3.19, 59.32), vec4(22.806, 22.934, 3.19, 54.31), vec4(22.806, 22.934, 0.50, 35.09), vec4(23.256, 23.353, 0.50, 35.12), vec4(23.256, 23.378, 3.82, 63.34), \n    vec4(23.256, 23.350, 3.82, 66.32), vec4(23.256, 23.378, 3.19, 54.31), vec4(23.256, 23.338, 3.82, 71.31), vec4(23.256, 23.306, 3.19, 63.43), vec4(23.256, 23.363, 3.19, 59.31), \n    vec4(23.406, 23.915, 3.82, 70.35), vec4(23.406, 23.903, 3.19, 53.32), vec4(23.406, 23.890, 3.19, 62.28), vec4(23.406, 23.950, 3.82, 62.36), vec4(23.406, 23.871, 0.50, 34.12), \n    vec4(23.406, 23.878, 3.82, 65.30), vec4(23.406, 23.925, 3.19, 58.35), vec4(24.006, 24.144, 3.19, 57.33), vec4(24.006, 24.140, 0.50, 33.08), vec4(24.006, 24.134, 3.19, 61.32), \n    vec4(24.006, 24.156, 3.82, 61.36), vec4(24.006, 24.146, 3.82, 69.32), vec4(24.006, 24.134, 3.82, 64.32), vec4(24.006, 24.169, 3.19, 52.34), vec4(24.306, 24.615, 2.43, 59.08), \n    vec4(24.456, 24.556, 0.50, 33.06), vec4(24.456, 24.538, 3.82, 69.25), vec4(24.456, 24.521, 3.82, 64.31), vec4(24.456, 24.521, 3.82, 61.39), vec4(24.456, 24.531, 3.19, 52.31), \n    vec4(24.456, 24.528, 3.19, 57.31), vec4(24.456, 24.513, 3.19, 61.33), vec4(24.606, 24.888, 2.43, 61.09), vec4(24.606, 24.709, 3.19, 61.31), vec4(24.606, 24.753, 3.82, 61.31), \n    vec4(24.606, 24.753, 0.50, 33.08), vec4(24.606, 24.700, 3.82, 64.34), vec4(24.606, 24.719, 3.19, 57.33), vec4(24.606, 24.746, 3.19, 52.31), vec4(24.606, 24.715, 3.82, 69.34), \n    vec4(24.906, 25.113, 2.43, 64.13), vec4(25.206, 25.313, 3.82, 64.35), vec4(25.206, 25.353, 0.50, 33.08), vec4(25.206, 25.384, 3.19, 52.31), vec4(25.206, 25.346, 3.82, 61.31), \n    vec4(25.206, 25.350, 3.82, 69.33), vec4(25.206, 25.321, 3.19, 61.33), vec4(25.206, 25.325, 3.19, 57.32), vec4(25.506, 25.640, 2.43, 69.10), vec4(25.656, 25.734, 3.82, 69.35), \n    vec4(25.656, 25.725, 3.82, 64.34), vec4(25.656, 25.734, 3.82, 61.33), vec4(25.656, 25.825, 2.43, 68.20), vec4(25.656, 25.746, 3.19, 52.33), vec4(25.656, 25.746, 0.50, 33.06), \n    vec4(25.656, 25.719, 3.19, 61.34), vec4(25.656, 25.725, 3.19, 57.28), vec4(25.806, 25.944, 3.82, 61.31), vec4(25.806, 25.915, 3.82, 64.35), vec4(25.806, 25.944, 0.50, 33.07), \n    vec4(25.806, 26.119, 2.43, 66.13), vec4(25.806, 25.965, 3.19, 52.34), vec4(25.806, 25.931, 3.19, 57.27), vec4(25.806, 25.931, 3.19, 61.34), vec4(25.806, 25.965, 3.82, 69.28), \n    vec4(26.106, 26.400, 2.43, 61.11), vec4(26.406, 26.490, 3.82, 64.35), vec4(26.406, 26.521, 3.19, 59.29), vec4(26.406, 26.538, 3.19, 64.33), vec4(26.406, 26.544, 3.19, 56.36), \n    vec4(26.406, 28.174, 2.43, 64.17), vec4(26.406, 26.563, 0.50, 40.12), vec4(26.406, 26.556, 3.82, 59.31), vec4(26.406, 26.503, 3.82, 68.29), vec4(26.856, 26.931, 0.50, 40.11), \n    vec4(26.856, 26.938, 3.82, 59.30), vec4(26.856, 26.921, 3.82, 64.35), vec4(26.856, 26.921, 3.82, 68.33), vec4(26.856, 26.909, 3.19, 64.39), vec4(26.856, 26.925, 3.19, 56.36), \n    vec4(26.856, 26.938, 3.19, 59.32), vec4(27.006, 27.128, 0.50, 40.10), vec4(27.006, 27.140, 3.82, 59.29), vec4(27.006, 27.115, 3.82, 64.35), vec4(27.006, 27.109, 3.82, 68.32), \n    vec4(27.006, 27.109, 3.19, 56.35), vec4(27.006, 27.121, 3.19, 64.32), vec4(27.006, 27.128, 3.19, 59.30), vec4(27.306, 27.515, 3.19, 57.27), vec4(27.306, 27.553, 3.82, 69.28), \n    vec4(27.306, 27.531, 3.82, 61.31), vec4(27.306, 27.503, 3.19, 61.33), vec4(27.306, 27.500, 3.82, 64.38), vec4(27.306, 27.719, 3.19, 64.34), vec4(27.606, 27.738, 3.19, 59.31), \n    vec4(27.606, 27.763, 3.82, 59.31), vec4(27.606, 27.734, 3.82, 64.29), vec4(27.606, 27.721, 3.82, 68.35), vec4(27.606, 27.746, 3.19, 56.28), vec4(27.606, 27.753, 0.50, 40.09), \n    vec4(28.056, 28.144, 3.19, 59.29), vec4(28.056, 28.140, 3.82, 59.32), vec4(28.056, 28.115, 3.82, 64.31), vec4(28.056, 28.138, 0.50, 40.10), vec4(28.056, 28.115, 3.82, 68.36), \n    vec4(28.056, 28.121, 3.19, 56.38), vec4(28.206, 28.328, 3.19, 56.32), vec4(28.206, 28.315, 3.82, 68.34), vec4(28.206, 28.344, 3.19, 59.34), vec4(28.206, 28.334, 3.82, 59.31), \n    vec4(28.206, 28.319, 3.82, 64.29), vec4(28.206, 28.344, 0.50, 40.09), vec4(28.206, 28.315, 3.19, 64.31), vec4(28.506, 28.734, 3.19, 61.39), vec4(28.506, 28.775, 3.19, 57.28), \n    vec4(28.506, 28.759, 3.82, 61.35), vec4(28.506, 28.738, 3.82, 69.31), vec4(28.506, 28.678, 3.19, 64.31), vec4(28.506, 28.721, 3.82, 64.33), vec4(28.806, 29.025, 3.82, 59.31), \n    vec4(28.806, 28.959, 3.19, 59.35), vec4(28.806, 28.965, 0.50, 40.10), vec4(28.806, 28.981, 3.82, 64.31), vec4(28.806, 28.956, 3.19, 64.31), vec4(28.806, 29.000, 3.19, 56.35), \n    vec4(28.806, 28.981, 3.82, 68.35), vec4(29.406, 30.040, 0.50, 35.06), vec4(29.406, 29.834, 3.82, 66.40), vec4(29.406, 29.838, 3.82, 63.39), vec4(29.406, 29.875, 3.19, 66.38), \n    vec4(29.406, 29.888, 3.19, 63.32), vec4(29.406, 30.000, 5.11, 83.41), vec4(29.406, 30.000, 5.11, 71.42), vec4(29.406, 29.900, 3.19, 59.33), vec4(29.406, 29.828, 3.82, 59.29), \n    vec4(29.406, 29.978, 2.43, 71.07), vec4(29.428, 31.125, 7.50, 66.50), vec4(29.428, 31.156, 7.50, 59.50), vec4(29.428, 31.138, 7.50, 63.50), vec4(30.006, 30.600, 5.11, 73.40), \n    vec4(30.006, 30.321, 0.50, 47.08), vec4(30.006, 30.538, 3.19, 59.35), vec4(30.006, 30.513, 3.19, 63.33), vec4(30.006, 30.509, 3.19, 66.39), vec4(30.006, 30.600, 5.11, 85.45), \n    vec4(30.006, 30.490, 3.82, 63.36), vec4(30.006, 30.490, 3.82, 66.40), vec4(30.006, 30.463, 3.82, 59.30), vec4(30.006, 30.640, 2.43, 73.05), vec4(30.306, 30.613, 0.50, 35.09), \n    vec4(30.606, 30.921, 0.50, 47.11), vec4(30.606, 31.050, 2.43, 75.07), vec4(30.606, 31.053, 3.82, 66.39), vec4(30.606, 31.063, 3.82, 59.31), vec4(30.606, 31.071, 3.82, 63.37), \n    vec4(30.606, 31.150, 5.11, 87.37), vec4(30.606, 31.078, 3.19, 59.35), vec4(30.606, 31.046, 3.19, 66.40), vec4(30.606, 31.034, 3.19, 63.35), vec4(30.606, 31.159, 5.11, 75.46), \n    vec4(30.906, 31.159, 0.50, 35.10), vec4(31.206, 31.484, 5.11, 88.43), vec4(31.206, 31.363, 0.50, 40.02), vec4(31.206, 31.544, 2.43, 76.07), vec4(31.206, 31.331, 3.19, 59.38), \n    vec4(31.206, 31.456, 5.11, 76.39), vec4(31.206, 31.331, 3.19, 68.43), vec4(31.206, 31.331, 3.19, 64.35), vec4(31.228, 33.656, 7.50, 59.50), vec4(31.228, 33.634, 7.50, 68.50), \n    vec4(31.228, 33.659, 7.50, 64.50), vec4(31.356, 31.613, 3.19, 59.32), vec4(31.356, 31.613, 3.19, 64.38), vec4(31.356, 31.603, 3.19, 68.43), vec4(31.506, 31.694, 5.11, 87.43), \n    vec4(31.506, 31.709, 5.11, 75.46), vec4(31.506, 31.634, 3.82, 68.35), vec4(31.506, 31.628, 3.82, 59.30), vec4(31.506, 31.609, 3.82, 64.34), vec4(31.656, 31.740, 2.43, 75.03), \n    vec4(31.656, 31.728, 3.19, 64.39), vec4(31.656, 31.725, 0.50, 40.12), vec4(31.656, 31.715, 3.19, 68.44), vec4(31.656, 32.044, 3.19, 59.33), vec4(31.806, 31.940, 0.50, 40.11), \n    vec4(31.806, 32.063, 3.19, 64.35), vec4(31.806, 32.063, 3.19, 68.41), vec4(31.806, 32.069, 2.43, 75.09), vec4(31.806, 32.088, 5.11, 75.45), vec4(31.806, 32.081, 5.11, 87.41), \n    vec4(32.106, 32.334, 5.11, 85.41), vec4(32.106, 32.306, 5.11, 73.47), vec4(32.106, 32.363, 3.19, 64.35), vec4(32.106, 32.338, 2.43, 73.10), vec4(32.106, 32.234, 3.82, 68.36), \n    vec4(32.106, 32.225, 3.82, 64.34), vec4(32.106, 32.363, 3.19, 68.39), vec4(32.106, 32.234, 3.82, 59.31), vec4(32.106, 32.363, 3.19, 59.39), vec4(32.406, 32.459, 3.19, 68.43), \n    vec4(32.406, 32.794, 2.43, 73.03), vec4(32.406, 32.488, 3.19, 64.38), vec4(32.406, 32.490, 3.19, 59.34), vec4(32.406, 32.696, 5.11, 73.40), vec4(32.406, 32.550, 0.50, 40.05), \n    vec4(32.406, 32.688, 5.11, 85.46), vec4(32.556, 32.813, 3.19, 64.39), vec4(32.556, 32.813, 3.19, 59.39), vec4(32.556, 32.813, 3.19, 68.42), vec4(32.706, 32.925, 5.11, 83.39), \n    vec4(32.706, 32.834, 3.82, 59.31), vec4(32.706, 32.831, 3.82, 64.34), vec4(32.706, 32.946, 5.11, 71.35), vec4(32.706, 32.846, 3.82, 68.36), vec4(32.856, 32.963, 2.43, 71.09), \n    vec4(32.856, 32.921, 0.50, 40.09), vec4(32.856, 32.928, 3.19, 68.43), vec4(32.856, 32.963, 3.19, 64.36), vec4(32.856, 32.965, 3.19, 59.33), vec4(33.006, 33.263, 3.19, 68.35), \n    vec4(33.006, 33.263, 3.19, 64.40), vec4(33.006, 33.263, 3.19, 59.35), vec4(33.006, 33.313, 2.43, 71.04), vec4(33.006, 33.290, 5.11, 83.37), vec4(33.006, 33.156, 0.50, 40.11), \n    vec4(33.006, 33.256, 5.11, 71.41), vec4(33.306, 33.428, 3.82, 59.32), vec4(33.306, 33.438, 3.82, 64.35), vec4(33.306, 33.438, 3.82, 68.35), vec4(33.306, 33.571, 2.43, 64.10), \n    vec4(33.306, 33.600, 5.11, 76.42), vec4(33.306, 33.578, 5.11, 64.42), vec4(33.306, 33.563, 3.19, 59.35), vec4(33.306, 33.563, 3.19, 64.39), vec4(33.306, 33.553, 3.19, 68.38), \n    vec4(33.606, 34.200, 5.11, 66.43), vec4(33.606, 34.181, 2.43, 66.12), vec4(33.606, 34.200, 5.11, 78.45), vec4(33.606, 33.753, 0.50, 42.07), vec4(33.606, 33.669, 3.19, 66.43), \n    vec4(33.606, 33.675, 3.19, 61.42), vec4(33.606, 33.696, 3.19, 57.36), vec4(33.628, 38.413, 7.50, 66.50), vec4(33.628, 36.075, 7.50, 61.50), vec4(33.628, 36.069, 7.50, 57.50), \n    vec4(33.756, 34.013, 3.19, 66.43), vec4(33.756, 34.013, 3.19, 57.36), vec4(33.756, 34.013, 3.19, 61.43), vec4(33.906, 34.028, 3.82, 66.34), vec4(33.906, 34.021, 3.82, 61.37), \n    vec4(33.906, 34.040, 3.82, 69.31), vec4(34.056, 34.163, 3.19, 61.35), vec4(34.056, 34.171, 3.19, 57.34), vec4(34.056, 34.134, 3.19, 66.42), vec4(34.056, 34.140, 0.50, 42.13), \n    vec4(34.206, 34.331, 0.50, 42.12), vec4(34.206, 35.746, 5.11, 85.42), vec4(34.206, 35.771, 5.11, 73.50), vec4(34.206, 34.463, 3.19, 57.35), vec4(34.206, 34.463, 3.19, 61.35), \n    vec4(34.206, 34.463, 3.19, 66.39), vec4(34.206, 35.374, 2.43, 73.06), vec4(34.506, 34.763, 3.19, 57.36), vec4(34.506, 34.725, 3.19, 61.39), vec4(34.506, 34.721, 3.19, 66.40), \n    vec4(34.506, 34.644, 3.82, 69.31), vec4(34.506, 34.615, 3.82, 66.37), vec4(34.506, 34.621, 3.82, 61.37), vec4(34.528, 34.690, 6.90, 66.30), vec4(34.528, 34.638, 6.90, 69.17), \n    vec4(34.678, 34.803, 6.90, 68.24), vec4(34.678, 34.775, 6.90, 71.28), vec4(34.806, 34.881, 3.19, 66.43), vec4(34.806, 34.896, 3.19, 61.38), vec4(34.806, 34.900, 3.19, 57.38), \n    vec4(34.806, 34.965, 0.50, 42.08), vec4(34.828, 34.969, 6.90, 69.21), vec4(34.828, 34.921, 6.90, 73.30), vec4(34.956, 35.196, 3.19, 66.41), vec4(34.956, 35.213, 3.19, 57.33), \n    vec4(34.956, 35.188, 3.19, 61.38), vec4(34.978, 35.103, 6.90, 71.22), vec4(34.978, 35.131, 6.90, 68.24), vec4(35.106, 35.225, 3.82, 66.37), vec4(35.106, 35.246, 3.82, 69.30), \n    vec4(35.106, 35.219, 3.82, 61.38), vec4(35.256, 35.328, 0.50, 42.18), vec4(35.256, 35.344, 3.19, 61.39), vec4(35.256, 35.353, 3.19, 57.31), vec4(35.278, 35.406, 6.90, 69.24), \n    vec4(35.278, 35.425, 6.90, 66.22), vec4(35.406, 35.663, 3.19, 61.36), vec4(35.406, 35.534, 0.50, 42.07), vec4(35.406, 35.656, 3.19, 66.42), vec4(35.406, 35.663, 3.19, 57.37), \n    vec4(35.578, 35.719, 6.90, 64.31), vec4(35.578, 35.725, 6.90, 68.37), vec4(35.706, 35.815, 3.82, 66.39), vec4(35.706, 35.831, 3.82, 61.40), vec4(35.706, 35.963, 3.19, 66.43), \n    vec4(35.706, 35.963, 3.19, 57.36), vec4(35.706, 35.834, 3.82, 69.31), vec4(35.706, 35.953, 3.19, 61.36), vec4(35.728, 37.713, 6.90, 63.38), vec4(35.728, 37.696, 6.90, 66.39), \n    vec4(36.006, 36.256, 5.11, 75.40), vec4(36.006, 36.113, 3.19, 66.40), vec4(36.006, 36.171, 0.50, 35.06), vec4(36.006, 36.121, 3.19, 63.36), vec4(36.006, 36.128, 3.19, 59.39), \n    vec4(36.006, 36.213, 5.11, 87.50), vec4(36.006, 36.219, 2.43, 75.09), vec4(36.028, 48.281, 7.50, 59.50), vec4(36.028, 38.406, 7.50, 63.50), vec4(36.156, 36.409, 3.19, 59.33), \n    vec4(36.156, 36.378, 3.19, 63.39), vec4(36.156, 36.363, 3.19, 66.46), vec4(36.306, 36.409, 3.82, 63.34), vec4(36.306, 36.409, 3.82, 66.39), vec4(36.306, 36.503, 5.11, 85.45), \n    vec4(36.306, 36.519, 5.11, 73.41), vec4(36.306, 36.419, 3.82, 59.29), vec4(36.306, 36.515, 2.43, 73.11), vec4(36.456, 36.538, 3.19, 66.43), vec4(36.456, 36.556, 3.19, 63.39), \n    vec4(36.456, 36.559, 3.19, 59.34), vec4(36.456, 36.546, 0.50, 35.10), vec4(36.606, 36.859, 2.43, 73.13), vec4(36.606, 36.840, 3.19, 66.44), vec4(36.606, 36.846, 3.19, 63.39), \n    vec4(36.606, 36.863, 3.19, 59.34), vec4(36.606, 36.894, 5.11, 85.42), vec4(36.606, 36.888, 5.11, 73.38), vec4(36.606, 36.725, 0.50, 35.11), vec4(36.906, 37.159, 5.11, 71.41), \n    vec4(36.906, 37.146, 5.11, 83.39), vec4(36.906, 37.021, 3.82, 63.37), vec4(36.906, 37.031, 3.82, 59.31), vec4(36.906, 37.031, 3.82, 66.42), vec4(36.906, 37.125, 2.43, 71.12), \n    vec4(36.906, 37.163, 3.19, 59.34), vec4(36.906, 37.138, 3.19, 63.39), vec4(36.906, 37.128, 3.19, 66.38), vec4(37.206, 37.488, 5.11, 83.42), vec4(37.206, 37.484, 2.43, 71.12), \n    vec4(37.206, 37.313, 3.19, 59.36), vec4(37.206, 37.313, 3.19, 63.42), vec4(37.206, 37.290, 3.19, 66.39), vec4(37.206, 37.375, 0.50, 35.09), vec4(37.206, 37.446, 5.11, 71.48), \n    vec4(37.356, 37.584, 3.19, 63.42), vec4(37.356, 37.613, 3.19, 59.39), vec4(37.356, 37.571, 3.19, 66.39), vec4(37.506, 37.728, 5.11, 81.39), vec4(37.506, 37.631, 3.82, 63.39), \n    vec4(37.506, 37.740, 2.43, 69.06), vec4(37.506, 37.634, 3.82, 59.32), vec4(37.506, 37.725, 5.11, 69.36), vec4(37.506, 37.631, 3.82, 66.43), vec4(37.656, 37.765, 3.19, 59.36), \n    vec4(37.656, 37.750, 3.19, 63.43), vec4(37.656, 37.750, 3.19, 66.37), vec4(37.656, 37.746, 0.50, 35.14), vec4(37.806, 38.063, 3.19, 59.35), vec4(37.806, 37.946, 0.50, 35.06), \n    vec4(37.806, 38.053, 3.19, 66.41), vec4(37.806, 38.053, 3.19, 63.43), vec4(37.806, 38.100, 5.11, 69.43), vec4(37.806, 38.084, 2.43, 69.06), vec4(37.806, 38.081, 5.11, 81.38), \n    vec4(38.106, 38.231, 3.82, 63.38), vec4(38.106, 38.400, 5.11, 66.40), vec4(38.106, 38.400, 5.11, 78.40), vec4(38.106, 38.234, 3.82, 59.32), vec4(38.106, 38.263, 3.19, 66.42), \n    vec4(38.106, 38.278, 3.19, 63.36), vec4(38.106, 38.331, 3.19, 59.38), vec4(38.106, 38.434, 2.43, 66.07), vec4(38.106, 38.234, 3.82, 66.43), vec4(38.406, 38.978, 5.11, 76.41), \n    vec4(38.406, 38.921, 5.11, 64.39), vec4(38.406, 38.503, 3.19, 64.34), vec4(38.406, 38.996, 2.43, 64.11), vec4(38.406, 38.515, 3.19, 68.40), vec4(38.406, 38.575, 0.50, 40.09), \n    vec4(38.406, 38.531, 3.19, 59.39), vec4(38.428, 43.290, 7.50, 64.50), vec4(38.428, 43.263, 7.50, 68.50), vec4(38.556, 38.778, 3.19, 64.37), vec4(38.556, 38.763, 3.19, 68.43), \n    vec4(38.556, 38.813, 3.19, 59.42), vec4(38.706, 38.831, 3.82, 64.35), vec4(38.706, 38.828, 3.82, 68.37), vec4(38.706, 38.844, 3.82, 59.33), vec4(38.856, 38.944, 0.50, 40.17), \n    vec4(38.856, 38.950, 3.19, 64.36), vec4(38.856, 38.931, 3.19, 68.39), vec4(38.856, 38.965, 3.19, 59.39), vec4(39.006, 40.351, 2.43, 76.06), vec4(39.006, 39.244, 3.19, 68.43), \n    vec4(39.006, 40.628, 5.11, 88.43), vec4(39.006, 40.640, 5.11, 76.38), vec4(39.006, 39.253, 3.19, 64.38), vec4(39.006, 39.263, 3.19, 59.33), vec4(39.006, 39.121, 0.50, 40.12), \n    vec4(39.306, 39.428, 3.82, 68.37), vec4(39.306, 39.515, 3.19, 64.39), vec4(39.306, 39.553, 3.19, 59.34), vec4(39.306, 39.421, 3.82, 59.31), vec4(39.306, 39.509, 3.19, 68.43), \n    vec4(39.306, 39.406, 3.82, 64.35), vec4(39.328, 39.425, 6.90, 64.25), vec4(39.328, 39.450, 6.90, 68.16), vec4(39.478, 39.590, 6.90, 66.27), vec4(39.478, 39.588, 6.90, 69.25), \n    vec4(39.606, 39.731, 0.50, 40.08), vec4(39.606, 39.696, 3.19, 64.39), vec4(39.606, 39.719, 3.19, 59.33), vec4(39.628, 39.738, 6.90, 71.22), vec4(39.628, 39.715, 6.90, 68.28), \n    vec4(39.756, 39.975, 3.19, 68.42), vec4(39.756, 39.988, 3.19, 64.35), vec4(39.756, 40.013, 3.19, 59.39), vec4(39.778, 39.878, 6.90, 69.18), vec4(39.778, 39.884, 6.90, 66.28), \n    vec4(39.906, 40.025, 3.82, 64.35), vec4(39.906, 40.025, 3.82, 59.33), vec4(39.906, 40.006, 3.82, 68.39), vec4(40.056, 40.181, 3.19, 59.33), vec4(40.056, 40.159, 3.19, 64.38), \n    vec4(40.056, 40.128, 3.19, 68.43), vec4(40.056, 40.153, 0.50, 40.10), vec4(40.078, 40.196, 6.90, 68.27), vec4(40.078, 40.240, 6.90, 64.25), vec4(40.206, 40.453, 0.50, 35.07), \n    vec4(40.206, 40.453, 3.19, 59.31), vec4(40.206, 40.463, 3.19, 64.36), vec4(40.206, 40.431, 3.19, 68.43), vec4(40.378, 40.488, 6.90, 66.27), vec4(40.378, 40.471, 6.90, 63.29), \n    vec4(40.506, 40.728, 0.50, 37.18), vec4(40.506, 40.740, 3.19, 68.42), vec4(40.506, 40.750, 3.19, 64.39), vec4(40.506, 40.763, 3.19, 59.34), vec4(40.506, 40.628, 3.82, 68.35), \n    vec4(40.506, 40.613, 3.82, 59.32), vec4(40.506, 40.621, 3.82, 64.36), vec4(40.528, 42.456, 6.90, 64.25), vec4(40.806, 40.850, 3.19, 68.49), vec4(40.806, 40.909, 3.19, 59.34), \n    vec4(40.806, 40.888, 3.19, 64.40), vec4(40.806, 41.644, 5.11, 80.40), vec4(40.806, 40.956, 0.50, 40.06), vec4(40.806, 41.665, 5.11, 92.37), vec4(40.806, 41.650, 2.43, 80.02), \n    vec4(40.956, 41.213, 3.19, 68.37), vec4(40.956, 41.213, 3.19, 59.37), vec4(40.956, 41.213, 3.19, 64.39), vec4(41.106, 41.221, 3.82, 64.35), vec4(41.106, 41.246, 3.82, 68.33), \n    vec4(41.106, 41.240, 3.82, 59.32), vec4(41.256, 41.371, 3.19, 59.35), vec4(41.256, 41.350, 3.19, 64.40), vec4(41.256, 41.338, 3.19, 68.38), vec4(41.256, 41.313, 0.50, 40.14), \n    vec4(41.406, 41.663, 3.19, 64.41), vec4(41.406, 41.663, 3.19, 59.35), vec4(41.406, 41.546, 0.50, 40.15), vec4(41.406, 41.663, 3.19, 68.39), vec4(41.706, 41.813, 3.82, 64.28), \n    vec4(41.706, 41.821, 3.82, 59.33), vec4(41.706, 41.944, 5.11, 88.43), vec4(41.706, 41.828, 3.82, 68.35), vec4(41.706, 41.925, 2.43, 76.05), vec4(41.706, 41.963, 3.19, 59.36), \n    vec4(41.706, 41.934, 3.19, 68.42), vec4(41.706, 41.946, 5.11, 76.39), vec4(41.706, 41.950, 3.19, 64.42), vec4(42.006, 42.078, 3.19, 68.39), vec4(42.006, 42.096, 3.19, 59.36), \n    vec4(42.006, 42.100, 3.19, 64.40), vec4(42.006, 42.228, 2.43, 76.10), vec4(42.006, 42.281, 5.11, 76.36), vec4(42.006, 42.263, 5.11, 88.39), vec4(42.006, 42.153, 0.50, 40.07), \n    vec4(42.156, 42.388, 3.19, 64.35), vec4(42.156, 42.413, 3.19, 59.37), vec4(42.156, 42.378, 3.19, 68.42), vec4(42.306, 42.525, 2.43, 71.08), vec4(42.306, 42.546, 5.11, 71.44), \n    vec4(42.306, 42.540, 5.11, 83.37), vec4(42.306, 42.431, 3.82, 68.36), vec4(42.306, 42.425, 3.82, 64.29), vec4(42.306, 42.440, 3.82, 59.33), vec4(42.456, 42.559, 3.19, 59.38), \n    vec4(42.456, 42.540, 3.19, 64.36), vec4(42.456, 42.519, 3.19, 68.41), vec4(42.456, 42.546, 0.50, 40.10), vec4(42.606, 42.746, 0.50, 40.13), vec4(42.606, 42.853, 3.19, 68.41), \n    vec4(42.606, 42.863, 3.19, 59.36), vec4(42.606, 42.881, 5.11, 83.35), vec4(42.606, 42.863, 5.11, 71.41), vec4(42.606, 42.863, 3.19, 64.35), vec4(42.606, 42.934, 2.43, 71.07), \n    vec4(42.906, 43.200, 5.11, 80.46), vec4(42.906, 43.138, 3.19, 59.39), vec4(42.906, 43.113, 3.19, 68.41), vec4(42.906, 43.021, 3.82, 68.36), vec4(42.906, 43.015, 3.82, 64.30), \n    vec4(42.906, 43.034, 3.82, 59.34), vec4(42.906, 43.200, 5.11, 68.47), vec4(42.906, 43.109, 3.19, 64.35), vec4(42.906, 43.206, 2.43, 68.14), vec4(43.206, 45.070, 2.43, 69.06), \n    vec4(43.206, 45.384, 5.11, 69.34), vec4(43.206, 45.388, 5.11, 81.37), vec4(43.206, 43.378, 0.50, 35.07), vec4(43.206, 43.321, 3.19, 59.37), vec4(43.206, 43.313, 3.19, 66.37), \n    vec4(43.206, 43.288, 3.19, 63.35), vec4(43.228, 47.994, 7.50, 63.50), vec4(43.228, 47.996, 7.50, 66.50), vec4(43.356, 43.550, 3.19, 63.39), vec4(43.356, 43.596, 3.19, 59.33), \n    vec4(43.356, 43.546, 3.19, 66.45), vec4(43.506, 43.615, 3.82, 59.35), vec4(43.506, 43.621, 3.82, 63.33), vec4(43.506, 43.628, 3.82, 66.38), vec4(43.656, 43.756, 3.19, 66.41), \n    vec4(43.656, 43.763, 3.19, 63.39), vec4(43.656, 43.765, 3.19, 59.33), vec4(43.656, 43.731, 0.50, 35.11), vec4(43.806, 44.063, 3.19, 59.34), vec4(43.806, 43.944, 0.50, 35.12), \n    vec4(43.806, 44.059, 3.19, 66.46), vec4(43.806, 44.063, 3.19, 63.39), vec4(44.106, 44.221, 3.82, 59.29), vec4(44.106, 44.315, 3.19, 66.38), vec4(44.106, 44.321, 3.19, 63.40), \n    vec4(44.106, 44.356, 3.19, 59.33), vec4(44.106, 44.215, 3.82, 63.35), vec4(44.106, 44.225, 3.82, 66.39), vec4(44.128, 44.231, 6.90, 75.18), vec4(44.128, 44.250, 6.90, 66.20), \n    vec4(44.278, 44.394, 6.90, 76.27), vec4(44.278, 44.369, 6.90, 68.32), vec4(44.406, 44.506, 3.19, 59.35), vec4(44.406, 44.500, 3.19, 63.42), vec4(44.406, 44.494, 3.19, 66.38), \n    vec4(44.406, 44.590, 0.50, 35.06), vec4(44.428, 44.550, 6.90, 69.24), vec4(44.428, 44.534, 6.90, 78.20), vec4(44.556, 44.794, 3.19, 66.39), vec4(44.556, 44.813, 3.19, 59.35), \n    vec4(44.556, 44.778, 3.19, 63.41), vec4(44.578, 44.678, 6.90, 68.24), vec4(44.578, 44.731, 6.90, 76.24), vec4(44.706, 44.828, 3.82, 66.39), vec4(44.706, 44.825, 3.82, 63.35), \n    vec4(44.706, 44.821, 3.82, 59.29), vec4(44.856, 44.950, 3.19, 66.38), vec4(44.856, 44.969, 3.19, 59.35), vec4(44.856, 44.950, 3.19, 63.43), vec4(44.856, 44.959, 0.50, 35.13), \n    vec4(44.878, 44.990, 6.90, 66.24), vec4(44.878, 45.009, 6.90, 75.25), vec4(45.006, 45.163, 0.50, 35.06), vec4(45.006, 45.263, 3.19, 66.39), vec4(45.006, 45.240, 3.19, 63.42), \n    vec4(45.006, 45.263, 3.19, 59.35), vec4(45.178, 45.303, 6.90, 64.29), vec4(45.178, 45.290, 6.90, 73.28), vec4(45.306, 45.525, 3.19, 63.35), vec4(45.306, 45.531, 3.19, 66.39), \n    vec4(45.306, 45.553, 3.19, 59.36), vec4(45.306, 45.415, 3.82, 59.31), vec4(45.306, 45.434, 0.50, 30.12), vec4(45.306, 45.409, 3.82, 63.35), vec4(45.306, 45.403, 3.82, 66.39), \n    vec4(45.328, 47.259, 6.90, 71.28), vec4(45.328, 47.500, 6.90, 63.31), vec4(45.606, 46.359, 2.43, 78.09), vec4(45.606, 46.453, 5.11, 90.45), vec4(45.606, 46.446, 5.11, 78.44), \n    vec4(45.606, 45.781, 0.50, 35.09), vec4(45.606, 45.700, 3.19, 63.35), vec4(45.606, 45.703, 3.19, 59.37), vec4(45.606, 45.709, 3.19, 66.38), vec4(45.756, 45.981, 3.19, 66.42), \n    vec4(45.756, 45.978, 3.19, 63.37), vec4(45.756, 46.006, 3.19, 59.37), vec4(45.906, 46.028, 3.82, 59.32), vec4(45.906, 46.028, 3.82, 66.42), vec4(45.906, 46.031, 3.82, 63.37), \n    vec4(46.056, 46.163, 0.50, 35.09), vec4(46.056, 46.171, 3.19, 59.39), vec4(46.056, 46.171, 3.19, 66.39), vec4(46.056, 46.153, 3.19, 63.38), vec4(46.206, 46.463, 3.19, 59.39), \n    vec4(46.206, 46.463, 3.19, 66.43), vec4(46.206, 46.453, 3.19, 63.38), vec4(46.206, 46.338, 0.50, 35.10), vec4(46.506, 46.721, 5.11, 87.52), vec4(46.506, 46.731, 5.11, 75.46), \n    vec4(46.506, 46.728, 2.43, 75.13), vec4(46.506, 46.628, 3.82, 63.37), vec4(46.506, 46.625, 3.82, 59.32), vec4(46.506, 46.744, 3.19, 63.38), vec4(46.506, 46.763, 3.19, 59.32), \n    vec4(46.506, 46.744, 3.19, 66.43), vec4(46.506, 46.621, 3.82, 66.35), vec4(46.806, 46.903, 3.19, 66.42), vec4(46.806, 47.059, 5.11, 75.43), vec4(46.806, 47.096, 5.11, 87.45), \n    vec4(46.806, 47.065, 2.43, 75.17), vec4(46.806, 46.903, 3.19, 63.39), vec4(46.806, 46.959, 0.50, 35.09), vec4(46.806, 46.913, 3.19, 59.34), vec4(46.956, 47.213, 3.19, 59.36), \n    vec4(46.956, 47.209, 3.19, 66.42), vec4(46.956, 47.203, 3.19, 63.40), vec4(47.106, 47.221, 3.82, 63.36), vec4(47.106, 47.340, 5.11, 83.40), vec4(47.106, 47.309, 5.11, 71.45), \n    vec4(47.106, 47.228, 3.82, 59.33), vec4(47.106, 47.340, 2.43, 71.09), vec4(47.106, 47.234, 3.82, 66.35), vec4(47.256, 47.331, 3.19, 63.39), vec4(47.256, 47.344, 3.19, 66.41), \n    vec4(47.256, 47.359, 3.19, 59.34), vec4(47.256, 47.334, 0.50, 35.10), vec4(47.406, 47.528, 0.50, 35.09), vec4(47.406, 47.678, 2.43, 71.06), vec4(47.406, 47.653, 3.19, 63.40), \n    vec4(47.406, 47.663, 3.19, 66.43), vec4(47.406, 47.663, 3.19, 59.35), vec4(47.406, 47.659, 5.11, 71.40), vec4(47.406, 47.700, 5.11, 83.35), vec4(47.706, 47.840, 0.50, 35.12), \n    vec4(47.706, 47.994, 2.43, 69.06), vec4(47.706, 47.821, 3.82, 59.33), vec4(47.706, 47.828, 3.82, 63.38), vec4(47.706, 47.884, 3.19, 66.39), vec4(47.706, 47.990, 5.11, 69.39), \n    vec4(47.706, 47.981, 5.11, 81.41), vec4(47.706, 47.875, 3.19, 63.40), vec4(47.706, 47.821, 3.82, 66.37), vec4(47.706, 47.963, 3.19, 59.35), vec4(48.006, 48.128, 3.82, 68.30), \n    vec4(48.006, 48.190, 0.50, 40.06), vec4(48.006, 48.221, 3.19, 68.35), vec4(48.006, 48.238, 3.19, 64.39), vec4(48.006, 48.256, 3.19, 59.35), vec4(48.006, 48.265, 2.43, 68.15), \n    vec4(48.006, 48.138, 3.82, 64.34), vec4(48.006, 48.140, 3.82, 59.32), vec4(48.006, 48.259, 5.11, 80.45), vec4(48.006, 48.290, 5.11, 68.39), vec4(48.028, 48.246, 7.50, 64.50), \n    vec4(48.028, 48.221, 7.50, 68.50), vec4(48.606, 49.200, 5.11, 71.45), vec4(48.606, 49.200, 5.11, 83.38), vec4(48.606, 49.125, 3.19, 66.39), vec4(48.606, 49.125, 3.19, 59.35), \n    vec4(48.606, 48.784, 0.50, 35.09), vec4(48.606, 49.125, 3.19, 63.40), vec4(48.606, 49.090, 3.82, 63.39), vec4(48.606, 49.090, 3.82, 66.35), vec4(48.606, 49.040, 3.82, 59.31), \n    vec4(48.606, 49.178, 2.43, 71.05), vec4(48.628, 50.271, 7.50, 63.50), vec4(48.628, 50.278, 7.50, 66.50), vec4(48.628, 50.290, 7.50, 59.50), vec4(48.906, 49.081, 0.50, 35.06), \n    vec4(49.188, 49.271, 1.50, 100.36), vec4(49.206, 49.388, 0.50, 47.09), vec4(49.206, 49.725, 3.19, 63.42), vec4(49.206, 49.725, 3.19, 66.39), vec4(49.206, 49.800, 5.11, 85.48), \n    vec4(49.206, 49.694, 3.82, 59.33), vec4(49.206, 49.715, 3.82, 66.36), vec4(49.206, 49.800, 5.11, 73.43), vec4(49.206, 49.725, 3.82, 63.31), vec4(49.206, 49.725, 3.19, 59.35), \n    vec4(49.206, 49.809, 2.43, 73.09), vec4(49.250, 49.346, 1.50, 97.53), vec4(49.334, 49.428, 1.50, 95.51), vec4(49.406, 49.484, 1.50, 93.50), vec4(49.465, 49.544, 1.50, 92.51), \n    vec4(49.506, 49.659, 0.50, 35.06), vec4(49.534, 49.615, 1.50, 88.47), vec4(49.596, 49.678, 1.50, 85.46), vec4(49.663, 49.740, 1.50, 83.46), vec4(49.721, 49.790, 1.50, 81.54), \n    vec4(49.778, 49.846, 1.50, 80.49), vec4(49.806, 50.425, 3.19, 59.35), vec4(49.806, 49.971, 0.50, 35.06), vec4(49.806, 50.400, 3.19, 66.39), vec4(49.806, 50.250, 3.82, 59.33), \n    vec4(49.806, 50.259, 3.82, 66.36), vec4(49.806, 50.265, 3.82, 63.34), vec4(49.806, 50.359, 5.11, 75.43), vec4(49.806, 50.350, 5.11, 87.41), vec4(49.806, 50.394, 3.19, 63.35), \n    vec4(49.806, 50.265, 2.43, 75.09), vec4(49.838, 49.921, 1.50, 76.49), vec4(49.903, 49.988, 1.50, 73.53), vec4(49.981, 50.071, 1.50, 71.49), vec4(50.053, 50.134, 1.50, 69.54), \n    vec4(50.106, 50.300, 0.50, 35.09), vec4(50.115, 50.203, 1.50, 68.48), vec4(50.196, 50.309, 1.50, 64.48), vec4(50.313, 50.390, 1.50, 61.58), vec4(50.406, 50.684, 5.11, 88.39), \n    vec4(50.406, 50.656, 5.11, 76.43), vec4(50.406, 50.490, 3.19, 64.31), vec4(50.406, 50.509, 1.50, 59.50), vec4(50.406, 50.590, 0.50, 40.11), vec4(50.406, 50.500, 3.19, 68.35), \n    vec4(50.406, 50.744, 2.43, 76.02), vec4(50.428, 52.834, 7.50, 64.50), vec4(50.428, 52.828, 7.50, 59.50), vec4(50.428, 52.815, 7.50, 68.50), vec4(50.556, 50.759, 3.19, 64.34), \n    vec4(50.556, 50.750, 3.19, 68.41), vec4(50.556, 50.784, 3.19, 59.37), vec4(50.706, 50.894, 5.11, 87.39), vec4(50.706, 50.834, 3.82, 68.38), vec4(50.706, 50.828, 3.82, 59.33), \n    vec4(50.706, 50.809, 3.82, 64.30), vec4(50.706, 50.909, 5.11, 75.48), vec4(50.856, 50.944, 0.50, 40.10), vec4(50.856, 50.940, 3.19, 64.35), vec4(50.856, 50.944, 3.19, 59.37), \n    vec4(50.856, 50.909, 3.19, 68.42), vec4(50.856, 50.940, 2.43, 75.05), vec4(51.006, 51.288, 5.11, 75.43), vec4(51.006, 51.269, 2.43, 75.12), vec4(51.006, 51.163, 0.50, 40.12), \n    vec4(51.006, 51.263, 3.19, 59.38), vec4(51.006, 51.263, 3.19, 64.36), vec4(51.006, 51.263, 3.19, 68.39), vec4(51.006, 51.281, 5.11, 87.44), vec4(51.306, 51.538, 2.43, 73.06), \n    vec4(51.306, 51.425, 3.82, 64.31), vec4(51.306, 51.534, 5.11, 85.44), vec4(51.306, 51.434, 3.82, 68.39), vec4(51.306, 51.506, 5.11, 73.44), vec4(51.306, 51.563, 3.19, 59.32), \n    vec4(51.306, 51.540, 3.19, 64.36), vec4(51.306, 51.434, 3.82, 59.35), vec4(51.306, 51.528, 3.19, 68.41), vec4(51.606, 51.994, 2.43, 73.06), vec4(51.606, 51.696, 3.19, 59.34), \n    vec4(51.606, 51.653, 3.19, 68.44), vec4(51.606, 51.678, 3.19, 64.39), vec4(51.606, 51.771, 0.50, 40.10), vec4(51.606, 51.896, 5.11, 73.43), vec4(51.606, 51.888, 5.11, 85.43), \n    vec4(51.756, 52.013, 3.19, 68.43), vec4(51.756, 52.013, 3.19, 64.36), vec4(51.756, 52.013, 3.19, 59.35), vec4(51.906, 52.146, 5.11, 71.39), vec4(51.906, 52.125, 5.11, 83.43), \n    vec4(51.906, 52.046, 3.82, 68.39), vec4(51.906, 52.034, 3.82, 59.35), vec4(51.906, 52.031, 3.82, 64.31), vec4(52.056, 52.163, 2.43, 71.12), vec4(52.056, 52.144, 0.50, 40.09), \n    vec4(52.056, 52.121, 3.19, 68.35), vec4(52.056, 52.140, 3.19, 59.35), vec4(52.056, 52.146, 3.19, 64.39), vec4(52.206, 52.463, 3.19, 64.40), vec4(52.206, 52.463, 3.19, 68.36), \n    vec4(52.206, 52.463, 3.19, 59.35), vec4(52.206, 52.513, 2.43, 71.06), vec4(52.206, 52.365, 0.50, 40.08), vec4(52.206, 52.490, 5.11, 83.39), vec4(52.206, 52.456, 5.11, 71.38), \n    vec4(52.506, 52.638, 3.82, 68.38), vec4(52.506, 52.744, 3.19, 59.35), vec4(52.506, 52.731, 3.19, 64.38), vec4(52.506, 52.628, 3.82, 59.29), vec4(52.506, 52.771, 2.43, 64.11), \n    vec4(52.506, 52.800, 5.11, 76.39), vec4(52.506, 52.778, 5.11, 64.45), vec4(52.506, 52.675, 3.19, 68.37), vec4(52.506, 52.638, 3.82, 64.32), vec4(52.806, 52.900, 3.19, 66.36), \n    vec4(52.806, 52.984, 0.50, 42.06), vec4(52.806, 52.884, 3.19, 61.38), vec4(52.806, 52.896, 3.19, 57.34), vec4(52.806, 53.400, 5.11, 66.45), vec4(52.806, 53.400, 5.11, 78.42), \n    vec4(52.806, 53.381, 2.43, 66.07), vec4(52.828, 55.265, 7.50, 57.50), vec4(52.828, 57.606, 7.50, 66.50), vec4(52.828, 55.263, 7.50, 61.50), vec4(52.956, 53.213, 3.19, 57.35), \n    vec4(52.956, 53.178, 3.19, 66.39), vec4(52.956, 53.175, 3.19, 61.33), vec4(53.106, 53.240, 3.82, 69.33), vec4(53.106, 53.228, 3.82, 66.37), vec4(53.106, 53.221, 3.82, 61.33), \n    vec4(53.256, 53.356, 3.19, 57.37), vec4(53.256, 53.331, 3.19, 61.37), vec4(53.256, 53.328, 3.19, 66.42), vec4(53.256, 53.340, 0.50, 42.19), vec4(53.406, 53.550, 0.50, 42.10), \n    vec4(53.406, 54.606, 2.43, 73.09), vec4(53.406, 53.646, 3.19, 57.35), vec4(53.406, 54.946, 5.11, 85.44), vec4(53.406, 53.778, 3.19, 61.36), vec4(53.406, 53.646, 3.19, 66.39), \n    vec4(53.406, 54.971, 5.11, 73.46), vec4(53.706, 53.921, 3.19, 66.40), vec4(53.706, 53.821, 3.82, 61.34), vec4(53.706, 53.815, 3.82, 66.40), vec4(53.706, 53.844, 3.82, 69.34), \n    vec4(53.706, 53.963, 3.19, 57.37), vec4(53.728, 53.815, 6.90, 69.24), vec4(53.728, 53.878, 6.90, 66.24), vec4(53.878, 53.965, 6.90, 68.31), vec4(53.878, 53.953, 6.90, 71.26), \n    vec4(54.006, 54.096, 3.19, 61.36), vec4(54.006, 54.088, 3.19, 57.31), vec4(54.006, 54.175, 0.50, 42.06), vec4(54.006, 54.084, 3.19, 66.41), vec4(54.028, 54.153, 6.90, 69.31), \n    vec4(54.028, 54.115, 6.90, 73.26), vec4(54.156, 54.413, 3.19, 57.33), vec4(54.156, 54.413, 3.19, 61.39), vec4(54.156, 54.413, 3.19, 66.41), vec4(54.178, 54.265, 6.90, 71.30), \n    vec4(54.178, 54.303, 6.90, 68.30), vec4(54.306, 54.419, 3.82, 61.34), vec4(54.306, 54.446, 3.82, 69.33), vec4(54.306, 54.425, 3.82, 66.39), vec4(54.456, 54.550, 3.19, 61.39), \n    vec4(54.456, 54.559, 3.19, 57.32), vec4(54.456, 54.534, 3.19, 66.44), vec4(54.456, 54.556, 0.50, 42.16), vec4(54.478, 54.588, 6.90, 66.26), vec4(54.478, 54.596, 6.90, 69.26), \n    vec4(54.606, 54.853, 3.19, 66.43), vec4(54.606, 54.759, 0.50, 42.09), vec4(54.606, 54.859, 3.19, 61.38), vec4(54.606, 54.863, 3.19, 57.31), vec4(54.778, 54.865, 6.90, 68.27), \n    vec4(54.778, 54.875, 6.90, 64.35), vec4(54.906, 55.163, 3.19, 57.35), vec4(54.906, 55.103, 3.19, 61.40), vec4(54.906, 55.034, 3.82, 69.27), vec4(54.906, 55.031, 3.82, 61.37), \n    vec4(54.906, 55.015, 3.82, 66.42), vec4(54.906, 55.115, 3.19, 66.37), vec4(54.928, 56.896, 6.90, 63.35), vec4(54.928, 56.921, 6.90, 66.35), vec4(55.206, 55.278, 3.19, 63.40), \n    vec4(55.206, 55.313, 3.19, 59.34), vec4(55.206, 55.419, 2.43, 75.10), vec4(55.206, 55.456, 5.11, 75.37), vec4(55.206, 55.413, 5.11, 87.46), vec4(55.206, 55.253, 3.19, 66.33), \n    vec4(55.206, 55.384, 0.50, 35.06), vec4(55.228, 57.600, 7.50, 63.50), vec4(55.228, 57.646, 7.50, 59.50), vec4(55.356, 55.571, 3.19, 63.43), vec4(55.356, 55.603, 3.19, 59.36), \n    vec4(55.356, 55.565, 3.19, 66.40), vec4(55.506, 55.715, 2.43, 73.06), vec4(55.506, 55.609, 3.82, 66.35), vec4(55.506, 55.609, 3.82, 63.36), vec4(55.506, 55.619, 3.82, 59.31), \n    vec4(55.506, 55.703, 5.11, 85.41), vec4(55.506, 55.719, 5.11, 73.44), vec4(55.656, 55.753, 0.50, 35.12), vec4(55.656, 55.709, 3.19, 66.39), vec4(55.656, 55.731, 3.19, 63.43), \n    vec4(55.656, 55.746, 3.19, 59.36), vec4(55.806, 56.059, 2.43, 73.14), vec4(55.806, 55.946, 0.50, 35.10), vec4(55.806, 56.094, 5.11, 85.44), vec4(55.806, 56.088, 5.11, 73.41), \n    vec4(55.806, 56.059, 3.19, 59.38), vec4(55.806, 56.034, 3.19, 66.40), vec4(55.806, 56.031, 3.19, 63.36), vec4(56.106, 56.363, 3.19, 59.38), vec4(56.106, 56.221, 3.82, 63.39), \n    vec4(56.106, 56.231, 3.82, 66.37), vec4(56.106, 56.231, 3.82, 59.34), vec4(56.106, 56.325, 2.43, 71.14), vec4(56.106, 56.359, 5.11, 71.38), vec4(56.106, 56.346, 5.11, 83.42), \n    vec4(56.106, 56.306, 3.19, 63.37), vec4(56.106, 56.306, 3.19, 66.41), vec4(56.406, 56.688, 5.11, 83.37), vec4(56.406, 56.646, 5.11, 71.51), vec4(56.406, 56.684, 2.43, 71.07), \n    vec4(56.406, 56.496, 3.19, 66.39), vec4(56.406, 56.509, 3.19, 63.38), vec4(56.406, 56.506, 3.19, 59.39), vec4(56.406, 56.569, 0.50, 35.03), vec4(56.556, 56.803, 3.19, 66.41), \n    vec4(56.556, 56.813, 3.19, 59.39), vec4(56.556, 56.794, 3.19, 63.39), vec4(56.706, 56.940, 2.43, 69.07), vec4(56.706, 56.831, 3.82, 66.39), vec4(56.706, 56.834, 3.82, 59.35), \n    vec4(56.706, 56.831, 3.82, 63.42), vec4(56.706, 56.925, 5.11, 69.39), vec4(56.706, 56.928, 5.11, 81.35), vec4(56.856, 56.953, 0.50, 35.13), vec4(56.856, 56.956, 3.19, 59.32), \n    vec4(56.856, 56.934, 3.19, 63.36), vec4(56.856, 56.919, 3.19, 66.39), vec4(57.006, 57.159, 0.50, 35.04), vec4(57.006, 57.263, 3.19, 59.31), vec4(57.006, 57.284, 2.43, 69.08), \n    vec4(57.006, 57.244, 3.19, 66.43), vec4(57.006, 57.281, 5.11, 81.40), vec4(57.006, 57.300, 5.11, 69.39), vec4(57.006, 57.234, 3.19, 63.39), vec4(57.306, 57.559, 3.19, 59.32), \n    vec4(57.306, 57.634, 2.43, 66.09), vec4(57.306, 57.528, 3.19, 66.42), vec4(57.306, 57.600, 5.11, 66.37), vec4(57.306, 57.600, 5.11, 78.43), vec4(57.306, 57.506, 3.19, 63.38), \n    vec4(57.306, 57.431, 3.82, 63.40), vec4(57.306, 57.434, 3.82, 66.39), vec4(57.306, 57.434, 3.82, 59.35), vec4(57.606, 57.771, 0.50, 37.06), vec4(57.606, 58.178, 5.11, 76.37), \n    vec4(57.606, 58.196, 2.43, 64.13), vec4(57.606, 58.121, 5.11, 64.42), vec4(57.606, 57.684, 3.19, 64.38), vec4(57.606, 57.703, 3.19, 68.33), vec4(57.606, 57.706, 3.19, 61.34), \n    vec4(57.628, 58.871, 7.50, 64.50), vec4(57.628, 60.053, 7.50, 61.50), vec4(57.628, 58.859, 7.50, 68.50), vec4(57.756, 57.934, 3.19, 68.38), vec4(57.756, 57.956, 3.19, 64.39), \n    vec4(57.756, 57.975, 3.19, 61.39), vec4(57.906, 58.006, 3.82, 64.28), vec4(57.906, 58.015, 3.82, 61.36), vec4(57.906, 58.019, 3.82, 68.37), vec4(58.056, 58.153, 0.50, 37.30), \n    vec4(58.056, 58.134, 3.19, 68.37), vec4(58.056, 58.153, 3.19, 64.39), vec4(58.056, 58.153, 3.19, 61.39), vec4(58.206, 58.463, 3.19, 64.39), vec4(58.206, 58.463, 3.19, 61.38), \n    vec4(58.206, 58.453, 3.19, 68.37), vec4(58.206, 59.828, 5.11, 88.45), vec4(58.206, 59.840, 5.11, 76.40), vec4(58.206, 58.309, 0.50, 37.06), vec4(58.206, 59.438, 2.43, 76.02), \n    vec4(58.506, 58.763, 3.19, 68.37), vec4(58.506, 58.763, 3.19, 64.39), vec4(58.506, 58.763, 3.19, 61.38), vec4(58.506, 58.631, 3.82, 61.36), vec4(58.506, 58.628, 3.82, 64.29), \n    vec4(58.506, 58.613, 3.82, 68.37), vec4(58.528, 58.634, 6.90, 73.22), vec4(58.678, 58.765, 6.90, 75.29), vec4(58.806, 59.344, 0.50, 42.10), vec4(58.806, 58.888, 3.19, 66.37), \n    vec4(58.806, 58.919, 3.19, 61.39), vec4(58.806, 58.913, 3.19, 70.37), vec4(58.828, 60.013, 7.50, 70.50), vec4(58.828, 60.044, 7.50, 66.50), vec4(58.828, 58.915, 6.90, 76.24), \n    vec4(58.956, 59.213, 3.19, 70.40), vec4(58.956, 59.213, 3.19, 66.36), vec4(58.956, 59.213, 3.19, 61.40), vec4(58.978, 59.096, 6.90, 76.32), vec4(59.106, 59.215, 3.82, 58.38), \n    vec4(59.106, 59.219, 3.82, 66.39), vec4(59.106, 59.196, 3.82, 61.31), vec4(59.256, 59.338, 3.19, 70.40), vec4(59.256, 59.340, 3.19, 66.38), vec4(59.256, 59.356, 3.19, 61.39), \n    vec4(59.278, 59.415, 6.90, 76.29), vec4(59.406, 59.638, 3.19, 70.36), vec4(59.406, 59.759, 0.50, 42.14), vec4(59.406, 59.663, 3.19, 61.39), vec4(59.406, 59.663, 3.19, 66.35), \n    vec4(59.578, 59.665, 6.90, 75.28), vec4(59.706, 59.934, 3.19, 61.39), vec4(59.706, 59.828, 3.82, 61.31), vec4(59.706, 59.828, 3.82, 58.37), vec4(59.706, 59.944, 3.19, 70.39), \n    vec4(59.706, 59.859, 3.82, 66.35), vec4(59.706, 59.953, 3.19, 66.38), vec4(59.728, 61.659, 6.90, 76.30), vec4(60.006, 60.106, 3.19, 64.34), vec4(60.006, 60.131, 3.19, 59.28), \n    vec4(60.006, 60.850, 2.43, 80.04), vec4(60.006, 60.103, 3.19, 68.31), vec4(60.006, 60.871, 5.11, 92.41), vec4(60.006, 60.871, 5.11, 80.37), vec4(60.006, 60.209, 0.50, 35.03), \n    vec4(60.028, 70.790, 7.50, 64.50), vec4(60.028, 62.428, 7.50, 71.50), vec4(60.028, 62.428, 7.50, 68.50), vec4(60.156, 60.413, 3.19, 59.35), vec4(60.156, 60.400, 3.19, 64.39), \n    vec4(60.156, 60.396, 3.19, 68.41), vec4(60.306, 60.438, 3.82, 68.36), vec4(60.306, 60.431, 3.82, 64.33), vec4(60.306, 60.450, 3.82, 59.28), vec4(60.456, 60.515, 3.19, 68.43), \n    vec4(60.456, 60.546, 3.19, 64.36), vec4(60.456, 60.559, 3.19, 59.34), vec4(60.606, 60.863, 3.19, 59.35), vec4(60.606, 60.853, 3.19, 64.38), vec4(60.606, 60.865, 0.50, 35.05), \n    vec4(60.606, 60.838, 3.19, 68.35), vec4(60.906, 61.034, 3.82, 64.32), vec4(60.906, 61.125, 2.43, 76.06), vec4(60.906, 61.113, 5.11, 88.40), vec4(60.906, 61.134, 5.11, 76.46), \n    vec4(60.906, 61.038, 3.82, 68.37), vec4(60.906, 61.163, 3.19, 59.34), vec4(60.906, 61.163, 3.19, 64.38), vec4(60.906, 61.163, 3.19, 68.35), vec4(60.906, 61.034, 3.82, 59.30), \n    vec4(61.206, 61.288, 3.19, 59.36), vec4(61.206, 61.428, 2.43, 76.06), vec4(61.206, 61.446, 5.11, 88.34), vec4(61.206, 61.444, 5.11, 76.38), vec4(61.206, 61.494, 0.50, 35.10), \n    vec4(61.206, 61.284, 3.19, 64.40), vec4(61.356, 61.609, 3.19, 68.40), vec4(61.356, 61.613, 3.19, 64.36), vec4(61.356, 61.613, 3.19, 59.32), vec4(61.506, 61.703, 5.11, 83.41), \n    vec4(61.506, 61.621, 3.82, 64.32), vec4(61.506, 61.640, 3.82, 68.38), vec4(61.506, 61.640, 3.82, 59.30), vec4(61.506, 61.725, 2.43, 71.10), vec4(61.506, 61.725, 5.11, 71.43), \n    vec4(61.656, 61.765, 3.19, 59.34), vec4(61.656, 61.728, 3.19, 64.39), vec4(61.656, 61.706, 3.19, 68.43), vec4(61.806, 62.134, 2.43, 71.09), vec4(61.806, 62.063, 3.19, 68.34), \n    vec4(61.806, 62.100, 5.11, 83.39), vec4(61.806, 62.063, 3.19, 64.38), vec4(61.806, 62.090, 5.11, 71.38), vec4(61.806, 62.009, 0.50, 47.07), vec4(61.806, 62.063, 3.19, 59.33), \n    vec4(62.106, 62.390, 5.11, 80.40), vec4(62.106, 62.328, 5.11, 68.51), vec4(62.106, 62.363, 3.19, 64.38), vec4(62.106, 62.406, 2.43, 68.09), vec4(62.106, 62.363, 3.19, 59.35), \n    vec4(62.106, 62.331, 0.50, 35.06), vec4(62.106, 62.363, 3.19, 68.36), vec4(62.106, 62.256, 3.82, 68.31), vec4(62.106, 62.231, 3.82, 59.30), vec4(62.106, 62.209, 3.82, 64.32), \n    vec4(62.406, 63.600, 5.11, 69.38), vec4(62.406, 63.600, 5.11, 81.42), vec4(62.406, 62.531, 3.19, 64.34), vec4(62.406, 62.525, 3.19, 57.34), vec4(62.406, 62.509, 3.19, 61.40), \n    vec4(62.406, 63.628, 2.43, 73.10), vec4(62.406, 62.909, 0.50, 33.00), vec4(62.428, 63.603, 7.50, 57.50), vec4(62.428, 64.784, 7.50, 61.50), vec4(62.556, 62.813, 3.19, 57.34), \n    vec4(62.556, 62.765, 3.19, 61.46), vec4(62.556, 62.796, 3.19, 64.33), vec4(62.706, 62.815, 3.82, 64.35), vec4(62.706, 62.821, 3.82, 61.35), vec4(62.706, 62.828, 3.82, 69.29), \n    vec4(62.856, 62.919, 3.19, 61.42), vec4(62.856, 62.965, 3.19, 57.36), vec4(62.856, 62.940, 3.19, 64.35), vec4(63.006, 63.263, 3.19, 57.35), vec4(63.006, 63.550, 0.50, 45.04), \n    vec4(63.006, 63.240, 3.19, 61.35), vec4(63.006, 63.263, 3.19, 64.35), vec4(63.306, 63.563, 3.19, 57.35), vec4(63.306, 63.563, 3.19, 64.35), vec4(63.306, 63.450, 3.82, 69.30), \n    vec4(63.306, 63.434, 3.82, 64.35), vec4(63.306, 63.421, 3.82, 61.35), vec4(63.306, 63.528, 3.19, 61.37), vec4(63.606, 64.759, 5.11, 82.45), vec4(63.606, 64.753, 5.11, 70.43), \n    vec4(63.606, 64.113, 0.50, 30.09), vec4(63.606, 63.709, 3.19, 64.35), vec4(63.606, 63.690, 3.19, 61.39), vec4(63.606, 63.688, 3.19, 58.39), vec4(63.606, 64.471, 2.43, 76.11), \n    vec4(63.628, 64.846, 7.50, 58.50), vec4(63.756, 64.013, 3.19, 58.41), vec4(63.756, 63.984, 3.19, 64.35), vec4(63.756, 63.940, 3.19, 61.39), vec4(63.906, 64.056, 3.82, 70.33), \n    vec4(63.906, 64.015, 3.82, 61.35), vec4(63.906, 64.013, 3.82, 64.34), vec4(64.056, 64.150, 3.19, 58.34), vec4(64.056, 64.131, 3.19, 64.35), vec4(64.206, 64.446, 0.50, 30.04), \n    vec4(64.206, 64.415, 3.19, 61.35), vec4(64.206, 64.463, 3.19, 64.34), vec4(64.206, 64.463, 3.19, 58.38), vec4(64.506, 64.759, 0.50, 34.10), vec4(64.506, 64.634, 3.82, 61.35), \n    vec4(64.506, 64.734, 3.19, 64.35), vec4(64.506, 64.625, 3.82, 64.28), vec4(64.506, 64.763, 3.19, 58.40), vec4(64.506, 64.650, 3.82, 70.36), vec4(64.506, 64.709, 3.19, 61.36), \n    vec4(64.806, 65.003, 0.50, 35.09), vec4(64.806, 71.188, 5.11, 83.44), vec4(64.806, 65.396, 2.43, 76.03), vec4(64.806, 71.184, 5.11, 71.47), vec4(64.806, 64.915, 3.19, 59.39), \n    vec4(64.806, 64.890, 3.19, 64.36), vec4(64.828, 70.790, 7.50, 68.50), vec4(64.828, 71.628, 7.50, 59.50), vec4(64.956, 65.131, 3.19, 68.39), vec4(64.956, 65.144, 3.19, 64.39), \n    vec4(64.956, 65.213, 3.19, 59.37), vec4(65.106, 65.246, 3.82, 64.33), vec4(65.106, 65.259, 3.82, 71.32), vec4(65.106, 65.259, 3.82, 68.29), vec4(65.128, 65.271, 6.90, 64.49), \n    vec4(65.128, 65.271, 6.90, 71.42), vec4(65.256, 65.375, 3.19, 59.35), vec4(65.256, 65.350, 0.50, 35.09), vec4(65.256, 65.346, 3.19, 64.34), vec4(65.256, 65.290, 3.19, 68.44), \n    vec4(65.278, 65.571, 6.90, 64.46), vec4(65.278, 65.571, 6.90, 71.46), vec4(65.406, 65.663, 3.19, 59.38), vec4(65.406, 65.594, 0.50, 35.07), vec4(65.406, 65.853, 2.43, 71.12), \n    vec4(65.406, 65.653, 3.19, 68.37), vec4(65.406, 65.663, 3.19, 64.33), vec4(65.578, 65.721, 6.90, 71.46), vec4(65.578, 65.721, 6.90, 64.45), vec4(65.706, 65.856, 3.82, 68.35), \n    vec4(65.706, 65.963, 3.19, 64.35), vec4(65.706, 65.963, 3.19, 68.39), vec4(65.706, 65.844, 3.82, 71.33), vec4(65.706, 65.850, 3.82, 64.35), vec4(65.706, 65.963, 3.19, 59.38), \n    vec4(65.728, 66.321, 6.90, 71.42), vec4(65.728, 66.321, 6.90, 64.43), vec4(66.006, 66.556, 4.58, 88.11), vec4(66.006, 66.121, 3.19, 59.39), vec4(66.006, 66.078, 3.19, 68.40), \n    vec4(66.006, 66.196, 0.50, 35.10), vec4(66.006, 66.575, 4.58, 76.06), vec4(66.006, 66.103, 3.19, 64.35), vec4(66.156, 66.384, 3.19, 68.41), vec4(66.156, 66.384, 3.19, 64.38), \n    vec4(66.156, 66.413, 3.19, 59.39), vec4(66.306, 66.434, 3.82, 68.36), vec4(66.306, 66.421, 3.82, 71.34), vec4(66.306, 66.431, 3.82, 64.35), vec4(66.328, 66.471, 6.90, 71.40), \n    vec4(66.328, 66.471, 6.90, 64.46), vec4(66.456, 66.546, 0.50, 35.07), vec4(66.456, 66.578, 3.19, 59.31), vec4(66.456, 66.559, 3.19, 68.39), vec4(66.456, 66.546, 3.19, 64.36), \n    vec4(66.478, 66.771, 6.90, 64.45), vec4(66.478, 66.771, 6.90, 71.44), vec4(66.606, 66.721, 0.50, 35.06), vec4(66.606, 66.859, 3.19, 64.36), vec4(66.606, 66.859, 3.19, 68.43), \n    vec4(66.606, 66.990, 4.58, 83.17), vec4(66.606, 66.981, 4.58, 71.17), vec4(66.606, 66.863, 3.19, 59.32), vec4(66.756, 66.878, 0.50, 47.13), vec4(66.778, 66.921, 6.90, 71.46), \n    vec4(66.778, 66.921, 6.90, 64.44), vec4(66.906, 67.038, 3.82, 64.28), vec4(66.906, 67.163, 3.19, 59.34), vec4(66.906, 67.028, 3.82, 71.35), vec4(66.906, 67.150, 3.19, 64.38), \n    vec4(66.906, 67.138, 3.19, 68.42), vec4(66.906, 67.046, 0.50, 35.04), vec4(66.906, 67.040, 3.82, 68.36), vec4(66.928, 67.521, 6.90, 64.48), vec4(66.928, 67.521, 6.90, 71.39), \n    vec4(67.206, 67.290, 3.19, 64.39), vec4(67.206, 67.315, 3.19, 59.35), vec4(67.206, 67.813, 2.43, 76.13), vec4(67.206, 67.388, 0.50, 35.09), vec4(67.356, 67.613, 3.19, 64.39), \n    vec4(67.356, 67.596, 3.19, 68.40), vec4(67.356, 67.613, 3.19, 59.39), vec4(67.506, 67.640, 3.82, 64.29), vec4(67.506, 67.646, 3.82, 71.36), vec4(67.506, 67.656, 3.82, 68.37), \n    vec4(67.528, 67.671, 6.90, 64.44), vec4(67.528, 67.671, 6.90, 71.46), vec4(67.656, 67.778, 3.19, 59.31), vec4(67.656, 67.750, 3.19, 64.37), vec4(67.656, 67.728, 3.19, 68.40), \n    vec4(67.656, 67.759, 0.50, 35.06), vec4(67.678, 67.971, 6.90, 64.44), vec4(67.678, 67.971, 6.90, 71.43), vec4(67.806, 68.063, 3.19, 64.37), vec4(67.806, 68.359, 2.43, 71.09), \n    vec4(67.806, 67.984, 0.50, 35.07), vec4(67.806, 68.063, 3.19, 68.42), vec4(67.806, 68.063, 3.19, 59.34), vec4(67.978, 68.121, 6.90, 71.43), vec4(67.978, 68.121, 6.90, 64.47), \n    vec4(68.106, 68.225, 3.82, 64.31), vec4(68.106, 68.240, 3.82, 68.35), vec4(68.106, 68.363, 3.19, 59.33), vec4(68.106, 68.321, 3.19, 64.37), vec4(68.106, 68.321, 3.19, 68.42), \n    vec4(68.106, 68.215, 3.82, 71.36), vec4(68.128, 68.721, 6.90, 64.46), vec4(68.128, 68.721, 6.90, 71.39), vec4(68.406, 68.459, 3.19, 68.39), vec4(68.406, 68.915, 4.58, 88.06), \n    vec4(68.406, 68.946, 4.58, 76.10), vec4(68.406, 68.571, 0.50, 35.07), vec4(68.406, 68.515, 3.19, 59.33), vec4(68.406, 68.490, 3.19, 64.37), vec4(68.556, 68.806, 3.19, 59.35), \n    vec4(68.556, 68.778, 3.19, 64.40), vec4(68.556, 68.778, 3.19, 68.35), vec4(68.706, 68.821, 3.82, 64.30), vec4(68.706, 68.846, 3.82, 68.36), vec4(68.706, 68.819, 3.82, 71.29), \n    vec4(68.728, 68.871, 6.90, 71.44), vec4(68.728, 68.871, 6.90, 64.46), vec4(68.856, 68.950, 0.50, 35.05), vec4(68.856, 68.921, 3.19, 68.35), vec4(68.856, 68.944, 3.19, 64.38), \n    vec4(68.856, 68.956, 3.19, 59.34), vec4(68.878, 69.171, 6.90, 71.43), vec4(68.878, 69.171, 6.90, 64.43), vec4(69.006, 69.425, 4.58, 71.20), vec4(69.006, 69.431, 4.58, 83.16), \n    vec4(69.006, 69.246, 3.19, 68.37), vec4(69.006, 69.246, 3.19, 64.39), vec4(69.006, 69.263, 3.19, 59.35), vec4(69.006, 69.100, 0.50, 35.02), vec4(69.156, 69.263, 0.50, 47.11), \n    vec4(69.178, 69.321, 6.90, 64.50), vec4(69.178, 69.321, 6.90, 71.43), vec4(69.306, 69.515, 3.19, 64.41), vec4(69.306, 69.563, 3.19, 59.36), vec4(69.306, 69.453, 0.50, 35.01), \n    vec4(69.306, 69.413, 3.82, 71.31), vec4(69.306, 69.421, 3.82, 68.40), vec4(69.306, 69.500, 3.19, 68.38), vec4(69.306, 69.428, 3.82, 64.31), vec4(69.328, 69.621, 6.90, 71.48), \n    vec4(69.328, 69.621, 6.90, 64.47), vec4(69.606, 70.344, 0.50, 35.06), vec4(69.606, 70.650, 3.19, 59.36), vec4(69.606, 70.146, 2.43, 80.03), vec4(69.606, 70.594, 3.82, 71.32), \n    vec4(69.606, 70.634, 3.82, 68.40), vec4(69.606, 70.650, 3.82, 64.33), vec4(69.606, 70.650, 3.19, 68.41), vec4(69.606, 70.650, 3.19, 64.41), vec4(69.628, 70.840, 6.90, 71.43), \n    vec4(69.628, 70.846, 6.90, 64.41), vec4(70.206, 70.569, 2.43, 76.08), vec4(70.506, 70.678, 0.50, 35.13), vec4(70.656, 70.756, 2.43, 71.13), vec4(70.788, 70.871, 1.50, 100.33), \n    vec4(70.806, 71.834, 3.82, 63.39), vec4(70.806, 72.169, 3.19, 59.38), vec4(70.806, 71.015, 0.50, 35.08), vec4(70.806, 71.025, 2.43, 75.13), vec4(70.806, 72.250, 3.19, 63.41), \n    vec4(70.806, 72.240, 3.19, 66.47), vec4(70.806, 71.819, 3.82, 66.43), vec4(70.806, 71.846, 3.82, 71.37), vec4(70.828, 71.594, 7.50, 66.50), vec4(70.828, 71.628, 7.50, 63.50), \n    vec4(70.850, 70.946, 1.50, 97.56), vec4(70.934, 71.028, 1.50, 95.47), vec4(71.006, 71.084, 1.50, 93.54), vec4(71.065, 71.144, 1.50, 92.54), vec4(71.106, 71.340, 2.43, 75.06), \n    vec4(71.134, 71.215, 1.50, 88.43), vec4(71.196, 71.278, 1.50, 85.49), vec4(71.263, 71.340, 1.50, 83.49), vec4(71.321, 71.390, 1.50, 81.50), vec4(71.378, 71.446, 1.50, 80.52), \n    vec4(71.406, 71.678, 2.43, 76.09), vec4(71.438, 71.521, 1.50, 76.46), vec4(71.503, 71.588, 1.50, 73.50), vec4(71.581, 71.671, 1.50, 71.52), vec4(71.653, 71.734, 1.50, 69.50), \n    vec4(71.706, 71.875, 2.43, 78.23), vec4(71.715, 71.803, 1.50, 68.51), vec4(71.796, 71.909, 1.50, 64.51), vec4(71.856, 73.266, 2.43, 76.09), vec4(71.913, 71.990, 1.50, 61.55), \n    vec4(72.006, 72.109, 1.50, 59.54), vec4(72.006, 72.190, 3.82, 59.32), vec4(72.006, 72.146, 3.82, 68.38), vec4(72.006, 72.131, 3.82, 64.37), vec4(72.006, 72.150, 0.50, 28.09), \n    vec4(72.006, 72.181, 3.19, 64.37), vec4(72.006, 72.150, 3.19, 56.36), vec4(72.456, 72.528, 3.19, 56.38), vec4(72.456, 72.550, 3.82, 59.32), vec4(72.456, 72.525, 3.82, 68.38), \n    vec4(72.456, 72.546, 3.19, 59.32), vec4(72.456, 72.531, 0.50, 28.10), vec4(72.456, 72.538, 3.82, 64.31), vec4(72.456, 72.550, 3.19, 64.35), vec4(72.606, 72.740, 3.19, 56.37), \n    vec4(72.606, 72.734, 3.82, 68.36), vec4(72.606, 72.725, 3.19, 64.39), vec4(72.606, 72.740, 0.50, 28.12), vec4(72.606, 72.740, 3.19, 59.32), vec4(72.606, 72.753, 3.82, 59.35), \n    vec4(72.606, 72.721, 3.82, 64.31), vec4(73.206, 73.340, 3.19, 59.31), vec4(73.206, 73.334, 0.50, 28.10), vec4(73.206, 73.313, 3.82, 64.31), vec4(73.206, 73.369, 3.82, 59.32), \n    vec4(73.206, 73.353, 3.82, 68.35), vec4(73.206, 73.356, 3.19, 56.39), vec4(73.206, 73.359, 3.19, 64.35), vec4(73.656, 73.759, 0.50, 28.11), vec4(73.656, 73.746, 3.82, 68.35), \n    vec4(73.656, 73.725, 3.19, 56.31), vec4(73.656, 73.740, 3.82, 64.31), vec4(73.656, 73.744, 3.82, 59.35), vec4(73.656, 73.744, 3.19, 59.34), vec4(73.656, 73.731, 3.19, 64.36), \n    vec4(73.806, 73.934, 3.19, 59.34), vec4(73.806, 73.925, 3.19, 56.32), vec4(73.806, 73.940, 3.82, 64.34), vec4(73.806, 73.953, 3.82, 59.28), vec4(73.806, 73.959, 3.82, 68.38), \n    vec4(73.806, 73.953, 0.50, 28.09), vec4(73.806, 73.913, 3.19, 64.37), vec4(74.406, 74.569, 0.50, 28.11), vec4(74.406, 74.544, 3.19, 59.35), vec4(74.406, 74.581, 3.82, 59.28), \n    vec4(74.406, 74.503, 3.82, 64.31), vec4(74.406, 74.550, 3.82, 68.35), vec4(74.406, 74.531, 3.19, 56.34), vec4(74.406, 74.534, 3.19, 64.38), vec4(74.856, 74.965, 0.50, 28.11), \n    vec4(74.856, 74.946, 3.82, 59.28), vec4(74.856, 74.940, 3.82, 64.31), vec4(74.856, 74.931, 3.19, 64.34), vec4(74.856, 74.934, 3.19, 59.35), vec4(74.856, 74.931, 3.82, 68.38), \n    vec4(74.856, 74.928, 3.19, 56.33), vec4(75.006, 75.115, 3.19, 59.35), vec4(75.006, 75.175, 0.50, 28.10), vec4(75.006, 75.134, 3.19, 64.33), vec4(75.006, 75.134, 3.19, 56.35), \n    vec4(75.006, 75.103, 3.82, 64.34), vec4(75.006, 75.125, 3.82, 68.38), vec4(75.006, 75.134, 3.82, 59.29), vec4(75.588, 75.671, 1.50, 100.36), vec4(75.606, 75.725, 3.82, 64.33), \n    vec4(75.606, 75.746, 3.82, 68.32), vec4(75.606, 75.740, 0.50, 28.10), vec4(75.606, 75.753, 3.19, 64.31), vec4(75.606, 75.750, 3.19, 59.34), vec4(75.606, 75.765, 3.82, 59.28), \n    vec4(75.606, 75.765, 3.19, 56.32), vec4(75.650, 75.746, 1.50, 97.53), vec4(75.734, 75.828, 1.50, 95.51), vec4(75.806, 75.884, 1.50, 93.50), vec4(75.865, 75.944, 1.50, 92.51), \n    vec4(75.934, 76.015, 1.50, 88.46), vec4(75.996, 76.078, 1.50, 85.46), vec4(76.056, 76.165, 0.50, 28.13), vec4(76.056, 76.144, 3.19, 59.37), vec4(76.056, 76.128, 3.82, 64.35), \n    vec4(76.056, 76.134, 3.82, 68.33), vec4(76.056, 76.156, 3.82, 59.30), vec4(76.056, 76.125, 3.19, 56.35), vec4(76.056, 76.113, 3.19, 64.38), vec4(76.063, 76.140, 1.50, 83.46), \n    vec4(76.121, 76.190, 1.50, 81.54), vec4(76.178, 76.246, 1.50, 80.49), vec4(76.206, 76.346, 3.82, 68.34), vec4(76.206, 76.371, 0.50, 28.09), vec4(76.206, 76.319, 3.19, 56.35), \n    vec4(76.206, 76.331, 3.19, 64.35), vec4(76.206, 76.334, 3.19, 59.31), vec4(76.206, 76.338, 3.82, 59.30), vec4(76.206, 76.306, 3.82, 64.35), vec4(76.238, 76.321, 1.50, 76.49), \n    vec4(76.303, 76.388, 1.50, 73.53), vec4(76.381, 76.471, 1.50, 71.49), vec4(76.453, 76.534, 1.50, 69.54), vec4(76.515, 76.603, 1.50, 68.48), vec4(76.596, 76.709, 1.50, 64.47), \n    vec4(76.713, 76.790, 1.50, 61.58), vec4(76.806, 78.996, 3.19, 64.34), vec4(76.806, 79.028, 3.82, 64.35), vec4(76.806, 79.050, 3.82, 68.35), vec4(76.806, 79.056, 3.82, 59.31), \n    vec4(76.806, 76.909, 1.50, 59.50), vec4(76.806, 79.078, 0.50, 35.13), vec4(76.806, 78.994, 3.19, 59.31), vec4(76.806, 78.994, 3.19, 56.36), vec4(77.106, 77.346, 2.43, 59.09), \n    vec4(77.406, 77.744, 2.43, 64.14), vec4(77.706, 78.019, 2.43, 68.10), vec4(78.006, 78.328, 2.43, 73.09), vec4(78.306, 78.640, 2.43, 71.17), vec4(78.606, 78.903, 2.43, 68.13), \n    vec4(78.906, 79.219, 2.43, 64.17), vec4(79.206, 79.356, 3.82, 63.35), vec4(79.206, 79.340, 3.82, 71.32), vec4(79.206, 79.403, 0.50, 35.06), vec4(79.206, 79.331, 3.82, 66.32), \n    vec4(79.206, 80.844, 2.43, 66.18), vec4(79.206, 79.328, 3.19, 63.39), vec4(79.206, 79.353, 3.19, 54.38), vec4(79.206, 79.340, 3.19, 59.31), vec4(79.656, 79.725, 3.82, 66.34), \n    vec4(79.656, 79.709, 3.82, 63.38), vec4(79.656, 79.721, 3.82, 71.34), vec4(79.656, 79.734, 3.19, 59.30), vec4(79.656, 79.709, 3.19, 63.39), vec4(79.656, 79.734, 0.50, 35.13), \n    vec4(79.656, 79.740, 3.19, 54.38), vec4(79.806, 79.909, 3.19, 63.39), vec4(79.806, 79.931, 3.82, 63.37), vec4(79.806, 79.928, 3.82, 71.31), vec4(79.806, 79.919, 3.82, 66.33), \n    vec4(79.806, 79.953, 0.50, 35.06), vec4(79.806, 79.944, 3.19, 54.35), vec4(79.806, 79.913, 3.19, 59.30), vec4(80.406, 80.503, 3.19, 63.35), vec4(80.406, 80.521, 3.82, 71.31), \n    vec4(80.406, 80.550, 0.50, 35.05), vec4(80.406, 80.563, 3.19, 54.31), vec4(80.406, 80.506, 3.82, 66.33), vec4(80.406, 80.500, 3.19, 59.31), vec4(80.406, 80.531, 3.82, 63.36), \n    vec4(80.856, 80.965, 3.82, 63.30), vec4(80.856, 80.946, 0.50, 35.11), vec4(80.856, 80.971, 3.82, 66.36), vec4(80.856, 80.953, 3.19, 63.39), vec4(80.856, 80.996, 3.19, 54.37), \n    vec4(80.856, 80.928, 3.82, 71.35), vec4(80.856, 81.059, 3.19, 59.31), vec4(81.006, 81.538, 3.19, 53.32), vec4(81.006, 81.538, 3.19, 58.40), vec4(81.006, 81.521, 3.19, 62.35), \n    vec4(81.006, 81.571, 3.82, 62.28), vec4(81.006, 81.521, 3.82, 65.32), vec4(81.006, 81.490, 3.82, 70.36), vec4(81.006, 81.494, 0.50, 34.08), vec4(81.606, 81.721, 3.82, 69.34), \n    vec4(81.606, 81.759, 3.82, 61.35), vec4(81.606, 81.753, 3.19, 52.32), vec4(81.606, 81.800, 0.50, 33.02), vec4(81.606, 81.731, 3.19, 61.37), vec4(81.606, 81.684, 3.82, 64.38), \n    vec4(81.606, 81.759, 3.19, 57.39), vec4(81.906, 82.181, 2.43, 59.05), vec4(82.056, 82.128, 3.19, 57.32), vec4(82.056, 82.146, 3.19, 52.31), vec4(82.056, 82.125, 3.19, 61.31), \n    vec4(82.056, 82.153, 0.50, 33.10), vec4(82.056, 82.131, 3.82, 64.36), vec4(82.056, 82.156, 3.82, 69.28), vec4(82.056, 82.109, 3.82, 61.34), vec4(82.206, 82.315, 3.19, 57.34), \n    vec4(82.206, 82.315, 3.19, 61.34), vec4(82.206, 82.434, 2.43, 61.13), vec4(82.206, 82.334, 3.82, 69.26), vec4(82.206, 82.359, 3.19, 52.36), vec4(82.206, 82.328, 3.82, 64.35), \n    vec4(82.206, 82.321, 3.82, 61.31), vec4(82.206, 82.359, 0.50, 33.01), vec4(82.506, 82.784, 2.43, 64.10), vec4(82.806, 82.921, 3.19, 61.32), vec4(82.806, 82.934, 3.82, 64.35), \n    vec4(82.806, 82.940, 3.82, 69.28), vec4(82.806, 82.956, 3.82, 61.32), vec4(82.806, 82.965, 3.19, 52.31), vec4(82.806, 82.928, 3.19, 57.33), vec4(82.806, 83.088, 2.43, 69.07), \n    vec4(82.806, 82.990, 0.50, 33.08), vec4(83.106, 83.403, 2.43, 68.18), vec4(83.256, 83.325, 3.19, 57.29), vec4(83.256, 83.325, 3.19, 61.37), vec4(83.256, 83.334, 3.82, 64.34), \n    vec4(83.256, 83.338, 3.82, 69.28), vec4(83.256, 83.334, 0.50, 33.12), vec4(83.256, 83.344, 3.19, 52.35), vec4(83.256, 83.328, 3.82, 61.34), vec4(83.406, 83.553, 3.19, 52.34), \n    vec4(83.406, 83.540, 3.82, 64.36), vec4(83.406, 83.559, 3.82, 61.35), vec4(83.406, 83.581, 0.50, 33.06), vec4(83.406, 83.569, 3.82, 69.31), vec4(83.406, 83.521, 3.19, 61.32), \n    vec4(83.406, 83.521, 3.19, 57.28), vec4(83.406, 83.715, 2.43, 66.17), vec4(83.706, 84.000, 2.43, 73.16), vec4(84.006, 85.806, 2.43, 71.14), vec4(84.006, 84.131, 3.19, 59.30), \n    vec4(84.006, 84.175, 0.50, 40.10), vec4(84.006, 84.134, 3.19, 56.35), vec4(84.006, 84.146, 3.82, 68.32), vec4(84.006, 84.169, 3.82, 59.32), vec4(84.006, 84.134, 3.19, 64.32), \n    vec4(84.006, 84.125, 3.82, 64.35), vec4(84.456, 84.540, 0.50, 40.11), vec4(84.456, 84.546, 3.19, 59.31), vec4(84.456, 84.559, 3.82, 59.33), vec4(84.456, 84.538, 3.82, 64.31), \n    vec4(84.456, 84.515, 3.82, 68.38), vec4(84.456, 84.528, 3.19, 56.39), vec4(84.456, 84.525, 3.19, 64.36), vec4(84.606, 84.746, 0.50, 40.12), vec4(84.606, 84.734, 3.19, 56.31), \n    vec4(84.606, 84.750, 3.82, 59.33), vec4(84.606, 84.728, 3.82, 68.35), vec4(84.606, 84.715, 3.82, 64.31), vec4(84.606, 84.719, 3.19, 59.31), vec4(84.606, 84.725, 3.19, 64.34), \n    vec4(85.206, 85.331, 3.19, 56.29), vec4(85.206, 85.315, 3.19, 64.34), vec4(85.206, 85.309, 3.82, 64.31), vec4(85.206, 85.328, 3.19, 59.30), vec4(85.206, 85.365, 3.82, 59.35), \n    vec4(85.206, 85.334, 0.50, 40.09), vec4(85.206, 85.315, 3.82, 68.35), vec4(85.656, 85.738, 3.19, 56.31), vec4(85.656, 85.753, 3.19, 59.31), vec4(85.656, 85.756, 3.19, 64.35), \n    vec4(85.656, 85.750, 3.82, 59.34), vec4(85.656, 85.734, 3.82, 64.32), vec4(85.656, 85.728, 3.82, 68.37), vec4(85.656, 85.734, 0.50, 40.11), vec4(85.806, 85.959, 3.19, 56.33), \n    vec4(85.806, 85.940, 3.82, 59.28), vec4(85.806, 85.909, 3.82, 64.32), vec4(85.806, 85.919, 3.82, 68.38), vec4(85.806, 85.938, 0.50, 40.10), vec4(85.806, 85.946, 3.19, 59.32), \n    vec4(85.806, 85.928, 3.19, 64.38), vec4(86.406, 86.546, 0.50, 40.09), vec4(86.406, 86.540, 3.19, 56.32), vec4(86.406, 86.544, 3.19, 64.29), vec4(86.406, 86.534, 3.19, 59.32), \n    vec4(86.406, 86.506, 3.82, 64.31), vec4(86.406, 86.531, 3.82, 68.36), vec4(86.406, 86.550, 3.82, 59.28), vec4(86.706, 86.959, 2.43, 59.09), vec4(86.856, 86.928, 3.19, 56.35), \n    vec4(86.856, 86.931, 3.19, 59.34), vec4(86.856, 86.940, 3.82, 59.30), vec4(86.856, 86.934, 3.82, 64.34), vec4(86.856, 86.900, 3.82, 68.43), vec4(86.856, 86.938, 0.50, 40.09), \n    vec4(86.856, 86.934, 3.19, 64.32), vec4(87.006, 87.131, 3.82, 68.32), vec4(87.006, 87.134, 3.82, 59.28), vec4(87.006, 87.128, 3.19, 64.33), vec4(87.006, 87.131, 0.50, 40.13), \n    vec4(87.006, 87.296, 2.43, 64.13), vec4(87.006, 87.150, 3.19, 56.36), vec4(87.006, 87.134, 3.19, 59.34), vec4(87.006, 87.115, 3.82, 64.35), vec4(87.306, 87.594, 2.43, 68.07), \n    vec4(87.606, 87.728, 3.19, 64.31), vec4(87.606, 87.734, 3.19, 56.33), vec4(87.606, 87.753, 3.82, 68.31), vec4(87.606, 87.740, 3.82, 59.30), vec4(87.606, 87.709, 3.82, 64.32), \n    vec4(87.606, 87.725, 0.50, 40.08), vec4(87.606, 87.946, 2.43, 73.08), vec4(87.606, 87.715, 3.19, 59.34), vec4(87.906, 88.206, 2.43, 71.11), vec4(88.056, 88.121, 3.82, 64.35), \n    vec4(88.056, 88.119, 3.82, 68.31), vec4(88.056, 88.128, 3.19, 56.35), vec4(88.056, 88.153, 0.50, 40.06), vec4(88.056, 88.131, 3.82, 59.31), vec4(88.056, 88.134, 3.19, 59.28), \n    vec4(88.056, 88.125, 3.19, 64.32), vec4(88.206, 88.344, 3.82, 59.31), vec4(88.206, 88.509, 0.50, 35.12), vec4(88.206, 88.303, 3.82, 64.35), vec4(88.206, 88.340, 3.82, 68.33), \n    vec4(88.206, 88.496, 2.43, 68.09), vec4(88.206, 88.331, 3.19, 59.29), vec4(88.206, 88.334, 3.19, 64.31), vec4(88.206, 88.350, 3.19, 56.36), vec4(88.506, 88.734, 0.50, 40.09), \n    vec4(88.506, 88.819, 2.43, 64.13), vec4(88.806, 88.965, 3.19, 54.37), vec4(88.806, 90.525, 2.43, 66.19), vec4(88.806, 88.919, 3.19, 63.35), vec4(88.806, 88.913, 3.82, 66.35), \n    vec4(88.806, 88.938, 3.82, 71.29), vec4(88.806, 88.940, 3.82, 63.34), vec4(88.806, 88.934, 0.50, 35.07), vec4(88.806, 88.938, 3.19, 59.28), vec4(89.256, 89.319, 3.82, 63.37), \n    vec4(89.256, 89.325, 3.82, 71.31), vec4(89.256, 89.328, 3.19, 63.38), vec4(89.256, 89.328, 3.19, 59.31), vec4(89.256, 89.340, 3.19, 54.39), vec4(89.256, 89.340, 0.50, 35.12), \n    vec4(89.256, 89.328, 3.82, 66.32), vec4(89.406, 89.559, 3.19, 54.34), vec4(89.406, 89.525, 3.82, 71.31), vec4(89.406, 89.525, 3.82, 63.35), vec4(89.406, 89.515, 3.19, 59.31), \n    vec4(89.406, 89.515, 3.82, 66.31), vec4(89.406, 89.515, 0.50, 35.05), vec4(89.406, 89.538, 3.19, 63.33), vec4(90.006, 90.106, 3.82, 71.31), vec4(90.006, 90.134, 3.19, 54.31), \n    vec4(90.006, 90.128, 3.19, 59.32), vec4(90.006, 90.094, 3.82, 66.32), vec4(90.006, 90.134, 0.50, 35.09), vec4(90.006, 90.134, 3.82, 63.36), vec4(90.006, 90.119, 3.19, 63.35), \n    vec4(90.456, 90.553, 0.50, 35.11), vec4(90.456, 90.506, 3.19, 63.42), vec4(90.456, 90.563, 3.19, 59.31), vec4(90.456, 90.578, 3.19, 54.30), vec4(90.456, 90.578, 3.82, 63.35), \n    vec4(90.456, 90.550, 3.82, 66.34), vec4(90.456, 90.538, 3.82, 71.31), vec4(90.606, 91.115, 3.82, 70.37), vec4(90.606, 91.078, 3.82, 65.31), vec4(90.606, 91.125, 3.19, 58.35), \n    vec4(90.606, 91.150, 3.82, 62.38), vec4(90.606, 91.103, 3.19, 53.32), vec4(90.606, 91.090, 3.19, 62.34), vec4(90.606, 91.071, 0.50, 34.12), vec4(91.206, 91.346, 3.82, 69.33), \n    vec4(91.206, 91.340, 0.50, 33.07), vec4(91.206, 91.334, 3.82, 64.33), vec4(91.206, 91.356, 3.82, 61.31), vec4(91.206, 91.369, 3.19, 52.33), vec4(91.206, 91.344, 3.19, 57.33), \n    vec4(91.206, 91.334, 3.19, 61.32), vec4(91.506, 91.815, 2.43, 59.02), vec4(91.656, 91.731, 3.19, 52.30), vec4(91.656, 91.728, 3.19, 57.31), vec4(91.656, 91.713, 3.19, 61.33), \n    vec4(91.656, 91.738, 3.82, 69.27), vec4(91.656, 91.721, 3.82, 61.33), vec4(91.656, 91.721, 3.82, 64.33), vec4(91.656, 91.756, 0.50, 33.12), vec4(91.806, 91.919, 3.19, 57.33), \n    vec4(91.806, 91.915, 3.82, 69.35), vec4(91.806, 91.900, 3.82, 64.35), vec4(91.806, 91.953, 3.82, 61.32), vec4(91.806, 91.946, 3.19, 52.31), vec4(91.806, 92.088, 2.43, 61.10), \n    vec4(91.806, 91.909, 3.19, 61.31), vec4(91.806, 91.953, 0.50, 33.08), vec4(92.106, 92.313, 2.43, 64.14), vec4(92.406, 92.550, 3.82, 69.34), vec4(92.406, 92.738, 2.43, 69.05), \n    vec4(92.406, 92.546, 3.82, 61.33), vec4(92.406, 92.553, 0.50, 33.08), vec4(92.406, 92.513, 3.82, 64.35), vec4(92.406, 92.521, 3.19, 61.33), vec4(92.406, 92.584, 3.19, 52.31), \n    vec4(92.406, 92.525, 3.19, 57.32), vec4(92.706, 92.978, 2.43, 68.18), vec4(92.856, 92.919, 3.19, 61.34), vec4(92.856, 92.925, 3.19, 57.34), vec4(92.856, 92.946, 3.19, 52.33), \n    vec4(92.856, 92.946, 0.50, 33.06), vec4(92.856, 92.934, 3.82, 61.34), vec4(92.856, 92.934, 3.82, 69.28), vec4(92.856, 92.925, 3.82, 64.35), vec4(93.006, 93.165, 3.82, 69.28), \n    vec4(93.006, 93.144, 3.82, 61.33), vec4(93.006, 93.115, 3.82, 64.35), vec4(93.006, 93.131, 3.19, 57.27), vec4(93.006, 93.165, 3.19, 52.34), vec4(93.006, 93.131, 3.19, 61.34), \n    vec4(93.006, 93.319, 2.43, 66.15), vec4(93.006, 93.144, 0.50, 33.07), vec4(93.306, 93.600, 2.43, 61.13), vec4(93.606, 93.721, 3.19, 59.29), vec4(93.606, 95.421, 2.43, 64.18), \n    vec4(93.606, 93.738, 3.19, 64.33), vec4(93.606, 93.703, 3.82, 68.31), vec4(93.606, 93.690, 3.82, 64.36), vec4(93.606, 93.763, 0.50, 40.12), vec4(93.606, 93.756, 3.82, 59.31), \n    vec4(93.606, 93.744, 3.19, 56.36), vec4(94.056, 94.109, 3.19, 64.39), vec4(94.056, 94.125, 3.19, 56.36), vec4(94.056, 94.121, 3.82, 68.33), vec4(94.056, 94.121, 3.82, 64.35), \n    vec4(94.056, 94.138, 3.82, 59.30), vec4(94.056, 94.138, 3.19, 59.32), vec4(94.056, 94.131, 0.50, 40.10), vec4(94.206, 94.328, 3.19, 59.30), vec4(94.206, 94.315, 3.82, 64.35), \n    vec4(94.206, 94.340, 3.82, 59.29), vec4(94.206, 94.328, 0.50, 40.10), vec4(94.206, 94.309, 3.19, 56.35), vec4(94.206, 94.321, 3.19, 64.32), vec4(94.206, 94.309, 3.82, 68.33), \n    vec4(94.506, 94.700, 3.82, 64.31), vec4(94.506, 94.753, 3.82, 69.28), vec4(94.506, 94.731, 3.82, 61.32), vec4(94.506, 94.919, 3.19, 64.34), vec4(94.506, 94.715, 3.19, 57.27), \n    vec4(94.506, 94.703, 3.19, 61.33), vec4(94.806, 94.934, 3.82, 64.30), vec4(94.806, 94.921, 3.82, 68.35), vec4(94.806, 94.938, 3.19, 59.31), vec4(94.806, 94.953, 0.50, 40.09), \n    vec4(94.806, 94.946, 3.19, 56.28), vec4(94.806, 94.963, 3.82, 59.32), vec4(95.256, 95.338, 0.50, 40.09), vec4(95.256, 95.321, 3.19, 56.38), vec4(95.256, 95.344, 3.19, 59.30), \n    vec4(95.256, 95.315, 3.82, 68.36), vec4(95.256, 95.340, 3.82, 59.32), vec4(95.256, 95.315, 3.82, 64.32), vec4(95.406, 95.528, 3.19, 56.32), vec4(95.406, 95.544, 3.19, 59.34), \n    vec4(95.406, 95.519, 3.82, 64.30), vec4(95.406, 95.534, 3.82, 59.32), vec4(95.406, 95.544, 0.50, 40.09), vec4(95.406, 95.515, 3.19, 64.32), vec4(95.406, 95.515, 3.82, 68.35), \n    vec4(95.706, 95.938, 3.82, 69.32), vec4(95.706, 95.934, 3.19, 61.39), vec4(95.706, 95.878, 3.19, 64.32), vec4(95.706, 95.959, 3.82, 61.35), vec4(95.706, 95.975, 3.19, 57.29), \n    vec4(95.706, 95.921, 3.82, 64.33), vec4(96.006, 96.225, 3.82, 59.25), vec4(96.006, 96.200, 3.19, 56.35), vec4(96.006, 96.159, 3.19, 59.28), vec4(96.006, 96.165, 0.50, 40.09), \n    vec4(96.006, 96.156, 3.19, 64.31), vec4(96.006, 96.181, 3.82, 68.35), vec4(96.006, 96.181, 3.82, 64.31), vec4(96.606, 97.088, 3.19, 63.33), vec4(96.606, 97.075, 3.19, 66.38), \n    vec4(96.606, 97.240, 0.50, 35.06), vec4(96.606, 97.038, 3.82, 63.39), vec4(96.606, 97.028, 3.82, 59.29), vec4(96.606, 97.200, 5.11, 83.37), vec4(96.606, 97.200, 5.11, 71.44), \n    vec4(96.606, 97.178, 2.43, 71.08), vec4(96.606, 97.034, 3.82, 66.40), vec4(96.606, 97.100, 3.19, 59.33), vec4(96.628, 98.325, 7.50, 66.50), vec4(96.628, 98.338, 7.50, 63.50), \n    vec4(96.628, 98.356, 7.50, 59.50), vec4(97.206, 97.690, 3.82, 63.36), vec4(97.206, 97.690, 3.82, 66.40), vec4(97.206, 97.663, 3.82, 59.31), vec4(97.206, 97.521, 0.50, 47.08), \n    vec4(97.206, 97.709, 3.19, 66.39), vec4(97.206, 97.713, 3.19, 63.33), vec4(97.206, 97.800, 5.11, 85.46), vec4(97.206, 97.800, 5.11, 73.43), vec4(97.206, 97.738, 3.19, 59.36), \n    vec4(97.206, 97.840, 2.43, 73.06), vec4(97.506, 97.813, 0.50, 35.09), vec4(97.806, 98.234, 3.19, 63.35), vec4(97.806, 98.246, 3.19, 66.40), vec4(97.806, 98.278, 3.19, 59.35), \n    vec4(97.806, 98.250, 2.43, 75.09), vec4(97.806, 98.263, 3.82, 59.31), vec4(97.806, 98.253, 3.82, 66.33), vec4(97.806, 98.271, 3.82, 63.37), vec4(97.806, 98.121, 0.50, 47.11), \n    vec4(97.806, 98.350, 5.11, 87.40), vec4(97.806, 98.359, 5.11, 75.43), vec4(98.106, 98.359, 0.50, 35.10), vec4(98.406, 98.744, 4.58, 76.02), vec4(98.406, 98.531, 3.19, 59.38), \n    vec4(98.406, 98.531, 3.19, 64.35), vec4(98.406, 98.744, 2.43, 76.02), vec4(98.406, 98.563, 0.50, 40.02), vec4(98.406, 98.531, 3.19, 68.43), vec4(98.406, 98.656, 5.11, 76.42), \n    vec4(98.406, 98.684, 5.11, 88.39), vec4(98.428, 100.856, 7.50, 59.50), vec4(98.428, 100.834, 7.50, 68.50), vec4(98.428, 100.859, 7.50, 64.50), vec4(98.556, 98.813, 3.19, 64.38), \n    vec4(98.556, 98.803, 3.19, 68.43), vec4(98.556, 98.813, 3.19, 59.32), vec4(98.706, 98.909, 5.11, 75.47), vec4(98.706, 98.809, 3.82, 64.34), vec4(98.706, 98.894, 5.11, 87.46), \n    vec4(98.706, 98.828, 3.82, 59.30), vec4(98.706, 98.834, 3.82, 68.35), vec4(98.856, 98.915, 3.19, 68.43), vec4(98.856, 99.244, 3.19, 59.33), vec4(98.856, 98.925, 0.50, 40.12), \n    vec4(98.856, 98.928, 3.19, 64.39), vec4(98.856, 98.940, 2.43, 75.05), vec4(98.856, 98.940, 4.58, 75.05), vec4(99.006, 99.269, 2.43, 75.10), vec4(99.006, 99.281, 5.11, 87.43), \n    vec4(99.006, 99.288, 5.11, 75.42), vec4(99.006, 99.263, 3.19, 64.35), vec4(99.006, 99.263, 3.19, 68.40), vec4(99.006, 99.140, 0.50, 40.10), vec4(99.006, 99.269, 4.58, 75.11), \n    vec4(99.306, 99.534, 5.11, 85.44), vec4(99.306, 99.506, 5.11, 73.43), vec4(99.306, 99.434, 3.82, 59.31), vec4(99.306, 99.434, 3.82, 68.36), vec4(99.306, 99.425, 3.82, 64.35), \n    vec4(99.306, 99.563, 3.19, 59.38), vec4(99.306, 99.563, 3.19, 64.35), vec4(99.306, 99.563, 3.19, 68.39), vec4(99.306, 99.538, 4.58, 73.06), vec4(99.306, 99.538, 2.43, 73.05), \n    vec4(99.606, 99.994, 2.43, 73.05), vec4(99.606, 99.688, 3.19, 64.37), vec4(99.606, 99.659, 3.19, 68.43), vec4(99.606, 99.690, 3.19, 59.34), vec4(99.606, 99.750, 0.50, 40.05), \n    vec4(99.606, 99.896, 5.11, 73.43), vec4(99.606, 99.888, 5.11, 85.42), vec4(99.606, 99.994, 4.58, 73.06), vec4(99.756, 100.013, 3.19, 64.39), vec4(99.756, 100.013, 3.19, 59.38), \n    vec4(99.756, 100.013, 3.19, 68.40), vec4(99.906, 100.034, 3.82, 59.31), vec4(99.906, 100.046, 3.82, 68.36), vec4(99.906, 100.125, 5.11, 83.42), vec4(99.906, 100.146, 5.11, 71.39), \n    vec4(99.906, 100.031, 3.82, 64.34), vec4(100.056, 100.163, 3.19, 64.36), vec4(100.056, 100.121, 0.50, 40.09), vec4(100.056, 100.128, 3.19, 68.42), vec4(100.056, 100.165, 3.19, 59.32), \n    vec4(100.056, 100.163, 2.43, 71.11), vec4(100.056, 100.163, 4.58, 71.12), vec4(100.206, 100.463, 3.19, 64.40), vec4(100.206, 100.463, 3.19, 68.42), vec4(100.206, 100.490, 5.11, 83.39), \n    vec4(100.206, 100.456, 5.11, 71.38), vec4(100.206, 100.513, 4.58, 71.06), vec4(100.206, 100.356, 0.50, 40.11), vec4(100.206, 100.463, 3.19, 59.34), vec4(100.206, 100.513, 2.43, 71.06), \n    vec4(100.506, 100.771, 2.43, 64.10), vec4(100.506, 100.763, 3.19, 59.35), vec4(100.506, 100.778, 5.11, 64.44), vec4(100.506, 100.628, 3.82, 59.33), vec4(100.506, 100.638, 3.82, 68.35), \n    vec4(100.506, 100.638, 3.82, 64.35), vec4(100.506, 100.800, 5.11, 76.38), vec4(100.506, 100.771, 4.58, 64.11), vec4(100.506, 100.763, 3.19, 64.38), vec4(100.506, 100.753, 3.19, 68.43), \n    vec4(100.806, 100.869, 3.19, 66.41), vec4(100.806, 101.400, 5.11, 78.42), vec4(100.806, 101.400, 5.11, 66.45), vec4(100.806, 101.381, 2.43, 66.13), vec4(100.806, 101.381, 4.58, 66.07), \n    vec4(100.806, 100.875, 3.19, 61.41), vec4(100.806, 100.953, 0.50, 42.07), vec4(100.806, 100.896, 3.19, 57.35), vec4(100.828, 103.269, 7.50, 57.50), vec4(100.828, 103.275, 7.50, 61.50), \n    vec4(100.828, 105.613, 7.50, 66.50), vec4(100.956, 101.213, 3.19, 57.36), vec4(100.956, 101.213, 3.19, 61.41), vec4(100.956, 101.213, 3.19, 66.42), vec4(101.106, 101.240, 3.82, 69.31), \n    vec4(101.106, 101.228, 3.82, 66.34), vec4(101.106, 101.221, 3.82, 61.37), vec4(101.256, 101.363, 3.19, 61.41), vec4(101.256, 101.334, 3.19, 66.41), vec4(101.256, 101.340, 0.50, 42.14), \n    vec4(101.256, 101.371, 3.19, 57.33), vec4(101.406, 101.531, 0.50, 42.12), vec4(101.406, 101.663, 3.19, 57.34), vec4(101.406, 101.663, 3.19, 66.38), vec4(101.406, 102.654, 2.43, 73.07), \n    vec4(101.406, 101.663, 3.19, 61.40), vec4(101.406, 102.946, 5.11, 85.44), vec4(101.406, 102.971, 5.11, 73.46), vec4(101.406, 102.069, 4.58, 73.09), vec4(101.706, 101.921, 3.19, 66.39), \n    vec4(101.706, 101.925, 3.19, 61.37), vec4(101.706, 101.963, 3.19, 57.35), vec4(101.706, 101.821, 3.82, 61.38), vec4(101.706, 101.815, 3.82, 66.38), vec4(101.706, 101.844, 3.82, 69.31), \n    vec4(101.728, 101.838, 6.90, 69.20), vec4(101.728, 101.890, 6.90, 66.25), vec4(101.878, 102.003, 6.90, 68.25), vec4(101.878, 101.975, 6.90, 71.23), vec4(102.006, 102.081, 3.19, 66.43), \n    vec4(102.006, 102.165, 0.50, 42.08), vec4(102.006, 102.096, 3.19, 61.36), vec4(102.006, 102.100, 3.19, 57.36), vec4(102.028, 102.121, 6.90, 73.32), vec4(102.028, 102.169, 6.90, 69.24), \n    vec4(102.156, 102.396, 3.19, 66.40), vec4(102.156, 102.413, 3.19, 57.39), vec4(102.156, 102.388, 3.19, 61.36), vec4(102.178, 102.331, 6.90, 68.20), vec4(102.178, 102.303, 6.90, 71.24), \n    vec4(102.306, 102.446, 3.82, 69.31), vec4(102.306, 102.425, 3.82, 66.37), vec4(102.306, 102.419, 3.82, 61.38), vec4(102.456, 102.528, 0.50, 42.18), vec4(102.456, 102.544, 3.19, 61.38), \n    vec4(102.456, 102.553, 3.19, 57.37), vec4(102.478, 102.625, 6.90, 66.25), vec4(102.478, 102.606, 6.90, 69.20), vec4(102.606, 102.856, 3.19, 66.40), vec4(102.606, 102.863, 3.19, 61.42), \n    vec4(102.606, 102.863, 3.19, 57.35), vec4(102.606, 102.734, 0.50, 42.13), vec4(102.778, 102.925, 6.90, 68.33), vec4(102.778, 102.919, 6.90, 64.34), vec4(102.906, 103.031, 3.82, 61.41), \n    vec4(102.906, 103.015, 3.82, 66.39), vec4(102.906, 103.153, 3.19, 61.35), vec4(102.906, 103.163, 3.19, 66.42), vec4(102.906, 103.163, 3.19, 57.35), vec4(102.906, 103.034, 3.82, 69.31), \n    vec4(102.928, 104.896, 6.90, 66.42), vec4(102.928, 104.913, 6.90, 63.40), vec4(103.206, 103.313, 3.19, 66.39), vec4(103.206, 103.371, 0.50, 35.06), vec4(103.206, 103.575, 2.43, 75.09), \n    vec4(103.206, 103.575, 4.58, 75.10), vec4(103.206, 103.456, 5.11, 75.36), vec4(103.206, 103.413, 5.11, 87.46), vec4(103.206, 103.321, 3.19, 63.35), vec4(103.206, 103.328, 3.19, 59.38), \n    vec4(103.228, 105.606, 7.50, 63.50), vec4(103.228, 115.481, 7.50, 59.50), vec4(103.356, 103.609, 3.19, 59.38), vec4(103.356, 103.578, 3.19, 63.37), vec4(103.356, 103.563, 3.19, 66.44), \n    vec4(103.506, 103.619, 3.82, 59.29), vec4(103.506, 103.609, 3.82, 66.40), vec4(103.506, 103.609, 3.82, 63.35), vec4(103.506, 103.703, 5.11, 85.41), vec4(103.506, 103.719, 5.11, 73.44), \n    vec4(103.656, 103.759, 3.19, 59.39), vec4(103.656, 103.756, 3.19, 63.38), vec4(103.656, 103.738, 3.19, 66.40), vec4(103.656, 103.746, 0.50, 35.10), vec4(103.656, 103.746, 2.43, 73.10), \n    vec4(103.656, 103.746, 4.58, 73.04), vec4(103.806, 104.040, 3.19, 66.42), vec4(103.806, 104.038, 2.43, 73.06), vec4(103.806, 104.063, 3.19, 59.39), vec4(103.806, 104.094, 5.11, 85.44), \n    vec4(103.806, 104.038, 4.58, 73.07), vec4(103.806, 104.088, 5.11, 73.41), vec4(103.806, 104.046, 3.19, 63.39), vec4(103.806, 103.925, 0.50, 35.11), vec4(104.106, 104.231, 3.82, 59.31), \n    vec4(104.106, 104.346, 5.11, 83.42), vec4(104.106, 104.328, 3.19, 66.42), vec4(104.106, 104.231, 3.82, 66.42), vec4(104.106, 104.221, 3.82, 63.37), vec4(104.106, 104.346, 4.58, 71.13), \n    vec4(104.106, 104.359, 5.11, 71.38), vec4(104.106, 104.346, 2.43, 71.11), vec4(104.106, 104.338, 3.19, 63.37), vec4(104.106, 104.363, 3.19, 59.32), vec4(104.406, 104.575, 0.50, 35.09), \n    vec4(104.406, 104.513, 3.19, 63.40), vec4(104.406, 104.513, 3.19, 59.33), vec4(104.406, 104.646, 5.11, 71.45), vec4(104.406, 104.788, 4.58, 71.07), vec4(104.406, 104.788, 2.43, 71.06), \n    vec4(104.406, 104.490, 3.19, 66.43), vec4(104.406, 104.688, 5.11, 83.38), vec4(104.556, 104.771, 3.19, 66.44), vec4(104.556, 104.784, 3.19, 63.40), vec4(104.556, 104.813, 3.19, 59.36), \n    vec4(104.706, 104.831, 3.82, 66.44), vec4(104.706, 104.928, 5.11, 81.35), vec4(104.706, 104.831, 3.82, 63.39), vec4(104.706, 104.834, 3.82, 59.33), vec4(104.706, 104.925, 5.11, 69.39), \n    vec4(104.856, 104.946, 0.50, 35.13), vec4(104.856, 104.965, 3.19, 59.35), vec4(104.856, 104.950, 3.19, 63.39), vec4(104.856, 104.946, 2.43, 69.05), vec4(104.856, 104.946, 4.58, 69.05), \n    vec4(104.856, 104.950, 3.19, 66.42), vec4(105.006, 105.263, 3.19, 59.34), vec4(105.006, 105.253, 3.19, 63.40), vec4(105.006, 105.253, 3.19, 66.39), vec4(105.006, 105.300, 2.43, 69.04), \n    vec4(105.006, 105.300, 4.58, 69.06), vec4(105.006, 105.281, 5.11, 81.41), vec4(105.006, 105.300, 5.11, 69.39), vec4(105.006, 105.146, 0.50, 35.06), vec4(105.306, 105.531, 3.19, 59.36), \n    vec4(105.306, 105.431, 3.82, 63.38), vec4(105.306, 105.478, 3.19, 63.41), vec4(105.306, 105.463, 3.19, 66.39), vec4(105.306, 105.434, 3.82, 66.36), vec4(105.306, 105.600, 5.11, 78.43), \n    vec4(105.306, 105.434, 3.82, 59.33), vec4(105.306, 105.584, 4.58, 66.09), vec4(105.306, 105.600, 5.11, 66.37), vec4(105.306, 105.584, 2.43, 66.08), vec4(105.606, 105.775, 0.50, 40.09), \n    vec4(105.606, 106.194, 2.43, 64.10), vec4(105.606, 105.703, 3.19, 64.39), vec4(105.606, 105.715, 3.19, 68.39), vec4(105.606, 105.731, 3.19, 59.37), vec4(105.606, 106.178, 5.11, 76.38), \n    vec4(105.606, 106.194, 4.58, 64.11), vec4(105.606, 106.121, 5.11, 64.42), vec4(105.628, 110.463, 7.50, 68.50), vec4(105.628, 110.490, 7.50, 64.50), vec4(105.756, 105.978, 3.19, 64.42), \n    vec4(105.756, 105.963, 3.19, 68.41), vec4(105.756, 106.013, 3.19, 59.39), vec4(105.906, 106.028, 3.82, 68.38), vec4(105.906, 106.044, 3.82, 59.34), vec4(105.906, 106.031, 3.82, 64.36), \n    vec4(106.056, 106.150, 3.19, 64.34), vec4(106.056, 106.131, 3.19, 68.39), vec4(106.056, 106.144, 0.50, 40.17), vec4(106.056, 106.165, 3.19, 59.36), vec4(106.206, 107.840, 5.11, 76.41), \n    vec4(106.206, 107.438, 2.43, 76.09), vec4(106.206, 106.321, 0.50, 40.12), vec4(106.206, 107.828, 5.11, 88.46), vec4(106.206, 106.453, 3.19, 64.36), vec4(106.206, 106.463, 3.19, 59.38), \n    vec4(106.206, 107.128, 4.58, 76.04), vec4(106.206, 106.444, 3.19, 68.41), vec4(106.506, 106.621, 3.82, 59.32), vec4(106.506, 106.709, 3.19, 68.41), vec4(106.506, 106.715, 3.19, 64.37), \n    vec4(106.506, 106.753, 3.19, 59.39), vec4(106.506, 106.628, 3.82, 68.37), vec4(106.506, 106.606, 3.82, 64.36), vec4(106.528, 106.625, 6.90, 64.21), vec4(106.528, 106.650, 6.90, 68.19), \n    vec4(106.678, 106.788, 6.90, 69.21), vec4(106.678, 106.790, 6.90, 66.29), vec4(106.806, 106.896, 3.19, 64.37), vec4(106.806, 106.919, 3.19, 59.39), vec4(106.806, 106.925, 0.50, 47.08), \n    vec4(106.828, 106.915, 6.90, 68.31), vec4(106.828, 106.938, 6.90, 71.25), vec4(106.956, 107.069, 0.50, 49.08), vec4(106.956, 107.175, 3.19, 68.40), vec4(106.956, 107.188, 3.19, 64.34), \n    vec4(106.956, 107.213, 3.19, 59.36), vec4(106.978, 107.084, 6.90, 66.24), vec4(106.978, 107.078, 6.90, 69.21), vec4(107.106, 107.231, 0.50, 52.06), vec4(107.106, 107.206, 3.82, 68.40), \n    vec4(107.106, 107.225, 3.82, 64.37), vec4(107.106, 107.225, 3.82, 59.33), vec4(107.256, 107.359, 3.19, 64.35), vec4(107.256, 107.381, 3.19, 59.38), vec4(107.256, 107.328, 3.19, 68.43), \n    vec4(107.256, 107.828, 0.50, 54.06), vec4(107.278, 107.440, 6.90, 64.22), vec4(107.278, 107.396, 6.90, 68.23), vec4(107.406, 107.663, 3.19, 64.34), vec4(107.406, 107.653, 3.19, 59.36), \n    vec4(107.406, 107.631, 3.19, 68.42), vec4(107.578, 107.671, 6.90, 63.31), vec4(107.578, 107.688, 6.90, 66.23), vec4(107.706, 107.950, 3.19, 64.37), vec4(107.706, 107.940, 3.19, 68.40), \n    vec4(107.706, 107.963, 3.19, 59.39), vec4(107.706, 107.813, 3.82, 59.33), vec4(107.706, 107.821, 3.82, 64.30), vec4(107.706, 107.828, 3.82, 68.36), vec4(107.728, 109.656, 6.90, 64.28), \n    vec4(108.006, 108.109, 3.19, 59.32), vec4(108.006, 108.169, 0.50, 40.06), vec4(108.006, 108.844, 5.11, 80.37), vec4(108.006, 108.865, 5.11, 92.40), vec4(108.006, 108.088, 3.19, 64.39), \n    vec4(108.006, 108.850, 2.43, 80.02), vec4(108.006, 108.050, 3.19, 68.47), vec4(108.156, 108.413, 3.19, 59.35), vec4(108.156, 108.413, 3.19, 68.42), vec4(108.156, 108.413, 3.19, 64.38), \n    vec4(108.306, 108.440, 3.82, 59.33), vec4(108.306, 108.446, 3.82, 68.34), vec4(108.306, 108.421, 3.82, 64.29), vec4(108.456, 108.540, 0.50, 40.13), vec4(108.456, 108.571, 3.19, 59.34), \n    vec4(108.456, 108.550, 3.19, 64.39), vec4(108.456, 108.538, 3.19, 68.43), vec4(108.606, 108.759, 0.50, 40.09), vec4(108.606, 108.863, 3.19, 64.39), vec4(108.606, 108.863, 3.19, 59.34), \n    vec4(108.606, 108.863, 3.19, 68.44), vec4(108.906, 109.144, 5.11, 88.40), vec4(108.906, 109.146, 5.11, 76.36), vec4(108.906, 109.163, 3.19, 59.35), vec4(108.906, 109.150, 3.19, 64.40), \n    vec4(108.906, 109.028, 3.82, 68.35), vec4(108.906, 109.021, 3.82, 59.34), vec4(108.906, 109.013, 3.82, 64.29), vec4(108.906, 109.134, 3.19, 68.40), vec4(108.906, 109.125, 2.43, 76.05), \n    vec4(109.206, 109.463, 5.11, 88.36), vec4(109.206, 109.481, 5.11, 76.39), vec4(109.206, 109.428, 2.43, 76.12), vec4(109.206, 109.365, 0.50, 40.05), vec4(109.206, 109.278, 3.19, 68.37), \n    vec4(109.206, 109.296, 3.19, 59.35), vec4(109.206, 109.300, 3.19, 64.39), vec4(109.356, 109.578, 3.19, 68.40), vec4(109.356, 109.588, 3.19, 64.41), vec4(109.356, 109.613, 3.19, 59.36), \n    vec4(109.506, 109.725, 2.43, 71.09), vec4(109.506, 109.640, 3.82, 59.35), vec4(109.506, 109.631, 3.82, 68.37), vec4(109.506, 109.740, 5.11, 83.40), vec4(109.506, 109.746, 5.11, 71.41), \n    vec4(109.506, 109.625, 3.82, 64.30), vec4(109.656, 109.719, 3.19, 68.40), vec4(109.656, 109.740, 3.19, 64.42), vec4(109.656, 109.763, 0.50, 40.10), vec4(109.656, 109.759, 3.19, 59.36), \n    vec4(109.806, 110.063, 3.19, 59.35), vec4(109.806, 110.063, 3.19, 64.34), vec4(109.806, 110.053, 3.19, 68.40), vec4(109.806, 110.081, 5.11, 83.39), vec4(109.806, 110.063, 5.11, 71.39), \n    vec4(109.806, 110.134, 2.43, 71.07), vec4(109.806, 110.044, 0.50, 39.14), vec4(110.106, 110.234, 3.82, 59.35), vec4(110.106, 110.338, 3.19, 59.37), vec4(110.106, 110.313, 3.19, 68.40), \n    vec4(110.106, 110.309, 3.19, 64.34), vec4(110.106, 110.406, 2.43, 68.15), vec4(110.106, 110.221, 3.82, 68.38), vec4(110.106, 110.400, 5.11, 80.43), vec4(110.106, 110.400, 5.11, 68.50), \n    vec4(110.106, 110.359, 0.50, 37.09), vec4(110.106, 110.215, 3.82, 64.31), vec4(110.406, 112.588, 5.11, 81.40), vec4(110.406, 110.584, 0.50, 35.07), vec4(110.406, 110.488, 3.19, 63.34), \n    vec4(110.406, 110.513, 3.19, 66.35), vec4(110.406, 110.521, 3.19, 59.36), vec4(110.406, 111.319, 2.43, 69.06), vec4(110.406, 112.584, 5.11, 69.37), vec4(110.428, 115.194, 7.50, 63.50), \n    vec4(110.428, 115.196, 7.50, 66.50), vec4(110.556, 110.750, 3.19, 63.38), vec4(110.556, 110.746, 3.19, 66.44), vec4(110.556, 110.796, 3.19, 59.39), vec4(110.706, 110.828, 3.82, 66.39), \n    vec4(110.706, 110.821, 3.82, 63.35), vec4(110.706, 110.815, 3.82, 59.30), vec4(110.856, 110.956, 3.19, 66.39), vec4(110.856, 110.940, 0.50, 35.14), vec4(110.856, 110.963, 3.19, 63.39), \n    vec4(110.856, 110.965, 3.19, 59.39), vec4(111.006, 111.259, 3.19, 66.44), vec4(111.006, 111.171, 0.50, 35.06), vec4(111.006, 111.263, 3.19, 63.39), vec4(111.006, 111.263, 3.19, 59.32), \n    vec4(111.306, 111.425, 3.82, 66.41), vec4(111.306, 111.415, 3.82, 63.35), vec4(111.306, 111.556, 3.19, 59.32), vec4(111.306, 111.421, 3.82, 59.30), vec4(111.306, 111.515, 3.19, 66.43), \n    vec4(111.306, 111.521, 3.19, 63.39), vec4(111.328, 111.450, 6.90, 66.23), vec4(111.328, 111.431, 6.90, 75.14), vec4(111.478, 111.594, 6.90, 76.29), vec4(111.478, 111.569, 6.90, 68.35), \n    vec4(111.606, 111.706, 3.19, 59.35), vec4(111.606, 111.763, 0.50, 35.09), vec4(111.606, 111.694, 3.19, 66.44), vec4(111.606, 111.700, 3.19, 63.41), vec4(111.628, 111.750, 6.90, 69.20), \n    vec4(111.628, 111.734, 6.90, 78.23), vec4(111.756, 112.013, 3.19, 59.34), vec4(111.756, 111.994, 3.19, 66.39), vec4(111.756, 111.978, 3.19, 63.40), vec4(111.778, 111.878, 6.90, 68.27), \n    vec4(111.778, 111.931, 6.90, 76.21), vec4(111.906, 112.028, 3.82, 66.40), vec4(111.906, 112.025, 3.82, 63.35), vec4(111.906, 112.021, 3.82, 59.31), vec4(112.056, 112.169, 3.19, 59.34), \n    vec4(112.056, 112.150, 3.19, 63.42), vec4(112.056, 112.156, 0.50, 35.09), vec4(112.056, 112.150, 3.19, 66.37), vec4(112.078, 112.209, 6.90, 75.22), vec4(112.078, 112.190, 6.90, 66.26), \n    vec4(112.206, 112.440, 3.19, 63.41), vec4(112.206, 112.463, 3.19, 59.35), vec4(112.206, 112.463, 3.19, 66.39), vec4(112.206, 112.459, 0.50, 35.04), vec4(112.378, 112.490, 6.90, 73.31), \n    vec4(112.378, 112.503, 6.90, 64.26), vec4(112.506, 112.731, 3.19, 66.38), vec4(112.506, 112.753, 3.19, 59.35), vec4(112.506, 112.615, 3.82, 59.33), vec4(112.506, 112.609, 3.82, 63.37), \n    vec4(112.506, 112.603, 3.82, 66.35), vec4(112.506, 112.696, 0.50, 47.08), vec4(112.506, 112.725, 3.19, 63.42), vec4(112.528, 114.700, 6.90, 63.28), vec4(112.528, 114.459, 6.90, 71.31), \n    vec4(112.806, 112.981, 0.50, 35.04), vec4(112.806, 113.559, 2.43, 78.10), vec4(112.806, 113.646, 5.11, 78.42), vec4(112.806, 112.909, 3.19, 66.37), vec4(112.806, 112.903, 3.19, 59.36), \n    vec4(112.806, 112.900, 3.19, 63.41), vec4(112.806, 113.653, 5.11, 90.49), vec4(112.956, 113.181, 3.19, 66.42), vec4(112.956, 113.206, 3.19, 59.37), vec4(112.956, 113.178, 3.19, 63.36), \n    vec4(113.106, 113.228, 3.82, 66.36), vec4(113.106, 113.231, 3.82, 63.38), vec4(113.106, 113.228, 3.82, 59.34), vec4(113.256, 113.371, 3.19, 66.39), vec4(113.256, 113.353, 3.19, 63.37), \n    vec4(113.256, 113.363, 0.50, 35.12), vec4(113.256, 113.371, 3.19, 59.39), vec4(113.406, 113.653, 3.19, 63.37), vec4(113.406, 113.538, 0.50, 35.13), vec4(113.406, 113.663, 3.19, 66.42), \n    vec4(113.406, 113.663, 3.19, 59.38), vec4(113.706, 113.928, 2.43, 75.07), vec4(113.706, 113.921, 5.11, 87.49), vec4(113.706, 113.944, 3.19, 66.42), vec4(113.706, 113.944, 3.19, 63.38), \n    vec4(113.706, 113.931, 5.11, 75.43), vec4(113.706, 113.963, 3.19, 59.39), vec4(113.706, 113.828, 3.82, 63.39), vec4(113.706, 113.825, 3.82, 59.33), vec4(113.706, 113.821, 3.82, 66.37), \n    vec4(114.006, 114.103, 3.19, 63.38), vec4(114.006, 114.103, 3.19, 66.41), vec4(114.006, 114.159, 0.50, 35.05), vec4(114.006, 114.265, 2.43, 75.17), vec4(114.006, 114.259, 5.11, 75.46), \n    vec4(114.006, 114.296, 5.11, 87.43), vec4(114.006, 114.113, 3.19, 59.40), vec4(114.156, 114.403, 3.19, 63.40), vec4(114.156, 114.409, 3.19, 66.42), vec4(114.156, 114.413, 3.19, 59.36), \n    vec4(114.306, 114.434, 3.82, 66.36), vec4(114.306, 114.540, 2.43, 71.10), vec4(114.306, 114.428, 3.82, 59.33), vec4(114.306, 114.540, 5.11, 83.44), vec4(114.306, 114.509, 5.11, 71.42), \n    vec4(114.306, 114.421, 3.82, 63.38), vec4(114.456, 114.531, 3.19, 63.39), vec4(114.456, 114.534, 0.50, 35.12), vec4(114.456, 114.544, 3.19, 66.41), vec4(114.456, 114.559, 3.19, 59.33), \n    vec4(114.606, 114.859, 5.11, 71.37), vec4(114.606, 114.863, 3.19, 59.35), vec4(114.606, 114.728, 0.50, 35.11), vec4(114.606, 114.900, 5.11, 83.39), vec4(114.606, 114.863, 3.19, 66.43), \n    vec4(114.606, 114.878, 2.43, 71.06), vec4(114.606, 114.853, 3.19, 63.40), vec4(114.906, 115.040, 0.50, 35.07), vec4(114.906, 115.190, 5.11, 69.43), vec4(114.906, 115.181, 5.11, 81.39), \n    vec4(114.906, 115.194, 2.43, 69.07), vec4(114.906, 115.021, 3.82, 66.39), vec4(114.906, 115.021, 3.82, 59.35), vec4(114.906, 115.028, 3.82, 63.33), vec4(114.906, 115.075, 3.19, 63.40), \n    vec4(114.906, 115.084, 3.19, 66.38), vec4(114.906, 115.163, 3.19, 59.35), vec4(115.206, 115.340, 3.82, 59.34), vec4(115.206, 115.490, 5.11, 68.43), vec4(115.206, 115.459, 5.11, 80.42), \n    vec4(115.206, 115.390, 0.50, 40.08), vec4(115.206, 115.338, 3.82, 64.28), vec4(115.206, 115.465, 2.43, 68.16), vec4(115.206, 115.438, 3.19, 64.38), vec4(115.206, 115.328, 3.82, 68.31), \n    vec4(115.206, 115.421, 3.19, 68.35), vec4(115.206, 115.456, 3.19, 59.35), vec4(115.228, 115.421, 7.50, 68.50), vec4(115.228, 115.446, 7.50, 64.50), vec4(115.806, 116.290, 3.82, 63.35), \n    vec4(115.806, 116.290, 3.82, 66.36), vec4(115.806, 116.325, 3.19, 66.39), vec4(115.806, 115.984, 0.50, 35.12), vec4(115.806, 116.400, 5.11, 83.42), vec4(115.806, 116.378, 2.43, 71.05), \n    vec4(115.806, 116.400, 5.11, 71.43), vec4(115.806, 116.325, 3.19, 59.35), vec4(115.806, 116.325, 3.19, 63.40), vec4(115.806, 116.240, 3.82, 59.34), vec4(115.828, 117.490, 7.50, 59.50), \n    vec4(115.828, 117.471, 7.50, 63.50), vec4(115.828, 117.478, 7.50, 66.50), vec4(116.106, 116.281, 0.50, 35.08), vec4(116.388, 116.471, 1.50, 100.33), vec4(116.406, 116.925, 3.82, 63.33), \n    vec4(116.406, 116.925, 3.19, 66.39), vec4(116.406, 116.588, 0.50, 47.09), vec4(116.406, 117.000, 5.11, 73.41), vec4(116.406, 117.000, 5.11, 85.45), vec4(116.406, 116.925, 3.19, 59.35), \n    vec4(116.406, 116.894, 3.82, 59.35), vec4(116.406, 116.915, 3.82, 66.38), vec4(116.406, 117.009, 2.43, 73.09), vec4(116.406, 116.925, 3.19, 63.42), vec4(116.450, 116.546, 1.50, 97.56), \n    vec4(116.534, 116.628, 1.50, 95.47), vec4(116.606, 116.684, 1.50, 93.54), vec4(116.665, 116.744, 1.50, 92.54), vec4(116.706, 116.859, 0.50, 35.02), vec4(116.734, 116.815, 1.50, 88.43), \n    vec4(116.796, 116.878, 1.50, 85.49), vec4(116.863, 116.940, 1.50, 83.43), vec4(116.921, 116.990, 1.50, 81.50), vec4(116.978, 117.046, 1.50, 80.51), vec4(117.006, 117.450, 3.82, 59.28), \n    vec4(117.006, 117.459, 3.82, 66.38), vec4(117.006, 117.559, 5.11, 75.47), vec4(117.006, 117.550, 5.11, 87.39), vec4(117.006, 117.171, 0.50, 35.09), vec4(117.006, 117.594, 3.19, 63.35), \n    vec4(117.006, 117.600, 3.19, 66.39), vec4(117.006, 117.465, 3.82, 63.35), vec4(117.006, 117.625, 3.19, 59.35), vec4(117.006, 117.465, 2.43, 75.09), vec4(117.038, 117.121, 1.50, 76.46), \n    vec4(117.103, 117.188, 1.50, 73.50), vec4(117.181, 117.271, 1.50, 71.51), vec4(117.253, 117.334, 1.50, 69.50), vec4(117.306, 117.500, 0.50, 35.10), vec4(117.315, 117.403, 1.50, 68.51), \n    vec4(117.396, 117.509, 1.50, 64.50), vec4(117.513, 117.590, 1.50, 61.55), vec4(117.606, 117.790, 0.50, 40.06), vec4(117.606, 117.856, 5.11, 76.39), vec4(117.606, 117.700, 3.19, 68.35), \n    vec4(117.606, 117.690, 3.19, 64.31), vec4(117.606, 117.944, 2.43, 76.03), vec4(117.606, 117.709, 1.50, 59.53), vec4(117.606, 117.884, 5.11, 88.43), vec4(117.606, 117.944, 4.58, 76.04), \n    vec4(117.628, 120.028, 7.50, 59.50), vec4(117.628, 120.034, 7.50, 64.50), vec4(117.628, 120.015, 7.50, 68.50), vec4(117.756, 117.950, 3.19, 68.41), vec4(117.756, 117.959, 3.19, 64.34), \n    vec4(117.756, 117.984, 3.19, 59.37), vec4(117.906, 118.094, 5.11, 87.43), vec4(117.906, 118.109, 5.11, 75.46), vec4(117.906, 118.034, 3.82, 68.40), vec4(117.906, 118.028, 3.82, 59.28), \n    vec4(117.906, 118.009, 3.82, 64.32), vec4(118.056, 118.144, 0.50, 40.12), vec4(118.056, 118.144, 3.19, 59.37), vec4(118.056, 118.140, 2.43, 75.06), vec4(118.056, 118.140, 3.19, 64.35), \n    vec4(118.056, 118.109, 3.19, 68.42), vec4(118.056, 118.140, 4.58, 75.06), vec4(118.206, 118.463, 3.19, 68.39), vec4(118.206, 118.463, 3.19, 64.36), vec4(118.206, 118.463, 3.19, 59.38), \n    vec4(118.206, 118.469, 2.43, 75.12), vec4(118.206, 118.363, 0.50, 40.13), vec4(118.206, 118.488, 5.11, 75.39), vec4(118.206, 118.481, 5.11, 87.42), vec4(118.206, 118.469, 4.58, 75.06), \n    vec4(118.506, 118.634, 3.82, 59.29), vec4(118.506, 118.634, 3.82, 68.41), vec4(118.506, 118.625, 3.82, 64.32), vec4(118.506, 118.738, 2.43, 73.06), vec4(118.506, 118.706, 5.11, 73.48), \n    vec4(118.506, 118.738, 4.58, 73.07), vec4(118.506, 118.740, 3.19, 64.35), vec4(118.506, 118.728, 3.19, 68.40), vec4(118.506, 118.734, 5.11, 85.41), vec4(118.506, 118.763, 3.19, 59.32), \n    vec4(118.806, 119.088, 5.11, 85.47), vec4(118.806, 119.096, 5.11, 73.41), vec4(118.806, 119.194, 4.58, 73.07), vec4(118.806, 118.971, 0.50, 40.05), vec4(118.806, 119.194, 2.43, 73.06), \n    vec4(118.806, 118.853, 3.19, 68.43), vec4(118.806, 118.878, 3.19, 64.39), vec4(118.806, 118.896, 3.19, 59.34), vec4(118.956, 119.213, 3.19, 68.43), vec4(118.956, 119.213, 3.19, 59.34), \n    vec4(118.956, 119.213, 3.19, 64.36), vec4(119.106, 119.234, 3.82, 59.30), vec4(119.106, 119.246, 3.82, 68.35), vec4(119.106, 119.325, 5.11, 83.39), vec4(119.106, 119.346, 5.11, 71.36), \n    vec4(119.106, 119.231, 3.82, 64.32), vec4(119.256, 119.363, 4.58, 71.06), vec4(119.256, 119.321, 3.19, 68.42), vec4(119.256, 119.340, 3.19, 59.34), vec4(119.256, 119.363, 2.43, 71.06), \n    vec4(119.256, 119.346, 3.19, 64.39), vec4(119.256, 119.344, 0.50, 40.10), vec4(119.406, 119.713, 4.58, 71.07), vec4(119.406, 119.713, 2.43, 71.06), vec4(119.406, 119.663, 3.19, 68.35), \n    vec4(119.406, 119.656, 5.11, 71.42), vec4(119.406, 119.663, 3.19, 59.34), vec4(119.406, 119.663, 3.19, 64.39), vec4(119.406, 119.565, 0.50, 40.10), vec4(119.406, 119.690, 5.11, 83.38), \n    vec4(119.706, 119.828, 3.82, 59.31), vec4(119.706, 119.838, 3.82, 68.33), vec4(119.706, 119.971, 2.43, 64.12), vec4(119.706, 119.875, 3.19, 68.36), vec4(119.706, 119.971, 4.58, 64.13), \n    vec4(119.706, 119.931, 3.19, 64.37), vec4(119.706, 119.944, 3.19, 59.35), vec4(119.706, 119.838, 3.82, 64.34), vec4(119.706, 120.000, 5.11, 76.43), vec4(119.706, 119.978, 5.11, 64.43), \n    vec4(119.856, 119.946, 0.50, 40.09), vec4(120.006, 120.184, 0.50, 42.09), vec4(120.006, 120.600, 5.11, 66.43), vec4(120.006, 120.581, 2.43, 66.07), vec4(120.006, 120.581, 4.58, 66.09), \n    vec4(120.006, 120.084, 3.19, 61.37), vec4(120.006, 120.096, 3.19, 57.34), vec4(120.006, 120.100, 3.19, 66.36), vec4(120.006, 120.600, 5.11, 78.46), vec4(120.028, 122.465, 7.50, 57.50), \n    vec4(120.028, 124.806, 7.50, 66.50), vec4(120.028, 122.463, 7.50, 61.50), vec4(120.156, 120.375, 3.19, 61.39), vec4(120.156, 120.413, 3.19, 57.35), vec4(120.156, 120.378, 3.19, 66.37), \n    vec4(120.306, 120.421, 3.82, 61.35), vec4(120.306, 120.440, 3.82, 69.28), vec4(120.306, 120.428, 3.82, 66.39), vec4(120.456, 120.540, 0.50, 42.23), vec4(120.456, 120.556, 3.19, 57.36), \n    vec4(120.456, 120.528, 3.19, 66.41), vec4(120.456, 120.531, 3.19, 61.43), vec4(120.606, 120.846, 3.19, 66.39), vec4(120.606, 120.750, 0.50, 42.08), vec4(120.606, 121.821, 2.43, 73.09), \n    vec4(120.606, 120.978, 3.19, 61.35), vec4(120.606, 122.146, 5.11, 85.43), vec4(120.606, 122.171, 5.11, 73.43), vec4(120.606, 121.269, 4.58, 73.09), vec4(120.606, 120.846, 3.19, 57.34), \n    vec4(120.906, 121.121, 3.19, 66.39), vec4(120.906, 121.163, 3.19, 57.36), vec4(120.906, 121.044, 3.82, 69.29), vec4(120.906, 121.021, 3.82, 61.35), vec4(120.906, 121.015, 3.82, 66.43), \n    vec4(120.928, 121.078, 6.90, 66.27), vec4(120.928, 121.015, 6.90, 69.21), vec4(121.078, 121.153, 6.90, 71.29), vec4(121.078, 121.165, 6.90, 68.35), vec4(121.206, 121.284, 3.19, 66.39), \n    vec4(121.206, 121.296, 3.19, 61.35), vec4(121.206, 121.288, 3.19, 57.37), vec4(121.206, 121.271, 0.50, 42.10), vec4(121.228, 121.315, 6.90, 73.29), vec4(121.228, 121.353, 6.90, 69.27), \n    vec4(121.356, 121.706, 0.50, 32.04), vec4(121.356, 121.613, 3.19, 57.39), vec4(121.356, 121.613, 3.19, 61.37), vec4(121.356, 121.613, 3.19, 66.40), vec4(121.378, 121.465, 6.90, 71.27), \n    vec4(121.378, 121.503, 6.90, 68.27), vec4(121.506, 121.619, 3.82, 61.36), vec4(121.506, 121.625, 3.82, 66.42), vec4(121.506, 121.646, 3.82, 69.29), vec4(121.656, 121.734, 3.19, 66.43), \n    vec4(121.656, 121.759, 3.19, 57.38), vec4(121.656, 121.750, 3.19, 61.39), vec4(121.678, 121.788, 6.90, 66.30), vec4(121.678, 121.796, 6.90, 69.23), vec4(121.806, 122.063, 3.19, 57.30), \n    vec4(121.806, 122.053, 3.19, 66.41), vec4(121.806, 122.059, 3.19, 61.38), vec4(121.806, 122.103, 0.50, 33.07), vec4(121.978, 122.065, 6.90, 68.31), vec4(121.978, 122.075, 6.90, 64.31), \n    vec4(122.106, 122.234, 3.82, 69.29), vec4(122.106, 122.231, 3.82, 61.39), vec4(122.106, 122.303, 3.19, 61.39), vec4(122.106, 122.363, 3.19, 57.33), vec4(122.106, 122.315, 3.19, 66.43), \n    vec4(122.106, 122.215, 3.82, 66.43), vec4(122.106, 122.365, 0.50, 34.10), vec4(122.128, 124.121, 6.90, 66.31), vec4(122.128, 124.096, 6.90, 63.32), vec4(122.406, 122.584, 0.50, 35.05), \n    vec4(122.406, 122.613, 4.58, 75.10), vec4(122.406, 122.613, 5.11, 87.44), vec4(122.406, 122.619, 2.43, 75.11), vec4(122.406, 122.656, 5.11, 75.41), vec4(122.406, 122.453, 3.19, 66.39), \n    vec4(122.406, 122.513, 3.19, 59.32), vec4(122.406, 122.478, 3.19, 63.39), vec4(122.428, 124.846, 7.50, 59.50), vec4(122.428, 124.800, 7.50, 63.50), vec4(122.556, 122.771, 3.19, 63.41), \n    vec4(122.556, 122.765, 3.19, 66.39), vec4(122.556, 122.803, 3.19, 59.35), vec4(122.706, 122.819, 3.82, 59.34), vec4(122.706, 122.903, 5.11, 85.46), vec4(122.706, 122.809, 3.82, 63.32), \n    vec4(122.706, 122.809, 3.82, 66.38), vec4(122.706, 122.915, 2.43, 73.06), vec4(122.706, 122.919, 5.11, 73.42), vec4(122.706, 122.913, 4.58, 73.08), vec4(122.856, 122.931, 3.19, 63.40), \n    vec4(122.856, 122.909, 3.19, 66.37), vec4(122.856, 122.953, 0.50, 35.12), vec4(122.856, 122.946, 3.19, 59.35), vec4(123.006, 123.228, 4.58, 73.11), vec4(123.006, 123.294, 5.11, 85.42), \n    vec4(123.006, 123.231, 3.19, 63.41), vec4(123.006, 123.234, 3.19, 66.38), vec4(123.006, 123.259, 3.19, 59.36), vec4(123.006, 123.288, 5.11, 73.39), vec4(123.006, 123.259, 2.43, 73.14), \n    vec4(123.006, 123.146, 0.50, 35.09), vec4(123.306, 123.563, 3.19, 59.36), vec4(123.306, 123.525, 2.43, 71.14), vec4(123.306, 123.559, 5.11, 71.43), vec4(123.306, 123.546, 5.11, 83.39), \n    vec4(123.306, 123.506, 3.19, 63.42), vec4(123.306, 123.506, 3.19, 66.39), vec4(123.306, 123.525, 4.58, 71.06), vec4(123.306, 123.421, 3.82, 63.35), vec4(123.306, 123.431, 3.82, 66.39), \n    vec4(123.306, 123.431, 3.82, 59.35), vec4(123.606, 123.696, 3.19, 66.37), vec4(123.606, 123.853, 4.58, 71.09), vec4(123.606, 123.884, 2.43, 71.07), vec4(123.606, 123.888, 5.11, 83.35), \n    vec4(123.606, 123.846, 5.11, 71.49), vec4(123.606, 123.706, 3.19, 59.36), vec4(123.606, 123.769, 0.50, 35.02), vec4(123.606, 123.709, 3.19, 63.43), vec4(123.756, 124.013, 3.19, 59.37), \n    vec4(123.756, 124.003, 3.19, 66.39), vec4(123.756, 123.994, 3.19, 63.43), vec4(123.906, 124.034, 3.82, 59.38), vec4(123.906, 124.031, 3.82, 63.37), vec4(123.906, 124.125, 5.11, 69.37), \n    vec4(123.906, 124.128, 5.11, 81.40), vec4(123.906, 124.140, 2.43, 69.08), vec4(123.906, 124.128, 4.58, 69.06), vec4(123.906, 124.031, 3.82, 66.42), vec4(124.056, 124.156, 3.19, 59.37), \n    vec4(124.056, 124.119, 3.19, 66.36), vec4(124.056, 124.153, 0.50, 35.12), vec4(124.056, 124.134, 3.19, 63.34), vec4(124.206, 124.496, 4.58, 69.05), vec4(124.206, 124.359, 0.50, 35.10), \n    vec4(124.206, 124.500, 5.11, 69.36), vec4(124.206, 124.481, 5.11, 81.39), vec4(124.206, 124.484, 2.43, 69.02), vec4(124.206, 124.434, 3.19, 63.36), vec4(124.206, 124.444, 3.19, 66.40), \n    vec4(124.206, 124.463, 3.19, 59.36), vec4(124.506, 124.800, 5.11, 78.41), vec4(124.506, 124.834, 2.43, 66.09), vec4(124.506, 124.790, 4.58, 66.10), vec4(124.506, 124.759, 3.19, 59.37), \n    vec4(124.506, 124.706, 3.19, 63.36), vec4(124.506, 124.800, 5.11, 66.41), vec4(124.506, 124.631, 3.82, 63.36), vec4(124.506, 124.634, 3.82, 66.41), vec4(124.506, 124.634, 3.82, 59.37), \n    vec4(124.506, 124.728, 3.19, 66.39), vec4(124.806, 124.884, 3.19, 64.35), vec4(124.806, 124.903, 3.19, 68.37), vec4(124.806, 124.906, 3.19, 61.39), vec4(124.806, 125.396, 2.43, 64.13), \n    vec4(124.806, 125.321, 5.11, 64.39), vec4(124.806, 125.369, 4.58, 64.13), vec4(124.806, 125.378, 5.11, 76.42), vec4(124.806, 124.971, 0.50, 37.06), vec4(124.828, 126.059, 7.50, 68.50), \n    vec4(124.828, 127.253, 7.50, 61.50), vec4(124.828, 126.071, 7.50, 64.50), vec4(124.956, 125.175, 3.19, 61.43), vec4(124.956, 125.156, 3.19, 64.37), vec4(124.956, 125.134, 3.19, 68.43), \n    vec4(125.106, 125.219, 3.82, 68.39), vec4(125.106, 125.215, 3.82, 61.32), vec4(125.106, 125.206, 3.82, 64.31), vec4(125.256, 125.353, 0.50, 37.29), vec4(125.256, 125.353, 3.19, 61.35), \n    vec4(125.256, 125.353, 3.19, 64.38), vec4(125.256, 125.334, 3.19, 68.41), vec4(125.406, 125.663, 3.19, 64.36), vec4(125.406, 125.663, 3.19, 61.35), vec4(125.406, 125.653, 3.19, 68.41), \n    vec4(125.406, 126.378, 4.58, 76.06), vec4(125.406, 126.606, 2.43, 76.02), vec4(125.406, 125.509, 0.50, 37.06), vec4(125.406, 127.028, 5.11, 88.43), vec4(125.406, 127.040, 5.11, 76.39), \n    vec4(125.706, 125.813, 3.82, 68.39), vec4(125.706, 125.828, 3.82, 64.31), vec4(125.706, 125.831, 3.82, 61.32), vec4(125.706, 125.963, 3.19, 61.35), vec4(125.706, 125.963, 3.19, 68.41), \n    vec4(125.706, 125.963, 3.19, 64.36), vec4(125.728, 125.834, 6.90, 73.26), vec4(125.878, 125.965, 6.90, 75.26), vec4(126.006, 126.113, 3.19, 70.41), vec4(126.006, 126.088, 3.19, 66.41), \n    vec4(126.006, 126.119, 3.19, 61.36), vec4(126.006, 126.296, 0.50, 42.06), vec4(126.028, 127.244, 7.50, 66.50), vec4(126.028, 127.213, 7.50, 70.50), vec4(126.028, 126.115, 6.90, 76.28), \n    vec4(126.156, 126.413, 3.19, 70.37), vec4(126.156, 126.413, 3.19, 66.40), vec4(126.156, 126.413, 3.19, 61.38), vec4(126.178, 126.296, 6.90, 76.35), vec4(126.306, 126.578, 0.50, 30.06), \n    vec4(126.306, 126.415, 3.82, 58.33), vec4(126.306, 126.419, 3.82, 66.42), vec4(126.306, 126.396, 3.82, 61.33), vec4(126.456, 126.556, 3.19, 61.37), vec4(126.456, 126.540, 3.19, 66.42), \n    vec4(126.456, 126.538, 3.19, 70.38), vec4(126.478, 126.615, 6.90, 76.27), vec4(126.606, 126.838, 3.19, 70.35), vec4(126.606, 126.863, 3.19, 66.39), vec4(126.606, 126.909, 0.50, 32.06), \n    vec4(126.606, 126.863, 3.19, 61.36), vec4(126.778, 126.865, 6.90, 75.32), vec4(126.906, 127.028, 3.82, 61.33), vec4(126.906, 127.059, 3.82, 66.31), vec4(126.906, 127.144, 3.19, 70.37), \n    vec4(126.906, 127.134, 3.19, 61.37), vec4(126.906, 127.028, 3.82, 58.32), vec4(126.906, 127.153, 3.19, 66.42), vec4(126.906, 127.153, 0.50, 34.18), vec4(126.928, 128.859, 6.90, 76.27), \n    vec4(127.206, 127.331, 3.19, 59.32), vec4(127.206, 127.306, 3.19, 64.31), vec4(127.206, 128.071, 5.11, 92.40), vec4(127.206, 128.071, 5.11, 80.42), vec4(127.206, 127.303, 3.19, 68.29), \n    vec4(127.206, 128.050, 2.43, 80.05), vec4(127.206, 127.409, 0.50, 35.06), vec4(127.228, 129.628, 7.50, 68.50), vec4(127.228, 129.628, 7.50, 71.50), vec4(127.228, 137.990, 7.50, 64.50), \n    vec4(127.356, 127.596, 3.19, 68.39), vec4(127.356, 127.613, 3.19, 59.39), vec4(127.356, 127.600, 3.19, 64.36), vec4(127.506, 127.650, 3.82, 59.31), vec4(127.506, 127.638, 3.82, 68.31), \n    vec4(127.506, 127.631, 3.82, 64.35), vec4(127.656, 127.715, 3.19, 68.39), vec4(127.656, 127.746, 3.19, 64.35), vec4(127.656, 127.759, 3.19, 59.38), vec4(127.806, 128.053, 3.19, 64.36), \n    vec4(127.806, 128.063, 3.19, 59.39), vec4(127.806, 128.038, 3.19, 68.39), vec4(127.806, 128.065, 0.50, 35.02), vec4(128.106, 128.334, 5.11, 76.43), vec4(128.106, 128.363, 3.19, 68.39), \n    vec4(128.106, 128.313, 5.11, 88.38), vec4(128.106, 128.363, 3.19, 59.31), vec4(128.106, 128.238, 3.82, 68.32), vec4(128.106, 128.325, 2.43, 76.06), vec4(128.106, 128.363, 3.19, 64.36), \n    vec4(128.106, 128.234, 3.82, 64.35), vec4(128.106, 128.234, 3.82, 59.32), vec4(128.406, 128.488, 3.19, 59.34), vec4(128.406, 128.484, 3.19, 64.38), vec4(128.406, 128.628, 2.43, 76.06), \n    vec4(128.406, 128.646, 5.11, 88.39), vec4(128.406, 128.644, 5.11, 76.36), vec4(128.406, 128.694, 0.50, 35.07), vec4(128.556, 128.813, 3.19, 64.34), vec4(128.556, 128.809, 3.19, 68.38), \n    vec4(128.556, 128.813, 3.19, 59.37), vec4(128.706, 128.925, 2.43, 71.10), vec4(128.706, 128.840, 3.82, 59.31), vec4(128.706, 128.840, 3.82, 68.33), vec4(128.706, 128.903, 5.11, 83.39), \n    vec4(128.706, 128.925, 5.11, 71.40), vec4(128.706, 128.821, 3.82, 64.34), vec4(128.856, 128.940, 0.50, 35.09), vec4(128.856, 128.965, 3.19, 59.39), vec4(128.856, 128.928, 3.19, 64.38), \n    vec4(128.856, 128.906, 3.19, 68.41), vec4(129.006, 129.263, 3.19, 68.39), vec4(129.006, 129.263, 3.19, 64.35), vec4(129.006, 129.263, 3.19, 59.37), vec4(129.006, 129.334, 2.43, 71.09), \n    vec4(129.006, 129.300, 5.11, 83.37), vec4(129.006, 129.209, 0.50, 47.07), vec4(129.006, 129.290, 5.11, 71.43), vec4(129.306, 129.528, 5.11, 68.50), vec4(129.306, 129.590, 5.11, 80.45), \n    vec4(129.306, 129.456, 3.82, 68.34), vec4(129.306, 129.431, 3.82, 59.32), vec4(129.306, 129.409, 3.82, 64.35), vec4(129.306, 129.531, 0.50, 35.05), vec4(129.306, 129.563, 3.19, 68.41), \n    vec4(129.306, 129.563, 3.19, 64.36), vec4(129.306, 129.563, 3.19, 59.32), vec4(129.306, 129.606, 2.43, 68.10), vec4(129.606, 129.725, 3.19, 57.31), vec4(129.606, 130.828, 2.43, 73.11), \n    vec4(129.606, 129.731, 3.19, 64.39), vec4(129.606, 129.709, 3.19, 61.38), vec4(129.606, 130.800, 5.11, 81.40), vec4(129.606, 129.813, 0.50, 33.10), vec4(129.606, 130.800, 5.11, 69.36), \n    vec4(129.628, 131.984, 7.50, 61.50), vec4(129.628, 130.803, 7.50, 57.50), vec4(129.756, 129.965, 3.19, 61.43), vec4(129.756, 129.996, 3.19, 64.38), vec4(129.756, 130.013, 3.19, 57.32), \n    vec4(129.906, 130.015, 3.82, 64.30), vec4(129.906, 130.021, 3.82, 61.35), vec4(129.906, 130.028, 3.82, 69.31), vec4(130.056, 130.138, 0.50, 33.06), vec4(130.056, 130.119, 3.19, 61.46), \n    vec4(130.056, 130.165, 3.19, 57.35), vec4(130.056, 130.140, 3.19, 64.34), vec4(130.206, 130.440, 3.19, 61.41), vec4(130.206, 130.463, 3.19, 64.32), vec4(130.206, 130.463, 3.19, 57.33), \n    vec4(130.206, 130.390, 0.50, 33.08), vec4(130.506, 130.634, 3.82, 64.30), vec4(130.506, 130.621, 3.82, 61.37), vec4(130.506, 130.728, 3.19, 61.42), vec4(130.506, 130.763, 3.19, 64.33), \n    vec4(130.506, 130.763, 3.19, 57.33), vec4(130.506, 130.650, 3.82, 69.31), vec4(130.806, 131.671, 2.43, 76.12), vec4(130.806, 131.953, 5.11, 70.48), vec4(130.806, 130.888, 3.19, 58.38), \n    vec4(130.806, 130.890, 3.19, 61.44), vec4(130.806, 130.909, 3.19, 64.35), vec4(130.806, 131.100, 0.50, 30.17), vec4(130.806, 131.959, 5.11, 82.43), vec4(130.828, 132.046, 7.50, 58.50), \n    vec4(130.956, 131.184, 3.19, 64.35), vec4(130.956, 131.140, 3.19, 61.36), vec4(130.956, 131.213, 3.19, 58.39), vec4(131.106, 131.215, 3.82, 61.37), vec4(131.106, 131.256, 3.82, 70.35), \n    vec4(131.106, 131.213, 3.82, 64.28), vec4(131.106, 131.400, 0.50, 34.08), vec4(131.256, 131.331, 3.19, 64.34), vec4(131.256, 131.350, 3.19, 58.39), vec4(131.406, 131.663, 3.19, 64.32), \n    vec4(131.406, 131.663, 3.19, 58.36), vec4(131.406, 131.615, 3.19, 61.40), vec4(131.406, 131.671, 0.50, 37.16), vec4(131.706, 131.950, 0.50, 42.07), vec4(131.706, 131.850, 3.82, 70.36), \n    vec4(131.706, 131.834, 3.82, 61.38), vec4(131.706, 131.963, 3.19, 58.38), vec4(131.706, 131.934, 3.19, 64.35), vec4(131.706, 131.909, 3.19, 61.42), vec4(131.706, 131.825, 3.82, 64.29), \n    vec4(132.006, 132.115, 3.19, 59.37), vec4(132.006, 132.090, 3.19, 64.35), vec4(132.006, 138.384, 5.11, 71.45), vec4(132.006, 138.388, 5.11, 83.42), vec4(132.006, 132.596, 2.43, 76.04), \n    vec4(132.006, 132.196, 0.50, 35.06), vec4(132.028, 138.828, 7.50, 59.50), vec4(132.028, 137.990, 7.50, 68.50), vec4(132.156, 132.413, 3.19, 59.36), vec4(132.156, 132.344, 3.19, 64.38), \n    vec4(132.156, 132.331, 3.19, 68.37), vec4(132.306, 132.459, 3.82, 68.31), vec4(132.306, 132.446, 3.82, 64.35), vec4(132.306, 132.459, 3.82, 71.34), vec4(132.328, 132.471, 6.90, 64.46), \n    vec4(132.328, 132.471, 6.90, 71.45), vec4(132.456, 132.546, 3.19, 64.39), vec4(132.456, 132.490, 3.19, 68.42), vec4(132.456, 132.575, 3.19, 59.35), vec4(132.456, 132.540, 0.50, 35.06), \n    vec4(132.478, 132.771, 6.90, 71.43), vec4(132.478, 132.771, 6.90, 64.43), vec4(132.606, 133.053, 2.43, 71.13), vec4(132.606, 132.863, 3.19, 59.36), vec4(132.606, 132.853, 3.19, 68.35), \n    vec4(132.606, 132.769, 0.50, 35.09), vec4(132.606, 132.863, 3.19, 64.39), vec4(132.778, 132.921, 6.90, 71.44), vec4(132.778, 132.921, 6.90, 64.49), vec4(132.906, 133.050, 3.82, 64.29), \n    vec4(132.906, 133.163, 3.19, 68.38), vec4(132.906, 133.163, 3.19, 64.33), vec4(132.906, 133.163, 3.19, 59.36), vec4(132.906, 133.044, 3.82, 71.35), vec4(132.906, 133.056, 3.82, 68.37), \n    vec4(132.928, 133.521, 6.90, 71.46), vec4(132.928, 133.521, 6.90, 64.46), vec4(133.206, 133.775, 4.58, 76.07), vec4(133.206, 133.413, 0.50, 35.02), vec4(133.206, 133.321, 3.19, 59.38), \n    vec4(133.206, 133.303, 3.19, 64.34), vec4(133.206, 133.278, 3.19, 68.39), vec4(133.206, 133.756, 4.58, 88.13), vec4(133.356, 133.584, 3.19, 68.40), vec4(133.356, 133.613, 3.19, 59.37), \n    vec4(133.356, 133.584, 3.19, 64.36), vec4(133.506, 133.621, 3.82, 71.35), vec4(133.506, 133.631, 3.82, 64.30), vec4(133.506, 133.634, 3.82, 68.38), vec4(133.528, 133.671, 6.90, 71.44), \n    vec4(133.528, 133.671, 6.90, 64.45), vec4(133.656, 133.759, 3.19, 68.39), vec4(133.656, 133.778, 3.19, 59.37), vec4(133.656, 133.781, 0.50, 35.16), vec4(133.656, 133.746, 3.19, 64.35), \n    vec4(133.678, 133.971, 6.90, 64.43), vec4(133.678, 133.971, 6.90, 71.42), vec4(133.806, 134.059, 3.19, 64.35), vec4(133.806, 134.063, 3.19, 59.38), vec4(133.806, 134.059, 3.19, 68.42), \n    vec4(133.806, 134.181, 4.58, 71.13), vec4(133.806, 134.190, 4.58, 83.18), vec4(133.806, 133.959, 0.50, 47.03), vec4(133.956, 134.240, 0.50, 35.05), vec4(133.978, 134.121, 6.90, 71.43), \n    vec4(133.978, 134.121, 6.90, 64.48), vec4(134.106, 134.338, 3.19, 68.40), vec4(134.106, 134.363, 3.19, 59.39), vec4(134.106, 134.350, 3.19, 64.37), vec4(134.106, 134.228, 3.82, 71.36), \n    vec4(134.106, 134.238, 3.82, 64.30), vec4(134.106, 134.240, 3.82, 68.37), vec4(134.128, 134.721, 6.90, 64.46), vec4(134.128, 134.721, 6.90, 71.44), vec4(134.406, 135.013, 2.43, 76.07), \n    vec4(134.406, 134.515, 3.19, 59.34), vec4(134.406, 134.490, 3.19, 64.38), vec4(134.406, 134.588, 0.50, 35.10), vec4(134.556, 134.796, 3.19, 68.39), vec4(134.556, 134.813, 3.19, 64.37), \n    vec4(134.556, 134.813, 3.19, 59.37), vec4(134.706, 134.846, 3.82, 71.31), vec4(134.706, 134.856, 3.82, 68.38), vec4(134.706, 134.840, 3.82, 64.31), vec4(134.728, 134.871, 6.90, 71.43), \n    vec4(134.728, 134.871, 6.90, 64.42), vec4(134.856, 134.978, 3.19, 59.38), vec4(134.856, 134.950, 3.19, 64.35), vec4(134.856, 134.928, 3.19, 68.39), vec4(134.856, 134.940, 0.50, 35.03), \n    vec4(134.878, 135.171, 6.90, 71.42), vec4(134.878, 135.171, 6.90, 64.48), vec4(135.006, 135.263, 3.19, 59.39), vec4(135.006, 135.263, 3.19, 64.36), vec4(135.006, 135.263, 3.19, 68.41), \n    vec4(135.006, 135.163, 0.50, 35.09), vec4(135.006, 135.559, 2.43, 71.09), vec4(135.178, 135.321, 6.90, 71.47), vec4(135.178, 135.321, 6.90, 64.45), vec4(135.306, 135.563, 3.19, 59.31), \n    vec4(135.306, 135.521, 3.19, 68.41), vec4(135.306, 135.440, 3.82, 68.36), vec4(135.306, 135.521, 3.19, 64.37), vec4(135.306, 135.425, 3.82, 64.32), vec4(135.306, 135.415, 3.82, 71.30), \n    vec4(135.328, 135.921, 6.90, 71.43), vec4(135.328, 135.921, 6.90, 64.43), vec4(135.606, 136.115, 4.58, 88.08), vec4(135.606, 135.715, 3.19, 59.32), vec4(135.606, 135.690, 3.19, 64.36), \n    vec4(135.606, 135.659, 3.19, 68.44), vec4(135.606, 135.815, 0.50, 35.08), vec4(135.606, 136.146, 4.58, 76.12), vec4(135.756, 135.978, 3.19, 68.42), vec4(135.756, 135.978, 3.19, 64.39), \n    vec4(135.756, 136.006, 3.19, 59.35), vec4(135.906, 136.046, 3.82, 68.38), vec4(135.906, 136.021, 3.82, 64.31), vec4(135.906, 136.019, 3.82, 71.30), vec4(135.928, 136.071, 6.90, 71.43), \n    vec4(135.928, 136.071, 6.90, 64.43), vec4(136.056, 136.144, 3.19, 64.37), vec4(136.056, 136.153, 0.50, 35.08), vec4(136.056, 136.156, 3.19, 59.32), vec4(136.056, 136.121, 3.19, 68.35), \n    vec4(136.078, 136.371, 6.90, 71.40), vec4(136.078, 136.371, 6.90, 64.46), vec4(136.206, 136.328, 0.50, 35.04), vec4(136.206, 136.463, 3.19, 59.34), vec4(136.206, 136.446, 3.19, 64.38), \n    vec4(136.206, 136.446, 3.19, 68.35), vec4(136.206, 136.625, 4.58, 71.21), vec4(136.206, 136.631, 4.58, 83.12), vec4(136.356, 136.759, 0.50, 30.06), vec4(136.378, 136.521, 6.90, 64.47), \n    vec4(136.378, 136.521, 6.90, 71.47), vec4(136.506, 136.700, 3.19, 68.36), vec4(136.506, 136.715, 3.19, 64.40), vec4(136.506, 136.763, 3.19, 59.36), vec4(136.506, 136.613, 3.82, 71.32), \n    vec4(136.506, 136.621, 3.82, 68.41), vec4(136.506, 136.628, 3.82, 64.32), vec4(136.528, 136.821, 6.90, 64.46), vec4(136.528, 136.821, 6.90, 71.45), vec4(136.806, 137.346, 2.43, 80.04), \n    vec4(136.806, 137.850, 3.19, 68.40), vec4(136.806, 137.850, 3.19, 64.40), vec4(136.806, 137.850, 3.19, 59.35), vec4(136.806, 137.850, 3.82, 64.34), vec4(136.806, 137.834, 3.82, 68.41), \n    vec4(136.806, 137.794, 3.82, 71.33), vec4(136.806, 137.546, 0.50, 35.09), vec4(136.828, 138.046, 6.90, 64.45), vec4(136.828, 138.040, 6.90, 71.40), vec4(137.406, 137.769, 2.43, 76.02), \n    vec4(137.706, 137.906, 0.50, 35.13), vec4(137.856, 137.956, 2.43, 71.13), vec4(137.988, 138.071, 1.50, 100.36), vec4(138.006, 139.046, 3.19, 66.46), vec4(138.006, 139.019, 3.82, 66.37), \n    vec4(138.006, 139.046, 3.82, 71.38), vec4(138.006, 138.225, 2.43, 75.14), vec4(138.006, 138.309, 0.50, 35.11), vec4(138.006, 139.046, 3.19, 59.37), vec4(138.006, 139.034, 3.82, 63.39), \n    vec4(138.006, 139.046, 3.19, 63.47), vec4(138.028, 138.828, 7.50, 63.50), vec4(138.028, 138.794, 7.50, 66.50), vec4(138.050, 138.146, 1.50, 97.53), vec4(138.134, 138.228, 1.50, 95.50), \n    vec4(138.206, 138.284, 1.50, 93.57), vec4(138.265, 138.344, 1.50, 92.50), vec4(138.306, 138.540, 2.43, 75.07), vec4(138.334, 138.415, 1.50, 88.46), vec4(138.396, 138.478, 1.50, 85.45), \n    vec4(138.463, 138.540, 1.50, 83.46), vec4(138.521, 138.590, 1.50, 81.53), vec4(138.578, 138.646, 1.50, 80.48), vec4(138.606, 138.878, 2.43, 76.09), vec4(138.638, 138.721, 1.50, 76.49), \n    vec4(138.703, 138.788, 1.50, 73.53), vec4(138.781, 138.871, 1.50, 71.48), vec4(138.853, 138.934, 1.50, 69.54), vec4(138.906, 139.196, 2.43, 78.24), vec4(138.915, 139.003, 1.50, 68.54), \n    vec4(138.996, 139.109, 1.50, 64.47), vec4(139.113, 139.190, 1.50, 61.59), vec4(139.206, 140.653, 3.19, 54.35), vec4(139.206, 139.378, 0.50, 38.07), vec4(139.206, 140.403, 3.82, 57.33), \n    vec4(139.206, 140.240, 3.82, 66.36), vec4(139.206, 140.788, 2.43, 76.08), vec4(139.206, 140.565, 3.19, 57.26), vec4(139.206, 140.434, 3.82, 62.28), vec4(139.206, 139.309, 1.50, 62.64), \n    vec4(139.206, 140.565, 3.19, 62.30), vec4(139.228, 140.396, 7.50, 62.50), vec4(139.228, 140.356, 7.50, 66.50), vec4(139.228, 140.406, 7.50, 69.50), vec4(139.656, 139.746, 0.50, 38.13), \n    vec4(139.806, 139.950, 0.50, 38.06), vec4(139.806, 140.406, 5.11, 78.51), vec4(139.806, 140.413, 5.11, 90.47), vec4(140.406, 140.971, 3.82, 61.31), vec4(140.406, 140.953, 5.11, 80.45), \n    vec4(140.406, 140.981, 3.19, 61.32), vec4(140.406, 140.584, 0.50, 37.09), vec4(140.406, 141.009, 5.11, 92.45), vec4(140.406, 141.115, 3.19, 53.34), vec4(140.406, 141.069, 3.19, 56.29), \n    vec4(140.406, 140.938, 3.82, 56.39), vec4(140.406, 140.950, 3.82, 65.32), vec4(140.428, 140.981, 7.50, 68.50), vec4(140.428, 141.009, 7.50, 61.50), vec4(140.428, 141.050, 7.50, 65.50), \n    vec4(140.856, 140.931, 0.50, 37.12), vec4(141.006, 141.653, 5.11, 81.45), vec4(141.006, 141.196, 0.50, 36.08), vec4(141.006, 141.515, 3.82, 60.31), vec4(141.006, 141.525, 3.82, 55.37), \n    vec4(141.006, 141.600, 3.19, 55.28), vec4(141.006, 141.609, 3.19, 52.34), vec4(141.006, 141.640, 3.19, 60.30), vec4(141.006, 141.621, 5.11, 93.40), vec4(141.006, 141.494, 3.82, 64.35), \n    vec4(141.028, 141.519, 7.50, 67.50), vec4(141.028, 152.053, 7.50, 64.50), vec4(141.028, 141.634, 7.50, 60.50), vec4(141.606, 142.103, 0.50, 35.06), vec4(141.606, 142.409, 5.11, 80.43), \n    vec4(141.606, 141.696, 3.19, 56.34), vec4(141.606, 141.700, 3.19, 59.29), vec4(141.606, 141.709, 3.19, 64.33), vec4(141.606, 142.459, 5.11, 92.47), vec4(141.606, 142.390, 2.43, 80.06), \n    vec4(141.628, 144.021, 7.50, 68.50), vec4(141.628, 144.038, 7.50, 59.50), vec4(141.756, 141.975, 3.19, 56.37), vec4(141.756, 141.950, 3.19, 59.31), vec4(141.756, 141.944, 3.19, 64.35), \n    vec4(141.906, 142.021, 3.82, 64.35), vec4(141.906, 142.040, 3.82, 68.36), vec4(141.906, 142.044, 3.82, 59.35), vec4(142.056, 142.159, 3.19, 56.31), vec4(142.056, 142.153, 3.19, 59.31), \n    vec4(142.056, 142.131, 3.19, 64.36), vec4(142.206, 142.659, 0.50, 35.04), vec4(142.206, 142.803, 3.19, 64.35), vec4(142.206, 142.865, 3.19, 59.31), vec4(142.206, 142.896, 3.19, 56.32), \n    vec4(142.506, 142.756, 5.11, 76.39), vec4(142.506, 142.650, 3.82, 68.35), vec4(142.506, 142.656, 3.82, 59.28), vec4(142.506, 142.706, 2.43, 76.00), vec4(142.506, 142.781, 5.11, 88.43), \n    vec4(142.506, 142.631, 3.82, 64.31), vec4(142.806, 143.025, 2.43, 76.06), vec4(142.806, 143.071, 5.11, 76.46), vec4(142.806, 143.119, 5.11, 88.40), vec4(142.806, 143.071, 0.50, 35.05), \n    vec4(142.806, 142.928, 3.19, 64.36), vec4(142.956, 143.209, 3.19, 56.35), vec4(142.956, 143.194, 3.19, 59.31), vec4(142.956, 143.194, 3.19, 64.32), vec4(143.106, 143.675, 0.50, 35.11), \n    vec4(143.106, 143.328, 5.11, 71.41), vec4(143.106, 143.344, 5.11, 83.36), vec4(143.106, 143.240, 3.82, 68.43), vec4(143.106, 143.263, 3.82, 64.32), vec4(143.106, 143.315, 2.43, 71.10), \n    vec4(143.106, 143.263, 3.82, 59.30), vec4(143.256, 143.325, 3.19, 56.31), vec4(143.256, 143.338, 3.19, 64.30), vec4(143.256, 143.346, 3.19, 59.29), vec4(143.406, 143.706, 5.11, 83.42), \n    vec4(143.406, 143.721, 5.11, 71.39), vec4(143.406, 143.984, 3.19, 64.29), vec4(143.406, 143.994, 3.19, 56.32), vec4(143.406, 144.015, 3.19, 59.31), vec4(143.406, 143.696, 2.43, 71.05), \n    vec4(143.706, 143.996, 5.11, 68.43), vec4(143.706, 143.938, 0.50, 47.02), vec4(143.706, 143.846, 3.82, 64.32), vec4(143.706, 143.994, 5.11, 80.40), vec4(143.706, 143.875, 3.82, 68.37), \n    vec4(143.706, 143.859, 3.82, 59.29), vec4(143.706, 143.944, 2.43, 68.10), vec4(144.006, 145.178, 2.43, 73.11), vec4(144.006, 145.221, 5.11, 81.35), vec4(144.006, 144.109, 3.19, 64.29), \n    vec4(144.006, 144.096, 3.19, 61.33), vec4(144.006, 144.094, 3.19, 57.27), vec4(144.006, 145.196, 5.11, 69.39), vec4(144.006, 144.371, 0.50, 33.05), vec4(144.028, 145.250, 7.50, 69.50), \n    vec4(144.028, 146.428, 7.50, 61.50), vec4(144.156, 144.325, 3.19, 64.31), vec4(144.156, 144.331, 3.19, 61.36), vec4(144.156, 144.365, 3.19, 57.31), vec4(144.306, 144.431, 3.82, 61.32), \n    vec4(144.306, 144.440, 3.82, 64.32), vec4(144.306, 144.463, 3.82, 69.33), vec4(144.456, 144.528, 3.19, 57.29), vec4(144.456, 144.521, 3.19, 61.31), vec4(144.606, 145.190, 3.19, 64.28), \n    vec4(144.606, 145.056, 0.50, 33.08), vec4(144.606, 145.221, 3.19, 61.33), vec4(144.606, 145.271, 3.19, 57.28), vec4(144.906, 145.053, 3.82, 69.28), vec4(144.906, 145.034, 3.82, 64.32), \n    vec4(144.906, 145.028, 3.82, 61.31), vec4(145.206, 145.484, 0.50, 30.12), vec4(145.206, 146.019, 2.43, 76.06), vec4(145.206, 145.300, 3.19, 64.31), vec4(145.206, 146.394, 5.11, 82.48), \n    vec4(145.206, 145.288, 3.19, 58.29), vec4(145.206, 146.388, 5.11, 70.46), vec4(145.228, 146.419, 7.50, 70.50), vec4(145.356, 145.563, 3.19, 64.31), vec4(145.356, 145.628, 3.19, 58.34), \n    vec4(145.356, 145.575, 3.19, 61.35), vec4(145.506, 145.781, 0.50, 34.11), vec4(145.506, 145.665, 3.82, 70.31), vec4(145.506, 145.621, 3.82, 61.33), vec4(145.506, 145.640, 3.82, 64.33), \n    vec4(145.656, 145.703, 3.19, 64.33), vec4(145.656, 145.728, 3.19, 61.34), vec4(145.656, 145.740, 3.19, 58.35), vec4(145.806, 146.100, 0.50, 37.17), vec4(145.806, 146.344, 3.19, 64.31), \n    vec4(145.806, 146.381, 3.19, 58.35), vec4(145.806, 146.390, 3.19, 61.29), vec4(146.106, 146.359, 0.50, 42.09), vec4(146.106, 146.263, 3.82, 70.34), vec4(146.106, 146.259, 3.82, 61.35), \n    vec4(146.106, 146.238, 3.82, 64.34), vec4(146.406, 146.990, 2.43, 76.05), vec4(146.406, 146.496, 3.19, 64.31), vec4(146.406, 146.488, 3.19, 56.33), vec4(146.406, 146.690, 0.50, 35.06), \n    vec4(146.406, 152.596, 5.11, 71.43), vec4(146.406, 152.613, 5.11, 83.45), vec4(146.406, 146.506, 3.19, 59.27), vec4(146.428, 152.031, 7.50, 68.50), vec4(146.428, 151.996, 7.50, 59.50), \n    vec4(146.556, 146.784, 3.19, 59.29), vec4(146.556, 146.806, 3.19, 56.36), vec4(146.556, 146.778, 3.19, 64.33), vec4(146.706, 146.825, 3.82, 64.34), vec4(146.706, 146.859, 3.82, 68.31), \n    vec4(146.706, 146.853, 3.82, 59.31), vec4(146.856, 146.931, 3.19, 64.35), vec4(146.856, 146.944, 3.19, 56.37), vec4(146.856, 146.953, 3.19, 59.28), vec4(147.006, 147.609, 3.19, 56.39), \n    vec4(147.006, 147.309, 0.50, 35.00), vec4(147.006, 147.565, 3.19, 64.33), vec4(147.006, 147.588, 3.19, 59.29), vec4(147.006, 147.378, 2.43, 71.17), vec4(147.306, 147.434, 3.82, 64.35), \n    vec4(147.306, 147.453, 3.82, 68.34), vec4(147.306, 147.446, 3.82, 59.32), vec4(147.606, 147.894, 0.50, 35.05), vec4(147.606, 147.709, 3.19, 59.29), vec4(147.606, 148.175, 4.58, 76.07), \n    vec4(147.606, 147.688, 3.19, 64.35), vec4(147.606, 148.156, 4.58, 88.13), vec4(147.756, 148.046, 3.19, 56.31), vec4(147.756, 148.031, 3.19, 64.36), vec4(147.756, 148.044, 3.19, 59.31), \n    vec4(147.906, 148.034, 3.82, 64.28), vec4(147.906, 148.046, 3.82, 59.32), vec4(147.906, 148.053, 3.82, 68.35), vec4(148.056, 148.144, 3.19, 56.31), vec4(148.056, 148.128, 3.19, 64.36), \n    vec4(148.056, 148.131, 3.19, 59.31), vec4(148.206, 148.819, 3.19, 59.31), vec4(148.206, 148.775, 3.19, 64.35), vec4(148.206, 148.863, 3.19, 56.33), vec4(148.206, 148.590, 4.58, 83.17), \n    vec4(148.206, 148.581, 4.58, 71.12), vec4(148.206, 148.471, 0.50, 37.09), vec4(148.506, 148.753, 0.50, 42.08), vec4(148.506, 148.650, 3.82, 59.33), vec4(148.506, 148.650, 3.82, 68.34), \n    vec4(148.506, 148.640, 3.82, 64.27), vec4(148.806, 149.050, 0.50, 35.07), vec4(148.806, 149.390, 2.43, 76.06), vec4(148.806, 148.896, 3.19, 64.30), vec4(148.956, 149.250, 3.19, 56.35), \n    vec4(148.956, 149.238, 3.19, 59.33), vec4(148.956, 149.225, 3.19, 64.31), vec4(149.106, 149.228, 3.82, 59.34), vec4(149.106, 149.219, 3.82, 64.29), vec4(149.106, 149.231, 3.82, 68.35), \n    vec4(149.256, 149.359, 3.19, 56.34), vec4(149.256, 149.353, 3.19, 59.34), vec4(149.256, 149.328, 3.19, 64.31), vec4(149.406, 150.028, 3.19, 56.34), vec4(149.406, 149.703, 0.50, 35.08), \n    vec4(149.406, 150.003, 3.19, 59.34), vec4(149.406, 149.965, 3.19, 64.31), vec4(149.406, 149.800, 2.43, 71.14), vec4(149.706, 149.865, 3.82, 68.36), vec4(149.706, 149.859, 3.82, 59.35), \n    vec4(149.706, 149.846, 3.82, 64.30), vec4(150.006, 150.515, 4.58, 88.07), vec4(150.006, 150.309, 0.50, 35.03), vec4(150.006, 150.546, 4.58, 76.11), vec4(150.006, 150.100, 3.19, 59.32), \n    vec4(150.006, 150.103, 3.19, 64.30), vec4(150.156, 150.444, 3.19, 56.37), vec4(150.156, 150.413, 3.19, 59.28), vec4(150.156, 150.400, 3.19, 64.33), vec4(150.306, 150.446, 3.82, 68.36), \n    vec4(150.306, 150.428, 3.82, 59.34), vec4(150.306, 150.425, 3.82, 64.31), vec4(150.456, 150.525, 3.19, 59.28), vec4(150.456, 150.531, 3.19, 56.36), vec4(150.606, 151.025, 4.58, 71.20), \n    vec4(150.606, 150.706, 0.50, 47.08), vec4(150.606, 151.159, 3.19, 64.29), vec4(150.606, 151.213, 3.19, 59.33), vec4(150.606, 151.246, 3.19, 56.34), vec4(150.606, 151.031, 4.58, 83.17), \n    vec4(150.756, 151.115, 0.50, 47.13), vec4(150.906, 151.021, 3.82, 68.39), vec4(150.906, 151.025, 3.82, 59.30), vec4(150.906, 151.031, 3.82, 64.32), vec4(151.206, 151.778, 2.43, 80.04), \n    vec4(151.206, 152.546, 3.19, 64.29), vec4(151.206, 152.196, 0.50, 35.04), vec4(151.206, 151.956, 3.82, 68.42), vec4(151.206, 151.988, 3.82, 64.35), vec4(151.206, 152.009, 3.82, 59.31), \n    vec4(151.806, 152.081, 2.43, 76.09), vec4(152.106, 152.421, 2.43, 71.12), vec4(152.106, 152.296, 3.82, 64.36), vec4(152.106, 152.325, 3.82, 59.37), vec4(152.106, 152.290, 3.82, 68.39), \n    vec4(152.406, 153.409, 3.82, 66.38), vec4(152.406, 153.415, 3.82, 63.41), vec4(152.406, 153.446, 3.82, 59.31), vec4(152.406, 152.546, 3.19, 59.38), vec4(152.406, 153.709, 3.19, 63.35), \n    vec4(152.406, 153.719, 3.19, 54.40), vec4(152.406, 152.671, 2.43, 75.06), vec4(152.406, 153.290, 0.50, 35.13), vec4(152.706, 152.984, 2.43, 71.10), vec4(153.006, 153.303, 2.43, 69.11), \n    vec4(153.306, 153.584, 2.43, 66.23), vec4(153.606, 158.421, 2.43, 64.12), vec4(153.606, 162.531, 5.11, 76.29), vec4(153.606, 153.750, 3.82, 64.29), vec4(153.606, 153.794, 3.82, 56.35), \n    vec4(153.606, 153.778, 3.82, 59.33), vec4(153.606, 153.696, 3.19, 59.32), vec4(153.606, 153.684, 3.19, 56.36), vec4(153.606, 153.834, 0.50, 28.06), vec4(153.606, 153.690, 3.19, 64.33), \n    vec4(153.606, 162.515, 5.11, 88.24), vec4(153.628, 154.819, 7.50, 64.50), vec4(153.628, 154.796, 7.50, 68.50), vec4(153.628, 154.809, 7.50, 59.50), vec4(153.756, 153.978, 3.19, 64.31), \n    vec4(153.756, 154.000, 3.19, 59.28), vec4(153.756, 154.006, 3.19, 56.35), vec4(154.056, 154.140, 0.50, 28.14), vec4(154.056, 154.163, 3.19, 56.34), vec4(154.056, 154.146, 3.19, 59.28), \n    vec4(154.056, 154.128, 3.19, 64.34), vec4(154.056, 154.138, 3.82, 64.31), vec4(154.056, 154.119, 3.82, 56.35), vec4(154.056, 154.140, 3.82, 59.34), vec4(154.206, 154.850, 3.19, 56.38), \n    vec4(154.206, 154.338, 3.82, 64.31), vec4(154.206, 154.356, 3.82, 56.35), vec4(154.206, 154.353, 3.82, 59.37), vec4(154.206, 154.359, 0.50, 28.13), vec4(154.206, 154.821, 3.19, 64.32), \n    vec4(154.206, 154.831, 3.19, 59.29), vec4(154.806, 154.915, 3.19, 62.26), vec4(154.806, 154.900, 3.19, 54.35), vec4(154.806, 154.890, 3.19, 57.28), vec4(154.806, 154.988, 3.82, 57.33), \n    vec4(154.806, 155.015, 0.50, 28.08), vec4(154.806, 154.953, 3.82, 66.35), vec4(154.806, 154.938, 3.82, 62.28), vec4(154.828, 155.994, 7.50, 66.50), vec4(154.828, 156.031, 7.50, 62.50), \n    vec4(154.828, 156.075, 7.50, 57.50), vec4(154.828, 154.971, 6.90, 71.28), vec4(154.828, 154.971, 6.90, 76.25), vec4(154.956, 155.150, 3.19, 57.31), vec4(154.956, 155.200, 3.19, 54.31), \n    vec4(154.956, 155.188, 3.19, 62.33), vec4(154.978, 155.121, 6.90, 71.28), vec4(154.978, 155.121, 6.90, 76.31), vec4(155.128, 155.271, 6.90, 76.28), vec4(155.128, 155.271, 6.90, 71.26), \n    vec4(155.256, 155.363, 3.19, 62.34), vec4(155.256, 155.328, 3.82, 62.29), vec4(155.256, 155.309, 3.82, 66.39), vec4(155.256, 155.344, 3.82, 57.33), vec4(155.256, 155.371, 0.50, 28.14), \n    vec4(155.256, 155.340, 3.19, 57.31), vec4(155.256, 155.346, 3.19, 54.32), vec4(155.278, 155.421, 6.90, 76.26), vec4(155.278, 155.421, 6.90, 71.35), vec4(155.406, 156.021, 3.19, 62.33), \n    vec4(155.406, 155.584, 3.82, 57.31), vec4(155.406, 155.546, 3.82, 66.37), vec4(155.406, 155.556, 3.82, 62.28), vec4(155.406, 155.615, 0.50, 28.13), vec4(155.406, 156.019, 3.19, 57.31), \n    vec4(155.406, 156.031, 3.19, 54.32), vec4(155.428, 155.594, 6.90, 71.28), vec4(155.428, 155.603, 6.90, 76.29), vec4(156.006, 156.113, 3.19, 64.29), vec4(156.006, 156.090, 3.19, 56.31), \n    vec4(156.006, 156.100, 3.19, 59.31), vec4(156.006, 156.231, 0.50, 28.07), vec4(156.006, 156.169, 3.82, 56.39), vec4(156.006, 156.153, 3.82, 59.31), vec4(156.006, 156.146, 3.82, 64.32), \n    vec4(156.028, 157.294, 7.50, 64.50), vec4(156.028, 157.275, 7.50, 59.50), vec4(156.028, 157.244, 7.50, 68.50), vec4(156.156, 156.381, 3.19, 64.29), vec4(156.156, 156.406, 3.19, 56.33), \n    vec4(156.156, 156.428, 3.19, 59.32), vec4(156.456, 156.540, 3.82, 64.34), vec4(156.456, 156.550, 3.82, 59.31), vec4(156.456, 156.546, 3.19, 59.32), vec4(156.456, 156.540, 3.19, 56.31), \n    vec4(156.456, 156.538, 3.82, 56.31), vec4(156.456, 156.534, 3.19, 64.32), vec4(156.456, 156.569, 0.50, 28.13), vec4(156.606, 157.196, 3.19, 64.31), vec4(156.606, 157.196, 3.19, 59.34), \n    vec4(156.606, 156.813, 0.50, 28.17), vec4(156.606, 157.209, 3.19, 56.31), vec4(156.606, 156.746, 3.82, 64.34), vec4(156.606, 156.763, 3.82, 56.33), vec4(156.606, 156.765, 3.82, 59.35), \n    vec4(157.206, 157.346, 3.82, 62.31), vec4(157.206, 157.390, 3.82, 57.29), vec4(157.206, 157.434, 0.50, 28.11), vec4(157.206, 157.300, 3.19, 57.26), vec4(157.206, 157.313, 3.19, 54.31), \n    vec4(157.206, 157.325, 3.19, 62.28), vec4(157.206, 157.359, 3.82, 66.38), vec4(157.228, 158.431, 7.50, 62.50), vec4(157.228, 158.434, 7.50, 66.50), vec4(157.228, 158.456, 7.50, 57.50), \n    vec4(157.228, 157.371, 6.90, 76.27), vec4(157.228, 157.371, 6.90, 71.26), vec4(157.356, 157.569, 3.19, 57.28), vec4(157.356, 157.609, 3.19, 62.31), vec4(157.356, 157.619, 3.19, 54.33), \n    vec4(157.378, 157.521, 6.90, 71.33), vec4(157.378, 157.521, 6.90, 76.30), vec4(157.528, 157.671, 6.90, 71.31), vec4(157.528, 157.671, 6.90, 76.25), vec4(157.656, 157.753, 3.82, 57.28), \n    vec4(157.656, 157.728, 3.82, 62.31), vec4(157.656, 157.709, 3.82, 66.33), vec4(157.656, 157.769, 0.50, 28.17), vec4(157.656, 157.744, 3.19, 62.31), vec4(157.656, 157.721, 3.19, 57.29), \n    vec4(157.656, 157.721, 3.19, 54.37), vec4(157.678, 157.821, 6.90, 76.31), vec4(157.678, 157.821, 6.90, 71.31), vec4(157.806, 157.959, 3.82, 66.31), vec4(157.806, 158.028, 0.50, 28.07), \n    vec4(157.806, 158.409, 3.19, 57.29), vec4(157.806, 157.963, 3.82, 62.31), vec4(157.806, 157.969, 3.82, 57.31), vec4(157.806, 158.440, 3.19, 54.35), vec4(157.806, 158.394, 3.19, 62.31), \n    vec4(157.828, 158.000, 6.90, 71.26), vec4(157.828, 157.996, 6.90, 76.28), vec4(158.406, 158.519, 3.19, 64.33), vec4(158.406, 158.621, 0.50, 28.10), vec4(158.406, 158.500, 3.19, 56.30), \n    vec4(158.406, 158.559, 3.82, 59.33), vec4(158.406, 158.581, 3.82, 56.35), vec4(158.406, 160.671, 2.43, 76.17), vec4(158.406, 158.509, 3.19, 59.28), vec4(158.406, 158.563, 3.82, 64.29), \n    vec4(158.428, 159.590, 7.50, 68.50), vec4(158.428, 159.638, 7.50, 59.50), vec4(158.428, 159.665, 7.50, 64.50), vec4(158.556, 158.815, 3.19, 59.31), vec4(158.556, 158.784, 3.19, 64.34), \n    vec4(158.556, 158.840, 3.19, 56.32), vec4(158.856, 158.953, 3.19, 56.31), vec4(158.856, 158.946, 3.19, 64.35), vec4(158.856, 158.950, 3.19, 59.30), vec4(158.856, 158.953, 0.50, 28.16), \n    vec4(158.856, 158.940, 3.82, 64.31), vec4(158.856, 158.934, 3.82, 56.36), vec4(158.856, 158.928, 3.82, 59.35), vec4(159.006, 159.163, 3.82, 56.35), vec4(159.006, 159.159, 3.82, 64.31), \n    vec4(159.006, 159.606, 3.19, 64.35), vec4(159.006, 159.609, 3.19, 59.30), vec4(159.006, 159.613, 3.19, 56.32), vec4(159.006, 159.209, 0.50, 28.06), vec4(159.006, 159.171, 3.82, 59.31), \n    vec4(159.606, 159.725, 3.19, 62.27), vec4(159.606, 159.809, 0.50, 28.09), vec4(159.606, 159.700, 3.19, 57.30), vec4(159.606, 159.719, 3.82, 62.26), vec4(159.606, 159.725, 3.82, 66.35), \n    vec4(159.606, 159.756, 3.82, 57.30), vec4(159.606, 159.703, 3.19, 54.31), vec4(159.628, 159.771, 6.90, 76.24), vec4(159.628, 160.840, 7.50, 62.50), vec4(159.628, 159.771, 6.90, 71.31), \n    vec4(159.628, 160.846, 7.50, 66.50), vec4(159.628, 160.709, 7.50, 57.50), vec4(159.756, 160.019, 3.19, 57.32), vec4(159.756, 160.025, 3.19, 62.28), vec4(159.756, 160.063, 3.19, 54.35), \n    vec4(159.778, 159.921, 6.90, 71.31), vec4(159.778, 159.921, 6.90, 76.34), vec4(159.928, 160.071, 6.90, 71.28), vec4(159.928, 160.071, 6.90, 76.29), vec4(160.056, 160.128, 3.82, 62.28), \n    vec4(160.056, 160.103, 3.82, 66.39), vec4(160.056, 160.140, 3.82, 57.33), vec4(160.056, 160.153, 0.50, 28.18), vec4(160.056, 160.140, 3.19, 57.33), vec4(160.056, 160.159, 3.19, 62.30), \n    vec4(160.078, 160.221, 6.90, 71.33), vec4(160.078, 160.221, 6.90, 76.28), vec4(160.206, 160.569, 3.19, 57.34), vec4(160.206, 160.315, 3.82, 62.29), vec4(160.206, 160.315, 3.82, 57.33), \n    vec4(160.206, 160.331, 3.82, 66.36), vec4(160.206, 160.665, 3.19, 54.34), vec4(160.206, 160.409, 0.50, 28.06), vec4(160.206, 160.744, 3.19, 62.28), vec4(160.228, 160.390, 6.90, 71.29), \n    vec4(160.228, 160.413, 6.90, 76.23), vec4(160.806, 161.065, 0.50, 28.09), vec4(160.806, 163.003, 3.19, 56.31), vec4(160.806, 163.034, 3.19, 59.26), vec4(160.806, 162.931, 3.82, 56.39), \n    vec4(160.806, 162.931, 3.82, 64.32), vec4(160.806, 162.921, 3.82, 59.31), vec4(160.806, 162.981, 3.19, 64.30), vec4(160.828, 162.713, 7.50, 64.50), vec4(160.828, 162.684, 7.50, 68.50), \n    vec4(160.828, 162.731, 7.50, 59.50) );\n\n// First usable noteEvent index for every second\nconst ivec2 timeEventRanges[166] = ivec2[](\n    ivec2(0, 0), ivec2(0, 0), ivec2(0, 0), ivec2(0, 7), ivec2(0, 25), ivec2(0, 39), ivec2(5, 60), ivec2(25, 81), ivec2(39, 105), ivec2(60, 128), ivec2(81, 131), ivec2(104, 134), ivec2(119, 156), ivec2(119, 177), ivec2(133, 192), ivec2(140, 210), ivec2(170, 234), ivec2(192, 248), ivec2(209, 269), ivec2(226, 292), ivec2(226, 309), ivec2(269, 327), ivec2(285, 348), ivec2(301, 362), ivec2(322, 386), ivec2(322, 410), ivec2(362, 426), ivec2(385, 445), ivec2(405, 471), ivec2(415, 484), \n    ivec2(415, 506), ivec2(464, 535), ivec2(471, 564), ivec2(481, 596), ivec2(513, 628), ivec2(513, 650), ivec2(580, 688), ivec2(587, 715), ivec2(587, 743), ivec2(587, 773), ivec2(587, 803), ivec2(657, 823), ivec2(657, 859), ivec2(657, 882), ivec2(657, 912), ivec2(657, 940), ivec2(657, 967), ivec2(657, 994), ivec2(657, 1020), ivec2(657, 1054), ivec2(657, 1082), ivec2(1006, 1113), ivec2(1016, 1147), ivec2(1066, 1170), ivec2(1066, 1204), ivec2(1138, 1233), ivec2(1141, 1262), ivec2(1141, 1294), ivec2(1142, 1324), ivec2(1142, 1343), \n    ivec2(1279, 1375), ivec2(1286, 1400), ivec2(1286, 1428), ivec2(1342, 1452), ivec2(1350, 1476), ivec2(1350, 1502), ivec2(1350, 1540), ivec2(1350, 1565), ivec2(1350, 1593), ivec2(1350, 1621), ivec2(1350, 1637), ivec2(1350, 1655), ivec2(1350, 1676), ivec2(1466, 1697), ivec2(1626, 1711), ivec2(1653, 1732), ivec2(1697, 1764), ivec2(1711, 1767), ivec2(1730, 1771), ivec2(1756, 1793), ivec2(1756, 1807), ivec2(1757, 1822), ivec2(1775, 1846), ivec2(1806, 1863), ivec2(1821, 1885), ivec2(1844, 1906), ivec2(1863, 1921), ivec2(1863, 1939), ivec2(1906, 1964), ivec2(1921, 1978), \n    ivec2(1938, 1999), ivec2(1957, 2022), ivec2(1957, 2039), ivec2(1992, 2056), ivec2(2019, 2082), ivec2(2039, 2101), ivec2(2049, 2121), ivec2(2049, 2142), ivec2(2101, 2168), ivec2(2108, 2201), ivec2(2118, 2239), ivec2(2151, 2264), ivec2(2151, 2297), ivec2(2226, 2329), ivec2(2233, 2361), ivec2(2233, 2395), ivec2(2235, 2428), ivec2(2235, 2450), ivec2(2306, 2480), ivec2(2306, 2507), ivec2(2306, 2536), ivec2(2306, 2564), ivec2(2306, 2595), ivec2(2306, 2615), ivec2(2306, 2652), ivec2(2306, 2677), ivec2(2306, 2699), ivec2(2306, 2736), ivec2(2664, 2771), ivec2(2674, 2801), \n    ivec2(2725, 2837), ivec2(2725, 2865), ivec2(2725, 2898), ivec2(2809, 2934), ivec2(2809, 2970), ivec2(2810, 2993), ivec2(2810, 3025), ivec2(2959, 3048), ivec2(2964, 3076), ivec2(2965, 3108), ivec2(3024, 3133), ivec2(3032, 3150), ivec2(3034, 3187), ivec2(3034, 3216), ivec2(3034, 3242), ivec2(3034, 3271), ivec2(3034, 3304), ivec2(3034, 3308), ivec2(3034, 3336), ivec2(3034, 3353), ivec2(3152, 3366), ivec2(3308, 3393), ivec2(3337, 3414), ivec2(3357, 3437), ivec2(3376, 3461), ivec2(3376, 3482), ivec2(3376, 3504), ivec2(3376, 3523), ivec2(3376, 3542), ivec2(3376, 3556), \n    ivec2(3376, 3579), ivec2(3376, 3586), ivec2(3376, 3599), ivec2(3376, 3617), ivec2(3376, 3648), ivec2(3590, 3668), ivec2(3601, 3695), ivec2(3601, 3732), ivec2(3601, 3753), ivec2(3601, 3779), ivec2(3601, 3806), ivec2(3602, 3806), ivec2(3602, 3806), ivec2(3602, 3806), ivec2(3602, 3806), ivec2(3797, 3799) );\n\nconst int songLengthSeconds = 165;\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftySWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 435, 492, 492, 1579]], "test": "untested"}
{"id": "7tyXDw", "name": "Fork Warped Liq rogo1965 323", "author": "rogo1965", "description": "Licence CC0: Liquid Metal\nSome experimenting with warped FBM and very very fake lighting turned out ok ", "tags": ["2d", "fbm", "warp"], "likes": 14, "viewed": 559, "published": 3, "date": "1640790417", "time_retrieved": "2024-07-30T18:39:29.069396", "image_code": "// Licence CC0: Liquid Metal\n// Some experimenting with warped FBM and very very fake lighting turned out ok \n    \n#define PI  3.141592654\n#define TAU (2.0*PI)\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec2 hash2(vec2 p) {\n  p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n  return fract(sin(p)*18.5453);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nfloat tanh_approx(float x) {\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat onoise(vec2 x) {\n  x *= 0.5;\n  float a = sin(x.x);\n  float b = sin(x.y);\n  float c = mix(a, b, psin(TAU*tanh_approx(a*b+a+b)));\n  \n  return c;\n}\n\nfloat vnoise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 w = fract(x);\n    \n#if 1\n  // quintic interpolation\n  vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n#else\n  // cubic interpolation\n  vec2 u = w*w*(3.0-2.0*w);\n#endif    \n\n  float a = hash(i+vec2(0.0,0.0));\n  float b = hash(i+vec2(1.0,0.0));\n  float c = hash(i+vec2(0.0,1.0));\n  float d = hash(i+vec2(1.0,1.0));\n    \n  float k0 =   a;\n  float k1 =   b - a;\n  float k2 =   c - a;\n  float k3 =   d - c + a - b;\n\n  float aa = mix(a, b, u.x);\n  float bb = mix(c, d, u.x);\n  float cc = mix(aa, bb, u.y);\n  \n  return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;\n}\n\nfloat fbm1(vec2 p) {\n  vec2 op = p;\n  const float aa = 0.45;\n  const float pp = 2.03;\n  const vec2 oo = -vec2(1.23, 1.5);\n  const float rr = 1.2;\n  \n  float h = 0.0;\n  float d = 0.0;\n  float a = 1.0;\n  \n  for (int i = 0; i < 5; ++i) {\n    h += a*onoise(p);\n    d += (a);\n    a *= aa;\n    p += oo;\n    p *= pp;\n    rot(p, rr);\n  }\n  \n  return mix((h/d), -0.5*(h/d), pow(vnoise(0.9*op), 0.25));\n}\n\nfloat fbm2(vec2 p) {\n  vec2 op = p;\n  const float aa = 0.45;\n  const float pp = 2.03;\n  const vec2 oo = -vec2(1.23, 1.5);\n  const float rr = 1.2;\n  \n  float h = 0.0;\n  float d = 0.0;\n  float a = 1.0;\n  \n  for (int i = 0; i < 7; ++i) {\n    h += a*onoise(p);\n    d += (a);\n    a *= aa;\n    p += oo;\n    p *= pp;\n    rot(p, rr);\n  }\n  \n  return mix((h/d), -0.5*(h/d), pow(vnoise(0.9*op), 0.25));\n}\n\nfloat fbm3(vec2 p) {\n  vec2 op = p;\n  const float aa = 0.45;\n  const float pp = 2.03;\n  const vec2 oo = -vec2(1.23, 1.5);\n  const float rr = 1.2;\n  \n  float h = 0.0;\n  float d = 0.0;\n  float a = 1.0;\n  \n  for (int i = 0; i < 3; ++i) {\n    h += a*onoise(p);\n    d += (a);\n    a *= aa;\n    p += oo;\n    p *= pp;\n    rot(p, rr);\n  }\n  \n  return mix((h/d), -0.5*(h/d), pow(vnoise(0.9*op), 0.25));\n}\n\n\nfloat warp(vec2 p) {\n  vec2 v = vec2(fbm1(p), fbm1(p+0.7*vec2(1.0, 1.0)));\n  \n  rot(v, 1.0+iTime*1.8);\n  \n  vec2 vv = vec2(fbm2(p + 3.7*v), fbm2(p + -2.7*v.yx+0.7*vec2(1.0, 1.0)));\n\n  rot(vv, -1.0+iTime*0.8);\n    \n  return fbm3(p + 9.0*vv);\n}\n\nfloat height(vec2 p) {\n  float a = 0.045*iTime;\n  p += 9.0*vec2(cos(a), sin(a));\n  p *= 2.0;\n  p += 13.0;\n  float h = warp(p);\n  float rs = 3.0;\n  return 0.35*tanh_approx(rs*h)/rs;\n}\n\nvec3 normal(vec2 p) {\n  // As suggested by IQ, thanks!\n  vec2 eps = -vec2(2.0/iResolution.y, 0.0);\n  \n  vec3 n;\n  \n  n.x = height(p + eps.xy) - height(p - eps.xy);\n  n.y = 2.0*eps.x;\n  n.z = height(p + eps.yx) - height(p - eps.yx);\n  \n  \n  return normalize(n);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x*=iResolution.x/iResolution.y;\n //lights positions\n  const vec3 lp1 = vec3(2.1, -0.5, -0.1);\n  const vec3 lp2 = vec3(-2.1, -0.5, -0.1);\n\n  float h = height(p);\n  vec3 pp = vec3(p.x, h, p.y);\n  float ll1 = length(lp1.xz - pp.xz);\n  vec3 ld1 = normalize(lp1 - pp);\n  vec3 ld2 = normalize(lp2 - pp);\n \n  vec3 n = normal(p);\n  float diff1 = max(dot(ld1, n), 0.0);\n  float diff2 = max(dot(ld2, n), 0.0);\n  //lights colors\n  vec3 baseCol1 = vec3(1.0, 0.1, 0.6);\n  vec3 baseCol2 = vec3(0.0, 0.9, 0.0);\n\n  float oh = height(p + ll1*0.05*normalize(ld1.xz));\n  const float level0 = 0.0;\n  const float level1 = 0.125;\n  // VERY VERY fake shadows + hilight\n  vec3 scol1 = baseCol1*(smoothstep(level0, level1, h) - smoothstep(level0, level1, oh));\n  vec3 scol2 = baseCol2*(smoothstep(level0, level1, h) - smoothstep(level0, level1, oh));\n  // specular and diffuse strenght\n  vec3 col = vec3(0.0);\n  col += 0.55*baseCol1.zyx*pow(diff1, 1.0);\n  col += 0.55*baseCol1.zyx*pow(diff1, 1.0);\n  col += 0.55*baseCol2.zyx*pow(diff2, 1.0);\n  col += 0.55*baseCol2.zyx*pow(diff2, 1.0);\n  col += scol1*0.5;\n  col += scol2*0.5;\n\n  //col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tyXDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 194, 194, 279], [281, 281, 305, 305, 375], [377, 377, 397, 397, 495], [497, 497, 518, 518, 547], [549, 549, 577, 577, 653], [655, 655, 677, 677, 805], [807, 807, 829, 829, 1396], [1398, 1398, 1418, 1418, 1792], [1794, 1794, 1814, 1814, 2188], [2190, 2190, 2210, 2210, 2584], [2587, 2587, 2607, 2607, 2829], [2831, 2831, 2853, 2853, 3013], [3015, 3015, 3036, 3069, 3277], [3279, 3279, 3316, 3316, 3565], [3567, 3567, 3624, 3624, 4858]], "test": "untested"}
{"id": "7lGXWw", "name": "Dudeverse 21", "author": "levonchic", "description": "My 39.2C be like:", "tags": ["bitmap", "acid", "universe", "is", "my", "it", "2021", "wednesday", "dudes"], "likes": 8, "viewed": 363, "published": 3, "date": "1640781183", "time_retrieved": "2024-07-30T18:39:30.040799", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// MIT License (c) bitrate16\n#define WIDTH 40\n#define HEIGHT 32\n#define FWIDTH 40.\n#define FHEIGHT 32.\n#define COLORS 16\n#define COLORBITS 4\n#define COLORMASK 15\n#define POINTS4INT 8\n#define INTPERFRAME 160\n#define FRAMES 1\n\nvec4[16] palette = vec4[16] (\n\tvec4(0.6901960784313725, 0.5843137254901961, 0.3764705882352941, 1.0),\n\tvec4(0.8627450980392157, 0.8117647058823529, 0.6627450980392157, 1.0),\n\tvec4(0.788235294117647, 0.6705882352941176, 0.4392156862745098, 1.0),\n\tvec4(0.7294117647058823, 0.6705882352941176, 0.5215686274509804, 1.0),\n\tvec4(0.7725490196078432, 0.6745098039215687, 0.5176470588235295, 1.0),\n\tvec4(0.5882352941176471, 0.43529411764705883, 0.17647058823529413, 1.0),\n\tvec4(0.6274509803921569, 0.4745098039215686, 0.2823529411764706, 1.0),\n\tvec4(0.9019607843137255, 0.8784313725490196, 0.7647058823529411, 1.0),\n\tvec4(0.6196078431372549, 0.5372549019607843, 0.24313725490196078, 1.0),\n\tvec4(0.8196078431372549, 0.7529411764705882, 0.49019607843137253, 1.0),\n\tvec4(0.7372549019607844, 0.7647058823529411, 0.5725490196078431, 1.0),\n\tvec4(0.4196078431372549, 0.41568627450980394, 0.2823529411764706, 1.0),\n\tvec4(0.403921568627451, 0.396078431372549, 0.24313725490196078, 1.0),\n\tvec4(0.0, 0.0, 0.0, 0.0),\n\tvec4(0.8470588235294118, 0.792156862745098, 0.6588235294117647, 1.0),\n\tvec4(0.796078431372549, 0.7176470588235294, 0.5529411764705883, 1.0)\n);\n\nint[160] matrix = int[160] (\n\t0xdddddddd,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0xddddd1dd,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0xfddddddd,\n\t0xddddd1dd,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0xdddd2204,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0xdd00000d,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0xfdddddd,\n\t0xdd060020,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0xd06000dd,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0x5008dd,\n\t0xdddddddd,\n\t0xddd1dddd,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0x6600ddd,\n\t0xdddddddd,\n\t0xddd1dddd,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0xddd,\n\t0xdddddddd,\n\t0xddd1dddd,\n\t0x11dddddd,\n\t0x3333ff,\n\t0x5550,\n\t0xddddddd3,\n\t0xdd21d11,\n\t0x111edddd,\n\t0x33f111,\n\t0x4055500,\n\t0xdddddddf,\n\t0x506201dd,\n\t0x222221dd,\n\t0x22222222,\n\t0x2f050000,\n\t0xddddddf2,\n\t0x50222ddd,\n\t0x292,\n\t0x22222000,\n\t0x22000022,\n\t0xddddf1f0,\n\t0x20221ddd,\n\t0x2f,\n\t0x22200000,\n\t0x22,\n\t0xddd1f120,\n\t0xf002dddd,\n\t0x0,\n\t0x20020000,\n\t0x22ff,\n\t0xdd1fff20,\n\t0xf100dddd,\n\t0x2,\n\t0x0,\n\t0x2000,\n\t0xd11f2220,\n\t0xf12ddddd,\n\t0x3,\n\t0x320000,\n\t0x60000000,\n\t0xd1f22000,\n\t0xf1eddddd,\n\t0xf00f3,\n\t0x43000,\n\t0x60030000,\n\t0xd1ff0000,\n\t0x11dddddd,\n\t0x101ee00f,\n\t0x1fff3f01,\n\t0xfffe1e,\n\t0x11f20000,\n\t0xe1dddddd,\n\t0xee050f,\n\t0x111eee0b,\n\t0xf11f4e,\n\t0x1ff22000,\n\t0xe7dddddd,\n\t0x11ee0891,\n\t0xe1eee111,\n\t0xfee11,\n\t0x11402000,\n\t0x1ddddddd,\n\t0xeee1a1ce,\n\t0xeee1e11e,\n\t0x4f1e,\n\t0x7f224200,\n\t0xdddddddd,\n\t0x1eeeeeee,\n\t0xeeee11ee,\n\t0xfff03fff,\n\t0xdf222234,\n\t0xdddddddd,\n\t0x1eeeee17,\n\t0x1ee11111,\n\t0xffff1fee,\n\t0xdf4424f1,\n\t0xdddddddd,\n\t0x11ee111d,\n\t0xeee11111,\n\t0xe1111e11,\n\t0xde4422fe,\n\t0xdddddddd,\n\t0x1eeee1dd,\n\t0x11111111,\n\t0xe1711e11,\n\t0xd7f4fff1,\n\t0xdddddddd,\n\t0xeeef1ddd,\n\t0xe111eee1,\n\t0x1111ee11,\n\t0xdd1fff11,\n\t0xdddddddd,\n\t0xeeff1ddd,\n\t0x111eeeee,\n\t0x111eee1e,\n\t0xddde111e,\n\t0xdddddddd,\n\t0xe1eddddd,\n\t0x11eeeeee,\n\t0x11ee1e11,\n\t0xddddd111,\n\t0xdddddddd,\n\t0xe1dddddd,\n\t0x1eeeeeee,\n\t0x1111e111,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0xeeeeeeee,\n\t0xddd11111,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0xdddddddd,\n\t0x11111ddd,\n\t0xddddddd1,\n\t0xdddddddd\n);", "buffer_a_code": "// MIT License (c) bitrate16\n// Animated texture, no buffering\n\n// ! - Prevent compile entire shader and freeze\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 frag = ivec2(fragCoord);\n    \n    if (iFrame != 0) { \n        // Use buffered texture where branch prediction is disabled\n        // Hello from Radeon HD 6670\n        fragColor = texelFetch(iChannel0, frag, 0);\n\t} else {\n        frag /= int(min(iResolution.x, iResolution.y) * 0.03);\n\t\tfragColor = vec4(0.0);\n\t\tif (frag.x >= WIDTH || frag.x <= 0 || frag.y >= HEIGHT || frag.y <= 0)\n\t\t\treturn;\n\t\telse {\n\t\t\tint px = frag.y * WIDTH + frag.x;\n\t\t\tint pind = px / POINTS4INT;\n\t\t\tint bind = px % POINTS4INT;\n\t\t\t\n\t\t\tint colind = (matrix[pind] >> (bind * COLORBITS)) & COLORMASK;\n\t\t\t\n\t\t\tfragColor = palette[colind];\n\t\t}\n\t}\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// MIT License (c) bitrate16\n#define SCALE 0.2\n#define ROT_SCALEX 0.2\n#define ROT_SCALEY 0.1\n\n// Source: https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat c = cos(iTime * ROT_SCALEX);\n\tfloat s = sin(iTime * ROT_SCALEY);\n\tmat2 rot = mat2(c, -s, s, c);\n\t\n\tvec2 frag = iResolution.xy * 0.5 + (fragCoord.xy - iResolution.xy * 0.5) * rot * 2.;\n\tvec2 uv = frag / iResolution.xy;\n\t\n\tvec4 a = texture(iChannel0, fract(sign(mod(uv * 1.1, 2.) - 1.) * uv * 1.1)) * .99;\n\t\n    float an = float(iFrame % 50) * 3.14 * 0.02;\n    an = sin(an) * cos(an) * 0.1;\n    float sm = sin(an);\n\tfloat cm = cos(an);\n\tmat2 m = mat2(cm, -sm, sm, cm);\n    \n    vec4 b = texture(iChannel1, clamp(m * uv * (1.0 + 0.25 * sin(iTime * 0.1)), 0.0, 1.0));\n\t\n\tfragColor = b.a * b + (1. - b.a) * a;\n    fragColor.rgb *= hsv2rgb(vec3(iTime, 0.5 + 0.5 * sin(iTime), 1.0));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGXWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 121]], "test": "untested"}
{"id": "ftGXDm", "name": "Mandelstatue Fake 3D", "author": "InvalidString", "description": "Mandelbrot sets with different power values stacked on top of one another.", "tags": ["mandelbrot", "fake3d"], "likes": 4, "viewed": 213, "published": 3, "date": "1640774507", "time_retrieved": "2024-07-30T18:39:30.914463", "image_code": "vec2 cMul(vec2 a, vec2 b){\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\n\nvec2 cPow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\n\n\nvec2 rot(float a, vec2 p){\n    return cMul(p, vec2(cos(a),sin(a)));\n}\n\nfloat sqrl(vec2 v){return dot(v,v);}\n\n#define sw(x) (sin(x)*.5+.5)\n\nfloat mb(vec2 uv, float power){\n    vec2 x = vec2(0);\n    \n    for(int j = 0; j< MANDELBROT_ITERATIONS; j++){\n        x += uv;\n        \n        x = cPow(x,power);\n        \n        float l = sqrl(x);\n        \n        if(l > 4.){return l;}\n        \n        //x = cMul(x,x);\n        \n    }\n    \n    return sqrl(x);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    \n    uv *= 3.;\n    \n    \n    uv *= vec2(1,2); // Squish\n    \n    \n    \n    \n    vec3 col = vec3(0);\n    \n    uv += vec2(0,1.3);\n    \n    \n    vec2 offset = vec2(0,-LAYER_OFFSET);\n    \n    for(float i = MAX_POW; i>MIN_POW; i-=LAYER_OFFSET/2.){\n    \n        vec2 ruv = rot(iTime*0.5,uv);\n        \n        float m = mb(ruv, i);\n    \n        \n        if(m < 4.){\n            col = vec3(sw(i*10.), sw(i*50.) * 0.1+0.4, sw(ruv.x * ruv.y*5.));\n        }\n        \n        uv += offset;\n    \n    }\n    \n    \n    \n    \n    \n    //col = mb(uv)<2. ? vec3(0) : vec3(1);\n    //col = mix(vec3(0),vec3(1), smoothstep(1., 3., length(x)));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define MANDELBROT_ITERATIONS 15\n#define LAYER_OFFSET 0.02\n\n#define MIN_POW 1.\n#define MAX_POW 3.", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGXDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 79], [81, 81, 111, 111, 211], [214, 214, 240, 240, 283], [285, 285, 304, 304, 321], [353, 353, 384, 384, 666], [671, 671, 728, 728, 1476]], "test": "untested"}
{"id": "NtySWm", "name": "Simulated smoke", "author": "moshuying", "description": "Simulated smoke", "tags": ["smoke"], "likes": 5, "viewed": 544, "published": 3, "date": "1640763818", "time_retrieved": "2024-07-30T18:39:31.866917", "image_code": "vec3 Effect(float speed, vec2 uv, float time)\n{\n    float t = mod(time*speed,60.0);\n    float rt =0.01*sin(t*0.45);\n    mat2 m1 = mat2(cos(rt),-sin(rt),-sin(rt),cos(rt));\n    vec2 uva=uv*m1;\n    float irt = 0.005* cos(t*0.05);\n    mat2 m2 = mat2(sin(irt),cos(irt),-cos(irt),sin(irt));\n    for(int i=1;i<40;i+=1)\n    {   \n        float it = float(i);\n        uva*=(m2);\n        uva.y+=-1.0+(0.6/it) * cos(t + it*uva.x + 0.5*it)\n        *float(mod(it,2.0)==0.0);\n        uva.x+=1.0+(0.5/it) * cos(t + it*uva.y + 0.5*(it+15.0));\n    }\n    //Intensity range from 0 to n;\n    float n = 0.5;\n    float r = n + n * sin(4.0*uva.x+t);\n    float gb = n + n * sin(3.0*uva.y);\n    return vec3(r,gb*0.8*r,gb*r);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(Effect(.02,uv,iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtySWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 700], [701, 701, 758, 808, 1014]], "test": "untested"}
{"id": "flyXWw", "name": "view-grubber", "author": "IWBTShyGuy", "description": "The message changes completely between the thumbnail and the main player.", "tags": ["shadertoy", "message", "itime", "iframe"], "likes": 15, "viewed": 857, "published": 3, "date": "1640753211", "time_retrieved": "2024-07-30T18:39:32.874223", "image_code": "// Determines if a person is watching a thumbnail.\nbool isThumbnail() { return textureLod(iChannel0, vec2(.5), 0.).x > .5; }\n\nfloat hash(float x) { return fract(sin(x * 114.514) * 191981.0); }\nfloat noise(float t, float gen) { return mix(hash(floor(t) + gen), hash(floor(t) + 1. + gen), fract(t)); }\nvec2 disp(float s, float gen) { return (2. * vec2(noise(s, gen), noise(s, gen + .42)) - 1.) * .0075; }\n\nfloat letter(in vec2 uv, in int idx) {\n    uv = (clamp(uv, 0., 1.) + vec2(idx % 16, 15 - idx / 16)) / 16.;\n    return texture(iChannel1, uv).x;\n}\n\n#define RENDER_MESSAGE(ARRAY, SIZE, Y_CENTER, disp, RGB) \\\nv = U / r.y + disp; len = ARRAY.length();\\\ndel = (v.y - Y_CENTER) / SIZE;\\\na = (v.x * 2. - r.x / r.y) / SIZE + float(len) * .5;\\\nv = vec2(fract(a) / 2. + .25, del + .5);\\\nif (0 <= (idx = int(floor(a))) && idx < len && abs(del) < .5)\\\nRGB += max(letter(v, ARRAY[idx]) - .1, 0.) / .9;\n\nconst int Youre_only_seeing_the_thumbnail[] = int[](\n    89, 111, 117, 39, 114, 101, 32, 111, 110, 108, 121, 32, 115, 101, 101, 105, 110, 103, 32, 116, 104, 101,\n    32, 116, 104, 117, 109, 98, 110, 97, 105, 108, 32, 58, 45, 40\n);\n\nconst int CLICK_HERE[] = int[](62, 32, 67, 76, 73, 67, 75, 32, 72, 69, 82, 69, 32, 60);\n\nconst int Thank_you_for_the_view[] = int[](\n    84, 104, 97, 110, 107, 32, 121, 111, 117, 32, 102, 111, 114, 32, 116, 104, 101, 32, 118, 105, 101, 119,\n    32, 59, 45, 41\n);\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    vec2 r = iResolution.xy, v, q; float a, del, s = iTime * 30.; int len, idx; O = vec4(0,0,0,1);\n    \n    // To make the Preview screen for thumbnails, only the first frame should be a thumbnail image.\n    bool bIsThumbnail = iFrame == 0 || isThumbnail();\n    if (bIsThumbnail) {\n        RENDER_MESSAGE(CLICK_HERE, .15, .4, disp(s, .1), O.x)\n        RENDER_MESSAGE(CLICK_HERE, .15, .4, disp(s, .15), O.y)\n        RENDER_MESSAGE(CLICK_HERE, .15, .4, disp(s, .2), O.z)\n        RENDER_MESSAGE(Youre_only_seeing_the_thumbnail, .095, .65, disp(s, .1), O.x)\n        RENDER_MESSAGE(Youre_only_seeing_the_thumbnail, .095, .65, disp(s, .15), O.y)\n        RENDER_MESSAGE(Youre_only_seeing_the_thumbnail, .095, .65, disp(s, .2), O.z)\n    } else {\n        RENDER_MESSAGE(Thank_you_for_the_view, .09, .5, vec2(0), O.xyz)\n    }\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\n// thumbnail judge\n//\n// The MIT License\n// Copyright  2021 IWBTShyGuy\n//\n\n// If one sees the thumnail, this image is white, else is black.\n//\n// # Details\n// If `iTime` of the first four frame does not exceed 10, it is the main player;\n// if it exceeds 10, it is the thumbnail.\n// https://www.shadertoy.com/view/7tV3zK\n// https://www.shadertoy.com/view/sl3XDs\nvoid mainImage(out vec4 O, in vec2 U) {\n    if (iFrame < 4) O = vec4(iTime > 8. ? 1. : 0.);\n    else O = texture(iChannel0, vec2(.5));\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyXWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 51, 71, 71, 124], [126, 126, 147, 147, 192], [193, 193, 226, 226, 299], [300, 300, 331, 331, 402], [404, 404, 442, 442, 549]], "test": "untested"}
{"id": "slVSDD", "name": "zoomy bouncy flower", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 6, "viewed": 310, "published": 3, "date": "1640745210", "time_retrieved": "2024-07-30T18:39:33.784789", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat func(float a, float b) {\n    return tanh(a * b) / tanh(a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n\n    float sc = 4.;\n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = fract(sc * uv) - 0.5;\n       \n    // thickness of burst\n    float b = 2. * thc(1., log(r) - iTime);\n    // closeness of bursts (min 1. I think)\n    float c = 1.;\n    // rotation (do b * (A + t), A could be uv.x for example)\n    float t = .2 * iTime;\n    \n    float x = mod(b * (5. * 0.5 * a / pi + t), c * b) - 0.5 * b;\n   \n    float n = 0.5 * (1. + cos(pi * clamp(x, -1., 1.))); // 3. * pi\n    n = smoothstep(0., 1., n);\n    // n = n * n * (3. - 2. * n);    \n    \n    float val = 4.; // <- change me to 1., 2., etc.\n    float d = 0.75 * (func(5. + 8. * cos(mix(2., 12., 0.5 + 0.5 * ths(4., iTime)) * r - 4. * iTime), n/val) - 0.5);\n    float k = 0.5;\n    float s = smoothstep(-k, k, -thc(4., 20. * d + iTime) * r + d);\n   // s = 2. * s * s;\n    \n    vec3 e = vec3(1.);\n    vec3 col = (1.-s) * pal(0.12 * iTime, 1.2 * e, 0.7 * e, e, vec3(0., 0.33,0.66));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVSDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 191, 191, 232], [234, 234, 261, 261, 302], [304, 304, 372, 372, 415], [417, 417, 437, 437, 512], [514, 514, 538, 538, 578], [580, 580, 610, 610, 646], [648, 648, 705, 705, 1791]], "test": "untested"}
{"id": "stc3Df", "name": "blackhole wave 1", "author": "gchipunov", "description": "A simple 2D plane deformation driven by the mouse (more info here: https://iquilezles.org/articles/deform/deform.htm)", "tags": ["2d", "planedeformation"], "likes": 4, "viewed": 292, "published": 3, "date": "1640733235", "time_retrieved": "2024-07-30T18:39:34.551738", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n  vec2 m = -1.0 + 2.0 * iMouse.xy / iResolution.xy;\n\n  float a1 = atan(p.y-m.y,p.x-m.x);\n  float r1 = sqrt(dot(p-m,p-m));\n  float a2 = atan(p.y+m.y,p.x+m.x);\n  float r2 = sqrt(dot(p+m,p+m));\n\n  vec2 uv;\n  uv.x = 0.12*clamp(sqrt(exp(iTime)),exp(r1-r2)*0.55,a2+r1+a2*iTime) + (r1-r2)*0.55 + sin(exp(iTime/r2));\n  uv.y = asin(sin(a1-a2))/3.1416;\n\t\n\n  vec3 col = texture( iChannel0, 0.125*uv ).zyx;\n\n  float w = exp(-55.0*r1) + exp(-55.0*r2*r2);\n\n  w += 0.25*smoothstep( 0.03,1.0,sin(228.0*uv.x));\n  w += 0.25*smoothstep( 0.93,1.0,sin(128.0*uv.y));\n\t\n  fragColor = vec4(fract(sqrt (col+w) +(col+w) / 1.1) ,1.0);\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.5,0.0,1.0);\n}", "buffer_a_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stc3Df.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[125, 125, 182, 182, 847]], "test": "untested"}
{"id": "ft33Df", "name": "background layer lines", "author": "gchipunov", "description": "made in 2 minutes", "tags": ["2d", "gradiant", "stock"], "likes": 0, "viewed": 177, "published": 3, "date": "1640733201", "time_retrieved": "2024-07-30T18:39:35.318688", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0/uv.x,4));\n vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0,4.0/uv.x));\n vec3 col3 = 0.5 + 0.5*cos(iTime+uv.xyy+vec3(0,2.0,4.0/uv.x));\nvec3 col4 = mix(col,col2,cos(iTime));\n\n//vec3 col5 = cos(col);//smoothstep(col,col2,col4);\n\nvec3 col5 = cos(smoothstep(col,col2/2.0,col4/2.0));//;\n\n    // Output to screen\n    fragColor = vec4(col5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft33Df.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 575]], "test": "untested"}
{"id": "Nt33Df", "name": "liness and half circle", "author": "gchipunov", "description": "made in 2 minutes", "tags": ["2d", "gradiant", "stock"], "likes": 0, "viewed": 187, "published": 3, "date": "1640733174", "time_retrieved": "2024-07-30T18:39:36.110570", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0/uv.x,4));\n vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0,4.0/uv.x));\n vec3 col3 = 0.5 + 0.5*cos(iTime+uv.xyy+vec3(0,2.0,4.0/uv.x));\nvec3 col4 = mix(col,col2,cos(iTime));\n\n//vec3 col5 = cos(col);//smoothstep(col,col2,col4);\n\nvec3 col5 = cos(smoothstep(col/3.0,col2/3.0,col4/2.0))/2.0;//;\n\n    // Output to screen\n    fragColor = vec4(col5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt33Df.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 583]], "test": "untested"}
{"id": "7lKSWW", "name": "Truchet + Kaleidoscope FTW", "author": "mrange", "description": "CC0: Truchet + Kaleidoscope FTW\nBit of experimenting with kaleidoscopes and truchet turned out nice\nQuite similar to an earlier shader I did but I utilized a different truchet pattern this time", "tags": ["kaleidoscope", "truchet"], "likes": 294, "viewed": 11279, "published": 3, "date": "1640723365", "time_retrieved": "2024-07-30T18:39:36.939354", "image_code": "// CC0: Truchet + Kaleidoscope FTW\n//  Bit of experimenting with kaleidoscopes and truchet turned out nice\n//  Quite similar to an earlier shader I did but I utilized a different truchet pattern this time\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define RESOLUTION      iResolution\n#define TIME            iTime\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)         (0.5+0.5*cos(x))\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 p) {\n  float a = dot(p, vec2 (127.1, 311.7));\n  return fract(sin (a)*43758.5453123);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\n// The path function\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.075*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\n// The derivate of the path function\n//  Used to generate where we are looking\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\n// The second derivate of the path function\n//  Used to generate tilt\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.125*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\nvec2 cell_df(float r, vec2 np, vec2 mp, vec2 off) {\n  const vec2 n0 = normalize(vec2(1.0, 1.0));\n  const vec2 n1 = normalize(vec2(1.0, -1.0));\n\n  np += off;\n  mp -= off;\n  \n  float hh = hash(np);\n  float h0 = hh;\n\n  vec2  p0 = mp;  \n  p0 = abs(p0);\n  p0 -= 0.5;\n  float d0 = length(p0);\n  float d1 = abs(d0-r); \n\n  float dot0 = dot(n0, mp);\n  float dot1 = dot(n1, mp);\n\n  float d2 = abs(dot0);\n  float t2 = dot1;\n  d2 = abs(t2) > sqrt(0.5) ? d0 : d2;\n\n  float d3 = abs(dot1);\n  float t3 = dot0;\n  d3 = abs(t3) > sqrt(0.5) ? d0 : d3;\n\n\n  float d = d0;\n  d = min(d, d1);\n  if (h0 > .85)\n  {\n    d = min(d, d2);\n    d = min(d, d3);\n  }\n  else if(h0 > 0.5)\n  {\n    d = min(d, d2);\n  }\n  else if(h0 > 0.15)\n  {\n    d = min(d, d3);\n  }\n  \n  return vec2(d, d0-r);\n}\n\nvec2 truchet_df(float r, vec2 p) {\n  vec2 np = floor(p+0.5);\n  vec2 mp = fract(p+0.5) - 0.5;\n  return cell_df(r, np, mp, vec2(0.0));\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {\n  float h_ = hash(n);\n  float h0 = fract(1777.0*h_);\n  float h1 = fract(2087.0*h_);\n  float h2 = fract(2687.0*h_);\n  float h3 = fract(3167.0*h_);\n  float h4 = fract(3499.0*h_);\n\n  float l = length(pp - ro);\n\n  vec3 hn;\n  vec2 p = (pp-off*vec3(1.0, 1.0, 0.0)).xy;\n  p *= ROT(0.5*(h4 - 0.5)*TIME);\n  float rep = 2.0*round(mix(5.0, 30.0, h2));\n  float sm = 0.05*20.0/rep;\n  float sn = smoothKaleidoscope(p, sm, rep);\n  p *= ROT(TAU*h0+0.025*TIME);\n  float z = mix(0.2, 0.4, h3);\n  p /= z;\n  p+=0.5+floor(h1*1000.0);\n  float tl = tanh_approx(0.33*l);\n  float r = mix(0.30, 0.45, PCOS(0.1*n));\n  vec2 d2 = truchet_df(r, p);\n  d2 *= z;\n  float d = d2.x;\n  float lw =0.025*z; \n  d -= lw;\n  \n  vec3 col = mix(vec3(1.0), vec3(0.0), smoothstep(aa, -aa, d));\n  col = mix(col, vec3(0.0), smoothstep(mix(1.0, -0.5, tl), 1.0, sin(PI*100.0*d)));\n//  float t0 = smoothstep(aa, -aa, -d2.y-lw);\n  col = mix(col, vec3(0.0), step(d2.y, 0.0));\n  //float t = smoothstep(3.0*lw, 0.0, -d2.y);\n//  float t = smoothstep(aa, -aa, -d2.y-lw);\n  float t = smoothstep(aa, -aa, -d2.y-3.0*lw)*mix(0.5, 1.0, smoothstep(aa, -aa, -d2.y-lw));\n  return vec4(col, t);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float d = pow(max(dot(rd, vec3(0.0, 0.0, 1.0)), 0.0), 20.0);\n  return vec3(d);\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = (2.0+1.0*tanh_approx(lp));\n//  float rdd = 2.0;\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const float planeDist = 1.0-0.25;\n  const int furthest = 6;\n  const int fadeFrom = max(furthest-5, 0);\n\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.95;\n  bool cutOut = false;\n\n  // Steps from nearest to furthest plane and accumulates the color \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = smoothstep(planeDist*float(furthest), planeDist*float(fadeFrom), nz);\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.xyz = mix(skyCol, pcol.xyz, fadeIn);\n      pcol.w *= fadeOut;\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm  = TIME*0.25;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, q);\n  col *= smoothstep(0.0, 4.0, TIME);\n  col = postProcess(col, q);\n \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKSWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[444, 504, 544, 544, 703], [705, 765, 805, 805, 847], [849, 909, 931, 931, 979], [981, 1041, 1061, 1061, 1143], [1145, 1205, 1233, 1299, 1375], [1377, 1460, 1499, 1499, 1584], [1586, 1669, 1705, 1705, 1938], [1940, 1940, 1979, 1979, 2008], [2010, 2010, 2040, 2040, 2067], [2069, 2069, 2091, 2091, 2135], [2137, 2137, 2158, 2158, 2203], [2205, 2291, 2336, 2336, 2490], [2492, 2492, 2553, 2553, 2766], [2768, 2789, 2811, 2811, 2945], [2947, 3026, 3049, 3049, 3124], [3126, 3196, 3220, 3220, 3299], [3301, 3301, 3352, 3352, 4059], [4061, 4061, 4095, 4095, 4195], [4197, 4197, 4265, 4265, 5396], [5398, 5398, 5431, 5431, 5514], [5516, 5516, 5572, 5572, 7075], [7077, 7077, 7106, 7106, 7407], [7409, 7409, 7464, 7464, 7691]], "test": "untested"}
{"id": "flKXWD", "name": "drugs", "author": "tungster24", "description": "just... drugs.", "tags": ["drugs"], "likes": 2, "viewed": 218, "published": 3, "date": "1640716475", "time_retrieved": "2024-07-30T18:39:37.846928", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*3.0-1.5,m=iMouse.xy/iResolution.xx;\n    float l = sin(uv.x*uv.y+iTime);\n    uv = uv+atan(l+cos(uv.x)+sin(uv.y));\n    uv = uv*l*cos(l)*sin(l);\n    uv = vec2(uv.x*uv.x-uv.y*uv.y,uv.y*uv.x*2.0);\n\n    vec4 col = texture(iChannel0,uv.xy/uv.xx*uv.yy);\n    col = 1.0/col-1.0;\n    col = 1.0/col;\n    \n    col = sin(col.yzxw)+1.0;\n    col = col.zyxw+(uv.x+uv.y);\n    uv = uv+col.rg;\n    uv = uv*col.rb;\n    col = col*sin(uv.x+iTime)*cos(uv.y+iTime);\n    col = round(col*(1.0/abs(sin(iTime))))/(1.0/abs(sin(iTime)));\n    col = vec4(sin(col.x),cos(col.y),tan(col.x*col.y),col.w);\n\n    // Output to screen\n    fragColor = vec4(col);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flKXWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 770]], "test": "untested"}
{"id": "ftVSDW", "name": "SMOOTH_THRESHOLD_VIDEO", "author": "SimonOakey", "description": "threshold filter for video with some fast blur in prior to filter artefacts - If you have any performance improvements - let me know :)", "tags": ["video", "blur", "threshold"], "likes": 6, "viewed": 327, "published": 3, "date": "1640707508", "time_retrieved": "2024-07-30T18:39:39.057690", "image_code": " \n\nvec3 fastBLUR(vec3 _col, vec2 _uv, float smoothy){\n\n    // forked from https://www.shadertoy.com/view/Xltfzj   :)\n    \n    float Pi = 6.28318530718; // Pi*2\n    \n    // GAUSSIAN BLUR SETTINGS {{{\n    float Directions = 7.0 ; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)\n    float Quality = 4.0; // BLUR QUALITY (Default 4.0 - More is better but slower)\n    float Size = 17.0*smoothy + 1.; // BLUR SIZE (Radius)\n    // GAUSSIAN BLUR SETTINGS }}}\n   \n    vec2 Radius = Size/iResolution.xy;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = _uv/iResolution.xy;\n    // Pixel colour\n    vec3 Color = _col;\n    \n    // Blur calculations\n    for( float d=0.0; d<Pi; d+=Pi/Directions)\n    {\n\t\tfor(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)\n        {\n\t\t\tColor += texture( iChannel0, _uv+vec2(cos(d),sin(d))*Radius*i).rgb;\t\t\n        }\n    }\n    \n    // Output to screen\n    Color /= Quality * Directions - 8.0;\n    return Color;\n\n\n\n}\n\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*16.0   +vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0,1.,1.), rgb, c.y);\n}\n\n\n\nfloat returnThresholdedShadeFromColor(vec3 _col, float _amount){\n\n\n    float _shade = (_col.x+_col.y + _col.z) * .333333;\n    \n    _shade *=  _amount;\n    \n    _shade = round(_shade);\n\n    _shade /=  _amount;\n\n    return _shade;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n   \n   // get relative mouse coordinates\n   float rmy = iMouse.y/iResolution.y;\n   float rmx = iMouse.x/iResolution.x;\n    \n    \n    // redudndant - only for demo purpose\n     if(iMouse.x ==0.){ rmx = .5 ;}\n     if(iMouse.y ==0.){ rmy = .5 ;}\n     \n   \n   // get image from video\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture( iChannel0, uv ).rgb;\n   \n   \n   // do some fast blur to reduce artefacts\n    col = fastBLUR(col,uv,rmx);\n   \n   //grayscale channel threshold\n    float _shade =  returnThresholdedShadeFromColor(col,6.*rmy+1.);\n     \n    col = vec3( _shade,_shade,_shade);\n\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVSDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 53, 116, 964], [968, 968, 995, 995, 1134], [1138, 1138, 1202, 1202, 1369], [1372, 1372, 1429, 1474, 2070]], "test": "untested"}
{"id": "NlVSDW", "name": "glass spirals thing", "author": "SnoopethDuckDuck", "description": "added too much stuff, looks okay", "tags": ["e"], "likes": 4, "viewed": 268, "published": 3, "date": "1640706878", "time_retrieved": "2024-07-30T18:39:39.954293", "image_code": "#define pi 3.14159\n\nfloat func(float a, float b) {\n    return tanh(a * b) / tanh(a);\n}\n\nfloat crv(float a, float b) {\n    float tr = 2. * max(fract(b), fract(-b)) - 1.;\n    tr *= tr * (3. - 2. * tr);\n    return func(a, 1. - func(a, tr));\n}\n\nvec3 crv(float a, vec3 v) {\n    return vec3(crv(a,v.x), crv(a, v.y), crv(a, v.z));\n}\n\nfloat thc(float a, float b) {\n    return func(a, cos(b));\n}\n\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b * crv(4., 6.28318*(c*t+d) ); // dont think 2pi is needed \n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    uv *= 0.8;\n    float a = 3. * atan(uv.y, uv.x);\n    float r = (1. + 0.5 * crv(1., (2./3.) * 0.5 * a / pi - 0.2 * iTime)) * length(uv);\n    //r = log(10. * r +crv(0.1, 0.5 * a /pi + 0. * r));\n    r = log(r + 0.58* cos(r));\n     \n    float b0 = 0.5 + (1. + thc(2., 4. * a + 10. * r + thc(4., 24. * r - iTime) + iTime));\n    float b01 = thc(4., 3. * a + 10. * cos(iTime) * r - iTime);\n    float b = b0 * b01 * (1. + cos(a + 10. * r - iTime));\n    float b2 = 10. * cos(3.5 * a + 10. * cos(a - 1. * iTime) +  10. * r - iTime);\n\n    float d = crv(b2 * b, 0.5 * a / pi + 2. * r - iTime);\n    float k = 480. - 40. * b0 * b01 * b; // 0.5 * b;\n    k = clamp(k, -1., 1.);\n    float s = smoothstep(-k, k, -d + 0.8 * b);\n    \n   // s = sqrt(s);\n    s *= 0.95 + 0.1 * h21(vec2(s));\n   //s = s * s * (3. - 2. * s);\n   // s *= 2. * s;\n\n  //  float s2 = clamp(2. * r * crv(10., 0.5 * a / pi + 3. * r + iTime),0.,1.);\n    \n    vec3 e = vec3(1.);\n    vec3 col = s * pal(s + 0.1 * iTime, e, e, e, vec3(0.,0.33,0.66));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlVSDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 50, 50, 86], [88, 88, 117, 117, 239], [241, 241, 268, 268, 325], [327, 327, 356, 356, 386], [389, 389, 457, 457, 534], [536, 536, 556, 556, 631], [633, 633, 690, 690, 1794]], "test": "untested"}
{"id": "7lGXDD", "name": "Concrete cubes", "author": "z0rg", "description": "Concrete cubes", "tags": ["3d", "cubes", "concrete"], "likes": 31, "viewed": 518, "published": 3, "date": "1640702641", "time_retrieved": "2024-07-30T18:39:40.839925", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).xyz;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\n\n// Thanks IQ !\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nvec2 map(vec3 p)\n{\n    vec3 op = p;\n    vec2 acc = vec2(10000.,-1.);\n    \n    float rep = 2.5;\n    vec2 id = floor((p.xz+rep*.5)/rep);\n    p.x += id.y;\n    p.xz = mod(p.xz+rep*.5,rep)-rep*.5;\n    p.xy *= r2d(PI*.25);\n    float shape = sdRoundBox(p, vec3(1.), .05);\n    acc = _min(acc, vec2(shape, 0.));\n    // Mmmmh id' like to make only the edges a bit broken...\n    // but I've no idea how :p\n    float alignedEdge = -op.y - 1.4;\n    acc.x += texture(iChannel0, op.xz*.1+.01*id.x).x*.5*(sat(alignedEdge*1.));\n    float face = abs(p.z)-1.;\n    acc.x += texture(iChannel0, op.xz*.1).x*1.5*(sat(face*1.))\n    *sat(sdRoundBox(p, vec3(.8,.8,10.), .05));\n    acc.x += texture(iChannel0, op.xz*.1).x*.0033;\n    acc = _min(acc, vec2(-op.y-.4, 0.));\n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01,0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x*.2;\n    }\n    return vec3(-1.);\n}\n\nvec3 getEnv(vec3 rd)\n{\n    return texture(iChannel1, rd*vec3(1.,-1.,1.)).xyz*.5;\n}\n\nvec3 getMat(vec3 res, vec3 rd, vec3 p, vec3 n)\n{\n    vec3 col = vec3(0.);\n    vec3 lpos = vec3(0.,-10.,10.)+1.81*(vec3(rand(), rand(), rand())-.5);\n    vec3 ldir = lpos-p;\n    vec3 h = normalize(rd+ldir);\n    \n    vec3 resshadow = trace(p+n*0.01, normalize(ldir), 64);\n    if (resshadow.y < 0.)\n    {\n        col = pow(sat(dot(n,h)), 2.)*vec3(0.506,0.996,0.937)*.25;\n        col += pow(sat(dot(n,h)), .5)*vec3(0.992,0.702,0.545);\n    }\n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    \n    float d = 9.;\n    float t = sin(iTime*.1)*.5+2.5;\n    vec3 dof = (vec3(rand(), rand(), rand())-.5)*.002;\n    vec3 ro = vec3(sin(t)*d,-5.,cos(t)*d);\n    vec3 ta = vec3(0.,-1.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    ro += dof;\n    rd = getCam(rd, uv)-dof;\n    \n    vec3 res = trace(ro, rd, 512);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        \n        col = getMat(res, rd, p, n);\n        vec3 diff = normalize(vec3(rand(), rand(), rand())-.5);\n        if (dot(diff, n) < 0.)\n            diff = -diff;\n        vec3 resdiff = trace(p+n*0.01, diff, 64);\n        if (resdiff.y > 0.)\n        {\n            vec3 pdiff = p+diff*resdiff.y;\n            vec3 ndiff = getNorm(pdiff, resdiff.x);\n            \n            col += getMat(resdiff, diff, pdiff, ndiff); \n        }\n        else\n            col += getEnv(diff);\n    }\n    else\n        col += getEnv(rd)*2.;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    seed = texture(iChannel3, uv).x;\n    seed+= iTime;\n    vec3 col = rdr(uv);\n    \n    col *= pow(1.-sat(length(uv)-.4), .2);\n    col = sat(col);\n    col = mix(col, texture(iChannel2, fragCoord/iResolution.xy).xyz, .95);\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0.,1.)\n#define PI 3.14159265\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Stolen from 0b5vr here https://www.shadertoy.com/view/ss3SD8\nfloat hash11(float p)\n{\n    return (fract(sin((p)*114.514)*1919.810));\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGXDD.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 571]], "test": "untested"}
{"id": "styXWD", "name": "VORONOI_SHATTER_WEBCAM", "author": "SimonOakey", "description": "basic playing with shattering the webcam stream through voronoi", "tags": ["voronoi", "worley", "shatter", "webcam", "mirror", "split"], "likes": 7, "viewed": 400, "published": 3, "date": "1640693224", "time_retrieved": "2024-07-30T18:39:41.633803", "image_code": "vec2 hash( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)));\n    return fract(sin(p)*18.5453);\n}\n\n// return distance, and cell id\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n      //vec2  r = g - f + o;\n\t    vec2  r = g - f + (0.5+0.5*sin(iTime+6.2831*o));\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/max(iResolution.x,iResolution.y);\n   p.y *=1.77;\n   \n   /*\n     \n     // axial mirror\n     p.x -=.5;\n     p.y -=.5;\n   \n    p.x = abs(-p.x*2.);\n    p.y = abs(-p.y*2.);\n    \n    */\n    \n    float rmx = iMouse.x/iResolution.x;\n    float rmy = iMouse.y/iResolution.y;\n    \n        \n    // redudndant - only for demo purpose\n     if(iMouse.x ==0.){ rmx = .7 ;}\n     if(iMouse.y ==0.){ rmy = .7 ;}\n    \n    // voronoi patterm\n    vec2 c = voronoi( 3.0+p*rmx*12. );\n\n   \n   \n    \n    //basic voronoi uv in gray\n    vec3 col = vec3(c.y,c.y,c.y);\n    \n    // add distance to center\n    col -= vec3(c.x,c.x,c.x);\n   \n   // above only for testing\n   \n   \n   // get real uv data\n    vec2 vpos = p.xy;\n    \n   \n    \n    vpos.xy -= c.yy*rmy;\n  \n  // distord by voronoi distance - todo - looks shitty ;)\n   //vpos += (( c.xx *6.3)-1.0)*.04*c.x*(1.-rmx);\n   \n   //safety first\n    vpos.x = abs(vpos.x);\n    vpos.y = abs(vpos.y);\n   \n    \n     col = texture( iChannel0, vpos.xy ).rgb;\n     \n     // darken cell edges\n     col -= c.xxx*.33*rmy;\n     \n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/styXWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 52, 167], [169, 201, 228, 228, 655], [657, 657, 714, 714, 1815]], "test": "untested"}
{"id": "flySWD", "name": "Loverlamp a la Metallicaustic", "author": "xenn", "description": "Mousey mousey zoo zoo", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 11, "viewed": 446, "published": 3, "date": "1640661143", "time_retrieved": "2024-07-30T18:39:42.859526", "image_code": "//forked\n\n#define HEIGHT 175.50\n#define BRIGHTNESS 2.5\n\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n/**\n\tUse Buffer A in iChannel0 for 3D letters. Read description!\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n//void mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n    // Normalized pixel coordinates (from 0 to 1)\n    \n   \n    vec2 uv = fragCoord/iResolution.xy;\n    //Texel Size\n    vec2 texel = vec2(1.) / iResolution.xy;\n    \n     vec4 frogColor = texture(iChannel3, uv);\n\n    vec3 normal = bump2Normal(uv, iChannel2, HEIGHT, texel);\n   \tvec3 normalRGB = normal2rgb(normal);\n    \n    vec3 lightDir = normalize(vec3(abs(sin(iTime/20.)), -abs(cos(iTime/40.)), abs(sin(iTime/40.))));\n    \n    vec3 toLightDir = vec3(0.0) - lightDir;\n    \n    float mouseX = iMouse.x / iResolution.x;\n    \n\tif (mouseX < 01.99) {\n        frogColor = vec4(BRIGHTNESS*dot(toLightDir, normalize(normal)));\n        frogColor*=texture(iChannel3, uv);\n    } else {\n        frogColor = vec4(normalRGB, 1.0);\n    }  \n    \n//    if(abs(toLightDir.x *.5 + .5 - uv.x) < 0.005 && abs(toLightDir.z *.5 + .5 - uv.y) < 0.005) {\n//    \tfrogColor = vec4(1.,abs(toLightDir.y*2.),vec2(0.));  \n//    }\n    \n    \n    \n    vec4 final = frogColor;\n    \n    vec4 ace = vec4(ACESFilm(vec3(0)), 1.0);;\n\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n//    vec2 uv = fragCoord.xy/iResolution.xy;\n\n\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n      vec3 color = vec3(texture(iChannel0, uv - 0.50 * d).r,\n                      texture(iChannel0, uv - .0 * d).g,\n                      texture(iChannel0, uv + 01.0 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.50  * d).r,\n                      texture(iChannel1, uv - .0 * d).g,\n                      texture(iChannel1, uv - 01.0 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv -0.50  * d).r,\n                      texture(iChannel2, uv - .0 * d).g,\n                      texture(iChannel2, uv - 01.0  * d).b);\n                      \n                       vec3 col3 = vec3(texture(iChannel3, uv - 0.50 * d).r,\n                      texture(iChannel3, uv - 0.0 * d).g,\n                      texture(iChannel3, uv - 1.0 * d).b);\n                      \n                      vec3 blend = (max(color,col));\n                      vec3 bland = (max(col,color));\n               //       blend *= bland;\n               //       col2 = min(col,col3)*col2;\n               //       col = mix(col,col3,color);\n              //       col3 = min(col,color)*col3;\n            //     color = mix(col,color,col3)*color;\n\n  //    color = ((max(color,col),col3)*(color));\n //     color = (mix(color,col2,col2)*(color));\n    float noise = .9 + randomFloat()*.15;\n  \t//fragColor = vec4(ACESFilm(frogColor));\n //   fragColor = mix(vec4(ACESFilm((col+(mix(bland,blend,0.5)))*noise), 1.0),frogColor,(col,1.0));\n//    fragColor = vec4(ace(final))*noise );\n //   fragColor = frogColor;\n //fragColor =(vec4(ACESFilm(mix(bland,blend,0.5)*noise),1.0));\n fragColor = mix((vec4(ACESFilm(mix(bland,blend,0.5)*noise),1.0)),frogColor,(color,.50));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define HEIGHT 175.0\n#define BRIGHTNESS 1.5\n\n/**\n\tUse Buffer A in iChannel0 for 3D letters. Read description!\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //Texel Size\n    vec2 texel = vec2(1.) / iResolution.xy;\n\n    vec3 normal = bump2Normal(uv, iChannel0, HEIGHT, texel);\n   \tvec3 normalRGB = normal2rgb(normal);\n    \n    vec3 lightDir = normalize(vec3(abs(sin(iTime/22.)), -abs(cos(iTime/33.)), abs(cos(iTime/44.))));\n    \n    vec3 toLightDir = vec3(0.0) - lightDir;\n    \n    float mouseX = iMouse.x / iResolution.x;\n    \n\tif (mouseX < 0.99) {\n        fragColor = vec4(BRIGHTNESS*dot(toLightDir, normalize(normal)));\n        fragColor*=texture(iChannel1, uv);\n    } else {\n        fragColor = vec4(normalRGB, 1.0);\n    }  \n    \n/*    if(abs(toLightDir.x *.5 + .5 - uv.x) < 0.005 && abs(toLightDir.z *.5 + .5 - uv.y) < 0.005) {\n    \tfragColor = vec4(1.,abs(toLightDir.y*2.),vec2(0.));  \n    }*/\n    \n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define iFeedbackColorShiftZoom 0.2\n//#define iFeedbackColorShiftImpact 0.001\n//#define iBlob1ColorPulseSpeed 0.03456\n//#define iBlob2ColorPulseSpeed 0.02345\n#define Margins .0\n\n#define PI 3.14159265359\n\nvec2 getFontSymbolSampleUV(int x, int y, vec2 uv) {\n\treturn uv * vec2(1./16.) + vec2(float(x) / 16., float(y) / 16.);\n}\n\nfloat getHeight(vec2 uv, sampler2D bumpMap, float maxHeight) {\n    return texture(bumpMap, uv).r*maxHeight;\n}\n\nvec3 getSlope(vec2 uv, float height, vec2 axis, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    float h1 = getHeight(uv+texelSize*axis, bumpMap, maxHeight);\n    float h2 = getHeight(uv-texelSize*axis, bumpMap, maxHeight);\n    return vec3(1,((height-h2) + (h1-height)) / 2.,0);\n}\n\nvec3 bump2Normal(vec2 uv, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    \n    float height = getHeight(uv, bumpMap, maxHeight);\n        \n    vec3 slopeX = getSlope(uv, height, vec2(1., 0.), bumpMap, maxHeight, texelSize).zyx;\n    vec3 slopeY = getSlope(uv, height, vec2(0., 1.), bumpMap, maxHeight, texelSize).xyz;\n    return cross(slopeX, slopeY).zyx;\n}\n\nvec3 normal2rgb(vec3 normal) {\n    return normalize(normal.rbg * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5));\n}\n\nfloat radius = 20.;\nfloat intensity = 5.;\nfloat fade = .99;\n\nfloat pi = 3.14159265359;\n\nfloat blurRadius = 3.;\n\nfloat sinWave(float v, float m){return (sin(v*m*pi*2.)+1.)/2.;}\n\n//from https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 xy2hue(vec2 v){\n    float h = (atan(v.y, v.x)/(pi) + 1.)/2.;\n    float b = length(v);\n    return vec4(hsv2rgb(vec3(h, 1., b)), 1.);\n}\n\n\n\n\n\n\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n//    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\n//vec3 hsv2rgb(vec3 cc)\n//{\n//    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n//    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n//    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n//}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n//#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .0001;\nconst float iFeedbackFadeRate         = .999;\nconst float iFeedbackColorShiftZoom   = .01;\nconst float iFeedbackColorShiftImpact = 0.0;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .05;\nconst float iBlobEdgeSmoothing        = .0015;\nconst float iBlob1Radius              = 1.5;\nconst float iBlob1PowFactor           = 69.;\nconst float iBlob1ColorPulseSpeed     = .25242;\nconst float iBlob2Radius              = 1.5;\nconst float iBlob2PowFactor           =69.;\nconst float iBlob2ColorPulseSpeed     = -.01834;\nconst float iBlob2ColorPulseShift     = 0.0;\nconst float iColorShiftOfRadius       = - .5;\nconst float iFeedbackMouseShiftFactor = .01;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * (iBlob1ColorPulseSpeed / 1.5), 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * (iBlob2ColorPulseSpeed / -1.5) + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n    \n //   vec3 prevColor2 = repeatedTexture(iChannel3, uv - stShift).rgb;\n //   prevColor2 *= iFeedbackFadeRate;\n    \n  //  vec3 prevColor3 = repeatedTexture(iChannel1, uv - stShift).rgb;\n //   prevColor3 *= iFeedbackFadeRate;\n    \n  //  prevColor = mix(prevColor,prevColor2,prevColor3);\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n         (1. * abs(cos(iTime / 3.2)))\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          (iBlob1PowFactor)) * iBlob1Color;\n        radius =\n         (1. * abs(sin(iTime / 3.3)))\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n         (iBlob2PowFactor)) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_b_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// All components are in the range [01], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n\n// All components are in the range [01], including hue.\nvec3 hsv2rgb2(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 fragment = texture(iChannel1, uv);\n    vec3 hsv = rgb2hsv(fragment.rgb);\n    float rad = (iTime/2.0) + (hsv.z*6.28);\n    vec2 off = vec2(sin(rad), cos(rad)) / (iResolution.xy / vec2(max(hsv.y,hsv.z)*3.14));\n    hsv.x += abs(sin(iTime/11.0 + ((iMouse.x/iResolution.x)*6.28))*max(iMouse.y/iResolution.y,hsv.z*hsv.z));\n    hsv.y = max(hsv.y, min(hsv.z, 0.5-( (00.5 * (cos(iTime / 3.))))));\n    fragColor = mix(texture(iChannel0, vec2(uv.x + off.x, uv.y + off.y)), vec4(hsv2rgb2(hsv), 0.1), hsv.y*(0.05 - (00.05 * (sin(iTime / 2.)))));\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 9\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col2 = texture(iChannel2,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col3 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 blend = max(mix(col,col2,col3),col);\n  fragColor=max(blend,col);\n//  fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_d_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flySWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 95, 95, 174], [176, 176, 199, 199, 339], [341, 409, 466, 575, 3570]], "test": "untested"}
{"id": "NlGXDW", "name": "COLOR_SHIFT_PLAYGROUND", "author": "SimonOakey", "description": "experiments with color shifting - still wip", "tags": ["color", "rgb", "shift", "hsb", "scheme"], "likes": 2, "viewed": 224, "published": 3, "date": "1640657668", "time_retrieved": "2024-07-30T18:39:43.781062", "image_code": "/*\n\n playing with colors again\n\n*/\n\n\n#define PI 3.14159\n#define TWO_PI (PI * 2.0)\n#define N 12.0\n\n\nvec3 hsb2rgb(vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x * 6. + vec3(0. , 4., 2.), 6.) - 3.) - 1., 0., 1. );\n    rgb = rgb * rgb * (3. - 2. * rgb);\n    return c.z * mix(vec3(1.), rgb, c.y);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n   \n    float steppi = sin(uv.x*88.  )*.5+.5;\n\t\n\tsteppi += cos(uv.y*49.  )*.5+.5;\n\t\n    steppi *= sin(uv.y*5. + iTime)*.5+.5;\n    \n\tsteppi += cos(steppi*4.);\n\t \n\t\n    \n     float f = steppi; \n\t\n\t\n\tfloat shift = iMouse.x / iResolution.x;\n\t\n\tfloat spread = iMouse.y*3. / iResolution.y;\n\t\n\tf += shift*4.;\n\t\n\t\n\t\n\tvec3 col = vec3(\n\tcos(f)*.5+.5,\n\tcos(f*spread )*.5+.5,\n\tcos(f*spread*3.)*.5+.5\n\t);\n\t\n\tcol = hsb2rgb(col);\n\t\n\t\n   \t fragColor = vec4(vec3(col), 1.0);\n\n}\n  \n  \n  \n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGXDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 121, 121, 289], [293, 293, 350, 350, 865]], "test": "untested"}
{"id": "NtGXDW", "name": "menger land", "author": "jorge2017a2", "description": "menger land", "tags": ["mengerland"], "likes": 12, "viewed": 248, "published": 3, "date": "1640657444", "time_retrieved": "2024-07-30T18:39:44.601867", "image_code": "//----------image\n//por jorge2017a2-\n//menger land\n//https://iquilezles.org/articles/distfunctions\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat distanceFractal(vec2 p)\n{\n    float dis = 1e20;\n    float s = 1.5;\n    \n    for(int i=0;i<4;i++)\n    {\n        dis = min(dis, sdBox(p,vec2(1.0,1.0))*s);\n        //perform folds\n        if(p.y>p.x)  p = vec2(p.y,p.x);\n        if(p.y<-p.x) p = vec2(-p.y,p.x);\n\n        p   *= 3.1;\n        s   /= 3.0;\n        p.x -= 6.;\n    }\n    \n    return dis;\n}\n\nfloat dBar(vec2 p, float width) {\n    vec2 d = abs(p) - width;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) + 0.01 * width;\n}\n\nfloat dCrossBar(vec3 p, float x) {\n    float bar_x = dBar(p.yz, x);\n    float bar_y = dBar(p.zx, x);\n    float bar_z = dBar(p.xy, x);\n    return min(bar_z, min(bar_x, bar_y));\n}\n\nfloat dMengerSponge(vec3 p) \n{\n     float d= distanceFractal(p.xy);\n      \n      float one_third = 1.0 / 3.0;\n    for (float i = 0.0; i < 3.0; i++) {\n        float k = pow(one_third, i);\n        float kh = k * 0.5;\n        d = max(d, -dCrossBar(mod(p + kh, k * 2.0) - kh, k * one_third));\n    }\n    return d;\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n      p.y=opRep1D(p.y, 3.0+abs(1.0*sin(iTime*0.25)) );\n   \n   float d4= dMengerSponge(p) ;\n   res =opU3(res,vec3(d4,1.0,-1.0));\n   \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    float occ = occlusion(hit, norm); \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col*(dif+.35 +vec3(.35,.45,.5)*spe) + vec3(.7,.9,1)*spe*spe;\n    color*=occ;\n    return color;\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nfloat nubes(vec2 uv, float rad, vec2 pos) \n{\n   \tuv.y += 0.09*cos(9.0*uv.x + 2.5*iTime);\n   return 1.-smoothstep(rad,rad+0.60,length(uv-pos + 0.23*uv.y)); \n}\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    return sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==5.0)\n    {   float escala=0.125;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n    \n      if (id_material==7.0)\n        {return pattern( p.xz );}\n    if (id_material==8.0)\n        {return pattern( p.xy );}\n    if (id_material==9.0)\n        {return pattern( p.zy );}\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        {   colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n        float dif1=1.0;\n        vec3 result;\n        {\n            result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n            result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n        } \n\n        col= result;\n        col *= 1.0 - pow(mObj.dist /(MAX_DIST) , 3.5);  \n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*0.5,50.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(  0.0, 20.0, -20.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -0.0, 30.0, 20.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,-1.0+t,6.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      //light_pos1+=ro; //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    //col = exposureToneMapping(2.0, col);\n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n\n\nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.45,0.45,0.45),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGXDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[559, 559, 595, 595, 616], [617, 617, 649, 649, 733], [734, 734, 773, 773, 868], [870, 914, 961, 961, 988], [989, 989, 1032, 1032, 1059], [1060, 1060, 1108, 1108, 1136], [1137, 1175, 1211, 1211, 1256], [1258, 1323, 1357, 1357, 1453], [1454, 1454, 1488, 1488, 1579], [1580, 1580, 1614, 1614, 1705], [1706, 1706, 1740, 1740, 1835], [1837, 1837, 1874, 1874, 1954], [1956, 1956, 1987, 1987, 2308], [2310, 2310, 2343, 2343, 2447], [2449, 2449, 2483, 2483, 2626], [2628, 2628, 2658, 2658, 2938], [2940, 2940, 2965, 2965, 3203], [3205, 3205, 3229, 3229, 3391], [3393, 3393, 3442, 3442, 4109], [4112, 4112, 4149, 4149, 4425], [4427, 4427, 4510, 4510, 5075], [5077, 5077, 5170, 5170, 5300], [5302, 5302, 5346, 5346, 5459], [5461, 5461, 5496, 5496, 5519], [5521, 5521, 5553, 5553, 5753], [5755, 5803, 5831, 5831, 6019], [6021, 6021, 6068, 6068, 6469], [6471, 6471, 6564, 6564, 6894], [6896, 6896, 6927, 6927, 7608], [7610, 7610, 7636, 7636, 7746], [7748, 7748, 7806, 7806, 7858], [7861, 7861, 7918, 7918, 8497]], "test": "untested"}
{"id": "NlGSzw", "name": "Cubic Hash Inversion", "author": "byt3_m3chanic", "description": "Dark and Ominous - just how I like my coffee.", "tags": ["raymarching", "domain", "polar", "rep", "blackle"], "likes": 36, "viewed": 589, "published": 3, "date": "1640651697", "time_retrieved": "2024-07-30T18:39:45.424667", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Cubic Hash Zone | @byt3_m3chanic \n    \n    Something I've been toying around with but hate most of\n    my shaders recently... though with enough effects, \n    anything looks good. Some more attempts at hatching and \n    other ways to stylize a shader.\n    \n    Thank you @blackle @mla @Shane and @iq for help, hints,\n    and knowledge.\n    \n    suggested music for viewing \n    \n    Synaesthesia | Flotation\n    https://www.youtube.com/watch?v=4p6OhXgu9T4\n    \n*/\n#define R \t\tiResolution\n#define T \t\tiTime\n#define M \t\tiMouse\n\n#define PI          \t3.14159265358\n#define PI2         \t6.28318530718\n\n#define MAX_DIST    100.\n\n//keeping things deterministic\nfloat u_hash = 1.97323;\n\nfloat hash21(vec2 a) { return fract(sin(dot(a,vec2(21.23,41.232)))*4123.2323); }\nfloat hash31(vec3 p3){\n    p3 += u_hash; p3  = fract(p3 * .1031); p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat box(vec3 p, vec3 d) {\n    p = abs(p) - d;\n    return length(max(p, 0.)) + min(0., max(max(p.x,p.y),p.z));\n}\n\n//@blackle https://www.shadertoy.com/view/Wl3fD2\n//nonzero sign function\nfloat nonZeroSign(float x) {\n    return x < 0. ? -1. : 1.;\n}\n\n//closest face of the cube to p\nvec3 face(vec3 p) {\n    vec3 ap = abs(p);\n    if (ap.x>=max(ap.z,ap.y)) return vec3(nonZeroSign(p.x),0.,0.);\n    if (ap.y>=max(ap.z,ap.x)) return vec3(0.,nonZeroSign(p.y),0.);\n    if (ap.z>=max(ap.x,ap.y)) return vec3(0.,0.,nonZeroSign(p.z));\n    return vec3(0);\n}\n\nmat2 rx,ry;\nvec3 hit,hitpoint,sid,gid;\nvec3 bxs = vec3(1.9,1.9,.845),cxs = vec3(3.8,1.9,.845);\n\nvec2 map (in vec3 p) { \n    vec2 res = vec2(MAX_DIST,0.);\n    p.zy*=ry;\n    p.xz*=ry;\n    vec3 g = p;\n    \n    //@mla inversion\n    float k = 9.0/dot(p,p); \n    p *= k;\n    //@blackle https://www.shadertoy.com/view/Wl3fD2\n    vec3 center = floor(p) + .5;\n    vec3 neighbour = center + face(p - center);\n    float hs = hash31(center+fract(u_hash*3.));\n    \n    //using some hash to random the layout\n    float m = hs;\n    if(hs>.75) m = 5.;\n    if(hs>.5 && hs<.75) m = 4.;\n    if(hs>.25 && hs<.5) m = 2.;\n    if(hs<.25) m = 3.;\n\n    vec3 pos  = p - center;\n    vec3 npos = p - neighbour;\n\n    float worst = box(npos, vec3(.25))-.005;\n    float me = hs>.25? hs<.6? length(pos)-(.3): box(pos, vec3(.25))-.005 : worst;\n    float thk = .045;\n    float bm = length(pos.xz)-thk;\n    bm = min(bm,length(pos.xy)-thk);\n    bm = min(bm,length(pos.zy)-thk);\n    bm = max(bm,box(p,bxs));\n    //clip objects.\n    me = max(me,-bm);\n    if(hs>.58&&hs<.65) me = max(me,-(length(pos)-.225));\n\n    me = max(me,box(p,cxs));\n    if(me<res.x) {\n        res = vec2(me,m);\n        hit=pos;\n        gid=center;\n    }\n    if(bm<res.x) {\n        res = vec2(bm,3.);\n        hit=pos;\n        gid=center;\n    }    \n\n    float mul = 1.0/k;\n    res.x *= mul / 1.56;\n    res.x=max(res.x,-(length(g)-.05));\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\n//@iq \nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// the rnd background patterns\nvec3 pattern(vec2 suv, vec3 clr) {\n    suv*=rot((PI*sin(u_hash)) );\n    suv-=T*.01;\n    float hs = fract(u_hash*4.3);\n    if(u_hash>.75){\n        vec2 f = fract(hs>.5?suv*5.:suv*15.)-.5;\n        clr = mix(clr,clr*.7,sin(f.x+f.y)>0.?1.:0.);\n    } else if(u_hash>.5){\n        vec2 f = fract(hs>.5?suv*8.:suv*4.)-.5;\n        clr = mix(clr,clr*.7,f.x*f.y>0.?1.:0.);\n    } else if(u_hash>.25){\n        vec2 f = fract(hs>.5?suv*8.:suv*4.)-.5;\n        clr = mix(clr,clr*.7,mod(floor(f.x),3.)==0.?1.:0.);\n    } else {\n        vec2 f = fract(suv*8.)-.5;\n        float d = length(f)-.25;\n        d=hs>.5?abs(abs(abs(abs(d)-.075)-.075)-.075)-.025:abs(abs(d)-.075)-.025;\n        clr = mix(clr,clr*.7,smoothstep(.01,.011,d));\n    }\n    return clr;\n}\n\n//@Shane ao\nfloat calcAO(in vec3 p, in vec3 n){\n    float sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n        float hr = float(i + 1)*.1325/3.75; \n        float d = map(p + n*hr).x;\n        occ += (hr - d)*sca;\n        sca *= .9;\n        if(sca>1e5) break;\n    }\n    return clamp(1. - occ, .075, 1.);\n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n, in vec2 F) {\n    n = normal(p,d,1.);\n    vec3 lpos = vec3(9.*sin(T*.2),25,9.*cos(T*.2));\n\n    vec3 l = normalize(lpos);\n    float diff = clamp(dot(n,l),0.,1.);\n    float spec = pow(max(dot(reflect(l, n), rd ), .1), 12.);\n    \n    float shdw = 1.0,t=.01;\n    for( int i =1; i<19; i++ ) {\n        float h = map(p + l*t).x;\n        if( h<1e-3 ) { shdw = 0.; break; }\n        shdw = min(shdw, 28.*h/t);\n        t += h;\n        if( shdw<.1 || t>45. ) break;\n    }\n\n    diff=mix(diff,diff*shdw,.5); \n    float ao = calcAO(p,n);\n    \n    //dithering and hatching tricks.. \n    ao=smoothstep(.2,.51,ao);\n    ao=clamp(ao,.3,.9);\n    vec3 sdif = vec3(ao*diff+.15);\n    if(diff<.5&&(mod(F.x,4.)==mod(F.y,4.))) sdif=sdif*.3;\n    if(diff<.175&&(mod(1.-F.y,4.)==mod(F.x,4.))) sdif=sdif*.25;\n    if(diff<.125&&(mod(F.x,1.)==mod(F.y,2.))) sdif=sdif*.2;\n    if(diff<.100&&(mod(1.-F.x,2.)==mod(F.y,2.))) sdif=sdif*.1;\n    if(diff<.015&&(mod(F.x,1.)==mod(F.y,1.))) sdif=sdif*.3;\n\n    if(spec>.45&&(mod(F.x,4.)==mod(F.y,4.))) sdif+=.15;\n    if(spec>.65&&(mod(1.-F.x,2.)==mod(F.y,2.))) sdif+=.15;\n    \n    return sdif;//diff*vec3(1);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    u_hash+=iDate.z+floor(T*.13);\n    float thash = fract(u_hash*u_hash*2.3);\n    if(thash>.75){\n       bxs = vec3(1.9,1.9,1.9);\n       cxs = vec3(1.9,.845,3.8);\n    }else if(thash>.5){\n       bxs = vec3(1.9,1.9,.845);\n       cxs = vec3(3.8,1.9,.845);\n    }else if(thash>.25){\n       bxs = vec3(1.9,1.9,.845);\n       cxs = vec3(.845,4.9,1.9);\n    }else{\n       bxs = vec3(.845,1.9,3.8);\n       cxs = vec3(1.9,.845,3.8);\n    }\n    vec3 C=vec3(.0);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec2 duv=uv;\n    float zoom = 10.;\n\n    vec3 ro = vec3(uv*zoom,-zoom-13.25);\n    vec3 rd = vec3(0,0,1.);\n    \n    float hash  = fract(u_hash*2.27)*PI2;\n    rx = rot(-.68+hash);\n    ry = rot((T*.01)+(u_hash>.5?-(hash+.68):-(hash+.68)));\n\n    vec3  p = ro + rd * .1;\n    float atten = .95;\n    float k = 1.,o = 1.,b = 3.;\n    \n    // loop inspired/adapted from @blackle \n    // https://www.shadertoy.com/view/flsGDH\n    for(int i=0;i<150;i++)\n    {\n        vec2 ray = map(p);\n \n        vec3 n=vec3(0);\n        float fresnel=0.;\n        float d = i<32?ray.x*.825:ray.x;\n        float m = ray.y;\n\n        p += rd * d *k;\n        \n        if (d*d < 1e-6) {\n            hitpoint=hit;\n            sid=gid;\n            o*=1e-5;\n            \n            C=mix(C,C+shade(p,rd,d,ray.y,n,F)*atten,1.);\n            if(b<1.)break;\n            b--;\n            atten *= m==3.?.45:.95;\n            p += rd*.025;\n            k = sign(map(p).x);\n          \n            if(m==3.){\n                rd=reflect(-rd,n);\n                p+=n*.01;\n                b--;\n            }else{\n                b--;\n                rd=refract(rd,n,.87);\n            }\n        }\n        if(distance(p,rd)>25.) { break; }\n    }\n    \n    float mask = smoothstep(.3,.8,length(uv)-.4);\n    float over = smoothstep(.1,.45,length(uv)-.3);\n\n    vec3 clr = mix(vec3(.5),vec3(.0) ,clamp(mask,0.,.5) );\n    clr = mix(pattern(uv,clr),vec3(.01), clamp(abs(.5+.5*cos(T*.2)),0.,1.) );\n    C = mix(C,mix(vec3(.05),vec3(.9),clr),o);\n\n    float hs = hash21(duv);\n    if(fract(hs*5.)>.65) C = clamp(C-.075,vec3(0),vec3(1));\n    \n    // Output to screen\n    C=sqrt(smoothstep(0.,1.,C));\n    O = vec4(C,1.0);\n}\n\n//end", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGSzw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[781, 781, 803, 803, 861], [862, 862, 884, 884, 1000], [1001, 1001, 1020, 1020, 1065], [1067, 1067, 1094, 1094, 1180], [1182, 1255, 1283, 1283, 1315], [1317, 1349, 1368, 1368, 1613], [1711, 1711, 1733, 1733, 3001], [3003, 3072, 3117, 3117, 3343], [3345, 3352, 3386, 3386, 3466], [3468, 3499, 3533, 3533, 4235], [4237, 4249, 4284, 4284, 4547], [4549, 4549, 4621, 4621, 5723], [5725, 5725, 5766, 5766, 7918]], "test": "untested"}
{"id": "slVXW1", "name": "exp_1", "author": "TestCoder", "description": "t", "tags": ["t"], "likes": 2, "viewed": 228, "published": 3, "date": "1640638831", "time_retrieved": "2024-07-30T18:39:46.203585", "image_code": "float cbrt(float number) {\n    return pow(abs(number), 1. / 3.);\n}\n\nfloat getErraticWave(float number) {\n    float scale = 1.;\n\n    return (\n        cbrt(sin(number))\n      + pow(\n          cos(\n              number + iTime / 3.\n          ),\n          3.\n        )\n    ) / scale;\n}\n\nvec3 getErraticPattern(float x, float y, vec2 uv) {\n    float stretch = 2.;\n    float mainDance = getErraticWave(\n        getErraticWave(uv.y + uv.x)\n      + getErraticWave(uv.y + -uv.x)\n      + getErraticWave(-uv.y + uv.x)\n      + getErraticWave(-uv.y + -uv.x)\n    );\n    vec2 frequency = texture(iChannel0, vec2(10.0)).xy / 64.;\n\n    return (\n        getErraticWave(\n            x\n        ) + getErraticWave(\n            y\n        )\n    ) * stretch * (1. - vec3(\n        mainDance * (\n            sin(\n                iTime / 20. + .5\n            ) + 1.\n        )\n    ,\n        mainDance * (\n            sin(\n                iTime / 4. + .25\n            ) + .5\n        )\n    ,\n        mainDance * (\n            sin(\n                iTime / 4. + 1.\n            ) + .25\n        ) + mainDance + frequency.x * 100.\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // - .5 so center of the screen is the center of the screen\n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n\n    // Sets ratio into 1:1\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n   \n    float frequency = texture(iChannel0, vec2(100.)).x;\n    vec3 col = 0.5 + 0.5*cos(iTime + uv.xyx + vec3(0,2,4));\n\n    float zoomOut = 15.;\n\n    vec3 rgb = 1. - getErraticPattern(\n                uv.x, uv.y, uv * zoomOut\n            ) + getErraticPattern(\n                -uv.x, uv.y, uv * zoomOut\n            ) + getErraticPattern(\n                uv.x, -uv.y, uv * zoomOut\n            ) + getErraticPattern(\n                -uv.x, -uv.y, uv * zoomOut\n            );\n\n    // Output to screen\n    fragColor = vec4(col * rgb * (1. / distance(uv, vec2(0.))),1.0);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVXW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 66], [68, 68, 104, 104, 281], [283, 283, 334, 334, 1105], [1107, 1107, 1164, 1278, 2002]], "test": "untested"}
{"id": "7l33WX", "name": "flash multicolor 1", "author": "gchipunov", "description": "made in 2 minutes", "tags": ["2d", "gradiant", "stock"], "likes": 1, "viewed": 202, "published": 3, "date": "1640634032", "time_retrieved": "2024-07-30T18:39:46.993473", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(50.0*iTime+uv.xyx+vec3(0,2.0/uv.y,4));\n vec3 col2 = 0.5 + 0.5*cos(50.0*iTime+uv.xyx+vec3(0,2.0,4.0/uv.y));\n vec3 col3 = 0.5 + 0.5*cos(50.0*iTime+uv.xyy+vec3(0,2.0,4.0/uv.x));\nvec3 col4 = mix(col,col2,cos(50.0*iTime));\n\n\n\n vec3 col10 = 0.5 + 0.5*cos(50.0*iTime+uv.xyx+vec3(0,2.0,4.0/uv.y));\n vec3 col11 = 0.5 + 0.5*cos(50.0*iTime+uv.xyy+vec3(4.0/uv.x,2.0/uv.y,4.0/uv.y));\n \n \n//vec3 col5 = cos(col);//smoothstep(col,col2,col4);\n\nvec3 col5 = cos(smoothstep(col+col3/333.0,col2+col/0.02,col4/0.02))/4.5 +col/ 5.0 -mix(col3,col2,cos(iTime));//;\ncol5 = col5/col10 + col11/col10;\n\ncol5 = col5/col10;\ncol5 = col5 - col11;\n\n    // Output to screen\n    fragColor = vec4(col5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l33WX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 883]], "test": "untested"}
{"id": "7lVXDh", "name": "(epilepsy) rainbow from gray ", "author": "incription", "description": "use mouse x to make the gradient vary between high and low brightness between frames. On my screen it generates a kind of rainbow at high mouse x", "tags": ["epilepsy", "hdr"], "likes": 1, "viewed": 252, "published": 3, "date": "1640633275", "time_retrieved": "2024-07-30T18:39:47.770395", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    if(uv.y > .5) {\n        col = mix(vec3(0,0,0), vec3(.15), uv.x);\n    } else {\n        float o = float(iFrame%2==0)*2. - 1.;\n        col = mix(vec3(0,0,0), vec3(.15) + vec3(.15) * o * 2. * (iMouse.x/iResolution.x), uv.x);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVXDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 391]], "test": "untested"}
{"id": "sltGDB", "name": "Interactive Weirdness", "author": "kp1197", "description": "CLICK AND DRAG.  Unsuccessful implementation of lattice fluid sim, still cool though.  Hue controlled by v.", "tags": ["fluids"], "likes": 1, "viewed": 63, "published": 3, "date": "1640632601", "time_retrieved": "2024-07-30T18:39:48.756758", "image_code": "\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel2, fragCoord / iResolution.xy);\n }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\nFlow Map\n*/\n\n\n\nconst float fade = 0.9;\nconst float eps = 1e-3;\n\n\n\nvec2 sign_preserving_max(vec2 a, vec2 b) {\n\n    float x1 = a.x;\n    float y1 = a.y;\n    float x2 = b.x;\n    float y2 = b.y;\n    \n    float x = max(abs(x1),abs(x2));\n    x *= (x == abs(x1)) ? sign(x1) : sign(x2);\n    \n    float y = max(abs(y1),abs(y2));\n    y *= (y == abs(y1)) ? sign(y1) : sign(y2);\n    \n    return vec2(x,y);\n}\n\nvec2 get_mouse_perturbation(in vec2 fragCoord) {\n    // read mouse variables\n    bool draw      = texelFetch(iChannel1, DRAW_ADDR, 0).x > 0.;\n    vec2 m2 = texelFetch(iChannel1, M2_POS_ADDR, 0).xy;\n    vec2 m1 = texelFetch(iChannel1, M1_POS_ADDR, 0).xy;\n    vec2 m0 = texelFetch(iChannel1, M0_POS_ADDR, 0).xy;\n\n    return get_mouse_perturbation_calcuation(fragCoord, draw, m2, m1, m0);\n}\n\nfloat weight_closeness(vec2 x) {\n    return (1. + eps) / (eps+ length(x) );\n}\n\nvec2 getAdvectedV(in vec2 fragCoord) {\n    \n    // sample the velocities around this point\n    vec2 va = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2(-1,-1)) % ivec2(iResolution.xy), 0).xy;\n    vec2 vb = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2(-1, 0)) % ivec2(iResolution.xy), 0).xy;\n    vec2 vc = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2(-1, 1)) % ivec2(iResolution.xy), 0).xy;\n    vec2 vd = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2( 0,-1)) % ivec2(iResolution.xy), 0).xy;\n    vec2 ve = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2( 0, 0)) % ivec2(iResolution.xy), 0).xy;\n    vec2 vf = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2( 0, 1)) % ivec2(iResolution.xy), 0).xy;\n    vec2 vg = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2( 1,-1)) % ivec2(iResolution.xy), 0).xy;\n    vec2 vh = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2( 1, 0)) % ivec2(iResolution.xy), 0).xy;\n    vec2 vi = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2( 1, 1)) % ivec2(iResolution.xy), 0).xy;\n\n    // where the neighboring grid positions end up after the timestep\n    vec2 pa = (va + vec2(-1.,-1.));\n    vec2 pb = (vb + vec2(-1,  0.));\n    vec2 pc = (vc + vec2(-1., 1.));\n    vec2 pd = (vd + vec2( 0.,-1.));\n    vec2 pe = (ve + vec2( 0., 0.));\n    vec2 pf = (vf + vec2( 0., 1.));\n    vec2 pg = (vg + vec2( 1.,-1.));\n    vec2 ph = (vh + vec2( 1., 0.));\n    vec2 pi = (vi + vec2( 1., 1.));\n    \n    /*\n    float wa = max(eps,1.-length(pa));\n    float wb = max(eps,1.-length(pb));\n    float wc = max(eps,1.-length(pc));\n    float wd = max(eps,1.-length(pd));\n    float we = max(eps,1.-length(pe));\n    float wf = max(eps,1.-length(pf));\n    float wg = max(eps,1.-length(pg));\n    float wh = max(eps,1.-length(ph));\n    float wi = max(eps,1.-length(pi));\n    */\n    float wa = weight_closeness(pa);\n    float wb = weight_closeness(pb);\n    float wc = weight_closeness(pc);\n    float wd = weight_closeness(pd);\n    float we = weight_closeness(pe);\n    float wf = weight_closeness(pf);\n    float wg = weight_closeness(pg);\n    float wh = weight_closeness(ph);\n    float wi = weight_closeness(pi);\n    \n    \n    float denom = max(eps,wa+wb+wc+wd+we+wf+wg+wh+wi);\n    return ((wa*va + wb*vb + wc*vc + wd*vd + we*ve + wf*vf + wg*vg + wh*vh + wi*vi))/ denom;\n    \n    //return (va+vb+vc+vd+ve+vf+vg+vh+vi)/9.;\n}\n\nfloat getDivergence(in vec2 fragCoord) {\n    \n    // sample the velocities around this point\n    vec2 va = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2(-1,-1)) % ivec2(iResolution.xy), 0).xy;\n    vec2 vb = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2(-1, 0)) % ivec2(iResolution.xy), 0).xy;\n    vec2 vc = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2(-1, 1)) % ivec2(iResolution.xy), 0).xy;\n    vec2 vd = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2( 0,-1)) % ivec2(iResolution.xy), 0).xy;\n    vec2 ve = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2( 0, 0)) % ivec2(iResolution.xy), 0).xy;\n    vec2 vf = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2( 0, 1)) % ivec2(iResolution.xy), 0).xy;\n    vec2 vg = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2( 1,-1)) % ivec2(iResolution.xy), 0).xy;\n    vec2 vh = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2( 1, 0)) % ivec2(iResolution.xy), 0).xy;\n    vec2 vi = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2( 1, 1)) % ivec2(iResolution.xy), 0).xy;\n\n    return divergence_calculation(va,vb,vc,vd,ve,vf,vg,vh,vi);\n    \n    //return (va+vb+vc+vd+ve+vf+vg+vh+vi)/9.;\n}\n\nvec2 bound(vec2 x) {\n    return length(x) > 1. ? normalize(x) : x;\n}\n\nvec2 get_random_v(in vec2 fragCoord) {\n    return voronoi_f1_colors( fragCoord, VORONOI_RANDOMNESS, VORONOI_EXPONENT, VORONOI_ANGLE).xy - 0.5;\n}\n\nvec2 camGradient(in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 e = vec2(0.5/iResolution.x, 0.);\n    \n    // WEBCAM\n    #if GRADIENT_SOURCE == 0\n        \n        vec2 grad = vec2(length(texture(iChannel3, SCALE * uv + e.xy + ANIMATE).xyz) - length(texture(iChannel3, SCALE * uv - e.xy + ANIMATE).xyz),\n                length(texture(iChannel3, SCALE * uv + e.yx + ANIMATE).xyz) - length(texture(iChannel3, SCALE * uv - e.yx + ANIMATE).xyz));\n    \n    // VORONOI\n    #elif GRADIENT_SOURCE == 1\n        vec2 grad = vec2(length(voronoi_f1_colors( uv + e.xy, VORONOI_RANDOMNESS, VORONOI_EXPONENT, VORONOI_ANGLE ).xyz) -\n            length(voronoi_f1_colors( uv - e.xy, VORONOI_RANDOMNESS, VORONOI_EXPONENT, VORONOI_ANGLE ).xyz),\n            length(voronoi_f1_colors( uv + e.yx, VORONOI_RANDOMNESS, VORONOI_EXPONENT, VORONOI_ANGLE ).xyz) -\n            length(voronoi_f1_colors( uv - e.yx, VORONOI_RANDOMNESS, VORONOI_EXPONENT, VORONOI_ANGLE ).xyz));\n    // IMAGE\n    #else\n        // TODO: WRAP\n        vec2 grad = vec2(length(texture(iChannel2, uv + e.xy).xyz) - length(texture(iChannel2, uv - e.xy).xyz),\n                length(texture(iChannel2, uv + e.yx).xyz) - length(texture(iChannel2, uv - e.yx).xyz));    \n    \n    #endif\n    return grad / 2.;\n}\n\nfloat camCurl(in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 e = vec2(0.5/iResolution.x, 0.);\n    \n    float dv2dx = texture(iChannel0, uv + e.xy).y - texture(iChannel0, uv - e.xy).y;\n    float dv1dy = texture(iChannel0, uv + e.yx).x - texture(iChannel0, uv - e.yx).x;\n    return dv2dx - dv1dy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    // TRAIT: -1. * \n    vec2 cam_grad = IMAGE_GRADIENT_SIGN * camGradient(fragCoord);\n    \n\n\n    // advection step\n    vec2 v = getAdvectedV(fragCoord);\n    \n    // divergence\n    float d = getDivergence(fragCoord);\n    \n    // todo: curl\n    float cam_curl = camCurl(fragCoord);\n\n    vec2 perturb = clamp(get_mouse_perturbation(fragCoord), -1.,1.);\n    \n    // TRAIT: oscillate?\n    //v = (v + perturb + clamp(sin(2.*iTime),0.,1.) * cam_grad);\n    \n    v = v + perturb - (cam_grad + 0.5*(cam_curl));\n    \n    v = bound(v);\n    \n    fragColor = vec4(v,0.,1.);\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\nMouse tracking / interactivity\n*/\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec4 m2_mouse  = texelFetch(iChannel1, M2_POS_ADDR, 0);\n    vec4 m1_mouse  = texelFetch(iChannel1, M1_POS_ADDR, 0);\n    vec4 m0_mouse  = texelFetch(iChannel1, M0_POS_ADDR, 0);\n\n    \n    bool draw = (iMouse.z > 0.) && (m2_mouse.z > 0.) && (m1_mouse.z > 0.);\n\n    if (ivec2(fragCoord) == M2_POS_ADDR) {\n        //vec2 prevMouse = texelFetch(iChannel1, MOUSE_POS_ADDR, 0).xy;\n        fragColor = vec4(iMouse.xyz, 0.);\n    }\n    \n    if (ivec2(fragCoord) == M1_POS_ADDR) {\n        fragColor = m2_mouse;\n    }\n    \n    if (ivec2(fragCoord) == M0_POS_ADDR) {\n        fragColor = m1_mouse;\n    }\n\n    \n    if (ivec2(fragCoord) == DRAW_ADDR) {\n        fragColor = draw ? vec4(1.) : vec4(0.);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n\n\nvec2 get_mouse_perturbation(in vec2 fragCoord) {\n    // read mouse variables\n    bool draw      = texelFetch(iChannel1, DRAW_ADDR, 0).x > 0.;\n    vec2 m2 = texelFetch(iChannel1, M2_POS_ADDR, 0).xy;\n    vec2 m1 = texelFetch(iChannel1, M1_POS_ADDR, 0).xy;\n    vec2 m0 = texelFetch(iChannel1, M0_POS_ADDR, 0).xy;\n\n    return get_mouse_perturbation_calcuation(fragCoord, draw, m2, m1, m0);\n}\n\nfloat getDivergence(in vec2 fragCoord) {\n    \n    // sample the velocities around this point\n    vec2 va = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2(-1,-1)) % ivec2(iResolution.xy), 0).xy;\n    vec2 vb = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2(-1, 0)) % ivec2(iResolution.xy), 0).xy;\n    vec2 vc = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2(-1, 1)) % ivec2(iResolution.xy), 0).xy;\n    vec2 vd = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2( 0,-1)) % ivec2(iResolution.xy), 0).xy;\n    vec2 ve = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2( 0, 0)) % ivec2(iResolution.xy), 0).xy;\n    vec2 vf = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2( 0, 1)) % ivec2(iResolution.xy), 0).xy;\n    vec2 vg = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2( 1,-1)) % ivec2(iResolution.xy), 0).xy;\n    vec2 vh = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2( 1, 0)) % ivec2(iResolution.xy), 0).xy;\n    vec2 vi = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2( 1, 1)) % ivec2(iResolution.xy), 0).xy;\n\n    return divergence_calculation(va,vb,vc,vd,ve,vf,vg,vh,vi);\n    \n    //return (va+vb+vc+vd+ve+vf+vg+vh+vi)/9.;\n}\n\nvec2 get_v(in vec2 fragCoord) {\n    return texture(iChannel0, fragCoord / iResolution.xy).xy;\n}\n\nfloat shade(vec2 fragCoord) {\n    float a = length(get_v(fragCoord + vec2(1,0))); //voronoi_f1_colors( 10.* (fragCoord + vec2(0,1)) / iResolution.xy, 1.0, 2.0, 3.14159/4.).w;\n    float b = length(get_v(fragCoord + vec2(-1,0)));//voronoi_f1_colors( 10.* (fragCoord + vec2(0,-1)) / iResolution.xy, 1.0, 2.0, 3.14159/4.).w;\n    float c = length(get_v(fragCoord + vec2(0,1)));//voronoi_f1_colors( 10.* (fragCoord + vec2(1,0)) / iResolution.xy, 1.0, 2.0, 3.14159/4.).w;\n    float d = length(get_v(fragCoord + vec2(0,-1)));//voronoi_f1_colors( 10.* (fragCoord + vec2(-1,0)) / iResolution.xy, 1.0, 2.0, 3.14159/4.).w;\n    vec2 grad = normalize(vec2((a-b)/2., (c-d)/2.));\n    vec2 light = vec2(cos(iTime),sin(iTime));\n    return 0.5 + 0.5 *dot(grad,light);\n    //return 5.*a;\n}\n\n\n// from https://www.shadertoy.com/view/MsjXRt\n// todo: my own implementation\nvec3 HueShift (in vec3 Color, in float Shift)\n{\n    vec3 P = vec3(0.55735)*dot(vec3(0.55735),Color);\n    \n    vec3 U = Color-P;\n    \n    vec3 V = cross(vec3(0.55735),U);    \n\n    Color = U*cos(Shift*6.2832) + V*sin(Shift*6.2832) + P;\n    \n    return Color;\n}\n\nfloat camCurl(in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 e = vec2(0.5/iResolution.x, 0.);\n    \n    float dv2dx = texture(iChannel0, uv + e.xy).y - texture(iChannel0, uv - e.xy).y;\n    float dv1dy = texture(iChannel0, uv + e.yx).x - texture(iChannel0, uv - e.yx).x;\n    return dv2dx - dv1dy;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // sample flow map\n    vec2 flow = texture(iChannel0, (fragCoord)/iResolution.xy).xy;\n    \n    // get some vector quantities\n    float d = getDivergence(fragCoord);\n    float divergence = clamp(-d, 0.,1.);\n    float convergence = clamp(d, 0., 1.);\n\n    // use the flowmap to offset sampling into the previous frame\n    vec4 prev = texture(iChannel2, vec2(fragCoord - flow) / iResolution.xy);\n    \n    // TRAITS: 0.99, 0.999\n    prev*=0.9999;\n    \n    \n    #if IMAGE_SOURCE == 0\n    vec4 colors = texture(iChannel3, SCALE * (fragCoord / iResolution.xy) + ANIMATE);\n    #else\n    vec4 colors =  0.3*voronoi_f1_colors( VORONOI_UV_SCALE * fragCoord / iResolution.xy + iTime, VORONOI_RANDOMNESS, VORONOI_EXPONENT, VORONOI_ANGLE);    \n    #endif\n\n    // TRAIT: 1.- is a trait\n    //\n\n    vec3 result = clamp(0.15*divergence * colors.xyz + (1.-0.15*divergence) * prev.xyz, 0., 1.);\n    \n    float mouse_movement = length(get_mouse_perturbation(fragCoord));\n    \n    //result = HueShift(result, length(result)*30.);\n    \n    result = (1.+0.01*length(flow))*HueShift(clamp(result,0.,1.), 0.005*length(flow));\n\n    float cam_curl = camCurl(fragCoord);\n\n    //vec3 result = shade(fragCoord) * mix(prev.xyz, colors.xyz, divergence);\n    fragColor = vec4(result,colors.w) - 0.1 * abs(cam_curl);// vec4(divergence,divergence,divergence,1.);\n    //}\n}", "buffer_c_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define IMAGE_SOURCE 0\n#define GRADIENT_SOURCE 0\n#define IMAGE_GRADIENT_SIGN -0.25\n#define SCALE (0.2)\n\n#define VORONOI_EXPONENT 2.0\n#define VORONOI_RANDOMNESS 1.0\n#define VORONOI_ANGLE 3.14159/4.\n#define VORONOI_UV_SCALE 10.\n\n//#define ANIMATE (0.5 * vec2(cos(0.15*iTime), sin(0.15*iTime)))\n#define ANIMATE vec2(0.,abs(0.01  * iTime))\n\n// IDEAS: feed the image gradient back into the flow map\n\nconst ivec2 MOUSE_DOWN_ADDR = ivec2(2);\nconst ivec2 DRAW_ADDR       = ivec2(3);\nconst ivec2 M2_POS_ADDR = ivec2(4);\nconst ivec2 M1_POS_ADDR = ivec2(5);\nconst ivec2 M0_POS_ADDR = ivec2(6);\n\n// per IQ: https://iquilezles.org/articles/distfunctions2d\nfloat segmentDist(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://thebookofshaders.com/12/\nvec2 random2f( vec2 p ) {\n    return fract(\n        sin(\n            vec2(\n                dot(p,vec2(127.1,311.7)),\n                dot(p,vec2(269.5,183.3)))\n        )*(43758.5453)\n    );\n}\n\nfloat veronoi_metric( in vec2 r, float exponent, float angle ) {\n    // manhattan\n    //return dot(abs(r), vec2(1.));\n    // euclidean\n    //return dot(r,r);\n    return dot(pow(abs(r),vec2(exponent)), 0.01+abs(vec2(cos(angle), sin(angle))));\n}\n\n\nvec4 voronoi_f1_colors( in vec2 x, float randomness, float power, float angle )\n{\n    vec2 p = floor( x );\n    vec2  f = fract( x );\n\n    float res = 8.0;\n    vec3 res_col = vec3(0.);\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 b = vec2( i, j );\n        vec2 point = random2f( vec2(p + b) );\n        vec2  r = vec2( b ) - f + randomness*point;\n        float d = veronoi_metric( r, power, angle);\n        vec3 col = vec3(point,1.);\n\n        res_col = (d < res) ? col : res_col;\n        res = min( res, d );\n    }\n    return vec4(res_col, sqrt( res ));\n}\n\nfloat divergence_calculation(vec2 va, vec2 vb, vec2 vc, vec2 vd, vec2 ve, vec2 vf, vec2 vg, vec2 vh, vec2 vi) {\n\n    float divergence = \n    dot(normalize(va), -0.707*vec2(-1,-1)) +\n    dot(normalize(vb), -vec2(-1, 0)) +\n    dot(normalize(vc), -0.707*vec2(-1, 1)) +\n    dot(normalize(vd), -vec2( 0,-1)) +\n    dot(normalize(ve), -vec2( 0, 0)) +\n    dot(normalize(vf), -vec2( 0, 1)) +\n    dot(normalize(vg), -0.707*vec2( 1,-1)) +\n    dot(normalize(vh), -vec2( 1, 0)) +\n    dot(normalize(vi), -0.707*vec2( 1, 1));\n    \n    return (divergence) / 1.;\n}\n\n\nvec2 get_mouse_perturbation_calcuation(in vec2 fragCoord, bool draw, vec2 m2, vec2 m1, vec2 m0) {\n    \n\n    // use some distance fields to calculate brush size\n    float dist1 = segmentDist(fragCoord, m2, m1);\n    float dist2 = segmentDist(fragCoord, m1, m0);\n    float dist = min(dist1,dist2);\n    vec2 mouse_v = m2-m1;\n    bool brush = dist < 15.;\n    bool moving = length(mouse_v) > 0.;\n    \n    // update the color - in the future this will be an IMPULSE\n    float strength = (1./(dist+1.));    \n    vec2 perturb = (draw && brush && moving) ? strength*mouse_v : vec2(0.);\n    \n    return perturb;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltGDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[6, 6, 63, 63, 130]], "test": "untested"}
{"id": "sl3GWX", "name": "lights wall slow", "author": "gchipunov", "description": "made in 2 minutes", "tags": ["2d", "gradiant", "stock"], "likes": 2, "viewed": 200, "published": 3, "date": "1640628124", "time_retrieved": "2024-07-30T18:39:49.772043", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0/uv.y,4));\n vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0,4.0/uv.y));\n vec3 col3 = 0.5 + 0.5*cos(iTime+uv.xyy+vec3(0,2.0,4.0/uv.x));\nvec3 col4 = mix(col,col2,cos(iTime));\n\n\n\n vec3 col10 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0,4.0/uv.y));\n vec3 col11 = 0.5 + 0.5*cos(iTime+uv.xyy+vec3(4.0/uv.x,2.0/uv.y,4.0/uv.y));\n \n \n//vec3 col5 = cos(col);//smoothstep(col,col2,col4);\n\nvec3 col5 = cos(smoothstep(col+col3/333.0,col2+col/0.02,col4/0.02))/4.5 +col/ 5.0 -mix(col3,col2,cos(iTime));//;\ncol5 = col5/col10 + col11/col10;\n\n    // Output to screen\n    fragColor = vec4(col5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3GWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 812]], "test": "untested"}
{"id": "7tcGWX", "name": "night club light wall 0", "author": "gchipunov", "description": "made in 2 minutes", "tags": ["2d", "gradiant", "stock"], "likes": 1, "viewed": 203, "published": 3, "date": "1640628103", "time_retrieved": "2024-07-30T18:39:50.740454", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0/uv.y,4));\n vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0,4.0/uv.y));\n vec3 col3 = 0.5 + 0.5*cos(iTime+uv.xyy+vec3(0,2.0,4.0/uv.x));\nvec3 col4 = mix(col,col2,cos(iTime));\n\n\n\n vec3 col10 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0,4.0/uv.y));\n vec3 col11 = 0.5 + 0.5*cos(50.0*iTime+uv.xyy+vec3(4.0/uv.x,2.0/uv.y,4.0/uv.y));\n \n \n//vec3 col5 = cos(col);//smoothstep(col,col2,col4);\n\nvec3 col5 = cos(smoothstep(col+col3/333.0,col2+col/0.02,col4/0.02))/4.5 +col/ 5.0 -mix(col3,col2,cos(iTime));//;\ncol5 = col5/col10 + col11/col10;\n\ncol5 = col5/col10;\ncol5 = col5 - col11;\n\n    // Output to screen\n    fragColor = vec4(col5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tcGWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 858]], "test": "untested"}
{"id": "slcGWX", "name": "nightclub lights wall", "author": "gchipunov", "description": "made in 2 minutes", "tags": ["2d", "gradiant", "stock"], "likes": 0, "viewed": 235, "published": 3, "date": "1640628077", "time_retrieved": "2024-07-30T18:39:51.502417", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0/uv.y,4));\n vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0,4.0/uv.y));\n vec3 col3 = 0.5 + 0.5*cos(iTime+uv.xyy+vec3(0,2.0,4.0/uv.x));\nvec3 col4 = mix(col,col2,cos(iTime));\n\n\n\n vec3 col10 = 0.5 + 0.5*cos(50.0*iTime+uv.xyx+vec3(0,2.0,4.0/uv.y));\n vec3 col11 = 0.5 + 0.5*cos(50.0*iTime+uv.xyy+vec3(4.0/uv.x,2.0/uv.y,4.0/uv.y));\n \n \n//vec3 col5 = cos(col);//smoothstep(col,col2,col4);\n\nvec3 col5 = cos(smoothstep(col+col3/333.0,col2+col/0.02,col4/0.02))/4.5 +col/ 5.0 -mix(col3,col2,cos(iTime));//;\ncol5 = col5/col10 + col11/col10;\n\ncol5 = col5/col10;\ncol5 = col5 - col11;\n\n    // Output to screen\n    fragColor = vec4(col5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcGWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 863]], "test": "untested"}
{"id": "fttGWX", "name": "static 2 orbits  gchipunov 381", "author": "gchipunov", "description": "A simple 2D plane deformation driven by the mouse (more info here: https://iquilezles.org/articles/deform/deform.htm)", "tags": ["2d", "planedeformation"], "likes": 1, "viewed": 188, "published": 3, "date": "1640627998", "time_retrieved": "2024-07-30T18:39:52.312252", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n  vec2 m = -1.0 + 2.0 * iMouse.xy / iResolution.xy;\n\n  float a1 = atan(p.y-m.y,p.x-m.x);\n  float r1 = sqrt(dot(p-m,p-m));\n  float a2 = atan(p.y+m.y,p.x+m.x);\n  float r2 = sqrt(dot(p+m,p+m));\n float a3 = atan(p.y+m.y/2.0,p.x+m.x);\n \n  vec2 uv;\n  uv.x = 0.12*clamp(sqrt(exp(iTime)),exp(r1-r2)*0.55,a2+r1+a2*iTime) + (r1-r2)*0.55 + sin(exp(iTime/r2));\n  \n  uv.y = asin(sin(a1-a2-a3))/3.1416;\n\t\n\n  vec3 col = texture( iChannel0, 0.125*uv ).zyx;\n\n  float w = exp(-55.0*r1) + exp(-55.0*r2*r2);\n\n  w += 0.25*smoothstep( 0.03,1.0,sin(228.0*uv.x));\n  w += 0.25*smoothstep( 0.93,1.0,sin(128.0*uv.y));\n\t\n  fragColor = vec4(fract(sqrt (col+w) +(col+w) / 1.1) ,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.5,0.0,1.0);\n}", "buffer_a_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttGWX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[125, 125, 182, 182, 893]], "test": "untested"}
{"id": "NlVSD1", "name": "column x", "author": "jorge2017a2", "description": "column x", "tags": ["columnx"], "likes": 6, "viewed": 269, "published": 3, "date": "1640619336", "time_retrieved": "2024-07-30T18:39:53.085185", "image_code": "//----------image\n//por jorge2017a2-\n//column x\n//https://iquilezles.org/articles/distfunctions\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 opRep3D( in vec3 p, in vec3 c )\n\t{ vec3 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3  opRep(vec3 p, vec3 r)\n   { return mod(p,r)-0.5*r; }\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec3 ColumnaX(vec3 p)\n{   vec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 p0=p;\n    vec3 p1,p2;\n    p1= rotate_z(p0-vec3(-6.0,4.5,-12.0), radians(20.0));\n    p2= rotate_z(p0-vec3(-6.0,4.5,-12.0), radians(-20.0));\n    float d1a =sdCylinderXZ(p1, vec2(0.65,4.0) );\n    float d1b =sdCylinderXZ(p2, vec2(0.65,4.0) );\n    float d0b= sdBox(p0-vec3(-6.0,8.5,-12.0),vec3(2.0,0.25,2.0) );\n    res =opU3(res, vec3(d1a,9.0,-1.0));\n    res =opU3(res, vec3(d1b,9.0,-1.0));\n    res =opU3(res, vec3(d0b,9.0,-1.0));\n    return res;\n}\n\nvec3 techoInclinado(vec3 p)\n{  vec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 p0=p;\n    vec3 p1, p2;\n    p1= rotate_z(p0-vec3(-5.0,11.0,-7.0), radians(-30.0));\n    p2= rotate_z(p0-vec3( 5.0,11.0,-7.0), radians( 30.0));\n    float d0a= sdBox(p1,vec3(6.0,0.25,7.0) );\n    float d0b= sdBox(p2,vec3(6.0,0.25,7.0) );\n    res =opU3(res, vec3(d0a,9.0,-1.0));\n    res =opU3(res, vec3(d0b,9.0,-1.0));   \n    return res;\n}\n\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   \n   res =opU3(res, vec3(planeDist1,-1.0,5.0));\n    float d0a= sdBox(p-vec3(0.0,0.0,-4.0),vec3(10.0,1.0,10.0) );\n    res =opU3(res, vec3(d0a,-1.0,7.0));\n    p.x=abs(p.x)-12.5;\n    vec3 resc1=ColumnaX(p);\n    vec3 resc2=ColumnaX(p-vec3(0.0,0.0,5.0));\n    vec3 resc3=ColumnaX(p-vec3(0.0,0.0,10.0));\n    \n    p=p0;\n    vec3 rest1= techoInclinado(p);\n    \n    res =opU3(res,resc1);\n    res =opU3(res,resc2);\n    res =opU3(res,resc3);\n    \n    res =opU3(res,rest1);\n    \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    float occ = occlusion(hit, norm); \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col*(dif+.35 +vec3(.35,.45,.5)*spe) + vec3(.7,.9,1)*spe*spe;\n    color*=occ;\n    return color;\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==5.0)\n    {   float escala=0.125;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    if (id_material==7.0)\n    {   float escala=0.25;\n        vec2 p2=rotatev2(p.xz, radians(45.0));\n    \tfloat d = mod(floor(p2.x*escala)+floor(p2.y*escala),2.0);\n\t    return vec3( clamp(d,0.0,1.0) )*vec3(0.5,0.0,0.25);\n    }\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        {   colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nRay RotarEnCirculo(vec3 ro,vec3 rd)\n{\n   float r=20.0;\n   float veltime=30.0;  \n    float tt = radians( -iTime*veltime);\n    vec3  pos=vec3(0.0,0.0,15.0);\n    vec3 rotation1 = pos+vec3(r*sin(tt), 0.0, r*cos(tt));\n    ro +=rotation1;   \n    rd=rotate_y( vec3(-rd.x,rd.y,-rd.z), tt);\n    return  Ray(ro,rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(  0.0, 20.0, -20.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -0.0, 30.0, 20.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,7.0,-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n   Ray ray= RotarEnCirculo(ro,rd);\n    ro=ray.ro;\n    rd=ray.rd;\n    \n    //light_pos1+=ro; //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    //col = exposureToneMapping(2.0, col);\n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n\nstruct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\n\nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.45,0.45,0.45),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n", "sound_code": "///fork\n///https://www.shadertoy.com/view/7tySWR.....Created by nabr in 2021-12-26\n\n\n#define _f(x)  fract(x)\n\n\nfloat synth(in float rt, in float t, int ch)\n{\n    float f=0.,ft=mod(6.*t,1.);\n    vec4 p=vec4(0);\n    \n    if(ch == 0) p=vec4(1523.893416,5261.94671,2856.681258,7833.71657);\n    else if(ch==1)\n    {\n    p=1.570796*vec4(440.,520.,691 ,4902.);\n    if(mod(rt, 10.)> 8.) p=1.570796*vec4(1440., 1890, 603, 2685);\n    }\n\n    f =  sin(p[int(6. * t)%4]*rt);\n    f*= (min(1.,3.*ft)*max(0.,1.-ft));\n    f*= cos( _f(.1*t)  + 10. * exp(-.205 * pow(1. - ft , 10.)));\n    f = sin( (2.*f)  / ( 1.24 - cos( f ) ) ) / ( (1.6643) + sin( 13.*  f ));\n\n    return f * clamp( (1. - sqrt(ft)) * 4. * ft , -1., 1.) ;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    //return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n    vec2 v1;\n    float val1;\n    float rt=mod(time,0.5);\n    float t=time;\n    int ch=1;\n    val1= synth( rt,  t, ch);\n    v1=vec2(val1);\n    return v1;\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlVSD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[556, 556, 592, 592, 613], [614, 614, 646, 646, 730], [731, 731, 770, 770, 865], [867, 911, 958, 958, 985], [986, 986, 1029, 1029, 1056], [1057, 1057, 1105, 1105, 1133], [1134, 1172, 1208, 1208, 1253], [1254, 1254, 1293, 1293, 1337], [1338, 1338, 1377, 1377, 1421], [1422, 1422, 1454, 1454, 1479], [1480, 1545, 1579, 1579, 1675], [1676, 1676, 1710, 1710, 1801], [1802, 1802, 1836, 1836, 1927], [1928, 1928, 1962, 1962, 2057], [2059, 2059, 2082, 2082, 2572], [2574, 2574, 2603, 2603, 2982], [2985, 2985, 3010, 3010, 3584], [3586, 3586, 3610, 3610, 3772], [3774, 3774, 3823, 3823, 4490], [4493, 4493, 4530, 4530, 4806], [4808, 4808, 4891, 4891, 5456], [5458, 5458, 5551, 5551, 5681], [5683, 5683, 5715, 5715, 5912], [5914, 5914, 5961, 5961, 6406], [6408, 6408, 6501, 6501, 6831], [6833, 6833, 6864, 6864, 7463], [7465, 7465, 7491, 7491, 7601], [7603, 7603, 7661, 7661, 7713], [7715, 7715, 7752, 7752, 8022], [8024, 8024, 8081, 8081, 8732]], "test": "untested"}
{"id": "NtVSW1", "name": "Drop shadow of round rect", "author": "fb", "description": "Drop shadow of the rounded rectangle. Box shadow", "tags": ["sdf", "shadow", "rect"], "likes": 21, "viewed": 2247, "published": 3, "date": "1640614055", "time_retrieved": "2024-07-30T18:39:54.104460", "image_code": "float sdRoundRect( in vec2 p, in vec2 b, in float r ) {\n    vec2 q = abs(p)-b+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n\nvec4 normalBlend(vec4 src, vec4 dst) {\n    float finalAlpha = src.a + dst.a * (1.0 - src.a);\n    return vec4(\n        (src.rgb * src.a + dst.rgb * dst.a * (1.0 - src.a)) / finalAlpha,\n        finalAlpha\n    );\n}\n\nfloat sigmoid(float t) {\n    return 1.0 / (1.0 + exp(-t));\n}\n\nfloat cornerRadius = 32.0;\nfloat blurRadius = 32.0f;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 center = iResolution.xy / 2.0;\n    vec2 hsize = iResolution.xy / 4.0;\n    \n\tfloat distShadow = clamp(sigmoid(sdRoundRect(fragCoord - center + vec2(0.0, iResolution.y / 20.0),\n        hsize, cornerRadius + blurRadius) / blurRadius), 0.0, 1.0);\n        \n    float distRect = clamp(sdRoundRect(fragCoord - center, hsize, cornerRadius), 0.0, 1.0);\n\n    vec3 col = vec3(distShadow);\n    col = mix(vec3(1.0), col, distRect);\n    \n    vec4 finalColor = normalBlend(vec4(vec3(1.0), 0.6), vec4(col, 1.0));\n    fragColor = finalColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtVSW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 141], [143, 143, 181, 181, 354], [356, 356, 380, 380, 416], [472, 472, 529, 579, 1156]], "test": "untested"}
{"id": "NtVSWh", "name": "meandering : funky MIPmap approx", "author": "FabriceNeyret2", "description": "use the shadertoy plugin to accelerate x16 \nMIPmap variants from davidar's meandering [url]https://shadertoy.com/view/NtVSDR[/url]\ncoef exploration.\n-> obvious axis-bias :-) . we should combine loop & MIPmap or try implement alternative fast prefiltering.", "tags": ["simulation", "convolution", "diffusion", "2tweets", "kernel", "ca", "golf", "reaction", "differential", "growth", "meandering"], "likes": 6, "viewed": 427, "published": 3, "date": "1640601632", "time_retrieved": "2024-07-30T18:39:54.986103", "image_code": "// MIPmap variants from davidar's meandering. https://shadertoy.com/view/NtVSDR\n\nM-A();}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* Original davidar version:\n#define A texelFetch(iChannel0,ivec2(i+u),0)\n#define G(a) exp(-dot(a*i,a*i)) * a*a / 3.1\nM;\n  for(int k=0; ++k<289; r += 9. * A * (G(.4) - G(.25))) i = vec2(k%17,k/17)-8.;\n  r = clamp(r,0.,1.);\n  iFrame<2 ? i = u - 99., r -= G(1.) : r;\n}\n*/\n\n\nM;\n// r += 2.*( A(1.5)- .4*A(2.5) ); \n// r += 2.*( A(1.5)- .5*A(2.5) );\n// r += 1.7*( A(1.5)- .45*A(2.5) );\n// r += .01*(texelFetch(iChannel1,ivec2(u)%256,0).r-.5); // if you want to add noise\n\n   vec2 R = iResolution.xy; r += (1.7+.4*u/R).x * ( A(1.5)- (.4+.2*u/R).y *A(2.5) ); // explore\n   \n   r = clamp(r,0.,1.);\n   iFrame<2 ? r -= dot(u-=99.,u) : r;\n}\n", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define M void mainImage(out vec4 r, vec2 u) { r -= r//\n#define A(v) texture(iChannel0,u/iResolution.xy,v+0.)\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtVSWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7sGSzG", "name": "Exocube", "author": "z0rg", "description": "Inspired by an electric gems video cover", "tags": ["retro", "cube", "hexagone"], "likes": 17, "viewed": 434, "published": 3, "date": "1640598552", "time_retrieved": "2024-07-30T18:39:55.994407", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    vec3 l2 = abs(l)-th;\n    \n    float x = max(l2.y, l2.z);\n    float y = max(l2.x, l2.z);\n    float z = max(l2.x, l2.y);\n    float cucube = max(min(min(x, y), z), cube);\n    return cucube;\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    acc = _min(acc, vec2(-(abs(p.y)-1.), 0.));\n    p.xy *= r2d(iTime*.76);\n    p.xz *= r2d(iTime*.5);\n    acc = _min(acc, vec2(_cucube(p, vec3(.5), vec3(.02)), 1.));\n    return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+r*uv.x+u*uv.y);\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p,ro), res.y);\n        p+= rd*res.x;\n    }\n    return vec3(-1.);\n}\n\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l = abs(p)-s;\n    return max(l.x, l.y);\n}\n\nvec3 palette(float f)\n{\n    vec3 cols[6];\n    cols[0] = vec3(1.000,0.871,0.522);\n    cols[1] = vec3(1.000,0.608,0.059);\n    cols[2] = vec3(1.000,0.302,0.000);\n    cols[3] = vec3(0.565,0.180,0.325);\n    cols[4] = vec3(0.196,0.145,0.208);\n    cols[5] = vec3(0.122,0.106,0.102);\n    float coef = f*5.;\n    int idx = int(coef);\n    return mix(cols[idx], cols[min(idx+1,5)], fract(coef));\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    \n    float dist = 10.;\n    float t = iTime*.25;\n    vec3 ro = vec3(sin(t)*dist,-0.5,cos(t)*dist);\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 128);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = normalize(cross(dFdx(p), dFdy(p)));\n        col = n*.5+.5;\n        if (res.z == 0.)\n        {\n\n        vec2 uvp = p.xz;\n        vec2 rep = vec2(1.,1.7);\n        vec2 idx = floor(((uvp+rep*.5)/rep));\n        uvp = mod(uvp+rep*.5,rep)-rep*.5;\n        float an = atan(uvp.y,uvp.x);\n        float astp = PI*2./6.;\n        float sector = mod(an+astp*.5,astp)-astp*.5;\n        //uvp -= vec2(0.,0.5);\n        uvp = vec2(sin(sector), cos(sector))*length(uvp);\n        uvp -= vec2(0.,.5);\n        col = mix(col, col*.5, 1.-sat((uvp.y)*400.));\n        \n        vec2 uvp2 = p.xz+rep*.5;\n        vec2 idx2 = floor(((uvp2+rep*.5)/rep));\n        uvp2 = mod(uvp2+rep*.5,rep)-rep*.5;\n        float an2 = atan(uvp2.y,uvp2.x);\n        float sector2 = mod(an2+astp*.5,astp)-astp*.5;\n        //uvp -= vec2(0.,0.5);\n        uvp2 = vec2(sin(sector2), cos(sector2))*length(uvp2);\n        uvp2 -= vec2(0.,.5);\n        col = mix(col, col*.5, 1.-sat((uvp2.y)*400.));\n        col = palette(sin(sign(uv.y)*idx.x+iTime)*.5+.5);\n        idx *= r2d(iTime*.15*sign(p.y));\n        idx2*= r2d(-iTime*.25*sign(p.y));\n        float shape = _sqr(idx,vec2(.5));\n        float shape2 = _sqr(idx2-vec2(.5),vec2(.5));\n        col = vec3(0.);\n        col = mix(col, palette(sat(shape*.12)), 1.-sat((uvp.y)*400.));\n        col = mix(col, palette(sat(shape2*.12)), 1.-sat((uvp2.y)*400.));\n          }\n                else\n                {\n                    col = vec3(1.);\n                }\n    }\n    else\n        col = mix(vec3(0.1), vec3(0.875,0.490,0.949), 1.-sat(abs(rd.y)*15.))*.125;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    uv *= r2d(PI*.125*sin(iTime*.25));\n    vec3 col = rdr(uv);\n    \n    vec2 off = (vec2(1., -1.)/(iResolution.x*2.));\n    if (true) // Not so cheap antialiasing\n    {\n        //col = vec3(1.,0.,0.);\n        vec3 acc = col;\n        acc += rdr(uv+off.xx);\n        acc += rdr(uv+off.xy);\n        acc += rdr(uv+off.yy);\n        acc += rdr(uv+off.yx);\n        col = acc/5.;\n        \n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGSzG.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[452, 452, 471, 471, 529], [531, 531, 571, 571, 829], [831, 831, 858, 858, 911], [912, 912, 930, 930, 1147], [1149, 1149, 1180, 1180, 1311], [1313, 1313, 1354, 1354, 1573], [1575, 1575, 1603, 1603, 1654], [1656, 1656, 1679, 1679, 2041], [2043, 2043, 2062, 2062, 3955], [3957, 3957, 4014, 4014, 4493]], "test": "untested"}
{"id": "stySWz", "name": "Bouncing Baubles", "author": "oneshade", "description": "Bouncing baubles.", "tags": ["2d", "christmas", "particles", "baubles"], "likes": 19, "viewed": 238, "published": 3, "date": "1640577320", "time_retrieved": "2024-07-30T18:39:57.037618", "image_code": "// Transformations\nmat2 Rotate2D(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co, -si, si, co);\n}\n\n// http://marcodiiga.github.io/radial-lens-undistortion-filtering\nvec2 barrelDistort(in vec2 p, in vec2 alpha) {\n    return p / (1.0 - alpha * dot(p, p));\n}\n\n// SDFs\nfloat sdCircle(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdStar5(in vec2 p, in float r, in float rf) {\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x, k1.y);\n    p.x = abs(p.x);\n    p -= 2.0 * max(dot(k1, p), 0.0) * k1;\n    p -= 2.0 * max(dot(k2, p), 0.0) * k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf * vec2(-k1.y, k1.x) - vec2(0.0, 1.0);\n    float h = clamp(dot(p, ba) / dot(ba, ba), 0.0, r);\n    return length(p - ba * h) * sign(p.y * ba.x - p.x * ba.y);\n}\n\n// Bauble design\nvoid drawBauble(inout vec3 pixel, in vec2 uv, in float unit, in float id, in vec2 pos, in float radius) {\n    float aa = unit / radius;\n    uv = (uv - pos) / radius;\n\n    vec3 color = Hash13(id + 18.0);\n    color /= max(color.r, max(color.g, color.b));\n    float radGrad = pow(abs(1.0 - length(uv)), 0.5);\n    float bauble = sdCircle(uv, 1.0);\n    pixel = mix(pixel, color * radGrad, smoothstep(aa, 0.0, bauble));\n\n    uv = barrelDistort(uv, vec2(0.4));\n    uv *= Rotate2D(Hash11(id + 1.0) * 6.28);\n    uv = mod(uv + 0.25, 0.5) - 0.25;\n\n    float selection = id / float(BAUBLES);\n    float pattern = selection < 0.5 ? sdCircle(uv, 0.1) : sdStar5(uv, 0.15, 0.5);\n\n    pattern = max(pattern, bauble);\n    pixel = mix(pixel, vec3(1.0, 1.0, 0.0) * sqrt(radGrad), smoothstep(aa, 0.0, pattern));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    fragColor = vec4(0.75);\n\n    // Draw particles\n    for (int id=0; id < BAUBLES; id++) {\n        Bauble b = loadBauble(id);\n        drawBauble(fragColor.rgb, uv, unit, float(id), b.pos, b.radius);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Settings\n#define BAUBLES 8\n#define EPSILON 0.001\n#define dt 1.0\n\n// Utilities\nstruct Bauble {\n    int id;\n    vec2 pos;\n    vec2 vel;\n    float mass;\n    float radius;\n};\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvec2 Hash12(in float x) {\n\tvec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 Hash13(in float p) {\n    vec3 p3 = fract(p * vec3(0.1031, 0.103, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xxy + p3.yzz) * p3.zyx); \n}\n\n// Initialize\nvec4 initBauble(in ivec2 addr) {\n    if (addr.x < BAUBLES) {\n        float x = float(addr.x) + iDate.w;\n        if (addr.y == 0) return vec4(Hash12(x + 274.937) - 0.5, 0.0, 0.0);\n        if (addr.y == 1) return vec4((Hash12(x + 385.583) - 0.5) * 0.01, 0.0, 0.0);\n        if (addr.y == 2) return vec4(mix(0.1, 0.25, Hash11(x + 858.938)), 0.0, 0.0, 0.0);\n        if (addr.y == 3) return vec4(mix(0.1, 0.2, Hash11(x + 374.497)), 0.0, 0.0, 0.0);\n        return vec4(0.0);\n    }\n\n    return vec4(0.0);\n}\n\n// Load/store\n#define loadBauble(bId)                                \\\n    Bauble(bId,                                        \\\n           texelFetch(iChannel0, ivec2(bId, 0), 0).xy, \\\n           texelFetch(iChannel0, ivec2(bId, 1), 0).xy, \\\n           texelFetch(iChannel0, ivec2(bId, 2), 0).x,  \\\n           texelFetch(iChannel0, ivec2(bId, 3), 0).x)  \\\n\nvec4 storeBauble(in Bauble b, in ivec2 addr) {\n    if (addr.y == 0) return vec4(b.pos, 0.0, 0.0);\n    if (addr.y == 1) return vec4(b.vel, 0.0, 0.0);\n    if (addr.y == 2) return vec4(b.mass, 0.0, 0.0, 0.0);\n    if (addr.y == 3) return vec4(b.radius, 0.0, 0.0, 0.0);\n}", "buffer_a_code": "// Force particles to stay within boundaries\nvec2 constrain(in vec2 pos, in vec2 constraints, in float radius) {\n    constraints -= radius - EPSILON;\n    return clamp(pos, -constraints, constraints);\n}\n\nBauble updateBauble(in Bauble b, in vec2 constraints) {\n    // Boundary collisions\n    if (abs(b.pos.x) > constraints.x - b.radius) b.vel.x = -b.vel.x;\n    if (abs(b.pos.y) > constraints.y - b.radius) b.vel.y = -b.vel.y;\n\n    // Particle-particle collisions\n    for (int id=0; id < BAUBLES; id++) {\n        if (id != b.id) {\n            Bauble b2 = loadBauble(id);\n            vec2 dir = b.pos - b2.pos;\n            float dist = length(dir);\n            float rsum = b.radius + b2.radius;\n            if (dist < rsum) {\n                vec2 n = dir / dist;\n                b.pos -= n * (dist - rsum);\n                vec2 perp = vec2(-n.y, n.x);\n                b.vel = dot(b2.vel, n) * n + dot(b.vel, perp) * perp;\n                // How to account for different masses?\n            }\n        }\n    }\n\n    // Move\n    b.pos = constrain(b.pos + b.vel * dt, constraints, b.radius);\n\n    return b;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 constraints = vec2(iResolution.x / iResolution.y * 0.5, 0.5);\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFrame == 0) fragColor = initBauble(iFragCoord);\n    if (iFrame > 0) {\n        if (iFragCoord.x < BAUBLES && iFragCoord.y < 4) {\n            Bauble b = loadBauble(iFragCoord.x);\n            b = updateBauble(b, constraints);\n            fragColor = storeBauble(b, iFragCoord);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stySWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 19, 46, 46, 118], [120, 186, 232, 232, 276], [278, 286, 325, 325, 353], [355, 406, 457, 457, 868], [870, 887, 992, 992, 1678], [1680, 1680, 1735, 1735, 2047]], "test": "untested"}
{"id": "ftyXD1", "name": "Wave interference simulation", "author": "x44203", "description": "The individual sources are placed in the for loop", "tags": ["simulation", "mathematics", "physics"], "likes": 5, "viewed": 276, "published": 3, "date": "1640576480", "time_retrieved": "2024-07-30T18:39:57.965138", "image_code": "#define pi 3.14159265358979323846264338327950288419716939937510582097494459230781640\n#define tau pi * 2.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float wavelength = 1.0 / 25.0;\n    float c = 0.1;\n    \n    \n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.x * 2.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    int sources = 64;\n    \n    float value = 0.0;\n    for (int i = 0; i < sources; i++)\n    {\n        float percentage = float(i) / float(sources);\n        \n        /* // Uncomment this for spiral waves and put the block below into comments\n        float x = sin(percentage * tau) * wavelength * 0.25;\n        float y = cos(percentage * tau) * wavelength * 0.25;\n        float phase = percentage * tau;\n        */\n        \n        /* // Uncomment this for linear waves to the right and put the block below into comments\n        float x = percentage * wavelength * 4. - 0.5;\n        float y = 0.0;\n        float phase = percentage * tau * 4.;;\n        */\n        \n        // Adjust these to make different arrangements\n        float fs = float(sources);\n        float sfs = sqrt(fs);\n        float sfs1 = 1. / sfs;\n        float x = (mod(percentage + 0.0001, sfs1) - 0.5 / sfs + 0.5 / fs) * sfs * wavelength * 2.;\n        float y = ((percentage - mod(percentage + 0.0001, sfs1)) * sfs1 - 0.5 / sfs + 0.5 / fs) * sfs * wavelength * 2.;\n        float phase = percentage * tau * 4.;\n        phase = -length(vec2(x, y) + 1. * vec2(sin(iTime), cos(iTime))) * tau / wavelength;\n        \n    \n        vec2 pos = vec2(x, y);\n        \n        value += sin(length(uv.xy - pos) / wavelength * tau - iTime * c * 3. / wavelength * tau + phase);\n        \n        // Green dots indicate source positions\n        col.y += exp(-100000. * pow(length(uv.xy - pos), 2.));\n    }\n    \n    col.x = +value / float(sources);\n    col.z = -value / float(sources);\n    \n    if (length(uv) < 0.005)\n    col.xyz = vec3(1., 1., 1.);\n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyXD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 164, 164, 2095]], "test": "untested"}
{"id": "NlGXzz", "name": "Path traced Rayleigh scattering", "author": "loicvdb", "description": "Mouse to rotate camera.\n\nSpectral path tracing of a rayleigh volume, using delta tracking instead of raymarching (slower, but unbiased). My first go at wavelength importance sampling and low discrepency sequences.", "tags": ["fractal", "volume", "mandelbulb", "volumetric", "pathtracing", "tracing", "rayleigh", "path", "spectral"], "likes": 88, "viewed": 2181, "published": 3, "date": "1640559722", "time_retrieved": "2024-07-30T18:39:59.497042", "image_code": "vec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nconst mat3 xyz2rgb = mat3(\n     3.2404542,-0.9692660, 0.0556434,\n    -1.5371385, 1.8760108,-0.2040259,\n    -0.4985314, 0.0415560, 1.0572252\n);\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    vec3 x = max(texelFetch(iChannel0, ivec2(u), 0).xyz, 0.0);\n    \n    float r = floor(log2(iResolution.y) - 4.5) + 0.5;\n    for(int i = 0; i < 2; i++)\n        x += texture(iChannel0, u/iResolution.xy, r + float(i * 2)).xyz * 0.1;\n        \n    o = vec4(ACESFilm(max(xyz2rgb * x, 0.0)), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// spp per frame\nconst int SPP = 1;\n\nconst float PI = 3.141592653589793;\n\n// Spectrum with its integral\nconst vec3 cie[48] = vec3[48](\n    vec3( 0.000000f, 0.000000f, 0.000001f ),    // 360 nm\n    vec3( 0.000006f, 0.000001f, 0.000026f ),    // 370 nm\n    vec3( 0.000160f, 0.000017f, 0.000705f ),    // 380 nm\n    vec3( 0.002362f, 0.000253f, 0.010482f ),    // 390 nm\n    vec3( 0.019110f, 0.002004f, 0.086011f ),    // 400 nm\n    vec3( 0.084736f, 0.008756f, 0.389366f ),    // 410 nm\n    vec3( 0.204492f, 0.021391f, 0.972542f ),    // 420 nm\n    vec3( 0.314679f, 0.038676f, 1.553480f ),    // 430 nm\n    vec3( 0.383734f, 0.062077f, 1.967280f ),    // 440 nm\n    vec3( 0.370702f, 0.089456f, 1.994800f ),    // 450 nm\n    vec3( 0.302273f, 0.128201f, 1.745370f ),    // 460 nm\n    vec3( 0.195618f, 0.185190f, 1.317560f ),    // 470 nm\n    vec3( 0.080507f, 0.253589f, 0.772125f ),    // 480 nm\n    vec3( 0.016172f, 0.339133f, 0.415254f ),    // 490 nm\n    vec3( 0.003816f, 0.460777f, 0.218502f ),    // 500 nm\n    vec3( 0.037465f, 0.606741f, 0.112044f ),    // 510 nm\n    vec3( 0.117749f, 0.761757f, 0.060709f ),    // 520 nm\n    vec3( 0.236491f, 0.875211f, 0.030451f ),    // 530 nm\n    vec3( 0.376772f, 0.961988f, 0.013676f ),    // 540 nm\n    vec3( 0.529826f, 0.991761f, 0.003988f ),    // 550 nm\n    vec3( 0.705224f, 0.997340f, 0.000000f ),    // 560 nm\n    vec3( 0.878655f, 0.955552f, 0.000000f ),    // 570 nm\n    vec3( 1.014160f, 0.868934f, 0.000000f ),    // 580 nm\n    vec3( 1.118520f, 0.777405f, 0.000000f ),    // 590 nm\n    vec3( 1.123990f, 0.658341f, 0.000000f ),    // 600 nm\n    vec3( 1.030480f, 0.527963f, 0.000000f ),    // 610 nm\n    vec3( 0.856297f, 0.398057f, 0.000000f ),    // 620 nm\n    vec3( 0.647467f, 0.283493f, 0.000000f ),    // 630 nm\n    vec3( 0.431567f, 0.179828f, 0.000000f ),    // 640 nm\n    vec3( 0.268329f, 0.107633f, 0.000000f ),    // 650 nm\n    vec3( 0.152568f, 0.060281f, 0.000000f ),    // 660 nm\n    vec3( 0.081261f, 0.031800f, 0.000000f ),    // 670 nm\n    vec3( 0.040851f, 0.015905f, 0.000000f ),    // 680 nm\n    vec3( 0.019941f, 0.007749f, 0.000000f ),    // 690 nm\n    vec3( 0.009577f, 0.003718f, 0.000000f ),    // 700 nm\n    vec3( 0.004553f, 0.001768f, 0.000000f ),    // 710 nm\n    vec3( 0.002175f, 0.000846f, 0.000000f ),    // 720 nm\n    vec3( 0.001045f, 0.000407f, 0.000000f ),    // 730 nm\n    vec3( 0.000508f, 0.000199f, 0.000000f ),    // 740 nm\n    vec3( 0.000251f, 0.000098f, 0.000000f ),    // 750 nm\n    vec3( 0.000126f, 0.000050f, 0.000000f ),    // 760 nm\n    vec3( 0.000065f, 0.000025f, 0.000000f ),    // 770 nm\n    vec3( 0.000033f, 0.000013f, 0.000000f ),    // 780 nm\n    vec3( 0.000018f, 0.000007f, 0.000000f ),    // 790 nm\n    vec3( 0.000009f, 0.000004f, 0.000000f ),    // 800 nm\n    vec3( 0.000005f, 0.000002f, 0.000000f ),    // 810 nm\n    vec3( 0.000003f, 0.000001f, 0.000000f ),    // 820 nm\n    vec3( 0.000002f, 0.000001f, 0.000000f )     // 830 nm\n);\n\nconst float invSpecIntegral = 1.0 / 116.643;\n\nfloat uintRangeToFloat(uint i)\n{\n    return float(i) / float(0xFFFFFFFFu);\n}\n\n// low-ish discrepency sequences\n\nconst uint LAMBDA = 0u;\nconst uint DOF_U = 1u;\nconst uint DOF_V = 2u;\nconst uint AA_U = 3u;\nconst uint AA_V = 4u;\nconst uint BASE = 5u;\n\nconst uint BRDF_U = 0u;\nconst uint BRDF_V = 1u;\nconst uint BOUNCE = 2u;\n\nuint bounce;\nuint frame;\nuint pixel;\nuint seed;\n\n\nuint hash(uint i)\n{\n\ti ^= i >> 12u;\n\ti *= 0xB5297A4Du;\n\ti ^= i >> 12u;\n\ti += 0x68E31DA4u;\n\ti ^= i >> 12u;\n\ti *= 0x1B56C4E9u;\n\treturn i;\n}\n\nfloat random()\n{\n    return uintRangeToFloat(hash(seed++));\n}\n\n\nfloat prng(uint dimension)\n{\n    // 32 dimensional noise\n    const int nDim = 32;\n    \n    // additive recurrence, using square roots of primes (some have been modified to not be too small)\n    const uint sqPrimes[nDim] = uint[nDim](\n        0x6a09e667u, 0xbb67ae84u, 0x3c6ef372u, 0xa54ff539u, 0x510e527fu, 0x9b05688au, 0x1f83d9abu, 0x5be0cd18u,\n        0xcbbb9d5cu, 0x629a2929u, 0x91590159u, 0x452fecd8u, 0x67332667u, 0x8eb44a86u, 0xdb0c2e0bu, 0x47b5481du,\n        0xae5f9155u, 0xcf6c85d1u, 0x2f73477du, 0x6d1826cau, 0x8b43d455u, 0xe360b595u, 0x1c456002u, 0x6f196330u,\n        0xd94ebeafu, 0x9cc4a611u, 0x261dc1f2u, 0x5815a7bdu, 0x70b7ed67u, 0xa1513c68u, 0x44f93634u, 0x720dcdfcu\n    );\n    \n    // low disrepency for dimensions < 32\n    if (dimension < uint(nDim))\n    {\n        return uintRangeToFloat((frame + pixel) * sqPrimes[dimension]);\n    }\n    // noise after that\n    else\n    {\n        return uintRangeToFloat(hash(frame + pixel));\n    }\n}\n\n\n// implicit volume\n\nfloat density(vec3 p)\n{\n    p = -p;\n\tvec3 w = p;\n\tfloat m = dot(w, w);\n    \n\tfor(int j = 0; j < 4; j++)\n    {\n\t\tif(m > 1.2) break;\n        \n        #if 0\n        \n        // trig\n        float a = 8.0 * acos(w.y * inversesqrt(m));\n        float i = 8.0 * atan(w.x, w.z);\n        w = m*m*m*m * vec3(sin(a) * sin(i), cos(a), sin(a) * cos(i)) + p;\n        \n        #elif 0\n        \n        // IQs\n\t\tfloat x = w.x;\n\t\tfloat y = w.y;\n\t\tfloat z = w.z;\n        float x2 = x * x;\n        float y2 = y * y;\n        float z2 = z * z;\n        float x4 = x2 * x2;\n        float y4 = y2 * y2;\n        float z4 = z2 * z2;\n\t\tfloat k3 = x2 + z2;\n\t\tfloat k2 = inversesqrt(k3 * k3 * k3 * k3 * k3 * k3 * k3);\n\t\tfloat k1 = x4 + y4 + z4 - 6.0 * y2 * z2 - 6.0 * x2 * y2 + 2.0 * z2 * x2;\n\t\tfloat k4 = x2 - y2 + z2;\n\t\tw.x = p.x +  64.0 * x * y * z * (x2 - z2) * k4 * (x4 - 6.0 * x2 * z2 + z4) * k1 * k2;\n\t\tw.y = p.y + -16.0 * y2 * k3 * k4 * k4 + k1 * k1;\n\t\tw.z = p.z + -8.0 * y * k4 * (x4 * x4 - 28.0 * x4 * x2 * z2 + 70.0 * x4 * z4 - 28.0 * x2 * z2 * z4 + z4 * z4) * k1 * k2;\n        \n        #else\n        \n        // faster version\n\t\tfloat x2 = w.x * w.x;\n\t\tfloat y2 = w.y * w.y;\n\t\tfloat z2 = w.z * w.z;\n        float x4 = x2 * x2;\n        float z4 = z2 * z2;\n        float k1 = x2 * z2;\n\t\tfloat k2 = x2 + z2;\n\t\tfloat k3 = x4 + z4 + y2 * (y2 - 6.0 * k2) + 2.0 * k1;\n        float k4 = k2 * k2 * k2;\n\t\tfloat k5 = k3 * inversesqrt(k4 * k4 * k2);\n\t\tfloat k6 = w.y * (k2 - y2);\n\t\tw.x = p.x + 64.0 * k6 * k5 * w.x * w.z * (x2 - z2) * (x4 - 6.0 * k1 + z4);\n\t\tw.y = p.y - 16.0 * k6 * k6 * k2 + k3 * k3;\n\t\tw.z = p.z - 8.0 * k6 * k5 * (x4 * (x4 - 28.0 * k1 + 70.0 * z4) + z4 * (z4 - 28.0 * k1));\n        \n        #endif\n        \n\t\tm = dot(w, w);\n\t}\n    \n\treturn mix(1.0, 0.005, step(1.2, m));\n}\n\n\n// volume tracing using detla tracking\n\nfloat trace(vec3 ro, vec3 rd, float l)\n{\n   \n    float b = -dot(ro, rd);\n    float d = b * b - dot(ro, ro) + 1.3;\n    \n    if(d < 0.0) return -1.0;\n    \n    float s = sqrt(d);\n    \n    float t = max(b - s, 0.0);\n    float mt = b + s;\n    \n    float invMaxDensity = l*l*l*l * 2.0e-13;\n    bool hit = false;\n    for (int i = 0; i < 256 && !hit && t < mt; i++)\n    {\n        t -= log(1.0 - random()) * invMaxDensity;\n        hit = random() < density(ro + rd * t);\n    }\n     \n    return hit && t < mt ? t : -1.0;\n}\n\n// brdf importance sampling\n\nvec3 brdfSample()\n{\n    vec2 r = vec2(2.0 * PI * prng(BASE + bounce * BOUNCE + BRDF_U),\n                  acos(2.0 * prng(BASE + bounce * BOUNCE + BRDF_V) - 1.0));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(s.y * s.x, s.y * c.x, c.y);\n}\n\nfloat brdfPdf(vec3 wi)\n{\n    return 0.25 / PI;\n}\n\n\nfloat brdf(vec3 wi)\n{\n    return 3.0 * (1.0 + wi.z * wi.z) / (PI * 16.0);\n}\n\n// wavelength importance sampling (proportional to luminance)\n\nfloat lambdaSample()\n{\n    float y = prng(LAMBDA), g;\n    \n    int i;\n    for (i = 0; i < 47 && y >= 0.0; i++)\n    {\n        g = cie[i].y * invSpecIntegral;\n        y -= g * 10.0;\n    }\n    \n    return float(355 + i * 10) + y / g;\n}\n\n\nfloat lambdaPdf(float l)\n{\n    int index = int(l * 0.1 - 35.5);\n    if(index < 0 || index > 47) \n    {\n        return 0.0;\n    }\n    return cie[index].y * invSpecIntegral;\n}\n\n\nvec3 wavelength2xyz(float l)\n{\n\tfloat x = l * 0.1 - 36.0;\n    int index = int(x);\n    if(index < 0 || index >= 47) \n    {\n        return vec3(0.0);\n    }\n    return mix(cie[index], cie[index + 1], fract(x)) * invSpecIntegral;\n}\n\n\nvec3 ortho(vec3 v)\n{\n    return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y,v.x,0.) : vec3(0.,-v.z,v.y));\n}\n\n\nfloat blackbody(float l, float t)\n{\n    const float h = 6.62607004e-16;\n    const float k = 1.38064852e-5;\n    const float c = 299792458e9;\n    \n    float a = 2.0 * h * c * c;\n    float b = h * c / (l * k * t);\n    return a / (l*l*l*l*l  * (exp(b) - 1.0));\n}\n\n\nfloat background(vec3 rd, float l)\n{\n    return 0.0;\n}\n\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    pixel = hash(uint(gl_FragCoord.x) + uint(gl_FragCoord.y) * 0x452fecd8u);\n    frame = iFrame == 0  || iMouse.z > 0.0 ? 0u : uint(texelFetch(iChannel0, ivec2(u), 0).a);\n    seed = hash(frame) ^ pixel;\n    \n    o.rgb = iFrame == 0 ? vec3(0) : texelFetch(iChannel0, ivec2(u), 0).rgb;\n    \n    vec2 rot = PI * (iMouse.yx - iResolution.yx * 0.5) / iResolution.y;\n    vec2 c = cos(rot), s = sin(rot);\n    mat3 rx = mat3(1, 0, 0, 0, c.x, -s.x, 0, s.x, c.x);\n    mat3 ry = mat3(c.y, 0, -s.y, 0, 1, 0, s.y, 0, c.y);\n    mat3 r = ry * rx;\n    \n    for (int i = 0; i < SPP; i++)\n    {\n        float a = prng(DOF_U) * PI * 2.0;\n        vec2 aperture = 0.05 * sqrt(prng(DOF_V)) * vec2(cos(a), sin(a));\n        vec2 uv = (floor(u) + vec2(prng(AA_U), prng(AA_V)) - iResolution.xy * 0.5) / iResolution.y;\n        vec3 ro = vec3(aperture, -4.0);\n        vec3 rd = normalize(vec3(uv * 3.9 / 6.0 - aperture, 3.9));\n        \n        ro = r * ro;\n        rd = r * rd;\n        \n        ro += vec3(0.0, 0.8, 0.0);\n        \n        float li = 0.0;\n        float att = 1.0;\n        \n        float l = lambdaSample();\n        \n        for (bounce = 0u; bounce < 8u; bounce++)\n        {\n            float t = trace(ro, rd, l);\n            \n            if (t < 0.0)\n            {\n                li += att * background(rd, l);\n                break;\n            }\n            \n            ro += rd * t;\n            \n            vec3 b = ortho(rd);\n            mat3 brdf2World = mat3(cross(b, rd), b, rd);\n            mat3 world2Brdf = transpose(brdf2World);\n            \n            const vec3 lDir = normalize(vec3(1.0));\n            \n            if (trace(ro, lDir, l) < 0.0)\n            {\n                li += att * brdf(world2Brdf * lDir) * blackbody(l, 6400.0) * 0.0003;\n            }\n            \n            rd = brdfSample();\n            att *= brdf(rd) / brdfPdf(rd);\n            \n            rd = brdf2World * rd;\n        }\n        \n        vec3 col = li / lambdaPdf(l) * wavelength2xyz(l);\n        \n        frame++;\n        \n        o = vec4(mix(o.rgb, col, 1.0 / float(frame)), frame);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGXzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 163], [309, 309, 345, 345, 640]], "test": "untested"}
{"id": "flGXDh", "name": "Wiggle Room", "author": "wyatt", "description": "Snowed in in Montana...", "tags": ["nbody"], "likes": 25, "viewed": 450, "published": 3, "date": "1640557005", "time_retrieved": "2024-07-30T18:40:00.450493", "image_code": "Main\n{\n    Q = vec4(0);\n    float d = 1e9;\n    for (float j = 0.; j < M; j++)\n    for (float i = 0.; i < N; i+=3.)\n    {\n        vec4 a = A(vec2(i,j));\n        vec4 b = A(vec2(i+3.,j));\n        float l = ln(U,a.xy,b.xy);\n        if (l < d) {\n            d = l;\n            Q = (.5+.5*sin(.1*iTime+j+vec4(1,2,3,4)))*\n            smoothstep(3.,2.,abs(l-8.));\n            Q += smoothstep(4.,3.,l);\n        }\n    \n    }\n    Q += .28*(\n        exp(-.01*U.x)+exp(-.01*U.y)+\n        exp(-.01*(R.x-U.x))+exp(-.01*(R.y-U.y))\n        );\n        Q = 1.-Q;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define N 100.\n#define M 8.\n#define Main void mainImage(out vec4 Q, in vec2 U)\n\n\nfloat ln (vec2 p, vec2 a, vec2 b)\n{\n    return distance(p,a+(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\n\n", "buffer_a_code": "vec2 shape (float i, float j) {\n    return vec2(\n        (.5+.4*sin(1.6*j+6.*iTime))*(i/N*.25+.25)*R.x,\n        R.y*(.5+.05*i/N*sin(4.*i/N*6.2))\n    );\n}\nMain\n{\n    if (U.y>M) discard;\n    Q = A(U);\n    {\n        \n        vec2 f = vec2(0);\n        for (float j=0.;j<M;j++)\n        for (float i=0.;i<N;i++)\n        {\n            if (j==floor(U.y)) {\n                vec4 a = A(vec2(i,U.y));\n                vec2 r1 = a.xy-Q.xy;\n                vec2 r2 = shape(i+.5,U.y)-shape(U.x,U.y);\n                float l1 = length(r1);\n                float l2 = length(r2);\n                if (l1>0.)\n                    f += r1/l1/N*(l1-l2);\n            } else {\n                vec4 a = A(vec2(i,j));\n                vec2 r = a.xy-Q.xy;\n                float l = length(r);\n                if (l>0.)\n                    f -= r/l*exp(-l*l/20./20.);\n            }\n        }\n        Q.zw += f;\n        Q.xy += f+Q.zw;\n        if (Q.x<1.)Q.x=1.,Q.z*=-1.,Q.w*=0.;\n        if (Q.y<1.)Q.y=1.,Q.w*=-1.,Q.z*=0.;\n        if (Q.x>R.x)Q.x=R.x,Q.z*=-1.,Q.w*=0.;\n        if (Q.y>R.y)Q.y=R.y,Q.w*=-1.,Q.z*=0.;\n    }\n    \n    if (iMouse.z>0.){\n        vec2 r = iMouse.xy-Q.xy;\n        Q.zw -= 1e-2*r*exp(-5.*length(r)/R.x);\n    }\n    \n    if (iFrame < 1)\n    {\n        \n        Q.xy = shape(U.x,U.y);\n        Q.y += 100.*U.y;\n        Q.z = 0.;\n        Q.w = 0.;\n    }\n\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec2 shape (float i, float j) {\n    return vec2(\n        (.5+.4*sin(1.6*j+6.*iTime))*(i/N*.25+.25)*R.x,\n        R.y*(.5+.05*i/N*sin(4.*i/N*6.2))\n    );\n}\nMain\n{\n    if (U.y>M) discard;\n    Q = A(U);\n    {\n        \n        vec2 f = vec2(0);\n        for (float j=0.;j<M;j++)\n        for (float i=0.;i<N;i++)\n        {\n            if (j==floor(U.y)) {\n                vec4 a = A(vec2(i,U.y));\n                vec2 r1 = a.xy-Q.xy;\n                vec2 r2 = shape(i+.5,U.y)-shape(U.x,U.y);\n                float l1 = length(r1);\n                float l2 = length(r2);\n                if (l1>0.)\n                    f += r1/l1/N*(l1-l2);\n            } else {\n                vec4 a = A(vec2(i,j));\n                vec2 r = a.xy-Q.xy;\n                float l = length(r);\n                if (l>0.)\n                    f -= r/l*exp(-l*l/20./20.);\n            }\n        }\n        Q.zw += f;\n        Q.xy += f+Q.zw;\n        if (Q.x<1.)Q.x=1.,Q.z*=-1.,Q.w*=0.;\n        if (Q.y<1.)Q.y=1.,Q.w*=-1.,Q.z*=0.;\n        if (Q.x>R.x)Q.x=R.x,Q.z*=-1.,Q.w*=0.;\n        if (Q.y>R.y)Q.y=R.y,Q.w*=-1.,Q.z*=0.;\n    }\n    \n    if (iMouse.z>0.){\n        vec2 r = iMouse.xy-Q.xy;\n        Q.zw -= 1e-2*r*exp(-5.*length(r)/R.x);\n    }\n    \n    if (iFrame < 1)\n    {\n        \n        Q.xy = shape(U.x,U.y);\n        Q.y += 100.*U.y;\n        Q.z = 0.;\n        Q.w = 0.;\n    }\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec2 shape (float i, float j) {\n    return vec2(\n        (.5+.4*sin(1.6*j+6.*iTime))*(i/N*.25+.25)*R.x,\n        R.y*(.5+.05*i/N*sin(4.*i/N*6.2))\n    );\n}\nMain\n{\n    if (U.y>M) discard;\n    Q = A(U);\n    {\n        \n        vec2 f = vec2(0);\n        for (float j=0.;j<M;j++)\n        for (float i=0.;i<N;i++)\n        {\n            if (j==floor(U.y)) {\n                vec4 a = A(vec2(i,U.y));\n                vec2 r1 = a.xy-Q.xy;\n                vec2 r2 = shape(i+.5,U.y)-shape(U.x,U.y);\n                float l1 = length(r1);\n                float l2 = length(r2);\n                if (l1>0.)\n                    f += r1/l1/N*(l1-l2);\n            } else {\n                vec4 a = A(vec2(i,j));\n                vec2 r = a.xy-Q.xy;\n                float l = length(r);\n                if (l>0.)\n                    f -= r/l*exp(-l*l/20./20.);\n            }\n        }\n        Q.zw += f;\n        Q.xy += f+Q.zw;\n        if (Q.x<1.)Q.x=1.,Q.z*=-1.,Q.w*=0.;\n        if (Q.y<1.)Q.y=1.,Q.w*=-1.,Q.z*=0.;\n        if (Q.x>R.x)Q.x=R.x,Q.z*=-1.,Q.w*=0.;\n        if (Q.y>R.y)Q.y=R.y,Q.w*=-1.,Q.z*=0.;\n    }\n    \n    if (iMouse.z>0.){\n        vec2 r = iMouse.xy-Q.xy;\n        Q.zw -= 1e-2*r*exp(-5.*length(r)/R.x);\n    }\n    \n    if (iFrame < 1)\n    {\n        \n        Q.xy = shape(U.x,U.y);\n        Q.y += 100.*U.y;\n        Q.z = 0.;\n        Q.w = 0.;\n    }\n\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "vec2 shape (float i, float j) {\n    return vec2(\n        (.5+.4*sin(1.6*j+6.*iTime))*(i/N*.25+.25)*R.x,\n        R.y*(.5+.05*i/N*sin(4.*i/N*6.2))\n    );\n}\nMain\n{\n    if (U.y>M) discard;\n    Q = A(U);\n    {\n        \n        vec2 f = vec2(0);\n        for (float j=0.;j<M;j++)\n        for (float i=0.;i<N;i++)\n        {\n            if (j==floor(U.y)) {\n                vec4 a = A(vec2(i,U.y));\n                vec2 r1 = a.xy-Q.xy;\n                vec2 r2 = shape(i+.5,U.y)-shape(U.x,U.y);\n                float l1 = length(r1);\n                float l2 = length(r2);\n                if (l1>0.)\n                    f += r1/l1/N*(l1-l2);\n            } else {\n                vec4 a = A(vec2(i,j));\n                vec2 r = a.xy-Q.xy;\n                float l = length(r);\n                if (l>0.)\n                    f -= r/l*exp(-l*l/20./20.);\n            }\n        }\n        Q.w -= .05;\n        Q.zw += f;\n        Q.xy += f+Q.zw;\n        if (Q.x<1.)Q.x=1.,Q.z*=-1.,Q.w*=0.;\n        if (Q.y<1.)Q.y=1.,Q.w*=-1.,Q.z*=0.;\n        if (Q.x>R.x)Q.x=R.x,Q.z*=-1.,Q.w*=0.;\n        if (Q.y>R.y)Q.y=R.y,Q.w*=-1.,Q.z*=0.;\n    }\n    \n    if (iMouse.z>0.){\n        vec2 r = iMouse.xy-Q.xy;\n        Q.zw -= 1e-2*r*exp(-5.*length(r)/R.x);\n    }\n    \n    if (iFrame < 1)\n    {\n        \n        Q.xy = shape(U.x,U.y);\n        Q.y += 100.*U.y;\n        Q.z = 0.;\n        Q.w = 0.;\n    }\n\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGXDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7tVXWR", "name": "JCVD - Tiled Animations", "author": "Yusef28", "description": "Showing all animations at once. It uses a buffer to serve the frames for 100 animations (or more if you change what is in common tab)", "tags": ["sprite", "sheet"], "likes": 6, "viewed": 272, "published": 3, "date": "1640549619", "time_retrieved": "2024-07-30T18:40:01.541575", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv/=2.;\n    // Time varying pixel color\n    vec3 col = texture(iChannel0,uv).rgb;\n    \n    //flip\n    //c3 col = texture(iChannel0,vec2(1.-uv.x,uv.y)).rgb;\n    \n    vec2 mousePos = floor(divisions*(vec2(iMouse.x/iResolution.x,\n                         iMouse.y/iResolution.y)));\n    \n    vec2 fragPos = floor(divisions*(vec2(fragCoord.x/iResolution.x,\n                        fragCoord.y/iResolution.y)));\n    \n    if(  (length(fragPos-mousePos) < 0.001) ){\n        col *= vec3(1.,0.7,0.7);\n        }\n    // Output to screen\n    fragColor = vec4(col,1.0);//+texture(iChannel1,uv).xxxw*0.2;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nbool checkBoundingBox(vec2 fragCoord, float idX, float idY){\n    \n    //float idX = mod(frame,divisions);\n    //float idY = frame/divisions;\n    \n  return (   \n            fragCoord.x >= idX*stepWidth \n            //&& fragCoord.x < (idX*stepWidth+stepWidth)\n            && fragCoord.x < (idX+1.)*stepWidth\n            \n            && fragCoord.y >= idY*stepHeight \n           // && fragCoord.y < (idY*stepHeight+stepHeight));\n           && fragCoord.y < (idY+1.)*stepHeight\n           );\n           \n   /*        \n     return (\n            (fragCoord.x/iResolution.x >= idX*(stepWidth/iResolution.x))\n         && (fragCoord.x/iResolution.x < (idX+1.)*(stepWidth/iResolution.x))\n         && (fragCoord.y/iResolution.y >= idY*(stepHeight/iResolution.y))\n         && (fragCoord.y/iResolution.y < (idY+1.)*(stepHeight/iResolution.y))\n            );\n           */\n           \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.,0.,0.,1.);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if( iFrame/int(frameStep) < int(divisions*divisions)){\n        \n        if( (mod(float(iFrame), frameStep) < 0.5) \n           ){\n            \n            float theFrame = float(iFrame) / frameStep;\n\n            float idX = mod(theFrame, divisions);\n\n            //Just needed to floor this lol\n            float idY = floor(theFrame / divisions);\n\n            if( checkBoundingBox(fragCoord, idX, idY )){\n\n                vec2 st = vec2(\n                    //(fragCoord.x-idX*stepWidth)/stepWidth,\n                    //(fragCoord.y-idY*stepHeight)/stepHeight\n\n                    (fragCoord.x/iResolution.x - idX*(stepWidth/iResolution.x)),\n                    (fragCoord.y/iResolution.y - idY*(stepHeight/iResolution.y))\n\n                    );\n\n                fragColor = texture(iChannel0,st*divisions);//vec4(vec3(st.y*divisions),1.);//\n\n\n                }\n            \n            \n            //if not in bounding box get frames we had\n            else{\n                    fragColor = texture(iChannel1,uv);\n                }\n                \n            }\n            //if not time for new frame, get frames we had\n            else{\n                    fragColor = texture(iChannel1,uv);\n                }\n    }\n    else{\n        \n        fragColor = texture(iChannel1, uv);\n    }\n\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define divisions 10. //20.\n#define asp iResolution.y/iResolution.x\n#define stepWidth iResolution.x/divisions\n#define stepHeight (iResolution.y)/divisions\n\n#define frameStep 20. //5.\n\n//for animations we hold info in pixels of the first row\n\n#define SET_ANIMATION 1 //1-3\n\n#define CURRENT_ANIMATION_ADDRESS vec2(2.5,0.5) //will be set by SET_ANIMATION\n\n//animation 1\n#define A1_START_FRAME_ADDRESS vec2(3.5,0.5)\n#define A1_CURRENT_FRAME_ADDRESS vec2(4.5,0.5)\n#define A1_END_FRAME_ADDRESS vec2(5.5,0.5)\n\nfloat rnd(vec2 id){\n    return fract(sin(dot(vec2(12.99,75.71),id)))*45262.;\n}", "buffer_b_code": "\n\nvec3 getAnimationData(float frameAddress){\n\n    return texture(iChannel1,\n               vec2(frameAddress+.5,0.5) / iResolution.xy).xyz;\n    }\n\nvec2 getFrameUV(vec2 uv, float currentFrame){\n\n    float idX = mod(currentFrame, divisions);\n    float idY = floor(currentFrame / divisions);\n    vec2 st = uv/divisions;\n    st.x += idX*(1./divisions);\n    st.y += idY*(1./divisions);\n         \n    return st;\n}\n\nfloat runAnimation( vec2 fragCoord, inout vec4 fragColor, float fA){\n    \n    //get frame info the really greedy way\n    vec2 tmpUV = floor((fragCoord.xy/iResolution.xy)*divisions);\n    //float frameAddress = tmpUV.x + tmpUV.y*divisions;\n    vec3 animationData = getAnimationData(fA);\n    \n    //set it here\n    float startFrame = animationData.x;\n    float currentFrame = animationData.y;\n    float endFrame = animationData.z;\n\n    if( mod(float(iFrame), frameStep) < 0.5) {\n    \n        if(currentFrame >= endFrame || currentFrame < startFrame)\n            {\n                currentFrame = startFrame;\n                //return  currentFrame;\n            }\n        else{currentFrame +=1. ;}\n      \n            vec2 shiftDown = vec2(stepWidth*tmpUV.x, stepHeight*tmpUV.y);\n            vec2 uv = (fragCoord.xy-shiftDown)/vec2(stepWidth,stepHeight);\n            vec2 st = getFrameUV(uv, currentFrame);\n            \n            fragColor = texture(iChannel0, st);\n            //vec4(vec3(currentFrame/(divisions*divisions)),1.);\n    }\n    else{\n        fragColor = texture(iChannel1,fragCoord.xy/iResolution.xy);\n    }\n    return currentFrame;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.,0.,0.,1.);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if( iFrame/int(frameStep) < int(divisions*divisions)){\n         \n        fragColor = texture(iChannel0, uv);\n    }\n    \n    else if( iFrame/int(frameStep) == int(divisions*divisions)){\n   \n        if(fragCoord.x <= divisions*divisions && fragCoord.y == 0.5){\n            \n            fragColor.x = floor(fragCoord.x);//floor(rnd(fragCoord.xy)*90.);\n            fragColor.y = fragColor.x;\n            fragColor.z = min(fragCoord.x + 9.,100.5);  \n        }\n    }\n    \n    else{\n        vec2 id = floor(divisions*uv);\n        float fA = floor(id.x + id.y*divisions);\n        \n        float currentFrame = runAnimation(fragCoord, fragColor,fA);\n        vec4 blankColor = vec4(0.);\n        \n        if(fragCoord.x < (divisions*divisions) && fragCoord.y == 0.5){\n            \n            fragColor.x = floor(fragCoord.x);//floor(fract(sin(fragCoord.x*10.)*45232.)*90.);\n            fragColor.y = runAnimation(\n                        fragCoord,\n                        blankColor,\n                        floor(fragCoord.x));      \n            fragColor.z = floor(fragCoord.x)+9.;//fragColor.x + 8.5;\n        }\n\n    }\n    \n}    ", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVXWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 745]], "test": "untested"}
{"id": "slGSDR", "name": "JCVD Animation Explorer", "author": "Yusef28", "description": "Wait for it to load all frames, then click any of the poses to start an animation.\nNo full screen\nChange number of frames by changing \"divisions\" iin common tab.", "tags": ["sprite", "sheet"], "likes": 4, "viewed": 223, "published": 3, "date": "1640549473", "time_retrieved": "2024-07-30T18:40:02.420226", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0,uv).rgb;\n    \n    vec2 mousePos = floor(divisions*(vec2(iMouse.x/iResolution.x,\n                         iMouse.y/iResolution.y)));\n    \n    vec2 fragPos = floor(divisions*(vec2(fragCoord.x/iResolution.x,\n                        fragCoord.y/iResolution.y)));\n    \n    if(  (length(fragPos-mousePos) < 0.001) ){\n        col *= vec3(1.,0.7,0.7);\n        }\n    // Output to screen\n    fragColor = vec4(col,1.0)+texture(iChannel1,uv).xxxw*0.2;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nbool checkBoundingBox(vec2 fragCoord, float idX, float idY){\n    \n    //float idX = mod(frame,divisions);\n    //float idY = frame/divisions;\n    \n  return (   \n            fragCoord.x >= idX*stepWidth \n            //&& fragCoord.x < (idX*stepWidth+stepWidth)\n            && fragCoord.x < (idX+1.)*stepWidth\n            \n            && fragCoord.y >= idY*stepHeight \n           // && fragCoord.y < (idY*stepHeight+stepHeight));\n           && fragCoord.y < (idY+1.)*stepHeight\n           );\n           \n   /*        \n     return (\n            (fragCoord.x/iResolution.x >= idX*(stepWidth/iResolution.x))\n         && (fragCoord.x/iResolution.x < (idX+1.)*(stepWidth/iResolution.x))\n         && (fragCoord.y/iResolution.y >= idY*(stepHeight/iResolution.y))\n         && (fragCoord.y/iResolution.y < (idY+1.)*(stepHeight/iResolution.y))\n            );\n           */\n           \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.,0.,0.,1.);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if( iFrame/int(frameStep) < int(divisions*divisions)){\n        \n        if( (mod(float(iFrame), frameStep) < 0.5) \n           ){\n            \n            float theFrame = float(iFrame) / frameStep;\n\n            float idX = mod(theFrame, divisions);\n\n            //Just needed to floor this lol\n            float idY = floor(theFrame / divisions);\n\n            if( checkBoundingBox(fragCoord, idX, idY )){\n\n                vec2 st = vec2(\n                    //(fragCoord.x-idX*stepWidth)/stepWidth,\n                    //(fragCoord.y-idY*stepHeight)/stepHeight\n\n                    (fragCoord.x/iResolution.x - idX*(stepWidth/iResolution.x)),\n                    (fragCoord.y/iResolution.y - idY*(stepHeight/iResolution.y))\n\n                    );\n\n                fragColor = texture(iChannel0,st*divisions);//vec4(vec3(st.y*divisions),1.);//\n\n\n                }\n            \n            \n            //if not in bounding box get frames we had\n            else{\n                    fragColor = texture(iChannel1,uv);\n                }\n                \n            }\n            //if not time for new frame, get frames we had\n            else{\n                    fragColor = texture(iChannel1,uv);\n                }\n    }\n    else{\n        \n        fragColor = texture(iChannel1, uv);\n    }\n\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define divisions 10. //20.\n#define asp iResolution.y/iResolution.x\n#define stepWidth iResolution.x/divisions\n#define stepHeight (iResolution.y)/divisions\n\n#define frameStep 20. //5.\n\n//for animations we hold info in pixels of the first row\n\n#define SET_ANIMATION 1 //1-3\n\n#define CURRENT_ANIMATION_ADDRESS vec2(2.5,0.5) //will be set by SET_ANIMATION\n\n//animation 1\n#define A1_START_FRAME_ADDRESS vec2(3.5,0.5)\n#define A1_CURRENT_FRAME_ADDRESS vec2(4.5,0.5)\n#define A1_END_FRAME_ADDRESS vec2(5.5,0.5)\n\n", "buffer_b_code": "\n\nvec3 getAnimationData(){\n    \n    float startFrame = \n                texture(iChannel1,\n                A1_START_FRAME_ADDRESS / iResolution.xy).x;\n    \n    float endFrame = \n                texture(iChannel1,\n                A1_END_FRAME_ADDRESS / iResolution.xy).x;\n                \n    float currentFrame = \n                texture(iChannel1,\n                A1_CURRENT_FRAME_ADDRESS / iResolution.xy).x; \n                \n                return vec3(startFrame,\n                            currentFrame,\n                            endFrame\n                            );\n}\n\n//void setAnimationData(vec2 fragCoord, vec4 fragColor, vec3 data){\n//    if(fragCoord = vec2(2.5,0.5)return;\n//}\nvec2 getFrameUV(vec2 uv, float currentFrame){\n\n    float idX = mod(currentFrame, divisions);\n    float idY = floor(currentFrame / divisions);\n    vec2 st = uv/divisions;\n    st.x += idX*(1./divisions);\n    st.y += idY*(1./divisions);\n         \n    return st;\n}\nfloat runAnimation( vec2 fragCoord, inout vec4 fragColor){\n    \n    \n        //get frame info the really greedy way\n        vec3 animationData = getAnimationData();\n        //set it here\n        float startFrame = animationData.x;\n        float currentFrame = animationData.y;\n        float endFrame = animationData.z;\n\n    if( mod(float(iFrame), frameStep/2.) < 0.5) {\n        if(currentFrame >= endFrame || currentFrame < startFrame)\n            {\n                currentFrame = startFrame;\n            }\n\n        //get the specific part of the buffer we want to render\n      //  if(fragCoord.x < stepWidth && fragCoord.y < stepHeight){\n\n            //set uv only where we want to see the animation(bottom left sqaure)\n            vec2 uv = fragCoord.xy/iResolution.xy;\n            //fragCoord.xy/vec2(stepWidth,stepHeight);\n            //set st to be the square of the current frame of the animation\n            vec2 st = getFrameUV(uv, currentFrame);\n            //set the fragColor to that animation frame color        \n            fragColor = texture(iChannel0,st);\n\n     //   }\n        //update current frame (looping)\n        currentFrame += 1.;\n    }\n    else{\n        fragColor = texture(iChannel1,fragCoord.xy/iResolution.xy);\n    }\n    return currentFrame;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.,0.,0.,1.);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if( iFrame/int(frameStep) < int(divisions*divisions)){\n        \n        \n        fragColor = texture(iChannel0, uv);\n    }\n    \n    else{\n    \n        float currentFrame = runAnimation(fragCoord, fragColor);\n        \n        vec2 animationData = texture(iChannel1, \n                             vec2(1.5,0.5)/iResolution.xy).xy;\n                             \n        float startFrame = animationData.x;\n        float endFrame = animationData.y;\n        \n        if(iMouse.z > 0.5){\n            vec2 mousePos = floor(divisions*(vec2(iMouse.x/iResolution.x,\n                         iMouse.y/iResolution.y)));\n            startFrame = mousePos.x + mousePos.y*divisions;\n            endFrame = startFrame + 10.;\n        }\n        \n        if(fragCoord.xy == vec2(1.5,0.5)){\n            fragColor.xy = vec2(startFrame,endFrame);\n        }\n        \n        if(      fragCoord.x == 3.5 && fragCoord.y == 0.5 ) {\n            fragColor.x = startFrame;\n        }\n        else if( fragCoord.xy == vec2(4.5,0.5) ) {\n            fragColor.x = currentFrame;\n        }  \n        else if( fragCoord.xy == vec2(5.5,0.5) ) {\n            fragColor.x = endFrame;\n        }  \n\n\n    }\n}    ", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGSDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 655]], "test": "untested"}
{"id": "NtGSWz", "name": "JCVD Sprite Sheet -No fullscreen", "author": "Yusef28", "description": "This has been done before by fabrice and crundle https://www.shadertoy.com/view/XsdBzH\nThis is my \"minimalist example\"\nYou can go full screen once but upon returning you lose data", "tags": ["sprite", "sheet"], "likes": 4, "viewed": 261, "published": 3, "date": "1640549039", "time_retrieved": "2024-07-30T18:40:03.308850", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0,uv).rgb;\n    \n    vec2 mousePos = floor(divisions*(vec2(iMouse.x/iResolution.x,\n                         iMouse.y/iResolution.y)));\n    \n    vec2 fragPos = floor(divisions*(vec2(fragCoord.x/iResolution.x,\n                        fragCoord.y/iResolution.y)));\n    \n    if( iMouse.z>0.5 && (length(fragPos-mousePos) < 0.001) ){\n        col *= vec3(1.,0.7,0.7);\n        }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nbool checkBoundingBox(vec2 fragCoord, float idX, float idY){\n    \n    //float idX = mod(frame,divisions);\n    //float idY = frame/divisions;\n    \n  return (   \n            fragCoord.x >= idX*stepWidth \n            //&& fragCoord.x < (idX*stepWidth+stepWidth)\n            && fragCoord.x < (idX+1.)*stepWidth\n            \n            && fragCoord.y >= idY*stepHeight \n           // && fragCoord.y < (idY*stepHeight+stepHeight));\n           && fragCoord.y < (idY+1.)*stepHeight\n           );\n           \n   /*        \n     return (\n            (fragCoord.x/iResolution.x >= idX*(stepWidth/iResolution.x))\n         && (fragCoord.x/iResolution.x < (idX+1.)*(stepWidth/iResolution.x))\n         && (fragCoord.y/iResolution.y >= idY*(stepHeight/iResolution.y))\n         && (fragCoord.y/iResolution.y < (idY+1.)*(stepHeight/iResolution.y))\n            );\n           */\n           \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.,0.,0.,1.);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if(     iFrame/int(frameStep) < int(divisions*divisions) \n         && mod(float(iFrame), frameStep) < 0.5 \n         && fragCoord.x >  0.5\n         && fragCoord.y > 0.5){\n        \n        float theFrame = float(iFrame) / frameStep;\n        \n        float idX = mod(theFrame, divisions);\n        \n        //Just needed to floor this lol\n        float idY = floor(theFrame / divisions);\n        \n        if( checkBoundingBox(fragCoord, idX, idY )){\n\n            vec2 st = vec2(\n                //(fragCoord.x-idX*stepWidth)/stepWidth,\n                //(fragCoord.y-idY*stepHeight)/stepHeight\n                \n                (fragCoord.x/iResolution.x - idX*(stepWidth/iResolution.x)),\n                (fragCoord.y/iResolution.y - idY*(stepHeight/iResolution.y))\n                \n                );\n                \n            fragColor = texture(iChannel0,st*divisions);//vec4(vec3(st.y*divisions),1.);//\n            \n            \n            }\n            \n        else{\n            fragColor = texture(iChannel1,uv);\n            }\n            \n    }else{\n        \n        vec2 prevRes = texture(iChannel1,vec2(0.05)/iResolution.xy ).xy;\n        \n        if(prevRes.x < iResolution.x){\n        \n            vec2 scaledFragCoord;\n            scaledFragCoord.x = fragCoord.x*(prevRes.x/iResolution.x);\n            scaledFragCoord.y = fragCoord.y*(prevRes.y/iResolution.y);\n            uv = scaledFragCoord.xy/iResolution.xy;\n        }\n\n        fragColor = texture(iChannel1,uv);\n        \n        if(     fragCoord.x <= 0.5\n             && fragCoord.y <= 0.5 ){\n                 fragColor.xy = iResolution.xy;\n             }\n         \n\n        }\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define divisions 10. //20.\n#define asp iResolution.y/iResolution.x\n#define stepWidth iResolution.x/divisions\n#define stepHeight (iResolution.y)/divisions\n\n#define frameStep 20. //5.", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGSWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 639]], "test": "untested"}
{"id": "slKSWz", "name": "SampleSunset", "author": "ASchneidman", "description": "Sunset made while following a tutorial.", "tags": ["sunset", "drawing"], "likes": 0, "viewed": 190, "published": 3, "date": "1640539702", "time_retrieved": "2024-07-30T18:40:04.156584", "image_code": "#define PI 3.14159265359\n\nvec3 colorB = vec3(0.104,0.099,0.640);\nvec3 colorA = vec3(1.000,0.933,0.000);\n\nfloat plot (vec2 st, float pct){\n  return  smoothstep( pct-0.01, pct, st.y) -\n          smoothstep( pct, pct+0.01, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord / min(iResolution.x, iResolution.y) - vec2(0.4, 0.0);\n    vec3 color = vec3(0.0);\n\n\tfloat cos_utime = (1. + cos(iTime)) / 2.;\n    float sin_utime = (1. + sin(iTime)) / 2.;\n    \n    vec3 pct = vec3(clamp(st.y - sin_utime, 0., 1.));\n    \n    pct.r = 0.;\n    pct.b = sin_utime;\n    \n    vec2 c = vec2(0.5, sin_utime);\n    vec2 q = st - c;\n    \n    float sun = 1.-smoothstep(0.0, .2, length(q));\n    \n    color = clamp(mix(colorA, colorB, pct) + sun, vec3(0.), vec3(1.));\n    \n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKSWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 137, 137, 228], [230, 230, 287, 287, 819]], "test": "untested"}
{"id": "7tGSzm", "name": "Synthwave sunset logo", "author": "nyri0", "description": "2D shader to play with distance functions, geometric shapes and color, also because it's cool :)\n\nIf it's slow, change AA to 1 (AA 2 is computing 4 samples per pixel).", "tags": ["retro", "synthwave"], "likes": 19, "viewed": 842, "published": 3, "date": "1640537926", "time_retrieved": "2024-07-30T18:40:04.922536", "image_code": "#define AA 2\n#define NH 4\n#define NV 12\n#define PI 3.14159265\n\nfloat prm(float a, float b, float x) {\n    return clamp((x - a) / (b - a) , 0.0, 1.0);\n}\n\nfloat par(float x) {\n    return 1.0 - pow(2.0 * x - 1.0, 2.0);\n}\n\nfloat length_sq(vec2 x) {\n    return dot(x, x);\n}\n\nfloat segment_df(vec2 uv, vec2 p0, vec2 p1) {\n  float l2 = length_sq(p1 - p0);\n  float t = clamp(dot(uv - p0, p1 - p0) / l2, 0.0, 1.0);\n  vec2 projection = p0 + t * (p1 - p0);\n  return distance(uv, projection);\n}\n\n// https://stackoverflow.com/a/2049593/8259873\nfloat segment_side(vec2 p0, vec2 p1, vec2 p2)\n{\n    return (p0.x - p2.x) * (p1.y - p2.y) - (p1.x - p2.x) * (p0.y - p2.y);\n}\n\nbool triangle_in(vec2 uv, vec2 p0, vec2 p1, vec2 p2)\n{\n    float d0 = segment_side(uv, p0, p1);\n    float d1 = segment_side(uv, p1, p2);\n    float d2 = segment_side(uv, p2, p0);\n\n    bool has_neg = (d0 < 0.0) || (d1 < 0.0) || (d2 < 0.0);\n    bool has_pos = (d0 > 0.0) || (d1 > 0.0) || (d2 > 0.0);\n\n    return !(has_neg && has_pos);\n}\n\nfloat triangle_sdf(vec2 uv, vec2 p0, vec2 p1, vec2 p2) {\n    float p0p1 = segment_df(uv, p0, p1);\n    float p1p2 = segment_df(uv, p1, p2);\n    float p2p0 = segment_df(uv, p2, p0);\n    float abs_diff = min(p0p1, min(p1p2, p2p0));\n    return triangle_in(uv, p0, p1, p2) ? -abs_diff : abs_diff;\n}\n\nfloat sun_sdf(vec2 uv) {\n    bool is_in = true;\n    float t = mod(iTime, 4.0) / 4.0;\n    float lo[7] = float[7](0.2, 0.03, -0.14, -0.31, -0.48, -0.65, -0.8);\n    float hi[7] = float[7](0.2, 0.05, -0.1, -0.25, -0.4, -0.55, -0.7);\n    float bands_sdf = 10.0;\n    for(int i = 0; i < 6; i++) {\n        float low = mix(lo[i+1], lo[i], t);\n        float high = mix(hi[i+1], hi[i], t);\n        float band_sdf = max(uv.y-high, low-uv.y);\n        bands_sdf = min(bands_sdf, band_sdf);\n    }\n    float circle_sdf = length(uv) - 0.7;\n    return max(circle_sdf, -bands_sdf);\n}\n\nfloat sq(float x) {\n    return x * x;\n}\n\nbool palm_in(vec2 uv) {\n    const float ah[NH] = float[NH](0.1, 0.25, 1.5, 2.5);\n    const float bh[NH] = float[NH](0.2, 0.75, -0.37, -0.17);\n    const float ch[NH] = float[NH](-0.17, 0.07, -0.147, 0.255);\n    const float dh[NH] = float[NH](-0.8, -0.8, 0.3, 0.1);\n    const float eh[NH] = float[NH](0.3, 0.1, 0.57, 0.37);\n    const float fh[NH] = float[NH](-1.7, -1.7, 0.3, 0.1);\n    const float gh[NH] = float[NH](0.3, 0.1, 0.57, 0.37);\n    const float th0[NH] = float[NH](0.01, 0.01, 0.005, 0.005);\n    const float th1[NH] = float[NH](0.03, 0.03, 0.03, 0.03);\n\n    bool h_in = false;\n    for(int i = 0; i < NH; i++) {\n        float h_dist = abs(uv.x - (ah[i] * sq(uv.y + bh[i]) + ch[i]));\n        h_in = h_in || h_dist < mix(th0[i], th1[i], par(prm(fh[i], gh[i], uv.y)))\n            && uv.y > dh[i] && uv.y < eh[i];\n    }\n    \n    const float av[NV] = float[NV](-2.7, -1.6, -3.5, -3.5, -2.0, -2.5,\n                                   -2.0, -1.6, -3.0, -3.5, -2.5, -3.0);\n    const float bv[NV] = float[NV](0.17, 0.3, 0.35, -0.095, -0.02, 0.2,\n                                   -0.225, -0.095, -0.045, -0.495, -0.4, -0.248);\n    const float cv[NV] = float[NV](0.3, 0.35, 0.46, 0.5, 0.35, 0.31,\n                                   0.1, 0.15, 0.25, 0.3, 0.15, 0.1);\n    const float dv[NV] = float[NV](-0.5, -0.65, -0.5, -0.15, -0.15, -0.15,\n                                   -0.155, -0.255, -0.1, 0.26, 0.26, 0.25);\n    const float ev[NV] = float[NV](-0.14, -0.14, -0.14, 0.15, 0.25, 0.15,\n                                   0.255, 0.255, 0.255, 0.57, 0.645, 0.545);\n\n    bool v_in = false;\n    for(int i = 0; i < NV; i++) {\n        float v_dist = abs(uv.y - (av[i] * sq(uv.x + bv[i]) + cv[i]));\n        v_in = v_in || v_dist < mix(0.005, 0.04, par(prm(dv[i], ev[i], uv.x)))\n            && uv.x > dv[i] && uv.x < ev[i];\n    }\n\n    return h_in || v_in;\n}\n\nmat2 rotation_mat(float alpha) {\n    float c = cos(alpha);\n    float s = sin(alpha);\n    return mat2(c, s, -s, c);\n}\n\nvec4 sampleColor(in vec2 sampleCoord)\n{\n    // uv is centered and such that the vertical values are between -1\n    // and 1 while preserving the aspect ratio.\n    vec2 uv = 2.0* (sampleCoord - iResolution.xy / 2.0) / iResolution.y;\n\n    const vec3 BG = vec3(0.1, 0.1, 0.2);\n    vec3 cyan = vec3(0.3, 0.85, 1);\n    vec3 magenta = vec3(1, 0.1, 1);\n    float t = sin(0.3 * cos(0.2 * iTime) * uv.x + uv.y + 1.0 + 0.15 * cos(0.3 * iTime));\n    vec3 cm = mix(cyan, magenta, t*t);\n    vec3 mc = mix(magenta, cyan, t*t);\n    \n    vec2 a = vec2(0, -0.9);\n    vec2 b = vec2(-1.0, 0.4);\n    vec2 c = vec2(1.1, 0.6);\n    \n    float alpha = 0.25 * cos(0.5 * iTime);\n    float gamma = -0.1 + 0.2 * cos(PI + 0.5 * iTime);\n    float beta = (alpha + gamma) / 2.0;\n    mat2 alpha_mat = rotation_mat(alpha);\n    mat2 beta_mat = rotation_mat(beta);\n    mat2 gamma_mat = rotation_mat(gamma);\n\n    vec2 t0a = alpha_mat * a;\n    vec2 t0b = alpha_mat * b;\n    vec2 t0c = alpha_mat * c;\n    vec2 t1b = mix(t0a, t0b, 3.0);\n    vec2 t1c = mix(t0a, t0c, 3.0);\n    vec2 t2a = beta_mat * a;\n    vec2 t2b = beta_mat * b;\n    vec2 t2c = beta_mat * c;\n    vec2 t3a = gamma_mat * a;\n    vec2 t3b = gamma_mat * b;\n    vec2 t3c = gamma_mat * c;\n    \n    float sun = sun_sdf(uv);\n    bool palm = palm_in(uv);\n    float tri0_sdf = triangle_sdf(uv, t0a, t0b, t0c);\n    float tri1_sdf = triangle_sdf(uv, t0a, t1b, t1c);\n    float tri2_sdf = triangle_sdf(uv, t2a, t2b, t2c);\n    float tri3_sdf = triangle_sdf(uv, t3a, t3b, t3c);\n    \n    vec3 col = BG;\n    \n    if(tri3_sdf < 0.0) col = vec3(0);\n    else if(tri3_sdf < 0.01) col = mc;\n    if(tri2_sdf < 0.0) col = mc;\n    if(tri0_sdf < 0.0) col = vec3(0);\n    else if(tri0_sdf < 0.01) col = mc;\n    if(tri1_sdf < 0.0) col = mix(cm, col, smoothstep(0.0, 0.01, sun));\n    if(tri1_sdf < 0.0 && palm) col = vec3(0);\n\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 colSum = vec4(0);\n    for(int i = 0; i < AA; i++) {\n        for(int j = 0; j < AA; j++) {\n            colSum += sampleColor(fragCoord + vec2(float(i) / float(AA), float(j) / float(AA)));\n        }\n    }\n    fragColor = colSum / colSum.w;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGSzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 101, 101, 151], [153, 153, 173, 173, 217], [219, 219, 244, 244, 268], [270, 270, 315, 315, 482], [484, 531, 578, 578, 654], [656, 656, 710, 710, 989], [991, 991, 1047, 1047, 1284], [1286, 1286, 1310, 1310, 1850], [1852, 1852, 1871, 1871, 1891], [1893, 1893, 1916, 1916, 3745], [3747, 3747, 3779, 3779, 3863], [3865, 3865, 3904, 4023, 5715], [5717, 5717, 5774, 5774, 6023]], "test": "untested"}
{"id": "stKXDR", "name": "Amazing Spider-Man (Sewer)", "author": "dean_the_coder", "description": "This one was a bit of a struggle. Getting the image from my head into the shader was more difficult than I could implement. :/", "tags": ["3d", "raymarching", "water", "caustics", "movie", "spiderman", "cineshader"], "likes": 14, "viewed": 4862, "published": 3, "date": "1640534391", "time_retrieved": "2024-07-30T18:40:05.806173", "image_code": "// 'Amazing Spider-Man (Sewer)' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/stKXDR (YouTube: https://youtu.be/khgZbRSwmFk)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// This one was a bit of a struggle. Getting the image from my head\n// into the shader was more difficult than I could implement.\n// Having webs with a small diameter going off into the distance\n// are tricky to raymarch quickly, and to make the scene better\n// I'd need some focal point adding to it (maybe lizards walking\n// on the webs, but that's beyond my ability atm).\n//\n// Hey ho - It was a fun scene to make, and I've learnt things I\n// can use in later shaders. :)\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n#define minH(a, b, c)\t{ float h_ = a; if (h_ < h.d) h = Hit(h_, b, c); }\n\nfloat t,\n      fade = 1.;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 p;\n};\n\nfloat n31(vec3 p) {\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n    const vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\nfloat smin(float a, float b) {\n\tfloat h = sat(.5 + .5 * (b - a) / .1);\n\treturn mix(b, a, h) - .1 * h * (1. - h);\n}\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat web(vec3 p, vec3 ano) {\n\tfloat lp = dot(p, p),\n\t      d = 1e7;\n\tp.xz *= rot(ano.z);\n\tmat2 r = rot(ano.x);\n\tfor (float i = 0.; i < ano.y; i++) {\n\t\td = min(d, length(p - vec3(max(p.x, 0.), 0, 0)));\n\t\tp.xz *= r;\n\t}\n\n\tvec2 a = sin(lp * vec2(8, 32)) * .5 + 1.;\n\treturn d - .005 * (.5 + dot(a * a * a, vec2(.26, .1)) + .5);\n}\n\nvec3 rayDir(vec3 ro, vec2 uv) {\n\tvec3 f = normalize(vec3(0, 0, 4) - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvec3 dtc(vec2 p, vec3 c) {\n\tif (abs(p.x) > .6 || abs(p.y) > .5) return c;\n\tif (step(min2(abs(p - vec2(0, .2))), .08) * step(p.y, .3) * step(abs(p.x), .4) > 0.) return vec3(8);\n\tfloat f,\n\t      dc = step(.5, p.x);\n\tp.x = abs(p.x) - .46;\n\tf = dot(p, p);\n\tdc += step(f, .25) * step(.16, f);\n\tif (dc > 0.) return vec3(3);\n\treturn c;\n}\n\nfloat watD(vec3 p, bool b) {\n\tif (b) {\n\t\tp.xz *= rot(t * .1);\n\t\tp.z += .1 * t;\n\t}\n\telse p.xz += t;\n\n\tp.y += t * .5;\n\treturn dot(vec2(n21(p.xz * 2.3 * mat2(.5403, .84147, -.84147, .5403)), n31(p.zyx * 5.1)), vec2(.15, .06));\n}\n\nfloat wat(vec3 p) {\n\tfloat d = p.y + 1.95 + watD(p, true),\n\t      disp = watD(p, false);\n\tp.xz *= mat2(.77722, -.62922, .62922, .77722);\n\tp += vec3(1.9, 2.1, -23.4);\n\treturn smin(d, box(p, vec3(.5, .2 + disp, 15. - disp)) - .2);\n}\n\nvec3 watN(vec3 p) {\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * wat(p + e);\n\t}\n\n\treturn normalize(n);\n}\n\nfloat webs(vec3 p) {\n\tp.y += .3;\n\tp.z -= 3.;\n\tfloat d = web(p, vec3(.1, 2, 7.1));\n\td = min(d, web(p, vec3(.17, 12, 4.06)));\n\tp.xy *= mat2(.83094, -.55636, .55636, .83094);\n\treturn min(d, web(p, vec3(.1, 2, 2.02)));\n}\n\nbool water = true;\nHit map(vec3 p) {\n\tfloat lp,\n\t      d = max(p.y + 2.2, 5. - length(p.xz));\n\tHit h = Hit(d, 2, p);\n\tminH(webs(p), 4, p);\n\tif (water) minH(wat(p), 1, p);\n\tp.z -= 3.;\n\tlp = length(p);\n\td = max(abs(lp - 26.5) - 20., -(length(p.xz) - 3.));\n\tvec3 q = p;\n\tq.y++;\n\tq.yz *= mat2(.94496, -.32719, .32719, .94496);\n\tq.xz *= mat2(.9383, .34583, -.34583, .9383);\n\td = max(d, 1.2 - length(q.xy));\n\tq = p;\n\tq.y += .4;\n\tq.xz *= mat2(.77722, -.62922, .62922, .77722);\n\td = max(d, 1.5 - length(q.xy));\n\tminH(d, 3, p);\n\td = box(q + vec3(0, 1.5, 0), vec3(1, .2, 50));\n\tq.x = abs(q.x) - 1.6;\n\tq.y += 1.8;\n\td = max(min(d, box(q, vec3(1, 1, 50))), 6.52 - lp);\n\tminH(d, 2, q);\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p) {\n\tfloat d,\n\t      s = 1.,\n\t      t = .1,\n\t      mxt = length(p - vec3(0, 8.2, 3));\n\tvec3 ld = normalize(vec3(0, 8.2, 3) - p);\n\tfor (float i = Z0; i < 15.; i++) {\n\t\td = map(t * ld + p).d;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.1, d);\n\t\tif (mxt - t < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\nfloat aof(vec3 p, vec3 n, float h) { return sat(map(h * n + p).d / h); }\n\nfloat fog(float d) { return exp(d * d * -5e-4) * S(30., 5., d); }\n\nvec3 lights(vec3 p, vec3 rd, vec3 n, Hit h) {\n\tconst vec2 spe = vec2(10, 1);\n\tvec3 c, ns,\n\t     ld = normalize(vec3(0, 8.2, 3) - p);\n\tfloat ao,\n\t      sha = .02 + shadow(p) * (.01 + S(6.8, 5.8, length(p.xz)));\n\tns = vec3(n31(h.p * 50.), n31(h.p * .5), n31(h.p * 3.));\n\tif (h.id == 3) {\n        // Walls.\n\t\tconst vec3 cs = vec3(.05, .025, 0);\n\t\tfloat v = abs(fract(atan(h.p.z, h.p.x) * 1.90986) - .2);\n\t\tc = vec3(.1);\n\t\tc = mix(pow(ns.x * .03 + c, vec3(1.6, 1.1 + .5 * S(.35, .5, ns.y), 1.6)), c, sat(v * 6.) * .4);\n\t\tc *= .8 + .2 * S(1., .46, ns.z);\n\t\tc = mix(.4 * pow(c, vec3(.75, .8, .66)), c, step(.2 * ns.z - 2., p.y));\n\t\tc = mix(c, ns.x * dtc((h.p.xy - vec2(4, -.5)) * vec2(-1.5, 1.5) * mat2(.91309, -.40776, .40776, .91309), c), .2);\n\t\tc *= .5 + .5 * S01(v * 70.);\n\t\tc *= .5 + .5 * S01(abs(h.p.y - 2.5) * 40.);\n\t\tvec3 uv = p * .2;\n\t\tvec2 q = vec2(watD(uv + cs, true), watD(uv + cs.zyx, true));\n\t\tc += pow(S01(abs(length((watD(uv, true) - q) / .05) - .5)), 4.) * 2.;\n\t}\n\telse if (h.id == 2) {\n        // Ground/steps.\n\t\tc = vec3(.05 - .04 * step(length(p.xz), 6.));\n\t\tif (p.y > -2.) c *= .3 + .7 * S(0., .02, abs(fract(h.p.z * .2) - .5)) * ns.x;\n\t}\n\telse {\n\t\tif (h.id == 1) {\n            // Water.\n\t\t\tn = normalize(n + vec3(0, 0, ns.x * .07));\n\t\t\tsha += .02;\n\t\t\treturn vec3((pow(sat(dot(rd, reflect(ld, n))), 20.) * 25. + S(.6, 1., 1. + dot(rd, n)) * .1 + S(.85, 1., wat(.3 * ld + p) / .3) * .03) * sha);\n\t\t}\n\n\t\tc = vec3(ns.x);\n\t}\n\n\tao = mix(aof(p, n, .2), aof(p, n, 2.), .7);\n\treturn mix((sat(.1 + .9 * dot(ld, n)) * (.3 + .7 * sha) * (.3 + .7 * ao) + sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .2 + pow(sat(dot(rd, reflect(ld, n))), spe.x) * spe.y) * ao * c * vec3(1, .9, .8), vec3(.002), S(.7, 1., 1. + dot(rd, n)) * .5);\n}\n\nvec3 scene(vec3 p, vec3 rd) {\n\tfade = min(1., abs(t));\n\tHit h;\n\tfloat d = 0.;\n\tfor (float i = Z0; i < 1e2; i++) {\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015) break;\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\tif (h.id == 1) {\n        // We hit water - Refract.\n\t\tvec3 n = watN(p),\n\t\t     col = lights(p, rd, n, h);\n\t\trd = refract(rd, n, .99);\n\t\tp += .1 * rd;\n\t\twater = false;\n\t\tfor (float i = Z0; i < 5.; i++) {\n\t\t\th = map(p);\n\t\t\tif (abs(h.d) < .0015) break;\n\t\t\tp += rd * h.d;\n\t\t}\n\n\t\tcol += pow(lights(p, rd, n, h), vec3(1, .9, .8));\n\t\treturn mix(vec3(.002), col, fog(length(p)));\n\t}\n\n\treturn mix(vec3(.002), lights(p, rd, N(p, d), h), fog(d));\n}\n\n#define rgba(col)\tvec4(pow(max(vec3(0), col), vec3(.45)) * fade, 0)\n\nvoid mainVR(out vec4 fragColor, vec2 fc, vec3 ro, vec3 rd) {\n\tt = mod(iTime, 30.);\n\trd.xz *= mat2(1, 0, 0, -1);\n\tfragColor = rgba(scene(ro, rd));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tt = mod(iTime, 30.);\n\tvec2 uv = (fc - .5 * R.xy) / R.y,\n\t     v = fc.xy / R.xy;\n\tvec3 ro = vec3(sin(iTime * vec2(.5, .2)) * .04 + vec2(0, .2 - .4 * cos(t * .2)), 0),\n\t     col = scene(ro, rayDir(ro, uv));\n\tcol *= .5 + .5 * pow(16. * v.x * v.y * (1. - v.x) * (1. - v.y), .4);\n\tfragColor = rgba(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKXDR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1294, 1294, 1313, 1370, 1656], [1658, 1658, 1677, 1677, 1703], [1705, 1705, 1735, 1735, 1819], [1821, 1821, 1841, 1841, 1865], [1867, 1867, 1887, 1887, 1921], [1923, 1923, 1942, 1942, 2002], [2004, 2004, 2031, 2031, 2102], [2104, 2104, 2133, 2133, 2429], [2431, 2431, 2462, 2462, 2605], [2607, 2607, 2633, 2633, 2937], [2939, 2939, 2967, 2967, 3164], [3166, 3166, 3185, 3185, 3396], [3398, 3398, 3417, 3417, 3611], [3613, 3613, 3633, 3633, 3829], [3850, 3850, 3867, 3867, 4515], [4517, 4517, 4542, 4542, 4761], [4763, 4763, 4785, 4785, 5078], [5080, 5080, 5116, 5116, 5152], [5154, 5154, 5174, 5174, 5219], [5221, 5221, 5266, 5266, 6955], [6957, 6957, 6986, 6986, 7587], [7658, 7658, 7718, 7718, 7805], [7807, 7807, 7852, 7852, 8154]], "test": "untested"}
{"id": "slKXWR", "name": "2d landscape variation", "author": "jorge2017a2", "description": "2d landscape variation", "tags": ["2dlandscapevariation"], "likes": 9, "viewed": 281, "published": 3, "date": "1640530644", "time_retrieved": "2024-07-30T18:40:06.762616", "image_code": "//por jorge2017a2\n\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 DrawFigBordeR(vec3 pColObj, vec3 colOut, float distObj, float r )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-r,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0)); return colOut;}\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\nvec3 DrawFigRB(vec3 pColObj, vec3 colOut, float distObj, float r )\n{  colOut = mix(colOut,pColObj ,S2( distObj-r,0.0)); return colOut; }\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{\n    vec2 e = vec2(sk,he);\n    p = (p.y<0.0)?-p:p;\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p;\n    p = vec2((p.y>0.0 || p.x>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nvec3 nubes(vec2 p, vec3 colOut)\n{    \n    vec2 centro=vec2(0.0,0.0);\n    float c1= sdCircle(p-vec2(0.01,0.05), 0.105);\n    float c2= sdCircle(p-vec2(0.15,0.02), 0.065);\n    float c3= sdCircle(p-vec2(-0.12,0.02), 0.065);\n    float b1=sdBox(p-vec2(0.0,-0.04), vec2(0.3,0.05 ) );\n    \n    float res=unionSDF(c1, c2);\n    res=unionSDF(res, c3);\n    res=differenceSDF(res,b1 );\n    colOut=DrawFigBordeR(vec3(1.0), colOut, res,0.001 );    \n\treturn colOut;\n    \n}\n\nvec3 HacerCasa(vec2 p, vec3 col)\n{\n ///casa 1\n    float d3a=sdBox(p-vec2(-1.25,-0.33), vec2(0.15,0.27) );\n    float wip,hep,skp;\n    wip=0.26;hep=0.22;skp=0.38;\n    float d3b= sdParallelogram(p.yx-vec2(0.05,-0.88), wip,hep,skp );\n    wip=0.14;hep=0.2;skp=0.13;\n    float d3c= sdParallelogram(p-vec2(-1.125,0.15), wip,hep,skp );\n    float d3d= sdParallelogram(p-vec2(-0.91,0.49), wip,hep,skp );\n    d3c= unionSDF(d3c, d3d);\n    \n    wip=0.15;hep=0.07;skp=0.1;\n    float d3e= sdParallelogram(p.yx-vec2(-0.05,-0.88), wip,hep,skp ); //puerta\n    col= DrawFigBorde(vec3(0.92),col,d3a);\n    col= DrawFigBorde(vec3(0.72),col,d3b);\n    col= DrawFigBorde(vec3(0.62),col,d3c);\n    col= DrawFigBorde(vec3(0.22),col,d3e);\n    return col;\n}\n\nvec3 HacerCactus(vec2 p, vec3 col)\n{\n    float d1= sdBox(p-vec2(-0.5,1.1),vec2(0.025,0.1) );\n    // animation\n    float tt=4.7;\n    float t =            3.14* (0.5+0.5*cos(tt));\n    vec2  w = vec2(0.20,0.15)*(0.5+0.5*cos(11.7*vec2(0.37,0.7)+vec2(0.0,2.0)));\n    float d2 = sdHorseshoe(p-vec2(-0.5,1.15),vec2(cos(t),sin(t)), 0.065, w);\n    d1= unionSDF(d1, d2);\n    col= DrawFigBorde(vec3(1.0,0.8,0.8), col, d1 );\n    return col;\n}\n\n\nvec3 casa3(vec2 p, vec3 col)\n{  \n    float d1= sdBox(p, vec2(3.5,2.5) );\n    float d2=sdTriangleIsosceles(vec2(p.x,-p.y)-vec2(4.5,-5.3), vec2(1.2,3.2) );\n    float d3=sdBox(p-vec2(-1.5,-0.4), vec2(0.8,0.8) ); //ventana\n    float d4=sdBox(p-vec2(1.5,-1.0), vec2(0.8,1.5) ); //puerta\n    float d5= sdParallelogram(p-vec2(0.0,3.6), 4.0, 1.9, 0.5 ); //techo\n    float d6= sdParallelogram(p.yx-vec2(0.6,4.3), 2.5, 0.75, 0.5 ); //lateral\n    \n    float d7=sdBox(p-vec2(1.7,3.5), vec2(0.8,0.8));\n    float d8=sdBox(p-vec2(-1.7,3.5), vec2(0.8,0.8));\n    float d7a=sdTriangleIsosceles(vec2(p.x,p.y)-vec2(-0.8,2.8), vec2(1.0,1.5) );\n    float d8a=sdTriangleIsosceles(vec2(p.x,p.y)-vec2( 2.5,2.8), vec2(1.0,1.5) );\n    \n    col= DrawFigBorde(vec3(1.0,0.8,0.1),col, d1 );// frente\n    col= DrawFigBorde(vec3(0.1),col, d6 );\n    col= DrawFigBorde(vec3(0.0),col, d2 );\n    col= DrawFigBorde(vec3(0.0,0.5,0.5),col, d3 );\n    col= DrawFigBorde(vec3(0.2,0.2,1.0),col, d4 ); //puerta\n    col= DrawFigBorde(vec3(1.0,0.0,0.0),col, d5 );\n    col= DrawFigBorde(vec3(0.0),col, d7a );\n    col= DrawFigBorde(vec3(0.0),col, d8a );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d7 );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d8 );\n    return col;\n}\n\nvec3 HacerCalle(vec2 p, vec3 col)\n{   vec2 p0=p;\n    ///hacer pasto\n    float d0= sdBox(p-vec2(0.0,-0.5),vec2(4.0,1.5) );\n    col= DrawFigBorde(vec3(0.25,0.7,0.3),col,d0);\n    \n    col= casa3(p*8.0-vec2(-14.0,6.0), col);\n    \n    float r1,r2,he;\n    r2=0.1; r1=1.0; he=1.0;\n    \n    float d1a= sdTrapezoid(p,r1,r2,he); //calle a\n    r2=0.15; r1=1.3; he=1.0;\n    float d1b= sdTrapezoid(p,r1,r2,he); //calle b\n    \n    p.y=opRep1D(p.y, 0.2 );\n    float d2=sdSegment(p,vec2(0.0),vec2(0.0,0.1) ); //linea\n    d2=intersectSDF(d2, d1a);\n    \n    p=p0;\n    \n    col= HacerCasa(p-vec2(0.0,0.0), col);\n    col= HacerCasa(vec2(-p.x, p.y)-vec2(0.0,0.0), col);\n    col= DrawFigBorde(vec3(0.85),col,d1b);\n    col= DrawFigBorde(vec3(0.75),col,d1a);\n    col= DrawFigBorde(vec3(0.0),col,d2);\n    col= HacerCactus(p,col);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=1.3;\n    uv*=esc;\n\n    vec3  col=vec3(0.45,0.7,1.0)-uv.y*0.125;\n    col=HacerCalle(uv-vec2(0.0,0.1), col);\n    \n    vec2 uv2=uv*0.5;\n        uv2.x+= opRep1D(iTime*0.5, 4.0 );\n        col= nubes(uv2*1.5-vec2(0.0,0.4), col);\n        col= nubes(uv2*1.5-vec2(0.5,0.6), col);\n        col= nubes(uv2*2.5-vec2(-1.5,0.7), col);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///fork sound\n//referencia\n//https://www.shadertoy.com/view/NljXWW\n///olvide la otra referencia :(\n\n\n// common constants, functions, etc...\n\n// keyboard code. (sharp key is fractional.)\nconst float _RA = 2.0;\nconst float _RASP = 2.5;\nconst float _SI = 3.0;\nconst float DO = 4.0;\nconst float DOSP = 4.5;\nconst float RE = 5.0;\nconst float RESP = 5.5;\nconst float MI = 6.0;\nconst float FA = 7.0;\nconst float FASP = 7.5;\nconst float SO = 8.0;\nconst float SOSP = 8.5;\nconst float RA = 9.0;\nconst float RASP = 9.5;\nconst float SI = 10.0;\nconst float DO_ = 11.0;\nconst float DOSP_ = 11.5;\nconst float RE_ = 12.0;\nconst float RESP_ = 12.5;\nconst float MI_ = 13.0;\n\n// song data\n\nconst int note_count = 145;\nconst float BPM = 240.0;\nconst float unit = 60.0 / BPM;\n\n// terminal time of each segment.\nconst float term[note_count] =\n        float[note_count](2.5, 3.0, 4.0, 4.5, 5.5, 6.0, 9.0, 12.0,\n                          14.5, 15.0, 16.5, 18.0, 24.0,\n                          26.5, 27.0, 28.0, 28.5, 29.5, 30.0, 33.0, 36.0,\n                          38.5, 39.0, 40.5, 42.0, 48.0,\n                          50.5, 51.0, 52.0, 52.5, 53.5, 54.0, 57.0, 60.0,\n                          62.5, 63.0, 64.5, 66.0, 72.0,\n                          74.5, 75.0, 76.0, 76.5, 77.5, 78.0, 81.0, 84.0,\n                          86.5, 87.0, 88.5, 90.0, 96.0,\n                          97.0, 97.5, 98.5, 99.0, 101.5, 102.0,\n                          103.0, 103.5, 104.5, 105.0, 107.5, 108.0,\n                          109.0, 109.5, 110.5, 111.0,\n                          112.5, 114.0, 115.5, 117.0, 120.0,\n                          121.0, 121.5, 122.5, 123.0, 125.5, 126.0,\n                          127.0, 127.5, 128.5, 129.0, 131.5, 132.0,\n                          133.0, 133.5, 134.5, 135.0,\n                          136.5, 138.0, 139.5, 141.0, 144.0,\n                          145.0, 145.5, 146.5, 147.0, 148.0, 148.5, 149.5, 150.0,\n                          151.0, 151.5, 152.5, 153.0, 156.0,\n                          157.0, 157.5, 158.5, 159.0, 160.0, 160.5, 162.0,\n                          163.0, 163.5, 164.5, 165.0, 168.0,\n                          169.0, 169.5, 170.5, 171.0, 172.0, 172.5, 173.5, 174.0,\n                          175.0, 175.5, 176.5, 177.0, 180.0,\n                          181.0, 181.5, 182.5, 183.0, 184.0, 184.5, 185.5, 186.0,\n                          187.0, 187.5, 188.5, 189.0, 192.0);\n\nconst float sus[note_count] =\n        float[note_count](2.5, 0.5, 1.0, 0.5, 1.0, 0.5, 2.5, 2.5,\n                          2.5, 0.5, 1.5, 1.5, 3.0,\n                          2.5, 0.5, 1.0, 0.5, 1.0, 0.5, 2.5, 2.5,\n                          2.5, 0.5, 1.5, 1.5, 3.0,\n                          2.5, 0.5, 1.0, 0.5, 1.0, 0.5, 2.5, 2.5,\n                          2.5, 0.5, 1.5, 1.5, 3.0,\n                          2.5, 0.5, 1.0, 0.5, 1.0, 0.5, 2.5, 2.5,\n                          2.5, 0.5, 1.5, 1.5, 3.0,\n                          1.0, 0.5, 1.0, 0.5, 2.5, 0.5,\n                          1.0, 0.5, 1.0, 0.5, 2.5, 0.5,\n                          1.0, 0.5, 1.0, 0.5, 1.5, 1.5, 1.5, 1.5, 2.5,\n                          1.0, 0.5, 1.0, 0.5, 2.5, 0.5,\n                          1.0, 0.5, 1.0, 0.5, 2.5, 0.5,\n                          1.0, 0.5, 1.0, 0.5, 1.5, 1.5, 1.5, 1.5, 2.5,\n                          1.0, 0.5, 1.0, 0.5, 1.0, 0.5, 1.0, 0.5,\n                          1.0, 0.5, 1.0, 0.5, 2.5,\n                          1.0, 0.5, 1.0, 0.5, 1.0, 0.5, 1.5,\n                          1.0, 0.5, 1.0, 0.5, 2.5,\n                          1.0, 0.5, 1.0, 0.5, 1.0, 0.5, 1.0, 0.5,\n                          1.0, 0.5, 1.0, 0.5, 2.5,\n                          1.0, 0.5, 1.0, 0.5, 1.0, 0.5, 1.0, 0.5,\n                          1.0, 0.5, 1.0, 0.5, 2.5);\n\n\nconst float notes[note_count] =\n        float[note_count](FA, DO, FA, DO, FA, SO, RA, FA,\n                          RASP, RASP, FA, SO, RA,\n                          FA, DO, FA, DO, FA, SO, RA, FA,\n                          SO, SO, SO, RA, SO,\n                          SO, SO, FASP, SO, RA, SO, FA, DO,\n                          RASP, RASP, FA, SO, RA,\n                          RE, MI, FA, MI, FA, RE, DO, FA,\n                          RA, RASP, RA, SO, FA,\n                          DO, DO, DO, DO, FA, MI,\n                          RE, RE, RE, RE, SO, FA,\n                          MI, MI, MI, MI, RE, MI, FA, SO, RA,\n                          DO, DO, DO, DO, FA, MI,\n                          RE, RE, RE, RE, SO, FA,\n                          MI, MI, MI, MI, RE, MI, FA, RA, FA,\n                          SO, SO, SO, RA, SI, SI, SI, RA,\n                          SO, SO, SO, MI, RE,\n                          MI, MI, RE, RE, SO, SO, SI,\n                          RA, RA, SO, RA, SI,\n                          RE_, RE_, RE_, RE_, RE_, RE_, MI_, RE_,\n                          SI, SO, RA, SI, RA,\n                          SO, RA, SI, SI, RA, RA, RE_, RE_,\n                          SI, SI, RA, RA, SO);\n\n// \nconst float array_w[7] = float[7](-4.0, -2.0, 0.0, 2.0, 3.0, 5.0, 7.0);\nconst float array_b[7] = float[7](0.0, -3.0, -1.0, 1.0, 0.0, 4.0, 6.0); //0:dummy.\n\n// get exponent. 0:white key, 1:black key.\n// 440.0\nfloat getExponent(float index){\n    float r, q;\n    int diffType = 0;\n    if(fract(index) > 0.25){ index += 0.5; diffType = 1; }\n    for(int i = 0; i < 7; i++){\n        r = mod(index, 7.0);\n        q = floor(index / 7.0);\n        if(float(i) == r){\n            return 12.0 * q - 12.0 + (diffType == 0 ? array_w[i] : array_b[i]);\n        }\n    }\n    return 0.0;\n}\n\n\n/////------------------------------------\nfloat PI = 3.14159265358979323846;\n\nfloat saw(float x) {\n    return asin(sin(x)) * sign(cos(x));\n}\n\n\nvec2 synthSaw(float time, float amp, float freq, float timeOffset, float decay, float timeLimit) {\n    \n    time = time - timeOffset;\n    if (time < 0. || time > timeLimit) return vec2(0.0);\n    \n    return amp * vec2( saw(2.0 * PI * freq * time)*exp(-decay * time) );\n}\n\nfloat impostorSaw(float time, float amp, float freq, float timeOffset, float decay, float timeLimit, float dummy) {\n\n    time = time - timeOffset;\n    if (time < 0. || time > timeLimit) return 0.0;\n\n    return amp * exp(-decay * time);\n\n}\n\nvec2 synthSuSaw(float time, float amp, float freq, float timeOffset, float decay, float timeLimit, float distr) {\n    \n    distr = 1.0 + distr;\n    \n    float d = distr;\n    float d2 = d * d;\n    float d3 = d2 * d;\n    \n    float a1, a2, a3, a4, a5, a6, a7;\n    \n    a1 = 0.1;\n    a2 = 0.2;\n    a3 = 0.3;\n    a4 = 1.0;\n    a5 = 0.3;\n    a6 = 0.2;\n    a7 = 0.1;\n    \n    vec2 sum = a1 * synthSaw(time, amp, freq / d3, timeOffset, decay, timeLimit) +\n        a2 * synthSaw(time, amp, freq / d2, timeOffset, decay, timeLimit) +\n        a3 * synthSaw(time, amp, freq / d, timeOffset, decay, timeLimit) +\n        a4 * synthSaw(time, amp, freq, timeOffset, decay, timeLimit) +\n        a3 * synthSaw(time, amp, freq * d, timeOffset, decay, timeLimit) +\n        a2 * synthSaw(time, amp, freq * d2, timeOffset, decay, timeLimit) +\n        a1 * synthSaw(time, amp, freq * d3, timeOffset, decay, timeLimit);\n        \n    sum = sum / (a1 + a2 + a3 + a4 + a5 + a6 + a7);\n    \n    return sum;\n}\n\nfloat impostorMusic(float time)\n{\n\n    float sixteen = 0.10;\n    \n    float div = sixteen * 64.0;\n    \n    time = time - floor(time / div) * div;\n    float suma ;\n    \n    float prop=1.0/23.0;\n    suma= impostorSaw(time, 0.1, 110.0, 0.0 * sixteen, 3.0, 3.0, 0.01)*prop\n        + impostorSaw(time, 0.1, 130.81, 4.0 * sixteen, 3.0, 3.0, 0.01)*prop\n        + impostorSaw(time, 0.1, 110.0, 7.0 * sixteen, 3.0, 3.0, 0.01)*prop\n        + impostorSaw(time, 0.1, 110.0, 9.0 * sixteen, 3.0, 3.0, 0.01)*prop\n        + impostorSaw(time, 0.1, 146.83, 10.0 * sixteen, 3.0, 3.0, 0.01)*prop\n        + impostorSaw(time, 0.1, 110.0, 12.0 * sixteen, 3.0, 3.0, 0.01)*prop\n        + impostorSaw(time, 0.1, 98.0, 14.0 * sixteen, 3.0, 3.0, 0.01)*prop\n        \n        + impostorSaw(time, 0.1, 110.0, 16.0 * sixteen, 3.0, 3.0, 0.01)*prop\n        + impostorSaw(time, 0.1, 164.81, 20.0 * sixteen, 3.0, 3.0, 0.01)*prop\n        + impostorSaw(time, 0.1, 110.0, 23.0 * sixteen, 3.0, 3.0, 0.01)*prop\n        + impostorSaw(time, 0.1, 110.0, 25.0 * sixteen, 3.0, 3.0, 0.01)*prop\n        + impostorSaw(time, 0.1, 174.61, 26.0 * sixteen, 3.0, 3.0, 0.01)*prop\n        + impostorSaw(time, 0.1, 164.810, 28.0 * sixteen, 3.0, 3.0, 0.01)*prop\n        + impostorSaw(time, 0.1, 130.81, 30.0 * sixteen, 3.0, 3.0, 0.01)*prop\n        \n        + impostorSaw(time, 0.1, 110.0, 32.0 * sixteen, 3.0, 3.0, 0.01)*prop\n        + impostorSaw(time, 0.1, 164.810, 34.0 * sixteen, 3.0, 3.0, 0.01)*prop\n        + impostorSaw(time, 0.1, 220.0, 36.0 * sixteen, 3.0, 3.0, 0.01)*prop\n        + impostorSaw(time, 0.1, 110.0, 38.0 * sixteen, 3.0, 3.0, 0.01)*prop\n        + impostorSaw(time, 0.1, 98.00, 39.0 * sixteen, 3.0, 3.0, 0.01)*prop\n        + impostorSaw(time, 0.1, 98.00, 41.0 * sixteen, 3.0, 3.0, 0.01)*prop\n        + impostorSaw(time, 0.1, 82.41, 42.0 * sixteen, 3.0, 3.0, 0.01)*prop\n        \n        + impostorSaw(time, 0.1, 130.81, 44.0 * sixteen, 2.5, 3.0, 0.01)*prop\n        + impostorSaw(time, 0.1, 110.0, 46.0 * sixteen, 2.5, 5.0, 0.01)*prop;\n        return sin(suma*20.0);\n}\n\n\n//float t, float freq, float span\nvec2 music(float time , float freq, float span)\n{\n\n    float sixteen = 0.10;\n    \n    float div = sixteen * 64.0;\n    \n    time = time - floor(time / div) * div;\n    float prop=1.0/23.0;\n    \n    vec2 suma= synthSuSaw(time, 0.1, freq, 0.0 * sixteen, 3.0, 3.0, 0.01);\n\n    return suma*20.0;\n}", "sound_code": "///fork sound\n//https://www.shadertoy.com/view/NljXWW\n///olvide la otra referencia :(\n\n#define TAU 6.2831\n\nfloat squ(float x){\n    x = fract(x);\n    return smoothstep(0.48, 0.52, x) * 2.0 - 1.0;\n}\n\nvec2 squWave(float time, float freq, float m){\n  return vec2(squ(freq * time)) * exp(-m * time);\n}\n\nvec2 sound(float t, float freq, float span){\n    vec2 v1= squWave(t, freq, 1.6 / span);\n    vec2 v2= music(t , freq, 1.6/ span);\n    return v1+v2;\n}\n\nvec2 mainSound( in int samp,float time){\n    vec2 wv = vec2(0.0);\n    float prevTerm = 0.0;\n    float frequency;\n    \n    for(int i = 0; i < note_count; i++){\n        if(time < term[i] * unit){\n            frequency = 440.0 * pow(2.0, getExponent(notes[i]) / 12.0);\n            wv += sound(time - prevTerm, frequency, sus[i] * unit);\n            break;\n        }\n        prevTerm = term[i] * unit;\n    }\n    return wv*0.35;\n}\n", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKXWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[301, 301, 337, 337, 382], [387, 387, 434, 434, 461], [462, 462, 505, 505, 532], [533, 533, 581, 581, 609], [612, 612, 684, 684, 810], [812, 812, 874, 874, 1004], [1006, 1006, 1087, 1087, 1215], [1217, 1217, 1274, 1274, 1344], [1346, 1346, 1408, 1408, 1473], [1475, 1475, 1543, 1543, 1611], [1613, 1613, 1677, 1677, 1748], [1751, 1751, 1785, 1785, 1880], [1882, 1882, 1919, 1919, 1993], [1995, 1995, 2030, 2030, 2053], [2055, 2055, 2107, 2107, 2223], [2225, 2225, 2250, 2250, 2269], [2270, 2270, 2295, 2295, 2314], [2315, 2315, 2351, 2351, 2379], [2382, 2382, 2448, 2448, 2665], [2668, 2668, 2733, 2733, 3043], [3046, 3046, 3112, 3112, 3454], [3456, 3456, 3522, 3522, 3792], [3795, 3795, 3846, 3846, 4154], [4157, 4157, 4190, 4190, 4613], [4615, 4615, 4649, 4660, 5342], [5344, 5344, 5380, 5380, 5774], [5777, 5777, 5807, 5807, 7001], [7003, 7003, 7038, 7038, 7825], [7827, 7827, 7884, 7884, 8369]], "test": "untested"}
{"id": "slGXDz", "name": "eindacor_fibonado", "author": "Eindacor_DS", "description": "Look, it's a thing!", "tags": ["spiral"], "likes": 0, "viewed": 15, "published": 3, "date": "1640528614", "time_retrieved": "2024-07-30T18:40:07.526573", "image_code": "\n#define TWOPI 6.28318530718f\n#define THETA 1.618033988749894848\n#define AA 0.001f\n\n#define CYAN vec3(0., 1., 1.)\n#define MAGENTA vec3(1., 0., 1.)\n#define YELLOW vec3(1., 1., 0.)\n#define RED vec3(1., 0., 0.)\n#define GREEN vec3(0., 1., 0.)\n#define BLUE vec3(0., 0., 1.)\n#define ORANGE vec3(1., .75, .25)\n#define PINK vec3(1., .25, .75)\n#define WHITE vec3(1.)\n#define BLACK vec3(0.)\n\nfloat getOffsetAngle(vec2 first, vec2 second) {\n    vec2 offsetVec = second - first;\n    float angle = atan(offsetVec.y / offsetVec.x);\n    \n    \n    if (first.x < second.x) {\n        angle = TWOPI / 2.f + angle;\n    } else if (first.y > second.y) {\n        angle = TWOPI + angle;\n    }\n    \n    return angle;\n}\n\nfloat circleSmoothStepFill(vec2 center, float radius, vec2 p, float antiAlias) {\n\treturn 1.f - smoothstep(radius - antiAlias, radius + antiAlias, distance(center, p));\n}\n\nfloat circleSmoothStep(vec2 center, float radius, float thickness, vec2 p, float antiAlias) {\n    float distFromCenter = distance(center, p);\n    float halfThickness = thickness / 2.f;\n    if (distFromCenter < radius) {\n        return smoothstep(radius - halfThickness - antiAlias, radius - halfThickness + antiAlias, distFromCenter);\n    } else {\n        return 1.f - smoothstep(radius + halfThickness - antiAlias, radius + halfThickness + antiAlias, distFromCenter);\n    }\n}\n\n/*\n\treturns smoothstep value for line segment\n\texample usage:\n\t\toutColor = mix(outColor, lineColor, lineSegmentSmoothStep(start, end, uv, thickness, AA, true));\n*/\nfloat lineSegmentSmoothStep(vec2 start, vec2 end, vec2 p, float lineThickness, float antiAlias, bool roundEnds) {\n    float halfThickness = lineThickness / 2.f;\n    if (dot(p-end, start - end) < 0.f || dot(p - start, end - start) < 0.f) {\n        return !roundEnds ? 0.f : max(\n\t\t\tcircleSmoothStepFill(start, halfThickness, p, antiAlias),\n\t\t\tcircleSmoothStepFill(end, halfThickness, p, antiAlias)\n        );  \n    }\n    \n    vec2 lineVec = normalize(end - start);\n    vec2 pVec = normalize(p - start);\n\n    float angle = acos(dot(lineVec, pVec) / length(lineVec) * length(pVec));\n    float distFromLine = sin(angle) * distance(start, p);\n    \n    return 1.f - smoothstep(lineThickness / 2.f - antiAlias, halfThickness + antiAlias, distFromLine);\n}\n\nfloat getRadialVal(vec2 p1, vec2 p2) {\n    float offsetAngle = getOffsetAngle(p1, p2);\n    offsetAngle = mod(TWOPI - offsetAngle + 3.f * TWOPI / 6.f, TWOPI);\n    return offsetAngle / TWOPI;\n}\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nfloat getHoldTransitionValue(float lower, float upper, float holdTime, float transitionTime, float time) {\n    float period = 2. * holdTime + 2. * transitionTime;\n    float halfPeriod = period / 2.;\n    float relativeTime = fract(time / halfPeriod);\n    float halfHoldTime = holdTime / 2.;\n    \n    float val = smoothstep(halfHoldTime, halfHoldTime + transitionTime, relativeTime * halfPeriod);\n    \n    if (int(time / halfPeriod) % 2 == 0) {\n        val = 1. - val;\n    }\n\n    return mix(lower, upper, val);\n}\n\nvec3 getRandomColor(float seed) {\n    seed = clamp(seed, 0., 1.);\n    float colorCount = 6.;\n    float colorIncrement = 1.f / colorCount;\n    float seedFloor = floor(seed / colorIncrement) * colorIncrement;\n    float lerpVal = smoothstep(seedFloor, seedFloor + colorIncrement, seed);\n\n    if (seed <= colorIncrement * 1.) {\n        return mix(RED, YELLOW, lerpVal);\n    } else if (seed <= colorIncrement * 2.) {\n        return mix(YELLOW, GREEN, lerpVal);\n    } else if (seed <= colorIncrement * 3.) {\n        return mix(GREEN, CYAN, lerpVal);\n    } else if (seed <= colorIncrement * 4.) {\n        return mix(CYAN, BLUE, lerpVal);\n    } else if (seed <= colorIncrement * 5.) {\n        return mix(BLUE, MAGENTA, lerpVal);\n    } else {\n        return mix(MAGENTA, vec3(1.), lerpVal);\n    }\n}\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec4 getCircleTangentPoints(vec2 p, vec2 circleCenter, float circleRadius) {\n    float distFromCircle = distance(p, circleCenter);\n    float angle = asin(circleRadius / distFromCircle);\n    float innerAngle = TWOPI / 4. - angle; // 180 degrees in a circle, one angle is 90, leaves 90 degrees between others\n    \n    vec2 firstPoint = ((p - circleCenter) * (circleRadius / distFromCircle)) * createRotationMatrix(innerAngle) + circleCenter;\n    vec2 secondPoint = ((p - circleCenter) * (circleRadius / distFromCircle)) * createRotationMatrix(-innerAngle) + circleCenter;\n    \n    return vec4(firstPoint.x, firstPoint.y, secondPoint.x, secondPoint.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n    float bandWidth = .03;\n    \n    vec2 center = vec2(.5 * aspectRatio, .5);\n    \n    uv = (uv - center) * createRotationMatrix(iTime * -.2) + center;\n    \n    float angle = asin((uv.y - center.y)/distance(uv, center));\n    \n    float radialVal = getRadialVal(center, uv);\n    float dist = distance(uv, center) + bandWidth * radialVal; \n\n    float val = mod(dist, bandWidth) / bandWidth;\n    val = 1.;\n    \n    vec2 startingPoint = center + vec2(bandWidth, 0.);\n    \n    int numPoints = 40;\n    \n    vec3 outColor = vec3(.1, .05, .3);\n    //outColor = vec3(1.);\n    \n    float transitionTime = 10.;\n    float holdTime = 0.;\n    \n    float radianIncrement = getHoldTransitionValue(THETA + .2, THETA, holdTime, transitionTime, iTime + holdTime * 2. + transitionTime);\n    vec3 fillColor = vec3(1.);\n    vec3 lineColor = vec3(0.);\n    \n    for (int i=0; i<numPoints; ++i) {\n        int pointIndex = numPoints - 1 - i;\n        \n        float radianOffset = float(pointIndex) * radianIncrement;\n        float fullRevolutions = radianOffset / TWOPI;\n        vec2 point = vec2(fullRevolutions * bandWidth) * createRotationMatrix(radianOffset) + center;\n        float pointRenderVal = distance(point, center) * 1.5;\n        \n        float pointRadius = mix(.025, .055, pointRenderVal);\n        float dist = distance(uv, point);\n        \n        float colorMod = mix(.2, 1., pointRenderVal);\n        \n        fillColor = getRandomColor(float(i)/float(numPoints));\n        \n        vec4 tangentPoints = getCircleTangentPoints(center, point, pointRadius);\n        \n        float lineWidth = pointRadius * .05;\n    \n        if (dist < pointRadius) {\n            outColor = fillColor * colorMod;\n            float pointVal = smoothstep(pointRadius - AA, pointRadius, dist);\n            outColor = mix(outColor, lineColor * colorMod, pointVal);\n        } else {\n            float pointVal = smoothstep(pointRadius + lineWidth, pointRadius + lineWidth + AA, dist);\n            outColor = mix(lineColor * colorMod, outColor, pointVal);\n        }\n        \n        if (distance(center, point) > pointRadius) {\n            outColor = mix(outColor, lineColor, lineSegmentSmoothStep(center, tangentPoints.xy, uv, lineWidth, AA, true));\n            outColor = mix(outColor, lineColor, lineSegmentSmoothStep(center, tangentPoints.zw, uv, lineWidth, AA, true));\n        }       \n    }\n\n    // Output to screen\n    vec3 washColor = vec3(0.8, .9, 1.);\n    fragColor = vec4(outColor * washColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGXDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[382, 382, 429, 429, 693], [695, 695, 775, 775, 864], [866, 866, 959, 959, 1342], [1344, 1508, 1621, 1621, 2255], [2257, 2257, 2295, 2295, 2448], [2450, 2450, 2495, 2495, 2599], [2601, 2601, 2707, 2707, 3111], [3113, 3113, 3146, 3146, 3902], [3904, 3950, 3970, 3970, 4036], [4038, 4038, 4114, 4114, 4689], [4692, 4692, 4749, 4799, 7402]], "test": "untested"}
{"id": "7lcSW2", "name": "Jump nyancat!", "author": "cyperus", "description": "Jump nyancat!", "tags": ["2d", "spiral", "mobius", "nyancat", "complex"], "likes": 7, "viewed": 477, "published": 3, "date": "1640525025", "time_retrieved": "2024-07-30T18:40:08.296515", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"Jump nyancat!\" Colling Patrik, cyperus, 2021\n//\n// DESCRIPTION:\n// - cyclic nyancat jump & run        \n// - transformations: moebius, riemannsphere, logspiral\n//\n// CONTROLS:\n//   <mouse>: subdivide & twist spiral branch\n//\n// BASED on:\n//   by FabriceNeyret2\n//    - https://www.shadertoy.com/view/fldSWS \"Logarithmic Moebius color arrows\"\n//   by mla \n//    - https://www.shadertoy.com/view/7t3SDB \"Spiral Weave\" \n//   by mrharicot\n//    - https://www.shadertoy.com/view/XdfGDH \"Gaussian Blur\"\n//       \n////////////////////////////////////////////////////////////////////////////////\n\n// transformation stack (comment in out)\n#define SSS          // SelfSimilarStructure\n#define MOEBIUS\n#define MOEBIUS_RS   // RiemannSphere\n#define LOGSPIRAL\n\n// texture stack (comment in out)\n#define TEX_NYANCAT\n#define TEX_STRIPS\n#define TEX_BACKGROUND\n\n// gizmo\nconst float gizmo_subdiv = 10.;\nvec2 gizmo_polar_tile_id(in vec2 p) {\n        p = (p.xy-.5*iResolution.xy)/iResolution.x;\n        p = vec2(length(p),atan(p.y,p.x));\n        p *= 2. * gizmo_subdiv * vec2(1.,1./PI2); // subdiv scale\n        p = floor(p);                             // subdiv\n        p.x += p.x >= 0.?1.:0.;                   // radius avoid zero.\n        return p;\n}\n\n// texture\nfloat normpdf(in float x, in float sigma) {\n    // https://www.shadertoy.com/view/XdfGDH by mrharicot\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvec3 gaussianblur(sampler2D iChannel, vec2 fragCoord, float R) {\n    // https://www.shadertoy.com/view/XdfGDH by mrharicot\n    //declare stuff\n    const int mSize = 6;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = 7.0;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j) {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i) {\n        for (int j=-kSize; j <= kSize; ++j) {\n            final_colour += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel, (fragCoord.xy+vec2(float(i),float(j))) / R).rgb;\n\n        }\n    }\t\t\n    return final_colour /= Z*Z;\n}\n\nvec4 nyancat(vec2 z, float scale, vec2 ju, float time) {   \n    z.x = fract(z.x-time/scale); // run, input z.x in [0., 1.], periodic & cyclic in x-direction (0)\n    z.y = fract(z.y);            // periodic in y-direction (comment in out)\n    z *= scale;\n    z.y -= ju.x*abs(cos(PI*ju.y*time));           // jump, amplitude, frequency\n    return ((.05<z.x&&z.x<.9)&&(0.<z.y&&z.y<.65)) // BB rectangle\n    ? texture(iChannel0,\n        vec2(40./256.*(z.x+floor(6.*fract(ju.y*time))),z.y+.2)) // sprite animation loop\n    : vec4(0.);   \n} \n \nvoid mainImage( out vec4 O, in vec2 uv )\n{\n    vec2  sp_k_M0 = vec2(4,2);  // subdivide & twist spiral branch\n    vec2  sp_k_U0;\n    float uc_k = float(4);      // unit-cells periodic in x-direction\n\n    vec2 R = iResolution.xy,\n         M = iMouse.xy,\n         U;\n    vec3 P, C;               // point, color\n    vec4 T;\n    bool M_init = iMouse == vec4(0.);           // mouse init\n    bool M_bd = iMouse.z > 0. && iMouse.w < 0.; // mouse button down\n    \n    float time = 0.5*iTime;  // animation velocity\n    vec2 U0 = 1.6*(uv.xy-.5*R.xy)/R.x; // U normalized in x-direction (0)\n    U = U0;    \n\n    // controls gismo\n    if(!M_init) sp_k_M0 = gizmo_polar_tile_id(M); // mouse coords\n    sp_k_U0 = gizmo_polar_tile_id(uv); // pixel coords\n    \n    // transform complex plain\n    #ifdef SSS\n    U = crpt(2.*U,  PI*0., 2, 0.1); // scale, rotate, power, translate\n    U = crpt(4.*U, -PI*0.02*time, 3, -0.7*cos(0.03*time));\n    # endif\n    \n    #ifdef MOEBIUS\n    U.x += 0.5; U /= dot(U,U); U.x -= 0.5; // inversion\n    U.x -= 0.5;\n    #endif\n    \n    #ifdef MOEBIUS_RS\n    float UU = dot(U,U); P = vec3(2.*U.x,+2.*U.y, -1.+UU)/(1.+UU); // 2D --> 3D stereographic projection   \n    P = rot3(P, normalize(vec3(0.1,1.,0.)), PI*0.05*time);         // rotation of the riemannsphere\n    U = vec2(P.x,P.y)/(1.-P.z);                                    // 3D --> 2D stereographic projection\n    #endif\n    \n    #ifdef LOGSPIRAL\n    U = clog(U)/PI2;               // complex log normalized\n    U = cmul(U,sp_k_M0);           // subdiv spiral branches, twist        \n    U += vec2(0.02, 0.03 )* time;  // move to and rotate around spiralcenter\n    //vec2 sp_id = floor(U);       // index at the branch cut (0,-+PI) not the same!   \n    vec2 sp_id = floor( vec2(-U.y,U.x) - floor(-U.y/sp_k_M0.x) * sp_k_M0 ); \n    # endif\n \n    // paint unitcellgrid\n    O = vec4(0); \n    \n    if (O.a < 1.) {\n        T = (sp_k_M0 == sp_k_U0 && M_bd) ? vec4(vec3(1.), 0.3) : O;\n        T *= T.a; O += (1.-O.a) * T; // alpha pre multiplied ,alpha under        \n    }\n    \n    #ifdef TEX_NYANCAT\n    if (O.a < 1.) {\n        T = nyancat(U, uc_k, vec2(0.1,1.), time);  T.xyz *= T.xyz; // gamma\n        T *= T.a; O += (1.-O.a) * T; // alpha pre multiplied ,alpha under\n    }\n    #endif\n    \n    #ifdef TEX_STRIPS\n    if (O.a < 1.) {\n        // show domains\n        if(M_bd) {\n            T.rgb = h2rgb((sp_id.x + sp_id.y)/4.); T.a = 1.;\n        }\n        // show stripes\n        else {\n            C.x = U.x + cosrec(0.2);                               // hue\n            C.y = 1.-(smoothpulsrec( U.y+0.5, 0.1) * cosrec(U.y)); // saturation\n            C.z = cosrec(uc_k*U.x);                                // value\n            T.rgb = hsv2rgb(C); T.a = C.z;\n        }\n        T.a *= 0.5 ;\n        T *= T.a; O += (1.-O.a) * T; // alpha pre multiplied, alpha under   \n    }\n    #endif\n    \n    // ellipse mask\n    O *= smoothstep(0.6,0., sqrt( dot( vec2(0.5,1.)*U0,U0)));\n\n    #ifdef TEX_BACKGROUND\n    if (O.a < 1.) {\n        T = vec4(gaussianblur(iChannel1, uv, R.x), 0.9);\n        T.xyz = pow(T.xyz,vec3(2.2));// gamma\n        T.xyz = pow(T.xyz,vec3(1.5));\n        T *= T.a; O += (1.-O.a) * T; // alpha pre multiplied, alpha under        \n    }\n    #endif\n    \n    O = vec4(pow(O.rgb, vec3(1./2.2)),1.); // gamma   \n}\n\n", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// constants\nconst float\n    PI = abs(atan(0.,-1.)),\n    PI2 = 2.*PI;\n\n// 1D\nfloat cosrec(float x) {\n    return 0.5*(1.+cos(PI2*x));\n}\n\nfloat smoothpulsrec(float x, float b) {\n    // b : pulswidth\n    x = abs( fract(x )-0.5);  \n    return 1.-smoothstep( 0., 0.5*b ,x ); \n}\n\n// 2D complex functions\nvec2 cmul(vec2 za,vec2 zb) {\n    return za*mat2(zb.x,-zb.y,zb.yx);\n}\n\nvec2 cinv(vec2 z) {\n    return vec2(z.x,-z.y)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return cmul(z,cinv(w));\n}\n\nvec2 cpow(vec2 z, int n) {\n    vec2 w = z;\n    for (int i = 1; i < n; i++)\n        w = cmul(w,z);\n    return w;\n}\n\nvec2 crot(vec2 z,float a) {\n    return cmul(z, vec2(cos(-a),sin(-a)));\n}\n\nvec2 clog(vec2 z) // : 1 --> 1 (we use only the visible main branch)\n{\n    return vec2(0.5*log(z.x*z.x+z.y*z.y),atan(z.y,z.x));\n}\n\nvec2 crpt(vec2 z,float a, int n, float x0) {\n\treturn cpow(crot(z, a), n) - vec2(x0, 0.);\n}\n\n// 3D\nvec3 rot3(vec3 P, vec3 A, float a) {\n    return mix( A*dot(P,A), P, cos(a) ) + sin(a)*cross(P,A);\n}\n\n// color\nvec3 h2rgb(float h) {\n    return vec3(.6*(1.+cos(PI2*(h+vec3(0,1,2)/3.))));\n}\n\nvec3 hsv2rgb(vec3 C ) {\n    // C.x in [0.+k, 1.+k] : hue\n    // C.y in [0.,1.]      : saturation\n    // C.z in [0.,1.]      : value\n    return mix(vec3(1.), h2rgb(C.x), C.y) * C.z;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcSW2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1066, 1066, 1103, 1103, 1416], [1418, 1429, 1472, 1530, 1583], [1585, 1585, 1649, 1727, 2467], [2469, 2469, 2525, 2525, 3003], [3007, 3007, 3049, 3049, 6294]], "test": "untested"}
{"id": "7tG3zW", "name": "Stochastic Gaussian Blur", "author": "zznewclear13", "description": "A stochastic gaussian blur effect.\nClick and drag to use different radius.", "tags": ["gaussianblur", "stochastic"], "likes": 6, "viewed": 617, "published": 3, "date": "1640519549", "time_retrieved": "2024-07-30T18:40:09.062467", "image_code": "//Gamma correction\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    color = pow(color, vec3(0.4545));\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//We use a 2D standard normal distribution for gaussian blur, clamp its range to [-2, 2] for image sampling.\n//The MAGIC_NUMBER means its volume in range [-2, 2].\n//We can approximate that offline by random sampling 2D standard normal distribution function million times (or even more).\n\n/////////////////////////////////////////\n//          Gaussian Function          //\n/////////////////////////////////////////\n#define INV_SQRT_2PI 0.3989422804\n#define INV_2PI 0.15915494309\n//Biased, but good enough to create a beautiful gaussian blur.\n#define MAGIC_NUMBER 0.9109782835241816\n\nfloat GaussianFunction(float x, float sigma)\n{\n    float invSigma = 1.0 / sigma;\n    float gaussian = INV_SQRT_2PI * invSigma * exp(-0.5 * x * x * invSigma * invSigma);\n    return gaussian;\n}\n\nfloat Gaussian2DFunction(float x, float sigma)\n{\n    float invSigma = 1.0 / sigma;\n    float invSigmaSqr = invSigma * invSigma;\n    float gaussian = INV_2PI * invSigmaSqr * exp(-0.5 * x * x * invSigmaSqr);\n    return gaussian;\n}\n\nfloat EvaluateWeight(vec2 offset, float sampleRadius)\n{\n    float sigmaLength = sampleRadius * 0.5;\n    float dist = length(offset);\n    float gaussian = Gaussian2DFunction(dist, sigmaLength) * 16.0 * sigmaLength * sigmaLength;\n    return gaussian;\n}\n\n/////////////////////////////////////////\n//           Random Function           //\n/////////////////////////////////////////\n\nfloat seed;\nfloat GetRandom(){return fract(sin(seed++)*43758.5453123);}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n/////////////////////////////////////////\n//           Sample Function           //\n/////////////////////////////////////////\n\n//Random sample in a (2 * sampleRadius) * (2 * sampleRadius) square.\nvec2 GetOffset(float sampleRadius)\n{\n    float randomA = GetRandom();\n    float randomB = GetRandom();\n    float offsetX = sampleRadius - randomA * sampleRadius * 2.0;\n    float offsetY = sampleRadius - randomB * sampleRadius * 2.0;\n    return vec2(offsetX, offsetY);\n}\n\nvec3 SampleImage(vec2 coord, float sampleRadius)\n{\n    vec2 offset = GetOffset(sampleRadius);\n    //Bilinear sampling, not perfect, but still good enough.\n    vec3 color = texture(iChannel0, coord + offset / iResolution.xy).rgb;\n    //It's important to linearlize color first.\n    color = pow(color, vec3(2.2));\n    float weight = EvaluateWeight(offset, sampleRadius) / MAGIC_NUMBER;   \n    return color * weight;\n}\n\n/////////////////////////////////////////\n//            Store Function           //\n/////////////////////////////////////////\n\nfloat PackIntFloat(float valueA, float valueB)\n{\n    return valueA + valueB / 256.0;\n}\n\nvoid UnpackIntFloat(float value, out float valueA, out float valueB)\n{\n    valueA = floor(value);\n    valueB = (value - valueA) * 256.0;\n}\n\n/////////////////////////////////////////\n//             Main Function           //\n/////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    seed = hash12(fragCoord) + iTime;\n    \n    float sampleRadius = 16.0;\n    float mixValue = 1.0;\n    float packedValue;\n    vec4 bufferA;\n    \n    if(iFrame == 0)\n    {\n        packedValue = PackIntFloat(mixValue, sampleRadius);\n        fragColor = vec4(0.0, 0.0, 0.0, packedValue);\n        return;\n    }\n    else if(iFrame >= 1)\n    {\n        bufferA = texture(iChannel1, uv);\n        UnpackIntFloat(bufferA.a, mixValue, sampleRadius);\n    }\n    \n    if(iMouse.z > 0.0)\n    {\n        sampleRadius = clamp(iMouse.y * 0.25, 1.0, 255.0);\n    }\n    \n    vec3 col = SampleImage(uv, sampleRadius);\n    \n    if(iMouse.z > 0.0)\n    {\n        mixValue = 1.0;\n    }\n    else\n    {\n        mixValue += 1.0;\n        col = mix(bufferA.rgb, col, 1.0 / mixValue);\n    }\n    \n    packedValue = PackIntFloat(mixValue, sampleRadius);  \n    fragColor = vec4(col, packedValue);\n}", "buffer_a_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tG3zW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 77, 239]], "test": "untested"}
{"id": "NlVSDz", "name": "Clelia curve", "author": "NinjaKoala", "description": "Clelia curve rendering (https://en.wikipedia.org/wiki/Cl%C3%A9lie).\nSee top comment for more infos.\n\nMerry Christmas to all!", "tags": ["3d", "distance", "curve", "parametric"], "likes": 9, "viewed": 270, "published": 3, "date": "1640518896", "time_retrieved": "2024-07-30T18:40:09.835400", "image_code": "/*\nPlentos question in https://www.shadertoy.com/view/7lGSRW\nled me to experiment with projecting a 3D parametric curve to 2D along a ray and then using the technique from\nhttps://www.shadertoy.com/view/3tsXDB to approximate the distance to that.\n\nIt works fine to compute the distance to the projected curve, but\ni failed to properly trace the curve along a ray,\ni couldn't decide which part of the curve lies nearer to the camera\nand which point on the surface of the curve is really hit by the ray\nwithout introducing severe artifacts, so i consider this experiment\nfailed for now.\n*/\n\n\nconst float pi=3.1415925;\n\nconst float clelia_fac=1./4.;\nconst float clelia_period=1./clelia_fac*2.*pi;\nconst float radius=1.;\n\nconst int num_iterations=3;\nconst int num_start_params=13;\n\nconst float eps=.001;\n\nconst float curve_width=.003;\n\nconst float rotation_speed=.5;\n\nmat2 rot(float t){\n\treturn mat2(cos(t),-sin(t),sin(t),cos(t));\n}\n\nvec3 parametric(float t){\n\t//clelia curve\n\tt*=clelia_period;\n\tvec3 p = radius*vec3(cos(t)*cos(clelia_fac*t),cos(t)*sin(clelia_fac*t),sin(t));\n\tp.yz*=rot(mod(rotation_speed*iTime,2.*pi));\n\treturn p;\n}\n\nvec3 parametric_diff(float t){\n\t//clelia curve\n\tt*=clelia_period;\n\tvec3 p = clelia_period*radius*vec3(-clelia_fac*cos(t)*sin(clelia_fac*t)-sin(t)*cos(clelia_fac*t),\n\t                                   clelia_fac*cos(t)*cos(clelia_fac*t)-sin(t)*sin(clelia_fac*t),\n\t                                   cos(t));\n\n\tp.yz*=rot(mod(rotation_speed*iTime,2.*pi));\n\treturn p;\n}\n\nfloat parametric_normal_iteration(float t, vec3 cam, mat3x2 mat){\n\tvec2 uv_to_p=mat*(parametric(t)-cam);\n\tvec2 tang=mat*parametric_diff(t);\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat trace_parametric_curve(vec3 ro, vec3 rd){\n    float t;\n    float t0=0.;\n\tfloat d0 = 1e38;\n\n\tvec3 nor1=normalize(vec3(-rd.y,rd.x,0.));\n\tvec3 nor2=cross(rd,nor1);\n\n\tmat3x2 mat=transpose(mat2x3(nor1,nor2));\n\tvec3 p0=ro;\n\n\tfor(int i=0;i<num_start_params;i++){\n\t\tt=t0;\n\t\tfor(int j=0;j<num_iterations;j++){\n\t\t\tt=parametric_normal_iteration(t,p0,mat);\n\t\t}\n\t\tt=clamp(t,0.,1.);\n\t\tvec3 p1=parametric(t);\n\t\tvec3 p0_to_p1=p1-p0;\n\t\td0=min(d0,dot(mat*p0_to_p1,mat*p0_to_p1));\n\n\t\tt0+=1./float(num_start_params-1);\n\t}\n\n\treturn d0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0, 0, 3);\n    vec3 rd = normalize(vec3(uv, 0.) - vec3(0,0,1));\n\n\tfloat dis = trace_parametric_curve(ro,rd);\n\n    if(dis < curve_width){\n    \tfragColor = vec4(1.-dis*1000.);\n    }\n    else{\n        fragColor = vec4(0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlVSDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[864, 864, 882, 882, 928], [930, 930, 955, 971, 1129], [1131, 1131, 1161, 1177, 1497], [1499, 1499, 1564, 1564, 1707], [1709, 1709, 1756, 1756, 2231], [2233, 2233, 2289, 2289, 2641]], "test": "untested"}
{"id": "7lGXDR", "name": "Infinite raymarched cube", "author": "ninofiliu", "description": "Cube, rendered in a raymarching fashion, with the ray being modulo'd to a containing cube, so that the ray ends up always passing close by or marching towards the cube\n\nCode should be self-readable once the raymarching basic theory is understood", "tags": ["raymarching", "simple", "cube"], "likes": 5, "viewed": 369, "published": 3, "date": "1640513793", "time_retrieved": "2024-07-30T18:40:10.604345", "image_code": "float STEP = 0.99;\nfloat MAX_DIST = 100.;\nfloat SURFACE_DIST = 0.0001;\nfloat NORMAL_DIST = 0.00001;\nvec3 MOD_CENTER = vec3(0., 0., -5.);\nfloat MOD_SIZE = 7.;\n\nstruct Marched {\n    vec3 w; // marched position, modulo'd\n    vec3 n; // surface normal\n    float d; // distance from scene\n    float md; // marched distance\n};\n\n/** \n * Signed distance from a point `w` to a plane defined by a point `p` and a normal `n`\n */\nfloat distPlane(vec3 w, vec3 p, vec3 n) {\n    return dot(n, w-p);\n}\n\n/** \n * The scene is a cube centered at `center`\n * The `radius` is the distance from `center` to any face\n * Faces are contained in infinite planes defined by `normals`\n * A point on each face is derived from existing variables\n * Like any concave polygon, the distance from it to a point\n * is the max of signed distance to infinite face planes\n */\nfloat distScene(vec3 w) {\n    vec3 center = vec3(0., 0., -5.);\n    float radius = .8;\n    vec3 normals[6];\n    normals[0] = vec3(0., sin(iTime), cos(iTime));\n    normals[1] = vec3(1., 0., 0.);\n    normals[2] = cross(normals[0], normals[1]);\n    for (int i = 0; i < 3; i++) {\n        normals[3+i] = -normals[i];\n    }\n    \n    float d = 0.;\n    for (int i = 0; i < 6; i++) {\n        d = max(d, distPlane(w, center + normals[i] * radius, normals[i]));\n    }\n    \n    return d;\n}\n\nMarched march(vec3 ray) {\n    vec3 w = vec3(0., 0., 0.);\n    float md = 0.;\n    float d = distScene(w);\n    int i = 0;\n    while (i < 1000 && d > SURFACE_DIST && d < MAX_DIST) {\n        w += ray * d * STEP;\n        md += d * STEP;\n        for (int j = 0; j < 3; j++) {\n            float offset = -MOD_CENTER[j] + MOD_SIZE / 2.;\n            w[j] = mod(w[j] + offset, MOD_SIZE) - offset;\n        }\n        d = distScene(w);\n        i++;\n    }\n    // Computes the normal based on distance from nearby points\n    // https://computergraphics.stackexchange.com/a/8097/17336\n    float dwx = distScene(w + vec3(NORMAL_DIST, 0., 0.));\n    float dwy = distScene(w + vec3(0., NORMAL_DIST, 0.));\n    float dwz = distScene(w + vec3(0., 0., NORMAL_DIST));\n    vec3 n = (vec3(dwx, dwy, dwz) - d) / NORMAL_DIST;\n    \n    return Marched(w, n, d, md);\n}\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n    // Camera is at (0,0,0) and looks towards (0,0,-1)\n    vec3 ray = normalize(vec3(\n        (coord - 0.5 * iResolution.xy)/min(iResolution.x, iResolution.y),\n        -1.\n    ));\n    Marched m = march(ray);\n    float light =\n        // light from a vertical source\n        // objects do not cast shadows\n        (0.5 + 0.5 * dot(m.n, vec3(0., 1., 0.)))\n        // darken far away objects\n        / (1. + .05 * m.md)\n        // adjusts brightness\n        * 2.;\n    color = vec4(vec3(light), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGXDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[322, 418, 459, 459, 485], [487, 838, 863, 863, 1314], [1316, 1316, 1341, 1341, 2151], [2153, 2153, 2200, 2255, 2698]], "test": "untested"}
{"id": "ftKSWz", "name": "A  demo of magnify", "author": "ololeecn", "description": "A  simple demo of magnify.\nthanks IQ", "tags": ["camera", "magnify", "whitening"], "likes": 2, "viewed": 474, "published": 3, "date": "1640513411", "time_retrieved": "2024-07-30T18:40:11.381267", "image_code": "// The MIT License\n// Copyright  2021 Ololee\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define SCALE 1.9  // magnification times,it must greater than 1.0\n#define BETA 7.0  // whiteing fractor. it's suit for me.\n#define MAGNIFY_SIZE 1.0\n#define MIRROR_SWITCH //Mirror switch\n\n\n/*\nwhiteing the image. \nbeta must not be 1.0 or a negative number\n*/\nvoid whitening(inout vec3 col,float beta){\n   col = log(col*(beta-1.0)+1.0)/log(beta);\n}\n\n\n/*\nthanks iq for his method\nlink:  https://www.shadertoy.com/view/3ltSW2\n*/\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // range from [0,1]\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ms = iMouse.xy/iResolution.xy;  \n    // range from [-1,1]\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y; \n    float scale = 1.0/SCALE;\n   \n   // mirror   \n    #ifdef MIRROR_SWITCH\n        vec2 one_zero = vec2(1.0,0.0);\n        vec2 minusOne_zero = vec2(-1.0,1.0);\n        uv = one_zero + uv*minusOne_zero;\n        ms = one_zero + ms*minusOne_zero;\n        \n    #endif    \n    ms *=(1.0-scale);\n   vec3 col =texture(iChannel0,uv).xyz;\n   whitening(col,BETA);\n   if( iMouse.z>0.001 )\n   {\n       vec3 colScale = texture(iChannel0,scale*uv+ms).xyz;\n       whitening(colScale,BETA);\n       col = mix(colScale,col, smoothstep(0.0, 0.01, length(p-m)-MAGNIFY_SIZE));\n   }\n   \n   fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKSWz.jpg", "access": "api", "license": "mit", "functions": [[1261, 1330, 1372, 1372, 1418], [1421, 1497, 1539, 1539, 1565], [1569, 1569, 1626, 1650, 2471]], "test": "untested"}
{"id": "7tGXDz", "name": "Fork Book of Life", "author": "davidar", "description": "Game of Life simulation with various spaceships and collisions in book form. Forked to give more of a printed paper aesthetic", "tags": ["simulation", "automata", "life", "gameoflife", "page", "book", "turning"], "likes": 24, "viewed": 473, "published": 3, "date": "1640506181", "time_retrieved": "2024-07-30T18:40:12.343694", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.1415926535897932384626433832795;\n\nfloat time()\n{\n    float mt = mod(iTime, 12.0);\n    return mt < 8.0 ? 0.0 : (mt - 8.0) / 4.0;\n}\n\nint pagesFlipped()\n{\n    return mod(iTime, 24.0) >= 12.0 ? 1 : 0;\n}\n\nfloat radius()\n{\n    return 0.982 - 2.0 * pow(time() - 0.3, 2.0);\n}\n\nvec2 circleBase()\n{\n    return vec2(4.0 - 4.0 * time(), 0.23);\n}\n\nvec2 circleCenter()\n{\n    return circleBase() + vec2(0.0, radius() - 0.002);\n}\n\nfloat arcAngle()\n{\n    return 2.0 * (PI - atan((8.0 - 4.0 * time()) / radius()));\n}\n\nfloat partArcAngle()\n{\n    float a = arcAngle();\n    float pa = 4.0 * time() / radius();\n    return pa < a ? pa : a;\n}\n\nvec2 lineEnd()\n{\n    return vec2(-4.0, 0.232);\n}\n\nvec2 lineStart()\n{\n    vec2 cc = circleCenter();\n    return cc + reflect(cc - circleBase() + vec2(0.0, 0.002), normalize(lineEnd() - cc));\n}\n\nfloat line2D(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat lineSDF(vec3 p)\n{\n    float pa = partArcAngle();\n    if (pa < arcAngle()) {\n        return MAX_DIST;\n    }\n    float len = 4.0 * time() - pa * radius();\n    vec2 l1 = lineStart();\n    vec2 ld = normalize(lineEnd() - l1);\n    float d2d = line2D(p.xy, l1, l1 + len * ld) - 0.002;\n    \n    return max(d2d, abs(p.z)-2.0);\n}\n\nfloat arc2D( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    if (scb.y*p.x>scb.x*p.y)\n    {\n        return sqrt((p.x - ra*scb.x)*(p.x - ra*scb.x) + (p.y - ra*scb.y)*(p.y - ra*scb.y)) - rb;\n    }\n    else\n    {\n        return sqrt(dot(p,p) + ra*ra - 2.0*ra*length(p)) - rb;\n    }\n    //float k = (scb.y*p.x>scb.x*p.y) ? dot(p,scb) - rb/280.0 : length(p);\n    //return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat arcSDF(vec3 p)\n{\n    float t = time();\n    float r = radius();\n    float hpa = partArcAngle() / 2.0;\n    if (hpa == 0.0) {\n        return MAX_DIST;\n    }\n    vec2 cp = circleBase() + vec2(0.0, r - 0.002);\n    float ma = 1.5 * PI - hpa;\n    float d2d = arc2D(p.xy - cp,\n        vec2(sin(ma), cos(ma)),\n        vec2(sin(hpa), cos(hpa)),\n        r, 0.002);\n    \n    return max(d2d, abs(p.z)-2.01);\n}\n\nfloat roundedCross2D( in vec2 p, in float h )\n{\n    float k = 0.5*(h+1.0/h);\n    p = abs(p);\n    return ( p.x<1.0 && p.y<p.x*(k-h)+h ) ? \n             k-sqrt(dot(p-vec2(1,k),p-vec2(1,k)))  :\n           sqrt(min(dot(p-vec2(0,h),p-vec2(0,h)),\n                    dot(p-vec2(1,0),p-vec2(1,0))));\n}\n\nfloat roundedCrossSDF(vec3 p)\n{\n    float d2d = roundedCross2D(p.xy - vec2(0.0, 0.23), 0.05);\n    \n    return max(d2d, abs(p.z)-2.1);\n}\n\nfloat trapezoid2D(vec2 p, float r1, float r2, float he)\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\nfloat trapezoidSDF(vec3 p)\n{\n    float d2d = trapezoid2D(p.xy - vec2(0.0, 0.13), 4.2, 4.0, 0.1);\n    \n    return max(d2d, abs(p.z)-2.0);\n}\n\nfloat coverSDF(vec3 p)\n{\n    vec3 d = abs(p) - vec3(4.23, 0.03, 2.03);\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));\n    return insideDistance + outsideDistance;\n}\n\nfloat sceneSDF(vec3 p) {\n    return min(min(min(\n        coverSDF(p),\n        max(trapezoidSDF(p),-roundedCrossSDF(p))),\n        arcSDF(p)),\n        lineSDF(p));\n}\n\n// ##################################################\n\nvec3 pageCoord(vec3 p)\n{\n    float t = time();\n    \n    if (p.y > 0.231)\n    {\n        if (arcSDF(p) < EPSILON)\n        {\n            vec2 rl = p.xy - circleCenter();\n            float ad = (PI / 2.0 + atan(rl.y, rl.x)) * radius();\n            if (length(rl) < radius())\n            {\n                return vec3(circleBase().x + ad, p.z, 0.0);\n            }\n            else\n            {\n                return vec3(-(circleBase().x + ad), p.z, 1.0);\n            }\n        }\n        else //if (lineSDF(p) < EPSILON)\n        {\n            float ld = distance(lineStart(), p.xy);\n            float ad = partArcAngle() * radius();\n            return vec3(-(circleBase().x + ad + ld), p.z, 1.0);\n        }\n    }\n    else\n    {\n        return vec3(p.x, p.z, p.x > 4.05 - 4.0 * t ? 1.0 : 0.0);\n    }\n}\n\nvec3 colFromPoint(vec3 p)\n{\n    if (p.y < 0.031)\n    {\n        return vec3(0,0,0.1);\n    }\n    else\n    {\n        vec3 pc = pageCoord(p);\n        vec2 uv = pc.xy / 2.;\n        vec3 fragColor = vec3(0.9, 0.85, 0.8);\n        \n        fragColor += 0.2 * FBM(300. * uv.xyy) - 0.05;\n        if (abs(pc.x) < 3.85 && abs(pc.y) < 1.85)\n        {\n            int sbuf = (int(pc.z) ^ pagesFlipped());\n            vec4 tc = texture(iChannel0, vec2(78.0 * float(sbuf) + (pc.x + 3.9) * 10.0, (pc.y + 1.9) * 10.0)/iResolution.xy);\n            float text = mix(0.6, 0.4, (tc.x + tc.y)/2.);\n            text += 0.2 * (FBM(20. * uv.xyy) - 0.5);\n            text += 0.1 * (FBM(50. * uv.xyy) - 0.5);\n            float ink = smoothstep(0.5, 0.49, text);\n            ink -= smoothstep(0.65, 0.75, FBM(25. * uv.xyy));\n            fragColor = mix(fragColor, vec3(0.8, 0.75, 0.7), smoothstep(0.55, 0.49, text));\n            fragColor = mix(fragColor, vec3(0.01, 0, 0), clamp(ink, 0., 1.));\n        }\n        return fragColor * clamp(p.y/0.18, 0., 1.5);\n    }\n}\n\nvec3 backColor(vec2 fc)\n{\n    return texture(iChannel3, vec3(fc/iResolution.xy - 0.5, -0.5)).rgb;\n}\n\n// ##################################################\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.7 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime/8.0),\n                          3.0,\n                          -1.5 + 3.0 * cos(iTime/8.0));\n    vec3 light1Intensity = vec3(0.5, 0.5, 0.5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n// ##################################################\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(7.5 * sin(0.5 * sin(iTime/8.0)), 12.0 - 2.0 * abs(sin(iTime/8.0)), 7.5 * cos(0.5 * sin(iTime/8.0)));\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.23, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON)\n    {\n        fragColor = vec4(backColor(fragCoord), 1.0);\n    }\n    else\n    {\n        vec3 p = eye + dist * worldDir;\n\n        vec3 K_a = 0.3 * colFromPoint(p);\n        vec3 K_d = colFromPoint(p);\n        vec3 K_s = vec3(0);\n        float shininess = 1.0;\n\n        vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n\n        fragColor = vec4(pow(color, vec3(1./2.2)), 1.0);\n    }\n}\n", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int shipc = 17;\n\nconst ivec3[] shipsz = ivec3[](\nivec3(3,3,0),      //Glider\nivec3(5,4,9),      //Lightweight spaceship\nivec3(6,5,29),     //Middleweight spaceship\nivec3(7,5,59),     //Heavyweight spaceship\nivec3(9,9,94),     //Loafer\nivec3(12,8,175),   //Copperhead\nivec3(13,12,271),  //Canada goose\nivec3(12,10,427),  //Turtle\nivec3(10,15,547),  //Dart\nivec3(7,16,697),   //Edge-repair spaceship 1\nivec3(8,16,809),   //B29\nivec3(11,17,937),  //Brain\nivec3(10,9,1124),  //Coe ship\nivec3(11,16,1214), //Weekender\nivec3(9,22,1390),  //Wasp\nivec3(12,24,1588), //Swan\nivec3(21,11,1876)  //Non-monotonic spaceship 1\n);\n\nconst vec2[] shipsp = vec2[](\nvec2(0.25,0.25),\nvec2(0.5,0.0),\nvec2(0.5,0.0),\nvec2(0.5,0.0),\nvec2(1.0/7.0,0.0),\nvec2(0.1,0.0),\nvec2(0.25,0.25),\nvec2(1.0/3.0,0.0),\nvec2(1.0/3.0,0.0),\nvec2(1.0/3.0,0.0),\nvec2(0.25,0.25),\nvec2(1.0/3.0,0.0),\nvec2(0.5,0.0),\nvec2(2.0/7.0,0.0),\nvec2(1.0/3.0,0.0),\nvec2(0.25,0.25),\nvec2(0.25,0.0)\n);\n\nconst uint[] ships = uint[](\n0x47c83179u,0x11030be6u,0x210182ffu,0x4cc90501u,\n0x201c0101u,0x3000b01u,0x2313a0du,0xa0c31210u,\n0x20b000c0u,0x60611a5u,0x1a81180u,0x40002019u,\n0x8b813004u,0xf01db4u,0xc8708a48u,0x428428a4u,\n0x871b4d01u,0xc8050060u,0x40110049u,0xe5013e50u,\n0x49104006u,0x5008010u,0x50314188u,0x9010304u,\n0x38210183u,0x8206050u,0x5048404au,0x218b4800u,\n0x10600806u,0xc006c12u,0x71cf488eu,0xe4c217cu,\n0x5f0c2u,0x3908e3du,0x271f0480u,0x60fcc1d0u,\n0x4220200cu,0x781b018u,0x201b148u,0x20140480u,\n0x8c018030u,0x460900a0u,0x400a403u,0x6010c118u,\n0xac400e00u,0x80e14800u,0xae389080u,0x41801808u,\n0x1c040803u,0x1810008u,0x400c00u,0x80580900u,\n0x110220u,0x6008505u,0xb85a0400u,0x803800a0u,\n0x2800u,0x600e00a0u,0x3006016u,0x1d703u,\n0x10029e20u,0xc31709a0u,0x84005c2u,0x69e20c3cu,\n0x400a01d7u,0x58000u\n);\n\n\n\n\nuint shipBit(int n, int x, int y)\n{\n    int b = shipsz[n].z + x + y * shipsz[n].x;\n    return (ships[b / 32] >> (31 - (b % 32))) % 2u;\n}\n\nint Cell(int n, in ivec2 p)\n{\n    ivec2 r = ivec2(78, 38);\n    p = (p+r) % r;\n    vec4 c = texelFetch(iChannel0, p + (n%2 == 1 ? ivec2(78,0) : ivec2(0)), 0);\n    return ((n/2 == 0 ? c.x : c.y) > 0.5) ? 1 : 0;\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n + iDate.w)*138.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n    float f = 0.0;\n    int e = 0;\n    \n    if (px.x < 2*78 && px.y < 38)\n    {\n        int b = px.x / 78;\n        if (iFrame % 3 == 0)\n        {\n            int k = Cell(b, px+ivec2(-1,-1)) + Cell(b, px+ivec2(0,-1)) + Cell(b, px+ivec2(1,-1))\n                  + Cell(b, px+ivec2(-1, 0))                           + Cell(b, px+ivec2(1, 0))\n                  + Cell(b, px+ivec2(-1, 1)) + Cell(b, px+ivec2(0, 1)) + Cell(b, px+ivec2(1, 1));\n\n            e = Cell(b, px);\n\n            f = ( ((k==2)&&(e==1)) || (k==3) ) ? 1.0 : 0.0;\n\n            if( iFrame == 0\n                || (b == 1 && mod(iTime, 24.0) < 2.0)\n                || (b == 0 && mod(iTime, 24.0) >= 12.0 && mod(iTime, 24.0) < 14.0))\n            {\n                if (iFrame != 0 && mod(iTime, 60.0) < 48.0)\n                {\n                    ivec2 gpx = px - ivec2(b==1?78:0,0);\n\n                    int si1 = int(floor((iDate.w + hash1(1.1)) * float(shipc))) % shipc;\n                    int si2 = int(floor((iDate.w + hash1(2.3)) * float(shipc))) % shipc;\n                    bool sr1 = int(floor((iDate.w + hash1(5.8)) * 2.0)) % 2 == 1;\n                    bool sr2 = int(floor((iDate.w + hash1(13.21)) * 2.0)) % 2 == 1;\n                    int ssm = (shipsz[si1].y / 2 + shipsz[si2].y / 2) / 2;\n                    int sy1 = int(floor((iDate.w + hash1(34.55)) * float(ssm * 2 + 1))) % (ssm * 2 + 1) - ssm;\n                    int sy2 = int(floor((iDate.w + hash1(89.144)) * float(ssm * 2 + 1))) % (ssm * 2 + 1) - ssm;\n\n                    float stps = floor(min(min(float(36 - shipsz[si1].x) / shipsp[si1].x,\n                        float(36 - shipsz[si2].x) / shipsp[si2].x), 140.0));\n\n                    ivec2 sp1 = ivec2(39 - shipsz[si1].x - int(shipsp[si1].x * stps),\n                        (38 + 19 + sy1 - shipsz[si1].y / 2 + (sr1?1:-1) * int(shipsp[si1].y * stps)) % 38);\n                    ivec2 sp2 = ivec2(38 + shipsz[si2].x + int(shipsp[si2].x * stps),\n                        (38 + 19 + sy2 - shipsz[si2].y / 2 + (sr2?1:-1) * int(shipsp[si2].y * stps)) % 38);\n\n                    if (gpx.x >= sp1.x && gpx.x < sp1.x + shipsz[si1].x\n                        && (sp1.y <= (sp1.y + shipsz[si1].y - 1) % 38 && (gpx.y >= sp1.y % 38 && gpx.y <= (sp1.y + shipsz[si1].y - 1) % 38)\n                        || (sp1.y > (sp1.y + shipsz[si1].y - 1) % 38 && (gpx.y >= sp1.y % 38 || gpx.y <= (sp1.y + shipsz[si1].y - 1) % 38))))\n                    {\n                        f = float(shipBit(si1, gpx.x - sp1.x, ((sr1 ? shipsz[si1].y + 37 - (gpx.y - sp1.y) : gpx.y - sp1.y + 38) % 38)));\n                    }\n                    else if (gpx.x <= sp2.x && gpx.x > sp2.x - shipsz[si2].x\n                        && (sp2.y <= (sp2.y + shipsz[si2].y - 1) % 38 && (gpx.y >= sp2.y % 38 && gpx.y <= (sp2.y + shipsz[si2].y - 1) % 38)\n                        || (sp2.y > (sp2.y + shipsz[si2].y - 1) % 38 && (gpx.y >= sp2.y % 38 || gpx.y <= (sp2.y + shipsz[si2].y - 1) % 38))))\n                    {\n                        f = float(shipBit(si2, sp2.x - gpx.x, ((sr2 ? shipsz[si2].y + 37 - (gpx.y - sp2.y) : gpx.y - sp2.y + 38) % 38)));\n                    }\n                    else\n                    {\n                        f = 0.0;\n                    }\n                }\n                else\n                {\n                    e = 0;\n                    f = step(0.7, hash1(fragCoord.x*13.0+hash1(fragCoord.y*71.1)));\n                }\n            }\n            else if( (b == 1 && mod(iTime, 24.0) < 11.0)\n                || (b == 0 && mod(iTime, 24.0) >= 12.0 && mod(iTime, 24.0) < 23.0))\n            {\n                e = 0;\n                f = float(Cell(b, px));\n            }\n        }\n        else\n        {\n            e = Cell(b + 2, px);\n            f = float(Cell(b, px));\n        }\n    }\n    \n\tfragColor = vec4(f, float(e), 0.0, 0.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n        vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n        vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n        vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n// By David Hoskins, May 2014. @ https://www.shadertoy.com/view/4dsXWn\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n\tvec3 f = fract(p); \n\tf *= f * (3.0-2.0*f);\n\n    return mix(\n\t\tmix(mix(hash13(i + vec3(0.,0.,0.)), hash13(i + vec3(1.,0.,0.)),f.x),\n\t\t\tmix(hash13(i + vec3(0.,1.,0.)), hash13(i + vec3(1.,1.,0.)),f.x),\n\t\t\tf.y),\n\t\tmix(mix(hash13(i + vec3(0.,0.,1.)), hash13(i + vec3(1.,0.,1.)),f.x),\n\t\t\tmix(hash13(i + vec3(0.,1.,1.)), hash13(i + vec3(1.,1.,1.)),f.x),\n\t\t\tf.y),\n\t\tf.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 ) * 1.7;\n\nfloat FBM( vec3 p )\n{\n    float f;\n\t\n\tf = 0.5000 * Noise(p); p = m*p;\n\tf += 0.2500 * Noise(p); p = m*p;\n\tf += 0.1250 * Noise(p); p = m*p;\n\tf += 0.0625   * Noise(p); p = m*p;\n\tf += 0.03125  * Noise(p); p = m*p;\n\tf += 0.015625 * Noise(p);\n    return f;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGXDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 177, 191, 191, 272], [274, 274, 294, 294, 341], [343, 343, 359, 359, 410], [412, 412, 431, 431, 476], [478, 478, 499, 499, 556], [558, 558, 576, 576, 641], [643, 643, 665, 665, 761], [763, 763, 779, 779, 811], [813, 813, 831, 831, 953], [955, 955, 993, 993, 1112], [1114, 1114, 1137, 1137, 1439], [1441, 1441, 1516, 1516, 1931], [1933, 1933, 1955, 1955, 2335], [2337, 2337, 2384, 2384, 2631], [2633, 2633, 2664, 2664, 2768], [2770, 2770, 2827, 2827, 3143], [3145, 3145, 3173, 3173, 3283], [3285, 3285, 3309, 3309, 3513], [3515, 3515, 3539, 3539, 3678], [3735, 3735, 3759, 3759, 4532], [5572, 5572, 5597, 5597, 5671], [5728, 6149, 6240, 6240, 6546], [6561, 6815, 6880, 6880, 7012], [7014, 7103, 7132, 7132, 7442], [7444, 7936, 8076, 8076, 8666], [8668, 9038, 9123, 9123, 9586], [9588, 9915, 9964, 9964, 10190], [10247, 10247, 10304, 10304, 11164]], "test": "untested"}
{"id": "NtVSDR", "name": "230char meandering", "author": "davidar", "description": "A little slow, use the shadertoy browser plugin to speed up if you're impatient", "tags": ["simulation", "convolution", "diffusion", "2tweets", "kernel", "ca", "golf", "reaction", "differential", "growth", "meandering"], "likes": 19, "viewed": 541, "published": 3, "date": "1640505418", "time_retrieved": "2024-07-30T18:40:13.189432", "image_code": "M-A;}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* Original:\n#define G(a) exp(-dot(a*i,a*i)) * a*a / 3.1\nM;\n  for(int k=0; ++k<289; r += 9. * A * (G(.4) - G(.25))) i = vec2(k%17,k/17)-8.;\n  r = clamp(r,0.,1.);\n  iFrame<2 ? i = u - 99., r -= G(1.) : r;\n}\n*/\n\n// Replaced Difference of Gaussians with Mexican hat wavelet\nM;\n  for(int k=0; ++k<289;\n      r += A * (.3 - .03*dot(i,i))*exp(-.1*dot(i,i))\n     ) i = vec2(k%17,k/17)-8.;\n  r = iFrame<2 ? -u.xyxy : clamp(r,0.,1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define M void mainImage(out vec4 r, vec2 u) { vec2 i = u-u; r -= r//\n#define A texelFetch(iChannel0,ivec2(i+u),0)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtVSDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NtKXWR", "name": "horrible illusion", "author": "SnoopethDuckDuck", "description": "e", "tags": ["raymarching", "template", "artofcode"], "likes": 7, "viewed": 233, "published": 3, "date": "1640493514", "time_retrieved": "2024-07-30T18:40:13.961368", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\n#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n} \n\n\nfloat GetDist(vec3 p) {\n    float r1 = 2.;\n    float r2 = 0.8;\n    \n    float d1 = length(p.xz) - r1;\n    float d2 = length(vec2(p.y, d1)) - r2;\n\n    float d = length(p) - 2.;\n    \n    float m = smoothstep(0., 1., 0.5 + 0.5 * thc(4., 0.4 * iTime));\n    \n    d = mix(d, d2, m);\n    \n    return 1. * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*.5 + .5;\n    \n    vec3 col = mix(vec3(.5,0.,0.),vec3(0.),k);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(4.6 * cos(0.5 * iTime), 0.4 * cos(0.3 * iTime) * 2.5, 4.6 * sin(0.5 * iTime));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 rf = refract(rd, n,0.1);\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = 0.42 *vec3(dif);\n       \n        float time = 0.;\n        float sc = 36.;\n        float str = 4.;\n        float val = thc(str, sc * r.x + time - 2. * pi / 3.) + \n                    thc(str, sc * r.y + time) +\n                    thc(str, sc * r.z + time + 2. * pi / 3.);\n        \n       \n       \n        col = texture(iChannel0, -n + val).rgb;\n        col = 2. * pow(col * col * (3. - 2. * col),vec3(2.)); \n        \n    } else {\n        col = texture(iChannel0, rd).rgb;\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtKXWR.jpg", "access": "api", "license": "mit", "functions": [[1495, 1495, 1524, 1524, 1565], [1567, 1567, 1596, 1596, 1637], [1639, 1639, 1666, 1666, 1707], [1709, 1709, 1736, 1736, 1777], [1779, 1779, 1847, 1847, 1890], [1892, 1892, 1912, 1912, 1987], [1989, 1989, 2013, 2013, 2053], [2055, 2055, 2074, 2074, 2136], [2140, 2140, 2163, 2163, 2442], [2444, 2444, 2478, 2478, 2689], [2691, 2691, 2715, 2715, 2905], [2907, 2907, 2957, 2957, 3148], [3150, 3150, 3168, 3168, 3266], [3269, 3269, 3326, 3326, 4512]], "test": "untested"}
{"id": "7tySWR", "name": "testing fdn stuff pi.II", "author": "nabr", "description": "debuging, playing around. reduced complexity, - 2x vec4 and one dot operation, lerp between gain values.", "tags": ["sound", "reverberation", "fnd"], "likes": 21, "viewed": 515, "published": 3, "date": "1640488296", "time_retrieved": "2024-07-30T18:40:14.730313", "image_code": "\nvoid print(inout vec4 O, in vec2 uv )\n{\n    //O -= O;\n    \n    vec2 U;\n    uv /= R.y;\n     \n    uv -= vec2(1.2,-.2);\n    U = ( uv - vec2(.0,.5) ) * 16.;\n    vec2 gV = getVal(0., 0., T);\n    \n    float ratio = float( gcd( int( gV.x ) , int( gV.y ) ));\n     \n    low C(22)C(1)C(12)caps C(-15)C(-6)spc spc // val1\n    O += pFloat(U, gV.x);\n    U = ( uv - vec2(.0,0.45) ) * 16.;\n    low C(22)C(1)C(12)caps C(-14)C(-6)spc spc  // val2\n    O += pFloat(U,gV.y);\n    U = ( uv - vec2(.05,0.40) ) * 24.;  // ratio\n    low C(18)C(1)C(20) C(9) C(15) \n    caps C(-6) spc spc\n    \n    O += pInt(U, (gV.x/ratio));\n    spc spc U.y+=.8;\n    O += pInt(U, 100.*floor(gV.y/ratio));\n    \n    U = ( uv - vec2(.05,0.30) ) * 24.;  // decay\n    low C(4)C(5)C(3) C(1) C(25) caps C(-6) spc spc\n    O += pFloat(U,decay);\n    O += draw_char(iChannel3).xxxx;\n \n}\n\n// char by FabriceNeyret2\n#define char(_p,_C)(((_p.x<0.||_p.x>1.||_p.y<0.||_p.y>1.))?vec4(0,0,0,1e5):textureGrad(iChannel3,_p/16.+fract(vec2(_C,15-_C/16)/16.),dFdx(_p/16.),dFdy(_p/16.)))\n\n// -------- texture\nfloat f(vec2 U)\n{\n    float O = 0.;\n     vec2 u=U;\n     u = vec2(.5, -1.5)+u*12.;\n     for(int i = 0; i < 7; ++i){\n     O += char(u,int[](83, 111, 117, 110, 100, 105, 110)[i]).x; //*max(0., 1.-T*.2);\n     u.x -= 1.5;\n     u*= mat2(0.6,-.8,.8, .6);\n     }\n     return O;\n}\nfloat tex(in vec2 p)\n{\n    float m = .5;\n    const vec2 e = vec2(.001, 0);\n    vec3 sn = normalize(vec3(f(p + e) - f(p - e), f(p + e.yx) - f(p - e.yx), -.2));\n    return clamp(max(0., dot(normalize(vec3(2.*p, m)), -sn)), .0, 1.);\n}\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    \n    vec2 cU = ((U - .5 * R) / R.y);\n    if(abs(cU.x-.54)<.3333&&abs(cU.y-.25)<.2){\n    vec2 M = vec2(.25, .5) * iTime ; //+ (6. * atan(iMouse.xy / R));\n    #define R3d(_a)(mat3(1,0,0,0,cos(_a.y),-sin(_a.y),0,sin(_a.y),cos(_a.y))*mat3(cos(_a.x),0,sin(_a.x),0,1,0,-sin(_a.x),0,cos(_a.x)))\n    vec3 o = R3d(M) * vec3(0, 0, float( (mod(T, 20.)> 16.)?-1.5:4.));\n    vec3 d = R3d(M) * vec3(cU+vec2(-.54, -.25), 2.2);\n    // -------- box\n    // https://iquilezles.org/articles/boxfunctions\n    vec3 no = o * 1. / d;\n    vec3 k = .25 * abs(1. / d);\n    vec3 pin = (-k) - no, pot = k - no;\n    float tN = max(pin.x, max(pin.y, pin.z));\n    float tF = min(pot.x, min(pot.y, pot.z));\n    if (tN < tF){\n        vec3 pos = (o + tF * d);\n        vec3 n = sign(d) * step(pot, pot.zxy) * step(pot, pot.yzx);\n        float tx = abs(n.x * tex(pos.zy) + n.y * tex(pos.zx) + n.z * tex(pos.xy));\n        // -------- shade box\n        O.xyz = sin(1.7 + tx * vec3(4.5, 6, 6.75)) * 0.45 + 0.5;\n        }\n    }\n    else{\n    //------- dancing beams of light\n    O.xyz=vec3(1e-6);\n    cU+=vec2(0.34, 0.19);\n    if(abs(cU.x)<.55&&abs(cU.y)<.3)\n    {\n    vec2 vr = v2rnd(T*6.);\n    vr = clamp(vr, -vec2(.5, .25), vec2(.5, .25));\n    float asp = 1.7/max(R.x, R.y),\n    cx = asp/length((cU.x+vr.x)),\n    cy = asp/length((cU.y+vr.y));\n    O.xyz = .051 * vec3(cU, sin(iTime)*.5+.5) \n    +vec3(mix(cy, cx, sin(2.*T)*.5+.5)-.074)\n    +.001*float(int(U.x+floor(U.y) * 21.999)& 13);\n    }\n    print(O, U);\n    }\n     \n     O = pow(O, vec4(.454545));\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define T iTime\n\nfloat rndp(in uint sd,in uint mv){return float((1315313u%(sd+1u))%mv);}\n\nvec2 v2rnd(in float t)\n{\n    float x=rndp(uint(t),27U),y=rndp(uint(t),31U);\n    return vec2(sin(x),cos(y));\n}\n\n\n// DEKAY OK\nconst float decay = 1.2;\nvec2 getVal(in float x, in float y, in float t)\n{\n     float valchange = + 71.991; //new random sequence\n     t = (t * (1./8.)) + valchange;\n     float xx = v2rnd(.5*t).x;\n     float yy = v2rnd(1.+t).y;\n     return abs( 12.566370 * vec2(xx, yy));\n}\n\n// https://github.com/riccardoscalco/glsl-gcd/blob/master/index.glsl\nint gcd(int u, int v) {\n\tu = abs(u);\n\tv = abs(v);\n\t// While loop is not always allowed, use a for loop.\n\tfor (int i = 0; i < 10; ++i) \n    {\n\t\tif (v == 0) break;\n\t\tu = (u% v);\n\t\tif (u == 0) break;\n\t\tv = (v% u);\n\t}\n\treturn u + v;\n}\n\n// --- chars https://www.shadertoy.com/view/llySRh by FabriceNeyret2\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc O+= char(U,64+CAPS+c);\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n  if ( p.x>.25&& p.x<.75 && p.y>.0&& p.y<1. )  // normal char box\n //   if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) // thighly y-clamped to allow dense text\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\n    return vec4(0);\n}\nvec4 draw_char(sampler2D iCnl) {\n    int c = char_id; vec2 p = char_pos;\n    return c < 0 \n        ? vec4(0,0,0,1e5):textureGrad(iCnl, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );}\n// --- display int4\n\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n// --- display float4.4\nvec4 pFloat(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n    v += pInt(p,floor(n)); p.x -= 2.;\n    v += char(p, 46);      p.x -= .5;\n    v += pInt(p,fract(n)*1e4);\n    return v;\n}\n\n", "sound_code": "\n#define Fs (1./iSampleRate)\n#define _f(x)  fract(x)\n\nfloat synth(in float rt, in float t, int ch) \n{\n  float f = 0., ft = mod(6. * t, 1.);\n  vec4 p = vec4(0);\n  if (ch == 0)\n    p = vec4(2880, 1440, 1182, 1804);\n  else if (ch == 1) {\n    p = vec4(1440., 720., 591, 902.);\n    if(mod(rt, 10.) > 8.) \n    p =vec4(1440., 1890, 603, 2685);\n  }\n\n  f = sin(1.570796 * p[int(6. * t) % 4] * rt) * min(1., 3. * ft) * max(0., 1. - ft);\n  f *= cos(_f(.1 * t) + 10. * exp(-.205 * pow(1. - ft, 10.)));\n  f = sin(2. * f / (1.24 - cos(f))) / (1.6643 + sin(13. * f));\n\n  return f * clamp((1. - sqrt(ft)) * 4. * ft, -1., 1.);\n}\n\nvoid bfdn(inout vec4 s, const in mat4 M, in uint i) \n{\n    s += //(s[0] * M[i][0] + s[1] * M[i][1] + s[2] * M[i][2] + s[3] * M[i][3]); \n         (s[0] * M[0][i] + s[1] * M[i][i] + s[2] * M[i][i] + s[3] * M[i][i]);\n}\n\n\nvec2 mainSound( in int samp,float time)\n{\n   // hard coded decay value in common tab\n   float mTime = float(samp)/iSampleRate;\n   vec2 gV = getVal(0., 0., mTime); // gain coefficient\n   \n   //\n   float ehd[6]=float[](.184089,.118295,.074423,.046412,.029080,.018004);//late dalaylines\n   vec4 dt = vec4(577, 601, 641, 661);//primes\n   \n   vec2 r = vec2(1e-6);\n   float fehd =0.;\n   float y = 0., y1 = 0., y2 = 0., y3=0., y4 = 0.;\n   float mt = float(samp)/iSampleRate;\n   float dlt = mt;\n   \n   //phaser\n   float vt = mt;\n   vec4 ehp = 1e-6 * vec4(17. * cos(vt), -15. * sin(vt), 12. * sin(vt),11. * cos(vt));\n   float rtxz =(mt+(ehp.x+ehp.z)), rtyw =(mt+(ehp.y+ehp.w));\n   \n   const uint sz=12u;\n   for(uint j = 0u; j < 2u; j++)\n     for(uint i = 0u; i < sz; ++i){\n\n\n//#define _DBG\n#ifdef _DBG\n   \n    const vec4 A = vec4(0, -1, 1, 0);\n    dt += vec4(\n    dt[(i + 0u)%4u],\n    dt[(i + 1u)%4u],\n    dt[(i + 2u)%4u],\n    dt[(i + 3u)%4u]);\n    \n    fehd = smoothstep(-gV.x, gV.y, (dot(A, dt) * .0001)  +  ehd[ i % 6u]) ;\n    float decayfehd = fehd; //mod(fehd, 1./4.) ;\n    dlt += fehd +  ehd[ i % 6u];\n    //mt += ehd[ i % 6u];\n\n#else\n\n     const mat4 A=mat4(0,-1.,1.,0,1.,0,0,1.,1.,0,0,-1.,0,-1.,-1.,0)*(1./sqrt(2.));\n     bfdn(dt, A, (i + 0u) % 4u );\n     bfdn(dt, A, (i + 1u) % 4u );\n     bfdn(dt, A, (i + 2u) % 4u );\n     bfdn(dt, A, (i + 3u) % 4u );\n     fehd = smoothstep(-gV.x, gV.y, (((dt.x + dt.y + dt.z + dt.w)) * .0001)+  ehd[ i % 6u] ) ;\n     float decayfehd = mod(fehd, 1./4.); //fehd;\n     dlt += fehd +  ehd[ i % 6u];\n     \n#endif\n        //-------- output\n        {\n            y1 =.4*synth(rtxz,time,0);\n            y2 =.4*synth(rtyw,time,0);\n            y3 =   synth(mt, dlt,0)*exp(-decay*decayfehd);\n            y4 =   synth(mt, dlt,0)*exp(-decay*decayfehd);\n        \n            if(time>9.5){\n            y1 +=.4*synth(.5*rtxz, time, 1 );\n            y2 +=.4*synth(.5*rtxz, time ,1);\n            y3 +=   synth(.5*mt, dlt, 1) * exp(-2.*decay*decayfehd);\n            y4 +=   synth(.5*mt, dlt, 1) * exp(-2.*decay*decayfehd);\n            }\n        }\n        \n        //multi channel split\n        float v[sz];//unroll for some mobile  \n        //float v[12] =float[](y2,y3,y3,y2,y2,y3,y3,y2,y4,y1,y1,y4);\n        v[0]=y2;v[1]=y3;v[2]=y3;v[3]=y2;v[4]=y2;v[5]=y3;v[6]=y3;v[7]=y2;v[8]=y4;v[9]=y1;v[10]=y1;v[11]=y4;\n        (i% 2u==0u)?(r.x += v[i % uint(sz)]): (r.y += v[i % uint(sz)]);\n\n    }\n\nreturn r /= float(8.) ;\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tySWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1315, 1315, 1337, 1337, 1546], [1547, 1547, 1586, 1586, 3107]], "test": "untested"}
{"id": "7lyXWz", "name": "noise ball (2?)", "author": "SnoopethDuckDuck", "description": "was trying to use spherical coords then gave in to my destructive urges", "tags": ["raymarching", "template", "artofcode"], "likes": 16, "viewed": 487, "published": 3, "date": "1640483060", "time_retrieved": "2024-07-30T18:40:15.494270", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define pi 3.14159\n\n#define MAX_STEPS 50\n#define MAX_DIST 50.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n} \n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 p) {\n    return max(max(abs(p.x), abs(p.y)), abs(p.z));\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat GetDist(vec3 p) {\n    float sc = 4.;\n    float sc2 = 2.;\n    \n    float a = atan(p.z, p.x);\n    float th = atan(p.y, p.x);\n    float r = length(p);/// (1. + p.y);\n    \n    float tim = 1. * a + r * 4. - iTime;\n    tim += 0.4 * h21(p.xz);\n    p = 1.2 * r * vec3(sin(a + tim) * cos(th+ tim), cos(a - tim) * sin(th+ tim), cos(th + tim) + sin(th + tim));\n    \n    vec3 ip = floor(sc2 * p) + 0.;\n    vec3 fp = fract(sc2 * p) - 0.5;\n    \n    \n    vec3 vec = 0.3 * vec3(cos(10. * h21(ip.xy) + tim), cos(10. * h21(ip.yz) + tim), cos(10. * h21(ip.zx) + tim));\n    float d0 = length(p) - 4. * mlength(fp) - 0.;\n    //d0 = length(p) - 1.;\n    \n    //p.y += cos(0.4 * r);\n   // p = vec3(a / pi, p.y, -0.4 * log(r) + .2 * iTime);\n    \n    vec2 ipos = floor(sc * p.xz) + 0.5;\n    vec2 fpos = fract(sc * p.xz) - 0.5; //cos(sc * p.xz / pi) - 0.5;\n    \n    return 0.23 * d0;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y *.5 + .5;\n    \n    vec3 col = mix(vec3(.5,0.,0.),vec3(0.),k);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float time = 0.2 * iTime;\n\n    float height = 0.;//1. + cos(time);\n    float dist = 5.;\n    vec3 ro = vec3(dist * cos(time), height, dist * sin(time));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,height,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);   \n   \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n       // vec3 rf = refract(rd, n,0.1);\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = 0.5 * vec3(dif);\n        \n        float b = .5 + .5 * cos(iTime);\n        \n        uv = fragCoord.xy / iResolution.xy;\n        col += 0.5 * texture(iChannel0, r).rgb;\n         \n       // float a = atan(rf.z, rf.x);\n       // float c = atan(rf.z,rf.y);\n        vec2 ipos = floor(p.xz) + 0.5;\n        float h = mix(h21(ipos),0., 0.5 + 0.5 * cos(iTime));\n        //col.r += 0.15 + .3 * cos(10. * rf.y + iTime - .5 * pi);\n        //col.g += 0.15 + .3 * cos(10. * rf.y + iTime);\n        //col.b += 0.15 + .3 * cos(10. * rf.y + iTime + .5 * pi);\n        //col = min(col, 1.2 * vec3(0.5 + 0.5 * cos(2. * p.y)));\n       // col *= clamp(1.05 * p.y, 0., 1.);\n        //col *= 0.5 + 0.5 * cos(length(p) + iTime);\n        col += thc(2., 2.5 * length(p) - iTime);\n        \n        vec3 e = vec3(1.);\n        col = col * pal(2.5 * length(p) - iTime, e, e, e, 0.25 * vec3(0.,0.33,0.66));\n       // col *= n.y;\n    } else {\n       // col = texture(iChannel0, rd).rgb;\n    }\n    \n    //col.r =0.02;\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyXWz.jpg", "access": "api", "license": "mit", "functions": [[1493, 1493, 1512, 1512, 1574], [1577, 1577, 1606, 1606, 1647], [1650, 1650, 1670, 1670, 1745], [1747, 1747, 1771, 1771, 1811], [1813, 1813, 1836, 1836, 1889], [1891, 1891, 1959, 1959, 2002], [2004, 2004, 2027, 2027, 2868], [2870, 2870, 2904, 2904, 3115], [3117, 3117, 3141, 3141, 3331], [3333, 3333, 3383, 3383, 3574], [3576, 3576, 3594, 3594, 3693], [3696, 3696, 3753, 3753, 5477]], "test": "untested"}
{"id": "styXDR", "name": "Cellular Graph", "author": "wyatt", "description": "Merry Christmas :)", "tags": ["voronoi", "graph"], "likes": 54, "viewed": 616, "published": 3, "date": "1640466241", "time_retrieved": "2024-07-30T18:40:16.310089", "image_code": "Main \n{\n    vec4 a = A(U);\n    vec4 b = B(U); \n    vec4 c = C(U);\n    float r = length(b.xy-b.zw);\n    float l = ln(U,b.xy,b.zw);\n    float p = length(U-a.xy);\n    Q = 1.5*c\n        *exp(-.003*(r-30.)*(r-30.))\n        *smoothstep(1.,0.,l);\n    //Q -= smoothstep(3.,2.,p);\n    Q += smoothstep(1.,0.,abs(p-2.))*c;\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, vec2 U)\nfloat ln (vec2 p, vec2 a, vec2 b) {\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nfloat pie (vec2 p, vec2 a, vec2 b) {\n\t if (length(a-b)<1e-3||length(a)<1.||length(b)<1.) return 1e9;\n    vec2 m = 0.5*(a+b); // midpoint\n    return abs(dot(p-m,b-m)/dot(b-m,b-m)); // pojection\n}\nbool cmp (vec2 p, vec2 a, vec2 b, vec2 c, vec2 d) {\n    float l1 = ln(p,a,b),\n          l2 = ln(p,c,d);\n    if (l1<.5&&l2<.5) return length(a-b)<length(b-c);\n    else return l1<l2;\n\n}", "buffer_a_code": "// Sort Particles \nMain\n{\n    Q = A(U);\n    for (float x=-2.;x<=2.;x++)\n    for (float y=-2.;y<=2.;y++)\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        if (length(U-q.xy)<length(U-Q.xy))\n            Q = q;\n    }\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Sort Graph \nMain\n{\n    Q = B(U);\n    Q.xy = A(U).xy;\n    for (float x=-2.;x<=2.;x++)\n    for (float y=-2.;y<=2.;y++)\n    {\n        vec2 u = vec2(x,y);\n        vec4\n            aa= A(U+u),\n            b = B(U+u),\n            a = vec4(A(b.xy).xy,A(b.zw).xy),\n            q = vec4(A(Q.xy).xy,A(Q.zw).xy);\n        if (cmp(U,q.xy,aa.xy,q.xy,q.zw))\n        {\n            Q.zw = q.zw = aa.xy;\n        } else\n        if (cmp(U,a.xy,a.zw,q.xy,q.zw))\n        {\n            q = a;\n            Q = b;\n        } else\n        if (cmp(U,q.xy,a.xy,q.xy,q.zw))\n        {\n            q.zw = a.xy;\n            Q.zw = a.zw;\n        }\n    }\n    Q.xy = A(Q.xy).xy;\n    Q.zw = A(Q.zw).xy;\n    if (length(U-Q.zw)<length(U-Q.xy))\n        Q = Q.zwxy;\n    if (iFrame<1) {\n        Q = vec4(U,U+1.);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Color \nMain {\n    vec4 d = D(U);\n    Q = C(d.xy);\n    \n    if (iFrame < 1)\n      Q = (.5+.5*sin(.1*U.y+vec4(1,2,3,4)));\n}\n\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Apply Forces \nMain \n{\n    Q = A(U);\n    vec4 cQ = C(Q.xy); \n    vec2 f = vec2(-1e-3);\n    for (float x=-3.;x<=3.;x++)\n    for (float y=-3.;y<=3.;y++)\n    {\n        vec2 u = Q.xy+vec2(x,y);\n        vec4 b = B(u),\n             c = C(b.zw),\n             a = A(b.zw);\n        vec2 r = Q.xy-a.xy;\n        float l = length(r); \n        float s = step(ln(u,b.xy,b.zw),1.);\n        if (l>0.&&b.z>1.&&b.w>1.)\n        {\n            float q = -.5*dot(cQ,c);\n            f +=    s*r/l*exp(-l/2.);\n            f += .5*s*q*r/l/l;\n        }\n    }\n    Q.zw +=   f;\n    Q.xy +=  f + Q.zw;\n    if (length(Q.zw)>1.)Q.zw=normalize(Q.zw);\n    if (iMouse.z>0.&&length(U-iMouse.xy)<5.) {\n        Q = vec4(U,0,0);\n    }\n    if (Q.x<1.){Q.x=1.;Q.z*=-1.;}\n    if (Q.y<1.){Q.y=1.;Q.w*=-1.;}\n    if (R.x-Q.x<1.){Q.x=R.x-1.;Q.z*=-1.;}\n    if (R.y-Q.y<1.){Q.y=R.y-1.;Q.w*=-1.;}\n    if (iFrame<1) {\n        Q = vec4(round(U/9.)*9.,0,0);\n    }\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/styXDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NlGSDz", "name": "Infinite Sequences of Powers", "author": "zovox", "description": "In General we write a Geometric Sequence like this:\n\n{ar^0, ar^1, ar^2, ar^3, ... }\n\nSince any number raised to the power of 0 is 1,\nshouldn't geometric sequences of powers\nconverge on 0 be exact numbers?\n\nThis shader is a test of that theory.", "tags": ["infinite", "geometric", "of", "powers", "sequences"], "likes": 2, "viewed": 244, "published": 3, "date": "1640455291", "time_retrieved": "2024-07-30T18:40:17.078035", "image_code": "#define PI 3.14159265359\n/*\n    Infinite Powers of Geometric Sequences:\n\n    In General we write a Geometric Sequence like this:\n\n    {a, ar, ar2, ar3, ... }\n\n    Since any number raised to the power of 0 is 1,\n    shouldn't geometric sequences of powers\n    converge on exact numbers?\n\n                   0\n               ...^\n           ar2^      = ?\n        ar^\n      a^\n\n    The purpose of this shader is to attempt a\n    brute-force algorithm for visualizing the\n    output of this algorithm. The x-domain\n    is a, r the y, and the output\n    colors on the plane up to n powers that\n    should also approach 0.\n\n    Enjoy!\n*/\n\nfloat geometric_sequence(float a, float r, float n) {\n    return a*pow(r, n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy*3.);\n    const float max_n = 1024.;\n    float delta_n = max_n;//sin(iTime)*.5+.5);\n    \n    float r = uv.y;\n    \n    float last_power = 1.;\n    \n    for(float n = 0.; n < max_n; n += 1.) {\n        if(n > delta_n) break; \n        float power = max_n-n;\n        last_power = pow(geometric_sequence(uv.x, uv.y, power), last_power);\n    }\n    fragColor = vec4(sin(PI*last_power+vec3(0.,PI/3.,4.*PI/3.))*.5+.5, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGSDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[633, 633, 686, 686, 712], [714, 714, 771, 771, 1224]], "test": "untested"}
{"id": "ftyXDz", "name": "simple hexagon with dot product", "author": "Yahor10", "description": "Purple diamond", "tags": ["hexagons", "dot", "hexogon"], "likes": 1, "viewed": 261, "published": 3, "date": "1640452512", "time_retrieved": "2024-07-30T18:40:17.857950", "image_code": "const float pi = acos(-1.0);\nconst float twopi = pi*2.0;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n\n   float leftside  = abs(dot(vec2(sin(-(pi+.6)),cos(-(pi+.6))),vec2(uv)));\n    float rightside = abs(dot(vec2(sin((pi+.6)),cos((pi+.6))),vec2(uv)));\n\n    float sides = max(leftside,rightside);\n    float rotup = dot(vec2(sin(pi),cos(pi)),vec2(uv));    \n    float rotsides = dot(vec2(sin(pi * .5),cos(pi * .5)),vec2(uv)) * 4.5;\n    float res = max(max(sides ,max(rotup,abs(rotup) * 4.5) *.1) *4.7,\n    abs(rotsides));\n    vec4 hex = (smoothstep(.51121,.53333,res) )* vec4(1.0);\n    \n    if(length(hex)< .56654)\n    fragColor =vec4(.3444,.2,1.0,.0);\n    else\n    fragColor = vec4(hex) * vec4(241321,.3454,.413333,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyXDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 114, 164, 877]], "test": "untested"}
{"id": "ftGXDz", "name": "Twisting concentric rectangles", "author": "akb74", "description": "Create a base image consisting of concentric rectangles, then apply a twisting effect to it.", "tags": ["polar", "twist"], "likes": 0, "viewed": 174, "published": 3, "date": "1640451849", "time_retrieved": "2024-07-30T18:40:18.623903", "image_code": "// Here's where we try and apply interesting effect(s)/math/art to the base image\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    // Normalized pixel coordinates (from 0 to 1)\n\tvec2 normalized = fragCoord.xy / iResolution.xy;\n    \n    vec2 fromCenter = normalized - vec2(0.5, 0.5);\n\n    // Convert to polar coordinates\n    float distance = sqrt((fromCenter.x * fromCenter.x) + (fromCenter.y * fromCenter.y));\n    float angle = atan(fromCenter.x, fromCenter.y);\n\n    // Mess with the angle\n    angle = angle + (sin(iTime * 0.5) * distance * 2.0);\n\n    // Convert back to cartesian coordinates\n    fromCenter = vec2(distance * cos(angle), distance * sin(angle));\n    vec2 uv = fromCenter + vec2(0.5, 0.5);\n\n    // Display the (distorted) base image\n    vec4 col = texture(iChannel0, uv);\n    fragColor = vec4(col.rgb, 1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// An attempt to copy u/camilleroux's base image, but making a complete mess of shapes and colors\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 normalized = fragCoord / iResolution.xy;\n\n    vec2 fromCenter = normalized - vec2(0.5, 0.5);\n    float rectRadius = max(abs(fromCenter.x), abs(fromCenter.y));\n    int band = int(ceil(16.0 * rectRadius));\n    \n    const float brightness = 0.7;\n    vec3 col;\n    \n    switch(band) {\n    case 4:\n    case 8:\n        col = brightness * vec3(1.0, 1.0, 1.0);\n        break;\n    case 3:\n    case 7:\n        col = brightness * vec3(0, 1.0, 1.0);\n        break;\n    case 2:\n    case 6:\n        col = brightness * vec3(1.0, 0.0, 0.0);\n        break;\n    case 1:\n    case 5:\n        col = brightness * vec3(1.0, 0.5, 0);\n        break;\n    default:\n        col = vec3(0.80, 0.80, 0.80);\n    }\n\n    // Output to screen\n    fragColor = vec4(col ,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGXDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 140, 192, 839]], "test": "untested"}
{"id": "wtscWX", "name": "Subterranean city", "author": "ShnitzelKiller", "description": "A test of smooth corners using neighbor rules on a voxel grid. I tried using 8-neighborhoods to define the shape but it was too slow, so horizontal neighbors only.", "tags": ["raymarching", "voxels", "city", "dark"], "likes": 6, "viewed": 246, "published": 3, "date": "1640450200", "time_retrieved": "2024-07-30T18:40:19.494574", "image_code": "#define PI 3.141593\n#define MAX_VOXELS 200\n#define MAXSTEP 50\n#define TOL 0.001\n#define FDIST 0.5\n\n#define PERIOD 11.\n#define BUILDINGRAD 4.\n\n#define GAMMA 0.5\nstruct Hit {\n    float t;\n    int mat;\n    vec3 n;\n    vec3 id;\n};\n    \nfloat noise2d(in vec2 uv) {\n    return fract(814.*sin(uv.x*15829.+uv.y*874.));\n}\n\nfloat hash( in vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Value3D.glsl\n\n    // establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    vec2 hash_mod = vec2( 1.0 / ( 635.298681 + vec2( Pi.z, Pi_inc1.z ) * 48.500388 ) );\n    vec4 hash_lowz = fract( Pt * hash_mod.xxxx );\n    vec4 hash_highz = fract( Pt * hash_mod.yyyy );\n\n    //\tblend the results and return\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( hash_lowz, hash_highz, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    return dot( res0, blend2.zxzx * blend2.wwyy );\n}\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\n    return vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n    \nfloat occupancy(in vec3 id, out int mat) {\n    vec2 block = floor(id.xy/PERIOD+0.5);\n    vec3 modid = vec3(mod(id.xy+0.5*PERIOD, PERIOD)-0.5*PERIOD, id.z);\n    float randval1 = noise2d(block);\n    float randval2 = noise2d(vec2(block.y, randval1));\n    \n    vec2 mindist = vec2(max(modid.z-1., PERIOD*0.5 - length(modid.xy)), 3.); //base\n    vec2 buildings = vec2(max(length(modid.xy)-BUILDINGRAD, -30.+modid.z-100.*randval2), 2.);\n    buildings.x = max(buildings.x, -length(vec2(mix(modid.x, modid.y, mod(floor(modid.z/4.), 2.0)), mod(modid.z, 4.)-2.)) + 2.);\n    mindist = condmin(mindist, buildings);\n    vec2 ground = vec2(modid.z + 10. * hash(id/10.), 1.0);\n    ground.x = min(ground.x, -modid.z+30. - 20. * hash(id/10.));\n    mindist = mix(mindist, ground, step(0.2, randval1));\n    float occ = step(mindist.x, 0.5);\n    mat = int(occ * round(mindist.y));\n    return occ;\n}\n\nfloat map(in vec3 ro, bool occ00, bool occ01, bool occ10, bool occ11) {\n    vec3 offsets = vec3(-1.,0.,1);\n    ro -= 0.5;\n    float height = 100.;\n    if (occ00)\n    \theight = min(height, length(max(vec2(0.), -ro.xy)));\n    if (occ11)\n    \theight = min(height, length(max(vec2(0.), ro.xy*offsets.zz)));\n    if (occ10)\n        height = min(height, length(max(vec2(0.), ro.xy*offsets.zx)));\n    if (occ01)\n        height = min(height, length(max(vec2(0.), ro.xy*offsets.xz)));\n    if (occ11 && occ00) {\n        height = min(height, 0.5-min(length(ro.xy + 0.5*offsets.zx), length(ro.xy+0.5*offsets.xz)));\n    }\n    if (occ01 && occ10) {\n        height = min(height, 0.5-min(length(ro.xy + 0.5*offsets.xx), length(ro.xy+0.5*offsets.zz)));\n    }\n    height -= 0.3;\n    return max(height, abs(ro.z)-0.5);\n}\n\nvec3 getnormal(vec3 ro, bool occ00, bool occ01, bool occ10, bool occ11) {\n    vec2 d = vec2(TOL, 0.0);\n    return normalize(vec3(\n        map(ro+d.xyy, occ00, occ01, occ10, occ11)-map(ro-d.xyy, occ00, occ01, occ10, occ11),\n        map(ro+d.yxy, occ00, occ01, occ10, occ11)-map(ro-d.yxy, occ00, occ01, occ10, occ11),\n        map(ro+d.yyx, occ00, occ01, occ10, occ11)-map(ro-d.yyx, occ00, occ01, occ10, occ11)));\n}\n\nHit voxtrace(in vec3 ro, in vec3 rd) {\n    Hit h;\n    h.mat = 0;\n    h.t = 0.;\n    // box marching with fb39ca4's DDA\n    h.id = floor(ro);        \n    vec3 ri = 1.0/rd;\n    vec3 rs = sign(rd);\n    vec3 dis = (h.id-ro + 0.5 + rs*0.5) * ri;\n    vec3 mm = vec3(0.0);\n    for (int i=0; i<MAX_VOXELS; i++) {\n        mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n\t\tdis += mm * rs * ri;\n        h.id += mm * rs;\n        \n        //h.n = -mm*rs;\n\n        //find all 8 corner states\n        /*vec3 offsets = vec3(-1.,0.,1);\n        int neighbormat; //TODO: force neighbor to be same material?\n        bool occ000 = occupancy(h.id, neighbormat) > 0.5;\n        bool occ001 = occupancy(h.id+offsets.yyx, neighbormat) > 0.5;\n        bool occ010 = occupancy(h.id+offsets.yxy, neighbormat) > 0.5;\n        bool occ011 = occupancy(h.id+offsets.yxx, neighbormat) > 0.5;\n        bool occ100 = occupancy(h.id+offsets.xyy, neighbormat) > 0.5;\n        bool occ101 = occupancy(h.id+offsets.xyx, neighbormat) > 0.5;\n        bool occ110 = occupancy(h.id+offsets.xxy, neighbormat) > 0.5;\n        bool occ111 = occupancy(h.id+offsets.xxx, neighbormat) > 0.5;*/\n\n        vec3 offsets = vec3(-1.,0.,1);\n        int neighbormat[4];\n        bool occs[4];\n        occs[0] = occupancy(h.id, neighbormat[0]) > 0.5; //00\n        occs[1] = occupancy(h.id+offsets.yxy, neighbormat[1]) > 0.5; //01\n        occs[2] = occupancy(h.id+offsets.xyy, neighbormat[2]) > 0.5; //10\n        occs[3] = occupancy(h.id+offsets.xxy, neighbormat[3]) > 0.5; //11\n        if (occs[0] || occs[1] || occs[2] || occs[3]) {\n            for (int k=0; k<4; k++) {\n                if (occs[k]) {\n                    h.mat = neighbormat[k];\n                    break;\n                }\n            }\n            vec3 mini = (h.id-ro + 0.5 - 0.5*vec3(rs))*ri;\n            float t_enter = max ( mini.x, max ( mini.y, mini.z ) );\n            vec3 maxi = (h.id-ro + 0.5 + 0.5*vec3(rs))*ri;\n            float t_exit = min ( maxi.x, min ( maxi.y, maxi.z ) );\n            \n            float dt = t_exit - t_enter;\n            \n            //raymarch\n            float t = 0.0;\n            vec3 eye = ro + rd * t_enter - h.id;\n            for (int i=0; i<MAXSTEP; i++) {\n                vec3 modpos2 = eye + rd*t;\n                float height = map(modpos2, occs[0], occs[1], occs[2], occs[3]);\n                t += height;\n                if (abs(height) < TOL) {\n                    h.t = t_enter + t;\n                    h.n = getnormal(eye + rd * t, occs[0], occs[1], occs[2], occs[3]);\n                    return h;\n                } else if (t < 0.0) {\n                    h.t = t_enter + t;\n                    return h;\n                } else if (t > dt) break;\n            }\n            h.t = t_exit;\n    \t}\n    }\n    \n    \n\t     \n    return h;\n}\n\n/*vec2 raymarch(in vec3 ro, in vec3 rd) {\n    float t = 0.0;\n    for (int i=0; i<MAXSTEP; i++) {\n        vec3 pos = eye + rd*t;\n        float dist = map(pos);\n        t += dist;\n        if (abs(dist) < TOL) {\n            return vec2(t, 1.0);\n        } else if (t > MAXDIST) break;\n    }\n    return vec2(t, 0.0);\n}*/\n\n#define sampleTriplanar(dir2, pos, tex) dir2.x * texture(tex, pos.yz).xyz + dir2.y * texture(tex, pos.zx).xyz + dir2.z * texture(tex, pos.xy).xyz\n\nvec3 shade(in vec3 n, in int mat, in vec3 pos, in vec3 lightpos) {\n    vec3 n2 = n*n;\n    vec3 albedo = vec3(0.);\n    if (mat == 0) {\n        return vec3(0.);\n    }\n    else if (mat == 1) {\n        albedo = sampleTriplanar(n2, (pos/5.), iChannel0);\n    } else if (mat == 2) {\n        albedo = sampleTriplanar(n2, pos, iChannel1);\n    } else {\n        albedo = sampleTriplanar(n2, (pos/10.), iChannel2);\n    }\n    vec3 lightdiff = lightpos - pos;\n    float lightdist = length(lightdiff);\n    lightdiff /= lightdist;\n    float lightfac = max(0., dot(lightdiff, n)) / (lightdist * lightdist) * 10.;\n    return albedo * lightfac;\n    // n*.25+.25 + vec3(mat)/4.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mouseY = iMouse.y < 1. ? 0. : (0.5-iMouse.y/iResolution.y) * PI;\n    float mouseX = iMouse.x < 1. ? iTime*0.25 : -(iMouse.x/iResolution.x) * 2. * PI;\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n\tvec3 eye = vec3(PERIOD*0.6, iTime * 9., 6.1);\n    vec3 w = vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), -sin(mouseY));\n    vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(FDIST*w + uv.x*u + uv.y*v);\n    \n    Hit h = voxtrace(eye, rd);\n    vec3 pos = eye + rd * h.t;\n    vec3 col = shade(h.n, h.mat, pos, eye);\n    fragColor = vec4(pow(col, vec3(GAMMA)), 1.);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtscWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[232, 232, 259, 259, 312], [314, 314, 339, 460, 1283], [1285, 1285, 1323, 1323, 1394], [1400, 1400, 1442, 1442, 2278], [2280, 2280, 2351, 2351, 3080], [3082, 3082, 3155, 3155, 3494], [3496, 3496, 3534, 3534, 6288], [6754, 6754, 6820, 6820, 7414], [7416, 7416, 7473, 7473, 8121]], "test": "untested"}
{"id": "ftGSWz", "name": "10 PRINT CHR$(205.5+RND(1)", "author": "mrange", "description": "CC0 - 10 PRINT CHR$(205.5+RND(1)); : GOTO 10\nAttempting to recreate the classic C64 truchet pattern\nCan be found here for example: https://en.wikipedia.org/wiki/Truchet_tiles\n", "tags": ["c64", "truchet"], "likes": 8, "viewed": 340, "published": 3, "date": "1640442157", "time_retrieved": "2024-07-30T18:40:20.337321", "image_code": "// CC0 - 10 PRINT CHR$(205.5+RND(1)); : GOTO 10\n//  Attempting to recreate the classic C64 truchet pattern\n//  Can be found here for example: https://en.wikipedia.org/wiki/Truchet_tiles\n\n// While very simple (especially the C64 version) the labyrinth it creates is fascinating.\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n\nfloat hash(vec2 p) {\n  float a = dot(p, vec2 (127.1, 311.7));\n  return fract(sin (a)*43758.5453123);\n}\n\nfloat cell_df(vec2 np, vec2 mp, vec2 off) {\n  const vec2 n0 = normalize(vec2(1.0, 1.0));\n  const vec2 n1 = normalize(vec2(-1.0, 1.0));\n\n  np += off;\n  mp -= off;\n  \n  float hh = hash(np);\n  vec2 n = hh > 0.5 ? n0 : n1;\n  vec2 t = vec2(n.y, -n.x);\n\n\n  vec2  p0 = mp;  \n  p0 = abs(p0);\n  p0 -= 0.5;\n  float d0 = length(p0)-0.0;\n\n  vec2  p1 = mp;\n  float d1 = dot(n, p1);\n  float px = dot(t, p1);\n  d1 = abs(px) > sqrt(0.5) ? d0 : abs(d1); \n\n  float d = d0;\n  d = min(d, d1);\n  \n  return d;\n}\n\nfloat truchet_df(vec2 p) {\n  vec2 np = floor(p+0.5);\n  vec2 mp = fract(p+0.5) - 0.5;\n  float d = 1E6;\n  const float off = 1.0;\n  for (float x=-off;x<=off;++x) {\n    for (float y=-off;y<=off;++y) {\n      vec2 o = vec2(x,y);\n      d = min(d,cell_df(np, mp, o));\n    }\n  }\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n  \n  float a = 0.1*TIME;\n  float z = mix(0.125, 0.25, 0.5+0.5*sin(sqrt(1.0/3.0)*a))*0.5;\n  p /= z;\n  p += 20.0*sin(vec2(sqrt(0.5)*a, a));\n  float d = truchet_df(p);\n  d -= 0.1;\n  d *= z;\n\n  const vec3 bgcol = vec3(68.0, 71.0, 226.0)/vec3(255.0);\n  const vec3 fgcol = vec3(164.0, 166.0, 251.0)/vec3(255.0);\n\n  vec3 col = bgcol;\n  col = mix(col,  fgcol, smoothstep(aa, -aa, d));\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGSWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 338, 358, 358, 440], [442, 442, 485, 485, 931], [933, 933, 959, 959, 1216], [1218, 1218, 1273, 1273, 1810]], "test": "untested"}
{"id": "ftGSWR", "name": "Grid random no bitwise", "author": "ersteller", "description": "I was looking for some random pixelated color grid. \nThis is what i was aiming for. Now without bitwise operations, so it can run with glslCanvas from\nhttps://thebookofshaders.com/", "tags": ["grid", "color", "random", "4bit"], "likes": 1, "viewed": 215, "published": 3, "date": "1640438040", "time_retrieved": "2024-07-30T18:40:21.102309", "image_code": "// grid dimensions\n#define GRID vec2(16,9)\n\n// number of bits used for each color channel\n// max 8 bits (otherwise the masks will overlapp)\n#define BITS 1.\n\n\nfloat random(float co){\n    return fract(sin(co)*33333.);\n}\n\n// uv input 0 to 1\nvec3 getRandomGridColor( in vec2 uv , in vec2 grid_size, float bits )\n{\n \n    // we use time fraction for random val\n    int frac = int(fract(iTime)*4095.);        \n    \n    // transform to grid pos\n    vec2 fetch_pos = vec2( uv * grid_size);\n    // quantize with int() and convert x y to an index \n    int idx = int(fetch_pos.x) + ( int(grid_size.y) - 1 - int(fetch_pos.y)) * int(grid_size.x);\n       \n    float seed = float( frac + idx);\n    \n    return vec3( \n        floor(random(3. * seed)* (bits+1.))  / bits , \n        floor(random(11. * seed)* (bits+1.)) / bits ,\n        floor(random(13. * seed)* (bits+1.)) / bits \n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // get random color in a grid\n    vec3 col = getRandomGridColor(uv, GRID, BITS);\n        \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGSWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 181, 181, 217], [873, 873, 930, 980, 1177]], "test": "untested"}
{"id": "7tKXzm", "name": "Grid random bit color", "author": "ersteller", "description": "I was looking for some random pixelated color grid. \nThis is what i was aiming for. \n\nSadly this only works in 3.0 and above :(", "tags": ["grid", "color", "random", "hash", "4bit", "bitwiseoperation"], "likes": 2, "viewed": 208, "published": 3, "date": "1640427389", "time_retrieved": "2024-07-30T18:40:21.864238", "image_code": "// grid dimensions\n#define GRID vec2(16,9)\n\n// number of bits used for each color channel\n// max 8 bits (otherwise the masks will overlapp)\n#define BITS 1\n\n\n// https://stackoverflow.com/Questions/4200224/random-noise-functions-for-glsl\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nint hash( int x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// uv input 0 to 1\nvec3 getRandomGridColor( in vec2 uv , in vec2 grid_size, int bits)\n{\n \n    // we use time fraction for random val\n    int frac = int(fract(iTime)*4095.);        \n    \n    // transform to grid pos\n    vec2 fetch_pos = vec2( uv * grid_size);\n    // quantize with int() and convert x y to an index \n    int idx = int(fetch_pos.x) + ( int(grid_size.y) - 1 - int(fetch_pos.y)) * int(grid_size.x);\n\n    // random value for each square\n    int rand = hash(idx + frac);\n    \n    // mask bits from the random value, shift and normalize each channel\n    int basemask = 0xff >> (8 - bits); // create a base bitmask\n    int rmask = basemask; \n    int gmask = basemask << 8;\n    int bmask = basemask << 16;\n    \n    return vec3( \n        float( rand & rmask)        / float(basemask), \n        float((rand & gmask) >> 8)  / float(basemask), \n        float((rand & bmask) >> 16) / float(basemask)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // get random color in a grid\n    vec3 col = getRandomGridColor(uv, GRID, BITS);\n        \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKXzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 307, 326, 326, 457], [1371, 1371, 1428, 1478, 1675]], "test": "untested"}
{"id": "7lVXzw", "name": "eindacor_spiralwave", "author": "Eindacor_DS", "description": "Spirals, ya dig?", "tags": ["spiral"], "likes": 1, "viewed": 225, "published": 3, "date": "1640411427", "time_retrieved": "2024-07-30T18:40:22.612239", "image_code": "#define TWOPI 6.28318530718f\n#define AA 0.001f\n\n#define CYAN vec3(0., .2, .2)\n#define MAGENTA vec3(.2, 0., .2)\n#define YELLOW vec3(.2, .2, 0.)\n#define BLACK vec3(0.)\n\n\nfloat getHoldTransitionValue(float lower, float upper, float holdTime, float transitionTime, float time) {\n    float period = 2. * holdTime + 2. * transitionTime;\n    float halfPeriod = period / 2.;\n    float relativeTime = fract(time / halfPeriod);\n    float halfHoldTime = holdTime / 2.;\n    \n    float val = smoothstep(halfHoldTime, halfHoldTime + transitionTime, relativeTime * halfPeriod);\n    \n    if (int(time / halfPeriod) % 2 == 0) {\n        val = 1. - val;\n    }\n\n    return mix(lower, upper, val);\n}\n\nfloat getOffsetAngle(vec2 first, vec2 second) {\n    vec2 offsetVec = second - first;\n    float angle = atan(offsetVec.y / offsetVec.x);\n    \n    \n    if (first.x < second.x) {\n        angle = TWOPI / 2.f + angle;\n    } else if (first.y > second.y) {\n        angle = TWOPI + angle;\n    }\n    \n    return angle;\n}\n\nfloat getRadialVal(vec2 p1, vec2 p2) {\n    float offsetAngle = getOffsetAngle(p1, p2);\n    offsetAngle = mod(TWOPI - offsetAngle + 3.f * TWOPI / 6.f, TWOPI);\n    return offsetAngle / TWOPI;\n}\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n    \n    float bandWidth = getHoldTransitionValue(0.1, .5, 0., 45., iTime);\n    \n    vec2 center = vec2(.5 * aspectRatio, .5);\n    \n    uv = (uv - center) * createRotationMatrix(TWOPI / 4. + iTime * .3) + center;\n    \n    float angle = asin((uv.y - center.y)/distance(uv, center));\n    \n    float sinModCoeff = getHoldTransitionValue(0., .02, 3., 10., iTime);\n    \n    float radialVal = getRadialVal(center, uv);\n    float dist = distance(uv, center) + bandWidth * radialVal + sin((radialVal + iTime * .05) * TWOPI * 10.) * sinModCoeff; \n    float dist2 = distance(uv, center) + bandWidth * -radialVal + sin((radialVal + iTime * .05) * TWOPI * 10.) * sinModCoeff; \n    \n    float val = pow(mod(dist, bandWidth) / bandWidth, 2.);\n    float val2 = pow(mod(dist2, bandWidth) / bandWidth, 2.);\n    \n    float coeff = getHoldTransitionValue(1., 3., 0., 26., iTime);\n    vec3 cyan = mix(vec3(1.), CYAN, getHoldTransitionValue(0., pow(val, coeff), 3., 10., iTime));\n    vec3 magenta = mix(vec3(1.), MAGENTA, getHoldTransitionValue(0., pow(val2, coeff), 3., 10., iTime + 13.));\n   \n    // Output to screen\n    vec3 modColor = vec3(1., .95, .8);\n    fragColor = vec4(cyan * magenta * modColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVXzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 274, 274, 678], [680, 680, 727, 727, 991], [993, 993, 1031, 1031, 1184], [1186, 1186, 1231, 1231, 1335], [1337, 1337, 1394, 1444, 2761]], "test": "untested"}
{"id": "ftVXRm", "name": "Simple Radial Spectrum Analyzer", "author": "qtiki", "description": "Radial version of the simple spectrum analyzer implementation.", "tags": ["audio", "spectrumanalyzer"], "likes": 2, "viewed": 420, "published": 3, "date": "1640388475", "time_retrieved": "2024-07-30T18:40:23.361236", "image_code": "const vec3 BAR_COLOR = vec3(0.8, 0.2, 0.3);\nconst float BAR_COUNT = 20.0;\nconst float BAR_WIDTH = 0.6;\n\nconst float BAR_START = 0.15;\nconst float BAR_END = 0.5;\n\n// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\nconst float FREQ_COUNT = 512.0;\n\nconst float PI = 3.14159265359;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv -= 0.5;\n    uv.x *= aspect;\n\n    float side = sign(uv.x);\n    float angle = -(atan(uv.y, uv.x * side) + PI/2.0) * side + PI;\n    float angleNormalized = angle / (2.0*PI);\n    \n    float dist = length(uv);\n\n    float barIndex = floor(angleNormalized * BAR_COUNT);\n    float barHeight = texelFetch(iChannel0, ivec2(barIndex * FREQ_COUNT / BAR_COUNT, 0), 0).r;\n    float barEndDist = BAR_START + barHeight * (BAR_END - BAR_START);\n    \n    float horizontal = smoothstep(1.0 - BAR_WIDTH, 1.0 - BAR_WIDTH, abs(sin(angleNormalized * PI * BAR_COUNT)));\n    float innerCircle = smoothstep(BAR_START, BAR_START, dist);\n    float outerCircle = 1.0 - smoothstep(barEndDist, barEndDist, dist);\n\n    // Output to screen\n    fragColor = vec4(BAR_COLOR * horizontal * innerCircle * outerCircle, 1.0);\n}\n", "image_inputs": [{"id": 18, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVXRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[308, 308, 363, 363, 1300]], "test": "untested"}
{"id": "slVXRz", "name": "Christmas Stars", "author": "mla", "description": "Some more stars. Happy Christmas (or celebration of your choice) to all.\n\nMouse sets polygon parameters (or press 'm' to stay with animation).", "tags": ["polygon", "winding", "isogonal", "isotoxal"], "likes": 18, "viewed": 419, "published": 3, "date": "1640381137", "time_retrieved": "2024-07-30T18:40:24.122201", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Christmas Stars, Matthew Arcus, mla, 2021\n//\n// More polygons, coloured according to winding number.\n// Now varying radius of the two sets of points as well as\n// the relative offset.\n//\n// <mouse>: sets N,M parameters (unless m pressed)\n// m: disable mouse action\n// c: colouring\n// h: hatching\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Two sets, A, B, of N evenly spaced points around the unit circle.\n// Connect A[i] to B[i] and B[i] to A[i+M]\n\nint N = 17; // 2N points\nint M = 7;  // Connect every M points\n\nfloat time;\n\nvec2 getpoint(int index,int parity) {\n  float theta = float(index)*PI/float(N);\n  float r = 1.0;\n  if (parity != 0) {\n    theta += 2.1*PI*time;\n    r = -1.5*cos(2.0*PI*time);\n  }\n  vec2 p = vec2(cos(theta),sin(theta));\n  //p /= max(abs(p.x),abs(p.y));\n  return r*p;\n}\n\n// Winding number - straight out of Numerical Recipes, streamlined\n// a little, and also getting distance to line.\nint polywind(vec2 p, inout float d) {\n  int wind = 0;\n  vec2 q = getpoint(0,0)-p;\n  int offset = 0;\n  for (int i = 1; i <= 2*N; i++) {\n    int index = (M*i)%(2*N);\n    vec2 r = getpoint(index+offset,i&1)-p;\n    d = min(d,segment(q,r));\n    float t = determinant(mat2(q,r));\n    if (q.y <= 0.0) {\n      if (r.y > 0.0 && t > 0.0) wind++;\n    } else {\n      if (r.y <= 0.0 && t < 0.0) wind--;\n    }\n    if (index == 0 && (i&1)==0) {\n      offset += 2;\n      r = getpoint(offset,0)-p;\n    }\n    q = r;\n  }\n  d = sqrt(d);\n  return wind;\n}\n\nvec3 getcol(int i) {\n  vec3 col = vec3(1);\n  // Seasonal colours from https://www.schemecolor.com/\n  if (i == 3) col = vec3(135,10,30)/255.0;\n  else if (i == 1) col = vec3(255,194,70)/255.0;\n  else if (i == 2) col = vec3(92,134,10)/255.0;\n  else if (i == 0) col = vec3(199,52,8)/255.0;\n  else if (i == 4) col = vec3(0,93,0)/255.0;\n  col = pow(col,vec3(2.2));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  time = 0.1*iTime;\n  vec2 p = 1.1*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n  //p /= 2.0*dot(p,p);\n  vec2 mouse = vec2(0);\n  float mgrid = 40.0;\n  M = int(time+0.25);\n  if (!key(CHAR_M) && iMouse.x > 0.0) {\n    N = 3+int(mgrid*iMouse.x/iResolution.x);\n    M = int(mgrid*iMouse.y/iResolution.y);\n  }\n  M = 1+(M%(N-1));\n  p = p.yx; // Flip x and y\n  float px = fwidth(p.x);\n  vec3 col = vec3(1,1,0.6);\n  float d = 1e8;\n  int wind = polywind(p,d);\n  if (!key(CHAR_C) && (wind&1) != 0) col = getcol(abs(wind>>1));\n  vec3 tex = texture(iChannel0,fragCoord/iResolution.x).xyz;\n  col = mix(vec3(0),col,smoothstep(-px,px,d-0.01*(0.5+0.5*dot(tex,tex))));\n  if (key(CHAR_H) && (wind&1) != 0) {\n    // Hatching\n    float d = fract(30.0*(length(p))-2.0*atan(p.y,p.x)/TWOPI);\n    d = min(d,1.0-d);\n    d /= 30.0;\n    float hwidth = 0.005*(0.5+dot(tex,tex));\n    col = mix(vec3(0),col,smoothstep(-px,px,d-hwidth));\n  }\n  col *= 0.5+0.5*sqrt(tex);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159;\nconst float TWOPI = 2.0*PI;\n\nfloat segment(vec2 a, vec2 b) {\n  b -= a;\n  float h = -dot(a,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  a+=b*h;\n  return dot(a,a);\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// Macros for use in \"common\" blocks.\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVXRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[658, 658, 695, 695, 925], [927, 1042, 1079, 1079, 1575], [1577, 1577, 1597, 1597, 1951], [1953, 1953, 2006, 2006, 3004]], "test": "untested"}
{"id": "NlKSzw", "name": "whirlpool sucky thing", "author": "SnoopethDuckDuck", "description": "idk whyat this is", "tags": ["raymarching", "template", "artofcode"], "likes": 5, "viewed": 278, "published": 3, "date": "1640373936", "time_retrieved": "2024-07-30T18:40:24.875188", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define pi 3.14159\n\n#define MAX_STEPS 100\n#define MAX_DIST 4.5\n#define SURF_DIST .01\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n} \n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 p) {\n    return max(max(abs(p.x), abs(p.y)), abs(p.z));\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat GetDist(vec3 p) {\n    float sc = 6.;\n    \n    float a = atan(p.z, p.x);\n    \n    float r1 = 5.;\n    float r2 = 1.5;\n    \n    float d1 = length(p.xz) - r1;\n    float d2 = length(vec2(4.5 * p.y, d1)) - r2;\n    \n    float r = d2 / (0.5 + cos(0.3 * d1));\n    \n    float d0 = length(p - vec3(0,1,0)) - 1.45;\n    float d02 = length(p - vec3(0,sin(0.4 * iTime),0)) - 0.2;\n    \n    p.y += -1. + cos(0.2 * r + iTime)- thc(2., 0.4 * r);\n    p = vec3(length(p.xz) * 0.4 + a / pi, p.y, 0.1 * cos(r) * log(r) - 0.08 * iTime);\n    \n    vec2 ipos = floor(sc * p.xz) + 0.5;\n    vec2 fpos = fract(sc * p.xz) - 0.5; //cos(sc * p.xz / pi) - 0.5;\n    \n    //float d = -0.8 - 0.3 * cos(d1 * 20. * r * r- 10. *  iTime) + length(vec3(fpos.x, p.y, fpos.y));\n    float d = -0.8 + length(vec3(fpos.x, p.y, fpos.y));\n    \n    d = max(d, d0);\n    d = min(d, d02);\n    return 0.3 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y *.5 + .5;\n    \n    vec3 col = mix(vec3(.5,0.,0.),vec3(0.),k);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float time = 0.4 * iTime;\n\n    vec3 ro = vec3(1.5 * thc(2., -time), sin(time - 0.2) - 1. * thc(2., pi/2. + time) , 1.5 * thc(2., 0.5 * pi - time));\n\n    vec3 rd = GetRayDir(uv, ro, vec3(0,sin(time - 0.2),0), 0.5);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n    \n   \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 rf = refract(rd, n,0.5);\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = 0.5 * vec3(dif);\n        \n        float b = .5 + .5 * cos(iTime);\n        \n       // uv = fragCoord.xy / iResolution.xy;\n        col += texture(iChannel0, r).rgb;\n         \n        // not really ipos at all\n        float ipos = floor(10. * length(p) - 4. * iTime);\n        float h = h21(vec2(ipos));\n\n        col *= 1.2 + 0.2 *  h;\n       // col += 2.5 * p.y;\n       // col = clamp(col, 0., 1.);\n        col *= 1. - (1. - step(1.5, p.y)) * (smoothstep(-1.5, 1.5, -1.5 + length(p.xz)));\n        col *= 0.5 * (1. + cos(r));\n        \n        float e3 = p.y + 1.;\n        d = RayMarch(p + 1.* rd, vec3(0.00));\n        d = clamp(d, -1., 0.);\n      \n        col += 0.2 * \n        clamp(1./ (0.5 * d * (0.5 + 0.5 * cos(p.y * 10. + iTime)) * p.y),0.,1.);\n       // col += 0.5 * d * (0.5 + 0.5 * cos(p.y * 10. + iTime)) * p.y * col;\n          \n         vec3 e = vec3(1.);\n        float l = length(col);\n        col *= pal(length(p) * 0.2 + p.y, e, e, e, 0.5 * vec3(0.,0.33,0.66));\n        //col *= 0.9;\n    }\n    \n   \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    //col *= 2. * pal(uv.y + 0.1 * cos(10. * uv.x + iTime) + 0.2 * iTime, vec3(0.5), vec3(0.5), vec3(0.5), 0.5 * vec3(0.,0.33,0.66));;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKSzw.jpg", "access": "api", "license": "mit", "functions": [[1493, 1493, 1512, 1512, 1574], [1577, 1577, 1606, 1606, 1647], [1650, 1650, 1670, 1670, 1745], [1747, 1747, 1771, 1771, 1811], [1813, 1813, 1836, 1836, 1889], [1891, 1891, 1959, 1959, 2002], [2004, 2004, 2027, 2027, 2867], [2869, 2869, 2903, 2903, 3114], [3116, 3116, 3140, 3140, 3330], [3332, 3332, 3382, 3382, 3573], [3575, 3575, 3593, 3593, 3692], [3695, 3695, 3752, 3752, 5568]], "test": "untested"}
{"id": "slVXRD", "name": "Julnisse", "author": "eimink", "description": "A simple christmas elf! Happy holidays!", "tags": ["sdf"], "likes": 5, "viewed": 268, "published": 3, "date": "1640371068", "time_retrieved": "2024-07-30T18:40:25.627177", "image_code": "// Happy holidays!\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nvoid rot(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nstruct MarchResult\n{\n    vec3 p;\n    float id;\n};\n\n\nvec2 sdf(vec3 p){\n   vec3 pp = p;\n   \n   vec2 head = vec2(sdSphere(pp,1.),1.);\n   \n   pp = pp-vec3(0,.6,0);\n   vec2 hat = vec2(sdRoundCone(pp,.8,.1,1.5),2.);\n   head = opU(head,hat);\n   pp = p - vec3(1.,0.3,0.);\n   vec2 nose = vec2(sdSphere(pp,.3),3.);\n   head = opU(head,nose);\n   pp = p - vec3(0,-.13,0);\n   vec2 body = vec2(sdSphere(pp,1.01),2.);\n   body = opU(head,body);\n   pp = p - vec3(0.4,-.7,0.5);\n   rot(pp.xy,5.);\n   float rleg = sdRoundCone(pp,.2,.25,.7);\n   pp = p - vec3(0.4,-.7,-0.5);\n   rot(pp.xy,5.);\n   float lleg = sdRoundCone(pp,.2,.25,.7);\n   float legs = min(lleg,rleg);\n   body = opU(vec2(legs,2.),body);\n   pp = p - vec3(0.0,0.,0.7);\n   rot(pp.yz,-5.);\n   rleg = sdRoundCone(pp,.2,.25,.7);\n   pp = p - vec3(0.0,0.,-0.7);\n   rot(pp.yz,5.);\n   lleg = sdRoundCone(pp,.2,.25,.7);\n   legs = min(lleg,rleg);\n   body = opU(vec2(legs,2.),body);\n   \n   return body;\n\n}\n\nMarchResult march(in vec3 ro, in vec3 rd, inout float t){\n\n    MarchResult m;\n    m.p = ro+rd;\n    for(int i = 0; i < 40; ++i){\n        vec2 d = sdf(m.p);\n        t += d.x;\n        m.p += rd*d.x;\n        m.id = d.y;\n        \n        if(d.x < 0.01 || t > 100.){\n            break;\n        }\n        \n    }\n    \n    return m;\n}\n\nvec3 color(in float id, vec3 p)\n{\n    if (id == 1.0)\n        return vec3(.6,.25,.25)-(texture(iChannel0,p.yz*2.).xyz*.5);\n    else if (id == 2.0)\n        return vec3(.7,.2,.2)-texture(iChannel0,p.xz*4.).xyz*.15;\n    else if (id == 3.0)\n        return vec3(.6,.5,.5);\n    else\n        return vec3(0);\n}\n\nvec3 calcNormal( in vec3 pos) \n{\n    vec2 e = vec2(0.00001, 0.0);\n    return normalize( vec3(sdf(pos+e.xyy).x-sdf(pos-e.xyy).x,\n                           sdf(pos+e.yxy).x-sdf(pos-e.yxy).x,\n                           sdf(pos+e.yyx).x-sdf(pos-e.yyx).x ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 cp = vec3(3.,2.0,3.);\n    vec3 ct = vec3(0,0,0);\n    vec3 ld = vec3(-2.,0.5,2.);\n    rot(cp.xz,iTime);\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 cf = normalize(ct-cp);\n    vec3 cr = normalize(cross(vec3(0.0,1.0,0.0),cf));\n    vec3 cu = normalize(cross(cf,cr));\n    \n    vec3 rd = normalize(mat3(cr,cu,cf)*vec3(q,radians(90.0)));\n    \n    vec3 p = vec3(0.0);\n    \n    float t;\n    MarchResult m;\n    m.p = vec3(0.0);\n    m.id = 0.0;\n    m = march(cp,rd,t);\n    \n    vec3 col = vec3(0.0);\n    if(t < 100.){\n        col = color(m.id,m.p) + (clamp(dot(calcNormal(m.p), ld), 0.0, 1.0)*0.1);\n        \n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVXRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 51, 51, 138], [140, 140, 173, 173, 197], [199, 199, 257, 257, 521], [523, 523, 556, 556, 601], [603, 603, 631, 631, 669], [723, 723, 740, 740, 1606], [1608, 1608, 1665, 1665, 1933], [1935, 1935, 1968, 1968, 2236], [2238, 2238, 2270, 2270, 2495], [2497, 2497, 2554, 2554, 3287]], "test": "untested"}
{"id": "NlKSRw", "name": "Simple Spectrum Analyzer", "author": "qtiki", "description": "Simple spectrum analyzer implementation.", "tags": ["audio", "spectrumanalyzer"], "likes": 4, "viewed": 381, "published": 3, "date": "1640361658", "time_retrieved": "2024-07-30T18:40:26.381162", "image_code": "const vec3 BAR_COLOR = vec3(0.8, 0.2, 0.3);\nconst float BAR_COUNT = 20.0;\nconst float BAR_WIDTH = 0.75;\n\n// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\nconst float FREQ_COUNT = 512.0;\n\nconst float PI = 3.14159265359;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float barIndex = floor(uv.x * BAR_COUNT);\n    float barHeight = texelFetch(iChannel0, ivec2(barIndex * FREQ_COUNT / BAR_COUNT, 0), 0).r;\n    \n    float horizontal = smoothstep(1.0 - BAR_WIDTH, 1.0 - BAR_WIDTH, abs(sin(uv.x * PI * BAR_COUNT)));\n    float vertical = smoothstep(1.0 - barHeight, 1.0 - barHeight, 1.0 - uv.y);\n    \n    // Output to screen\n    fragColor = vec4(BAR_COLOR * horizontal * vertical, 1.0);\n}\n", "image_inputs": [{"id": 18, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKSRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 251, 306, 356, 817]], "test": "untested"}
{"id": "7lGXzm", "name": "shader santa", "author": "yasuo", "description": "my original sketch", "tags": ["santa"], "likes": 22, "viewed": 360, "published": 3, "date": "1640359584", "time_retrieved": "2024-07-30T18:40:27.130159", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p.x)-s.x,abs(p.y)-s.y)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\nvec3 santa(vec2 p, vec3 col){\n    vec2 prevP = p;\n    \n    // shadow\n    p.x*=0.5;\n    p.y*=1.5;\n    p.y+=0.5;\n    float d = length(p)-0.2;\n    col = mix(col,vec3(0.0),S(d,-0.3));     \n    \n    // body\n    p = prevP;\n    d = B(p,vec2(0.2,0.17));\n    p.x = abs(p.x)-0.15;\n    float a = radians(10.0);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    float d2 = d;\n    col = mix(col,vec3(0.7,0.0,0.0),S(d,0.0));\n    \n    d = max(p.y+0.13,d);\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    d2 = max(abs(p.y+0.08)-0.016,d2);\n    col = mix(col,vec3(0.0),S(d2,0.0));   \n    \n    p = prevP;\n    p.y+=0.078;\n    d = abs(B(p,vec2(0.03,0.02)))-0.005;\n    col = mix(col,vec3(0.7,0.7,0.3),S(d,0.0)); \n    p = prevP;\n    \n    // legs\n    p.x = abs(p.x)-0.12;\n    p.y+=0.25;\n    d = B(p,vec2(0.01,0.08));\n    col = mix(col,vec3(0.7,0.0,0.0),S(d,0.0));\n    \n    p.y+=0.05;\n    d = B(p,vec2(0.01,0.03));\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p.x-=0.02;\n    p.y+=0.02;\n    d = B(p,vec2(0.02,0.01));\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    // arm\n    p = prevP;\n    p.x = abs(p.x)-0.21;\n    \n    float frame = mod(iTime,1.);\n    if(frame<0.5){\n        p.y-=0.05;\n        p*=Rot(radians(-60.0));\n    } else {\n        p.y-=0.13;\n        p*=Rot(radians(-120.0));\n    }\n    \n    d = B(p,vec2(0.01,0.1));\n    col = mix(col,vec3(0.7,0.0,0.0),S(d,0.0));\n    \n    p.y+=0.12;\n    d = B(p,vec2(0.01,0.02));\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p.x-=0.015;\n    p.y-=0.008;\n    d = B(p,vec2(0.005,0.007));\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    // face and head\n    p = prevP;\n    p.y-=0.17;\n    p.y*=0.8;\n    d = length(p)-0.14;\n    col = mix(col,vec3(1.0),S(d,0.0));    \n    \n    p = prevP;\n    p.y-=0.25;\n    p.y*=1.25;\n    d = length(p)-0.125;\n    col = mix(col,vec3(0.9,0.7,0.6),S(d,0.0));\n    \n    // face details\n    p = prevP;\n    p.y-=0.2;\n    p.x = abs(p.x)-0.07;\n    p*=Rot(radians(10.0));\n    p.x*=0.7;\n    p.y*=0.9;\n    d = length(p)-0.08;\n    p.y-=0.07;\n    d2 = length(p)-0.08;\n    d = max(-d2,d);\n    col = mix(col,vec3(.99,0.95,0.8),S(d,0.0));\n    p = prevP;\n    p.y-=0.21;\n    p.y*=1.5;\n    d = length(p)-0.03;\n    col = mix(col,vec3(.8,0.6,0.5),S(d,0.0));\n    p = prevP;\n    p.y-=0.13;\n    p.y*=0.8;\n    d = length(p)-0.01;\n    col = mix(col,vec3(.5,0.2,0.2),S(d,0.0));\n    \n    p = prevP;\n    p.x = abs(p.x)-0.07;\n    p.y-=0.255;\n    p*=Rot(radians(20.0));\n    p.y*=2.5; \n    \n    d = length(p)-0.04;\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    p = prevP;\n    p.x = abs(p.x)-0.04;\n    p.y-=0.235;\n    d = length(p)-0.008;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    // hat\n    p = prevP;\n    p.y-=0.43;\n    d = B(p,vec2(0.15,0.12));\n    a = radians(10.);\n    p.x+=0.13;\n    d = max(-dot(p,vec2(cos(a),sin(a))),d);\n    p = prevP;\n    a = radians(52.);\n    p.y-=0.43;\n    p.x+=0.04;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    col = mix(col,vec3(0.7,0.0,0.0),S(d,0.0));\n    p = prevP;\n    p.y-=0.3;\n    d = B(p,vec2(0.12,0.02));\n    col = mix(col,vec3(1.0),S(d,0.0));\n    p.x+=0.14;\n    p.y-=0.21;\n    d = length(p)-0.03;\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    return col;\n}\n\nfloat snowflake(vec2 p){\n    p*=Rot(radians(iTime*30.0));\n    p = DF(p,1.5);\n    p -= vec2(0.04);\n    p*=Rot(radians(45.0));\n    \n    float d = B(p,vec2(0.003,0.055));\n    p.x = abs(p.x)-0.01;\n    p*=Rot(radians(-25.0));\n    d = min(B(p,vec2(0.02,0.003)),d);\n    p.y-=0.025;\n    d = min(B(p,vec2(0.02,0.003)),d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 prevP = p;\n    \n    vec3 col = vec3(0.8);\n    \n    p.y-=0.15;\n    p.x = abs(p.x)-0.5;\n    p.x*=1.5+cos(iTime*6.0)*0.05;\n    p.y*=1.5+sin(iTime*6.0)*0.03; \n    \n    col = santa(p-vec2(0.0,-0.1),col);\n    \n    p = prevP;\n    p.x*=1.0+cos(iTime*6.0)*0.05;\n    p.y*=1.0+sin(iTime*6.0)*0.03; \n    \n    col = santa(p-vec2(0.0,-0.1),col);\n    \n    p = prevP;\n    p*=2.0;\n    p.x += -1.75;\n    p.x+=sin(iTime*0.5)*2.0;\n    for(int i = 1; i<=20; i++){\n\t\tvec3 pt = vec3(0);\n\t\tp.x += float(i)/20.0*0.6;\n\t\tp.y += mod((iTime*0.1)+float(i),4.0)-2.0;\n        float d = snowflake(p);\n        col = mix(col, vec3(1.0),S(d,0.0));\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGXzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[326, 326, 355, 355, 3445], [3447, 3447, 3471, 3471, 3775], [3777, 3777, 3834, 3834, 4558]], "test": "untested"}
{"id": "slyXzw", "name": "Doors_lesson-127", "author": "xlat", "description": "Very simple.", "tags": ["fragmentshader"], "likes": 2, "viewed": 223, "published": 3, "date": "1640352037", "time_retrieved": "2024-07-30T18:40:27.886138", "image_code": "///----------------------------------------------------------------------------|\n/// XLAT\n/// Doors_lesson-127\n///----------------------------------------------------------------------------:\n/// (...   ,     ...)\n///----------------------------------------------------------------------------:\n\n///------------------------|\n/// Config.                |\n///------------------------:\nconst float RADIUSS  =  0.7;\nconst float NSEC     = 18.0;\n      float SPEED    =  0.2;\n///------------------------.\n\nconst vec4  WHITE    = vec4(0.9, 0.9, 0.9, 1.);\nconst vec4  BLUE     = vec4(0.0, 0.0, 0.6, 1.);\nconst vec4  RED      = vec4(0.6, 0. , 0. , 1.);\nconst vec4  BGROUND  = vec4(0.0, 0.0, 0.2, 1.);\nconst vec4  YELLOW   = vec4(0.0, 0.0, 0.0, 1.);\n\nconst float PIx2     = 6.2831853;\n\n/// not use\nvec4 tonsin(float minn, float maxx, float a)\n{   a = a - minn;\n    float x = 1.57 / (maxx - minn);\n    float c  = 0.3  * cos(a * x);\n    return vec4(c, c, c, .8);\n}\n\nfloat distance_x2(vec2 p1, vec2 p2)\n{   vec2   dp = p1 - p2;\n    return dp.x * dp.x + dp.y * dp.y;\n}\n\nbool isCircle(vec2 p, float radius)\n{   float d = distance_x2(p, vec2(0., 0.));\n    float r = radius * radius;\n    if( d < r && d > r * 0.8 ) return true ;\n                               return false;\n}\n\n#define step_t vec2\n\nfloat Speed ;\nfloat Speed1;\nfloat Speed2;\nfloat RADIUS;\n\n#define SIN  sin(Speed)\n#define SIN1 sin(Speed1)\n#define SIN2 sin(Speed2)\n#define COS  cos(Speed) \n#define COS1 cos(Speed1)\n#define COS2 cos(Speed2)\n\n#define STEP(amplitude_x, speed_x, amplitude_y, speed_y) step_t( \\\n                              -abs(amplitude_x * sin(speed_x)),  \\\n                                   amplitude_y * sin(speed_y))\n\n///----------------------------------------------|\n/// Lept\n///----------------------------------------------:\nstruct Lept\n{   int   i          ;\n    float radius     ;\n    float radiusintro;\n    vec2  pos        ;\n    float speedx     ;\n    float speedy     ;\n    float speedr     ;\n    int   modecolor  ;\n    vec3  colorinit  ;\n};\n\n///----------------------------------------------|\n/// Common lib.\n///----------------------------------------------:\nvec2 rot(vec2 p, float a)\n{   return vec2( p.x * cos(a) - p.y * sin(a),\n                 p.x * sin(a) + p.y * cos(a) );\n}\n\nfloat getAngle(vec2 pos)\n{   vec2 p = normalize(pos);\n    if(p.y > 0.0) return acos(p.x);\n    else          return PIx2 - acos(p.x);\n}\n\nconst int       AMOUNT_LEPTS = 2;\nLept      lepts[AMOUNT_LEPTS];\nvoid init_lepts()\n{   \n    lepts[0] = Lept(0, 0.1 , 0.8, vec2( 0.3, 0.1), 0.9, 1.0, 1.1, 3,\n                                  vec3( 0.3, 0.3 , 0.3));\n                                  \n    lepts[1] = Lept(1, 0.08, 0.5, vec2( 0.1,-0.1), 1.2, 1.2, 1.0, 2,\n                                  vec3( 0.3, 0.3 , 0.3));\n}\n        \nvec3 move_lept(int i, inout vec2 pixel)\n{   \n    vec3 colorresult = vec3(-1.0);\n    if(isCircle(pixel + STEP(0.1, lepts[i].speedx * SIN2 - 0.2 * SIN,\n                             0.2, lepts[i].speedy * COS1 - 0.1 * COS),\n                                  lepts[i].radius * SIN + lepts[i].radius + 0.05))\n    {   if(1 == lepts[i].modecolor)\n        {\n            colorresult.r = lepts[i].colorinit.r * COS + 0.7;\n            colorresult.g = lepts[i].colorinit.g * SIN + 0.7;\n            colorresult.b = 0.0;\n        }\n        else if(2 == lepts[i].modecolor)\n        {\n            colorresult.r = lepts[i].colorinit.r * COS + 0.7;\n            colorresult.g = 0.0;\n            colorresult.b = lepts[i].colorinit.b * SIN + 0.7;\n        }\n        else if(3 == lepts[i].modecolor)\n        {\n            colorresult.r = 0.0;\n            colorresult.g = lepts[i].colorinit.g * COS + 0.7;\n            colorresult.b = lepts[i].colorinit.b * SIN + 0.7;\n        }\n    }\n    return colorresult;\n  //return BLUE;\n}\n\nvec4 flower(vec2 pixel)\n{   for(int i = 0; i < AMOUNT_LEPTS; ++i)\n    {   vec3 color   = move_lept(i, pixel);\n        if(  color.r > -1.0)\n        {   return vec4(color, 1.0);\n        }\n    }\n    return vec4(-1.0);\n    //return BLUE;\n}\n\n#define NO if(false)\n\nvec4 colorSectors(vec2 pos)\n{\n    pos = rot(pos - 0.5, Speed);\n\n    if(RADIUS * RADIUS < pos.x * pos.x + pos.y * pos.y) return BGROUND;\n\n    float asector = PIx2 / NSEC  ;\n    float a       = getAngle(pos);\n\n    for(float i = asector, j = 0.; i < PIx2; i += asector, j += 1.)\n    {\n        if(a < i)\n        {   \n            if(mod(j, 2.) == 0.)\n            {\n                vec4 color = flower(rot(pos, -i));\n                if(color.a > 0.)\n                {   return color + vec4( 0., 0., fract(a)/3., 0.);\n                }\n            }\n            else\n            {   float t =  i - asector - a - a;\n                vec4 color = flower(rot(pos, t));\n                if(color.a > 0.)\n                {   return color + vec4( fract(t)/3., fract(t)/3., fract(t)/3., 0.);\n                }\n            }\n\n            return vec4(0.3*sin(i)+0.4, 0.0, 0.0, 1.0);\n        }\n    }\n\n    return WHITE;\n}\n\n///----------------------------------------------------------------------------|\n/// Doors.\n///----------------------------------------------------------------------------:\nvec4 Door_X(vec2 pos)\n{   \n    if(pos.x < 0.05) return tonsin(0.  , 0.05, pos.x);\n    if(pos.x > 0.45) return tonsin(0.45, 0.5 , pos.x);\n    \n    if(pos.y < 0.05) return tonsin(0.  , 0.05, pos.y);\n    if(pos.y > 0.95) return tonsin(0.95, 1.  , pos.y);\n    \n    return tonsin(0.4, 0.8, pos.y);\n}\n\nfloat Move_Door(float t)\n{   float a = cos(t / 4.) * 0.21;\n\n    if(a < 0.) return 0.42;\n\n           t = 0.21 - cos(t / 2.) * 0.21;\n    return t;\n}\n\nvec4 Doors(vec2 pos, float t)\n{\n    float open = Move_Door(t);\n\n    float\n       xx = pos.x + open;\n    if(xx < 0.5) return Door_X(vec2(xx      , pos.y));\n\n       xx = pos.x - open;\n    if(xx > 0.5) return Door_X(vec2(xx - 0.5, pos.y));\n\n    return vec4(-1.);\n}\n\n///----------------------------------------------------------------------------|\n/// Run.\n///----------------------------------------------------------------------------:\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord/iResolution.xy;  \n    init_lepts();\n    \n    float arr[] = float[5](1., 1., 1., 1., 1.);\n\n    float a = ((SPEED+.6)*sin(iTime/ 5.) - 1.6) / iTime;\n    \n    Speed    = iTime * (SPEED+a)      ;\n    Speed1   = iTime * (SPEED+a) * 1.2;\n    Speed2   = iTime * (SPEED+a) * 1.5;\n    \n    RADIUS   = iTime / 5.; if(RADIUS > RADIUSS) RADIUS = RADIUSS;\n\n    vec4 brd = Doors(pos, iTime);\n    if(  brd.a == -1.) fragColor = colorSectors(pos);\n    else               fragColor = brd;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyXzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[860, 872, 918, 918, 1036], [1038, 1038, 1075, 1075, 1138], [1140, 1140, 1177, 1177, 1342], [2104, 2222, 2249, 2249, 2343], [2345, 2345, 2371, 2371, 2479], [2546, 2546, 2565, 2565, 2859], [2869, 2869, 2910, 2910, 3870], [3872, 3872, 3897, 3897, 4107], [4131, 4131, 4160, 4160, 5032], [5034, 5207, 5230, 5230, 5501], [5503, 5503, 5529, 5529, 5649], [5651, 5651, 5682, 5682, 5912], [5914, 6085, 6142, 6142, 6641]], "test": "untested"}
{"id": "flGXRm", "name": "Simple Colored Noise", "author": "TeMaToS", "description": "Just a simple colored noise, that I discovered while tried to achieve that", "tags": ["noise"], "likes": 2, "viewed": 288, "published": 3, "date": "1640328621", "time_retrieved": "2024-07-30T18:40:28.635135", "image_code": "float random(float income){\n    return fract( (sin(income) * 4698.0101255) + (sin(income) * 29189.92918) + (sin(income) * 8.327) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 1.1;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(sin(random(uv.x * (iTime + 250.0) - uv.y * (iTime + 2125.0))), sin(random(uv.x * (iTime + 80.0) + uv.y * (iTime + 1.0) )), sin(random(uv.x * (iTime + 8.0) - uv.y * (iTime + 32.0) )));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGXRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 133], [135, 135, 192, 242, 641]], "test": "untested"}
{"id": "NlySRw", "name": "testing fdn stuff", "author": "nabr", "description": "bum chack bum chack chack", "tags": ["sound", "reverberation", "fnd"], "likes": 12, "viewed": 382, "published": 3, "date": "1640316072", "time_retrieved": "2024-07-30T18:40:29.399093", "image_code": "// char by FabriceNeyret2\n#define char(_p,_C)(((_p.x<0.||_p.x>1.||_p.y<0.||_p.y>1.))?vec4(0,0,0,1e5):textureGrad(iChannel3,_p/16.+fract(vec2(_C,15-_C/16)/16.),dFdx(_p/16.),dFdy(_p/16.)))\n\n\n#define T iTime\n#define R iResolution.xy\n\nfloat f(vec3 p){return 6.-(length(smoothstep(-.3,.3,pow(fract(.8*vec3(p.xy,T+p.z)),vec3(cos(T)+1., sin(T)*.7+.7, .5))))+max(p.x,1.+p.y));}\nvoid mainImage(out vec4 O,in vec2 U)\n{\n    //tunnel\n    vec2 u=(U-.5*R)/min(R.x,R.y),e=vec2(.001,-.001);\n    vec3 p,n;float t;\n    for(int i=0;i<32;i++)\n    O=vec4(.7*max(dot(normalize(vec3(2,.5,fract(T)*5.)-p),\n    float((t+=.5*f(p=vec3(abs(u),.2)*t))>1.)\n    *normalize(e.yxx*f(p+e.yxx)+e.xxy*f(p+e.xxy)+e.xyx*f(p+e.xyx)+e.yyy*f(p+e.yyy)))\n    -(cos(t*.3+T)*.5+.5)*vec3(.1,.7,0.65),0.),1);\n    \n     //print char sound in\n     u = vec2(.5+sin(2.*u.y+2.*T), -1.5)+u*(6.+T);\n     for(int i = 0; i < 7; ++i){\n     O += char(u,int[](83, 111, 117, 110, 100, 105, 110)[i]).x*max(0., 1.-T*.2);\n     u.x -= 1.5;\n     u*= mat2(0.6,-.8,.8, .6);\n     }\n     \n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "\n// Minimalist implantation of the idea behind a Feedback Delay Network\n// Usually it is sampel-based, works on the Time Domain, Circular Buffer. Good use for Compute-shader design.\n// I adopted the idea for my personal GPU-Sound workflow.\n// I wrote some commentes: when i say original scemata i mean \n// https://ccrma.stanford.edu/~jos/pasp/Feedback_Delay_Networks_FDN.html\n// some code in C https://github.com/bmFicg/audioexp/blob/master/fdn/main.c\n\n// License - CC0 or use as you wish\n\n\n\n\n//=====================  music sequencer by gaz\n// https://www.shadertoy.com/view/ftdXzs\n\n// sound source\n#define PI acos(-1.)\n#define PIH (PI * .5)\n#define TAU (PI * 2.)\n#define osc_sin(x) sin((x) * TAU)\n#define osc_saw(x) (1. - fract(x) * 2.)\n#define osc_sqr(x) sign(.5 - fract(x))\n#define osc_tri(x) (asin(sin((x) * PI)) / PIH)\n \nfloat noize(float t,  float a, float b){\n    float g = fract(cos(t * exp2(a)) * exp2(b)) + 6.;\n    return exp(-.08 * g * g) * 40. - 1.;\n}\n\nfloat kick(float t)\n{\n    return clamp(1.5 * asin(cos(320. * t -30.0 * exp(-40. * t))),\n                   -1.,\n                    1.\n                 ) * exp(-4. * t);\n}\n\nfloat snare(float t){\n    float n = noize(t, 10., 10.) * exp(-t * 10.);\n    float f = t * 160.;\n    float a = .3 * osc_tri(1.2 * f) * exp(-t * 3.);\n    float b = .05 * osc_sin(10. * f + a) * exp(-t * 3.);\n    float c = osc_sin(f + b) * exp(-t * 15.);\n    return n + c;\n}\n\nfloat hihat(float t){\n    return noize(t, 10., 18.) * exp(-t * 15.);\n}\n\nfloat OFFSET;\nint TMP, POS, IDX;\n#define EXTRACT(m, a)\\\n{\\\n    TIME = mod(TIME, barTime);\\\n    IDX = -1;\\\n    float b, c;\\\n    for(int i = 0; i < m; i++){\\\n        b = barTime / float(m);\\\n        c = float(int[]a[i % int[]a.length()]);\\\n        if(c > 0.) OFFSET = 0.;\\\n        if(TIME < b) break;\\\n        IDX += int(c);\\\n        TIME -= b;\\\n        OFFSET += b / max(1., c);\\\n    }\\\n    if(c > 0.)IDX += int(TIME / b * c) + 1;\\\n    TIME = mod(TIME, b / max(1., c));\\\n    TIME += OFFSET;\\\n}\n    \n// Rhythm( beat<Number of divisions per bar> , Array of beat divisions )\n// Arrays are enclosed in `()`\n// I'm using a trick on the macro to free the array size\n// If it is the same array, it will be repeated even if it is omitted.\n#define Rhythm(m, a)\\\n    TMP++;\\\n    if(POS == TMP) EXTRACT(m, a)\n// Info( Array of int information )\n// Arrays are enclosed in `()`\n// I'm using a trick on the macro to free the array size\n// If it is the same array, it will be repeated even if it is omitted.\n#define Info(a)\\\n    if(POS == TMP) INF = int[]a[IDX % int[]a.length()];\n\n// Reset every time you change the information.\n#define Reset \\\n    OFFSET = 100.;\\\n    TIME = time;\\\n    TMP = -1;\\\n    POS = int(time / barTime);\n// Loop( Number of measures to repeat )\n#define Loop(n)\\\n    TIME = mod(TIME, barTime * float(n));\\\n    POS %= n;\n\nvec2 mSound(float time ){\n    float bpm = 120.;\n    // One bar time\n    float barTime = 240. / bpm;\n    // Time to input to the sound source\n    float TIME;\n    // Current information\n    int INF;\n    float gain = 0.;\n\n    Reset;\n    Loop(1)\n    Rhythm(2, (1))\n    gain = .6 * kick(TIME);\n\n    Reset;\n    Loop(1)\n    Rhythm(4, (0, 1, 0, 2)) \n    gain += .5 * snare(TIME);\n      \n    return .5 * clamp(1.5 * vec2(gain), -1., 1.);\n}\n\n\n//=====================   major7_chord by lil_chickehh\n// https://www.shadertoy.com/view/ftdSDB\n// Intervals:\nconst float intrvls[12] =float[12](1.0, 1.059463094, 1.122462048, 1.189207115, 1.259921049,1.334839854, 1.414213562, 1.498307076, 1.587401051, 1.681792830,1.781797436, 1.887748625);\n\n\n\n//===================== FEEDBACK DELAY NETWORK\nvoid bfdn(inout vec4 s, const in mat4 M, in uint i) \n{\n    i = i % 4u;\n    s += (s[0] * M[0][i] + s[1] * M[i][i] + s[2] * M[i][i] + s[3] * M[i][i]);\n         //original scemata can be simplified to a dot function\n         //(s[0] * M[i][0] + s[1] * M[i][1] + s[2] * M[i][2] + s[3] * M[i][3]); \n}\n\n\n#define _f(_x)(fract(_x))\n#define cs(_s, _r)(sin(_s)*_r+_r)\nfloat inst(in float t, const in uint i) \n{\n    float y = 0., f1 = 0., f0a = 0., f2 = 0., f3 = 0.;\n    float ft1 = _f(2. * t), ft0 = _f(3. * t);\n    \n    float n = (t * 214013.);//noise\n    \n    int p0 = mod(t, 6.) > 4. ? 2 : 0;\n    int p1 = mod(t, 2.) > 1. ? 4 : mod(t, 3.) > 2. ? 6 : 9;\n    ivec4 itv = ivec4(p0, p1, 7, 11);\n    \n    f1 = sin(TAU * intrvls[itv[i % 4u]] * 120. * t);\n    f1 *= min(1., 10. * ft1) * max(0., 1. - ft1);\n    \n    //original scemata has comp filters replaced with some phase shift funtion\n    f2 = cos(4. * f1) / (1.751225 + sin(f1 + .5 * _f(n * _f(t + n))));\n    \n    f2 *= 20. * mix(1.99994, 1., cs(t, .5));\n    f2 *= min(1., 30. * ft0) * max(0., 1. - ft0);\n    \n    y = clamp(cs(t, .255) * f1 + .7 * (.5 + f2), -.3, .3);\n    \n    return t<6.?mSound(t).x : .9 * mSound( t).x  +(.25 * f1 + y);\n}\n\nvec2 mainSound(in int samp, float time) \n{\n    vec2 r = vec2(1e-6);\n    float y = 0., y1 = 0., y3 = 0., y2 = 0., y4 = 0.;\n   \n    mat4 A = mat4(0, -1., 1., 0, 1., 0, 0, 1., 1., 0, 0, -1., 0, -1., -1., 0) * (1. / sqrt(2.)); //hadamard matrix, transposed to collum wise\n    vec4 dt = vec4(577, 601, 641, 661);//primes to-do: bigger kernel size\n    \n    float mt = float(samp) * (1./iSampleRate);\n    float dlt = mt;\n    \n    //phaser helps with resonnance howling tone, original scemata has comp filters \n    float vt = mt;\n    vec4 ehp = 1e-4 * vec4(17. * cos(vt), -15. * sin(vt), 12. * sin(vt),11. * cos(vt)) ;\n    \n    //gain coefficient - room size\n    float g1 = .0001 * mix(3., 9.125, step(mod(time, 12.), 6.));\n    \n    \n    const uint sz = 12u;\n    for (uint j = 0u; j < 3u; j++) //inc. or decrease density\n        for (uint i = 0u; i < sz; ++i) \n        {\n            \n            {\n                y1 = inst((dlt + (ehp.x + ehp.z)), i);\n                y2 = inst((dlt + (ehp.y + ehp.w)), i);\n                y3 = inst(dlt, i);\n                y4 = inst(dlt, i);\n                \n                //multi channel split\n                float v[sz]; //unroll for some mobile\n                //v = float[](y2, y3, y3, y2, y1, y4, y4, y1, y4, y3, y1, y2);\n                 v[0]=y2;v[1]=y3;v[2]=y3;v[3]=y2;v[4]=y1;v[5]=y4;v[6]=y4;v[7]=y1;v[8]=y4;v[9]=y3;v[10]=y1;v[11]=y2;\n                (i % 2u == 0u) ? (r.x += v[i % sz]) : (r.y += v[i % sz]);\n                \n                // stacking, advance delay line\n                bfdn(dt, A, (i + 0u));\n                bfdn(dt, A, (i + 1u));\n                bfdn(dt, A, (i + 2u));\n                bfdn(dt, A, (i + 3u));\n                \n                \n                dlt += (dt.x + dt.y + dt.z + dt.w) / float(18) //decay dump oversampled-late delays\n                                                      * g1;   \n                }\n        }\n \n    //dry\n    for(uint h = 0u; h < 3u; h++)y += .25 * inst(dlt, h);\n    \n    //out\n    return y + (r /= 12.);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlySRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 231, 247, 247, 369]], "test": "untested"}
{"id": "stVXzD", "name": "glitch_better_simplex", "author": "Fililip", "description": "!", "tags": ["simplex", "glitch"], "likes": 11, "viewed": 697, "published": 3, "date": "1640302771", "time_retrieved": "2024-07-30T18:40:30.158063", "image_code": "vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //float n = 1.5;\n    float n = noise(fragCoord.y + iTime);\n    float sdist = snoise(vec2(0.0, uv.y * 8.0 + iTime * 2.0));\n    float size = max(0.0, sin(iTime * 12.0) * 0.25 );\n    uv.x += size * sdist * snoise(vec3(vec2(uv.x, floor(fragCoord.y / n) * n) + vec2(iTime * 4.4, iTime * 0.2), iTime * 0.4));\n    vec2 uv_r = uv + size * 0.1 * sdist * snoise(vec3(vec2(uv.x, floor(fragCoord.y / n) * n) + vec2(iTime * 4.4, iTime * 0.2), iTime * 0.4));\n    vec2 uv_b = uv - size * 0.05 * sdist * snoise(vec3(vec2(uv.x, floor(fragCoord.y / n) * n) + vec2(iTime * 4.4, iTime * 0.2), iTime * 0.4));\n    vec4 r = texture(iChannel0, uv_r);\n    vec4 g = texture(iChannel0, uv);\n    vec4 b = texture(iChannel0, uv_b);\n    fragColor = vec4(r.r, g.g, b.b, 1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVXzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 61], [63, 63, 84, 84, 904], [958, 958, 979, 979, 1016], [1017, 1017, 1044, 1044, 1092], [1094, 1094, 1115, 1115, 2951], [2953, 2953, 2973, 2973, 3011], [3013, 3013, 3034, 3034, 3124], [3126, 3126, 3181, 3181, 3977]], "test": "untested"}
{"id": "slKSRD", "name": "Mosaic fractal 4", "author": "jarble", "description": "An interesting mosaic pattern.", "tags": ["fractal", "mosaic"], "likes": 3, "viewed": 228, "published": 3, "date": "1640290019", "time_retrieved": "2024-07-30T18:40:30.912048", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);    \n    vec3 col;  \n    float t1 = 4.5*64.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float t2 = floor((iTime/2.+uv.x)/10.0)/t1;\n\n    float offset = .5;\n    float scale2 = 1.5;\n    float bend = 1.;\n    float scale = c1.z;\n    for(int i=0;i<6;i++)\n    {\n        vec2 t2 = vec2(0);\n        vec2 t3 = vec2(0);\n        for(int k = 0; k < 3; k++){\n            //bend = 1.+col.x;\n            uv /= -scale2;\n            uv -= t2.yx/(scale);\n            t2 = triangle_wave(-uv.yx-offset,scale)/bend;\n            t3 = triangle_wave(-uv,scale)*bend;\n            uv.yx = t2+t3;\n        }\n        col.x = abs((uv.x)-(uv.y)-col.x);\n        col = col.yzx;\n    }\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKSRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 277, 316, 316, 361], [363, 363, 420, 420, 1214]], "test": "untested"}
{"id": "ftVXzD", "name": "Mosaic fractal 3", "author": "jarble", "description": "An interesting mosaic pattern.", "tags": ["fractal", "carpet", "rug"], "likes": 8, "viewed": 315, "published": 3, "date": "1640276523", "time_retrieved": "2024-07-30T18:40:31.664037", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5*4.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0)/t1;\n    //vec3 random1 = (hash31(3.+t2)-.5)/12.;\n    //vec3 random2 = (hash31(4.+t2)-.5)/12.;\n    //vec3 random3 = (hash31(3.+t2)-vec3(.5))/1.5;\n    //vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    float bend = 1.;\n    for(int c=0;c<1;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<9;i++)\n        {\n            vec2 t2 = vec2(0);\n            for(int k = 0; k < 3; k++){    \n                uv /= -scale2;\n                uv -= t2.yx/(scale);\n                t2 = triangle_wave(uv.yx-offset,scale);\n                vec2 t3 = triangle_wave(uv,scale);\n                uv.yx = t2+t3;\n \n\n            }\n            offset += .5/scale;\n            scale /= 1.+(scale2)*col.x/(8.);\n            scale2 -= (col.x-1.)/(4.);\n\n\n            col[c] = abs((uv.x)-(uv.y)+col.x);\n            col = col.yzx;\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVXzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[276, 386, 408, 454, 587], [589, 589, 628, 628, 673], [675, 675, 732, 732, 2081]], "test": "untested"}
{"id": "flVSRD", "name": "Wavy Transition", "author": "turboplay", "description": "Found it somewhere I can't recall :). ", "tags": ["wavy", "transition"], "likes": 3, "viewed": 313, "published": 3, "date": "1640273103", "time_retrieved": "2024-07-30T18:40:32.416026", "image_code": "float p1 = 0.1f; // 0 - 1\n\nvec2 offset(float progress, float x, float theta)\n{\n    float phase = progress * progress + progress + theta;\n    float shifty = p1 * progress * cos(10.0 * (progress + x));\n    return vec2(0, shifty);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = mod(iTime,4.)*0.25;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 c1 = texture(iChannel0,uv + offset(time, uv.x, 0.0));\n    vec4 c2 = texture(iChannel1,uv + offset(1.0 - time, uv.x, 3.14));\n    fragColor = mix(c1, c2, time);\n\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVSRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 78, 78, 229], [231, 231, 288, 288, 536]], "test": "untested"}
{"id": "ftKSRD", "name": "eindacor_cmykwaves", "author": "Eindacor_DS", "description": "I'll never describe my shaders..... EVER! I'm not a part of your system!", "tags": ["cmyk"], "likes": 1, "viewed": 219, "published": 3, "date": "1640271150", "time_retrieved": "2024-07-30T18:40:33.171008", "image_code": "#define CYAN vec3(0., 1., 1.)\n#define MAGENTA vec3(1., 0., 1.)\n#define YELLOW vec3(1., 1., 0.)\n#define TWOPI 6.28318530718f\n\n#define NORMALIZE_SIN false\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nfloat getHoldTransitionValue(float lower, float upper, float holdTime, float transitionTime, float time) {\n    float period = 2. * holdTime + 2. * transitionTime;\n    float halfPeriod = period / 2.;\n    float relativeTime = fract(time / halfPeriod);\n    float halfHoldTime = holdTime / 2.;\n    \n    float val = smoothstep(halfHoldTime, halfHoldTime + transitionTime, relativeTime * halfPeriod);\n    \n    if (int(time / halfPeriod) % 2 == 0) {\n        val = 1. - val;\n    }\n\n    return mix(lower, upper, val);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n\n    float distMultiplier = getHoldTransitionValue(2., 50., 5., 40., iTime);\n    float radialSineModifier = 12.;\n    float radiasSineDistModifier = getHoldTransitionValue(0., 2., 5., 10., iTime);\n    \n    vec2 cyanCenter = vec2(.5 * aspectRatio, .5);\n    float cyanAngle = atan((uv.y - cyanCenter.y)/(uv.x - cyanCenter.x));\n    float cyanVal = sin(iTime + \n        distMultiplier * distance(uv, cyanCenter) + sin(cyanAngle * radialSineModifier) * radiasSineDistModifier);\n    if (NORMALIZE_SIN) {\n        cyanVal = (cyanVal + 1.) / 2.;\n    }\n    vec3 cyan = mix(vec3(1.), CYAN, cyanVal);\n    \n    vec2 magentaCenter = vec2(.25 * aspectRatio, .75);\n    mat2x2 magentaRotation = createRotationMatrix(-iTime * .01);    \n    magentaCenter = (magentaCenter - cyanCenter) * magentaRotation + cyanCenter;\n    float magentaAngle = atan((uv.y - magentaCenter.y)/(uv.x - magentaCenter.x));\n    float magentaVal = sin(iTime + \n        distMultiplier * distance(uv, magentaCenter) + sin(magentaAngle * radialSineModifier) * radiasSineDistModifier);\n    if (NORMALIZE_SIN) {\n        magentaVal = (magentaVal + 1.) / 2.;\n    }\n    vec3 magenta = mix(vec3(1.), MAGENTA, magentaVal);\n    \n    vec2 yellowCenter = vec2(.75 * aspectRatio, .25);\n    mat2x2 yellowRotation = createRotationMatrix(iTime * .03);\n    yellowCenter = (yellowCenter - cyanCenter) * yellowRotation + cyanCenter;\n    float yellowAngle = atan((uv.y - yellowCenter.y)/(uv.x - yellowCenter.x));\n    float yellowVal = sin(iTime + \n        distMultiplier * distance(uv, yellowCenter) + sin(yellowAngle * radialSineModifier) * radiasSineDistModifier);\n    if (NORMALIZE_SIN) {\n        yellowVal = (yellowVal + 1.) / 2.;\n    }\n    vec3 yellow = mix(vec3(1.), YELLOW, yellowVal);\n\n    // Output to screen\n    fragColor = vec4(cyan * magenta * yellow, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKSRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 199, 199, 303], [305, 305, 411, 411, 815], [817, 817, 874, 874, 2799]], "test": "untested"}
{"id": "flVXRW", "name": "log spherical flower ", "author": "SnoopethDuckDuck", "description": "quick and messy (in hindsight i dont think is log spherical)", "tags": ["raymarching", "template", "artofcode"], "likes": 16, "viewed": 417, "published": 3, "date": "1640270555", "time_retrieved": "2024-07-30T18:40:33.922000", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define pi 3.14159\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n} \n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 p) {\n    return max(max(abs(p.x), abs(p.y)), abs(p.z));\n}\n\nfloat GetDist(vec3 p) {\n    float sc = 6.;\n    \n    float a = atan(p.z, p.x);\n    float r = length(p)/ (1. + p.y);\n    \n    //p.y += cos(0.4 * r);\n    p = vec3(a / pi, p.y, -log(r) - .2 * iTime);\n    \n    vec2 ipos = floor(sc * p.xz) + 0.5;\n    vec2 fpos = fract(sc * p.xz) - 0.5; //cos(sc * p.xz / pi) - 0.5;\n    \n    \n    \n    float d = -0.7 - 0.3 * cos(10. * r + iTime) + length(vec3(fpos.x, p.y, fpos.y));\n    \n    return 0.4 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y *.5 + .5;\n    \n    vec3 col = mix(vec3(.5,0.,0.),vec3(0.),k);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(5,4,5);\n    float time = 0.2 * iTime;\n\n    ro = vec3(5. * cos(time), 3., 5. * sin(time));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.2);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n    \n   \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 rf = refract(rd, n,0.1);\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = 0.5 * vec3(dif);\n        \n        float b = .5 + .5 * cos(iTime);\n        \n        uv = fragCoord.xy / iResolution.xy;\n        col += 0.5 * texture(iChannel0, r).rgb;\n         \n        float a = atan(rf.z, rf.x);\n        float c = atan(rf.z,rf.y);\n        vec2 ipos = floor(p.xz) + 0.5;\n        float h = mix(h21(ipos),0., 0.5 + 0.5 * cos(iTime));\n        col.r += 0.15 + .3 * cos(10. * rf.y + iTime - .5 * pi);\n        col.g += 0.15 + .3 * cos(10. * rf.y + iTime);\n        col.b += 0.15 + .3 * cos(10. * rf.y + iTime + .5 * pi);\n        //col = min(col, 1.2 * vec3(0.5 + 0.5 * cos(2. * p.y)));\n        col *= 1.2 * p.y;\n        //col *= 1. - (1. - step(1.5, p.y)) * (smoothstep(-1.5, 1.5, -1.5 + length(p.xz)));\n        //col *= 1. - length(p.xz)/3.;\n       // col += Bg(r);\n       //col *= -pow(thc(2., length(p) - iTime), 5.);\n        \n    } else {\n        col = texture(iChannel0, rd).rgb;\n    }\n    \n    //col.r =0.02;\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVXRW.jpg", "access": "api", "license": "mit", "functions": [[1495, 1495, 1514, 1514, 1576], [1579, 1579, 1608, 1608, 1649], [1652, 1652, 1672, 1672, 1747], [1749, 1749, 1773, 1773, 1813], [1815, 1815, 1838, 1838, 1891], [1893, 1893, 1916, 1916, 2329], [2331, 2331, 2365, 2365, 2576], [2578, 2578, 2602, 2602, 2792], [2794, 2794, 2844, 2844, 3035], [3037, 3037, 3055, 3055, 3154], [3157, 3157, 3214, 3214, 4861]], "test": "untested"}
{"id": "slySRD", "name": "Devil's staircase", "author": "IWBTShyGuy", "description": "[url]https://en.wikipedia.org/wiki/Cantor_function[/url]", "tags": ["fractal"], "likes": 8, "viewed": 241, "published": 3, "date": "1640252170", "time_retrieved": "2024-07-30T18:40:34.676981", "image_code": "void mainImage(out vec4 O, in vec2 U) {\n    vec2 r = iResolution.xy;\n    O = vec4(1);\n\n    U = (U - r / 2.) / r.y + .5;\n    float d = 9.,\n          a = 3.,\n          b = 2.,\n          x = 1. / a,\n          y = 1. / b, t, q;\n    for (int i = 0; ++i < 9;){\n        q = U.x - x;\n        t = clamp(q, 0., 1. / a);\n        d = min(d, length(vec2(q - t, U.y - y)));\n        bool f = q * a < .5;\n        a *= 3.; b *= 2.;\n        x += (f ? -2. : 4.) / a;\n        y += (f ? -1. : 1.) / b;\n    }\n    O -= min(d / 0.003, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slySRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 517]], "test": "untested"}
{"id": "NlGXRW", "name": "worlds worst planet shader", "author": "incription", "description": "trying out rayleigh scattering from sebastian lagues videos\ni know all the code is messy but I am learning everything rn", "tags": ["light", "planet", "scattering"], "likes": 4, "viewed": 397, "published": 3, "date": "1640247790", "time_retrieved": "2024-07-30T18:40:35.613478", "image_code": "#define F(x,y) col = mix(x, col, smoothstep(0., fwidth(y), y))\n\n#define LIGHT_POS vec3(sin(iTime/2.)*10., -3., cos(iTime/2.)*10.)\n#define MOON_POS vec3(-sin(iTime/5.)*3., 0, -cos(iTime/5.)*3.)\n#define WAVES vec3(.7, .53, .34)\n\n#define KM 0.00007848061\n\n#define SCATTER_STR 3.\n#define MAX_STEPS 100\n#define MAX_DIST  100.\n#define SURF_DIST    .00001\n\n#define ATM_WIDTH    .07848061\n#define ATM_POINTS 10.\n#define OPT_POINTS 10.\n#define DENSITY_F  15.\n\nfloat scene(vec3 p) {\n    \n    vec3 pp = R(Q(vec3(0, -iTime / 2., 0)), p);\n    float ocean = length(pp) - .5;\n    float surface = sdFbm(pp + .5, length(pp)-(.5 + KM * 10.)).x;\n    surface = max(surface, length(p) - (.50 + KM));\n    float box = sdBox(p - vec3(.5, 0., 0.0), vec3(0.1));\n    float moon = length(p - MOON_POS) - .1;\n    float sun  = length(p - LIGHT_POS) - .05;\n    \n    return min(surface, min(sun, min(ocean, moon)));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    \n    for(int i=0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = scene(p);\n        dO += dS;\n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 getNormal(vec3 p) {\n    float d = scene(p);\n    vec2  e = vec2(.01, 0);\n    vec3 n = d - vec3(\n        scene(p - e.xyy),\n        scene(p - e.yxy),\n        scene(p - e.yyx));\n        \n    return normalize(n);\n}\n\nfloat getLight(vec3 p, vec3 rd) {\n    vec3 l = normalize(LIGHT_POS - p);\n    vec3 n = getNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n        float d = rayMarch(p + n*SURF_DIST*2., l);\n    if(d<length(LIGHT_POS-p)) dif *= 0.1;\n    \n    vec3 direction_to_view = rd;\n    vec3 direction_to_light = normalize(LIGHT_POS - p);\n    vec3 light_reflection_unit_vector =\n                \t reflect(direction_to_light , n);\n    float specular_intensity = \n        1.15* pow(clamp(dot(direction_to_view, light_reflection_unit_vector), 0.0,1.0), 50.0);\n    return dif + .3 * specular_intensity;\n}\n\n\nfloat densityAtPoint(vec3 p) {\n    float height = length(p - vec3(0)) - .5;\n    float height01 = height / (ATM_WIDTH);\n    \n    float localDensity = exp(-height01 * DENSITY_F) * (1. - height01);\n    return localDensity;\n}\n\nfloat opticalDepth(vec3 ro, vec3 rd, float dO) {\n    vec3 point = ro; \n    float stepSize = dO / (OPT_POINTS - 1.);\n    float depth = 0.;\n    \n    for(float i = 0.; i < OPT_POINTS; i++) {\n        float density = densityAtPoint(point);\n        depth += density * stepSize;\n        point += rd * stepSize;\n    }\n    \n    return depth;\n}\n\nvec3 atmScattering(vec3 ro, vec3 rd, float dO, vec3 col) {\n    vec3 scatterPoint = ro;\n    float stepSize = dO / (ATM_POINTS - 1.);\n    vec3 light = vec3(0);\n    vec3 scatter = pow3(.4 / WAVES, 4.) * SCATTER_STR;\n    float viewRayOpticalDepth = 0.;\n    vec3 sunDir = normalize(LIGHT_POS);\n    \n    for(float i = 0.; i < ATM_POINTS; i++) {\n        vec2 sph = raySphere(scatterPoint, sunDir, vec3(0), .5 + ATM_WIDTH);\n        float sunRayLength = sph.y;\n        float sunRayOpticalDepth = opticalDepth(scatterPoint, sunDir, sunRayLength);\n        viewRayOpticalDepth = opticalDepth(scatterPoint, -rd, stepSize * i);\n        vec3 transmittance = exp(-(sunRayOpticalDepth + viewRayOpticalDepth) * scatter);\n        float density = densityAtPoint(scatterPoint);\n        \n        light += density * transmittance * scatter * stepSize;\n        scatterPoint += rd * stepSize;\n        \n    }\n    \n    float originalTransmittance = exp(-viewRayOpticalDepth);\n    return col * originalTransmittance + light;\n}\n\nvec3 planetCol(float l) {\n    if(l < SURF_DIST + .5) return vec3(0.071,0.141,0.431);\n    if(l < .5 + ATM_WIDTH) return vec3(0.192,0.749,0.231);\n    return vec3(0);\n}\n\nvec3 view(vec3 v)\n{\n    float t = 0.;\n    #if PRESET == 1\n    \tt = iTime * 1.0; // rotate\n        //t = iTime * 0.0;\n    #elif PRESET == 2\n    \t//t = iTime * 0.3; // shockwave\n    \t//t = iTime * 0.1; // blob\n        t = iTime * 0.0; // stationary\n    #elif PRESET == 3\n    \tt = iTime * 0.3;\n    #elif PRESET == 4\n    \tt = iTime * 1.0;\n    #endif\n    v = R(Q(vec3(0, t / 2., 0)), v);\n    return v;\n}\n\nfloat map(vec3 p)\n{\n    float r = length(p);\n    float planet = r - .5;\n    float background = 200. - r;\n    return min(planet, background);\n}\n\nvec3 flowColor(vec3 col)\n{\n    return vec3(col.z) / 2.;\n}\n\n\nvec3 renderSphere(vec2 fragCoord)\n{\n\n    vec2 uv = (fragCoord - iResolution.xy / 2.) / iResolution.y;\n    vec3 p = view(vec3(0, 0, -9));\n    vec3 v = view(normalize(vec3(uv*.22, 1)));\n\n\tfor (int i=0 ; i<60 ; i++)\n        p += v * map(p);\n    \n    //vec3 col = vec3(length(T(p).xyz) + .5);\n    vec3 col = vec3(abs(min(0., T(p).w/1. - .3)));\n    if (length(p) > 1.5)\n        col = vec3(0);\n    col *= T(p).w * .5 + .9;\n    //col = vec3(polar(normalize(p)),0);\n    //col = topolar(polar(normalize(p)));\n    //col = normalize(p);\n    //col = texture(iChannel0, fragCoord/iResolution.xy).w;\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 muv = iMouse.xy / iResolution.xy;\n         muv -= .5;\n         muv *= 50.;\n         \n   \n    \n    vec3 ro = texelFetch(iChannel2, ivec2(0, 0), 0).xyz;\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    vec2 sph = raySphere(ro, rd, vec3(0), 100.);\n    vec3 col = vec3(0);\n    //sun\n    sph = raySphere(ro, rd, LIGHT_POS, .5);\n    if(sph != vec2(-1.)) col *= 1. - vec3(1., 1., 0.);\n    \n    sph = raySphere(ro, rd, vec3(0), .5 + ATM_WIDTH);\n    if(sph != vec2(-1.))\n    {\n        //set ray to surface\n        ro += rd * sph.x; }\n        \n        float d = rayMarch(ro, rd);\n        vec3 p = ro + rd * d;\n        \n        //sph = raySphere(ro, rd, vec3(0), .5);\n        //float dstPlanet = min(d, sph.x);\n        float dif = getLight(p, rd);\n        col += planetCol(length(p)) * dif;\n        col += renderSphere(fragCoord) * dif;\n        sph = raySphere(ro, rd, vec3(0), .5 + ATM_WIDTH);\n        float l = min(sph.y, d - sph.x);\n        //l -= d;\n        if(l > 0.) {\n            //vec3 pointInAtmosphere = ro + rd * l;\n            vec3 scatter = atmScattering(ro, rd, l - SURF_DIST * 2., col);\n            col += scatter;\n        }\n    \n    col = pow(col, vec3(.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 raySphere( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec3 pow3(vec3 x, float p) {\n    return vec3(pow(x.x, p), pow(x.y, p), pow(x.z, p));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 opCheapBend( in vec3 p )\n{\n    const float k = 10.0; // or some other amount\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\nvec3 opRotate( in vec3 p, float theta ) {\n\n    float c = cos(theta);\n    float s = sin(theta);\n    return p * mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat sdMandelbrot( in vec2 c )\n{\n    #if 1\n    {\n        float c2 = dot(c, c);\n        // skip computation inside M1 - https://iquilezles.org/articles/mset1bulb\n        if( 256.0*c2*c2 - 96.0*c2 + 32.0*c.x - 3.0 < 0.0 ) return 0.0;\n        // skip computation inside M2 - https://iquilezles.org/articles/mset2bulb\n        if( 16.0*(c2+2.0*c.x+1.0) - 1.0 < 0.0 ) return 0.0;\n    }\n    #endif\n\n    // iterate\n    float di =  1.0;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<300; i++ )\n    {\n        if( m2>1024.0 ) { di=0.0; break; }\n\n\t\t// Z' -> 2ZZ' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|log|Z|/|Z'|\n\tfloat d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if( di>0.5 ) d=0.0;\n\t\n    return d;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nfloat hash(vec3 p)  \n{\n    p  = 17.0*fract( p*0.3183099+vec3(.11,.17,.13) );\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat sph( ivec3 i, vec3 f, ivec3 c )\n{\n   // random radius at grid vertex i+c\n   float rad = 0.5*hash(vec3(i));\n   // distance to sphere at grid vertex i+c\n   return length(f-vec3(c)) - rad; \n}\n\nfloat sdBase( vec3 p )\n{\n   ivec3 i = ivec3(floor(p));\n    vec3 f =       fract(p);\n   // distance to the 8 corners spheres\n   return min(min(min(sph(i,f,ivec3(0,0,0)),\n                      sph(i,f,ivec3(0,0,1))),\n                  min(sph(i,f,ivec3(0,1,0)),\n                      sph(i,f,ivec3(0,1,1)))),\n              min(min(sph(i,f,ivec3(1,0,0)),\n                      sph(i,f,ivec3(1,0,1))),\n                  min(sph(i,f,ivec3(1,1,0)),\n                      sph(i,f,ivec3(1,1,1)))));\n}\n\nvec2 sdFbm( in vec3 p, float d )\n{\n    const mat3 m = mat3( 0.00,  0.80,  0.60, \n                        -0.80,  0.36, -0.48,\n                        -0.60, -0.48,  0.64 );\n    float t = 0.0;\n\tfloat s = 1.0;\n    for( int i=0; i<7; i++ )\n    {\n        float n = s*sdBase(p);\n    \td = smax( d, -n, 0.2*s );\n        t += d;\n        p = 2.0*m*p;\n        s = 0.5*s;\n    }\n    \n    return vec2(d,t);\n}\n\n// 1..4\n#define PRESET 1\n\nconst float PI = 3.141592653589793;\n\n// converts point U (that sits on a sphere with arbitrary radius) to two polar angles uv for texture lookup\nvec2 polar(vec3 U)\n{\n    return fract(vec2(\n        atan(U.x, U.z) / 2.,\n        atan(U.y, length(U.xz))\n    ) / PI + .5);\n}\n\n// converts two polar angles uv from texture to point U on a sphere with radius 1\nvec3 topolar(vec2 uv)\n{\n    uv = vec2(2, 1) * (uv - .5) * PI;\n    return vec3(sin(uv.x), 0, cos(uv.x)) * cos(uv.y) + vec3(0, sin(uv.y), 0);\n}\n\n#define T(U) texture(iChannel0, polar(U))\n\n// convert v to a quaternion\n//  - direction of v: axis of rotation (ccw when viewed from above)\n//  - length of v: angle in radians\nvec4 Q(vec3 v)\n{\n    float a = length(v);\n    return vec4(v / (a + 1e-9) * sin(a * .5), cos(a * .5));\n}\n\n// quaternion rotation: rotates the direction v by the quaternion q\nvec3 R(vec4 q, vec3 v)\n{\n    vec3 t = 2. * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 p = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    \n    if(iFrame == 0) p = vec3(0., 0., 2.);\n    fragColor = vec4(p, 0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// https://www.shadertoy.com/view/4lGcWc\n// placeholder fluid sim curtesy of @pyBlob\n\n\n// calculate an arbitrary tangent vector at point U on the surface a sphere\nvec3 getv1(vec3 U)\n{\n    vec3 u = abs(U);\n    float m = max(u.x, max(u.y, u.z));\n    if (u.x == m)\n        return cross(U, vec3(0,1,0));\n    return cross(U, vec3(1,0,0));\n}\n\nvoid mainCubemap(out vec4 q, in vec2 _fc, in vec3 _ro, in vec3 U);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // simulate a cubemap by mapping planar coordinates uv to points U on surface of a sphere\n    mainCubemap(fragColor, fragCoord, vec3(0), topolar(fragCoord / iResolution.xy));\n    //fragColor.xyz = topolar(fragCoord / iResolution.xy);\n}\n\n// radius of the sphere [pixels]\nconst float RA = 1000.;\n// convert surface displacement v [pixels] (the direction is still the rotation axis)\n// 1. to v / RA [radians] (-> angular displacement)\n// 2. to quaternion Q(v / RA)\nvec4 QRA(vec3 v) { return Q(v / RA); }\n\n// read iChannel0\nvec4 t(vec3 U) {\n    return T(U);\n    //return vec4(vec3(1,0,0), T(U).w);\n}\n\nvoid mainCubemap(\n    // q.xyz contains the angular velocity of the fluid at the current position.\n    //   angular velocity is a vector with two components:\n    //     - its direction is the axis of rotation (like for rigidbodies)\n    //       when viewing this axis from above, rotation is always counter-clockwise\n    //     - its length is proportional to the surface speed [pixels/tick]\n    //   e.g. preset=2\n    //      blob has angular velocity vec3(0,10,0) -> points up (\"+y/up\" axis).\n    //      when looking at the \"+y/up\"-axis from above, the blob is at the bottom edge.\n    //      ccw rotation means the that blob will move in the \"-x/left\"-direction.\n    //   e.g. preset=1\n    //      the central ring has angular velocity vec3(0,10,0) -> points up (\"+y/up\" axis).\n    //      when looking at the \"+y/up\"-axis from above, the ring is all around the edge/equator.\n    //      ccw rotation means the whole ring rotates along this edge (like the blob from preset=2).\n    //   e.g. preset=3\n    //      blob has angular velocity vec3(10,0,0) -> points to right (\"+x/right\" axis).\n    //      when looking at the \"+x/right\"-axis from above, the blob is at the left edge.\n    //      ccw rotation means the that blob will move in the \"+y/up\"-direction.\n    // q.w contains the pressure.\n    out vec4 q,\n    // _fc is not used - fragCoord\n    in vec2 _fc,\n    // _ro is not used - 0\n    in vec3 _ro,\n    // point on the surface of the sphere.\n    // normalize(U) is the normal at that point and points out.\n    in vec3 U\n    )\n{\n    // tangent vector that is perpendicular to the normal direction U\n    vec3 _v1 = normalize(getv1(U));\n    // cotangent vector that is perpendicular to both _v1 and U\n    vec3 _v2 = normalize(cross(_v1, U));\n\n    // offsets for the particles (see shader from wyatt)\n    // these are quaternions (rotation instead of displacement)\n    vec4 va = QRA(_v1);\n    vec4 vb = QRA(_v2);\n    vec4 vc = QRA(-_v1);\n    vec4 vd = QRA(-_v2);\n    \n    // particle locations, uses R instead of + (see shader from wyatt)\n    vec3 O = U, A = R(va, U), B = R(vb, U), C = R(-vc, U), D = R(-vd, U);\n    // particle states (see shader from wyatt)\n    vec4 u = t(U), a = t(A), b = t(B), c = t(C), d = t(D);\n\n    vec4 p;\n    vec2 g = vec2(0);\n    \n    #define I 2\n    for (int i=0 ; i<I ; i++)\n    {\n        // move particles R(QRA(-angular_surface_velocity), position) instead of (pos + velocity)\n        U = R(QRA(-u.xyz), U);\n        A = R(QRA(-a.xyz), A);\n        B = R(QRA(-b.xyz), B);\n        C = R(QRA(-c.xyz), C);\n        D = R(QRA(-d.xyz), D);\n        \n        // U and A,B,C,D are close, so we can approximate surface distance by spatial 3d distance.\n        //   -> this is the same as in shader from wyatt\n        p += vec4(\n            // approximately arc length for small velocities\n            length(U-A),\n            length(U-B),\n            length(U-C),\n            length(U-D)\n        ) * RA - 1.;\n        \n        g += vec2(a.w-c.w, b.w-d.w);\n        \n        u = t(U); a = t(A); b = t(B); c = t(C); d = t(D);\n    }\n    \n    q = T(U);\n    vec4 N = (a+b+c+d) / 4.;\n    q = mix(q, N, vec4(0,0,0,1));\n    q.xyz -= (_v1 * g.x + _v2 * g.y) / 10. / float(I);\n    q.w += (p.x + p.y + p.z + p.w) / 10.;\n\n    q.w *= 0.9999;\n\n    //q.xyz = U;\n\n    if (iFrame < 1) q = vec4(0);\n \t#if PRESET == 1\n    \tif (iFrame < 14 && abs(O.y)<.1) q.xyzw = vec4(sin(atan(U.x,U.z)*8.)*.2,4,0,0);\n    #elif PRESET == 2\n    \tif (iFrame < 14 && -O.z>0.99) q.xyzw = vec4(0,10,0,0);\n    #elif PRESET == 3\n    \tif (iFrame < 14 && -O.z>0.999) q.xyzw = vec4(10,0,0,0);\n    #elif PRESET == 4\n    \tU = cos(U * 30.); if (iFrame < 14) q.xyzw = vec4(0, 0, 0, U.x*U.y*U.z);\n    #endif\n}\n", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGXRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[451, 451, 472, 472, 885], [887, 887, 921, 921, 1141], [1143, 1143, 1167, 1167, 1357], [1359, 1359, 1392, 1392, 1954], [1957, 1957, 1987, 1987, 2178], [2180, 2180, 2228, 2228, 2514], [2516, 2516, 2574, 2574, 3514], [3516, 3516, 3541, 3541, 3681], [3683, 3683, 3702, 3702, 4081], [4083, 4083, 4102, 4102, 4225], [4227, 4227, 4253, 4253, 4284], [4287, 4287, 4322, 4322, 4891], [4893, 4893, 4950, 4950, 6224]], "test": "untested"}
{"id": "flyXzD", "name": "Petroff Quincuncial Projection", "author": "paniq", "description": "Implementation of https://dl.acm.org/doi/pdf/10.1145/3460521", "tags": ["uv", "map", "normal", "tiling", "spherical", "octahedron", "equiareal", "petroff"], "likes": 9, "viewed": 406, "published": 3, "date": "1640244725", "time_retrieved": "2024-07-30T18:40:36.726502", "image_code": "/*\n    This work is placed into the public domain via the CC0 1.0 public domain\n    dedication: https://creativecommons.org/publicdomain/zero/1.0/\n*/\n\n// Implementation of\n// A Square Equal-Area Map Projection with Low Angular Distortion, Minimal Cusps, and Closed-Form Solutions\n// by Matthew A. Petroff (https://dl.acm.org/doi/pdf/10.1145/3460521)\n \n// additional sources used:\n// https://bl.ocks.org/mpetroff/dcf7b090eabda85d081d47e8a0c71d4a\n\n// if defined, demonstrate the inverse mapping \n//#define SHOW_INVERSE\n\n// if defined, shows the quincuncial tiling version\n//#define SHOW_QUINCUNCIAL\n\n// if defined, shows an environment map instead of a XYZ color gradient\n// for inverse mode, demonstrates texture mapping\n#define SHOW_CUBEMAP\n\n// if defined, shows latitude/longitude lines\n#define SHOW_FLOW_LINES\n\n// if defined, shows a UV tesselation of quadliterals, and the proportional\n// difference between the quadliteral area and the expected average size (2/N)\n//#define SHOW_SOLID_ANGLE\n\n// if not defined, computes a more accurate solid angle from cosines,\n// though the precision of this method is terrible and is only relevant\n// for rough tesselations anyway.\n#define USE_TRIANGLE_AREA\n\n// subdivisions per quadrant\n#if defined(SHOW_SOLID_ANGLE)||defined(SHOW_INVERSE)\n#undef SHOW_FLOW_LINES\n// solid angle subdivisions\nconst float subdivisions = 128.0;\n#else\n// flow line subdivisions\nconst float subdivisions = 16.0;\n#endif\n\n// thesis related functions\n//////////////////////////////////////////////////////////\n\n//#define TEST_EQUIAREAL\n//#define TEST_INVERTIBLE\n#ifdef TEST_INVERTIBLE\n#undef SHOW_CUBEMAP\n#endif\n\nfloat nzsign(float x) {\n    return (x >= 0.)?1.:-1.;\n}\nvec2 nzsign(vec2 v) {\n    return vec2(nzsign(v.x),nzsign(v.y));\n}\n\nvec2 new_projection(vec3 n) {\n    const float pi = radians(180.);\n    \n    vec2 s = nzsign(n.xy);\n    float lambda = atan(abs(n.y), abs(n.x));\n    float phi = asin(n.z);\n    if (abs(lambda - pi / 2.) > 1e-6) lambda = mod(lambda, pi / 2.);\n    bool q = lambda > pi / 4.; \n    lambda = lambda > pi / 4. ? pi / 2. - lambda : lambda;\n    \n    // Handle edge cases\n    if (phi == pi / 2.) return vec2(0.);\n    if (lambda > pi / 4. - 1e-12)\n        lambda = pi / 4. - 1e-12;\n        \n    const float phi0 = 3. * pi / 8.;\n    const float cos_phi0 = cos(phi0);\n    const float sin_phi0 = sin(phi0);\n\n    const float psi0 = asin(1. / sqrt(2. - cos_phi0 * cos_phi0));\n    const float psi1 = pi - 2. * psi0;\n    const float rho = asin(2. * sin_phi0 / sqrt(3. - cos(2. * phi0)));\n\n    const float hprime = 12. / pi * (psi0 + rho - pi / 2.);\n    const float xiprime = atan((pi * (hprime - 3.) * (hprime - 3.)) / (sqrt(3.) *\n        (pi * (hprime * hprime - 2. * hprime + 45.) - 96. * psi0 - 48. * rho)));\n\n    const float psi0prime = atan(sqrt(3.) / hprime);\n    const float psi1prime = 7. * pi / 6. - psi0prime - xiprime;\n    const float psi2prime = xiprime - pi / 6.;\n    const float rhoprime = atan(hprime / sqrt(3.));\n\n    float lambda0 = floor((lambda + pi / 4.) / (pi / 2.)) * pi / 2.;\n\n    float theta = abs(atan(cos(phi) * sin(lambda - lambda0), sin_phi0 *\n        cos(phi) * cos(lambda - lambda0) - cos_phi0 * sin(phi)));\n    float r = acos(sin_phi0 * sin(phi) + cos_phi0 * cos(phi) *\n        cos(lambda - lambda0));\n\n    float beta;\n    if (theta <= psi0)\n        beta = psi0 - theta;\n    else if (theta <= psi0 + psi1)\n        beta = theta - psi0;\n    else\n        beta = pi - theta;\n\n    float c = theta <= psi0 + psi1 ? acos(cos_phi0 / sqrt(2.)) : pi / 2. - phi0;\n\n    float G, Gprime, F;\n    if (theta <= psi0) {\n        G = psi0;\n        Gprime = psi0prime;\n        F = rho;\n    } else if (theta <= psi0 + psi1) {\n        G = psi1;\n        Gprime = psi1prime;\n        F = pi / 2. - rho;\n    } else {\n        G = psi0;\n        Gprime = psi2prime;\n        F = pi / 4.;\n    }\n\n    float aprime = theta <= psi0 ? hprime : sqrt(hprime * hprime + 3.) *\n        sin(pi / 3. - rhoprime) / sin(xiprime);\n    float cprime = theta <= psi0 + psi1 ? sqrt(hprime * hprime + 3.) : 3. - hprime;\n\n    float x = acos(cos(r) * cos(c) + sin(r) * sin(c) * cos(beta));\n\n    float gamma = asin(sin(beta) * sin(r) / sin(x));\n\n    float epsilon = acos(sin(G) * sin(gamma) * cos(c) - cos(G) * cos(gamma));\n\n    float upupvp = (gamma + G + epsilon - pi) / (F + G - pi / 2.);\n\n    float cos_xy = sqrt(1. - pow(sin(G) * sin(c) / sin(epsilon), 2.));\n    float xpxpyp = sqrt((1. - cos(x)) / (1. - cos_xy));\n\n    float uprime = aprime * upupvp;\n    float xpyp = sqrt(uprime * uprime + cprime * cprime - 2. * uprime * cprime * cos(Gprime));\n    float cos_gammaprime = sqrt(1. - pow((uprime * sin(Gprime) / xpyp), 2.));\n    float xprime = xpyp * xpxpyp;\n    float yprime = xpyp - xprime;\n    float rprime = sqrt(xprime * xprime + cprime * cprime - 2. * xprime * cprime * cos_gammaprime);\n    float alphaprime = acos((yprime * yprime - uprime * uprime - rprime * rprime) / (-2. * uprime * rprime));\n\n    // Put theta back in the correct section\n    float thetaprime;\n    if (theta <= psi0)\n        thetaprime = alphaprime;\n    else if (theta <= psi0 + psi1)\n        thetaprime = 7. * pi / 6. - xiprime - alphaprime;\n    else\n        thetaprime = 7. * pi / 6. - xiprime + alphaprime;\n\n    // Handle edge cases\n    if (lambda < 1e-12)\n        thetaprime = phi < phi0 ? 0. : pi;\n    if (x == 0.) {\n        thetaprime = Gprime;\n        rprime = cprime;\n    }\n\n    float xm = rprime * sin(thetaprime);\n    float ym = -rprime * cos(thetaprime) - (3. - hprime);\n\n    float xy0 = xm * sqrt(3.) / 3.;\n    float xy1 = ym / 3.;\n\n    vec2 point = vec2(xy0, xy1);\n    \n    if (q) {\n        float tmp = point[0];\n        point[0] = -point[1];\n        point[1] = -tmp;\n    }\n    return s*vec2(-point[1], point[0]);\n}\n\nvec2 new_projection_inverse(vec2 uv) {\n    const float pi = radians(180.0);\n    \n    vec2 s = nzsign(uv);\n    vec2 uv0 = -abs(uv);\n    bool t = uv0.y / uv0.x < 1.;\n    uv = t ? uv0.yx : uv0;\n\n    const float phi0 = 3.0 * pi / 8.0;\n    const float cos_phi0 = cos(phi0);\n    const float sin_phi0 = sin(phi0);\n\n    float x_c = 3.0 * uv.x / sqrt(3.0);\n    float y_h = 3.0 * uv.y;\n    \n    const float hprime = 12.0 / pi * (asin(1. / sqrt(2. - cos_phi0 * cos_phi0)) +\n        asin(2. * sin_phi0 / sqrt(3. - cos(2. * phi0))) - pi / 2.);\n    float rprime = sqrt(x_c * x_c + (hprime - 3. - y_h) * (hprime - 3. - y_h));\n    float thetaprime = abs(atan(x_c, hprime - 3. - y_h));\n\n    const float xiprime = atan((pi * (hprime - 3.) * (hprime - 3.)) / (sqrt(3.) *\n        (pi * (hprime * hprime - 2. * hprime + 45.) -\n        96. * asin(1. / sqrt(2. - cos_phi0 * cos_phi0)) -\n        48. * asin(2. * sin_phi0 / sqrt(3. - cos(2. * phi0))))));\n    const float psi0prime = atan(sqrt(3.) / hprime);\n    const float psi1prime = 7. * pi / 6. - psi0prime - xiprime;\n    const float psi2prime = xiprime - pi / 6.;\n\n    float alphaprime;\n    if (thetaprime <= psi0prime)\n        alphaprime = thetaprime;\n    else if (thetaprime <= psi0prime + psi1prime)\n        alphaprime = pi - psi2prime - thetaprime;\n    else\n        alphaprime = thetaprime + psi2prime - pi;\n\n    float c = thetaprime <= psi0prime + psi1prime ? acos(cos_phi0 / sqrt(2.)) : pi / 2. - phi0;\n\n    const float psi0 = asin(1. / sqrt(2. - cos_phi0 * cos_phi0));\n    const float psi1 = pi - 2. * psi0;\n    const float rho = asin(2. * sin_phi0 / sqrt(3. - cos(2. * phi0)));\n\n    // The original publication neglected to mention that the non-prime to\n    // prime replacement should only be done in the condition statements, so G\n    // is still set to psi0 / psi1.\n    float G;\n    float Gprime;\n    float F;\n    if (thetaprime <= psi0prime) {\n        G = psi0;\n        Gprime = psi0prime;\n        F = rho;\n    } else if (thetaprime <= psi0prime + psi1prime) {\n        G = psi1;\n        Gprime = psi1prime;\n        F = pi / 2. - rho;\n    } else {\n        G = psi0;\n        Gprime = psi2prime;\n        F = pi / 4.;\n    }\n\n    float aprime = thetaprime <= psi0prime ? hprime : sqrt(hprime * hprime + 3.) *\n        sin(pi / 3. - atan(hprime / sqrt(3.))) / sin(xiprime);\n    float cprime = thetaprime <= psi0prime + psi1prime ? sqrt(hprime * hprime + 3.) : 3. - hprime;\n\n    float b;\n    if (thetaprime <= psi0prime)\n        b = pi / 4.;\n    else if (thetaprime <= psi0prime + psi1prime)\n        b = atan(sqrt(2.) * tan(phi0));\n    else\n        b = pi / 2. - atan(sqrt(2.) * tan(phi0));\n\n    float betaprime = Gprime - alphaprime;\n    float xprime = sqrt(rprime * rprime + cprime * cprime - 2. * rprime *\n        cprime * cos(betaprime));\n    float gammaprime = xprime > 0. ? asin(rprime * sin(betaprime) / xprime) : 0.;  // Avoid divide by zero\n    float epsilonprime = pi - Gprime - gammaprime;\n    float yprime = epsilonprime > 0. ? rprime * sin(alphaprime) / sin(epsilonprime) : 0.;  // Avoid divide by zero\n    float uprime = sqrt(abs(cprime * cprime +\n        (xprime + yprime) * (xprime + yprime) -\n        2. * cprime * (xprime + yprime) * cos(gammaprime)));  // Take absolute value to avoid negative numbers due numerical precision issues\n    float vprime = aprime - uprime;\n\n    float delta = atan(\n        (-sin(vprime * (F + G - pi / 2.) / aprime))\n        / (cos(b) - cos(vprime * (F + G - pi / 2.) / aprime))\n    );\n\n    float gamma = F - delta;\n    float cos_xy = 1. / sqrt(1. + (tan(b) / cos(delta)) * (tan(b) / cos(delta)));\n\n    float x = acos(1. - (xprime / (xprime + yprime)) * (xprime / (xprime + yprime)) * (1. - cos_xy));\n\n    float r = acos(cos(x) * cos(c) + sin(x) * sin(c) * cos(gamma));\n    float beta = asin(sin(x) * sin(gamma) / sin(r));\n\n    float alpha;\n    if (thetaprime <= psi0prime)\n        alpha = psi0 - beta;\n    else if (thetaprime <= psi0prime + psi1prime)\n        alpha = beta + psi0;  // There was a sign error here in the original publication\n    else\n        alpha = pi - beta;\n\n    float phi = asin(sin_phi0 * cos(r) - cos_phi0 * sin(r) * cos(alpha));\n    float lambda = nzsign(x_c) * atan(sin(alpha) *\n        sin(r) * cos_phi0 / (cos(r) - sin_phi0 * sin(phi)));\n    lambda *= float(abs(phi) != pi / 2.);  // Handle edge case\n    return s*vec2(s.y*(t ? -pi / 2. - lambda : lambda), phi + pi/2.);\n}\n\n// convert tiling uv coordinates [0..2]x[0..1] to a normal on the sphere\nvec3 uv_normal(vec2 uv) {\n    // tile [0..2]x[0..1] to [-1..1]x[-1..1] + hemisphere flag\n    uv = uv/2.0;\n    uv = fract(uv);\n    uv = (uv.y >= 0.5)?(1.0 - uv):uv;\n    bool h = (uv.x >= 0.5);\n    uv.x = h?(1.0 - uv.x):uv.x;\n    uv = uv*4.0 - 1.0;\n    // apply projection\n    uv = new_projection_inverse(uv);\n    // convert from spherical coordinates to normal\n    uv.x += radians(90.0);\n    float phi_s = sin(uv.x);\n    float phi_c = cos(uv.x);\n    float theta_s = sin(uv.y);\n    float theta_c = cos(uv.y);\n    return vec3(\n        theta_s * phi_c,\n        theta_s * phi_s,\n        h?theta_c:-theta_c\n    );\n}\n\n// convert a normal on the sphere to tiling uv coordinates [0..2]x[0..1]\nvec2 normal_uv(vec3 n) {\n    bool h = (n.z < 0.0);\n    \n    uv = new_projection(vec3(n.x, n.y, abs(n.z)));\n    \n    uv = (uv+1.0)/2.0;\n    uv.x = h?(2.0 - uv.x):uv.x;\n    return uv;\n}\n\n// convert tiling quinuncial uv coordinates [0..1]x[0..1] to a normal on the sphere\nvec3 quincuncial_uv_normal(vec2 uv) {\n    uv = vec2(uv.x + uv.y - 0.5, uv.y - uv.x + 0.5);\n    vec3 n = uv_normal(uv);\n    n.xy = vec2(n.x - n.y, n.x + n.y)*sqrt(0.5);\n    return n;\n}\n\n// convert a normal on the sphere to tiling quinuncial uv coordinates [0..1]x[0..1]\nvec2 quincuncial_normal_uv(vec3 n) {\n    n.xy = vec2(n.x + n.y, n.y - n.x)*sqrt(0.5);\n    uv = normal_uv(n);\n    uv = vec2(uv.x - uv.y, uv.x + uv.y - 1.0);\n    uv = (1.0 - abs(uv)) * (step(0.0,uv.yx)*2.0 - 1.0);\n    uv = (1.0 - abs(uv)) * (step(0.0,uv.yx) - 0.5) + 0.5;\n    return uv;\n}\n\n#ifdef SHOW_QUINCUNCIAL\n#define uv_normal quincuncial_uv_normal\n#define normal_uv quincuncial_normal_uv\n#endif\n\n// visualization\n//////////////////////////////////////////////////////////\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a); float s = sin(a);\n    return vec2(p.x*c + p.y*s, -s*p.x + c*p.y);\n}\n\nfloat triangle_area(vec3 A, vec3 B, vec3 C) {\n    return length(cross(B - A, C - A)) / 2.0;\n}\n\nvec2 nanglebasis (vec3 a, vec3 b) {\n    float ab = dot(a, b);\n    return vec2(ab, sqrt(1.0 - ab * ab));\n}\n\nfloat simplex_solid_angle (vec2 u, vec2 v, vec2 w) {\n    float A =\n            acos((u.x - v.x * w.x) / (v.y * w.y))\n            + acos((v.x - w.x * u.x) / (w.y * u.y))\n            + acos((w.x - u.x * v.x) / (u.y * v.y))\n            - radians(180.0);\n    return (A != A)?0.0:A;\n}\n\nfloat pyramid_points_solid_angle (vec3 A, vec3 B, vec3 C, vec3 D) {\n#ifdef USE_TRIANGLE_AREA\n    return triangle_area(A, B, C) + triangle_area(C, D, A);\n#else\n    vec2 ab = nanglebasis(A, B);\n    vec2 ac = nanglebasis(A, C);\n    vec2 da = nanglebasis(A, D);\n    vec2 bc = nanglebasis(B, C);\n    vec2 cd = nanglebasis(C, D);\n    return simplex_solid_angle(bc, ac, ab) + simplex_solid_angle(da, ac, cd);\n#endif\n}\n\n// from https://www.shadertoy.com/view/WlfXRN\nvec3 plasma(float t) {\n\n    const vec3 c0 = vec3(0.05873234392399702, 0.02333670892565664, 0.5433401826748754);\n    const vec3 c1 = vec3(2.176514634195958, 0.2383834171260182, 0.7539604599784036);\n    const vec3 c2 = vec3(-2.689460476458034, -7.455851135738909, 3.110799939717086);\n    const vec3 c3 = vec3(6.130348345893603, 42.3461881477227, -28.51885465332158);\n    const vec3 c4 = vec3(-11.10743619062271, -82.66631109428045, 60.13984767418263);\n    const vec3 c5 = vec3(10.02306557647065, 71.41361770095349, -54.07218655560067);\n    const vec3 c6 = vec3(-3.658713842777788, -22.93153465461149, 18.19190778539828);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvec3 stereographic_sphere(vec2 uv) {\n    vec3 n = vec3(uv, sqrt(1.0 - dot(uv,uv)));\n    float t = iTime*0.1;\n    n.yz = rotate(n.yz, radians(sin(t*0.25*radians(360.0))*45.0));    \n    n.xz = rotate(n.xz, t*radians(360.0));    \n    return n;\n}\n\n//////////////////////////////////////////////////////////\n\n// for inverse mapping\nvec3 transfer_color(vec2 q) {\n#ifdef SHOW_CUBEMAP\n    if (q.x >= 1.0) {\n        q.x = 2.0 - q.x;\n    }\n    return textureLod(iChannel1, q*2.0, 0.0).rgb;\n#elif 1\n    ivec2 p = ivec2(q*subdivisions) & 1;\n    vec3 s = vec3(p.x^p.y)*0.5 + 0.5;\n    q = q - mod(q, 1.0/subdivisions);\n    float b = 0.0;\n    if (q.x >= 1.0) {        \n        b = q.x - 1.0;\n        q.x = 2.0 - q.x;        \n    }\n    return s*vec3(q, b);\n#endif\n}\n\nvec3 transfer_color(vec3 p) {\n#ifdef SHOW_CUBEMAP\n#ifndef TEST_EQUIAREAL\n    p.xz = rotate(p.xz, iTime*0.5);\n#endif\n    return textureLod(iChannel0, p, 0.0).xyz;\n#elif defined(SHOW_INVERSE)\n    vec2 q = normal_uv(p);\n    q = q - mod(q, 1.0/subdivisions);\n    return vec3(q*0.5 + 0.5, 0.0);\n#else\n    return p*0.5 + 0.5;\n#endif\n}\n\nfloat flow_lines(vec3 q) {\n#ifndef TEST_EQUIAREAL\n    q.xz = rotate(q.xz, radians(90.0) + iTime*0.5);\n#endif\n    float a = atan(q.y, q.x);\n    float r = acos(q.z);\n    float A = subdivisions;\n    return sin(a*A)*sin(r*A);\n}\n\nvec2 transform_origin(vec2 p) {\n#ifdef SHOW_QUINCUNCIAL\n    return (p*2.0)*0.5 + 0.5;\n#else\n    return (p*0.5 + 0.5)*vec2(2.0,2.0);\n#endif    \n}\n\nfloat arcmap_flow_lines(vec2 p) {\n    vec2 uv = transform_origin(p);\n    return flow_lines(uv_normal(uv));\n}\n\nbool in_range(vec2 p) {\n    return max(abs(p.x),abs(p.y)) <= 1.0;\n}\n\nvec3 solid_angle_color(vec3 p00, vec3 p10, vec3 p01, vec3 p11) {\n#ifdef SHOW_QUINCUNCIAL\n    // ideal solid angle: 4*pi / subdivisions\n    float isa = 4.0 * radians(180.0) / (subdivisions * subdivisions);\n#else\n    // ideal solid angle: 2*pi / subdivisions\n    float isa = 2.0 * radians(180.0) / (subdivisions * subdivisions);\n#endif\n    float sa1 = pyramid_points_solid_angle(p00,p10,p11,p01);\n    float sa2 = pyramid_points_solid_angle(p10,p00,p01,p11);\n    float sa = (uv.x*uv.y < 0.0)?sa1:sa2;\n#if 1\n    sa = abs(sa/isa-1.0);\n#else\n    sa = abs(log2(sa/isa));\n#endif\n    return plasma(clamp(sa,0.0,1.0));\n}\n\nvoid paint_uv_normal() {\n    set_line_width_px(1.2);\n    \n    vec2 uv = transform_origin(get_origin());\n    #ifdef TEST_INVERTIBLE\n    vec2 p = normal_uv(uv_normal(uv));\n    #else\n    vec3 p = uv_normal(uv);\n    #endif\n    set_source_rgb(transfer_color(p));\n#ifdef SHOW_SOLID_ANGLE\n    float s = 1.0/subdivisions;\n    uv = uv - mod(uv, s) + s * 0.5;\n    vec2 w = 0.5*vec2(-s,s);\n    vec3 p00 = uv_normal(uv + w.xx);\n    vec3 p10 = uv_normal(uv + w.yx);\n    vec3 p01 = uv_normal(uv + w.xy);\n    vec3 p11 = uv_normal(uv + w.yy);\n    set_source_rgb(solid_angle_color(p00,p10,p01,p11));\n#endif\n    rectangle(-1.0,-1.0,2.0,2.0);\n    fill_preserve();    \n    set_source_rgb(vec3(0.0));\n    stroke();\n#ifdef SHOW_FLOW_LINES\n    if (in_range(get_origin())) {\n        graph2D(arcmap_flow_lines);\n        stroke();\n    }\n#endif\n}\n\nvoid paint_normal_uv() {\n    set_line_width_px(1.2);\n    vec3 n = stereographic_sphere(get_origin());  \n    vec2 uv = normal_uv(n);  \n    set_source_rgb(transfer_color(uv));\n    circle(0.0, 0.0, 1.0);\n    fill_preserve();\n    set_source_rgb(vec3(0.0));\n    stroke();\n}\n\nvoid paint() {\n    set_source_rgb(vec3(0.2));\n    clear();\n\n#if defined(SHOW_INVERSE)\n    paint_normal_uv();\n#else\n    paint_uv_normal();\n#endif    \n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord, iMouse.xy, iResolution.xy);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.16\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2020-12-02: 0.16\n// * support for drawing concentric rings\n\n// 2020-11-30: 0.15\n// * support for drawing orthogonal grids\n// * adjusted uv so corners are centered on pixels\n// * small adjustment to line pixel width computation\n\n// 2020-11-12: 0.14\n// * added support for depth testing\n\n// 2020-11-11: 0.13\n// * fixed 2D graphs not filling\n// * added circle_px()\n\n// 2019-06-06: 0.12\n// * split implementation and demo into common and image tab\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\nvoid set_source_depth(float depth);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the old source with the new one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n// if enabled, use the depth value for testing;\n// smaller values win\nvoid depth_test(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add a circle path at P with pixel radius R\nvoid circle_px(vec2 p, float r);\nvoid circle_px(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// add an orthogonal grid with cell size S\nvoid grid(vec2 s);\nvoid grid(float w, float h);\nvoid grid(float s);\n// draw concentric rings around origin p, with spacing r and offset phase\nvoid rings(vec2 p, float r, float phase);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// draw a letter with the given texture coordinate\nvoid letter(sampler2D font_texture_source, ivec2 l);\nvoid letter(sampler2D font_texture_source, int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    bool depth_test;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n    float source_z;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n#define DEFAULT_DEPTH 1e+30\n\nContext _stack;\n\nvoid init (vec2 fragCoord, vec2 mouse, vec2 resolution) {\n\taspect = vec2(resolution.x / resolution.y, 1.0);\n\tScreenH = min(resolution.x,resolution.y);\n\tAA = ScreenH*0.5;\n\tAAINV = 1.0 / AA;\n    \n    uv = (fragCoord.xy - 0.5) / resolution;\n    vec2 m = mouse / resolution;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false,\n        DEFAULT_DEPTH\n    );\n}\n\nvec3 _color = vec3(1);\nfloat _depth = DEFAULT_DEPTH;\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color.rgb = mix(_color.rgb, _stack.source.rgb, _stack.source.a);\n    _depth = (_stack.source.a == 1.0)?_stack.source_z:_depth;\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(pow(_color.rgb, vec3(1.0/2.2)), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color.rgb;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    if (_stack.depth_test) {\n        if ((w == 1.0) && (_stack.source_z <= _depth)) {\n            _depth = _stack.source_z;\n        } else if ((w == 0.0) || (_stack.source_z > _depth)) {            \n            return;\n        }\n    }\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color.rgb = _color.rgb * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\n\nvoid depth_test(bool enable) {\n    _stack.depth_test = enable;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_depth(float depth) {\n    _stack.source_z = depth;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(sampler2D font_texture_source, ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(sampler2D font_texture_source, int lx, int ly) {\n    letter(font_texture_source, ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid grid(vec2 size) {\n    vec4 f = abs(fract(_stack.position/size.xyxy+0.5)-0.5)*size.xyxy;\n    add_field(vec2(min(f.x,f.y),min(f.z,f.w)));\n}\nvoid grid(float w, float h) {\n    grid(vec2(w,h));\n}\nvoid grid(float s) {\n    grid(vec2(s));\n}\nvoid rings(vec2 p, float r, float phase) {\n    vec4 q = _stack.position - p.xyxy;\n    vec2 f = abs(fract(vec2(length(q.xy),length(q.zw))/r-phase+0.5)-0.5)*r;\n    add_field(f);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid circle_px(vec2 p, float r) {\n    circle(p, r/(0.5*ScreenH));\n}\nvoid circle_px(float x, float y, float r) {\n    circle_px(vec2(x,y), r);\n}\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(f_x / length(df_x));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyXzD.jpg", "access": "api", "license": "public-domain", "functions": [[1631, 1631, 1654, 1654, 1685], [1686, 1686, 1707, 1707, 1751], [1753, 1753, 1782, 1782, 5721], [5723, 5723, 5761, 5761, 10104], [10106, 10179, 10204, 10267, 10788], [10790, 10863, 10887, 10887, 11046], [11048, 11132, 11169, 11169, 11315], [11317, 11401, 11437, 11437, 11687], [11878, 11878, 11908, 11908, 11998], [12000, 12000, 12045, 12045, 12093], [12095, 12095, 12130, 12130, 12200], [12202, 12202, 12254, 12254, 12481], [12483, 12483, 12550, 12550, 12893], [12895, 12941, 12963, 12963, 13617], [13619, 13619, 13655, 13655, 13861], [13923, 13946, 13975, 13975, 14368], [14370, 14370, 14399, 14399, 14698], [14700, 14700, 14726, 14726, 14923], [14925, 14925, 14956, 14956, 15069], [15071, 15071, 15104, 15104, 15179], [15181, 15181, 15204, 15204, 15248], [15250, 15250, 15314, 15314, 15864], [15866, 15866, 15890, 15890, 16685], [16687, 16687, 16711, 16711, 16955], [16957, 16957, 16971, 16971, 17107], [17169, 17169, 17226, 17226, 17312]], "test": "untested"}
{"id": "flGSzD", "name": "eindacor_perlincmyk", "author": "Eindacor_DS", "description": "You can't make me describe my shader!", "tags": ["perlin"], "likes": 2, "viewed": 197, "published": 3, "date": "1640235384", "time_retrieved": "2024-07-30T18:40:37.497440", "image_code": "#define PI 3.1415926\n#define AA .001\n\n#define CYAN vec3(0., 1., 1.)\n#define MAGENTA vec3(1., 0., 1.)\n#define YELLOW vec3(1., 1., 0.)\n#define BLACK vec3(0.)\n\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 getRandomVector(float seed) {\n    vec2 outVec;\n    if (seed < .25) {\n        outVec = vec2(1., 1.);\n    } else if (seed < .5) {\n        outVec = vec2(-1., 1.);\n    } else if (seed < .75) {\n        outVec = vec2(1., -1.);\n    } else {\n        outVec = vec2(-1., -1.);\n    }\n    \n    return outVec;\n}\n\nfloat biLerp(float f0, float f1, float f2, float f3, float lerpX, float lerpY) {\n    float upper = mix(f1, f2, lerpX);\n    float lower = mix(f0, f3, lerpX);\n    \n    return mix(lower, upper, lerpY);\n}\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nfloat getModifiedDot(vec2 uv, vec2 p, float gridDimension, float pHash) {   \n    float rotation = sin(iTime * .05 + pHash) * 2. * PI;\n    if (pHash < .5) {\n        rotation *= -1.;\n    }\n    mat2x2 rotationMatrix = createRotationMatrix(rotation);\n\n    return dot((uv - p) / gridDimension, getRandomVector(pHash) * rotationMatrix);\n}\n\nfloat getHoldTransitionValue(float lower, float upper, float holdTime, float transitionTime, float time) {\n    float period = 2. * holdTime + 2. * transitionTime;\n    float halfPeriod = period / 2.;\n    float relativeTime = fract(time / halfPeriod);\n    float halfHoldTime = holdTime / 2.;\n    \n    float val = smoothstep(halfHoldTime, halfHoldTime + transitionTime, relativeTime * halfPeriod);\n    \n    if (int(time / halfPeriod) % 2 == 0) {\n        val = 1. - val;\n    }\n\n    return mix(lower, upper, val);\n}\n\nfloat getPerlinValue(vec2 uv, float gridDimension) {\n    float xCoord = floor(uv.x / gridDimension) * gridDimension;\n    float yCoord = floor(uv.y / gridDimension) * gridDimension;\n    \n    float xIndex = floor(uv.x / gridDimension);\n    float yIndex = floor(uv.y / gridDimension);\n    \n    float p0Hash = hash(vec2(xIndex, yIndex));\n    float p1Hash = hash(vec2(xIndex, yIndex + 1.));\n    float p2Hash = hash(vec2(xIndex + 1., yIndex + 1.));\n    float p3Hash = hash(vec2(xIndex + 1., yIndex));\n    \n    vec2 p0 = vec2(xCoord, yCoord);\n    vec2 p1 = vec2(xCoord, yCoord + gridDimension);\n    vec2 p2 = vec2(xCoord + gridDimension, yCoord + gridDimension);\n    vec2 p3 = vec2(xCoord + gridDimension, yCoord);\n    \n    float rotation = sin(iTime * .15) * 2. * PI;\n    rotation = getHoldTransitionValue(0., 1., 5., 5., iTime);\n    mat2x2 rotationMatrix = createRotationMatrix(rotation);\n    \n    float dot0 = getModifiedDot((uv - p0) * rotationMatrix + p0, p0, gridDimension, p0Hash);\n    float dot1 = getModifiedDot((uv - p1) * rotationMatrix + p1, p1, gridDimension, p1Hash);\n    float dot2 = getModifiedDot((uv - p2) * rotationMatrix + p2, p2, gridDimension, p2Hash);\n    float dot3 = getModifiedDot((uv - p3) * rotationMatrix + p3, p3, gridDimension, p3Hash);\n    \n    float xInterp = smoothstep(p0.x, p2.x, uv.x);\n    float yInterp = smoothstep(p0.y, p2.y, uv.y);\n    \n    float val = biLerp(dot0, dot1, dot2, dot3, xInterp, yInterp);\n\n    float xLerp = mod(uv.x / 2., gridDimension);\n    float revealMargin = gridDimension * .95;\n    \n    \n    return val;\n    return mix(-5., 5., (val + 1.) / 2.);\n}\n\nfloat getPerlinIterationValue(vec2 uv, float gridDimension, int iterations) {\n    float val = getPerlinValue(uv, .1);\n    \n    for (int i=0; i<iterations; ++i) {\n        val += getPerlinValue(uv / pow(2., float(i + 1)), gridDimension);\n    }\n \n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    uv += vec2(iTime * .1);\n    \n    float gridSize = .1;\n    float uvMultiplier = 4.;\n    int iterations = 10;\n    float timeMultiplier = .08;\n    \n    float cyanVal = getPerlinIterationValue((uv) * uvMultiplier, gridSize, iterations);\n    vec3 cyan = mix(vec3(1.), CYAN, cyanVal);\n    \n    float yellowVal = getPerlinIterationValue((uv + vec2(12.3 * gridSize)) * uvMultiplier, gridSize, iterations);\n    vec3 yellow = mix(vec3(1.), YELLOW, yellowVal);\n    \n    float magentaVal = getPerlinIterationValue((uv + vec2(25.5 * gridSize)) * uvMultiplier, gridSize, iterations);\n    vec3 magenta = mix(vec3(1.), MAGENTA, magentaVal);\n    \n    float blackVal = getPerlinIterationValue((uv + vec2(31.8 * gridSize)) * uvMultiplier, gridSize, iterations * 2);\n    vec3 black = mix(vec3(1.), BLACK, blackVal);\n    \n    vec3 mixColor = cyan * yellow * magenta;\n    mixColor.r = clamp(mixColor.r, 0., 1.);\n    mixColor.g = clamp(mixColor.g, 0., 1.);\n    mixColor.b = clamp(mixColor.b, 0., 1.);\n    \n    vec3 inverseMix = vec3(1.) - mixColor;\n    vec3 modColor = vec3(1., .25, .25);\n\n    if (fragCoord.x/iResolution.x < .5) {\n        fragColor = vec4(vec3(1.) - mix(inverseMix, mixColor, blackVal) * modColor, 1.0);\n    } else {\n        fragColor = vec4(mix(inverseMix, mixColor, blackVal) * modColor, 1.0);\n    }\n    \n    float diagonalVal = smoothstep(fragCoord.x / aspectRatio, fragCoord.x / aspectRatio, fragCoord.y);\n    fragColor = mix(vec4(mix(inverseMix, mixColor, blackVal) * modColor, 1.0), vec4(vec3(1.) - mix(inverseMix, mixColor, blackVal) * modColor, 1.0),diagonalVal);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGSzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 204, 224, 224, 290], [292, 292, 326, 326, 595], [597, 597, 677, 677, 797], [799, 799, 844, 844, 948], [950, 950, 1023, 1023, 1282], [1284, 1284, 1390, 1390, 1794], [1796, 1796, 1848, 1848, 3398], [3400, 3400, 3477, 3477, 3661], [3663, 3663, 3720, 3720, 5418]], "test": "untested"}
{"id": "ftySzW", "name": "eindacor_niftysquiggles", "author": "Eindacor_DS", "description": "More colors and stuff, I suppose, idk. Just stare at it.", "tags": ["cmyk"], "likes": 1, "viewed": 217, "published": 3, "date": "1640227743", "time_retrieved": "2024-07-30T18:40:38.247435", "image_code": "#define PI 3.1415926\n#define INVERT true\n\n#define CYAN vec3(0., 1., 1.)\n#define MAGENTA vec3(1., 0., 1.)\n#define YELLOW vec3(1., 1., 0.)\n#define BLACK vec3(0.)\n\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 getRandomVector(float seed) {\n    vec2 outVec;\n    if (seed < .25) {\n        outVec = vec2(1., 1.);\n    } else if (seed < .5) {\n        outVec = vec2(-1., 1.);\n    } else if (seed < .75) {\n        outVec = vec2(1., -1.);\n    } else {\n        outVec = vec2(-1., -1.);\n    }\n    \n    return outVec;\n}\n\nfloat biLerp(float f0, float f1, float f2, float f3, float lerpX, float lerpY) {\n    float upper = mix(f1, f2, lerpX);\n    float lower = mix(f0, f3, lerpX);\n    \n    return mix(lower, upper, lerpY);\n}\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nfloat getModifiedDot(vec2 uv, vec2 p, float gridDimension, float pHash) {\n    float rotation = sin(iTime * .1 + pHash) * 2. * PI;\n    if (pHash < .5) {\n        rotation *= -1.;\n    }\n    mat2x2 rotationMatrix = createRotationMatrix(rotation);\n    \n    //return dot((uv - p) / gridDimension, getRandomVector(pHash));\n    return dot((uv - p) / gridDimension, getRandomVector(pHash) * rotationMatrix);\n}\n\nfloat getPerlinIterationValue(vec2 uv, float gridDimension) {\n    float xCoord = floor(uv.x / gridDimension) * gridDimension;\n    float yCoord = floor(uv.y / gridDimension) * gridDimension;\n    \n    float xIndex = floor(uv.x / gridDimension);\n    float yIndex = floor(uv.y / gridDimension);\n    \n    float p0Hash = hash(vec2(xIndex, yIndex));\n    float p1Hash = hash(vec2(xIndex, yIndex + 1.));\n    float p2Hash = hash(vec2(xIndex + 1., yIndex + 1.));\n    float p3Hash = hash(vec2(xIndex + 1., yIndex));\n    \n    vec2 p0 = vec2(xCoord, yCoord);\n    vec2 p1 = vec2(xCoord, yCoord + gridDimension);\n    vec2 p2 = vec2(xCoord + gridDimension, yCoord + gridDimension);\n    vec2 p3 = vec2(xCoord + gridDimension, yCoord);\n    \n    float rotation = sin(iTime * .15) * 2. * PI;\n    mat2x2 rotationMatrix = createRotationMatrix(rotation);\n    \n    float dot0 = getModifiedDot(uv, p0, gridDimension, p0Hash);\n    float dot1 = getModifiedDot(uv, p1, gridDimension, p1Hash);\n    float dot2 = getModifiedDot(uv, p2, gridDimension, p2Hash);\n    float dot3 = getModifiedDot(uv, p3, gridDimension, p3Hash);\n    \n    float xInterp = smoothstep(p0.x, p2.x, uv.x);\n    float yInterp = smoothstep(p0.y, p2.y, uv.y);\n    \n    float val = biLerp(dot0, dot1, dot2, dot3, xInterp, yInterp);\n\n    float xLerp = mod(uv.x / 2., gridDimension);\n    float revealMargin = gridDimension * .95;\n    \n    return val;\n    return pow(mix(-1., 1., (val + 1.) / 2.), .5);\n}\n\nfloat getPerlinValue(vec2 uv, float gridDimension, int iterations) {\n    uv /= 50.;\n    float val = 0.;\n    for (int i=0; i<iterations; i++) {\n        val += getPerlinIterationValue(uv, gridDimension * 1. / pow(2., float(iterations)));\n        uv *= 2.;\n    }\n    \n    return val;\n}\n\nfloat getHoldTransitionValue(float lower, float upper, float holdTime, float transitionTime, float time) {\n    float period = 2. * holdTime + 2. * transitionTime;\n    float halfPeriod = period / 2.;\n    float relativeTime = fract(time / halfPeriod);\n    float halfHoldTime = holdTime / 2.;\n    \n    float val = smoothstep(halfHoldTime, halfHoldTime + transitionTime, relativeTime * halfPeriod);\n    \n    if (int(time / halfPeriod) % 2 == 0) {\n        val = 1. - val;\n    }\n\n    return mix(lower, upper, val);\n}\n\nvec3 getHoldTransitionValue3(vec3 lower, vec3 upper, float holdTime, float transitionTime, float time) {\n    float period = 2. * holdTime + 2. * transitionTime;\n    float halfPeriod = period / 2.;\n    float relativeTime = fract(time / halfPeriod);\n    float halfHoldTime = holdTime / 2.;\n    \n    float val = smoothstep(halfHoldTime, halfHoldTime + transitionTime, relativeTime * halfPeriod);\n    \n    if (int(time / halfPeriod) % 2 == 0) {\n        val = 1. - val;\n    }\n\n    return mix(lower, upper, val);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n    uv += vec2(iTime * .05);\n   \n    float gridSize = .15;\n    \n    float cyanVal = getPerlinValue(uv, gridSize, 1);\n    vec3 cyan = mix(vec3(1.), getHoldTransitionValue3(CYAN, YELLOW, 5., 5., iTime), cyanVal);\n    \n    float yellowVal = getPerlinValue(uv + vec2(12.3 * gridSize), gridSize, 2);\n    vec3 yellow = mix(vec3(1.), getHoldTransitionValue3(YELLOW, MAGENTA, 5., 5., iTime + 1.), yellowVal);\n    \n    float magentaVal = getPerlinValue(uv + vec2(25.5 * gridSize), gridSize, 3);\n    vec3 magenta = mix(vec3(1.), getHoldTransitionValue3(MAGENTA, CYAN, 5., 5., iTime + 2.), magentaVal);\n    \n    float blackVal = getPerlinValue(uv + vec2(31.8 * gridSize), gridSize, 4);\n    vec3 black = mix(vec3(1.), BLACK, blackVal * getHoldTransitionValue(-1., 1., 0., 10., iTime));\n\n    fragColor = vec4(cyan * yellow * magenta * black,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftySzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 208, 228, 228, 294], [296, 296, 330, 330, 599], [601, 601, 681, 681, 801], [803, 803, 848, 848, 952], [954, 954, 1027, 1027, 1354], [1356, 1356, 1417, 1417, 2793], [2795, 2795, 2863, 2863, 3077], [3079, 3079, 3185, 3185, 3589], [3591, 3591, 3695, 3695, 4099], [4102, 4102, 4159, 4159, 5120]], "test": "untested"}
{"id": "NtyXRW", "name": "eindacor_cmyk", "author": "Eindacor_DS", "description": "Colors and stuff, I suppose.", "tags": ["cmyk"], "likes": 0, "viewed": 188, "published": 3, "date": "1640224946", "time_retrieved": "2024-07-30T18:40:38.998427", "image_code": "#define PI 3.1415926\n#define INVERT true\n\n#define CYAN vec3(0., 1., 1.)\n#define MAGENTA vec3(1., 0., 1.)\n#define YELLOW vec3(1., 1., 0.)\n#define BLACK vec3(0.)\n\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 getRandomVector(float seed) {\n    vec2 outVec;\n    if (seed < .25) {\n        outVec = vec2(1., 1.);\n    } else if (seed < .5) {\n        outVec = vec2(-1., 1.);\n    } else if (seed < .75) {\n        outVec = vec2(1., -1.);\n    } else {\n        outVec = vec2(-1., -1.);\n    }\n    \n    return outVec;\n}\n\nfloat biLerp(float f0, float f1, float f2, float f3, float lerpX, float lerpY) {\n    float upper = mix(f1, f2, lerpX);\n    float lower = mix(f0, f3, lerpX);\n    \n    return mix(lower, upper, lerpY);\n}\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nfloat getModifiedDot(vec2 uv, vec2 p, float gridDimension, float pHash) {\n    float rotation = sin(iTime * .1 + pHash) * 2. * PI;\n    if (pHash < .5) {\n        rotation *= -1.;\n    }\n    mat2x2 rotationMatrix = createRotationMatrix(rotation);\n    \n    //return dot((uv - p) / gridDimension, getRandomVector(pHash));\n    return dot((uv - p) / gridDimension, getRandomVector(pHash) * rotationMatrix);\n}\n\n\nfloat getPerlinValue(vec2 uv, float gridDimension) {\n    float xCoord = floor(uv.x / gridDimension) * gridDimension;\n    float yCoord = floor(uv.y / gridDimension) * gridDimension;\n    \n    float xIndex = floor(uv.x / gridDimension);\n    float yIndex = floor(uv.y / gridDimension);\n    \n    float p0Hash = hash(vec2(xIndex, yIndex));\n    float p1Hash = hash(vec2(xIndex, yIndex + 1.));\n    float p2Hash = hash(vec2(xIndex + 1., yIndex + 1.));\n    float p3Hash = hash(vec2(xIndex + 1., yIndex));\n    \n    vec2 p0 = vec2(xCoord, yCoord);\n    vec2 p1 = vec2(xCoord, yCoord + gridDimension);\n    vec2 p2 = vec2(xCoord + gridDimension, yCoord + gridDimension);\n    vec2 p3 = vec2(xCoord + gridDimension, yCoord);\n    \n    float rotation = sin(iTime * .15) * 2. * PI;\n    mat2x2 rotationMatrix = createRotationMatrix(rotation);\n    \n    float dot0 = getModifiedDot(uv, p0, gridDimension, p0Hash);\n    float dot1 = getModifiedDot(uv, p1, gridDimension, p1Hash);\n    float dot2 = getModifiedDot(uv, p2, gridDimension, p2Hash);\n    float dot3 = getModifiedDot(uv, p3, gridDimension, p3Hash);\n    \n    float xInterp = smoothstep(p0.x, p2.x, uv.x);\n    float yInterp = smoothstep(p0.y, p2.y, uv.y);\n    \n    float val = biLerp(dot0, dot1, dot2, dot3, xInterp, yInterp);\n\n    float xLerp = mod(uv.x / 2., gridDimension);\n    float revealMargin = gridDimension * .95;\n    \n    return val;\n    //return pow(mix(-0., 1., (val + 1.) / 2.), .5);\n}\n\nfloat getHoldTransitionValue(float lower, float upper, float holdTime, float transitionTime, float time) {\n    float period = 2. * holdTime + 2. * transitionTime;\n    float halfPeriod = period / 2.;\n    float relativeTime = fract(time / halfPeriod);\n    float halfHoldTime = holdTime / 2.;\n    \n    float val = smoothstep(halfHoldTime, halfHoldTime + transitionTime, relativeTime * halfPeriod);\n    \n    if (int(time / halfPeriod) % 2 == 0) {\n        val = 1. - val;\n    }\n\n    return mix(lower, upper, val);\n}\n\nvec3 getHoldTransitionValue3(vec3 lower, vec3 upper, float holdTime, float transitionTime, float time) {\n    float period = 2. * holdTime + 2. * transitionTime;\n    float halfPeriod = period / 2.;\n    float relativeTime = fract(time / halfPeriod);\n    float halfHoldTime = holdTime / 2.;\n    \n    float val = smoothstep(halfHoldTime, halfHoldTime + transitionTime, relativeTime * halfPeriod);\n    \n    if (int(time / halfPeriod) % 2 == 0) {\n        val = 1. - val;\n    }\n\n    return mix(lower, upper, val);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n    uv += vec2(iTime * .05);\n   \n    float gridSize = .15;\n    \n    float cyanVal = getPerlinValue(uv, gridSize);\n    vec3 cyan = mix(vec3(1.), getHoldTransitionValue3(CYAN, YELLOW, 5., 5., iTime), cyanVal);\n    \n    float yellowVal = getPerlinValue(uv + vec2(12.3 * gridSize), gridSize);\n    vec3 yellow = mix(vec3(1.), getHoldTransitionValue3(YELLOW, MAGENTA, 5., 5., iTime + 1.), yellowVal);\n    \n    float magentaVal = getPerlinValue(uv + vec2(25.5 * gridSize), gridSize);\n    vec3 magenta = mix(vec3(1.), getHoldTransitionValue3(MAGENTA, CYAN, 5., 5., iTime + 2.), magentaVal);\n    \n    float blackVal = getPerlinValue(uv + vec2(31.8 * gridSize), gridSize);\n    vec3 black = mix(vec3(1.), BLACK, blackVal * getHoldTransitionValue(-1., 1., 10., 10., iTime));\n\n    fragColor = vec4(cyan * yellow * magenta * black,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtyXRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 208, 228, 228, 294], [296, 296, 330, 330, 599], [601, 601, 681, 681, 801], [803, 803, 848, 848, 952], [954, 954, 1027, 1027, 1354], [1357, 1357, 1409, 1409, 2787], [2789, 2789, 2895, 2895, 3299], [3301, 3301, 3405, 3405, 3809], [3812, 3812, 3869, 3869, 4819]], "test": "untested"}
{"id": "NtGSRW", "name": "happy bouncing variation 4", "author": "leon", "description": "shader about boucing animation, space transformation, easing functions, funny shape and colorful vibes.", "tags": ["colorful", "animation"], "likes": 25, "viewed": 434, "published": 3, "date": "1640222425", "time_retrieved": "2024-07-30T18:40:39.756400", "image_code": "// \"happy bouncing v4\"\n// shader about boucing animation, space transformation, easing functions,\n// funny shape and colorful vibes.\n// by leon denise (2021-12-22)\n// licensed under hippie love conspiracy\n\n// using Inigo Quilez works:\n// arc sdf from https://www.shadertoy.com/view/wl23RK\n// color palette https://iquilezles.org/articles/palettes\n\nfloat globalSpeed = 0.5;\nconst float pi = 3.1415;\n\nvec2 animation(vec2 p, float t)\n{\n    float ta = fract(t)*6.283;\n    float tt = t;\n    \n    p.y -= 0.15; // sidebar\n    p *= rot(sin(ta)*.2*ss(.0,.5,p.y+.2)); // swing\n    \n    return p;\n}\n\nvec4 buddy (vec2 pp, vec3 tint, float t, float ii)\n{\n    // result\n    float scene = 100.;\n    vec3 col = vec3(0);\n    \n    // variables\n    vec2 p, q;\n    float shape, zhape;\n    float ta = t*6.283;\n    float bodySize = 0.25;\n    float turn = sin(t*6.283*.5-.5)*2.;\n    \n    // body\n    p = animation(pp, t);\n    float body = circle(p, bodySize);\n\n    p = animation(pp, t-.01)+vec2(0.,-1.)*bodySize;\n    p.x = abs(p.x)-0.1;\n    zhape = circle(p*vec2(.7,.4), 0.02);\n    body = smin(body, zhape, .04);\n    \n    // mouth\n    p = animation(pp, t + .02)+vec2(-.2*turn,.5)*bodySize;\n    q = p;\n    shape = smin(body, circle(p, 0.1), 0.2);\n    add(shape, tint, scene, col);\n    col *= clp(zhape*10.+.5)*-.2+1.;\n    p *= 1.5;\n    p.x = abs(p.x)-0.05;\n    shape = sdArc(p+vec2(0,.1), pi/-3., 2., .05, .02);\n    add(shape, tint*.6, scene, col);\n    \n    // nose\n    shape = circle(q-vec2(0,.02), .04);\n    add(shape, tint*.5, scene, col);\n    col *= shadow(shape);\n\n    // eyes\n    shape = 100.;\n    p = animation(pp, t+.02);\n    p = p - vec2(.2*turn, .6)*bodySize;\n    p.x = abs(p.x)-0.04;\n    add(circle(p, 0.04), vec3(1)*ss(-.2,0.2,p.y+.1), shape, col);\n    add(circle(p+vec2(.01), 0.02), vec3(0), shape, col);\n    col *= shadow(shape);\n    scene = min(scene, shape);\n    \n    return vec4(col, scene);\n}\n\nvoid mainImage( out vec4 color, in vec2 pixel )\n{\n    vec2 uv = pixel/iResolution.xy;\n    color = vec4(.25)*step(uv.y,0.1); // sidebar\n    \n    vec4 shape;\n    vec2 pos = (pixel-vec2(0.5,0)*iResolution.xy)/iResolution.y;\n    vec2 p, pp;\n    \n    // rolling buddy\n    p = pos;\n    p.y -= 0.1;\n    p.x -= fract(iTime*globalSpeed*.5+.61)*2.-1.;\n    p *= rot(pos.x*20.);\n    shape = vec4(vec3(0.976,0.976,0.424)*ss(.1,.0,length(p)), circle(p,.04));\n    add(shape, color);\n    p.y += 0.02;\n    add(vec4(vec3(0), sdArc(p, pi/-2., 1., 0.02, .005)), color);\n    p.x = abs(p.x)-0.01;\n    p.y -= 0.03;\n    add(vec4(vec3(0), circle(p, 0.006)), color);\n    color.rgb *= shadow(shape.a);\n    \n    // bouncing buddies\n    const float instances = 5.;\n    for (float i = 0.; i < instances; ++i)\n    {\n        float ii = i/(instances);\n        float iy = i/(instances-1.);\n        float t = (iTime*globalSpeed + iy);\n        \n        // distribute instances\n        p = pos;\n        p.x += (iy*2.-1.)*.6;\n        p.y -= .15;\n        \n        // scale\n        p *= 2.;\n        \n        // jump animation\n        float ta = fract(t)*6.283;\n        float tt = sin(clp(fract(t*.5)*3.)*3.14);\n        p += vec2(0.,-abs(sin(ta))*2.)*tt*.3; // looping\n        p.y *= 1.+.1*sin(ta*4.)*tt; // stretch\n        \n        float dist = length(animation(p,t));\n        \n        // color palette by Inigo Quilez\n        vec3 tint = .5+.5*cos(vec3(0.,.3,.6)*6.28 + i*5. + dist*-2.);\n        \n        // glow\n        color.rgb += tint * clp(-dist+.4)*2.;\n        \n        // add shape to frame\n        add(buddy(p, tint, t, ii), color);\n    }\n}", "image_inputs": [], "common_code": "\n#define fill(sdf) (smoothstep(.001, 0., sdf))\n#define repeat(p,r) (mod(p,r)-r/2.)\n#define ss(a,b,t) (smoothstep(a,b,t))\n#define clp(t) (clamp(t,0.,1.))\n\n// add shape to layer\nvoid add (in float sdf, in vec3 col, inout float sdfLayers, inout vec3 colLayers)\n{\n    colLayers = mix(colLayers, col, fill(sdf));\n    sdfLayers = min(sdf, sdfLayers);\n}\n\n// add shape to frame\nvoid add(in vec4 shape, inout vec4 frame)\n{\n    if (shape.a < 0.) frame.rgb = shape.rgb;\n}\n\n// soft drop shadow from shape \nfloat shadow (float sdf)\n{\n    return clamp(sdf+.9,0.,1.);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdArc( in vec2 p, in float ta, in float tb, in float ra, float rb )\n{\n    p.y -= ra; // offset y\n    vec2 sca = vec2(sin(ta),cos(ta));\n    vec2 scb = vec2(sin(tb),cos(tb));\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p,scb) : length(p);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \n// snippets\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat circle (vec2 p, float size)\n{\n    return length(p)-size;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGSRW.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[399, 399, 432, 432, 587], [589, 589, 641, 655, 1886], [1888, 1888, 1937, 1937, 3497]], "test": "untested"}
{"id": "Nl3XWX", "name": "Chain Thing", "author": "oneshade", "description": "Click and drag with the mouse.", "tags": ["string", "path", "following"], "likes": 22, "viewed": 328, "published": 3, "date": "1640220281", "time_retrieved": "2024-07-30T18:40:40.509387", "image_code": "float sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n#define drawSDF(dist, color) fragColor.rgb = mix(fragColor.rgb, color, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    fragColor = vec4(1.0);\n\n    vec2[JOINTS] joints;\n    for (int n=0; n < JOINTS; n++) {\n        joints[n] = load(ivec2(n, 0)).xy;\n    }\n\n    vec2 prev = joints[0];\n    drawSDF(length(uv - prev) - 0.01, vec3(0.0));\n    for (int n=1; n < JOINTS; n++) {\n        vec2 cur = joints[n];\n        drawSDF(length(uv - joints[n]) - 0.01, vec3(0.0));\n        drawSDF(sdLine(uv, prev, cur) - 0.001, vec3(0.0));\n        prev = cur;\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 state, in vec2 addr) {\n    state = vec4(0.0);\n    ivec2 iAddr = ivec2(addr);\n    if (iFrame == 0) {\n        if (iAddr.x < JOINTS && iAddr.y == 0) {\n            state.x = -addr.x / 50.0;\n            if (iAddr.x == 0) state.z = 0.01;\n        }\n    }\n\n    if (iFrame > 0) {\n        if (iAddr.x < JOINTS && iAddr.y == 0) {\n            vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n            vec2 corner = vec2(0.5 * iResolution.x / iResolution.y, 0.5) - 0.02;\n\n            vec4[JOINTS] joints;\n            for (int n=0; n < JOINTS; n++) {\n                joints[n] = load(ivec2(n, 0));\n            }\n\n            joints[0].xy += (mouse - joints[0].xy) * 0.1;\n            joints[0] = restrain(joints[0], -corner, corner);\n\n            for (int n=1; n < JOINTS; n++) {\n                joints[n].zw.y -= GRAVITY * dt;\n                joints[n].xy += joints[n].zw * dt;\n\n                vec4 next = load(ivec2(iAddr.x - 1, 0));\n                vec2 toNext = joints[n - 1].xy - joints[n].xy;\n\n                vec2 dirToNext = normalize(toNext);\n                vec2 tangent = vec2(-dirToNext.y, dirToNext.x);\n                joints[n].zw = tangent * dot(joints[n].zw, tangent) * JOINT_FRICTION;\n\n                joints[n].xy = joints[n - 1].xy - normalize(toNext) * SPACING;\n                joints[n] = restrain(joints[n], -corner, corner);\n            }\n\n            state = joints[iAddr.x];\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define load(frag) texelFetch(iChannel0, frag, 0)\n\n#define JOINTS 10\n#define SPACING 0.1\n#define GRAVITY 0.05\n\n#define BOUNDARY_FRICTION 1.0\n#define JOINT_FRICTION 0.85\n\n#define dt 0.2\n\nvec4 restrain(in vec4 p, in vec2 a, in vec2 b) {\n    if (p.x < a.x) {\n        p.x = a.x;\n        if (p.z < 0.0) p.z = -BOUNDARY_FRICTION * p.z;\n    }\n\n    if (p.x > b.x) {\n        p.x = b.x;\n        if (p.z > 0.0) p.z = -BOUNDARY_FRICTION * p.z;\n    }\n\n    if (p.y < a.y) {\n        p.y = a.y;\n        if (p.w < 0.0) p.w = -BOUNDARY_FRICTION * p.w;\n    }\n\n    if (p.y > b.y) {\n        p.y = b.y;\n        if (p.w > 0.0) p.w = -BOUNDARY_FRICTION * p.w;\n    }\n\n    return p;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat snoise(in float x) {\n    return mix(Hash11(floor(x)), Hash11(ceil(x)), smoothstep(0.0, 1.0, fract(x)));\n}\n\nfloat fbm(in float x, in float scale, in int octaves) {\n    x *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (int o=0; o < octaves; o++) {\n        value += snoise(x) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        x *= 2.0;\n    }\n\n    return value / tscale;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3XWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 155]], "test": "untested"}
{"id": "slVXR1", "name": "twisty refract", "author": "pema99", "description": "a", "tags": ["raymarching"], "likes": 6, "viewed": 292, "published": 3, "date": "1640210987", "time_retrieved": "2024-07-30T18:40:41.250406", "image_code": "#define PI (22.0/7.0)\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nmat2 rot(float r)\n{\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat ball(vec3 p)\n{\n    // scale\n    float scale = cos(iTime*3.)*0.2+1.0;\n    p *= scale;   \n\n    // twist\n    float twist = sin(iTime*3.);\n    p.xz *= rot(mix(0., p.y*6., twist));\n    \n    // rot cube\n    p.xz *= rot(iTime);\n    p.xy *= rot(1.);\n   \n    // bulge\n    float bulge = cos(iTime*3.);\n    p += bulge*(0.07*(sin(p.x*p.y*p.z*200.)*0.5+0.5));\n    \n    // bloat\n    float bloat = sin(iTime*6.)*0.5+0.5;\n    return mix(sdBox(p, vec3(0.4)), length(p)-0.65, bloat);\n}\n\nfloat map(vec3 p)\n{\n    vec3 c = vec3(3.);\n    vec3 q = p;\n    //vec3 q = mod(p+0.5*c,c)-0.5*c;\n    float d = ball(q);\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    vec3 p = ro;\n    int i = 0;\n    for (; i < 100; i++)\n    {\n        float dist = map(p)*0.7;\n        if (dist < 0.001) break;\n        t += dist;\n        p = ro + t * rd;\n    }\n    return vec2(t, i);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 o = vec2(0.001, 0.);\n    return normalize(vec3(\n        map(p + o.xyy) - map(p - o.xyy),\n        map(p + o.yxy) - map(p - o.yxy),\n        map(p + o.yyx) - map(p - o.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * ((fragCoord/iResolution.xy) - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    for (int i = 0; i < 2; i++)\n    {\n        for (int j = 0; j < 2; j++)\n        {\n            vec3 ro = vec3(0., 0., -3.);\n            vec3 rd = normalize(vec3(uv + vec2(float(i)*0.5+0.25, float(j)*0.5+0.25)*0.006, 0.) - ro);\n            ro.xz *= rot(iTime);\n            rd.xz *= rot(iTime);\n\n            vec2 res = march(ro, rd);\n            float dist = res.x;\n            float iters = res.y;\n\n            if (dist < 10.)\n            {\n                col.r += texture(iChannel0, refract(rd, normal(ro + dist * rd), 1.0/1.07)).r*0.25;\n                //col += (normal(ro + dist * rd) * 0.5 + 0.5) * 0.25;\n            }\n            else\n            {\n                col.r += texture(iChannel0, rd).r*0.25;\n            }\n        }\n    }\n    for (int i = 0; i < 2; i++)\n    {\n        for (int j = 0; j < 2; j++)\n        {\n            vec3 ro = vec3(0., 0., -3.);\n            vec3 rd = normalize(vec3(uv + vec2(float(i)*0.5+0.25, float(j)*0.5+0.25)*0.006, 0.) - ro);\n            ro.xz *= rot(iTime);\n            rd.xz *= rot(iTime+0.015);\n\n            vec2 res = march(ro, rd);\n            float dist = res.x;\n            float iters = res.y;\n\n            if (dist < 10.)\n            {\n                col.gb += texture(iChannel0, refract(rd, normal(ro + dist * rd), 1.0/1.07)).gb*0.25;\n                //col += (normal(ro + dist * rd) * 0.5 + 0.5) * 0.25;\n            }\n            else\n            {\n                col.gb += texture(iChannel0, rd).gb*0.25;\n            }\n        }\n    }\n    // don't do this, kids. I'm just too lazy to add the chromatic aberration as a second pass postprocess\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVXR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 54, 54, 145], [147, 147, 190, 190, 289], [291, 291, 310, 310, 362], [364, 364, 384, 397, 837], [839, 839, 858, 858, 973], [975, 975, 1005, 1005, 1227], [1229, 1229, 1250, 1250, 1439], [1441, 1441, 1498, 1548, 3315]], "test": "untested"}
{"id": "7tVXR1", "name": "twisty shiny", "author": "pema99", "description": "a", "tags": ["raymarching"], "likes": 5, "viewed": 314, "published": 3, "date": "1640210722", "time_retrieved": "2024-07-30T18:40:42.012368", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.r = texture(iChannel0, fragCoord.xy / iResolution.xy).r;\n    fragColor.gb = texture(iChannel0, fragCoord.xy / iResolution.xy + vec2(0.011, 0.)).gb;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI (22.0/7.0)\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nmat2 rot(float r)\n{\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat ball(vec3 p)\n{\n    // scale\n    float scale = cos(iTime*3.)*0.2+1.0;\n    p *= scale;   \n\n    // twist\n    float twist = sin(iTime*3.);\n    p.xz *= rot(mix(0., p.y*6., twist));\n    \n    // rot cube\n    p.xz *= rot(iTime);\n    p.xy *= rot(1.);\n   \n    // bulge\n    float bulge = cos(iTime*3.);\n    p += bulge*(0.07*(sin(p.x*p.y*p.z*200.)*0.5+0.5));\n    \n    // bloat\n    float bloat = sin(iTime*6.)*0.5+0.5;\n    return mix(sdBox(p, vec3(0.4)), length(p)-0.65, bloat);\n}\n\nfloat map(vec3 p)\n{\n    vec3 c = vec3(3.);\n    vec3 q = p;\n    //vec3 q = mod(p+0.5*c,c)-0.5*c;\n    float d = ball(q);\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    vec3 p = ro;\n    int i = 0;\n    for (; i < 100; i++)\n    {\n        float dist = map(p)*0.6;\n        if (dist < 0.001) break;\n        t += dist;\n        p = ro + t * rd;\n    }\n    return vec2(t, i);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 o = vec2(0.001, 0.);\n    return normalize(vec3(\n        map(p + o.xyy) - map(p - o.xyy),\n        map(p + o.yxy) - map(p - o.yxy),\n        map(p + o.yyx) - map(p - o.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * ((fragCoord/iResolution.xy) - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    for (int i = 0; i < 2; i++)\n    {\n        for (int j = 0; j < 2; j++)\n        {\n            vec3 ro = vec3(0., 0., -3.);\n            vec3 rd = normalize(vec3(uv + vec2(float(i)*0.5+0.25, float(j)*0.5+0.25)*0.006, 0.) - ro);\n            ro.xz *= rot(iTime*0.3);\n            rd.xz *= rot(iTime*0.3);\n\n            vec2 res = march(ro, rd);\n            float dist = res.x;\n            float iters = res.y;\n\n            if (dist < 10.)\n            {\n                col.rgb += texture(iChannel0, reflect(rd, normal(ro + dist * rd))).rgb*0.25;\n                //col += (normal(ro + dist * rd) * 0.5 + 0.5) * 0.25;\n            }\n            else\n            {\n                col.rgb += texture(iChannel0, rd).rgb*0.25;\n            }\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVXR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 221]], "test": "untested"}
{"id": "stKXR1", "name": "rotate camera", "author": "jorge2017a2", "description": "rotate camera", "tags": ["camera", "rotate"], "likes": 3, "viewed": 373, "published": 3, "date": "1640209837", "time_retrieved": "2024-07-30T18:40:42.770342", "image_code": "///-------------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  \n    p.y-=10.0;\n    vec3 p0=p;\n    float planeDist1 = p.y+10.0;  \n\t\n   \n    res =opU3(res, vec3(planeDist1,-1.0,7.0)); //inf\n   \n    p.y=p.y+8.0;\n    float  d0= sdBox( p-vec3( 0.0,0.0,0.0),    vec3(1.0,3.0,1.0) );\n    float  d1= sdBox( p-vec3(-10.0,0.0,0.0),   vec3(1.0,3.0,1.0) );\n    float  d2= sdBox( p-vec3( 10.0,0.0,0.0),   vec3(1.0,3.0,1.0) );\n    float  d3= sdBox( p-vec3(-10.0,0.0,10.0),  vec3(1.0,3.0,1.0) );\n    float  d4= sdBox( p-vec3( 10.0,0.0,10.0),  vec3(1.0,3.0,1.0) );\n    float  d5= sdBox( p-vec3(-10.0,0.0,-10.0), vec3(1.0,3.0,1.0) );\n    float  d6= sdBox( p-vec3( 10.0,0.0,-10.0), vec3(1.0,3.0,1.0) );\n    \n    \n    float  d7= sdSphere(p-vec3(0.0,4.5,0.0),1.5 );\n    \n    float t = iTime*3.0;\n    float r=6.0;\n    vec3 rotation = vec3(r*sin(t), 0.0, r*cos(t));\n    vec3 pos=p0;\n    pos+=vec3(0.0,3.0,0.0);\n    pos+=rotation / 2.0;\n    \n   \n     rotation = vec3(0.0, r*sin(t), r*cos(t));\n    vec3 pos1=p0;\n    pos1+=vec3(0.0,3.0,0.0);\n    pos1+=rotation / 2.0;\n    \n    \n    rotation = vec3(r*sin(t),r*cos(t) ,0.0 );\n    vec3 pos2=p0;\n    pos2+=vec3(0.0,3.0,0.0);\n    pos2+=rotation / 2.0;\n    \n    float  d8=   sdSphere(pos,0.5 );\n    float  d9=  sdSphere(pos1,0.5 );\n    float  d10= sdSphere(pos2,0.5 );\n    \n    res =opU3(res, vec3(d0,1.0,-1.0)); \n    res =opU3(res, vec3(d1,2.0,-1.0)); \n    res =opU3(res, vec3(d2,3.0,-1.0)); \n    res =opU3(res, vec3(d3,4.0,-1.0)); \n    res =opU3(res, vec3(d4,5.0,-1.0));\n    res =opU3(res, vec3(d5,6.0,-1.0));\n    res =opU3(res, vec3(d6,7.0,-1.0));\n    \n    res =opU3(res, vec3(d7,8.0,-1.0));\n    res =opU3(res, vec3(d8,10.0,-1.0));\n    res =opU3(res, vec3(d9,11.0,-1.0));\n    res =opU3(res, vec3(d10,12.0,-1.0));\n    return res;\n}\n\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n      lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n}\n\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==7.0)\n    {return pattern( p.xz );}\n    \n    if (id_material==8.0)\n    {return pattern( p.xy );}\n    \n    if (id_material==9.0)\n    {return pattern( p.zy );}    \n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2)*light_color2;\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n   \n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(  10.0, 10.0, -15.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0,15.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,6.0,0.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n   \n   //float r=10.0;\n   //float veltime=30.0;  \n   \n   float r=20.0+10.0*sin(iTime*0.25);\n   float veltime=10.0+10.0*sin(5.0+iTime*0.25);  \n   \n    float tt = radians( iTime*veltime);\n    vec3  pos=vec3(0.0,0.0,-1.0);\n    vec3 rotation1 = pos+vec3(r*sin(tt), 0.0, r*cos(tt));\n    ro +=rotation1;\n       \n    rd=rotate_y( vec3(-rd.x,rd.y,-rd.z), tt);\n    vec3 col= Render( ro,  rd);\n    \n    //col = exposureToneMapping(2.0, col);\n    col = linear2srgb(col);\n    \n   \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{   if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) return Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKXR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[501, 501, 537, 537, 558], [559, 559, 591, 591, 675], [677, 702, 736, 736, 832], [833, 833, 867, 867, 958], [959, 959, 993, 993, 1084], [1086, 1086, 1120, 1120, 1215], [1217, 1217, 1242, 1242, 2968], [2971, 2971, 2995, 2995, 3157], [3159, 3159, 3208, 3208, 3840], [3843, 3843, 3879, 3879, 4124], [4126, 4126, 4153, 4153, 4170], [4172, 4172, 4208, 4208, 4300], [4301, 4301, 4347, 4347, 4472], [4474, 4474, 4548, 4548, 6110], [6113, 6113, 6193, 6193, 6316], [6318, 6318, 6350, 6350, 6547], [6549, 6597, 6625, 6625, 6813], [6815, 6815, 6862, 6862, 7095], [7097, 7097, 7190, 7190, 7536], [7539, 7539, 7570, 7570, 8200], [8202, 8202, 8228, 8228, 8338], [8340, 8340, 8398, 8398, 8450], [8452, 8452, 8509, 8509, 9415]], "test": "untested"}
{"id": "slVSzh", "name": "Matrix code rain", "author": "paz7", "description": "Wanted to recreate the effect where leader characters \"stamp\" trail characters behind themselves.\n\nMerry Matrix Christmas everybody :)\n\nTODO:\n-find better characters", "tags": ["2d", "rain", "code", "matrix"], "likes": 13, "viewed": 483, "published": 3, "date": "1640209624", "time_retrieved": "2024-07-30T18:40:43.531307", "image_code": "//shader properities to play with\nfloat rows = 64.;\nfloat columns = 128.;\nfloat speed = 0.05;\n\nfloat gridRows(float t){\n    return fract(ceil(t*rows)/rows);\n}\n\nfloat gridColumns(float t){\n    return fract(ceil(t*columns)/columns);\n}\n\n//indecies of the gird\nvec2 grid(vec2 t){\n    return vec2(gridColumns(t.x),gridRows(t.y));\n}\n//UVs of grid tiles\nvec2 gridUV(vec2 t){\n\n    return vec2(fract(t.x*columns),fract(t.y*rows));\n}\n\nfloat leader(vec2 uv, float xpos, float yOffset){\n    //snap to grid on the x axis\n    xpos = gridColumns(xpos);\n    uv.x = gridColumns(uv.x);\n    \n    float leader = floor((fract(abs(-yOffset-1./rows - uv.y))+1./rows));//horizontal mask\n    leader *= floor(1.-(abs(xpos-uv.x)));//vertical mask\n    return clamp01(leader);\n}\n\nfloat trail(vec2 uv, float xpos, float yOffset){\n    //snap both axes\n    uv = grid(uv);\n    xpos = gridColumns(xpos);\n    yOffset = gridRows(yOffset);\n    \n    float trail = 1.-(fract(abs(-yOffset-uv.y))+1./rows);//trail    \n    trail = clamp01(trail*2.-1.);//remap\n    trail *= floor(1.-(abs(xpos-uv.x)));//vertical mask    \n    return trail;\n}\n\nfloat character(vec2 screenUV, vec2 uv, float index){   \n    index += floor(screenUV.x * columns)/256.;//offset by position\n    index += floor((iTime)*speed*columns/5.)/256.;//offset by time\n    index = fract(index)*255.;//remap to 0.-255.;\n    index = floor(index);\n    \n    vec2 charUV = fract(uv/16.);\n    charUV.x += floor(mod(index,16.))/16.;\n    charUV.y += floor(index/16.)/16.;\n    \n    return texture(iChannel0,charUV).x;\n}\n\nfloat trailCharacter(vec2 uv){\n    return character(uv,gridUV(uv),grid(uv).y);\n}\n\nfloat leaderCharacter(vec2 uv, vec2 time){\n    return character(uv,gridUV(uv+fract(time*rows)/rows),grid(uv+fract(time*rows)/rows).y);\n}\n\n//credit: https://www.flickr.com/photos/kynd/9546075099/\nfloat func(float t){\n    t = t*2. - 1.;\n    return 1. - pow(max(0.,abs(t)*2.-1.),2.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenUV = fragCoord/iResolution.xy;\n\n    vec2 uv = screenUV;\n    vec2 uv2 = screenUV;\n    vec2 uv3 = screenUV;\n    \n    float t = fract(iTime*speed*2.);\n    float t2 = fract(iTime*speed*2.+0.33);\n    float t3 = fract(iTime*speed*2.+0.66);\n    float alpha = func(t);\n    float alpha2 = func(t2);\n    float alpha3 = func(t3);\n    \n    uv*=(1.-t)*4.;\n    uv+=(0.5*t)*4.;\n    uv2*=(1.-t2)*4.;\n    uv2+=(0.5*t2)*4.;\n    uv3*=(1.-t3)*4.;\n    uv3+=(0.5*t3)*4.; \n    \n    vec3 col = vec3(0.);\n    vec2 time = vec2(0.,1.)*iTime*speed;    \n    float layer = 0.;        \n    col = vec3(0.);   \n    time = vec2(0.,1.)*(iTime)*speed;\n    \n    layer += trail(uv,uv.x, time.y+random01(gridColumns(uv.x)*321.421)) * trailCharacter(uv) * alpha;\n    layer += leader(uv, uv.x, time.y+random01(gridColumns(uv.x)*321.421)) * leaderCharacter(uv,time) * alpha * 2.;\n\n    layer += trail(uv2,uv2.x, time.y+random01(gridColumns(uv2.x)*321.421)) * trailCharacter(uv2) * alpha2;\n    layer += leader(uv2,uv2.x, time.y+random01(gridColumns(uv2.x)*321.421)) * leaderCharacter(uv2,time) * alpha2 * 2.;\n\n    layer += trail(uv3,uv3.x, time.y+random01(gridColumns(uv3.x)*321.421)) * trailCharacter(uv3) * alpha3;\n    layer += leader(uv3,uv3.x, time.y+random01(gridColumns(uv3.x)*321.421)) * leaderCharacter(uv3,time) * alpha3 * 2.;\n    \n    col.x = layer;\n    float final = clamp01(layer);    \n    final = final + final * texture(iChannel1,fragCoord/iResolution.xy).r * 3.;\n    col = hsv2rgb(0.25,1.-pow(final,25.),1.)*final;\n    \n    /*//step by step of a single character\n    col = vec3(0.);\n    uv = fragCoord/iResolution.xy;\n    if(uv.x<.125){\n        col = leader(uv,0.01, time.y) * vOne;\n    }else if(uv.x<.25){\n        col = trail(uv,0.126, time.y) * vOne;\n    }else if(uv.x<.375){\n        col = leader(uv,0.251, time.y) * vOne;\n        col += trail(uv,0.251, time.y) * vOne;\n    }else if(uv.x<.5){\n        col = trailCharacter(uv) * vOne;\n    }else if(uv.x<.625){\n        col = leaderCharacter(uv,time) * vOne;\n    }else{\n        col = trail(uv,0.8, time.y) * trailCharacter(uv) * vOne;\n        col += leader(uv,0.8, time.y) * leaderCharacter(uv,time) * vOne;\n    }*/\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define vOne vec3(1.);\n\nfloat random01(float seed){\n    return fract(sin(dot(vec2(seed), vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat clamp01(float t){\n    return clamp(t,0.,1.);\n}\n\nvec2 clamp01(vec2 t){\n    return clamp(t,0.,1.);\n}\n\nvec3 hsv2rgb(float h, float s, float v)\n{\n    vec3 c = vec3(h,s,v);\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVSzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 119, 119, 158], [160, 160, 187, 187, 232], [234, 257, 275, 275, 326], [327, 347, 367, 367, 423], [425, 425, 474, 507, 749], [751, 751, 799, 820, 1097], [1099, 1099, 1152, 1152, 1531], [1533, 1533, 1563, 1563, 1613], [1615, 1615, 1657, 1657, 1751], [1753, 1810, 1830, 1830, 1898], [1900, 1900, 1957, 1957, 4142]], "test": "untested"}
{"id": "NtVXzh", "name": "Lava Grid", "author": "SnoopethDuckDuck", "description": "simple combination of these 2 shaders:\nhttps://www.shadertoy.com/view/sdcSDX  (Egg Yolks)\nhttps://www.shadertoy.com/view/NlcSDs  ", "tags": ["e"], "likes": 8, "viewed": 378, "published": 3, "date": "1640177272", "time_retrieved": "2024-07-30T18:40:44.291275", "image_code": "#define pi 3.14159\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat h21 (vec2 p, float sc) {\n    p.x = mod(p.x, sc); p.y = mod(p.y, sc);\n    return fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\n// this isnt adding much + quite expensive\nfloat selength(vec2 uv, float n) {\n    return pow(pow(abs(uv.x), n) + pow(abs(uv.y), n), 1./n);\n}\n\nvec2 movingTiles(vec2 uv, float sc, float speed){\n    float time = speed * iTime;\n    \n    // Change me for different patterns\n    float val = 2. * abs(uv.x) + 2. * abs(uv.y) + 1. * time;\n    float ft = fract(val);\n   \n    uv *= sc;\n    \n    float s = step(0.5, ft);\n    float a = 0.5;\n    \n    uv.x +=      s * sign(fract(uv.y * a) - a) * ft * 2.;\n    uv.y += (1.-s) * sign(fract(uv.x * a) - a) * ft * 2.;\n\t\n    return fract(uv * 1.);\n}\n\nfloat rand(vec2 ipos, vec2 fpos, float sc) {\n    float val = 6. * length(fpos-0.5) + h21(ipos, sc) - iTime;\n    //float val = h21(ipos, sc) + iTime;\n    \n    float a = 2. * pi * h21(ipos, sc);\n    float c = cos(a); \n    float s = sin(a);\n    \n    float v1 = h21(vec2(c * floor(val), s * floor(val)) + 0.01 * ipos, sc);\n    float v2 = h21(vec2(c * (floor(val) + 1.), s * (floor(val) + 1.)) + 0.01 * ipos, sc);  \n    \n    float m = fract(val);\n    m = m * m * (3. - 2. * m);\n   \n    return mix(v1, v2, m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/ iResolution.y; \n    uv += 0.02 * iTime;\n    \n    float c = 30.;\n    float sc = 17.;\n    \n    // Cut into grid\n    vec2 ipos = floor(sc * uv) + 0.5;  \n    vec2 fpos = fract(sc * uv) - 0.;\n    \n    // Corner positions\n    vec2 lp  = ipos + vec2(1,0);\n    vec2 tp  = ipos + vec2(0,1);\n    vec2 tlp = ipos + vec2(1,1);  \n    vec2 idp = ipos + vec2(0,0);\n\n    // Generate values for each corner of uv\n    float sc2 = c * sc;\n    float l  = rand(lp,  fpos, sc2);\n    float t  = rand(tp,  fpos, sc2);\n    float tl = rand(tlp, fpos, sc2);\n    float id = rand(idp, fpos, sc2);\n\n    // Smooth fpos so boundaries meet smoothly\n    vec2 sfpos = fpos * fpos * (3. - 2. * fpos);\n\n    // Box lerp between the corner values\n    float v = l  * sfpos.x      * (1.-sfpos.y)\n     \t    + t  * (1.-sfpos.x) * sfpos.y\n     \t    + tl * sfpos.x      * sfpos.y\n      \t    + id * (1.-sfpos.x) * (1.-sfpos.y);\n        \n    // Do the tile pattern (maybe this should be fpos?)\n    uv = movingTiles(uv, sc, 0.2 + 0.0003 * cos(10. * v + iTime));\n\n    // Draw stuff\n    float n = 4.;\n    vec3 e = vec3(1.);\n    vec3 col = v * pal(0.025 - 0.05 * h21(uv) + selength(uv-0.5, n), \n                       e, e, e, 0.5 * v  + 2.6 * vec3(0.,0.33,0.66));\n    /*\n    float k = 1.;\n    float s = smoothstep(-k, k, -0.5 - 0.5 * cos(10. * v) + v);\n    vec3 col =  s * v * pal(0.025 - 0.05 * h21(uv) + selength(uv-0.5, n), \n                       e, e, e, 0.5 * v  + 2.6 * vec3(0.,0.33,0.66));\n    col += (1. - s) * v;\n    */\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtVXzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 88, 88, 131], [133, 133, 153, 153, 228], [230, 230, 260, 260, 377], [379, 379, 403, 403, 443], [445, 488, 522, 522, 585], [587, 587, 636, 636, 1024], [1026, 1026, 1070, 1070, 1531], [1533, 1533, 1590, 1590, 3158]], "test": "untested"}
{"id": "NlVXRz", "name": "Cloud Computing #9", "author": "PyThrrrown", "description": "I just tweaked this wonderful shader to make it a smooth flight.", "tags": ["clouds"], "likes": 14, "viewed": 529, "published": 3, "date": "1640177048", "time_retrieved": "2024-07-30T18:40:45.143995", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// For diagram shader showing how samples are taken:\n//\n// https://www.shadertoy.com/view/ll3GWs\n//\n// We are in the process of writing up this technique. The following github repos\n// is the home of this research.\n//\n// https://github.com/huwb/volsample\n//\n// \n//\n// Additional credits - this scene is mostly mash up of these two amazing shaders:\n//\n// Clouds by iq: https://www.shadertoy.com/view/XslGRr\n// Cloud Ten by nimitz: https://www.shadertoy.com/view/XtS3DD\n// \n\n#define SAMPLE_COUNT 200\n#define PERIOD .19\n\n// mouse toggle\nbool STRUCTURED;\n\n// cam moving in a straight line\nvec3 sundir;\n\n// LUT based 3d value noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n    return mix( rg.x, rg.y, f.z );\n}\n\n\nvec4 map( in vec3 p )\n{\n\tfloat d = 0.1 + .8 * sin(0.6*p.z)*sin(0.5*p.x) - p.y;\n\n    vec3 q = p;\n    float f;\n    \n    f  = 0.5000*noise( q ); q = q*2.02;\n    f += 0.2500*noise( q ); q = q*2.03;\n    f += 0.1250*noise( q ); q = q*2.01;\n    f += 0.0625*noise( q );\n    d += 2.75 * f;\n\n    d = clamp( d, 0.0, 1.0 );\n    \n    vec4 res = vec4( d );\n    \n    //vec3 col = 1.15 * vec3(.1,,1.1);\n    vec3 col = 1.3 * vec3(.9,.9,.8);\n\n    col += vec3(1.,0.,0.) * exp2(res.x*10.-10.);\n    res.xyz = mix( col, vec3(0.7,0.7,0.7), res.x );\n    \n    return res;\n}\n\n\n// to share with unity hlsl\n#define float2 vec2\n#define float3 vec3\n#define fmod mod\nfloat mysign( float x ) { return x < 0. ? -1. : 1. ; }\nfloat2 mysign( float2 x ) { return float2( x.x < 0. ? -1. : 1., x.y < 0. ? -1. : 1. ) ; }\n\n// compute ray march start offset and ray march step delta and blend weight for the current ray\nvoid SetupSampling( out float2 t, out float2 dt, out float2 wt, in float3 ro, in float3 rd )\n{\n    if( !STRUCTURED )\n    {\n        dt = float2(PERIOD,PERIOD);\n        t = dt;\n        wt = float2(0.5,0.5);\n        return;\n    }\n    \n    // the following code computes intersections between the current ray, and a set\n    // of (possibly) stationary sample planes.\n    \n    // much of this should be more at home on the CPU or in a VS.\n    \n    // structured sampling pattern line normals\n    float3 n0 = (abs( rd.x ) > abs( rd.z )) ? float3(1., 0., 0.) : float3(0., 0., 1.); // non diagonal\n    float3 n1 = float3(mysign( rd.x * rd.z ), 0., 1.); // diagonal\n\n    // normal lengths (used later)\n    float2 ln = float2(length( n0 ), length( n1 ));\n    n0 /= ln.x;\n    n1 /= ln.y;\n\n    // some useful DPs\n    float2 ndotro = float2(dot( ro, n0 ), dot( ro, n1 ));\n    float2 ndotrd = float2(dot( rd, n0 ), dot( rd, n1 ));\n\n    // step size\n    float2 period = ln * PERIOD;\n    dt = period / abs( ndotrd );\n\n    // dist to line through origin\n    float2 dist = abs( ndotro / ndotrd );\n\n    // raymarch start offset - skips leftover bit to get from ro to first strata lines\n    t = -mysign( ndotrd ) * fmod( ndotro, period ) / abs( ndotrd );\n    if( ndotrd.x > 0. ) t.x += dt.x;\n    if( ndotrd.y > 0. ) t.y += dt.y;\n\n    // sample weights\n    float minperiod = PERIOD;\n    float maxperiod = sqrt( 2. )*PERIOD;\n    wt = smoothstep( maxperiod, minperiod, dt/ln );\n    wt /= (wt.x + wt.y);\n}\n\nvec4 raymarch( in vec3 ro, in vec3 rd )\n{\n    vec4 sum = vec4(0, 0, 0, 0);\n    \n    // setup sampling - compute intersection of ray with 2 sets of planes\n    float2 t, dt, wt;\n\tSetupSampling( t, dt, wt, ro, rd );\n    \n    // fade samples at far extent\n    float f = .9; // magic number - TODO justify this\n    float endFade = f*float(SAMPLE_COUNT)*PERIOD;\n    float startFade = .9*endFade;\n    \n    for(int i=0; i<SAMPLE_COUNT; i++)\n    {\n        if( sum.a > 0.99 ) continue;\n\n        // data for next sample\n        vec4 data = t.x < t.y ? vec4( t.x, wt.x, dt.x, 0. ) : vec4( t.y, wt.y, 0., dt.y );\n        // somewhat similar to: https://www.shadertoy.com/view/4dX3zl\n        //vec4 data = mix( vec4( t.x, wt.x, dt.x, 0. ), vec4( t.y, wt.y, 0., dt.y ), float(t.x > t.y) );\n        vec3 pos = ro + data.x * rd;\n        float w = data.y;\n        t += data.zw;\n        \n        // fade samples at far extent\n        w *= smoothstep( endFade, startFade, data.x );\n        \n        vec4 col = map( pos );\n        \n        // iqs goodness\n        float dif = clamp((col.w - map(pos+0.6*sundir).w)/0.6, 0.0, 1.0 );\n        vec3 lin = vec3(0.51, 0.53, 0.63)*1.35 + 0.55*vec3(0.85, 0.57, 0.3)*dif;\n        col.xyz *= lin;\n        \n        col.xyz *= col.xyz;\n        \n        col.a *= 0.75;\n        col.rgb *= col.a;\n\n        // integrate. doesn't account for dt yet, wip.\n        sum += col * (1.0 - sum.a) * w;\n    }\n\n    sum.xyz /= (0.001+sum.w);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nvec3 sky( vec3 rd )\n{\n    vec3 col = vec3(0.);\n    \n    float hort = 1. - clamp(abs(rd.y), 0., 1.);\n    col += 0.5*vec3(.99,.5,.0)*exp2(hort*8.-8.);\n    col += 0.1*vec3(.5,.9,1.)*exp2(hort*3.-3.);\n    col += 0.55*vec3(.6,.6,.9);\n    \n    float sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n    col += .2*vec3(1.0,0.3,0.2)*pow( sun, 2.0 );\n    col += .5*vec3(1.,.9,.9)*exp2(sun*650.-650.);\n    col += .1*vec3(1.,1.,0.1)*exp2(sun*100.-100.);\n    col += .3*vec3(1.,.7,0.)*exp2(sun*50.-50.);\n    col += .5*vec3(1.,0.3,0.05)*exp2(sun*10.-10.); \n    \n    float ax = atan(rd.y,length(rd.xz))/1.;\n    float ay = atan(rd.z,rd.x)/2.;\n    float st = texture( iChannel0, vec2(ax,ay) ).x;\n    float st2 = texture( iChannel0, .25*vec2(ax,ay) ).x;\n    st *= st2;\n    st = smoothstep(0.65,.9,st);\n    col = mix(col,col+1.8*st,clamp(1.-1.1*length(col),0.,1.));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // click mouse to use naive raymarching\n    STRUCTURED = iMouse.z <= 0.;\n    sundir = normalize(vec3(-90.0,90.0,0.));\n\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n    vec2 mo = -1.0 + 2.0*iMouse.xy / iResolution.xy;\n   \n    // camera\n    //vec3 lookDir = vec3(cos(.53*iTime),0.,sin(iTime));\n    //vec3 camVel = vec3(-20.,0.,0.);\n    vec3 lookDir = vec3(1.0,0.,0.);\n    vec3 camVel = vec3(.5,0.,0.);\n\n\n\n    vec3 ro = vec3(.0,sin(iTime*1.)*.2+1.9,0.) + iTime*camVel;\n    vec3 ta = ro + lookDir; //vec3(ro.x, ro.y, ro.z-1.);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    float fov = 1.0;\n    vec3 rd = normalize( fov*p.x*uu + fov*1.2*p.y*vv + 1.5*ww );\n    \n    // divide by forward component to get fixed z layout instead of fixed dist layout\n    //vec3 rd_layout = rd/mix(dot(rd,ww),1.0,samplesCurvature);\n    vec4 clouds = raymarch( ro, rd );\n    \n    vec3 col = clouds.xyz;\n        \n    // sky if visible\n    if( clouds.w <= .999 )\n\t    col = mix( sky(rd), col, clouds.w );\n    \n\tcol = clamp(col, 0., 1.);\n    col = smoothstep(0.,1.,col);\n\t//col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12 ); //Vign\n        \n    fragColor = vec4( col, 1.0 );\n}\n\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlVXRz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[689, 717, 743, 743, 969], [972, 972, 995, 995, 1520], [1608, 1608, 1633, 1633, 1662], [1663, 1663, 1690, 1690, 1752], [1754, 1850, 1944, 1944, 3331], [3333, 3333, 3374, 3374, 4813], [4815, 4815, 4836, 4836, 5676], [5678, 5678, 5735, 5779, 7045]], "test": "untested"}
{"id": "NtKXzh", "name": "twisty thing xd", "author": "pema99", "description": "a", "tags": ["raymarching"], "likes": 5, "viewed": 360, "published": 3, "date": "1640177001", "time_retrieved": "2024-07-30T18:40:45.971782", "image_code": "#define PI (22.0/7.0)\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nmat2 rot(float r)\n{\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat ball(vec3 p)\n{\n    // scale\n    float scale = cos(iTime*3.)*0.2+1.0;\n    p *= scale;   \n\n    // twist\n    float twist = sin(iTime*3.);\n    p.xz *= rot(mix(0., p.y*6., twist));\n    \n    // rot cube\n    p.xz *= rot(iTime);\n    p.xy *= rot(1.);\n   \n    // bulge\n    float bulge = cos(iTime*3.);\n    p += bulge*(0.07*(sin(p.x*p.y*p.z*200.)*0.5+0.5));\n    \n    // bloat\n    float bloat = sin(iTime*6.)*0.5+0.5;\n    return mix(sdBox(p, vec3(0.4)), length(p)-0.65, bloat);\n}\n\nfloat map(vec3 p)\n{\n    vec3 c = vec3(3.);\n    vec3 q = p;\n    //vec3 q = mod(p+0.5*c,c)-0.5*c;\n    float d = ball(q);\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    vec3 p = ro;\n    int i = 0;\n    for (; i < 100; i++)\n    {\n        float dist = map(p)*0.7;\n        if (dist < 0.001) break;\n        t += dist;\n        p = ro + t * rd;\n    }\n    return vec2(t, i);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 o = vec2(0.001, 0.);\n    return normalize(vec3(\n        map(p + o.xyy) - map(p - o.xyy),\n        map(p + o.yxy) - map(p - o.yxy),\n        map(p + o.yyx) - map(p - o.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * ((fragCoord/iResolution.xy) - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    for (int i = 0; i < 2; i++)\n    {\n        for (int j = 0; j < 2; j++)\n        {\n            vec3 ro = vec3(0., 0., -3.);\n            vec3 rd = normalize(vec3(uv + vec2(float(i)*0.5+0.25, float(j)*0.5+0.25)*0.006, 0.) - ro);\n\n            vec2 res = march(ro, rd);\n            float dist = res.x;\n            float iters = res.y;\n\n            if (dist < 10.)\n            {\n                col += (normal(ro + dist * rd) * 0.5 + 0.5) * 0.25;\n            }\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtKXzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 54, 54, 145], [147, 147, 190, 190, 289], [291, 291, 310, 310, 362], [364, 364, 384, 397, 837], [839, 839, 858, 858, 973], [975, 975, 1005, 1005, 1227], [1229, 1229, 1250, 1250, 1439], [1441, 1441, 1498, 1548, 2189]], "test": "untested"}
{"id": "NtKSRh", "name": "Equiareal Tiling Spherical Map", "author": "paniq", "description": "mapping UV to the circle via shirley-chiu, then to the sphere via lambert azimuthal equal-area projection\ninverse is also provided.", "tags": ["uv", "map", "normal", "tiling", "spherical", "octahedron", "equiareal", "collignon"], "likes": 9, "viewed": 435, "published": 3, "date": "1640174835", "time_retrieved": "2024-07-30T18:40:46.918251", "image_code": "\n// if defined, demonstrate the inverse mapping \n//#define SHOW_INVERSE\n\n// if defined, shows the quincuncial tiling version\n//#define SHOW_QUINCUNCIAL\n\n// if defined, shows an environment map instead of a XYZ color gradient\n// for inverse mode, demonstrates texture mapping\n#define SHOW_CUBEMAP\n\n// if defined, shows latitude/longitude lines\n#define SHOW_FLOW_LINES\n\n// if defined, shows a UV tesselation of quadliterals, and the proportional\n// difference between the quadliteral area and the expected average size (2/N)\n// if FIX_EQUAL_AREA is defined, the proportions will be ideal.\n//#define SHOW_SOLID_ANGLE\n\n// if not defined, computes a more accurate solid angle from cosines,\n// though the precision of this method is terrible and is only relevant\n// for rough tesselations anyway.\n#define USE_TRIANGLE_AREA\n\n// subdivisions per quadrant\n#if defined(SHOW_SOLID_ANGLE)||defined(SHOW_INVERSE)\n#undef SHOW_FLOW_LINES\n// solid angle subdivisions\nconst float subdivisions = 128.0;\n#else\n// flow line subdivisions\nconst float subdivisions = 16.0;\n#endif\n\n// thesis related functions\n//////////////////////////////////////////////////////////\n\n//#define TEST_EQUIAREAL\n//#define TEST_INVERTIBLE\n#ifdef TEST_INVERTIBLE\n#undef SHOW_CUBEMAP\n#endif\n\n// convert tiling uv coordinates [0..2]x[0..1] to a normal on the sphere\nvec3 uv_normal(vec2 uv) {\n    // tile [0..2]x[0..1] to [-1..1]x[-1..1] + hemisphere flag\n    uv = uv/2.0;\n    uv = fract(uv);\n    uv = (uv.y >= 0.5)?(1.0 - uv):uv;\n    bool h = (uv.x >= 0.5);\n    uv.x = h?(1.0 - uv.x):uv.x;\n    uv = uv*4.0 - 1.0;\n    // Shirley-Chiu Mapping (L1 arclength, equiareal)\n    bool is_h = (abs(uv.x) > abs(uv.y));\n    vec2 o = is_h?uv:uv.yx;\n    float r = o.x;\n    float d = o.y/r - 1.0;\n    float phi = radians(45.0)*(1.0 + ((r == 0.0)?0.0:(is_h?d:-d)));\n    vec2 n2 = vec2(cos(phi),sin(phi));\n    // Lambert Azimuthal Equal-Area Projection\n    float rr = r*r; float cos_a = 1.0 - rr;\n    return vec3(n2*(r*sqrt(2.0 - rr)), h?-cos_a:cos_a);\n}\n\n// convert a normal on the sphere to tiling uv coordinates [0..2]x[0..1]\nvec2 normal_uv(vec3 n) {\n    bool h = (n.z < 0.0);\n    // Lambert Azimuthal Equal-Area Projection\n    vec2 uv = n.xy/sqrt((h?-n.z:n.z) + 1.0);\n    // Shirley-Chiu Mapping (L1 arclength, equiareal)\n    float a = atan(uv.y, uv.x) / radians(360.0) - 0.125;\n    float px = abs(fract(a) - 0.5);\n    float py = abs(fract(a - 0.25) - 0.5);\n    float r = length(uv);\n    uv = (2.0 * r) * vec2(px - py, px + py - 0.5) + 0.5;\n    uv.x = h?(2.0 - uv.x):uv.x;\n    return uv;\n}\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a); float s = sin(a);\n    return vec2(p.x*c + p.y*s, -s*p.x + c*p.y);\n}\n// convert tiling quinuncial uv coordinates [0..1]x[0..1] to a normal on the sphere\nvec3 quincuncial_uv_normal(vec2 uv) {\n    uv = vec2(uv.x + uv.y - 0.5, uv.y - uv.x + 0.5);\n    vec3 n = uv_normal(uv);\n    n.xy = vec2(n.x - n.y, n.x + n.y)*sqrt(0.5);\n    return n;\n}\n\n// convert a normal on the sphere to tiling quinuncial uv coordinates [0..1]x[0..1]\nvec2 quincuncial_normal_uv(vec3 n) {\n    n.xy = vec2(n.x + n.y, n.y - n.x)*sqrt(0.5);\n    uv = normal_uv(n);\n    uv = vec2(uv.x - uv.y, uv.x + uv.y - 1.0);\n    uv = (1.0 - abs(uv)) * (step(0.0,uv.yx)*2.0 - 1.0);\n    uv = (1.0 - abs(uv)) * (step(0.0,uv.yx) - 0.5) + 0.5;\n    return uv;\n}\n\n#ifdef SHOW_QUINCUNCIAL\n#define uv_normal quincuncial_uv_normal\n#define normal_uv quincuncial_normal_uv\n#endif\n\n// visualization\n//////////////////////////////////////////////////////////\n\nfloat triangle_area(vec3 A, vec3 B, vec3 C) {\n    return length(cross(B - A, C - A)) / 2.0;\n}\n\nvec2 nanglebasis (vec3 a, vec3 b) {\n    float ab = dot(a, b);\n    return vec2(ab, sqrt(1.0 - ab * ab));\n}\n\nfloat simplex_solid_angle (vec2 u, vec2 v, vec2 w) {\n    float A =\n            acos((u.x - v.x * w.x) / (v.y * w.y))\n            + acos((v.x - w.x * u.x) / (w.y * u.y))\n            + acos((w.x - u.x * v.x) / (u.y * v.y))\n            - radians(180.0);\n    return (A != A)?0.0:A;\n}\n\nfloat pyramid_points_solid_angle (vec3 A, vec3 B, vec3 C, vec3 D) {\n#ifdef USE_TRIANGLE_AREA\n    return triangle_area(A, B, C) + triangle_area(C, D, A);\n#else\n    vec2 ab = nanglebasis(A, B);\n    vec2 ac = nanglebasis(A, C);\n    vec2 da = nanglebasis(A, D);\n    vec2 bc = nanglebasis(B, C);\n    vec2 cd = nanglebasis(C, D);\n    return simplex_solid_angle(bc, ac, ab) + simplex_solid_angle(da, ac, cd);\n#endif\n}\n\nvec3 plasma(float t) {\n\n    const vec3 c0 = vec3(0.05873234392399702, 0.02333670892565664, 0.5433401826748754);\n    const vec3 c1 = vec3(2.176514634195958, 0.2383834171260182, 0.7539604599784036);\n    const vec3 c2 = vec3(-2.689460476458034, -7.455851135738909, 3.110799939717086);\n    const vec3 c3 = vec3(6.130348345893603, 42.3461881477227, -28.51885465332158);\n    const vec3 c4 = vec3(-11.10743619062271, -82.66631109428045, 60.13984767418263);\n    const vec3 c5 = vec3(10.02306557647065, 71.41361770095349, -54.07218655560067);\n    const vec3 c6 = vec3(-3.658713842777788, -22.93153465461149, 18.19190778539828);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n\n\nvec3 stereographic_sphere(vec2 uv) {\n    vec3 n = vec3(uv, sqrt(1.0 - dot(uv,uv)));\n    float t = iTime*0.1;\n    n.yz = rotate(n.yz, radians(sin(t*0.25*radians(360.0))*45.0));    \n    n.xz = rotate(n.xz, t*radians(360.0));    \n    return n;\n}\n\n//////////////////////////////////////////////////////////\n\n// for inverse mapping\nvec3 transfer_color(vec2 q) {\n#ifdef SHOW_CUBEMAP\n    if (q.x >= 1.0) {\n        q.x = 2.0 - q.x;\n    }\n    return textureLod(iChannel1, q*2.0, 0.0).rgb;\n#elif 1\n    ivec2 p = ivec2(q*subdivisions) & 1;\n    vec3 s = vec3(p.x^p.y)*0.5 + 0.5;\n    q = q - mod(q, 1.0/subdivisions);\n    float b = 0.0;\n    if (q.x >= 1.0) {        \n        b = q.x - 1.0;\n        q.x = 2.0 - q.x;        \n    }\n    return s*vec3(q, b);\n#endif\n}\n\nvec3 transfer_color(vec3 p) {\n#ifdef SHOW_CUBEMAP\n#ifndef TEST_EQUIAREAL\n    p.xz = rotate(p.xz, iTime*0.5);\n#endif\n    return textureLod(iChannel0, p, 0.0).xyz;\n#elif defined(SHOW_INVERSE)\n    vec2 q = normal_uv(p);\n    q = q - mod(q, 1.0/subdivisions);\n    return vec3(q*0.5 + 0.5, 0.0);\n#else\n    return p*0.5 + 0.5;\n#endif\n}\n\nfloat flow_lines(vec3 q) {\n#ifndef TEST_EQUIAREAL\n    q.xz = rotate(q.xz, radians(90.0) + iTime*0.5);\n#endif\n    float a = atan(q.y, q.x);\n    float r = acos(q.z);\n    float A = subdivisions;\n    return sin(a*A)*sin(r*A);\n}\n\nvec2 transform_origin(vec2 p) {\n#ifdef SHOW_QUINCUNCIAL\n    return (p*2.0)*0.5 + 0.5;\n#else\n    return (p*0.5 + 0.5)*vec2(2.0,2.0);\n#endif    \n}\n\nfloat arcmap_flow_lines(vec2 p) {\n    vec2 uv = transform_origin(p);\n    return flow_lines(uv_normal(uv));\n}\n\nbool in_range(vec2 p) {\n    return max(abs(p.x),abs(p.y)) <= 1.0;\n}\n\nvec3 solid_angle_color(vec3 p00, vec3 p10, vec3 p01, vec3 p11) {\n#ifdef SHOW_QUINCUNCIAL\n    // ideal solid angle: 4*pi / subdivisions\n    float isa = 4.0 * radians(180.0) / (subdivisions * subdivisions);\n#else\n    // ideal solid angle: 2*pi / subdivisions\n    float isa = 2.0 * radians(180.0) / (subdivisions * subdivisions);\n#endif\n    float sa1 = pyramid_points_solid_angle(p00,p10,p11,p01);\n    float sa2 = pyramid_points_solid_angle(p10,p00,p01,p11);\n    float sa = (uv.x*uv.y < 0.0)?sa1:sa2;\n#if 1\n    sa = abs(sa/isa-1.0);\n#else\n    sa = abs(log2(sa/isa));\n#endif\n    return plasma(clamp(sa,0.0,1.0));\n}\n\nvoid paint_uv_normal() {\n    set_line_width_px(1.2);\n    \n    vec2 uv = transform_origin(get_origin());\n    #ifdef TEST_INVERTIBLE\n    vec2 p = normal_uv(uv_normal(uv));\n    #else\n    vec3 p = uv_normal(uv);\n    #endif\n    set_source_rgb(transfer_color(p));\n#ifdef SHOW_SOLID_ANGLE\n    float s = 1.0/subdivisions;\n    uv = uv - mod(uv, s) + s * 0.5;\n    vec2 w = 0.5*vec2(-s,s);\n    vec3 p00 = uv_normal(uv + w.xx);\n    vec3 p10 = uv_normal(uv + w.yx);\n    vec3 p01 = uv_normal(uv + w.xy);\n    vec3 p11 = uv_normal(uv + w.yy);\n    set_source_rgb(solid_angle_color(p00,p10,p01,p11));\n#endif\n    rectangle(-1.0,-1.0,2.0,2.0);\n    fill_preserve();    \n    set_source_rgb(vec3(0.0));\n    stroke();\n#ifdef SHOW_FLOW_LINES\n    if (in_range(get_origin())) {\n        graph2D(arcmap_flow_lines);\n        stroke();\n    }\n#endif\n}\n\nvoid paint_normal_uv() {\n    set_line_width_px(1.2);\n    vec3 n = stereographic_sphere(get_origin());  \n    vec2 uv = normal_uv(n);  \n    set_source_rgb(transfer_color(uv));\n    circle(0.0, 0.0, 1.0);\n    fill_preserve();\n    set_source_rgb(vec3(0.0));\n    stroke();\n}\n\nvoid paint() {\n    set_source_rgb(vec3(0.2));\n    clear();\n\n#if defined(SHOW_INVERSE)\n    paint_normal_uv();\n#else\n    paint_uv_normal();\n#endif    \n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord, iMouse.xy, iResolution.xy);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.16\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2020-12-02: 0.16\n// * support for drawing concentric rings\n\n// 2020-11-30: 0.15\n// * support for drawing orthogonal grids\n// * adjusted uv so corners are centered on pixels\n// * small adjustment to line pixel width computation\n\n// 2020-11-12: 0.14\n// * added support for depth testing\n\n// 2020-11-11: 0.13\n// * fixed 2D graphs not filling\n// * added circle_px()\n\n// 2019-06-06: 0.12\n// * split implementation and demo into common and image tab\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\nvoid set_source_depth(float depth);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the old source with the new one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n// if enabled, use the depth value for testing;\n// smaller values win\nvoid depth_test(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add a circle path at P with pixel radius R\nvoid circle_px(vec2 p, float r);\nvoid circle_px(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// add an orthogonal grid with cell size S\nvoid grid(vec2 s);\nvoid grid(float w, float h);\nvoid grid(float s);\n// draw concentric rings around origin p, with spacing r and offset phase\nvoid rings(vec2 p, float r, float phase);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// draw a letter with the given texture coordinate\nvoid letter(sampler2D font_texture_source, ivec2 l);\nvoid letter(sampler2D font_texture_source, int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    bool depth_test;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n    float source_z;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n#define DEFAULT_DEPTH 1e+30\n\nContext _stack;\n\nvoid init (vec2 fragCoord, vec2 mouse, vec2 resolution) {\n\taspect = vec2(resolution.x / resolution.y, 1.0);\n\tScreenH = min(resolution.x,resolution.y);\n\tAA = ScreenH*0.5;\n\tAAINV = 1.0 / AA;\n    \n    uv = (fragCoord.xy - 0.5) / resolution;\n    vec2 m = mouse / resolution;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false,\n        DEFAULT_DEPTH\n    );\n}\n\nvec3 _color = vec3(1);\nfloat _depth = DEFAULT_DEPTH;\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color.rgb = mix(_color.rgb, _stack.source.rgb, _stack.source.a);\n    _depth = (_stack.source.a == 1.0)?_stack.source_z:_depth;\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(pow(_color.rgb, vec3(1.0/2.2)), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color.rgb;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    if (_stack.depth_test) {\n        if ((w == 1.0) && (_stack.source_z <= _depth)) {\n            _depth = _stack.source_z;\n        } else if ((w == 0.0) || (_stack.source_z > _depth)) {            \n            return;\n        }\n    }\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color.rgb = _color.rgb * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\n\nvoid depth_test(bool enable) {\n    _stack.depth_test = enable;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_depth(float depth) {\n    _stack.source_z = depth;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(sampler2D font_texture_source, ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(sampler2D font_texture_source, int lx, int ly) {\n    letter(font_texture_source, ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid grid(vec2 size) {\n    vec4 f = abs(fract(_stack.position/size.xyxy+0.5)-0.5)*size.xyxy;\n    add_field(vec2(min(f.x,f.y),min(f.z,f.w)));\n}\nvoid grid(float w, float h) {\n    grid(vec2(w,h));\n}\nvoid grid(float s) {\n    grid(vec2(s));\n}\nvoid rings(vec2 p, float r, float phase) {\n    vec4 q = _stack.position - p.xyxy;\n    vec2 f = abs(fract(vec2(length(q.xy),length(q.zw))/r-phase+0.5)-0.5)*r;\n    add_field(f);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid circle_px(vec2 p, float r) {\n    circle(p, r/(0.5*ScreenH));\n}\nvoid circle_px(float x, float y, float r) {\n    circle_px(vec2(x,y), r);\n}\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(f_x / length(df_x));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtKSRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1250, 1323, 1348, 1411, 1994], [1996, 2069, 2093, 2093, 2533], [2534, 2534, 2564, 2564, 2654], [2655, 2739, 2776, 2776, 2922], [2924, 3008, 3044, 3044, 3294], [3485, 3485, 3530, 3530, 3578], [3580, 3580, 3615, 3615, 3685], [3687, 3687, 3739, 3739, 3966], [3968, 3968, 4035, 4035, 4378], [4380, 4380, 4402, 4402, 5056], [5060, 5060, 5096, 5096, 5302], [5364, 5387, 5416, 5416, 5809], [5811, 5811, 5840, 5840, 6139], [6141, 6141, 6167, 6167, 6364], [6366, 6366, 6397, 6397, 6510], [6512, 6512, 6545, 6545, 6620], [6622, 6622, 6645, 6645, 6689], [6691, 6691, 6755, 6755, 7305], [7307, 7307, 7331, 7331, 8126], [8128, 8128, 8152, 8152, 8396], [8398, 8398, 8412, 8412, 8548], [8610, 8610, 8667, 8667, 8753]], "test": "untested"}
{"id": "styXz1", "name": "3D Game of Life", "author": "IWBTShyGuy", "description": "The number of cubes is the number of adjacent voxels.", "tags": ["gameoflife"], "likes": 19, "viewed": 493, "published": 3, "date": "1640165316", "time_retrieved": "2024-07-30T18:40:47.772967", "image_code": "//\n// Interface of 3D Game of Life\n//\n// The MIT License\n// Copyright  2021 IWBTShyGuy\n//\n\n#if HW_PERFORMANCE!=0\n// If defined, activate anti-aliasing, level: 2 or 3\n#define AA 2\n#endif\n\n// When this macro is enabled, the number of adjacent voxels will be displayed.\n#define DEBUG_MODE\n\n// Size of the game board\nconst ivec3 I = ivec3(24);\n// Period of update\nconst float FREQ = 0.75;\n\nint fetch(ivec3 i) { return int(texelFetch(iChannel0, ivec2(i.x * I.y + i.y, i.z), 0).x);}\n\n#ifdef DEBUG_MODE\nfloat letter(in vec2 uv, in int idx) {\n    uv = clamp(uv, 0.0, 1.0);\n    int i = idx % 16;\n    int j = 15 - idx / 16;\n    vec2 origin = vec2(float(i) / 16.0, float(j) / 16.0);\n    uv = (uv / 16.0 + origin);\n    float r = texture(iChannel1, uv).x;\n    return floor(r + 0.5);\n}\n\nfloat digit(in vec2 uv, in int number) {\n    float size = 0.7;\n    int a = number / 10;\n    int b = number % 10;\n    float irr0 = letter((uv - 0.5 + vec2(0.25, 0)) / size + 0.5, 48 + a);\n    float irr1 = letter((uv - 0.5 - vec2(0.25, 0)) / size + 0.5, 48 + b);\n    return max(irr0, irr1);\n}\n\nint calcNeighborhood(vec3 p) {\n    int c = 0;\n    for (int k = 0; k < 27; k += k == 12 ? 2 : 1) {\n        ivec3 i = (I + ivec3(floor(p)) % I) % I + ivec3(0,0,I.z);\n        c += fetch((i + ivec3(k / 9, (k % 9) / 3, k % 3) - 1 + I) % I + ivec3(0,0,I.z));\n    }\n    return c;\n}\n#endif\n\nconst float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float radian = camera.fov;\n    float h = tan(radian * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat appearEffect(float t, bool prevExists, bool nextExists) {\n    float a = 1.0;\n    float k = 5.0;\n    float m = 1.2;\n    float s = fract(t);\n    float tmp = m - m * k * k * (s - 1.0 / k) * (s - 1.0 / k);\n    tmp = prevExists ? a : tmp;\n    a = s < 1.0 / k ? tmp : max(tmp, a);\n    tmp = m - m * k * k * (s - (k - 1.0) / k) * (s - (k - 1.0) / k);\n    tmp = nextExists ? a : tmp;\n    return s > (k - 1.0) / k ? tmp : max(tmp, a); \n}\n\n// cellwise SDF\nfloat cellDist(in vec3 p, in vec3 q, in float t) {\n    bool nextExists = fetch((I + ivec3(floor(q)) % I) % I) == 1;\n    bool currExists = fetch((I + ivec3(floor(q)) % I) % I + ivec3(0,0,I.z)) == 1;\n    bool prevExists = fetch((I + ivec3(floor(q)) % I) % I + ivec3(0,0,I.z*2)) == 1;\n    if (!currExists) return 0.5;\n    p = fract(q) + p - q - 0.5;\n    float a = appearEffect((t - 0.1) / 0.75, prevExists, nextExists);\n    return sdBox(p, vec3(0.15 * a)) - 0.025 * a;\n}\n\n// SDF\nfloat sDist(in vec3 p, in vec3 dir, in float t) {\n    float dist = cellDist(p, p, t);\n    if (floor(p + dist * dir) != floor(p)) {\n        dist = min(dist, cellDist(p, p + dist * dir, t));\n    }\n    return dist;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 p, in vec3 dir, in float t) {\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize(vec3(\n        cellDist(p+h.xyy, p, t) - cellDist(p-h.xyy, p, t),\n        cellDist(p+h.yxy, p, t) - cellDist(p-h.yxy, p, t),\n        cellDist(p+h.yyx, p, t) - cellDist(p-h.yyx, p, t)\n    ));\n}\n\n#ifdef DEBUG_MODE\nvec2 getTexCoord(in vec3 p, in float t) {\n    vec2 res = vec2(0);\n    bool nextExists = fetch((I + ivec3(floor(p)) % I) % I) == 1;\n    bool prevExists = fetch((I + ivec3(floor(p)) % I) % I + ivec3(0,0,I.z*2)) == 1;\n    p = fract(p) - 0.5;\n    float a = appearEffect((t - 0.1) / 0.75, prevExists, nextExists);\n    if (abs(abs(p.x) - 0.175 * a) < 1.0e-2) res = p.zy / (0.3 * a) + 0.5; \n    else if (abs(abs(p.y) - 0.175 * a) < 1.0e-2) res = p.zx / (0.3 * a) + 0.5; \n    else if (abs(abs(p.z) - 0.175 * a) < 1.0e-2) res = p.xy / (0.3 * a) + 0.5;\n    return res;\n}\n#endif\n\nconst float FAR = 13.0;\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    if (iTime < 0.1) { fragColor = vec4(0,0,0,1); return; } \n    float time = iTime - 0.1;\n    vec2 theta = vec2(0.15, 0.25) * time;\n    theta.y = sin(theta.y);\n\n    Camera camera;\n    camera.position = vec3(0, 0, -time * 0.5);\n    camera.direction = vec3(sin(theta.x) * cos(theta.y), sin(theta.y), -cos(theta.x) * cos(theta.y));\n    camera.up_direction = vec3(0, 1, 0);\n    camera.fov = PI / 4.0;\n    camera.aspect = iResolution.x / iResolution.y;\n    Ray ray = cameraRay(camera, fragCoord / iResolution.xy);\n\n    float dist = 0.0;\n    vec3 p;\n    for (int _i = 0; _i < 100; _i++) {\n        p = ray.origin + dist * ray.direction;\n        float dist0 = sDist(p, ray.direction, iTime);\n        if (dist0 < 0.00001 || dist > FAR) break;\n        dist += dist0;\n    }\n\n    vec3 col = vec3(0);\n    if (dist < FAR) {\n        vec3 normal = calcNormal(p, ray.direction, iTime);\n        float c = -dot(ray.direction, normal);\n        c = clamp(c, 0.0, 1.0);\n#ifdef DEBUG_MODE\n        vec2 uv = getTexCoord(p, iTime);\n        int num = calcNeighborhood(p);\n        c = clamp(c, 0.0, 1.0) * (1.0 - digit(uv, num));\n#endif\n        float k = smoothstep(0.0, 1.0, dist / FAR);\n        k *= k;\n        col = (1.0 - k) * c + k * col;\n    }\n\n    fragColor = vec4(pow(col, vec3(0.4545)), 1);\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    \n// smart anti-aliasing\n// reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\n// If defined, visualize anti-aliased pixels.\n//#define VISUALIZE_AA\n#ifdef AA\n    if (fwidth(length(O.xyz)) > 0.2) {\n        O.xyz = pow(O.xyz, vec3(2.2));\n        vec4 o;\n#if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              mainImage0(o,U + (vec2(k - (k / 2) * 2, k / 2) - 0.5) / 1.5);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 5.0;\n#elif (AA == 3)\n        for (int k = 0; k < 9; k += k == 3 ? 2 : 1 ) {\n              mainImage0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 9.0;\n#endif\n#ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n#endif\n        O.xyz = pow(O.xyz, vec3(0.4545));\n    }\n#endif\n    O.w = 1.0;\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\n// Core of 3D Game of Life\n//\n// The MIT License\n// Copyright  2021 IWBTShyGuy\n//\n\n// Size of the game board\nconst ivec3 I = ivec3(24);\n// Period of update\nconst float FREQ = 0.75;\n\n// Emin <= c <= Emax: survive\n// Fmin <= c <= Fmax: generate\n// where c is the number of live voxels around.\n// Based on the paper below, I have set up a rule that makes it rare for the game to end.\n// http://wpmedia.wolfram.com/uploads/sites/13/2018/02/01-3-1.pdf\nconst int Emin = 4;\nconst int Emax = 7;\nconst int Fmin = 5;\nconst int Fmax = 6;\n\n// Convert pixel memory coordinates to voxel coordinates.\nivec3 px2idx(ivec2 U) { return ivec3(U.x / I.y, U.x % I.y, U.y); }\n// Get the state of a voxel\nint fetch(ivec3 i) { return int(texelFetch(iChannel0, ivec2(i.x * I.y + i.y, i.z), 0).x);}\n// good old sine hash function\nfloat hash12(vec2 u) { return fract(sin(dot(u, vec2(12.31539, 3.134781))) * 2144132.3); }\n\nvoid mainImage(out vec4 O, in vec2 FC) {\n    ivec2 U = ivec2(FC);\n    // Preserve the previous time in the upper left pixel.\n    if (U == ivec2(0, int(iResolution.y) - 1)) { O.x = iTime; return; }\n    // Randomly fill voxels in the first frame.\n    else if (iFrame == 0) { O.x = hash12(FC) < 0.4 ? 1.0 : 0.0; return; }\n\n    // The status is maintained except for the moment when the time boundary is crossed.\n    float prevTime = texelFetch(iChannel0, ivec2(0, int(iResolution.y) - 1), 0).x;\n    if (mod(iTime, FREQ) < 0.1 || mod(prevTime, FREQ) > 0.1) {\n        O = texture(iChannel0, FC / iResolution.xy); return;\n    }\n\n    ivec3 i = px2idx(U);\n    // Save the previous state in chronological order.\n    if (I.z <= i.z) { i.z -= I.z; O.x = float(fetch(i)); return; }\n\n    // Look at the state of neighboring voxels and sum them to advance the game.\n    int c = 0, n = fetch(i);\n    for (int k = 0; k < 27; k += k == 12 ? 2 : 1) {\n        c += fetch((i + ivec3(k / 9, (k % 9) / 3, k % 3) - 1 + I) % I);\n    }\n    O.x = (Emin <= c && c <= Emax && n == 1) || (Fmin <= c && c <= Fmax) ? 1.0 : 0.0;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/styXz1.jpg", "access": "api", "license": "mit", "functions": [[388, 388, 408, 408, 478], [1608, 1729, 1774, 1774, 2208], [2210, 2259, 2288, 2288, 2375], [2377, 2377, 2440, 2440, 2811], [2813, 2829, 2879, 2879, 3296], [3298, 3305, 3354, 3354, 3518], [3520, 3566, 3619, 3619, 3894], [4507, 4507, 4563, 4563, 5839]], "test": "untested"}
{"id": "7tGXzh", "name": "FFXIV Grapes Official Shadertoy!", "author": "toomuchvoltage", "description": "Grapes... made from Harry's recent Tweet: https://twitter.com/HarryAlisavakis/status/1473354613835325442\n\nI'm terribly sorry for this...", "tags": ["lowpoly", "gem", "meme", "harry", "grapes", "ffxiv", "alisavakis"], "likes": 8, "viewed": 504, "published": 3, "date": "1640159982", "time_retrieved": "2024-07-30T18:40:48.602748", "image_code": "/***********************************************************\n\n   Grapes, OMG GRAPES!\n   I couldn't help myself... I'm sorry.\n\n   Covered under the MIT license:\n\n   Copyright (c) 2021 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n\n#define DRAW_DISTANCE 100.0\n#define M_PI 3.1415926535\n//#define USE_PERIODIC_SMOOTHING 1\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n    return dot(p,n) + h;\n}\n\nconst vec3 topNorm1 = normalize (vec3 (0.0, 1.0, 0.75));\nconst vec3 topNorm2 = normalize (vec3 (0.0, 1.0, -0.75));\nconst vec3 topNorm3 = normalize (vec3 (0.75, 1.0, 0.0));\nconst vec3 topNorm4 = normalize (vec3 (-0.75, 1.0, 0.0));\nconst vec3 sideNorm1 = normalize (vec3 (0.0, -0.1, 0.75));\nconst vec3 sideNorm2 = normalize (vec3 (0.0, -0.1, -0.75));\nconst vec3 sideNorm3 = normalize (vec3 (0.75, -0.1, 0.0));\nconst vec3 sideNorm4 = normalize (vec3 (-0.75, -0.1, 0.0));\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n#ifdef USE_PERIODIC_SMOOTHING\nfloat scene(vec3 p)\n{\n    float smoothFactor = abs(sin(iTime)) * 0.5;\n    \n    float box = sdBox (p, vec3 (0.5, 1.0, 0.5));\n    float topPlane1 = sdPlane (p, topNorm1, -0.8);\n    float topPlane2 = sdPlane (p, topNorm2, -0.8);\n    float topPlane3 = sdPlane (p, topNorm3, -0.8);\n    float topPlane4 = sdPlane (p, topNorm4, -0.8);\n    float topCut = opSmoothIntersection (opSmoothIntersection (topPlane1, topPlane2, smoothFactor), opSmoothIntersection (topPlane3, topPlane4, smoothFactor), smoothFactor);\n\n    float sidePlane1 = sdPlane (p - vec3 (0.0, 0.0, 0.75) * 0.5, sideNorm1, 0.0);\n    float sidePlane2 = sdPlane (p - vec3 (0.0, 0.0, -0.75) * 0.5, sideNorm2, 0.0);\n    float sidePlane3 = sdPlane (p - vec3 (0.75, 0.0, 0.0) * 0.5, sideNorm3, 0.0);\n    float sidePlane4 = sdPlane (p - vec3 (-0.75, 0.0, 0.0) * 0.5, sideNorm4, 0.0);\n    float sideCut = opSmoothIntersection (opSmoothIntersection (sidePlane1, sidePlane2, smoothFactor), opSmoothIntersection (sidePlane3, sidePlane4, smoothFactor), smoothFactor);\n    \n    float bottomPlane1 = sdPlane (p, -topNorm1, -0.8);\n    float bottomPlane2 = sdPlane (p, -topNorm2, -0.8);\n    float bottomPlane3 = sdPlane (p, -topNorm3, -0.8);\n    float bottomPlane4 = sdPlane (p, -topNorm4, -0.8);\n    float bottomCut = opSmoothIntersection (opSmoothIntersection (bottomPlane1, bottomPlane2, smoothFactor), opSmoothIntersection (bottomPlane3, bottomPlane4, smoothFactor), smoothFactor);\n\n    return opSmoothIntersection (opSmoothIntersection (topCut, box, smoothFactor), opSmoothIntersection (sideCut, bottomCut, smoothFactor), smoothFactor) - smoothFactor;\n}\n#else\nfloat scene(vec3 p)\n{\n    float box = sdBox (p, vec3 (0.5, 1.0, 0.5));\n    float topPlane1 = sdPlane (p, topNorm1, -0.8);\n    float topPlane2 = sdPlane (p, topNorm2, -0.8);\n    float topPlane3 = sdPlane (p, topNorm3, -0.8);\n    float topPlane4 = sdPlane (p, topNorm4, -0.8);\n    float topCut = max (max (topPlane1, topPlane2), max (topPlane3, topPlane4));\n\n    float sidePlane1 = sdPlane (p - vec3 (0.0, 0.0, 0.75) * 0.5, sideNorm1, 0.0);\n    float sidePlane2 = sdPlane (p - vec3 (0.0, 0.0, -0.75) * 0.5, sideNorm2, 0.0);\n    float sidePlane3 = sdPlane (p - vec3 (0.75, 0.0, 0.0) * 0.5, sideNorm3, 0.0);\n    float sidePlane4 = sdPlane (p - vec3 (-0.75, 0.0, 0.0) * 0.5, sideNorm4, 0.0);\n    float sideCut = max (max (sidePlane1, sidePlane2), max (sidePlane3, sidePlane4));\n    \n    float bottomPlane1 = sdPlane (p, -topNorm1, -0.8);\n    float bottomPlane2 = sdPlane (p, -topNorm2, -0.8);\n    float bottomPlane3 = sdPlane (p, -topNorm3, -0.8);\n    float bottomPlane4 = sdPlane (p, -topNorm4, -0.8);\n    float bottomCut = max (max (bottomPlane1, bottomPlane2), max (bottomPlane3, bottomPlane4));\n\n    return max (max (topCut, box), max (sideCut, bottomCut));\n}\n#endif\n\nbool sphereMarchScene(vec3 startPt, vec3 dir, out vec3 hitPt, out vec3 hitNorm)\n{\n    vec3 samplePt = startPt;\n    for (int i = 0; i != 120; i++)\n    {\n        float curDist = scene (samplePt);\n        if ( curDist < 0.001 )\n        {\n            hitNorm.x = scene(samplePt + vec3(0.001, 0.0, 0.0)) - scene(samplePt - vec3(0.001, 0.0, 0.0));\n            hitNorm.y = scene(samplePt + vec3(0.0, 0.001, 0.0)) - scene(samplePt - vec3(0.0, 0.001, 0.0));\n            hitNorm.z = scene(samplePt + vec3(0.0, 0.0, 0.001)) - scene(samplePt - vec3(0.0, 0.0, 0.001));\n            hitNorm = normalize (hitNorm);\n            hitPt = samplePt;\n            return true;\n        }\n        samplePt += curDist * dir;\n    }\n    return false;\n}\n\nfloat evalTex (vec2 uv)\n{\n    return max (textureLod (iChannel0, uv, 0.0).r - 0.2, 0.0) * 1.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvRaw = fragCoord/iResolution.xy;\n    vec2 uv = uvRaw * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec4 mouseInfo = iMouse / iResolution.xxxx;\n    \n    vec3 curEye;\n    float angX = mouseInfo.x * 6.0 - M_PI * 0.5;\n    float angY = mouseInfo.y * 6.0 - M_PI * 0.5;\n    if (iMouse.z <= 0.0) angX += iTime;\n    curEye = vec3 (cos(angX), angY, sin(angX)) * 3.0;\n    vec3 sampleLook = normalize (-curEye);\n    \n    vec3 side = cross (vec3 (0.0, -1.0, 0.0), sampleLook);\n    vec3 up = cross (side, sampleLook);\n    \n    vec3 sampleDir = normalize (sampleLook + side * uv.x + up * uv.y);\n    vec3 samplePt = curEye + sampleDir;\n\n    samplePt = curEye + sampleDir;\n    vec3 hitNorm, hitPoint;\n    vec3 colorAccum = vec3 (0.0);\n\n    if ( sphereMarchScene (samplePt, sampleDir, hitPoint, hitNorm) )\n    {\n        vec3 absNorm = abs (hitNorm);\n        vec3 matFetch;\n        if ( absNorm.x > 0.7 )\n        {\n            vec2 centUV = hitPoint.yz * 0.5;\n            matFetch = vec3 (evalTex (centUV));\n            float du = evalTex (centUV - vec2 (0.01, 0.0)) - evalTex (centUV + vec2 (0.01, 0.0));\n            float dv = evalTex (centUV - vec2 (0.0, 0.01)) - evalTex (centUV + vec2 (0.0, 0.01));\n            hitNorm = normalize (hitNorm + vec3 (0.0, du, dv));\n        }\n        else if ( absNorm.y > 0.7 )\n        {\n            vec2 centUV = hitPoint.xz * 0.5;\n            matFetch = vec3 (evalTex (centUV));\n            float du = evalTex (centUV - vec2 (0.01, 0.0)) - evalTex (centUV + vec2 (0.01, 0.0));\n            float dv = evalTex (centUV - vec2 (0.0, 0.01)) - evalTex (centUV + vec2 (0.0, 0.01));\n            hitNorm = normalize (hitNorm + vec3 (du, 0.0, dv));\n        }\n        else\n        {\n            vec2 centUV = hitPoint.xy * 0.5;\n            matFetch = vec3 (evalTex (centUV));\n            float du = evalTex (centUV - vec2 (0.01, 0.0)) - evalTex (centUV + vec2 (0.01, 0.0));\n            float dv = evalTex (centUV - vec2 (0.0, 0.01)) - evalTex (centUV + vec2 (0.0, 0.01));\n            hitNorm = normalize (hitNorm + vec3 (du, dv, 0.0));\n        }\n        matFetch *= vec3 (0.25, 0.05, 1.0) * 0.5; // Grape color\n        \n        float absNdotL = abs (dot(sampleDir,hitNorm));\n        \n        float diff = absNdotL; // Headlight lambert\n        diff = pow (diff, 2.0);\n        \n        vec3 Rv = reflect (sampleDir, hitNorm);\n        vec3 L1 = -sampleLook;\n        vec3 L2 = normalize (-sampleLook + vec3 (55.0, 0.0, 0.0));\n        float phong1 = abs (dot (Rv, L1)); // Headlight phong1\n        phong1 = pow (phong1, 500.0);\n        vec3 phoneLight1 = phong1 * vec3 (0.75, 0.75, 0.0);\n        float phong2 = abs (dot (Rv, L2)); // Headlight phong2\n        phong2 = pow (phong2, 500.0);\n        vec3 phoneLight2 = phong2 * vec3 (0.25, 0.35 ,0.5);\n        \n        vec3 shlick = pow (1.0 - absNdotL, 7.0) * vec3 (0.25, 0.35 ,0.5) * 0.5; // Fresnel halo\n        \n        fragColor = vec4 (diff * matFetch + phoneLight1 + phoneLight2 + shlick, 1.0);\n        \n        fragColor.rgb = pow (fragColor.rgb, vec3 (1.0/2.2)); // Gamma\n    }\n    else\n        fragColor = vec4 (vec3 (0.25, 0.35 ,0.5) * max (1.5 - length(uv), 0.0), 1.0);\n    \n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGXzh.jpg", "access": "api", "license": "mit", "functions": [[1603, 1603, 1634, 1634, 1725], [1727, 1727, 1769, 1769, 1796], [2267, 2267, 2326, 2326, 2425], [5229, 5229, 5310, 5310, 5953], [5955, 5955, 5980, 5980, 6052], [6054, 6054, 6111, 6111, 9278]], "test": "untested"}
{"id": "7tySRh", "name": "real coool thing", "author": "bigbadbob234", "description": "might give headache and not be pleasant to watch, idk. \nI like it, like hyperpop that goes through your eyeballs\n", "tags": ["colors", "colorshift", "shepardtone", "russellbeat", "inventing", "newcolors"], "likes": 1, "viewed": 222, "published": 3, "date": "1640145019", "time_retrieved": "2024-07-30T18:40:49.440508", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy; // + vec2(-.5, .5);\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //vec2 uv = fragCoord;\n    \n    float t = (sin(iTime*.2)*.5+.5)*1.5; // shld reverse at 26 se\n    float k = .005;\n    float doodle = iTime*64.;\n    float a = .5 + .5*cos(doodle + uv.x - (uv.x*floor(uv.x/k)) + uv.y - (uv.y*floor(uv.y/k)));\n    float b1 = (t-floor(t));\n    float b = a; // + b1;\n    //(uv.x*floor(uv.x / 7.0)) \n    float h = b - (b * floor(b/t));\n    float h2 = exp(h)/2.718;\n    \n       \n    //vec3 midcol = vec3(1.,1.,1.);\n    //vec3 cola = mix(vec3(1.,.0,1.), vec3(1.,0.,0.), h2);\n    //vec3 colb = mix(vec3(0.,1.,1.), vec3(0.,.5,1.), h2);\n    \n    //vec3 cola = mix(vec3(2.,.0,.0), vec3(0.,1.,2.), h);\n    //vec3 colb = mix(vec3(1.,1.,1.), vec3(0.,.0,2.), h2);\n    //vec3 col = mix(cola, colb, h);\n    \n    //vec3 cola = mix(vec3(1,1,0), vec3(1,0,1), h);\n    //vec3 colb = mix(vec3(1,0,1), vec3(0,1,12), h2*h);\n    //vec3 col = mix(cola, colb, h2);\n\n\n    // Time varying pixel color\n    //vec2 uv2 = fragCoord/iResolution.xy;\n    //vec3 colc = 0.5 + 0.5*cos(t+uv2.xyx+vec3(0,2,4));\n    //vec3 colc2 = 0.5 + 0.5*sin(t+uv2.xyx+vec3(0,2,4));\n    //vec3 cola = mix(colc, vec3(0,3,0), h);\n    //vec3 colb = mix(colc2, vec3(1,1,1), h2*h);\n    //vec3 col = mix(cola, colb, h2);\n    \n    vec3 cola = mix(vec3(1,1,0), vec3(1,0,0), h);\n    vec3 colb = mix(vec3(0,1,1), vec3(0,1,5), h2*h);\n    vec3 col = mix(cola, colb, h2);\n    \n    \n    //vec3 col = vec3(1.-h2*2., (.5-h2)*(.5-h), h2*(abs(.25-h)+1.));\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tySRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 1797]], "test": "untested"}
{"id": "NtyXz1", "name": "happy bouncing variation 3", "author": "leon", "description": "shader about boucing animation, space transformation, easing functions, funny shape and colorful vibes.", "tags": ["colorful", "animation"], "likes": 28, "viewed": 532, "published": 3, "date": "1640141951", "time_retrieved": "2024-07-30T18:40:50.189505", "image_code": "// Fork of \"happy bouncing variation 2\" by leon. https://shadertoy.com/view/NlGXR1\n// 2021-12-22 01:53:45\n\n// Fork of \"happy bouncing variation 1\" by leon. https://shadertoy.com/view/ftGXR1\n// 2021-12-22 00:28:04\n\n// Fork of \"happy bouncing\" by leon. https://shadertoy.com/view/flyXRh\n// 2021-12-22 00:11:16\n\n// \"happy bouncing\"\n// shader about boucing animation, space transformation, easing functions,\n// funny shape and colorful vibes.\n// by leon denise (2021-12-21)\n// licensed under hippie love conspiracy\n\n// using Inigo Quilez works:\n// arc sdf from https://www.shadertoy.com/view/wl23RK\n// color palette https://iquilezles.org/articles/palettes\n\n// global variable\nfloat bodySize = 0.3;\n\n// shape eyes\nvec2 size = vec2(.08, .09);\nfloat divergence = 0.08;\n\n// easing curves are below\nfloat jump(float);\nfloat walk(float);\nfloat stretch(float);\nfloat bounce(float);\nfloat swing(float);\n\nfloat ao(float);\n\n// list of transformation (fun to tweak)\nvec2 animation(vec2 p, float t)\n{\n    t = fract(t);\n    \n    p.y -= bodySize;\n    p.y -= 0.1;\n    \n    float j = jump(t);\n    p.y -= j*.1;\n    p.x *= stretch(t)*.1+1.;\n    p *= rot(sin(p.y+t*6.283)*.5);\n    float b = bounce(t)*.2;\n    p.y *= b+1.;\n    p.y += b*bodySize;\n    //p.x += walk(t)*0.2;\n    //p *= 1.5-j*.9;\n    \n    return p;\n}\n\nvec4 sdEyes (vec2 p, float t, vec3 tint, float sens)\n{\n    vec3 col = vec3(0);\n    float shape = 100.;\n    \n    // eyes positions\n    p = animation(p, t);\n    p *= rot(swing(t)*-.1);\n    p -= vec2(.03, bodySize);\n    p.x -= divergence*sens;\n\n    // globe shape\n    float eyes = circle(p, size.x);\n    //col = mix(col, tint, fill(eyes));\n    //shape = min(shape, eyes);\n\n    // white eye shape\n    eyes = circle(p, size.y);\n    col = mix(col, vec3(1)*ss(-.2,0.2,p.y+.1), fill(eyes));\n    shape = min(shape, eyes);\n\n    // black dot shape\n    eyes = circle(p, 0.02);\n    col = mix(col, vec3(0), fill(eyes));\n    shape = min(shape, eyes);\n    \n    return vec4(col, shape);\n}\n\nvoid mainImage( out vec4 color, in vec2 pixel )\n{\n    vec2 uv = pixel/iResolution.xy;\n    color = vec4(0,0,0,1);\n    \n    // ground\n    color.rgb += vec3(.25)*step(uv.y,0.1);\n    \n    // number of friends\n    const float buddies = 5.;\n    for (float i = 0.; i < buddies; ++i)\n    {\n        // usefull to dissociate instances\n        float ii = i/(buddies);\n        float iy = i/(buddies-1.);\n        \n        // translate\n        float iii = 1.-ii;\n        \n        // translate instances\n        vec2 pp = (pixel-vec2(0.5,0)*iResolution.xy)/iResolution.y;\n        pp.x += (iy*2.-1.)*.5;\n        pp *= 2.;\n        \n        // time\n        float t = fract(iTime*.5 + ii);\n        \n        // there will be sdf shapes\n        float shape = 1000.;\n        vec2 p;\n        \n        // there will be layers\n        vec3 col = vec3(0);\n        \n        // color palette\n        // Inigo Quilez (https://iquilezles.org/articles/palettes)\n        vec3 tint = .5+.5*cos(vec3(0.,.3,.6)*6.28+i-length(animation(pp-vec2(0,.1),t))*3.);\n        \n        // body shape\n        p = animation(pp, t);\n        float body = circle(p, bodySize);\n        col += tint*fill(body);\n        shape = min(shape, body);\n        \n        vec4 eyes = sdEyes(pp, t-.01, tint, -1.);\n        col = mix(col*ao(eyes.a), eyes.rgb, step(eyes.a,0.));\n        shape = min(shape, eyes.a);\n        eyes = sdEyes(pp, t+.01, tint, 1.);\n        col = mix(col*ao(eyes.a), eyes.rgb, step(eyes.a,0.));\n        shape = min(shape, eyes.a);\n        \n        \n        // smile animation\n        float anim = sin(t*6.28)*.5+.5;\n        float thin = mix(0.01, 0.05, anim);\n        float lips = mix(0.1, 0.1, anim);\n        float smile = mix(.1, .6, anim);\n        float radius = mix(0.5, 0.5, anim);\n        \n        // smile position\n        p = animation(pp, t+0.01);\n        p -= bodySize*vec2(.1, radius*2.+radius*anim+.5*anim);\n        vec2 q = p;\n        \n        // arc\n        float d = sdArc(p,-3.14/2., smile, radius, thin);\n        \n        float dm = d-lips;\n        shape = min(shape, dm);\n        col = mix(col*ao(dm), tint, fill(dm));\n        \n        // black line\n        col = mix(col*ao(d), tint*.6, fill(d));\n        \n        // add buddy to frame\n        color.rgb = mix(color.rgb * ao(shape), col, step(shape, 0.));\n    }\n}\n\nfloat ao (float sd)\n{\n    return clamp(sd+.85,0.,1.);\n}\n\n// easing curves (not easy to tweak)\n// affect timing of transformations;\n\nfloat jump (float t)\n{\n    t = min(1., t*3.);\n    t = abs(sin(t*3.1415));\n    return pow(t, .8);\n}\n\nfloat walk (float t)\n{\n    t = mix(pow(t,2.), pow(t, 0.5), t);\n    return (cos(t*3.1415*2.));\n}\n\nfloat swing (float t)\n{\n    //t = pow(t, .5);\n    //t = t*2.;\n    //t = pow(t, .5);\n    t = sin(t*3.14*2.);\n    return t;\n}\n\nfloat stretch (float t)\n{\n    float tt = sin(t*6.283*2.);\n    return tt;\n}\n\nfloat bounce (float t)\n{\n    float tt = cos(t*6.283*2.);\n    return tt;\n}", "image_inputs": [], "common_code": "\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdArc( in vec2 p, in float ta, in float tb, in float ra, float rb )\n{\n    vec2 sca = vec2(sin(ta),cos(ta));\n    vec2 scb = vec2(sin(tb),cos(tb));\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p,scb) : length(p);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n// snippets\n#define fill(sdf) (smoothstep(.001, 0., sdf))\n#define repeat(p,r) (mod(p,r)-r/2.)\n#define ss(a,b,t) (smoothstep(a,b,t))\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat circle (vec2 p, float size)\n{\n    return length(p)-size;\n}\nfloat wrap (float v)\n{\n    return sin(v*6.283)*.5+.5;\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtyXz1.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[911, 952, 985, 985, 1290], [1292, 1292, 1346, 1346, 1963], [1965, 1965, 2014, 2014, 4257], [4259, 4259, 4280, 4280, 4314], [4391, 4391, 4413, 4413, 4489], [4491, 4491, 4513, 4513, 4586], [4588, 4588, 4611, 4671, 4711], [4713, 4713, 4738, 4738, 4787], [4789, 4789, 4813, 4813, 4862]], "test": "untested"}
{"id": "NldXWf", "name": "Metalomateron", "author": "davidar", "description": "I've been really enjoying [url=https://www.shadertoy.com/user/lomateron]lomateron[/url]'s fluid simulations lately, so in an effort to understand them, I ended up simplifying/abstracting several and combining them into a single generalised shader", "tags": ["convolution"], "likes": 66, "viewed": 820, "published": 3, "date": "1640141511", "time_retrieved": "2024-07-30T18:40:50.965430", "image_code": "// Original shaders by lomateron.\n// I find it rather pleasing how the core loop for each of the buffers can be distilled into a short one-liner,\n// such complex behaviour from quite simple systems!\n\nMAIN {\n    vec4 a = Du;\n    if(SHADER == 2) { // veinss\n        r = sin(a.x*4.+vec4(1,3,5,4))*.25 + sin(a.y*4.+vec4(1,3,2,4))*.25 + .5;\n    } else if(SHADER == 3) { // exploding blobs\n        r = a.z+a.z*sin(length(a.xy)+vec4(1,2,3,4));\n    } else if(SHADER == 4) { // wigli wires\n        r = sin(a.x*2.+vec4(1,2,3,4)+0.)*.25 + sin(a.y*2.+vec4(1,2,3,4)+0.)*.25 + .5;\n    } else if(SHADER == 5) { // spirals vs ghosts\n        r = pow(a.z,.15)*(cos(length(a.xy)*2.+vec4(0,2,4,6)+3.)*.3+.7);\n    } else if(SHADER == 6) { // radioactive space balls\n        r = sin(pow(a.z,.15)*5.+vec4(1,2,3,4))*.5+.5;\n    } else if(SHADER == 7) { // exotic smoke\n        r = a.xxyz*.1+sin(pow(a.z,.2)*2.+vec4(1,2,3,4))*.5+.5;\n    }\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define GRID vec2(3,2)\n#define CELL ivec2(GRID * u/R)\n#define SHADER (2 + CELL.x + int(GRID.x)*CELL.y)\n\n#define MAIN void mainImage( out vec4 r, in vec2 u )\n#define R iResolution.xy\n\n#define UV fract(GRID * u/R)\n\n// convolutions\n#define CONV(z) for(int i=-z; i<=z; ++i) for(int j=-z; j<=z; ++j)\n#define CONVO(z) CONV(z) if(0. < length(ij) && length(ij) <= float(z))\n\n// gaussian\n#define G(c) exp(-dot(c,c))\n\n// textures\n#define UVCOORD(u) ((vec2(CELL) + fract(GRID * (u)/R)) / GRID)\n#define A(u) texture(iChannel0,UVCOORD(u))\n#define B(u) texture(iChannel1,UVCOORD(u))\n#define C(u) texture(iChannel2,UVCOORD(u))\n#define D(u) texture(iChannel3,UVCOORD(u))\n\n#define Au A(u)\n#define Bu B(u)\n#define Cu C(u)\n#define Du D(u)\n\n#define Ai A(u+ij)\n#define Bi B(u+ij)\n#define Ci C(u+ij)\n#define Di D(u+ij)\n\n#define Ad (Ai - Au)\n#define Bd (Bi - Bu)\n#define Cd (Ci - Cu)\n#define Dd (Di - Du)\n\n// rotation\n#define rot90(b) ((b).yx * vec2(-1,1))\n\n// safe division\n#define normz(v) (length(v) == 0. ? v : normalize(v))\n#define recip(s) ((s) == 0. ? 1. : 1./(s))\n\n#define ij vec2(i,j)\n#define nij normz(ij)\n#define lij length(ij)\n", "buffer_a_code": "#define Dp vec2(dot(nij, Dd.xy), dot(nij, rot90(Dd.xy)))\n\nMAIN {\n    r = vec4(0);\n    vec4 w = vec4(0);\n    if(SHADER == 2) {\n        float z = .5*.5 / 3.14; // gaussian normalisation const\n        CONV(6) r += z * G(.5 * ij) * vec4(Dp.x, abs(Dp.y), 1,1);\n    } else if(SHADER == 3) {\n        CONV(8) r += .375 * lij * G(.375 * ij) * vec4(nij * Dd.z, Dp * Di.z);\n    } else if(SHADER == 4) {\n        CONV(4) r.x += length(Dd.xy);\n    } else if(SHADER == 5) {\n        w = vec4(.7, .175, .1, 1);\n    } else if(SHADER == 6) {\n        w = vec4(.66, .25, .1, 1);\n    //} else if(SHADER == 7.5) {\n    //    w = vec4(2, .5, 1, 1);\n    //} else if(SHADER == 8.5) {\n    //    CONVO(8) r += vec4(vec2(length(Dd.xy) * sin(dot(ij/8., rot90(Dd))*6.)), dot(nij, rot90(Dd)), 0);\n    } else if(SHADER == 7) {\n        w = vec4(0,0,1,1);\n    //} else if(SHADER == 9) {\n    //    CONV(8) r += dot(Di.xy,ij/4.)*G(ij/4.);\n    }\n    if(w.w != 0.) CONVO(8) r += vec4(nij * Dd.z * cos(w.x * lij) * G(w.y * lij) * w.z, Dp);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "MAIN {\n    r = Du;\n    vec4 w = vec4(0);\n    if(SHADER == 2) {\n        w = vec4(1, 1, .5, 3);\n    } else if(SHADER == 3) {\n        w = vec4(-.0225 * Du.z, 1, .375, 2);\n    } else if(SHADER == 4) {\n        w = vec4(-.00675, 1, .75, 0);\n    } else if(SHADER == 5 || SHADER == 7) {\n        w = vec4(1./8e3, 1, 0, 1);\n    //} else if(SHADER == 8.5) {\n    //    w = vec4(-1e-6, 0, 1./8., 1);\n    //} else if(SHADER == 9) {\n    //    w = vec4(-.0015, 1, .5, 0);\n    }\n    CONVO(8)\n        r.xy += w.x * mix(Ai.xy, vec2(1), w.y) * G(w.z * ij)\n            * ( w.w == 0. ? ij * Ai.x\n              : w.w == 1. ? nij * Ai.z\n              : w.w == 2. ? rot90(ij) * Ai.w\n              : nij * (Ai.x*.1 + Ad.y*.5));\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "MAIN {\n    r = Bu;\n    float w = 1.;\n    if(SHADER == 1) {\n        r = Du;\n    } else if(SHADER == 3) {\n        r += Au * (Bu.z-.5);\n        w = .5;\n    } else if(SHADER == 5) {\n        r += Au;\n        w = 1.5;\n    } else if(SHADER == 6) {\n        r = Du + Au;\n        w = 1./.75;\n    //} else if(SHADER == 7.5) {\n    //    r += Au;\n    } else if(SHADER == 7) {\n        r += Au * (Bu.z-.5)*.3;\n    //} else if(SHADER == 9) {\n    //    r = Du;\n    //    w = 1./6. * (sin(Du.z*3.)*2.+4.);\n    }\n    float s = 0.;\n    CONV(8) s += G(w * (r.xy + ij));\n    r = vec4(r.xy, recip(s), 0);\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "MAIN {\n    r = vec4(0);\n    vec4 w = vec4(0);\n    /*if(SHADER == 1) {\n        CONV(6) r += Di.z * G(Ci.xy+ij) * vec4(Ci.xy+(Ci.xy+ij)*(.8-Di.z),Ci.z,1);\n    } else*/ if(SHADER == 2 || SHADER == 4) {\n        w = vec4(0,1,0,0);\n    } else if(SHADER == 3) {\n        w = vec4(1, .5, 0, 0);\n    } else if(SHADER == 5) {\n        w = vec4(1, 1.5, 0, 0);\n    } else if(SHADER == 6) {\n        w = vec4(2, 1./.75, 0, 0);\n    } else if(SHADER == 7) {\n        w = vec4(1,1,0,0);\n    //} else if(SHADER == 9) {\n    //    CONV(6) r += vec4((Bi * Ci.z * G((Bi.xy-ij)/6. * (sin(Bi.z*3.)*2.+4.))).xyz, 0);\n    }\n\n    CONV(8) r += (w.x == 0. ? 1. : w.x == 1. ? Bi.z : Di.z) * G(w.y * (Ci.xy - ij)) * vec4(Ci.xyz, 1);\n    r.xy *= recip(r.w);\n\n    int scales[9] = int[](0,22,4,4,8,16,8,8,2);\n    float scale = float(scales[SHADER-1]);\n    if(iMouse.z>0.) {\n        vec2 m = scale*(u-iMouse.xy)/R.y;\n        r += vec4(m,0,0)*G(m)*.1;\n    }\n    if(iFrame < 2) {\n        vec2 m = scale * (UV - 0.5);\n        //if(SHADER == 9) r = vec4(.1*G(m));\n        r = vec4(m,1,1)*G(m);\n    }\n}\n", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldXWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "flySR1", "name": "Voxel City Raymarched", "author": "ShnitzelKiller", "description": "voxel DDA plus raymarching for individual cells", "tags": ["raymarching"], "likes": 11, "viewed": 362, "published": 3, "date": "1640137658", "time_retrieved": "2024-07-30T18:40:51.714428", "image_code": "#define PI 3.141593\n#define MAX_VOXELS 400\n#define MAX_HEIGHT 100.\n#define MAXSTEP 200\n#define MAX_SHADOW_VOXELS 100\n#define TOL 0.001\n#define NORMTOL 0.001\n#define FDIST 0.5\n\n#define PERIOD 11.\n#define BUILDINGRAD 4.\n#define RIM_SIZE .1\n#define SPEED 5.\n\nstruct Hit {\n    float t;\n    int mat;\n    vec3 n;\n    vec3 id;\n};\n    \nfloat noise2d(in vec2 uv) {\n    return fract(814.*sin(uv.x*15829.+uv.y*874.));\n}\n\nfloat smoothnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( noise2d( i + vec2(0.0,0.0) ), \n                     noise2d( i + vec2(1.0,0.0) ), u.x),\n                mix( noise2d( i + vec2(0.0,1.0) ), \n                     noise2d( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\n    return vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat occupancy(in vec3 id, out int mat) {\n    vec2 block = floor(id.xy/PERIOD+0.5);\n    vec3 modid = vec3(mod(id.xy+0.5*PERIOD, PERIOD)-0.5*PERIOD, id.z);\n    float randval1 = noise2d(block);\n    float randval2 = noise2d(vec2(block.y, randval1));\n    \n    vec2 mindist = vec2(max(modid.z-(500. * max(0.,randval1 - 0.1)), PERIOD*0.5 - length(modid.xy)), 3.); //base\n    vec2 buildings = vec2(max(length(modid.xy)-BUILDINGRAD, -30.+modid.z-100.*randval2), 2.);\n    buildings.x = max(buildings.x, -length(vec2(mix(modid.x, modid.y, mod(floor(modid.z/4.), 2.0)), mod(modid.z, 4.)-2.)) + 2.);\n    mindist = condmin(mindist, buildings);\n    vec2 ground = vec2(modid.z + smoothnoise(id.xy/4.), 1.0);\n    mindist = mix(mindist, ground, step(0.2, randval1));\n    float occ = step(mindist.x, 0.5);\n    mat = int(occ * round(mindist.y));\n    return occ;\n}\n\nfloat map(in vec3 ro, float blend) {\n    vec3 roabs = abs(0.5-ro);\n    vec3 diffs = .5 - RIM_SIZE - roabs;\n    float scaffdist = max(min(diffs.x, diffs.y), max(min(diffs.y, diffs.z), min(diffs.z, diffs.x)));\n    //float blockdist = length(0.5-ro)-0.73;\n    if (roabs.x < roabs.y) roabs.xy = roabs.yx;\n    vec2 ro2 = abs(roabs.xy - vec2(0.5, 0));\n    vec2 diffs2 = .2 - ro2;\n    float blockdist = min(diffs2.x, diffs2.y);\n    //blockdist = max(blockdist, -length(roabs - vec3(0.8, 0.,0.))+0.55);\n    return mix(blockdist, scaffdist, blend);\n}\n\nvec3 getnormal(vec3 ro, float blend) {\n    vec2 d = vec2(NORMTOL, 0.0);\n    return normalize(vec3(\n        map(ro+d.xyy, blend)-map(ro-d.xyy, blend),\n        map(ro+d.yxy, blend)-map(ro-d.yxy, blend),\n        map(ro+d.yyx, blend)-map(ro-d.yyx, blend)));\n}\n\nHit voxtrace(in vec3 ro, in vec3 rd) {\n    Hit h;\n    h.mat = 0;\n    h.t = 0.;\n    // box marching with fb39ca4's DDA\n    h.id = floor(ro);        \n    vec3 ri = 1.0/rd;\n    vec3 rs = sign(rd);\n    vec3 dis = (h.id-ro + 0.5 + rs*0.5) * ri;\n    vec3 mm = vec3(0.0);\n    //int j=0;\n    for (int i=0; i<MAXSTEP; i++) {\n        mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n\t\tdis += mm * rs * ri;\n        h.id += mm * rs;\n        if (h.id.z > MAX_HEIGHT) {\n            return h;\n        }\n        if (occupancy(h.id, h.mat) > 0.5) {\n            h.n = -mm*rs;\n\t\n            vec3 mini = (h.id-ro + 0.5 - 0.5*vec3(rs))*ri;\n            float t_enter = max ( mini.x, max ( mini.y, mini.z ) );\n            vec3 maxi = (h.id-ro + 0.5 + 0.5*vec3(rs))*ri;\n            float t_exit = min ( maxi.x, min ( maxi.y, maxi.z ) );\n            \n            float dt = t_exit - t_enter;\n            \n            float matblend = float(h.mat - 2);\n            \n            \n            //raymarch\n            if (h.mat != 1) {\n                float t = 0.0;\n                vec3 eye = ro + rd * t_enter - h.id;\n                while (i < MAXSTEP) {\n                    ++i;\n                    vec3 modpos2 = eye + rd*t;\n\n                    float height = map(modpos2, matblend);\n                    t += height;\n                    if (abs(height) < TOL) {\n                        h.t = t_enter + t;\n                        h.n = getnormal(eye + rd * t, matblend);\n                        return h;\n                    } else if (t < 0.0) {\n                        h.t = t_enter;\n                        return h;\n                    } else if (t > dt) {\n                        h.t = t_exit;\n                        break;\n                    }\n                }\n                h.t = t_exit;\n            } else {\n                h.t = t_enter;\n                return h;\n            }\n    \t}\n    }\n    \n    \n\t     \n    return h;\n}\n\nvec2 shadowtrace(in vec3 ro, in vec3 rd) {\n    float t = 0.;\n    vec3 id = floor(ro);\n    vec3 ri = 1.0/rd;\n    vec3 rs = sign(rd);\n    vec3 dis = (id-ro + 0.5 + rs*0.5) * ri;\n    vec3 mm = vec3(0.0);\n    //int j=0;\n    for (int i=0; i<MAX_SHADOW_VOXELS; i++) {\n        mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n\t\tdis += mm * rs * ri;\n        id += mm * rs;\n        int mat;\n        if (id.z > MAX_HEIGHT) {\n            return vec2(1., i);\n        }\n        if (occupancy(id, mat) > 0.5) {\n            if (mat != 3)\n            return vec2(0., i);\n    \t}\n    }\n    return vec2(1., MAX_SHADOW_VOXELS);\n}\n\nvec3 sampleTriplanar(in vec3 dir2, in vec3 pos, in sampler2D tex) {\n    return dir2.x * texture(tex, pos.yz).xyz + dir2.y * texture(tex, pos.zx).xyz + dir2.z * texture(tex, pos.xy).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mouseY = iMouse.y < 1. ? 0. : (0.5-iMouse.y/iResolution.y) * PI;\n    float mouseX = iMouse.x < 1. ? iTime*0.25 : -(iMouse.x/iResolution.x) * 2. * PI;\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n\tvec3 eye = vec3(PERIOD*0.5, iTime * SPEED, 6.4);\n    vec3 w = vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), -sin(mouseY)+.00001);\n    vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(FDIST*w + uv.x*u + uv.y*v);\n    \n    Hit h = voxtrace(eye, rd);\n    vec3 pos = eye + h.t * rd;\n    vec3 LIGHTDIR = normalize(vec3(1., -2., 1.5));\n    vec2 shadowfac = shadowtrace(pos, LIGHTDIR);\n    float attenuation_fac = shadowfac.y/float(MAX_SHADOW_VOXELS) * .5;\n    float shadowfac_attenuated = mix(shadowfac.x, 1., (attenuation_fac));\n    \n    float lightfac = max(0., dot(h.n, LIGHTDIR));\n    //dummy visualization\n    \n    vec3 n2 = h.n * h.n;\n    //vec3 col = ((h.n * (float(h.mat)/4.))*.5 +.5);\n    vec3 skycol = texture(iChannel3, rd.yzx).xyz * vec3(0.6, 0.8, 0.9);\n    vec3 texpos = pos / 2.;\n    vec3 col = mix(sampleTriplanar(n2, texpos, iChannel0), mix(sampleTriplanar(n2, texpos, iChannel1), sampleTriplanar(n2, texpos, iChannel2), clamp(float(h.mat-2), 0., 1.)), clamp(float(h.mat-1), 0., 1.));\n    col = mix(skycol, col * (mix(lightfac * shadowfac_attenuated, 1., 0.1)), min(1., float(h.mat)));\n    col = mix(col, vec3(1.8, 0.5, 0.6), sqrt(clamp(-pos.z/50., 0., 1.)));\n    \n    fragColor = vec4(pow(col, vec3(0.75)), 1.);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flySR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[328, 328, 355, 355, 408], [410, 410, 442, 442, 748], [750, 750, 788, 788, 859], [861, 861, 903, 903, 1706], [1708, 1708, 1744, 1744, 2249], [2251, 2251, 2289, 2289, 2506], [2508, 2508, 2546, 2546, 4425], [4427, 4427, 4469, 4469, 5041], [5043, 5043, 5110, 5110, 5230], [5232, 5232, 5289, 5289, 6798]], "test": "untested"}
{"id": "NlGXR1", "name": "happy bouncing variation 2", "author": "leon", "description": "shader about boucing animation, space transformation, easing functions, funny shape and colorful vibes.", "tags": ["colorful", "animation"], "likes": 9, "viewed": 304, "published": 3, "date": "1640137502", "time_retrieved": "2024-07-30T18:40:52.468412", "image_code": "// Fork of \"happy bouncing variation 1\" by leon. https://shadertoy.com/view/ftGXR1\n// 2021-12-22 00:28:04\n\n// Fork of \"happy bouncing\" by leon. https://shadertoy.com/view/flyXRh\n// 2021-12-22 00:11:16\n\n// \"happy bouncing\"\n// shader about boucing animation, space transformation, easing functions,\n// funny shape and colorful vibes.\n// by leon denise (2021-12-21)\n// licensed under hippie love conspiracy\n\n// using Inigo Quilez works:\n// arc sdf from https://www.shadertoy.com/view/wl23RK\n// color palette https://iquilezles.org/articles/palettes\n\n// global variable\nvec3 rng;\nfloat bodySize = 0.2;\n\n// shape eyes\nvec2 size = vec2(.07, .05);\nfloat divergence = 0.06;\n\n// easing curves are below\nfloat jump(float);\nfloat walk(float);\nfloat stretch(float);\nfloat bounce(float);\nfloat swing(float);\n\n// list of transformation (fun to tweak)\nvec2 animation(vec2 p, float t)\n{\n    t = fract(t);\n    \n    p.y -= bodySize;\n    // sidebar\n    p.y -= 0.1;\n    p.y -= (jump(t))*.5;\n    //p.x += walk(t)*0.1;\n    \n    return p;\n}\n\nvec4 sdEyes (vec2 p, float t, vec3 tint, float sens)\n{\n    vec3 col = vec3(0);\n    float shape = 100.;\n    \n    // eyes positions\n    p = animation(p, t);\n    p *= rot(swing(t)*-.5);\n    p -= vec2(.03, bodySize+size.x*.2);\n    p.x -= divergence*sens;\n\n    // globe shape\n    float eyes = circle(p, size.x);\n    col = mix(col, tint, fill(eyes));\n    shape = min(shape, eyes);\n\n    // white eye shape\n    eyes = circle(p, size.y);\n    col = mix(col, vec3(1), fill(eyes));\n\n    // black dot shape\n    eyes = circle(p, 0.02);\n    col = mix(col, vec3(0), fill(eyes));\n    \n    return vec4(col, shape);\n}\n\nvoid mainImage( out vec4 color, in vec2 pixel )\n{\n    vec2 uv = pixel/iResolution.xy;\n    color = vec4(0,0,0,1);\n    \n    // ground\n    //color.rgb += mix(vec3(0.945,0.945,0.792), vec3(0.820,0.482,0.694), smoothstep(0.0,.2,uv.y-.2));\n    color.rgb += vec3(.25)*step(uv.y,0.1);\n    \n    // number of friends\n    const float buddies = 6.;\n    for (float i = 0.; i < buddies; ++i)\n    {\n        // usefull to dissociate instances\n        float ii = i/(buddies);\n        float iy = i/(buddies-1.);\n        \n        // translate\n        //ii = fract(ii+iTime*.2);\n        float iii = 1.-ii;\n        \n        // translate instances\n        vec2 pp = (pixel-vec2(0.5,0)*iResolution.xy)/iResolution.y;\n        pp.x += (iy*2.-1.)*.5;\n        pp *= 2.;\n        \n        // time\n        float t = fract(iTime*.5 + ii * .5);\n        \n        // there will be sdf shapes\n        float shape = 1000.;\n        vec2 p;\n        \n        // there will be layers\n        vec3 col = vec3(0);\n        \n        // color palette\n        // Inigo Quilez (https://iquilezles.org/articles/palettes)\n        vec3 tint = .5+.5*cos(vec3(0.,.3,.6)*6.28+i-length(animation(pp-vec2(0,.1),t))*3.);\n        \n        // body shape\n        p = animation(pp, t);\n        p.x *= stretch(t)*-0.2+1.;\n        float body = circle(p, bodySize);\n        col += tint*fill(body);\n        shape = min(shape, body);\n        \n        vec4 eyes = sdEyes(pp, t-.03, tint, -1.);\n        col = mix(col, eyes.rgb, step(eyes.a,0.));\n        shape = min(shape, eyes.a);\n        eyes = sdEyes(pp, t-.01, tint, 1.);\n        col = mix(col, eyes.rgb, step(eyes.a,0.));\n        shape = min(shape, eyes.a);\n        \n        // smile animation\n        float anim = cos(pow(t, 2.)*6.28)*.5+.5;\n        \n        // smile position\n        p = animation(pp, t-0.01);\n        p -= bodySize*vec2(.1, .6-1.*anim);\n        vec2 q = p;\n        \n        // arc (fun to tweak)\n        float smile = mix(0., 1., anim);//+(.5+.5*sin(ii*12.+iTime*12.*ii));\n        float thin = mix(0.05, 0.01, anim);//+0.04*(.5+.5*sin(ii*12.+iTime*22.*ii));\n        float d = sdArc(p,-3.14/2., smile, 0.1, thin);\n        \n        // black line\n        col = mix(col, tint*(fract(q.y*5.)*.7+.3), fill(d));\n        \n        // add buddy to frame\n        float ao = clamp(shape+.9,0.,1.);\n        color.rgb = mix(color.rgb * ao, col, step(shape, 0.));\n    }\n}\n\n// easing curves (not easy to tweak)\n// affect timing of transformations;\n\nfloat jump (float t)\n{\n    t = min(1., t*4.);\n    t = abs(sin(t*3.1415));\n    return pow(sin(t*3.14/2.), .5);\n}\n\nfloat walk (float t)\n{\n    t = mix(pow(t,.5), pow(t, 2.0), t);\n    return (cos(t*3.1415*2.));\n}\n\nfloat swing (float t)\n{\n    //t = pow(t, .5);\n    //t = t*2.;\n    //t = pow(t, .5);\n    t = sin(t*3.14*2.);\n    return t;\n}\n\nfloat stretch (float t)\n{\n    float tt = sin(pow(t, 2.)*10.);\n    return tt;\n}\n\nfloat bounce (float t)\n{\n    float tt = cos(pow(t, .5)*3.14);\n    return tt;\n}", "image_inputs": [], "common_code": "\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdArc( in vec2 p, in float ta, in float tb, in float ra, float rb )\n{\n    vec2 sca = vec2(sin(ta),cos(ta));\n    vec2 scb = vec2(sin(tb),cos(tb));\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p,scb) : length(p);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n// snippets\n#define fill(sdf) (smoothstep(.001, 0., sdf))\n#define repeat(p,r) (mod(p,r)-r/2.)\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat circle (vec2 p, float size)\n{\n    return length(p)-size;\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGXR1.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[796, 837, 870, 870, 1017], [1019, 1019, 1073, 1073, 1617], [1619, 1619, 1668, 1668, 3983], [4060, 4060, 4082, 4082, 4171], [4173, 4173, 4195, 4195, 4268], [4270, 4270, 4293, 4353, 4393], [4395, 4395, 4420, 4420, 4473], [4475, 4475, 4499, 4499, 4553]], "test": "untested"}
{"id": "ftGXR1", "name": "happy bouncing variation 1", "author": "leon", "description": "shader about boucing animation, space transformation, easing functions, funny shape and colorful vibes.", "tags": ["colorful", "animation"], "likes": 63, "viewed": 3963, "published": 3, "date": "1640132615", "time_retrieved": "2024-07-30T18:40:53.321132", "image_code": "// Fork of \"happy bouncing\" by leon. https://shadertoy.com/view/flyXRh\n// 2021-12-22 00:11:16\n\n// \"happy bouncing\"\n// shader about boucing animation, space transformation, easing functions,\n// funny shape and colorful vibes.\n// by leon denise (2021-12-21)\n// licensed under hippie love conspiracy\n\n// using Inigo Quilez works:\n// arc sdf from https://www.shadertoy.com/view/wl23RK\n// color palette https://iquilezles.org/articles/palettes\n\n// global variable\nvec3 rng;\nfloat bodySize = 0.2;\n\n// shape eyes\nvec2 size = vec2(.07, .05);\nfloat divergence = 0.06;\n\n// easing curves are below\nfloat jump(float);\nfloat walk(float);\nfloat stretch(float);\nfloat bounce(float);\nfloat swing(float);\n\n// list of transformation (fun to tweak)\nvec2 animation(vec2 p, float t)\n{\n    t = fract(t);\n    \n    p.y -= bodySize-0.5;\n    p.y -= jump(t)*0.5;\n    //p.x += walk(t)*0.1;\n    p.x *= stretch(t)*-0.2+1.;\n    \n    // bounce stretch with collision\n    float b = bounce(t)*.2;\n    p.y *= b+1.;\n    p.y += abs(b)*bodySize;\n    \n    return p;\n}\n\nvoid mainImage( out vec4 color, in vec2 pixel )\n{\n    color = vec4(0,0,0,1);\n    \n    // number of friends\n    const float buddies = 3.;\n    for (float i = 0.; i < buddies; ++i)\n    {\n        // usefull to dissociate instances\n        float ii = i/(buddies-1.);\n        float iii = 1.-ii;\n        \n        // translate instances\n        vec2 pp = (pixel-0.5*iResolution.xy)/iResolution.y;\n        pp.x += (ii*2.-1.)*.4;\n        pp.y -= 0.1;\n        \n        // time\n        float t = fract(iTime*.5 + ii * .5);\n        \n        // there will be sdf shapes\n        float shape = 1000.;\n        vec2 p;\n        \n        // there will be layers\n        vec3 col = vec3(0);\n        \n        // color palette\n        // Inigo Quilez (https://iquilezles.org/articles/palettes)\n        vec3 tint = .5+.5*cos(vec3(0.,.3,.6)*6.28+i-length(animation(pp-vec2(0,.1),t))*3.);\n        \n        // body shape\n        float body = circle(animation(pp, t), bodySize);\n        col += tint*fill(body);\n        shape = min(shape, body);\n\n        // eyes positions\n        p = animation(pp, t+0.02);\n        p *= rot(swing(t)*-.5);\n        p -= vec2(.03, bodySize+size.x*.2);\n        p.x = abs(p.x)-divergence;\n        \n        // globe shape\n        float eyes = circle(p, size.x);\n        shape = min(shape, eyes);\n        col = mix(col, tint, fill(eyes));\n        \n        // white eye shape\n        eyes = circle(p, size.y);\n        col = mix(col, vec3(1), fill(eyes));\n        shape = min(shape, eyes);\n        \n        // black dot shape\n        eyes = circle(p, 0.02);\n        col = mix(col, vec3(0), fill(eyes));\n        \n        // smile animation\n        float anim = cos(pow(t, .5)*6.28)*.5+.5;\n        \n        // smile position\n        p = animation(pp, t-0.02);\n        p *= rot(swing(t)*.5);\n        p -= bodySize*vec2(.4, 1.-1.5*anim);\n        \n        // arc (fun to tweak)\n        float smile = mix(0., 1., anim);//+(.5+.5*sin(ii*12.+iTime*12.*ii));\n        float thin = mix(0.1, 0.02, anim);//+0.04*(.5+.5*sin(ii*12.+iTime*22.*ii));\n        float d = sdArc(p,-3.14/2., smile, 0.1, thin);\n        \n        // mouth shape\n        d = d-mix(.01, .04, anim);\n        shape = min(shape, d);\n        col = mix(col, tint*(1.-p.x), fill(d));\n        \n        // black line\n        col = mix(col, tint*.5, fill(d+.05));\n        \n        // add color to frame\n        color.rgb = mix(color.rgb, col, step(shape, 0.));\n    }\n}\n\n// easing curves (not easy to tweak)\n// affect timing of transformations;\n\nfloat jump (float t)\n{\n    t = min(1., t*4.);\n    t = abs(sin(t*3.1415));\n    return pow(sin(t*3.14/2.), 1.9);\n}\n\nfloat walk (float t)\n{\n    t = mix(pow(t,.5), pow(t, 2.0), t);\n    return (cos(t*3.1415*2.));\n}\n\nfloat swing (float t)\n{\n    t = pow(t, .5);\n    //t = t*2.;\n    //t = pow(t, .5);\n    t = sin(t*3.14*2.);\n    return t;\n}\n\nfloat stretch (float t)\n{\n    float tt = sin(pow(t, .2)*10.);\n    return tt;\n}\n\nfloat bounce (float t)\n{\n    float tt = cos(pow(t, .2)*6.38);\n    return tt;\n}", "image_inputs": [], "common_code": "\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdArc( in vec2 p, in float ta, in float tb, in float ra, float rb )\n{\n    vec2 sca = vec2(sin(ta),cos(ta));\n    vec2 scb = vec2(sin(tb),cos(tb));\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p,scb) : length(p);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n// snippets\n#define fill(sdf) (smoothstep(.001, 0., sdf))\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat circle (vec2 p, float size)\n{\n    return length(p)-size;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGXR1.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[689, 730, 763, 763, 1028], [1030, 1030, 1079, 1079, 3443], [3520, 3520, 3542, 3542, 3632], [3634, 3634, 3656, 3656, 3729], [3731, 3731, 3754, 3754, 3852], [3854, 3854, 3879, 3879, 3932], [3934, 3934, 3958, 3958, 4012]], "test": "untested"}
{"id": "NlGSR1", "name": "Fork Worley Noi TestCoder 615", "author": "TestCoder", "description": "A simple Worley noise shader. Full tutorial at ibreakdownshaders.blogspot.com. Original shader from  http://glslsandbox.com/e#23237.0", "tags": ["2d", "noise", "worley", "noob"], "likes": 1, "viewed": 295, "published": 3, "date": "1640129631", "time_retrieved": "2024-07-30T18:40:54.165873", "image_code": "//Calculate the squared length of a vector\nfloat length2(vec2 p){\n    return dot(p,p);\n}\n\n//Generate some noise to scatter points.\nfloat noise(vec2 p){\n\treturn fract(sin(fract(sin(p.x) * (43.13311)) + p.y) * 31.0011);\n}\n\nfloat worley(vec2 p) {\n    //Set our distance to infinity\n\tfloat d = 1e30;\n    //For the 9 surrounding grid points\n\tfor (int xo = -1; xo <= 1; ++xo) {\n\t\tfor (int yo = -1; yo <= 1; ++yo) {\n            //Floor our vec2 and add an offset to create our point\n\t\t\tvec2 tp = floor(p) + vec2(xo, yo);\n            //Calculate the minimum distance for this grid point\n            //Mix in the noise value too!\n\t\t\td = min(d, length2(p - tp - noise(tp)));\n\t\t}\n\t}\n\treturn 100.0*exp(-4.0*abs(.5*d - 1.0));\n}\n\nfloat fworley(vec2 p) {\n    //Stack noise layers \n\treturn sqrt(sqrt(sqrt(\n\t\tworley(p*5.0 + 0.25*iTime) *\n\t\tsqrt(worley(p * 50.0 + 0.12 + -0.1*iTime)) *\n\t\tsqrt(sqrt(worley(p * -10.0 + 0.03*iTime))))));\n}\n      \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //Calculate an intensity\n    float t = fworley(uv * iResolution.xy / 500.0);\n    //Add some gradient\n    t*=exp(-length2(abs(1.*uv - 1.0)));\t\n    //Make it blue!\n    fragColor = vec4(t * vec3(0.1, 1.1*t, pow(t, 0.5-t)), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGSR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 43, 65, 65, 88], [90, 131, 151, 151, 219], [221, 221, 243, 278, 714], [716, 716, 739, 765, 918], [926, 926, 983, 983, 1257]], "test": "untested"}
{"id": "flyXRh", "name": "happy bouncing", "author": "leon", "description": "shader about boucing animation, space transformation, easing functions, funny shape and colorful vibes.", "tags": ["colorful", "animation"], "likes": 15, "viewed": 436, "published": 3, "date": "1640126946", "time_retrieved": "2024-07-30T18:40:54.929831", "image_code": "// \"happy bouncing\"\n// shader about boucing animation, space transformation, easing functions,\n// funny shape and colorful vibes.\n// by leon denise (2021-12-21)\n// licensed under hippie love conspiracy\n\n// using Inigo Quilez works:\n// arc sdf from https://www.shadertoy.com/view/wl23RK\n// color palette https://iquilezles.org/articles/palettes\n\n// global variable\nfloat bodySize = 0.2;\n\n// shape eyes\nvec2 size = vec2(.07, .05);\nfloat divergence = 0.06;\n\n// easing curves are below\nfloat jump(float);\nfloat walk(float);\nfloat stretch(float);\nfloat bounce(float);\nfloat swing(float);\n\n// list of transformation (fun to tweak)\nvec2 animation(vec2 p, float t)\n{\n    t = fract(t);\n    \n    p.y -= bodySize-0.5;\n    p.y -= jump(t)*0.5;\n    p.x += walk(t)*0.1;\n    p.x *= stretch(t)*-0.2+1.;\n    \n    // bounce stretch with collision\n    float b = bounce(t)*-0.2;\n    p.y *= b+1.;\n    p.y += abs(b)*bodySize;\n    \n    return p;\n}\n\nvoid mainImage( out vec4 color, in vec2 pixel )\n{\n    color = vec4(0,0,0,1);\n    \n    // number of friends\n    const float buddies = 5.;\n    for (float i = 0.; i < buddies; ++i)\n    {\n        // usefull to dissociate instances\n        float ii = i/(buddies-1.);\n        float iii = 1.-ii;\n        \n        // translate instances\n        vec2 pp = (pixel-0.5*iResolution.xy)/iResolution.y;\n        pp.x += (ii*2.-1.)*.4;\n        \n        // time\n        float t = fract(iTime*.5 + ii * .5);\n        \n        // there will be sdf shapes\n        float shape = 1000.;\n        vec2 p;\n        \n        // there will be layers\n        vec3 col = vec3(0);\n        \n        // color palette\n        // Inigo Quilez (https://iquilezles.org/articles/palettes)\n        vec3 tint = .5+.5*cos(vec3(0.,.3,.6)*6.28+i-length(animation(pp,t))*3.);\n        \n        // body shape\n        float body = circle(animation(pp, t), bodySize);\n        col += tint*fill(body);\n        shape = min(shape, body);\n\n        // eyes positions\n        p = animation(pp, t+0.02);\n        p *= rot(swing(t)*-.5);\n        p -= vec2(.03, bodySize+size.x*.2);\n        p.x = abs(p.x)-divergence;\n        \n        // globe shape\n        float eyes = circle(p, size.x);\n        shape = min(shape, eyes);\n        col = mix(col, tint, fill(eyes));\n        \n        // white eye shape\n        eyes = circle(p, size.y);\n        col = mix(col, vec3(1), fill(eyes));\n        shape = min(shape, eyes);\n        \n        // black dot shape\n        eyes = circle(p, 0.02);\n        col = mix(col, vec3(0), fill(eyes));\n        \n        // smile animation\n        float anim = cos(pow(t, .5)*6.28)*.5+.5;\n        \n        // smile position\n        p = animation(pp, t-0.02);\n        p *= rot(swing(t)*-.9);\n        p -= bodySize*vec2(.5, .5+anim*.5);\n        \n        // arc (fun to tweak)\n        float smile = mix(0., 1., anim);//+(.5+.5*sin(ii*12.+iTime*12.*ii));\n        float thin = mix(0.1, 0.02, anim);//+0.04*(.5+.5*sin(ii*12.+iTime*22.*ii));\n        float d = sdArc(p,-3.14/2., smile, 0.1, thin);\n        \n        // mouth shape\n        d = d-mix(.01, .04, anim);\n        shape = min(shape, d);\n        col = mix(col, tint*1.2, fill(d));\n        \n        // black line\n        col = mix(col, tint*.5, fill(d+.05));\n        \n        // add color to frame\n        color.rgb = mix(color.rgb, col, step(shape, 0.));\n    }\n}\n\n// easing curves (not easy to tweak)\n// affect timing of transformations;\n\nfloat jump (float t)\n{\n    t = min(1., t*4.);\n    t = abs(sin(t*3.1415));\n    return pow(sin(t*3.14/2.), 1.9);\n}\n\nfloat walk (float t)\n{\n    t = mix(pow(t,.5), pow(t, 2.0), t);\n    return (cos(t*3.1415*2.));\n}\n\nfloat swing (float t)\n{\n    t = t*2.;\n    t = pow(t, .5);\n    t = sin(t*3.14*2.);\n    return t;\n}\n\nfloat stretch (float t)\n{\n    float tt = cos(pow(t, .2)*30.);\n    return tt;\n}\n\nfloat bounce (float t)\n{\n    float tt = cos(pow(t, .2)*10.);\n    return tt;\n}", "image_inputs": [], "common_code": "\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdArc( in vec2 p, in float ta, in float tb, in float ra, float rb )\n{\n    vec2 sca = vec2(sin(ta),cos(ta));\n    vec2 scb = vec2(sin(tb),cos(tb));\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p,scb) : length(p);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n// snippets\n#define fill(sdf) (smoothstep(.001, 0., sdf))\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat circle (vec2 p, float size)\n{\n    return length(p)-size;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyXRh.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[584, 625, 658, 658, 923], [925, 925, 974, 974, 3301], [3378, 3378, 3400, 3400, 3490], [3492, 3492, 3514, 3514, 3587], [3589, 3589, 3612, 3612, 3686], [3688, 3688, 3713, 3713, 3766], [3768, 3768, 3792, 3792, 3845]], "test": "untested"}
{"id": "NlyXRh", "name": "basic climb ladder", "author": "jorge2017a2", "description": "basic climb ladder", "tags": ["basic", "ladder", "climb"], "likes": 6, "viewed": 219, "published": 3, "date": "1640120139", "time_retrieved": "2024-07-30T18:40:55.691794", "image_code": "///------------image\n//por jorge2017a1-\n\n//referencia \n///https://www.shadertoy.com/view/ssdGWl...plento\n//https://www.shadertoy.com/view/MtffWs....iq\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nvec3 EscaleraTorre(vec3 p)\n{   vec3 res= vec3(9999.0, -1.0,-1.0);\n    float d1, d=99999.0;\n    int y;\n    float AnchoTot=2.5;\n    float AltoTot=10.0;\n    float NumEs=5.0;\n    float AnchoEs=AnchoTot/NumEs;\n    float AltoEs=AltoTot/NumEs;\n    float AltoEsNew;\n    \n    for(int i=1;i<=int(NumEs);i++ )\n     {   \n      float posx=float(i)*AnchoEs*2.0;\n      float posy=-float(i)*AltoEs*2.0;\n      AltoEsNew=AltoTot-( float(i)- 1.0)*AltoEs ;\n      float d1=sdBox(p-vec3(posx,posy/2.0-AltoEsNew,0.0), vec3(AnchoEs,AltoEs+AltoEsNew,2.0) );\n      d=min(d,d1);\n     }   \n    res =opU3(res, vec3(d,16,-1.0)); //inf\n    return res;\n}\n\nvec2 stairpos(float x)\n{ return vec2(x-0.6, -x*0.6 + .2);  }\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n    \n\tfloat planeDist1 = p.y+5.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,1.0,-1.0)); //inf\n    \n   vec3 et= EscaleraTorre(p.yxz-vec3(-5.5,6.0,0.0));\n   res =opU3(res, et);\n    \n    float t=mod(iTime,6.0);\n    float posyfl=floor(t);\n    float posyfr=fract(t);\n    \n   \n    float movy=posyfl;\n    float movx=-posyfl*2.0;\n    float sd1= sdSphere(p-vec3(7.0+movx,-4.5+abs(movy),-1.0),0.5 );\n    res =opU3(res, vec3(sd1,1.0,-1.0)); \n    //------\n    float mult=0.5;\n    t=mod(iTime*mult,5.0);\n    float x=t;\n    \n    float h = fract(x)-0.5;\n    float s = -sign(h);\n    float th = 1.0- 2.0*abs(h);          // also 1.0 + 2.0*h*s\n    float pxht = x + h*th;\n   \n    float movy2=pxht;\n    float movx2=-x*2.0;\n    float sd2= sdSphere(p-vec3(7.0+movx2,-4.5+movy2,-0.5),0.5 );\n    res =opU3(res, vec3(sd2,2.0,-1.0)); \n    \n    //------------\n    \n    mult=1.0;\n    t=mod(iTime*mult,8.0);\n     x=-t;\n     vec2 cb = stairpos(x - 1.);\n     cb.y += 0.5*abs(cos(t*2.0));\n     float sd3= sdSphere(p-vec3(8.5+cb.x,-5.5+cb.y,0.5),0.5 );\n     res =opU3(res, vec3(sd3,3.0,-1.0)); \n     \n     \n     /*\n     //por  pyBlob\n     for (t=0.;t<8.;t+=0.1) // shows everything at once\n    {\n        float x=-t;\n        vec2 cb = stairpos(x - 1.);\n        cb.y += 0.5 * abs(cos(t*2.0));\n        float sd3 = sdSphere(p - vec3(8.5 + cb.x, -5.5 + cb.y, 0.5), 0.4);\n        res = opU3(res, vec3(sd3,3.0,-1.0)); \n    }\n     */\n    //----------\n     \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 nor = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    nor= normalize(nor);\n    return nor;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n        {mObj.hitbln = true; minDist = abs(t); break;}\n        \n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        \n        t += dS.x;\n        marchCount++;\n    }\n        \n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\nfloat FakeSoftShadow(float result, vec3 LightPos,vec3 point,vec3 normal)\n{\n    vec3 shadowOffset = normal * 0.2 ;\n    \n    int epoch = 5;\n    \n    float delta = result/float(epoch);\n    float lightOffset = 0.2;\n    \n    for(int i = 0; i<epoch; i++)\n    {\n        vec3 tmp = LightPos +vec3(0,0,i)*lightOffset;\n        //if(RayMarching(point + shadowOffset,normalize(tmp-point)) < length(tmp-point))\n        float dis=RayMarch(point + shadowOffset,normalize(tmp-point), int( MAX_DIST));\n        if (dis< length(tmp-point))\n        {\n            result -= delta;\n        }\n    }\n    return result;\n}\n\nfloat specularBRDF(float roughness, vec3 n, vec3 v, vec3 l)\n{\n    vec3 h = normalize(v + l);\n    float NoV = abs(dot(n, v)) + .1;\n    float NoL = clamp(dot(n, l), 0., 1.);\n    float NoH = clamp(dot(n, h), 0., 1.);\n    float D = (2. + 1. / roughness) * pow(max(1. - NoH * NoH, .0078125), 1. / roughness * .5) / (2. * PI);\n    return D / (4. * (NoL + NoV - NoL * NoV));\n}\n\n\n//----------------------------------------------------\n//https://www.shadertoy.com/view/ft3SRr\nvec3 Shading(vec3 LightPos, vec3 pos, vec3 ro,vec3 baseCol)\n{\n    //ro=eye\n    vec3 L = normalize(LightPos - pos);\n    vec3 V = normalize(ro - pos);\n    vec3 N = GetNormal(pos);\n    vec3 H = normalize(L+V);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float Ambient = 0.1;\n       \n    float result = max(dot(L,N),0.0)*0.5 + pow(max(dot(H,N),0.0),20.)*0.9;\n    result = FakeSoftShadow(result, LightPos,pos,N);\n    \n    float roughness=4.25;\n    vec3 specol=specularBRDF(roughness, N, V, L)*baseCol;\n    \n    Material mate;\n    mate.baseCol = vec3(.38, .02, .02);\n    mate.specularCol = vec3(0.56 ,.64, .64);\n    \n    return ((result+Ambient)*baseCol+specol*mate.specularCol)/2.0;\n        \n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    vec3 sha= Shading(plight_pos,p,ro,colobj);\n    result =  sha;\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{ float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2)*light_color2;\n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n   return col;\n}\n\n\n// Tone mapping\n// See: http://filmicgames.com/archives/75\nvec3 Uncharted2ToneMapping(vec3 color)\n{   float gamma = 2.2;\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n\tfloat exposure = 0.012;\n\tcolor *= exposure;\n\tcolor = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n\tfloat white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n\tcolor /= white;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n\n    light_pos1= vec3(10.0, 10.0, -10.0 );    light_color1=vec3(1.0);\n \tlight_pos2= vec3(-10.0, 30.0, -10.0 ); light_color2 = vec3(1.0); \n\n   float posz=0.0;\n   vec3 ro=vec3(-1.0,1.0,-16.5+posz);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    vec3 col= Render( ro,  rd);\n    col+=Uncharted2ToneMapping(col);   \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//--------------common\nstruct Material\n{\n    vec3 baseCol;\n    vec3 specularCol;\n    float roughness;\n};\n\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlyXRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[595, 595, 631, 631, 652], [653, 653, 685, 685, 769], [771, 815, 862, 862, 889], [890, 890, 933, 933, 960], [961, 961, 1009, 1009, 1037], [1663, 1663, 1687, 1687, 1723], [1725, 1765, 1790, 1790, 3276], [3278, 3278, 3302, 3302, 3482], [3484, 3484, 3533, 3533, 4223], [4226, 4226, 4300, 4300, 4822], [4824, 4824, 4885, 4885, 5193], [5196, 5291, 5352, 5365, 5984], [5986, 5986, 6066, 6066, 6193], [6195, 6195, 6227, 6227, 6422], [6424, 6424, 6517, 6517, 6688], [6691, 6691, 6722, 6722, 7342], [7345, 7404, 7444, 7444, 7880], [7883, 7932, 7989, 7989, 8514]], "test": "untested"}
{"id": "7lKXzz", "name": "depth of field focus study 33", "author": "morisil", "description": "Testing something out", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 23, "viewed": 1116, "published": 3, "date": "1640112000", "time_retrieved": "2024-07-30T18:40:56.451762", "image_code": "// Fork of \"depth of field focus study 32\" by morisil. https://shadertoy.com/view/NlKXzz\n// 2021-12-21 18:39:46\n\n// Fork of \"depth of field focus study 2\" by morisil. https://shadertoy.com/view/flc3zX\n// 2021-12-21 13:06:50\n\n// Fork of \"depth of field focus study\" by morisil. https://shadertoy.com/view/sld3zB\n// 2021-11-08 19:52:49\n\nconst float SHAPE_SIZE = .6;\nconst float CHROMATIC_ABBERATION = .3;\nconst float ITERATIONS = 7.;\nconst float INITIAL_LUMA = .5;\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y);\n    float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, dist);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n\n    st = vec2((cos(st.x * cos(iTime * .1) * 5.) * .5 + .5),  (cos(st.y * cos(iTime * .1) * 5.) * .5 + .5));\n    st *= sin(iTime * .1) * 1.0;\n    float modScale = 1.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    float blur = .2;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .5), cos(iTime * .3));\n        //center += pow(length(center), 1.);\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur),\n            getColorComponent(center, modScale, blur),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur)        \n        ) * luma;\n        st *= 1.3;\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        if (color == vec3(1)) break;\n        luma *= .63;\n        blur *= .63;\n    }\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKXzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[464, 464, 535, 535, 771], [773, 773, 828, 828, 1817]], "test": "untested"}
{"id": "Nl3SDl", "name": "Saturnish planet", "author": "z0rg", "description": "My most polished planet shader so far, really happy to show it to you, have fun observing this saturn inspired planet !", "tags": ["space", "planet", "stars", "saturn", "asteroid", "gas"], "likes": 40, "viewed": 983, "published": 3, "date": "1640102816", "time_retrieved": "2024-07-30T18:40:57.221703", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\n// Chromatic abberation\nvec3 rdr(vec2 uv)\n{\n  float dist = .002;//0.5*sat(pow(length(uv)-.2,2.));\n  vec2 dir = normalize(vec2(1.));\n  vec3 col = vec3(0.);\n  col.r = texture(iChannel1, uv+dir*dist).r;\n  col.g = texture(iChannel1, uv).g;\n  col.b = texture(iChannel1, uv-dir*dist).b;\n  return col;\n}\n// A JJ Abrams likish flare\nvec3 chromaFlare(vec2 uv, vec2 ouv, float sz, float id)\n{\n    vec3 col = vec3(0.);\n    col = texture(iChannel0, vec2(1.)+uv*vec2(-1.)*id).xyz;\n    float shape = max(length(ouv)-.5, -(length(ouv)-.15));\n    col *= vec3(1.)*(1.-sat(shape*1.));\n    return pow(col,vec3(3.))*.5*vec3(.1,.2,.7);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    \n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n     \n    vec3 rgb = rdr(uv)+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb += chromaFlare(uv, cuv, 0.01, .75)*vec3(.1,0.,1.)*3.;\n    rgb += chromaFlare(uv, cuv, 0.01, .95)*vec3(1.,0.,0.);\n    rgb += chromaFlare(uv, cuv, 0.01, 1.)*vec3(0.,1.,0.);\n    rgb += chromaFlare(uv, cuv, 0.01, 1.05)*vec3(0.,0.,1.);\n\n    seed+= texture(iChannel2, .75*uv+vec2(-0.1,-.2)).x;\n    seed += iTime;\n    \n    // calculating kind of \"luminance\" this way is more reliable than fixed points on the picture\n    float avglight = 0.;\n    for (int i = 0; i < 16; ++i)\n    {\n        avglight += length(texture(iChannel0, vec2(rand(), rand())).xyz);\n    }\n    avglight /= 16.;\n    \n    // Kind of cheap pupillary light reflex\n    rgb *= mix(1.5,.5, pow(avglight,1.));\n    \n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\n\nvec3 lpos; // Sun position\nfloat _time;\n\nfloat mapring(vec3 p)\n{\n    p.xy *= r2d(.3);\n    float ring = max(max(length(p.xz)-5., -(length(p.xz)-3.)), abs(p.y)-.001);\n    return ring;\n}\n\nvec2 map(vec3 p) // I know the vec2 is useless here but it's legacy :p\n{\n    vec2 acc = vec2(10000.,-1.);\n    \n    float planet = length(p)-2.;\n    acc = _min(acc, vec2(planet, 0.));\n      \n    return acc;\n}\n\nvec3 accCol;\nvec2 tracering(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        float res = mapring(p);\n        if (res < 0.01)\n            return vec2(res, distance(p, ro));\n        p+= rd*res;\n    }\n    return vec2(-1.);\n}\n\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    accCol = vec3(0.);\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        accCol += (1.-sat(res.x/.521))\n        *vec3(0.639,0.545,0.384)\n        *.02\n        *sat(sat(dot(normalize(p-lpos), normalize(p)))+.05);\n        p+= rd*res.x*.25;\n    }\n    return vec3(-1.);\n}\n\nvec3 getNormal(float d, vec3 p)\n{\n    vec2 e = vec2(0.01,0.);\n    return normalize(vec3(d) - vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 getEnv(vec3 rd)\n{\n    rd.xy *= r2d(.5);\n    vec3 col = vec3(0.);\n    col += 1.5*pow(texture(iChannel0, 2.*vec2(atan(rd.z, rd.x), acos(rd.y))).x,20.);\n    vec2 uvSky = 2.*vec2(atan(rd.z, rd.x), acos(rd.y));\n    vec3 rgblact = mix(vec3(0.984,0.639,0.455), vec3(0.984,0.639,0.455).zyx, \n    pow(texture(iChannel0,uvSky*.1).x,.76));\n    float visi = sat(sat((abs(rd.y*20.)-.1-0.3 \n    *texture(iChannel2, uvSky).x)*2.)+.4);\n    col += visi*1.3*rgblact*pow(texture(iChannel0, uvSky).x,2.)*(1.-sat(5.*abs(dot(rd, vec3(0.,1.,0.)))));\n    col = pow(col, vec3(1.5))*.6;\n    return col*.5;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    float d = mix(3.,15.,sat(sin(_time*.33)*.5+.5));\n    float t = _time*.1;\n    vec3 ro = vec3(sin(t)*d,sin(_time*.2)*5.,cos(t)*d);\n    vec3 ta = vec3(0.,sin(_time+PI*.5),0.);\n    vec3 rd = normalize(ta-ro);\n    rd = getCam(rd, uv);\n    \n    float raydist = 1000.;\n    vec2 resring = tracering(ro, rd, 100);\n\n    vec3 res = trace(ro, rd, 64);\n    if (res.y > 0.)\n    {\n        raydist = res.y;\n        vec3 p = ro + rd*res.y;\n        vec3 n = getNormal(res.x, p);\n        \n        col = n*.5+.5;\n        vec3 ldir = p-lpos;\n        vec3 h = normalize(rd+ldir);\n        float ndotl = dot(normalize(ldir), n);\n        if (res.z == 0.)\n        {\n            vec3 prd = n;\n            vec2 uvplanet = vec2((atan(prd.z, prd.x)-_time*.1)*2.*1.575, acos(prd.y));\n            float clouds = texture(iChannel2, uvplanet*.25*vec2(.2,1.)).x;\n            clouds = pow(clouds, mix(.5, .025, pow(sat(ndotl),.01)));\n            col = vec3(0.137,0.125,0.063)*.75*(1.-sat(-ndotl));\n            col += vec3(0.620,0.592,0.420)*pow(sat(ndotl),.3);\n            col *= clouds;\n            vec2 uvpole = vec2(atan(p.z, p.x), abs(p.y)-1.95);\n            vec3 storm = texture(iChannel2, uvpole*vec2(.05,1.)).xyz;\n            col = mix(col, col*.5+storm*vec3(0.424,0.718,0.996)*2., sat((-max(uvpole.y,-uvpole.y-.1)-0.02*sin(_time+uvpole.x*5.))*20.));\n        }\n    }\n    else\n    {\n        col = getEnv(rd);\n    }\n        col += accCol;\n    if (raydist > 30.)\n        col += 1.*vec3(1.000,0.867,0.502)*pow(sat(dot(rd, -normalize(lpos-ro))),100.);\n  \n    if (resring.y > 0. && resring.y < raydist)\n    {\n        vec3 pring = ro+rd*resring.y;\n        float an = atan(pring.z, pring.x);\n        float ring = texture(iChannel2, vec2(abs(an*.01), length(pring.xz))).x;\n        ring += texture(iChannel2, pring.xz*1.*vec2(2.,1.)).x*.25;\n        ring *= mix(0.25,1.,sat((length(pring.xz)-3.5)*400.));\n        ring *= mix(0.125,1.,sat((abs(length(pring.xz)-4.2)-.1)*400.));\n        vec3 resshadow = trace(pring, -normalize((lpos+2.*(vec3(rand(), rand(), rand())-.5))-pring), 64);\n        col *= sat(ring+.5);\n        col = mix(col, vec3(.8)*mix(.2,1.,float(resshadow.y < 0.)), pow(ring,.5)*.6);\n        col *= mix(0.,1.,1.-sat((length(pring)-4.9)*3.));\n    }\n  col = sat(col);\n  return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lpos = vec3(100.,-15.,0.);\n    \n    _time = iTime*.35;\n    vec2 ouv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n        seed+= texture(iChannel0, .75*ouv+vec2(-0.1,-.2)).x;\n    seed += iTime;\n    uv *= r2d(sin(_time*.125)*.25);\n    vec2 off = vec2(1., -1.)/(iResolution.x*1.75);\n    \n    vec3 col = rdr(uv+off*(vec2(rand(), rand())-.5)*2.); // Single sample AA\n\n    col += .1*rand(); // film grain\n    \n    col = pow(col, vec3(1.2));\n    \n    col = mix(col, texture(iChannel1, ouv).xyz, .8); // \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define GLOW_SAMPLES 80\n#define GLOW_DISTANCE 0.1\n#define GLOW_POW .8\n#define GLOW_OPACITY .6\n#define PI 3.14159265\n#define sat(a) clamp(a, 0., 1.)\n\n// Stolen from 0b5vr here https://www.shadertoy.com/view/ss3SD8\nfloat hash11(float p)\n{\n    return (fract(sin((p)*114.514)*1919.810));\n}\n\nmat2 r2d(float a){float cosa = cos(a);float sina = sin(a);return mat2(cosa,sina,-sina,cosa);}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(uv.x*r+-uv.y*u));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3SDl.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[409, 409, 423, 423, 462], [463, 487, 506, 506, 759], [760, 788, 845, 845, 1079], [1080, 1080, 1137, 1137, 2396]], "test": "untested"}
{"id": "WtscWr", "name": "Voxel City PathTraced", "author": "ShnitzelKiller", "description": "shitty city", "tags": ["raytracing", "voxels", "pathtracing", "city"], "likes": 8, "viewed": 302, "published": 3, "date": "1640093135", "time_retrieved": "2024-07-30T18:40:57.971698", "image_code": "#define PI 3.141593\n#define MAX_VOXELS 100\n#define SECONDARY_STEPS 10\n#define SAMPLES_PER_FRAME 30\n#define BOUNCES 3\n#define FDIST 0.5\n#define ATMOSPHERE_TRANSMISSION 0.99\n#define SCATTER_FACTOR 0.5\n#define EPS 0.01\n\n#define PERIOD 11.\n#define BUILDINGRAD 4.\n\nstruct Hit {\n    float t;\n    int mat;\n    vec3 n;\n    vec3 id;\n};\n    \nfloat noise2d(in vec2 uv) {\n    return fract(814.*sin(uv.x*15829.+uv.y*874.));\n}\n\nuint seed;\nuint pcg_hash()\n{\n    seed = seed * 747796405u + 2891336453u;\n    uint word = ((seed >> ((seed >> 28u) + 4u)) ^ seed) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\nfloat GetRandom()\n{\n    return float(pcg_hash()) / 4294967296.0;\n}\n\nvec2 GetRandom2(){return vec2(GetRandom(), GetRandom());}\n\nvec3 randnorm() {\n    vec2 utheta = GetRandom2() * 2. - 1.;\n    utheta.y *= PI;\n    float rho = sqrt(1.-utheta.x * utheta.x);\n    return vec3(cos(utheta.y)*rho, sin(utheta.y)*rho, utheta.x);\n}\n\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\n    return vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\n//occupancy function + material\nfloat occupancy(in vec3 id, out int mat) {\n    vec2 block = floor(id.xy/PERIOD+0.5);\n    vec3 modid = vec3(mod(id.xy+0.5*PERIOD, PERIOD)-0.5*PERIOD, id.z);\n    float randval1 = noise2d(block);\n    float randval2 = noise2d(vec2(block.y, randval1));\n    \n    vec2 mindist = vec2(max(modid.z-1., PERIOD*0.5 - length(modid.xy)), 3.); //base\n    vec2 buildings = vec2(max(length(modid.xy)-BUILDINGRAD, -30.+modid.z-100.*randval2), 2.);\n    buildings.x = max(buildings.x, -length(vec2(mix(modid.x, modid.y, mod(floor(modid.z/4.), 2.0)), mod(modid.z, 4.)-2.)) + 2.);\n    mindist = condmin(mindist, buildings);\n    mindist = mix(mindist, vec2(modid.z, 1.), step(0.3, randval1));\n    float occ = step(mindist.x, 0.5);\n    mat = int(occ * round(mindist.y));\n    return occ;\n}\n\nHit voxtrace(in vec3 ro, in vec3 rd, int iters) {\n    Hit h;\n    h.mat = 0;\n    h.t = 0.;\n    // box marching with fb39ca4's DDA\n    h.id = floor(ro);        \n    vec3 ri = 1.0/rd;\n    vec3 rs = sign(rd);\n    vec3 dis = (h.id-ro + 0.5 + rs*0.5) * ri;\n    vec3 mm = vec3(0.0);\n    for (int i=0; i<iters; i++) {\n        mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n\t\tdis += mm * rs * ri;\n        h.id += mm * rs;\n        if (occupancy(h.id, h.mat) > 0.5) {\n            break;\n    \t}\n    }\n    \n    h.n = -mm*rs;\n\t\n\tvec3 mini = (h.id-ro + 0.5 - 0.5*vec3(rs))*ri;\n\th.t = max ( mini.x, max ( mini.y, mini.z ) );\n\t     \n    return h;\n}\n\nvec3 bgcol(in vec3 rd) {\n    return mix(vec3(0., 0., 1.), vec3(0.6, 0.8, 1.), 1.-pow(abs(rd.z), 2.));\n}\n\nvec3 pathtrace(in vec3 eye, in vec3 rd) {\n    vec3 col = vec3(0.);\n    vec3 thru = vec3(1.);\n    for (int i=0; i<BOUNCES; i++) {\n        Hit h = voxtrace(eye, rd, i == 0 ? MAX_VOXELS : SECONDARY_STEPS);\n        //thru *= pow(ATMOSPHERE_TRANSMISSION, h.t);\n        if (h.mat == 0) {\n            col += thru * bgcol(rd);\n            break;\n        }\n        eye = eye + h.t * rd;\n        vec3 nr = randnorm();\n        vec3 nref = reflect(rd, h.n);\n\t\tnr = mix(nref, normalize(h.n + nr), SCATTER_FACTOR);\n        vec3 albedo = vec3(1.);\n        vec3 emissive = vec3(0.);\n        if (h.mat == 1) {\n            albedo = vec3(0.3, 0.7, 0.9);\n        } else if (h.mat == 2) {\n            albedo = vec3(0.6, 0.9, 0.5);\n        } else if (h.mat == 3) {\n            albedo = vec3(1.);\n            //emissive = vec3(0.5, 0.4, 0.2);\n        }\n        \n        col += thru * emissive;\n        thru *= albedo;\n        \n        float maxthru = max(thru.x, max(thru.y, thru.z));\n        if (GetRandom() > maxthru) {\n            break;\n        }\n        thru *= 1.0/maxthru;\n        \n        rd = nr;\n        eye += EPS * rd;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    float mouseY = iMouse.y < 1. ? 0. : (0.5-iMouse.y/iResolution.y) * PI;\n    float mouseX = iMouse.x < 1. ? iTime*0.25 : -(iMouse.x/iResolution.x) * 2. * PI;\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n\tvec3 eye = vec3(PERIOD*0.5, iTime * 9., 6.1);\n    vec3 w = vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), -sin(mouseY));\n    vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(FDIST*w + uv.x*u + uv.y*v);\n    \n    vec3 col = vec3(0.);\n    float weight = 0.0;\n    for (int i=0; i<SAMPLES_PER_FRAME; i++) {\n        float newweight = weight + 1.0;\n        vec3 newcol = pathtrace(eye, rd);\n        col = (col * weight + newcol)/newweight;\n        weight = newweight;\n    }\n    \n    //dummy visualization\n    fragColor = vec4(pow(col, vec3(0.45)), 1.0);\n    //fragColor = vec4((sin(h.t*10.)*.1+.5) * float(h.mat) * (h.n*.5 +.5), 1.);\n    //fragColor = vec4(fract(h.id/10.), 1.);\n    //fragColor = vec4(vec3(h.mat)/3., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtscWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[332, 332, 359, 359, 412], [425, 425, 442, 442, 591], [593, 593, 612, 612, 659], [661, 661, 679, 679, 718], [720, 720, 737, 737, 912], [915, 915, 953, 953, 1024], [1026, 1058, 1100, 1100, 1823], [1825, 1825, 1874, 1874, 2463], [2465, 2465, 2489, 2489, 2568], [2570, 2570, 2611, 2611, 3701], [3703, 3703, 3760, 3760, 4883]], "test": "untested"}
{"id": "NlKXzz", "name": "depth of field focus study 32", "author": "morisil", "description": "Testing something out", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 6, "viewed": 257, "published": 3, "date": "1640092562", "time_retrieved": "2024-07-30T18:40:58.722690", "image_code": "// Fork of \"depth of field focus study 2\" by morisil. https://shadertoy.com/view/flc3zX\n// 2021-12-21 13:06:50\n\n// Fork of \"depth of field focus study\" by morisil. https://shadertoy.com/view/sld3zB\n// 2021-11-08 19:52:49\n\nconst float SHAPE_SIZE = .6;\nconst float CHROMATIC_ABBERATION = .3;\nconst float ITERATIONS = 7.;\nconst float INITIAL_LUMA = .5;\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y);\n    float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, dist);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n\n    st = vec2((cos(st.x * 3.) * .5 + .5),  (cos(st.y * 3.) * .5 + .5));\n    st *= sin(iTime * .1) * 2.0;\n    float modScale = 1.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    float blur = .2;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .5), cos(iTime * .3));\n        //center += pow(length(center), 1.);\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur),\n            getColorComponent(center, modScale, blur),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur)        \n        ) * luma;\n        st *= 1.3;\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        if (color == vec3(1)) break;\n        luma *= .63;\n        blur *= .63;\n    }\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKXzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[351, 351, 422, 422, 658], [660, 660, 715, 715, 1668]], "test": "untested"}
{"id": "Nt3SzX", "name": "Coupled Springs & exp(matrix)", "author": "oneshade", "description": "Implementing the matrix exponential in GLSL.", "tags": ["physics", "springs", "coupled"], "likes": 17, "viewed": 197, "published": 3, "date": "1640069842", "time_retrieved": "2024-07-30T18:40:59.469693", "image_code": "// General coupled springs system implemented in python:\n// https://replit.com/@hathnoname/General-Coupled-Springs-System\n\n// See http://eprints.ma.man.ac.uk/634/1/high05e.pdf\n// Once again, I got bitten by GLSL's backwards matrix multiplication\nmat4 expm(in mat4 A) {\n    vec4 norm = abs(A[0]) + abs(A[1]) + abs(A[2]) + abs(A[3]);\n    float L1 = max(norm.x, max(norm.y, max(norm.z, norm.w)));\n    float squarings = ceil(log2(max(1.0, L1 / 3.92572478313866)));\n    A /= exp2(squarings);\n\n    mat4 A2 = A * A;\n    mat4 A4 = A2 * A2;\n    mat4 A6 = A4 * A2;\n    mat4 U = (A6 + 1512.0 * A4 + 277200.0 * A2 + 8648640.0 * mat4(1.0)) * A;\n    mat4 V = 56.0 * A6 + 25200.0 * A4 + 1995840.0 * A2 + 17297280.0 * mat4(1.0);\n\n    mat4 P =  U + V;\n    mat4 Q = -U + V;\n    mat4 R = P * inverse(Q);\n\n    for (float i=0.0; i < squarings; i++) R *= R;\n \n    return R;\n}\n\nvec4 state(in float t, in vec4 x0) {\n    mat4 A = mat4(\n                    0.0,      1.0,             0.0,      0.0,\n        -(k1 + k2) / m1, -u1 / m1,         k2 / m1,      0.0,\n                    0.0,      0.0,             0.0,      1.0,\n                k2 / m2,      0.0, -(k2 + k3) / m2, -u2 / m2\n    );\n\n    vec4 B = vec4(\n        0.0, (k1 * (f1 + l1) - k2 * l2) / m1,\n        0.0, (k2 * l2 + k3 * (f2 - l3)) / m2\n    );\n\n    //vec4 C = B * inverse(A);\n    float det = A[1][2] * A[3][0] - A[1][0] * A[3][2];\n    vec4 C = vec4((A[1][2] * B[3] - A[3][2] * B[1]) / det, 0.0,\n                  (A[3][0] * B[1] - A[1][0] * B[3]) / det, 0.0);\n\n    return (x0 + C) * expm(A * t) - C;\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 12.0;\n    vec3 color = 1.0 - texture(iChannel1, fragCoord / iResolution.xy).rgb;\n    float unit = 24.0 / iResolution.y;\n\n    // Calculate the current state of the system\n    vec4 sys = state(3.0 * iTime, vec4(-2.0, 0.0, 4.0, 0.0));\n\n    // Draw fixtures\n    drawSDF(sdDisk(uv, vec2(f1, 0.0), 0.25), vec3(0.0));\n    drawSDF(sdDisk(uv, vec2(f2, 0.0), 0.25), vec3(0.0));\n\n    // Draw the springs\n    float m1Left = sys.x - r1, m1Right = sys.x + r1;\n    float m2Left = sys.z - r2, m2Right = sys.z + r2;\n\n    if (min(f1, m1Left) < uv.x && uv.x < max(f1, m1Left)) {\n        drawSDF(udTriangleWave(uv - vec2(f1, 0.0), 8.0 / (m1Left - f1), 1.5), vec3(0.0));\n    }\n\n    if (min(m1Right, m2Left) < uv.x && uv.x < max(m1Right, m2Left)) {\n        drawSDF(udTriangleWave(uv - vec2(m1Right, 0.0), 8.0 / (m2Left - m1Right), 1.5), vec3(0.0));\n    }\n\n    if (min(m2Right, f2) < uv.x && uv.x < max(m2Right, f2)) {\n        drawSDF(udTriangleWave(uv - vec2(m2Right, 0.0), 8.0 / (f2 - m2Right), 1.5), vec3(0.0));\n    }\n\n    // Draw the masses\n    drawSDF(sdBox(uv - vec2(sys.x, 0.0), vec2(r1)), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdBox(uv - vec2(sys.z, 0.0), vec2(r2)), vec3(0.0, 0.0, 1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "// Fixtures\n#define f1 -7.5\n#define f2 7.5\n\n// Masses\n#define m1 1.0\n#define m2 3.0\n\n// Size\n#define r1 sqrt(m1)\n#define r2 sqrt(m2)\n\n// Friction\n#define u1 0.1\n#define u2 0.1\n\n// Spring lengths\n#define l1 5.0\n#define l2 5.0\n#define l3 5.0\n\n// Spring constants\n#define k1 1.0\n#define k2 3.0\n#define k3 1.0\n\n// SDFs\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\n// https://www.shadertoy.com/view/tlcBW2\nfloat udTriangleWave(in vec2 p, in float freq, in float amp) {\n    float pw = 1.0 / abs(freq), qw = 0.25 * pw;\n    p.x = abs(mod(p.x * sign(freq) + qw, pw) - 0.5 * pw) - qw;\n\n    vec2 sc = vec2(2.0 * amp, pw);\n    float l = length(sc);\n    sc /= l;\n\n    p *= mat2(sc, -sc.y, sc.x);\n    return length(vec2(p.x, max(0.0, abs(p.y) - 0.25 * l)));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3SzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 246, 268, 268, 853], [855, 855, 891, 891, 1540], [1622, 1622, 1677, 1677, 2951]], "test": "untested"}
{"id": "ft3XDl", "name": "Solstice Stars", "author": "mla", "description": "Some stars for the Solstice.  \"Isogonal\" polygons where alternate sides are equal length, coloured according to \"winding number\", calculated using algorithm from Numerical Recipes.\n\nMouse sets polygon parameters (or press 'm' to stay with animation).", "tags": ["polygon", "winding", "semiregular"], "likes": 26, "viewed": 408, "published": 3, "date": "1640069192", "time_retrieved": "2024-07-30T18:41:00.258583", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Solstice Stars, Matthew Arcus, mla, 2021\n//\n// \"Isogonal\" polygons, coloured according to winding number.\n//\n// <mouse>: sets N,M parameters (unless m pressed)\n// m: disable mouse action\n// c: colouring\n// h: hatching\n// x: don't show compound polygons\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Two sets, A, B, of N evenly spaced points around the unit circle.\n// Connect A[i] to B[i] and B[i] to A[i+M]\n\nint N = 17; // 2N points\nint M = 3;  // Connect every M points\n\nfloat offset = 0.0; // Angular offset between point sets.\n\n// Parity = 0: set A, parity = 1: set B\nvec2 getpoint(int index, int parity) {\n  float theta = TWOPI*float(index)/float(N) + (float(parity)-0.5)*offset;\n  return vec2(cos(theta),sin(theta));\n}\n\n// Winding number - straight out of Numerical Recipes, streamlined\n// a little, and also getting distance to line.\n// Need a little bodge to detect returning to start (eg. when M divides N).\nint polywind(vec2 p, inout float d) {\n  int wind = 0, start = 0; \n  // Rebase everything to p\n  vec2 q = getpoint(0,0)-p;\n  for (int i = 1; i <= 2*N; i++) {\n    int index = M*(i>>1)%N;\n    vec2 r = getpoint(index+start,i&1)-p;\n    d = min(d,segment(q,r));\n    float t = determinant(mat2(q,r));\n    if (q.y <= 0.0) {\n      if (r.y > 0.0 && t > 0.0) wind++;\n    } else {\n      if (r.y <= 0.0 && t < 0.0) wind--;\n    }\n    // This next conditional handles the situation where\n    // M is a multiple of N, so we have a compound polygon.\n    if (index == 0 && (i&1) == 0) {\n      if (key(CHAR_X)) break; // Don't show compounds\n      // This code moves to the start of the next polygon.\n      start++;\n      r = getpoint(start,0)-p;\n    }\n    q = r;\n  }\n  d = sqrt(d);\n  return wind;\n}\n\nvec3 getcol(int i) {\n  vec3 col = vec3(1);\n  // Seasonal colours from https://www.schemecolor.com/\n  if (i == 3) col = vec3(135,10,30)/255.0;\n  else if (i == 1) col = vec3(255,194,70)/255.0;\n  else if (i == 2) col = vec3(92,134,10)/255.0;\n  else if (i == 0) col = vec3(199,52,8)/255.0;\n  else if (i == 4) col = vec3(0,93,0)/255.0;\n  col = pow(col,vec3(2.2));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float time = 0.1*iTime;\n  offset = TWOPI*(time + 0.5);\n  vec2 p = 1.05*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec2 mouse = vec2(0);\n  float mgrid = 20.0;\n  M = int(time);\n  if (!key(CHAR_M) && iMouse.x > 0.0) {\n    N = 3+int(mgrid*iMouse.x/iResolution.x);\n    M = int(mgrid*iMouse.y/iResolution.y);\n  }\n  M = 1+(M%(N-1));\n  p = p.yx; // Flip x and y\n  float px = fwidth(p.x);\n  vec3 col = vec3(1,1,0.6);\n  float d = 1e8;\n  int wind = polywind(p,d);\n  if (!key(CHAR_C) && (wind&1) != 0) col = getcol(abs(wind)>>1);\n  vec3 tex = texture(iChannel0,fragCoord/iResolution.x).xyz;\n  col = mix(vec3(0),col,smoothstep(-px,px,d-0.01*(0.5+0.5*dot(tex,tex))));\n  if (!key(CHAR_H) && (wind&1) != 0) {\n    // Hatching\n    float d = fract(30.0*(p.x));\n    d = min(d,1.0-d);\n    d /= 30.0;\n    float hwidth = 0.005*(0.5+dot(tex,tex));\n    col = mix(vec3(0),col,smoothstep(-px,px,d-hwidth));\n  }\n  col *= 0.5+0.5*sqrt(tex);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159;\nconst float TWOPI = 2.0*PI;\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash(uint x) {\n  return float(ihash(x))/pow(2.0,32.0);\n}\n\nfloat segment(vec2 a, vec2 b) {\n  b -= a;\n  float h = -dot(a,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  a+=b*h;\n  return dot(a,a);\n}\n\nvec2 cmul(vec2 z1, vec2 z2) {\n  return mat2(z1.x,z1.y,-z1.y,z1.x)*z2;\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// Macros for use in \"common\" blocks.\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3XDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[855, 1046, 1083, 1083, 1826], [1828, 1828, 1848, 1848, 2202], [2204, 2204, 2257, 2257, 3236]], "test": "untested"}
{"id": "7lySRz", "name": "Turing pattern generator", "author": "copperbotte", "description": "turing pattern generator to show a friend of mine how differential equations work.\n\nSet it to fullscreen while its running!", "tags": ["math", "physics"], "likes": 1, "viewed": 120, "published": 3, "date": "1640067157", "time_retrieved": "2024-07-30T18:41:01.076397", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float c = texture(iChannel0, fragCoord / iResolution.xy).x;\n    if(0.0 < c)\n        col = vec3(0, c, 0.0);\n    else\n        col = vec3(-c, 0, 0.0);\n    \n    // Output to screen\n    fragColor = vec4(lsrgb2srgb(col), 1.0);\n    \n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = computeDeltas(fragCoord, iResolution, iTime, iTimeDelta, iFrame, iChannel0, iChannel1);\n    \n    //if(iTime < 5.0)\n    //    uv = texture(iChannel2, fragCoord / iResolution.xy).xy;\n    \n    fragColor = vec4(vec3(uv.x), 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n//another random number generator\n//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat hashrandom( float x )\n{\n    return floatConstruct(hash(floatBitsToUint(x)));\n}\n\n// random number generator **\n// taken from iq :)\nfloat seed;    //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\nfloat laplacian(in sampler2D iChannel, in vec2 uv, in vec3 iResolution)\n{\n    mat3x3 f;\n    for(int i=0; i<3; ++i)\n        for(int j=0; j<3; ++j)\n            f[i][j] = texture(iChannel, uv + vec2(ivec2(i,j) - 1)/iResolution.xy).x;\n    \n    float dx = f[0][1] - 2.0*f[1][1] + f[2][1];\n    float dy = f[1][0] - 2.0*f[1][1] + f[1][2];\n    \n    //return dot(vec2(dx, dy) * (iResolution.xy*iResolution.xy), vec2(1));\n    return (dx + dy)*(450.0); \n}\n\nvec2 computeDeltas(in vec2 fragCoord, in vec3 iResolution, float iTime, float iTimeDelta, int iFrame, sampler2D iChannel0, sampler2D iChannel1)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    seed = hashrandom(iTime + iResolution.y * uv.x + uv.y);\n\n    float u, v; // \"random\" lmao\n    //u = clamp(u, 0.0, 1.0);\n    //v = clamp(v, 0.0, 1.0);\n    \n    if(1.0 < iTime )\n    {\n        u = texture(iChannel0, fragCoord / iResolution.xy).x;\n        v = texture(iChannel1, fragCoord / iResolution.xy).x;\n    }\n    \n    if(u == 0.0)\n        u = rnd();\n    if(v== 0.0)\n        v = rnd();\n    \n    float delu = laplacian(iChannel0, fragCoord / iResolution.xy, iResolution);\n    float delv = laplacian(iChannel1, fragCoord / iResolution.xy, iResolution);\n\n    float tau = 1.0; // 0.1 // 1.0 very cool\n    float sigma = 1.0;\n    float lambda = 1.0;\n    float k = -0.05;\n    float cu = 2.8e-4 * 5.0;\n    float cv = 5e-3 * 5.0;\n\n    float du = cu*delu + lambda*u-u*u*u-k - sigma*v;\n    float dv =(cv*delv + u - v)/tau;\n\n    float rate = 100.0;\n    //if(1.0 < iTime)\n    //if(1.0 < float(iFrame)/240.0)\n    //    rate = 50.0;\n    rate = mix(50.0, 100.0, smoothstep(480.0, 240.0, float(iFrame)));\n\n    u += du / rate;\n    v += dv / rate;\n    \n    return vec2(u, v);\n}\n\n\n\n\n\n// Color space transforms\nfloat lsrgb2srgb(in float lsrgb)\n{\n    if(lsrgb < 0.0031308)\n        return lsrgb * 12.92;\n    float a = 1.055;\n    return a * pow(lsrgb, 1.0/2.4) - (a - 1.0);\n}\n\nvec3 lsrgb2srgb(in vec3 lsrgb)\n{\n    return vec3(lsrgb2srgb(lsrgb.x),lsrgb2srgb(lsrgb.y),lsrgb2srgb(lsrgb.z));\n}\n\nfloat srgb2lsrgb(in float srgb)\n{\n    if(srgb < 0.04045)\n        return srgb / 12.92;\n    float a = 1.055;\n    return pow(1.0 + (srgb - 1.0) / a, 2.4);\n}\n\nvec3 srgb2lsrgb(in vec3 srgb)\n{\n    return vec3(srgb2lsrgb(srgb.x),srgb2lsrgb(srgb.y),srgb2lsrgb(srgb.z));\n}\n\n//https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(in vec3 rgb)\n{\n\tvec4 k = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, k.wz), vec4(rgb.gb, k.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n    \n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    \n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(in vec3 hsv)\n{\n\tvec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(hsv.xxx + k.xyz) * 6.0 - k.www);\n    return hsv.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), hsv.y);    \n}\n\nvec3 saturationClip(in vec3 rgb)\n{\n    vec3 hsv = rgb2hsv(rgb);\n    \n    if(1.0 < hsv.z)\n        hsv.yz /= hsv.z;\n    \n    return hsv2rgb(hsv);\n}\n\n\n\n\n\nfloat cielab_decode(in float lab)\n{\n    float delta = 6.0/29.0;\n    if(delta < lab)\n        return lab * lab * lab;\n    else\n        return 3.0*delta*delta*(lab - 4.0/29.0);\n}\n\nvec3 cieLAB2cieXYZ(in vec3 lab)\n{\n    // Decode lab to ciexyz\n    lab = (lab + vec3(0.16,0.0,0.0)) / vec3(1.16,5.00,2.00);\n    lab = transpose(mat3(1.0, 1.0, 0.0,\n               1.0, 0.0, 0.0,\n               1.0, 0.0,-1.0)) * lab;\n    return vec3(cielab_decode(lab.x),cielab_decode(lab.y),cielab_decode(lab.z));\n}\n\nvec3 cieXYZ2lsrgb(in vec3 xyz)\n{\n    return transpose(mat3(3.2406,-1.5372,-0.4986,\n                -0.9689, 1.8758, 0.0415,\n                 0.0557,-0.2040, 1.0570)) * xyz;\n}\n\n//     Uses a pair of Pad approximants to approximate matplotlib's viridis \n// color map. Computed by converting viridis into cieLAB, where L is linear, and\n// used gradient descent to compute the coefficients.  a* and b* have 0.0091 and\n// 0.0073 max absolute errors.  This colormap undoes the transform into linear\n// srgb color space.\n\nvec3 colorMap( in float scalar )\n{\n    float l_a[9] = float[9](0.80213256, 0.50558149, -0.00293372, 0.01460916, -0.01709858, 0., 0., 0., 0.);\n\n    float a_a[9] = float[9](-0.42688488, -0.87879584, 0.52822597, 0.17720305, 0.37109753, 0., 0., 0., 0.);\n    float a_b[9] = float[9](1., -0.17339854, 0.14818623, 0.04694771, 0.28992562, 0.02420924, 0.29365531, -0.01061596, 0.27261829);\n    \n    float b_a[9] = float[9](-0.08560176, 0.99106308, 0.29440914, 0.21043724, 0.14043312, -0.09626866, 0.07279252, 0., 0.);\n    float b_b[9] = float[9](1., -0.21130356, -0.04647037, 0.00883619, 0.19551535, 0.08748587, 0.28251813, 0., 0.);\n    \n    float t = clamp(scalar, 0.0, 1.0)*2.0 - 1.0;\n    \n    float L = l_a[8];\n    vec4 pade = vec4(a_a[8], a_b[8], b_a[8], b_b[8]);\n    for(int i=7; 0<=i; i--)\n    {\n        L = l_a[i] + t*L;\n        pade = vec4(a_a[i], a_b[i], b_a[i], b_b[i]) + t*pade;\n    }\n    float a = pade.x/pade.y;\n    float b = pade.z/pade.w;\n    \n    vec3 lab = vec3(L/1.3, a, b); // this 1.3 isn't originally part of viridis, but it looks ugly without it\n    vec3 xyz = cieLAB2cieXYZ(lab);\n    vec3 lsrgb = cieXYZ2lsrgb(xyz);\n    return clamp(srgb2lsrgb(lsrgb), 0.0, 1.0); // I thought I compensated for color space in the original computation? Its weird that this is needed here\n    \n    return lsrgb;\n}\n\n", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = computeDeltas(fragCoord, iResolution, iTime, iTimeDelta, iFrame, iChannel0, iChannel1);\n    \n    //if(iTime < 5.0)\n    //    uv = texture(iChannel2, fragCoord / iResolution.xy).xy;\n    \n    fragColor = vec4(vec3(uv.y), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lySRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 478]], "test": "untested"}
{"id": "ftySzR", "name": "270char fluid", "author": "davidar", "description": "[url=https://twitter.com/david_ar/status/1473611601626341376]Fluid simulation implemented in one tweet[/url]\n\nTakes a few seconds to start. Remove the indicated line in Buffer A to reduce the character count.", "tags": ["simulation", "fluid", "convolution", "2tweets", "golf"], "likes": 43, "viewed": 3071, "published": 3, "date": "1640066157", "time_retrieved": "2024-07-30T18:41:01.836365", "image_code": "M-1.+A.z;}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "M;\n  for(int k=0; k++<196; v = A.xy+i, r += vec4(v-i + v-v*A.z,1,1) * A.z / exp(dot(v,v)) / 3.142)\n    i = vec2(k%14,k/14)-7.;\n  //r.z > 0. ? r.xy /= r.z : u; // slightly more accurate, but slightly longer and slightly more buggy on some devices\n  r.xy /= r.z + 1e-6; // add epsilon to avoid division by zero\n\n  iFrame%500<2 ? r += vec4(u/1e3-.5\n      * iResolution.xy/1e3 // this line can safely be removed when the resolution is >500px\n      ,.3,0) : r;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define M void mainImage(out vec4 r, vec2 u) { vec2 v, i = u-u; r -= r//\n#define A texelFetch(iChannel0,ivec2(i+u),0)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftySzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ftGXzz", "name": "Migraine Yourgraine", "author": "xenn", "description": "NFT me", "tags": ["displacement", "chromatic", "aberration", "mapping", "dispersion"], "likes": 5, "viewed": 345, "published": 3, "date": "1640049464", "time_retrieved": "2024-07-30T18:41:02.782834", "image_code": "// Fork of \"Percolating Impressionism\" by xenn. https://shadertoy.com/view/Ndc3zj\n// 2021-12-21 01:17:19\n\n// Mashup Fork of \"Displacement with Dispersion\" by cornusammonis. https://shadertoy.com/view/4ldGDB\n// 2021-08-28 10:34:29\n// & this https://www.shadertoy.com/view/MsGSRd by flockeroo\n#define HEIGHT 22.50\n#define BRIGHTNESS 1.5\n#define Margins 0.1\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n/**\n\tUse Buffer A in iChannel0 for 3D letters. Read description!\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n//void mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n    // Normalized pixel coordinates (from 0 to 1)\n    \n   \n    vec2 uv = fragCoord/iResolution.xy;\n    //Texel Size\n    vec2 texel = vec2(1.) / iResolution.xy;\n    \n     vec4 frogColor = texture(iChannel3, uv);\n\n    vec3 normal = bump2Normal(uv, iChannel2, HEIGHT, texel);\n   \tvec3 normalRGB = normal2rgb(normal);\n    \n    vec3 lightDir = normalize(vec3(abs(sin(iTime/20.)), -abs(cos(iTime/40.)), abs(sin(iTime/40.))));\n    \n    vec3 toLightDir = vec3(0.0) - lightDir;\n    \n    float mouseX = iMouse.x / iResolution.x;\n    \n\tif (mouseX < 01.99) {\n        frogColor = vec4(BRIGHTNESS*dot(toLightDir, normalize(normal)));\n        frogColor*=texture(iChannel3, uv);\n    } else {\n        frogColor = vec4(normalRGB, 1.0);\n    }  \n    \n    if(abs(toLightDir.x *.5 + .5 - uv.x) < 0.005 && abs(toLightDir.z *.5 + .5 - uv.y) < 0.005) {\n    \tfrogColor = vec4(1.,abs(toLightDir.y*2.),vec2(0.));  \n    }\n    \n    \n    \n    vec4 final = frogColor;\n    \n    vec4 ace = vec4(ACESFilm(vec3(0)), 1.0);;\n\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n//    vec2 uv = fragCoord.xy/iResolution.xy;\n\n\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n      vec3 color = vec3(texture(iChannel0, uv - 0.50 * d).r,\n                      texture(iChannel0, uv - .0 * d).g,\n                      texture(iChannel0, uv + 01.0 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.50  * d).r,\n                      texture(iChannel1, uv - .0 * d).g,\n                      texture(iChannel1, uv - 01.0 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv -0.50  * d).r,\n                      texture(iChannel2, uv - .0 * d).g,\n                      texture(iChannel2, uv - 01.0  * d).b);\n                      \n                       vec3 col3 = vec3(texture(iChannel3, uv - 0.50 * d).r,\n                      texture(iChannel3, uv - 0.0 * d).g,\n                      texture(iChannel3, uv - 1.0 * d).b);\n                      \n                      vec3 blend = (max(color,col));\n                      vec3 bland = (max(col,color));\n               //       blend *= bland;\n               //       col2 = min(col,col3)*col2;\n               //       col = mix(col,col3,color);\n              //       col3 = min(col,color)*col3;\n            //     color = mix(col,color,col3)*color;\n\n  //    color = ((max(color,col),col3)*(color));\n //     color = (mix(color,col2,col2)*(color));\n    float noise = .9 + randomFloat()*.15;\n  \t//fragColor = vec4(ACESFilm(frogColor));\n //   fragColor = mix(vec4(ACESFilm((col+(mix(bland,blend,0.5)))*noise), 1.0),frogColor,(col,1.0));\n//    fragColor = vec4(ace(final))*noise );\n //   fragColor = frogColor;\n //fragColor =(vec4(ACESFilm(mix(bland,blend,0.5)*noise),1.0));\n fragColor = mix((vec4(ACESFilm(mix(bland,blend,0.5)*noise),1.0)),frogColor,(color,.50));\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n    A fracturing dynamical system\n\tsee: https://www.shadertoy.com/view/MsyXRW\n*/\n\n#define _G0 0.25\n#define _G1 0.125\n#define _G2 0.0625\n#define W0 -3.0\n#define W1 0.5\n#define TIMESTEP 0.1\n#define ADVECT_DIST 2.0\n#define DV 0.70710678\n\n// nonlinearity\nfloat nl(float x) {\n    return 1.0 / (1.0 + exp(W0 * (W1 * x - 0.5))); \n}\n\nvec4 gaussian(vec4 x, vec4 x_nw, vec4 x_n, vec4 x_ne, vec4 x_w, vec4 x_e, vec4 x_sw, vec4 x_s, vec4 x_se) {\n    return _G0*x + _G1*(x_n + x_e + x_w + x_s) + _G2*(x_nw + x_sw + x_ne + x_se);\n}\n\nbool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\nvec4 advect(vec2 ab, vec2 vUv, vec2 step) {\n    \n    vec2 aUv = vUv - ab * ADVECT_DIST * step;\n    \n    vec2 n  = vec2(0.0, step.y);\n    vec2 ne = vec2(step.x, step.y);\n    vec2 e  = vec2(step.x, 0.0);\n    vec2 se = vec2(step.x, -step.y);\n    vec2 s  = vec2(0.0, -step.y);\n    vec2 sw = vec2(-step.x, -step.y);\n    vec2 w  = vec2(-step.x, 0.0);\n    vec2 nw = vec2(-step.x, step.y);\n\n    vec4 u =    texture(iChannel0, fract(aUv));\n    vec4 u_n =  texture(iChannel0, fract(aUv+n));\n    vec4 u_e =  texture(iChannel0, fract(aUv+e));\n    vec4 u_s =  texture(iChannel0, fract(aUv+s));\n    vec4 u_w =  texture(iChannel0, fract(aUv+w));\n    vec4 u_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 u_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 u_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 u_se = texture(iChannel0, fract(aUv+se));\n    \n    return gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n}\n\n#define SQRT_3_OVER_2 0.86602540378\n#define SQRT_3_OVER_2_INV 0.13397459621\n\nvec2 diagH(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    return 0.5 * ((x + x_v) * SQRT_3_OVER_2_INV + (x_h + x_d) * SQRT_3_OVER_2);\n}\n\nvec2 diagV(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    return 0.5 * ((x + x_h) * SQRT_3_OVER_2_INV + (x_v + x_d) * SQRT_3_OVER_2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    vec2 n  = vec2(0.0, 1.0);\n    vec2 ne = vec2(1.0, 1.0);\n    vec2 e  = vec2(1.0, 0.0);\n    vec2 se = vec2(1.0, -1.0);\n    vec2 s  = vec2(0.0, -1.0);\n    vec2 sw = vec2(-1.0, -1.0);\n    vec2 w  = vec2(-1.0, 0.0);\n    vec2 nw = vec2(-1.0, 1.0);\n\n    vec4 u =    texture(iChannel0, fract(vUv));\n    vec4 u_n =  texture(iChannel0, fract(vUv+texel*n));\n    vec4 u_e =  texture(iChannel0, fract(vUv+texel*e));\n    vec4 u_s =  texture(iChannel0, fract(vUv+texel*s));\n    vec4 u_w =  texture(iChannel0, fract(vUv+texel*w));\n    vec4 u_nw = texture(iChannel0, fract(vUv+texel*nw));\n    vec4 u_sw = texture(iChannel0, fract(vUv+texel*sw));\n    vec4 u_ne = texture(iChannel0, fract(vUv+texel*ne));\n    vec4 u_se = texture(iChannel0, fract(vUv+texel*se));\n    \n    const float vx = 0.5;\n    const float vy = SQRT_3_OVER_2;\n    const float hx = SQRT_3_OVER_2;\n    const float hy = 0.5;\n\n    float di_n  = nl(distance(u_n.xy + n, u.xy));\n    float di_w  = nl(distance(u_w.xy + w, u.xy));\n    float di_e  = nl(distance(u_e.xy + e, u.xy));\n    float di_s  = nl(distance(u_s.xy + s, u.xy));\n    \n    float di_nne = nl(distance((diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)), u.xy));\n    float di_ene = nl(distance((diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)), u.xy));\n    float di_ese = nl(distance((diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)), u.xy));\n    float di_sse = nl(distance((diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)), u.xy));    \n    float di_ssw = nl(distance((diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)), u.xy));\n    float di_wsw = nl(distance((diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)), u.xy));\n    float di_wnw = nl(distance((diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)), u.xy));\n    float di_nnw = nl(distance((diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)), u.xy));\n\n    vec2 xy_n  = u_n.xy + n - u.xy;\n    vec2 xy_w  = u_w.xy + w - u.xy;\n    vec2 xy_e  = u_e.xy + e - u.xy;\n    vec2 xy_s  = u_s.xy + s - u.xy;\n    \n    vec2 xy_nne = (diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)) - u.xy;\n    vec2 xy_ene = (diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)) - u.xy;\n    vec2 xy_ese = (diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)) - u.xy;\n    vec2 xy_sse = (diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)) - u.xy;\n    vec2 xy_ssw = (diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)) - u.xy;\n    vec2 xy_wsw = (diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)) - u.xy;\n    vec2 xy_wnw = (diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)) - u.xy;\n    vec2 xy_nnw = (diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)) - u.xy;\n\n    vec2 ma = di_nne * xy_nne + di_ene * xy_ene + di_ese * xy_ese + di_sse * xy_sse + di_ssw * xy_ssw + di_wsw * xy_wsw + di_wnw * xy_wnw + di_nnw * xy_nnw + di_n * xy_n + di_w * xy_w + di_e * xy_e + di_s * xy_s;\n\n    vec4 u_blur = gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n    \n    vec4 au = advect(u.xy, vUv, texel);\n    vec4 av = advect(u.zw, vUv, texel);\n    \n    vec2 dv = av.zw + TIMESTEP * ma;\n    vec2 du = au.xy + TIMESTEP * dv;\n\n    if (iMouse.z > 0.0) {\n    \tvec2 d = fragCoord.xy - iMouse.xy;\n        float m = exp(-length(d) / 50.0);\n        du += 0.2 * m * normz(d);\n    }\n    \n    vec2 init = texture(iChannel1, vUv, 4.0).xy;\n    // initialize with noise\n    if((length(u) < 0.001 && length(init) > 0.001) || reset()) {\n        fragColor = 8.0 * (vec4(-0.5) + vec4(init.xy, init.xy));\n    } else {\n        du = length(du) > 1.0 ? normz(du) : du;\n        fragColor = vec4(du, dv);\n    }\n    \n\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n    A fluid-like dynamical system\n\tsee: https://www.shadertoy.com/view/XddSRX\n*/\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\n// reverse advection\nvec4 advect(vec2 ab, vec2 vUv, vec2 step, float sc) {\n    \n    vec2 aUv = vUv - ab * sc * step;\n    \n    const float _G0 = 0.25; // center weight\n    const float _G1 = 0.125; // edge-neighbors\n    const float _G2 = 0.0625; // vertex-neighbors\n    \n    // 3x3 neighborhood coordinates\n    float step_x = step.x;\n    float step_y = step.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(iChannel0, fract(aUv));\n    vec4 uv_n =  texture(iChannel0, fract(aUv+n));\n    vec4 uv_e =  texture(iChannel0, fract(aUv+e));\n    vec4 uv_s =  texture(iChannel0, fract(aUv+s));\n    vec4 uv_w =  texture(iChannel0, fract(aUv+w));\n    vec4 uv_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 uv_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 uv_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 uv_se = texture(iChannel0, fract(aUv+se));\n    \n    return _G0*uv + _G1*(uv_n + uv_e + uv_w + uv_s) + _G2*(uv_nw + uv_sw + uv_ne + uv_se);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float _K0 = -20.0/6.0; // center weight\n    const float _K1 = 4.0/6.0;   // edge-neighbors\n    const float _K2 = 1.0/6.0;   // vertex-neighbors\n    const float cs = -3.0;  // curl scale\n    const float ls = 3.0;  // laplacian scale\n    const float ps = 0.0;  // laplacian of divergence scale\n    const float ds = -12.0; // divergence scale\n    const float dp = -6.0; // divergence update scale\n    const float pl = 0.3;   // divergence smoothing\n    const float ad = 6.0;   // advection distance scale\n    const float pwr = 1.0;  // power when deriving rotation angle from curl\n    const float amp = 1.0;  // self-amplification\n    const float upd = 0.99;  // update smoothing\n    const float sq2 = 0.6;  // diagonal weight\n    \n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    // 3x3 neighborhood coordinates\n    float step_x = texel.x;\n    float step_y = texel.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(iChannel0, fract(vUv));\n    vec4 uv_n =  texture(iChannel0, fract(vUv+n));\n    vec4 uv_e =  texture(iChannel0, fract(vUv+e));\n    vec4 uv_s =  texture(iChannel0, fract(vUv+s));\n    vec4 uv_w =  texture(iChannel0, fract(vUv+w));\n    vec4 uv_nw = texture(iChannel0, fract(vUv+nw));\n    vec4 uv_sw = texture(iChannel0, fract(vUv+sw));\n    vec4 uv_ne = texture(iChannel0, fract(vUv+ne));\n    vec4 uv_se = texture(iChannel0, fract(vUv+se));\n    \n    // uv.x and uv.y are the x and y components, uv.z and uv.w accumulate divergence \n\n    // laplacian of all components\n    vec4 lapl  = _K0*uv + _K1*(uv_n + uv_e + uv_w + uv_s) + _K2*(uv_nw + uv_sw + uv_ne + uv_se);\n    \n    // calculate curl\n    // vectors point clockwise about the center point\n    float curl = uv_n.x - uv_s.x - uv_e.y + uv_w.y + sq2 * (uv_nw.x + uv_nw.y + uv_ne.x - uv_ne.y + uv_sw.y - uv_sw.x - uv_se.y - uv_se.x);\n    \n    // compute angle of rotation from curl\n    float sc = cs * sign(curl) * pow(abs(curl), pwr);\n    \n    // calculate divergence\n    // vectors point inwards towards the center point\n    float div  = uv_s.y - uv_n.y - uv_e.x + uv_w.x + sq2 * (uv_nw.x - uv_nw.y - uv_ne.x - uv_ne.y + uv_sw.x + uv_sw.y + uv_se.y - uv_se.x);\n    \n    vec2 norm = normz(uv.xy);\n    \n    float sdx = uv.z + dp * uv.x * div + pl * lapl.z;\n    float sdy = uv.w + dp * uv.y * div + pl * lapl.w;\n\n    vec2 ab = advect(vec2(uv.x, uv.y), vUv, texel, ad).xy;\n    \n    // temp values for the update rule\n    float ta = amp * ab.x + ls * lapl.x + norm.x * ps * lapl.z + ds * sdx;\n    float tb = amp * ab.y + ls * lapl.y + norm.y * ps * lapl.w + ds * sdy;\n\n    // rotate\n    float a = ta * cos(sc) - tb * sin(sc);\n    float b = ta * sin(sc) + tb * cos(sc);\n    \n    vec4 abd = upd * uv + (1.0 - upd) * vec4(a,b,sdx,sdy);\n    \n    fragColor = vec4(abd);\n    \n    abd.xy = clamp(length(abd.xy) > 1.0 ? normz(abd.xy) : abd.xy, -1.0, 1.0);\n    fragColor = vec4(abd);\n    \n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define posterSteps 12.0\n#define lumaMult 1.\n#define timeMult 0.05\n#define BW 0\n\nfloat rgbToGray(vec4 rgba) {\n\tconst vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    return dot(rgba.xyz, W);\n}\n\nvec3 hsv2rgb2(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    float luma = rgbToGray(color) * lumaMult;\n    float lumaIndex = floor(luma * posterSteps);\n   \tfloat lumaFloor = lumaIndex / posterSteps;\n    float lumaRemainder = (luma - lumaFloor) * posterSteps;\n    if(mod(lumaIndex, 2.) == 0.) lumaRemainder = 1.0 - lumaRemainder; // flip luma remainder for smooth color transitions\n    float timeInc = iTime * timeMult;\n    float lumaCycle = mod(luma + timeInc, 1.);\n    vec3 roygbiv = hsv2rgb(vec3(lumaCycle, 1., lumaRemainder));\n    if(BW == 1) {\n        float bw = rgbToGray(vec4(roygbiv, 1.));\n        fragColor = vec4(vec3(bw), 1.0);\n    } else {\n        fragColor = vec4(roygbiv, 1.0);\n    }\n}", "buffer_c_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "\n\n// displacement amount\n#define DISP_SCALE -2.\n\n// chromatic dispersion samples\n#define SAMPLES 32\n\n// contrast\n#define SIGMOID_CONTRAST 12.0\n\n// channels to use for displacement, either xy or zw\n#define CH yz\n\n\nvec3 contrast(vec3 x) {\n\treturn 1.0 / (1.0 + exp(-SIGMOID_CONTRAST * (x - 0.5)));    \n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0) ? vec2(0) : normalize(x);\n}\n\n/*\n\tThis function supplies a weight vector for each color channel.\n\tIt's analogous to (but not a physically accurate model of)\n\tthe response curves for each of the 3 cone types in the human eye.\n\tThe three functions for red, green, and blue have the same integral\n    over [0, 1], which is 1/3.\n    Here are some other potential terms for the green weight that \n\tintegrate to 1/3:\n        2.0*(1-x)*x\n        10.0*((1-x)*x)^2\n        46.667*((1-i)*i)^3\n        210.0*((1-x)*x)^4\n        924.0*((1-x)*x)^5\n    By the way, this series of coefficients is OEIS A004731 divided by 3,\n    which is a pretty interesting series: https://oeis.org/A002457\n*/\nvec3 sampleWeights(float i) {\n\treturn vec3(i * i, 46.6666*pow((1.0-i)*i,3.0), (1.0 - i) * (1.0 - i));\n}\n\nvec3 sampleDisp(vec2 uv, vec2 dispNorm, float disp) {\n    vec3 col = vec3(0);\n    const float SD = 1.0 / float(SAMPLES);\n    float wl = 0.0;\n    vec3 denom = vec3(0);\n    for(int i = 0; i < SAMPLES; i++) {\n        vec3 sw = sampleWeights(wl);\n        denom += sw;\n        col += sw * texture(iChannel1, uv + dispNorm * disp * wl).xyz;\n        wl  += SD;\n    }\n    \n    // For a large enough number of samples,\n    // the return below is equivalent to 3.0 * col * SD;\n    return col / denom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 texel = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 n  = vec2(0.0, texel.y);\n    vec2 e  = vec2(texel.x, 0.0);\n    vec2 s  = vec2(0.0, -texel.y);\n    vec2 w  = vec2(-texel.x, 0.0);\n\n    vec2 d   = texture(iChannel0, uv).CH;\n    vec2 d_n = texture(iChannel0, fract(uv+n)).CH;\n    vec2 d_e = texture(iChannel0, fract(uv+e)).CH;\n    vec2 d_s = texture(iChannel0, fract(uv+s)).CH;\n    vec2 d_w = texture(iChannel0, fract(uv+w)).CH; \n\n    // antialias our vector field by blurring\n    vec2 db = 0.4 * d + 0.15 * (d_n+d_e+d_s+d_w);\n\n    float ld = length(db);\n    vec2 ln = normz(db);\n\n\tvec3 col = sampleDisp(uv, ln, DISP_SCALE * ld);\n    \n    fragColor = vec4(contrast(col), 1.0);\n\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 getFontSymbolSampleUV(int x, int y, vec2 uv) {\n\treturn uv * vec2(1./16.) + vec2(float(x) / 16., float(y) / 16.);\n}\n\nfloat getHeight(vec2 uv, sampler2D bumpMap, float maxHeight) {\n    return texture(bumpMap, uv).r*maxHeight;\n}\n\nvec3 getSlope(vec2 uv, float height, vec2 axis, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    float h1 = getHeight(uv+texelSize*axis, bumpMap, maxHeight);\n    float h2 = getHeight(uv-texelSize*axis, bumpMap, maxHeight);\n    return vec3(1,((height-h2) + (h1-height)) / 2.,0);\n}\n\nvec3 bump2Normal(vec2 uv, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    \n    float height = getHeight(uv, bumpMap, maxHeight);\n        \n    vec3 slopeX = getSlope(uv, height, vec2(1., 0.), bumpMap, maxHeight, texelSize).zyx;\n    vec3 slopeY = getSlope(uv, height, vec2(0., 1.), bumpMap, maxHeight, texelSize).xyz;\n    return cross(slopeX, slopeY).zyx;\n}\n\nvec3 normal2rgb(vec3 normal) {\n    return normalize(normal.rbg * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5));\n}\n\nfloat radius = 20.;\nfloat intensity = 5.;\nfloat fade = .99;\n\nfloat pi = 3.14159265359;\n\nfloat blurRadius = 3.;\n\nfloat sinWave(float v, float m){return (sin(v*m*pi*2.)+1.)/2.;}\n\n//from https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 xy2hue(vec2 v){\n    float h = (atan(v.y, v.x)/(pi) + 1.)/2.;\n    float b = length(v);\n    return vec4(hsv2rgb(vec3(h, 1., b)), 1.);\n}\n\n\n\n\n\n\n", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGXzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[374, 374, 394, 394, 473], [475, 475, 498, 498, 638], [640, 708, 765, 874, 3863]], "test": "untested"}
{"id": "7ldXDs", "name": "Viscosity Clone #1", "author": "PyThrrrown", "description": "This is a clone from https://www.shadertoy.com/view/tdyBRt.\nI just tweaked it a little bit to make it look more tasty. :)", "tags": ["viscosity"], "likes": 22, "viewed": 800, "published": 3, "date": "1640034427", "time_retrieved": "2024-07-30T18:41:03.550781", "image_code": "// Created by Alex Kluchikov viscosity klk\n// tweaked by PyThrrrone\n\n#define PI 3.141592654\nvec2 rot(vec2 p,float a)\n{\n    float c=sin(a*35.83);\n    float s=cos(a*35.83);\n    return p*mat2(s,c,c,-s);\n}\nvoid mainImage(out vec4 o, in vec2 uv)\n{\n    uv/=iResolution.xy;\n    uv=vec2(.125,.75)+(uv-vec2(.125,.5))*.003;\n    float T=iTime*.1;\n\n    vec3 c = clamp(1.-.7*vec3(\n        length(uv-vec2(1.1,1)),\n        length(uv-vec2(1.1,1)),\n        length(uv-vec2(1.1,1))\n        ),0.,1.)*2.-1.;\n    vec3 c0=vec3(0);\n    float w0=0.;\n    const float N=5.;\n    for(float i=0.;i<N;i++)\n    {\n        float wt=(i*i/N/N-.2)*.3;\n        float wp=0.5+(i+1.)*(i+1.5)*0.000001;\n        float wb=.05+i/N*0.1;\n    \tc.zx=rot(c.zx,1.6+T*0.65*wt+(uv.x+.7)*23.*wp);\n    \tc.xy=rot(c.xy,c.z*c.x*wb+1.7+T*wt+(uv.y+1.1)*15.*wp);\n    \tc.yz=rot(c.yz,c.x*c.y*wb+2.4-T*0.79*wt+(uv.x+uv.y*(fract(i/2.)-0.25)*4.)*17.*wp);\n    \tc.zx=rot(c.zx,c.y*c.z*wb+1.6-T*0.65*wt+(uv.x+.7)*23.*wp);\n    \tc.xy=rot(c.xy,c.z*c.x*wb+1.7-T*wt+(uv.y+1.1)*15.*wp);\n        float w=(1.5-i/N);\n        c0+=c*w;\n        w0+=w;\n    }\n    c0=c0/w0*2.+.5;//*(1.-pow(uv.y-.5,2.)*2.)*2.+.5;\n    c0*=.5+dot(c0,vec3(1,1,1))/sqrt(3.)*.5;\n    c0+=pow(length(sin(c0*PI*4.))/sqrt(3.)*1.0,20.)*(.3+.7*c0);\n\to=vec4(c0,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldXDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 118, 118, 201], [202, 202, 242, 242, 1255]], "test": "untested"}
{"id": "sltXDs", "name": "Iso Hitomezashi Stitch [Day 732]", "author": "jeyko", "description": "hmm", "tags": ["shane", "mdtmjvm", "stitch", "isogrid"], "likes": 23, "viewed": 416, "published": 3, "date": "1640032338", "time_retrieved": "2024-07-30T18:41:04.314738", "image_code": "// https://www.youtube.com/watch?v=JbfhzlMk2eY&ab_channel=Numberphile\n// ^ Hitomezashi Stitch Patterns - Numberphile ^\n\n// Inspired by Shane's awesome style\n// But the code is unreadable and not a good way to go about it :D\n\n// But the basic concept of the isogrid construction is (and this method is pretty good):\n// repeating space on each of the three \"axes\" of the triangle. \n// An axis is defined by a direction, so your uv in one axis would be mod(dot(uv,axis),1.).\n// dot(uv,axis) being line/plane SDF\n\n// Then a bunch of hacks to render the lines of neighboring triagnles.\n// I tried to colour them but failed miserably.\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    //fragCoord += 250.*noise(vec3(uv*2.5,5.))/iResolution.xy;\n    col = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    col = vec3(1)*pow(col,vec3(0.85,0.96,1.1));\n    \n    float no = noise(vec3(uv*2.,35.));\n    //col = mix(col,vec3(0),smoothstep(0.,0.5,max(noise(vec3(uv*2.2 + 0.1,35.)) - 0.5,0.))*0.4);\n    \n    //col = mix(col,vec3(1),smoothstep(0.,4.,max(no - 0.5,0.))*.4);\n    \n    col *= 1. - pow(dot(uv,uv*0.6),2.)*2.;\n    \n    //col += min(no - 0.5,0.)*0.02;\n    \n    float n1d = texelFetch(iChannel2,ivec2(mod(fragCoord + vec2(float(iFrame)*0.4,0.),256.)),0).x*0.5;\n    vec3 n  = texelFetch(iChannel2,ivec2(mod(fragCoord + n1d*200. ,256.)),0).xyz*0.6;\n    \n    \n    //C = smoothstep(0.,1.,C);z\n    \n    //col.xyz = pow(max(col.xyz,0.), vec3(0.55) + n*0.1);\n    \n    col.xyz += smoothstep(1.,0.,length(col))*n*0.05;\n    \n    col.xyz -= smoothstep(0.,1.,length(col))*n*0.01;\n    \n    //col = col/(col*0.5 + 0.7);\n    \n    \n    col = pow(clamp(col,0.01,1.),vec3(0.4545));\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define third 1./3.\n\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n#define pmodTri(p,a) (mod(p,a) - third*a)\n\n#define dmin(da,db) (da.x) < (db.x) ? (da) : (db)\n\n#define dminm(da,db,bm) (da.x) < (db) ? (da) : vec2(db,bm)\n\n#define draw(col,newCol, d) col = mix(col,newCol,smoothstep(pxSz,0.,d))\n\n// Dave Hoskins's hash without sine.\nfloat r21(float a, float b)\n{\n    vec2 p = vec2(a,b);\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\n// Mirror point across axis.\nvec2 refl(vec2 p, vec2 axis){\n    float d = dot(p,axis);\n    if (d < 0.)\n        return p;\n    else\n        return p - axis*2.*d;\n}\n\n// Probability on each axis of even or odd distribution.\nvec3 probabilities;\n\n\nbvec3 getShouldDraw(vec3 idline, vec3 id){\n    idline = floor(idline);\n    id = floor(id);\n    bvec3 shouldDraw = bvec3(\n        r21(idline.x,10.) < probabilities.x,\n        r21(idline.y,20.) < probabilities.y,\n        r21(idline.z,30.) < probabilities.z\n    );\n    \n    if(mod(id.z,2.) == 0.)\n        shouldDraw.y = !shouldDraw.y;\n    if(mod(id.y,2.) == 0.)\n        shouldDraw.z = !shouldDraw.z;\n    if(mod(id.y,2.) == 0.)\n        shouldDraw.x = !shouldDraw.x;\n    return shouldDraw;\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uvn = U/R.xy;\n    \n    vec2 uv = (U - 0.5*R)/R.y;\n    \n    probabilities = vec3(\n        iMouse.x/iResolution.x, iMouse.y/iResolution.y, 0.5\n    );\n    \n    {\n        // value noise\n        float t = 1.;\n        float env = fract(iTime/t);\n        env = pow(env,7.);\n        float fl = floor(iTime/t);\n        float vn = mix(hash11(fl),hash11(fl+1.),env);\n        probabilities.z = vn;\n\n    }\n    \n    uv *= 15. - sin(iTime)*0.4;\n    \n    uv.x += iTime*1.45;\n    \n    uv += noise(vec3(uv*0.1,0.))*0.01;\n    uv += noise(vec3(uv*rot(0.25*pi)*0.6 + 4.,0.))*0.01;\n    float pxSz = fwidth(uv.y)*1.1;\n    \n    vec3 col = vec3(0);\n\n    float md = 1.;\n    \n    vec2 axisA = vec2(0,1);\n    vec2 axisB = vec2(0,1)*rot(pi*2./3.);\n    vec2 axisC = vec2(0,1)*rot(-pi*2./3.);\n    \n    vec3 uvtri = vec3(dot(uv,axisA),dot(uv,axisB),dot(uv,axisC));\n    \n    vec3 id = floor(uvtri/md);\n    \n    vec2 uvlocal = uv - (axisA*id.x + axisB*id.y + axisC*id.z)*third*2.;\n    \n    vec3 idlineuv = (uvtri + (third)*0.5)/md;\n    vec3 idline = floor(idlineuv);\n    \n    //float pattcnt = 17.;\n    \n    vec3 flips = step(1.0,mod(uvtri,2.0))*2.0-1.0;\n    float flip = flips.x * flips.y * flips.z;\n\n    bool flipped = false;\n    if(mod(id.x + id.y + id.z,2.) == 0.){\n        //uvtri = -pmodTri(uvtri,-md);\n        flipped = true;\n    } else{\n        //uvtri = pmodTri(uvtri,md);\n    }\n    \n\n    //col += vec3(0.8,0.4,0.7) + 0.5*sin(vec3(1,2.5,1.6) + id*vec3(0.5,0.1,0.1)*0.7 + id.x + id.y + id.z);\n    col = vec3(1);    \n    \n    \n     \n     {   \n        float linew = 0.024;\n        float d = 10e5;\n\n        \n        bvec3 shouldDraw = getShouldDraw(idline, id);\n        \n        \n        bvec3 skip = bvec3(true);\n        \n        \n        \n        vec3 lineCol = vec3(0);\n        \n        // draw lines\n        \n        float dx = abs(dot(uvlocal,axisA) + third * flip) - linew;\n        float dy = abs(dot(uvlocal,axisB) + third * flip) - linew;\n        float dz = abs(dot(uvlocal,axisC) + third * flip) - linew;\n        \n        if(skip.x && shouldDraw.x){\n            d = dx;\n        }\n        \n        if(skip.y && shouldDraw.y){\n            d = min(dy,d);\n        }\n        \n        if(skip.z && shouldDraw.z){\n            d = min(dz,d);\n        }\n        \n        float oldd = d;\n        float dd = min(dx,min(dy,dz));\n        float ddb = dd;\n        \n        d = pmod(d + 0.4,0.2);\n        d = abs(d);\n        \n        ddb = pmod(ddb + 0.4,0.2);\n        ddb = abs(ddb);\n        \n        draw(col,(sin(vec3(10.4,5.2,5.5) + sin(id.x*2. + sin(id.y)*6. + iTime*10.))*0.2 + 0.6)*0.7, d - 0.001);\n        \n        \n        if(oldd > 1.)\n            draw(col,(sin(vec3(0.4,1.2,9.5) + sin(uvtri.x*2. + sin(uvtri.y)*6. + iTime*10.))*0. + 0.7)*1., ddb - 0.02);\n        \n        \n        \n        col=mix(col,col*col*col*0.4, smoothstep(0.4,0.,oldd)*0.1);\n        \n        draw(col,lineCol*0., oldd);\n        \n    }\n    {\n        float dotw = 0.1 + sin(idline.y + iTime + sin(idline.z))*0.05;\n        // dots center\n        float d = length(uvlocal) - dotw*0.1;\n        draw(col,vec3(0),d);\n        \n        // dots edges\n        vec2 p = refl(uvlocal,axisA);\n        //p = uvlocal;\n        //p = refl(p,axisB);\n        p = refl(uvlocal,axisC);\n        \n        d = length(p - axisA*third*2.) - dotw;\n        //draw(col,vec3(0),d);\n        d = min(d,length(p - axisB*third*2.) - dotw);\n        //draw(col,vec3(0),d);\n        d = min(d,length(p + axisC*third*2.) - dotw);\n        \n        draw(col,vec3(0),d);\n        \n        \n    }\n    \n    col = mix(col,col*col*col*0.5,smoothstep(0.445,0.3,texture(iChannel1,uv*0.0025).x)*0.5);\n    \n    col = mix(col,vec3(0),clamp(noise(vec3(uv*3.,0.)),0.,1.)*0.1);\n    //col = exp(-col*4.);\n    C = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat noise(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,11.);\n    p.xw *= rot(1.4);\n    p.x *= 57.;\n    for(float i = 0.; i < 5.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(2.5-i);\n        p += cos(p*1./amp + vec4(3,2,1,1.) )*amp*.3;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.7;\n        p *= 1.5;\n    }\n    \n    //n = sin(n*1.);\n    n = abs(n);\n    return n;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltXDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[718, 718, 775, 775, 1895]], "test": "untested"}
{"id": "stcXDs", "name": "1D Discrete Heat Flow", "author": "oneshade", "description": "Solving the heat difference equation (NOT differential equation).", "tags": ["heat", "pde", "differences"], "likes": 8, "viewed": 222, "published": 3, "date": "1640030255", "time_retrieved": "2024-07-30T18:41:05.079693", "image_code": "// See https://www.desmos.com/calculator/bqmdhati2x\n\n//#define DISCRETE_TIME\n\n#define PI 3.1415926536\n#define QT 0.7071067812 // cos(/4)\n\n// Safer pow(a, t)\nfloat expn(in float a, in float t) {\n    if (abs(t) < 1e-10) return 1.0;\n    return pow(abs(a), t) * (a < 0.0 ? cos(PI * t) : 1.0);\n}\n\n// abs(4.0 - mod(n, 8.0))\nfloat tri(in float n, in float t, in float k) {\n    float h = 2.0;\n    h += 0.8535533906 * cos(0.25 * PI * n) * expn(1.0 + (QT - 1.0) * k, t);\n    h += 0.1464466094 * cos(0.75 * PI * n) * expn(1.0 - (QT + 1.0) * k, t);\n    h += 0.1464466094 * cos(1.25 * PI * n) * expn(1.0 - (QT + 1.0) * k, t);\n    h += 0.8535533906 * cos(1.75 * PI * n) * expn(1.0 + (QT - 1.0) * k, t);\n    return h;\n}\n\n// 4.0 * mod(floor(n / 4.0), 2.0)\nfloat square(in float n, in float t, in float k) {\n    float h = 2.0;\n    h += 1.3065629649 * cos(0.25 * PI * n + 1.9634954085) * expn(1.0 + (QT - 1.0) * k, t);\n    h += 0.5411961001 * cos(0.75 * PI * n + 2.7488935719) * expn(1.0 - (QT + 1.0) * k, t);\n    h += 0.5411961001 * cos(1.25 * PI * n - 2.7488935719) * expn(1.0 - (QT + 1.0) * k, t);\n    h += 1.3065629649 * cos(1.75 * PI * n - 1.9634954085) * expn(1.0 + (QT - 1.0) * k, t);\n    return h;\n}\n\n// mod(n, 4.0)\nfloat saw(in float n, in float t, in float k) {\n    float h = 1.5;\n    h -= 0.7071067812 * cos(0.5 * PI * n - 0.7853981634) * expn(1.0 - k, t);\n    h -= 0.7071067812 * cos(1.5 * PI * n + 0.7853981634) * expn(1.0 - k, t);\n    h -=  0.5 * cos(PI * n) * expn(1.0 - 2.0 * k, t);\n    return h;\n}\n\n// f(0) = 1.55, f(1) = 2.66, f(2) = 2.51, f(3) = 1.94,\n// f(4) = 3.88, f(5) = 2.57, f(6) = 2.42, f(7) = 0.00\nfloat custom(in float n, in float t, in float k) {\n    float h = 2.19125;\n    h += 0.4931253070 * cos(0.25 * PI * n - 2.7445711841) * expn(1.0 + (QT - 1.0) * k, t);\n    h += 0.2111854791 * cos(0.75 * PI * n - 2.2203501522) * expn(1.0 - (QT + 1.0) * k, t);\n    h += 0.2111854791 * cos(1.25 * PI * n + 2.2203501522) * expn(1.0 - (QT + 1.0) * k, t);\n    h += 0.4931253070 * cos(1.75 * PI * n + 2.7445711841) * expn(1.0 + (QT - 1.0) * k, t);\n    h += 0.4159721295 * cos(0.50 * PI * n - 1.4199747323) * expn(1.0 - k, t);\n    h += 0.4159721295 * cos(1.50 * PI * n + 1.4199747323) * expn(1.0 - k, t);\n    h += 0.39875 * cos(PI * n) * expn(1.0 - 2.0 * k, t);\n    return h;\n}\n\n//float f(in float x) { return abs(mod(x, 8.0) - 4.0); }\n//#define once(n, k) (f(n) + ((f(n - 1.0) + f(n + 1.0)) / 2.0 - f(n)) * k)\n//#define twice(n, k) (once(n, k) + ((once(n - 1.0, k) + once(n + 1.0, k)) / 2.0 - once(n, k)) * k)\n//#define thrice(n, k) (twice(n, k) + ((twice(n - 1.0, k) + twice(n + 1.0, k)) / 2.0 - twice(n, k)) * k)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.x * 8.0;\n    float unit = 8.0 / iResolution.y;\n    fragColor = vec4(0.0);\n\n    #ifdef DISCRETE_TIME\n    float time = floor(iTime);\n    #else\n    float time = iTime;\n    #endif\n\n    float height = custom(floor(uv.x), time, 0.25);\n    fragColor.rb += mix(vec2(0.0, 1.0), vec2(1.0, 0.0), height / 4.0) * step(uv.y, height);\n\n    fragColor += smoothstep(unit, 0.0, abs(mod(uv.x + 0.5, 1.0) - 0.5));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcXDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 159, 195, 195, 292], [294, 320, 367, 367, 706], [708, 742, 792, 792, 1191], [1193, 1208, 1255, 1255, 1498], [1500, 1609, 1659, 1659, 2275], [2615, 2615, 2670, 2670, 3105]], "test": "untested"}
{"id": "ftdXR7", "name": "Analytical AA - Polygon VG ", "author": "sopyer", "description": "Inspired by https://graphics.cs.illinois.edu/wp-content/uploads/2019/09/paper1013-main.pdf\nPolygonal shapes only, uses basic box kernel with texture space axis aligned max screen space derivative kernel shape", "tags": ["procedural", "antialiasing", "vector", "aa", "analytical", "texturing", "vg"], "likes": 8, "viewed": 331, "published": 3, "date": "1640019801", "time_retrieved": "2024-07-30T18:41:05.888531", "image_code": "// Inspired by https://graphics.cs.illinois.edu/wp-content/uploads/2019/09/paper1013-main.pdf(Real-Time Analytic Antialiased Text for 3-D Environments)\n// Polygonal shapes only, uses basic box kernel with texture space axis aligned max screen space derivative kernel shape.\n\n\n// The MIT License\n// Copyright  2019 Mykhailo Parfeniuk\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nfloat saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nvec2 saturate(vec2 x)\n{\n    return clamp(x, vec2(0.0), vec2(1.0));\n}\n\nvec2 rcp(vec2 v)\n{\n\treturn vec2(1.0f) / v;\n}\n\nfloat IntegrateSegment(vec2 P0, vec2 P1, vec2 XBounds, vec2 YBounds)\n{\n\tvec2 D = P1 - P0;\n\tvec2 invD = rcp(D);\n\n\tP0.y -= YBounds.x; \n\tYBounds = vec2(0.0f, YBounds.y - YBounds.x);\n\n\tvec2 tv = saturate((XBounds - P0.xx) * invD.xx);\n\tvec2 th = saturate((YBounds - P0.yy) * invD.yy);\n\n\tfloat tv_min = min(tv.x, tv.y);\n\tfloat tv_max = max(tv.x, tv.y);\n\n\tfloat th_min = min(th.x, th.y);\n\tfloat th_max = max(th.x, th.y);\n\n#if 1 // Handle Nan\n#if 0 // Return second argument in case of NaN\n\ttv_min = max(tv_min, 0.0f);\n\ttv_max = min(tv_max, 1.0f);\n\tth_min = max(th_min, 0.0f);\n\tth_max = min(th_max, 1.0f);\n#else\n\ttv_min = max(0.0f, tv_min);\n\ttv_max = min(1.0f, tv_max);\n\tth_min = max(0.0f, th_min);\n\tth_max = min(1.0f, th_max);\n#endif\n#endif\n\n\tfloat tmin = max(tv_min, th_min);\n\tfloat tmax = min(tv_max, th_max);\n\n\tfloat t_p1 = min(tmin, tmax);\n\tfloat t_p2 = max(tmin, tmax);\n\n\tvec2 p0 = clamp(P0 + tv_min * D, vec2(XBounds.x, YBounds.x), vec2(XBounds.y, YBounds.y));\n\tvec2 p1 = clamp(P0 + t_p1 * D, vec2(XBounds.x, YBounds.x), vec2(XBounds.y, YBounds.y));\n\tvec2 p2 = clamp(P0 + t_p2 * D, vec2(XBounds.x, YBounds.x), vec2(XBounds.y, YBounds.y));\n\tvec2 p3 = clamp(P0 + tv_max * D, vec2(XBounds.x, YBounds.x), vec2(XBounds.y, YBounds.y));\n\n\treturn (p3.x - p2.x) * p3.y + 0.5f * (p2.x - p1.x) * (p2.y + p1.y) + (p1.x - p0.x) * p0.y;\n}\n\n\n\nvec3 bg = vec3(0.1, 0.5, 0.4);\nvec3 grey = vec3(0.1);\nvec3 white = vec3(1);\nvec3 black = vec3(0);\nvec3 red = vec3(1, 0, 0);\nvec3 blue = vec3(0, 0, 1);\nvec3 yellow = vec3(1, 1, 0);\nvec3 magenta = vec3(1, 0, 1);\n\n\n\n// --- AA Box filtered version ---\n\nfloat triangle(in vec2 xBounds, in vec2 yBounds)\n{\n    return IntegrateSegment(vec2(5, -5), vec2(25, -5), xBounds, yBounds)\n                  + IntegrateSegment(vec2(25, -5), vec2(5, -25), xBounds, yBounds)\n                  + IntegrateSegment(vec2(5, -25), vec2(5, -5), xBounds, yBounds);\n}\n\nfloat quad(in vec2 xBounds, in vec2 yBounds)\n{\n    return abs(IntegrateSegment(vec2(-25, -5), vec2(-5, -15), xBounds, yBounds)\n                  + IntegrateSegment(vec2(-5, -15), vec2(-25, -25), xBounds, yBounds)\n                  + IntegrateSegment(vec2(-25, -25), vec2(-15, -15), xBounds, yBounds)\n                  + IntegrateSegment(vec2(-15, -15), vec2(-25, -5), xBounds, yBounds));\n}\n\n\nfloat romb(in vec2 xBounds, in vec2 yBounds)\n{\n    return abs(IntegrateSegment(vec2(5, 15), vec2(15, 25), xBounds, yBounds)\n                  + IntegrateSegment(vec2(15, 25), vec2(25, 15), xBounds, yBounds)\n                  + IntegrateSegment(vec2(25, 15), vec2(15, 5), xBounds, yBounds)\n                  + IntegrateSegment(vec2(15, 5), vec2(5, 15), xBounds, yBounds));\n}\n\nfloat fivegon(in vec2 xBounds, in vec2 yBounds)\n{\n    return IntegrateSegment(vec2(-5, 5), vec2(-20, 5), xBounds, yBounds)\n                  + IntegrateSegment(vec2(-20, 5), vec2(-25, 20), xBounds, yBounds)\n                  + IntegrateSegment(vec2(-25, 20), vec2(-20, 25), xBounds, yBounds)\n                  + IntegrateSegment(vec2(-20,25), vec2(-5, 20), xBounds, yBounds);\n                  + IntegrateSegment(vec2(-5, 20), vec2(-5, 5), xBounds, yBounds);\n}\n\nfloat rect(vec2 pmin, vec2 pmax, float w, in vec2 xBounds, in vec2 yBounds)\n{\n    float result = 0.0;\n\n    result += IntegrateSegment(vec2(pmin.x-w, pmin.y-w), vec2(pmin.x-w, pmax.y+w), xBounds, yBounds);\n    result += IntegrateSegment(vec2(pmin.x+w, pmax.y-w), vec2(pmin.x+w, pmin.y+w), xBounds, yBounds);\n\n    result += IntegrateSegment(vec2(pmin.x-w, pmax.y+w), vec2(pmax.x+w, pmax.y+w), xBounds, yBounds);\n    result += IntegrateSegment(vec2(pmax.x-w, pmax.y-w), vec2(pmin.x+w, pmax.y-w), xBounds, yBounds);\n\n    result += IntegrateSegment(vec2(pmax.x+w, pmax.y+w), vec2(pmax.x+w, pmin.y-w), xBounds, yBounds);\n    result += IntegrateSegment(vec2(pmax.x-w, pmin.y+w), vec2(pmax.x-w, pmax.y-w), xBounds, yBounds);\n\n    result += IntegrateSegment(vec2(pmax.x+w, pmin.y-w), vec2(pmin.x-w, pmin.y-w), xBounds, yBounds);\n    result += IntegrateSegment(vec2(pmin.x+w, pmin.y+w), vec2(pmax.x-w, pmin.y+w), xBounds, yBounds);\n    \n    return result;\n}\n\nvec3 aaBoxFilteredTexture( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    vec3 color;\n    vec2 max_dd = max(ddx, ddy);\n    vec2 xBounds = p.xx + vec2(-0.5, 0.5) * max_dd.xx;\n    vec2 yBounds = p.yy + vec2(-0.5, 0.5) * max_dd.yy;\n    float kernelNorm = 1.0 / (max_dd.x * max_dd.y); \n    \n    // background\n    color = bg;\n    color = mix(color, white, saturate(kernelNorm*rect(vec2(-35), vec2(35), 0.15, xBounds, yBounds)));\n    color = mix(color, red, saturate(kernelNorm*romb(xBounds, yBounds)));\n    color = mix(color, blue, saturate(kernelNorm*triangle(xBounds, yBounds)));\n    color = mix(color, magenta, saturate(kernelNorm*quad(xBounds, yBounds)));\n    color = mix(color, yellow, saturate(kernelNorm*fivegon(xBounds, yBounds)));\n\n    return color;\n}\n\n// Helpers\n\nvec2 toUV( in vec3 pos )\n{\n\treturn pos.xz;\n}\n\n\nvoid calcCamera( out vec3 ro, out vec3 ta )\n{\n\tfloat an = 0.2*iTime+2.0;//0.1*sin(3.0*iTime);\n\tro = vec3( 6.0*cos(an), 200.0*abs(0.5+0.5*sin(2.0*an))+1.05, 6.0*sin(an) );\n    ta = vec3( 0.0, 1.0, 0.0 );\n}\n\nvoid calcRayForPixel( in vec2 pix, out vec3 resRo, out vec3 resRd )\n{\n\tvec2 p = (-iResolution.xy + 2.0*pix) / iResolution.y;\n\t\n     // camera movement\t\n\tvec3 ro, ta;\n\tcalcCamera( ro, ta );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\t\n\tresRo = ro;\n\tresRd = rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n\t\n\tvec3 ro, rd, ddx_ro, ddx_rd, ddy_ro, ddy_rd;\n\tcalcRayForPixel( fragCoord + vec2(0.0,0.0), ro, rd );\n\tcalcRayForPixel( fragCoord + vec2(1.0,0.0), ddx_ro, ddx_rd );\n\tcalcRayForPixel( fragCoord + vec2(0.0,1.0), ddy_ro, ddy_rd );\n\t\t\n    \n\tvec3 col = vec3(0.9);\n    \n    // intersect plane\n\tfloat t = (0.01-ro.y)/rd.y;\n\tif( t>0.0 )\n\t{\n\t\tvec3 nor = vec3(0.0,1.0,0.0); \n\t\tvec3 pos = ro + t*rd;\n        \n#if 1\n\t\t// -----------------------------------------------------------------------\n        // compute ray differentials by intersecting the tangent plane to the  \n        // surface.\t\t\n\t\t// -----------------------------------------------------------------------\n\n\t\t// computer ray differentials\n\t\tvec3 ddx_pos = ddx_ro - ddx_rd*dot(ddx_ro-pos,nor)/dot(ddx_rd,nor);\n\t\tvec3 ddy_pos = ddy_ro - ddy_rd*dot(ddy_ro-pos,nor)/dot(ddy_rd,nor);\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec2     uv = toUV(     pos );\n\t\tvec2 ddx_uv = toUV( ddx_pos ) - uv;\n\t\tvec2 ddy_uv = toUV( ddy_pos ) - uv;\n#else\n\t\t// -----------------------------------------------------------------------\n        // Because we are in the GPU, we do have access to differentials directly\n        // This wouldn't be the case in a regular raytrace.\n\t\t// It wouldn't work as well in shaders doing interleaved calculations in\n\t\t// pixels (such as some of the 3D/stereo shaders here in Shadertoy)\n\t\t// -----------------------------------------------------------------------\n\t\tvec2 uvw = toUV( pos );\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec2 ddx_uvw = dFdx( uvw ); \n        vec2 ddy_uvw = dFdy( uvw ); \n#endif\n\n        // Texture\n        col = vec3(1.0)*aaBoxFilteredTexture( uv, abs(ddx_uv), abs(ddy_uv) );\n\t}\n\t\n    // \"gamma correction\"\t\n\tcol = pow( col, vec3(0.4545) );\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdXR7.jpg", "access": "api", "license": "mit", "functions": [[1361, 1361, 1386, 1386, 1419], [1421, 1421, 1444, 1444, 1489], [1491, 1491, 1509, 1509, 1535], [1537, 1537, 1607, 1607, 2860], [3113, 3113, 3163, 3163, 3404], [3406, 3406, 3452, 3452, 3795], [3798, 3798, 3844, 3844, 4171], [4173, 4173, 4222, 4222, 4633], [4635, 4635, 4712, 4712, 5582], [5584, 5584, 5650, 5650, 6336], [6350, 6350, 6376, 6376, 6394], [6397, 6397, 6442, 6442, 6601], [6603, 6603, 6672, 6672, 7045], [7047, 7047, 7104, 7104, 8932]], "test": "untested"}
{"id": "7ldXDl", "name": "infinite traditional hallway", "author": "yasuo", "description": "infinite traditional hallway", "tags": ["hallway"], "likes": 19, "viewed": 353, "published": 3, "date": "1640019316", "time_retrieved": "2024-07-30T18:41:06.722301", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 64\n#define MAX_DIST 64.\n#define SURF_DIST .0001\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p.x)-s.x,abs(p.y)-s.y)\n#define ZERO (min(iFrame,0))\n#define TRADITIONAL_ASSET0_MAT 0\n#define FRAME_MAT0 4\n#define FRAME_MAT1 5\n#define FRAME_MAT2 6\n#define FRAME_MAT3 7\n#define FRAME_MAT4 8\n\n// by Dave_Hoskins\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\nfloat B3D(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat doorFrame(vec3 p){\n    vec3 prevP = p;\n    \n    p.x = abs(p.x)-0.5;\n    float d = B3D(p,vec3(0.02,0.8,0.02));\n    p = prevP;\n    \n    p.y = abs(p.y)-0.78;\n    float d2 = B3D(p,vec3(0.5,0.02,0.02));\n    \n    d = min(d,d2);\n    return d;\n}\n\nfloat doorFrameWire(vec3 p){\n    p.y-=0.27;\n    vec3 prevP = p;\n    \n    p.y = mod(p.y,0.2)-0.1;\n    float d = B3D(p,vec3(0.5,0.01,0.01));\n    p = prevP;\n    \n    p.x = mod(p.x,0.2)-0.1;\n    float d2 = B3D(p,vec3(0.01,0.6,0.01));\n    d = min(d,d2);\n    p = prevP;\n    return max(B3D(p,vec3(0.5,0.51,0.03)),d);\n}\n\nvec2 doorModel1(vec3 p){\n    vec3 prevP = p;\n    \n    float d = doorFrame(p);\n    float d2 = doorFrameWire(p);\n    d = min(d,d2);\n    \n    vec2 model = vec2(d,FRAME_MAT0);\n    \n    d = B3D(p-vec3(0.0,0.275,0.0),vec3(0.5,0.5,0.001));\n    vec2 model2 = vec2(d,FRAME_MAT1);\n    \n    d = B3D(p-vec3(0.0,-0.5,0.0),vec3(0.5,0.28,0.001));\n    vec2 model3 = vec2(d,FRAME_MAT2);\n    \n    return combine(model,combine(model2,model3));\n}\n\nvec2 doorModel2(vec3 p){\n    vec3 prevP = p;\n    \n    float d = doorFrame(p);\n    float d2 = doorFrameWire(p);\n    \n    p.y-=0.27;\n    d2 = max((length(abs(p.xy))-0.4),d2);\n    d = min(d,d2);\n    \n    vec2 model = vec2(d,FRAME_MAT0);\n    \n    p = prevP;\n    d = B3D(p-vec3(0.0,0.275,0.0),vec3(0.5,0.5,0.001));\n    p.y-=0.27;\n    d = max((length(abs(p.xy))-0.4),d);\n    \n    vec2 model2 = vec2(d,FRAME_MAT1);\n    \n    p = prevP;\n    d = B3D(p-vec3(0.0,-0.5,0.0),vec3(0.5,0.28,0.001));\n    vec2 model3 = vec2(d,FRAME_MAT2);\n    \n    p = prevP;\n    d = B3D(p-vec3(0.0,0.275,0.0),vec3(0.5,0.5,0.001));\n    p.y-=0.27;\n    d = max(-(length(abs(p.xy))-0.4),d);\n    \n    vec2 model4 = vec2(d,FRAME_MAT3);    \n    \n    return combine(model,combine(model2,combine(model3,model4)));\n}\n\nvec2 doorModel3(vec3 p){\n    vec3 prevP = p;\n    \n    float d = doorFrame(p);\n    p.y-=0.1;\n    p.y = mod(p.y,0.2)-0.1;\n    float d2 = B3D(p,vec3(0.5,0.01,0.01));\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = mod(p.x,0.2)-0.1;\n    d2 = B3D(p,vec3(0.01,0.8,0.01));\n    d = min(d,d2);\n    \n    p = prevP;\n    d = max(B3D(p,vec3(0.5,0.78,0.03)),d);\n    \n    vec2 model = vec2(d,FRAME_MAT0);\n\n    d = B3D(p,vec3(0.48,0.76,0.001));\n    vec2 model2 = vec2(d,FRAME_MAT1);\n    \n    return combine(model,model2);\n}\n\nvec2 openDoorModel(vec3 p){\n    vec3 prevP = p;\n    \n    float d = doorFrame(p);\n    p.x+=0.4;\n    float d2 = length(p.xy)-0.035;\n    d2 = max(abs(p.z)-0.011,d2);\n    d = min(d,d2);\n    vec2 model = vec2(d,FRAME_MAT0);\n    p = prevP;\n    d = B3D(p,vec3(0.48,0.76,0.001));\n    vec2 model2 = vec2(d,FRAME_MAT4);\n    \n    return combine(model,model2);\n}\n\nvec2 tatamiFloor(vec3 p){\n    vec3 prevP = p;\n    float d = B3D(p,vec3(1.0,0.1,5.0));\n    vec2 model = vec2(d,-1);\n    return model;\n}\n\nvec2 doorBlock(vec3 p){\n    vec3 prevP = p;\n    p.y-=0.1;\n    p.x = abs(p.x)-1.0;\n    p.xz*=Rot(radians(90.0));\n    vec2 model1 = doorModel1(p);\n    vec2 model2 = doorModel2(p-vec3(1.0,0.0,0.0));\n    vec2 model3 = doorModel3(p-vec3(-1.0,0.0,0.0));\n    \n    return combine(model1,combine(model2,model3));\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    p.y+=0.8;\n    vec2 model = tatamiFloor(p);\n    \n    p = prevP;\n    p.z-=iTime;\n    p.z=mod(p.z,3.0)-1.5;\n    vec2 model2 = doorBlock(p);\n    \n    p = prevP;\n    p.y-=0.1;\n    p.x = abs(p.x)-(0.75-(sin(iTime*2.0)*0.2));\n    p.z-=iTime;\n    p.z=mod(p.z,4.0)-2.;\n    vec2 model3 = openDoorModel(p);\n    \n    p = prevP;\n    p.z-=iTime;\n    p.z=mod(p.z,4.0)-2.;\n    float d = B3D(p-vec3(0.0,-0.7,0.0),vec3(1.0,0.03,0.03));\n    p.x = abs(p.x)-1.0;\n    float d2 = B3D(p,vec3(0.03,1.0,0.03));\n    vec2 model4 = vec2(min(d,d2),FRAME_MAT0);\n    \n    return combine(model, combine(model2,combine(model3,model4)));\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<3; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    //float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    //float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.); // spec\n        \n    return diffCol;\n}\n\nvec3 reflectMaterial(vec3 p, vec3 rd, vec3 n) {\n    vec3 r = reflect(p+rd*1.6,n);\n    vec3 col = r;\n    \n    return col;\n}\n\nfloat tatami(vec2 p){\n    p*=2.0;\n    vec2 uv = fract(p)-0.5;\n    vec2 prevUV = uv;\n    vec2 id = floor(p);\n    float n = hash12(id);\n    \n    float d = 100.0;\n    if(n<0.5){\n        uv.x-=0.45;\n        d = B(uv,vec2(0.05,0.5));\n    }\n    uv = prevUV;\n    uv.y-=0.45;\n    float d2 = B(uv,vec2(0.5,0.05));\n    return min(d,d2);\n}\n\nvec3 tatamiMat(vec2 p, vec3 col){\n    float d = tatami(p);\n    p.x*=0.1;\n    vec2 id = floor(p*500.0);\n    float n = hash12(id);\n    col = mix(vec3(0.6,0.7,0.6)-(n*n*0.1),vec3(0.15,0.3,0.25)*n,S(d,0.0));\n    return col;\n}\n\nfloat texNoise(vec2 p){\n    vec2 id = floor(p*500.0);\n    float n = hash12(id);\n    return n;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    vec3 np = p;\n    np.z-=iTime;\n    float nn = texNoise(np.xz);\n    if(mat == FRAME_MAT0){\n        return diffuseMaterial(n,rd,p,vec3(0.4,0.2,0.1)-(nn*nn*0.1));\n    }\n    \n    if(mat == FRAME_MAT1){\n        return diffuseMaterial(n,rd,p,vec3(1.0)-(nn*nn*0.1));\n    }\n    if(mat == FRAME_MAT2){\n        return diffuseMaterial(n,rd,p,vec3(0.8,0.7,0.5)-(nn*nn*0.1));\n    }\n    if(mat == FRAME_MAT3){\n        return diffuseMaterial(n,rd,p,vec3(0.7,0.6,0.4)-(nn*nn*0.1));\n    }\n    if(mat == FRAME_MAT4){\n        np.x = abs(np.x)-(0.75-(sin(iTime*2.0)*0.2));\n        nn = texNoise(np.xz);\n        return diffuseMaterial(n,rd,p,vec3(1.2)-(nn*0.05));\n    }\n    p.z-=iTime;\n    return diffuseMaterial(n,rd,p,tatamiMat(p.xz,col));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy -.3;\n    \n    float t = iTime;\n\n    vec3 ro = vec3(0, 0.0, 1.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    //ro.yz *= Rot(radians(10.0));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0.0), 0.5);\n    rd*=matRotateZ(radians(sin(t*0.5)*15.0));\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        col *= exp( -0.038*d.x*d.x*d.x );//fog\n    } else {\n        col = mix(vec3(0.0),vec3(0.2,0.1,0.3),uv.y);\n    }\n    \n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldXDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[753, 772, 794, 794, 914], [916, 916, 952, 952, 994], [996, 996, 1023, 1023, 1077], [1079, 1079, 1103, 1103, 1322], [1324, 1324, 1352, 1352, 1635], [1637, 1637, 1661, 1661, 2063], [2065, 2065, 2089, 2089, 2838], [2840, 2840, 2864, 2864, 3348], [3350, 3350, 3377, 3377, 3700], [3702, 3702, 3727, 3727, 3836], [3838, 3838, 3861, 3861, 4143], [4145, 4145, 4167, 4167, 4796], [4798, 4798, 4856, 4856, 5123], [5125, 5125, 5149, 5149, 5350], [5352, 5352, 5394, 5394, 5589], [5591, 5632, 5681, 5681, 5975], [5977, 5977, 6034, 6072, 6634], [6636, 6636, 6683, 6683, 6758], [6760, 6760, 6781, 6781, 7088], [7090, 7090, 7123, 7123, 7311], [7313, 7313, 7336, 7336, 7408], [7410, 7410, 7469, 7469, 8195], [8197, 8197, 8254, 8254, 9141]], "test": "untested"}
{"id": "7ltSDl", "name": "3d noise wave thing", "author": "SnoopethDuckDuck", "description": "nothing special and lots of artifacts", "tags": ["raymarching", "template", "artofcode"], "likes": 7, "viewed": 322, "published": 3, "date": "1640014882", "time_retrieved": "2024-07-30T18:41:07.577016", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define pi 3.14159\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n} \n\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat GetDist(vec3 p) {\n    float d = p.y -1. * cos(0.3 * length(p.xz) - iTime);\n    \n    float sc = 2.;\n   // vec2 ipos = floor(sc * mix(p.xx, p.zz, 0.5 + 0.5 * cos(iTime))) + 0.5;\n    vec2 ipos = floor(sc * p.xz) + 0.5;\n    vec2 fpos = sc * p.xz - ipos;\n    \n    float h = h21(ipos);\n    d = mix(0.2 * length(p) - 1., d, 0.75 + 0.25 * cos(2. * pi * h + iTime));\n    d += smoothstep(-0.25,0.25, -h + 0.5 \n    + 0.5 * cos(2. * pi * h + iTime));\n         \n    // d *= h;\n    \n    return 0.15 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*.5 + .5;\n    \n    vec3 col = mix(vec3(.5,0.,0.),vec3(0.),k);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(5,4,5);\n    ro = vec3(5. * cos(0.5 * iTime), 4., 5. * sin(0.5 * iTime));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,1.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 rf = refract(rd, n,0.1);\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = 0.42 *vec3(dif);\n        \n        float b = .5 + .5 * cos(iTime);\n        \n        uv = fragCoord.xy / iResolution.xy;\n        col += 0.5 * texture(iChannel0, r).rgb;\n         \n        float a = atan(rf.z, rf.x);\n        float c = atan(rf.z,rf.y);\n        vec2 ipos = floor(p.xz) + 0.5;\n        float h = mix(h21(ipos),0., 0.5 + 0.5 * cos(iTime));\n        col.r += 0.15 + .3 * cos(2. * pi * h + 10. * rf.y + iTime - .5 * pi);\n        col.g += 0.15 + .3 * cos(2. * pi * h + 10. * rf.y + iTime);\n        col.b += 0.15 + .3 * cos(2. * pi * h + 10. * rf.y + iTime + .5 * pi);\n        col = min(col, 1.2 * vec3(0.5 + 0.5 * cos(2. * p.y)));\n       \n        \n    } else {\n        col = texture(iChannel0, rd).rgb;\n    }\n    \n    //col.r =0.02;\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltSDl.jpg", "access": "api", "license": "mit", "functions": [[1495, 1495, 1514, 1514, 1576], [1580, 1580, 1600, 1600, 1675], [1677, 1677, 1701, 1701, 1741], [1743, 1743, 1766, 1766, 2240], [2242, 2242, 2276, 2276, 2487], [2489, 2489, 2513, 2513, 2703], [2705, 2705, 2755, 2755, 2946], [2948, 2948, 2966, 2966, 3064], [3067, 3067, 3124, 3124, 4558]], "test": "untested"}
{"id": "7tdSDl", "name": "fork menger sponge-color", "author": "jorge2017a2", "description": "fork menger sponge-color", "tags": ["forkmengerspongecolor"], "likes": 5, "viewed": 219, "published": 3, "date": "1640014197", "time_retrieved": "2024-07-30T18:41:08.332995", "image_code": "///modificado por jorge2017a2\n//referencia\n//https://www.shadertoy.com/view/ltGSWz\n\n#define distfar 6.0\n#define iterations 5.0\n\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat maxcomp(vec3 p) {\n    return max(p.x,max(p.y,p.z));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nfloat sdBox2D(vec2 p, vec2 b) {\n\tvec2  di = abs(p) - b;\n    float mc = max(di.x,di.y);\n    return min(mc,length(max(di,0.0)));\n}\n\nfloat sdCross( in vec3 p )\n{\n  float da = sdBox2D(p.xy,vec2(1.0));\n  float db = sdBox2D(p.yz,vec2(1.0));\n  float dc = sdBox2D(p.zx,vec2(1.0));\n  return min(da,min(db,dc));\n}\n\nvec2 sdCrossC3( in vec3 p )\n{\n  float da = sdBox2D(p.xy,vec2(1.0));\n  float db = sdBox2D(p.yz,vec2(1.0));\n  float dc = sdBox2D(p.zx,vec2(1.0));\n   vec2 dmin=vec2(9999.99,-1.0);\n  \n  dmin=opU(vec2(db,1.0),vec2(dc,2.0) );\n  dmin=opU(vec2(da,3.0),dmin );\n\n  return dmin;\n}\n\n\n#define MENGER_ITERATIONS\t2\n\n\nvec2 mapFractal(in vec3 p)\n{\t\n \n    float d = sdBox(p,vec3(2.5+0.3*sin(iTime*0.25)));\n    vec2 res = vec2(d, 7.0);\n    float s = 2.5;\n    \n    for(int i = 0; i < MENGER_ITERATIONS; ++i)\n    {\t  s = pow(2.0,float(i));\n        vec3 a = mod(p * s, 2.0) - 1.0;\n        s *= 11.0;\n        vec3 r = abs(1.0 - 5.0 * abs(a));\n\n       vec2 c2=sdCrossC3(r);\n        c2.x= (c2.x-0.25)/s;\n        float c=c2.x;\n\n        if(c > d) { d = c2.x; res = c2; }\n    }\n    \n    return res;\n}\n\nvec2 map(vec3  p)\n{   \n   vec2 d1=mapFractal(p);\n   return vec2(d1);\n}\n\nvec3 calcnormal(vec3 p) {\n    vec2 e = vec2(0.0001, 0.0);\n    vec3 n;\n    n.x = map(p+e.xyy).x - map(p-e.xyy).x;\n    n.y = map(p+e.yxy).x - map(p-e.yxy).x;\n    n.z = map(p+e.yyx).x - map(p-e.yyx).x;\n    return  normalize(n);\n}\n\nfloat softshadow (vec3 ro, vec3 rd) {\n    float res = 1.0;\n    float t = 0.001;\n    for (float i = 0.0; i < 1000.0; i++) {\n        if (t>distfar) break;\n        vec2 h = map(ro + t*rd);\n        if (h.x < 0.0001) return 0.0;\n        res = min(res, 64.0*h.x/t);\n        t += h.x;\n    }\n    return res;\n}\n\nvec3 trace(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (float i = 0.0; i < 1000.0; i++) {\n        if (t > distfar) break;\n        vec2 d = map(ro + rd*t);\n        if (d.x < 0.0001) return vec3(t, d.y, i);\n        t += d.x;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.0,0.0,4.5);\n    vec3 rd = normalize(vec3(uv,-1.5));\n    \n    float theta = sin(iTime/2.0);\n    mat2 rot = mat2(cos(theta),sin(theta),-sin(theta),cos(theta));\n    ro.yz *= rot;\n    rd.yz *= rot;\n    theta = iTime/3.0;\n    rot = mat2(cos(theta),sin(theta),-sin(theta),cos(theta));\n    ro.xz *= rot;\n    rd.xz *= rot;\n    \n    vec3 t = trace(ro, rd);\n    \n    vec3 col = vec3(0.8);\n    \n    if (t.y > 0.5) {\n        \n        vec3 pos = ro + rd*t.x;\n        vec3 lig = normalize(vec3(0.6,1.0,0.8));\n        vec3 nor = calcnormal(pos);\n        float refRange = 0.2;\n        \n        float occ = 1.0/(1.0+t.z/15.0);\n        float sha = softshadow(pos, lig);\n        float dif = max(0.0, dot(nor,lig));\n        float sky = 0.5+0.5*nor.y;\n        float ind = max(0.0, dot(nor,vec3(-1.0,-0.2,-1.0)*lig));\n        float ref = max(1.0-refRange,dot(-nor,rd))-1.0+refRange;\n        \n        vec3 col2=getColor( int(t.y));\n        col = vec3(0.8,1.0,1.2)*dif*pow(vec3(sha),vec3(1.0,1.2,1.5));\n        col += vec3(0.2,0.3,0.4)*ind*occ;\n        col += (vec3(0.2,0.2,1.3)+sky*occ)*1.2;\n        col += pow(ref,2.0)*4.0*occ;\n        col*=col2;\n        \n        col = pow(col,vec3(0.4545));\n        \n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdSDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 222, 222, 249], [250, 250, 293, 293, 320], [321, 321, 369, 369, 397], [399, 399, 422, 422, 458], [460, 460, 491, 491, 582], [584, 584, 615, 615, 712], [714, 714, 742, 742, 887], [889, 889, 918, 918, 1158], [1191, 1191, 1219, 1219, 1661], [1663, 1663, 1682, 1682, 1733], [1735, 1735, 1760, 1760, 1961], [1963, 1963, 2000, 2000, 2264], [2266, 2266, 2296, 2296, 2521], [2523, 2523, 2580, 2580, 3922]], "test": "untested"}
{"id": "7ldSWl", "name": "Psynthetika Meautiful Hues", "author": "xenn", "description": "Custom mandelbox", "tags": ["fractal", "gi", "dof", "bloom", "depthoffield", "ao", "mandelbox"], "likes": 16, "viewed": 336, "published": 3, "date": "1640011313", "time_retrieved": "2024-07-30T18:41:09.278467", "image_code": "\n// Fork of \"Weird mandelbox\" by loicvdb. https://shadertoy.com/view/3t3GWH\n// 2021-06-06 02:02:38\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 bloom(float scale, float threshold, vec2 fragCoord){\n    float logScale = log2(scale)+1.0;\n    \n    vec3 bloom = vec3(0);\n    for(int y = -1; y <= 1; y++)\n        for(int x = -1; x <= 1; x++)\n            bloom += textureLod(iChannel0, (fragCoord+vec2(x, y) * scale)/iResolution.xy, logScale).rgb;\n    \n    return max(bloom/9.0 - vec3(threshold), vec3(0));\n}\n\n// Fork of \"Psynthetika\" by xenn. https://shadertoy.com/view/fdKGDy\n// 2021-09-29 06:32:00\n\n//Chromatic aberration, film grain and tone mapping\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm2(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n    vec3 color = vec3(texture(iChannel0, uv - 1.0 * d).r,\n                      texture(iChannel0, uv - -0.0 * d).g,\n                      texture(iChannel0, uv + 1.0 * d).b);\n    \n    \n    float noise = .9 + randomFloat()*.15;\n//  \tfragColor = vec4(ACESFilm(color*noise), 1.0);\n//}\n\n//void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 frogColor;\n    vec4 frigColor;\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    vec3 bloomSum = bloom(.1 * iResolution.y, .9, fragCoord) * .2\n        \t\t  + bloom(.2 * iResolution.y, .5, fragCoord) * .2;\n//    frogColor = vec4(ACESFilm(color*noise), 1.0);\n//    frigColor = mix(vec4(ACESFilm(col + bloomSum), 1.0),vec4(ACESFilm2(color*noise), 1.0),(1.0 * abs(sin(iTime * .50))));\n        frogColor = max(vec4(ACESFilm(col + bloomSum), 1.0),vec4(ACESFilm2(color*noise), 1.0));\n        frigColor = min(vec4(ACESFilm(col + bloomSum), 1.0),vec4(ACESFilm2(color*noise), 1.0));\n\nfragColor = mix(frigColor,frogColor,1.0-(0.999*(cos(iTime/3.14159265359))));\n// fragColor = max(vec4(ACESFilm(col + bloomSum), 1.0),vec4(ACESFilm2(color*noise), 1.0));\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MaxSteps 64\n#define MaxShadowSteps 32\n#define AmbientLightSteps 14\n#define MaxDist 2.0\n#define MinDist .015\n#define GIStrength .93\n#define AOStrength .3\n\nvec3 CamPos = vec3(0, 0, -17.);\nvec3 CamRot = vec3(0);\nfloat CamFocalLength = 1.5;\n\nvec3 LightDir;\nvec3 LightColor = vec3(.7, .5, .3) * 10.;\nfloat LightRadius = .05;\n\nfloat Scale = 2.25;\nfloat Radius = .5;\nint Iterations = 9;\nmat3 Rotation;\n\nfloat distanceEstimation(vec3 position){\n    position *= Rotation;\n\tvec4 scalevec = vec4(Scale, Scale, Scale, abs(Scale)) / Radius;\n\tfloat C1 = abs(Scale-1.0), C2 = pow(abs(Scale), float(1-Iterations));\n\tvec4 p = vec4(position.xyz, 1.0), p0 = vec4(position.xyz, 1.0);\n\tfor (int i=0; i< Iterations; i++) {\n    \tp.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n    \tp.xyzw *= clamp(max(Radius/dot(p.xyz, p.xyz), Radius), 0.0, 1.0);\n        if(i < 2) p.xyz *= Rotation;\n    \tp.xyzw = p*scalevec + p0;\n\t}\n\treturn (length(p.xyz) - C1) / p.w - C2;\n}\n\nvec3 normalEstimation(vec3 pos, float dist){\n  vec2 k = vec2(dist, 0);\n  return normalize(vec3(distanceEstimation(pos + k.xyy),\n\t  \t\t\t\t\tdistanceEstimation(pos + k.yxy),\n  \t\t\t\t\t\tdistanceEstimation(pos + k.yyx))\n\t\t\t\t - vec3(dist));\n}\nvec3 normalEstimation(vec3 pos){\n  float dist = distanceEstimation(pos);\n  return normalEstimation(pos, dist);\n}\n\nvec3 backgroundColor(vec3 dir){\n    return texture(iChannel0, dir).rgb;\n}\n\n//blurred cubemap for ambient lighting\nvec3 backgroundColorHemi(vec3 dir){\n    return textureLod(iChannel0, dir, 9.5).rgb;\n}\n\nvec3 directLight(vec3 pos, vec3 normal){\n    float dotLight = -dot(normal, LightDir);\n    if(dotLight < 0.0) return vec3(0);\n    vec3 pos0 = pos;\n    float minAngle = LightRadius;\n    for(int i = 0; i < MaxShadowSteps; i++){\n        float dist = distanceEstimation(pos);\n        if(dist > MaxDist) break;\n        if(dist < MinDist) return vec3(0.0);\n        pos -= LightDir * dist * 3.0;\t//goes 3 times faster since we don't need details\n        minAngle = min(asin(dist/length(pos-pos0)), minAngle);\n    }\n    return LightColor * dotLight * clamp(minAngle/LightRadius, .0, 1.0);\n}\n\nvec3 ambientLight(vec3 pos){\n    vec3 pos0 = pos;\n    float dist0 = distanceEstimation(pos);\n    vec3 normal = normalEstimation(pos).xyz, gi, al = vec3(0.0);\n    float ao = 1., dist = dist0;\n    for(int i = 0; i < AmbientLightSteps; i++){\n        float expectedDist = dist * (1. + .8);\n        dist = distanceEstimation(pos);\n        float weight = AOStrength*(1.-float(i)/float(AmbientLightSteps));\t//more weight to first samples\n        ao *= pow(clamp(dist/expectedDist, 0., 1.0), weight);\n        normal = normalize(normalEstimation(pos, dist)+1.5*normal); //\"smoothed\" normal to avoid artifacts\n        pos += normal * .8*dist; //slightly shorter to avoid artifacts\n        al += backgroundColorHemi(normal);\n        if(i == 6 || i == 13) gi += ao*directLight(pos, normal); // two GI samples\n    }\n    gi *= GIStrength/2.0;\n    return gi + al/float(AmbientLightSteps) * ao;\n}\n\nbool trace(inout vec3 pos, in vec3 dir, out vec3 n){\n    for(int i = 0; i < MaxSteps; i++){\n        float dist = distanceEstimation(pos);\n        if(dist > MaxDist) break;\n        if(dist < MinDist){\n            n = normalEstimation(pos);\n            for(int j = 0; j < 3; j++){\n                dist = distanceEstimation(pos) - 2.*MinDist;\n        \t\tpos += dist * dir;\n            }\n            return true;\n        }\n        pos += dir * dist;\n    }\n    return false;\n}\n\n\nvec4 rayTrace(vec3 pos, vec3 dir){\n    for(int i = 0; i < 5; i++){ //to get to a distance inferior to MaxDist\n        float dist = distanceEstimation(pos);\n        pos += dist * dir;\n        if(dist < MaxDist) break;\n    }\n    vec3 n;\n    if(!trace(pos, dir, n))\n        return vec4(backgroundColor(dir), 20.0);\n    return vec4(directLight(pos, n)+ambientLight(pos), length(CamPos - pos));\n}\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float time = iTime + 43.;\n    \n    //fractal animation\n    Rotation = rotationMatrix(vec3(time, time*.7, time*.4)*.2);\n    Scale += sin(time*.5)*.25;\n    Radius += cos(time) *.25;\n    \n    //light animation\n    LightDir = normalize(vec3(sin(time*.6), -1, cos(time*.6)));\n    \n    //camera animation\n    CamRot.z = sin(time*.4)*.2;\n    \n    vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n    vec3 rayDir = normalize(vec3(uv, CamFocalLength)) * rotationMatrix(CamRot);\n\n    fragColor = rayTrace(CamPos, rayDir);\n    \n}", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "//extremely basic atmosphere\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir ){\n    float factor = pow(abs(rayDir.y), .5)*sign(rayDir.y)*.5+.5;\n\tvec3 col = vec3(.5 + (0.5 * sin(iTime/3.14159265359)), .5 + (0.5 * (cos(iTime/1.570796326795))), .5 + (0.5 * (sin(iTime/6.28318530718)))) * factor + vec3(1.2) * (1.0*factor);\n    fragColor = vec4(col, 1.0);\n//}\n// float factor = pow(abs(rayDir.y), .5)*sign(rayDir.y)*.5+.5;\n\tvec3 coloro = vec3(.5 - (0.5 * (cos(iTime/6.28318530718))), .5 - (0.5 * (sin(iTime/3.14159265359))), .5 - (0.5 * (cos(iTime/1.570796326795)))) * factor * vec3(1.2) * (1.0/factor);\n//    fragColor = vec4(col, 1.0);\n//void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n//{\n    vec3 skyCol = vec3(80,180,255)/ 255.0;\n    vec3 horizonCol = vec3(255,255,255)/ 255.0;\n//    vec3 groundCol = vec3(0,0,35)/ 255.0;\n    vec3 groundCol = coloro;\n    \n    vec3 sunCol = vec3(1.0, 1.0, 1.0);\n    float sunSize = 0.0005;\n    float sunBlur = 0.0025;\n    float sunScatter = 0.25;\n    \n    vec3 moonCol = vec3(1.0, 1.0, 1.0);\n    float moonSize = 0.00025;\n    float moonGlow = 0.05;\n    float moonShadow = 0.5;\n    float starSize = 0.04;\n    \n    vec3 sunPos = _sunPos(iTime); \n    vec3 moonPos = _moonPos(iTime);\n    vec3 sunDir = normalize(sunPos - rayOri); \n    vec3 moonDir = normalize(moonPos - rayOri); \n    float pitch =  0.5 + rayDir.y * 0.5;\n    \n    // sky\n    // -----------------------------------------------------------\n    vec3 colo = skyCol;\n    horizonCol = mix (vec3(255,55,0)/ 255.0, vec3(255,255,255)/ 255.0, smoothstep(-0.5, 0.75, sunPos.y));\n    horizonCol = mix (vec3(55,155,155)/ 255.0, horizonCol, smoothstep(-0.5, 0.0, sunPos.y));        \n    col = mix(horizonCol, col, smoothstep(0.4, 0.8, pitch));    \n    col = mix(groundCol, col, smoothstep(0.49, 0.5, pitch));\n    \n    // sun\n    // ------------------------------------------------------------\n    sunCol = mix(vec3(255,85,0)/ 255.0, vec3(255,255,255)/ 255.0, max(0.0, min(1.0, smoothstep(-0.4, 0.8, sunPos.y))));\n    float sun = dot(sunDir, rayDir);    // return [-1,1] based on angle \n    sunSize += sunSize * 100.0 * (1.0-smoothstep(-0.8, 0.11, sunPos.y)); // scale sun based on height\n    float sunDisk = smoothstep((1.0 - sunSize) - sunSize*2.0, 1.0 - sunSize, sun); // define sun disk\n    sunScatter = smoothstep((1.0 - sunSize) - sunScatter, 1.0 - sunSize, sun) *  smoothstep(-0.8, 0.2, sunPos.y); \n    float sunGlow = smoothstep((1.0 - sunSize) - sunBlur, 1.0 - sunSize, sun);\n\n    float haloSize = 0.02;\n    float sunHalo = smoothstep(0.9999 - haloSize, 0.9999, sun);\n    sunHalo = mix(0.055, 0.05, fract(sunHalo*2.) );\n\n    //float angle = acos( dot(sunDir, rayDir) / (length(sunDir)*length(rayDir)) );\n    //float sunFlare = smoothstep((1.0 - sunSize*2.0) - 0.05*smoothstep(0.0, 3.14*.25,angle*10.) , 1.0 - sunSize*2.0, sun);\n    float horizonMask = smoothstep( -0.2, 0.05, rayDir.y); // mask sun along horizon\n    sunDisk *= smoothstep( -0.05, 0.025, rayDir.y);\n    sunGlow *= smoothstep( -0.05, 0.025, rayDir.y);\n    sunHalo *= smoothstep( -0.2, 0.05, rayDir.y); // mask sun along horizon\n    \n    col = mix(col, sunCol, sunScatter*.25);\n    col = mix(col, sunCol, sunGlow*.5);\n    col += sunDisk + sunScatter*.05 + sunGlow*.05;\n    col += vec3(sunHalo*6.0, 0.0,0.0);\n\n    // night\n    // ------------------------------------------------------------\n    col *= max(0.35, min(1.0, smoothstep(-1.0, 0.0, sunPos.y)));\n    \n    // stars\n    // ------------------------------------------------------------\n    float starNoise = random3D( rayDir, vec3(0.5,0.1,7.0+ iTime*0.001));\n    vec2 starCoords = vec2(fract(rayDir.x * 50.0), fract(rayDir.y * 50.0) );  \n    float stars = step(0.6, starCoords.y) * (1.0-step(0.6 + starSize, starCoords.y)) * step(0.3, starCoords.x) * (1.0- step(0.3 + starSize, starCoords.x));\n    stars *= smoothstep(-0.01, 0.00, rayDir.y);\n    col += stars * pow(starNoise, 3.0) * (1.0-max(0.0, min(1.0, smoothstep(-1.0, 0.0, sunPos.y))));\n       \n    horizonMask = smoothstep( -0.01, 0.01, rayDir.y); // mask sun along horizon\n    // moon\n    // -------------------------------------------------------------\n    float moon = dot(moonDir, rayDir);\n    moonShadow = mix(-0.05, -0.0, moonShadow);\n    moonShadow = dot(vec4(rotY(moonShadow)*vec4(moonDir,1.0)).xyz, rayDir);\n    float moonDisk = smoothstep(1.0-moonSize-0.00025, 1.0-moonSize, moon); \n    moonShadow = smoothstep(1.0-moonSize*2.0-0.00025, 1.0-moonSize*2.0, moonShadow); \n    moonDisk *= (1.0 - moonShadow*.995) * horizonMask  * smoothstep(0.0, 0.3, moonPos.y);    \n    col = mix(col, moonCol, moonDisk);\n    col += moonDisk;\n    \n    moonGlow = smoothstep(1.0-moonSize-moonGlow, 1.0-moonSize, moon) * horizonMask  * smoothstep(0.0, 0.3, moonPos.y); \n    col = mix(col, moonCol, moonGlow*.025) ; \n    \n    \n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//first DoF pass\n\n#define Aperture .025\n#define DoFClamping .35\n#define DoFSamples 64\n\n#define dir normalize(vec2(1.0, 1.0))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //autofocus\n    float focalDistance = texture(iChannel0, vec2(.5), 5.0).a;\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*Aperture)/iResolution.xy);\n        dr = min(abs(p.a-focalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*Aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//second DoF pass\n\n#define Aperture .025\n#define DoFClamping .35\n#define DoFSamples 64\n\n#define dir normalize(vec2(1.0, -1.0))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //autofocus\n    float focalDistance = texture(iChannel0, vec2(.5), 5.0).a;\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*Aperture)/iResolution.xy);\n        dr = min(abs(p.a-focalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*Aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Pi  3.14159265359\n\n#define FocalDistance 1.4\n#define LensRatio 30.5\n#define Margins .10\n\n\nfloat _viewDepth = -1.;\n\nvec3 _sunPos (float time)\n{\ntime = time * .05;\n    // cos(time*0.25)*0.85, sin(time*0.25)*0.6-0.2, 0.0\n    return vec3(-0.6+sin(time*0.2), cos(time*0.2), sin(time*0.2) );       \n}\n\nvec3 _moonPos (float time)\n{\n    time = time * .5;\n    time -= 5.;\n    return vec3(-2.0+sin(time*0.2)*1.5, cos(time*0.2), sin(time*0.2) );          \n}\n\n\n// interpolation\nfloat gaussianInterpol (float t, float a, float b, float c)\n{\n    // a - amplitude, b - center pos, c - frequency\n    return a * exp(-(t-b)*(t-b) / (2.0*c*c));\n   \n}\n\n// fractal noise\n\nfloat random3D(vec3 xyz, vec3 dir)\n{\n    float val = dot(xyz, dir);\n    return fract(30.0 * sin(val));\n}\n\n\n// transformations\n\nmat4 rotX(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( 1.0,        0.0,        0.0, 0.0),\n        vec4( 0.0, cos(angle), sin(angle), 0.0),\n        vec4( 0.0,-sin(angle), cos(angle), 0.0),\n        vec4( 0.0,        0.0,        0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\nmat4 rotY(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( cos(angle), 0.0, -sin(angle), 0.0),\n        vec4(        0.0, 1.0,         0.0, 0.0),\n        vec4( sin(angle), 0.0,  cos(angle), 0.0),\n        vec4(        0.0, 0.0,         0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\nmat4 rotZ(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( cos(angle), sin(angle), 0.0, 0.0),\n        vec4(-sin(angle), cos(angle), 0.0, 0.0),\n        vec4(        0.0,        0.0, 1.0, 0.0),\n        vec4(        0.0,        0.0, 0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\n// math utils\nfloat magnitude(vec3 a)\n{\n    return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);\n}\n\nvec3 normalized(vec3 a)\n{\n    return a/length(a);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldSWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 123, 123, 263], [265, 265, 322, 322, 627], [792, 792, 812, 812, 891], [893, 893, 917, 917, 1057], [1059, 1059, 1116, 1116, 2584]], "test": "untested"}
{"id": "NttXWl", "name": "nahkd's Flying Particles", "author": "nahkd123", "description": "Flying particles loop. By combining multiple particles layers (a.k.a \"batches\") and apply some sort of \"time offset\" for each layer, I can create seamless loop. Quite good for screensaver.", "tags": ["particles"], "likes": 12, "viewed": 488, "published": 3, "date": "1639991536", "time_retrieved": "2024-07-30T18:41:10.031454", "image_code": "vec4 background(vec2 uv) {\n    return mix(vec4(.18, .10, 0, 1), vec4(.28, .12, .05, 1), uv.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = background(uv) + texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.141592653589793238462643383279502884197169399375105820974944592\n#define DEPTH_MAX_DIFF 0.1\n#define DEPTH_INIT_MIN 0.1\n#define DEPTH_INIT_MAX 0.2\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// From noise to random location\nvec3 randomPosition(float seed, int index) {\n    return vec3(\n        rand(vec2(seed, index * 2)),\n        rand(vec2(-seed, index)),\n        rand(vec2(2.0 * seed, index))\n    );\n}\n\nfloat calcNextDepth(float initial, float generatedNext) {\n    float generatedDiff = generatedNext - initial;\n    if (generatedDiff < 0.0) return initial - 0.1;\n    return initial + 0.1;\n}\n\nfloat calcProgress(float from, float to, float iTime) {\n    float duration = to - from;\n    return clamp((iTime - from) / duration, 0.0, 1.0);\n}\n\nvec3 randomParticle(float timeFrom, float timeTo, float iTime, int seed) {\n    float p = calcProgress(timeFrom, timeTo, iTime);\n    vec3 posA = randomPosition(0.0, seed) * 2.0 - 1.0;\n    vec3 posB = randomPosition(1.1, seed) * 2.0 - 1.0;\n    vec3 posCurr = mix(posA, posB, p);\n    vec2 pos = posCurr.xy;\n    \n    float depthCurr = clamp((posA.z + 1.0) / 2.0, DEPTH_INIT_MIN, DEPTH_INIT_MAX);\n    float depthNext = calcNextDepth(depthCurr, (posB.z + 1.0) / 2.0);\n    float depth = mix(depthCurr, depthNext, p);\n    return vec3(pos, depth);\n}\n\nfloat calcFade(float from, float to, float iTime) {\n    float p = calcProgress(from, to, iTime);\n    return sin(p * PI);\n}\n\nvec4 circle(vec2 uv, vec2 xy, float radius, float resolution) {\n    return clamp(\n        vec4(distance(uv, xy) > radius? 0.0 : 1.0) * 0.5 +\n        vec4(distance(uv, xy) > radius + 1.0 / resolution? 0.0 : 1.0) * 0.5,\n    0.0, 1.0);\n}\n\n", "buffer_a_code": "#define PARTICLE_LIFETIME 3.5\n#define PARTICLES_BATCH_TIME 5.0\n#define PARTICLES_PER_BATCH 12\n\nvec4 particlesBatch(vec2 uv, float t, int shift) {\n    t = mod(t, PARTICLES_BATCH_TIME);\n    vec4 col = vec4(0);\n    for (int i = 0; i < PARTICLES_PER_BATCH; i++) {\n        float particleStart = float(i) * 0.1;\n        float particleEnd = particleStart + PARTICLE_LIFETIME;\n        if (t < particleStart || t > particleEnd) continue;\n        \n        vec3 part = randomParticle(particleStart, particleEnd, t, i + shift);\n        float radius = clamp(part.z / 9.0, 0.01, 0.1);\n        \n        vec4 particleCol = circle(uv, part.xy, radius, iResolution.x) * 4.2;\n        col += particleCol * (part.z + 0.05) * calcFade(particleStart, particleEnd, t);\n    }\n    return col;\n}\n\nvec4 particles(vec2 uv, float t) {\n    vec4 col = vec4(0);\n    int lastIdx = 0;\n    for (float tShift = 0.0; tShift < PARTICLES_BATCH_TIME; tShift += 1.0) {\n        col += particlesBatch(uv, t - tShift, lastIdx);\n        lastIdx += PARTICLES_PER_BATCH + 3;\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy - 0.5) * vec2(iResolution.x / iResolution.y * 2.0, 2);\n    uv /= 2.0;\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy) * 0.2 + particles(uv, iTime) * vec4(1, 0.79, 0.52, 1.0) * 0.8;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NttXWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 96], [98, 98, 153, 153, 254]], "test": "untested"}
{"id": "sl3XDs", "name": "iFrame testing", "author": "davidar", "description": "Nothing to see here, just testing how shadertoy initialises iFrame in different circumstances\n\nMain player: iFrame=0\nPreview: iFrame=1\nEmbedded player: iFrame=1", "tags": ["test", "iframe"], "likes": 3, "viewed": 817, "published": 3, "date": "1639988363", "time_retrieved": "2024-07-30T18:41:10.816355", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int i = int(5.*fragCoord.x/iResolution.x);\n    int iFrame0 = int(texture(iChannel0, vec2(0)).x) + 100;\n    fragColor = vec4(i == iFrame0, i == iFrame, 0,0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(min(float(iFrame-100), texture(iChannel0,vec2(0)).x));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3XDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 220]], "test": "untested"}
{"id": "7l3SWs", "name": "texture_lighting_test", "author": "lambmeow", "description": "testing texture mapping with more complex shapes.\n12/20/2021 - fixed lighing a bit", "tags": ["sdf", "texture", "lighting", "wood"], "likes": 8, "viewed": 290, "published": 3, "date": "1639979270", "time_retrieved": "2024-07-30T18:41:11.691016", "image_code": "mat2 rot(float a) { \n    float ca = cos(a), sa = sin(a);\n    return mat2(ca, -sa, sa, ca);\n}\n\nvec2 ss(vec3 p, vec3 l)\n{\n    //p.x = abs(p.x);\n    float sph = length(p - l) - 0.2;\n    p.x = sin(p.x );\n    p.y = abs(sin(p.y));\n    p.x = mod(p.x + 2.25, 4.5) - 2.25;\n    \n   \n    for(int i = 0; i < 3; i ++)\n    {\n        p.xy *= rot(p.y + iTime + float(i) * 0.5);\n    }\n    p.yz += 0.30 * sin(iTime * 2. + p.z);\n\n   float res = min(length(p.xy) - .75, sph);\n   return vec2(res, res == sph);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r = iResolution.xy, uv= (2. * fragCoord.xy - r)/r.y;\n    vec3 pos = vec3(0), \n    ro = vec3(3.141529/2. + sin(iTime  + 0.5) * 0.5, \n    11. + cos(iTime + 0.4) *0.25, \n    iTime * 1.5), \n    rd = normalize(vec3(uv, 2.));\n    rd.xy *= rot(iTime * 0.25);\n    float ll = 0.;\n    vec3 lpos = ro + vec3(sin(iTime + 3.5235) * 0.5 + 1., cos(iTime) * 0.53, 3);\n    vec2 dd = vec2(0);\n    float cc = 100.;\n    for(int i = 0; i < 255; i ++)\n    {\n        pos = ro + rd * ll;  \n        dd = abs(ss(pos, lpos));\n        ll += dd.x;\n        cc = min(cc, length(pos - lpos) - 1.);\n        \n        if ( ll > 100. || dd.x < 0.001) break;   \n    }\n    if(dd.y == 1.)\n        fragColor = vec4(1);\n    else if(ll > 100.)\n        fragColor =  vec4(0);\n    else\n    {\n        \n    vec3 n = vec3(0);\n    for(int i = 0; i < 4; i++)\n    {\n        vec3 eps = 0.001 * (vec3(9 >> i&1, i >> 1 & 1, i & 1) * 2. - 1.);\n        n += eps * ss(pos + eps, lpos).x;\n    }\n    \n    n = normalize(n);\n    \n    float x = mod(pos.x + 1.5, 3.) - 1.5; \n    vec3 lv = lpos - pos; \n    float d = length(lv),ndl = max(dot(normalize(lv) , n), 0.0) , a =1./(1. + d * 0.1 + d * d * 0.025);\n    \n    vec4 color = texture(iChannel0, vec2(atan(pos.y/x) , pos.z));\n    fragColor = vec4(ndl) * color;\n    fragColor += vec4(max(pow(dot(n, normalize(n + normalize(lv))), 200.),0.) ) * (color.r+ color.g + color.z)/7.;\n    fragColor *= max(1./(1.+cc),0.);\n    fragColor *= a;\n    \n    \n\n    }\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3SWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 92], [94, 94, 119, 141, 490], [491, 491, 548, 548, 1997]], "test": "untested"}
{"id": "7t3SDf", "name": "Simplest detailed fluid", "author": "davidar", "description": "Golfing lomateron's fluid shader down to 30% of the original size, and a single buffer", "tags": ["simulation", "fluid", "convolution", "2tweets", "golf"], "likes": 65, "viewed": 1278, "published": 3, "date": "1639977359", "time_retrieved": "2024-07-30T18:41:12.445998", "image_code": "M {\n    r = 1.-A().zzzz;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "M {\n    r *= 0.;\n    for(vec2 i = vec2(-7); ++i.x < 7.;) for(i.y = -7.; ++i.y < 7.;) {\n        vec2 v = A(i).xy;                          // neighbour velocity\n        r += A(i).z                                // neighbour mass\n                * exp(-dot(v+i,v+i)) / 3.14        // normalised Gaussian\n                * vec4(mix(v+v+i, v, A(i).z),1,1); // velocity contribution\n    }\n    r.xy /= r.z + 1e-6;\n    if(iFrame % 500 == 1) {\n        vec2 m = 4.*u/iResolution.xy-2.;\n        r += vec4(m,1,0) * exp(-dot(m,m));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define M void mainImage(out vec4 r, vec2 u)\n#define A(i) texelFetch(iChannel0,ivec2(i+u),0)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3SDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NtcXDl", "name": "noise pattern thingy", "author": "SnoopethDuckDuck", "description": "basic idea:\nhttps://www.shadertoy.com/view/NlcSDs", "tags": ["e"], "likes": 4, "viewed": 265, "published": 3, "date": "1639954904", "time_retrieved": "2024-07-30T18:41:13.194995", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat h21 (vec2 p, float sc) {\n    p.x = mod(p.x, sc); p.y = mod(p.y, sc);\n    return fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat rand(vec2 ipos, vec2 fpos, float sc) {\n    // V2:\n    //float val = atan(fpos.y, fpos.x) + 8. * length(fpos - 0.5) + h21(ipos, sc) + iTime;\n    float val = length(fpos - 0.5) + h21(ipos, sc) + iTime;\n    \n    float v1 = h21(floor(val) + ipos,      sc);\n    float v2 = h21(floor(val) + ipos + 1., sc);\n    \n    float m = fract(val);\n    m = m * m * (3. - 2. * m);\n   \n    return mix(v1, v2, m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/ iResolution.y;\n    uv += 2. + 0.02 * iTime;\n    \n    float c = 30.;\n    float sc = 6.;\n    \n    vec2 ipos = floor(sc * uv) + 0.5;  \n    vec2 fpos = fract(sc * uv) - 0.;\n    \n    // Corner positions\n    vec2 lp  = ipos + vec2(1,0);\n    vec2 tp  = ipos + vec2(0,1);\n    vec2 tlp = ipos + vec2(1,1);  \n    vec2 idp = ipos + vec2(0,0);\n\n    // Generate values for each corner of uv\n    float sc2 = c * sc;\n    float l  = rand(lp,  fpos, sc2);\n    float t  = rand(tp,  fpos, sc2);\n    float tl = rand(tlp, fpos, sc2);\n    float id = rand(idp, fpos, sc2);\n\n    // Smooth fpos so boundaries meet smoothly\n    vec2 sfpos = fpos * fpos * (3. - 2. * fpos);\n    \n    // Box lerp between the corner values\n    float v = l  * sfpos.x      * (1.-sfpos.y)\n     \t    + t  * (1.-sfpos.x) * sfpos.y\n     \t    + tl * sfpos.x      * sfpos.y\n      \t    + id * (1.-sfpos.x) * (1.-sfpos.y);\n\n    fpos -= 0.5;\n    // mlength on its own works fine too\n    float d = mlength(fpos) + 0.8 * abs(fpos.x) + 0.5 * cos(10. * v + iTime);\n    float k = v; //+ cos(10. * d -iTime); // <- V2\n    float s = smoothstep(-k, k, d - 2. * v);\n    s = mix(2., 10., 0.5 + 0.5 * thc(4., 100. * v + iTime)) * s * s;\n\n    vec3 e = vec3(1);\n    vec3 col = s * pal(v, e, e, e, 0.25 * vec3(0.,0.33, 0.66));\n    col += 0.05;\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtcXDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 191, 191, 232], [234, 234, 261, 261, 302], [304, 304, 372, 372, 415], [417, 417, 437, 437, 512], [514, 514, 544, 544, 661], [663, 663, 687, 687, 727], [729, 729, 773, 874, 1130], [1132, 1132, 1189, 1189, 2546]], "test": "untested"}
{"id": "NtcXWl", "name": "Hand drawn/rotoscope effect", "author": "menis", "description": "A rotoscope effect using your webcam. ", "tags": ["webcam", "outlines", "outline", "cool", "rotoscope", "handdrawn"], "likes": 9, "viewed": 719, "published": 3, "date": "1639942911", "time_retrieved": "2024-07-30T18:41:13.954963", "image_code": "#define A texture(iChannel0, v/iResolution.xy).r\nvoid mainImage(out vec4 o, vec2 u) {\n\tvec2 v=u;\n    o += 27.4*(.05-length(A-vec2( (v.x++,A),(v.x--,v.y++,A) )));}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 O, vec2 u) {\n\tvec2 U=u/iResolution.xy;\n    O = mod(iChannelTime[3],.5) < .03 ? texture(iChannel1,U) : texture(iChannel0,U); }\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtcXWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 85, 85, 162]], "test": "untested"}
{"id": "7ldXDf", "name": "Distortion illusion", "author": "golinad", "description": "Ring appearing to shrink/grow due to moving texture.", "tags": ["optical", "illusion"], "likes": 5, "viewed": 236, "published": 3, "date": "1639942386", "time_retrieved": "2024-07-30T18:41:14.706953", "image_code": "// click / drag in image left/right to let the ring shrink/grow\n#define PI 3.14159265359\nfloat rps = 8.0; // rounds per second\nfloat edgeDelay = 20.0; // positive: grow, negative: shrink\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float edgeDelay = (iMouse.x / iResolution.x - 0.5) * 100.0;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 pos = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 uv = pos;\n\n\n    // ring\n    float dist = abs(length(pos) - 0.3);\n    float hit = smoothstep(0.05, 0.04, dist);\n    float edgeHit = smoothstep(0.9, 0.00, hit);\n    \n    // Time varying pixel color\n    vec3 fillCol = pow(0.6 + 0.4*sin(iTime*-PI*rps + atan(uv.x, uv.y)), 1.0)*vec3(1);\n    vec3 edgeCol = pow(0.6 + 0.4*sin(iTime*-PI*rps + atan(uv.x, uv.y) + (length(pos) - 0.3)*edgeDelay), 1.0)*vec3(1);\n    vec3 bgCol = vec3(0.5);\n    \n    // Output to screen\n    fragColor = vec4(mix(bgCol, mix(fillCol, edgeCol, edgeHit), hit),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldXDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 188, 245, 245, 965]], "test": "untested"}
{"id": "stdSDf", "name": "random gallery", "author": "SnoopethDuckDuck", "description": "example using this idea: \nhttps://www.shadertoy.com/view/7tdSDX\n\ni like the colors\n\nmore readable version: https://www.shadertoy.com/view/43GGDK", "tags": ["e"], "likes": 54, "viewed": 862, "published": 3, "date": "1639936131", "time_retrieved": "2024-07-30T18:41:15.455950", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat rand(float val, vec2 ipos) {\n    float v = h21(floor(val) + 0.01 * ipos);\n    float v2 = h21(floor(val) + 1. + 0.01 * ipos);\n    float m = fract(val);\n    m = m * m * (3. - 2. * m); // could use different function here\n    return mix(v, v2, m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n        \n    float sc = 7.;\n    uv.x += 0.04 * iTime;\n    uv.y -= cos(1.1 * floor(sc * uv.x) + 0.05 * iTime);\n     \n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = sc * uv - ipos;\n    \n    // could use rand(,) instead of h21() here but it gets chaotic when u stack them\n    float a = 2. * pi * h21(ipos);\n    float val0 = h21(ipos) - 10. * (cos(a) * uv.x + sin(a) * uv.y) - 0.1 * iTime;\n    float v0 = rand(val0, ipos);\n    \n    float val = h21(ipos) - 2.5 * v0 * thc(4., v0 * 10. * length(fpos)) - 0.5 * iTime;\n    float v = rand(val, ipos);\n    \n    float rd = 0.5 * v;\n    float t = 10. * v + length(fpos) * 10. * v0 - iTime;\n    vec2 p = (0.5 - rd) * vec2(cos(t), sin(t));\n    \n    float d = length(fpos - p);\n    float k = 0.5;\n    float s = smoothstep(-k, k, -d + rd);\n    s = 2. * s * s * s;\n    vec3 col = vec3(s);\n    \n    vec3 e = vec3(1.);\n    col = s * pal(4. * v + d, e, e, e, 0.5 * vec3(0.,0.33,0.66));\n    col += 0.1;\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdSDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 191, 191, 232], [234, 234, 261, 261, 302], [304, 304, 372, 372, 415], [417, 417, 437, 437, 512], [514, 514, 538, 538, 578], [580, 580, 614, 614, 832], [834, 834, 891, 891, 1928]], "test": "untested"}
{"id": "sttSWf", "name": "Testfeld", "author": "vapoi", "description": "just playing around", "tags": ["2d", "simple"], "likes": 2, "viewed": 176, "published": 3, "date": "1639931513", "time_retrieved": "2024-07-30T18:41:16.205945", "image_code": "const float fPi = 3.14159;\n\nfloat GetStar(vec2 p, float fTime)\n{\n    float fLength = length(p);\n    // fAngle 0.0 bis 1.0:\n    float fAngle = (atan(p.y, p.x) * 0.5) / fPi + 0.5;\n       \n    \n    float fWrinkle = fract(fAngle * 5.0 + fTime);\n    \n    return 0.6 * smoothstep(-0.3, 0.2, fWrinkle) * smoothstep(-2.0, 0.25, -fLength) ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Koordinaten -1.0 bis 1.0 (x-Achse bei Breitbild entsprechend mehr)\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - vec2(1.0, 1.0);\n    uv.x /= iResolution.y / iResolution.x;\n\n    float fTime = iTime * 0.2;\n    float fValue = 0.0;\n    \n    vec2 pos = vec2(0.0);\n    float fi = 0.0;\n    vec2 vDiss = vec2(0.0);\n   \n    for (int i = 0; i < 6; i++)\n    {\n        fi = float(i) * 0.3;\n        vDiss = vec2(0.12 * cos(fTime * -fi * 0.7), \n                     0.32 * sin(fTime * fi * 1.3));\n        \n        \n        pos = 0.3 * vec2(sin(fTime + fi + vDiss.x),\n                         cos(fTime - fi + vDiss.y));\n        fValue += GetStar(uv + pos, fTime);\n    }\n    \n    \n    float fColorSwitch = smoothstep(-0.3, 0.3, cos(fTime * 3.0 + fPi));\n    //fValue *= fColorSwitch + 0.2;\n    vec3 useColor = mix(vec3(0.2), vec3(0.9, 0.5, 0.25), fColorSwitch);\n    \n\n    vec3 color = fValue * useColor;\n    \n    // Pixel setzen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttSWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 64, 64, 333], [336, 336, 393, 467, 1351]], "test": "untested"}
{"id": "7tdSDX", "name": "nice technique 2", "author": "SnoopethDuckDuck", "description": "spent ages making a nice example with this, then PC crashed :(\n\nu could use v for any kind of cell property, e.g. circle radius, offsetting a trajectory, color,\neach cell changes randomly \"independently\" of the others", "tags": ["e"], "likes": 10, "viewed": 395, "published": 3, "date": "1639928016", "time_retrieved": "2024-07-30T18:41:16.955939", "image_code": "// issue: \n// floor(val) + ipos gives it a diagonal bias (not always noticeable)\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    float sc = 24.;\n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = sc * uv - ipos;\n    \n    // you can put anything here\n    float val = h21(ipos) - iTime;\n    // val = h21(ipos) - 10. * uv.y - iTime;\n    \n    // Gives each cell a fixed angle (removes diagonal bias)\n    /*\n    float a = 2. * 3.14159 * h21(ipos);\n    float c = cos(a); \n    float s = sin(a);\n    \n    // current value (using 0.01 so it looks \"random\" for longer)\n    float v = h21(vec2(c * floor(val), s * floor(val)) + 0.01 * ipos);\n    // next value\n    float v2 = h21(vec2(c * (floor(val) + 1.), s * (floor(val) + 1.)) + 0.01 * ipos);\n    */\n    \n    // current value (using 0.01 so it looks \"random\" for longer)\n    float v = h21(floor(val) + 0.01 * ipos);\n    // next value\n    float v2 = h21(floor(val) + 1. + 0.01 * ipos);\n    \n    // smooth lerp between values\n    float m = fract(val);\n    m = m * m * (3. - 2. * m);\n    v = mix(v, v2, m);\n    \n    fragColor = vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdSDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 102, 102, 177], [179, 179, 236, 236, 1256]], "test": "untested"}
{"id": "sltXWX", "name": "In the bathroom", "author": "IWBTShyGuy", "description": "A bath taken in the middle of the night.\nIt was a place of relaxation, but also a bit of anxiety.", "tags": ["3d", "modeling"], "likes": 17, "viewed": 429, "published": 3, "date": "1639924754", "time_retrieved": "2024-07-30T18:41:17.920361", "image_code": "// Copyright  2021 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n// Uncommenting this macro will enable anti-aliasing.\n// However, it takes a long time to compile\n// (less than 30 seconds on my machine with Windows 10 and RTX 2070).\n// #define AA 2\n\n/******************** Config ********************/\nconst vec3 CAMERA_POSITION = vec3(-2, -2, 6);\nconst vec3 CAMERA_DIRECTION = vec3(0.5, 0.25, -1.5); // <- will normalized\nconst float CAMERA_AMP = 0.005;\n\nconst float FAR = length(CAMERA_POSITION) * 2.0;\n\n// the main wall is always the plane z = 0\n\n// light\nconst float LIGHT_SCALE = 1.5;\nconst mat3 LIGHT_ROTATE = rotate3D(vec3(1, 0, 0), PI/2.0);\n// LIGHT_DISP does not exist. Light is always at the origin.\n\n// shower base\nconst float BASE_SCALE = 0.5;\nconst mat3 BASE_ROTATE =\n    rotate3D(vec3(0, 0, 1), PI / 2.0) * rotate3D(vec3(1, 0, 0), PI / 2.0);\nconst vec3 BASE_DISP = vec3(-1.2, -1.7, 0);\n\n// shower\nconst float SHOWER_SCALE = 0.6;\nconst mat3 SHOWER_ROTATE = rotate3D(vec3(1, 0, 0), PI / 6.0)\n        * rotate3D(vec3(0, 0, 1), -PI / 2.0)\n        * rotate3D(vec3(1, 0, 0), -PI / 2.0);\nconst vec3 SHOWER_DISP = vec3(-1.2, -1.4, 0.21);\nconst float SHOWER_HOLE_RADIUS = 6.0;\nconst float SHOWER_HOLE_THETA = 20.0;\n\n// mirror\nconst vec3 MIRROR_DISP = vec3(2, -3.5, 0);\n// Mirror is easy to model and directly tweak the SDF for scale and rotation.\n\n// hanger\nconst float HANGER_SCALE = 1.0;\nconst mat3 HANGER_ROTATE = rotate3D(vec3(0, 0, 1), PI / 2.0)\n        * rotate3D(vec3(0, 1, 0), PI / 2.0);\nconst vec3 HANGER_DISP = vec3(4.5, -2.2, 2.5);\n\n// after effect\nconst float LIGHT_FLICKER = 0.1;\nconst float STEAM = 0.025;\n\n/******************** Object SDFs ********************/\nfloat sdWall(in vec3 p) {\n    return p.z;\n}\n\nfloat sdLight(in vec3 p) {\n    vec3 q; // temporary\n\n    q = p - vec3(0, 0.05, 0.0);\n    float base = sdCylinder(q, 0.3, 0.05);\n\n    q = p - vec3(0, 0.3, 0.0);\n    float head = sdCylinder(q, 0.4, 0.15) - 0.05;    \n\n    return min(base, head);\n}\n\nfloat sdShowerBase(in vec3 p) {\n    vec3 q; // temporary\n    \n    float dist = sdTrape(p, 0.4, 0.3, 0.5);\n\n    q = rotate3D(vec3(0, 0, 1), PI / 2.0) * (p - vec3(0, 0.35, 0));\n    dist = max(dist, -sdCylinder(q, 0.2, 1.0));\n\n    return dist - 0.005;\n}\n\nfloat sdShower(in vec3 p) {\n    vec3 q; // temporary\n\n    // shower head\n    q = p + vec3(0.3, 0, 0);\n    float head = sdCylinder(q, 0.5, 0.1) - 0.1;\n\n    // shower nozzle\n    q = rotate3D(vec3(0,0,1), PI/1.5) * (p - vec3(0.15, 0, 0));\n    float nozzle = sdTrape(q, 0.2, 0.1, 0.4);\n\n    q = rotate3D(vec3(0, 0, 1), PI / 1.5) * (p - vec3(0.9, -0.43, 0)) - vec3(0, 1, 0);\n    float hose = sdCylinder(q, 0.1, 2.0);\n    return opSmoothUnion(opSmoothUnion(head, nozzle, 0.05), hose, 0.05);\n}\n\nfloat sdMirror(in vec3 p) {\n    float dist = sdBox(p, vec3(1, 2, 0.1)) - 0.1;\n    dist = max(dist, p.z - 0.1);\n    return dist;\n}\n\nfloat sdRightWall(in vec3 p) {\n    return 4.5 - p.x;\n}\n\nfloat sdHanger(in vec3 p) {\n    vec3 q; // temporary\n    float dist = 100.0;\n\n    q = p - vec3(-2, 0, 0);\n    dist = min(dist, sdCylinder(q, 0.1, 0.3) - 0.1);\n    q = p - vec3(2, 0, 0);\n    dist = min(dist, sdCylinder(q, 0.1, 0.3) - 0.1);\n    q = rotate3D(vec3(0, 0, 1), PI / 2.0) * (p - vec3(0, 0.2, 0));\n    dist = min(dist, sdCylinder(q, 0.1, 2.0));\n\n    return dist;\n}\n\n/******************** Macro utility ********************/\n#define DEF_RAYMARCHING(raymarch, sDist, LOOP_MAX) \\\nfloat raymarch(in Ray ray) {\\\n    float dist = 0.0;\\\n    for (int i = 0; i < LOOP_MAX; i++) {\\\n        vec3 p = ray.origin + dist * ray.direction;\\\n        float dist0 = sDist(p);\\\n        if (dist0 < 1.0e-6 || dist > FAR) break;\\\n        dist += dist0;\\\n    }\\\n    return dist;\\\n}\n\n// Take a sample point from the surface of the light and average it.\n#define DEF_SURFACE_LIGHTING(color, colorOneLight) \\\nvec3 color(in vec3 p, in Ray ray, in vec3 normal) {\\\n    int index = objectIndex(p);\\\n    float lightRadius = 0.4 * LIGHT_SCALE;\\\n    float lightDistance = length(p.xy);\\\n    float theta = acos(lightRadius / lightDistance);\\\n    vec3 col = vec3(0);\\\n    const int U_SAMPLE = 5;\\\n    const int V_SAMPLE = 3;\\\n    for (int i = 0; i < U_SAMPLE; i++) {\\\n        float u = float(i) / float(U_SAMPLE - 1);\\\n        u = theta * (2.0 * u - 1.0);\\\n        float cu = cos(u), su = sin(u);\\\n        mat2 mat = mat2(cu, su, -su, cu);\\\n        vec2 lpb = mat * normalize(p.xy) * lightRadius;\\\n        for (int j = 0; j < V_SAMPLE; j++) {\\\n            float h = float(j) / float(V_SAMPLE - 1);\\\n            h = (0.1 + 0.4 * h) * LIGHT_SCALE;\\\n            col += colorOneLight(p, ray, normal, vec3(lpb, h));\\\n        }\\\n    }\\\n    return col / float(U_SAMPLE * V_SAMPLE);\\\n}\n\n/******************** Global SDF ********************/\nfloat sDist(in vec3 p) {\n    vec3 q; // temporary\n\n    float dist = sdWall(p);\n\n    q = transpose(LIGHT_ROTATE) * p / LIGHT_SCALE;\n    dist = min(dist, sdLight(q) * LIGHT_SCALE);\n    \n    q = transpose(BASE_ROTATE) * (p - BASE_DISP) / BASE_SCALE;\n    dist = min(dist, sdShowerBase(q) * BASE_SCALE);\n\n    q = transpose(SHOWER_ROTATE) * (p - SHOWER_DISP) / SHOWER_SCALE;\n    dist = min(dist, sdShower(q) * SHOWER_SCALE);\n\n    q = p - MIRROR_DISP;\n    dist = min(dist, sdMirror(q));\n\n    dist = min(dist, sdRightWall(p));\n\n    q = transpose(HANGER_ROTATE) * (p - HANGER_DISP) / HANGER_SCALE;\n    dist = min(dist, sdHanger(q) * HANGER_SCALE);\n\n    return dist;\n}\n\nDEF_RAYMARCHING(raymarch, sDist, 256)\n\nvec3 calcNormal(in vec3 p) {\n    const vec2 e = vec2(0, 1.0e-4);\n    return normalize(vec3(\n        sDist(p + e.yxx) - sDist(p - e.yxx),\n        sDist(p + e.xyx) - sDist(p - e.xyx),\n        sDist(p + e.xxy) - sDist(p - e.xxy)\n    ));\n}\n\n/******************** coloring ********************/\nint objectIndex(in vec3 p) {\n    vec3 q;\n\n    float dist = sdWall(p);\n    if (dist < 1.0e-5) return 0;\n\n    q = transpose(LIGHT_ROTATE) * p / LIGHT_SCALE;\n    dist = sdLight(q) * LIGHT_SCALE;\n    if (dist < 1.0e-5) return 1;\n    \n    q = transpose(BASE_ROTATE) * (p - BASE_DISP) / BASE_SCALE;\n    dist = sdShowerBase(q) * BASE_SCALE;\n    if (dist < 1.0e-5) return 2;\n\n    q = transpose(SHOWER_ROTATE) * (p - SHOWER_DISP) / SHOWER_SCALE;\n    dist = sdShower(q) * SHOWER_SCALE;\n    if (dist < 1.0e-5) return 3;\n\n    q = p - MIRROR_DISP;\n    dist = sdMirror(q);\n    if (dist < 1.0e-5) return 4;\n\n    dist = sdRightWall(p);\n    if (dist < 1.0e-5) return 5;\n    \n    q = transpose(HANGER_ROTATE) * (p - HANGER_DISP) / HANGER_SCALE;\n    dist = sdHanger(q) * HANGER_SCALE;\n    if (dist < 1.0e-5) return 6;\n\n    return 7;\n}\n\nvec3 colWallOneLight(in vec3 p, in Ray ray, in vec3 normal, in vec3 lightPos) {\n    vec3 lightDir = normalize(p - lightPos);\n    float c = microfacet(normal, ray.direction, lightDir, 0.1, 0.8);\n\n    float shadow = 1.0, dist = 0.01,\n        lightDist = distance(p, lightPos), k = 2.0;\n    for (int i = 0; i < 32; i++) {\n        vec3 p0 = p - dist * lightDir;\n\n        float dist0; vec3 q;\n        q = transpose(BASE_ROTATE) * (p0 - BASE_DISP) / BASE_SCALE;\n        dist0 = sdShowerBase(q) * BASE_SCALE;\n\n        q = transpose(SHOWER_ROTATE) * (p0 - SHOWER_DISP) / SHOWER_SCALE;\n        dist0 = min(dist0, sdShower(q) * SHOWER_SCALE);\n\n        if (dist0 < 1.0e-2) {\n            shadow = 0.0;\n            break;\n        } else if (dist > lightDist) break;\n\n        shadow = min(shadow, k * dist0 / dist);\n        dist += dist0;\n    }\n\n    return vec3(c * (shadow + 0.1) / 1.1);\n}\n\nDEF_SURFACE_LIGHTING(colWall, colWallOneLight)\n\nvec3 colShowerBaseOneLight(in vec3 p, in Ray ray, in vec3 normal, in vec3 lightPos) {\n    vec3 lightDir = normalize(p - lightPos);\n    float c = microfacet(normal, ray.direction, lightDir, 0.2, 0.5) * 0.9;\n    c += microfacet(normal, ray.direction, ray.direction, 0.0, 0.5) * 0.1;\n\n    float shadow = 1.0, dist = 0.01,\n        lightDist = distance(p, lightPos), k = 2.0;\n    for (int i = 0; i < 64; i++) {\n        vec3 p0 = p - dist * lightDir;\n\n        float dist0 = 100.0; vec3 q;\n        q = transpose(BASE_ROTATE) * (p0 - BASE_DISP) / BASE_SCALE;\n        dist0 = sdShowerBase(q) * BASE_SCALE;\n\n        q = transpose(SHOWER_ROTATE) * (p0 - SHOWER_DISP) / SHOWER_SCALE;\n        dist0 = min(dist0, sdShower(q) * SHOWER_SCALE);\n\n        if (dist0 < 1.0e-3) {\n            shadow = 0.0;\n            break;\n        } else if (dist > lightDist) break;\n\n        shadow = min(shadow, k * dist0 / dist);\n        dist += dist0;\n    }\n\n    return vec3(c * (shadow + 0.1) / 1.1);\n}\n\nDEF_SURFACE_LIGHTING(colShowerBase, colShowerBaseOneLight)\n\nvec3 colShowerOneLight(in vec3 p, in Ray ray, in vec3 normal, in vec3 lightPos) {\n    float shadow = 1.0, dist = 0.05,\n        lightDist = distance(p, lightPos), k = 2.0;\n    vec3 lightDir = normalize(p - lightPos);\n    for (int i = 0; i < 64; i++) {\n        vec3 p0 = p - dist * lightDir;\n\n        float dist0 = 100.0; vec3 q;\n        q = transpose(BASE_ROTATE) * (p0 - BASE_DISP) / BASE_SCALE;\n        dist0 = sdShowerBase(q) * BASE_SCALE;\n\n        q = transpose(SHOWER_ROTATE) * (p0 - SHOWER_DISP) / SHOWER_SCALE;\n        dist0 = min(dist0, sdShower(q) * SHOWER_SCALE);\n\n        if (dist0 < 1.0e-3) {\n            shadow = 0.0;\n            break;\n        } else if (dist > lightDist) break;\n\n        shadow = min(shadow, k * dist0 / dist);\n        dist += dist0;\n    }\n\n    mat3 mat = transpose(SHOWER_ROTATE);\n    p = mat * (p - SHOWER_DISP) / SHOWER_SCALE;\n    normal = mat * normal;\n    lightPos = mat * (lightPos - SHOWER_DISP) / SHOWER_SCALE;\n    ray.direction = mat * ray.direction;\n    lightDir = normalize(p - lightPos);\n\n    k = length(p.zx + vec2(0.0, 0.3));\n    vec3 q = rotate3D(vec3(0, 0, 1), PI / 1.5) * (p - vec3(0.9, -0.43, 0));\n    float c;\n    if (p.y < 0.00001 && k < 0.5) {\n        vec2 r = (p.zx + vec2(0.0, 0.3)) / 0.5;\n        float r_int = (floor(length(r) * SHOWER_HOLE_RADIUS) + 0.5) / SHOWER_HOLE_RADIUS;\n        float theta = acos(clamp(normalize(r).x, -1.0, 1.0)) * sign(r.y);\n        c = 1.0;\n        k = length(r);\n        if ((theta < PI * 0.4 || PI * 0.6 < theta || k < 0.5) && k > 0.2) {\n            float theta_int = (floor(theta / (2.0 * PI) * SHOWER_HOLE_THETA) + 0.5);\n            theta_int *= 2.0 * PI / SHOWER_HOLE_THETA;\n            vec2 center = r_int * vec2(cos(theta_int), sin(theta_int));\n            c = clamp(distance(r, center) / 0.025, 0.0, 1.0);\n        }\n        c = microfacet(normal, ray.direction, ray.direction, 0.2, 0.8) * c * c * 0.3;\n    } else if (q.y < -0.43) {\n        c = microfacet(normal, ray.direction, lightDir, 0.2, 0.45) * 0.8;\n        c += microfacet(normal, ray.direction, ray.direction, 0.0, 0.5) * 0.2;\n    } else {\n        c = microfacet(normal, ray.direction, lightDir, 0.2, 1.0);\n    }\n    c = min(c, 1.0);\n\n    return vec3(c * (shadow + 0.1) / 1.1);\n}\n\nDEF_SURFACE_LIGHTING(colShower, colShowerOneLight)\n\nvec3 colMirrorSideOneLight(in vec3 p, in Ray ray, in vec3 normal, in vec3 lightPos) {\n    vec3 lightDir = normalize(p - lightPos);\n    float c = microfacet(normal, ray.direction, lightDir, 0.9, 0.3);\n    return vec3(c);\n}\n\nDEF_SURFACE_LIGHTING(colMirrorSide, colMirrorSideOneLight)\n\n// It is far enough away from the viewpoint and lights. The light is considered a point source.\nvec3 colRightWall(in vec3 p, in Ray ray, in vec3 normal) {\n    vec3 lightPos = vec3(0, 0, 0.4);\n    vec3 lightDir = normalize(p - lightPos);\n    float lightDist = distance(p, lightPos);\n    float c = microfacet(normal, ray.direction, lightDir, 0.1, 0.8) / (lightDist * lightDist * 0.05);\n\n    float shadow = 1.0, dist = 0.01, k = 2.0;\n    for (int i = 0; i < 32; i++) {\n        vec3 p0 = p - dist * lightDir;\n\n        float dist0; vec3 q;\n        q = transpose(HANGER_ROTATE) * (p0 - HANGER_DISP) / HANGER_SCALE;\n        dist0 = sdHanger(q) * HANGER_SCALE;\n\n        if (dist0 < 1.0e-2) {\n            shadow = 0.0;\n            break;\n        } else if (dist > lightDist) break;\n\n        shadow = min(shadow, k * dist0 / dist);\n        dist += dist0;\n    }\n\n    return vec3(c * (shadow + 0.1) / 1.1);\n}\n\nvec3 colHanger(in vec3 p, in Ray ray, in vec3 normal) {\n    vec3 lightPos = vec3(0, 0, 0.4);\n    vec3 lightDir = normalize(p - lightPos);\n    float lightDist = distance(p, lightPos);\n\n    vec3 q = transpose(HANGER_ROTATE) * (p - HANGER_DISP) / HANGER_SCALE;\n    vec3 col;\n    if (q.y > 0.3001) {\n        col = vec3(0.7, 0.8, 0.9);\n        col *= microfacet(normal, ray.direction, lightDir, 0.5, 0.2);\n    } else if (length(abs(q.zx) - vec2(0, 2)) > 0.2001) {\n        col = vec3(1.0);\n        col *= microfacet(normal, ray.direction, lightDir, 0.7, 0.5);\n    } else {\n        col = vec3(1.0);\n        col *= microfacet(normal, ray.direction, lightDir, 0.5, 0.2);\n    }\n\n    return col;\n}\n\nfloat sdInMirror(in vec3 p) {\n    vec3 q;\n\n    float dist = sdRightWall(p);\n\n    q = transpose(HANGER_ROTATE) * (p - HANGER_DISP) / HANGER_SCALE;\n    dist = min(dist, sdHanger(q) * HANGER_SCALE);\n\n    return dist;\n}\n\nDEF_RAYMARCHING(raymarchInMirror, sdInMirror, 128)\n\nvec3 colInMirror(in vec3 p, in Ray ray, in vec3 normal) {\n    int index = objectIndex(p);\n    switch(index) {\n        case 5:\n            return colRightWall(p, ray, normal);\n        case 6:\n            return colHanger(p, ray, normal);\n    }\n}\n\nvec3 colMirror(in vec3 p, in Ray ray, in vec3 normal) {\n    if (normal.z < 1.0e-4) {\n        return colMirrorSide(p, ray, normal);\n    }\n\n    Ray refRay;\n    refRay.origin = p;\n    refRay.direction = reflect(ray.direction, normal);\n    float dist = raymarchInMirror(refRay);\n    vec3 refPos = refRay.origin + dist * refRay.direction;\n    vec3 refNormal = calcNormal(refPos);\n    return colInMirror(refPos, refRay, refNormal);\n}\n\nvec3 color(in vec3 p, in Ray ray, in vec3 normal) {\n    int index = objectIndex(p);\n    switch(index) {\n        case 0:\n            return colWall(p, ray, normal);\n        case 1:\n            float c = -dot(ray.direction, normal);\n            return vec3(1.0 - (1.0 - c) * (1.0 - c));\n        case 2:\n            return colShowerBase(p, ray, normal);\n        case 3:\n            return colShower(p, ray, normal);\n        case 4:\n            return colMirror(p, ray, normal);\n    }\n}\n\n/******************* main function ********************/\nvoid mainImage3D(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 disp = smoothnoise31(iTime * 0.05);\n    disp = 2.0 * CAMERA_AMP * disp - CAMERA_AMP;\n    Camera camera = newCamera(\n        CAMERA_POSITION + disp,\n        normalize(CAMERA_DIRECTION - disp),\n        vec3(0, 1, 0),\n        PI / 5.0,\n        1.0\n    );\n    Ray ray = cameraRay(camera, fragCoord / iResolution.y);\n\n    vec2 xy = ray.origin.xy - ray.direction.xy * ray.origin.z / ray.direction.z;\n    float a = 0.9 * LIGHT_SCALE, b = 0.5 * LIGHT_SCALE;\n    bool lightDomain = (xy.x * xy.x) / (a * a) + (xy.y * xy.y) / (b * b) < 1.0 || xy.y > 0.0;\n    bool showerDomain = xy.x < 0.0;\n\n    float dist = raymarch(ray);\n    vec3 p = ray.origin + dist * ray.direction;\n    vec3 normal = calcNormal(p);\n    vec3 col = color(p, ray, normal) * pow(vec3(1, 1, 0.9), vec3(2.2));\n\n    fragColor = vec4(col, 1);\n}\n\n// smart anti-aliasing\n// reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\nvoid mainImage3DAA(out vec4 O, in vec2 U) {\n    mainImage3D(O, U);\n    \n    #ifdef AA\n    if (fwidth(length(O.xyz)) > 0.1) {\n\n        vec4 o;\n    #if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              mainImage3D(o,U + (vec2(k % 2, k / 2) - 0.5) / 1.5);\n              O += o;\n        }\n        O /= 5.0;\n    #elif (AA == 3)\n        for (int k = 0; k < 9; k += k == 3 ? 2 : 1 ) {\n              mainImage3D(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0);\n              O += o;\n        }\n        O /= 9.0;\n    #endif\n\n    // If defined, visualize anti-aliased pixels.\n    //#define VISUALIZE_AA\n    #ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n    #endif\n    }\n    #endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragCoord.x -= (iResolution.x - iResolution.y) / 2.0;\n    if (fragCoord.x < 0.0 || fragCoord.x > iResolution.y) {\n        fragColor = vec4(0, 0, 0, 1);\n        return;\n    }\n\n    mainImage3DAA(fragColor, fragCoord);\n\n    vec2 uv = fragCoord / iResolution.y;\n    fragColor.xyz *= 1.0 - LIGHT_FLICKER * (1.0 - fbm113(iTime * 30.0, 0.0) / 3.0);\n    float br = smoothfbm125(uv * vec2(sqrt(2.0), sqrt(5.0)) * 10.0 - vec2(0, iTime * 0.5), 0.0);\n    br = (1.0 - br / 5.0) * STEAM;\n    fragColor.xyz = 1.0 - (1.0 - fragColor.xyz) * (1.0 - br);\n\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.4545));\n    fragColor.w = 1.0;\n}\n", "image_inputs": [], "common_code": "/******************** 3D toolkit ********************/\n\nconst float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nCamera newCamera(vec3 position, vec3 direction, vec3 up_direction, float fov, float aspect) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float h = tan(camera.fov * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\n#define rotate3D(axis, angle) mat3(\\\n    axis[0] * axis[0] * (1.0 - cos(angle)) + cos(angle),\\\n    axis[0] * axis[1] * (1.0 - cos(angle)) + axis[2] * sin(angle),\\\n    axis[0] * axis[2] * (1.0 - cos(angle)) - axis[1] * sin(angle),\\\n    axis[0] * axis[1] * (1.0 - cos(angle)) - axis[2] * sin(angle),\\\n    axis[1] * axis[1] * (1.0 - cos(angle)) + cos(angle),\\\n    axis[1] * axis[2] * (1.0 - cos(angle)) + axis[0] * sin(angle),\\\n    axis[0] * axis[2] * (1.0 - cos(angle)) + axis[1] * sin(angle),\\\n    axis[1] * axis[2] * (1.0 - cos(angle)) - axis[0] * sin(angle),\\\n    axis[2] * axis[2] * (1.0 - cos(angle)) + cos(angle)\\\n)\n\nfloat microfacet(vec3 normal, vec3 cameraDir, vec3 lightDir, float metal, float roughness) {\n    vec3 middle = normalize(cameraDir + lightDir);\n    float dotCN = clamp(-dot(cameraDir, normal), 0.0, 1.0);\n    float dotLN = clamp(-dot(lightDir, normal), 0.0, 1.0);\n    float dotNM = clamp(-dot(normal, middle), 0.0, 1.0);\n    float dotCM = clamp(dot(cameraDir, middle), 0.0, 1.0);\n    float alpha = roughness * roughness;\n    \n    // diffuse BRDF\n    float diffuse = 1.0 - metal;\n    \n    // microfacet distribution\n    float alpha2 = alpha * alpha;\n    float tmp = 1.0 - dotNM * dotNM * (1.0 - alpha2);\n    float distribution = alpha2 / (tmp * tmp);\n\n    // schlick approxy & geometric decay\n    float alp = alpha * 0.5;\n    float sal = dotLN / (dotLN * (1.0 - alp) + alp);\n    float sac = dotCN / (dotCN * (1.0 - alp) + alp);\n    float decay = sal * sac;\n\n    // fresnel\n    float c = 1.0 - dotCM;\n    c = c * c * c * c * c;\n    float fresnel = metal + (1.0 - metal) * c;\n\n    // specular BRDF\n    tmp = 4.0 * dotCN * dotLN;\n    float specular = distribution * decay / tmp * fresnel;\n    if (tmp < 0.0001) specular = 0.0;\n    \n    return (diffuse + specular) * dotLN;\n}\n\n/******************** hash & noise ********************/\n// https://www.shadertoy.com/view/XlXcW4\nvec3 hash(uvec3 x) {\n    const uint k = 1103515245U;\n    x.y = ((x.y>>8U)^x.y)*k;\n    x.z = ((x.z>>8U)^x.z)*k;\n    x.z = ((x.z>>8U)^x.z)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)/float(0xffffffffU);\n}\n\nvec3 noise31(float x) {\n    uint s = uint(int(floor(x)) + 2147483647);\n    float t = fract(x);\n    return mix(hash(uvec3(s)), hash(uvec3(s + 1u)), t);\n}\n\nfloat noise11(float x) {\n    return noise31(x).x;\n}\n\n#define three_mix(a0, a1, a2, t) (\\\n      a0 * (1.0 - t) * (1.0 - t) * 0.5\\\n    + a1 * ((t + 1.0) * (1.0 - t) + t * (2.0 - t)) * 0.5\\\n    + a2 * t * t * 0.5\\\n)\n\nvec3 smoothnoise31(float x) {\n    uint s = uint(int(floor(x)) + 2147483647);\n    float t = fract(x);\n    return three_mix(\n        hash(uvec3(s - 2u)),\n        hash(uvec3(s - 1u)),\n        hash(uvec3(s)),\n        t\n    );\n}\n\nfloat fbm113( in float x, in float H ) {\n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i = 0; i < 3; i++ ) {\n        t += a*noise11(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\nvec3 smoothnoise32(vec2 x) {\n    const int k = 2147483647;\n    uvec2 s = uvec2(ivec2(floor(x)) + k);\n    vec2 t = fract(x);\n    uvec3 e = uvec3(0, 1, 2);\n    return three_mix(\n        three_mix(\n            hash(uvec3(s - e.zz, k)),\n            hash(uvec3(s - e.yz, k)),\n            hash(uvec3(s - e.xz, k)),\n            t.x\n        ),\n        three_mix(\n            hash(uvec3(s - e.zy, k)),\n            hash(uvec3(s - e.yy, k)),\n            hash(uvec3(s - e.xy, k)),\n            t.x\n        ),\n        three_mix(\n            hash(uvec3(s - e.zx, k)),\n            hash(uvec3(s - e.yx, k)),\n            hash(uvec3(s - e.xx, k)),\n            t.x\n        ),\n        t.y\n    );\n}\n\nfloat smoothnoise12(vec2 x) {\n    return smoothnoise32(x).x;\n}\n\nfloat smoothfbm125( in vec2 x, in float H ) {\n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i < 5; i++ ) {\n        t += a*smoothnoise12(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n/******************** Primitive SDF ********************/\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, float r, float h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCone( in vec3 p, in float angle, float h ) {\n  vec2 q = h*vec2(tan(angle),-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\n// r0 > r1\nfloat sdTrape(in vec3 p, in float r0, in float r1, in float h) {\n    float theta = atan((r0 - r1), h);\n    float x = r0 * h / (r0 - r1);\n    return max(sdCone(p - vec3(0, x, 0), theta, x), p.y - h);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltXWX.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[1638, 1694, 1719, 1719, 1737], [1739, 1739, 1765, 1765, 1983], [1985, 1985, 2016, 2016, 2235], [2237, 2237, 2264, 2264, 2723], [2725, 2725, 2752, 2752, 2854], [2856, 2856, 2886, 2886, 2910], [2912, 2912, 2939, 2939, 3284], [4663, 4718, 4742, 4742, 5376], [5417, 5417, 5445, 5445, 5652], [5654, 5707, 5735, 5735, 6522], [6524, 6524, 6603, 6603, 7400], [7450, 7450, 7535, 7535, 8421], [8483, 8483, 8564, 8564, 10712], [10766, 10766, 10851, 10851, 10987], [11145, 11145, 11203, 11203, 11945], [11947, 11947, 12002, 12002, 12633], [12635, 12635, 12664, 12664, 12850], [12904, 12904, 12961, 12961, 13148], [13150, 13150, 13205, 13205, 13577], [13579, 13579, 13630, 13630, 14061], [14063, 14120, 14177, 14177, 14985], [15807, 15807, 15862, 15862, 16482]], "test": "untested"}
{"id": "7ltXWX", "name": "Rock the Balls", "author": "dr2", "description": "Balls and arms", "tags": ["collision", "dynamics", "flexitube"], "likes": 28, "viewed": 360, "published": 3, "date": "1639915152", "time_retrieved": "2024-07-30T18:41:18.882788", "image_code": "// \"Rock the Balls\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  No. 38 in \"Ball Dynamics\" series; others are listed in \"Balls Falling\" (NsKGR3)\n*/\n\n#define AA  0  // (= 0/1) optional antialiasing\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvec3 OrAng (vec3 p);\nvec3 OrAngT (vec3 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nmat3 QtToRMat (vec4 q);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\nfloat Fbm2 (vec2 p);\nvec4 Loadv4 (int idVar);\n\nconst ivec3 nbEdge = ivec3 (8, 2, 8);  // same in all buffs\nconst int nBall = nbEdge.x * nbEdge.y * nbEdge.z;\n\nvec3 ltDir, vnBall, hbSize, vnBlk;\nvec2 blkAng;\nvec2 qTube, aRotCs[2];\nfloat tCur, dstFar, hbMarg, radBs, radUp, hUp;\nint idObj, idBall;\nconst int txOff = 2;\nconst float pi = 3.1415927;\n\nconst int nSeg = 3;\nconst int nTube = 4;\n\nstruct TbCon {\n  vec3 pLo, pHi;\n  vec2 sRotCs[2], tRotCs[2];\n  float chLen, segRad;\n};\nTbCon tbCon[nTube];\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\n#define F(x) (sin (x) / x - b)\n\nfloat TubesDf (vec3 p, float dMin)\n{ // (modded from \"Elevating Platter\" and \"Slithering Worm\")\n  vec3 q, pp;\n  vec2 b;\n  float tubeRad, d, s;\n  tubeRad = 0.2;\n  q = p;\n  q.y -= tbCon[0].pLo.y;\n  d = PrTorusDf (q.xzy, 0.5 * tubeRad, radBs);\n  q.y -= hUp - tbCon[0].pLo.y;\n  q.xy = Rot2Cs (q.xy, aRotCs[0]);\n  q.zy = Rot2Cs (q.zy, aRotCs[1]);\n  d = min (d, PrTorusDf (q.xzy, 0.5 * tubeRad, radUp));\n  DMIN (2);\n  pp = p;\n  for (int k = VAR_ZERO; k < nTube; k ++) {\n    p = pp - tbCon[k].pLo;\n    p.xz = Rot2Cs (p.xz, tbCon[k].tRotCs[0]);\n    p.xy = Rot2Cs (p.xy, tbCon[k].tRotCs[1]);\n    p.xy = Rot2Cs (p.xy, tbCon[k].sRotCs[1]);\n    q = p;\n    d = PrSphDf (q, 1.2 * tubeRad);\n    DMIN (2);\n    s = 1.;\n    for (int j = 0; j < nSeg; j ++) {\n      q = p;\n      q.xy = Rot2Cs (vec2 (- q.y, q.x - tbCon[k].segRad), tbCon[k].sRotCs[0]);\n      b = vec2 (length (q.xy) - tbCon[k].segRad, q.z);\n      d = max (length (b) - tubeRad, dot (vec2 (abs (q.x), q.y), tbCon[k].sRotCs[0]));\n      p.xy = Rot2Cs (vec2 (q.y, - q.x), tbCon[k].sRotCs[0]);\n      p.x = - (p.x + tbCon[k].segRad);\n      s = - s;\n      if (d < dMin) qTube = atan (vec2 (- q.x, b.x), vec2 (- q.y, b.y)) * vec2 (tbCon[k].segRad, s);\n      DMIN (3);\n    }\n    q = p;\n    d = PrSphDf (q, 1.2 * tubeRad);\n    DMIN (2);\n  }\n  return dMin;\n}\n\nfloat SecSolve (float b)\n{  // (from \"Bucking Bronco\")\n  vec3 t;\n  vec2 f;\n  float x;\n  if (b < 0.95) {\n    t.yz = vec2 (0.7, 1.2);\n    f = vec2 (F(t.y), F(t.z));\n    for (int nIt = 0; nIt < 4; nIt ++) {\n      t.x = (t.z * f.x - t.y * f.y) / (f.x - f.y);\n      t.zy = t.yx;\n      f = vec2 (F(t.x), f.x);\n    }\n    x = t.x;\n  } else if (b < 1.) {\n    x = sqrt (10. * (1. - sqrt (1. - 1.2 * (1. - b))));\n  } else {\n    x = 0.;\n  }\n  return x;\n}\n\nvoid SetConf ()\n{\n  vec3 vp, s;\n  float segLen, segAng, a, aRot[2];\n  segLen = 2.;\n  hUp = 6.;\n  radUp = sqrt(2.) * (hbSize.x - hbMarg) + 0.1;\n  radBs = 1.3 * radUp;\n  aRot[0] = - blkAng.y;\n  aRot[1] = - blkAng.x;\n  aRotCs[0] = sin (aRot[0] + vec2 (0.5 * pi, 0.));\n  aRotCs[1] = sin (aRot[1] + vec2 (0.5 * pi, 0.));\n  for (int k = 0; k < nTube; k ++) {\n    a = 2. * pi * float (k) / float (nTube);\n    tbCon[k].pLo.y = 0.2;\n    tbCon[k].pLo.xz = Rot2D (vec2 (radBs, 0.), a);\n    tbCon[k].pHi.y = hUp;\n    s.xz = Rot2D (vec2 (radUp, 0.), a);\n    s.xy = Rot2D (vec2 (s.x, 0.), - aRot[0]);\n    s.zy = Rot2D (s.zy, - aRot[1]);\n    tbCon[k].pHi = vec3 (0., hUp, 0.) + s;\n    vp = tbCon[k].pHi - tbCon[k].pLo;\n    tbCon[k].chLen = 0.5 * length (vp) / float (nSeg);\n    segAng = max (1e-4, SecSolve (tbCon[k].chLen / segLen));\n    tbCon[k].segRad = segLen / segAng;\n    tbCon[k].sRotCs[0] = sin (segAng + vec2 (0.5 * pi, 0.));\n    tbCon[k].sRotCs[1] = sin (- segAng + vec2 (0.5 * pi, 0.));\n    tbCon[k].tRotCs[0] = sin (atan (vp.z, - vp.x) + pi + vec2 (0.5 * pi, 0.));\n    tbCon[k].tRotCs[1] = sin (asin (length (vp.xz) / length (vp)) + vec2 (0.5 * pi, 0.));\n  }\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 sLen;\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = OrAng (p - vec3 (0., hUp, 0.));\n  q = abs (q);\n  sLen = vec4 (hbSize - hbMarg - 0.05, 0.);\n  d = min (min (\n     PrRoundBoxDf (q - sLen.wyz, sLen.xww + 0.05, 0.05),\n     PrRoundBoxDf (q - sLen.xwz, sLen.wyw + 0.05, 0.05)),\n     PrRoundBoxDf (q - sLen.xyw, sLen.wwz + 0.05, 0.05));\n  DMIN (1);\n  dMin = TubesDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar || p.y < 0.) break;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    u = ro - p.xyz;\n    rad = 0.49 * p.w;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vnBall = (u + d * rd) / rad;\n        idBall = n;\n      }\n    }\n  }\n  return dMin;\n} \n\nfloat BallHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    u = ro - p.xyz;\n    rad = 0.49 * p.w;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) dMin = d;\n    }\n  }\n  return smoothstep (0., rng, dMin);\n}\n\nfloat BallChqr (int idBall, vec3 vnBall)\n{\n  vec3 u;\n  vec2 a;\n  u = vnBall * QtToRMat (Loadv4 (txOff + 4 * idBall + 2));\n  a = mod (floor (8. * vec2 (atan (u.x, u.y), asin (u.z)) / pi), 2.) - 0.5;\n  return step (0., sign (a.x) * sign (a.y));\n}\n\nfloat BlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u;\n  float dMin, dn, df;\n  dMin = dstFar;\n  v = ro / rd;\n  tp = (hbSize - hbMarg - 0.04) / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    vnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return dMin;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.04 * d, h));\n    d += h;\n    if (sh < 0.001 || d > dMax) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, rob, rdb, vn;\n  vec2 u;\n  float dstBall, dstObj, db, nDotL, sh;\n  SetConf ();\n  col = vec3 (0.);\n  rob = OrAng (ro - vec3 (0., hUp, 0.));\n  rdb = OrAng (rd);\n  db = BlkHit (rob, rdb);\n  dstBall = (db < dstFar) ? BallHit (rob, rdb) : dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (min (dstObj, dstBall) < dstFar) {\n    if (dstObj < dstBall) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      if (idObj == 1) col4 = vec4 (0.8, 0.8, 0.85, 0.1);\n      else if (idObj == 2) col4 = vec4 (0.8, 0.9, 0.8, 0.1);\n      else if (idObj == 3) col4 = mix (vec4 (1., 0.7, 0., 0.2), vec4 (0.6, 0.6, 1., 0.2),\n         step (0., sin (8. * pi * qTube.x + 3. * qTube.y)));\n    } else {\n      ro += dstBall * rd;\n      vn = OrAngT (vnBall);\n      col4 = vec4 (HsvToRgb (vec3 (fract (33. * float (idBall) / float (nBall) +\n         0.5 * BallChqr (idBall, vn)), 0.9, 1.)), 0.3);\n    }\n    nDotL = max (dot (vn, ltDir), 0.);\n    nDotL *= nDotL;\n  } else if (rd.y < 0.) {\n    dstObj = - ro.y / rd.y;\n    ro += dstObj * rd;\n    vn = vec3 (0., 1., 0.);\n    nDotL = max (dot (vn, ltDir), 0.);\n    u = 0.25 * ro.xz;\n    col4 = vec4 (0.6, 0.6, 0.7, 0.1) * (1. - 0.2 * Fbm2 (4. * u));\n    u = abs (fract (u + 0.5) - 0.5);\n    col4.rgb *= (1. - 0.15 * smoothstep (0.05, 0.08, abs (max (abs (u.x + u.y), abs (u.x - u.y)) -\n       0.2) - 0.2)) * (1. - 0.15 * smoothstep (0.05, 0.08, length (max (u - 0.42, 0.))));\n  }\n  if (min (dstObj, dstBall) < dstFar) {\n    sh = (dstObj < dstFar) ? ObjSShadow (ro, ltDir, dstFar) : 1.;\n    sh = min (sh, 0.5 + 0.5 * BallHitSh (OrAng (ro - vec3 (0., hUp, 0.)), OrAng (ltDir), 20.));\n    col = col4.rgb * (0.2 + 0.8 * sh * nDotL) + col4.a * step (0.95, sh) *\n       pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    col *= 1. - 0.9 * smoothstep (0.2, 0.3, length (ro.xz) / dstFar);\n  }\n  if (db < min (dstObj, dstFar)) {\n    col *= 0.95;\n    vn = OrAngT (vnBlk);\n    col = mix (col, vec3 (0.7, 0.7, 0.75) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.1 * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.), pow (1. - abs (dot (rd, vn)), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, asp, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  az = 0.1 * pi;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.005 * pi * tCur;\n  }\n  el = clamp (el, -0.35 * pi, -0.02 * pi);\n  stDat = Loadv4 (0);\n  hbSize = stDat.xyz;\n  stDat = Loadv4 (1);\n  blkAng = stDat.xy;\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 3., -40.);\n  hbMarg = 0.4;\n  zmFac = 4.;\n  dstFar = 20. * length (hbSize);\n  ltDir = vuMat * normalize (vec3 (-1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr *\n       (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nvec3 OrAng (vec3 p)\n{\n  p.yx = Rot2D (p.yx, blkAng.y);\n  p.yz = Rot2D (p.yz, blkAng.x);\n  return p;\n}\n\nvec3 OrAngT (vec3 p)\n{\n  p.yz = Rot2D (p.yz, - blkAng.x);\n  p.yx = Rot2D (p.yx, - blkAng.y);\n  return p;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. -\n     3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Rock the Balls\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec3 nbEdge = ivec3 (8, 2, 8);\nconst int nBall = nbEdge.x * nbEdge.y * nbEdge.z;\n\nvec3 hbSize, gVec;\nfloat nStep, fOvlap, fricN, fricS, fricT;\nconst float txRow = 128.;\nconst int txOff = 2;\nconst float pi = 3.1415927;\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv;\n  float diamN, rSep, diamAv, h, fc, ft;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    rmN = p.xyz;\n    diamN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    diamAv = 0.5 * (diam + diamN);\n    if (n != mId && rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      vmN = Loadv4 (txOff + 4 * n + 1).xyz;\n      wmN = Loadv4 (txOff + 4 * n + 3).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 drw;\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  drw = vec4 ((hbSize - abs (rm)) * (1. - 2. * step (0., rm)), 0.);\n  for (int nf = VAR_ZERO; nf < 3; nf ++) {\n    dr = (nf == 1) ? drw.wyw : ((nf == 0) ? drw.xww : drw.wwz);\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross (wm, dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms, dt;\n  fOvlap = 500.;\n  fricN = 5.;\n  fricT = 5.;\n  fricS = 0.5;\n  fDamp = 0.001;\n  grav = 1.;\n  dt = 0.02;\n  p = Loadv4 (txOff + 4 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  p = Loadv4 (txOff + 4 * mId + 1);\n  vm = p.xyz;\n  qm = Loadv4 (txOff + 4 * mId + 2);\n  wm = Loadv4 (txOff + 4 * mId + 3).xyz;\n  ms = diam * diam * diam;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  PairInt (mId, rm, vm, wm, diam, am, wam);\n  BdyInt (rm, vm, wm, diam, am, wam);\n  am -= grav * gVec + fDamp * vm;\n  wam -= fDamp * wm;\n  vm += dt * am / ms;\n  rm += dt * vm;\n  wm += dt * wam / (0.2 * ms * diam);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec3 e;\n  float mIdf;\n  e = vec3 (nbEdge);\n  mIdf = float (mId);\n  rm = 0.95 * (floor (vec3 (mod (mIdf, e.x), mod (mIdf, e.x * e.y) / e.x,\n     mIdf / (e.x * e.y))) - 0.5 * (e - 1.));\n  vm = 2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1. - 0.3 * Hashff (mIdf + 0.1);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, p, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag, blkAng;\n  float diam;\n  int mId, pxId;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + txOff) discard;\n  if (pxId >= txOff) mId = (pxId - txOff) / 4;\n  else mId = -1;\n  doInit = false;\n  if (iFrame <= 2) doInit = true;\n  if (doInit) {\n    hbSize = vec3 (0.7, 0.5, 0.7) * vec3 (nbEdge) + 0.5;\n    nStep = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    hbSize = stDat.xyz;\n    nStep = stDat.w;\n    ++ nStep;\n  }\n  blkAng = 0.1 * pi * sin (vec2 (0.002, -0.0022) * pi * nStep);\n  gVec = vec3 (0., 1., 0.);\n  gVec.yx = Rot2D (gVec.yx, blkAng.y);\n  gVec.yz = Rot2D (gVec.yz, blkAng.x);\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam);\n    else Step (mId, rm, vm, qm, wm, diam);\n  }\n  if (pxId == 0) stDat = vec4 (hbSize, nStep);\n  else if (pxId == 1) stDat = vec4 (blkAng, 0., 0.);\n  else {\n    mId = pxId - (txOff + 4 * mId);\n    p = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, ((pxId >= txOff) ? p : stDat), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Rock the Balls\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec3 nbEdge = ivec3 (8, 2, 8);\nconst int nBall = nbEdge.x * nbEdge.y * nbEdge.z;\n\nvec3 hbSize, gVec;\nfloat nStep, fOvlap, fricN, fricS, fricT;\nconst float txRow = 128.;\nconst int txOff = 2;\nconst float pi = 3.1415927;\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv;\n  float diamN, rSep, diamAv, h, fc, ft;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    rmN = p.xyz;\n    diamN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    diamAv = 0.5 * (diam + diamN);\n    if (n != mId && rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      vmN = Loadv4 (txOff + 4 * n + 1).xyz;\n      wmN = Loadv4 (txOff + 4 * n + 3).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 drw;\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  drw = vec4 ((hbSize - abs (rm)) * (1. - 2. * step (0., rm)), 0.);\n  for (int nf = VAR_ZERO; nf < 3; nf ++) {\n    dr = (nf == 1) ? drw.wyw : ((nf == 0) ? drw.xww : drw.wwz);\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross (wm, dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms, dt;\n  fOvlap = 500.;\n  fricN = 5.;\n  fricT = 5.;\n  fricS = 0.5;\n  fDamp = 0.001;\n  grav = 1.;\n  dt = 0.02;\n  p = Loadv4 (txOff + 4 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  p = Loadv4 (txOff + 4 * mId + 1);\n  vm = p.xyz;\n  qm = Loadv4 (txOff + 4 * mId + 2);\n  wm = Loadv4 (txOff + 4 * mId + 3).xyz;\n  ms = diam * diam * diam;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  PairInt (mId, rm, vm, wm, diam, am, wam);\n  BdyInt (rm, vm, wm, diam, am, wam);\n  am -= grav * gVec + fDamp * vm;\n  wam -= fDamp * wm;\n  vm += dt * am / ms;\n  rm += dt * vm;\n  wm += dt * wam / (0.2 * ms * diam);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec3 e;\n  float mIdf;\n  e = vec3 (nbEdge);\n  mIdf = float (mId);\n  rm = 0.95 * (floor (vec3 (mod (mIdf, e.x), mod (mIdf, e.x * e.y) / e.x,\n     mIdf / (e.x * e.y))) - 0.5 * (e - 1.));\n  vm = 2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1. - 0.3 * Hashff (mIdf + 0.1);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, p, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag, blkAng;\n  float diam;\n  int mId, pxId;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + txOff) discard;\n  if (pxId >= txOff) mId = (pxId - txOff) / 4;\n  else mId = -1;\n  doInit = false;\n  if (iFrame <= 2) doInit = true;\n  if (doInit) {\n    hbSize = vec3 (0.7, 0.5, 0.7) * vec3 (nbEdge) + 0.5;\n    nStep = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    hbSize = stDat.xyz;\n    nStep = stDat.w;\n    ++ nStep;\n  }\n  blkAng = 0.1 * pi * sin (vec2 (0.002, -0.0022) * pi * nStep);\n  gVec = vec3 (0., 1., 0.);\n  gVec.yx = Rot2D (gVec.yx, blkAng.y);\n  gVec.yz = Rot2D (gVec.yz, blkAng.x);\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam);\n    else Step (mId, rm, vm, qm, wm, diam);\n  }\n  if (pxId == 0) stDat = vec4 (hbSize, nStep);\n  else if (pxId == 1) stDat = vec4 (blkAng, 0., 0.);\n  else {\n    mId = pxId - (txOff + 4 * mId);\n    p = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, ((pxId >= txOff) ? p : stDat), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltXWX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1275, 1275, 1311, 1370, 2568], [2570, 2570, 2596, 2624, 3012], [3014, 3014, 3031, 3031, 4171], [4173, 4173, 4195, 4195, 4596], [4598, 4598, 4631, 4631, 4878], [4880, 4880, 4901, 4901, 5158], [5160, 5160, 5194, 5194, 5624], [5627, 5627, 5674, 5674, 6051], [6053, 6053, 6095, 6095, 6297], [6299, 6299, 6332, 6332, 6644], [6646, 6646, 6695, 6695, 6937], [6939, 6939, 6974, 6974, 9095], [9097, 9097, 9150, 9150, 10434], [10436, 10436, 10482, 10482, 10529], [10531, 10531, 10564, 10564, 10591], [10593, 10593, 10639, 10639, 10696], [10698, 10698, 10723, 10723, 11039], [11041, 11041, 11062, 11062, 11142], [11144, 11144, 11166, 11166, 11250], [11252, 11252, 11274, 11274, 11312], [11314, 11314, 11336, 11336, 11374], [11376, 11376, 11412, 11412, 11618], [11620, 11620, 11650, 11650, 11763], [11765, 11765, 11796, 11796, 11860], [11862, 11862, 11886, 11886, 12008], [12042, 12042, 12066, 12066, 12178], [12180, 12180, 12205, 12205, 12391], [12393, 12393, 12414, 12414, 12569], [12663, 12663, 12688, 12688, 12811]], "test": "untested"}
{"id": "7tdXWX", "name": "Offendomatic", "author": "offendomatic", "description": "Original code by CaliCoastReplay, 301 and mu6k", "tags": ["offendomatic"], "likes": 12, "viewed": 355, "published": 3, "date": "1639914994", "time_retrieved": "2024-07-30T18:41:19.647743", "image_code": "// I started working a bit on the colors of Remix 2, ended up with something like this. :)\n// Remix 2 here: https://www.shadertoy.com/view/MtcGD7\n// Remix 1 here: https://www.shadertoy.com/view/llc3DM\n// Original here: https://www.shadertoy.com/view/XsXXRN\n\nfloat rand(vec2 n) {\n    return fract(sin(cos(dot(n, vec2(12.9898,12.1414)))) * 83758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i <5; i++) {\n        total += noise(n) * amplitude;\n        n += n*1.7;\n        amplitude *= 0.47;\n    }\n    return total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    const vec3 c1 = vec3(0.5, 0.0, 0.1);\n    const vec3 c2 = vec3(0.9, 0.1, 0.0);\n    const vec3 c3 = vec3(0.2, 0.1, 0.7);\n    const vec3 c4 = vec3(1.0, 0.9, 0.1);\n    const vec3 c5 = vec3(0.1);\n    const vec3 c6 = vec3(0.9);\n\n    vec2 speed = vec2(0.1, 0.9);\n    float shift = 1.327+sin(iTime*2.0)/2.4;\n    float alpha = 1.0;\n    \n\tfloat dist = 3.5-sin(iTime*0.4)/1.89;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = fragCoord.xy * dist / iResolution.xx;\n    p += sin(p.yx*4.0+vec2(.2,-.3)*iTime)*0.04;\n    p += sin(p.yx*8.0+vec2(.6,+.1)*iTime)*0.01;\n    \n    p.x -= iTime/1.1;\n    float q = fbm(p - iTime * 0.3+1.0*sin(iTime+0.5)/2.0);\n    float qb = fbm(p - iTime * 0.4+0.1*cos(iTime)/2.0);\n    float q2 = fbm(p - iTime * 0.44 - 5.0*cos(iTime)/2.0) - 6.0;\n    float q3 = fbm(p - iTime * 0.9 - 10.0*cos(iTime)/15.0)-4.0;\n    float q4 = fbm(p - iTime * 1.4 - 20.0*sin(iTime)/14.0)+2.0;\n    q = (q + qb - .4 * q2 -2.0*q3  + .6*q4)/3.8;\n    vec2 r = vec2(fbm(p + q /2.0 + iTime * speed.x - p.x - p.y), fbm(p + q - iTime * speed.y));\n    vec3 c = mix(c1, c2, fbm(p + r)) + mix(c3, c4, r.x) - mix(c5, c6, r.y);\n    vec3 color = vec3(1.0/(pow(c+1.61,vec3(4.0))) * cos(shift * fragCoord.y / iResolution.y));\n    \n    color=vec3(1.0,.2,.05)/(pow((r.y+r.y)* max(.0,p.y)+0.1, 4.0));;\n    color += (texture(iChannel0,uv*0.6+vec2(.5,.1)).xyz*0.01*pow((r.y+r.y)*.65,5.0)+0.055)*mix( vec3(.9,.4,.3),vec3(.7,.5,.2), uv.y);\n    color = color/(1.0+max(vec3(0),color));\n    fragColor = vec4(color.x, color.y, color.z, alpha);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdXWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[258, 258, 278, 278, 352], [354, 354, 375, 375, 581], [583, 583, 602, 602, 787], [789, 789, 846, 846, 2375]], "test": "untested"}
{"id": "fltSWf", "name": "space elision box", "author": "elenzil", "description": "an experiment that's been bouncing around my head for a while.\nwhat if you removed a cubic region of space itself, topologically speaking ?\nakin to 6 (3?) portals arranged in a cube.  what would that look like ?\n.. not super surprising, it turns out.", "tags": ["portal", "topology", "elision"], "likes": 5, "viewed": 234, "published": 3, "date": "1639903291", "time_retrieved": "2024-07-30T18:41:20.420676", "image_code": "// Fork of \"space elision box\" by elenzil. https://shadertoy.com/view/fltSWf\n// 2022-01-13 22:32:35\n\n/*\n\n    A cubic portion of space has been removed topologically..\n    Opposite faces of the cube are 'identified' (meaning made identical topologically)\n    so that a ray entering one face immediately leaves from the opposite face.\n    In nature the mineral Ulexite does something similar, but only along a single axis.\n    \n    Also, Panini Projection!\n\n*/\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n#define SSEPS  (4.0 / MINRES)\n#define ZERO (min(iFrame,0))\nconst float pi = 3.14159265359;\n\n#define AA 2\n\nfloat gTime = 0.0;\n\nmat2 rot2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nvec2 opUnion(in vec2 a, in vec2 b) {\n    if (a.x < b.x) {\n        return a;\n    }\n    else {\n        return b;\n    }\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// iq\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBoxRounded( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n// iq\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdB1(vec3 p) {\n    return sdBoxRounded(p, vec3(0.5), 0.1);\n}\n\nfloat sdB2(vec3 p) {\n    return sdBoxFrame(p, vec3(0.5 - 0.1), 0.05) - 0.01;\n}\n\nfloat sdB3(vec3 p) {\n    const vec3 bv = vec3(0.5, 0.5, 0.05);\n    p.xz *= rot2(gTime * 0.2);\n    float d = 1e9;\n    d =  min( d, sdBoxRounded(p, bv.xyz   , 0.01));\n    d =  min( d, sdBoxRounded(p, bv.yzx   , 0.01));\n    d =  min( d, sdBoxRounded(p, bv.zxy   , 0.01));\n    d = -min(-d, sdBoxRounded(p, vec3(0.4), 0.01));\n    return d;\n}\n\nvec2 map(in vec3 P) {\n    vec3 p = P;\n    vec2 q = vec2(1e11, -1.0);\n    p.xz *= rot2(gTime * 0.1);\n    q = opUnion(q, vec2(sdB2(abs(p) - vec3(2.5, 0.0, 0.0)), 1.0));\n    q = opUnion(q, vec2(sdB2(abs(p) - vec3(0.0, 0.0, 2.5)), 1.0));\n    q = opUnion(q, vec2(sdB3(abs(p) - vec3(2.5, 0.0, 2.5)), 1.0));\n    \n    if (iMouse.z < 2.0) {\n        q = opUnion(q, vec2(sdBoxFrame(P, vec3(1.02), 0.04) - 0.01, 2.0));\n    }\n    \n    vec3 s = P;\n    s.y += 1.5;\n    s.yz *= rot2(s.x * 0.7);\n    s.x = mod(s.x + 0.4 + gTime, 0.8) - 0.4;\n    s.z = abs(s.z) - 0.3 * smoothstep(18.0, 1.0, abs(P.x));\n    q = opUnion(q, vec2(sdSphere(s, 0.2), 3.0));\n    \n    return q;\n}\n\nfloat map2(in vec3 p) {\n    return sdBoxRounded(p, vec3(1.0), 0.0);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );\n}\n\nconst bool invisicube = false;\n\nvec4 march(in vec3 ro, inout vec3 rd, out bool portaled) {\n    portaled = false;\n    float t = 0.0;\n    vec2 q;\n    \n    vec3 p = ro;\n    \n    // this is a dual ray-marching loop.\n    // we march both a regular scene and a portal scene.\n    for (int step = 0; step < 200; ++step) {\n    \n        // regular geometry\n        q = map(p);\n        if (q.x < 1e-3) {\n            return vec4(p, q.y);\n        }\n        if (length(p) > 50.0) {\n            return vec4(p, -1.0);\n        }\n    \n        // portal geometry.\n        // I'm cheating here and assuming the geometry is a unit cube at the origin.\n        // todo: stop assuming that. march thru the portal geometry along the normal\n        //       until you come out the other side.\n        float m2d = map2(p);\n        if (m2d < 1e-3) {\n            portaled = true;\n            if (abs(p.x) < 1.0 && abs(p.y) < 1.0) {\n                p.z *= -1.01;\n            }\n            else if (abs(p.x) < 1.0 && abs(p.z) < 1.0) {\n                p.y *= -1.01;\n            }\n            else {\n                p.x *= -1.01;\n            }\n            rd = normalize(rd);\n            p += rd * 4e-3;\n        }\n        \n        // marching step is the smaller of the two scenes.\n        p += rd * (min (q.x, m2d));\n    }\n    \n    return vec4(p, q.y);\n}\n\nfloat Pow2(float x) { return x * x; }\n// PaniniProjection from TinyTexel\n// https://www.shadertoy.com/user/TinyTexel\n// https://www.shadertoy.com/view/Wt3fzB\n// tc  [-1,1] | fov  [0, ) | d  [0,1]\nvec3 PaniniProjection(vec2 tc, float fov, float d)\n{\n    float d2 = d*d;\n\n    {\n        float fo = pi / 2.0 - fov * 0.5;\n\n        float f = cos(fo)/sin(fo) * 2.0;\n        float f2 = f*f;\n\n        float b = (sqrt(max(0.0, Pow2(d+d2)*(f2+f2*f2))) - (d*f+f)) / (d2+d2*f2-1.0);\n\n        tc *= b;\n    }\n    \n    /* http://tksharpless.net/vedutismo/Pannini/panini.pdf */\n    float h = tc.x;\n    float v = tc.y;\n    \n    float h2 = h*h;\n    \n    float k = h2/Pow2(d+1.0);\n    float k2 = k*k;\n    \n    float discr = max(0.0, k2*d2 - (k+1.0)*(k*d2-1.0));\n    \n    float cosPhi = (-k*d+sqrt(discr))/(k+1.0);\n    float S = (d+1.0)/(d+cosPhi);\n    float tanTheta = v/S;\n    \n    float sinPhi = sqrt(max(0.0, 1.0-Pow2(cosPhi)));\n    if(tc.x < 0.0) sinPhi *= -1.0;\n    \n    float s = inversesqrt(1.0+Pow2(tanTheta));\n    \n    return vec3(sinPhi, tanTheta, cosPhi) * s;\n}\n\nvoid initRay(out vec3 ro, out vec3 rd, in vec2 xy) {\n    // Ray direction in camera space\n    float paniniFOV = 0.5;\n    float paniniD   = 2.0;\n    vec3  rayDirCam = PaniniProjection(xy, paniniFOV, paniniD);\n    \n    // Rotate ray according to camera orientation.\n    vec3  lookTo    = vec3(0.0);\n    vec3  lookFm    = vec3(0.0, 2.0, 6.0);\n    float wobble    = 0.0;\n    vec2  m         = iMouse.xy / RES;\n    if (length(m) < 0.05) {\n        m = vec2(gTime * 0.01, 0.5);\n    }\n    lookFm.yz      *= rot2(( m.y - 0.5) * -2.0 + sin(gTime) * wobble);\n    lookFm.xz      *= rot2((-m.x * pi ) *  2.5 + cos(gTime) * wobble);\n    vec3  camFw     = normalize(lookTo - lookFm);\n    vec3  camRt     = normalize(cross(camFw, vec3(0.0, 1.0, 0.0)));\n    vec3  camUp     = normalize(cross(camRt, camFw));\n    mat3  wldFrmCam = mat3(camRt, camUp, camFw);\n    \n    ro = lookFm;\n    rd = wldFrmCam * rayDirCam;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    gTime = iTime;\n    \n    vec3 accum = vec3(0.0);\n    for (int aaY = ZERO; aaY < AA; ++aaY) {\n    for (int aaX = ZERO; aaX < AA; ++aaX) {\n\n        vec2 aaO = vec2(ivec2(aaX, aaY)) / float(AA) - 0.5;\n\n        vec2 p = (XY + aaO - RES / 2.0) / MINRES * 2.0;\n        p *= 1.2;\n\n        vec3 ro;\n        vec3 rd;\n\n        initRay(ro, rd, p);\n\n        bool portaled;\n        vec4 q = march(ro, rd, portaled);\n\n        vec3 col = vec3(0.0);\n        \n        vec3 sky = texture(iChannel0, rd).rgb;\n\n        if (q.w < 0.0) {\n            // sky\n            col += sky;\n        }\n        else {\n            vec3 p = q.xyz;\n            vec3 nrm = calcNormal(p);\n            vec3 rfl = reflect(rd, nrm);\n\n            // reflection and lighting from cube map\n            if (q.w != 3.0) {\n                col += mix(texture(iChannel0, rfl), texture(iChannel1, rfl), 0.8).rgb;\n            }\n            else {\n                col = 0.7 * vec3(nrm.y * 0.5 + 0.5);\n            }\n\n            // colors\n            if (q.w == 1.0 || q.w == 3.0) {\n                col = mix(col, col * ((p * 0.5) + 0.5), 0.3);\n            }\n            else if (q.w == 2.0) {\n                col = mix(col, vec3(0.0), 0.5);\n            }\n            \n            col = mix(col, sky, smoothstep(6.0, 30.0, length(p)));\n\n        }\n        \n        accum      += col;\n    }}\n    \n    vec3 rgb = accum / float(AA * AA);\n    \n    RGBA = vec4(rgb, 1.0);\n}\n\n", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fltSWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[653, 653, 677, 677, 761], [763, 763, 799, 799, 881], [883, 883, 922, 922, 950], [952, 958, 989, 989, 1076], [1078, 1078, 1125, 1125, 1220], [1223, 1229, 1274, 1274, 1556], [1558, 1558, 1578, 1578, 1624], [1626, 1626, 1646, 1646, 1704], [1706, 1706, 1726, 1726, 2042], [2044, 2044, 2065, 2065, 2697], [2699, 2699, 2722, 2722, 2768], [2770, 2816, 2846, 2846, 3115], [3149, 3149, 3207, 3207, 4439], [4441, 4441, 4462, 4462, 4478], [4479, 4650, 4702, 4702, 5506], [5508, 5508, 5560, 5597, 6403], [6405, 6405, 6448, 6448, 7865]], "test": "untested"}
{"id": "7l3SDX", "name": "Happy Soup", "author": "hamoid", "description": "Counterclockwise", "tags": ["rotation", "spinning"], "likes": 8, "viewed": 359, "published": 3, "date": "1639876008", "time_retrieved": "2024-07-30T18:41:21.209567", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x /= iResolution.y/iResolution.x;\n    float d = length(uv) * 10.0;\n    float i = floor(d);\n    float n = 1.0;\n    d = mod(d, n);\n    float a = smoothstep(0.10, 0.15, d) - smoothstep(0.90, 0.95, d);\n    float angle = atan(uv.y, uv.x) + i;\n    float shade = 0.5 + 0.8 * smoothstep(0.10, 0.90, d);\n    float off = (0.01 + n * 1.5);\n    float aa = mod(angle * (2.0 + i) + n - iTime * off, 3.14159);\n    float clip = smoothstep(0.10, 1.50, aa) - smoothstep(2.20, 2.25, aa);\n    float glow = smoothstep(1.20, 2.20, aa) - smoothstep(2.20, 2.25, aa);\n    \n    fragColor = vec4(\n      (sin(angle + vec3(0.0, 1.2, 3.2) + iTime) * 0.5 * shade + 0.5) * a * clip + \n       a * glow * glow * 0.5, 1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3SDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 806]], "test": "untested"}
{"id": "NltSRH", "name": "Journey tribute", "author": "z0rg", "description": "A scene inspired by the game Journey which is wonderful =D", "tags": ["game", "ambient", "tribute", "journey"], "likes": 14, "viewed": 392, "published": 3, "date": "1639875154", "time_retrieved": "2024-07-30T18:41:22.110159", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb, vec3(1.7));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    rgb *= 1.-sat(length(cuv*2.)-.5);\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define GROUND_MAT 0.\n#define PILLAR_MAT 1.\n\nmat2 r2d(float a) {float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Stolen from 0b5vr here https://www.shadertoy.com/view/ss3SD8\nfloat hash11(float p)\n{\n    return (fract(sin((p)*114.514)*1919.810));\n}\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\nfloat fixedseed;\nfloat fixedrand()\n{\n    fixedseed++;\n    return hash11(fixedseed);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y,l.z));\n}\n\nfloat _pillar(vec3 p)\n{\n    float acc = _cube(p, vec3(.4,10.,.4));\n    acc = min(acc, _cube(p-vec3(0.,9.2,0.), vec3(.42,10.,.42)));\n    float vertholth = .1;\n    acc = max(acc, -_cube(p, vec3(1.,10.,vertholth)));\n    acc = max(acc, -_cube(p, vec3(vertholth,10.,1.)));\n    acc = min(acc, _cube(p, vec3(.1,10.,.1)));\n    \n    acc = min(acc, _cube(p-vec3(0.,9.75,0.), vec3(.44,10.,.44)));\n    \n    // Upper part\n    acc = min(acc, _cube(p+vec3(0.,12.,0.), vec3(.5,10.,.5)));\n    float w1 = .3;\n    float l1 = .55;\n    acc = min(acc, _cube(p+vec3(0.,2.5,0.), vec3(w1,w1,l1)));\n    acc = min(acc, _cube(p+vec3(0.,2.5,0.), vec3(l1,w1,w1)));\n    \n    float w2 = .2;\n    float l2 = .6;\n    acc = min(acc, _cube(p+vec3(0.,2.5,0.), vec3(w2,w2,l2)));\n    acc = min(acc, _cube(p+vec3(0.,2.5,0.), vec3(l2,w2,w2)));\n    acc = acc-.1*(texture(iChannel0, p.xy*.2).x*.01-texture(iChannel0, p.zy*.2).x*.01);\n    return acc;\n}\n\nvec2 map(vec3 p)\n{\n    vec3 op = p;\n    vec2 acc = vec2(1000.,-1.);\n    \n    float ground = -p.y\n    -sin(p.z*10.-p.x*1.)*.01*sin(p.x*.5+iTime*.5)*sat(sin(p.z*.5))\n    -sin((p.z+p.x*.2)*10.)*.01*sat(sin(p.x*1.5+p.z))\n    -.5*(sin(p.z*.75+p.x)*1.5-sin(p.x*.5+iTime*.5)*sin(p.z*5.+p.x*10.)*.05)*pow(sat(abs(p.x)/10.),1.);\n    acc = _min(acc, vec2(ground, GROUND_MAT));\n   \n   \n    p.x = abs(p.x);\n    p.x -= 2.;\n    float rep = 3.;\n    \n    p.z = mod(p.z+rep*.5, rep)-rep*.5;\n    acc = _min(acc, vec2(_pillar(p), PILLAR_MAT));\n    \n    op -= vec3(-1.,-2.5,0.);\n    vec3 p1 = op-vec3(sin(iTime*3.)+.5*sin(iTime), sin(iTime*1.7)*.5,sin(iTime*3.7));    \n    acc = _min(acc, vec2(length(p1)-.05, 2.));\n    vec3 p2 = op-vec3(sin(-iTime*3.)+.5*sin(-iTime), sin(iTime*1.7)*.5,sin(-iTime*1.7));    \n    acc = _min(acc, vec2(length(p2)-.01, 2.));\n    \n    return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 2.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+(r*uv.x+u*uv.y)*fov);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.001,0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\nvec3 accCol;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    accCol = vec3(0.);\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x<0.001)\n            return vec3(res.x, distance(p, ro), res.y);\n        vec3 pl = p;\n        pl.xy *= r2d(-.25);\n        if (length(pl.xz-vec2(-2.5,1.)) < 2.)\n            accCol += .015*vec3(1.000,0.733,0.361)*(1.-sat(res.x/1.51))*sat(-p.y-1.);\n        p+= rd*res.x*.25;\n    }\n    return vec3(-1.);\n}\n\nvec3 getMat(vec3 res, vec3 rd, vec3 p, vec3 n)\n{\n    vec3 col = vec3(0.);\n    vec3 lpos = vec3(-2.,15.,15.);\n    vec3 ldir = p-lpos;\n    vec3 h = normalize(rd+ldir);\n    float ndoth = dot(n,h);\n    if (res.z == GROUND_MAT)\n    {\n        vec3 sandn = (vec3(fixedrand(), fixedrand(),fixedrand())-.5)*2.;\n        float ndoth2 = dot(normalize(n+sandn*.1),h);\n        col = vec3(0.118,0.322,0.243)*pow(sat(ndoth2),10.)*2.;\n        col += vec3(0.118,0.322,0.243)*pow(sat(ndoth2),2.)*.5;\n        col += vec3(0.459,0.686,0.376)*pow(sat(ndoth2),20.)*15.*(1.-sat(res.y/10.));\n        col *= 3.;\n    }\n    else if (res.z == PILLAR_MAT)\n    {\n        float pattern = texture(iChannel0, p.xy*.4).x-texture(iChannel0, p.zy*.4).x;\n        col = vec3(.1)*sat(pattern+.75)*.25;\n        col += 1.2*vec3(.1,.23,.34)*(1.-sat(abs(p.y+1.)*.5))*.5*pow(sat(ndoth),.25);\n        vec3 pl = p-vec3(-1.,0.,0.);\n        col += 1.5*vec3(1.000,0.733,0.361)*(1.-sat(length(pl.xz)-5.))*.35*sat(1.2+ndoth);\n    }\n    else\n        col = n*.5+.5;\n\n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    \n    vec3 dof = (vec3(rand(), rand(), rand())-.5)*.1*sat(length(uv)*.5);\n    vec3 ro = vec3(1.4-.1*sin(iTime*.25),-.2,-3.)+dof;\n    vec3 ta = vec3(0.,-1.5,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv)-dof;\n    vec3 res = trace(ro, rd, 1024);\n    float maxDist = 100.;\n    float dist = maxDist;\n    vec3 halolight = vec3(0.);\n    if (res.y > 0.)\n    {\n        halolight = accCol;\n        dist = res.y;\n        vec3 p = ro+rd*res.y;\n        fixedseed = texture(iChannel0,p.xz*.005).x;\n        vec3 n = getNorm(p, res.x);\n        col = getMat(res, rd, p, n);\n        vec3 refl = normalize(reflect(rd,n)+.5*(vec3(rand(),rand(),rand())-.5));\n        vec3 resrefl = trace(p+n*0.01, refl, 128);\n        if (resrefl.y> 0.)\n        {\n            vec3 prefl = p*refl*resrefl.y;\n            vec3 nrefl = getNorm(prefl, resrefl.x);\n            col += getMat(resrefl, rd, prefl, nrefl)*(res.z == GROUND_MAT ? 2.5 : .2);\n        }\n    }\n    \n    vec3 fogcol = vec3(.1,.34,.21)*.5*sat(uv.y+.75);//mix(vec3(.1,.34,.21)*.5, vec3(0.784,0.784,0.639)*.1, sat((dist-20.)*.05));\n    col = mix(col, fogcol, pow(sat(dist/maxDist), .25));\n    col += halolight*1.2;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    seed+= texture(iChannel0, uv).x;\n    seed += iTime;\n    \n    vec3 col = rdr(uv);\n    col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).xyz, .85);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define GLOW_SAMPLES 40\n#define GLOW_DISTANCE 0.3\n#define GLOW_POW .8\n#define GLOW_OPACITY .4\n\n#define sat(a) clamp(a,0., 1.)", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltSRH.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1117]], "test": "untested"}
{"id": "NtK3Rc", "name": "CubesLive", "author": "z0rg", "description": "Somthing I made on bonzomatic originally as a training for live shader showdown.\nCode is not cleaned at all !", "tags": ["zefzef"], "likes": 5, "viewed": 498, "published": 3, "date": "1639874864", "time_retrieved": "2024-07-30T18:41:22.954900", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat _time;\n#define FFT(a) pow(sat(texture(iChannel0, vec2(a,0.)).x*100.),1.)\n\n#define sat(a) clamp(a, 0., 1.)\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\nfloat _cube(vec3 p, vec3 s)\n{\n  s.xz -= (sin(p.y*20.)*.2+.8)*.05;\n  vec3 l = abs(p)-s;\n  return max(l.x, max(l.y, l.z));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 defr = r;\n  defr.xy *= r2d(uv.y*10.);\n  r = mix(r, defr, sin(_time));\n  vec3 u = normalize(cross(rd, r));\n  return normalize(rd+(r*uv.x+u*uv.y)*(asin(sin(_time))*.2+.8));\n}\nvec2 map(vec3 p)\n{\n  p.y = -abs(p.y);\n  vec3 vp = p;\n  vec2 acc = vec2(1000.,-1.);\n  \n  float rep = 0.4;\n  float w = .1;\n  //p.y = texture(tex\n  p.xz *= r2d(sin(p.y+_time)*.2);\n  vec2 idx = floor((p.xz+rep*.5)/rep);\n  p.xz = mod(p.xz+rep*.5,rep)-rep*.5;\n  float cubes = _cube(p, vec3(w, 1.+FFT(length(idx)*.2), w));\n  \n  float repv = .3*length(idx);\n  vp.y = mod(vp.y+repv*.5-_time*length(idx)*.15,repv)-repv*.5;\n  cubes = max(cubes, _cube(vp, vec3(10.,.1,10.)));\n  \n  acc = _min(acc, vec2(cubes, floor(length(idx)+_time)));\n  \n  //acc = _min(acc, vec2(-p.y, 0.));\n  \n  \n  \n  return acc;\n}\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n  return normalize(cross(dFdx(p), dFdy(p)));\n}\n\n\nfloat accAO;\nvec3 accCol2;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accAO = 0.;\n  accCol2 = vec3(0.);\n  vec3 p = ro;\n  for (int i = 0; i < steps; ++i)\n  {\n    vec2 res = map(p);\n    if (res.x < 0.01)\n      return vec3(res.x, distance(p, ro), res.y);\n    accAO += sat(res.x/0.01)*.002;\n    accCol2 += vec3(sin(p.x+_time*10.)*.2+.5,.2,.5)*pow(sat(res.x/.05),1.)*.01;\n    p+=rd*res.x*.15;\n  }\n  return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 col = vec3(0.);\n \n  float dist = 5.;\n  vec3 ro = vec3(sin(_time*.33)*dist,-5.*sin(_time*.1),cos(_time*.25)*dist);\n  vec3 ta = vec3(0.,0.,0.);\n  vec3 rd = normalize(ta-ro);\n  \n  rd = getCam(rd, uv);\n  vec3 res = trace(ro, rd, 512);\n  if (res.y > 0.)\n  {\n    vec3 p = ro +rd*res.y;\n    vec3 n = getNorm(p, res.x);\n    col = n*.5+.5;\n    float fade = 1.;//(1.-sat((length(p.xz)-sin(_time+length(p.xz)))*1.));\n    vec3 ldir = normalize(vec3(1.,1.,1.));\n    col = vec3(1.)*pow(sat(-dot(n, normalize(ldir+rd))),.8)\n    +vec3(.3,.25,.25);\n    col *= fade;\n    col = 1.-col;\n    float ffti = _time;//texture(texFFTIntegrated, length(p.xz)*.1+_time).x*0.1;\n    if (dot(n, vec3(0.,1.,0.)) < -0.5 && p.y < -0.1)\n      col = vec3(sin(res.z)*.5+.5, .3, sin(res.z*10.)*.2+.8)*sat(sin(length(p.xz)*5.-_time*10.))*1.5;\n    col *= 1.-accAO;\n    col += accCol2;\n  }\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy -.5*iResolution.xy)/iResolution.xx;\n  _time = iTime+texture(iChannel1, fragCoord.xy/8.).x*1.*sat(length(uv));\n  //uv *= r2d(texture(texFFTIntegrated, 1.).x*.25);\n  vec3 col = rdr(uv);\n  col.xy *= r2d(_time);\n  col.xy = .2+.8*abs(col.xy);\n  fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtK3Rc.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[509, 509, 528, 528, 586], [587, 587, 616, 616, 709], [711, 711, 738, 738, 783], [785, 785, 816, 816, 1045], [1046, 1046, 1064, 1064, 1635], [1636, 1636, 1667, 1667, 1822], [1852, 1852, 1893, 1893, 2239], [2241, 2241, 2260, 2260, 3134], [3136, 3136, 3193, 3193, 3487]], "test": "untested"}
{"id": "sldXD2", "name": "Fork Menger Sponge", "author": "jorge2017a2", "description": "///modificado por jorge2017a2\nThis is a simple Menger Sponge, rendered with raymarching. This is based on iq's article about iterative fractals: https://iquilezles.org/articles/menger/menger.htm", "tags": ["3d", "raymarching", "fractal", "menger", "sponge", "mengersponge"], "likes": 21, "viewed": 474, "published": 3, "date": "1639842107", "time_retrieved": "2024-07-30T18:41:23.842527", "image_code": "///modificado por jorge2017a2\n//referencia\n//https://www.shadertoy.com/view/ltGSWz\n\n#define distfar 6.0\n#define iterations 5.0\n\nfloat maxcomp(vec3 p) {\n    return max(p.x,max(p.y,p.z));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nfloat sdBox2D(vec2 p, vec2 b) {\n\tvec2  di = abs(p) - b;\n    float mc = max(di.x,di.y);\n    return min(mc,length(max(di,0.0)));\n}\n\nfloat sdCross( in vec3 p )\n{\n  float da = sdBox2D(p.xy,vec2(1.0));\n  float db = sdBox2D(p.yz,vec2(1.0));\n  float dc = sdBox2D(p.zx,vec2(1.0));\n  return min(da,min(db,dc));\n}\n\n#define MENGER_ITERATIONS\t2\n\nvec4 mapFractal(in vec3 p)\n{\t\n    p.xz = mod(p.xz + 4.0, 2.0) -1.0;\n    //p.y = mod(p.y + 1.0, 2.0) - 1.0;\n\t\n    float d = sdBox(p,vec3(1.0));\n    vec4 res = vec4(d, 1.0, 0.01, 0.0);\n\t\n    //float s = 1.5;\n    float s = 2.5;\n    \n    for(int i = 0; i < MENGER_ITERATIONS; ++i)\n    {\t \n       \n        s = pow(2.0,float(i));\n        vec3 a = mod(p * s, 2.0) - 1.0;\n        s *= 11.0;\n        //vec3 r = abs(1.0 - 4.0 * abs(a));\n        vec3 r = abs(1.0 - 5.0 * abs(a));\n        \n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 0.85) / s;\n        \n\n        if(c > d)\n        {\n            d = c;\n            res = vec4(d, min(res.y, 0.2 * da * db * dc), 0.0, 1.0);\n        }\n    }\n    \n    return res;\n}\n\n\nvec2 map1(vec3 p) \n{\n    float d = sdBox(p,vec3(1.0));\n    \n    for (float i = 0.0; i < iterations; i++) {\n\n        float scale = pow(2.0,i);\n        vec3 q = mod(scale*p,2.0)-1.0;\n        q = 1.0-abs(q);\n        float c = sdCross(q*3.0)/(scale*3.0);\n        d = max(d,-c),1.0;\n        \n        p += scale/3.0;\n\t\t\n    }\n    \n    return vec2(d,1.0);\n    \n}\n\n\n\n\nvec2 map(vec3  p)\n{\n\n   float t=mod(iTime,10.0); \n   float t1=mod(t,4.0);\n   float t2=mod(t,3.0);\n   float d1;\n   if (t1<t2)\n    d1=mapFractal(p).x;\n   else\n    d1=map1(p).x;\n   \n   return vec2(d1,1.0);\n    \n}\n\n/*\n*/\n\nvec3 calcnormal(vec3 p) {\n    vec2 e = vec2(0.0001, 0.0);\n    vec3 n;\n    n.x = map(p+e.xyy).x - map(p-e.xyy).x;\n    n.y = map(p+e.yxy).x - map(p-e.yxy).x;\n    n.z = map(p+e.yyx).x - map(p-e.yyx).x;\n    return  normalize(n);\n}\n\nfloat softshadow (vec3 ro, vec3 rd) {\n    float res = 1.0;\n    float t = 0.001;\n    for (float i = 0.0; i < 1000.0; i++) {\n        if (t>distfar) break;\n        vec2 h = map(ro + t*rd);\n        if (h.x < 0.0001) return 0.0;\n        res = min(res, 64.0*h.x/t);\n        t += h.x;\n    }\n    return res;\n}\n\nvec3 trace(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (float i = 0.0; i < 1000.0; i++) {\n        if (t > distfar) break;\n        vec2 d = map(ro + rd*t);\n        if (d.x < 0.0001) return vec3(t, d.y, i);\n        t += d.x;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.0,0.0,1.5);\n    vec3 rd = normalize(vec3(uv,-1.5));\n    \n    float theta = sin(iTime/2.0);\n    mat2 rot = mat2(cos(theta),sin(theta),-sin(theta),cos(theta));\n    ro.yz *= rot;\n    rd.yz *= rot;\n    theta = iTime/3.0;\n    rot = mat2(cos(theta),sin(theta),-sin(theta),cos(theta));\n    ro.xz *= rot;\n    rd.xz *= rot;\n    \n    vec3 t = trace(ro, rd);\n    \n    vec3 col = vec3(0.8);\n    \n    if (t.y > 0.5) {\n        \n        vec3 pos = ro + rd*t.x;\n        vec3 lig = normalize(vec3(0.6,1.0,0.8));\n        vec3 nor = calcnormal(pos);\n        float refRange = 0.2;\n        \n        float occ = 1.0/(1.0+t.z/15.0);\n        float sha = softshadow(pos, lig);\n        float dif = max(0.0, dot(nor,lig));\n        float sky = 0.5+0.5*nor.y;\n        float ind = max(0.0, dot(nor,vec3(-1.0,-0.2,-1.0)*lig));\n        float ref = max(1.0-refRange,dot(-nor,rd))-1.0+refRange;\n        \n        col = vec3(0.8,1.0,1.2)*dif*pow(vec3(sha),vec3(1.0,1.2,1.5));\n        col += vec3(0.2,0.3,0.4)*ind*occ;\n        col += vec3(0.2,0.2,0.3)*sky*occ;\n        col += pow(ref,2.0)*4.0*occ;\n        \n        col = pow(col,vec3(0.4545));\n        \n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldXD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 151, 151, 187], [189, 189, 220, 220, 311], [313, 313, 344, 344, 441], [443, 443, 471, 471, 616], [647, 647, 675, 675, 1444], [1447, 1447, 1467, 1467, 1802], [1807, 1807, 1826, 1826, 2016], [2025, 2025, 2050, 2050, 2251], [2253, 2253, 2290, 2290, 2554], [2556, 2556, 2586, 2586, 2811], [2813, 2813, 2870, 2870, 4148]], "test": "untested"}
{"id": "7tdXDj", "name": "Hitomezashi 3D", "author": "mla", "description": "Hitomezashi 3d. Inspired by Ayliean MacDonald on Numberphile: [url]https://www.youtube.com/watch?v=JbfhzlMk2eY[/url]", "tags": ["3d", "hitomezashi"], "likes": 19, "viewed": 408, "published": 3, "date": "1639836926", "time_retrieved": "2024-07-30T18:41:24.701231", "image_code": "////////////////////////////////////////////////////////////////\n//\n// 3D Hitomezashi Patterns, Matthew Arcus, mla. 2021\n//\n// Inspired by the Numberphile video by Ayliean MacDonald:\n// https://www.youtube.com/watch?v=JbfhzlMk2eY\n//\n// Mouse moves viewpoint\n// 'a': turn on AA\n// 'c': clip to cube\n// 'r': autorotation\n// 't': autotranslation\n// 'x': variable randomicity\n//\n////////////////////////////////////////////////////////////////\n\nbool dorotate = true;\nbool dotranslate = true;\nbool doclamp = false;\n\nfloat N = 9.0; // Clamped size\nfloat vradius = 0.1; // Vertex radius\nfloat eradius = 0.05; // Edge radius\nfloat maxdist = 50.0;\n\nfloat eyedist = 10.0;     // Distance of eye from origin\nvec3 light = vec3(0,2,1); // Light direction\nint numsteps = 200;       // Maximum raymarching steps\nfloat precis = 1e-3;      // Raymarching precision\n\nvec3 clampvertex(vec3 vertex){\n  if (!doclamp) return vertex;\n  return clamp(vertex,0.0,N);\n}\n\n// It seems worth caching data for the last vertex used.\nvec3 lastvertex = vec3(0.5);\nvec3 vx,vy,vz;\n\nfloat threshold = 0.5; // Randomization threshold\n\nfloat de0(vec3 z, out int type) {\n  if (dotranslate) z.z -= iTime;\n  z += 0.5*N; \n  vec3 vertex = round(z);\n  vertex = clampvertex(vertex);\n  if (vertex != lastvertex) {\n    lastvertex = vertex;\n    vec3 signs = 2.0*mod(vertex,2.0)-1.0;\n    vec3 lines = vec3(hash(vertex.yz),\n                      hash(vertex.zx),\n                      hash(vertex.xy));\n    signs *= 2.0*vec3(lines.x<threshold,\n                      lines.y<threshold,\n                      lines.z<threshold)-1.0;\n    vx = clampvertex(vertex-signs.x*vec3(1,0,0));\n    vy = clampvertex(vertex-signs.y*vec3(0,1,0));\n    vz = clampvertex(vertex-signs.z*vec3(0,0,1));\n  }\n  int xytype = 1+(int(vertex.z) & 1);\n  float d = 1e8, d1;\n  d1 = distance(z,vertex)-vradius;\n  if (d1 < d) { d = d1; type = 0; }\n  d1 = segment(z,vertex,vx)-eradius;\n  if (d1 < d) { d = d1; type = xytype; }\n  d1 = segment(z,vertex,vy)-eradius;\n  if (d1 < d) { d = d1; type = xytype; }\n  d1 = segment(z,vertex,vz)-eradius;\n  if (d1 < d) { d = d1; type = 3; }\n  return d;\n}\n\nfloat de(vec3 z, out int type) {\n  int t1,t2;\n  float d = de0(z,type);\n  float d1 = d;\n  //d1 = de0(z.yzx+0.5,t1);\n  //if (d1 < d) { d = d1; type = t1; }\n  return d;\n}\n\nfloat de(vec3 z) {\n  int type;\n  return de(z,type);\n}\n\nvec3 getbackground(vec3 r) {\n  if (key(CHAR_B)) return vec3(0);\n  return vec3(1,1,0.8);\n}\n\nvec3 getbasecolor(int type) {\n  if (type == 0) return vec3(0.2);\n  if (type == 1) return 0.2+0.8*vec3(1,0,0);\n  if (type == 2) return 0.2+0.8*vec3(0,0,1);\n  if (type == 3) return 0.2+0.8*vec3(1,1,0);\n  return vec3(1,0,1);\n}\n\nfloat march(vec3 q, vec3 r) {\n  float t = 0.01; // Total distance so far.\n  for (int i = 0; i < numsteps; i++) {\n    //assert(i < 50);\n    vec3 p = q+t*r;\n    float d = de(p);\n    if (abs(d) < precis) return t;\n    t += 0.8*d;\n    // We might go backwards!\n    if (t < 0.0 || t > maxdist) break;\n  }\n  return -1.0;\n}\n\n// Get the normal of the surface at point p.\nvec3 getnormal(vec3 p, float t) {\n  float eps = 1e-3;\n  vec2 e = vec2(eps,0);\n  float k = de(p);\n  return normalize(vec3(de(p + e.xyy) - k,\n                        de(p + e.yxy) - k,\n                        de(p + e.yyx) - k));\n}\n\n// Rotate according to mouse position\nvec3 transformframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    // Full range of rotation across the screen.\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  // autorotation\n  if (dorotate) {\n      float t = iTime;\n      p.yz = rotate(p.yz,-t*0.05);\n      p.zx = rotate(p.zx,-t*0.05);\n  }\n  return p;\n}\n\n// Follow ray from q, direction r.\nvec3 raycolor(vec3 q, vec3 r) {\n  float t = march(q,r);\n  if (t < 0.0) return getbackground(r);\n  vec3 p = q+t*r;\n  vec3 normal = getnormal(p,t);\n  int type = 0;\n  de(p,type);\n  vec3 color = getbasecolor(type);\n  float ambient = 0.3;\n  vec3 lightdir = normalize(light);\n  float diffuse = 0.7*clamp(dot(normal,lightdir),0.0,1.0);\n  color *= ambient+ diffuse;\n    if (!key(CHAR_S)) {\n    float specular = pow(max(0.0,dot(reflect(lightdir,normal),r)),4.0);\n    color += specular;\n  }\n  if (!key(CHAR_F)) color = mix(color,getbackground(r),clamp(t/(maxdist),0.0,1.0));\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  int AA = 1;\n  if (key(CHAR_A)) AA = 2;\n  dorotate = key(CHAR_R);\n  doclamp = key(CHAR_C);\n  dotranslate = !doclamp && !key(CHAR_T);\n  if (key(CHAR_X)) threshold += 0.5*(cos(0.2*PI*iTime));\n  vec3 eye = vec3(0,0,eyedist);\n  eye = transformframe(eye);\n  light = transformframe(light);\n  vec3 col = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n      vec3 ray = vec3(z,-2);\n      if (key(CHAR_I)) {\n        eye = transformframe(vec3(4.0*z,-8.0));\n        ray = vec3(0,0,1);\n      }\n      ray = transformframe(ray);\n      ray = normalize(ray);\n      col += raycolor(eye,ray);\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545)); // Gamma\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;;\n}\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\nfloat segment(vec3 p, vec3 a, vec3 b) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  float d = length(pa - ba * h);\n  return d;\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash(vec2 p) {\n  uint ux = uint(int(p.x));\n  uint uy = uint(int(p.y));\n  uint h = ihash(ux^(uy<<16));\n  return float(h)/pow(2.0,32.0);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdXDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[849, 849, 879, 879, 942], [2108, 2108, 2140, 2140, 2275], [2277, 2277, 2295, 2295, 2330], [2332, 2332, 2360, 2360, 2421], [2423, 2423, 2452, 2452, 2646], [2648, 2648, 2677, 2677, 2964], [2966, 3011, 3044, 3044, 3240], [3242, 3280, 3309, 3309, 3722], [3724, 3759, 3790, 3790, 4341], [4343, 4343, 4394, 4394, 5210]], "test": "untested"}
{"id": "7ltXWj", "name": "A simple pi menu", "author": "ololeecn", "description": "This is my second shader, it's a long way to learn shader, hope I can keep it up. \nSome functions from iq and one from FabriceNeyret2.", "tags": ["2d"], "likes": 8, "viewed": 231, "published": 3, "date": "1639831740", "time_retrieved": "2024-07-30T18:41:25.579882", "image_code": "#define NUM 8\n#define R 0.5\n#define SMALLR 0.2\n#define ROTATESPEED -2.0\n#define PI 3.14159265358979\n\n\n//from iq\nfloat sdCircle(vec2 p, float r){\n    return length(p) - r;\n}  \n\n//from iq\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n//from iq\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p,scb) : length(p);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n\n//from FabriceNeyret2\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b);   // proj coord on line\n    h = clamp(h, 0.,1.);               // round end\n    return length(p - b * h);          // dist to segment\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.0);\n    vec3 eyeCol = vec3(1.0);\n\n   \n    float part = 2.0*PI/float(NUM);\n    for(int i = 0; i < NUM; i++){\n        float index = float(i);\n        float rad = part * index + (iTime*ROTATESPEED);\n        float d = sdCircle(p - (R-0.1) * vec2(cos(rad),sin(rad)),SMALLR);\n        col = mix(vec3(eyeCol),col,smoothstep(0.0,0.01,d));\n    }\n     col = mix(vec3(0.0),col,smoothstep(0.0,0.01,sdCircle(p,R+0.01)));\n     col = mix(vec3(eyeCol),col,smoothstep(0.0,0.01,abs(sdCircle(p,R-0.01))));\n     col = mix(vec3(eyeCol),col,smoothstep(0.0,0.04,abs(sdCircle(p,R-0.04))));\n     \n     \n     \n     //draw mouse\n     float startRad = 1.0*PI;\n     float stopRad = 0.001;\n     float mouse = sdArc(p-vec2(0.0,0.1),vec2(cos(startRad),sin(startRad)),vec2(0.001,0.001),0.16,0.005);\n     col = mix(vec3(eyeCol),col,smoothstep(0.0,0.01,mouse));\n     \n     \n     //draw saliva\n     float saliva = line(p,vec2(0.0,0.1)+0.16*vec2(cos(1.7*PI),sin(1.7*PI)),vec2(0.0,0.1)+0.176*vec2(cos(1.71*PI),sin(1.65*PI)));\n     col = mix(vec3(eyeCol),col,smoothstep(0.0,0.01,saliva));\n     \n     \n      //draw eye\n     float eyesize = 0.5 + sin(4.0*iTime) * 0.5;\n     p.x=abs(p.x);\n     float eye = sdEllipse(p+vec2(-0.18,-0.15),vec2(0.04,0.07-0.02*eyesize));\n     col = mix(vec3(eyeCol),col,smoothstep(0.0,0.01,eye));\n     \n    fragColor =vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltXWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 112, 144, 144, 172], [176, 186, 228, 228, 1250], [1252, 1262, 1337, 1337, 1515], [1518, 1540, 1575, 1575, 1769], [1771, 1771, 1828, 1828, 3270]], "test": "untested"}
{"id": "fttXWj", "name": "A Piece of String", "author": "oneshade", "description": ".", "tags": ["string", "path", "following"], "likes": 38, "viewed": 318, "published": 3, "date": "1639795871", "time_retrieved": "2024-07-30T18:41:26.470500", "image_code": "float sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n#define drawSDF(dist, color) fragColor.rgb = mix(fragColor.rgb, color, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    fragColor = vec4(1.0);\n\n    vec2 total = vec2(0.0);\n    vec2[JOINTS] joints;\n    for (int n=0; n < JOINTS; n++) {\n        vec2 joint = load(ivec2(n, 0)).xy;\n        joints[n] = joint;\n        total += joint;\n    }\n\n    uv += total / float(JOINTS);\n    vec2 prev = joints[0];\n    //drawSDF(length(uv - prev) - 0.01, vec3(0.0));\n    for (int n=1; n < JOINTS; n++) {\n        vec2 cur = joints[n];\n        //drawSDF(length(uv - joints[n]) - 0.01, vec3(0.0));\n        drawSDF(sdLine(uv, prev, cur) - 0.001, vec3(0.0));\n        prev = cur;\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 state, in vec2 addr) {\n    state = vec4(0.0);\n    ivec2 iAddr = ivec2(addr);\n    if (iFrame == 0) {\n        if (iAddr.x < JOINTS && iAddr.y == 0) {\n            state.x = -addr.x / 50.0;\n            if (iAddr.x == 0) state.z = 0.01;\n        }\n    }\n\n    if (iFrame > 0) {\n        if (iAddr.x < JOINTS && iAddr.y == 0) {\n            state = load(iAddr);\n            if (iAddr.x == 0) {\n                state.xy += state.zw;\n                float rot = 0.5 * fbm(iTime, 1.0, 10) - 0.25;\n                float co = cos(rot), si = sin(rot);\n                state.zw *= mat2(co, -si, si, co);\n            }\n\n            else {\n                vec4 next = load(ivec2(iAddr.x - 1, 0));\n                state.xy = next.xy - normalize(next.xy - state.xy) * SPACING;\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define load(frag) texelFetch(iChannel0, frag, 0)\n\n#define JOINTS 50\n#define SPACING 0.025\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat snoise(in float x) {\n    return mix(Hash11(floor(x)), Hash11(ceil(x)), smoothstep(0.0, 1.0, fract(x)));\n}\n\nfloat fbm(in float x, in float scale, in int octaves) {\n    x *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (int o=0; o < octaves; o++) {\n        value += snoise(x) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        x *= 2.0;\n    }\n\n    return value / tscale;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttXWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 155]], "test": "untested"}
{"id": "NtdSWj", "name": "Basic Krillin 2d", "author": "jorge2017a2", "description": "Basic Krillin 2d", "tags": ["basickrillin2d"], "likes": 3, "viewed": 202, "published": 3, "date": "1639794723", "time_retrieved": "2024-07-30T18:41:27.343167", "image_code": "//por jorge2017a2\n//Basic Krillin 2d\n// 17-dic-2021\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 DrawFigBordeR(vec3 pColObj, vec3 colOut, float distObj, float r )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-r,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0)); return colOut;}\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\nvec3 DrawFigRB(vec3 pColObj, vec3 colOut, float distObj, float r )\n{  colOut = mix(colOut,pColObj ,S2( distObj-r,0.0)); return colOut; }\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nvec3 HacerCejaIzq(vec2 p, vec3 col)\n{   vec2 p0=p; \n    p=rotatev2(p,radians(70.));\n    float d1b= sdCircle(p*vec2(0.5,1.0)-vec2(0.2,-0.4),0.065 );\n    float d1c= sdCircle(p*vec2(0.5,1.0)-vec2(0.25,-0.425),0.07 );\n    float ddif2=differenceSDF(d1b, d1c);\n    col= DrawFigDelgado(vec3(0.0), col,ddif2);\n    return col;\n}\n\nvec3 HacerBoca(vec2 p, vec3 col)\n{   vec2 p0=p; \n    float d1a= sdCircle(p-vec2(0.2,-0.4),0.5 );\n    float d1b= sdCircle(p-vec2(0.2,-0.35),0.5 );\n    float d1c= sdBox(p-vec2(0.2,-0.8),vec2(0.15,0.15) );\n    float ddif=differenceSDF(d1a, d1b);\n    ddif= intersectSDF(ddif, d1c);\n    col= DrawFigDelgado(vec3(1.0,0.0,0.0), col,ddif);\n    return col;\n}\n\nvec3 HacerBrazo(vec2 p, vec3 col)\n{   vec2 p0=p-vec2(-0.05,-0.82); \n    p0.x=abs(p0.x)-0.1;\n    p=p0;\n    \n    vec2 pc1p1=vec2(.224,.326);\n    vec2 pc1p2=vec2(.307,.409);\n    vec2 pc1p3=vec2(.354,.021);\n\n    vec2 pc2p1=vec2(.220,.322);\n    vec2 pc2p2=vec2(.137,.236);\n    vec2 pc2p3=vec2(.193,.008);\n\n    float db1= sdBezier(p,pc1p1,pc1p2,pc1p3 );\n    float db2= sdBezier(p,pc2p1,pc2p2,pc2p3 );\n    db1= unionSDF(db1,db2);\n    col = DrawFigDelgado(vec3(0.0),col,db1);    \n    return col;\n}\n\nvec3 HacerOjos(vec2 p, vec3 col)\n{   vec2 p0=p;    \n    //pupila iqz\n    vec2 pa = p0;\n    float d5a = sdCircle(pa-vec2(-0.2, -0.3), 0.015);\n    //pupila der\n    float d5b = sdCircle(pa- vec2(0.02, -0.3), 0.015);\n    col = DrawFigDelgado(vec3(0.0, 0.0, 0.0), col, d5a);  //pupila\n    col = DrawFigDelgado(vec3(0.0, 0.0, 0.0), col, d5b);  //pupila\n    \n    p=p0*vec2(0.8)-vec2(-0.6,-0.6);\n    //ojo izq\n    vec2 pc1p1=vec2(.363,.372);\n    vec2 pc1p2=vec2(.354,.463);\n    vec2 pc1p3=vec2(.429,.426);\n\n    vec2 pc2p1=vec2(.363,.372);\n    vec2 pc2p2=vec2(.370,.285);\n    vec2 pc2p3=vec2(.425,.318);\n    float db1= sdBezier(p,pc1p1,pc1p2,pc1p3 );\n    float db2= sdBezier(p,pc2p1,pc2p2,pc2p3 );\n     \n     //ojo der\n    p=p0*vec2(0.8)-vec2(-0.45,-0.6);   \n    vec2 pc3p1=vec2(.568,.360);\n    vec2 pc3p2=vec2(.571,.467);\n    vec2 pc3p3=vec2(.500,.430);\n\n    vec2 pc4p1=vec2(.568,.360);\n    vec2 pc4p2=vec2(.565,.326);\n    vec2 pc4p3=vec2(.550,.314);\n    float db3= sdBezier(p,pc3p1,pc3p2,pc3p3 );\n    float db4= sdBezier(p,pc4p1,pc4p2,pc4p3 );\n    db1= unionSDF(db1,db2);\n    db3= unionSDF(db3,db4);\n    col = DrawFigDelgado(vec3(0.0),col,db1);\n    col = DrawFigDelgado(vec3(0.0),col,db3);\n return col;\n}   \n\n\nvec3 HacerRostro2d(vec2 uv, vec3 col)\n{   vec2 p0=uv; \n    vec2 p=uv;\n    float r;\n    float d1, d2, d3;\n    float d4a,d4b,d5a,d5b;\n    vec2 pa , pb;\n    \n    //cabeza\n    p = p0;\n    p-= vec2(-0.08, 0.1);\n    p*=  vec2(0.95, 0.76);\n    d1 = sdCircle(p, 0.5);\n    \n    float d1a=sdCircle(p*vec2(0.7,1.0)-vec2(0.0,0.17), 0.33);\n    float d1b=sdCircle(p*vec2(0.7,1.0)-vec2(0.0,-0.17), 0.33);\n    d1= unionSDF( d1,d1a);\n    d1= unionSDF( d1,d1b);\n    \n    //puntos en frente\n    r = 0.015;\n    pa = p0;\n    pa.y+=0.12;\n    pa.x+=0.06;\n    pa.x=abs(pa.x)-0.01;\n    \n    float d6a = sdCircle(pa- vec2(0.05, 0.5), r);\n    float d6b = sdCircle(pa- vec2(0.05, 0.4), r);\n    float d6c = sdCircle(pa- vec2(0.05, 0.3), r);\n    \n    //orejas\n    r = 0.15;\n    pa = p0*vec2(1.0,0.8)-vec2(-0.07,-0.5);\n    pa.x=abs(pa.x)-0.4;\n    float d7a = sdCircle(pa- vec2(0.05, 0.4), r);\n    \n    col = DrawFigBorde(vec3(1.0, 1.0, 1.0), col, d7a);\n    col=DrawFigBordeR(vec3(0.99, 0.917, 0.811), col, d1,0.001);  //cabeza\n    \n    vec2 pmov=p0-vec2(0.0,0.15*abs(sin(iTime)) );\n    col= HacerOjos(pmov,col);\n    \n    p=p0*vec2(0.7,0.7)-vec2(0.0,0.2);\n    //ceja iqz\n    col= HacerCejaIzq(p-vec2(0.02,0.5),col);\n    col= HacerCejaIzq(vec2(-p.x, p.y)-vec2(0.12,0.45),col);\n    \n    col= DrawFigDelgado(vec3(0.905, 0.815, 0.666), col, d6a);\n    col= DrawFigDelgado(vec3(0.905, 0.815, 0.666), col, d6b);\n    col= DrawFigDelgado(vec3(0.905, 0.815, 0.666), col, d6c);\n    \n    col=HacerBoca(pmov-vec2(-0.28,0.38),col);\n    col=HacerBrazo(p,col);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=1.0;\n    uv*=esc;\n\n    vec3  col=vec3(0.45,0.7,1.0)-uv.y*0.5/esc;\n    col= HacerRostro2d(uv-vec2(0.0,0.5),col);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "float dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdSWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[335, 335, 371, 371, 416], [422, 422, 469, 469, 496], [497, 497, 540, 540, 567], [568, 568, 616, 616, 644], [647, 647, 719, 719, 845], [847, 847, 909, 909, 1039], [1041, 1041, 1122, 1122, 1250], [1252, 1252, 1309, 1309, 1379], [1381, 1381, 1443, 1443, 1508], [1510, 1510, 1578, 1578, 1646], [1648, 1648, 1712, 1712, 1783], [1786, 1786, 1820, 1820, 1915], [1917, 1917, 1954, 1954, 2028], [2030, 2030, 2065, 2065, 2088], [2090, 2090, 2127, 2127, 2409], [2411, 2411, 2445, 2445, 2760], [2762, 2762, 2797, 2797, 3251], [3253, 3253, 3287, 3287, 4450], [4456, 4456, 4495, 4495, 5991], [5993, 5993, 6050, 6050, 6332]], "test": "untested"}
{"id": "7l3XW2", "name": "noise blobby blobs", "author": "SnoopethDuckDuck", "description": "float v = h21(floor(h21(ipos) + iTime) + 0.01 * ipos); is a nice technique\n\ne.g.\nhttps://www.shadertoy.com/view/7tdSDj", "tags": ["e"], "likes": 10, "viewed": 369, "published": 3, "date": "1639780138", "time_retrieved": "2024-07-30T18:41:28.108122", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 thc(float a, vec3 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat h21 (float a, float b, float sc) {\n    a = mod(a, sc); b = mod(b, sc);\n    return fract(sin(dot(vec2(a, b), vec2(12.9898, 78.233)))*43758.5453123);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 pnt(vec2 ipos, float sc) {\n    float h = h21(ipos.x, ipos.y, sc);\n    float t = iTime + 10. * h;\n    float k = 1.5 +  h;\n    return 0.4 * vec2(thc(4. * (1.-h), 100. + k * t), \n                      ths(4. * h, 100. + (1.-k) * t));\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b * cos(6.28318*(c*t+d) );\n}\n\nfloat fn(vec2 p, float time) {\n    float m = fract(h21(p) + time);\n    return m * m * (3. - 2. * m);\n}\n\nfloat test(vec2 p, float time, float a) {\n    return h21(floor(h21(p) + time) + a + 0.01 * p);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/ iResolution.y;\n    vec2 ouv = uv;\n   // ouv *= 2.3;\n        \n    float a = atan(uv.y, uv.x);\n    float r = length(uv); \n    uv.y += 0.02 * iTime; // 0.06\n\n    float sc = 20.;\n    vec2 fpos = fract(sc * uv) - 0.; // dont include -0.5, so box lerp is easier\n    vec2 ipos = floor(sc * uv) + 0.;    \n    \n    // box corner points\n    vec2 lp = ipos + vec2(1.,0.);\n    vec2 tp = ipos + vec2(0.,1.);\n    vec2 tlp = ipos + vec2(1.);\n    vec2 idp = ipos;\n\n    float time = 0.5 * iTime;\n    \n    // corner value 1: floor(time)\n    float l = test(lp, time, 0.);\n    float t = test(tp, time, 0.);\n    float tl = test(tlp, time, 0.);\n    float id = test(idp, time, 0.);\n    \n    // corner value 2: floor(time) + 1.\n    float l2 = test(lp, time, 1.);\n    float t2 = test(tp, time, 1.);\n    float tl2 = test(tlp, time, 1.);\n    float id2 = test(idp, time, 1.);\n    \n    // lerp between corner values, present and future\n    l = mix(l, l2, fn(lp, time));\n    t = mix(t, t2, fn(tp, time));\n    tl = mix(tl, tl2, fn(tlp, time));\n    id = mix(id, id2, fn(idp, time));\n    \n    // smooth fpos so end points meet continuously\n    vec2 sfpos = fpos * fpos * (3. - 2. * fpos);\n\n    // box lerp corner values\n    float v = l  * sfpos.x      * (1.-sfpos.y)\n     \t    + t  * (1.-sfpos.x) * sfpos.y\n     \t    + tl * sfpos.x      * sfpos.y\n      \t    + id * (1.-sfpos.x) * (1.-sfpos.y);\n    \n    // remove me to see grid version\n    v += 0.4 + 1.2 * (1. - length(ouv)) * cos(20. * length(ouv) + 0. * atan(ouv.y, ouv.x) - 2. * iTime);\n    \n    float k = 0.1; \n    float s = smoothstep(-k, k, -v + 0.3);\n    s = pow(4. * (1.-s) * s, 2.);\n    \n    float k2 = 0.1;\n    s = step(0.4, s); //smoothstep(-k2, k2, s - 0.4);\n\n    vec3 col = vec3(s);\n    vec3 e = vec3(1.);\n    col = s * pal(h21(vec2(ipos)), e, e, e, vec3(0.,0.33,0.66));\n    \n    \n    fragColor = vec4(col, 1.); //vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3XW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 191, 191, 232], [234, 234, 254, 254, 329], [331, 331, 371, 371, 486], [488, 488, 540, 540, 659], [661, 661, 692, 692, 898], [900, 900, 968, 968, 1012], [1014, 1014, 1044, 1044, 1116], [1118, 1118, 1159, 1159, 1214], [1218, 1218, 1275, 1275, 3181]], "test": "untested"}
{"id": "slcSW2", "name": "trippy butterfly thing i dont kn", "author": "SnoopethDuckDuck", "description": "im not sure if this is a monstrosity or a masterpiece", "tags": ["e"], "likes": 22, "viewed": 549, "published": 3, "date": "1639779503", "time_retrieved": "2024-07-30T18:41:28.870085", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 thc(float a, vec3 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat h21 (float a, float b, float sc) {\n    a = mod(a, sc); b = mod(b, sc);\n    return fract(sin(dot(vec2(a, b), vec2(12.9898, 78.233)))*43758.5453123);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 pnt(vec2 ipos, float sc) {\n    float h = h21(ipos.x, ipos.y, sc);\n    float t = iTime + 10. * h;\n    float k = 1.5 +  h;\n    return 0.4 * vec2(thc(4. * (1.-h), 100. + k * t), \n                      ths(4. * h, 100. + (1.-k) * t));\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b * cos(6.28318*(c*t+d) );\n}\n\nfloat test(vec2 p) {\n    return h21(floor(h21(p) + iTime) + 0.01 * p);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/ iResolution.y;\n    vec2 ouv = uv;\n    ouv.y += 0.05 * cos(iTime);\n    vec2 ms = (iMouse.xy - 0.5 * iResolution.xy)/ iResolution.y;\n    //uv += 3. + 0.04 * iTime;\n    \n    float a = atan(uv.y, uv.x);\n    float r = length(uv); \n    //uv = vec2(4. * a/pi, log(r) - 0.1 * iTime);\n    \n    float c = 2.;\n    // cant scale dynamically because sc used in h21 (bad)\n    float sc = 50.;// + 1./length(ouv-ms);\n    vec2 fpos = fract(sc * uv) - 0.;\n    vec2 ipos = floor(sc * uv) + 0.5;    \n    \n    // Generate values for each corner of uv (sloppy)\n    float l  = h21(ipos.x + 1., ipos.y,      c * sc);\n    float t  = h21(ipos.x,      ipos.y + 1., c * sc);\n    float tl = h21(ipos.x + 1., ipos.y + 1., c * sc);\n    float id = h21(ipos.x,      ipos.y,      c * sc);\n\n    vec2 lp = ipos + vec2(1.,0.);\n    vec2 tp = ipos + vec2(0.,1.);\n    vec2 tlp = ipos + vec2(1.);\n    vec2 idp = ipos;\n\n    l = test(lp);\n    t = test(tp);\n    tl = test(tlp);\n    id = test(idp);\n    \n    //float v = h21(floor(h21(ipos) + iTime) + 0.01 * ipos);\n\n    // Smooth fpos completely, so v noise looks better\n    vec2 sfpos = fpos * fpos * (3. - 2. * fpos);\n    \n    // Smooth the grid uvs so different uvs meet continuously on the edges\n    //fpos = mix(fpos, fpos * fpos * (3. - 2. * fpos), 0.5 * thc(4., iTime));\n    \n    // Box lerp between the corner values to get a radius value for this pixel\n    float v = l  * sfpos.x      * (1.-sfpos.y)\n     \t    + t  * (1.-sfpos.x) * sfpos.y\n     \t    + tl * sfpos.x      * sfpos.y\n      \t    + id * (1.-sfpos.x) * (1.-sfpos.y);\n            \n    uv *= mix(0.6, 0.2, 0.5 + 0.5 * thc(4., v * 10. + iTime));// + 0.5 * cos(v + iTime);\n    vec2 p = vec2(thc(2., 0.2 * v + 8. * abs(uv.x) + 2. * a - iTime), \n                  ths(2., 0.2 * v + 8. * abs(uv.y) - 3. * a - iTime));\n    uv.x *= thc(4., iTime + 8. * p.x);\n    uv.y *= ths(4., iTime + 8. * p.y);\n    float d = length(uv/p);\n    float k = 0.1 * v;\n    float s = smoothstep(-k,k, -d + 0.15);\n    s *= 4. * s * s;\n    s = clamp(s, 0., 1.);\n    vec3 col = vec3(s);\n    vec3 e = vec3(1.);\n    col = s * pal(thc(2., 0.1 * h21(ipos) + 10. * r + 4. * length(p) - iTime), \n                    e, e, e, mix(0., 0.5, 0.5 + 0.5 * cos(length(p)*32. + iTime)) + 0.5 * vec3(0.,0.33,0.66));\n    \n    //col *= smoothstep(-v * 0.2, v, -length(ouv) + 0.25);\n    col *= mix(smoothstep(-v * 0.2, v, -length(ouv) + 0.25), 1., 0.5 + 0.5 * cos(0.8 * iTime));\n    fragColor = vec4(col, 1.); //vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcSW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 191, 191, 232], [234, 234, 254, 254, 329], [331, 331, 371, 371, 486], [488, 488, 540, 540, 659], [661, 661, 692, 692, 898], [900, 900, 968, 968, 1012], [1014, 1014, 1034, 1034, 1086], [1090, 1090, 1147, 1147, 3643]], "test": "untested"}
{"id": "flcSW2", "name": "simple refraction test", "author": "drschizzo", "description": ".", "tags": ["raymarching", "reflect", "refract"], "likes": 124, "viewed": 5527, "published": 3, "date": "1639759279", "time_retrieved": "2024-07-30T18:41:29.712831", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n\n#define MAX_STEPS 200\n#define MAX_DIST 30.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nstruct Hit{\n    float d;\n    float obj;\n    vec3 id;\n};\n\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nHit GetDist(vec3 p) {\n\n    vec3 boxpos=p;\n\n    \n    boxpos.xz*=Rot(T*.7);\n   boxpos.xy*=Rot(-T*.5);\n   boxpos.yz*=Rot(-T*.8);\n    \n    float d = sdRoundBox(boxpos, vec3(.9),.2);\n   \n   float obj=-0.;\n //  boxpos.xy*=Rot(-T);\n //  boxpos.yz*=Rot(T);\n\n    \n   float rep=mix(.5,1.8,.5+.5*(sin(T*.4)));\n   boxpos+=rep/2.;\n   vec3 q=mod((boxpos),rep)-rep/2.;\n   vec3 ids=floor(boxpos-q);\n   float s2 = length(q)-(.08+(.05*sin(T+(ids.x+ids.y)+ids.z)))*(rep*2.);\n   float s2bis = sdBox(q,vec3((.05+(.05*sin(T+(ids.x+ids.y)+ids.z)))*(rep*2.)));\n   s2=mix(s2,s2bis,.5+.5*sin(T*2.+(ids.x+ids.y)+ids.z));\n   s2=max(d+.01,s2);\n   \n   d=max(d,-s2+.08);//*(rep+.5));    \n    \n    if(s2<d)\n        obj=1.;\n    \n    \n    d=min(s2,d);\n    \n        \n    vec3 q2=mod(p,2.)-1.;\n    vec3 id=floor(p-q2);\n    q2.y=p.y+sin(T+id.x*id.y)*.5+1.35;\n    float ds=length(q2)-.4;    \n    \n    ds=max(ds,-sdBox(p,vec3(2.5)));\n    ds=max(ds,length(p)-6.);\n    if(ds<d){\n        obj=3.;\n    }\n    d=min(d,ds);\n    \n    float pl=p.y+1.5;\n    if(pl<d)\n        obj=3.;\n    \n    d=opSmoothUnion(d,pl,.4);    \n    \n      \n\n    return Hit(d,obj,ids);\n}\n\nHit RayMarch(vec3 ro, vec3 rd,float direction) {\n\tfloat dO=0.;\n    float obj=0.;\n    vec3 id;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        Hit h=GetDist(p);\n        obj=h.obj;\n        id=h.id;\n        float dS = h.d*direction;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return Hit(dO,obj,id);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).d;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).d,\n        GetDist(p-e.yxy).d,\n        GetDist(p-e.yyx).d);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 1.5, -5);\n    if(dot(m.xy,m.xy)>0.){\n        ro.yz *= Rot(-min(m.y,.45)*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n       }\n       \n   ro.xz*=Rot(T/2.);    \n       \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float bo=6.;\n    float fresnel=1.;\n\n    bool issecond=false;\n    Hit h;\n    float i=0.;\n    vec3 p;\n    for(;i<bo;i++){\n    \n        h=RayMarch(ro, rd,1.);\n        float IOR=1.35;\n        //col*=1./bo;\n        \n\n        if(h.d<MAX_DIST){\n            \n            if(h.obj==0.){\n                p = ro + rd * h.d;\n                vec3 n = GetNormal(p);\n                \n               \n                vec3 rIn=refract(rd,n,1./IOR);\n\n                Hit hIn= RayMarch(p-n*.003,rIn,-1.);\n                \n                float dIn=hIn.d;\n                vec3 pIn=p+rIn*dIn;\n                vec3 nIn=-GetNormal(pIn);\n\n                vec3 rOut=vec3(0.);\n                float shift=.01;\n\n                rOut=refract(rIn,nIn,IOR);\n                if(dot(rOut,rOut)==0.) rOut=reflect(-rIn,nIn);\n                ro=pIn-nIn*.03;\n                rd=rOut;\n                \n            }\n            else if(h.obj==1.){\n                vec3 p = ro + rd * h.d;\n                vec3 n = GetNormal(p);\n                float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n                col+=((.5+.5*sin((vec3(.54,.3,.7)+h.id)*T))*fresnel)*.7;\n                col *= vec3(dif);\n                //*1./bo;\n                break;\n            }\n            else if(h.obj==2.){\n                break;\n                vec3 p = ro + rd * h.d;\n                vec3 n = GetNormal(p);\n                float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n                col+=vec3(.2,.1,.8);\n\n                col *= vec3(dif);\n                break;\n            }\n            else if(h.obj==3.){\n                p = ro + rd * h.d;\n                vec3 n = GetNormal(p);\n                \n                ro=p+n*.003;\n                rd=reflect(rd,n);\n                if(!issecond){\n                    fresnel=pow(1.-dot(rd,n),2.);\n                //col+=vec3(.03,.08,.1);\n                   }\n                issecond=true;\n            }\n            \n        }\n        else{\n            vec3 bcolor=vec3(.08);\n            if(i==0. ){\n                col=bcolor;\n\n                }\n            else\n                col=mix((col+texture(iChannel0,rd.xyz).xyz)/i*fresnel,bcolor,1.-S(15.,0.,length(p)));\n            break;\n        }\n    }\n    \n    \n \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcSW2.jpg", "access": "api", "license": "mit", "functions": [[1409, 1409, 1428, 1428, 1490], [1551, 1551, 1596, 1596, 1687], [1689, 1689, 1718, 1718, 1799], [1802, 1802, 1854, 1854, 1953], [1956, 1956, 1977, 1977, 3069], [3071, 3071, 3119, 3119, 3433], [3435, 3435, 3459, 3459, 3657], [3659, 3659, 3709, 3709, 3900], [3904, 3904, 3960, 3960, 6637]], "test": "untested"}
{"id": "NlcXW2", "name": "a little idea", "author": "SnoopethDuckDuck", "description": "d = length(uv/p - 1.) where p is some point with motion is kind of interesting - moves the point but flips (or squashes?)  it too, not sure what else u could do with it ", "tags": ["e"], "likes": 46, "viewed": 533, "published": 3, "date": "1639759038", "time_retrieved": "2024-07-30T18:41:30.486763", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n   \n    float sc = 64.; // change me\n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    \n    float h = h21(ipos);\n    float time = 0.2 * h + 0.3 * mlength(fpos) + iTime;\n    \n    vec2 p = 0.5 * vec2(thc(3., time), ths(3., time));\n    \n    float e = 0.4;\n    float d = length(uv / p - e);\n    \n    float k = 0.2;\n    float s = smoothstep(-k, k, -d + pow(cos(24. * d - iTime),3.) * e);\n    \n    vec3 col = s * pal(ths(3., time) + thc(3., time), vec3(1.), vec3(1.), vec3(1.), (0.5/3.) * vec3(0,1,2));\n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcXW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 232, 232, 275], [277, 277, 297, 297, 372], [374, 374, 398, 398, 438], [440, 440, 497, 497, 1117]], "test": "untested"}
{"id": "fl3XDj", "name": "Pixel void", "author": "_Chae4ek_", "description": "Simple pixel void", "tags": ["noise", "perlin", "pixel", "void"], "likes": 2, "viewed": 278, "published": 3, "date": "1639749338", "time_retrieved": "2024-07-30T18:41:31.333498", "image_code": "float rand(in vec2 st) {\n  return fract(sin(dot(st.xy, vec2(13.0, 79.0))) * 2764.4437);\n}\n\nvec3 rand(in vec3 s) {\n  float t = 4096.0 * sin(dot(s, vec3(17.0, 31.0, 11.0)));\n  return vec3(fract(512.0 * t), fract(64.0 * t), fract(8.0 * t)) - 0.5;\n}\n\n// simplex perlin noise\nfloat snoise(in vec3 p) {\n  vec3 s = floor(p + dot(p, vec3(0.33333333333)));\n  vec3 x = p - s + dot(s, vec3(0.16666666667));\n\n  vec3 e = step(0.0, x - x.yzx);\n  vec3 i1 = e * (1.0 - e.zxy);\n  vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\n  vec3 x1 = x - i1 + 0.16666666667;\n  vec3 x2 = x - i2 + 0.33333333333;\n  vec3 x3 = x - 0.5;\n\n  vec4 w = vec4(dot(x, x), dot(x1, x1), dot(x2, x2), dot(x3, x3));\n  w = max(0.6 - w, 0.0);\n  w = pow(w, vec4(4.0));\n  w *= vec4(dot(rand(s), x), dot(rand(s + i1), x1), dot(rand(s + i2), x2), dot(rand(s + 1.0), x3));\n\n  return dot(w, vec4(30.0, 60.0, 50.0, 15.0));\n}\n\n#define PI 3.14159265359\n\nconst vec3 AZUR = vec3(0.0, 0.5, 1.0);\n\n#define scale 50.0\n#define speed 0.07\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 st = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n  st *= scale;\n\n  vec2 vel = vec2(iTime * speed * scale);\n  vec2 ipos = floor(st + vel);\n  float randpos = rand(ipos);\n  // magic\n  float sq = snoise(vec3(ipos, randpos)) * (sin(iTime * PI * randpos + randpos * 3443.0) + randpos) * 0.3;\n\n  vec3 color = AZUR * sq;\n\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3XDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 89], [91, 91, 113, 113, 245], [247, 271, 296, 296, 859], [966, 966, 1021, 1021, 1387]], "test": "untested"}
{"id": "sttSDB", "name": "nahkd's Bloom Effect", "author": "nahkd123", "description": "Shader that applies bloom effect. Colors are encoded using tanh() function and decoded with atanh() function. Values that's larger than 1 will gives bloom effect", "tags": ["postprocessing", "bloom"], "likes": 7, "viewed": 352, "published": 3, "date": "1639735468", "time_retrieved": "2024-07-30T18:41:32.230101", "image_code": "// Post processing\n// Set the speed to something lower to increase quality\n#define SPEED 6\n\nvec4 emitAt(vec2 uv) {\n    vec4 channelColor = clamp(atanh(texture(iChannel0, uv)), 0.0, 3.0);\n    vec4 baseColor = clamp(channelColor, 0.0, 1.0);\n    return channelColor - baseColor * 0.87;\n}\n\nvec4 blurH(vec2 fragCoord, int radiusPx) {\n    float mul = 1. / float(radiusPx);\n    vec4 result = emitAt(fragCoord/iResolution.xy) * mul;\n    for (int i = 1; i < radiusPx; i += SPEED) {\n        result += emitAt((fragCoord + vec2(i, 0))/iResolution.xy) * mul * float(SPEED) * 0.5;\n        result += emitAt((fragCoord + vec2(-i, 0))/iResolution.xy) * mul * float(SPEED) * 0.5;\n    }\n    return result;\n}\nvec4 blurAll(vec2 fragCoord, int radiusPx) {\n    float mul = 1. / float(radiusPx);\n    vec4 result = blurH(fragCoord, radiusPx) * mul;\n    for (int i = 1; i < radiusPx; i += SPEED) {\n        result += blurH(fragCoord + vec2(0, i), radiusPx) * mul * float(SPEED) * 0.5;\n        result += blurH(fragCoord + vec2(0, -i), radiusPx) * mul * float(SPEED) * 0.5;\n    }\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 channelColor = clamp(atanh(texture(iChannel0, uv)), 0.0, 2.0);\n    vec4 baseColor = clamp(channelColor, 0.0, 1.0);\n    \n    fragColor = baseColor + blurAll(fragCoord, 50);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 pixelAt(vec2 uv) {\n    vec4 color = texture(iChannel0, uv);\n    \n    // Sliding window\n    float p = (cos(iTime) + 1.0) / 2.0;\n    if (p >= uv.x - 0.02 && p <= uv.x + 0.02) return vec4(0);\n    else if (p <= uv.x) return color;\n\n    if (uv.y > 0.97) return vec4(1, 0, 0, 1);\n    if (color.r > 0.8 || color.g > 0.8 || color.b > 0.8) return color * 20.0;\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = tanh(pixelAt(uv));\n}\n", "buffer_a_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttSDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 114, 114, 284], [286, 286, 328, 328, 688], [689, 689, 733, 733, 1071], [1073, 1073, 1128, 1128, 1351]], "test": "untested"}
{"id": "stdXDS", "name": "Azimuthal Projections", "author": "paniq", "description": "Three of the most popular invertible azimuthal projections, for equal-area, equidistance and conformant mappings to and from the disc, including various invertible disc <-> square mappings", "tags": ["projection", "area", "spherical", "equal", "arcmap"], "likes": 17, "viewed": 578, "published": 3, "date": "1639731276", "time_retrieved": "2024-07-30T18:41:33.192528", "image_code": "\n// if defined, demonstrate the inverse mapping \n//#define SHOW_INVERSE\n\n// if defined, adjusts the latitude so that equal spaced points on the map\n// are equal spaced on the sphere; if not defined, the latitude will map\n// exactly to the radius.\n#define FIX_EQUAL_AREA\n\n// if defined, adjusts the latitude so that crossing angles are preserved\n// this excludes the equidistant or equal-area properties.\n//#define FIX_CONFORMAL\n\n// if defined, stretches the map to cover the entire UV square; various\n// modes are available below, of which the default provides an equiareal\n// mapping.\n//#define SQUARIFY\n\n// if defined, shows an environment map instead of a XYZ color gradient\n// for inverse mode, demonstrates texture mapping\n#define SHOW_CUBEMAP\n\n// if defined, shows latitude/longitude lines\n#define SHOW_FLOW_LINES\n\n// if defined, shows the latitude as cos(theta) instead of theta\n//#define SHOW_COS_THETA\n\n// if defined, shows a UV tesselation of quadliterals, and the proportional\n// difference between the quadliteral area and the expected average size (2/N)\n// if FIX_EQUAL_AREA is defined, the proportions will be ideal.\n//#define SHOW_SOLID_ANGLE\n\n// if not defined, computes a more accurate solid angle from cosines,\n// though the precision of this method is terrible and is only relevant\n// for rough tesselations anyway.\n#define USE_TRIANGLE_AREA\n\n// subdivisions per quadrant\n#if defined(SHOW_SOLID_ANGLE)||defined(SHOW_INVERSE)\n#undef SHOW_FLOW_LINES\n// solid angle subdivisions\nconst float subdivisions = 32.0;\n#else\n// flow line subdivisions\nconst float subdivisions = 16.0;\n#endif\n\n// thesis related functions\n//////////////////////////////////////////////////////////\n\n//#define TEST_EQUIAREAL\n//#define TEST_INVERTIBLE\n#ifdef TEST_INVERTIBLE\n#undef SHOW_CUBEMAP\n#endif\n\n// some of the square<->disc conversion functions are from\n// https://arxiv.org/abs/1509.06344\n// https://jcgt.org/published/0005/02/01/\n// area normalization after\n// Stratified Sampling of 2-Manifolds, James Arvo\n// https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.3412&rep=rep1&type=pdf\n\n// approximate inverse of f(x) = x - sin(x)\n// used by chord mapping\nfloat inverse_diff_sinx_x(float y) {\n    // newton's method\n    float y0 = mod(y, radians(360.0));\n    float x = y0 - sign(y0 - radians(180.0));\n    // higher resolutions might require more iterations\n    for (int i = 0; i < 4; ++i) { \n        float f_x = x - sin(x) - y0;\n        float ff_x = 1.0 - cos(x);\n        x = x - f_x / ff_x;\n    }\n    return (y == 0.0)?y:(x + y - y0);\n}\n\nvec2 inv_shirley_chiu(vec2 p) {\n    // Shirley-Chiu Mapping (L1 arclength, equiareal)\n    float r = length(p);\n    float a = atan(p.y, p.x) / radians(360.0) - 0.125;\n    float px = abs(fract(a) - 0.5);\n    float py = abs(fract(a - 0.25) - 0.5);\n    return (4.0 * r) * vec2(px - py, px + py - 0.5);\n}\n\nvec2 shirley_chiu(vec2 p) {\n    // Shirley-Chiu Mapping (L1 arclength, equiareal)\n    bool is_h = (abs(p.x) > abs(p.y));\n    vec2 o = is_h?p:p.yx;\n    float r = o.x;\n    float h = o.y/r - 1.0;\n    float phi = radians(45.0)*(1.0 + ((r == 0.0)?0.0:(is_h?h:-h)));\n    return vec2(cos(phi),sin(phi))*r;\n}\n\n// map a square [-1..1]x[-1..1] to a disc of radius 1\nvec2 square_disc(vec2 p) {\n#if 0\n    // Elliptical Grid Mapping (Philip Nowell)\n    // http://mathproofs.blogspot.com/2005/07/mapping-square-to-circle.html\n    p = p*sqrt(1.0 - p.yx*p.yx/2.0);\n    return p;\n#elif 0\n    // FG-Squircular Mapping (Fernandez Guasti squircle)\n    vec2 pp = p*p;\n    float L = pp.x + pp.y;\n    p = p*sqrt((L - pp.x * pp.y)/L);    \n    return p;\n#elif 0\n    // polar equi-areal\n    float r = sqrt((p.x+1.0)/2.0);\n    float phi = p.y*radians(180.0);\n    return r*vec2(cos(phi),sin(phi));\n#elif 0\n    // chord mapping, equi-areal\n    float a = (1.0 - abs(p.y))*radians(180.0); // A*2\n    float theta = inverse_diff_sinx_x(a)/2.0; // theta/2\n    p.y = cos(theta)*sign(p.y);\n    p.x = p.x * sin(theta);\n    return p;\n#elif 0\n    // half-concentric chord mapping, equi-areal\n    p = vec2(p.y + p.x, p.x - p.y)*0.5;\n\n    float h1 = 1.0 - abs(p.y);\n    p.x = (h1 == 0.0)?0.0:(p.x / h1);\n\n    float a = h1*h1*radians(180.0); // A*2\n    float theta = inverse_diff_sinx_x(a)/2.0; // theta/2\n    p.y = cos(theta)*sign(p.y);\n    p.x = p.x * sin(theta);\n\n    p = vec2(p.y + p.x, p.x - p.y)*sqrt(0.5);\n    return p;\n#elif 0\n    // L1 elliptical grid mapping, area-normalized\n    vec2 s = sign(p);\n    p = abs(p);\n    \n    // warp parameters\n    float c0 = 1.0/2.0*sqrt(-8.0*p.x + 9.0);\n    p = vec2(\n        3.0/2.0 - c0,\n        1.0/2.0 + c0 - sqrt(5.0/2.0 - 2.0*p.x - c0*(2.0*p.y - 1.0)));\n    // map\n    p = p*(1.0 - p.yx/2.0);\n    \n    p = p * s;\n    \n    p = vec2(p.y + p.x, p.y - p.x);\n    p = shirley_chiu(p);    \n    return p;\n#elif 1\n    // Shirley-Chiu Mapping (L1 arclength, equiareal)\n    return shirley_chiu(p);\n#else\n    // Stretching\n    return p/length(p)*max(abs(p.x),abs(p.y));\n#endif\n}\n\n// map a disc of radius 1 to a square [-1..1]x[-1..1]\nvec2 disc_square(vec2 p) {\n#if 0\n    // Elliptical Grid Mapping (Philip Nowell)\n    // http://mathproofs.blogspot.com/2005/07/mapping-square-to-circle.html\n    vec2 pp = p*p;\n    float z1 = pp.x - pp.y;\n    vec2 z = 2.0 + vec2(z1,-z1);\n    vec2 w = 2.0 * sqrt(2.0) * p;\n    return (sqrt(z + w) - sqrt(z - w))/2.0;\n#elif 0\n    // FG-Squircular Mapping (Fernandez Guasti squircle)\n    vec2 pp = p*p;\n    float L = pp.x + pp.y;\n    return sqrt(0.5)*sign(p)/abs(p.yx)* sqrt(L - sqrt(L*(L - 4.0*pp.x*pp.y)));\n#elif 0\n    // polar equi-areal\n    float r = dot(p,p);\n    float phi = atan(p.y,p.x);\n    return vec2(r*2.0-1.0, phi/radians(180.0));\n#elif 0\n    // chord mapping, equi-areal\n    float c = sqrt(1.0 - p.y*p.y); // half chord\n    float a = asin(c) - c*abs(p.y);\n    p.x /= c;\n    p.y = (1.0 - a/radians(90.0))*sign(p.y);\n    return p;\n#elif 0\n    // half-concentric chord mapping, equi-areal\n    p = vec2(p.y + p.x, p.x - p.y)*sqrt(0.5);\n    float c = sqrt(1.0 - p.y*p.y);\n    float a = asin(c) - c*abs(p.y);\n    float h1 = sqrt(a/radians(90.0));\n    p.y = (1.0 - h1)*sign(p.y);\n    p.x = (c == 0.0)?0.0:(p.x * h1 / c);\n    p = vec2(p.y + p.x, p.x - p.y);    \n    return p;\n#elif 0\n    // L1 elliptical grid mapping, area-normalized\n    p = inv_shirley_chiu(p);\n    p = vec2(p.x - p.y, p.x + p.y)/2.0;\n    vec2 s = sign(p);\n    p = abs(p);\n    p = 1.0/2.0*p - 1.0/2.0*p.yx - 1.0/2.0*sqrt(p*p - 2.0*(p + 2.0)*p.yx + p.yx*p.yx - 4.0*p + 4.0) + 1.0;\n    p = vec2(\n        3.0/2.0*p.x - 1.0/2.0*p.x*p.x,\n        (2.0*(p.x - 2.0)*p.y + p.y*p.y)/(2.0*p.x - 3.0));    \n    p = p * s;\n    return p;\n#elif 1\n    // Shirley-Chiu Mapping (L1 arclength, equiareal)\n    return inv_shirley_chiu(p);\n#else\n    // Stretching\n    return p/max(abs(p.x),abs(p.y))*length(p);\n#endif\n}\n\nvec3 conformal_normal(vec2 uv) {\n    // Stereographic map projection\n    float rr = dot(uv,uv);\n    float sin_a_div_r = 2.0/(rr + 1.0);\n    float cos_a = (1.0 - rr)*0.5*sin_a_div_r;\n    return vec3(uv*sin_a_div_r, cos_a);\n}\n\nvec2 conformal_disc(vec3 n) {\n    // Stereographic map projection\n    return n.xy/(n.z + 1.0);\n}\n\nvec3 equalarea_normal(vec2 uv) {\n    // lambert azimuthal equal-area projection\n    float rr = dot(uv,uv);\n    float cos_a = 1.0 - rr;\n    float sin_a_div_r = sqrt(2.0 - rr);\n    return vec3(uv*sin_a_div_r, cos_a);\n}\n\nvec2 equalarea_disc(vec3 n) {\n    // lambert azimuthal equal-area projection\n    return n.xy/sqrt(n.z + 1.0);\n}\n\nvec3 equidistant_normal(vec2 uv) {\n    // azimuthal equidistant projection\n    float r = length(uv);\n    float a = r*radians(90.0);\n    return vec3(((r==0.0)?vec2(0.0):(uv/r*sin(a))), cos(a));\n}\n\nvec2 equidistant_disc(vec3 n) {\n    // azimuthal equidistant projection\n    float a = acos(n.z);\n    float r = a/radians(90.0);\n    return n.xy/sin(a)*r;\n}\n\n// arcmap coordinates to normal\nvec3 arcmap_normal(vec2 uv) {\n#ifdef SQUARIFY\n    uv = square_disc(uv);\n#endif\n#ifdef FIX_CONFORMAL\n    return conformal_normal(uv);\n#elif defined(FIX_EQUAL_AREA)\n    return equalarea_normal(uv);\n#else\n    return equidistant_normal(uv);\n#endif        \n}\n\n// normal to arcmap coordinates\nvec2 normal_arcmap(vec3 n) {\n    vec2 uv;\n#ifdef FIX_CONFORMAL\n    uv = conformal_disc(n);\n#elif defined(FIX_EQUAL_AREA)\n    uv = equalarea_disc(n);\n#else\n    uv = equidistant_disc(n);\n#endif  \n#ifdef SQUARIFY\n    return disc_square(uv);\n#else\n    return uv;\n#endif\n}\n\n// visualization\n//////////////////////////////////////////////////////////\n\nfloat triangle_area(vec3 A, vec3 B, vec3 C) {\n    return length(cross(B - A, C - A)) / 2.0;\n}\n\nvec2 nanglebasis (vec3 a, vec3 b) {\n    float ab = dot(a, b);\n    return vec2(ab, sqrt(1.0 - ab * ab));\n}\n\nfloat simplex_solid_angle (vec2 u, vec2 v, vec2 w) {\n    float A =\n            acos((u.x - v.x * w.x) / (v.y * w.y))\n            + acos((v.x - w.x * u.x) / (w.y * u.y))\n            + acos((w.x - u.x * v.x) / (u.y * v.y))\n            - radians(180.0);\n    return (A != A)?0.0:A;\n}\n\nfloat pyramid_points_solid_angle (vec3 A, vec3 B, vec3 C, vec3 D) {\n#ifdef USE_TRIANGLE_AREA\n    return triangle_area(A, B, C) + triangle_area(C, D, A);\n#else\n    vec2 ab = nanglebasis(A, B);\n    vec2 ac = nanglebasis(A, C);\n    vec2 da = nanglebasis(A, D);\n    vec2 bc = nanglebasis(B, C);\n    vec2 cd = nanglebasis(C, D);\n    return simplex_solid_angle(bc, ac, ab) + simplex_solid_angle(da, ac, cd);\n#endif\n}\n\nvec3 plasma(float t) {\n\n    const vec3 c0 = vec3(0.05873234392399702, 0.02333670892565664, 0.5433401826748754);\n    const vec3 c1 = vec3(2.176514634195958, 0.2383834171260182, 0.7539604599784036);\n    const vec3 c2 = vec3(-2.689460476458034, -7.455851135738909, 3.110799939717086);\n    const vec3 c3 = vec3(6.130348345893603, 42.3461881477227, -28.51885465332158);\n    const vec3 c4 = vec3(-11.10743619062271, -82.66631109428045, 60.13984767418263);\n    const vec3 c5 = vec3(10.02306557647065, 71.41361770095349, -54.07218655560067);\n    const vec3 c6 = vec3(-3.658713842777788, -22.93153465461149, 18.19190778539828);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a); float s = sin(a);\n    return vec2(p.x*c + p.y*s, s*p.x - c*p.y);\n}\n\nvec3 stereographic_sphere(vec2 uv) {\n    vec3 n = vec3(uv, sqrt(1.0 - dot(uv,uv)));\n    float t = iTime*0.1;\n    n.yz = rotate(n.yz, radians(sin(t*0.25*radians(360.0))*45.0));    \n    n.xz = rotate(n.xz, t*radians(360.0));    \n    return n;\n}\n\n//////////////////////////////////////////////////////////\n\n// for inverse mapping\nvec3 transfer_color(vec2 q) {\n    q = q*0.5 + 0.5;\n#ifdef SHOW_CUBEMAP\n    return textureLod(iChannel1, q*2.0, 0.0).rgb;\n#elif 1\n    ivec2 p = ivec2(q*subdivisions) & 1;\n    return vec3(p.x^p.y);\n#else\n    q = q - mod(q, 1.0/subdivisions);\n    return vec3(q, 0.0);\n#endif\n}\n\nvec3 transfer_color(vec3 p) {\n#ifdef SHOW_CUBEMAP\n#ifndef TEST_EQUIAREAL\n    p.xz = rotate(p.xz, iTime*0.5);\n#endif\n    return textureLod(iChannel0, p, 0.0).xyz;\n#elif defined(SHOW_INVERSE)\n    vec2 q = normal_arcmap(p);\n    q = q - mod(q, 1.0/subdivisions);\n    return vec3(q*0.5 + 0.5, 0.0);\n#else\n    return p*0.5 + 0.5;\n#endif\n}\n\nfloat flow_lines(vec3 q) {\n#ifndef TEST_EQUIAREAL\n    q.xz = rotate(q.xz, radians(90.0) + iTime*0.5);\n#endif\n    float a = atan(q.y, q.x);\n#ifdef SHOW_COS_THETA\n    float r = q.z*radians(90.0);\n#else\n    float r = acos(q.z);\n#endif\n    float A = subdivisions;\n    return sin(a*A)*sin(r*A);\n}\n\nfloat arcmap_flow_lines(vec2 p) {\n    return flow_lines(arcmap_normal(p));\n}\n\nbool in_range(vec2 p) {\n#ifdef SQUARIFY\n    return max(abs(p.x),abs(p.y)) <= 1.0;\n#else\n    return length(p) <= 1.0;\n#endif\n}\n\nvec3 solid_angle_color(vec3 p00, vec3 p10, vec3 p01, vec3 p11) {\n#ifdef SQUARIFY    \n    // ideal solid angle: pi / (2*subdivisions)\n    float isa = radians(180.0) / (2.0 * (subdivisions * subdivisions));\n#else\n    // ideal solid angle: 2 / (subdivisions)\n    float isa = 2.0 / (subdivisions * subdivisions);\n#endif\n    float sa1 = pyramid_points_solid_angle(p00,p10,p11,p01);\n    float sa2 = pyramid_points_solid_angle(p10,p00,p01,p11);\n    float sa = (uv.x*uv.y < 0.0)?sa1:sa2;\n#if 1\n    sa = abs(sa/isa-1.0);\n#else\n    sa = abs(log2(sa/isa));\n#endif\n    return plasma(clamp(sa,0.0,1.0));\n}\n\nvoid paint_arcmap() {\n    set_line_width_px(1.2);\n    \n    vec2 uv = get_origin();\n    #ifdef TEST_INVERTIBLE\n    vec2 p = normal_arcmap(arcmap_normal(uv));\n    #else\n    vec3 p = arcmap_normal(uv);\n    #endif\n    set_source_rgb(transfer_color(p));\n#ifdef SHOW_SOLID_ANGLE\n    float s = 1.0/subdivisions;\n    uv = uv - mod(uv, s) + s * 0.5;\n    vec2 w = 0.5*vec2(-s,s);\n    vec3 p00 = arcmap_normal(uv + w.xx);\n    vec3 p10 = arcmap_normal(uv + w.yx);\n    vec3 p01 = arcmap_normal(uv + w.xy);\n    vec3 p11 = arcmap_normal(uv + w.yy);\n    set_source_rgb(solid_angle_color(p00,p10,p01,p11));\n#endif\n#ifdef SQUARIFY\n    rectangle(-1.0,-1.0,2.0,2.0);\n#else\n    circle(0.0, 0.0, 1.0);\n#endif\n    fill_preserve();    \n    set_source_rgb(vec3(0.0));\n    stroke();\n#ifdef SHOW_FLOW_LINES\n    if (in_range(get_origin())) {\n        graph2D(arcmap_flow_lines);\n        stroke();\n    }\n#endif\n}\n\nvoid paint_inverse_arcmap() {\n    set_line_width_px(1.2);\n    vec3 n = stereographic_sphere(get_origin());  \n    float z = n.z;\n    n.z = abs(n.z);\n    vec2 uv = normal_arcmap(n);  \n    if (z < 0.0) {\n        uv.x = -uv.x;\n    }\n    set_source_rgb(transfer_color(uv));\n    circle(0.0, 0.0, 1.0);\n    fill_preserve();\n    set_source_rgb(vec3(0.0));\n    stroke();\n}\n\nvoid paint() {\n    set_source_rgb(vec3(0.2));\n    clear();\n\n#if defined(SHOW_INVERSE)\n    paint_inverse_arcmap();\n#else\n    paint_arcmap();\n#endif    \n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord, iMouse.xy, iResolution.xy);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.16\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2020-12-02: 0.16\n// * support for drawing concentric rings\n\n// 2020-11-30: 0.15\n// * support for drawing orthogonal grids\n// * adjusted uv so corners are centered on pixels\n// * small adjustment to line pixel width computation\n\n// 2020-11-12: 0.14\n// * added support for depth testing\n\n// 2020-11-11: 0.13\n// * fixed 2D graphs not filling\n// * added circle_px()\n\n// 2019-06-06: 0.12\n// * split implementation and demo into common and image tab\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\nvoid set_source_depth(float depth);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the old source with the new one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n// if enabled, use the depth value for testing;\n// smaller values win\nvoid depth_test(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add a circle path at P with pixel radius R\nvoid circle_px(vec2 p, float r);\nvoid circle_px(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// add an orthogonal grid with cell size S\nvoid grid(vec2 s);\nvoid grid(float w, float h);\nvoid grid(float s);\n// draw concentric rings around origin p, with spacing r and offset phase\nvoid rings(vec2 p, float r, float phase);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// draw a letter with the given texture coordinate\nvoid letter(sampler2D font_texture_source, ivec2 l);\nvoid letter(sampler2D font_texture_source, int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    bool depth_test;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n    float source_z;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n#define DEFAULT_DEPTH 1e+30\n\nContext _stack;\n\nvoid init (vec2 fragCoord, vec2 mouse, vec2 resolution) {\n\taspect = vec2(resolution.x / resolution.y, 1.0);\n\tScreenH = min(resolution.x,resolution.y);\n\tAA = ScreenH*0.5;\n\tAAINV = 1.0 / AA;\n    \n    uv = (fragCoord.xy - 0.5) / resolution;\n    vec2 m = mouse / resolution;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false,\n        DEFAULT_DEPTH\n    );\n}\n\nvec3 _color = vec3(1);\nfloat _depth = DEFAULT_DEPTH;\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color.rgb = mix(_color.rgb, _stack.source.rgb, _stack.source.a);\n    _depth = (_stack.source.a == 1.0)?_stack.source_z:_depth;\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(pow(_color.rgb, vec3(1.0/2.2)), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color.rgb;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    if (_stack.depth_test) {\n        if ((w == 1.0) && (_stack.source_z <= _depth)) {\n            _depth = _stack.source_z;\n        } else if ((w == 0.0) || (_stack.source_z > _depth)) {            \n            return;\n        }\n    }\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color.rgb = _color.rgb * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\n\nvoid depth_test(bool enable) {\n    _stack.depth_test = enable;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_depth(float depth) {\n    _stack.source_z = depth;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(sampler2D font_texture_source, ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(sampler2D font_texture_source, int lx, int ly) {\n    letter(font_texture_source, ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid grid(vec2 size) {\n    vec4 f = abs(fract(_stack.position/size.xyxy+0.5)-0.5)*size.xyxy;\n    add_field(vec2(min(f.x,f.y),min(f.z,f.w)));\n}\nvoid grid(float w, float h) {\n    grid(vec2(w,h));\n}\nvoid grid(float s) {\n    grid(vec2(s));\n}\nvoid rings(vec2 p, float r, float phase) {\n    vec4 q = _stack.position - p.xyxy;\n    vec2 f = abs(fract(vec2(length(q.xy),length(q.zw))/r-phase+0.5)-0.5)*r;\n    add_field(f);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid circle_px(vec2 p, float r) {\n    circle(p, r/(0.5*ScreenH));\n}\nvoid circle_px(float x, float y, float r) {\n    circle_px(vec2(x,y), r);\n}\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(f_x / length(df_x));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdXDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2096, 2165, 2201, 2224, 2546], [2548, 2548, 2579, 2633, 2847], [2849, 2849, 2876, 2930, 3149], [3151, 3205, 3231, 3231, 4922], [4924, 4978, 5004, 5004, 6745], [6747, 6747, 6779, 6815, 6970], [6972, 6972, 7001, 7037, 7068], [7070, 7070, 7102, 7149, 7286], [7288, 7288, 7317, 7364, 7399], [7401, 7401, 7435, 7475, 7595], [7597, 7597, 7628, 7668, 7752], [7754, 7786, 7815, 7815, 8039], [8041, 8073, 8101, 8101, 8340], [8419, 8419, 8464, 8464, 8512], [8514, 8514, 8549, 8549, 8619], [8621, 8621, 8673, 8673, 8900], [8902, 8902, 8969, 8969, 9312], [9314, 9314, 9336, 9336, 9990], [9992, 9992, 10022, 10022, 10111], [10113, 10113, 10149, 10149, 10355], [10417, 10440, 10469, 10469, 10713], [10715, 10715, 10744, 10744, 11047], [11049, 11049, 11075, 11075, 11340], [11342, 11342, 11375, 11375, 11418], [11420, 11420, 11443, 11443, 11545], [11547, 11547, 11611, 11611, 12143], [12145, 12145, 12166, 12166, 13027], [13029, 13029, 13058, 13058, 13392], [13394, 13394, 13408, 13408, 13546], [13608, 13608, 13665, 13665, 13751]], "test": "untested"}
{"id": "NldSDB", "name": "eindacor_oscillationfun", "author": "Eindacor_DS", "description": "It's just some random shader, and you're not a dolt. You're a nice person.", "tags": ["something"], "likes": 0, "viewed": 15, "published": 3, "date": "1639722934", "time_retrieved": "2024-07-30T18:41:33.956485", "image_code": "\n#define CYAN vec3(0., 1., 1.)\n#define MAGENTA vec3(1., 0., 1.)\n#define YELLOW vec3(1., 1., 0.)\n#define RED vec3(1., 0., 0.)\n#define GREEN vec3(0., 1., 0.)\n#define BLUE vec3(0., 0., 1.)\n#define ORANGE vec3(1., .75, .25)\n#define PINK vec3(1., .25, .75)\n#define WHITE vec3(1.)\n#define BLACK vec3(0.)\n\nvec3 getRandomColor(float seed) {\n    seed = clamp(seed, 0., 1.);\n    float colorCount = 6.;\n    float colorIncrement = 1.f / colorCount;\n    float seedFloor = floor(seed / colorIncrement) * colorIncrement;\n    float lerpVal = smoothstep(seedFloor, seedFloor + colorIncrement, seed);\n\n    if (seed <= colorIncrement * 1.) {\n        return mix(RED, YELLOW, lerpVal);\n    } else if (seed <= colorIncrement * 2.) {\n        return mix(YELLOW, GREEN, lerpVal);\n    } else if (seed <= colorIncrement * 3.) {\n        return mix(GREEN, CYAN, lerpVal);\n    } else if (seed <= colorIncrement * 4.) {\n        return mix(CYAN, BLUE, lerpVal);\n    } else if (seed <= colorIncrement * 5.) {\n        return mix(BLUE, MAGENTA, lerpVal);\n    } else {\n        return mix(MAGENTA, vec3(1.), lerpVal);\n    }\n}\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n    float val = sin(dot(p, vec2(12.9898f, 78.233f))) * 43758.5453f;\n    return val - floor(val);\n}\n\nfloat getHoldTransitionValue(float lower, float upper, float holdTime, float transitionTime, float time) {\n    float period = 2. * holdTime + 2. * transitionTime;\n    float halfPeriod = period / 2.;\n    float relativeTime = fract(time / halfPeriod);\n    float halfHoldTime = holdTime / 2.;\n    \n    float val = smoothstep(halfHoldTime, halfHoldTime + transitionTime, relativeTime * halfPeriod);\n    \n    if (int(time / halfPeriod) % 2 == 0) {\n        val = 1. - val;\n    }\n\n    return mix(lower, upper, val);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n    float holdTime = 0.;\n    float transitionTime = 12.;\n    \n    float pRadius = .08;\n    float AA = .002;\n    \n    float divisions = 24.;\n    \n    float timeOffset = (-transitionTime / divisions * 2.) * sin(iTime);\n    timeOffset = getHoldTransitionValue(-1., 1., 5., 3., iTime);\n    fragColor = vec4(0.);\n    \n    int count = int(divisions);\n    float localAA = .02;\n    float bounceCoeff = .1;\n    \n    float yLower = .2;\n    float yUpper = .8;\n    for (int i=0; i<count; ++i) {\n        float offsetTime = float(i) * timeOffset;\n        float radius = pRadius * (1. - uv.y);\n        float leftSide = (aspectRatio - 1.) / 2.;\n        float xVal = getHoldTransitionValue(.2 * aspectRatio, .8 * aspectRatio, holdTime, transitionTime, iTime + offsetTime + (holdTime + transitionTime) / 2.);\n        float yVal = getHoldTransitionValue(yLower, yUpper, holdTime, transitionTime, iTime + offsetTime);\n        vec2 p = vec2(xVal, yVal);\n        \n        float pointVal = smoothstep(radius + AA, radius - AA, distance(uv, p));\n        fragColor += vec4(vec3(getRandomColor(hash(vec2(float(i))))), 1.) * pointVal;\n        \n        if (uv.y > mix(yLower, yUpper, .5)) {\n            if (uv.x < aspectRatio * .5) {\n                float leftEdge = .2 * aspectRatio + radius;\n                float leftVal = smoothstep(leftEdge, leftEdge + localAA, uv.x);\n                fragColor = mix(fragColor, vec4(0.), leftVal);\n            } else {\n                float rightEdge = .8 * aspectRatio - radius;\n                float rightVal = smoothstep(rightEdge - localAA, rightEdge, uv.x);\n                fragColor = mix(vec4(0.), fragColor, rightVal);\n            }\n        }  \n    }\n \n    yLower = .35;\n    yUpper = .8;\n    for (int i=0; i<count; ++i) {\n        float offsetTime = float(i) * timeOffset;\n        float radius = pRadius * (1. - uv.y);\n        float leftSide = (aspectRatio - 1.) / 2.;\n        float xVal = getHoldTransitionValue(.2 * aspectRatio, .8 * aspectRatio, holdTime, transitionTime, iTime + offsetTime + (holdTime + transitionTime) / 2.);\n        float yVal = getHoldTransitionValue(yLower, yUpper, holdTime, transitionTime, iTime + offsetTime);\n        vec2 p = vec2(xVal, yVal);\n        \n        float pointVal = smoothstep(radius + AA, radius - AA, distance(uv, p));\n        fragColor += vec4(vec3(getRandomColor(hash(vec2(float(i))))), 1.) * pointVal;\n        \n        if (uv.y > mix(yLower, yUpper, .5)) {\n            if (uv.x < aspectRatio * .5) {\n                float leftEdge = .2 * aspectRatio + radius;\n                float leftVal = smoothstep(leftEdge, leftEdge + localAA, uv.x);\n                fragColor = mix(fragColor, vec4(0.), leftVal);\n            } else {\n                float rightEdge = .8 * aspectRatio - radius;\n                float rightVal = smoothstep(rightEdge - localAA, rightEdge, uv.x);\n                fragColor = mix(vec4(0.), fragColor, rightVal);\n            }\n        }  \n    }\n    \n    yLower = .5;\n    yUpper = .8;\n    for (int i=0; i<count; ++i) {\n        float offsetTime = float(i) * timeOffset;\n        float radius = pRadius * (1. - uv.y);\n        float leftSide = (aspectRatio - 1.) / 2.;\n        float xVal = getHoldTransitionValue(.2 * aspectRatio, .8 * aspectRatio, holdTime, transitionTime, iTime + offsetTime + (holdTime + transitionTime) / 2.);\n        float yVal = getHoldTransitionValue(yLower, yUpper, holdTime, transitionTime, iTime + offsetTime);\n        vec2 p = vec2(xVal, yVal);\n        \n        float pointVal = smoothstep(radius + AA, radius - AA, distance(uv, p));\n        fragColor += vec4(vec3(getRandomColor(hash(vec2(float(i))))), 1.) * pointVal;\n        \n        if (uv.y > mix(yLower, yUpper, .5)) {\n            if (uv.x < aspectRatio * .5) {\n                float leftEdge = .2 * aspectRatio + radius;\n                float leftVal = smoothstep(leftEdge, leftEdge + localAA, uv.x);\n                fragColor = mix(fragColor, vec4(0.), leftVal);\n            } else {\n                float rightEdge = .8 * aspectRatio - radius;\n                float rightVal = smoothstep(rightEdge - localAA, rightEdge, uv.x);\n                fragColor = mix(vec4(0.), fragColor, rightVal);\n            }\n        } \n        \n    }\n    fragColor *= pow(.95, smoothstep(.2, .8, uv.y) * 20.);\n    //fragColor *= 1. - smoothstep(.2, .9, uv.y);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldSDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[299, 299, 332, 332, 1088], [1090, 1136, 1156, 1156, 1255], [1257, 1257, 1363, 1363, 1767], [1769, 1769, 1826, 1876, 6308]], "test": "untested"}
{"id": "NlKGzw", "name": "basic 3d engine", "author": "ArmandB", "description": "click and drag to look around, wasd to move\nf to enter fly, space to go up, shift to go down\n\nbugs: \ncollision detection fails at triangle edges", "tags": ["3d"], "likes": 4, "viewed": 370, "published": 3, "date": "1639709332", "time_retrieved": "2024-07-30T18:41:34.910933", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    vec3 cross_col = vec3(1.0 - (col.r + col.b + col.g)/3.0);\n    \n    if (abs(iResolution.x/iResolution.y * (uv.x - 0.5)) < 0.003 && abs(uv.y - 0.5) < 0.02){\n        col = cross_col;\n    }\n    if (abs(iResolution.x/iResolution.y * (uv.x - 0.5)) < 0.02 && abs(uv.y - 0.5) < 0.003){\n        col = cross_col;\n    }\n    \n    bool isFly = texelFetch(iChannel1, ivec2(5,0), 0).x == 1.0;\n    if (isFly && floor(fragCoord.y) < 10.0){\n        col = vec3(1);\n    }\n\n    fragColor = vec4(col, 1.0);\n    //activate to see depth info\n    //fragColor = vec4(texture(iChannel0, uv).a*0.1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//frog scene\nvec3 tris[84] = vec3[](\n\tvec3(1.00000, -7.81250, 3.62500), vec3(2.40625, -8.75000, 5.03125), vec3(2.56250, -8.75000, 3.00000),\n\tvec3(1.00000, -9.21875, 1.59375), vec3(2.40625, -8.12500, 1.59375), vec3(2.56250, -8.75000, 3.00000),\n\tvec3(2.40625, -8.75000, 5.03125), vec3(1.00000, -7.81250, 3.62500), vec3(-0.40625, -8.75000, 5.03125),\n\tvec3(2.40625, -8.75000, 5.03125), vec3(-0.40625, -8.75000, 5.03125), vec3(1.00000, -9.68750, 3.00000),\n\tvec3(1.97432, -10.26671, 4.43575), vec3(2.40625, -8.75000, 5.03125), vec3(1.00000, -9.68750, 3.00000),\n\tvec3(1.97432, -10.26671, 4.43575), vec3(1.00000, -9.68750, 3.00000), vec3(2.56250, -8.75000, 3.00000),\n\tvec3(1.97432, -10.26671, 4.43575), vec3(2.56250, -8.75000, 3.00000), vec3(2.40625, -8.75000, 5.03125),\n\tvec3(2.09654, -10.11252, 2.16017), vec3(1.00000, -9.68750, 3.00000), vec3(1.00000, -9.21875, 1.59375),\n\tvec3(2.09654, -10.11252, 2.16017), vec3(1.00000, -9.21875, 1.59375), vec3(2.56250, -8.75000, 3.00000),\n\tvec3(2.09654, -10.11252, 2.16017), vec3(2.56250, -8.75000, 3.00000), vec3(1.00000, -9.68750, 3.00000),\n\tvec3(2.56250, -8.75000, 3.00000), vec3(2.40625, -8.12500, 1.59375), vec3(1.00000, -7.81250, 3.62500),\n\tvec3(2.30131, -7.22539, 1.85546), vec3(1.00000, -7.81250, 3.62500), vec3(2.40625, -8.12500, 1.59375),\n\tvec3(2.30131, -7.22539, 1.85546), vec3(2.40625, -8.12500, 1.59375), vec3(1.00000, -7.50000, 0.81250),\n\tvec3(2.30131, -7.22539, 1.85546), vec3(1.00000, -7.50000, 0.81250), vec3(1.00000, -7.81250, 3.62500),\n\tvec3(1.00000, -7.50000, 0.81250), vec3(2.40625, -8.12500, 1.59375), vec3(1.00000, -9.21875, 1.59375),\n\tvec3(-0.40625, -8.75000, 5.03125), vec3(1.00000, -7.81250, 3.62500), vec3(-0.56250, -8.75000, 3.00000),\n\tvec3(-0.40625, -8.12500, 1.59375), vec3(1.00000, -9.21875, 1.59375), vec3(-0.56250, -8.75000, 3.00000),\n\tvec3(-0.40625, -8.75000, 5.03125), vec3(0.02568, -10.26671, 4.43575), vec3(1.00000, -9.68750, 3.00000),\n\tvec3(1.00000, -9.68750, 3.00000), vec3(0.02568, -10.26671, 4.43575), vec3(-0.56250, -8.75000, 3.00000),\n\tvec3(-0.56250, -8.75000, 3.00000), vec3(0.02568, -10.26671, 4.43575), vec3(-0.40625, -8.75000, 5.03125),\n\tvec3(1.00000, -9.68750, 3.00000), vec3(-0.09654, -10.11252, 2.16017), vec3(1.00000, -9.21875, 1.59375),\n\tvec3(1.00000, -9.21875, 1.59375), vec3(-0.09654, -10.11252, 2.16017), vec3(-0.56250, -8.75000, 3.00000),\n\tvec3(-0.56250, -8.75000, 3.00000), vec3(-0.09654, -10.11252, 2.16017), vec3(1.00000, -9.68750, 3.00000),\n\tvec3(-0.40625, -8.12500, 1.59375), vec3(-0.56250, -8.75000, 3.00000), vec3(1.00000, -7.81250, 3.62500),\n\tvec3(1.00000, -7.81250, 3.62500), vec3(-0.30131, -7.22539, 1.85546), vec3(-0.40625, -8.12500, 1.59375),\n\tvec3(-0.40625, -8.12500, 1.59375), vec3(-0.30131, -7.22539, 1.85546), vec3(1.00000, -7.50000, 0.81250),\n\tvec3(1.00000, -7.50000, 0.81250), vec3(-0.30131, -7.22539, 1.85546), vec3(1.00000, -7.81250, 3.62500),\n\tvec3(-0.40625, -8.12500, 1.59375), vec3(1.00000, -7.50000, 0.81250), vec3(1.00000, -9.21875, 1.59375)\n);\n\nvec3 norms[84] = vec3[](\n\tvec3(0.52592, 0.84957, 0.04046), vec3(0.52592, 0.84957, 0.04046), vec3(0.52592, 0.84957, 0.04046),\n\tvec3(0.56624, -0.72802, -0.38648), vec3(0.56624, -0.72802, -0.38648), vec3(0.56624, -0.72802, -0.38648),\n\tvec3(0.00000, 0.83205, 0.55470), vec3(0.00000, 0.83205, 0.55470), vec3(0.00000, 0.83205, 0.55470),\n\tvec3(0.00000, -0.90796, 0.41906), vec3(0.00000, -0.90796, 0.41906), vec3(0.00000, -0.90796, 0.41906),\n\tvec3(-0.82493, 0.01306, 0.56508), vec3(-0.82493, 0.01306, 0.56508), vec3(-0.82493, 0.01306, 0.56508),\n\tvec3(0.42247, -0.70411, -0.57074), vec3(0.42247, -0.70411, -0.57074), vec3(0.42247, -0.70411, -0.57074),\n\tvec3(0.95125, -0.29963, 0.07317), vec3(0.95125, -0.29963, 0.07317), vec3(0.95125, -0.29963, 0.07317),\n\tvec3(-0.52070, -0.80993, -0.26998), vec3(-0.52070, -0.80993, -0.26998), vec3(-0.52070, -0.80993, -0.26998),\n\tvec3(0.60180, 0.25971, -0.75524), vec3(0.60180, 0.25971, -0.75524), vec3(0.60180, 0.25971, -0.75524),\n\tvec3(0.34510, -0.57517, 0.74167), vec3(0.34510, -0.57517, 0.74167), vec3(0.34510, -0.57517, 0.74167),\n\tvec3(0.57362, 0.77028, 0.27861), vec3(0.57362, 0.77028, 0.27861), vec3(0.57362, 0.77028, 0.27861),\n\tvec3(0.81480, -0.07229, 0.57522), vec3(0.81480, -0.07229, 0.57522), vec3(0.81480, -0.07229, 0.57522),\n\tvec3(0.56020, 0.29097, -0.77558), vec3(0.56020, 0.29097, -0.77558), vec3(0.56020, 0.29097, -0.77558),\n\tvec3(-0.28580, 0.95243, 0.10583), vec3(-0.28580, 0.95243, 0.10583), vec3(-0.28580, 0.95243, 0.10583),\n\tvec3(0.30637, -0.39390, -0.86659), vec3(0.30637, -0.39390, -0.86659), vec3(0.30637, -0.39390, -0.86659),\n\tvec3(-0.52592, 0.84957, 0.04046), vec3(-0.52592, 0.84957, 0.04046), vec3(-0.52592, 0.84957, 0.04046),\n\tvec3(-0.56624, -0.72802, -0.38648), vec3(-0.56624, -0.72802, -0.38648), vec3(-0.56624, -0.72802, -0.38648),\n\tvec3(0.82493, 0.01306, 0.56508), vec3(0.82493, 0.01306, 0.56508), vec3(0.82493, 0.01306, 0.56508),\n\tvec3(-0.42247, -0.70411, -0.57074), vec3(-0.42247, -0.70411, -0.57074), vec3(-0.42247, -0.70411, -0.57074),\n\tvec3(-0.95125, -0.29963, 0.07317), vec3(-0.95125, -0.29963, 0.07317), vec3(-0.95125, -0.29963, 0.07317),\n\tvec3(0.52070, -0.80993, -0.26998), vec3(0.52070, -0.80993, -0.26998), vec3(0.52070, -0.80993, -0.26998),\n\tvec3(-0.60180, 0.25971, -0.75524), vec3(-0.60180, 0.25971, -0.75524), vec3(-0.60180, 0.25971, -0.75524),\n\tvec3(-0.34510, -0.57517, 0.74167), vec3(-0.34510, -0.57517, 0.74167), vec3(-0.34510, -0.57517, 0.74167),\n\tvec3(-0.57362, 0.77028, 0.27861), vec3(-0.57362, 0.77028, 0.27861), vec3(-0.57362, 0.77028, 0.27861),\n\tvec3(-0.81480, -0.07229, 0.57522), vec3(-0.81480, -0.07229, 0.57522), vec3(-0.81480, -0.07229, 0.57522),\n\tvec3(-0.56020, 0.29097, -0.77558), vec3(-0.56020, 0.29097, -0.77558), vec3(-0.56020, 0.29097, -0.77558),\n\tvec3(0.28580, 0.95243, 0.10583), vec3(0.28580, 0.95243, 0.10583), vec3(0.28580, 0.95243, 0.10583),\n\tvec3(-0.30637, -0.39390, -0.86659), vec3(-0.30637, -0.39390, -0.86659), vec3(-0.30637, -0.39390, -0.86659)\n);\nvec2 uvs[84] = vec2[](\n\tvec2(0.25, 0.625), vec2(0.36405968958428014, 0.43703840967234786), vec2(0.4426367015629745, 0.625),\n\tvec2(0.6261209504097085, 0.7778742786007942), vec2(0.5, 0.6520504421433214), vec2(0.6261209504097085, 0.5625),\n\tvec2(0.40625, 0.6434875), vec2(0.265625, 0.8125), vec2(0.125, 0.6434875),\n\tvec2(1, 0.22371874999999997), vec2(0.71875, 0.22371874999999997), vec2(0.859375, 0),\n\tvec2(0.46107340298841437, 1.1102230246251565e-16), vec2(0.6296388466269683, 0), vec2(0.4375, 0.18139861079862452),\n\tvec2(0.9248515993070089, 0.38375422857243824), vec2(0.75, 0.4375), vec2(0.75, 0.25528122641914064),\n\tvec2(0.6685691698949203, 0.182869926324968), vec2(0.5677491036075522, 0.375), vec2(0.5, 0.18286992632496812),\n\tvec2(0, 0.8125), vec2(0, 0.6679910967275718), vec2(0.13174892714297248, 0.735932781003874),\n\tvec2(0.6174575503272173, 0.5279150297458242), vec2(0.5, 0.625), vec2(0.5, 0.4096267860455658),\n\tvec2(0.8125, 0.7171275176968819), vec2(0.7589757097762928, 0.875), vec2(0.6679935867286074, 0.7171275176968819),\n\tvec2(0.4426094069783164, 0.003157947517582582), vec2(0.4426094069783164, 0.15783819684260147), vec2(0.25, 0),\n\tvec2(0.21045709063774487, 0.4375), vec2(0, 0.3514722787666176), vec2(0.2490204152806803, 0.3514722787666176),\n\tvec2(5.551115123125783e-17, 0.1434872040485914), vec2(0.09150304566515644, 0.16617161536589942), vec2(0, 0.3125),\n\tvec2(0.2273628301992232, 0.45598713794783996), vec2(0.2273628301992232, 0.625), vec2(0, 0.4565237710154286),\n\tvec2(0.25, 0.21339403804558854), vec2(0.4225849914036922, 0.21339403804558854), vec2(0.34761101379411197, 0.375),\n\tvec2(0.36405968958428014, 0.43703840967234786), vec2(0.25, 0.625), vec2(0.4426367015629745, 0.625),\n\tvec2(0.5, 0.6520504421433214), vec2(0.6261209504097085, 0.7778742786007942), vec2(0.6261209504097085, 0.5625),\n\tvec2(0.6296388466269683, 0), vec2(0.46107340298841437, 1.1102230246251565e-16), vec2(0.4375, 0.18139861079862452),\n\tvec2(0.75, 0.4375), vec2(0.9248515993070089, 0.38375422857243824), vec2(0.75, 0.25528122641914064),\n\tvec2(0.5677491036075522, 0.375), vec2(0.6685691698949203, 0.182869926324968), vec2(0.5, 0.18286992632496812),\n\tvec2(0, 0.6679910967275718), vec2(0, 0.8125), vec2(0.13174892714297248, 0.735932781003874),\n\tvec2(0.5, 0.625), vec2(0.6174575503272173, 0.5279150297458242), vec2(0.5, 0.4096267860455658),\n\tvec2(0.7589757097762928, 0.875), vec2(0.8125, 0.7171275176968819), vec2(0.6679935867286074, 0.7171275176968819),\n\tvec2(0.4426094069783164, 0.15783819684260147), vec2(0.4426094069783164, 0.003157947517582582), vec2(0.25, 0),\n\tvec2(0, 0.3514722787666176), vec2(0.21045709063774487, 0.4375), vec2(0.2490204152806803, 0.3514722787666176),\n\tvec2(0.09150304566515644, 0.16617161536589942), vec2(5.551115123125783e-17, 0.1434872040485914), vec2(0, 0.3125),\n\tvec2(0.2273628301992232, 0.625), vec2(0.2273628301992232, 0.45598713794783996), vec2(0, 0.4565237710154286),\n\tvec2(0.4225849914036922, 0.21339403804558854), vec2(0.25, 0.21339403804558854), vec2(0.34761101379411197, 0.375)\n);\n\n//rectangle scene\n/*vec3 tris[36] = vec3[](\n\tvec3(28.50000, -7.50000, 38.00000), vec3(28.50000, -10.00000, 38.00000), vec3(28.50000, -7.50000, -32.00000),\n\tvec3(-26.50000, -7.50000, 38.00000), vec3(-26.50000, -10.00000, 38.00000), vec3(-26.50000, -10.00000, -32.00000),\n\tvec3(28.50000, -7.50000, 38.00000), vec3(28.50000, -7.50000, -32.00000), vec3(-26.50000, -7.50000, 38.00000),\n\tvec3(28.50000, -10.00000, 38.00000), vec3(-26.50000, -10.00000, 38.00000), vec3(28.50000, -10.00000, -32.00000),\n\tvec3(28.50000, -7.50000, 38.00000), vec3(-26.50000, -7.50000, 38.00000), vec3(28.50000, -10.00000, 38.00000),\n\tvec3(28.50000, -7.50000, -32.00000), vec3(-26.50000, -7.50000, -32.00000), vec3(-26.50000, -10.00000, -32.00000),\n\tvec3(28.50000, -7.50000, -32.00000), vec3(-26.50000, -7.50000, 38.00000), vec3(-26.50000, -7.50000, -32.00000),\n\tvec3(-26.50000, -10.00000, 38.00000), vec3(28.50000, -10.00000, -32.00000), vec3(-26.50000, -10.00000, -32.00000),\n\tvec3(-26.50000, -7.50000, 38.00000), vec3(-26.50000, -7.50000, -32.00000), vec3(-26.50000, -10.00000, -32.00000),\n\tvec3(28.50000, -7.50000, -32.00000), vec3(28.50000, -10.00000, -32.00000), vec3(-26.50000, -10.00000, -32.00000),\n\tvec3(28.50000, -10.00000, 38.00000), vec3(28.50000, -7.50000, -32.00000), vec3(28.50000, -10.00000, -32.00000),\n\tvec3(-26.50000, -7.50000, 38.00000), vec3(28.50000, -10.00000, 38.00000), vec3(-26.50000, -10.00000, 38.00000)\n);\nvec3 norms[36] = vec3[](\n\tvec3(1.00000, 0.00000, 0.00000), vec3(1.00000, 0.00000, 0.00000), vec3(1.00000, 0.00000, 0.00000),\n\tvec3(1.00000, 0.00000, 0.00000), vec3(1.00000, 0.00000, 0.00000), vec3(1.00000, 0.00000, 0.00000),\n\tvec3(0.00000, 1.00000, 0.00000), vec3(0.00000, 1.00000, 0.00000), vec3(0.00000, 1.00000, 0.00000),\n\tvec3(0.00000, -1.00000, 0.00000), vec3(0.00000, -1.00000, 0.00000), vec3(0.00000, -1.00000, 0.00000),\n\tvec3(0.00000, 0.00000, 1.00000), vec3(0.00000, 0.00000, 1.00000), vec3(0.00000, 0.00000, 1.00000),\n\tvec3(0.00000, 0.00000, 1.00000), vec3(0.00000, 0.00000, 1.00000), vec3(0.00000, 0.00000, 1.00000),\n\tvec3(0.00000, 1.00000, 0.00000), vec3(0.00000, 1.00000, 0.00000), vec3(0.00000, 1.00000, 0.00000),\n\tvec3(0.00000, -1.00000, 0.00000), vec3(0.00000, -1.00000, 0.00000), vec3(0.00000, -1.00000, 0.00000),\n\tvec3(-1.00000, 0.00000, 0.00000), vec3(-1.00000, 0.00000, 0.00000), vec3(-1.00000, 0.00000, 0.00000),\n\tvec3(0.00000, 0.00000, -1.00000), vec3(0.00000, 0.00000, -1.00000), vec3(0.00000, 0.00000, -1.00000),\n\tvec3(-1.00000, 0.00000, 0.00000), vec3(-1.00000, 0.00000, 0.00000), vec3(-1.00000, 0.00000, 0.00000),\n\tvec3(0.00000, 0.00000, -1.00000), vec3(0.00000, 0.00000, -1.00000), vec3(0.00000, 0.00000, -1.00000)\n);\nvec2 uvs[36] = vec2[](\n\tvec2(1.00000, 1.00000), vec2(1.00000, 0.50000), vec2(0.00000, 1.00000),\n\tvec2(0.00000, 1.00000), vec2(0.00000, 0.50000), vec2(1.00000, 0.50000),\n\tvec2(0.00000, 0.00000), vec2(0.00000, 1.00000), vec2(1.00000, 0.00000),\n\tvec2(0.00000, 0.00000), vec2(0.00000, 1.00000), vec2(1.00000, 0.00000),\n\tvec2(0.00000, 1.00000), vec2(1.00000, 1.00000), vec2(0.00000, 0.50000),\n\tvec2(1.00000, 1.00000), vec2(0.00000, 1.00000), vec2(0.00000, 0.50000),\n\tvec2(0.00000, 1.00000), vec2(1.00000, 0.00000), vec2(1.00000, 1.00000),\n\tvec2(0.00000, 1.00000), vec2(1.00000, 0.00000), vec2(1.00000, 1.00000),\n\tvec2(0.00000, 0.93750), vec2(7.00000, 0.93750), vec2(7.00000, 0.68750),\n\tvec2(5.50000, 0.81250), vec2(5.50000, 0.56250), vec2(0.00000, 0.56250),\n\tvec2(0.00000, 0.56250), vec2(7.00000, 0.81250), vec2(7.00000, 0.56250),\n\tvec2(0.00000, 0.81250), vec2(5.50000, 0.56250), vec2(0.00000, 0.56250)\n);*/\n\n//constants\nconst float PI = 3.14159265359;\nconst float playerWalk = 0.01;\nconst float playerSprint = 0.02;\nconst float playerJump = 0.6;\nconst float playerFly = 0.02;\nconst float gravity = 0.02;\nconst float playerHeight = 2.5;\nconst float playerRadius = 0.5;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n//returns a point rotated in 3d (radians)\nvec3 rotate3d(vec3 point, vec3 angle, vec3 origin){ \n    point -= origin; //subtract pivot\n    //calculate consts\n    float cx = cos(angle.x);\n    float sx = sin(angle.x);\n    float cy = cos(angle.y);\n    float sy = sin(angle.y);\n    float cz = cos(angle.z);\n    float sz = sin(angle.z);\n    //rotate point\n    point *= mat3(\n        cy*cz, sx*sy*cz - cx*sz, cx*sy*cz + sx*sz,\n        cy*sz, sx*sy*sz + cx*cz, cx*sy*sz - sx*cz,\n        -sy, sx*cy, cx*cy\n    );\n    point += origin; //add pivot\n    return point;\n}\n\n//returns the normal of 3 points\nvec3 getNormal(vec3 a, vec3 b, vec3 c) { \n    return normalize(cross(c - a, b - a));\n}\n\n//returns the center point of 3 points\nvec3 getCenter(vec3 a, vec3 b, vec3 c){ \n    return (a + b + c)/3.0;\n}\n\n//returns the closest point on a line segment to a point\nvec3 closestOnSegment(vec3 A, vec3 B, vec3 Point) {\n    vec3 AB = B - A;\n    float t = dot(Point - A, AB) / dot(AB, AB);\n    return A + clamp(t,0.0,1.0) * AB; \n}\n\n//returns the barycentric coordinates of a point\nvec3 getBary(in vec3 p1, in vec3 p2, in vec3 p3, in vec3 p0)\n{\n    vec3 a = p2 - p3;\n    vec3 b = p1 - p3;\n    vec3 c = p0 - p3;\n    float ab = dot(a,b);\n    float ac = dot(a,c);\n    float bc = dot(b,c);\n    float m = dot(a,a);\n    float n = dot(b,b);\n    float d = m * n - ab*ab;\n    float u = (m * bc - ab * ac) / d;\n    float v = (n * ac - ab * bc) / d;\n    float w = 1.0 - u - v;\n    return vec3(u,v,w);\n}\n\n//returns a point cast onto a plane\nvec3 castToPlane(vec3 point, vec3 normal, vec3 a) {\n    float dist = dot(normal, point - a);\n    return point - dist * normal; \n}\n\n//returns the intersection of a plane r and a ray\nfloat planeRayIntersect(vec3 rayDir, vec3 rayOrigin, vec3 center, vec3 normal) { \n    float denom = dot(rayDir,normal);\n    if (denom != 0.0){ //ray is parralel if 0\n        float dist = dot(center - rayOrigin, normal)/denom;\n        if (dist >= 0.0){\n            return dist; //distance along ray to intersection point\n        }\n    }\n    return -1.0; //ray doesn't intersect\n}\n\n//returns the distance from a ray to the edges of a triangle (not really)\nfloat getTriEdgeDist(vec3 a, vec3 b, vec3 c, vec3 p){\n    float distAB = distance(p,closestOnSegment(a,b,p));\n    float distBC = distance(p,closestOnSegment(b,c,p));\n    float distCA = distance(p,closestOnSegment(c,a,p));\n    return min(distAB, min(distBC, distCA));\n}\n\n//returns whether  a point lies on a triangle\nbool isInTriangle(vec3 p,vec3 a,vec3 b,vec3 c){\n    vec3 bary = getBary(a,b,c,p);\n    return bary.x > 0.0 && bary.y > 0.0 && bary.x + bary.y < 1.0;\n}\n\n//returns the closest point on a triangle to a point\nvec3 closestPointOnTriangle(vec3 a, vec3 b, vec3 c, vec3 p, vec3 normal){\n    vec3 planePoint = castToPlane(p,normal,a);\n    \n    if (!isInTriangle(planePoint,a,b,c)){\n        float planeDist = distance(planePoint, p);\n\n        vec3 closestAB = closestOnSegment(a,b,p);\n        vec3 closestBC = closestOnSegment(b,c,p);\n        vec3 closestCA = closestOnSegment(c,a,p);\n        \n        float distAB = distance(closestAB,p);\n        float distBC = distance(closestBC,p);\n        float distCA = distance(closestCA,p);\n        \n        if (distAB <= distBC && distAB <= distCA){\n            return closestAB;\n        } else if (distBC <= distAB && distBC <= distCA){\n            return closestBC;\n        } else if (distCA <= distAB && distCA <= distBC){\n            return closestCA;\n        }\n    }\n    return planePoint;\n}\n\n//returns the closest point on a given line segment to a triangle\nvec3 closestPointOnLineSegmentToTri(vec3 a, vec3 b, vec3 c, vec3 p1, vec3 p2, vec3 normal, vec3 center) {\n    float segmentLength = length(p2-p1);\n    vec3 segmentDir = (p2-p1)/segmentLength;\n    float distAlongSegment = clamp(planeRayIntersect(segmentDir,p1,center,normal),0.0,segmentLength);\n    return p1 + segmentDir*distAlongSegment;\n}\n\n// https://iquilezles.org/articles/intersectors/\n// capsule defined by extremes pa and pb, and radious ra\n// Note that only ONE of the two spherical caps is checked for intersections,\n// which is a nice optimization\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float ra )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - ra*ra*baba;\n    float h = b*b - a*c;\n    if( h >= 0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n        float y = baoa + t*bard;\n        // body\n        if( y>0.0 && y<baba ) return t;\n        // caps\n        vec3 oc = (y <= 0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - ra*ra;\n        h = b*b - c;\n        if( h>0.0 ) return -b - sqrt(h);\n    }\n    return -1.0;\n}\n\n//https://www.shadertoy.com/view/Xt3SzX\n// cap normal \n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return (pa - h*ba)/r;\n}\n\n//random functions from //https://www.shadertoy.com/view/4djSRW\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//https://iquilezles.org/articles/smin/\n//power smooth min (k=8)\nfloat smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\nfloat voronoi4d(vec4 uv){\n    float n = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            for (int z = -1; z < 2; z++){\n                for (int w = -1; w < 2; w++){\n                    n = smin(n,distance(floor(uv) + vec4(x,y,z,w) + hash44(floor(uv) + vec4(x,y,z,w)),uv),2.0);\n                }\n            }\n        }\n    }\n    return n;\n}", "buffer_a_code": "//player movement\n\nconst int W = 87;\nconst int A = 65;\nconst int S = 83;\nconst int D = 68;\nconst int SPACE = 32;\nconst int SHIFT = 16;\nconst int CTRL = 17;\nconst int F = 70;\n\nint keyPressed(int key){\n    return (texelFetch( iChannel1, ivec2(key, 0),0 ).x > 0.0) ? 1 : 0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    \n    \n    if (floor(fragCoord) == vec2(0,0)){\n        //fetch last pos and rotation \n        vec3 rotation = texelFetch(iChannel0, ivec2(1,0), 0).xyz;\n        vec3 velocity = texelFetch(iChannel0, ivec2(0,0), 0).xyz;\n        bool grounded = texelFetch(iChannel0, ivec2(3,0), 0).w == 1.0;\n        bool isFly = (texelFetch(iChannel0, ivec2(5,0), 0).x == 1.0);\n        //rotate velocity by camera y rotation\n        velocity += rotate3d( \n            vec3(\n                float(keyPressed(D) - keyPressed(A)),\n                0,\n                float(keyPressed(W) - keyPressed(S))\n            ) * (keyPressed(CTRL) == 1 ? playerSprint : playerWalk), \n            vec3(0, rotation.y, 0), \n            vec3(0)\n        );\n        \n        velocity *= 0.90;\n        \n        if (isFly){\n            velocity.y += float(keyPressed(SPACE) - keyPressed(SHIFT))*playerFly;\n        } else {\n            if (grounded){\n                if (keyPressed(SPACE) == 1){\n                    velocity.y = playerJump;\n                } \n            } else {\n                velocity.y -= gravity;\n            }\n        }\n        \n        col = vec4(velocity,0); \n    }\n    \n    if (floor(fragCoord) == vec2(1,0)){//rotation\n        vec2 draggedMouse = texelFetch(iChannel0, ivec2(4,0), 0).xy/iResolution.xy*2.0 - 1.0;\n        vec3 rotation = vec3(clamp(-draggedMouse.y*PI,-PI/2.0,PI/2.0), draggedMouse.x*PI, 0); \n        col = vec4(rotation,0); \n    }\n    \n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    \n    //collision resolution\n    if (floor(fragCoord) == vec2(3,0)){//position\n        vec3 pos = texelFetch(iChannel0, ivec2(3,0), 0).xyz;\n        vec3 vel = texelFetch(iChannel0, ivec2(0,0), 0).xyz;\n        bool grounded = false;\n        \n        pos += vel;\n        \n        if (pos.y < -40.0){\n            pos = vec3(0,5,0);\n        }\n        \n        //vec3 penetrationVec = vec3(-999);\n        for (int i = 0; i < tris.length()/3; i++){\n            //load tri vertices\n            vec3 v1 = tris[i*3];\n            vec3 v2 = tris[i*3+1];\n            vec3 v3 = tris[i*3+2];\n            //caspule collision detection\n            //calculate distance from line segment to triangle, if less than player radius, theres a collision\n            \n            vec3 normal = getNormal(v1,v2,v3);\n            vec3 center = getCenter(v1,v2,v3);\n            //the ends of the line segment\n            vec3 point1 = pos; //head\n            vec3 point2 = pos-vec3(0,playerHeight,0); //feet\n            \n            vec3 closestOnSegment = closestPointOnLineSegmentToTri(v1,v2,v3,point1,point2, center, normal);\n            \n            vec3 closestOnTri = closestPointOnTriangle(v1,v2,v3,closestOnSegment, normal);\n            \n            float dist = distance(closestOnTri, closestOnSegment);\n            \n            if (dist < playerRadius) {\n                grounded = true;\n                vec3 colnorm = normalize(closestOnTri - closestOnSegment);\n                float penetration = playerRadius - dist;\n                pos -= colnorm*penetration;\n            }\n        }\n        \n        col = vec4(pos,grounded);\n    }\n    \n    //dragged mouse pos\n    if (floor(fragCoord) == vec2(4,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(4,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(4,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(4,0), 0);\n        }\n    }\n    \n    if (floor(fragCoord) == vec2(5,0)){ //fly\n        bool isFly = (texelFetch(iChannel0, ivec2(5,0), 0).x == 1.0);\n        bool wasPressed = texelFetch(iChannel0, ivec2(5,0), 0).y == 1.0;\n        bool isPressed = keyPressed(F) == 1;\n        \n        if (isPressed && !wasPressed) {\n            if (isFly) {\n                isFly = false;\n            } else {\n                isFly = true;\n            }\n        }\n        col = vec4(isFly ?1 : 0, isPressed ? 1 : 0, 0, 0); \n    }\n    \n    fragColor = vec4(col);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//main drawing, alpha is depth map\n\nconst vec3 lightDirection = vec3(-0.2,-0.7,-0.1);\nconst vec3 lightColor = vec3(1.0,1.0,0.8);\nconst float diffuseAmount = 0.7; // 0 to 1\nconst float specularAmount = 0.3; // 0 to 1\nconst float ambientAmount = 0.5; // 0 to 1\nconst float shininessAmount = 10.0; // at least 1\nconst int ssao_samples = 10;\nconst float ssao_radius = 0.2;\nconst float shadowStrength = 1.0;\n\nvec3 surf_shader(vec3 v1, vec3 v2, vec3 v3, vec2 texCoord, vec3 bary, vec3 point, vec3 camPos, vec3 incident, vec3 normal, vec3 lightDirection, float depth, vec3 uv){ \n    vec3 col = vec3(0);\n    vec3 texCol = texelFetch(iChannel1, ivec2(texCoord*16.0),0).rgb;\n    lightDirection = normalize(lightDirection);\n    \n    //ssao\n    float intersections = 0.0;\n    for (int samples = 0; samples < ssao_samples; samples ++){\n        vec3 direction = normalize(hash33((point + float(samples))*100.0)*2.0 - 1.0);\n        if (dot(direction,normal) < 0.0){\n            direction = reflect(direction, normal);\n        }\n        vec3 samplePoint = point + direction*ssao_radius;\n        //need to loop for all tris\n        for (int i = 0; i < tris.length()/3; i++){\n            vec3 a = tris[i*3]; \n            vec3 b = tris[i*3+1];\n            vec3 c = tris[i*3+2];\n        \n            vec3 center = (a+b+c)/3.0;\n            vec3 norm = getNormal(a,b,c);\n            float intersect = planeRayIntersect(normalize(samplePoint - uv), uv, center, norm);\n            if (intersect < length(samplePoint - uv) && isInTriangle(uv + intersect*normalize(samplePoint - uv), a,b,c)){\n                intersections ++;\n                break;\n            }\n        }\n    }\n    float shadowing = intersections/float(ssao_samples);\n    \n    //shadows\n    for (int i = 0; i < tris.length()/3; i++){\n        vec3 a = tris[i*3]; \n        vec3 b = tris[i*3+1];\n        vec3 c = tris[i*3+2];\n        \n        vec3 center = (a+b+c)/3.0;\n        vec3 norm = getNormal(a,b,c);\n        float intersect = planeRayIntersect(-lightDirection, point, center, norm);\n        if (intersect > 0.01 && isInTriangle(point - intersect*lightDirection, a,b,c)){\n            shadowing += 1.0;\n            break;\n        }\n    }\n    \n    //lighting\n    float diffuseAngle = max(dot(-lightDirection,normal) - shadowing,0.0);\n    float specularAngle = max(dot(reflect(lightDirection,normal),-incident),0.0);\n    \n    vec3 ambient = texCol*ambientAmount;\n    vec3 diffuse = texCol*diffuseAngle*diffuseAmount;\n    vec3 specular = lightColor*pow(specularAngle,shininessAmount)*specularAmount;\n    \n    col = diffuse + specular + ambient;\n    \n    //fog\n    col = mix(col,vec3(0.8),smoothstep(30.0,40.0,depth));\n    //col = vec3(occlusion);\n    /*vec3 center = (v1+v2+v3)/3.0;\n    vec3 pointOnPlane = uv + planeRayIntersect(incident, uv, center, normal)*incident;\n    col = getTriEdgeDist(v1,v2,v3,pointOnPlane) <= 0.03 ? vec3(1) : col;*/\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camPos = texelFetch(iChannel0, ivec2(3,0), 0).xyz + vec3(0,playerHeight,0);\n    vec3 camRot = texelFetch(iChannel0, ivec2(1,0), 0).xyz;\n\n    vec3 uv = vec3((fragCoord - iResolution.xy*0.5)/iResolution.y * 2.0, 1.0); //center uv on center of screen from 1 to -1\n    float pxunit = 2.0/iResolution.y;\n    vec3 rayDir = normalize(uv); //set the direction of the ray for the pixel\n    uv = rotate3d(uv, camRot, vec3(0));\n    rayDir = rotate3d(rayDir, camRot, vec3(0));\n    uv += camPos; //offset uv by position\n    \n    vec3 col = vec3(0); //set base color to black\n    float depth = -1.0; //set base depth to -1\n    int closestTri = 0;\n    vec3 closestPoint = vec3(0);\n    vec3 closestNormal = vec3(0,1,0);\n    \n    // initialize vertices of triangle\n    vec3 v1 = vec3(0); \n    vec3 v2 = vec3(0);\n    vec3 v3 = vec3(0);\n    \n    //loop through triangles\n    for (int i = 0; i < tris.length()/3; i++){\n        //load tri vertices\n        v1 = tris[i*3]; \n        v2 = tris[i*3+1];\n        v3 = tris[i*3+2];\n        \n        vec3 center = getCenter(v1,v2,v3); // get the center of the triangle\n        vec3 normal = getNormal(v1,v2,v3); // get the normal of the triangle\n        float planeDist = planeRayIntersect(rayDir, uv, center, normal); //get the distance from the ray origin to the plane the triangle lies on\n        vec3 pointOnPlane = uv + rayDir*planeDist; // get the point the ray intersects the plane\n        if (planeDist == -1.0) continue; // skip if ray does not intersect plane\n        \n        if (isInTriangle(pointOnPlane, v1, v2, v3) && (planeDist < depth || depth == -1.0)) { // check if point is on the triangle\n            depth = planeDist; // set the depth of the depthmap\n            closestTri = i;\n            closestPoint = pointOnPlane;\n        }\n    }\n    \n    if (depth != -1.0) { //objects\n        vec3 v1 = tris[closestTri*3];\n        vec3 v2 = tris[closestTri*3+1];\n        vec3 v3 = tris[closestTri*3+2];\n        \n        vec3 bary = getBary(v1, v2, v3, closestPoint);\n        vec2 texCoord = bary.x*uvs[closestTri*3] + bary.y*uvs[closestTri*3+1] + bary.z*uvs[closestTri*3+2];\n        \n        vec3 normal = norms[closestTri*3]*bary.x + norms[closestTri*3+1]*bary.y + norms[closestTri*3+2]*bary.z;\n        col = surf_shader(v1,v2,v3, texCoord, bary, closestPoint, camPos, rayDir, normal, lightDirection, depth, uv);\n    \n    } else { //sky and lines\n        //sky gradient\n        col = mix(vec3(0.6,0.5,0.5), vec3(0.0, 0.5, 1.0), rayDir.y/2.0 +0.5);\n        \n        float rl = dot(rayDir, -lightDirection);\n        \n        //sun\n        col = mix(col,mix(vec3(1,1,0),vec3(1),rl*rl*20.0-9.65),smoothstep(0.0, 0.03, rl-0.7));\n        \n        //clouds\n        float cloudScale = 1.0/rayDir.y;\n        int cloudSteps = 3;\n        float cloudDist = planeRayIntersect(rayDir, uv, vec3(0,50,0), vec3(0,1,0));\n        float cloudDist2 = planeRayIntersect(rayDir, uv, vec3(0,40,0), vec3(0,1,0));\n        if (cloudDist >= 0.0 || cloudDist2 >= 0.0){\n            float cloudStep = cloudDist2 - cloudDist;\n            float n = 0.0;\n            for (int i = 0; i < cloudSteps; i++)\n                n += voronoi4d(vec4(cloudDist*rayDir + cloudStep*rayDir*float(i), 1)*0.01);\n            col = vec3(n/10.0);\n        }\n        /*if (rayDir.y >= 0.0){\n            col = mix(vec3(0.8+n/4.0),col, smoothstep(0.0,0.4, n-0.3));\n        }*/\n        \n        //fog\n        col = mix(vec3(0.8),col,abs(rayDir.y));\n        \n        //axis lines\n        col = mix(vec3(0,1,0),col,smoothstep(0.0, pxunit, abs(rayDir.y)));\n        col = mix(vec3(1,0,0),col,smoothstep(0.0, pxunit, abs(rayDir.x)));\n        col = mix(vec3(0,0,1),col,smoothstep(0.0, pxunit, abs(rayDir.z)));\n    }\n    \n    /*vec3 offset = vec3(-1, 0,0);\n    vec3 point1 = camPos + offset; //head\n    vec3 point2 = vec3(camPos.x,camPos.y+(playerHeight-playerRadius), camPos.z) + offset; //feet\n    float player_render = capIntersect( uv, rayDir, point1, point2, playerRadius);\n    \n    if (player_render != -1.0){\n        vec3 intersect = uv + rayDir*player_render;\n        col = surf_shader(vec3(0), vec3(0), vec3(0), vec2(0), intersect, rayDir, capNormal(intersect, point1, point2, playerRadius), lightDirection, player_render, uv);\n    }*/\n    \n    fragColor = vec4(col,depth);\n}", "buffer_b_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKGzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 732]], "test": "untested"}
{"id": "sttXzs", "name": "Three Way Spring", "author": "oneshade", "description": "Another spring contraption with differential equations.", "tags": ["physics", "system", "springs", "threeway"], "likes": 20, "viewed": 299, "published": 3, "date": "1639703863", "time_retrieved": "2024-07-30T18:41:35.686859", "image_code": "// Space operators\nvec2 axisAlign(in vec2 p, in vec2 up) {\n    return mat2(up.x, -up.y, up.yx) * p;\n}\n\n// SDFs\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n// https://www.shadertoy.com/view/tlcBW2\nfloat udTriangleWave(in vec2 p, in float freq, in float amp) {\n    float pw = 1.0 / freq, qw = 0.25 * pw;\n    vec2 sc = vec2(2.0 * amp, pw);\n    float l = length(sc);\n    p.x = abs(mod(p.x + qw, pw) - 0.5 * pw) - qw;\n    p *= mat2(sc, -sc.y, sc.x) / l;\n    return length(vec2(p.x, max(0.0, abs(p.y) - 0.25 * l)));\n}\n\n// ax'' + bx' + cx = 0\nvec2 ode21(in float t, in float t0, in vec2 x0, in vec2 v0,\n           in float a, in float b, in float c) {\n\n    t -= t0;\n    float alpha = -b / (2.0 * a);\n    float discr = alpha * alpha - c / a;\n    float beta = sqrt(abs(discr));\n\n    if (discr < 0.0) { // Underdamped\n        float w = beta * t;\n        return (x0 * cos(w) - (alpha * x0 - v0) / beta * sin(w)) * exp(alpha * t);\n    }\n\n    if (abs(discr) < 1e-3) { // Critically damped\n        return (x0 - (alpha * x0 - v0) * t) * exp(alpha * t);\n    }\n\n    // Overdamped\n    return (((beta - alpha) * x0 + v0) * exp((alpha + beta) * t) +\n            ((beta + alpha) * x0 - v0) * exp((alpha - beta) * t)) / (2.0 * beta);\n}\n\n#define drawSDF(dist, col) color = mix(color, col.rgb, smoothstep(unit, 0.0, dist) * col.a)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 origin = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - origin) / iResolution.y * 8.0;\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - origin.xyxy) / iResolution.y * 8.0;\n    float unit = 16.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Default before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec4(1.0, -2.0, 2.0, -1.0);\n\n    // Constants: mass (m), friction (), anchors (p1, p2, p3), springiness (k1, k2, k3)\n    float m = 1.0;\n    float u = 0.8;\n\n    vec2 p1 = 3.0 * vec2(1.0, 0.0);\n    vec2 p2 = 3.0 * vec2(-0.75, 1.0);\n    vec2 p3 = 3.0 * vec2(-1.6, -0.8);\n\n    float k1 = 30.0;\n    float k2 = 30.0;\n    float k3 = 30.0;\n\n    // Precomputation\n    float springTotal = k1 + k2 + k3;\n    vec2 center = (k1 * p1 + k2 * p2 + k3 * p3) / springTotal;\n\n    // Initial position (x0), initial velocity (v0), and start time (t0)\n    vec2 x0 = mouse.zw;\n    vec2 v0 = (mouse.xy - mouse.zw) * 10.0;\n    float t0 = texelFetch(iChannel0, ivec2(0), 0).x;\n\n    // Current position\n    vec2 pos = ode21(iTime, t0, x0, v0, m, u, springTotal) + center;\n\n    // Plot of the path\n    vec2 prev = ode21(max(0.0, iTime - 1.0), 0.0, x0, v0, m, u, springTotal) + center;\n    for (float t=-0.99; t < 0.01; t += 0.01) {\n        vec2 cur = ode21(max(0.0, iTime + t), t0, x0, v0, m, u, springTotal) + center;\n        drawSDF(sdLine(uv, prev, cur), vec4(0.0, 0.0, 0.0, t + 1.0));\n        prev = cur;\n    }\n\n    // Springs\n    vec2 uv1 = axisAlign(uv - p1, normalize(pos - p1));\n    if (uv1.x > 0.0 && uv1.x < length(pos - p1)) drawSDF(udTriangleWave(uv1, 8.0 / length(pos - p1), 0.75), vec4(0.0, 0.0, 0.0, 1.0));\n\n    vec2 uv2 = axisAlign(uv - p2, normalize(pos - p2));\n    if (uv2.x > 0.0 && uv2.x < length(pos - p2)) drawSDF(udTriangleWave(uv2, 8.0 / length(pos - p2), 0.75), vec4(0.0, 0.0, 0.0, 1.0));\n\n    vec2 uv3 = axisAlign(uv - p3, normalize(pos - p3));\n    if (uv3.x > 0.0 && uv3.x < length(pos - p3)) drawSDF(udTriangleWave(uv3, 8.0 / length(pos - p3), 0.75), vec4(0.0, 0.0, 0.0, 1.0));\n\n    drawSDF(sdDisk(uv, p1, 0.25), vec4(1.0, 0.5, 0.25, 1.0));\n    drawSDF(sdDisk(uv, p2, 0.25), vec4(0.25, 1.0, 0.5, 1.0));\n    drawSDF(sdDisk(uv, p3, 0.25), vec4(0.5, 0.25, 1.0, 1.0));\n\n    // Mass\n    drawSDF(sdDisk(uv, pos, 0.5), vec4(0.0, 0.0, 1.0, 1.0));\n\n    // Vignette\n    color *= 1.0 - 2.0 * pow(length(fragCoord / iResolution.xy - 0.5), 4.0);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    if (iFrame > 0) fragColor = texelFetch(iChannel0, ivec2(0), 0);\n    if (iMouse.z > 0.0) fragColor.x = iTime;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttXzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 19, 58, 58, 101], [103, 111, 159, 159, 191], [193, 193, 240, 240, 348], [350, 391, 453, 453, 706], [708, 731, 839, 839, 1408], [1502, 1502, 1557, 1557, 3968]], "test": "untested"}
{"id": "sldSRl", "name": "infinit polar fractions", "author": "cyperus", "description": " polar fraction with local and index coordinates.", "tags": ["complex"], "likes": 5, "viewed": 285, "published": 3, "date": "1639701867", "time_retrieved": "2024-07-30T18:41:36.458795", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// \n//  \"infinit polar fractions\" created by Colling Patrik (cyperus) in 2021\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// by akohdr see comments\n//#define AKOHDR\n\nconst float PI_2 = acos(0.), PI = 2.*PI_2, PI2 = 4.*PI_2;\n\nvec3 hsv2rgb (float h, float s, float v )\n{\n    return mix(vec3(1.), 0.5*(1.+cos(2.*PI*(h + vec3(0,1,2)/3. ))), s*1.333)*v;   \n}\n\nvec2 afn(in vec2 z, in int n) {\n    #ifdef AKOHDR\n    z *= -1.; // rotation by PI\n    z.x = (atan(z.y,z.x)/PI2 + 1.) * float(n);\n    #else    \n    z.x = (atan(z.y,z.x)/PI2 + .5) * float(n);\n    #endif\n    z.y = floor(z.x);     // index\n    z.x = z.y-z.x;        // local coords\n    return vec2(z.x,z.y); // vec2(a, a_id);\n}\n\nvoid mainImage( out vec4 O, in vec2 U)\n{\n    vec3 R = iResolution, col;    \n    vec2 Z = (2.*U-R.xy)/R.y;    \n    float r,a,a_id, n = floor(exp(0.5*iTime));\n    \n    r = length(Z); Z = afn(Z, int(n)); a = Z.x; a_id = Z.y;\n\n    float s = 0.8, v = 1.;       \n    col = r<0.9 \n        ? hsv2rgb(a, s, v)\n        : hsv2rgb(-a_id/n, s, v);\n    \n    O = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldSRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[347, 347, 390, 390, 475], [477, 477, 508, 508, 800], [802, 802, 842, 842, 1165]], "test": "untested"}
{"id": "NsyXWt", "name": "Brittle Hollow", "author": "Remming_Senegal", "description": "A trip around brittle hollow from Outer Wilds", "tags": ["fractal", "voronoi", "noise", "raymarch", "rays", "space", "geometry", "modulus", "recursion", "buffer", "planets", "detail", "resolution", "outerwilds"], "likes": 12, "viewed": 402, "published": 3, "date": "1639698849", "time_retrieved": "2024-07-30T18:41:37.420224", "image_code": "/*\n    Behold! Brittle Hollow from OuterWilds!\n    I'm a huge fan of this game, and this project gave me a good reason to make it myself\n    Lots of customized shaders going on to try and mimic the game.\n    There's probably ALOT I could cut down on for performance, so get ready for that in multiple updates!\n*/\n\n/*\n    Post-Processing buffer\n    This is where bloom and other graphical effects will happen\n*/\nfloat sdCircle(vec2 p, float s) {\n    \n    return length(p)-s;\n}\n\n// Check out https://www.desmos.com/calculator/eie9tao79e\nfloat warpSpace(float x, float scale, float slope) {\n    // delta changes where the center is\n    vec2 delta = vec2(0.0);\n    \n    float u = scale*(x-delta.x);\n    float v = sign(u);\n    v /= abs((u * u) - slope);\n    v += u;\n    v /= scale;\n    v += delta.y;\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // -----------------------------------------------\n    //\n    //     Coordinate Spaces that we might use\n    //\n    // -----------------------------------------------\n    float aspect = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 center_uv = ((uv * 2.0 - 1.0)/2.0); //(0,0) is in the center of the screen\n    vec2 square_uv = center_uv; \n    square_uv.x *= aspect; // (0,0) and aspect ratio applied\n    \n    // ----------------------------------\n    //\n    //     The Rest of The Image\n    //\n    // ----------------------------------\n    \n    vec4 image = texture(iChannel0,uv);\n    vec3 bufferA = image.rgb;\n    float bufferA_depth = image.a;\n    \n    vec3 finalcolor = bufferA;\n    \n    // ---------------------------------\n    //\n    //         The Black Hole\n    //\n    // ---------------------------------\n    \n    // ---------------------------\n    // STEP 1) Make a blackhole prop\n    // ---------------------------\n    float bh_dist = sdCircle(square_uv,-0.3);\n    \n    // ---------------------------\n    // STEP 2) Make a blackhole UV shader\n    // --------------------------- \n    \n    // Blackhole color\n    vec3 bh_color = vec3(0.0);\n    \n    // The actual circle that makes the blackhole\n    float bh_circle = 1.0 - smoothstep(0.4,0.403,bh_dist);\n    \n    // The shader is the \"uv\" times the color\n    vec3 blackhole = bh_color*bh_circle;\n    \n    // The range of influence for the warping shader\n    float bh_influence = 1.0 - smoothstep(0.6,0.7,bh_dist);\n\n    // --------------------------------------------------------\n    // STEP 3) Warp the space\n    // If it's in the skybox or this far away, render the blackhole\n    // --------------------------------------------------------\n    #define BLACKHOLEWARP\n    \n    #ifdef BLACKHOLEWARP\n    if(bufferA_depth <= 1.0 || bufferA_depth > 15.0) {\n        \n        // This math here exists to add a circular warp on a uv with no aspect ratio applied to it\n        float l = length(center_uv);\n        float sc = length(normalize(center_uv) * vec2(aspect,1.0)) * 9.3;\n        \n        float warp = warpSpace(l,sc,1.4);\n        vec2 warpuv = warp * normalize(center_uv);\n        warpuv += 0.5; // set center to (0,0)\n        \n        // The warp shader.\n        // Ya it's post-process\n        vec3 warpcol = texture(iChannel0,warpuv).rgb;\n        \n        // Add the warp effect\n        finalcolor = mix(finalcolor,warpcol,bh_influence);\n        // Add the blackhole prop\n        finalcolor = mix(finalcolor,blackhole,bh_circle);\n    }\n    #endif\n    \n    // ---------------------------------------------------------\n    // Add a fade to white after all the rocks have fallen\n    // --------------------------------------------------------\n    \n    // Despite me already defining time in buffer A, \n    // my BEST GUESS is that I have to do it again because time's value will only exist\n    // within the SCOPE of buffer A?\n    \n    time = mod(iTime,MAX_LOOP); \n    if(time >= MAX_LOOP*0.9) {\n        \n        float fadeout = time-(MAX_LOOP*0.9);\n        \n        finalcolor += vec3(fadeout);\n    }\n    if(time <= MAX_LOOP*0.1 && iTime > MAX_LOOP) { // iTime > MAX_LOOP is so it doesn't do it the first time\n        float fadein = 1.0 - (time);\n        finalcolor += vec3(max(fadein,0.0));\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(finalcolor,1.0);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n    Functions that I find myself reusing in every project I do\n    Not much of this is actually used, but it gives me a file I can just copy and paste everywhere\n    Any shader-specific stuff will most likely be in the image buffer\n    This is probably a file that you'll see grow more and more as I use it in more projects\n    Everything in here found is what should be unchanged from shader to shader.\n*/\n\n/*---------------------------------------------------------------------------------\n\n    All purpose variables that can be used anywhere 3D, 2D, raymarching, functions, and more!\n    \n-----------------------------------------------------------------------------------*/\nfloat time = 0.0; //eventually set to iTime. Easiest way to get around the lack of an timer in common\n#define FOV 90.0\n#define PI 3.14159265359\n#define MAX_LOOP 50.0\n//#define DEBUG\n\n/*\n    First section all about transformations\n*/\n\nmat3 RotationX(float rotation) {\n    mat3 rotateX = mat3(\n        1.0, 0.0, 0.0,\n\t\t0.0, cos(rotation), -sin(rotation),\n\t\t0.0, sin(rotation), cos(rotation)\n    );\n\n    return rotateX;\n}\n\nmat3 RotationY(float rotation) {\n    mat3 rotateY = mat3(\n        cos(rotation), 0.0, sin(rotation),\n\t\t0.0, 1.0, 0.0, \n\t\t-sin(rotation), 0.0, cos(rotation)\n    );\n\n    return rotateY;\n}\n\nmat3 RotationZ(float rotation) {\n    mat3 rotateZ = mat3(\n        cos(rotation), -sin(rotation), 0.0,\n\t\tsin(rotation), cos(rotation), 0.0,\n\t\t0.0, 0.0, 1.0\n    );\n\n    return rotateZ;\n}\n\n// scale would just be *= vec3(scales)\n// and translate would just be += vec3(translation)\n// so no functions for that just yet\n\n\n/*\n    Applies transformations as we see fit\n    It's in a function like this because we call this twice\n        -Transform the ray that the scene uses\n        -Transform the UV that the tetxure shader uses\n    THIS IS A VERY IMPORTANT FUNCTION! DO NOT LOOSE IT!\n*/\n\n//this is so sad why isn't iTime already declared :(\nvoid Transform(inout vec3 p) {\n    p *= RotationY(0.5*time);\n}\n\n// Transform function that returns a value instead of editing the parameter\nvec3 TransformReturn(vec3 p) {\n    vec3 temp = p;\n    Transform(temp);\n    return temp;\n}\n\n/*\n    Signed Distance functions and their operations\n    Basically the core of the scene.\n*/\n\nstruct sdf {\n    float dist; // nothing to see here just the distance\n    int ID; // ID which we can then use to apply a corresponding shader to\n    mat3 transform; // Specific transformation that the SDF around it\n};\n\n// Signed primitives\nfloat sdSphere(vec3 p, float s) {\n    \n    return length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    \n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h)\n{\n    // n must be normalized\n    return dot(p,n) + h;\n}\n\n// c is the angles of the cone\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\n//operations\nvec3 sdInfinite(vec3 sd, float c) {\n    return mod(sd+0.5*c,c)-0.5*c;\n}\n\nvec3 sdRepeat(vec3 sd, float c, vec3 d) {\n    vec3 q = sd-c*clamp(round(sd/c),-d,d);\n    return q;\n}\n\nvec3 sdReflectX(vec3 p)\n{\n    float q;\n    q = abs(p.x);\n    return vec3(q,p.yz);\n}\n\nvec3 sdReflectXZ(vec3 p) {\n\tvec2 q;\n    q = abs(p.xz);\n    return vec3(q.x,p.y,q.y);\n}\n\nfloat smoothEdges( in float d, in float h ) {\n    return d - h;\n}\n\n// All from https://iquilezles.org/articles/distfunctions\n// Me prentending that I didn't just copy and paste this from IQs site\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n/*\n    Structures and functions that we can use to set up the 3D scene\n    The most complicated step in this part is adding SDFs\n    Not only does it apply some sort of union, it also has to keep track of IDs\n    The IDs are responsible for saying which shader should be applied to a given shape.\n    \n    TODO: \n        -Figure out how to merge the colors of two objects in a union\n        -Correct UVs for individual objects\n*/\n\nstruct Ray {\n    vec3 ori;\n    vec3 dir;\n};\n\nstruct Light {\n    Ray point;\n    vec3 color;\n    float strength;\n};\n\n// keeps me from having to write the same inputs again and again\nstruct ShaderInput {\n    vec3 normal; // normals of scene\n    vec3 cameraNormal; //normals of the scene relative to the camera. Its just the normals but transformed\n    Ray rendered; // the scene after all the raymarching has been done\n    Ray camera; // viewport\n    vec3 uv; // UVs of each SDF\n    float depth; // depth buffer\n};\n\n// The ID of the obj that the ray hits\n#define SKY -1\nint ID = SKY;\n\n//-------------------------------------------------------------------------------------------------\n// Shader IDs\n//-------------------------------------------------------------------------------------------------\n#define CRACKS 0\n#define ICE 1\n#define BLACKHOLE 2\n#define ICICLES 3\n#define INSIDE 4\n\n// The whole scene in just one float. Yep\nfloat globalsd;\nbool ignoreID = false; // HORRIBLE way to program this, but saves me time\n\nvoid addSDF(sdf obj) {\n    globalsd = min(globalsd, obj.dist);\n    if(globalsd == obj.dist && !ignoreID) {\n        ID = obj.ID;\n    }\n}\n\nvoid subtractSDF(sdf obj) {\n\n    globalsd = max(globalsd, -obj.dist);\n    if(globalsd == obj.dist && !ignoreID) {\n        ID = obj.ID;\n    }\n}\n\n// -------------------------------------------------\n// Noise functions\n// ---------------------------------------------\nvec3 hash(vec3 x, sampler2D channel) {\n    return textureLod( channel, (x.xy+vec2(3.0,1.0)*x.z+0.5)/256.0, 0.0).xyz;\n}\n\nvec3 hash2( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p)*43758.5453123);\n}\n\n// return value noise (in x) and its derivatives (in yzw)\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash2( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash2( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash2( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash2( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash2( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash2( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash2( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash2( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nmat3 noisemat = mat3(\n            1.2, 0.5, 1.6,\n            -1.6, 1.2, 0.5,\n            -0.5, -1.6, 1.2\n        );\n        \n// ----------------------------\n// Misc mathematical functions\n// ----------------------------\n\n// Forces a discontinuity in x\nfloat cut(float x, float n) {\n    return round(x*n)/n;\n}\n\nvec3 cut(vec3 p, float n) {\n    vec3 ret;\n    ret.x = cut(p.x,n);\n    ret.y = cut(p.y,n);\n    ret.z = cut(p.z,n);\n    return ret;\n}\n\n//Doesn't start a timer until a given amount of time later\nfloat forceWait(float t, float offset) {\n    return max(t,offset)-offset;\n}\n\n// -------------------------------------------------------------\n//\n// Texture functions\n// Everything here generally applies to 2d maps or textures\n//\n// -------------------------------------------------------------\nfloat average(vec3 p) {\n    return (p.x+p.y+p.z)/3.0;\n}\n\nfloat average(vec4 p) {\n    return average(p.xyz);\n}\n\nvec3 normalTexture(sampler2D image, vec2 uv, float ep) {\n    float d0 = average(texture(image, uv));\n    \n    float dX = average(texture(image, uv - vec2(ep,0.0) ));\n    float dY = average(texture(image, uv - vec2(0.0,ep) ));\n    \n    vec3 n = vec3(d0-dX,d0-dY,0.0);\n    \n    return normalize(n);\n}", "cube_a_code": "//#define EASYWAYOUT\n#define GAS\n\nvec3 saturate(vec3 rgb, float sat) {\n    vec3 gray = vec3((rgb.r + rgb.g + rgb.b)/3.0);\n    \n    return mix(gray,rgb,sat);\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    #ifdef EASYWAYOUT \n        vec3 col = hash2(rayDir).xxx;\n        col *= 50.0;\n        col -= 49.3; \n    #else\n        vec3 col = vec3(noise(80.0*rayDir));\n        col *= 50.0;\n        col -= 13.0; // This will change overtime to mimic the supernovas across outerwilds\n        vec3 starColor = hash2(cut(rayDir,8.0));\n        starColor = saturate(starColor,0.2);  \n        col *= starColor;\n    #endif\n    col = clamp(col,0.0,1.0);\n\n    // Adds thsi nice ambient gas around the cubemap.\n    // Kind of unessecary but it looks nice\n    #ifdef GAS\n        float gasnoise = noise(rayDir*vec3(1.0,0.5,1.0));\n        vec3 gas = gasnoise * vec3(1.0,0.0,1.0);\n    \n        col += gas;\n    #endif\n    \n    // --------------------------------------------------------------------------------------\n    // This is the sun!\n    // Skip all the intensive distance functions and just make a disc somewhere in the sky\n    // --------------------------------------------------------------------------------------\n    vec3 sunPos = vec3(rayDir.xy,sign(rayDir.z)-1.0);\n    \n    // bloom\n    vec3 glow1 = (1.0-sdSphere(sunPos,0.00001)) * vec3(1.0);\n    vec3 glow2 = smoothstep(0.5,1.0,glow1) * vec3(1.0);\n    vec3 glow3 = smoothstep(0.5,1.0,glow2) * vec3(1.0);\n    \n    vec3 sunBase = smoothstep(0.99,1.0,glow1) * vec3(1.0,1.0,0.0); //Color will change over time\n    \n    vec3 sun = sunBase + glow1 + glow2 + glow3;\n    \n    sun = clamp(sun,0.0,1.0);\n    \n    col += sun;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}", "cube_a_inputs": [], "buffer_a_code": "/*\n    3D Render buffer\n    This is where the brittle hollow and all the textures are generated\n*/\n\n//#define FREE_CAMERA\n\nvec3 hash( vec3 x ) {\n\treturn hash(x,iChannel0);\n}\n\nvoid voronoi3D( in vec3 p, out vec3 coord, out float distToBorder, out float color)\n{\n    vec3 n = floor(p);\n    vec3 f = fract(p);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n    distToBorder = 5.0;\n    for( float x=-1.0; x<=1.0; x++ )\n    for( float y=-1.0; y<=1.0; y++ )\n    for( float z=-1.0; z<=1.0; z++ )\n    {\n        vec3 g = vec3(x,y,z);\n\t\tvec3 o = hash( n + g );\n        vec3 r = g + o - f;\n        float d = length(r);\n\n        if(d<distToBorder)\n        {\n            distToBorder = d;\n            coord = r;\n            color = o.x;\n        } \n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    distToBorder = 8.0;\n    for( float x=-1.0; x<=1.0; x++ )\n    for( float y=-1.0; y<=1.0; y++ )\n    for( float z=-1.0; z<=1.0; z++ )\n    {\n        vec3 g = vec3(x,y,z);\n\t\tvec3 o = hash( n + g );\n        vec3 r = g + o - f;\n        vec3 normal = coord - r;\n       \n        if( dot(normal,normal)>0.0001 ) {\n            float j = dot( 0.5*(coord+r), normalize(r-coord));\n            distToBorder = min( distToBorder, j );\n        }\n    }\n    coord += p;\n}\n\n// returns position\nfloat gravity(float time,float startpoint) {\n    //const float grav = -9.81;\n    const float grav = -2.5; // gravitational constant in m/s/s\n    return startpoint + (grav/2.0)*time*time;\n}\n\n//-------------------------------------------------------------------------------------------------\n// Generate Scene\n// This is where all the object math happens.\n// This giant block comment exists so I don't miss this function when scrolling around the project\n//-------------------------------------------------------------------------------------------------\n\nconst float upperBound = 10.0;\n//const float g = 1./length(vec2(1.,upperBound)); // <- equation used to get g\n// The magic number lags the raymarcher. Why? I have no idea.\nconst float g = 0.099503719021;\nfloat generateScene(vec3 ray) {\n\n    // Transform around the origin\n    Transform(ray);\n    \n    // ---------------------------------------\n    // Place objects in scene\n    // ---------------------------------------\n    \n    // ----------------------\n    // The Planet Surface\n    // ----------------------\n        sdf Planet;\n        Planet.dist = sdSphere(ray,5.0);\n           \n        // First Voronoi Pass. Gives it it's iconic \"cracked\" texture\n        // Normalizing the 3D coordinates gets rid of magnitude, only direction.\n        // This gives us these REALLY nice rays that shoot out from the origin to use as circular coordinates\n        vec3 coord_Pass1;\n        float distToBorder_Pass1;\n        float color_Pass1;\n        voronoi3D(normalize(ray)*5.0,coord_Pass1,distToBorder_Pass1,color_Pass1);\n        \n        //Mess with the cell heights to give them some more variety\n        color_Pass1 *= 0.5;\n        \n        // ----------------------------------------\n        // Simulating Falling Debris:\n        // --------------------------------------\n        // \n        // 1) which rocks fall when is determined by a random number when we input the voronoi cell coord\n        // 2) If the rockStartTime is equal to iTime, start falling\n        // 3) the cell height (color_Pass1) decreases parabolically with the equation x = xo + vt + a/2 t^2. See gravity() for more\n        // \n        // 4) After the time hits a certain value ( probably 5 + decayTime), the process is reversed.\n        //\n        // \n        // -----------------------------------------\n        float decayTime = MAX_LOOP; // seconds that it'll take to fully decimate\n        \n        float randID = hash(coord_Pass1).x;\n        randID *= decayTime;\n        randID = cut(randID,5.0); // Forces some discontinuities so it falls in waves\n        \n        float cellHeight = gravity(forceWait(time,randID),color_Pass1);\n        float maxCellHeight = gravity(forceWait(time,decayTime),color_Pass1);\n        \n        // -----------------------------------------------------------\n        // The Distance calculation\n        // h is height\n        // f is distance to border\n        // if h and f are positive, it means that the closest point away is a corner\n        // if h is negative (inside the cell), f is the closest point away\n        // if f is negative (above the cell) , h is the closest point away\n        // -----------------------------------------------------------\n        float h = Planet.dist - cellHeight;\n        float f = 0.01-distToBorder_Pass1;\n        \n        // Clamp everything to an outermost-sphere\n        // Keeps us from getting raymarch errors from discontinuities in height\n        \n        // these numbers decide the framerate of the whole shader\n        h = max( min( h, 0.05 ), Planet.dist-maxCellHeight-0.2);\n        f = max(f,h);\n\n        float width = 0.4; //width of cell\n    \n        float hI = cellHeight - width;\n        float fI = -distToBorder_Pass1;\n        \n        hI = Planet.dist - hI;\n        fI = max(fI,hI);\n        \n        Planet.dist = max(f,-fI);\n        \n        // Changes the shader ID depending on hI, the height of the inside part of the planet\n        if(hI > 0.01) {\n            Planet.ID = CRACKS;        \n        } else {\n            Planet.ID = INSIDE;        \n        }\n        \n    // ----------------------    \n    // The Ice Caps\n    // ----------------------\n        sdf IceCaps;\n        IceCaps.dist = sdSphere(ray*vec3(1.4,0.95,1.4),5.7);\n        //float cutout = sdSphere(ray*vec3(1.0,1.3,1.0),5.6);\n        float cutout = sdBox(ray,vec3(5.0,3.6,5.0));\n        IceCaps.dist = max(IceCaps.dist,-cutout);\n        \n        // adds noise to snow\n        {\n            vec3 noiseray = ray;\n            for(int i = 0; i < 2; i++) {\n                IceCaps.dist -= noise(0.4*noiseray);\n                noiseray *= noisemat;\n            }\n        }\n        //iceCaps.dist *= g;\n        IceCaps.ID = ICE;\n        \n    // ----------------------    \n    // The Icicles\n    // Very cone + noise based\n    // ----------------------\n        sdf Icicles;\n        float cones;\n        #define MAX_ICICLES 6\n\n        {\n            float cr = 0.4;\n            float cones_top = 99999999.0; // random high number\n            float cones_bottom = 99999999.0;\n            \n            for(int i = 0; i < MAX_ICICLES; i++) {\n                float deg = (float(i) / float(MAX_ICICLES))*2.0*PI;\n                deg *= 2.0;\n                if(i >= (MAX_ICICLES / 2)) cr = 0.2; else cr = 0.4;\n            \n                float ct = sdCone(\n                    ( RotationX(cr*cos(deg)) * RotationZ(cr*sin(deg)) * ray ) + vec3(0.0,1.0,0.0),\n                    vec2(0.04,0.2), \n                    3.8\n                    );\n                cones_top = min(cones_top,ct);\n                \n                float cb = sdCone(\n                    ( RotationX(cr*cos(deg)) * RotationZ(cr*sin(deg)) * (vec3(1.0,-1.0,1.0) * ray) )  + vec3(0.0,1.0,0.0), \n                    vec2(0.04,0.2),\n                    3.8\n                    );  \n                cones_bottom = min(cones_bottom,cb);\n            }\n\n            cones = min(cones_top,cones_bottom); \n        }\n        \n        cones -= 0.5*noise(ray);\n        cones -= 0.1*noise(4.0*ray);\n        \n        Icicles.dist = cones;\n        Icicles.ID = ICICLES;      \n        \n    // ---------------------------------\n    // Adds them together into the scene\n    // ---------------------------------\n    globalsd = 1.0;\n    addSDF(Planet);\n    addSDF(IceCaps);\n    addSDF(Icicles);\n   \n    return globalsd;\n}\n\n// ----------------------------------------------------------------------\n// RayMarching scene\n// TODO: Find optimal numbers for MAX_STEPS, MAX_DISTANCE, and EPSILON\n// ----------------------------------------------------------------------\n\n#define MAX_STEPS 600\n#define MAX_DISTANCE 20.0\n#define EPSILON 0.001\nfloat rayMarch(Ray o) {\n    vec3 ray;\n    float sd,d;\n  \t\n    for(int i = 0; i < MAX_STEPS; i++) {\n        ray = o.ori + (o.dir * d);\n        sd = generateScene(ray);\n        \n        if(sd < EPSILON) {\n            return d;\n        }\n        //Not having this somewhere makes these strange blobs around the objects\n        ID = SKY;\n        \n        d += sd;\n        if(d > MAX_DISTANCE) break;\n    }\n}\n\n// Gets the depth buffer\nfloat depthBuffer(Ray o) {\n    ignoreID = true;\n    vec3 ray;\n    float sd,d;\n  \t\n    for(int i = 0; i < MAX_STEPS; i++) {\n        ray = o.ori + (o.dir * d);\n        sd = generateScene(ray);\n        \n        if(sd < EPSILON) {\n            //ignoreID = false;\n            return d;\n        }\n        \n        d += sd;\n        if(d > MAX_DISTANCE) {\n            //ignoreID = false;\n            break;\n        }  \n    }\n}\n\n#define NORMAL_EPSILON 0.01\nvec3 Normal(vec3 p) {\n    float d0 = generateScene(p);\n    \n    float dX = generateScene(p - vec3(NORMAL_EPSILON,0.0,0.0));\n    float dY = generateScene(p - vec3(0.0,NORMAL_EPSILON,0.0));\n    float dZ = generateScene(p - vec3(0.0,0.0,NORMAL_EPSILON));\n    \n    vec3 r = vec3(d0-dX,d0-dY,d0-dZ);\n    \n    return normalize(r);\n}\n\nvec3 pointLighting(ShaderInput s, Light l, vec3 color) {\n\n    vec3 pointLight = color * dot(l.point.dir,s.normal);\n    \n    // this commented set can take care of shadows, but it's kind of broken and I want to replace it with soft shadows\n    /*Ray o;\n    o.ori = s.rendered.ori + vec3(0.4)*l.point.dir;\n    o.dir = l.point.dir;\n    \n    float lightRay = depthBuffer(o);\n    \n    if(lightRay > 1.0) {\n        pointLight = vec3(0.0);\n    }*/\n    \n    return pointLight;\n}\n\n// Specular lighting from a point in space\nvec3 specularLighting(ShaderInput s, Light l, float specular_power) {\n    vec3 ldir = l.point.dir;\n\n    vec3 h = normalize(s.camera.dir-(ldir));\n    float spec = dot(h,-s.normal);\n    spec = pow(spec,specular_power);\n    \n    if(isnan(spec)) spec = 0.0; //Becomes NAN when facing away form the light.\n    spec = clamp(spec,0.0,1.0);\n    \n    return vec3(spec);\n}\n\n// This manages to somehow, sample a texture? What the fuck?\nvec3 phongLighting(ShaderInput s, Light l, vec3 color, float specular_power) {\n    vec3 phong = pointLighting(s, l, color) + specularLighting(s, l, specular_power);\n    return (color + phong) / 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = mod(iTime,MAX_LOOP);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv * 2.0 - 1.0)/2.0;\n    \n    // Applying aspect ratio\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n    \n    // Setting up 3D space\n    vec3 xyz = normalize(vec3(uv,1.0));\n    float fovrange = tan(radians(FOV*.5));\n    xyz *= fovrange;\n    \n    // Setting up camera\n    Ray camera;\n\n    vec2 mouse = -8.0 * vec2(iMouse.xy/iResolution.xy);\n    \n    #ifdef FREE_CAMERA\n        float radius = 15.0;\n        camera.ori = vec3(0.0,radius*sin(mouse.y),-radius*cos(mouse.y)) * RotationY(mouse.x);\n        camera.dir = vec3(mouse.y,mouse.x,0.0);\n    #else\n        float radius = 15.0;\n        float speed = 0.1*iTime + PI/2.0;\n        camera.ori = vec3(0.0,0.0,-radius) * RotationY(speed);\n        camera.dir = vec3(0.0,speed,0.0);\n    #endif\n    \n    // Transforming 3D space to camera space\n    xyz *= RotationX(camera.dir.x) * RotationY(camera.dir.y) * RotationZ(camera.dir.z);\n    \n    // Setting up the raymarch\n    Ray viewport;\n    viewport.ori = camera.ori;\n    viewport.dir = xyz;\n    \n    // Applying raymarch\n    Ray rendered;\n    float depth = rayMarch(viewport);\n    rendered.dir = viewport.dir * depth;\n    rendered.ori = viewport.ori + rendered.dir; //rendered.ori is the new scene data\n    \n    // Correct UV coords to transform with the image\n    vec3 textuv = rendered.ori;\n    Transform(textuv);\n    \n    // Get normals of image\n    vec3 normals = Normal(rendered.ori);\n    \n    // A Set of inputs that most shaders will use. Keeps be from writing the same parameters repeatedly\n    ShaderInput si;\n    si.normal = normals;\n    si.cameraNormal = TransformReturn(normals);\n    si.rendered = rendered;\n    si.camera = viewport;\n    si.uv = textuv * 0.25; // scales the uv down\n    si.depth = depth;\n    \n    // Creating some universal variables that will be used later\n    Light light1;\n    light1.color = vec3(1.0);\n    light1.strength = 1.0;\n    light1.point.ori = vec3(0.0,0.0,6.0);\n    \n    //#define LIGHTDIRNOTWORKING // Light should face sun, but doesn't???\n    #ifndef LIGHTDIRNOTWORKING\n        light1.point.dir = normalize(light1.point.ori - si.rendered.ori);\n    #else\n        light1.point.dir = vec3(0.0,0.0,1.0);\n        light1.point.dir *= RotationY(-iTime); //Am i \"undoing\" a transformation somewhere?\n    #endif\n    \n    // -------------------------------------------------------------------------\n    // ID correlates to the shader that we'll use for a given shape in the scene\n    // Adding {} maintains scope, allowing me to reuse variable names\n    // -------------------------------------------------------------------------\n    vec3 finalcolor;\n    if(si.depth < 1.0) ID = SKY; // Sets out of bounds depth to the sky\n    switch(ID) {\n        case CRACKS:\n            {\n            vec3 colx = texture(iChannel1,(si.uv.zy)).rgb;\n            vec3 coly = texture(iChannel1,(si.uv.xz)).rgb;\n            vec3 colz = texture(iChannel1,(si.uv.xy)).rgb;\n        \n            vec3 blend = abs(si.cameraNormal);\n            blend /= dot(blend,vec3(1.0));\n            \n            vec3 surfaceColor = vec3(1.23,1.0,1.45);\n            vec3 rockySurface = (colx * blend.x + coly * blend.y + colz * blend.z);\n            vec3 surface = surfaceColor * rockySurface;\n            \n            finalcolor = phongLighting(si, light1, surface, 50.0);\n            }\n        break;\n        case ICE:\n            {\n            vec3 surfaceIceCaps = vec3(0.9,0.9,1.0);\n            finalcolor = phongLighting(si, light1, surfaceIceCaps, 0.0);\n            }\n        break;\n        case ICICLES:\n            {\n            vec3 icecolor = vec3(0.7,0.7,1.0);\n            si.normal = cut(si.normal,1.4);\n            finalcolor = phongLighting(si, light1, icecolor, 50.0) + (icecolor / 2.0);\n            }\n        break;\n        case INSIDE:\n            {\n            // The texture\n            vec3 colx = texture(iChannel3,(si.uv.zy)).rgb;\n            vec3 coly = texture(iChannel3,(si.uv.xz)).rgb;\n            vec3 colz = texture(iChannel3,(si.uv.xy)).rgb;\n            \n            // The normal of the texture\n            vec3 ncolx = normalTexture(iChannel3,(si.uv.zy),0.03);\n            vec3 ncoly = normalTexture(iChannel3,(si.uv.xz),0.03);\n            vec3 ncolz = normalTexture(iChannel3,(si.uv.xy),0.03);\n        \n            vec3 blend = abs(si.cameraNormal);\n            blend /= dot(blend,vec3(1.0));\n            \n            vec3 surfaceColor = vec3(1.23,1.0,1.45);\n            vec3 chipSurface = (colx * blend.x + coly * blend.y + colz * blend.z);\n            vec3 surface = surfaceColor * chipSurface;\n            \n            // changes the normal of the underside so there's more detail on the underbelly\n            si.normal += 0.7*(ncolx * blend.x + ncoly * blend.y + ncolz * blend.z);\n            \n            finalcolor = phongLighting(si, light1, surface, 50.0);\n            }\n        break;\n        case SKY:\n            {\n            finalcolor = texture(iChannel2,si.camera.dir).rgb;\n            }\n        break;\n    }\n    \n    // Output to screen \n    // set the alpha channel as the depth buffer\n    fragColor = vec4(finalcolor,si.depth);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This generates the texture for the underside of the planet\n\n// I got this from https://www.shadertoy.com/view/XtXBzN. Thanks to marian42!\n\nconst float triangleScale = 0.816497161855865; // ratio of edge length and height\nconst float period = 30.0;\n\n// good old randomizer\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 getTriangleCoords(vec2 uv) {\n    uv.y /= triangleScale;\n    vec2 triangleCoords = floor(uv);\n    triangleCoords.x *= 2.0;\n    float mody = floor(mod(triangleCoords.y, 2.0));\n    vec2 local = vec2(fract(uv.x + mody * 0.5) - 0.5, fract(uv.y));\n    \n    // Turns square segments into triangular segments\n    if (local.y > abs(local.x) * 2.0) {\n        triangleCoords.x += local.x < 0.0 ? 1.0 : -1.0;\n    }\n    if (local.x >= 0.0 && mody == 0.0) {\n        triangleCoords.x += 2.0;\n    }\n    \n    return triangleCoords;\n}\n\nfloat getColor(vec2 uv) {\n    vec2 triangle = getTriangleCoords(uv);\n     \n    float angle = floor(6.0 * rand(triangle + 0.1)) / 3.0 * PI;\n    vec2 direction = vec2(sin(angle), cos(angle));\n    float projected = dot(direction, uv);    \n    \n    return rand(triangle);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 40.0;\n    float value = getColor(uv);\n    \n    vec3 col = vec3(1.0,0.5,0.26);\n    \n    col *= value;\n    col += 0.1;\n    \n\tfragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsyXWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[314, 411, 444, 444, 475], [477, 535, 587, 628, 810], [812, 812, 868, 1039, 4246]], "test": "untested"}
{"id": "fldXWS", "name": "Cubic Dispersal", "author": "Tater", "description": "3d version of [url]https://www.shadertoy.com/view/stdGz4[/url]. I finally got around to finishing it. \n\nuse mouse to reveal perspective. ", "tags": ["3d", "raymarching", "subdivision"], "likes": 151, "viewed": 5022, "published": 3, "date": "1639698771", "time_retrieved": "2024-07-30T18:41:38.186176", "image_code": "//Building on ideas from\n//https://www.shadertoy.com/view/fd3SRN\n//https://www.shadertoy.com/view/fsySWm\n//https://www.shadertoy.com/view/stdGz4\n//https://www.shadertoy.com/view/7sKGRy\n//https://www.shadertoy.com/view/fsyGD3\n//https://www.shadertoy.com/view/fdyGDt\n//https://www.shadertoy.com/view/7dVGDd\n//https://www.shadertoy.com/view/NsKGDy\n\n//I had some plans to make a more elaborate shape using the \"fully animated subdivision\"\n//but it ended up not looking that interesting when applied to an octree and it's too\n//expensive to make shapes out of multiple \"sheets\" of this.\n\n//I hope you enjoy it none the less :) \n//(sorry if it's expensive I didn't do much opmimizing)\n\n#define MDIST 150.0\n#define STEPS 164.0\n#define pi 3.1415926535\n#define pmod(p,x) (mod(p,x)+0.5*(x))\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n//this is a useless trick but it's funny\n#define vmm(v,minOrMax) minOrMax(v.x,minOrMax(v.y,v.z))\n\n//iq box sdf\nfloat ebox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(vmm(q,max),0.0);\n}\n//iq palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos(2.*pi*(c*t+d));\n}\nfloat h11 (float a) {\n    return fract(sin((a)*12.9898)*43758.5453123);\n}\n//https://www.shadertoy.com/view/fdlSDl\nvec2 tanha(vec2 x) {\n  vec2 x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\nfloat tanha(float x) {\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nstruct sdResult\n{\n    vec2 center;\n    vec2 dim;\n    float id;\n    float vol;\n};\n\nsdResult subdiv(vec2 p,float seed){\n    vec2 dMin = vec2(-10.);\n    vec2 dMax = vec2(10.);\n    float t = iTime*0.6;\n    float t2 = iTime;\n    vec2 dim = dMax - dMin;\n    float id = 0.;\n    float ITERS = 6.;\n    \n    float MIN_SIZE = 0.1;\n    float MIN_ITERS = 1.;\n    \n    //big thanks to @0b5vr for letting me use his cleaner subdiv implementation\n    //https://www.shadertoy.com/view/NsKGDy\n    vec2 diff2 = vec2(1);\n    for(float i = 0.;i<ITERS;i++){\n        vec2 divHash=tanha(vec2(sin(t2*pi/3.+id+i*t2*0.05),cos(t2*pi/3.+h11(id)*100.+i*t2*0.05))*3.)*0.35+0.5;\n        //divHash=vec2(sin(t*pi/3.+id),cos(t*pi/3.+h11(id)*100.))*0.5+0.5;\n        //if(iMouse.z>0.5){divHash = mix(divHash,M,0.9);}\n        divHash = mix(vec2(0.5),divHash,tanha(sin(t*0.8)*5.)*0.2+0.4);\n        vec2 divide = divHash * dim + dMin;\n        divide = clamp(divide, dMin + MIN_SIZE+0.01, dMax - MIN_SIZE-0.01);\n        vec2 minAxis = min(abs(dMin - divide), abs(dMax - divide));\n        float minSize = min( minAxis.x, minAxis.y);\n        bool smallEnough = minSize < MIN_SIZE;\n        if (smallEnough && i + 1. > MIN_ITERS) { break; }\n        dMax = mix( dMax, divide, step( p, divide ));\n        dMin = mix( divide, dMin, step( p, divide ));\n        diff2 =step( p, divide)-\n        vec2(h11(diff2.x+seed)*10.,h11(diff2.y+seed)*10.);\n        id = length(diff2)*100.0;\n        dim = dMax - dMin;\n    }\n    vec2 center = (dMin + dMax)/2.0;\n    sdResult result;\n    result.center = center;\n    result.id = id;\n    result.dim = dim;\n    result.vol = dim.x*dim.y;\n    return result;\n}\nvec3 rdg = vec3(0);\nfloat dibox(vec3 p,vec3 b,vec3 rd){\n    vec3 dir = sign(rd)*b;   \n    vec3 rc = (dir-p)/rd;\n    return min(rc.x,rc.z)+0.01; \n}\nbool traverse = true;\nvec3 map(vec3 p){\n    float seed = sign(p.y)-0.3;\n    seed = 1.;\n    //p.y = abs(p.y)-4.;\n\n    vec2 a = vec2(99999,1);\n    vec2 b = vec2(2);\n    \n    a.x = p.y-2.0;\n    float id = 0.;\n    if(a.x<0.1||!traverse){\n        float t = iTime;\n        sdResult sdr = subdiv(p.xz,seed);\n        vec3 centerOff = vec3(sdr.center.x,0,sdr.center.y);\n        vec2 dim = sdr.dim;\n\n        float rnd = 0.05;\n        float size = min(dim.y,dim.x)*1.;\n        //size = 1.;\n        size+=(sin((centerOff.x+centerOff.z)*0.6+t*4.5)*0.5+0.5)*2.;\n        size = min(size,4.0);\n        a.x = ebox(p-centerOff-vec3(0,0,0),vec3(dim.x,size,dim.y)*0.5-rnd)-rnd;\n        if(traverse){\n            b.x = dibox(p-centerOff,vec3(dim.x,1,dim.y)*0.5,rdg);\n            a = (a.x<b.x)?a:b;\n        }\n        id = sdr.id;\n    }\n    return vec3(a,id);\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0.);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-0.5*R.xy)/R.y;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,6.,-12)*1.2;\n\n    ro.xz*=rot(0.35);\n    vec3 lk = vec3(-1,-3,0.5);\n    if(iMouse.z>0.){\n       ro*=2.;\n       lk = vec3(0);\n       ro.yz*=rot(2.0*(iMouse.y/iResolution.y-0.5));\n       ro.zx*=rot(-9.0*(iMouse.x/iResolution.x-0.5));\n    }\n    vec3 f = vec3(normalize(lk-ro));\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(1.8)+r*uv.x+uv.y*cross(f,r));\n    rdg = rd;\n    vec3 p = ro;\n    float dO =0.;\n    vec3 d;\n    bool hit = false;\n        \n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n        if(d.x<0.005){\n            hit = true;\n            break;\n        }\n        if(dO>MDIST)break;\n    }\n    \n    if(hit&&d.y!=2.0){\n        traverse = false;\n        vec3 n = norm(p);\n        vec3 r = reflect(rd,n);\n        vec3 e = vec3(0.5);\n        vec3 al = pal(fract(d.z)*0.35-0.8,e*1.2,e,e*2.0,vec3(0,0.33,0.66));\n        col = al;\n        vec3 ld = normalize(vec3(0,45,0)-p);\n\n        //sss from nusan\n        float sss=0.1;\n        float sssteps = 10.;\n        for(float i=1.; i<sssteps; ++i){\n            float dist = i*0.2;\n            sss += smoothstep(0.,1.,map(p+ld*dist).x/dist)/(sssteps*1.5);\n        }\n        sss = clamp(sss,0.0,1.0);\n        \n        float diff = max(0.,dot(n,ld))*0.7+0.3;\n        float amb = dot(n,ld)*0.45+0.55;\n        float spec = pow(max(0.,dot(r,ld)),13.0);\n        //blackle ao \n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).x)\n        float ao = AO(0.1,n,p)*AO(.2,n,p)*AO(.3,n,p);\n\n        spec = smoothstep(0.,1.,spec);\n        col = vec3(0.204,0.267,0.373)*\n        mix(vec3(0.169,0.000,0.169),vec3(0.984,0.996,0.804),mix(amb,diff,0.75))\n        +spec*0.3;\n        col+=sss*al;\n        col*=mix(ao,1.,0.65);\n        col = pow(col,vec3(0.85));\n    }\n    else{\n    col = mix(vec3(0.373,0.835,0.988),vec3(0.424,0.059,0.925),length(uv));\n\n    }\n    \n    col *=1.0-0.5*pow(length(uv*vec2(0.8,1.)),2.7);\n    vec3 col2 = smoothstep(vec3(0.0, 0.0, 0.0), vec3(1.1, 1.1, 1.3), col);\n    col = mix(col,col2,0.5)*1.05;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldXWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[930, 943, 972, 972, 1048], [1049, 1062, 1129, 1129, 1168], [1169, 1169, 1190, 1190, 1242], [1243, 1283, 1303, 1303, 1378], [1379, 1379, 1401, 1401, 1477], [1561, 1561, 1596, 1596, 3120], [3141, 3141, 3176, 3176, 3267], [3290, 3290, 3307, 3307, 4106], [4107, 4107, 4125, 4125, 4253], [4254, 4254, 4310, 4310, 6493]], "test": "untested"}
{"id": "ftcXDB", "name": "Minimal Hardy", "author": "nabr", "description": "save the cheerleader save the world", "tags": ["sound", "drums"], "likes": 17, "viewed": 456, "published": 3, "date": "1639696964", "time_retrieved": "2024-07-30T18:41:39.042886", "image_code": "// char by FabriceNeyret2\n#define char(_p,_C)(((_p.x<0.||_p.x>1.||_p.y<0.||_p.y>1.))?vec4(0,0,0,1e5):textureGrad(iChannel3,_p/16.+fract(vec2(_C,15-_C/16)/16.),dFdx(_p/16.),dFdy(_p/16.)))\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n     #define R iResolution.xy\n     #define t 8.*iTime\n     vec4 Oo = O;\n     //print char sound in\n     vec2 u =  3.*(vec2(U.x, U.y)*2.-R)/R.y +vec2(.5, -1.5);\n     float a= .92;\n     for(int i = 0; i < 7; ++i){\n     O += char(u,int[](83, 111, 117, 110, 100, 105, 110)[i]).x* max(0., 1.-t*.04) ;\n     Oo.xyz += (cos(floor(sin(t)*u.x)*8.*u.y*vec3(1, 2,3)+2.*iTime));\n     u.x -= 1.45;\n     u*= mat2(cos(a), -sin(a), sin(a), cos(a));\n     }\n     //\n     vec2 st =  abs(3.*(U*2.-R)/min(R.x,R.y));\n     st += .2/length(sin(t+max(st.x,st.y)));\n     ivec2 gv = ivec2(st);\n     O.xz += vec2(.8, cos(t)*.6+.6)*float(gv.x==(int(t)/2%4)&&gv.y==(int(t)/3%4))/float(iFrame%10);\n     O.yz += clamp( sin(st.y +.5*iTime) * ((O.x+O.z)/2.), 0., 1.);\n     if(iTime<8.)\n     O += mix(min(O,Oo), max(1.-sqrt(Oo), O), sin(t)*.5+.5);\n     if(mod(1. + .5 *t, 4.) > 2.)\n      O += min(O,Oo);\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define _f(x) fract(x)\n\nvoid hardy(in float rt, in float of, inout float y)\n{\n\n    float yy = 0.;\n    \n    float tm = (_f(rt *2.) - of);\n    float ft = _f(4. *tm);\n    float en = (1. + _f(rt));\n    float ten = 0.; \n    en = ten = (sqrt(en) *4. *en);\n\n    float sr = .67, pa = .1;\n    \n    if (rt > 14.25 && rt < 15.5)\n    {\n        sr = .4;\n        pa = .21;\n        en = 1.;\n    }\n\n    float xe = pow(max(_f(tm), .0001), pa) * (sin(tm) *sr + sr);\n\n    if(mod(rt, 6.) > 5. && rt > 20.)\n        en = (.5 + cos(en));\n    \n    if(rt>6.&&rt<8. || rt > 24.&&rt < 30.)\n        en = sqrt(ten) *4. *ten;\n\n    yy = (sin(240.5* sin(xe)) *(.5 + cos(en)));\n\n    if(rt > 6. && rt < 12. && mod(1. + .5 *rt, 3.) > 2.)\n        yy += .07* sin(1244. *xe);\n\n    yy *= (min(1., 200. *ft) *max(0., 1. - ft));\n    y = (clamp(yy, -.5, .5));\n\n    if(rt > 16.1)\n        y += .1 * sin(6300. *rt + en) *exp(-10. *_f(8. *rt));\n\n}\n\n\n#define Fs iSampleRate\nvec2 mainSound(in int s, float t)\n{\n    t = mod(float(s)/Fs,38.);\n    \n    vec2 drm0 = vec2(0);\n    \n    hardy(t, .503, drm0.x);\n    hardy(t, .505, drm0.y);\n    return (drm0-.3*(.5*drm0.x-drm0.y));\n    \n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcXDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fldSWS", "name": "Logarithmic Moebius color arrows", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "zoom", "spiral", "mobius", "transform", "logarithm", "short", "golf"], "likes": 29, "viewed": 360, "published": 3, "date": "1639691244", "time_retrieved": "2024-07-30T18:41:39.837760", "image_code": "// color variant of https://shadertoy.com/view/NltXRl\n\nvoid mainImage(out vec4 O,  vec2 U)\n{\n    vec2 z = iResolution.xy;\n         U = (z = (U+U - z) / z.y) -.2;\n\tz.x += 2.;  \n    U.x -= .6;\n    U *= mat2(z,-z.y,z) / dot(U,U);\n    U = log(length(U+=.5)) + atan(U.y, U.x) * vec2(1.592, -.637);\n    U.y -= iTime/4.;\n    z = fract(U+U)-.5;\n    O = ( ( z.y<0.? -z.y: .25 ) - abs(z.xxxx) )\n        / fwidth(length(1.4*z));\n        \n    U = floor(U*4.) +vec2(z.x<0.,z.y>0.);                           // arrow Id\n    O = min(O,1.) * ( .6 + .6 * cos( U.x+8.*U.y +iTime + vec4(0,23,21,0)) ); // hue\n}\n\n", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldSWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 92, 92, 592]], "test": "untested"}
{"id": "ftdSWS", "name": "arrows ( extruded )", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "escher", "short", "onetweet", "arrows", "golf"], "likes": 12, "viewed": 274, "published": 3, "date": "1639689795", "time_retrieved": "2024-07-30T18:41:40.600721", "image_code": "// extruded variant of https://shadertoy.com/view/fltXRl\n\nvoid mainImage(out vec4 O, vec2 U){\n    float R = iResolution.y;\n   // U += vec2(.5,.8)*U.y;\n    U = mod( 4.*U, R ) - R/2.;\n    O = max( abs(U.yyyy) + ( U.x>0. ? -R/4. : U.x ) , 0. ); // arrows\n    if ( U.x<0. ? U.y+U.x > -R/8. : U.y > R/6. && U.y-U.x > -R/4. ) O += .5; // walls\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdSWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 93, 93, 339]], "test": "untested"}
{"id": "7t3SDB", "name": "Spiral Weave", "author": "mla", "description": "Just playing around with some patterns: square tiling, each cell has a line in a random orientation plus its mirror image (adjust line position with mouse).", "tags": ["spiral", "complex", "log", "weave"], "likes": 31, "viewed": 434, "published": 3, "date": "1639684048", "time_retrieved": "2024-07-30T18:41:41.468401", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// Spiral Weave, Matthew Arcus, mla, 2021\n// Construct a simple weave pattern from a square grid.\n// Shown with a complex log transformation for added interest.\n////////////////////////////////////////////////////////////////////////////////\n\nvec3 drawline(vec3 col, vec2 p, vec2 q, vec2 r, float px) {\n  vec3 linecol = vec3(1);\n  float linedist = segment(p,q,r)-0.2;\n  col = mix(linecol,col,smoothstep(-px,px,linedist));\n  col *= smoothstep(-px,px,abs(linedist)-0.02);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec2 mouse = vec2(0.4,0.6);\n  if (iMouse.x > 0.0) {\n    mouse = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    mouse *= 2.0;\n  }\n  if (!key(CHAR_T)) {\n    // Invert\n    p += 0.5;\n    p /= dot(p,p);\n    p -= 0.5;\n    // complex log\n    p = vec2(log(length(p)),atan(p.y,p.x))/PI;\n  }\n  // get pixel width from p.x (which is continuous)\n  float px = fwidth(p.x);\n  // rotate & scale with a complex mult\n  vec2 rot = vec2(7,3);\n  p = cmul(p,rot);\n  // adjust pixel width\n  px *= length(rot);\n  // rotate along spirals\n  p.y += iTime;\n  // index of current cell, need to take account of complex branch\n  vec2 index = vec2(-p.y,p.x);\n  // this ensures that index(z-i) = index(z+i)\n  index -= floor(index.x/rot.x)*rot;\n  // apply symmetries\n  p += 1.0;\n  p = mod(p,2.0);\n  p -= 1.0;\n  if (key(CHAR_M)) p = abs(p); // Mirror symmetry\n  if (p.y < 0.0) p = -p; // rotate lower to upper\n  if (p.x < 0.0) p = vec2(p.y,-p.x); // rotate left to right\n  // hash for current cell\n  float h = hash(uint(iTime*0.0)^uint(int(index.y))^uint(int(index.x)<<16));\n  // randomly flip\n  if (!key(CHAR_H) && h < 0.5) p = p.yx;\n  // show cell sectors\n  vec3 col = vec3(0.1);\n  if (!key(CHAR_C)) col = 0.2+0.8*h2rgb(h);\n  if (!key(CHAR_S)) col *= 0.5+0.5*smoothstep(-px,px,p.x-p.y);\n  // draw random line and its reflection\n  vec2 q = vec2(mouse.x,0), r = vec2(mouse.y,1);\n  col = drawline(col,p,q,r,px);\n  col = drawline(col,p.yx,q,r,px);\n\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float PI = 3.14159;\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash(uint x) {\n  return float(ihash(x))/pow(2.0,32.0);\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  //h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nvec2 cmul(vec2 z1, vec2 z2) {\n  return mat2(z1.x,z1.y,-z1.y,z1.x)*z2;\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// Macros for use in \"common\" blocks.\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3SDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[324, 324, 383, 383, 566], [568, 568, 621, 621, 2156]], "test": "untested"}
{"id": "sdSGWV", "name": "MandelBrot Orbit trap 2", "author": "MinimilisticBits", "description": "sdfsdf", "tags": ["fssg"], "likes": 14, "viewed": 486, "published": 3, "date": "1639683418", "time_retrieved": "2024-07-30T18:41:42.239339", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n    //col *= 0.8;\n    col = pow(col, vec3(1./1.6));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat rand(vec2 n) { \n\treturn fract(sin(n.x*100. + n.y*245.)*10000.);\n}\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\t\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm( in vec2 x, in float H )\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    const int numOctaves = 4;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*noise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t*0.1;\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvec2 hash2(inout float seed) {\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n\nvec2 mulz(vec2 z){\nreturn vec2(z.x*z.x-z.y*z.y, 2.0*z.x*z.y);\n} \n\nfloat box(vec2 p, vec2 s){\nvec2 a = abs(p)-s;\nreturn max(a.x,a.y);\n}\n\nfloat star( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nfloat g1(float x){\nreturn  sin(x);\n}\n\nfloat g2(float x){\nreturn tan(x)+tanh(x);\n}\n\n\nvec3 mand(vec2 p, vec2 q){\nfloat trapdist = 0.8;\nbool trapped = false;\nvec2 trap2 = p;\nfloat timestep = 0.06;\nfloat stalksradius = 0.002;\n//float trapsize = 0.01;\nvec2 z = p;\nvec2 c = p;\n float stalksradiushigh=sqrt(c.x*c.x+c.y*c.y)+stalksradius;\n float stalksradiuslow=sqrt(c.x*c.x+c.y*c.y)-stalksradius;\n float trap3;\n float a = 0.1;\n float b = 0.4;\n float ztot = 0.;\nfloat s = 0.;\nfloat k = 999999999.;\nfor(int i = 0; i < 60; i++){\nz = mulz(z)+c;\nk = min(k, star(z-p, 0.003));\nfloat d = dot(z,z);\ns+=exp(-0.2*d);\nif(length(z) > 22.)break;\n\t//crosses orbit traps\n  trap2.x = trap2.x - timestep*sin(z.y + tan(3.*z.y*a));\n  trap2.y = trap2.y + timestep*tan(z.x + tan(3.*z.x*b));\n  \n  /*trap2.x = trap2.x - timestep*(g1(z.y+g2(a*z.y))) - timestep*(g1(z.x + g2(a*z.x)));\n  trap2.y = trap2.y - timestep*(g2(z.x+g1(a*z.x))) - timestep*(g2(z.y + g1(a*z.y)));\n  float px = trap2.x;\n\nfloat r= sqrt(trap2.x*trap2.x+trap2.y*trap2.y);\nfloat t= atan(trap2.y/(trap2.x));\ntrap2.x = r*cos(2.*t);\ntrap2.y = r*sin(2.*t);\n  */\n  \n  float ds = dot(trap2.x-p, trap2.y-p);\n  trap3 += exp(-0.2*ds);\n  float magnitude = length(z);\nif ((sqrt(magnitude)<=stalksradiushigh) && (sqrt(magnitude)>=stalksradiuslow) && (i>1)) {\n\tztot=sqrt(ztot)+(1.-abs(sqrt(magnitude)-sqrt(c.x*c.x+c.y*c.y))/stalksradius);\n    trapped=true;\n    }\n//if (trapped==true) break;\n}\n\n//return vec3(1.-trapdist/trapsize);\n//float trap = 1.-(trapdist/trapsize);\n\t\t\t\t//stalkcolor=min(1,sqrt(ztot));\n//float trap = 1.-trapdist/stalksradius;\nfloat trap = min(min(0.5,(ztot)),length(z*0.2));\n\n//return vec3(trap);\n//return vec3(fbm(q*abs(trap2)*0.01,1.));\n//fbm(trap2*0.02,3.)*2.1\n//return palette(trap+k*3.10+fbm(mulz(z)*0.00001*fbm(mulz(z)*0.001,3.),3.)*1.1, vec3(0.5), vec3(0.5), vec3(1.), vec3(0.,0.1,0.2));\nreturn palette(s*.1+trap, vec3(0.5), vec3(0.5), vec3(1.), vec3(0.,0.1,0.2))*fbm(q*abs(trap2)*0.02+fbm(q*abs(trap2)*0.02,3.),3.)*12.1;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n    \n    float seed = uv.x + uv.y * 3.43121412313 + fract(1.12345314312*iTime);\n    uv += (hash2(seed)*2.0-1.0)*0.001;\n    //if(iFrame < 30)discard;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    float scale = 0.003;\n        uv *= (scale);\n    vec2 pos = vec2(208., 299.)/iResolution.xy;\n    pos = pos * 2.0 - 1.0;\n    uv = (vec2(0.31*2.-1.,0.8305555555555556*2.0-1.))-uv;\n    //uv = mouse - uv;\n    // Time varying pixel color\n    vec3 col = mand(uv, (fragCoord.xy/iResolution.xy)*10.);\n    vec3 prevcol = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    col = mix(prevcol, col, 1.0/(float(iFrame+1)));\n    // Output to screen\n    //col = vec3(fbm(.,2.));\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSGWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 300]], "test": "untested"}
{"id": "7l3XWS", "name": "mess x 100", "author": "SnoopethDuckDuck", "description": "i outdo my messy code every time. no idea what this is", "tags": ["e"], "likes": 2, "viewed": 235, "published": 3, "date": "1639675108", "time_retrieved": "2024-07-30T18:41:43.104028", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 thc(float a, vec3 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat h21 (float a, float b, float sc) {\n    a = mod(a, sc); b = mod(b, sc);\n    return fract(sin(dot(vec2(a, b), vec2(12.9898, 78.233)))*43758.5453123);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 pnt(vec2 ipos, float sc) {\n    float h = h21(ipos.x, ipos.y, sc);\n    float t = iTime + 10. * h;\n    float k = 1.5 +  h;\n    return 0.4 * vec2(thc(4. * (1.-h), 100. + k * t), \n                      ths(4. * h, 100. + (1.-k) * t));\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b * cos(6.28318*(c*t+d) );\n}\n\n// idk what to call this\nvec2 func(float t) {\n    return vec2(.5 + .5 * cos(t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/ iResolution.y;\n    vec2 ouv = uv;\n    vec2 ms = (iMouse.xy - 0.5 * iResolution.xy)/ iResolution.y;\n    \n    float ax = abs(uv.x); float ay = abs(uv.y);\n    vec2 uv2 = uv + 1. + 1. * cos( \n    20. * mix(ax, ay, 0.5 + 0.5 * cos(ax / (1. + ay) * 8. - iTime)) \n    / (1. + mix(ay, ax, 0.5 + 0.5 * sin(ay / (1. + ax) * 8. + iTime)) )   \n    - iTime);\n    \n    \n   \n   uv = mix(uv, uv2, 0.15 + 0. * cos(iTime));\n   uv += 1. + thc(40000., 10. * length(uv) + atan(uv.y, uv.x) - iTime);\n    float a = atan(uv.y, uv.x);\n    float r = length(uv); \n    //uv = vec2(4. * a/pi, log(r) - 0.1 * iTime);\n    \n    float c = 4.;\n    // cant scale dynamically because sc used in h21 (bad)\n    float sc = 20.;// + 1./length(ouv-ms);\n    vec2 fpos = fract(sc * uv) - 0.;\n    vec2 ipos = floor(sc * uv) + 0.5;    \n   // vec2 fpos = fract(sc * (uv - ms)) - 0.;\n   // vec2 ipos = floor(sc * (uv - ms)) + 0.5;    \n    \n    //fpos = mix(fpos, fpos * fpos * (3. - 2. * fpos), 0.5 * thc(4., iTime));\n    \n    // Generate values for each corner of uv (sloppy)\n    float l  = h21(ipos.x + 1., ipos.y,      c * sc);\n    float t  = h21(ipos.x,      ipos.y + 1., c * sc);\n    float tl = h21(ipos.x + 1., ipos.y + 1., c * sc);\n    float id = h21(ipos.x,      ipos.y,      c * sc);\n\n    // Smooth fpos completely, so v noise looks better\n    vec2 sfpos = fpos * fpos * (3. - 2. * fpos);\n\n    // Smooth the grid uvs so different uvs meet continuously on the edges\n    //fpos = mix(fpos, fpos * fpos * (3. - 2. * fpos), 0.5 * thc(4., iTime));\n    \n    // Box lerp between the corner values to get a radius value for this pixel\n    float v = l  * sfpos.x      * (1.-sfpos.y)\n     \t    + t  * (1.-sfpos.x) * sfpos.y\n     \t    + tl * sfpos.x      * sfpos.y\n      \t    + id * (1.-sfpos.x) * (1.-sfpos.y);\n    \n    vec2 p = vec2(0.5 * thc(-0.5 + h21(ipos), 10. * h21(ipos) + iTime), \n                  0.3 * ths(-0.5 + h21(ipos),  10. * h21(ipos) + iTime));\n    float d = (-v + 1. * thc(4., 50. * r + v + 0.6 * iTime)) * length(ouv) + length(ouv - p);\n    float k = 0.2;\n    float s = smoothstep(-k, k,-d);\n\n    vec3 col;// = vec3(s-v);\n    col = s/ v * pal(s + 0.1 *  iTime, vec3(1.), vec3(1.), vec3(1.), h21(ipos) * 4. * (v-s) + 0.5 * vec3(0.,0.33,0.66));\n    //col *= 0.4;\n   fragColor = vec4(col, 1.); //vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3XWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 191, 191, 232], [234, 234, 254, 254, 329], [331, 331, 371, 371, 486], [488, 488, 540, 540, 659], [661, 661, 692, 692, 898], [900, 900, 968, 968, 1012], [1014, 1039, 1059, 1059, 1096], [1098, 1098, 1155, 1155, 3481]], "test": "untested"}
{"id": "slcXWS", "name": "The place of the core", "author": "yasuo", "description": "The place of the core", "tags": ["core"], "likes": 9, "viewed": 240, "published": 3, "date": "1639672959", "time_retrieved": "2024-07-30T18:41:43.878956", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 64\n#define MAX_DIST 64.\n#define SURF_DIST .0001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define ZERO (min(iFrame,0))\n\n\n// by Dave_Hoskins\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat B3D(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat simplePyramid(vec3 p, float h, vec3 s){\n    vec3 prevP = p;\n    p.y*=h;\n    float d = B3D(p,s);\n    float a = radians(45.);\n    p.xz = abs(p.xz);\n    d = max(dot(p.xy,vec2(cos(a),sin(a))),d);\n    d = max(dot(p.yz,vec2(cos(a),sin(a))),d);\n    return d;\n}\n\nfloat polygonObject(vec3 p){\n    vec3 prevP = p;\n    \n    float d = B3D(p,vec3(0.2,0.2,0.2));\n    float a = radians(45.0);\n    p = abs(p);\n    p-=vec3(-0.1,0.5,0.0);\n    d = max(dot(p,vec3(cos(a),sin(a),cos(a))),d);\n    \n    p = prevP;\n    p.y=abs(p.y);\n    p.xz*=Rot(radians(45.0));\n    p.y-=0.56;\n    float d2 = simplePyramid(p,0.39,vec3(0.14));\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p.x-=0.56;\n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(45.0));\n    d2 = simplePyramid(p,0.39,vec3(0.14));\n    d = min(d,d2);\n    \n    p = prevP;\n    p.z = abs(p.z);\n    p.z-=0.56;\n    p.yz*=Rot(radians(-90.0));\n    p.xz*=Rot(radians(45.0));\n    d2 = simplePyramid(p,0.39,vec3(0.14));\n    d = min(d,d2*0.6);    \n    return d;\n}\n\nfloat particleObject(vec3 p, float h, vec3 s){\n    p.y*=h;\n    p.y = abs(p.y)-0.03;\n    float d = simplePyramid(p,1.0,s);\n    return d;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    p.xy*=Rot(radians(20.*iTime*3.0));\n    p.yz*=Rot(radians(30.*iTime*2.0));\n    float d = polygonObject(p);\n  \n    p = prevP;\n    p.xy*=Rot(radians(-30.*iTime*1.5));\n    p.yz*=Rot(radians(-20.*iTime*2.0));\n    p = abs(p)-0.4;\n    float d2 = particleObject(p,0.9,vec3(0.07));\n    d = min(d,d2);\n    p = abs(p)-0.4;\n    d2 = particleObject(p,0.9,vec3(0.07));\n    d = min(d,d2);\n    \n\n    p = prevP;\n    p.y-=iTime*0.5;\n    p = mod(p,0.8)-0.4;\n    p = abs(p)-0.4;\n    float d3 = B3D(p,vec3(0.1,0.3,0.5));\n    p = abs(p)-0.4;\n    d3 = min(B3D(p,vec3(0.7,0.1,0.3)),d3);\n    p = abs(p)-0.4;\n    d3 = min(B3D(p,vec3(0.3,0.1,0.6)),d3);\n    \n    p = prevP;\n    d2 = -length(p) + 3.8;\n    d2 = max(d3,d2);\n    d = min(d,d2);\n    \n    vec2 model = vec2(d,0);\n\n    return model;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<3; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 reflectMaterial(vec3 p, vec3 rd, vec3 n) {\n    vec3 r = reflect(p+rd*1.6,n);\n    vec3 col = r;\n    \n    return col;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n\n    return diffuseMaterial(n,rd,p,reflectMaterial(n,rd,p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy -.3;\n    \n    float t = iTime*2.0;\n    t += 0.1*hash12(uv);\n    \n    vec3 ro = vec3(0, 0, 1.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    if(iMouse.z>0.){\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.xz *= Rot(radians(-15.0+t*20.0));\n    }\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 0.5);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        col *= exp( -0.038*d.x*d.x*d.x );//fog\n    } else {\n        col = vec3(0.0);\n    }\n    \n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcXWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[232, 251, 273, 273, 393], [395, 395, 422, 422, 476], [478, 478, 523, 523, 737], [739, 739, 767, 767, 1484], [1486, 1486, 1532, 1532, 1623], [1625, 1625, 1647, 1647, 2443], [2445, 2445, 2503, 2503, 2770], [2772, 2772, 2796, 2796, 2997], [2999, 2999, 3041, 3041, 3236], [3238, 3279, 3328, 3328, 3622], [3624, 3624, 3681, 3681, 4300], [4302, 4302, 4349, 4349, 4424], [4426, 4426, 4485, 4485, 4548], [4550, 4550, 4607, 4607, 5604]], "test": "untested"}
{"id": "flcSWS", "name": "Cubic Blender V2", "author": "byt3_m3chanic", "description": "Just playing while waiting for Blender to render out trying to reproduce what I rendered out. Of course its marching so the materials are not as good as blender - need to up my PBR game.\n    \nhttps://twitter.com/byt3m3chanic/status/1471029268994043907", "tags": ["cubeblendercopy2"], "likes": 19, "viewed": 424, "published": 3, "date": "1639669536", "time_retrieved": "2024-07-30T18:41:44.722700", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Cubic Blender V2\n    12/15/21 - byt3_m3chanic\n    Just playing while waiting for Blender to render out.\n \n    https://twitter.com/byt3m3chanic/status/1471029268994043907\n    \n    also tidbits from @blackle for domain rep/refraction.\n\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n\n#define PI          3.14159265358\n#define PI2         6.28318530718\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234); }\nfloat lsp(float b,float e,float t) { return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t=t-1.)*t*t+1.; }\n\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nvec2 edge(vec2 p) {\n    vec2 p2 = abs(p);\n    return (p2.x > p2.y) ? vec2((p.x<0.)?-1.:1.,0.) : vec2(0.,(p.y<0.)?-1.:1.);\n}\n\n// globals & const\nvec3 hit,hitPoint;\nvec4 gtile,stile;\nfloat glow=0.,ftime=0.,ga1,ga2,ga3,ga4;\nmat2 rxt;\n\nconst float size = .85;\nconst float hlf = size/2.;\nconst vec3 bs = vec3(hlf*.96);\n\nconst float zoom = 5.;\nconst float cp = 3.;\n\nvec2 map(vec3 p, float sg){\n    vec2 res = vec2(1e5,0.);\n\n    float zp = p.z+(ga4*16.);\n    float zd = floor((zp+8.)/16.);\n    p.z+=(ga1*16.);\n    p.z=mod(p.z+8.,16.)-8.;\n    \n    vec3 q = p;\n    //domain rep by @blackle https://www.shadertoy.com/view/3lcBD2\n    vec2 center = floor(q.xz) + .5;\n    vec2 nghbor = center + edge(q.xz - center);\n    \n    float dist = mod(zd,3.)==0.?center.x+center.y:mod(zd,2.)==0.?center.x:length(center);\n    float ht = 1.5*sin((dist*.55)+ftime);\n    ht=clamp(ht,0.,3.);\n    float oyf = .25;\n    \n    float me   = box(p - vec3(center.x,ht-oyf,center.y),vec3(bs*.35));\n    float next = box(p - vec3(nghbor.x,ht-oyf,nghbor.y),vec3(bs.x*.35,bs.y*2.,bs.z*.35));\n\n    float bx = (abs(q.x)>cp||abs(q.z)>cp) ? next : min(me, next);\n    if(sg>0.&&ht>.5) glow += mix(0.,.0001/(.001+bx*bx),clamp(ht-.55,0.,1.)*1.5);\n    if(bx<res.x) {\n       res = vec2(bx,3.);\n       gtile.xyz = vec3(center,zd);\n       gtile.w=3.;\n       hit = p;\n    } \n\n    float distortion = 28.;\n    float dsn = sin(distortion * p.x*.7) * sin(distortion * p.y-oyf) * sin(distortion * p.z*.7) * 0.01;\n    float dst = .01;\n    float blx = box(p-vec3(center.x,-oyf,center.y),vec3(bs.x*.65,bs.y*.65,bs.z*.65));\n    next = box(p-vec3(nghbor.x,-oyf,nghbor.y),vec3(bs.x*.65,bs.y*.65,bs.z*.65));\n    blx = max(blx,-box(p-vec3(center.x,-oyf,center.y),vec3(bs.x*.45,bs.y*.85,bs.z*.45)));\n    blx-=dsn;\n\n    float ice = (abs(q.x)>cp||abs(q.z)>cp) ? next : min(blx, next);\n    if(ice<res.x) {\n       res = vec2(ice,5.);\n       gtile.xyz = vec3(center,dist);\n       hit = p;\n    } \n    \n    float flr = box(p-vec3(center.x,-.5-oyf,center.y),vec3(bs.x,.075,bs.z));\n    next = box(p-vec3(nghbor.x,-.5-oyf,nghbor.y),vec3(bs.x,5.,bs.z));\n    \n    float gnd = (abs(q.x)>cp||abs(q.z)>cp) ? next : min(flr, next);\n    if(gnd<res.x) {\n       res = vec2(gnd,7.);\n       gtile.xyz = vec3(center,dist);\n       hit = p;\n    } \n\n    return res;\n}\n\n// normal\nvec3 normal(vec3 p, float t, float md) {\n    float e = md*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( \n        h.xyy*map( p + h.xyy*e,0. ).x + \n        h.yyx*map( p + h.yyx*e,0. ).x + \n        h.yxy*map( p + h.yxy*e,0. ).x + \n        h.xxx*map( p + h.xxx*e,0. ).x );\n}\n\nfloat ptn_d(vec3 p){\n    vec2 uv = p.xz;\n    uv*=rot(.785);\n    vec2 ff = floor(uv);\n    float f = clamp(mod(ff.x,2.)*1.-.5,0.,1.);\n    float h = mix(1.,.0,f);\n    return h;\n}\nvec3 hue(float t) { \n    vec3 d = vec3(0.220,0.576,0.961);\n    return .45 + .375*cos(PI2*t*(vec3(.985,.98,.95)*d)); \n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n, inout vec3 ref) {\n    n = normal(p,d,.1);\n\n    vec3 l = normalize(vec3(-15.,25,15)-p);\n    float diff = clamp(dot(n,l),.1,.8);\n    float spec = pow(max(dot(reflect(l, n), rd ), .1), 32.)*.75;\n\n    vec3 h = vec3(.01);\n\n    if(m==1.) {h=vec3(.5);ref=h;}\n\n    if(m==3.) {h = hue(stile.z*1.5);ref=h*.5;}\n    \n    if(m==5.) {h = vec3(0.718,0.843,0.816);ref=vec3(.65);}\n\n    if(m==7.) {h=vec3(.01);ref=vec3(.2);}\n    \n    h*=diff+spec; \n    return h;\n}\n\nvec3 renderAll( vec2 PX )\n{\n\n    ftime = (T*2.35);\n    float tmod = mod(T,10.);\n    float t3 = lsp(5.0, 10.0, tmod);\n    ga1 = eoc(t3);\n    ga1 = ga1*ga1*ga1;\n\n    ga4 = (t3)+floor(T*.1);\n    \n    vec2 uv = (2.*PX.xy-R.xy)/max(R.x,R.y);\n    vec3 C=vec3(.001);\n\n    vec3 ro = vec3(uv*zoom,-zoom-10.);\n    vec3 rd = vec3(0,0,1.);\n\n    float x = M.z > 0. ? (M.x/R.x * 2. - 1.) * PI : -.48;\n\n    mat2 rx =rot(.62);\n    mat2 ry =rot(x);\n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    float atten=1.,k=1.,alpha=1.;\n    vec3 p = ro + rd * .1;\n    vec3 fill=vec3(1), ref=vec3(0);\n    \n    float bt =2.,ct =6.;\n\n    float fA = 0.;\n    for(int i=0;i<100;i++)\n    {\n        vec2 ray = map(p,bt>1.?1.:0.);\n        float d = ray.x;\n        float m = ray.y;\n\n        p += rd * d *k;\n\n        if (d*d < 1e-6) {\n            hitPoint=hit;\n            stile=gtile;\n            \n            alpha *=1e-1;\n            \n            vec3 h=vec3(0);\n            vec3 n=vec3(0);\n            \n            C+=shade(p,rd,d,ray.y,n,ref)*fill;\n            if(bt<1.&&ct<1.)break;\n\n            p += rd*.015;\n            k = sign(map(p,0.).x);\n\n            if(m!=5.&&m!=3.){\n                fill *= ref;\n                rd=reflect(-rd,n);\n                p+=n*.02;\n                ct--;\n            }else if (bt>0.){\n                fill *= ref;\n                rd=refract(rd,n,.79);\n                bt--;\n            }\n        }  \n        if(distance(p,rd)>25.) { break; }\n    }\n\n    float mask = smoothstep(.1,.6,length(uv)-.4);\n    vec3 clr = mix(vec3(0.282,0.349,0.557),vec3(0.012,0.086,0.310)*.05 ,mask );\n    C+=clamp(max(glow,-mask),0.,.95);\n    uv*=rot(.785);\n    vec2 ff = floor(uv*45.);\n    float f = clamp(mod(ff.x,1.5)*1.-.15,0.,1.);\n    clr = mix(clr,clr*.7,f);\n    C = mix(C,clr,alpha);\n  \n    return C;\n}\n\n// baby AA - make 2 for some kind of smoothness\n#define AA 1\nvoid mainImage( out vec4 O, in vec2 F ){   \n    \n    vec3 C = renderAll(F);\n    #if AA>1\n        C +=renderAll(F+vec2(.5,.5));\n        C /= 2.;    \n    #endif\n    C = clamp(C,vec3(0),vec3(1));\n    C = pow(C, vec3(.4545));  \n    O = vec4(C,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcSWS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[517, 517, 538, 538, 594], [595, 595, 631, 631, 666], [667, 667, 686, 686, 711], [713, 713, 738, 738, 823], [825, 825, 844, 844, 948], [1185, 1185, 1212, 1212, 3100], [3102, 3112, 3152, 3152, 3394], [3396, 3396, 3416, 3416, 3571], [3572, 3572, 3591, 3591, 3690], [3692, 3692, 3769, 3769, 4198], [4200, 4200, 4227, 4227, 5995], [6058, 6058, 6098, 6098, 6303]], "test": "untested"}
{"id": "fl3SDS", "name": "Colorful Cube Space", "author": "IWBTShyGuy", "description": "The cubes appear and disappear.", "tags": ["3d"], "likes": 5, "viewed": 262, "published": 3, "date": "1639654138", "time_retrieved": "2024-07-30T18:41:45.572427", "image_code": "// Copyright  2021 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n#if HW_PERFORMANCE!=0\n// If defined, activate anti-aliasing, level: 2 or 3\n#define AA 2\n#endif\n\nconst float AXIS_VELO = 1.0 / PI;\nconst float ROTATE_VELO = 1.0;\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// Random unit vector\n// https://qiita.com/aa_debdeb/items/e416ae8a018692fc07eb\nvec3 randomAxis(vec2 gen) {\n    vec2 uv = hash22(gen);\n    float z = 2.0 * uv.x - 1.0;\n    float t = 2.0 * PI * uv.y;\n    return vec3(\n        sqrt(1.0 - z * z) * cos(t),\n        sqrt(1.0 - z * z) * sin(t),\n        z\n    );\n}\n\n// cellwise SDF\nfloat cellDist(in vec3 p, in vec3 q, in float t) {\n    vec3 fq = floor(q);\n    float gen = fq.x + fq.y * sqrt(2.0) + fq.z * sqrt(5.0);\n    float eGen0 = hash11(gen + 0.8649 + floor(t / 2.0));\n    float eGen1 = hash11(gen + 1.8649 + floor(t / 2.0));\n    float eGen2 = hash11(gen + 2.8649 + floor(t / 2.0));\n    float eGen3 = hash11(gen + 3.8649 + floor(t / 2.0));\n    float eGen4 = hash11(gen + 4.8649 + floor(t / 2.0));\n    bool prevExists = (eGen0 + eGen1 + eGen2) / 3.0 < 0.75;\n    bool corrExists = (eGen1 + eGen2 + eGen3) / 3.0 < 0.75;\n    bool nextExists = (eGen2 + eGen3 + eGen4) / 3.0 < 0.75;\n    if (corrExists) return 0.5;\n    vec3 disp = 0.1 * hash33(fq);\n    p = fract(q) + p - q - 0.5 - disp;\n    vec3 axis = randomAxis(fq.xy);\n    float a = 1.0;\n    float k = 5.0;\n    float m = 1.2;\n    float s = fract(t * 0.5);\n    float tmp = m - m * k * k * (s - 1.0 / k) * (s - 1.0 / k);\n    tmp = prevExists ? tmp : a;\n    a = s < 1.0 / k ? tmp : max(tmp, a);\n    tmp = m - m * k * k * (s - (k - 1.0) / k) * (s - (k - 1.0) / k);\n    tmp = nextExists ? tmp : a;\n    a = s > (k - 1.0) / k ? tmp : max(tmp, a);\n    p = rot(axis, ROTATE_VELO * t) * p;\n    return sdRoundBox(p, vec3(0.15) * a, 0.025 * a);\n}\n\n// SDF\nfloat sDist(in vec3 p, in vec3 dir, in float t) {\n    float dist = cellDist(p, p, t);\n    if (floor(p + dist * dir) != floor(p)) {\n        dist = min(dist, cellDist(p, p + dist * dir, t));\n    }\n    return dist;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 p, in vec3 dir, in float t) {\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize(vec3(\n        cellDist(p+h.xyy, p, t) - cellDist(p-h.xyy, p, t),\n        cellDist(p+h.yxy, p, t) - cellDist(p-h.yxy, p, t),\n        cellDist(p+h.yyx, p, t) - cellDist(p-h.yyx, p, t)\n    ));\n}\n\nconst float FAR = 12.0;\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 theta = vec2(0.15, 0.25) * iTime;\n    theta.y = sin(theta.y) * 0.7;\n    Camera camera = newCamera(\n        vec3(sin(iTime * 0.1) * 0.1, -iTime * 0.5, cos(iTime * 0.1) * 0.1),\n        vec3(cos(theta.x) * cos(theta.y), sin(theta.y), sin(theta.x) * cos(theta.y)),\n        //vec3(0),\n        //vec3(0, 0, 1),\n        vec3(0, 1, 0),\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, fragCoord / iResolution.xy);\n\n    vec3 p = ray.origin;\n    for (int _i = 0; _i < 100; _i++) {\n        float dist = sDist(p, ray.direction, iTime);\n        float rDist2 = dot(p - ray.origin, p - ray.origin);\n        if (dist < 0.00001 || rDist2 > 144.0) break;\n        p += dist * ray.direction;\n    }\n\n    vec3 col = vec3(0.9, 0.8, 0.9);\n    float dist = length(p - ray.origin);\n    if (dist < FAR) {\n        vec3 normal = calcNormal(p, ray.direction, iTime);\n        float c = -dot(ray.direction, normal);\n        c = clamp(c, 0.0, 1.0);\n        float k = smoothstep(0.0, 1.0, dist / FAR);\n        k *= k;\n        vec3 mat = hash33(floor(p) + 1.23);\n        col = (1.0 - k) * c * mat + k * col;\n    }\n\n    fragColor = vec4(pow(col, vec3(0.4545)), 1);\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    \n// smart anti-aliasing\n// reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\n// If defined, visualize anti-aliased pixels.\n//#define VISUALIZE_AA\n#ifdef AA\n    if (fwidth(length(O.xyz)) > 0.2) {\n        O.xyz = pow(O.xyz, vec3(2.2));\n        vec4 o;\n#if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              mainImage0(o,U + (vec2(k % 2, k / 2) - 0.5) / 1.5);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 5.0;\n#elif (AA == 3)\n        for (int k = 0; k < 9; k += k == 3 ? 2 : 1 ) {\n              mainImage0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 9.0;\n#endif\n#ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n#endif\n        O.xyz = pow(O.xyz, vec3(0.4545));\n    }\n#endif\n    O.w = 1.0;\n}\n", "image_inputs": [], "common_code": "const float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nCamera newCamera(vec3 position, vec3 direction, vec3 up_direction, float fov, float aspect) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float h = tan(camera.fov * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\n// Rodrigues' rotation formula\nmat3 rot(vec3 axis, float angle) {\n    return mat3(\n        axis[0] * axis[0] * (1.0 - cos(angle)) + cos(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) + axis[2] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) - axis[1] * sin(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) - axis[2] * sin(angle),\n        axis[1] * axis[1] * (1.0 - cos(angle)) + cos(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) + axis[0] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) + axis[1] * sin(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) - axis[0] * sin(angle),\n        axis[2] * axis[2] * (1.0 - cos(angle)) + cos(angle)\n    );\n}\n\n\n/* Hash without Sine https://www.shadertoy.com/view/4djSRW */\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3SDS.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[240, 289, 332, 332, 423], [425, 505, 532, 532, 730], [732, 748, 798, 798, 1953], [1955, 1962, 2011, 2011, 2175], [2177, 2223, 2276, 2276, 2551], [2577, 2577, 2633, 2633, 3819]], "test": "untested"}
{"id": "ftcSWS", "name": "Mausolea", "author": "dr2", "description": "Mausolea = plural of mausoleum (mouseable)", "tags": ["building", "lightcone", "mausoleum"], "likes": 16, "viewed": 377, "published": 3, "date": "1639648981", "time_retrieved": "2024-07-30T18:41:46.516902", "image_code": "// \"Mausolea\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrConCylDf (vec3 p, vec2 cs, float r, float h);\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h);\nfloat Maxv2 (vec2 p);\nfloat Minv2 (vec2 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 qHit, sunDir, lmpPos[3];\nvec2 gId, nSub, rfCs, lmpCs[3];\nfloat dstFar, tCur, bWid, bHt, trHt, gSize, lmpRot[3], lmpAz;\nint idObj;\nbool isDark;\nconst int idFlr = 1, idRf = 2, idWall = 3, idCol = 4, idLit = 5, idPlat = 6, idRoad = 7, \n   idTree = 8, idMvLmp = 9;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid SetBldParm ()\n{\n  vec2 h;\n  h = Hashv2v2 (73.11 * gId + 0.1);\n  bWid = (0.15 + 0.1 * h.x) * gSize;\n  bHt = bWid * (0.75 + 0.25 * h.y);\n  if (h.y < 0.05) bHt = 0.;\n  trHt = 0.5 + 0.5 * bHt / (0.25 * gSize);\n  rfCs = sin (0.1 * (1. + bHt) * pi + vec2 (0.5 * pi, 0.));\n  h = Hashv2v2 (13.1 * gId + 0.1);\n  nSub = 1. + step (0.33, h) + 2. * step (0.67, h);\n}\n\nfloat GObjDf (vec3 p)\n{\n  vec3 q, ss;\n  vec2 bw;\n  float dMin, d, db, w, h;\n  dMin = dstFar;\n  q = p;\n  q.xz -= gSize * (gId + 0.5);\n  q.y -= 0.01;\n  d = PrRoundBoxDf (q, vec3 (vec2 (0.4075 * gSize), 0.01).xzy - 0.002 * gSize, 0.002 * gSize);\n  DMINQ (idPlat);\n  d = trHt * PrConCapsDf (vec3 ((abs (q.xz) - 0.39 * gSize) / trHt, q.y / trHt - 0.11),\n     sin (0.06 * pi + vec2 (0.5 * pi, 0.)), 0.03, 0.06);\n  DMINQ (idTree);\n  if (bHt > 0.) {\n    h = 2. * bHt / (nSub.x + nSub.y);\n    w = bWid / max (nSub.x, nSub.y);\n    q.y -= h + 0.005;\n    q.xz = mix (q.xz, abs (q.xz) - 0.2 * gSize, step (1.5, nSub));\n    q.xz = mix (q.xz, abs (q.xz) - 0.1 * gSize, step (2.5, nSub));\n    bw = bWid / nSub;\n    db = PrRoundBox2Df (q.xz, bw + 0.25 * w - 0.001 * w, 0.001 * w);\n    ss = vec3 (abs (q.xz) - 1.25 * bw, q.y - 1.05 * h).xzy;\n    d = abs (q.y + 0.95 * h) - 0.04 * h;\n    d = SmoothMax (d, db, 0.005);\n    DMINQ (idFlr);\n    d = (nSub.x != nSub.y) ? max (- ss.y - 0.1 * h,\n       dot (((nSub.x > nSub.y) ? ss.yx : ss.yz), rfCs)) : max (max (- ss.y - 0.1 * h,\n       dot (ss.yx, rfCs)), max (- ss.y - 0.1 * h, dot (ss.yz, rfCs)));\n    d = SmoothMax (d, db, 0.005);\n    DMINQ (idRf);\n    d = max (PrRoundBox2Df (q.xz, bw - 0.25 * w - 0.001 * w, 0.001 * w), abs (q.y) - h);\n    DMINQ (idWall);\n    d = min (PrCapsDf (vec3 (q.x, q.y - 0.6 * h, abs (q.z) - bw.y + 0.22 * w).yzx, 0.03 * w, 0.2 * w),\n       PrCapsDf (vec3 (abs (q.x) - bw.x + 0.22 * w, q.y - 0.6 * h, q.z), 0.03 * w, 0.2 * w));\n    DMINQ (idLit);\n    q.xz = mod (q.xz + 0.25 * w, 0.5 * w) - 0.25 * w;\n    d = max (PrCylDf (q.xzy, 0.1 * w, h), db);\n    DMINQ (idCol);\n  }\n  q = p;\n  d = q.y;\n  DMINQ (idRoad);\n  return dMin;\n}\n\nfloat GObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  vec2 gIdP;\n  float dHit, d, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  rdi.xz = 1. / rd.xz;\n  gIdP = vec2 (-999.);\n  eps = 0.001;\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 240; j ++) {\n    p = ro + dHit * rd;\n    gId = floor (p.xz / gSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetBldParm ();\n    }\n    d = GObjDf (p);\n    dHit += min (d, eps + max (0., Minv2 ((gSize * (gId + step (0., rd.xz)) - p.xz) * rdi.xz)));\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 GObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat GObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  int idObjT;\n  idObjT = idObj;\n  sh = 1.;\n  gIdP = vec2 (-999.);\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    p = ro + d * rd;\n    gId = floor (p.xz / gSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetBldParm ();\n    }\n    h = GObjDf (p);\n    sh = min (sh, smoothstep (0., 0.2 * d, h));\n    d += max (h, 0.01);\n    if (h < 0.001 || d > dMax) break;\n  }\n  idObj = idObjT;\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p - lmpPos[0];\n  q.y -= 0.07 - lmpPos[0].y;\n  q.yz = Rot2D (q.yz, -0.05 * pi);\n  q.xz = Rot2D (q.xz, lmpRot[0] + lmpAz);\n  q.z = - q.z;\n  d = PrConCylDf (q, sin (0.05 * pi + vec2 (0.5 * pi, 0.)), 0.01, 0.01);\n  DMINQ (idMvLmp);\n  q = (p - lmpPos[1]).xzy;\n  d = PrConCylDf (q, lmpCs[1], 0.03, 0.02);\n  DMINQ (idMvLmp);\n  q = (p - lmpPos[2]).xzy;\n  d = PrConCylDf (q, lmpCs[2], 0.03, 0.02);\n  DMINQ (idMvLmp);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0002 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  int idObjT;\n  idObjT = idObj;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (h, 0.01);\n    if (h < 0.001 || d > dMax) break;\n  }\n  idObj = idObjT;\n  return 0.7 + 0.3 * sh;\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = (p - lmpPos[1]).xzy;\n  d = PrConCylDf (q, lmpCs[1], 0.03, 1.5);\n  DMINQ (idMvLmp);\n  q = (p - lmpPos[2]).xzy;\n  d = PrConCylDf (q, lmpCs[2], 0.03, 1.5);\n  DMINQ (idMvLmp);\n  return dMin;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShGrid (vec2 p, vec2 g, int stag)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (stag > 0 && 2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.02, 0.03, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.07 * pi * smoothstep (0.4, 0.47, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec4 ObjCol (vec3 ro, vec3 rd, inout vec3 vn)\n{\n  vec4 col4, cBld;\n  vec3 rg;\n  vec2 h;\n  bool fxz;\n  h = Hashv2v2 (39.1 * gId + 0.1);\n  cBld = vec4 (HsvToRgb (vec3 (0.7 * h.x, 0.2, 0.6 + 0.2 * h.y)), 0.1);\n  if (idObj == idFlr) {\n    col4 = cBld;\n  } else if (idObj == idRf) {\n    col4 = cBld;\n  } else if (idObj == idWall) {\n    fxz = (abs (vn.x) > 0.99);\n    rg = ShGrid ((fxz ? qHit.zy : qHit.xy) * 32., vec2 (1., 1.5), 1);\n    col4 = cBld * rg.y;\n    rg.xz *= sign (fxz ? vn.x : vn.z);\n    if (fxz) {\n      if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n      else vn.xz = Rot2D (vn.xz, rg.x);\n    } else {\n      if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n      else vn.zx = Rot2D (vn.zx, rg.x);\n    }\n  } else if (idObj == idCol) {\n    col4 = cBld;;\n  } else if (idObj == idPlat) {\n    rg = ShGrid (32. * ro.xz, vec2 (1.), 0);\n    col4 = vec4 (0.5, 0.5, 0.5, 0.1) * rg.y;\n    if (vn.y > 0.99) {\n      if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);\n      else vn.yx = Rot2D (vn.yx, rg.x);\n    }\n  } else if (idObj == idRoad) {\n    rg = ShGrid (16. * ro.xz, vec2 (1.), 0);\n    col4 = vec4 (0.3, 0.3, 0.35, 0.) * rg.y;\n    if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);\n    else vn.yx = Rot2D (vn.yx, rg.x);\n  } else if (idObj == idTree) {\n    col4 = vec4 (0.1, 0.4, 0.1, 0.);\n  } else if (idObj == idLit) {\n    col4 = vec4 (1., 1., 0.7, -1.);\n  } else if (idObj == idMvLmp) {\n    col4 = (isDark && (qHit.z < -0.002 || qHit.z > -0.002 &&\n       abs (fract (8. * atan (qHit.y, - qHit.x) / (2. * pi) + 0.5) - 0.5) < 0.15)) ?\n       vec4 (0.7, 0.7, 0.5, -1.) : vec4 (0.8, 0.8, 0.3, 0.2);\n  }\n  return col4;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  skCol = (isDark ? 0.1 : 1.) * vec3 (0.4, 0.5, 0.8);\n  if (rd.y < 0.02 * Fbm1 (128. * mod (atan (rd.x, rd.z) / (2. * pi) + 0.625, 1.))) {\n    col = 0.9 * skCol;\n  } else {\n    q = 0.02 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    if (! isDark) {\n      sd = max (dot (rd, sunDir), 0.);\n      skCol = mix (skCol, vec3 (1., 1., 0.8), step (0.1, sd) *\n         0.2 * pow (sd, 128.) + 0.8 * pow (sd, 2048.));\n    } else clCol *= 0.3;\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roo, rdo, qHitG, ltPos, ltDir, ltAx;\n  vec2 vf;\n  float dstObjG, dstObj, dstTrObj, sh, a, ltDst, att;\n  int idObjG;\n  lmpCs[0] = sin (0.28 * pi + vec2 (0.5 * pi, 0.));\n  lmpCs[1] = sin (0.06 * pi + vec2 (0.5 * pi, 0.));\n  lmpCs[2] = sin (0.06 * pi + vec2 (0.5 * pi, 0.));\n  vf = vec2 (0.);\n  roo = ro;\n  rdo = rd;\n  dstObjG = GObjRay (ro, rd);\n  idObjG = idObj;\n  qHitG = qHit;\n  dstObj = isDark ? ObjRay (ro, rd) : dstFar;\n  if (dstObjG < min (dstObj, dstFar)) {\n    idObj = idObjG;\n    qHit = qHitG;\n    dstObj = dstObjG;\n  }\n  if (rd.y < 0. && min (dstObjG, dstObj) >= dstFar) {\n    dstObj = - ro.y / rd.y;\n    idObj = idRoad;\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = (idObj == idObjG) ? GObjNf (ro) : ObjNf (ro);\n    col4 = ObjCol (ro, rd, vn);\n    if (idObj == idFlr || idObj == idWall) {\n      vf = vec2 (128., 0.2);\n    } else if (idObj == idCol) {\n      a = mod (16. * (atan (qHit.z, - qHit.x) / (2. * pi)), 1.);\n      vn.xz = Rot2D (vn.xz, -0.15 * pi * sin (pi * a * a));\n      vf = vec2 (128., 0.2);\n    } else if (idObj == idPlat) {\n      vf = vec2 (64., 0.5);\n    } else if (idObj == idTree) {\n      vf = vec2 (256., 2.);\n    } else if (idObj == idRoad) {\n      vf = vec2 (32., 1.);\n    }\n    if (vf.x > 0.) vn = VaryNf (vf.x * qHit, vn, vf.y);\n    if (isDark) {\n      ltPos = lmpPos[0];\n      ltAx = vec3 (0., 0., -1.);\n      ltAx.yz = Rot2D (ltAx.yz, 0.12 * pi);\n      ltAx.xz = Rot2D (ltAx.xz, - lmpRot[0] - lmpAz);\n      ltDir = ltPos - ro;\n      ltDst = length (ltDir);\n      ltDir /= ltDst;\n    } else {\n      ltDst = dstFar;\n      ltDir = sunDir;\n    }\n    sh = GObjSShadow (ro + 0.01 * vn, ltDir, ltDst);\n    if (isDark) sh = min (sh, ObjSShadow (ro + 0.01 * vn, vec3 (0., 1., 0.), ltDst));\n    if (col4.a >= 0.) {\n      if (isDark) {\n        att = smoothstep (-0.05, 0.05, dot (ltAx, ltDir) - lmpCs[0].x) *\n           step (- dot (vn, ltDir), 0.) / (1. + 0.01 * ltDst * ltDst);\n        att = min (att, sh);\n        col = col4.rgb * (0.1 + 0.1 * max (vn.y, 0.) + 0.8 * att * max (dot (vn, ltDir), 0.)) +\n           col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n        for (int k = 1; k <= 2; k ++) {\n          ltDir = lmpPos[k] - ro;\n          ltDst = length (ltDir);\n          ltDir /= ltDst;\n          ltAx = vec3 (0., 1., 0.);\n          att = smoothstep (-0.1, 0.1, dot (ltAx, ltDir) - lmpCs[k].x) *\n             step (- dot (vn, ltDir), 0.) / (1. + 0.002 * ltDst * ltDst);\n          col += att * (col4.rgb * max (dot (vn, ltDir), 0.) +\n             col4.a * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.));\n        }           \n      } else {\n        col = col4.rgb * (0.2 + 0.1 * max (dot (vn.xz, - normalize (sunDir.xz)), 0.) +\n           0.8 * sh * max (dot (vn, sunDir), 0.)) +\n           col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n      }\n    } else col = col4.rgb * (0.6 - 0.4 * dot (vn, rd));\n    col = mix (col, SkyBgCol (roo, rd), smoothstep (0.5, 0.9, dstObj / dstFar));\n  } else col = SkyBgCol (ro, rd);\n  if (isDark) {\n    for (int k = 1; k <= 2; k ++) {\n      ro = roo;\n      rd = rdo;\n      dstTrObj = TrObjRay (ro, rd);\n      if (dstTrObj < min (dstObj, dstFar)) {\n        ro += dstTrObj * rd;\n        vn = TrObjNf (ro);\n        ltDst = length (lmpPos[k] - ro);\n        att = step (qHit.z, 0.) / (1. + 0.1 * ltDst * ltDst);\n        att *= max (- dot (vn, rd), 0.) * (1. - smoothstep (-0.2, -0.1, dstTrObj - min (dstObj, dstFar)));\n        if (att > 0.) col = mix (col, vec3 (1., 1., 0.8) * (1. + 16. * pow (Fbm2 (1024. *\n           vec2 (dot (qHit.yx, sin (atan (rd.z, - rd.x) + vec2 (0.5 * pi, 0.))),\n           qHit.z - 0.1 * tCur)), 16.)), 0.15 * att);\n      }\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{ \n  vec3 p;\n  float pLen, s, cCount;\n  pLen = 2.* gSize;\n  p.y = 0.;\n  s = mod (t, 11.);\n  if (s < 7.) p.xz = (s < 4.) ? vec2 (0., s) : vec2 (s - 4., 4.);\n  else p.xz = (s < 9.) ? vec2 (3., 11. - s) : vec2 (12. - s, 2.);\n  cCount = floor (t / 11.);\n  if (mod (cCount, 2.) == 0.) p.x *= -1.;\n  else p.x -= 1.;\n  p.z += 2. * cCount;\n  p.xz *= pLen ;\n  return p;\n}\n\nvoid FlyPR (float s, out vec3 p, out float az)\n{\n  vec3 fpF, fpB, vd;\n  float ds;\n  ds = 0.05;\n  fpF = TrackPath (s + ds);\n  fpB = TrackPath (s - ds);\n  vd = fpF - fpB;\n  p = 0.5 * (fpF + fpB);\n  az = 0.5 * pi - atan (vd.z, vd.x);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 flMat, vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv, mMid, ut, mSize, msw;\n  float spd, el, az, zmFac, asp, sr, tPos;\n  int vuId, regId;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 18000.) + 30. * floor (dateCur.w / 3600.);\n  asp = canvas.x / canvas.y;\n  mSize = (1./5.) * vec2 (asp, 1.);\n  mMid = vec2 (asp, 1.) * (1. - mSize.y) * vec2 (-1., -1.);\n  ut = abs (uv - mMid) - mSize;\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    msw = 2. * mPtr.xy - mMid / vec2 (asp, 1.);\n    if (Maxv2 (abs (msw)) < mSize.y) {\n      regId = 1;\n      msw /= 2. * mSize.y;\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  if (Maxv2 (ut) < 0.) {\n    uv = (uv - mMid) / mSize.y;\n    vuId = 1;\n  }\n  if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  isDark = (vuId == 0);\n  spd = 0.1;\n  tPos = spd * tCur;\n  gSize = 2.;\n  FlyPR (tPos + 0.1, lmpPos[0], lmpRot[0]);\n  FlyPR (tPos + 0.3, lmpPos[1], lmpRot[1]);\n  FlyPR (tPos - 0.3, lmpPos[2], lmpRot[2]);\n  lmpPos[0].y = 0.3;\n  lmpPos[1].y = 1.;\n  lmpPos[2].y = 1.;\n  FlyPR (tPos, ro, az);\n  ro.y = 0.2;\n  ro.xz += 0.001;\n  el = 0.;\n  lmpAz = 0.;\n  if (mPtr.z > 0.) {\n    lmpAz += 2. * pi * msw.x;\n    az += 2. * pi * msw.x;\n    el += 0.6 * pi * msw.y;\n  }\n  lmpAz = clamp (lmpAz, - 0.5 * pi, 0.5 * pi);\n  el = clamp (el, - 0.25 * pi, 0.25 * pi);\n  vuMat = StdVuMat (el - 0.03 * pi, az);\n  dstFar = 20.;\n  sunDir = normalize (vec3 (0.5, 1.5, -1.));\n  zmFac = 3.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (mPtr.z > 0. && Maxv2 (abs (uv)) < 0.03 && Minv2 (abs (uv)) < 0.005)\n     col = mix (col, vec3 (1., 1., 1.), 0.2);\n  if (Maxv2 (ut) < 0. && Minv2 (abs (ut)) * canvas.y < 2.) col = vec3 (0.5, 0.5, 0.1);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrConCylDf (vec3 p, vec2 cs, float r, float h)\n{\n  return max (dot (vec2 (length (p.xy) - r, p.z), cs), abs (p.z) - h);\n}\n\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h)\n{\n  vec2 b;\n  float d;\n  d = max (dot (vec2 (length (p.xy) - r, p.z), cs), abs (p.z) - h);\n  h /= cs.x * cs.x;\n  r /= cs.x;\n  b = vec2 (r, h);\n  b *= cs.y;\n  p.z += b.x;\n  return min (d, min (length (p - vec3 (0., 0., h)) - r + b.y,\n     length (p - vec3 (0., 0., - h)) - r  - b.y));\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) -\n     1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcSWS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1234, 1234, 1254, 1254, 1593], [1595, 1595, 1618, 1618, 3277], [3279, 3279, 3313, 3313, 3892], [3894, 3894, 3916, 3916, 4172], [4174, 4174, 4224, 4224, 4684], [4686, 4686, 4708, 4708, 5183], [5185, 5185, 5218, 5218, 5466], [5468, 5468, 5489, 5489, 5744], [5746, 5746, 5795, 5795, 6098], [6100, 6100, 6124, 6124, 6363], [6365, 6365, 6400, 6400, 6584], [6586, 6586, 6609, 6609, 6866], [6868, 6868, 6908, 6908, 7282], [7284, 7284, 7331, 7331, 8888], [8890, 8890, 8924, 8924, 9770], [9772, 9772, 9807, 9807, 13576], [13578, 13578, 13604, 13604, 13965], [13967, 13967, 14015, 14015, 14199], [14201, 14201, 14257, 14257, 16594], [16596, 16596, 16642, 16642, 16689], [16691, 16691, 16738, 16738, 16785], [16787, 16787, 16829, 16829, 16880], [16882, 16882, 16925, 16925, 16989], [16991, 16991, 17045, 17045, 17118], [17120, 17120, 17175, 17175, 17459], [17461, 17461, 17483, 17483, 17510], [17512, 17512, 17534, 17534, 17561], [17563, 17563, 17608, 17608, 17700], [17702, 17702, 17747, 17747, 17785], [17787, 17787, 17844, 17844, 17927], [17929, 17929, 17965, 17965, 18171], [18173, 18173, 18203, 18203, 18316], [18318, 18318, 18342, 18342, 18464], [18498, 18498, 18522, 18522, 18582], [18584, 18584, 18608, 18608, 18661], [18663, 18663, 18687, 18687, 18799], [18801, 18801, 18826, 18826, 18972], [18974, 18974, 18999, 18999, 19185], [19187, 19187, 19209, 19209, 19363], [19365, 19365, 19386, 19386, 19541], [19543, 19543, 19572, 19572, 19784], [19786, 19786, 19825, 19825, 20077]], "test": "untested"}
{"id": "sl3Szf", "name": "Kaleidoscopic dream", "author": "NLIBS", "description": "Inspired by some of gaz's recent fractals", "tags": ["fractal", "volumetric", "glow"], "likes": 8, "viewed": 322, "published": 3, "date": "1639648745", "time_retrieved": "2024-07-30T18:41:47.286844", "image_code": "#define r(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define T (iTime+step(40.,iTime)*11.)\n\nvoid mainImage( out vec4 O, vec2 U ) {\n    vec3 R = iResolution,                          //Setup camera\n         ro = vec3(0,0,-2),                        //\n         rd = normalize(vec3((2.*U-R.xy)/R.x,.8)); //\n    ro.zx *= r(T*.1);                              //\n    rd.zx *= r(T*.1);                              //\n    float t=.0,f=1.,i=f,h=f;     //Setup variables\n    vec3 c = vec3(0), p=c;       //\n    mat2 r1 = r(.1+T*.03);       //\n    while (t<3.) {               //\n        p = ro+rd*t;             //\n        for (int i=0;i<20;i++) { //\n            p = abs(p.yzx)*1.1-vec3(.044,0,.22+T*.009); //Iterate point\n            p.yz *= r1;                                 //\n        }\n        h = length(p-vec3(clamp(p.xy,-.2,.8),0.))*.14; //Find and step by distance\n        i = max(h,.002)*f;                             //\n        t += i;                                        //\n        c += exp(2.-t*3.) * (cos(p.x*6.+vec3(9,4,5.3))*.5+.5) * max(0.,f-4e2*h) * i*12.; //fog, colour, threshold, weight\n        f*=1.005; //Accelerate ray\n    }\n    \n    O = sqrt(c).rgbb; //Cheap gamma\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3Szf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 125, 125, 1184]], "test": "untested"}
{"id": "7ltXRs", "name": "lomateron2x", "author": "wyatt", "description": "lomateron's fluid algorithm with 2 substances\n[url]https://www.shadertoy.com/view/sl3Szs[/url]", "tags": ["convolution"], "likes": 34, "viewed": 467, "published": 3, "date": "1639648225", "time_retrieved": "2024-07-30T18:41:48.065762", "image_code": "Main \n{\n    vec4 a = A(U), b = B(U); \n    Q = b.wwww;\n    Q += a.w*max(cos(1.7+5.*a.z+vec4(1,2,3,4)),0.);\n    Q = 1.-Q;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n\n\n// oneshade:\n//https://www.shadertoy.com/view/7sKSRh\nfloat std;\nfloat erf(in float x) {\n    x *= std;\n    //return sign(x) * sqrt(1.0 - exp(-1.239192 * x * x));\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x)); // likely faster version by @spalmer\n}\nfloat erfstep (float a, float b, float x) {\n    return .5*(erf(b-x)-erf(a-x));\n}", "buffer_a_code": "Main\n{   std = 2.;\n    vec4 dQ = Q = vec4(0);\n    for (float x = -4.; x<=4.;x++)\n    for (float y = -4.; y<=4.;y++)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        vec2 v = u+a.xy;\n        float w = erfstep(-.5,.5,v.x)*\n                  erfstep(-.5,.5,v.y);\n        dQ.xyz += w*a.w*a.xyz;\n        dQ.w   += w*a.w;\n    }\n    if (dQ.w>0.)\n    {\n        dQ.xyz/=dQ.w;\n        Q = dQ;\n    }\n    \n    \n    if (iFrame < 1) {Q = vec4(0,0,0,.1);}\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n        \n    Q = A(U);\n    vec4 dQ = vec4(0);\n    for (float x = -1.; x<=1.;x++)\n    for (float y = -1.; y<=1.;y++)\n    if(x!=0.||y!=0.)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        vec4 b = B(U+u);\n        float f = 0.125*(\n        a.w+b.w);\n        dQ.xy -= f*u/dot(u,u);\n    }\n    Q += dQ;\n    Q.y -= .5/R.y;\n    vec2 M = 1.5*R;\n    if (iMouse.z>0.) M = iMouse.xy;\n    if(length(U-M)<.02*R.y)Q = vec4(.1*normalize(M-0.5*R),-1,3.);\n    if (iFrame < 1) Q = vec4(0,0,U.x/R.x,.2+.1*cos(U.x));\n    if (U.x<1.||U.y<1.||R.x-U.x<1.) Q.xy*=0.;\n    if (R.y-U.y<1.)Q.w *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n{\n    std = 1.;\n    vec4 dQ = Q = vec4(0);\n    for (float x = -4.; x<=4.;x++)\n    for (float y = -4.; y<=4.;y++)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        vec2 v = u+a.xy;\n        float w = erfstep(-.5,.5,v.x)*\n                  erfstep(-.5,.5,v.y);\n        dQ.xyz += w*a.w*a.xyz;\n        dQ.w   += w*a.w;\n    }\n    if (dQ.w>0.)\n    {\n        dQ.xyz/=dQ.w;\n        Q = dQ;\n    }\n    \n    \n    if (iFrame < 1) {Q = vec4(0,0,0,.1);}\n}", "buffer_c_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n        \n    Q = A(U);\n    vec4 dQ = vec4(0);\n    for (float x = -1.; x<=1.;x++)\n    for (float y = -1.; y<=1.;y++)\n    if(x!=0.||y!=0.)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        vec4 b = B(U+u);\n        float f = 0.1*(\n        a.w*(a.w-1.)+b.w);\n        dQ.xy -= f*u/dot(u,u);\n    }\n    Q += dQ;\n    Q.y -= .5/R.y;\n    vec2 M = 1.5*R;\n    if (iMouse.z>0.) M = iMouse.xy;\n    if(length(U-M)<.02*R.y)Q = vec4(.1*normalize(M-0.5*R),-1,3.);\n    if (iFrame < 1) Q = vec4(0,0,0,.5+.1*sin(U.x));\n    if (U.x<1.||U.y<1.||R.x-U.x<1.) Q.xy*=0.;\n    if (R.y-U.y<1.)Q.w *= 0.;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltXRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "sltXRl", "name": "Disney Principled BSDF", "author": "markusm", "description": "Port of GLSL_PathTracer from @knightcrawler25. Tried to abstract the content as good as possible into the Common tab.", "tags": ["pathtracer", "disney", "bsdf", "principled"], "likes": 70, "viewed": 2862, "published": 3, "date": "1639622285", "time_retrieved": "2024-07-30T18:41:49.024199", "image_code": "/*\n * Port of https://github.com/knightcrawler25/GLSL-PathTracer\n * Copyright(c) 2019-2021 Asif Ali\n *\n * v0.1 - Initial Release\n *\n */\n\nfloat Luminance(vec3 c)\n{\n    return 0.212671 * c.x + 0.715160 * c.y + 0.072169 * c.z;\n}\n\nvec3 Tonemap(in vec3 c, float limit)\n{\n    return c * 1.0 / (1.0 + Luminance(c) / limit);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n    fragColor.rgb = Tonemap(fragColor.rgb, 1.5);\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.4545));\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define PI         3.14159265358979323\n#define INV_PI     0.31830988618379067\n#define TWO_PI     6.28318530717958648\n#define INV_TWO_PI 0.15915494309189533\n#define INV_4_PI   0.07957747154594766\n#define EPS 0.001\n#define INF 1000000.0\n\n#define QUAD_LIGHT 0\n#define SPHERE_LIGHT 1\n#define DISTANT_LIGHT 2\n\n#define LIGHTS\n//#define RR\n#define RR_DEPTH 2\n\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Material\n{\n    vec3 baseColor;\n    vec3 emission;\n    float anisotropic;\n    float metallic;\n    float roughness;\n    float subsurface;\n    float specularTint;\n    float sheen;\n    float sheenTint;\n    float clearcoat;\n    float clearcoatRoughness;\n    float specTrans;\n    float ior;\n    float atDistance;\n    vec3 extinction;\n};\n\nstruct Light\n{\n    vec3 position;\n    vec3 emission;\n    vec3 u;\n    vec3 v;\n    float radius;\n    float area;\n    int type;\n};\n\nstruct State\n{    \n    int depth;\n    float eta;\n    float hitDist;\n\n    vec3 fhp;\n    vec3 normal;\n    vec3 ffnormal;\n    vec3 tangent;\n    vec3 bitangent;\n\n    bool isEmitter;\n\n    vec2 texCoord;\n    int matID;\n    Material mat;\n};\n\n#define NUM_LIGHTS 17\nLight lights[NUM_LIGHTS];\n\nvoid initLights() {\n\n    for(int i = 0; i < NUM_LIGHTS; i +=1) {\n        float f = float(i);\n        \n        vec3 p = vec3(-2.04973, 5., -8. + f);\n  \n        vec3 u = vec3(2.040, 5., -8. + f) - p;\n        vec3 v = vec3(-2.04973, 5., -7.5 + f) - p;\n        \n\n        float area = length(cross(u, v));\n        \n        lights[i] = Light( p,         // Position\n                           vec3(5),   // Emission\n                           u,         // u, only for rect lights\n                           v,         // v, only for rect lights\n                           0.,        // Radius for sphere light, \n                           area,      // area  \n                           0);        // type: 0 - rect, 1 - sphere, 2 - dist\n    \n    }\n}\n\n// Get the camera position and lookAt\nvoid getCameraPos(inout vec3 origin, inout vec3 lookAt) {\n    origin = vec3(15., 15, 0.);\n    lookAt = vec3(0., 0., 0.);\n}\n\n// Get the scene background color\nvec3 getBackground(Ray ray) {\n    return vec3(0);\n}\n\n// Map\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 opU(vec2 o1, vec2 o2) {\n    return (o1.x < o2.x) ? o1 : o2;\n}\n\nvec2 map(vec3 p) {\n    \n    vec2 obj = vec2(sdBox(p - vec3(0, 0.4, 0), vec3(5, 0.3, 9)), 2.);\n    \n    // Silver\n    obj = opU(vec2(length(p - vec3(-0.57, 2.2, 6.55)) - 1.2, 5), obj);\n\n    // Ping\n    obj = opU(vec2(length(p - vec3(2.6, 1.4, 3.6)) - 0.8, 4), obj);\n\n    // Orange\n    obj = opU(vec2(length(p - vec3(-0.8, 1.86, -3.59)) - 1., 3), obj);\n\n    // Glass\n    obj = opU(vec2(length(p - vec3(1.8, 2.6, -6.59)) - 1.3, 1), obj);\n\n    // Marble\n    obj = opU(vec2(length(p - vec3(3.5, 1.2, -1.5)) - 0.6, 6), obj);\n    \n    return obj;\n}\n\nvec3 calculateNormal(vec3 p) {\n \n    vec3 epsilon = vec3(0.001, 0., 1.);\n    \n    vec3 n = vec3(map(p + epsilon.xyy).x - map(p - epsilon.xyy).x,\n                  map(p + epsilon.yxy).x - map(p - epsilon.yxy).x,\n                  map(p + epsilon.yyx).x - map(p - epsilon.yyx).x);\n    \n    return normalize(n);\n}\n\n// Get the scene hit record\nbool getSceneHit(Ray ray, bool shadowRay, inout State state) {\n                    \n    float t = 0.001;\n    \n    // Analytical floor\n    float groundDist = (0. - ray.origin.y) / ray.direction.y;\n    float matId = -1.;\n\n    bool hit = groundDist > 0. ? true : false;\n\n    // Raymarch the rest \n    for(int i = 0; i < 120; ++i) {\n        vec3 p = ray.origin + ray.direction * t;\n        \n        vec2 d = map(p);\n        float ad = abs(d.x);\n\n        if (ad < (0.0001)) {\n            hit = true;\n            matId = d.y;\n            break;\n         }\n            \n         t += ad;\n         \n         if (t>27.0) { break; }\n    }\n    \n    if (hit) {\n\n        if ( (groundDist > 0. && groundDist < t) || matId < 0.5 ) {\n\n            // Ground\n            state.mat.baseColor = vec3(1, 0, 0);\n            state.mat.roughness = 0.5;\n            state.mat.metallic = 0.2;\n                \n            state.fhp = ray.origin + ray.direction * groundDist;\n            state.normal = vec3(0, 1, 0);\n\n            // 70s Wallpaper from Shane, https://www.shadertoy.com/view/ls33DN\n            vec2 p = state.fhp.xz;\n            p.x *= sign(cos(length(ceil(p /= 2.))*99.));\n    \n            float f = clamp(cos(min(length(p = fract(p)), length(--p))*44.), 0., 1.);\n            \n            f = clamp(f, 0., 1.);\n            \n            state.mat.clearcoat = f;\n            state.mat.clearcoatRoughness = f;\n            state.mat.baseColor = mix(state.mat.baseColor, \n                        vec3(1.0, 0.71, 0.29), f);\n                        \n            state.hitDist = groundDist;\n        } else {\n        \n            state.fhp = ray.origin + ray.direction * t;\n        \n            // Glass\n            if (matId > 0.5 && matId < 1.5) {\n                state.mat.baseColor = vec3(2);\n                state.mat.specTrans = 1.;\n                state.mat.roughness = 0.0;\n\n            } else\n            // Red\n            if (matId > 1.5 && matId < 2.5) {\n                state.mat.baseColor = vec3(1, 0, 0);\n                state.mat.roughness = 0.5;\n                state.mat.metallic = 0.2;\n            } else\n            // Orange\n            if (matId > 2.5 && matId < 3.5) {\n                state.mat.baseColor = vec3(1, 0.186, 0.);\n                state.mat.roughness = 0.001;\n                state.mat.clearcoat = 1.0;\n                state.mat.clearcoatRoughness = 1.0;\n            } else\n            // Ping\n            if (matId > 3.5 && matId < 4.5) {\n                state.mat.baseColor = vec3(0.93, 0.89, 0.85);\n                state.mat.roughness = 1.;\n                state.mat.subsurface = 1.0;\n            } else\n            // Silver\n            if (matId > 4.5 && matId < 5.5) {\n                state.mat.baseColor = vec3(0.9, 0.9, 0.9);\n                state.mat.roughness = 0.0;\n                state.mat.metallic = 1.;\n            } else\n            // Marble\n            if (matId > 5.5 && matId < 6.5) {\n                state.mat.baseColor = vec3(0.099, 0.24, 0.134);\n                state.mat.roughness = 0.001;\n                state.mat.clearcoat = 1.0;\n                state.mat.clearcoatRoughness = 1.0;\n            }\n            \n            if (shadowRay == false) {\n                state.normal = calculateNormal(state.fhp);\n            }\n            \n            state.hitDist = t;\n        }\n        \n        // Hack for enabling transparent reflections\n        if (shadowRay == true && state.mat.specTrans > 0.5) hit = false;\n    }\n    \n    return hit;\n}\n", "buffer_a_code": "\n// Port of https://github.com/knightcrawler25/GLSL-PathTracer\n// Copyright(c) 2019-2021 Asif Ali\n\n// Headers\n\nstruct BsdfSampleRec\n{\n    vec3 L;\n    vec3 f;\n    float pdf;\n};\n\nstruct LightSampleRec\n{\n    vec3 normal;\n    vec3 emission;\n    vec3 direction;\n    float dist;\n    float pdf;\n};\n\nuvec4 seed;\nivec2 pixel;\n\nint numOfLights;\n\nvoid InitRNG(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n    seed = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n}\n\nvoid pcg4d(inout uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y * v.w; v.y += v.z * v.x; v.z += v.x * v.y; v.w += v.y * v.z;\n    v = v ^ (v >> 16u);\n    v.x += v.y * v.w; v.y += v.z * v.x; v.z += v.x * v.y; v.w += v.y * v.z;\n}\n\nfloat rand()\n{\n    pcg4d(seed); return float(seed.x) / float(0xffffffffu);\n}\n\nvec3 FaceForward(vec3 a, vec3 b)\n{\n    return dot(a, b) < 0.0 ? -b : b;\n}\n\nfloat Luminance(vec3 c)\n{\n    return 0.212671 * c.x + 0.715160 * c.y + 0.072169 * c.z;\n}\n\n// Camera\n\nRay getCameraRay(vec2 offset) {\n    vec3 origin = vec3(0);\n    vec3 lookAt = vec3(0);\n    \n    getCameraPos(origin, lookAt);\n\n    vec2 uv = (gl_FragCoord.xy + offset) / iResolution.xy - .5;\n    uv.y *= iResolution.y / iResolution.x;\n\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( lookAt - origin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    vec3 direction = normalize( uv.x * ix + uv.y * iy + .85 * iz );\n\n    return Ray(origin, direction);\n}\n\n\n// Sampling\n\nfloat GTR1(float NDotH, float a)\n{\n    if (a >= 1.0)\n        return INV_PI;\n    float a2 = a * a;\n    float t = 1.0 + (a2 - 1.0) * NDotH * NDotH;\n    return (a2 - 1.0) / (PI * log(a2) * t);\n}\n\nvec3 SampleGTR1(float rgh, float r1, float r2)\n{\n    float a = max(0.001, rgh);\n    float a2 = a * a;\n\n    float phi = r1 * TWO_PI;\n\n    float cosTheta = sqrt((1.0 - pow(a2, 1.0 - r1)) / (1.0 - a2));\n    float sinTheta = clamp(sqrt(1.0 - (cosTheta * cosTheta)), 0.0, 1.0);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n\n    return vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);\n}\n\nfloat GTR2(float NDotH, float a)\n{\n    float a2 = a * a;\n    float t = 1.0 + (a2 - 1.0) * NDotH * NDotH;\n    return a2 / (PI * t * t);\n}\n\nvec3 SampleGTR2(float rgh, float r1, float r2)\n{\n    float a = max(0.001, rgh);\n\n    float phi = r1 * TWO_PI;\n\n    float cosTheta = sqrt((1.0 - r2) / (1.0 + (a * a - 1.0) * r2));\n    float sinTheta = clamp(sqrt(1.0 - (cosTheta * cosTheta)), 0.0, 1.0);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n\n    return vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);\n}\n\nvec3 SampleGGXVNDF(vec3 V, float rgh, float r1, float r2)\n{\n    vec3 Vh = normalize(vec3(rgh * V.x, rgh * V.y, V.z));\n\n    float lensq = Vh.x * Vh.x + Vh.y * Vh.y;\n    vec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) * inversesqrt(lensq) : vec3(1, 0, 0);\n    vec3 T2 = cross(Vh, T1);\n\n    float r = sqrt(r1);\n    float phi = 2.0 * PI * r2;\n    float t1 = r * cos(phi);\n    float t2 = r * sin(phi);\n    float s = 0.5 * (1.0 + Vh.z);\n    t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;\n\n    vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;\n\n    return normalize(vec3(rgh * Nh.x, rgh * Nh.y, max(0.0, Nh.z)));\n}\n\nfloat GTR2Aniso(float NDotH, float HDotX, float HDotY, float ax, float ay)\n{\n    float a = HDotX / ax;\n    float b = HDotY / ay;\n    float c = a * a + b * b + NDotH * NDotH;\n    return 1.0 / (PI * ax * ay * c * c);\n}\n\nvec3 SampleGTR2Aniso(float ax, float ay, float r1, float r2)\n{\n    float phi = r1 * TWO_PI;\n\n    float sinPhi = ay * sin(phi);\n    float cosPhi = ax * cos(phi);\n    float tanTheta = sqrt(r2 / (1.0 - r2));\n\n    return vec3(tanTheta * cosPhi, tanTheta * sinPhi, 1.0);\n}\n\nfloat SmithG(float NDotV, float alphaG)\n{\n    float a = alphaG * alphaG;\n    float b = NDotV * NDotV;\n    return (2.0 * NDotV) / (NDotV + sqrt(a + b - a * b));\n}\n\nfloat SmithGAniso(float NDotV, float VDotX, float VDotY, float ax, float ay)\n{\n    float a = VDotX * ax;\n    float b = VDotY * ay;\n    float c = NDotV;\n    return 1.0 / (NDotV + sqrt(a * a + b * b + c * c));\n}\n\nfloat SchlickFresnel(float u)\n{\n    float m = clamp(1.0 - u, 0.0, 1.0);\n    float m2 = m * m;\n    return m2 * m2 * m;\n}\n\nfloat DielectricFresnel(float cosThetaI, float eta)\n{\n    float sinThetaTSq = eta * eta * (1.0f - cosThetaI * cosThetaI);\n\n    // Total internal reflection\n    if (sinThetaTSq > 1.0)\n        return 1.0;\n\n    float cosThetaT = sqrt(max(1.0 - sinThetaTSq, 0.0));\n\n    float rs = (eta * cosThetaT - cosThetaI) / (eta * cosThetaT + cosThetaI);\n    float rp = (eta * cosThetaI - cosThetaT) / (eta * cosThetaI + cosThetaT);\n\n    return 0.5f * (rs * rs + rp * rp);\n}\n\nvec3 CosineSampleHemisphere(float r1, float r2)\n{\n    vec3 dir;\n    float r = sqrt(r1);\n    float phi = TWO_PI * r2;\n    dir.x = r * cos(phi);\n    dir.y = r * sin(phi);\n    dir.z = sqrt(max(0.0, 1.0 - dir.x * dir.x - dir.y * dir.y));\n    return dir;\n}\n\nvec3 UniformSampleHemisphere(float r1, float r2)\n{\n    float r = sqrt(max(0.0, 1.0 - r1 * r1));\n    float phi = TWO_PI * r2;\n    return vec3(r * cos(phi), r * sin(phi), r1);\n}\n\nvec3 UniformSampleSphere(float r1, float r2)\n{\n    float z = 1.0 - 2.0 * r1;\n    float r = sqrt(max(0.0, 1.0 - z * z));\n    float phi = TWO_PI * r2;\n    return vec3(r * cos(phi), r * sin(phi), z);\n}\n\nfloat PowerHeuristic(float a, float b)\n{\n    float t = a * a;\n    return t / (b * b + t);\n}\n\nvoid Onb(in vec3 N, inout vec3 T, inout vec3 B)\n{\n    vec3 up = abs(N.z) < 0.999 ? vec3(0, 0, 1) : vec3(1, 0, 0);\n    T = normalize(cross(up, N));\n    B = cross(N, T);\n}\n\nvoid SampleSphereLight(in Light light, in vec3 surfacePos, inout LightSampleRec lightSampleRec)\n{\n    float r1 = rand();\n    float r2 = rand();\n\n    vec3 sphereCentertoSurface = surfacePos - light.position;\n    float distToSphereCenter = length(sphereCentertoSurface);\n    vec3 sampledDir;\n\n    // TODO: Fix this. Currently assumes the light will be hit only from the outside\n    sphereCentertoSurface /= distToSphereCenter;\n    sampledDir = UniformSampleHemisphere(r1, r2);\n    vec3 T, B;\n    Onb(sphereCentertoSurface, T, B);\n    sampledDir = T * sampledDir.x + B * sampledDir.y + sphereCentertoSurface * sampledDir.z;\n\n    vec3 lightSurfacePos = light.position + sampledDir * light.radius;\n\n    lightSampleRec.direction = lightSurfacePos - surfacePos;\n    lightSampleRec.dist = length(lightSampleRec.direction);\n    float distSq = lightSampleRec.dist * lightSampleRec.dist;\n\n    lightSampleRec.direction /= lightSampleRec.dist;\n    lightSampleRec.normal = normalize(lightSurfacePos - light.position);\n    lightSampleRec.emission = light.emission * float(numOfLights);\n    lightSampleRec.pdf = distSq / (light.area * 0.5 * abs(dot(lightSampleRec.normal, lightSampleRec.direction)));\n}\n\nvoid SampleRectLight(in Light light, in vec3 surfacePos, inout LightSampleRec lightSampleRec)\n{\n    float r1 = rand();\n    float r2 = rand();\n\n    vec3 lightSurfacePos = light.position + light.u * r1 + light.v * r2;\n    lightSampleRec.direction = lightSurfacePos - surfacePos;\n    lightSampleRec.dist = length(lightSampleRec.direction);\n    float distSq = lightSampleRec.dist * lightSampleRec.dist;\n    lightSampleRec.direction /= lightSampleRec.dist;\n    lightSampleRec.normal = normalize(cross(light.u, light.v));\n    lightSampleRec.emission = light.emission * float(numOfLights);\n    lightSampleRec.pdf = distSq / (light.area * abs(dot(lightSampleRec.normal, lightSampleRec.direction)));\n}\n\nvoid SampleDistantLight(in Light light, in vec3 surfacePos, inout LightSampleRec lightSampleRec)\n{\n    lightSampleRec.direction = normalize(light.position - vec3(0.0));\n    lightSampleRec.normal = normalize(surfacePos - light.position);\n    lightSampleRec.emission = light.emission * float(numOfLights);\n    lightSampleRec.dist = INF;\n    lightSampleRec.pdf = 1.0;\n}\n\nvoid SampleOneLight(in Light light, in vec3 surfacePos, inout LightSampleRec lightSampleRec)\n{\n    int type = int(light.type);\n\n    if (type == QUAD_LIGHT)\n        SampleRectLight(light, surfacePos, lightSampleRec);\n    else if (type == SPHERE_LIGHT)\n        SampleSphereLight(light, surfacePos, lightSampleRec);\n    else\n        SampleDistantLight(light, surfacePos, lightSampleRec);\n}\n\n\nvec3 EmitterSample(in Ray r, in State state, in LightSampleRec lightSampleRec, in BsdfSampleRec bsdfSampleRec)\n{\n    vec3 Le;\n\n    if (state.depth == 0)\n        Le = lightSampleRec.emission;\n    else\n        Le = PowerHeuristic(bsdfSampleRec.pdf, lightSampleRec.pdf) * lightSampleRec.emission;\n\n    return Le;\n}\n\n// Disney\n\nvec3 ToWorld(vec3 X, vec3 Y, vec3 Z, vec3 V)\n{\n    return V.x * X + V.y * Y + V.z * Z;\n}\n\nvec3 ToLocal(vec3 X, vec3 Y, vec3 Z, vec3 V)\n{\n    return vec3(dot(V, X), dot(V, Y), dot(V, Z));\n}\n\nfloat FresnelMix(Material mat, float eta, float VDotH)\n{\n    float metallicFresnel = SchlickFresnel(VDotH);\n    float dielectricFresnel = DielectricFresnel(VDotH, eta);\n    return mix(dielectricFresnel, metallicFresnel, mat.metallic);\n}\n\nvec3 EvalDiffuse(Material mat, vec3 Csheen, vec3 V, vec3 L, vec3 H, out float pdf)\n{\n    pdf = 0.0;\n    if (L.z <= 0.0)\n        return vec3(0.0);\n\n    // Diffuse\n    float FL = SchlickFresnel(L.z);\n    float FV = SchlickFresnel(V.z);\n    float FH = SchlickFresnel(dot(L, H));\n    float Fd90 = 0.5 + 2.0 * dot(L, H) * dot(L, H) * mat.roughness;\n    float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n    // Fake Subsurface TODO: Replace with volumetric scattering\n    float Fss90 = dot(L, H) * dot(L, H) * mat.roughness;\n    float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n    float ss = 1.25 * (Fss * (1.0 / (L.z + V.z) - 0.5) + 0.5);\n\n    // Sheen\n    vec3 Fsheen = FH * mat.sheen * Csheen;\n\n    pdf = L.z * INV_PI;\n    return (INV_PI * mix(Fd, ss, mat.subsurface) * mat.baseColor + Fsheen) * (1.0 - mat.metallic) * (1.0 - mat.specTrans);\n}\n\nvec3 EvalSpecReflection(Material mat, float eta, vec3 specCol, vec3 V, vec3 L, vec3 H, out float pdf)\n{\n    pdf = 0.0;\n    if (L.z <= 0.0)\n        return vec3(0.0);\n\n    float FM = FresnelMix(mat, eta, dot(L, H));\n    vec3 F = mix(specCol, vec3(1.0), FM);\n    float D = GTR2(H.z, mat.roughness);\n    float G1 = SmithG(abs(V.z), mat.roughness);\n    float G2 = G1 * SmithG(abs(L.z), mat.roughness);\n    float jacobian = 1.0 / (4.0 * dot(V, H));\n\n    pdf = G1 * max(0.0, dot(V, H)) * D * jacobian / V.z;\n    return F * D * G2 / (4.0 * L.z * V.z);\n}\n\nvec3 EvalSpecRefraction(Material mat, float eta, vec3 V, vec3 L, vec3 H, out float pdf)\n{\n    pdf = 0.0;\n    if (L.z >= 0.0)\n        return vec3(0.0);\n\n    float F = DielectricFresnel(abs(dot(V, H)), eta);\n    float D = GTR2(H.z, mat.roughness);\n    float denom = dot(L, H) + dot(V, H) * eta;\n    denom *= denom;\n    float G1 = SmithG(abs(V.z), mat.roughness);\n    float G2 = G1 * SmithG(abs(L.z), mat.roughness);\n    float jacobian = abs(dot(L, H)) / denom;\n\n    pdf = G1 * max(0.0, dot(V, H)) * D * jacobian / V.z;\n\n    vec3 specColor = pow(mat.baseColor, vec3(0.5));\n    return specColor * (1.0 - mat.metallic) * mat.specTrans * (1.0 - F) * D * G2 * abs(dot(V, H)) * abs(dot(L, H)) * eta * eta / (denom * abs(L.z) * abs(V.z));\n}\n\nvec3 EvalClearcoat(Material mat, vec3 V, vec3 L, vec3 H, out float pdf)\n{\n    pdf = 0.0;\n    if (L.z <= 0.0)\n        return vec3(0.0);\n\n    float FH = DielectricFresnel(dot(V, H), 1.0 / 1.5);\n    float F = mix(0.04, 1.0, FH);\n    float D = GTR1(H.z, mat.clearcoatRoughness);\n    float G = SmithG(L.z, 0.25)\n        * SmithG(V.z, 0.25);\n    float jacobian = 1.0 / (4.0 * dot(V, H));\n\n    pdf = D * H.z * jacobian;\n    return vec3(0.25) * mat.clearcoat * F * D * G / (4.0 * L.z * V.z);\n}\n\nvoid GetSpecColor(Material mat, float eta, out vec3 specCol, out vec3 sheenCol)\n{\n    float lum = Luminance(mat.baseColor);\n    vec3 ctint = lum > 0.0 ? mat.baseColor / lum : vec3(1.0f);\n    float F0 = (1.0 - eta) / (1.0 + eta);\n    specCol = mix(F0 * F0 * mix(vec3(1.0), ctint, mat.specularTint), mat.baseColor, mat.metallic);\n    sheenCol = mix(vec3(1.0), ctint, mat.sheenTint);\n}\n\nvoid GetLobeProbabilities(Material mat, float eta, vec3 specCol, float approxFresnel, out float diffuseWt, out float specReflectWt, out float specRefractWt, out float clearcoatWt)\n{\n    diffuseWt = Luminance(mat.baseColor) * (1.0 - mat.metallic) * (1.0 - mat.specTrans);\n    specReflectWt = Luminance(mix(specCol, vec3(1.0), approxFresnel));\n    specRefractWt = (1.0 - approxFresnel) * (1.0 - mat.metallic) * mat.specTrans * Luminance(mat.baseColor);\n    clearcoatWt = mat.clearcoat * (1.0 - mat.metallic);\n    float totalWt = diffuseWt + specReflectWt + specRefractWt + clearcoatWt;\n\n    diffuseWt /= totalWt;\n    specReflectWt /= totalWt;\n    specRefractWt /= totalWt;\n    clearcoatWt /= totalWt;\n}\n\nvec3 DisneySample(State state, vec3 V, vec3 N, out vec3 L, out float pdf)\n{\n    pdf = 0.0;\n    vec3 f = vec3(0.0);\n\n    float r1 = rand();\n    float r2 = rand();\n\n    vec3 T, B;\n    Onb(N, T, B);\n    V = ToLocal(T, B, N, V); // NDotL = L.z; NDotV = V.z; NDotH = H.z\n\n    // Specular and sheen color\n    vec3 specCol, sheenCol;\n    GetSpecColor(state.mat, state.eta, specCol, sheenCol);\n\n    // Lobe weights\n    float diffuseWt, specReflectWt, specRefractWt, clearcoatWt;\n    // TODO: Recheck fresnel. Not sure if correct. VDotN produces fireflies with rough dielectric.\n    // VDotH matches Mitsuba and gets rid of all fireflies but H isn't available at this stage\n    float approxFresnel = FresnelMix(state.mat, state.eta, V.z);\n    GetLobeProbabilities(state.mat, state.eta, specCol, approxFresnel, diffuseWt, specReflectWt, specRefractWt, clearcoatWt);\n\n    // CDF for picking a lobe\n    float cdf[4];\n    cdf[0] = diffuseWt;\n    cdf[1] = cdf[0] + specReflectWt;\n    cdf[2] = cdf[1] + specRefractWt;\n    cdf[3] = cdf[2] + clearcoatWt;\n\n    if (r1 < cdf[0]) // Diffuse Reflection Lobe\n    {\n        r1 /= cdf[0];\n        L = CosineSampleHemisphere(r1, r2);\n\n        vec3 H = normalize(L + V);\n\n        f = EvalDiffuse(state.mat, sheenCol, V, L, H, pdf);\n        pdf *= diffuseWt;\n    }\n    else if (r1 < cdf[1]) // Specular Reflection Lobe\n    {\n        r1 = (r1 - cdf[0]) / (cdf[1] - cdf[0]);\n        vec3 H = SampleGGXVNDF(V, state.mat.roughness, r1, r2);\n\n        if (H.z < 0.0)\n            H = -H;\n\n        L = normalize(reflect(-V, H));\n\n        f = EvalSpecReflection(state.mat, state.eta, specCol, V, L, H, pdf);\n        pdf *= specReflectWt;\n    }\n    else if (r1 < cdf[2]) // Specular Refraction Lobe\n    {\n        r1 = (r1 - cdf[1]) / (cdf[2] - cdf[1]);\n        vec3 H = SampleGGXVNDF(V, state.mat.roughness, r1, r2);\n\n        if (H.z < 0.0)\n            H = -H;\n\n        L = normalize(refract(-V, H, state.eta));\n\n        f = EvalSpecRefraction(state.mat, state.eta, V, L, H, pdf);\n        pdf *= specRefractWt;\n    }\n    else // Clearcoat Lobe\n    {\n        r1 = (r1 - cdf[2]) / (1.0 - cdf[2]);\n        vec3 H = SampleGTR1(state.mat.clearcoatRoughness, r1, r2);\n\n        if (H.z < 0.0)\n            H = -H;\n\n        L = normalize(reflect(-V, H));\n\n        f = EvalClearcoat(state.mat, V, L, H, pdf);\n        pdf *= clearcoatWt;\n    }\n\n    L = ToWorld(T, B, N, L);\n    return f * abs(dot(N, L));\n}\n\nvec3 DisneyEval(State state, vec3 V, vec3 N, vec3 L, out float bsdfPdf)\n{\n    bsdfPdf = 0.0;\n    vec3 f = vec3(0.0);\n\n    vec3 T, B;\n    Onb(N, T, B);\n    V = ToLocal(T, B, N, V); // NDotL = L.z; NDotV = V.z; NDotH = H.z\n    L = ToLocal(T, B, N, L);\n\n    vec3 H;\n    if (L.z > 0.0)\n        H = normalize(L + V);\n    else\n        H = normalize(L + V * state.eta);\n\n    if (H.z < 0.0)\n        H = -H;\n\n    // Specular and sheen color\n    vec3 specCol, sheenCol;\n    GetSpecColor(state.mat, state.eta, specCol, sheenCol);\n\n    // Lobe weights\n    float diffuseWt, specReflectWt, specRefractWt, clearcoatWt;\n    float fresnel = FresnelMix(state.mat, state.eta, dot(V, H));\n    GetLobeProbabilities(state.mat, state.eta, specCol, fresnel, diffuseWt, specReflectWt, specRefractWt, clearcoatWt);\n\n    float pdf;\n\n    // Diffuse\n    if (diffuseWt > 0.0 && L.z > 0.0)\n    {\n        f += EvalDiffuse(state.mat, sheenCol, V, L, H, pdf);\n        bsdfPdf += pdf * diffuseWt;\n    }\n\n    // Specular Reflection\n    if (specReflectWt > 0.0 && L.z > 0.0 && V.z > 0.0)\n    {\n        f += EvalSpecReflection(state.mat, state.eta, specCol, V, L, H, pdf);\n        bsdfPdf += pdf * specReflectWt;\n    }\n\n    // Specular Refraction\n    if (specRefractWt > 0.0 && L.z < 0.0)\n    {\n        f += EvalSpecRefraction(state.mat, state.eta, V, L, H, pdf);\n        bsdfPdf += pdf * specRefractWt;\n    }\n\n    // Clearcoat\n    if (clearcoatWt > 0.0 && L.z > 0.0 && V.z > 0.0)\n    {\n        f += EvalClearcoat(state.mat, V, L, H, pdf);\n        bsdfPdf += pdf * clearcoatWt;\n    }\n\n    return f * abs(L.z);\n}\n\n// Intersection\n\nfloat SphereIntersect(float rad, vec3 pos, Ray r)\n{\n    vec3 op = pos - r.origin;\n    float eps = 0.001;\n    float b = dot(op, r.direction);\n    float det = b * b - dot(op, op) + rad * rad;\n    if (det < 0.0)\n        return INF;\n\n    det = sqrt(det);\n    float t1 = b - det;\n    if (t1 > eps)\n        return t1;\n\n    float t2 = b + det;\n    if (t2 > eps)\n        return t2;\n\n    return INF;\n}\n\nfloat RectIntersect(in vec3 pos, in vec3 u, in vec3 v, in vec4 plane, in Ray r)\n{\n    vec3 n = vec3(plane);\n    float dt = dot(r.direction, n);\n    float t = (plane.w - dot(n, r.origin)) / dt;\n\n    if (t > EPS)\n    {\n        vec3 p = r.origin + r.direction * t;\n        vec3 vi = p - pos;\n        float a1 = dot(u, vi);\n        if (a1 >= 0.0 && a1 <= 1.0)\n        {\n            float a2 = dot(v, vi);\n            if (a2 >= 0.0 && a2 <= 1.0)\n                return t;\n        }\n    }\n\n    return INF;\n}\n\n\n// DirectLight\nvec3 DirectLight(in Ray r, in State state)\n{\n    vec3 Li = vec3(0.0);\n    vec3 surfacePos = state.fhp + state.normal * EPS;\n\n    BsdfSampleRec bsdfSampleRec;\n\n//#define ENVMAP\n    // Environment Light\n#ifdef ENVMAP\n#ifndef CONSTANT_BG\n    {\n        vec3 color;\n        vec4 dirPdf = SampleEnvMap(color);\n        vec3 lightDir = dirPdf.xyz;\n        float lightPdf = dirPdf.w;\n\n        Ray shadowRay = Ray(surfacePos, lightDir);\n        bool inShadow = AnyHit(shadowRay, INF - EPS);\n\n        if (!inShadow)\n        {\n            bsdfSampleRec.f = DisneyEval(state, -r.direction, state.ffnormal, lightDir, bsdfSampleRec.pdf);\n\n            if (bsdfSampleRec.pdf > 0.0)\n            {\n                float misWeight = PowerHeuristic(lightPdf, bsdfSampleRec.pdf);\n                if (misWeight > 0.0)\n                    Li += misWeight * bsdfSampleRec.f * color / lightPdf;\n            }\n        }\n    }\n#endif\n#endif\n\n    // Analytic Lights \n#ifdef LIGHTS\n    {\n        LightSampleRec lightSampleRec;\n\n        //Pick a light to sample\n        int index = int(rand() * float(numOfLights));\n\n        Light light = lights[index];\n\n        light = Light(light.position, light.emission, light.u, light.v, light.radius, light.area, light.type);\n        SampleOneLight(light, surfacePos, lightSampleRec);\n\n        if (dot(lightSampleRec.direction, lightSampleRec.normal) < 0.0) // Required for quad lights with single sided emission\n        {\n            Ray shadowRay = Ray(surfacePos, lightSampleRec.direction);\n            bool inShadow = getSceneHit(shadowRay, true, state);//AnyHit(shadowRay, lightSampleRec.dist - EPS);\n\n            if (!inShadow) {\n                bsdfSampleRec.f = DisneyEval(state, -r.direction, state.ffnormal, lightSampleRec.direction, bsdfSampleRec.pdf);\n\n                float weight = 1.0;\n                if(light.area > 0.0) // No MIS for distant light\n                    weight = PowerHeuristic(lightSampleRec.pdf, bsdfSampleRec.pdf);\n\n                if (bsdfSampleRec.pdf > 0.0)\n                    Li += weight * bsdfSampleRec.f * lightSampleRec.emission / lightSampleRec.pdf;\n            }\n        }\n    }\n#endif\n\n    return Li;\n}\n\n// Path tracer\n\nvec3 PathTrace(Ray r)\n{\n    vec3 radiance = vec3(0.0);\n    vec3 throughput = vec3(1.0);\n    State state;\n    LightSampleRec lightSampleRec;\n    BsdfSampleRec bsdfSampleRec;\n    vec3 absorption = vec3(0.0);\n    \n    // Initial material values\n    state.mat.anisotropic  = 0.0;\n\n    state.mat.metallic     = 0.0;\n    state.mat.roughness    = 0.5;\n    state.mat.subsurface   = 0.0;\n    state.mat.specularTint = 0.0;\n            \n    state.mat.sheen        = 0.0;\n    state.mat.sheenTint    = 0.0;\n    state.mat.clearcoat    = 0.0;\n    state.mat.clearcoatRoughness = 0.0;\n            \n    state.mat.roughness    = 0.;\n    state.mat.ior          = 1.45;\n    state.mat.extinction   = vec3(1);\n    state.mat.atDistance   = 1.;\n\n\n    initLights();\n    numOfLights = NUM_LIGHTS;\n\n    const int maxDepth = 4;\n    for (int depth = 0; depth < maxDepth; depth++)\n    {\n        state.depth = depth;\n        bool hit = getSceneHit(r, false, state);\n\n        if (!hit) {\n            radiance += getBackground(r) * throughput;\n        } else {        \n            state.ffnormal = dot(state.normal, r.direction) <= 0.0 ? state.normal : -state.normal;\n            Onb(state.normal, state.tangent, state.bitangent);\n            state.mat.roughness = max(state.mat.roughness, 0.001);\n            state.eta = dot(state.normal, state.ffnormal) > 0.0 ? (1.0 / state.mat.ior) : state.mat.ior;\n        }\n        \n        // Lights\n        for (int i = 0; i < numOfLights; i++)\n        {\n            Light light = lights[i];\n            \n            // Intersect rectangular area light\n            if (light.type == 0)\n            {\n                vec3 u = light.u;\n                vec3 v = light.v;\n                vec3 normal = normalize(cross(light.u, light.v));\n                //if (dot(normal, r.direction) > 0.) // Hide backfacing quad light\n                    //continue;\n                vec4 plane = vec4(normal, dot(normal, light.position));\n                u *= 1.0f / dot(u, u);\n                v *= 1.0f / dot(v, v);\n\n                float d = RectIntersect(light.position, u, v, plane, r);\n                if (d < 0.)\n                    d = INF;\n                    \n                if (d < state.hitDist)\n                {\n                    state.hitDist = d;\n                    float cosTheta = dot(-r.direction, normal);\n                    float pdf = (d * d) / (light.area * cosTheta);\n                    lightSampleRec.emission = light.emission;\n                    lightSampleRec.pdf = pdf;\n                    state.isEmitter = true;\n                }\n            } else\n            // Intersect spherical area light\n            if (light.type == 1)\n            {\n                float d = SphereIntersect(light.radius, light.position, r);\n                if (d < 0.)\n                    d = INF;\n                if (d < state.hitDist)\n                {\n                    state.hitDist = d;\n                    float pdf = (d * d) / light.area;\n                    lightSampleRec.emission = light.emission;\n                    lightSampleRec.pdf = pdf;\n                    state.isEmitter = true;\n                }\n            }\n        }\n        \n        // Reset absorption when ray is going out of surface\n        if (dot(state.normal, state.ffnormal) > 0.0)\n            absorption = vec3(0.0);\n\n        radiance += state.mat.emission * throughput;\n\n#ifdef LIGHTS\n        if (state.isEmitter)\n        {\n            radiance += EmitterSample(r, state, lightSampleRec, bsdfSampleRec) * throughput;\n            break;\n        }\n#endif\n\n        // Add absoption\n        throughput *= exp(-absorption * state.hitDist);\n\n        radiance += DirectLight(r, state) * throughput;\n\n        bsdfSampleRec.f = DisneySample(state, -r.direction, state.ffnormal, bsdfSampleRec.L, bsdfSampleRec.pdf);\n\n        // Set absorption only if the ray is currently inside the object.\n        if (dot(state.ffnormal, bsdfSampleRec.L) < 0.0)\n            absorption = -log(state.mat.extinction) / state.mat.atDistance;\n\n        if (bsdfSampleRec.pdf > 0.0)\n            throughput *= bsdfSampleRec.f / bsdfSampleRec.pdf;\n        else\n            break;\n\n#ifdef RR\n        // Russian roulette\n        if (depth >= RR_DEPTH)\n        {\n            float q = min(max(throughput.x, max(throughput.y, throughput.z)) + 0.001, 0.95);\n            if (rand() > q)\n                break;\n            throughput /= q;\n        }\n#endif\n\n        r.direction = bsdfSampleRec.L;\n        r.origin = state.fhp + r.direction * EPS;\n    }\n\n    return radiance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitRNG(fragCoord, iFrame);\n\n    // Camera\n    Ray ray = getCameraRay(vec2(rand(), rand()));\n\n    // Pathtrace\n    vec3 col = PathTrace(ray);\n    col = clamp(col, 0., 5.);\n\n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel1, uv) * (1. - 1./float(iFrame+1)) + texture(iChannel0, uv) * 1./float(iFrame + 1);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltXRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 162, 162, 225], [227, 227, 265, 265, 318], [320, 320, 377, 377, 561]], "test": "untested"}
{"id": "ftdXRl", "name": "thingthingthingthing", "author": "SnoopethDuckDuck", "description": "meddling with noise and things, no idea. lots of unused code", "tags": ["e"], "likes": 4, "viewed": 269, "published": 3, "date": "1639611859", "time_retrieved": "2024-07-30T18:41:49.795137", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    //uv.x += 0.1 * iTime;\n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n    \n    float time = 0.2 * iTime;\n    float c = 1.;\n    float f = 20.;\n    vec2 uv2 = 2. * uv * vec2(ths(f * (1. + h21(uv)), c * abs(uv.x) - time), thc(f * (1. + h21(uv)), c * abs(uv.y) - time));\n    vec2 uv3 = 2. * uv * vec2(ths(2., c * abs(uv.x) + time), thc(2., c * abs(uv.y) + time));\n\n    if (iFrame % 2 == 0)\n        uv = uv2;\n    else\n        uv = uv3;\n        uv = uv2;\n    //uv = mix(uv2, uv3, vec2(0.5 + 0.5 * thc(4., 2. * iTime)));\n    uv = vec2(ceil(2. * h21(floor(0.5 * iTime) + floor(2. * uv))) * atan(uv.y,uv.x) / pi, log(length(uv))-time);\n    \n    //uv += h21(uv) * 0.01 * thc(1000., 4. * r - iTime);\n    vec2 v = vec2(cos(a + iTime), sin(a + iTime));\n    float sc = 4.;\n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    \n    float d = length(fpos);\n    float k = 0.5;\n    a = atan(fpos.y, fpos.x);\n    \n    float h = h21(ipos);\n    float s = smoothstep(-k, k, 0.5 * (0.5 + 0.5 * thc(2.,(10. + 10. * h) * d + a + 11. * h - iTime )) - d);\n    s *= 3. * (0.5-d);\n    vec3 col = s* pal(s + cos(h21(ipos) + (1. + 0.005 * h21(uv)) * iTime), vec3(1.), vec3(1.), vec3(1.), 0.1 + 0.4 * vec3(0.,0.33,0.66));\n    //col *= 0.8;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdXRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 191, 191, 232], [234, 234, 261, 261, 302], [304, 304, 372, 372, 415], [417, 417, 437, 437, 512], [514, 514, 538, 538, 578], [580, 580, 637, 637, 2009]], "test": "untested"}
{"id": "NltXRl", "name": "Logarithmic Moebius arrows", "author": "FabriceNeyret2", "description": "( antialiasing is quite ugly... )\n\nclick", "tags": ["2d", "zoom", "spiral", "mobius", "transform", "logarithm", "short", "golf"], "likes": 36, "viewed": 528, "published": 3, "date": "1639594444", "time_retrieved": "2024-07-30T18:41:50.568071", "image_code": "// variant of https://shadertoy.com/view/4sGXDK\n// golfed version below\n\n/**/    // 277 chars \n\nvoid mainImage(out vec4 O,  vec2 U){\n\n    vec2 z = iResolution.xy;                                // normalized coordinates\n         U = (U+U - z) / z.y;\n    \n\tz = U - vec2(-2,0);  U -= vec2(.8,.2);                  // Moebius transform\n    U *= mat2(z,-z.y,z) / dot(U,U);\n              \n                   // offset   spiral, zoom       phase     // spiraling\n    U =   log(length(U+=.5))*vec2(.5, -.5) + vec2(0,iTime/8.)\n        + atan(U.y, U.x)/6.283 * vec2(5, 2);        \n                                     // n  \n    z = fract(U*4.)-.5;                                     // cells\n    O = ( abs(z.xxxx) + ( z.y<0.? z.y: -.25 ) )             // arrows \n        / fwidth(length(z));                                // AA\n    if ( iMouse.z>0. && mod(floor(U*4.),4.)==vec2(z.x<0.,0) ) O.gba *= 0.;\n}\n/**/\n\n\n\n\n\n/** // 259: -18 Xor and iapafoto\n\nvoid mainImage(out vec4 O,  vec2 U)\n{\n    vec2 z = iResolution.xy;\n         U = (z = (U+U - z) / z.y) -.2;\n\tz.x += 2.;  \n    U.x -= .6;\n    U *= mat2(z,-z.y,z) / dot(U,U);\n    U = log(length(U+=.5)) + atan(U.y, U.x) * vec2(1.592, -.637);\n    U.y -= iTime/4.;\n    U = fract(U+U)-.5;\n    O = ( ( U.y<0.? -U.y: .25 ) - abs(U.xxxx) )\n        / fwidth(length(1.4*U));\n}\n/**/\n", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltXRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 132, 132, 898]], "test": "untested"}
{"id": "fltXRl", "name": "arrows ( 106 chars )", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "escher", "short", "onetweet", "arrows", "golf"], "likes": 16, "viewed": 344, "published": 3, "date": "1639593267", "time_retrieved": "2024-07-30T18:41:51.330033", "image_code": "// -2 by coyote , -1 by Xor\n\nvoid mainImage(out vec4 O, vec2 U){\n    U = mod( 6.*U, O.y=iResolution.y ) - O.y/2.;\n    O = abs( U ).yyyy  - ( U.x<0. ? O.y/4. : U.x );\n}\n\n\n\n\n\n/** // 109 chars: -4 by Greg, -2 by Xor\n\nvoid mainImage(out vec4 O, vec2 U){\n    float R = iResolution.y;\n    U = mod( 6.*U, R ) - R/2.;\n    O = abs(U.yyyy) + ( U.x>0. ? -R/4. : U.x );\n}\n/**/\n\n\n\n\n\n/** // 115 chars: -3 by Fab, -4 by Greg\n\nvoid mainImage(out vec4 O,  vec2 U){\n    U = mod( 6.* U - (O.xy= iResolution.xy) , O.y ) -.5*O.y;\n    O = abs(U.yyyy) + ( U.x < 0. ? U.x: -O.y/4. );\n}\n/**/\n\n\n\n\n\n/** // 122 chars\n\nvoid mainImage(out vec4 O,  vec2 U){\n    vec2 R = iResolution.xy;\n    U = fract( 3.* (U+U - R ) / R.y ) -.5;\n    O = ( abs(U.y) + ( U.x < 0. ? U.x: -.25 ) ) * R.yyyy;\n}\n/**/\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fltXRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 64, 64, 167]], "test": "untested"}
{"id": "stcXzs", "name": "retro cityscape by graphtoy", "author": "yasuo", "description": "reference:\nhttps://www.youtube.com/watch?v=lVYksrvNe28\n", "tags": ["graphtoy"], "likes": 19, "viewed": 380, "published": 3, "date": "1639585204", "time_retrieved": "2024-07-30T18:41:52.092994", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p.x)-s.x,abs(p.y)-s.y)\n\nfloat hash(vec2 p){\n    vec2 rand = fract(sin(p*123.456)*567.89);\n    rand += dot(rand,rand*34.56);\n    return fract(rand.x*rand.y);\n}\n\nfloat starLayer(vec2 p){\n    p.x += iTime*0.1;\n    p*=12.0;\n    vec2 uv = fract(p)-0.5;\n    vec2 id = floor(p);\n    float n = hash(id);\n    \n    vec2 size = vec2(0.0);\n    float x = 0.0;\n    if(n<0.1){\n        size = vec2(0.025,0.2);\n        uv.x-=0.2;\n        uv.y-=0.2;\n    } else if(n>=0.1 && n<0.4){\n        size = vec2(0.02,0.15);\n        uv.x+=0.3;\n        uv.y+=0.2;\n    }\n    return min(B(uv,size),B(uv,vec2(size.y,size.x)));\n}\n\nfloat buildingWindowBase(vec2 p, float scale){\n    p*=scale;\n    vec2 uv = fract(p)-0.5;\n    vec2 id = floor(p);\n    vec2 size = vec2(0.25);\n    return B(uv,size);\n}\n\nfloat buildingWindow(vec2 p, float scale){\n    p*=scale;\n    vec2 uv = fract(p)-0.5;\n    vec2 id = floor(p);\n    float n = hash(id);\n    \n    vec2 size = vec2(0.0);\n    if(n<0.5){\n        size = vec2(0.25);\n    }\n    return B(uv,size);\n}\n\nvec3 buildingMaterial(vec2 p, vec3 col, float scale){\n    float d = buildingWindowBase(p,scale);\n    col = mix(col,vec3(0.3),S(d,0.0));\n    d = buildingWindow(p,scale);\n    col = mix(col,vec3(0.8),S(d,0.0));\n    return col;\n}\n\nfloat birds(vec2 p){\n    p.x+=iTime*0.2;\n    p.x = mod(p.x,0.8)-0.4;\n    p.y-=0.45;\n    float d = B(p,vec2(0.04,0.006));\n    p.x+=0.01;\n    p.y-=0.01+sin(iTime*5.0)*0.006;\n    float d2 = B(p,vec2(0.02,0.006));\n    return min(d,d2);\n}\n\nfloat cloud(vec2 p){\n    float d = B(p,vec2(0.06,0.003));\n    p.y+=0.011;\n    d = min(B(p,vec2(0.1,0.003)),d);\n    p.y+=0.011;\n    d = min(B(p,vec2(0.28,0.003)),d);\n    p.y+=0.011;\n    p.x = abs(p.x);\n    p.x-=0.13;\n    d = min(B(p,vec2(0.09,0.003)),d);\n    p.y+=0.011;\n    d = min(B(p,vec2(0.05,0.003)),d);\n    return d;\n}\n\nvec3 car(vec2 p, vec3 col){\n    p*=7.0;\n    vec2 prevP = p;\n    \n    p = prevP;\n    p.y+=0.13;\n    p.y*=7.0;\n    float d = length(p)-0.4;\n    col = mix(col,vec3(0.3),S(d,-0.2));    \n    \n    p = prevP;\n    d = B(p,vec2(0.3,0.08));\n    float a = radians(45.);\n    p = abs(p);\n    p-=vec2(0.3,0.05);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    \n    p = prevP;\n    p.x = abs(p.x)-0.15;\n    p.y+=0.05;\n    d = max(-(length(p)-0.09),d);    \n    \n    col = mix(col,vec3(0.7,0.6,0.1),S(d,0.0));\n    \n    p = prevP;\n    p.y-=0.16;\n    d = B(p,vec2(0.19,0.08));\n    a = radians(20.);\n    p.x = abs(p.x);\n    p.x-=0.14;\n    p.y-=0.05;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    col = mix(col,vec3(0.7,0.6,0.1),S(d,0.0));\n    \n    p = prevP;\n    p.y-=0.16;\n    d = B(p,vec2(0.15,0.06));\n    a = radians(20.);\n    p.x = abs(p.x);\n    p.x-=0.11;\n    p.y-=0.06;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    p = prevP;\n    d = max(-(abs(p.x)-0.012),d);\n    col = mix(col,vec3(0.6,0.8,0.9),S(d,0.0));\n    \n    p = prevP;\n    p.x = abs(p.x)-0.15;\n    p.y+=0.05;\n    d = length(p)-0.08;\n    col = mix(col,vec3(0.),S(d,0.0));\n    d = length(p)-0.06;\n    col = mix(col,vec3(0.7),S(d,0.0));\n    \n    return col;\n}\n\nvec3 missile(vec2 p, vec3 col, vec3 col2){\n    vec2 prevP = p;\n    p = prevP;\n    p -= vec2(0.06,-0.02);\n    float d = B(p,vec2(0.07,0.015));\n    d = min(length(p-vec2(-0.07,0.0))-0.015,d);\n    \n    p.x -= 0.03;\n    p.y = abs(p.y);\n    p.y-=0.02;\n    float d2 = B(p,vec2(0.03,0.02));\n    float a = radians(-40.0);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n    d = min(d2,d);\n    col = mix(col,col2,S(d,0.0));\n    return col;\n}\n\nvec3 chopper(vec2 p, vec3 col){\n    p*=Rot(radians(-10.0));\n    p*=1.7;\n    p.y+=sin(iTime*3.0)*0.02;\n    vec2 prevP = p;\n    float d = B(p,vec2(0.22,0.1));\n    float a = radians(-70.);\n    p.y-=0.09;\n    d = max(-dot(p,vec2(cos(a),sin(a))),d);\n    p = prevP;\n    a = radians(70.);\n    p.y+=0.13;\n    d = max(-dot(p,vec2(cos(a),sin(a))),d);\n    p = prevP;\n    a = radians(45.);\n    p.x-=0.26;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    p = prevP;\n    a = radians(-50.);\n    p.x-=0.3;\n    p.y-=0.06;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    \n    p = prevP;\n    p.x-=0.35;\n    p.y-=0.015;\n    d = min(B(p,vec2(0.15,0.025)),d);\n    \n    p = prevP;\n    p.y-=0.015;\n    p.y = abs(p.y);\n    p.x-=0.49;\n    p.y-=0.06;\n    \n    p*=Rot(radians(10.0));\n    a = radians(-10.);\n    \n    d = min(max(-dot(p-vec2(-0.01,0.0),vec2(cos(a),sin(a))),B(p,vec2(0.02,0.05))),d);\n    \n    col = mix(col,vec3(0.3,0.5,0.3),S(d,0.0));\n    \n    p = prevP;\n    p.x+=0.08;\n    p.y-=0.05;\n    d = B(p,vec2(0.1,0.05));\n    a = radians(-70.);\n    d = max(-dot(p,vec2(cos(a),sin(a))),d);\n    \n    a = radians(-70.);\n    d = max(dot(p-vec2(0.00,-0.05),vec2(cos(a),sin(a))),d);\n    \n    col = mix(col,vec3(0.6,0.8,0.9),S(d,0.0));\n    \n    p = prevP;\n    p.x = abs(p.x)-0.06;\n    p.y+=0.13;\n    d = B(p,vec2(0.006,0.03));\n    p.y+=0.03;\n    d = min(B(p,vec2(0.07,0.006)),d);\n    col = mix(col,vec3(0.3,0.5,0.5),S(d,0.0));\n    \n    p = prevP;\n    p.x-=0.1;\n    p.y-=0.14;\n    d = B(p,vec2(0.01,0.05));\n    p.y-=0.02;\n    d = min(B(p,vec2(0.3+sin(iTime*10.0)*0.25,0.01)),d);\n    \n    col = mix(col,vec3(0.3,0.5,0.5),S(d,0.0));\n    \n    p = prevP;\n    col = missile(p-vec2(0.01,-0.01),col,vec3(0.2,0.4,0.4)*0.3);\n    col = missile(p,col,vec3(0.2,0.4,0.4));\n    \n    \n    return col;\n}\n\nvec3 streetLight(vec2 p, vec3 col){\n    p*=2.0;\n    vec2 prevP = p;\n    float d = B(p,vec2(0.005,0.1));\n    col = mix(col,vec3(0.7,0.3,0.2),S(d,0.0));\n    \n    p*=Rot(radians(45.));\n    p.x+=0.068;\n    p.y-=0.115;\n    d = B(p,vec2(0.005,0.05));\n    col = mix(col,vec3(0.7,0.3,0.2),S(d,0.0));\n    \n    p = prevP;\n    \n    p*=Rot(radians(45.));\n    p.x+=0.058;\n    p.y-=0.115;\n    d = B(p,vec2(0.005,0.025));\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    \n    vec3 col = mix(vec3(0.5,0.3,0.7),vec3(0.3,0.3,0.5),uv.y+0.3);\n    \n    float t = iTime;\n    \n    // The following code should be `sqrt(8^2-x^2)`, but it does not work for me, so I used the normal circle distance function.\n    float d = length(uv-vec2(0.0,-0.15))-0.6;\n    uv.y-=iTime*0.05;\n    uv.y = mod(uv.y,0.05)-0.025;\n    d = max(-B(uv,vec2(10.0,0.01)),d);\n    col = mix(col,mix(vec3(0.7,0.5,0.6),vec3(0.7,0.1,0.5),prevUV.y+0.2),S(d,0.0));    \n    \n    // star\n    uv = prevUV;\n    d = starLayer(uv);\n    col = mix(col,vec3(0.6,0.4,0.5),S(max(-uv.y+0.25,d),0.0));  \n    \n    // clouds\n    uv = prevUV;\n    uv.x-=iTime*0.05;\n    uv.x = mod(uv.x,1.6)-0.8;\n    uv.y-=0.45;\n    d = cloud(uv);\n    col = mix(col,vec3(0.6,0.2,0.3),S(d,0.0)); \n    \n    // birds\n    uv = prevUV;\n    d = birds(uv);\n    col = mix(col,vec3(0.0),S(d,0.0)); \n    \n    // buildings1\n    uv*=6.0;\n    d = -0.7+1.5*sin(floor((uv.x*2.5)+t)*4321.);\n    uv.y += d;\n    col = mix(col,vec3(0.15),S(uv.y,0.0));\n    \n    // buildings2\n    uv = prevUV;\n    uv*=6.0;\n    d = -0.7+1.*sin(floor((uv.x*1.5)+(t*1.5))*2121.);\n    uv.y += d;\n    uv.x+=iTime+0.22;\n    col = mix(col,buildingMaterial(uv,vec3(0.2),8.5),S(uv.y,0.0));\n    \n    // buildings3\n    uv = prevUV;\n    uv.x+=iTime*0.3;\n    uv*=1.2;\n    uv.y+=0.1;\n    uv.x = mod(uv.x,0.6)-0.3;\n    d = B(uv,vec2(0.1,0.16));\n    float a = radians(30.0);\n    uv.x = abs(uv.x);\n    uv.y-=0.3;\n    d = max(dot(uv,vec2(cos(a),sin(a))),d);\n    col = mix(col,buildingMaterial(uv,vec3(0.05),60.),S(d,0.0));\n    uv.x = abs(uv.x)-0.05;\n    uv.y+=0.13;\n    d = B(uv,vec2(0.01,0.01));\n    col = mix(col,vec3(0.5,0.0,0.0),S(d,0.0));\n\n    uv = prevUV;\n    uv.x+=iTime*0.3;\n    uv*=1.2;\n    uv.y+=0.1;\n    uv.x-=0.3;\n    uv.x = mod(uv.x,0.6)-0.3;\n    d = B(uv,vec2(0.1,0.22));\n    uv.x = abs(uv.x);\n    uv.y-=0.36;\n    d = max(dot(uv,vec2(cos(a),sin(a))),d);\n    col = mix(col,buildingMaterial(uv,vec3(0.05),80.),S(d,0.0));\n    \n    \n    // road\n    uv = prevUV;\n    col = mix(col,vec3(0.3),S(uv.y+0.2,0.0));\n    col = mix(col,vec3(0.4),S(uv.y+0.25,0.0));\n    col = mix(col,vec3(0.5),S(uv.y+0.45,0.0));\n    \n    uv.x+=iTime*0.3;\n    uv.x = mod(uv.x,0.4)-0.2;\n    uv.y+=0.34;\n    d = B(uv,vec2(0.1,0.002));\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    // street rights\n    uv = prevUV;\n    uv.x+=iTime*0.28;\n    uv.x = mod(uv.x,0.4)-0.2;\n    uv.y+=0.18;\n    col = streetLight(uv,col);\n    \n    // cars\n    uv = prevUV;\n    uv.x+=iTime*0.4;\n    uv.x = mod(uv.x,0.15)-0.075;\n    uv.y+=0.28;\n    col = car(uv,col);\n    \n    uv = prevUV;\n    uv.x-=iTime*0.2-0.075;\n    uv.x = mod(uv.x,0.15)-0.075;\n    uv.y+=0.4;\n    col = car(uv,col);\n    \n    // street rights\n    uv = prevUV;\n    uv.x+=iTime*0.28;\n    uv.x = mod(uv.x,0.4)-0.2;\n    uv.y+=0.43;\n    col = streetLight(uv,col);    \n    \n    // chopper\n    uv = prevUV;\n    uv.x+=iTime*0.6-0.6;\n    uv.x = mod(uv.x,2.6)-1.3;\n    uv.y-=0.2;\n    col = chopper(uv,col);\n    \n    // test codes\n    uv = prevUV;\n    //col = streetLight(uv,col);\n    \n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    fragColor = vec4(col, 1.0)+(hash(uv*iTime*0.1))*0.13;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcXzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 224, 224, 339], [341, 341, 365, 365, 776], [778, 778, 824, 824, 943], [945, 945, 987, 987, 1182], [1184, 1184, 1237, 1237, 1409], [1411, 1411, 1431, 1431, 1644], [1646, 1646, 1666, 1666, 1969], [1971, 1971, 1998, 1998, 3172], [3174, 3174, 3216, 3216, 3604], [3606, 3606, 3637, 3637, 5361], [5363, 5363, 5398, 5398, 5831], [5833, 5833, 5890, 5890, 9090]], "test": "untested"}
{"id": "7l3Xzs", "name": "Zoom Swap", "author": "eiffie", "description": "The center green square is replaced by a red diamond while zooming out. Can you  see why line 5 breaks the illusion?", "tags": ["illusion"], "likes": 2, "viewed": 316, "published": 3, "date": "1639584923", "time_retrieved": "2024-07-30T18:41:52.865927", "image_code": "//Zoom Swap Illusion by eiffie\n//While zooming out the green square in the center is replaced by a red diamond.\n#define time (iTime-2.)\nvoid mainImage( out vec4 O, in vec2 U ){\n    //U-=.5;//uncomment to break illusion\n    vec2 uv = (2.*U-iResolution.xy)/iResolution.x;\n    vec2 p=abs(2.*fract(uv*time*15.)-1.);//tile and zoom out\n    float g=min(p.x,p.y)-.25;            //green squares\n    float r=1.-p.x-p.y;                  //red diamonds\n    O = vec4(r,g,0,0)*(1.-length(uv));\n}", "image_inputs": [], "sound_code": "vec2 mainSound( int samp, float time )\n{//ByteBeats\n  int t=int(time*88200.+.5);\n  vec2 v=vec2((t*(t>>9 & t>>14))%256,((t+32)*(t>>8 & t>>12))%256)/256.-.5;\n  return sin(v*6.283)*sin(vec2(time,time+1.57))*clamp(time*.025,.0,.25);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3Xzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 136, 176, 218, 484]], "test": "untested"}
{"id": "sl3Szs", "name": "simple detailed fluid", "author": "lomateron", "description": "made the simples possible code to make a fluid using only convolutions\nsimpler form https://www.shadertoy.com/view/7t3SDf", "tags": ["convolution"], "likes": 104, "viewed": 2000, "published": 3, "date": "1639580360", "time_retrieved": "2024-07-30T18:41:53.650828", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    vec4 a = texture(iChannel0,u);\n    fragColor = a.z*(+sin(a.x*4.+vec4(1,3,5,4))*.2\n                     +sin(a.y*4.+vec4(1,3,2,4))*.2+.6);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec2 v = u/iResolution.xy;\n    vec4 a = A(u);\n    vec2 m = +a.xy                      //fluid velocity\n             -vec2(0,1)*.01             //gravity\n             +float(v.x<.05)*vec2(1,0)  //wall\n             +float(v.y<.05)*vec2(0,1)  //wall\n             -float(v.x>.95)*vec2(1,0)  //wall\n             -float(v.y>.95)*vec2(0,1); //wall\n    float s = 0.;\n    float z = 4.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n      vec2 c = -m+vec2(i,j);//translate the gaussian 2Dimage using the velocity\n      s += exp(-dot(c,c));  //calculate the gaussian 2Dimage\n    }}\n    if(s==0.){s = 1.;}      //avoid division by zero\n              s = 1./s;\n    fragColor = vec4(m,s,0);//velocity in .xy\n                            //convolution normalization in .z\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  o = vec4(0);\n    float z = 4.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n      vec4  a = A(u+vec2(i,j));        //old velocity in a.xy, mass in a.z\n      vec4  b = B(u+vec2(i,j));        //new velocity in b.xy, normalization of convolution in .z\n      vec2  c = -b.xy-vec2(i,j);       //translate the gaussian 2Dimage\n      float s = a.z*exp(-dot(c,c))*b.z;//calculate the normalized gaussian 2Dimage multiplied by mass\n      vec2  e = c*(a.z-.8);            //fluid expands or atracts itself depending on mass\n      o.xy += s*(b.xy+e);              //sum all translated velocities\n      o.z  += s;                       //sum all translated masses\n    }}\n    float tz = 1./o.z;\n    if(o.z==0.){tz = 0.;}              //avoid division by zero\n    o.xy *= tz;                        //calculate the average velocity\n    if(iMouse.z>0.)                    //mouse click adds velocity\n    {\n        vec2 m = 8.*(u-iMouse.xy)/iResolution.y;\n        o += vec4(m,0,0)*.1*exp(-dot(m,m));\n    }\n    if(iFrame==0)\n    {\n        vec2 m = 3.*(u-iResolution.xy*.5)/iResolution.y;\n        o = vec4(0,0,1,1)*exp(-dot(m,m));\n    }\n    fragColor = o;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3Szs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 240]], "test": "untested"}
{"id": "fl3XRf", "name": "Pinching", "author": "Wykes", "description": "Click and drag", "tags": ["shapingfunctions"], "likes": 0, "viewed": 199, "published": 3, "date": "1639558603", "time_retrieved": "2024-07-30T18:41:54.459666", "image_code": "float plot(vec2 st, float pct){\n\n  return  smoothstep( pct-0.2, pct, st.y) -\n\n          smoothstep( pct, pct+0.1, st.y);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n    \n    st = (st * 2.0-1.0) * 1.0;\n\n    st.x = st.x/1.0;\n\n    //st.y = st.y+0.672;\n    \n    vec2 m = iMouse.xy / iResolution.xy; \n    m  = (m * 2.0-1.0) * 1.0;\n\n    float y =0.184;\n\n    y = sin(cos(st.x) + st.y) - m.x/(3.944*(st.y) + 2.0*(st.x));\n\n    float plt = plot(st,y);\n\n    \n\n    vec3 colour = vec3(y);\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+st.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(colour,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3XRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 123], [126, 126, 183, 233, 736]], "test": "untested"}
{"id": "Nl3XRf", "name": "Circus", "author": "Wykes", "description": "Click and drag", "tags": ["shapingfunctions"], "likes": 1, "viewed": 169, "published": 3, "date": "1639558388", "time_retrieved": "2024-07-30T18:41:55.245564", "image_code": "float plot(vec2 st, float pct){\n\n  return  smoothstep( pct-0.7, pct, st.y) -\n\n          smoothstep( pct, pct+0.684, st.y);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n    st = (st*2.0 - -0.016) * 0.216 ;\n    float y = 0.0;\n\n    y = (((sin( st.y / 0.270 ) + st.x / -1.896) + fract( st.x / -4.066 )) + fract( st.x / st.y*2.592 )) * m.y;\n\n    vec3 col = vec3(y);\n\n    float pct = plot(st,y);\n\n    col = vec3(pct);\n\n    // Time varying pixel color\n    //col = 0.5 + 0.5*cos(iTime+st.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3XRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 125], [128, 128, 185, 235, 704]], "test": "untested"}
{"id": "ftcXRf", "name": "Candy Wrapper", "author": "Wykes", "description": ".", "tags": ["shapingfunctions"], "likes": 1, "viewed": 167, "published": 3, "date": "1639558099", "time_retrieved": "2024-07-30T18:41:56.012514", "image_code": "//out vec4 fragColor;\n\nfloat plot(vec2 st, float pct){\n\n  return  smoothstep( pct-0.7, pct, st.y) - smoothstep( pct, pct+0.684, st.y);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n    \n    st = (st*2.0 - 1.0) * 1.0 ;\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    m = (m*2.0 - 1.0);\n\n    float y = 0.0;\n\n    y = (((sin( st.y / 100.334 ) + st.x / -2.224) + fract( st.x / -0.282 )) + fract( st.x / st.y )) * m.y;\n\n\n\n    vec3 color = vec3(y);\n\n\n\n    float pct = plot(st,y);\n\n    color = vec3(pct);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+st.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcXRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 54, 54, 137], [139, 139, 196, 246, 753]], "test": "untested"}
{"id": "flcXRl", "name": "L1 To Spherical Coordinates", "author": "paniq", "description": "left: octahedral normal mapping, right: collignon quincuncial projection", "tags": ["2d", "vector", "library", "graphics"], "likes": 20, "viewed": 682, "published": 3, "date": "1639555906", "time_retrieved": "2024-07-30T18:41:56.968957", "image_code": "// if defined, shows how the spherical L1 arclength mapping is tilable in 2D\n//#define SHOW_TILING\n\n// if defined, shows latitude/longitude lines\n#define SHOW_FLOW_LINES\n\n// if defined, shows an environment map instead of a XYZ color gradient\n// for inverse mode, demonstrates texture mapping\n//#define SHOW_CUBEMAP\n\n// if defined, shows the latitude as cos(theta) instead of theta\n//#define SHOW_COS_THETA\n\n// if defined, shows a UV tesselation of quadliterals, and the proportional\n// difference between the quadliteral area and the expected average size (pi/N)\n// if FIX_EQUAL_AREA is defined, the proportions will be ideal.\n//#define SHOW_SOLID_ANGLE\n\n// if defined, adjusts the latitude so that equal spaced points on the map\n// are equal spaced on the sphere; if not defined, the latitude will map\n// exactly to the L1 radius.\n#define FIX_EQUAL_AREA\n\n// if not defined, computes a more accurate solid angle from cosines,\n// though the precision of this method is terrible and is only relevant\n// for rough tesselations anyway.\n#define USE_TRIANGLE_AREA\n\n// if defined, demonstrate the inverse mapping \n//#define SHOW_INVERSE\n#define SHOW_GUYOU_MAP\n\n// subdivisions per quadrant\n#if defined(SHOW_SOLID_ANGLE)||defined(SHOW_INVERSE)\n#undef SHOW_FLOW_LINES\n// solid angle subdivisions\nconst float subdivisions = 16.0;\n#else\n// flow line subdivisions\nconst float subdivisions = 8.0;\n#endif\n\n// thesis related functions\n//////////////////////////////////////////////////////////\n\nvec2 oct_wrap (vec2 v) {\n    return (1.0 - abs(v.yx)) * sign(v);\n}\n\n// https://jcgt.org/published/0003/02/01/\n// uv is [-1..1]x[-1..1]\nvec3 octahedral_surface(vec2 uv) {\n    float z = 1.0 - abs(uv.x) - abs(uv.y);\n    return vec3((z >= 0.0)?uv:oct_wrap(uv), z);\n}\n\n// spherical coordinates from points on L1 surface\nvec2 L1_to_spherical(vec3 o) {\n    // L1 to L2 arclength\n    float r = abs(o.x) + abs(o.y);\n    float h = 1.0 - o.x / r;\n    // phi = half the L1 arclength * pi/2\n    float phi = (r == 0.0)?0.0:((o.y >= 0.0)?h: -h) * radians(90.0);\n    // L1 to L2 radius\n#ifdef FIX_EQUAL_AREA\n    // inverse of https://en.wikipedia.org/wiki/Collignon_projection\n    float z = 1.0 - abs(o.z);    \n    float theta = radians(90.0) - asin(1.0 - z*z)*sign(o.z);\n#else\n    float theta = (1.0 - o.z) * radians(90.0);\n#endif\n    return vec2(phi, theta);\n}\n\n// uv is [-pi..pi]x[0..pi]\nvec3 spherical_surface(vec2 uv) {\n    float phi_s = sin(uv.x);\n    float phi_c = cos(uv.x);\n    float theta_s = sin(uv.y);\n    float theta_c = cos(uv.y);\n    return vec3(\n        theta_s * phi_c,\n        theta_s * phi_s,\n        theta_c\n    );\n}\n\n// [0..1]x[0..1]+offset -> [-1..1]x[-1..1]\n// https://en.wikipedia.org/wiki/Peirce_quincuncial_projection\nvec2 tile_quincuncial(vec2 p) {\n    p = mod(p, 2.0);\n    ivec2 q = ivec2(p);\n    vec2 uv = p - vec2(q);\n    return (uv*2.0-1.0)*((((q.x ^ q.y) & 1) != 0)?-1.0:1.0);\n}\n\n// [0..2]x[0..1]+offset -> [-1..1]x[-1..1]\n// https://en.wikipedia.org/wiki/Guyou_hemisphere-in-a-square_projection\nvec2 tile_guyou(vec2 p) {\n    p = vec2(p.x + p.y, p.y - p.x + 1.0)/2.0;\n    return tile_quincuncial(p);\n}\n\n//// inversion\n\n// n is a normal vector\nvec2 spherical_coordinates(vec3 n) {\n    return vec2(atan(n.y, n.x), acos(n.z));\n}\n\n// point on L1 surface from spherical coordinates\nvec3 spherical_to_L1(vec2 uv) {\n    // L2 to L1 radius\n#ifdef FIX_EQUAL_AREA\n    // forward formula of https://en.wikipedia.org/wiki/Collignon_projection\n    float theta = radians(90.0) - uv.y;\n    float z = (1.0 - sqrt(1.0 - sin(abs(theta))))*sign(theta);\n#else\n    float z = 1.0 - uv.y / radians(90.0);\n#endif\n    // L2 to L1 arclength\n    float a = uv.x / radians(45.0);\n    float r = 1.0 - abs(z);\n    a = mod(a + 4.0, 8.0) - 4.0;\n    float cos_x = 1.0 - abs(a) / 2.0;\n    vec2 xy = r * vec2(cos_x, sign(a)*(1.0 - abs(cos_x)));\n    return vec3(xy, z);\n}\n\nvec3 L1normalize(vec3 n) {\n    return n / (abs(n.x) + abs(n.y) + abs(n.z));\n}\n\n// n is a point on the L1 surface\nvec2 octahedral_coordinates(vec3 n) {\n    //n = L1normalize(n); // not necessary if point is already normalized\n    return (n.z >= 0.0)?n.xy:oct_wrap(n.xy);\n}\n\n// [-1..1]x[-1..1] -> [0..2]x[0..1]\nvec2 inverse_guyou(vec2 o) {    \n    o = vec2(o.x - o.y + 1.0/2.0, o.x + o.y - 1.0/2.0);\n    o += vec2(-0.5, 0.5);\n    if (o.y >= 1.0) {\n        o = 2.0 - o;        \n    } else if (o.x < -1.0) {\n        o.x = o.x + 4.0;\n    } else if (o.y < -1.0) {\n        o = vec2(2.0,-2.0) - o;\n    }\n    return (o+1.0)/2.0;\n}\n\n// visualization\n//////////////////////////////////////////////////////////\n\nfloat triangle_area(vec3 A, vec3 B, vec3 C) {\n    return length(cross(B - A, C - A)) / 2.0;\n}\n\nvec2 nanglebasis (vec3 a, vec3 b) {\n    float ab = dot(a, b);\n    return vec2(ab, sqrt(1.0 - ab * ab));\n}\n\nfloat simplex_solid_angle (vec2 u, vec2 v, vec2 w) {\n    float A =\n            acos((u.x - v.x * w.x) / (v.y * w.y))\n            + acos((v.x - w.x * u.x) / (w.y * u.y))\n            + acos((w.x - u.x * v.x) / (u.y * v.y))\n            - radians(180.0);\n    return (A != A)?0.0:A;\n}\n\nfloat pyramid_points_solid_angle (vec3 A, vec3 B, vec3 C, vec3 D) {\n#ifdef USE_TRIANGLE_AREA\n    return triangle_area(A, B, C) + triangle_area(C, D, A);\n#else\n    vec2 ab = nanglebasis(A, B);\n    vec2 ac = nanglebasis(A, C);\n    vec2 da = nanglebasis(A, D);\n    vec2 bc = nanglebasis(B, C);\n    vec2 cd = nanglebasis(C, D);\n    return simplex_solid_angle(bc, ac, ab) + simplex_solid_angle(da, ac, cd);\n#endif\n}\n\nvec3 plasma(float t) {\n\n    const vec3 c0 = vec3(0.05873234392399702, 0.02333670892565664, 0.5433401826748754);\n    const vec3 c1 = vec3(2.176514634195958, 0.2383834171260182, 0.7539604599784036);\n    const vec3 c2 = vec3(-2.689460476458034, -7.455851135738909, 3.110799939717086);\n    const vec3 c3 = vec3(6.130348345893603, 42.3461881477227, -28.51885465332158);\n    const vec3 c4 = vec3(-11.10743619062271, -82.66631109428045, 60.13984767418263);\n    const vec3 c5 = vec3(10.02306557647065, 71.41361770095349, -54.07218655560067);\n    const vec3 c6 = vec3(-3.658713842777788, -22.93153465461149, 18.19190778539828);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a); float s = sin(a);\n    return vec2(p.x*c + p.y*s, s*p.x - c*p.y);\n}\n\nvec3 stereographic_sphere(vec2 uv) {\n    vec3 n = vec3(uv, sqrt(1.0 - dot(uv,uv)));\n    float t = iTime*0.1;\n    n.yz = rotate(n.yz, radians(sin(t*0.25*radians(360.0))*45.0));    \n    n.xz = rotate(n.xz, t*radians(360.0));    \n    return n;\n}\n\n//////////////////////////////////////////////////////////\n\n// for inverse mapping\nvec3 transfer_color(vec2 q) {\n#ifdef SHOW_GUYOU_MAP\n    q = inverse_guyou(q);\n    // mirror U coordinate (0-1-0)\n    q.x = 1.0-abs(1.0-q.x);\n#else\n    q = q*0.5 + 0.5;\n#endif\n#ifdef SHOW_CUBEMAP\n    return textureLod(iChannel1, q*4.0, 2.0).rgb;\n#else\n    q = q - mod(q, 1.0/subdivisions);\n    return vec3(q, 0.0);\n#endif\n}\n\nvec3 transfer_color(vec3 p) {\n#ifdef SHOW_CUBEMAP\n    p.xy = rotate(p.xy, radians(90.0 + 45.0));\n    p.xz = rotate(p.xz, radians(90.0));\n    return textureLod(iChannel0, p, 0.0).xyz;\n#elif defined(SHOW_INVERSE)\n    vec2 q = octahedral_coordinates(spherical_to_L1(spherical_coordinates(p)));\n    q = q - mod(q, 1.0/subdivisions);\n    return vec3(q*0.5 + 0.5, 0.0);\n#else\n    return p*0.5 + 0.5;\n#endif\n}\n\nfloat flow_lines(vec3 q) {\n    float a = atan(q.y, q.x);\n#ifdef SHOW_COS_THETA\n    float r = q.z*radians(90.0);\n#else\n    float r = acos(q.z);\n#endif\n    float A = subdivisions;\n    return sin((a-iTime*0.1)*2.0*A)*sin(r*A);\n}\n\nfloat octahedral_map_flow_lines(vec2 p) {\n    return flow_lines(normalize(octahedral_surface(p)));    \n}\n\nfloat octahedral_arc_map_flow_lines(vec2 p) {\n    return flow_lines(spherical_surface(L1_to_spherical(octahedral_surface(p))));\n}\n\nfloat tiled_octahedral_arc_map_flow_lines(vec2 p) {\n    return flow_lines(spherical_surface(L1_to_spherical(octahedral_surface(tile_guyou((p-1.0)/2.0)))));\n}\n\nbool in_range(vec2 p) {\n    return max(abs(p.x),abs(p.y)) < 1.0;\n}\n\nvec3 solid_angle_color(vec3 p00, vec3 p10, vec3 p01, vec3 p11) {\n    // ideal solid angle: pi / subdivisions\n    float isa = radians(180.0) / (subdivisions * subdivisions);\n    float sa1 = pyramid_points_solid_angle(p00,p10,p11,p01);\n    float sa2 = pyramid_points_solid_angle(p10,p00,p01,p11);\n    float sa = (uv.x*uv.y < 0.0)?sa1:sa2;\n#if 1\n    sa = abs(sa/isa-1.0);\n#else\n    sa = abs(log2(sa/isa));\n#endif\n    return plasma(clamp(sa,0.0,1.0));\n}\n\nvoid paint_octahedral_map() {\n    set_line_width_px(1.2);\n    vec2 uv = get_origin();    \n    vec3 p = normalize(octahedral_surface(uv));\n    set_source_rgb(transfer_color(p));\n#ifdef SHOW_SOLID_ANGLE\n    float s = 1.0/subdivisions;\n    uv = uv - mod(uv, s) + s * 0.5;\n    vec2 w = 0.5*vec2(-s,s);\n    vec3 p00 = normalize(octahedral_surface(uv + w.xx));\n    vec3 p10 = normalize(octahedral_surface(uv + w.yx));\n    vec3 p01 = normalize(octahedral_surface(uv + w.xy));\n    vec3 p11 = normalize(octahedral_surface(uv + w.yy));\n    set_source_rgb(solid_angle_color(p00,p10,p01,p11));\n#endif        \n    rectangle(-1.0, -1.0, 2.0, 2.0);    \n    fill_preserve();    \n    set_source_rgb(vec3(0.0));\n    stroke();\n#ifdef SHOW_FLOW_LINES    \n    if (in_range(get_origin())) {\n        graph2D(octahedral_map_flow_lines);\n        stroke();\n    }\n#endif\n}\n\nvoid paint_inverse_octahedral_map() {\n    set_line_width_px(1.2);\n    vec3 n = stereographic_sphere(get_origin());     \n    vec2 uv = octahedral_coordinates(L1normalize(n));    \n    set_source_rgb(transfer_color(uv));\n    circle(0.0, 0.0, 1.0);\n    fill_preserve();    \n    set_source_rgb(vec3(0.0));\n    stroke();\n}\n\nvoid tile_octahedral_arc_map() {\n    set_line_width_px(1.5);\n#if 1\n    vec3 p = spherical_surface(L1_to_spherical(octahedral_surface(tile_guyou((get_origin()+1.0)/2.0))));\n    set_source_rgb(transfer_color(p));\n#else\n    vec2 uv = (get_origin()+1.0)/2.0;\n    #if 1\n    uv = fract(uv);\n    uv = uv*2.0-1.0;\n    #endif\n    #if 1\n    //uv = tile_guyou(uv);\n    uv = inverse_guyou(uv);\n    #else\n    uv = tile_quincuncial(uv);\n    #endif\n    uv = uv*0.5+0.5;\n    if (min(uv.x,uv.y) < 0.0)\n        return;\n    if (uv.x > 2.0)\n        return;   \n    if (uv.y > 1.0)\n        return; \n    float b = clamp(uv.x - 1.0, 0.0, 1.0);\n    uv.x = fract(uv.x);\n    set_source_rgb(vec3(uv,b));\n#endif\n    clear();\n    rectangle(-1.0, -1.0, 4.0, 2.0);\n    set_source_rgb(vec3(0.0));\n    stroke();\n#ifdef SHOW_FLOW_LINES\n    set_source_rgb(vec3(0.0));\n    graph2D(tiled_octahedral_arc_map_flow_lines);\n    stroke();\n#endif\n}\n\nvoid paint_octahedral_arc_map() {\n    set_line_width_px(1.2);\n    \n    vec2 uv = get_origin();    \n    vec3 p = spherical_surface(L1_to_spherical(octahedral_surface(uv)));\n    set_source_rgb(transfer_color(p));\n#ifdef SHOW_SOLID_ANGLE\n    float s = 1.0/subdivisions;\n    uv = uv - mod(uv, s) + s * 0.5;\n    vec2 w = 0.5*vec2(-s,s);\n    vec3 p00 = spherical_surface(L1_to_spherical(octahedral_surface(uv + w.xx)));\n    vec3 p10 = spherical_surface(L1_to_spherical(octahedral_surface(uv + w.yx)));\n    vec3 p01 = spherical_surface(L1_to_spherical(octahedral_surface(uv + w.xy)));\n    vec3 p11 = spherical_surface(L1_to_spherical(octahedral_surface(uv + w.yy)));\n    set_source_rgb(solid_angle_color(p00,p10,p01,p11));\n#endif    \n    rectangle(-1.0, -1.0, 2.0, 2.0);\n    fill_preserve();    \n    set_source_rgb(vec3(0.0));\n    stroke();\n#ifdef SHOW_FLOW_LINES\n    if (in_range(get_origin())) {\n        graph2D(octahedral_arc_map_flow_lines);\n        stroke();\n    }\n#endif\n}\n\nvoid paint_inverse_octahedral_arc_map() {\n    set_line_width_px(1.2);\n    vec3 n = stereographic_sphere(get_origin());     \n    vec2 uv = octahedral_coordinates(spherical_to_L1(spherical_coordinates(n)));\n    set_source_rgb(transfer_color(uv));\n    circle(0.0, 0.0, 1.0);\n    fill_preserve();\n    set_source_rgb(vec3(0.0));\n    stroke();\n}\n\nvoid paint() {\n    set_source_rgb(vec3(0.2));\n    clear();\n\n#ifdef SHOW_TILING\n    scale(0.5);\n    tile_octahedral_arc_map();\n#elif defined(SHOW_INVERSE)\n    scale(0.75);\n    if (get_origin().x < 0.0) {\n        translate(-1.1,0.0);\n        paint_inverse_octahedral_map();\n    } else {\n        translate(1.1,0.0);\n        paint_inverse_octahedral_arc_map();\n    }\n#else\n    scale(0.75);\n    if (get_origin().x < 0.0) {\n        translate(-1.1,0.0);\n        paint_octahedral_map();\n    } else {\n        translate(1.1,0.0);\n        paint_octahedral_arc_map();\n    }\n#endif    \n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord, iMouse.xy, iResolution.xy);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.16\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2020-12-02: 0.16\n// * support for drawing concentric rings\n\n// 2020-11-30: 0.15\n// * support for drawing orthogonal grids\n// * adjusted uv so corners are centered on pixels\n// * small adjustment to line pixel width computation\n\n// 2020-11-12: 0.14\n// * added support for depth testing\n\n// 2020-11-11: 0.13\n// * fixed 2D graphs not filling\n// * added circle_px()\n\n// 2019-06-06: 0.12\n// * split implementation and demo into common and image tab\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\nvoid set_source_depth(float depth);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the old source with the new one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n// if enabled, use the depth value for testing;\n// smaller values win\nvoid depth_test(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add a circle path at P with pixel radius R\nvoid circle_px(vec2 p, float r);\nvoid circle_px(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// add an orthogonal grid with cell size S\nvoid grid(vec2 s);\nvoid grid(float w, float h);\nvoid grid(float s);\n// draw concentric rings around origin p, with spacing r and offset phase\nvoid rings(vec2 p, float r, float phase);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// draw a letter with the given texture coordinate\nvoid letter(sampler2D font_texture_source, ivec2 l);\nvoid letter(sampler2D font_texture_source, int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    bool depth_test;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n    float source_z;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n#define DEFAULT_DEPTH 1e+30\n\nContext _stack;\n\nvoid init (vec2 fragCoord, vec2 mouse, vec2 resolution) {\n\taspect = vec2(resolution.x / resolution.y, 1.0);\n\tScreenH = min(resolution.x,resolution.y);\n\tAA = ScreenH*0.5;\n\tAAINV = 1.0 / AA;\n    \n    uv = (fragCoord.xy - 0.5) / resolution;\n    vec2 m = mouse / resolution;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false,\n        DEFAULT_DEPTH\n    );\n}\n\nvec3 _color = vec3(1);\nfloat _depth = DEFAULT_DEPTH;\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color.rgb = mix(_color.rgb, _stack.source.rgb, _stack.source.a);\n    _depth = (_stack.source.a == 1.0)?_stack.source_z:_depth;\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(pow(_color.rgb, vec3(1.0/2.2)), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color.rgb;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    if (_stack.depth_test) {\n        if ((w == 1.0) && (_stack.source_z <= _depth)) {\n            _depth = _stack.source_z;\n        } else if ((w == 0.0) || (_stack.source_z > _depth)) {            \n            return;\n        }\n    }\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color.rgb = _color.rgb * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\n\nvoid depth_test(bool enable) {\n    _stack.depth_test = enable;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_depth(float depth) {\n    _stack.source_z = depth;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(sampler2D font_texture_source, ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(sampler2D font_texture_source, int lx, int ly) {\n    letter(font_texture_source, ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid grid(vec2 size) {\n    vec4 f = abs(fract(_stack.position/size.xyxy+0.5)-0.5)*size.xyxy;\n    add_field(vec2(min(f.x,f.y),min(f.z,f.w)));\n}\nvoid grid(float w, float h) {\n    grid(vec2(w,h));\n}\nvoid grid(float s) {\n    grid(vec2(s));\n}\nvoid rings(vec2 p, float r, float phase) {\n    vec4 q = _stack.position - p.xyxy;\n    vec2 f = abs(fract(vec2(length(q.xy),length(q.zw))/r-phase+0.5)-0.5)*r;\n    add_field(f);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid circle_px(vec2 p, float r) {\n    circle(p, r/(0.5*ScreenH));\n}\nvoid circle_px(float x, float y, float r) {\n    circle_px(vec2(x,y), r);\n}\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(f_x / length(df_x));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcXRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1483, 1483, 1507, 1507, 1549], [1551, 1618, 1652, 1652, 1745], [1747, 1798, 1828, 1854, 2329], [2331, 2358, 2391, 2391, 2603], [2605, 2711, 2742, 2742, 2877], [2879, 2995, 3020, 3020, 3100], [3118, 3142, 3178, 3178, 3224], [3226, 3276, 3307, 3330, 3833], [3835, 3835, 3861, 3861, 3912], [3914, 3948, 3985, 4059, 4106], [4108, 4144, 4172, 4172, 4456], [4535, 4535, 4580, 4580, 4628], [4630, 4630, 4665, 4665, 4735], [4737, 4737, 4789, 4789, 5016], [5018, 5018, 5085, 5085, 5428], [5430, 5430, 5452, 5452, 6106], [6108, 6108, 6138, 6138, 6227], [6229, 6229, 6265, 6265, 6471], [6533, 6556, 6585, 6585, 6878], [6880, 6880, 6909, 6909, 7282], [7284, 7284, 7310, 7310, 7509], [7511, 7511, 7552, 7552, 7615], [7617, 7617, 7662, 7662, 7746], [7748, 7748, 7799, 7799, 7905], [7907, 7907, 7930, 7930, 7973], [7975, 7975, 8039, 8085, 8426], [8428, 8428, 8457, 8457, 9273], [9275, 9275, 9312, 9312, 9591], [9593, 9593, 9625, 9625, 10497], [10499, 10499, 10532, 10532, 11470], [11472, 11472, 11513, 11513, 11811], [11813, 11813, 11827, 11827, 12387], [12449, 12449, 12506, 12506, 12592]], "test": "untested"}
{"id": "ftcSRl", "name": "2d Path tracing try 3", "author": "MinimilisticBits", "description": "Worked on this renderer all night, I'm quite happy how it turned out.", "tags": ["2d", "pathtracing"], "likes": 11, "viewed": 499, "published": 3, "date": "1639554974", "time_retrieved": "2024-07-30T18:41:57.947341", "image_code": "//NOT MY CODE//////////////////////\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.,1.);\n}\n//////////////////////////////////\n\nvec3 blur(vec2 uv, float r){\nvec3 c = vec3(0.);\nuv *= iResolution.xy;\nfloat iter = 0.;\nfor(int i = 0; i < 10; i++){\n  for(int k = 0; k < 10; k++){\n     float x = float(k)-5.;\n     float y = float(i)-5.;\n     x*=r;\n     y*=r;\n     //float bok = texture(iChannel1, vec2(0.5)+((vec2(x,y)*6.)/iResolution.xy)).y;\n     vec4 c2 = texture(iChannel0, (uv+vec2(x,y))/iResolution.xy).xyzw;\n     vec3 col = c2.xyz / (c2.w+1.);\n     //if(length(col) > 0.6)col*=1.2;\n     c += col;\n     iter+=1.;\n  }\n}\nc/=iter;\nreturn c;\n} \n\n\nvec3 blur2(vec2 p,float dist){\np*=iResolution.xy;\n    vec3 s;\n    \n    vec3 div = vec3(0.);\n    //vec2 off = vec2(0.0, r);\n    float k = 0.61803398875;\n    for(int i = 0; i < 150; i++){\n    float m = float(i)*0.01;\n    float r = 2.*3.14159*k*float(i);\n    vec2 coords = vec2(m*cos(r), m*sin(r))*dist;\n    vec4 c2 = texture(iChannel0, (p+coords)/iResolution.xy).xyzw;\n    vec3 c = c2.xyz / (c2.w+1.);\n    //c = c*c *1.8;\n    vec3 bok = pow(c,vec3(4.));\n      s+=c*bok;\n      div += bok;\n    }\n        \n    s/=div;\n    \n    return s;\n    \n}\nvec2 rot(vec2 a, float c){\nc = c*3.14159/180.;\nfloat l = length(a);\na/=l;\n\nfloat ang = (a.y < 0.)?2.*3.14159-acos(a.x):acos(a.x);\nang += c;\n\nreturn l*vec2(cos(ang), sin(ang));\n}\n\nfloat torus(vec2 p, vec2 s){\n    vec2 mm = normalize(p);\n    return length(mm*s.x - p) - s.y;\n}\n\nfloat box(vec2 p, vec2 s){\nvec2 a = abs(p)-s;\nreturn max(a.x,a.y);\n}\n\nfloat hex(vec2 p, float s){\nfloat box1 = box(p, vec2(s));\nvec2 pos = rot(p, 45.);\nreturn min(box1, box(pos, vec2(s)));\n}\nvec3 pal(float t, vec3 a){\nreturn 0.5 + 0.5*cos(2.*3.14159*t + a);\n}\n\nvec3 lens(vec2 p, vec2 mouse){\np*=10.;\n\nvec3 col = vec3(0.);\n\ncol += sin(texture(iChannel1, normalize(mouse-p)*0.7).x)*exp(-(length(mouse-p)-1.2)*1.);\ncol += exp(-(length(-mouse*0.5-p)-0.5)*3.);\nfor(int i = 0; i < 5; i++){\ncol += exp(-hex(-mouse*(0.2-float(i)*0.1)-p, 0.5-float(i)*0.1)*2.);\n}\n\ncol += exp(-torus(mouse*0.2-p, vec2(2., 0.01))*2.);\n\nvec3 col2 = vec3(1.)*exp(-torus(-mouse - p, vec2(6., 0.3))*20.);\ncol2 *= sin(texture(iChannel1, normalize(-mouse-p)*0.7).x)*exp(-(length(-mouse-p)-2.2)*1.);\ncol2 *= vec3(0.9,0.5,0.2);\ncol2 *= length(mouse-p)*0.04;\n\nvec3 col3 = vec3(1.)*exp(-torus(-mouse*0.2 - p, vec2(10., 2.))*4.);\ncol3 *= sin(texture(iChannel1, normalize(-mouse-p)*0.7).x)*exp(-(length(-mouse-p)-2.2)*1.);\ncol3 *= vec3(0.9,0.5,0.2);\ncol3 *= length(mouse-p)*0.04;\n\ncol += col2;\ncol += col3;\ncol*=exp(-(length(mouse-p)-4.2)*0.2);\n//col += exp(-(length(p)-4.));\n\ncol *= pal(length(mouse-p)*0.1, vec3(0.0,0.6,0.9));\ncol += exp(-(length(mouse-p)-0.6)*0.3)*vec3(0.9,0.7,0.2);\n\n//vec2 pos2 = (mouse)-p;\n//pos2 = rot(pos2, mouse.x*8.);\n//col += exp(-length(pos2*vec2(1., 0.01)))*exp(-(length(mouse*0.2-p)-4.2)*0.6);\n\nreturn col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n \n    // Time varying pixel color\n    vec4 c = texture(iChannel0, uv).xyzw;\n    vec3 col = c.xyz/(c.w+1.);\n    vec2 uf = uv * 2.0 - 1.0;\n    uf.x *= 1.3;\n    uf.y /= 1.3;\n    //vec3 col = blur2(uv, max(length(uf*14.)*1.-(9.0-length(uf*0.1)), 0.));\n    col = clamp(col,0.,1.);\n   //col *=  clamp(lensflare(uf, vec2(0.5,0.5)),0.,1.)*1.;\n    \n   /*col *=  lensflare(uf, vec2(0.5,0.5))*2.\n    + lensflare(uf, vec2(-0.5,0.5))*2.\n    + lensflare(uf, vec2(0.5,-0.5))*2.\n    +lensflare(uf, vec2(-0.5,-0.5))*2.;\n    */\n    \n    /*col *= clamp(lens(uf, vec2(5.5,5.5)),0.,1.)*2.\n    +clamp(lens(uf, vec2(-5.5,5.5)),0.,1.)*2.\n    +clamp(lens(uf, vec2(5.5,-5.5)),0.,1.)*2.\n    +clamp(lens(uf, vec2(-5.5,-5.5)),0.,1.)*2.;\ncol *= 2.;*/\n   col += lens(uf, vec2(0.))*0.1;\n    float off = texture(iChannel0, uv).w;\n     vec3 rad;\n    vec2 offset2 = (fragCoord - iResolution.xy/2.)*1.;\n    for(int i = 0; i < 20; i++){\n       vec2 offset = fragCoord + offset2*smoothstep(0.,15.-length(uv*2.0-1.)*1.5, float(i)/20.)*1.;\n       rad.x += texture(iChannel0, (offset+offset2*0.024)/iResolution.xy).x/float(off+1.);\n       rad.y += texture(iChannel0, (offset)/iResolution.xy).y/float(off+1.);\n       rad.z += texture(iChannel0, (offset-offset2*0.024)/iResolution.xy).z/float(off+1.);\n\n    }\n    rad /= 16.;\n \n    col += rad*0.1;\n    //col = ACESFilm(col);\n    col = clamp(col, 0., 1.);\n     col = vec3(1.)-exp(-.3*col);\n\n    //NOT MY CODE//////////////////\n    vec3 a = vec3(0.3,0.3,0.4)-0.4;\n    col = mix(col, smoothstep(0.,1.,col),a);\n    //////////////////////////////\n    // Output to screen\n    vec3 aa = vec3(1.0,1.1,1.1);\n    col = sqrt(col/aa);\n    col = (1.0/((1.0)+exp(-(10.)*(col-0.5))));\ncol = pow(col, vec3(1.3))*1.8;\ncol = pow(col, vec3(0.9,0.99,0.9));\ncol = ACESFilm(col);\n    col = pow(col, vec3(1./2.2));\n//uv = uv * 2.0 - 1.0;\n//uv.x *= 1.3;\n//uv.y /= 1.3;\n//col *= (1.0-length(uv*0.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 rot(vec2 a, float c){\nc = c*3.14159/180.;\nfloat l = length(a);\na/=l;\n\nfloat ang = (a.y < 0.)?2.*3.14159-acos(a.x):acos(a.x);\nang += c;\n\nreturn l*vec2(cos(ang), sin(ang));\n}\nvec3 pal(float t, vec3 a){\nreturn 0.5 + 0.5*cos(2.*3.14159*t + a);\n}\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat rndf(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\n\nfloat box(vec2 p, vec2 s){\nvec2 a = abs(p)-s;\nreturn max(a.x, a.y);\n}\n\nfloat torus(vec2 p, vec2 s){\nreturn length((normalize(p)*s.x)-p)-s.y;\n}\n\nvec3 l = vec3(0.);\nbool ref = false;\nvec3 c = vec3(1.);\nvec2 hash2( vec2 p )\n{\n\treturn textureLod( iChannel1, (p+0.5)/256.0, 0.0 ).xy;\n}\nvec2 voronoi(vec2 p){\nvec2 f = floor(p);\nvec2 res = vec2(8.);\nfor(int i = 0; i < 9; i++){\nvec2 coords = f + vec2(mod(float(i),3.)-1., float(i/3)-1.);\nvec2 o = hash2( coords );\no = 0.5 + 0.4*sin(6.2831*o );\nvec2 pos = (coords+o);\nfloat d = dot(pos-p,pos-p);\nif( d < res.x )\n{\n    res.y = res.x;\n    res.x = d;\n}\nelse if( d < res.y )\n{\n    res.y = d;\n}\n}\nreturn res;\n}\nfloat jb(vec3 p){\n    float s=3., e;\n    s*=e=3./min(dot(p,p),50.);\n    p=abs(p)*e;\n  //  escape = 0.;\n    for(int i=0;i++<17;){\n        p=vec3(2,4,2)-abs(p-vec3(2,4,2)),\n            s*=e=8./min(dot(p,p),10.),\n            p=abs(p)*e;\n        //    escape += exp(-0.2*dot(p,p));\n            }\n    return min(length(p.xz)-.1,p.y)/s;\n}\n/////////////////\nfloat escape = 0.;\n  float DEmine(vec3 p0){\nvec4 p = vec4(p0, 1.);\nescape = 0.;\nfor(int i = 0; i < 7; i++){\np*=4.8;\np.xyz = mod(p.xyz-1.5, 3.)-1.5;\nfloat m = length(p.xyz);\n\np/=dot(p.xyz,p.xyz)+mod(m, 1.);\nescape += exp(-0.2*dot(p.xyz,p.xyz));\n}\n\nreturn length(p.xyz)/p.w;\n}\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\nfloat dis(vec2 p){\nl = vec3(0.);\nc = vec3(1.);\n\nref = false;\n//float a2 = voronoi(p*0.5).x*0.1;\n//vec3 pos = vec3(mod(p, 4.)-2., 2.8);\n//pos.yz = rot(pos.yz, 0.);\nfloat a = torus(rot(mod(p,3.)-1.5, 45.)/1., vec2(1.5,0.1))*1.;\n// float a = voronoi(p*0.5).x*0.1;\n\nfloat a2 = DEmine(vec3(mod(p.xy*0.6, 4.)-2., 8.0))*.8;\n//float a2 = abs(torus(mod(p,2.)-1., vec2(1.9,.1)))-0.1;\n//if(length(mod(p,3.)-1.5) < 0.9 ){\n//a = -0.05;\n//}\nif(a < 0.01){\na = -0.05;\n}\nif(a2 < 0.01){\na2 = -0.05;\n}\n//float b1 = box(rot(mod(vec2(0.,0.)-p, 5.)-2.5, 0.), vec2(0.7,.4));\nfloat b2 = torus(mod(vec2(0.,0.)-p,5.)-2.5, vec2(.9,.1));\nfloat b1 = torus(vec2(0.,0.)-p, vec2(.8,.1));\n\n//b1 = box(p, vec2(.5,.5));\n//b2 = box(mod(vec2(0.,0.)-p,5.)-2.5, vec2(.3,.3));\n//b2 = box(p, vec2(.5,0.5));\n\nfloat c2 = abs(box(rot(mod(vec2(-3.,0.)-p, 5.)-2.5, 45.), vec2(1.5,0.8)))-0.1;\nfloat d = abs(box(mod(vec2(0., -1.5)-p, 5.)-2.5, vec2(.6,.6)))-0.1;\nfloat e = abs(box(rot(mod(vec2(3.,0.)-p, 5.)-2.5, -45.), vec2(1.5, 0.2)))-0.1;\nfloat fin = min(min(min(a2,a), min(b1,b2)),min(min(d,e),c2));\nfin = min(min(min(b1,b2), min(a2,a)),min(c2,min(d,e)));\nif(fin == b1 || fin == b2){l = vec3(3.);}\nif(fin == e || fin == d || fin == c2){ref = true;c = vec3(0.2,0.7,0.9);}\nif(fin == a){\n//c = vec3(0.2,0.9,0.9);\nref = false;c = vec3(0.2,0.6,0.7);\n}\nif(fin == a2){\n//c = vec3(0.2,0.9,0.9);\nref = true;c = pal(escape, vec3(0.9,0.5,0.2));\n}\nreturn fin;\n}\n\nvec3 wavetorgb(float wave){\nvec3 col = vec3(0.);\nif(wave > 410. && wave < 440.){\ncol = vec3(0.19-0.19*(440.-wave)/30., 0., 1.);\n}else if(wave > 440. && wave < 490.){\ncol = vec3(0., 1.0-(490.-wave)/50., 1.);\n}else if(wave > 490. && wave < 510.){\ncol = vec3(0., 1., (510.-wave)/20.);\n}else if(wave > 510. && wave < 580.){\ncol = vec3(1.-(580.-wave)/70., 1., 0.);\n}else if(wave > 580. && wave < 640.){\ncol = vec3(1., (640.-wave)/60., 0.);\n}else if(wave > 640. && wave < 700.){\ncol = vec3(1., 0., 0.);\n}else if(wave > 700. && wave < 780.){\ncol = vec3(0.35-0.65*(780.-wave)/80., 0., 0.);\n}\n\n\nreturn col;\n}\n\nvec2 norm(vec2 p){\nreturn normalize(vec2(\ndis(vec2(p.x+0.01, p.y))-dis(vec2(p.x-0.01, p.y)),\ndis(vec2(p.x, p.y+0.01))-dis(vec2(p.x, p.y-0.01)))\n);\n}\n\nfloat f_wavelength(float wave, float a, float b){\nreturn exp(-pow((wave-(b+a)/2.)/((b-a)/2.),2.));\n}\n\nvec3 wavetorgb3(float wave){\nreturn vec3(\nf_wavelength(wave, 520., 630.),\nf_wavelength(wave, 500., 590.),\nf_wavelength(wave, 410., 480.)\n);\n}\n\nvec3 wavetorgb2(float wave){\nreturn vec3(\nexp(-pow((wave-630.)/30.,2.))+exp(-pow((wave-430.)/10.,2.)),\nexp(-pow((wave-530.)/20.,2.)),\nexp(-pow((wave-470.)/20.,2.))\n)*2.;\n}\n\nvec3 wavetoxyz(float wave){\nfloat x = 1.065*exp(-0.5*pow((wave-595.8)/33.33,2.))+0.366*exp(-0.5*pow((wave-446.8)/19.44,2.));\nfloat y = 1.014*exp(-0.5*pow((log(wave)-log(556.3))/0.075,2.));\nfloat z = 1.839*exp(-0.5*pow((wave-449.8)/0.051,2.));\nreturn vec3(x,y,z);\n}\n\nvec3 XYZtorgb(vec3 XYZ){\nvec3 RGB = vec3(3.2404542*XYZ.x - 1.5371385*XYZ.y - 0.4985314*XYZ.z,\n-0.9692660*XYZ.x + 1.8760108*XYZ.y + 0.0415560*XYZ.z,\n0.0556434*XYZ.x - 0.2040259*XYZ.y + 1.0572252*XYZ.z\n);\nreturn RGB;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uint r = uint(uint(fragCoord.x) * uint(1973) \n    + uint(fragCoord.y) * uint(9277) \n    + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 odd = vec2(rndf(r), rndf(r))*2.0-1.0;\n    odd /= iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    uv += odd*2.;\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n    \n    int tiles = 2;\n    int samples =450;\n    float jk = float(iFrame%samples);\n\n    vec2 res = iResolution.xy / float(tiles);\n    int times = (iFrame/samples);\n    vec2 time = vec2(float(times%tiles), float((times/tiles)%(tiles)));\n    vec2 rr = res*time;\n    \n    //if(fragCoord.x < (rr.x) || fragCoord.x > (rr.x+res.x))discard;\n   //if(fragCoord.y < (rr.y) || fragCoord.y > (rr.y+res.y))discard;\n  \n    \n    vec2 p = uv*3.;\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    float ang = rndf(r)*2.*3.14159;\n    vec2 d = vec2(cos(ang), sin(ang));\n    float select = rndf(r);\n    float wave = 410. + 370.*select;\n    \n    if(dis(p) < 0.01 && ref == true ){\n        vec2 n = norm(p); \n        vec2 p2 = p;\n        for(int k = 0; k < 80; k++){\n            float dist2 = -dis(p2);\n            if(dist2 < 0.01){\n                vec2 n2 = norm(p2+d*0.02);\n                d = refract(d, -n2, select);\n                p2 += n2*0.05; \n                break;\n            }\n            p2 += d*dist2;\n        }\n        \n         p = p2;\n    }else if(dis(p) < 0.01 && ref == false && (l.x == 0. && l.y == 0. && l.z == 0.)){\n        vec2 n = norm(p); \n           // col += c*max(dot(n, vec2(0.,1.)),0.2);\n\n        vec2 p2 = p;\n        for(int k = 0; k < 80; k++){\n            float dist2 = -dis(p2);\n            if(dist2 < 0.01){\n                vec2 n2 = norm(p2+d*0.02);\n                p2 += n2*0.05; \n                break;\n            }\n            p2 += d*dist2;\n        }\n         p = p2;\n    }\n    bool firsthit = false;\n    vec2 n2 = vec2(0.);\n    vec3 c2 = vec3(0.);\n    vec3 tt = wavetorgb(wave);\n    for(int i = 0; i < 420; i++){\n        float dist = dis(p);\n        if(length(p) > 20.)break;\n        if(dist < 0.01){\n            vec2 n = norm(p-d*0.02); \n            c2 = c;\n            if(!firsthit){\n            n2 = n;\n            c2 = c;\n            firsthit = true;\n            }\n            if(ref){\n            d = refract(d,n,1.0-select);\n            vec2 p2 = p-n*0.05;\n                for(int k = 0; k < 80; k++){\n                    float dist2 = -dis(p2);\n                    if(dist2 < 0.001){\n                        vec2 n2 = norm(p2+d*0.02);\n                        d = refract(d, -n2, select);\n                        p2 += n2*0.05; \n                        break;\n                    }\n                    p2 += d*dist2;\n                }\n                p = p2;\n                tt *= c2;\n            }else if((l.x > 0.01 || l.y > 0.01 || l.z > 0.01) && !ref){\n                col += l*tt;//*max(dot(n, normalize(p)), 0.2);\n                //d = reflect(d,n);\n                //p += n*0.03;\n                break;\n            }else if((l.x == 0. && l.y == 0. && l.z == 0.) && !ref){\n                d = reflect(d, n);\n                tt *= c2;\n               // d = normalize(d + normalize(vec2(rndf(r), rndf(r))*2.0-1.0));\n                p += n*0.05;\n            }\n            \n        }\n        \n        p += d*dist;\n    }\n    col = clamp(col, 0., 15.);\n    if(jk != 0.){\n    col += texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    }\n    // Output to screen\n    fragColor = vec4(col,float(iFrame));\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcSRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 36, 59, 59, 213], [250, 250, 278, 278, 760], [764, 764, 794, 794, 1302], [1303, 1303, 1329, 1329, 1480], [1482, 1482, 1510, 1510, 1577], [1579, 1579, 1605, 1605, 1647], [1649, 1649, 1676, 1676, 1769], [1770, 1770, 1796, 1796, 1838], [1840, 1840, 1870, 1870, 2978], [2982, 2982, 3039, 3089, 5069]], "test": "untested"}
{"id": "fttSDn", "name": "2d Path tracing try 2", "author": "MinimilisticBits", "description": "sdfsg", "tags": ["sdfsg"], "likes": 3, "viewed": 314, "published": 3, "date": "1639499115", "time_retrieved": "2024-07-30T18:41:58.959634", "image_code": "//NOT MY CODE//////////////////////\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.,1.);\n}\n//////////////////////////////////\n\nvec3 blur(vec2 uv, float r){\nvec3 c = vec3(0.);\nuv *= iResolution.xy;\nfloat iter = 0.;\nfor(int i = 0; i < 10; i++){\n  for(int k = 0; k < 10; k++){\n     float x = float(k)-5.;\n     float y = float(i)-5.;\n     x*=r;\n     y*=r;\n     //float bok = texture(iChannel1, vec2(0.5)+((vec2(x,y)*6.)/iResolution.xy)).y;\n     vec4 c2 = texture(iChannel0, (uv+vec2(x,y))/iResolution.xy).xyzw;\n     vec3 col = c2.xyz / (c2.w+1.);\n     //if(length(col) > 0.6)col*=1.2;\n     c += col;\n     iter+=1.;\n  }\n}\nc/=iter;\nreturn c;\n} \n\n\nvec3 blur2(vec2 p,float dist){\np*=iResolution.xy;\n    vec3 s;\n    \n    vec3 div = vec3(0.);\n    //vec2 off = vec2(0.0, r);\n    float k = 0.61803398875;\n    for(int i = 0; i < 150; i++){\n    float m = float(i)*0.01;\n    float r = 2.*3.14159*k*float(i);\n    vec2 coords = vec2(m*cos(r), m*sin(r))*dist;\n    vec4 c2 = texture(iChannel0, (p+coords)/iResolution.xy).xyzw;\n    vec3 c = c2.xyz / (c2.w+1.);\n    //c = c*c *1.8;\n    vec3 bok = pow(c,vec3(4.));\n      s+=c*bok;\n      div += bok;\n    }\n        \n    s/=div;\n    \n    return s;\n    \n}\nfloat ring(vec2 p, vec2 pos, float r1, float r2){\nvec2 a = normalize(p-pos);\nreturn length((pos+a*r1)-p)-r2;\n}\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nconst float pi = 3.14159;\nvec2 rot(vec2 a, float c){\nfloat l = length(a);\na/=l;\nfloat ang = (a.y < 0.)?2.0*pi - acos(a.x):acos(a.x);\nang += c;\nreturn vec2(l*cos(ang), l*sin(ang));\n}\n\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\nvec3 lensflare(vec2 uv, vec2 mouse){\nfloat dist = ring(uv, -mouse, 0.7, 0.001);\n    dist = exp(-dist*40.2);\n    vec3 col;\n    col += vec3(1.,0.7,0.2)*exp(-(length(mouse-uv)-0.08)*4.);\n    \n    col += vec3(1.,0.7,0.2)*exp(-(length(mouse-uv)-0.08)*1.)*0.4;\n    col += sin(texture(iChannel1, normalize(mouse-uv)*0.05).x)\n    *cos(texture(iChannel1, normalize(mouse-uv)*0.01).y)*exp(-6.0*length(mouse-uv));\n    \n   \n    vec3 c = palette(1.0-length(mouse)*0.5, vec3(0.5),vec3(0.5),vec3(1.0, 0.7, 0.4),vec3(0.00, 0.15, 0.20));\n    vec3 c2 =  palette((1.0-length(mouse))*0.5, vec3(0.5),vec3(0.5),vec3(1.0, 1., 1.),vec3(0.00, 0.1, 0.20));\n    vec3 c3 =  palette((length(mouse))*0.5, vec3(0.5),vec3(0.5),vec3(2.0, 1., 1.),vec3(0.5, 0.2, 0.25));\n    vec3 c4 =  palette((length(mouse-uv)), vec3(0.5),vec3(0.5),vec3(1.0, 1., 1.),vec3(0., 0.33, 0.67));\n    //col += exp(-(ring(uv, mouse, 0.3, 0.004))*146.)*c2*0.2;\n\n    col += vec3(1.)*exp(-(length(-mouse*0.5-uv)-0.005)*3.)*c2;\n    col += vec3(1.)*exp(-(length(-mouse*0.1-uv)-0.005)*17.)*c;\n    col += vec3(1.)*exp(-(length(mouse*0.3-uv)-0.05)*2.)*c3*length(mouse);\n    col += vec3(1.)*exp(-(ring(uv, mouse*0.5, 0.01, 0.004))*46.)*c2*length(mouse);\n    col += exp(-(length(rot(mouse-uv, mouse.x*0.1)*vec2(1.,122.))-1.3)*1.)*c2*exp(-length(mouse)*2.);\n    col += exp(-(length(rot(mouse-uv, (mouse.y+0.2)*0.2)*vec2(1.,122.))-1.3)*1.)*c2*exp(-length(mouse)*2.);\n    col += exp(-(length(rot(mouse-uv, mouse.x+1.0)*vec2(1.,62.))-1.3)*1.)*c4*exp(-length(-mouse*0.2-uv)*6.)*1.;\n    col += exp(-(length(rot(mouse-uv, mouse.x+2.0)*vec2(1.,62.))-1.3)*1.)*c4*exp(-length(-mouse*0.2-uv)*6.)*1.;\n\n    for(int i = 0; i < 4; i++){\n       col += exp(-sdPentagon((mouse*(0.4-(float(i)*0.2))) - uv, 0.1+float(i)*0.05)*16.)*0.02;\n    }\n    \n    \n    float dist2 = (max(length(-mouse*0.8-uv)-0.3, -(length(-mouse*0.66-uv)-0.3)))*0.6;\n    col += vec3(0.4)*exp(-dist2*4.)*c2;\n    col += (1.0-length((-mouse*0.5-uv)-(mouse-uv))-0.01)*0.2;\n    col += vec3(dist*(1.0-length(mouse)))*c;\n    col += exp(-(ring(uv, -mouse*0.2, 0.8, 0.004))*46.)*c2*sin(texture(iChannel1, normalize(uv)).x)*exp(-2.0*length(-mouse-uv));\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n \n    // Time varying pixel color\n    vec4 c = texture(iChannel0, uv).xyzw;\n    //vec3 col = c.xyz/(c.w+1.);\n    vec2 uf = uv * 2.0 - 1.0;\n    uf.x *= 1.3;\n    uf.y /= 1.3;\n    vec3 col = blur2(uv, max(length(uf*14.)*1.-(8.0-length(uf*0.1)), 0.));\n    col = clamp(col,0.,1.);\n    col +=  clamp(lensflare(uf, vec2(0.,0.))*.06,0.,1.);\n   // col +=  lensflare(uf, vec2(0.5,-0.5))*0.01;\n   // col +=  lensflare(uf, vec2(-0.5,-0.5))*0.01;\n   // col +=  lensflare(uf, vec2(-0.5,0.5))*0.01;\n\n    \n    float off = texture(iChannel0, uv).w;\n     vec3 rad;\n    vec2 offset2 = (fragCoord - iResolution.xy/2.)*1.;\n    for(int i = 0; i < 20; i++){\n       vec2 offset = fragCoord + offset2*smoothstep(0.,15.-length(uv*2.0-1.)*1.5, float(i)/20.)*1.;\n       rad.x += texture(iChannel0, (offset+offset2*0.024)/iResolution.xy).x/float(off+1.);\n       rad.y += texture(iChannel0, (offset)/iResolution.xy).y/float(off+1.);\n       rad.z += texture(iChannel0, (offset-offset2*0.024)/iResolution.xy).z/float(off+1.);\n\n    }\n    rad /= 16.;\n \n   // col = rad;\n    \n    //col = ACESFilm(col);\n    col = clamp(col, 0., 1.);\n     col = vec3(1.)-exp(-1.0*col);\n\n    //NOT MY CODE//////////////////\n    vec3 a = vec3(0.3,0.3,0.4)-0.4;\n    col = mix(col, smoothstep(0.,1.,col),a);\n    //////////////////////////////\n    // Output to screen\n    vec3 aa = vec3(1.0,1.1,1.1);\n    col = sqrt(col/aa);\n    col = (1.0/((1.0)+exp(-(10.)*(col-0.5))));\ncol = pow(col, vec3(1.3))*1.8;\n//col = pow(col, vec3(0.9,0.7,0.9));\ncol = ACESFilm(col);\n    col = pow(col, vec3(1./2.2));\nuv = uv * 2.0 - 1.0;\n//uv.x *= 1.3;\n//uv.y /= 1.3;\ncol *= (1.0-length(uv*0.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 rot(vec2 a, float c){\nc = c*3.14159/180.;\nfloat l = length(a);\na/=l;\n\nfloat ang = (a.y < 0.)?2.*3.14159-acos(a.x):acos(a.x);\nang += c;\n\nreturn l*vec2(cos(ang), sin(ang));\n}\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat rndf(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\n\nfloat box(vec2 p, vec2 s){\nvec2 a = abs(p)-s;\nreturn max(a.x, a.y);\n}\n\nfloat torus(vec2 p, vec2 s){\nreturn length((normalize(p)*s.x)-p)-s.y;\n}\n\nvec3 l = vec3(0.);\nbool ref = false;\nvec3 c = vec3(1.);\nvec2 hash2( vec2 p )\n{\n\treturn textureLod( iChannel1, (p+0.5)/256.0, 0.0 ).xy;\n}\nvec2 voronoi(vec2 p){\nvec2 f = floor(p);\nvec2 res = vec2(8.);\nfor(int i = 0; i < 9; i++){\nvec2 coords = f + vec2(mod(float(i),3.)-1., float(i/3)-1.);\nvec2 o = hash2( coords );\no = 0.5 + 0.4*sin(6.2831*o );\nvec2 pos = (coords+o);\nfloat d = dot(pos-p,pos-p);\nif( d < res.x )\n{\n    res.y = res.x;\n    res.x = d;\n}\nelse if( d < res.y )\n{\n    res.y = d;\n}\n}\nreturn res;\n}\nfloat jb(vec3 p){\n    float s=3., e;\n    s*=e=3./min(dot(p,p),50.);\n    p=abs(p)*e;\n  //  escape = 0.;\n    for(int i=0;i++<17;){\n        p=vec3(2,4,2)-abs(p-vec3(2,4,2)),\n            s*=e=8./min(dot(p,p),10.),\n            p=abs(p)*e;\n        //    escape += exp(-0.2*dot(p,p));\n            }\n    return min(length(p.xz)-.1,p.y)/s;\n}\n/////////////////\n\n  float DEmine(vec3 p0){\nvec4 p = vec4(p0, 1.);\nfor(int i = 0; i < 7; i++){\np*=4.8;\np.xyz = mod(p.xyz-1.5, 3.)-1.5;\nfloat m = length(p.xyz);\n\np/=dot(p.xyz,p.xyz)+mod(m, 1.);\n\n}\n\nreturn length(p.xyz)/p.w;\n}\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\nfloat dis(vec2 p){\nl = vec3(0.);\nc = vec3(1.);\n\nref = false;\nfloat a2 = voronoi(p*0.2).x*0.1;\nvec3 pos = vec3(p, 1.8);\npos.yz = rot(pos.yz, 0.);\nfloat a = DEmine(pos/1.)*1.;\n//a = torus(mod(p, 2.)-1., vec2(.9,.1));\n//2 = torus(mod(p,5.)-2.5, vec2(.9,.1));\n//if(length(mod(p,3.)-1.5) < 0.9 ){\n//a = -0.05;\n//}\nif(a < 0.01){\na = -0.05;\n}\nif(a2 < 0.01){\na2 = -0.05;\n}\n//float b1 = box(rot(mod(vec2(0.,0.)-p, 5.)-2.5, 0.), vec2(0.7,.4));\nfloat b2 = torus(mod(vec2(0.,0.)-p,5.)-2.5, vec2(.9,.1));\nfloat b1 = torus(vec2(0.,0.)-p, vec2(.8,.1));\n\n//b1 = box(p, vec2(.5,0.5));\n//b2 = box(p, vec2(.5,0.5));\n\nfloat c2 = abs(box(rot(mod(vec2(-3.,0.)-p, 5.)-2.5, 45.), vec2(5.1, .2)))-0.1;\nfloat d = abs(box(mod(vec2(0., -1.5)-p, 5.)-2.5, vec2(2., 0.2)))-0.1;\nfloat e = abs(box(rot(mod(vec2(3.,0.)-p, 5.)-2.5, -45.), vec2(5.1, .2)))-.1;\nfloat fin = min(min(a, min(b2,b1)),min(min(d,e),c2));\nif(fin == b1 || fin == b2){l = vec3(3.);}\nif(fin == e || fin == d || fin == c2){ref = true;c = vec3(0.2,0.3,0.9);}\nif(fin == a){\n//c = vec3(0.2,0.9,0.9);\nref = false;c = vec3(0.7,0.6,0.2);\n}\nif(fin == a2){\n//c = vec3(0.2,0.9,0.9);\nref = false;c = vec3(0.1,0.6,0.7);\n}\nreturn fin;\n}\n\nvec3 wavetorgb(float wave){\nvec3 col = vec3(0.);\nif(wave > 410. && wave < 440.){\ncol = vec3(0.19-0.19*(440.-wave)/30., 0., 1.);\n}else if(wave > 440. && wave < 490.){\ncol = vec3(0., 1.0-(490.-wave)/50., 1.);\n}else if(wave > 490. && wave < 510.){\ncol = vec3(0., 1., (510.-wave)/20.);\n}else if(wave > 510. && wave < 580.){\ncol = vec3(1.-(580.-wave)/70., 1., 0.);\n}else if(wave > 580. && wave < 640.){\ncol = vec3(1., (640.-wave)/60., 0.);\n}else if(wave > 640. && wave < 700.){\ncol = vec3(1., 0., 0.);\n}else if(wave > 700. && wave < 780.){\ncol = vec3(0.35-0.65*(780.-wave)/80., 0., 0.);\n}\n\n\nreturn col;\n}\n\nvec2 norm(vec2 p){\nreturn normalize(vec2(\ndis(vec2(p.x+0.01, p.y))-dis(vec2(p.x-0.01, p.y)),\ndis(vec2(p.x, p.y+0.01))-dis(vec2(p.x, p.y-0.01)))\n);\n}\n\nfloat f_wavelength(float wave, float a, float b){\nreturn exp(-pow((wave-(b+a)/2.)/((b-a)/2.),2.));\n}\n\nvec3 wavetorgb3(float wave){\nreturn vec3(\nf_wavelength(wave, 520., 630.),\nf_wavelength(wave, 500., 590.),\nf_wavelength(wave, 410., 480.)\n);\n}\n\nvec3 wavetorgb2(float wave){\nreturn vec3(\nexp(-pow((wave-630.)/30.,2.))+exp(-pow((wave-430.)/10.,2.)),\nexp(-pow((wave-530.)/20.,2.)),\nexp(-pow((wave-470.)/20.,2.))\n)*2.;\n}\n\nvec3 wavetoxyz(float wave){\nfloat x = 1.065*exp(-0.5*pow((wave-595.8)/33.33,2.))+0.366*exp(-0.5*pow((wave-446.8)/19.44,2.));\nfloat y = 1.014*exp(-0.5*pow((log(wave)-log(556.3))/0.075,2.));\nfloat z = 1.839*exp(-0.5*pow((wave-449.8)/0.051,2.));\nreturn vec3(x,y,z);\n}\n\nvec3 XYZtorgb(vec3 XYZ){\nvec3 RGB = vec3(3.2404542*XYZ.x - 1.5371385*XYZ.y - 0.4985314*XYZ.z,\n-0.9692660*XYZ.x + 1.8760108*XYZ.y + 0.0415560*XYZ.z,\n0.0556434*XYZ.x - 0.2040259*XYZ.y + 1.0572252*XYZ.z\n);\nreturn RGB;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uint r = uint(uint(fragCoord.x) * uint(1973) \n    + uint(fragCoord.y) * uint(9277) \n    + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 odd = vec2(rndf(r), rndf(r))*2.0-1.0;\n    odd /= iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    uv += odd*2.;\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n    \n    int tiles = 2;\n    int samples =150;\n    float jk = float(iFrame%samples);\n\n    vec2 res = iResolution.xy / float(tiles);\n    int times = (iFrame/samples);\n    vec2 time = vec2(float(times%tiles), float((times/tiles)%(tiles)));\n    vec2 rr = res*time;\n    \n    if(fragCoord.x < (rr.x) || fragCoord.x > (rr.x+res.x))discard;\n    if(fragCoord.y < (rr.y) || fragCoord.y > (rr.y+res.y))discard;\n  \n    \n    vec2 p = uv*5.;\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    float ang = rndf(r)*2.*3.14159;\n    vec2 d = vec2(cos(ang), sin(ang));\n    float select = rndf(r);\n    float wave = 410. + 370.*select;\n    \n    if(dis(p) < 0.01 && ref == true ){\n        vec2 n = norm(p); \n        vec2 p2 = p;\n        for(int k = 0; k < 80; k++){\n            float dist2 = -dis(p2);\n            if(dist2 < 0.01){\n                vec2 n2 = norm(p2+d*0.02);\n                d = refract(d, -n2, select);\n                p2 += n2*0.05; \n                break;\n            }\n            p2 += d*dist2;\n        }\n        \n         p = p2;\n    }else if(dis(p) < 0.01 && ref == false && (l.x == 0. && l.y == 0. && l.z == 0.)){\n        vec2 n = norm(p); \n           // col += c*max(dot(n, vec2(0.,1.)),0.2);\n\n        vec2 p2 = p;\n        for(int k = 0; k < 80; k++){\n            float dist2 = -dis(p2);\n            if(dist2 < 0.01){\n                vec2 n2 = norm(p2+d*0.02);\n                p2 += n2*0.05; \n                break;\n            }\n            p2 += d*dist2;\n        }\n         p = p2;\n    }\n    bool firsthit = false;\n    vec2 n2 = vec2(0.);\n    vec3 c2 = vec3(0.);\n    vec3 tt = wavetorgb(wave);\n    for(int i = 0; i < 420; i++){\n        float dist = dis(p);\n        if(length(p) > 20.)break;\n        if(dist < 0.01){\n            vec2 n = norm(p-d*0.02); \n            c2 = c;\n            if(!firsthit){\n            n2 = n;\n            c2 = c;\n            firsthit = true;\n            }\n            if(ref){\n            d = refract(d,n,1.0-select);\n            vec2 p2 = p-n*0.05;\n                for(int k = 0; k < 80; k++){\n                    float dist2 = -dis(p2);\n                    if(dist2 < 0.001){\n                        vec2 n2 = norm(p2+d*0.02);\n                        d = refract(d, -n2, select);\n                        p2 += n2*0.05; \n                        break;\n                    }\n                    p2 += d*dist2;\n                }\n                p = p2;\n                tt *= c2;\n            }else if((l.x > 0.01 || l.y > 0.01 || l.z > 0.01) && !ref){\n                col += l*tt*dot(n2, vec2(0.,1.));\n                //d = reflect(d,n);\n                //p += n*0.03;\n                break;\n            }else if((l.x == 0. && l.y == 0. && l.z == 0.) && !ref){\n                d = reflect(d, n);\n                tt *= c2;\n               // d = normalize(d + normalize(vec2(rndf(r), rndf(r))*2.0-1.0));\n                p += n*0.05;\n            }\n            \n        }\n        \n        p += d*dist;\n    }\n    col = clamp(col, 0., 15.);\n    if(jk != 0.){\n    col += texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    }\n    // Output to screen\n    fragColor = vec4(col,jk);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttSDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 36, 59, 59, 213], [250, 250, 278, 278, 760], [764, 764, 794, 794, 1302], [1303, 1303, 1352, 1352, 1413], [1414, 1414, 1486, 1486, 1529], [1557, 1557, 1583, 1583, 1712], [1714, 1714, 1757, 1757, 2039], [4187, 4187, 4244, 4294, 6009]], "test": "untested"}
{"id": "slcSRf", "name": "Hypersphere Frame", "author": "IWBTShyGuy", "description": "Hypersphere Frame", "tags": ["4d"], "likes": 2, "viewed": 278, "published": 3, "date": "1639486249", "time_retrieved": "2024-07-30T18:41:59.724589", "image_code": "// The MIT License\n// Copyright  2021 IWBTShyGuy \n\n#define AA 2\n\nconst vec3 GOLD = pow(vec3(242, 186, 35) / 255.0, vec3(2.2));\n\nfloat sdSphereFrame3D(vec4 p, float r, float e) {\n    return min(min(min(\n        length(vec2(length(p.xyz) - r, p.w)) - e,\n        length(vec2(length(p.yzw) - r, p.x)) - e),\n        length(vec2(length(p.zwx) - r, p.y)) - e),\n        length(vec2(length(p.wxy) - r, p.z)) - e\n    );\n}\n\nfloat sDist(in vec4 p) {\n    return sdSphereFrame3D(p, 1.0, 0.1);\n}\n\nvec4 calcNormal(in vec4 p) {\n    const vec2 e = vec2(1.0e-4, 0);\n    return normalize(vec4(\n        sDist(p + e.xyyy) - sDist(p - e.xyyy),\n        sDist(p + e.yxyy) - sDist(p - e.yxyy),\n        sDist(p + e.yyxy) - sDist(p - e.yyxy),\n        sDist(p + e.yyyx) - sDist(p - e.yyyx)\n    ));\n}\n\nconst float FAR = 12.0;\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    float veloMove = 0.5;\n    float veloTarget = 0.3;\n    vec4 position = vec4(\n        (1.0 + cos(iTime * veloMove)) * 1.5,\n        0.5,\n        (1.0 + cos(iTime * veloMove)) * 1.5,\n        sin(iTime * veloMove) * 1.5\n    );\n    vec4 direction = normalize(vec4(sin(iTime * veloTarget), 0, cos(iTime * veloTarget), 0) - position);\n    vec4 up = vec4(-direction.y, direction.x, 0, 0);\n    vec4 tactile = vec4(0, 0, -direction.w, direction.z);\n    if (length(tactile) < 1.0e-2) {\n        fragColor = vec4(1, 0, 0, 1);\n        return;\n    }\n    Camera camera = newCamera(\n        position,\n        direction,\n        up,\n        tactile,\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, fragCoord / iResolution.xy);\n\n    float dist = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec4 p = ray.origin + dist * ray.direction;\n        float dist0 = sDist(p);\n        if (dist0 < 1.0e-6 || dist > FAR) break;\n        dist += dist0;\n    }\n\n    vec3 col = pow(texture(iChannel0, normalize(ray.direction.zwx)).xyz, vec3(2.2));\n    if (dist < FAR) {\n        vec4 p = ray.origin + dist * ray.direction;\n        vec4 normal = calcNormal(p);\n        float c = microfacet(\n            normal,\n            ray.direction,\n            ray.direction,\n            0.4,\n            0.5\n        ) * 0.7;\n        c += microfacet(\n            normal,\n            ray.direction,\n            vec4(0, 0, 0, -1),\n            0.9,\n            0.5\n        ) * 0.3;\n        col = clamp(c, 0.0, 1.0) * GOLD;\n    }\n\n\n    // It must be remark the camera does not collide with shape.\n    // The result does not change if the following commet out is removed.\n    //if (dist < 1.0e-3) col = vec3(0);\n\n    fragColor = vec4(pow(col, vec3(0.4545)), 1);\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    \n// smart anti-aliasing\n// reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\n// If defined, visualize anti-aliased pixels.\n//#define VISUALIZE_AA\n#ifdef AA\n    if (fwidth(length(O.xyz)) > 0.1) {\n\n        O.xyz = pow(O.xyz, vec3(2.2));\n        vec4 o;\n#if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              mainImage0(o,U + (vec2(k % 2, k / 2) - 0.5) / 1.5);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 5.0;\n#elif (AA == 3)\n        for (int k = 0; k < 9; k += k == 3 ? 2 : 1 ) {\n              mainImage0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 9.0;\n#endif\n#ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n#endif\n        O.xyz = pow(O.xyz, vec3(0.4545));\n    }\n#endif\n    O.w = 1.0;\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//\n// 4D toolkit\n//\n// The MIT License\n// Copyright  2021 IWBTShyGuy \n//\n\nconst float PI = 3.141592653;\n\nvec4 three_cross(in vec4 a, in vec4 b, in vec4 c) {\n    return vec4(\n        -determinant(mat3(a.yzw, b.yzw, c.yzw)),\n        determinant(mat3(a.zwx, b.zwx, c.zwx)),\n        -determinant(mat3(a.wxy, b.wxy, c.wxy)),\n        determinant(mat3(a.xyz, b.xyz, c.xyz))\n    );\n}\n\nstruct Camera {\n    vec4 position;\n    vec4 direction;\n    //@ upper direction of camera\n    //@ not need to perp to `direction`\n    vec4 up_direction;\n    //@ normal of the hyperplane\n    //@ not have to be normalized\n    //@ assumed being perp to `direction`.\n    vec4 tactile;\n    float fov;\n    //@ x / y\n    float aspect;\n};\n\nCamera newCamera(\n    in vec4 position,\n    in vec4 direction,\n    in vec4 up_direction,\n    in vec4 tactile,\n    in float fov,\n    in float aspect\n) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.tactile = tactile;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\nstruct Ray {\n    vec4 origin;\n    vec4 direction;\n};\n\n// uv: fragCoord / iResolution.xy\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float h = tan(camera.fov * 0.5);\n    float w = h * camera.aspect;    \n    vec4 right = -normalize(three_cross(camera.direction, camera.up_direction, camera.tactile));\n    vec4 up = -normalize(three_cross(right, camera.direction, camera.tactile));\n    vec4 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\n// ------------------- microfacet base rendering ------------------- //\nfloat microfacet(vec4 normal, vec4 cameraDir, vec4 lightDir, float metal, float roughness) {\n    vec4 middle = normalize(cameraDir + lightDir);\n    float dotCN = clamp(-dot(cameraDir, normal), 0.0, 1.0);\n    float dotLN = clamp(-dot(lightDir, normal), 0.0, 1.0);\n    float dotNM = -dot(normal, middle);\n    float dotCM = dot(cameraDir, middle);\n    float alpha = roughness * roughness;\n    \n    // diffuse BRDF\n    float diffuse = 1.0 - metal;\n    \n    // microfacet distribution\n    float alpha2 = alpha * alpha;\n    float tmp = 1.0 - dotNM * dotNM * (1.0 - alpha2);\n    float distribution = alpha2 / (tmp * tmp);\n\n    // schlick approxy & geometric decay\n    float alp = alpha * 0.5;\n    float sal = dotLN / (dotLN * (1.0 - alp) + alp);\n    float sac = dotCN / (dotCN * (1.0 - alp) + alp);\n    float decay = sal * sac;\n\n    // fresnel\n    float c = 1.0 - dotCM;\n    c = c * c * c * c * c;\n    float fresnel = metal + (1.0 - metal) * c;\n\n    // specular BRDF\n    tmp = 4.0 * dotCN * dotLN;\n    float specular = distribution * decay / tmp * fresnel;\n    if (tmp < 0.0001) specular = 0.0;\n    \n    return (diffuse + specular) * dotLN;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcSRf.jpg", "access": "api", "license": "mit", "functions": [[130, 130, 179, 179, 413], [415, 415, 439, 439, 482], [484, 484, 512, 512, 772], [798, 798, 854, 854, 2618]], "test": "untested"}
{"id": "NlcXRf", "name": "test mist", "author": "jcyuan", "description": "test the efx of erase from a mist (like the efx in some games)", "tags": ["sdf", "mist", "multiplepass"], "likes": 5, "viewed": 375, "published": 3, "date": "1639460336", "time_retrieved": "2024-07-30T18:42:00.503506", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 suv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 ouv = fragCoord / iResolution.xy;\n    vec2 d = texture(iChannel1, ouv).xy;\n    \n    float w = length(fwidth(ouv));\n    vec3 ball = .02 / d.y * vec3(.2, 1., 0.);\n    \n    float m = pow(exp(-d.x), 5.);\n    vec3 col = texture(iChannel0, ouv).rgb * m + ball;\n    \n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 hash3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nfloat snoise(vec3 p) {\n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n\n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n\n    vec4 w, d;\n\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n\n    w = max(0.6 - w, 0.0);\n\n    d.x = dot(hash3(s), x);\n    d.y = dot(hash3(s + i1), x1);\n    d.z = dot(hash3(s + i2), x2);\n    d.w = dot(hash3(s + 1.0), x3);\n\n    w *= w;\n    w *= w;\n    d *= w;\n\n    return dot(d, vec4(52.0));\n}\n", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec4 c = texture(iChannel0, fragCoord / iResolution.xy);\n    vec2 mv = vec2(cos(iTime) * .95, sin(iTime) * .45) * snoise(vec3(vec2(0.), iTime * .5)) * 3.;\n    float d = length(uv + mv);\n    c.y = d;\n    if (c.z == 0.) {\n        c.x = d;\n        c.z = 1.;\n    } else {\n        c.x = min(c.x, d);\n    }\n    \n    fragColor = c;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcXRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 425]], "test": "untested"}
{"id": "NtcSRf", "name": "another fractal", "author": "jorge2017a2", "description": "another fractal\n\n", "tags": ["anotherfractal"], "likes": 38, "viewed": 652, "published": 3, "date": "1639454576", "time_retrieved": "2024-07-30T18:42:01.273448", "image_code": "///------------image\n//por jorge2017a2-\n//another fractal\n//--13-dic-2021\n#define MAX_STEPS 160\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n#define MENGER_ITERATIONS\t2\n\nvec4 mapFractal(in vec3 p)\n{\t\n    p.xz = mod(p.xz + 4.0, 2.0) -1.0;\n    //p.y = mod(p.y + 1.0, 2.0) - 1.0;\n\t\n    float d = sdBox(p,vec3(1.0));\n    vec4 res = vec4(d, 1.0, 0.01, 0.0);\n    float s = 2.5;\n\n    for(int i = 0; i < MENGER_ITERATIONS; ++i)\n    {\n        vec3 a = mod(p * s, 2.0) - 1.0;\n        s *= 11.0;\n        vec3 r = abs(1.0 - 5.0 * abs(a));\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 0.85) / s;\n\n        if(c > d)\n        {  d = c; res = vec4(d, min(res.y, 0.2 * da * db * dc), 0.0, 1.0); }\n    }\n    return res;\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+5.0;  //piso inf\n      float t=-iTime*0.5;\n    vec4 v4=mapFractal(p-vec3(0.55,1.3,0.0+t));\n    res =opU3(res, vec3(v4.x,1.0,-1.0)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 nor = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    nor= normalize(nor);\n    return nor;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n        {mObj.hitbln = true; minDist = abs(t); break;}\n        \n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        \n        t += dS.x;\n        marchCount++;\n    }\n        \n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nfloat FakeSoftShadow(float result, vec3 LightPos,vec3 point,vec3 normal)\n{\n    vec3 shadowOffset = normal * 0.2 ;\n    int epoch = 5;\n    \n    float delta = result/float(epoch);\n    float lightOffset = 0.2;\n    \n    for(int i = 0; i<epoch; i++)\n    {\n        vec3 tmp = LightPos +vec3(0,0,i)*lightOffset;\n        float dis=RayMarch(point + shadowOffset,normalize(tmp-point), int( MAX_DIST));\n        if (dis< length(tmp-point))\n        { result -= delta; }\n    }\n    return result;\n}\n\nfloat specularBRDF(float roughness, vec3 n, vec3 v, vec3 l)\n{\n    vec3 h = normalize(v + l);\n    float NoV = abs(dot(n, v)) + .1;\n    float NoL = clamp(dot(n, l), 0., 1.);\n    float NoH = clamp(dot(n, h), 0., 1.);\n    float D = (2. + 1. / roughness) * pow(max(1. - NoH * NoH, .0078125), 1. / roughness * .5) / (2. * PI);\n    return D / (4. * (NoL + NoV - NoL * NoV));\n}\n\n//----------------------------------------------------\n//https://www.shadertoy.com/view/ft3SRr\nvec3 Shading(vec3 LightPos, vec3 pos, vec3 ro,vec3 baseCol)\n{\n    //ro=eye\n    vec3 L = normalize(LightPos - pos);\n    vec3 V = normalize(ro - pos);\n    vec3 N = GetNormal(pos);\n    vec3 H = normalize(L+V);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float Ambient = 0.1;\n       \n    float result = max(dot(L,N),0.0)*0.5 + pow(max(dot(H,N),0.0),20.)*0.9;\n    result = FakeSoftShadow(result, LightPos,pos,N);\n    \n    float roughness=4.25;\n    vec3 specol=specularBRDF(roughness, N, V, L)*baseCol;\n    \n    Material mate;\n    mate.baseCol = vec3(.38, .02, .02);\n    mate.specularCol = vec3(0.56 ,.64, .64);          \n    return ((result+Ambient)*baseCol+specol*mate.specularCol)/2.0;\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    vec3 sha= Shading(plight_pos,p,ro,colobj);\n    result =  sha;\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n\n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }    \n    return colobj;\n}\n\n/*\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n   float d=RayMarch(ro,rd, MAX_STEPS);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2)*light_color2;\n        \n        col= result;\n        //col *= 1.0 - pow(d*d /(MAX_DIST*1.5) , 4.5);  \n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n   return col;\n}\n*/\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{   vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n \n    float d=RayMarch(ro,rd, MAX_STEPS);\n    Obj=mObj;\n\n    vec3 sky = render_sky_color(rd);\n    col = sky;\n\n    if(mObj.hitbln) \n    {   vec3 p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2)*light_color2;\n\n        col= result;\n        //col *= 1.0 - pow(d*d /(MAX_DIST*1.5) , 4.5);  \n    }\n\n    col = mix(col, sky, smoothstep(0., .08, min(d, MAX_DIST)/MAX_DIST));\n\n    return col;\n}\n\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n// Tone mapping\n// See: http://filmicgames.com/archives/75\nvec3 Uncharted2ToneMapping(vec3 color)\n{\n    float gamma = 2.2;\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n\tfloat exposure = 0.012;\n\tcolor *= exposure;\n\tcolor = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n\tfloat white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n\tcolor /= white;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \t\n    light_pos1= vec3(5.0, 10.0, -10.0 );    light_color1=vec3(1.0);\n \tlight_pos2= vec3( -10.0, 30.0, -10.0 ); light_color2 = vec3(1.0); \n \n   \n   vec3 ro=vec3(0.5,2.0,-20.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    \n    vec3 col= Render( ro,  rd);\n    \n    //col = linear2srgb(col);\n    col+=Uncharted2ToneMapping(col);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "//--------------common\nstruct Material\n{\n    vec3 baseCol;\n    vec3 specularCol;\n    float roughness;\n};\n\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    //if (i>-1 ) \n\t//\treturn Arrcolores[i];\n    \n    if (i==0 )  return vec3(0.0);\n    if (i==1 )  return vec3(1.0);\n    \n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtcSRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[534, 534, 566, 566, 650], [681, 681, 709, 709, 1312], [1314, 1314, 1339, 1339, 1604], [1606, 1606, 1630, 1630, 1810], [1812, 1812, 1861, 1861, 2551], [2555, 2555, 2591, 2591, 2836], [2838, 2838, 2912, 2912, 3320], [3322, 3322, 3383, 3383, 3691], [3693, 3788, 3849, 3862, 4477], [4479, 4479, 4559, 4559, 4686], [4688, 4688, 4720, 4720, 4917], [4920, 4920, 5013, 5013, 5174], [5898, 5898, 5929, 5929, 6673], [6676, 6676, 6702, 6702, 6812], [6814, 6814, 6872, 6872, 6924], [6926, 6985, 7025, 7025, 7463], [7466, 7515, 7572, 7572, 8125]], "test": "untested"}
{"id": "Nl3XRX", "name": "1D Array Ersteller", "author": "ersteller", "description": "Without a texture using only a 1D array in code.\n", "tags": ["notexture", "ersteller", "lookuparray"], "likes": 2, "viewed": 137, "published": 3, "date": "1639445016", "time_retrieved": "2024-07-30T18:42:02.110211", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n// only 1D arrays but at least with constructor ;(\nconst int[] aiErsteller = int[] (\n      0,0,0,0,0,0,0,\n\t  0,0,0,1,0,0,0,\n\t  0,0,1,1,1,0,0,\n\t  0,0,0,1,0,0,0,\n\t  0,0,0,0,0,0,0,\n\t  1,1,1,1,1,1,1,\n\t  1,0,1,1,1,0,1,\n\t  1,0,1,1,1,0,1,\n      0,0,1,1,1,0,0,\n\t  0,0,1,1,1,0,0,\n\t  0,0,1,0,1,0,0,\n\t  0,0,1,0,1,0,0,\n\t  0,0,1,0,1,0,0,\n\t  0,1,1,0,1,1,0,\n      0,0,0,0,0,0,0\n);\n\nconst vec2 bitmap_size = vec2(7, 15);\n\n\n// input 0 to 1\nvec3 getValueXY( in vec2 uv  )\n{\n\tfloat value = 1.;\n    vec3 col ;\n    // transform to grid pos\n    vec2 fetch_pos = vec2( uv * bitmap_size.y );\n    // check if in array range\n\tif( fetch_pos.x >= 0.  && fetch_pos.y >= 0.\n\t\t&& fetch_pos.x < bitmap_size.x  && fetch_pos.y < bitmap_size.y  )\n\t{\n        // convert x y to index \n\t\tint idx = int(fetch_pos.x) + ( int(bitmap_size.y) - 1 - int(fetch_pos.y)) * int(bitmap_size.x);\n\t\tvalue = float(1 - aiErsteller[idx]); // invert\n        \n        // glitch effect every 3 seconts \n        if (fract(iTime/5.) < 1./5. && value == 0.)\n        {\n            // we use time fraction for random value\n            int frac = int(fract(iTime)*4095.*10.);\n            int y = int(fetch_pos.y);\n            int x = int(fetch_pos.x);          \n            \n            // some kind of random bitwise fun\n            col = vec3( \n                float((frac & 0x00f)^x^y) / 15., \n                float(((frac & 0x0f0)>>4)^x^y) / 15., \n                float(((frac & 0xf00)>>8)^x^y) / 15.\n            );\n            if (int((bitmap_size.y)-fract(iTime/5.)*10.*(bitmap_size)) == y)\n            {\n               return col;\n            }\n        } \n\t} else value = 1.;  // outer color;\n\treturn vec3(value);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize coord (and force square grid aspect ratio)\n\tvec2 uv = vec2(fragCoord.x /iResolution.y,fragCoord.y/iResolution.y);\n    // shift to center\n    uv.x = uv.x-0.6;\n    uv.y = uv.y-0.;\n   \n    vec3 col = getValueXY(uv);\n\n\n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3XRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1780, 1780, 1837, 1897, 2100]], "test": "untested"}
{"id": "Wl2fDR", "name": "ZeeAngle", "author": "lennyjpg", "description": "z", "tags": ["2d", "flat", "grid", "triangles", "flag", "blue", "pattern", "exp"], "likes": 7, "viewed": 303, "published": 3, "date": "1639440236", "time_retrieved": "2024-07-30T18:42:03.201293", "image_code": "void mainImage( out vec4 O, in vec2 f )\n{\n    vec2 uv = f / iResolution.x;\n    float t = iTime * 0.1;\n    float yy = exp(uv.y * 6.),\n        k = floor(yy)*2.0,\n        x = fract(uv.x*k*3.0);\n    vec2 u = vec2(x, fract(yy));\n    u.y = abs(u.y-0.5);\n    float b = u.x + u.y*2.0,\n        a = uv.y * .1,\n        d = smoothstep(b + a , b - a, 1.);\n    vec3 blue = vec3(0., 120., 191.) / 255.;\n    O = vec4(mix(blue, vec3(1.), d),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2fDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 430]], "test": "untested"}
{"id": "sltSR2", "name": "HexaGold 2", "author": "aiekick", "description": "An HexaGold :-,)", "tags": ["hexagon", "hex", "hexa", "gold"], "likes": 65, "viewed": 1598, "published": 3, "date": "1639435274", "time_retrieved": "2024-07-30T18:42:04.151752", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2021 (github:aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned with Noodlesplate (https://github.com/aiekick/NoodlesPlate)\n\nmat3 rotz(float a)\n{\n    float c = cos(a), s = sin(a);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\n// from IQ, https://www.shadertoy.com/view/Xds3zN\n// sdf of heaxagon\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// hexagons repeat placement\n#define ox 1.3\n#define oz 1.5\n\n// variation between 0 and 1 along p.z\nfloat var_z = 0.0;\n\n// common part used by the map and mat functions\n// return the two sdf's\nvoid common_map(vec3 p, out float df0, out float df1)\n{\n\tp *= rotz(p.z * 0.05);\n\t\n\tp.y = 5.0 + 5.0 * var_z - abs(p.y);\n\t\n    // the horizontal wave\n\tfloat wave = sin(length(p.xz) * 0.25 - iTime * 1.5);\n\tdf0 = abs(p.y + wave) - 1.0;\n\t\n\tvec2 hex_size = vec2(0.25 + p.y * 0.25, 10.0);\n\t\n    // first hexagones row\n\tvec3 q0 = p;\n\tq0.x = mod(q0.x - ox, ox + ox) - ox;\n\tq0.z = mod(q0.z - oz * 0.5, oz) - oz * 0.5;\n\tfloat hex0 = sdHexPrism(q0.xzy, hex_size) - 0.2; \n\t\n    // second hexagones row\n\tvec3 q1 = p;\n\tq1.x = mod(q1.x, ox + ox) - ox;\n\tq1.z = mod(q1.z, oz) - oz * 0.5;\n\tfloat hex1 = sdHexPrism(q1.xzy, hex_size) - 0.2; \n\t\n    // the hexagones\n\tdf1 = min(hex0, hex1);\n}\n\n// from IQ\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\n// return the final SDF\nfloat map(vec3 p)\n{\n    float df0, df1;\n    common_map(p, df0, df1);\n    \n    // final df\n    return smax(df0, df1, 0.1);\n    //return max(df0, df1);\n}\n\n// same code as map but with decomposition of the last max()\n// for return the material id\nfloat mat(vec3 p)\n{\n\tfloat df0, df1;\n    common_map(p, df0, df1);\n    \n    // max() decomposition for get df id\n\tif (df0 > df1)\n\t\treturn 1.0;\n\treturn 0.0;\n}\n\n// get normal for the surface point and a precision\nvec3 getNormal(vec3 p)\n{\n\tconst vec3 e = vec3(0.1, 0, 0);\n\treturn normalize(vec3(\n\t\tmap(p+e)-map(p-e),\n\t\tmap(p+e.yxz)-map(p-e.yxz),\n\t\tmap(p+e.zyx)-map(p-e.zyx)));\n}\n\n// IQ Occ\nfloat getAmbiantOcclusion(vec3 p, vec3 n, float k)\n{\n    const float aoStep = 0.1; \n\tfloat occl = 0.;\n    for(int i = min(iFrame,0); i < 6; ++i)\n    {\n        float diff = float(i)*aoStep;\n        float d = map(p + n*diff);\n        occl += (diff - d) * pow(2., float(-i));\n    }\n    return min(1., 1. - k*occl);\n}\n\n// IQ Shadow\nfloat getShadow(vec3 ro, vec3 rd, float minD, float maxD, float k)\n{\n    float res = 1.0;\n    float d = minD;\n\tfloat s = 0.;\n    for(int i = min(iFrame,0); i < 20; ++i)\n    {\n        s = map(ro + rd * d);\n        if( abs(s)<d*d*1e-5 ) return 0.0;\n        res = min( res, k * s / d );\n\t\td += s;\n        if(d >= maxD) break;\n    }\n    return res;\n}\n\n// get the perpsective camera\nvec3 cam(vec2 uv, vec3 ro, vec3 cv, float fov)\n{\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n  \treturn normalize(z + fov*uv.x*x + fov*uv.y*y);\n}\n\n// from IQ https://www.shadertoy.com/view/MsS3Wc\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 si = iResolution.xy;\n    \n    // central uv\n    vec2 uvc = (2.*fragCoord.xy-si)/si.y;\n    \n    // classic path camera\n\tvec3 ro = vec3(0.0, 0.0, iTime * 20.0 + 5.0);\n\tvec3 cv = ro + vec3(0.0, 0.0, 4.0);\n\tvec3 rd = cam(uvc, ro, cv, 0.4);\n\n    vec3 col = vec3(0);\n\n    vec3 p = ro;\n    float s = 1., d = 0.;\n    const float md = 70.;\n\tfor (int i = min(iFrame,0); i < 200; i++)\n\t{\n\t\t// log marching\n        if (d*d/s > 1e6 || d > md) break;\n        var_z = sin(p.z * 0.1) * 0.5 + 0.5;\n\t\ts = map(p);\n\t\td += s * 0.5;\n        p = ro + rd * d;\n\t}\n\t\n\tif (d < md)\n\t{\n        // surface normal\n        // internal precision of 0.1 for remove some aliasing\n\t\tvec3 n = getNormal(p);\n\t\t\n\t\t// light pos\n\t\tvec3 lp = vec3(0,5,0);\n\t\t\n\t\t// light dir\n\t\tvec3 ld = normalize(lp - p);\n\t\t\t\t\t\t\t\t\n        // diffuse, ambiant occlusion, shadow, specular\n\t\tfloat diff = pow(dot(n, ld) * .5 + .5,2.0);\n\t\tfloat ao = getAmbiantOcclusion(p, n, 40.0);\n\t\tfloat sha = clamp(getShadow(p, ld, 0.01, 150.0, 5.0), 0. ,0.9);\n\t\t\n\t\tif (mat(p) > 0.5) // hexa face\n        { \n            // variation between orange glod and white along z\n            col = mix(\n                vec3(1.5, 1.0, 0.0), \n                vec3(2.0, 2.0, 2.0), \n                var_z);\n\t\t} \n        else // hexa sides\n        {\n            // gold\n            col = vec3(1.0, 0.85, 0.0) * 0.75;\t\n        }\n        \n        // apply reflection\n        col *= texture(iChannel0, reflect(rd, n)).rgb;\n\t\t\n        // final brdf\n\t\tcol += diff * sha * 0.5;\n\t}\n\t\n    // clamp for avoid overlight\n\tcol = clamp(col, 0., 1.);\n        \n    // distance fog\n\tcol *= exp(1.0-d*d*0.001);\n\t\n    // final color\n\tfragColor = vec4(col,1);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltSR2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[224, 224, 244, 244, 317], [319, 388, 424, 424, 734], [855, 928, 983, 983, 1597], [1599, 1610, 1651, 1651, 1740], [1742, 1742, 1781, 1781, 1810], [1812, 1836, 1855, 1855, 1987], [1989, 2080, 2099, 2099, 2236], [2238, 2290, 2314, 2314, 2454], [2456, 2466, 2518, 2518, 2779], [2781, 2794, 2862, 2862, 3140], [3142, 3172, 3220, 3220, 3398], [3400, 3482, 3516, 3516, 3692], [3694, 3694, 3751, 3751, 5413]], "test": "untested"}
{"id": "sldXzj", "name": "[TDF 2021]", "author": "totetmatt", "description": "My compo for TokyoDemoFest 2021 GLSL competition \n", "tags": ["lowpoly", "tdf2021"], "likes": 25, "viewed": 585, "published": 3, "date": "1639425977", "time_retrieved": "2024-07-30T18:42:05.021427", "image_code": "\n\n\n//\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat box(vec2 p,vec2 b){\n    vec2 q = abs(p)-b;\n    return length(max(vec2(0.),q))+min(0.,max(q.x,q.y));\n}\nfloat box3(vec3 p,vec3 b){\n    vec3 q =abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n}\nfloat tokyo(vec3 p){\n\tp*=2.;\n\tvec3 op = p;\n\tp.x -=6.;\n\tfloat d = box3(p-vec3(0.,4.,0.),vec3(5.,1.,1.));\n\tfloat q = min(d,box3(p-vec3(0.,0.,0.),vec3(4.,3.,1.)));\n\tq = max(q,-min(d,box3(p-vec3(0.,0.,0.),vec3(3.,2.,2.))));\n\td = min(d,q);\n\td =min(d,box3(p,vec3(4.,1.,1.)));\n\td = min(d,box3(p,vec3(1.,7.,1.)));\n\tp.y-=-5.;\n\tp.x = abs(p.x)-2.;\n\tp.xy*=rot(-.885);\n\td = min(d,box3(p,vec3(1.,2.5,1.)));\n\t\n\tp =op;\n\tp.x+=6.;\n\tfloat d2 = box3(p-vec3(0.,4.,0.),vec3(5.,1.,1.));\n\tfloat q2 = min(d2,box3(p-vec3(0.,0.,0.),vec3(4.,3.,1.)));\n\tq2 = max(q2,-min(d2,box3(p-vec3(0.,0.,0.),vec3(3.,2.,2.))));\n\td2 = min(d2,q2);\n\t\n\td2 = min(d2,box3(p-vec3(0.,5.,0.),vec3(1.,2.,1.)));\n\td2 = min(d2,box3(p-vec3(0.,-5.,0.),vec3(1.,2.,1.)));\n\td2 = min(d2,box3(p-vec3(1,-6.5,0.),vec3(2.,.5,1.)));\n\tp.y-=-4.;\n\tp.x = abs(p.x)-2.;\n\tp.xy*=rot(-.885);\n\td2 = min(d2,box3(p,vec3(.5,2.5,1.)));\t\n\t\n\td= min(d2,d);\n\treturn d/2.;\n}\nfloat diam(vec3 p,float s){\n\t p = abs(p);\n\t return (p.x+p.y+p.z-s)*inversesqrt(3.);\n}\n\nvec3 op;\nfloat di(vec3 p){\n    float q = 0.;\n    vec4 pp = vec4(p,1.1);\n    const float cc = 2.;\n    for(float i=1.; i<=cc ;i++){\n      q += (asin(sin(pp.x))+acos(cos(pp.z)))/pp.a;\n      pp*=1.1;\n      pp.xyz +=vec3(1.1,2.,3.);\n      pp.xyz = abs(pp.xyz);\n      pp.xz *=rot(-.785*i+i);\n      \n    }\n    return q/(cc+pp.a);\n\n}\nvec2 sdf(vec3 p){\nvec3 tp = p;\n\t\n   op = p;\n\n    vec2 h;\n    p.xy *=rot(p.z*.1);\n    p.y= -abs(p.y)+(3.+asin(sin(iTime+p.z*.1))*.5);\n    \n    h.x = length(p+1.)-.1;\n    p.y +=2.+di(p);\n    h.x = min(h.x, box(p.xy,vec2(6.1,.5) ) );\n\th.x *=.65;\n    h.y = 1.;\n\t\n    vec2 t;\n\n    tp.xz*=rot(pow(fract(iTime*.3),.125)*3.14);\n    tp.xy*=rot(pow(fract(iTime*.3+.5),.125)*3.14);\n    t.x = mix(diam(tp,2.5),box3(tp,vec3(1.1)),asin(sin(floor(iTime)+pow(fract(iTime),.5)))*.3+.2);\n\tt.x =mix(t.x , tokyo(-tp),clamp(sin(iTime),-.5,.5)+.5);\n\t tp = op;\n    vec4 ttp = vec4(tp,1.);\n\tttp.yz*=rot(iTime*.01);\n    for(float i=0.;i<=6.;i++){\n        ttp*=1.3;\n        ttp.xyz = abs(ttp.xzy)-11.;\n        ttp.xz*=rot(-.785+i);\n\t    ttp.xy*=rot(i);\n        t.x = min(t.x,box3(ttp.xyz,vec3(.5))/ttp.a);\n    }\n\t\n    t.y = 2.;\n    h = t.x < h.x ? t:h;\n    return h;\n    \n}\n#define q(s) s*sdf(p+s).x\n#define ao(rp,n,k) clamp(sdf(rp+n*k).x/k,.0,1.)\n#define gao(rp,n) (ao(rp,n,.1)+ao(rp,n,.5)+ao(rp,n,.7))\nvec3 norm(vec3 p,float e){vec2 nv=vec2(-e,e);return normalize(q(nv.xyy)+q(nv.yxy)+q(nv.yyx)+q(nv.xxx));}\nvec3 pal(float t){return .5+vec3(.5,.2,.1)*cos(6.28*(vec3(1.,.5,.6)*t+vec3(.0,.1,.2)));}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(12.,-0.1+iMouse.y*.01,-6.+iMouse.x*.01);\n    vec3 rt = vec3(0.);\n    vec3 z = normalize(rt-ro);\n    vec3 x = (cross(z,vec3(0.,-1.,.0)));\n    vec3 y = (cross(z,x));\n    \n    vec3 rp = ro;\n    vec3 rd = normalize(mat3(x,y,z)*vec3(uv,.9));\n    vec3 light = mat3(x,y,z)*vec3(-2.,-1.,-4.);\n    vec3 col = vec3(.1);\n    for(float i=0.;i<=128.;i++){\n        vec2 d = sdf(rp);\n        if(length(rp) > 50.) break;\n        if(d.x <.001){\n        \n            vec3 n = norm(rp,.019);\n            vec3 nn = norm(rp,.02+abs(sin(iTime+rp.z*.2))*.01);\n                           float dif = dot(normalize(light-rp),n);\n                           float spc = max(0.,dot(normalize(rp-ro),reflect(normalize(-light),n)));\n                           spc = pow(spc,32.);\n\t\tfloat fr = pow(1.-dot(-rd,n),4.);\n                col = vec3(.1)+vec3(.15,.5,.7)*dif+spc*.75;\n                float l = length(n-nn);\n                float s = step(.01,l);\n                col = max(vec3(0.),mix(col-s,col*s, floor(rp.z*.1-.3+di(rp.zzz*.1)*.2)*(gao(rp,n)/3.)*.75+.5));\n                col = pow(col,vec3(.8));\n\t\tif(d.y ==1.) {col *=smoothstep(10.5,.0,op.z);col += -fr+s*pal(op.z*.1+iTime)*smoothstep(-.1,.1,op.z);}\n                break;\n           \n            \n        }\n        rp +=rd*d.x;\n    \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldXzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 12, 30, 30, 77], [78, 78, 103, 103, 185], [186, 186, 212, 212, 302], [303, 303, 323, 323, 1191], [1192, 1192, 1219, 1219, 1277], [1288, 1288, 1305, 1305, 1604], [1605, 1605, 1622, 1622, 2452], [2583, 2583, 2609, 2609, 2687], [2688, 2688, 2706, 2706, 2776], [2779, 2779, 2836, 2886, 4296]], "test": "untested"}
{"id": "sldSRj", "name": "negative light", "author": "Mots_Doux", "description": "My very first shader, basic tests aside.\nNot much to say, its just basic stuff bundled in one shader.\n\nComments and criticism are welcomed, for I am an absolute beginner.", "tags": ["grid", "negative"], "likes": 3, "viewed": 215, "published": 3, "date": "1639422956", "time_retrieved": "2024-07-30T18:42:05.993827", "image_code": "// This shader is licensed under the Creative Commons Zero 1.0 License\n// https://creativecommons.org/publicdomain/zero/1.0/legalcode\n// It means you can do anything you want, its pretty much Public Domain\n\n#define TAU 6.28318530718\n\nfloat square(float x) {\n    return x * x;\n}\n\n// function to draw the grid\n// has a lot of parameters but allows avoiding some code duplication\nvec4 grid(vec2 uv, float cellSize, vec3 color1, vec3 color2, float ratio) {\n    if ((mod(uv.x * ratio, cellSize) <= cellSize/2.0 && mod(uv.y, cellSize) <= cellSize/2.0) || (mod(uv.x * ratio, cellSize) >= cellSize/2.0 && mod(uv.y, cellSize) >= cellSize/2.0)) {\n        return vec4(color1, 1.0);\n    } else {\n        return vec4(color2, 1.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates of the pixel\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // duration of the animation in seconds\n    float duration = 5.0;\n    \n    // colors of the grid\n    vec3 color1 = vec3(1.0, 1.0, 1.0);\n    vec3 color2 = vec3(0.0, 0.436, 1.0);\n\n    // ratio of the display surface so we have a proper circle and not an ellipse\n    float ratio = iResolution.x / iResolution.y;\n    \n    // center of the circle, moves with time\n    // this is a very simple movement only for me to explore the iTime parameter and the cos function\n    vec2 center = vec2(cos(TAU / duration * iTime) * 0.2 + 0.5, cos(TAU / duration * iTime) * 0.2 + 0.5);\n    \n    // radius of our circle\n    float radius = 0.3;\n    \n    // size of each cell of the grid\n    float cellSize = 0.5;\n    \n    // circle equation, true if the pixel is inside the circle\n    // (pixel.x - center.x)^2 + (pixel.y - center.y)^2 <= radius^2\n    // pixels in the circle get an inverted color\n    /*if (square(uv.x * ratio - center.x) + square(uv.y - center.y) <= square(radius)) {\n        fragColor = 1.0 - grid(uv, cellSize, color1, color2, ratio);\n    } else {\n        fragColor = grid(uv, cellSize, color1, color2, ratio);\n    }*/\n    \n    // change suggested by hamtarodeluxe, replace the commented lines above + removes aliasing\n    vec4 col = grid(uv, cellSize, color1, color2, ratio);\n    float squareRadius = square(radius);\n    // returns smooth Hermite interpolation between 0 and 1 when\n    // squareRadius < square(uv.x * ratio - center.x) + square(uv.y - center.y) < squareRadius + 0.005\n    float t = smoothstep(squareRadius, squareRadius + 0.005, square(uv.x * ratio - center.x) + square(uv.y - center.y));\n    // mix is simply a lerp function\n    fragColor = mix(1.-col, col, t);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldSRj.jpg", "access": "api", "license": "cc-sampling-plus-1.0", "functions": [[237, 237, 260, 260, 280], [282, 380, 455, 455, 728], [730, 730, 787, 819, 2556]], "test": "untested"}
{"id": "fldXR2", "name": "4D Fattened Flat Torus", "author": "IWBTShyGuy", "description": "We finally caught sight of the flat torus.", "tags": ["4d"], "likes": 10, "viewed": 321, "published": 3, "date": "1639417632", "time_retrieved": "2024-07-30T18:42:06.935310", "image_code": "// The MIT License\n// Copyright  2021 IWBTShyGuy \n\n#define AA 3\n\nfloat sdFlatTorus(in vec4 p, in vec2 t) {\n    return length(vec2(length(p.xy), length(p.zw)) - t);\n}\n\nfloat sDist(in vec4 p) {\n    return sdFlatTorus(p, vec2(1)) - 0.2;\n}\n\nvec4 calcNormal(in vec4 p) {\n    const vec2 e = vec2(1.0e-4, 0);\n    return normalize(vec4(\n        sDist(p + e.xyyy) - sDist(p - e.xyyy),\n        sDist(p + e.yxyy) - sDist(p - e.yxyy),\n        sDist(p + e.yyxy) - sDist(p - e.yyxy),\n        sDist(p + e.yyyx) - sDist(p - e.yyyx)\n    ));\n}\n\nconst float FAR = 12.0;\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 dir = vec4(sin(iTime * 0.5), 0, cos(iTime * 0.5), 0);\n    Camera camera = newCamera(\n        -dir * 5.0,\n        normalize(dir),\n        vec4(0, -sin(iTime), 0, cos(iTime)),\n        vec4(0, cos(iTime), 0, sin(iTime)),\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, fragCoord / iResolution.xy);\n\n    float dist = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec4 p = ray.origin + dist * ray.direction;\n        float dist0 = sDist(p);\n        if (dist0 < 1.0e-6 || dist > FAR) break;\n        dist += dist0;\n    }\n\n    vec3 col = vec3(0);\n    if (dist < FAR) {\n        vec4 p = ray.origin + dist * ray.direction;\n        vec4 normal = calcNormal(p);\n        float c = -dot(normal, ray.direction);\n        col += c;\n    }\n\n    fragColor = vec4(pow(col, vec3(0.4545)), 1);\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    \n// smart anti-aliasing\n// reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\n// If defined, visualize anti-aliased pixels.\n//#define VISUALIZE_AA\n#ifdef AA\n    if (fwidth(length(O.xyz)) > 0.1) {\n\n        O.xyz = pow(O.xyz, vec3(2.2));\n        vec4 o;\n#if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              mainImage0(o,U + (vec2(k % 2, k / 2) - 0.5) / 1.5);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 5.0;\n#elif (AA == 3)\n        for (int k = 0; k < 9; k += k == 3 ? 2 : 1 ) {\n              mainImage0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 9.0;\n#endif\n#ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n#endif\n        O.xyz = pow(O.xyz, vec3(0.4545));\n    }\n#endif\n    O.w = 1.0;\n}", "image_inputs": [], "common_code": "//\n// 4D toolkit\n//\n// The MIT License\n// Copyright  2021 IWBTShyGuy \n//\n\nconst float PI = 3.141592653;\n\nvec4 three_cross(in vec4 a, in vec4 b, in vec4 c) {\n    return vec4(\n        -determinant(mat3(a.yzw, b.yzw, c.yzw)),\n        determinant(mat3(a.zwx, b.zwx, c.zwx)),\n        -determinant(mat3(a.wxy, b.wxy, c.wxy)),\n        determinant(mat3(a.xyz, b.xyz, c.xyz))\n    );\n}\n\nstruct Camera {\n    vec4 position;\n    vec4 direction;\n    //@ upper direction of camera\n    //@ not need to perp to `direction`\n    vec4 up_direction;\n    //@ normal of the hyperplane\n    //@ not have to be normalized\n    //@ assumed being perp to `direction`.\n    vec4 tactile;\n    float fov;\n    //@ x / y\n    float aspect;\n};\n\nCamera newCamera(\n    in vec4 position,\n    in vec4 direction,\n    in vec4 up_direction,\n    in vec4 tactile,\n    in float fov,\n    in float aspect\n) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.tactile = tactile;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\nstruct Ray {\n    vec4 origin;\n    vec4 direction;\n};\n\n// uv: fragCoord / iResolution.xy\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float h = tan(camera.fov * 0.5);\n    float w = h * camera.aspect;    \n    vec4 right = -normalize(three_cross(camera.direction, camera.up_direction, camera.tactile));\n    vec4 up = -normalize(three_cross(right, camera.direction, camera.tactile));\n    vec4 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldXR2.jpg", "access": "api", "license": "mit", "functions": [[67, 67, 108, 108, 167], [169, 169, 193, 193, 237], [239, 239, 267, 267, 527], [553, 553, 609, 609, 1440]], "test": "untested"}
{"id": "fttXzj", "name": "Hello 4D Repetition Cube", "author": "IWBTShyGuy", "description": "My second 4D raymarching.", "tags": ["4d"], "likes": 5, "viewed": 280, "published": 3, "date": "1639411749", "time_retrieved": "2024-07-30T18:42:07.943614", "image_code": "// The MIT License\n// Copyright  2021 IWBTShyGuy \n\n#define AA 2\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec4 p, vec4 b ) {\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,max(q.z, q.w))),0.0);\n}\n\nfloat cellDist(in vec4 p, in vec4 q, in float t) {\n    p = fract(q + vec4(0, 0, 0, 1.0e-4)) + p - q;\n    return sdBox(p - vec4(0.5, 0.5, 0.5, 0.5), vec4(0.15));\n}\n\nfloat sDist(in vec4 p, in vec4 dir, in float t) {\n    float dist = cellDist(p, p, t);\n    if (floor(p) != floor(p + dist * dir)) {\n        dist = min(dist, cellDist(p, p + dist * dir, t));\n    }\n    return dist;\n}\n\nvec4 calcNormal(in vec4 p, in vec4 dir, in float t) {\n    const vec2 e = vec2(1.0e-4, 0);\n    return normalize(vec4(\n        cellDist(p + e.xyyy, p, t) - cellDist(p - e.xyyy, p, t),\n        cellDist(p + e.yxyy, p, t) - cellDist(p - e.yxyy, p, t),\n        cellDist(p + e.yyxy, p, t) - cellDist(p - e.yyxy, p, t),\n        cellDist(p + e.yyyx, p, t) - cellDist(p - e.yyyx, p, t)\n    ));\n}\n\nconst float FAR = 12.0;\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 dir = vec4(\n        cos(iTime * 0.1),\n        sin(iTime * 0.1),\n        cos(iTime * 0.06),\n        sin(iTime * 0.06)\n    );\n    Camera camera = newCamera(\n        vec4(0, 0, 0, fract(iTime * 0.3)),\n        normalize(dir),\n        vec4(0, 1, 0, 0),\n        vec4(\n            -sin(iTime * 0.1),\n            cos(iTime * 0.1),\n            -sin(iTime * 0.06),\n            cos(iTime * 0.06)\n        ),\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, fragCoord / iResolution.xy);\n\n    float dist = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec4 p = ray.origin + dist * ray.direction;\n        float dist0 = sDist(p, ray.direction, iTime);\n        if (dist0 < 1.0e-6 || dist > FAR) break;\n        dist += dist0;\n    }\n\n    vec3 col = vec3(0);\n    if (dist < FAR) {\n        vec4 p = ray.origin + dist * ray.direction;\n        vec4 normal = calcNormal(p, vec4(0), iTime);\n        float c = -dot(normal, ray.direction);\n        c = mix(c, 0.0, smoothstep(0.0, 1.0, dist / FAR));\n        col += c * ((fract(p.wxy) - 0.5) / 0.3 + 0.5);\n    }\n\n    fragColor = vec4(pow(col, vec3(0.4545)), 1);\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    \n// smart anti-aliasing\n// reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\n// If defined, visualize anti-aliased pixels.\n//#define VISUALIZE_AA\n#ifdef AA\n    if (fwidth(length(O.xyz)) > 0.1) {\n\n        O.xyz = pow(O.xyz, vec3(2.2));\n        vec4 o;\n#if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              mainImage0(o,U + (vec2(k % 2, k / 2) - 0.5) / 1.5);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 5.0;\n#elif (AA == 3)\n        for (int k = 0; k < 9; k += k == 3 ? 2 : 1 ) {\n              mainImage0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 9.0;\n#endif\n#ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n#endif\n        O.xyz = pow(O.xyz, vec3(0.4545));\n    }\n#endif\n    O.w = 1.0;\n}\n", "image_inputs": [], "common_code": "//\n// 4D toolkit\n//\n// The MIT License\n// Copyright  2021 IWBTShyGuy \n//\n\nconst float PI = 3.141592653;\n\nvec4 three_cross(in vec4 a, in vec4 b, in vec4 c) {\n    return vec4(\n        -determinant(mat3(a.yzw, b.yzw, c.yzw)),\n        determinant(mat3(a.zwx, b.zwx, c.zwx)),\n        -determinant(mat3(a.wxy, b.wxy, c.wxy)),\n        determinant(mat3(a.xyz, b.xyz, c.xyz))\n    );\n}\n\nstruct Camera {\n    vec4 position;\n    vec4 direction;\n    //@ upper direction of camera\n    //@ not need to perp to `direction`\n    vec4 up_direction;\n    //@ normal of the hyperplane\n    //@ not have to be normalized\n    //@ assumed being perp to `direction`.\n    vec4 tactile;\n    float fov;\n    //@ x / y\n    float aspect;\n};\n\nCamera newCamera(\n    in vec4 position,\n    in vec4 direction,\n    in vec4 up_direction,\n    in vec4 tactile,\n    in float fov,\n    in float aspect\n) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.tactile = tactile;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\nstruct Ray {\n    vec4 origin;\n    vec4 direction;\n};\n\n// uv: fragCoord / iResolution.xy\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float h = tan(camera.fov * 0.5);\n    float w = h * camera.aspect;    \n    vec4 right = -normalize(three_cross(camera.direction, camera.up_direction, camera.tactile));\n    vec4 up = -normalize(three_cross(right, camera.direction, camera.tactile));\n    vec4 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttXzj.jpg", "access": "api", "license": "mit", "functions": [[67, 116, 147, 147, 244], [246, 246, 296, 296, 408], [410, 410, 459, 459, 623], [625, 625, 678, 678, 1010], [1036, 1036, 1092, 1092, 2235]], "test": "untested"}
{"id": "tstczS", "name": "Paper Plane", "author": "zduny", "description": "Prototype of my mobile game:\n[url]https://play.google.com/store/apps/details?id=com.zduny.paperplane[/url]\n\nControls: \nSPACE to start\nLEFT ARROW and RIGHT ARROW - control the plane", "tags": ["game", "interactive", "text", "origami"], "likes": 108, "viewed": 10585, "published": 3, "date": "1639409611", "time_retrieved": "2024-07-30T18:42:09.193272", "image_code": "INCLUDE_TEXTURE_GRID_WIDTH\nINCLUDE_GAME_CONSTANTS\nINCLUDE_STATE_STRUCT\nINCLUDE_STATE_LOAD_FUNCTION\n\nconst bool showTexture = false;\n\nconst vec3 background = vec3(0.454, 0.672, 0.984);\n\nconst float aspectRatio = 8.0 / 16.0;\nconst float top = 1.0 / aspectRatio;\n\nState state;\nvec3 letterColor;\n\nvec4 blend(in vec4 under, in vec4 over) {\n  vec4 result = mix(under, over, over.a);\n  result.a = over.a + under.a * (1.0 - over.a);\n    \n  return result;\n}\n\nvec2 fixUv(in vec2 uv) {\n  uv = clamp(uv, 0.0, 1.0);\n  uv.x *= iResolution.y / iResolution.x;\n  return uv;\n}\n\nvec4 getPipeTexture(in vec2 uv) {\n  return texture(iChannel1, fixUv(uv) / float(textureGridWidth));\n}\n\nvec4 getPlaneTexture(in float angle, in vec2 uv) {\n  float total = float(textureGridWidth * textureGridWidth - 2);  \n  float i = round((angle + 0.5) * total + 1.0);\n  \n  uv = fixUv(uv);\n  uv.x += iResolution.y / iResolution.x * mod(i, float(textureGridWidth));\n  uv.y += floor(i / float(textureGridWidth));\n  \n  return texture(iChannel1, uv / float(textureGridWidth));\n}\n\nvoid drawLetter(inout vec4 fragColor, in vec2 fragCoord, \n                in vec2 position, in vec2 size, in int code) {\n  vec2 uv = fragCoord - position;\n  uv += size * 0.5;\n  uv /= size;\n  \n  if (uv.x > 0.0 && uv.x < 1.0 && uv.y > 0.0 && uv.y < 1.0) {\n    uv.x += float(code % 16);\n    uv.y += float(15 - code / 16);\n    \n    uv *= 0.0625;\n    \n    float sd = abs(texture(iChannel2, uv).a);\n    fragColor = blend(fragColor, \n      vec4(vec3(0.0), smoothstep(0.0, 1.0, (0.55 - sd) * 50.0)));\n    fragColor = blend(fragColor, \n      vec4(letterColor, smoothstep(0.0, 1.0, (0.51 - sd) * 50.0)));\n  }\n}\n\nfloat elasticOut(float t) {\n  return sin(-13.0 * (t + 1.0) * 3.1416 * 0.5) * pow(2.0, -10.0 * t) + 1.0;\n}\n\nfloat cubicIn(float t) {\n  return t * t * t;\n}\n\nfloat cubicOut(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\n\nconst float HALF_PI = 3.1416 * 0.5;\nfloat elasticInOut(float t) {\n  return t < 0.5\n    ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0))\n    : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;\n}\n\nvoid drawPipes(inout vec4 fragColor, in vec2 fragCoord, \n               in vec2 position, in float gap) {   \n  float size = pipeSize;\n\n  vec2 uv = fragCoord - position;\n  if (uv.x > 0.0) {\n    uv.x *= -1.0;\n  }\n  uv += size * 0.5;\n  uv.x += size * 0.21 + gap;\n  uv /= size;\n  \n  fragColor = blend(fragColor, getPipeTexture(uv));\n}\n\nvoid drawAllPipes(inout vec4 fragColor, in vec2 fragCoord) {\n  vec4 outColor = fragColor;\n\n  for (int i = 0; i < pipesCount; i++) {\n    Gap gap = state.gaps[i];\n    vec2 position = vec2(gap.position, \n      pipesStart + state.pipesOffset + float(i) * pipesGap);\n    drawPipes(outColor, fragCoord, position, gap.size);\n  }\n  \n  float time = clamp(max(iTime, state.animationTime) * 1.5, 0.0, 1.0);\n  fragColor = mix(fragColor, outColor, cubicIn(time));\n}\n\n#define INCLUDE_DRAW_STRING_FUNCTION(name, arrayName, arrayLength)         \\\n  void name(inout vec4 fragColor, in vec2 fragCoord, float offset) {       \\\n    float size = 1.0 / float(arrayLength);                                 \\\n                                                                           \\\n    fragCoord.y -= top - size * (1.0 + offset) - 0.2;                      \\\n    fragCoord *= 1.08;                                                     \\\n    fragCoord.x = clamp(fragCoord.x, -1.0, 1.0);                           \\\n    fragCoord.x += 1.0;                                                    \\\n    fragCoord *= 0.5;                                                      \\\n                                                                           \\\n    int code = arrayName[int(fragCoord.x / size - 0.01)];                  \\\n    fragCoord.x = mod(fragCoord.x, size) - size * 0.5;                     \\\n                                                                           \\\n    drawLetter(fragColor, fragCoord, vec2(0.0), vec2(size * 1.4), code);   \\\n  }\n\nconst int paperLength = 5;\nconst int[] paperLetters = int[](80, 65, 80, 69, 82);\n\nconst int planeLength = 5;\nconst int[] planeLetters = int[](80, 76, 65, 78, 69);\n\nINCLUDE_DRAW_STRING_FUNCTION(drawPaper, paperLetters, paperLength)\nINCLUDE_DRAW_STRING_FUNCTION(drawPlane, planeLetters, planeLength)\n\nvoid drawLogo(inout vec4 fragColor, in vec2 fragCoord) {\n  if (state.animationState >= STATE_IN_GAME) {\n    return;\n  }\n\n  bool inAnimation = state.animationState <= STATE_MENU;\n  float animationTime = state.animationTime;\n  \n  float time = clamp(animationTime * 1.1, 0.0, 1.0);\n  float position = inAnimation \n    ? mix(-8.0, 0.0, elasticOut(time))\n    : mix(0.0, -8.0, cubicIn(time));\n    \n  letterColor = vec3(1.0);\n  drawPaper(fragColor, fragCoord, position - 0.5);\n  drawPlane(fragColor, fragCoord, position + 2.0);\n}\n\nvoid drawScore(inout vec4 fragColor, in vec2 fragCoord) {\n  if (state.animationState < STATE_IN_GAME && state.highScore == 0) {\n    return;\n  }\n\n  bool inAnimation = state.animationState <= STATE_MENU;\n  float animationTime = state.animationTime;\n  \n  float time = state.animationState == STATE_GAME_OVER \n    ? 1.0\n    : clamp(animationTime * (inAnimation ? 1.2 : 0.5) - 0.1, 0.0, 1.0);\n  float y = inAnimation\n    ? mix(2.0, 0.0, elasticOut(time))\n    : mix(0.0, 1.55, elasticInOut(time));\n  \n  float size = 0.27;\n  \n  int[] scoreString = int[](0, 0, 0, 0, 0, 0, 0);\n  int scoreLength = 0;\n  int score;\n  if (state.animationState <= STATE_MENU) {\n    score = state.highScore;\n  } else if (state.animationState == STATE_OUTRO && time < 0.7) {\n    score = int(mix(float(state.highScore), 0.0, clamp((time - 0.5) * 4.0, 0.0, 1.0)));\n  } else if (state.animationState == STATE_OUTRO) {\n    score = 0;\n  }else if (state.animationState >= STATE_IN_GAME) {\n    score = state.score;\n  }\n  for (int i = 0; i < 6; i++) {\n    scoreString[i] = 48 + score % 10;\n    scoreLength++;\n    score = score / 10;\n    if (score == 0) {\n      break;\n    }\n  }\n  \n  letterColor = \n    (state.animationState >= STATE_IN_GAME && state.score <= state.highScore) ||\n    (state.animationState == STATE_OUTRO && time > 0.5)\n    ? vec3(1.0)\n    : vec3(1.0, 1.0, 0.7);\n    \n  vec4 outColor = vec4(0.0);\n  float letterWidth = size * 0.8;\n  for (int i = 0; i < scoreLength; i++) {\n    vec2 position = vec2(0.0 + float(scoreLength - i - 1) * letterWidth, y + 0.21);\n    position.x -= float(scoreLength) * 0.5 * letterWidth - letterWidth * 0.48;\n    drawLetter(outColor, fragCoord, position, vec2(size * 1.4), scoreString[i]);\n  }\n  \n  if (state.animationState == STATE_IN_GAME && state.highScore == 0) {\n    outColor.a *= cubicIn(clamp((state.animationTime - 4.0) * 3.0, 0.0, 1.0));\n  }\n  if (state.animationState == STATE_GAME_OVER && \n      state.score < 2 && \n      state.highScore == 0) {\n    outColor.a = 0.0;\n  }\n  fragColor = blend(fragColor, outColor);\n}\n\nvoid drawPaperPlaneButton(inout vec4 fragColor, in vec2 fragCoord, \n                          in vec2 position, bool shadow) {\n  vec2 size = vec2(shadow ? 0.71 : 0.68);\n  \n  position -= fragCoord;\n  position += size * 0.5;\n  \n  position /= size;\n  float tmp = position.x;\n  position.x = 1.0 - position.y;\n  position.y = tmp;\n  \n  vec4 color = getPlaneTexture(0.0, position);\n  \n  fragColor = blend(fragColor, shadow ? vec4(vec3(0.2), color.a * 0.5) : color);\n}\n\nvoid drawPlayButton(inout vec4 fragColor, in vec2 fragCoord) {\n  if (state.animationState >= STATE_IN_GAME) {\n    return;\n  }\n\n  vec2 position = vec2(0.0, -1.0);\n  \n  bool inAnimation = state.animationState <= STATE_MENU;\n  float animationTime = state.animationTime;\n  float time = clamp(animationTime * 1.2, 0.0, 1.0);\n  \n  vec2 circlePosition = inAnimation\n    ? mix(position - vec2(0.0, 3.0), position, elasticOut(animationTime))\n    : mix(position, position - vec2(0.0, 3.0), cubicIn(animationTime));\n  \n  const float radius = 0.45;\n  float sd = distance(circlePosition, fragCoord);\n  \n  fragColor = blend(fragColor, \n    vec4(vec3(0.0), smoothstep(1.0, 0.0, (sd - radius - 0.02) * 100.0)));\n  fragColor = blend(fragColor, \n    vec4(vec3(0.0, 0.0, 0.85), smoothstep(1.0, 0.0, (sd - radius) * 100.0)));\n\n  position += vec2(0.01, 0.02);\n  \n  time = clamp(animationTime * (inAnimation ? 3.0 : 2.0), 0.0, 1.0);\n  \n  vec2 shadowPosition = inAnimation\n    ? mix(position - vec2(2.7, 0.0), position, cubicOut(time))\n    : mix(position, position + vec2(2.7, 0.0), cubicIn(time));\n  \n  if (state.isPlayPressed) {\n    position.y -= 0.025;\n  }\n  vec2 planePosition = inAnimation\n    ? mix(position - vec2(3.0, 0.0), position, cubicOut(time))\n    : mix(position, position + vec2(3.0, 0.0), cubicIn(time));\n    \n  vec4 shadow = vec4(0.0);\n  drawPaperPlaneButton(shadow, fragCoord, shadowPosition + vec2(0.0, -0.03), true);\n  shadow.a *= smoothstep(1.0, 0.0, (sd - radius - 0.02) * 100.0);\n  fragColor = blend(fragColor, shadow);\n  \n  drawPaperPlaneButton(fragColor, fragCoord, planePosition, false);\n}\n\nvoid drawPlane(inout vec4 fragColor, in vec2 fragCoord) {\n  if (state.animationState < STATE_OUTRO) {\n    return;\n  }\n  \n  vec2 size = vec2(planeSize);\n  vec2 position = state.plane.position;\n  \n  position -= fragCoord;\n  position += size * 0.5;\n  \n  position /= size;\n  position.y = 1.0 - position.y;\n  \n  vec4 color = getPlaneTexture(state.plane.angle, position);\n  \n  fragColor = blend(fragColor, color);\n}\n\nvoid normalizeFragCoord(inout vec2 fragCoord) {\n  fragCoord -= iResolution.xy * 0.5;\n  fragCoord /= iResolution.y * 0.5;\n  fragCoord /= aspectRatio;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {  \n  fragColor = vec4(vec3(0.0), 1.0);\n  \n  if (showTexture) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(background, 1.0);\n    fragColor = blend(fragColor, texture(iChannel1, uv));\n    return;\n  }\n  \n  normalizeFragCoord(fragCoord);\n  bool inFrame = abs(fragCoord.x) < 1.0;\n  if (inFrame) {\n    state = loadState(); \n    fragColor = vec4(background, 1.0);\n    drawAllPipes(fragColor, fragCoord);\n    drawLogo(fragColor, fragCoord);\n    drawPlayButton(fragColor, fragCoord);\n    drawPlane(fragColor, fragCoord);\n    drawScore(fragColor, fragCoord);\n  }\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 toLinear(in vec3 color) { return pow(color, vec3(2.2)); }\nvec3 toSRGB(in vec3 color) { return pow(color, vec3(1.0 / 2.2)); }\n\n#define INCLUDE_TEXTURE_GRID_WIDTH                                       \\\n  const int textureGridWidth = 6;\n\n#define loadVariable(location)                                           \\\n  texelFetch(iChannel0, ivec2(location, 0), 0)\n\n#define isKeyDown(keyCode)                                               \\\n  (texelFetch(iChannel1, ivec2(keyCode, 0), 0).x > 0.0)\n \nconst int resolutionLocation = 0; \n#define INCLUDE_GAME_CONSTANTS                                           \\\n  const int pipesCount = 6;                                              \\\n  const float pipeSize = 0.5;                                            \\\n  const float pipesStart = -2.5;                                         \\\n  const float pipesGap = 1.05;                                           \\\n  const float planeMinPosition = 1.0;                                    \\\n  const float planeSize = 0.5;                                           \\\n  const float turningSpeed = 2.0;                                        \\\n  const vec2 startingPosition = vec2(-3.0, 4.0);                         \\\n  const float startingAngle = 0.5;                                       \\\n  const float startingOffset = -3.2;                                     \\\n                                                                         \\\n  const int variousLocation = 1;                                         \\\n  const int planeDataLocation = 2;                                       \\\n  const int keysLocation = 3;                                            \\\n  const int pipesLocation = 4;                                           \\\n  const int endOfData = pipesLocation + pipesCount;\n  \n#define STATE_INTRO 0\n#define STATE_MENU 1\n#define STATE_OUTRO 2\n#define STATE_IN_GAME 3\n#define STATE_GAME_OVER 4\n  \n#define INCLUDE_STATE_STRUCT                                             \\\n  struct Gap {                                                           \\\n    float position;                                                      \\\n    float size;                                                          \\\n  };                                                                     \\\n                                                                         \\\n  struct Plane {                                                         \\\n    vec2 position;                                                       \\\n    float angle;                                                         \\\n  };                                                                     \\\n                                                                         \\\n  struct State {                                                         \\\n    vec2 oldResolution;                                                  \\\n    vec2 newResolution;                                                  \\\n    Plane plane;                                                         \\\n    int animationState;                                                  \\\n    float animationTime;                                                 \\\n    float pipesOffset;                                                   \\\n    int score;                                                           \\\n    int highScore;                                                       \\\n    float traveledDistance;                                              \\\n    bool isPlayPressed;                                                  \\\n    Gap[pipesCount] gaps;                                                \\\n  };\n  \n#define INCLUDE_STATE_LOAD_FUNCTION                                      \\\n  State loadState() {                                                    \\\n    State state;                                                         \\\n                                                                         \\\n    vec4 resolutionData = loadVariable(resolutionLocation);              \\\n    state.oldResolution = resolutionData.zw;                             \\\n    state.newResolution = resolutionData.xy;                             \\\n                                                                         \\\n    vec4 planeData = loadVariable(planeDataLocation);                    \\\n                                                                         \\\n    Plane plane;                                                         \\\n    plane.position = planeData.xy;                                       \\\n    plane.angle = planeData.z;                                           \\\n                                                                         \\\n    state.plane = plane;                                                 \\\n                                                                         \\\n    vec4 variousData = loadVariable(variousLocation);                    \\\n    state.animationState = int(variousData.x);                           \\\n    state.animationTime = variousData.y;                                 \\\n    state.pipesOffset = variousData.z;                                   \\\n    state.score = int(variousData.w);                                    \\\n                                                                         \\\n    vec4 keysData = loadVariable(keysLocation);                          \\\n    state.isPlayPressed = keysData.x > 0.0;                              \\\n    state.highScore = int(keysData.y);                                   \\\n    state.traveledDistance = keysData.z;                                 \\\n                                                                         \\\n    for (int i = 0; i < pipesCount; i++) {                               \\\n      vec2 pipesData = loadVariable(pipesLocation + i).xy;               \\\n                                                                         \\\n      Gap gap;                                                           \\\n      gap.position = pipesData.x;                                        \\\n      gap.size = pipesData.y;                                            \\\n                                                                         \\\n      state.gaps[i] = gap;                                               \\\n    }                                                                    \\\n                                                                         \\\n    return state;                                                        \\\n  }\n  \n#define INCLUDE_STATE_SAVE_FUNCTION                                      \\\n  int fragmentCoordinates = 0;                                           \\\n  vec4 outputColor = vec4(0.0);                                          \\\n                                                                         \\\n  void saveState(in State state) {                                       \\\n    switch (fragmentCoordinates) {                                       \\\n      case resolutionLocation:                                           \\\n        outputColor.xy = state.newResolution;                            \\\n        outputColor.zw = state.oldResolution;                            \\\n        return;                                                          \\\n      case planeDataLocation:                                            \\\n        outputColor.xy = state.plane.position;                           \\\n        outputColor.z = state.plane.angle;                               \\\n        return;                                                          \\\n      case variousLocation:                                              \\\n        outputColor.x = float(state.animationState);                     \\\n        outputColor.y = state.animationTime;                             \\\n        outputColor.z = state.pipesOffset;                               \\\n        outputColor.w = float(state.score);                              \\\n        return;                                                          \\\n      case keysLocation:                                                 \\\n        outputColor.x = state.isPlayPressed ? 1.0 : 0.0;                 \\\n        outputColor.y = float(state.highScore);                          \\\n        outputColor.z = state.traveledDistance;                          \\\n        return;                                                          \\\n    }                                                                    \\\n                                                                         \\\n    if (fragmentCoordinates >= pipesLocation &&                          \\\n        fragmentCoordinates < endOfData) {                               \\\n      int i = fragmentCoordinates - pipesLocation;                       \\\n                                                                         \\\n      Gap gap = state.gaps[i];                                           \\\n                                                                         \\\n      outputColor.x = gap.position;                                      \\\n      outputColor.y = gap.size;                                          \\\n    }                                                                    \\\n  }     \n\n\n#define MS_STANDARD_1  vec2[](vec2(0.0))\n#define MS_STANDARD_2  vec2[](vec2(-0.25), vec2(0.25))\n#define MS_STANDARD_4  vec2[](                                           \\\n                         vec2(-0.125, -0.375), vec2(0.375, -0.125),      \\\n                         vec2(-0.375,  0.125), vec2(0.125,  0.375)       \\\n                       )\n#define MS_STANDARD_8  vec2[](                                           \\\n                         vec2( 0.0625, -0.1875), vec2(-0.0625,  0.1875), \\\n                         vec2( 0.3125,  0.0625), vec2(-0.1875, -0.3125), \\\n                         vec2(-0.3125,  0.3125), vec2(-0.4375, -0.0625), \\\n                         vec2( 0.1875,  0.4375), vec2( 0.4375, -0.4375)  \\\n                       )\n                            \n#define MS_STANDARD_16 vec2[](                                           \\\n                         vec2( 0.0625,  0.0625), vec2(-0.0625, -0.1875), \\\n                         vec2(-0.1875,  0.125 ), vec2( 0.25  , -0.0625), \\\n                         vec2(-0.3125, -0.125 ), vec2( 0.125 ,  0.3125), \\\n                         vec2( 0.3125,  0.1875), vec2( 0.1875, -0.3125), \\\n                         vec2(-0.125 ,  0.375 ), vec2( 0.0   , -0.4375), \\\n                         vec2(-0.25  , -0.375 ), vec2(-0.375 ,  0.25  ), \\\n                         vec2(-0.5   ,  0.0   ), vec2( 0.4375, -0.25  ), \\\n                         vec2( 0.375 ,  0.4375), vec2(-0.4375, -0.5   )  \\\n                       )\n                             \n#define AA_1                                                             \\\n  const int sampleCount = 1;                                             \\\n  const vec2[] samplePositions = MS_STANDARD_1;\n\n#define AA_2                                                             \\\n  const int sampleCount = 2;                                             \\\n  const vec2[] samplePositions = MS_STANDARD_2;\n\n#define AA_4                                                             \\\n  const int sampleCount = 4;                                             \\\n  const vec2[] samplePositions = MS_STANDARD_4;\n\n#define AA_8                                                             \\\n  const int sampleCount = 8;                                             \\\n  const vec2[] samplePositions = MS_STANDARD_8;\n\n#define AA_16                                                            \\\n  const int sampleCount = 16;                                            \\\n  const vec2[] samplePositions = MS_STANDARD_16;\n\n#define INCLUDE_SUPER_SAMPLE_FUNCTION(name, quality, takeSample)         \\\n  vec4 name(in vec2 fragCoord) {                                         \\\n    quality                                                              \\\n    vec4 result = vec4(0.0);                                             \\\n    for (int i = 0; i < sampleCount; i++) {                              \\\n      result += takeSample(fragCoord + samplePositions[i]);              \\\n    }                                                                    \\\n                                                                         \\\n    return result / float(sampleCount);                                  \\\n  }\n\n#define INCLUDE_GRID_SUPER_SAMPLE_FUNCTION(name, takeSample)             \\\n  vec4 name(in vec2 fragCoord, in int samplesSqrt) {                     \\\n    vec4 outColor = vec4(0.0);                                           \\\n    for (int x = 0; x < samplesSqrt; x++) {                              \\\n      for (int y = 0; y < samplesSqrt; y++) {                            \\\n        vec2 offset =                                                    \\\n          vec2((float(x) + 0.5) * (1.0 / float(samplesSqrt)) - 0.5,      \\\n               (float(y) + 0.5) * (1.0 / float(samplesSqrt)) - 0.5);     \\\n        vec2 samplePosition = fragCoord + offset;                        \\\n        outColor += takeSample(samplePosition);                          \\\n      }                                                                  \\\n    }                                                                    \\\n                                                                         \\\n    return outColor / float(samplesSqrt * samplesSqrt);                  \\\n  }", "buffer_a_code": "INCLUDE_GAME_CONSTANTS  \nINCLUDE_STATE_STRUCT\nINCLUDE_STATE_LOAD_FUNCTION\nINCLUDE_STATE_SAVE_FUNCTION\n\n#define KEY_SPACE 32\n#define KEY_LEFT 37\n#define KEY_RIGHT 39\n\nfloat timeDelta() {\n  return iTimeDelta * 1.0;\n}\n\nfloat random(float seed) {\n  return fract(sin(seed) * 43758.5453123);\n}\n\nGap randomGap(float seed) {\n  Gap gap;\n  \n  gap.position = (random(seed) - 0.5) * 1.3;\n  gap.size = 0.2 + random(seed * 0.37) * 0.3;\n  \n  return gap;\n}\n\nvoid initPlane(inout State state) {\n  float side = random(iDate.w) < 0.5 ? -1.0 : 1.0;\n\n  Plane plane;\n  plane.position = startingPosition;\n  plane.position.x *= side;\n  plane.angle = startingAngle * side;\n  state.plane = plane;\n}\n\nState initialState() {\n  State state;\n  \n  state.oldResolution = iResolution.xy;\n  state.newResolution = iResolution.xy;\n  \n  initPlane(state);\n  \n  state.animationState = STATE_INTRO;\n  state.animationTime = 0.0;\n  state.pipesOffset = 0.0;\n  state.score = 0;\n  state.highScore = 0;\n  state.traveledDistance = 0.0;\n  \n  state.isPlayPressed = false;\n  \n  for (int i = 0; i < pipesCount; i++) {\n    state.gaps[i] = randomGap(float(i));\n  }\n  \n  return state;\n}\n\nvoid handlePlayButton(inout State state) {\n  if (state.isPlayPressed && !isKeyDown(KEY_SPACE)) {\n    state.animationState = STATE_OUTRO;\n    state.animationTime = 0.0;\n  }\n  state.isPlayPressed = isKeyDown(KEY_SPACE);\n}\n\nfloat planeFall(in Plane plane) {\n  float speed = timeDelta() * 2.0;\n  return (0.9 - pow(abs(plane.angle), 1.4)) * speed;\n}\n\nvoid movePlane(inout Plane plane) {\n  float speed = timeDelta() * 2.0;\n  plane.position.x += plane.angle * speed;\n  plane.position.y -= planeFall(plane);\n}\n\nvec2 planeHitbox(in Plane plane) {\n  float angle = plane.angle * 2.1 + 3.1416 * 0.5;\n  vec2 hitbox = plane.position - vec2(cos(angle), sin(angle)) * planeSize * 0.39;\n  hitbox.y += planeSize * 0.05;\n  return hitbox;\n}\n\nbool outOfBounds(in vec2 hitbox) {\n  return hitbox.x < -1.0 || hitbox.x > 1.0; \n}\n\nbool intersectsPipes(in vec2 hitbox, in State state) {\n  for (int i = 0; i < pipesCount; i++) {\n    Gap gap = state.gaps[i];\n    vec2 position = vec2(gap.position, \n      pipesStart + state.pipesOffset + float(i) * pipesGap);\n    float deltaY = abs(hitbox.y - position.y);\n    if (deltaY < pipeSize * 0.25) {\n      float deltaX = abs(hitbox.x - position.x);\n      if (deltaX > gap.size) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nState updateState(in State state) {\n  state.oldResolution = state.newResolution;\n  state.newResolution = iResolution.xy;\n  \n  switch (state.animationState) {\n    case STATE_INTRO:\n      if (state.score > state.highScore) {\n        state.highScore = state.score;\n      }\n      state.pipesOffset += timeDelta();\n      state.animationTime += timeDelta();\n      if (state.animationTime > 0.5) {\n        handlePlayButton(state);\n      }\n      if (state.animationTime >= 1.0) {\n        state.animationState = STATE_MENU;\n      }\n      break;\n    case STATE_MENU:\n      state.pipesOffset += timeDelta();\n      handlePlayButton(state);\n      break;\n    case STATE_OUTRO:\n      movePlane(state.plane);\n      if (state.animationTime > 0.6) {\n        if (state.animationTime < 2.5) {\n          state.pipesOffset = mix(state.pipesOffset, startingOffset, 0.05);\n        } else {\n          state.animationState = STATE_IN_GAME;\n          state.traveledDistance = 0.0;\n          state.score = 0;\n        }\n      } else {\n        state.pipesOffset += timeDelta();\n      }\n      state.animationTime += timeDelta();\n      break;\n    case STATE_IN_GAME:\n      if (isKeyDown(KEY_LEFT)) {\n        state.plane.angle -= turningSpeed * timeDelta();\n      }\n      if (isKeyDown(KEY_RIGHT)) {\n        state.plane.angle += turningSpeed * timeDelta();\n      }\n      state.plane.angle = clamp(state.plane.angle, -0.5, 0.5);\n    \n      movePlane(state.plane);\n    \n      if (state.plane.position.y < planeMinPosition) {\n        float delta = abs(state.plane.position.y - planeMinPosition);\n        state.pipesOffset += delta;\n        state.traveledDistance += delta;\n        state.plane.position.y = planeMinPosition;\n      }\n     \n      state.score = int((state.traveledDistance - 0.45) / pipesGap);\n      \n      vec2 hitbox = planeHitbox(state.plane); \n      if (outOfBounds(hitbox) || intersectsPipes(planeHitbox(state.plane), state)) {\n        state.animationState = STATE_GAME_OVER;\n        state.animationTime = 0.0;\n      }\n      state.animationTime += timeDelta();\n      break;\n      \n    case STATE_GAME_OVER:\n      state.animationTime += timeDelta();\n      float delta = planeFall(state.plane);\n      state.pipesOffset += delta;\n      state.plane.position.y += delta;\n      \n      if (state.animationTime > 1.0) {\n        state.animationState = STATE_INTRO;\n        state.animationTime = 0.0;\n        initPlane(state);\n      }\n      break;\n  }\n  \n  if (state.pipesOffset > pipesGap) {\n    state.pipesOffset = mod(state.pipesOffset, pipesGap);\n    for (int i = pipesCount - 1; i > 0; i--) {\n      state.gaps[i] = state.gaps[i - 1];\n    }\n    state.gaps[0] = randomGap(iTime);\n  }\n  \n  return state;\n}\n  \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = vec4(0.0);\n  fragmentCoordinates = ivec2(fragCoord).x;\n  if (fragmentCoordinates < endOfData) {\n    if (iFrame == 0) {\n      saveState(initialState());\n    } else {\n      saveState(updateState(loadState()));\n    }\n    fragColor = outputColor;\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "INCLUDE_TEXTURE_GRID_WIDTH\n\nconst float pi = 3.1416;\nconst float epsilon = 0.00001;\nconst vec3 right = vec3(1.0, 0.0, 0.0);\nconst vec3 up = vec3(0.0, 1.0, 0.0);\nconst vec3 forward = vec3(0.0, 0.0, -1.0);\n\nconst vec3[] points =\n    vec3[](vec3(0.0, -1.3, 0.0), vec3(-1.0, 1.0, 0.0), vec3(-0.21, 1.0, 0.0),\n           vec3(0.0, 0.92, -0.4), vec3(0.21, 1.0, 0.0), vec3(0.9, 1.0, 0.0));\nconst ivec3[] triangles =\n    ivec3[](ivec3(0, 1, 2), ivec3(2, 3, 0), ivec3(3, 4, 0), ivec3(4, 5, 0));\nconst ivec2[] lines =\n    ivec2[](ivec2(0, 1), ivec2(0, 2), ivec2(0, 3), ivec2(0, 4), ivec2(0, 5),\n            ivec2(1, 2), ivec2(2, 3), ivec2(3, 4), ivec2(4, 5));\nconst int lengthTriangles = 4;\nconst int lengthLines = 9;\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n    \nstruct Sphere {\n  vec3 origin;\n  float radius;\n};\n    \nmat4 rotationMatrix(in vec3 axis, in float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n      oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,\n      oc * axis.z * axis.x + axis.y * s, 0.0, oc * axis.x * axis.y + axis.z * s,\n      oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n      oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s,\n      oc * axis.z * axis.z + c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 translationMatrix(in vec3 translation) {\n  return mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,\n              translation.x, translation.y, translation.z, 1.0);\n}\n\nRay createRayOrthographic(in vec2 screenPosition) {\n  return Ray(vec3(screenPosition, 0.0), vec3(0.0, 0.0, -1.0));\n}\n\nvec3 positionOnRay(in Ray ray, in float t) {\n  return ray.origin + ray.direction * t;\n}\n\nvoid transformRay(inout Ray ray, mat4 matrix) {\n  ray.origin = (matrix * vec4(ray.origin, 1.0)).xyz;\n  ray.direction = normalize(matrix * vec4(ray.direction, 0.0)).xyz;\n}\n\nbool rayIntersectsSphere(in Ray ray, in Sphere sphere, out float t0,\n                         out float t1) {\n  float a = dot(ray.direction, ray.direction);\n  vec3 s0_r0 = ray.origin - sphere.origin;\n  float b = 2.0 * dot(ray.direction, s0_r0);\n  float c = dot(s0_r0, s0_r0) - (sphere.radius * sphere.radius);\n  float delta = b * b - 4.0 * a * c;\n  float a_2 = 2.0 * a;\n\n  if (delta < 0.0) {\n    return false;\n  }\n\n  float delta_sqrt = sqrt(delta);\n\n  t0 = (-b - delta_sqrt) / a_2;\n  t1 = (-b + delta_sqrt) / a_2;\n\n  return true;\n}\n\nbool rayIntersectsTriangle(in Ray ray, in vec3 v0, in vec3 v1, in vec3 v2,\n                           out float t) {\n  vec3 edge1, edge2, h, s, q;\n  float a, f, u, v;\n\n  edge1 = v1 - v0;\n  edge2 = v2 - v0;\n\n  h = cross(ray.direction, edge2);\n  a = dot(edge1, h);\n\n  if (a > -epsilon && a < epsilon)\n    return false;\n\n  f = 1.0 / a;\n  s = ray.origin - v0;\n  u = f * dot(s, h);\n\n  if (u < 0.0 || u > 1.0)\n    return false;\n\n  q = cross(s, edge1);\n  v = f * dot(ray.direction, q);\n\n  if (v < 0.0 || u + v > 1.0)\n    return false;\n\n  // At this stage we can compute t to find out where the intersection point is\n  // on the line.\n  t = f * dot(edge2, q);\n  if (t > epsilon) // ray intersection\n  {\n    return true;\n  }\n\n  // This means that there is a line intersection but not a ray intersection.\n  return false;\n}\n\nbool rayIntersectsCylinder(in Ray ray, in vec3 pa, in vec3 pb, in float radius, \n                           out float t0, out float t1) {\n  vec3 ro = ray.origin;\n  vec3 rd = ray.direction;\n\n  vec3 cc = 0.5 * (pa + pb);\n  float ch = length(pb - pa);\n  vec3 ca = (pb - pa) / ch;\n  ch *= 0.5;\n\n  vec3 oc = ro - cc;\n\n  float card = dot(ca, rd);\n  float caoc = dot(ca, oc);\n\n  float a = 1.0 - card * card;\n  float b = dot(oc, rd) - caoc * card;\n  float c = dot(oc, oc) - caoc * caoc - radius * radius;\n  float h = b * b - a * c;\n  if (h < 0.0)\n    return false;\n  h = sqrt(h);\n  t0 = (-b - h) / a;\n  t1 = (-b + h) / a; // exit point\n\n  float y = caoc + t0 * card;\n\n  // body\n  if (abs(y) < ch) {\n    return true;\n  }\n\n  return false;\n}\n\nbool rayIntersectsLine(in Ray ray, in vec3 pa, in vec3 pb, in float radius, out float t) {\n  float t0, trash;\n\n  t = 100000.0;\n\n  bool i = false;\n  if (rayIntersectsSphere(ray, Sphere(pa, radius), t0, trash)) {\n    t = t0;\n    i = true;\n  }\n\n  if (rayIntersectsSphere(ray, Sphere(pb, radius), t0, trash) && t0 < t) {\n    t = t0;\n    i = true;\n  }\n\n  if (rayIntersectsCylinder(ray, pa, pb, radius, t0, trash) && t0 < t) {\n    t = t0;\n    i = true;\n  }\n\n  return i;\n}\n\n\nvec4 trace(in Ray ray, int i) {\n  vec4 color = vec4(0.0);  \n    \n  float total = float(textureGridWidth * textureGridWidth - 2);\n  float angle = float(i - 1) / total - 0.5;  \n    \n  mat4 transform = rotationMatrix(up, 0.0) *\n                   rotationMatrix(forward, angle * 2.2) *\n                   rotationMatrix(right, -0.6) *\n                   translationMatrix(vec3(0.0, 0.0, 12.0));\n  transformRay(ray, transform);  \n    \n  float t0 = 100000.0;\n  for (int i = 0; i < lengthTriangles; i++) {\n    ivec3 triangle = triangles[i];\n    vec3 a = points[triangle[0]];\n    vec3 b = points[triangle[1]];\n    vec3 c = points[triangle[2]];\n\n    float t;\n    if (rayIntersectsTriangle(ray, a, b, c, t) && t < t0) {\n      t0 = t - 0.0;\n      color = vec4(1.0);\n    }\n  }\n\n  for (int i = 0; i < lengthLines; i++) {\n    ivec2 line = lines[i];\n    vec3 a = points[line[0]];\n    vec3 b = points[line[1]];\n\n    float t;\n    vec3 normal;\n    if (rayIntersectsLine(ray, a, b, 0.04, t) && t < t0) {\n      t0 = t;\n      color = vec4(vec3(0.0), 1.0);\n    }\n  } \n    \n  return color;\n}\n\nvec4 drawPipe(in vec2 position) {\n  float offset = position.x < 0.0 ? 0.17 : 0.0;\n \n  if (position.x > 0.8) {\n    return vec4(0.0);\n  }\n \n  if (abs(position.y) < 0.9 - offset) {\n    if ((abs(position.y) < 0.8 - offset) && \n        !(position.x > 0.0 && position.x < 0.1) && \n        (position.x < 0.7)) {\n      float y = position.y + offset * 0.97;\n      vec3 color = vec3(0.458, 0.835, 0.184);\n      color = y > 0.57 && y < 0.73 ? vec3(0.803, 0.964, 0.505) : color;\n      color = y > 0.45 && y < 0.53 ? vec3(0.740, 0.940, 0.442) : color;\n      color = y > 0.37 && y < 0.4 ? vec3(0.658, 0.935, 0.284) : color;\n      y = position.y - offset * 0.9;\n      color = y < -0.55 && y > -0.8 ? vec3(0.380, 0.734, 0.145) : color;\n      color = y < -0.7 && y > -0.8 ? vec3(0.280, 0.634, 0.145) : color;\n      \n      return vec4(toLinear(color), 1.0);\n    }\n    \n    return vec4(toLinear(vec3(0.233, 0.227, 0.247)), 1.0);\n  }\n  \n  return vec4(0.0);\n}\n\nvec4 takeSample(in vec2 position) {\n  float size = iResolution.y / float(textureGridWidth);\n  ivec2 xy = ivec2(position / size);\n  position = mod(position, size); \n  position -= vec2(0.5 * size);\n  position /= size * 0.33;\n    \n  int i = xy.x + xy.y * textureGridWidth;\n  if (i == 0) {\n    position *= 1.2;\n    return drawPipe(position);\n  } else {\n    Ray ray = createRayOrthographic(position);\n    return trace(ray, i);\n  }\n}\n\nbool resolutionChanged() {\n  vec4 resolutionData = loadVariable(resolutionLocation);\n  return resolutionData.xy != resolutionData.zw;\n}\n\n\nINCLUDE_SUPER_SAMPLE_FUNCTION(superSample, AA_16, takeSample)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  if (iFrame > 0 && !resolutionChanged()) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel1, uv);\n    return;\n  }   \n    \n  if (fragCoord.x > iResolution.y) {\n    fragColor = vec4(0.0);\n    return;\n  }\n    \n  fragColor = superSample(fragCoord);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstczS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[293, 293, 334, 334, 448], [450, 450, 474, 474, 558], [560, 560, 593, 593, 661], [663, 663, 713, 713, 1033], [1035, 1035, 1155, 1155, 1635], [1637, 1637, 1664, 1664, 1742], [1744, 1744, 1768, 1768, 1790], [1792, 1792, 1817, 1817, 1866], [1904, 1904, 1933, 1933, 2132], [2134, 2134, 2239, 2239, 2464], [2466, 2466, 2526, 2526, 2918], [4302, 4302, 4358, 4358, 4824], [6857, 6857, 6983, 6983, 7317], [7319, 7319, 7381, 7381, 8911], [8913, 8913, 8970, 8970, 9322], [9324, 9324, 9371, 9371, 9474], [9476, 9476, 9531, 9531, 10105]], "test": "untested"}
{"id": "stcXD7", "name": "Isometric Grid Height Map", "author": "Shane", "description": "Rendering some overlapping hexagons on an isometric grid to produce a height map of extruded blocks.", "tags": ["2d", "grid", "hexagon", "heightmap", "vector", "isometric", "block"], "likes": 68, "viewed": 1253, "published": 3, "date": "1639406773", "time_retrieved": "2024-07-30T18:42:10.183625", "image_code": "/*\n\n    Isometric Grid Height Map\n    -------------------------\n    \n    Rendering some overlapping hexagons in an isometric grid fashion \n    to produce a height map of extruded blocks. Isometric grid \n    renderings are certainly not new, but they're fun and simple to \n    code.\n    \n    I had a few versions of this lying around for ages, but wasn't \n    inspired to do anything with them until Bitless posted his really \n    cool \"Cyberspace data warehouse\" example. He put isometric height\n    maps on the faces of isometric cubes, which the isometric design \n    crowd have probably done before, but it was new to me. For anyone \n    who hasn't seen it, the link is below.\n    \n    A lot of people are familiar with the isometric height map concept, \n    but for anyone who isn't, you render cubes (or an extruded version) \n    in back to front order in a diamond pattern, or corresponding \n    patterns to cover the amount of overlap. In this case, I'm rendering \n    seven cells in a hexagon pattern.\n    \n    Just to mix things up a little and break the visual monotony, I\n    rendered columns of differing width and offset them a bit. Other \n    than that, there's not a lot to it.\n    \n    By the way, rendering in this way is fun, novel and fast, but there \n    are way better 3D methods that will achieve the same.  I've attached \n    a link to a much simpler version of this for anyone interested in \n    the process, or code golfing an isometric heightmap, maze, etc. :)\n    \n    \n    \n    Inspired by the following:\n    \n    // Very cool, and unique.\n    Cyberspace data warehouse - bitless\n    https://www.shadertoy.com/view/NlK3Wt\n    \n    // Here's a more sophisticated example. It requires more\n    // work, but is based on a similar concept.\n    Isometric City 2.5D - knarkowicz\n    https://www.shadertoy.com/view/MljXzz\n    \n    // A less interesting, but easier to understand, verion:\n    Isometric Height Map - Shane\n    https://www.shadertoy.com/view/flcSzX\n    \n*/\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// Using two hexagons to creat an extruded box of varying height.\n// I hacked in some logic to make it happen, but there might be\n// more efficient ways. Either way, it works, so it'll do.\nfloat dist(vec2 p, float h, float sz){\n\n    //return length(p);\n    \n     // The vertical height component of the hexagon. We're taking\n    // a little off to get rid of artifacts.\n    float szD = sz/.8660254 - .015;\n    \n    // Height factor. More height looks more interesting, but too much\n    // sends the blocks out of the cell range and causes artifacts.\n    const float hFact = .75;\n    \n    // Moving the blocks down a bit to maximize the range. I've hack a \n    // number in, but you could probably calculate something.\n    p.y -= -.1;\n    \n    \n    // I should be rendering three calculated polygons consisting of\n    // the top and two sides, but that requires more effort and GPU\n    // power, so I've merely merged a base hexagon and a hexagon on\n    // top that moves in the Y direction according to the height,\n    // which is good enough for this example.\n    vec2 q = abs(p);\n    float hxB = max(q.y*.8660254 + q.x*.5, q.x);\n    \n    q = abs(p - vec2(0, szD - h)*hFact);\n    float hxH = max(q.y*.8660254 + q.x*.5, q.x);\n\n    // If the block is less that the size of a hexagon, you need the\n    // maximum overlay of the two. If it's above the height of the\n    // base hexagon, fuse the two together... It took me while to \n    // figure that out, but it works.\n    float d = max(hxB, hxH);\n    if(h - szD<0.) d = min(hxB, hxH);\n    return d;\n    \n}\n\n// If you're rendering triangles, hexagons, isometric grids, etc, the number\n// 1.732 (sqrt(3)) will come up all the time.\nconst vec2 s = vec2(1.7320508, 1);\n\n// Hexagon grid.\nvec4 getGrid(vec2 p){\n\n    // Finding the local coordinates and ID of the nearest hexagon center.\n    vec4 ip = floor(vec4(p/s, p/s + .5));\n    vec4 q = p.xyxy - vec4(ip.xy + .5, ip.zw)*s.xyxy;\n    return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw - .5);\n   \n}\n\nfloat height(vec2 p){\n\n    //float rnd = hash21(p);\n    //return smoothstep(.5, .95, sin(rnd*6.2831 + iTime)*.5 + .5);\n    float tm = mod(iTime/1.5, 6.2831);\n    float h = dot(sin(p*.73/1.25 - cos(p.yx*.97/1.25 - tm)*2.3), vec2(.25)) + .5;\n    p *= 2.;\n    float h2 = dot(sin(p*.73/1.25 - cos(p.yx*.97/1.25 - tm*2.)*2.3), vec2(.25)) + .5;\n    h = mix(h, h2, .333);\n    return smoothstep(0., 1., h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\n    // Aspect correct coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    // Scale and smoothing factor.\n    const float sc = 16.;\n    float sf = sc/iResolution.y;\n    \n    \n    // Scaling and translation.\n    vec2 p = uv*sc + s*iTime/3.;\n    // Including rotation for a side wall perpective.\n    //vec2 p = rot2(-3.14159/2.)*uv*vec2(-1, 1)*sc + s.yx*iTime/4.;\n    \n    \n    // Scene field calculations.\n    \n    // Light direction. Shining down and to the left.\n    vec2 ld = normalize(s);\n    \n  \n   \n    // Rendering in a diamond grouping. Top first, the two below that, and the bottom.\n    //vec2[4] cntr = vec2[4](vec2(0, .5), vec2(-.5, 0), vec2(.5, 0), vec2(0, -.5));\n    \n    \n    // Rendering in a seven cell grouping, and taking rendering order into account:\n    // Top cell first, then the two below, the one below those, two more below\n    // that and the one on the bottom.\n    vec2[7] cntr = vec2[7](vec2(0, .5), vec2(-.5, 0), vec2(.5, 0), vec2(0, -.5),\n                           vec2(-.5, -.5), vec2(.5, -.5), vec2(0, -1));    \n    \n    float obj[7], objSh[7], side[7], side2[7], top[7], hgt[7];\n    vec4[7] p4I;\n\n    \n    // The block width. The maximum is s.y/2. (.8660254) and will produce a packed \n    // grid with no gaps. However, due to overlap, the height needs to be reduced.\n    float sz = .7;\n    vec2 szOffs = sz/s.yx;\n    \n    // Object shadow.\n    float objShad = 1e5;\n    \n    for(int i = min(0, iFrame); i<7; i++){\n   \n        // Obtain the hexagon and ID for this position. I could probably \n        // streamline the process, but this will do.\n        vec4 p4 = getGrid(p + cntr[i]*s);\n        // Random 2D offset.\n        vec2 offs = vec2(hash21(p4.zw + .1), hash21(p4.zw + .2)) - .5;\n        // Random size.\n        sz = .7*(hash21(p4.zw + .3)*.35 + .65);\n        szOffs = sz/s.yx; \n        // Position based height. \n        float h = height(p4.zw*s);\n        vec2 q = p4.xy - cntr[i]*s - offs*vec2(.2, .2); \n        \n        // The extruded column object, which is just two overlayed \n        // hexagons in disguise.\n        obj[i] = dist(q, h, sz) - sz;\n        \n        /*\n        // Failed experiment with different tops.\n        float bx = -1e5;\n        if(hash21(p4.zw + .23)<.5){\n           bx = max(abs(q.x) - sz, \n                    abs(q.y - (sz/.8660254 - .015 - h)*.75 - .15) - sz*.5);\n        }\n        */\n        \n        // Using the column object above and some simple CSG to construt \n        // the top and sides.\n        float sd1 = dist(q - vec2(-1)*szOffs, h, sz) - sz;\n        float sd2 = dist(q - vec2(1, -1)*szOffs, h, sz) - sz;\n        side[i] = max(obj[i], sd1);\n        side2[i] = max(obj[i], sd2);\n        top[i] = max(obj[i], -min(sd1, sd2));\n        \n        // Failed experiment with different tops.\n        //top[i] = max(top[i] - .05, bx);  \n        \n        // The shadow of the column object.\n        objSh[i] = dist(q - ld*.5*sz, h, sz) - sz;\n        \n        // Saving the height, and hexagon cell information.\n        hgt[i] = h;\n        p4I[i] = p4;\n        \n        // The shadow is laid down first on the background, so can be\n        // calculated here.\n        objShad = min(objShad,  objSh[i]);\n \n    }\n     \n  \n\n    \n    // Initiate the scene color to the background.\n    vec3 col = vec3(.3, .25, .2);\n    \n \n    // Rendering the object shadows onto the background. \n    col = mix(col, vec3(.05, .05, .1), (1. - smoothstep(0., sf*2., objShad))*.4);\n     \n   \n    // Loop through all seven object cells and rendering the objects.\n    for(int i = min(0, iFrame); i<7; i++){\n        \n        // Dark glow around the objects for more fake AO.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., obj[i]))*.35);\n        \n        // Unique position-based cell ID.\n        vec2 id = p4I[i].zw;\n        \n        \n        // Coloring -- Mildly inspired by the colors in Shadertoy's in-house\n        // \"Rock Tiles\" texture.\n        float rnd = hash21(id);\n        float fn = dot(sin(id*s/3.5/1.5 - cos(id.yx*s/2.3/1.5)*2.), vec2(.25)) + .5;\n        fn = smoothstep(.1, .9, fn);  \n        vec3 oCol = .6 + .4*cos(6.2831*mix(fn, rnd, .65)/3. + vec3(0, 1, 2)/1.65);  \n        oCol = mix(oCol, oCol.xzy, fn*(hash21(id + .3)*.25 + .25));\n        if(hash21(id + .27)<.33) oCol = oCol*.6;\n        if(hash21(id + .37)<.66) oCol = min(oCol*1.4, 1.);\n        /*\n        // Load in the \"Rock Tiles\" texture for a comparison.\n        vec3 tx = texture(iChannel0, id*s/sc/1.5).xyz; tx *= tx;\n        tx = smoothstep(-.05, .7, tx);\n        vec3 oCol = tx*1.5;\n        */\n       \n        // Using the height for some extra shadowing.\n        float shad = 1. - hgt[i]*.5;\n        \n       \n        // The top of the extruded box.\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, top[i])); // Edge, or stroke.\n        //col = mix(col, oCol*ao*2., 1. - smoothstep(0., sf, top[i] + .04)); \n        //col = mix(col, vec3(0), 1. - smoothstep(0., sf, top[i] + .1)); \n        col = mix(col, oCol*shad, 1. - smoothstep(0., sf, top[i] + .04)); // Main.\n        // Render dark holes on random faces to break up the monotony.\n        if(hash21(id + .34)<.5){\n        //if(mod(p4I[i].z + p4I[i].w, 2.)<.5){ // Checkered option.\n            col = mix(col, vec3(0), 1. - smoothstep(0., sf, top[i] + .22)); \n            col = mix(col, oCol*shad/3., 1. - smoothstep(0., sf, top[i] + .265)); \n        }         \n\n        \n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, side[i])); // Edge, or stroke.\n        //col = mix(col, vec3(.25, .5, .75)*shad, 1. - smoothstep(0., sf, side[i] + .04));\n        //col = mix(col, vec3(0), 1. - smoothstep(0., sf, side[i] + .1));      \n        col = mix(col, oCol*vec3(.25, .5, .75)*shad, 1. - smoothstep(0., sf, side[i] + .04)); // Main.\n        \n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, side2[i])); // Edge, or strke.\n        //col = mix(col, vec3(2, .75, .5)*shad, 1. - smoothstep(0., sf, side2[i] + .04)); // Edge, or stroke.\n        //col = mix(col, vec3(0), 1. - smoothstep(0., sf, side2[i] + .1)); // Edge, or strke.       \n        col = mix(col, oCol*vec3(2, .75, .5)*shad, 1. - smoothstep(0., sf, side2[i] + .04)); // Main.\n    \n   \n    }\n   \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n\n \n    // Rough gamma correction, and screen presentation.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcXD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1993, 2026, 2048, 2048, 2106], [2109, 2137, 2158, 2158, 2221], [2224, 2413, 2451, 2593, 3779], [3940, 3957, 3978, 4054, 4244], [4246, 4246, 4267, 4364, 4646]], "test": "untested"}
{"id": "7lcSz2", "name": "Hello 4D Cube", "author": "IWBTShyGuy", "description": "My first 4D raymarching.", "tags": ["4d"], "likes": 8, "viewed": 262, "published": 3, "date": "1639404971", "time_retrieved": "2024-07-30T18:42:11.163006", "image_code": "// The MIT License\n// Copyright  2021 IWBTShyGuy \n\n#define AA 2\n\n// cf: https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec4 p, vec4 b ) {\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,max(q.z, q.w))),0.0);\n}\n\n// cf: https://iquilezles.org/articles/distfunctions\nfloat sdBoxFrame( vec4 p, vec4 b, float e ) {\n  p = abs(p)-b;\n  vec4 q = abs(p+e)-e;\n  return min(min(min(\n      length(max(vec4(p.x,q.y,q.z,q.w),0.0))+min(max(max(max(p.x,q.y),q.z),q.w),0.0),\n      length(max(vec4(q.x,p.y,q.z,q.w),0.0))+min(max(max(max(q.x,p.y),q.z),q.w),0.0)),\n      length(max(vec4(q.x,q.y,p.z,q.w),0.0))+min(max(max(max(q.x,q.y),p.z),q.w),0.0)),\n      length(max(vec4(q.x,q.y,q.z,p.w),0.0))+min(max(max(max(q.x,q.y),q.z),p.w),0.0));\n}\n\nfloat sDist(in vec4 p) {\n    if (fract(iTime / 20.0) < 0.5) {\n        return sdBox(p, vec4(0.5));\n    } else {\n        return sdBoxFrame(p, vec4(0.5),0.1);\n    }\n}\n\nvec4 calcNormal(in vec4 p) {\n    const vec2 e = vec2(1.0e-4, 0);\n    return normalize(vec4(\n        sDist(p + e.xyyy) - sDist(p - e.xyyy),\n        sDist(p + e.yxyy) - sDist(p - e.yxyy),\n        sDist(p + e.yyxy) - sDist(p - e.yyxy),\n        sDist(p + e.yyyx) - sDist(p - e.yyyx)\n    ));\n}\n\nconst float FAR = 12.0;\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 dir = vec4(\n        cos(iTime * 0.5),\n        sin(iTime * 0.5),\n        cos(iTime * 0.3),\n        sin(iTime * 0.3)\n    );\n    Camera camera = newCamera(\n        -dir * 3.0 / sqrt(2.0),\n        normalize(dir),\n        vec4(0, 1, 0, 0),\n        vec4(\n            -sin(iTime * 0.5),\n            cos(iTime * 0.5),\n            -sin(iTime * 0.3),\n            cos(iTime * 0.3)\n        ),\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, fragCoord / iResolution.xy);\n\n    float dist = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec4 p = ray.origin + dist * ray.direction;\n        float dist0 = sDist(p);\n        if (dist0 < 1.0e-6 || dist > FAR) break;\n        dist += dist0;\n    }\n\n    vec3 col = vec3(0);\n    if (dist < FAR) {\n        vec4 p = ray.origin + dist * ray.direction;\n        vec4 normal = calcNormal(p);\n        float c = -dot(normal, ray.direction);\n        col += c * (p.xyz + 0.5);\n    }\n\n    fragColor = vec4(pow(col, vec3(0.4545)), 1);\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    \n// smart anti-aliasing\n// reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\n// If defined, visualize anti-aliased pixels.\n//#define VISUALIZE_AA\n#ifdef AA\n    if (fwidth(length(O.xyz)) > 0.1) {\n\n        O.xyz = pow(O.xyz, vec3(2.2));\n        vec4 o;\n#if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              mainImage0(o,U + (vec2(k % 2, k / 2) - 0.5) / 1.5);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 5.0;\n#elif (AA == 3)\n        for (int k = 0; k < 9; k += k == 3 ? 2 : 1 ) {\n              mainImage0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 9.0;\n#endif\n#ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n#endif\n        O.xyz = pow(O.xyz, vec3(0.4545));\n    }\n#endif\n    O.w = 1.0;\n}\n", "image_inputs": [], "common_code": "//\n// 4D toolkit\n//\n// The MIT License\n// Copyright  2021 IWBTShyGuy \n//\n\nconst float PI = 3.141592653;\n\nvec4 three_cross(in vec4 a, in vec4 b, in vec4 c) {\n    return vec4(\n        -determinant(mat3(a.yzw, b.yzw, c.yzw)),\n        determinant(mat3(a.zwx, b.zwx, c.zwx)),\n        -determinant(mat3(a.wxy, b.wxy, c.wxy)),\n        determinant(mat3(a.xyz, b.xyz, c.xyz))\n    );\n}\n\nstruct Camera {\n    vec4 position;\n    vec4 direction;\n    //@ upper direction of camera\n    //@ not need to perp to `direction`\n    vec4 up_direction;\n    //@ normal of the hyperplane\n    //@ not have to be normalized\n    //@ assumed being perp to `direction`.\n    vec4 tactile;\n    float fov;\n    //@ x / y\n    float aspect;\n};\n\nCamera newCamera(\n    in vec4 position,\n    in vec4 direction,\n    in vec4 up_direction,\n    in vec4 tactile,\n    in float fov,\n    in float aspect\n) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.tactile = tactile;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\nstruct Ray {\n    vec4 origin;\n    vec4 direction;\n};\n\n// uv: fragCoord / iResolution.xy\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float h = tan(camera.fov * 0.5);\n    float w = h * camera.aspect;    \n    vec4 right = -normalize(three_cross(camera.direction, camera.up_direction, camera.tactile));\n    vec4 up = -normalize(three_cross(right, camera.direction, camera.tactile));\n    vec4 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcSz2.jpg", "access": "api", "license": "mit", "functions": [[67, 120, 151, 151, 248], [250, 303, 348, 348, 758], [760, 760, 784, 784, 923], [925, 925, 953, 953, 1213], [1239, 1239, 1295, 1295, 2305]], "test": "untested"}
{"id": "7l3XR2", "name": "Circles Moire patterns ", "author": "ersteller", "description": "Concept from book of shaders and modified a little. ", "tags": ["circle", "star", "moire", "pattern", "subpixel"], "likes": 4, "viewed": 290, "published": 3, "date": "1639400863", "time_retrieved": "2024-07-30T18:42:11.996777", "image_code": "// from https://thebookofshaders.com/07/\n// Distance fields\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n  vec3 color = vec3(0.0);\n  float d = 0.0;\n\n  // normalize \n  vec2 st = fragCoord.xy/iResolution.xy;\n  \n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n\n  // account for aspect ratio\n  st.x *= iResolution.x/iResolution.y;\n    \n  // Make the distance field\n  d = length( abs(st) -0.75 );\n\n  // Visualize the distance field\n  fragColor = vec4(vec3(fract(d*10.0 * iTime)),1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3XR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 117, 117, 500]], "test": "untested"}
{"id": "7t3SRN", "name": "Sliced harmonics [241 chars]", "author": "hnh", "description": "Depth-illusion of some deformed grid. \nBased on the previous [url]https://www.shadertoy.com/view/slV3Rz[\\url].", "tags": ["2d", "grid", "onetweet", "golf"], "likes": 4, "viewed": 208, "published": 3, "date": "1639396491", "time_retrieved": "2024-07-30T18:42:12.832542", "image_code": "// Based on the previous https://www.shadertoy.com/view/slV3Rz\n// by squeezing out some more geometric variety. It produces\n// a minimalistic depth illusion of some sliced iso-surfaces.\n// Thanks to XOR for substancial golfing support in the base\n// version and general teachings from FabriceNeyret2 and Shane.\n\n\nvoid mainImage(out vec4 O, vec2 p){\n    float a = iTime*.1;\n    p = p/iResolution.y*4. + sin(a+vec2(8,0))*20.;  // camera\n    p *= sin(cos(p+a))*.2;  // deform\n\n    vec2 s = floor(p + (p.x + p.y)*.4);  // tilted grid, depth illusion\n    s = .6 - step(p -= s - (s.x + s.y)*.21, p.yx)*.4;\n    s *= exp(.5-8.*length(p*p-s));\n    \n    O = s.x*8. + s.y*vec4(.02,.5,2.5,1);  // colors\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3SRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[313, 313, 348, 348, 693]], "test": "untested"}
{"id": "7t3Szj", "name": "Stomper", "author": "dr2", "description": "A stomper's job is never done...", "tags": ["randomness", "kinematics"], "likes": 16, "viewed": 288, "published": 3, "date": "1639392925", "time_retrieved": "2024-07-30T18:42:13.594505", "image_code": "// \"Stomper\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec2 Hashv2f (float p);\nfloat Fbm2 (vec2 p);\n\nvec3 ltDir, qHit, pStomp;\nvec2 pAct, pActP;\nfloat tCur, dstFar, boxSz, tCyc, tPhs;\nint idObj;\nint idPlat = 1, idBallR = 2, idBallM = 3, idStomp = 4, idTube = 5, idGrnd = 6;\nconst float pi = 3.1415927;\n\nstruct TbCon {\n  vec3 pLo, pHi;\n  vec2 aLimCs, tRotCs[2], pRotCs[2];\n  float chLen, chDist, ang, rad;\n};\nTbCon tbCon;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, db, a;\n  dMin = dstFar;\n  q = p;\n  db = PrBox2Df (q.xz, vec2 (boxSz));\n  d = max (PrBoxDf (q, vec3 (vec2 (boxSz + 0.5), 0.5).xzy), - max (db,\n     PrCylDf (vec3 (fract (q.xz) - 0.5, q.y - 0.5), 0.4, 0.8)));\n  DMINQ (idPlat);\n  d = max (db, - PrBox2Df (q.xz - pAct, vec2 (0.5)));\n  q.xz = fract (q.xz) - 0.5;\n  d = max (PrSphDf (vec3 (q.xz, q.y - 0.15).xzy, 0.4), d);\n  DMINQ (idBallR);\n  q = p;\n  q.xz -= pAct;\n  q.y -= 0.15;\n  if (tPhs < 0.8) q.y -= 0.4 * (1. - cos (10. * pi * tCyc));\n  d = PrSphDf (q, 0.4);\n  DMINQ (idBallM);\n  q = p;\n  q -= pStomp;\n  d = min (PrCylDf (q.xzy, 0.35, 0.05), max (PrCapsDf (q.xzy, 0.1, 0.3), - q.y));\n  DMINQ (idStomp);\n  q = p;\n  q.xz -= tbCon.pLo.xz;\n  d = PrCylDf (q.xzy, 0.4, 0.5);\n  DMINQ (idPlat);\n  q.y -= 0.5;\n  d = max (PrCapsDf (q.xzy, 0.1, 0.3), - q.y);\n  DMINQ (idTube);\n  d = min (PrSphDf (p - tbCon.pLo, 0.1), PrSphDf (p - tbCon.pHi, 0.1));\n  DMINQ (idTube);\n  q = p - tbCon.pLo;\n  q.xz = Rot2Cs (q.xz, tbCon.tRotCs[0]);\n  q.yz = Rot2Cs (q.yz, tbCon.tRotCs[1]) - vec2 (tbCon.chLen, tbCon.chDist);\n  a = fract ((256. / tbCon.ang) * atan (q.y, - q.z) / (2. * pi));\n  d = max (dot (vec2 (abs (q.y), - q.z), tbCon.aLimCs), length (vec2 (length (q.yz) -\n     tbCon.rad, q.x)) - (0.1 - 0.015 * smoothstep (0.15, 0.35, 0.5 - abs (0.5 - a))));\n  DMINQ (idTube);\n  q = p;\n  d = max (q.y - 0.4, - db);\n  DMINQ (idGrnd);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  int idObjT;\n  idObjT = idObj;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  idObj = idObjT;\n  return 0.5 + 0.5 * sh;\n}\n\n#define F(x) (sin (x) / x - b)\n\nfloat SecSolve (float b)\n{  // (from \"Bucking Bronco\")\n  vec3 t;\n  vec2 f;\n  float x;\n  if (b < 0.95) {\n    t.yz = vec2 (0.7, 1.2);\n    f = vec2 (F(t.y), F(t.z));\n    for (int nIt = 0; nIt < 4; nIt ++) {\n      t.x = (t.z * f.x - t.y * f.y) / (f.x - f.y);\n      t.zy = t.yx;\n      f = vec2 (F(t.x), f.x);\n    }\n    x = t.x;\n  } else if (b < 1.) {\n    x = sqrt (10. * (1. - sqrt (1. - 1.2 * (1. - b))));\n  } else {\n    x = 0.;\n  }\n  return x;\n}\n\nvoid SetConf ()\n{\n  vec3 vp;\n  float tubeLen;\n  boxSz = 4.;\n  tCyc = tCur / 2. + 1.;\n  tPhs = fract (tCyc);\n  pAct = floor (boxSz * (2. * Hashv2f (1.11 + 17.33 * floor (tCyc)) - 1.)) + 0.5;\n  pActP = floor (boxSz * (2. * Hashv2f (1.11 + 17.33 * floor (tCyc - 1.)) - 1.)) + 0.5;\n  if (tPhs < 0.8) {\n    pStomp.xz = mix (pActP, pAct, tPhs / 0.8);\n    pStomp.y = 1.7;\n  } else {\n    pStomp.xz = pAct;\n    pStomp.y = mix (0.5, 2., max (2. * abs (tPhs - 0.9) / 0.1 - 1., 0.));\n  }\n  tbCon.pLo = vec3 (1.5 * boxSz, 0.9, 0.);\n  tbCon.pHi = pStomp;\n  tbCon.pHi.y += 0.4;\n  vp = tbCon.pHi - tbCon.pLo;\n  tbCon.chLen = 0.5 * length (vp);\n  tbCon.tRotCs[0] = sin (atan (vp.x, vp.z) + vec2 (0.5 * pi, 0.));\n  tbCon.tRotCs[1] = sin (- asin (length (vp.xz) / length (vp)) + vec2 (0.5 * pi, 0.));\n  tubeLen = 1.4 * boxSz;\n  tbCon.ang = SecSolve (tbCon.chLen / tubeLen);\n  tbCon.chDist = tbCon.chLen / tan (tbCon.ang);\n  tbCon.rad = length (vec2 (tbCon.chDist, tbCon.chLen));\n  tbCon.aLimCs = sin (- tbCon.ang + vec2 (0.5 * pi, 0.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, sh, nDotL;\n  SetConf ();\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idPlat) {\n      col4 = vec4 (0.5, 0.2, 0., 0.2);\n    } else if (idObj == idGrnd) {\n      col4 = vec4 (0.5, 0.2, 0., 0.2) * (0.8 + 0.2 * Fbm2 (4. * ro.xz));\n    } else if (idObj == idBallR) {\n      col4 = vec4 (0., 1., 0., 0.2);\n      if (PrBox2Df (ro.xz - pActP, vec2 (0.5)) < 0.) col4 = mix (vec4 (1., 0., 0., 0.2) *\n         (0.7 + 0.3 * sin (16. * pi * tCur)), col4, smoothstep (0.2, 0.6, tPhs));\n    } else if (idObj == idBallM) {\n      col4 = vec4 (1., 0., 0., 0.2);\n      if (tPhs > 0.9) col4 = vec4 (0.7, 0.5, 0., 0.2);\n    } else if (idObj == idStomp) {\n      col4 = mix (vec4 (1., 1., 1., 0.2), vec4 (0., 0., 1., -1.),\n         smoothstep (0., 0.02, length (qHit.xz) - 0.25));\n    } else if (idObj == idTube) {\n      col4 = vec4 (1., 1., 1., 0.2);\n    }\n    if (idObj == idBallR || idObj == idBallM) col4 *= 0.7 + 0.3 * smoothstep (0., 0.02,\n       abs (length (qHit.xz) - 0.2) - 0.02);\n    if (col4.a >= 0.) {\n      nDotL = max (dot (vn, ltDir), 0.);\n      if (idObj == idTube) nDotL *= nDotL;\n      sh = ObjSShadow (ro + 0.01 * vn, ltDir);\n      col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n         col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n      col *= 1. - 0.9 * smoothstep (0.2, 0.3, length (ro.xz) / dstFar);\n    } else col = col4.rgb * (0.5 + 0.5 * max (- dot (rd, vn), 0.));\n  } else {\n    col = vec3 (0.1);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  el = clamp (el, -0.4 * pi, -0.13 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 1., -30.);\n  zmFac = 5.5;\n  dstFar = 60.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3Szj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[905, 905, 927, 927, 2330], [2332, 2332, 2365, 2365, 2549], [2551, 2551, 2572, 2572, 2827], [2829, 2829, 2866, 2866, 3145], [3179, 3179, 3205, 3233, 3621], [3623, 3623, 3640, 3640, 4642], [4644, 4644, 4679, 4679, 6261], [6305, 6305, 6361, 6361, 7362], [7364, 7364, 7396, 7396, 7496], [7498, 7498, 7531, 7531, 7620], [7622, 7622, 7655, 7655, 7682], [7684, 7684, 7726, 7726, 7777], [7779, 7779, 7822, 7822, 7886], [7888, 7888, 7924, 7924, 8130], [8132, 8132, 8162, 8162, 8275], [8277, 8277, 8308, 8308, 8372], [8406, 8406, 8430, 8430, 8483], [8485, 8485, 8509, 8509, 8621], [8623, 8623, 8648, 8648, 8834], [8836, 8836, 8857, 8857, 9012]], "test": "untested"}
{"id": "slcXRj", "name": "Pixel Aurora Borealis", "author": "_Chae4ek_", "description": "Beautiful pixel northern lights in the polar coordinate system", "tags": ["noise", "perlin", "pixel", "spiral", "stars", "polar"], "likes": 8, "viewed": 450, "published": 3, "date": "1639391814", "time_retrieved": "2024-07-30T18:42:14.423289", "image_code": "#define PI 3.14159265359\n#define PI2 6.28318530718\n\nfloat rand(in float x) {\n  return fract(sin(x) * 1e4);\n}\n\nfloat rand(in vec2 st) {\n  vec2 r = fract(sin(st) * 2.7644437);\n  return fract(r.y * 276.44437 + r.x);\n}\n\nvec3 rand(in vec3 s) {\n  float t = 4096.0 * sin(dot(s, vec3(17.0, 31.0, 11.0)));\n  return vec3(fract(512.0 * t), fract(64.0 * t), fract(8.0 * t)) - 0.5;\n}\n\n// simplex perlin noise\nfloat snoise(in vec3 p) {\n  vec3 s = floor(p + dot(p, vec3(0.33333333333)));\n  vec3 x = p - s + dot(s, vec3(0.16666666667));\n\n  vec3 e = step(0.0, x - x.yzx);\n  vec3 i1 = e * (1.0 - e.zxy);\n  vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\n  vec3 x1 = x - i1 + 0.16666666667;\n  vec3 x2 = x - i2 + 0.33333333333;\n  vec3 x3 = x - 0.5;\n\n  vec4 w = vec4(dot(x, x), dot(x1, x1), dot(x2, x2), dot(x3, x3));\n  w = max(0.6 - w, 0.0);\n  w = pow(w, vec4(4.0));\n  w *= vec4(dot(rand(s), x), dot(rand(s + i1), x1), dot(rand(s + i2), x2), dot(rand(s + 1.0), x3));\n\n  return dot(w, vec4(30.0, 50.0, 30.0, 40.0));\n}\n\nvec2 rot(in vec2 st, in float angle) {\n  float c = cos(angle), s = sin(angle);\n  return mat2(c, -s, s, c) * st;\n}\n\nfloat alfa0(in float r_, in float r, in float theta) {\n  // tan(alfa) = y'/x' = (r'*sin(theta) + r*cos(theta)) / (r'*cos(theta) - r*sin(theta))\n  float s = sin(theta), c = cos(theta);\n  return atan(r_ * s + r * c, r_ * c - r * s);\n}\n\nfloat borealis_green1(in vec2 st, in float step2) {\n  const float a = 100.0;\n  float r = length(st);\n  float theta = atan(st.y, st.x);\n\n  float f_ = a / r;                                 // the equation with respect to theta\n  float n_ = trunc((f_ - theta) / PI2) * PI2 + PI;  // periodic N\n  float r_ = -a / ((theta + n_) * (theta + n_));    // r' = -a / theta^2\n  float alfa = alfa0(r_, r, theta);\n  r += 4.0 * cos(rot(st, alfa).x - iTime) + rand(r) * 2.0;\n  // recalc:\n  float f = a / r;                                // the equation with respect to theta\n  float n = trunc((f - theta) / PI2) * PI2 + PI;  // periodic N\n  float func = a / (theta + n);                   // the equation with respect to r\n\n  return smoothstep(0.0, step2, abs(r - func));\n}\n\nfloat borealis_green2(in vec2 st, in float step2) {\n  st.x = -st.x;\n  const float a = 1.55;\n  float r = length(st);\n  float theta = atan(st.y, st.x);\n\n  float f_ = log(r) / log(a);                       // the equation with respect to theta\n  float n_ = trunc((f_ - theta) / PI2) * PI2 + PI;  // periodic N\n  float r_ = pow(a, theta + n_) * log(a);           // r' = pow(a, theta) * log(a)\n  float alfa = alfa0(r_, r, theta);\n  r += 4.0 * cos(rot(st, alfa).x + iTime) + rand(r) * 2.0;\n  // recalc:\n  float f = log(r) / log(a);                      // the equation with respect to theta\n  float n = trunc((f - theta) / PI2) * PI2 + PI;  // periodic N\n  float func = pow(a, theta + n);                 // the equation with respect to r\n\n  return smoothstep(0.0, step2, abs(r - func));\n}\n\nfloat borealis_blue(in vec2 st, in float step2) {\n  const float a = 100.0;\n  float r = length(st);\n  float theta = atan(st.y, st.x);\n\n  float f_ = a / r;                                 // the equation with respect to theta\n  float n_ = trunc((f_ - theta) / PI2) * PI2 + PI;  // periodic N\n  float r_ = -a / ((theta + n_) * (theta + n_));    // r' = -a / theta^2\n  float alfa = alfa0(r_, r, theta);\n  r += 4.0 * cos(rot(st, alfa).y + iTime) + rand(r) * 2.0;  // it's weird, but pretty good\n  // recalc:\n  float f = a / r;                                // the equation with respect to theta\n  float n = trunc((f - theta) / PI2) * PI2 + PI;  // periodic N\n  float func = a / (theta + n);                   // the equation with respect to r\n\n  return smoothstep(0.0, step2, abs(r - func));\n}\n\nfloat particles(in vec2 st, in float step1) {\n  float r = rand(floor(st));\n  return smoothstep(step1, 1.0, r) * max(0.0, sin(r * 34433.0 + 2.0 * iTime));\n}\n\nvec3 color;\nconst vec3 GREEN = vec3(0.0, 1.0, 0.1647);\nconst vec3 GREEN2 = vec3(0.0039, 0.2275, 0.1216);\nconst vec3 GREEN3 = vec3(0.0275, 0.2118, 0.098);\nconst vec3 BLUE = vec3(0.0039, 0.0196, 0.0667);\nconst vec3 BLUE2 = vec3(0.0, 0.1451, 0.3608);\nconst vec3 BLUE3 = vec3(0.4039, 0.5294, 0.7137);\nconst vec3 BLUE4 = vec3(0.0863, 0.1451, 0.2);\n\nfloat christmas_tree(in vec2 st) {\n  const float a = 0.4;\n  float x = st.x - 9.0, y = st.y + 31.0;\n  float f = 0.27 * cos(3.2 * y * a + abs(x * a)) * (y * a - 15.0) - 2.4 * abs(x * a) -\n            0.46 * (y * a + abs(y * a)) + 5.0 * (y * a - abs(y * a - 2.0));\n\n  if (abs(f) < 6.0) color += GREEN3 * particles(st, 0.3);  // extra particles around\n  return step(f, -4.0);\n}\n\n#define scale 100.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 st = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n  st *= scale;\n\n  // alignment\n  vec2 st2 = vec2(st.x - 15.0, st.y - 2.0 * rand(floor(st.x)));\n  st2 = floor(st2);\n  st2.y = st2.y * 1.2 - 35.0;\n  st2.x -= 17.0;\n  st2 = rot(st2, 4.5);\n\n  // background\n  color = BLUE * max(st.y * -0.09, 1.0);\n\n  // green 1\n  color += GREEN2 * (1.0 - borealis_green1(st2, 1.0));\n  color += GREEN * (1.0 - borealis_green1(st2, 6.0));\n  color += BLUE * (1.0 - borealis_green1(st2, 14.0));\n\n  // green 2\n  vec2 st4 = rot(st2, -PI);\n  st4.x += -10.0;\n  st4.y += 5.0;\n  color += GREEN2 * (1.0 - borealis_green2(st4, 2.0));\n  color += GREEN * (1.0 - borealis_green2(st4, 7.5));\n  color += BLUE * (1.0 - borealis_green2(st4, 16.0));\n\n  // blue\n  st2 = rot(st2, -0.6);\n  st2 *= 0.5;\n  color += BLUE * (1.0 - borealis_blue(st2, 1.0));\n  color += BLUE * (1.0 - borealis_blue(st2, 3.0));\n  color += BLUE * (1.0 - borealis_blue(st2, 6.0));\n\n  // particles and snow\n  vec2 st3 = st;\n  st3.y += 0.1 * iTime * (3.0 + 15.0 * rand(floor(st3.x)));\n  st2.y += 0.1 * iTime * (3.0 + 15.0 * rand(floor(st2.x)));\n  color += BLUE2 * particles(st2, 0.995);\n  color += BLUE3 * particles(st3, 0.992);\n\n  st = floor(st);\n  color *= christmas_tree(st);\n\n  // cliffs\n  float x2 = st.x * 0.09 + 1.0;\n  if (x2 < 0.0 || x2 > 3.4) {\n    float threshold = snoise(vec3(x2, x2, 10.0)) * 30.0 - 15.0;\n    if (st.y < threshold + 2.0 * rand(st)) color = BLUE4 * particles(st, 0.0);\n    if (st.y < threshold - 1.0) color = vec3(0.0);\n  }\n  float x1 = st.x * 0.01;\n  if (st.y < snoise(vec3(x1, x1, 10.0)) * 26.0 - 20.0) color = vec3(0.0);\n\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcXRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 76, 76, 108], [110, 110, 134, 134, 214], [216, 216, 238, 238, 370], [372, 396, 421, 421, 984], [986, 986, 1024, 1024, 1099], [1101, 1101, 1155, 1244, 1333], [1335, 1335, 1386, 1386, 2094], [2096, 2096, 2147, 2147, 2880], [2882, 2882, 2931, 2931, 3671], [3673, 3673, 3718, 3718, 3828], [4174, 4174, 4208, 4208, 4547], [4570, 4570, 4625, 4625, 6254]], "test": "untested"}
{"id": "slcSRj", "name": "Flash of white", "author": "zyc", "description": "Flash of white", "tags": ["blank"], "likes": 2, "viewed": 289, "published": 3, "date": "1639390748", "time_retrieved": "2024-07-30T18:42:15.315903", "image_code": "const float PI = 3.1415926;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = fragCoord.xy/iResolution.xy;\n   float duration = 0.1;\n   float time = mod(iTime,duration);\n   vec4 whiteColor = vec4(1.0);\n   float amplitude = abs(0.16*sin(time * (PI/duration)));\n   vec4 mask = texture(iChannel0, uv);\n   fragColor = mask * (1.0 - amplitude) + whiteColor * amplitude;\n}\n", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcSRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 86, 86, 387]], "test": "untested"}
{"id": "flcSz2", "name": "Pixel stars", "author": "_Chae4ek_", "description": "Extremely simple space with pixel stars", "tags": ["simple", "pixel", "space", "galaxy", "stars"], "likes": 8, "viewed": 557, "published": 3, "date": "1639386638", "time_retrieved": "2024-07-30T18:42:16.226468", "image_code": "float rand(in vec2 st) {\n  vec2 r = fract(sin(st) * 2.7644437);\n  return fract(r.y * 276.44437 + r.x);\n}\n\nfloat particles(in vec2 st) {\n  float r = rand(floor(st));\n  return 0.01 + smoothstep(0.995, 1.0, r) * max(0.0, sin(r * 34433.0 + iTime));\n}\n\nconst vec3 BLUE = vec3(0.0, 0.1, 0.2);\n\n#define p(st) particles(st)\nvec3 avg(in vec2 st, in float a) {\n  vec2 A = vec2(0.0, a);\n  return BLUE * (p(st) + p(st + A) + p(st + A.yx) + p(st - A) + p(st - A.yx));\n}\n\nvec3 stars(in vec2 st) {\n  vec3 color = vec3(0.0);\n  for (float i = 5.0; i > 0.0; --i) color += mix(color, avg(st, i), 1.5);\n  return color + p(st);\n}\n\n#define scale 150.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 st = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n  st *= scale;\n\n  vec3 color = stars(st);\n\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcSz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 104], [106, 106, 135, 135, 246], [316, 316, 350, 350, 456], [458, 458, 482, 482, 608], [631, 631, 686, 686, 827]], "test": "untested"}
{"id": "Nl3Szj", "name": "Ubad Khabad", "author": "Wykes", "description": "Click and drag", "tags": ["shapingfunctions"], "likes": 1, "viewed": 184, "published": 3, "date": "1639379550", "time_retrieved": "2024-07-30T18:42:17.371406", "image_code": "float plot(vec2 st, float pct){\n  return  smoothstep( pct-0.2, pct, st.y) -\n          smoothstep( pct, pct+0.1, st.y);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n    //st = (st * 2.0-1.0) * 1.0;\n    st.x = st.x/m.x; // <-play with this \n    //st.y = st.y+0.672;\n    \n    \n    \n    float y =0.0;\n    y = log(abs(pow(st.x,1.088) + 1.0)) + floor(10.0 * st.x) - 10.0*st.x;\n\n    // Time varying pixel color\n    vec3 col = vec3(y);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3Szj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 120], [124, 124, 181, 231, 637]], "test": "untested"}
{"id": "sttSzS", "name": "Interregio", "author": "lennyjpg", "description": "a", "tags": ["asdfa"], "likes": 8, "viewed": 261, "published": 3, "date": "1639375634", "time_retrieved": "2024-07-30T18:42:18.325855", "image_code": "float rand(vec2 n) { \nreturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\nvec2 ip = floor(p);\nvec2 u = fract(p);\nu = u*u*(3.0-2.0*u);\nfloat res = mix(\n    mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n    mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\nreturn res*res;\n}\n\n\nfloat wave(vec2 p, float i){\n float medium = noise((p + i * .77 ) * vec2(7. , .1)),\n small = noise((p + i * .33) * vec2(17.57 , .1)),\n large = noise((p + i * .56) * vec2(.052 , .5));\nfloat offset = large - medium * .78 - small * .1;\nfloat a = p.y + offset * .5;\na *= 1.5;\na -= .2;\nfloat b = .7 - i * .05;\nif(mod(i, 2.) > .5){\n   a = 1. - a;\n}\n return step(a,b);\n}\n\nvec3 colors[8] = vec3[]( \n    vec3( 1.0, 0.2, 0.0 ),\n    vec3( 0.1, 0.2, 0.3 ),\n    vec3( 0.1, 0.1, 0.0 ),\n    vec3(0.137,0.137,0.122),\n    vec3( 1.0, 1.0, 0.9 ),\n    vec3( 0.4, 0.2, 1.0 ),\n    vec3(0.953,0.325,0.514),\n    vec3( 1.0, 0.1, 0.2 ));\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = fragCoord/iResolution.y;\nuv.x*=0.5;\nvec2 u = uv;\nfloat t = iTime * 0.2;\nvec2 m = iMouse.xy/iResolution.xy;\nu.x += m.x * 10.0;\nvec3 color = colors[5];\nfor(float i = 1.0; i < 14.0; i++){\n   float speed = noise(vec2(i*0.23,0.0));\n   speed = i*0.1;\n   vec2 v = u.xy;\n   v.x += speed * t;\n   float e = wave(v, i);\n   color = mix(color, colors[int(mod(i-1., 8.0))],  e);\n}\nfragColor = vec4(color , 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttSzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 86], [88, 88, 108, 108, 314], [317, 317, 345, 345, 680], [934, 934, 991, 991, 1401]], "test": "untested"}
{"id": "NlcSRj", "name": "Mouse Offset Mandelbrot", "author": "JennySchub", "description": "this was originially made as a phone wallpaper (instead of mouse position, it uses the gyroscope)", "tags": ["fractal", "mouse", "mandelbrot"], "likes": 21, "viewed": 527, "published": 3, "date": "1639372153", "time_retrieved": "2024-07-30T18:42:19.317204", "image_code": "#define PI 3.141592653\n#define AA 2.\n\nvec3 colMap(float v) {\n v=mod(v, PI+1.3)-.8;\n return vec3(\n  sin(sin(v-.6)),\n  sin(sin(v)),\n  sin(sin(v+.8))\n  );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float aaFract = 1./AA;\n  fragColor = vec4(0.);\n  vec2 mouz = iMouse.xy;\n  if(mouz.x == 0. || mouz.y == 0.){\n      mouz.x=iResolution.x*.45;\n      mouz.y=iResolution.y*.45;\n  }\n  for(float aa=0.; aa<1.; aa+=aaFract){\n      for(float bb=0.; bb<1.; bb+=aaFract){\n          vec2 uv =  ( (fragCoord.yx + vec2(aa,bb) ) -.5* iResolution.yx ) / iResolution.x;\n          uv*=(-cos(iTime*.1)+1.3)*.28;\n          uv+=vec2(.1,.65);\n\n          vec2 c =uv;\n          vec2 z=c;\n          float l=0.;\n          float sum=length(z);\n          vec2 newZ;\n          for(int i=0;i<40;i++){\n           c+=(mouz.yx/iResolution.yx  -.5)*-.01*float(i);\n            newZ=vec2(-z.y*z.y+z.x*z.x, 2.*z.x*z.y)+c;\n            sum+=length(newZ-z);\n            z=newZ;\n            l=length(z);\n            if(l>2.) break;\n          }\n          vec2 dir=z-c;\n          vec3 col = vec3(dir, .0);\n\n          uv.x=mod((atan(dir.y,dir.x)/PI*.5+.5)*6.+(iTime+sin(iTime)*.9)*4., 1.);\n          uv.y=mod(length(dir*.5),1.);\n\n          col=colMap(sum*.2-l*.1+iTime*.1).gbr;\n\n          fragColor += vec4(col.grb, 1.0) * aaFract*aaFract;\n        }\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcSRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 60, 60, 153], [155, 155, 212, 212, 1327]], "test": "untested"}
{"id": "NsVGWc", "name": "ball explosion", "author": "JennySchub", "description": "this has some 90s dancemusic CD logo vibes", "tags": ["circle"], "likes": 16, "viewed": 436, "published": 3, "date": "1639372001", "time_retrieved": "2024-07-30T18:42:20.200842", "image_code": "#define PI 3.141592652\nfloat circle(vec2 uv, vec2 c, float r){\n    return smoothstep(r, r+2./iResolution.x, length(uv-c));\n}\n\nfloat unsmoothstep(float mn, float mx, float x) {\n    x-=mn;\n    x/=mx-mn;\n    return x + (x - (x * x * (3.0 - 2.0 * x)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tim = -iTime*.1;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - .5);\n    uv.x*=iResolution.x/iResolution.y;\n\n    float angl = atan(uv.y, uv.x);\n    \n    float adir=-angl+PI*.5;\n    // -angl+PI*.5\n    \n    vec3 col = vec3(1.);\n    float iCount=12.;\n    for(float i=0.; i<iCount; i++){\n        float dir = floor(adir/(PI/3.)+.5)*(PI/3.);\n        \n        if(mod(i+.1, 2.)<.5){\n            // todo\n            dir = floor((adir-PI/6.)/(PI/3.)+.5)*(PI/3.) + PI/6.;\n        }\n        float timMod1 = mod(-tim+i*(1./iCount), 1.);\n        timMod1 = unsmoothstep(0.,.8,pow(smoothstep(0.,1.,timMod1),.8));\n        float circ = circle(\n            uv, \n            vec2(sin(dir)*timMod1, cos(dir)*timMod1), \n            cos(timMod1*6.-PI*.65)*.1\n        );\n        \n        col *= circ;\n        \n    \n    }\n    \n    col*=circle(uv, vec2(0.), sin(iTime)*.04+.038);\n    \n    // Output to screen\n    fragColor = vec4(col*-1.+1.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVGWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 62, 62, 124], [126, 126, 175, 175, 250], [252, 252, 309, 309, 1287]], "test": "untested"}
{"id": "fldSRB", "name": "Malmousque", "author": "XT95", "description": "A lot based on my previous shader, but some new tricks here :\n- Rock based on triangles\n- Foams\n- More temporal accumulations on the out of focus part!\n- PBR Sky\n", "tags": ["water", "dof", "rock", "foam"], "likes": 143, "viewed": 11103, "published": 3, "date": "1639355776", "time_retrieved": "2024-07-30T18:42:25.950469", "image_code": "// ---------------------------------------------------------------------------------\n// Compositing pass\n// ---------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    vec2 uv = fragCoord * invRes;\n\n    // Chromatic aberration\n    vec2 offset = (uv*2.-1.)/iResolution.xy*.75;\n    vec4 col = vec4(0.);\n    col.r = texture(iChannel0, uv+offset).r;\n    col.g = texture(iChannel0, uv-offset).g;\n    col.b = texture(iChannel0, uv+offset).b;\n\n    // Vignetting & color grading\n    col *= pow( uv.x * uv.y * (1.-uv.x) * (1.-uv.y)*100., .15 );\n    col = pow(col, vec4(1.0,1.05,1.1, 1.));\n    \n    // Gamma correction\n    fragColor = pow(col*3., vec4(1./2.2));\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ---------------------------------------------------------------------------------\n// Sky\n// https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky\n// ---------------------------------------------------------------------------------\nfloat iSphere(vec3 ro, vec3 rd, float radius) {\n    float b = 2.0 * dot(rd, ro);\n    float c = dot( ro, ro ) - radius * radius;\n    float disc = b * b - 4.0 * c;\n    if (disc < 0.0)\n        return (-1.0);\n    float q = (-b + ((b < 0.0) ? -sqrt(disc) : sqrt(disc))) / 2.0;\n    float t0 = q;\n    float t1 = c / q;\n    return max(t0,t1);//vec2(t0,t1);\n}\n\nvec3 skyColor( in vec3 rd )\n{\n    const int nbSamples = 64;\n    const int nbSamplesLight = 32;\n    \n    vec3 absR = vec3(3.8e-6f, 13.5e-6f, 33.1e-6f);\n    vec3 absM = vec3(21e-6f);\n    \n    \n    vec3 accR = vec3(0.);\n    vec3 accM = vec3(0.);\n    \n    float mu = dot(rd, sundir);\n    float g = 0.76f; \n    vec2 phase = vec2(3.f / (16.f * PI) * (1. + mu * mu), 3.f / (8.f * PI) * ((1.f - g * g) * (1.f + mu * mu)) / ((2.f + g * g) * pow(1.f + g * g - 2.f * g * mu, 1.5f)));\n\n    float radA = 6420e3;\n    float radE = 6360e3;\n    vec3 ro = vec3(0., radE+1., 0.);\n    float t = iSphere(ro, rd, radA);\n    float stepSize = t / float(nbSamples);\n    \n    vec2 opticalDepth = vec2(0.);\n    \n    for(int i=ZERO; i<nbSamples; i++) {\n     \tvec3 p = ro + rd * (float(i)+.5) * stepSize;\n        \n        float h = length(p) - radE;\n        vec2 thickness = vec2(exp(-h/7994.), exp(-h/1200.)) * stepSize;\n        opticalDepth += thickness;\n        \n        float tl = iSphere(p, sundir, radA);\n        float stepSizeLight = tl / float(nbSamplesLight);\n        vec2 opticalDepthLight = vec2(0.);\n        int j;\n        for(j=ZERO; j<nbSamplesLight; j++) {\n            vec3 pl = p + sundir * (float(j)+.5) * stepSizeLight;\n            float hl = length(pl) - radE;\n            if (hl < 0.) break;\n        \topticalDepthLight += vec2(exp(-hl/7994.), exp(-hl/1200.)) * stepSizeLight;\n        }\n        if (j == nbSamplesLight) {\n            vec3 tau = absR * (opticalDepth.x + opticalDepthLight.x) + absM * 1.1 * (opticalDepth.y + opticalDepthLight.y);\n            vec3 att = exp(-tau);\n            accR += att * thickness.x ;\n            accM += att * thickness.y;\n        }\n    }\n    \n    return (accR * absR * phase.x + accM * absM * phase.y)*1.5;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy*4.;\n    \n    if (uv.x>1. || uv.y>1.) return;\n    \n    vec3 rd = equi2cube(uv);\n    \n    // compute only on the first frame!\n    //if (iFrame < 4) {\n        fragColor = vec4(skyColor(rd), 1.);\n    //} else {\n    //    fragColor = texture(iChannel0, uv*.25);\n    //}\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ZERO (min(iFrame,0)) // skip unroll loop\n#define saturate(x) clamp(x,0.,1.)\n#define PI 3.141592653589\n#define PI_2 1.5707963267948966192313216916398\n#define PI_X_2 6.283185307179586476925286766559\n#define GOLDEN_RATIO 0.61803398875\n#define time iTime\n#define frame iFrame\n\nvec3 sundir = normalize( vec3(1.5,.8,2.) );\n\n\n\n// ---------------------------------------------------------------------------------\n// Maths toolbox\n// ---------------------------------------------------------------------------------\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\nvec3 tri(vec3 x) {\n    return abs(x-floor(x)-.5);\n}\nvec3 hash3(vec3 p) {\n    uvec3 x = uvec3(p*100000.+1000.);\n    const uint k = 1103515245U; \n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\nfloat hash( vec2 p )\n{\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123);\n}\nfloat hash( float p )\n{\n    vec3 p3  = fract(vec3(p) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n    float s = rnd.x*PI*2.;\n    float t = rnd.y*2.-1.;\n    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n    vec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n    return v * sign(dot(v, dir));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( vec2 p) {\n    float d = noise(p) * .5;\n    d += noise(p*2.) * .25;\n    d += noise(p*4.) * .125;\n    \n    return d;\n}\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nvec3 equi2cube (vec2 uv) {\n    vec2 thetaphi = (uv*2.-1.) * vec2(PI, PI_2); \n    return vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n}\n\nvec2 cube2equi (vec3 p) {\n    return vec2((atan(p.z, p.x) / PI_X_2) + 0.5, acos(-p.y) / PI);    \n}\n\n// ---------------------------------------------------------------------------------\n// Triplanar mapping + bump mapping! \n// clever code taken from Shane\n// https://www.shadertoy.com/view/MscSDB\n// ---------------------------------------------------------------------------------\nvec3 tex3D( sampler2D tex, vec3 p, vec3 n )\n{\n    n = abs(n);\n    vec4 col = texture(tex, p.yz)*n.x + texture(tex, p.xz)*n.y + texture(tex, p.xy)*n.z;\n    return pow(col.rgb,vec3(2.2));\n}\n\nvec3 bumpMapping( sampler2D tex, vec3 p, vec3 n, float bf )\n{\n    const vec2 e = vec2(0.001, 0);\n    \n    mat3 m = mat3( tex3D(tex, p - e.xyy, n).rgb,\n                   tex3D(tex, p - e.yxy, n).rgb,\n                   tex3D(tex, p - e.yyx, n).rgb);\n    \n    vec3 g = vec3(0.299, 0.587, 0.114) * m;\n    g = (g - dot( tex3D(tex,  p , n).rgb, vec3(0.299, 0.587, 0.114)) )/e.x;\n    g -= n * dot(n, g);\n                      \n    return normalize( n + g*bf );\n    \n}", "buffer_b_code": "// ---------------------------------------------------------------------------------\n// Raytracing pass\n// ---------------------------------------------------------------------------------\n\nconst mat3 mt = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.93;\nconst mat2 mw = mat2(1.6,1.2,-1.2,1.6);\n\n\n\n// ---------------------------------------------------------------------------------\n// Signed Distance Field\n// ---------------------------------------------------------------------------------\nfloat terrain(vec3 p) {\n    \n    float d = length(p.xy-vec2(-4.,0.))-2.;\n    d = smin(d, capsule(p, vec3(-5.,0.,7.), vec3(0.,2.,7.), 1.), 1.7);\n    d = smin(d, p.y-.1+smoothstep(-3.1,5.,p.x)*2., 0.1);\n    \n    // Add detail only if we are closed of the surface\n    if (d < 1.) {\n        // Inspired by many shaders of Shane, the master of the rock.\n        float z = 1.;\n        for(int i = 0; i < 6; i++)\n        {\n            d -= dot(tri(p*.5 + tri(p.yzx*.375)), vec3(.4*z));\n            z *= -0.55;\n            p = p*mt;\n        }\n    }\n    \n    return d;\n}\nfloat water(vec3 p) {\n    float d = p.y;\n    \n    float amp = .1;\n    p.xz *= mw;\n    float t = time*.3;\n    \n    // Add detail only if we are closed of the surface\n    if (d < .2) {\n        for(int i=0; i<6; i++)\n        {\n            d -= (1.-abs(sin(noise(p.xz-t)))) * amp;\n            amp *= .5;\n            p.xz *= mw;\n        }\n    }\n    \n    return d;\n}\n\nfloat map(vec3 p) {\n    float d1 = terrain(p);\n    float d2 = water(p);\n    float d = min(d1,d2);\n    return d;\n    \n}\n\n\n// ---------------------------------------------------------------------------------\n// Raytracing toolbox\n// ---------------------------------------------------------------------------------\nvec3 raymarch(vec3 ro, vec3 rd, const vec2 nf) {\n    vec3 p = ro + rd * nf.x;\n    float l = 0.;\n    for(int i=ZERO; i<70; i++) {\n        float d = map(p);\n        l += d;\n        p += rd * d;\n        \n        if(abs(d)<.01 || l > nf.y)\n            break;\n    }\n    \n    return p;\n}\n\nvec3 normal( vec3 p )\n{\n    const float h = 0.005;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h);\n    }\n    return normalize(n);\n}\n\n\nvec3 raymarchUnderwater(vec3 ro, vec3 rd, const vec2 nf) {\n    vec3 p = ro + rd * nf.x;\n    float l = 0.;\n    for(int i=ZERO; i<32; i++) {\n        float d = terrain(p);\n        l += d;\n        p += rd * d;\n        \n        if(abs(d)<.05 || l > nf.y)\n            break;\n    }\n    \n    return p;\n}\n// Simplified version of https://www.shadertoy.com/view/4sdGWN - http://www.aduprat.com/portfolio/?page=articles/hemisphericalSDFAO\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n\tconst int nbIte = 6;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv;\n    \n\tfloat ao = 0.0;\n    \n    for( int i=ZERO; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l;\n        \n        ao += (l - max(terrain( p + rd ),0.)) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n// iq Soft Shadow - https://iquilezles.org/articles/rmshadows\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = terrain(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n// ---------------------------------------------------------------------------------\n// Shading\n// ---------------------------------------------------------------------------------\nvec3 skyColor(vec3 rd) {\n    return texture(iChannel3, cube2equi(rd)*.25).rgb;\n}\nvec3 shade(vec3 ro, vec3 rd, vec3 p, vec3 n) {\n    vec3 sky = skyColor(rd);\n    if (map(p) > .3) return sky;\n    \n    float wet = smoothstep(.15+fbm(p.xz*30.)*.15,0.15,p.y) * step(0.,water(p));\n    \n    vec3 albedo = tex3D(iChannel1,p*1.,n)*vec3(.3,.275,.25)* (smoothstep(.1,0.4,p.y)+.1);\n    albedo = mix(albedo, vec3(0.09,0.15,0.03)*0.5, saturate(fbm(p.xz*20.2)*2.-.3)*wet*.075);\n    albedo = mix(albedo, vec3(0.1,0.03,0.2)*0.5, saturate(fbm(p.xz*20.2+1.)*2.-.6)*wet*.075);\n    n = bumpMapping(iChannel1,p*1.,n,.005);\n\n    float shad = shadow(p,sundir, .5,10., 10.);\n    float ao = ambientOcclusion(p,n, 5.5,1.7);\n    ao *= smoothstep(0.5,5., length(p-vec3(-1.,0.5,4.5)));\n    \n    vec3 diff = vec3(1.,.5,.3) * saturate(dot(n,sundir)+.1) * pow(vec3(shad),vec3(1.0,1.3,1.8));\n    vec3 skyl = vec3(0.2,0.25,0.35) * (n.y*.25+.75) * ao;\n    vec3 bounce = vec3(1.,.5,.3) * max(dot( n, normalize(sundir*vec3(-1.0,0.0,-1.0))), 0.0) * ao;\n    vec3 spe = vec3(1.,.8,.5) * pow(max(dot(reflect(rd,n),sundir),0.), 80.) * shad * wet;\n    \n    vec3 col = albedo * ( diff*3.+ skyl*1.3 + bounce*.2 + spe*50. );\n    \n    return col;\n}\n\nvec3 calcPixel(vec3 ro, vec3 rd, float seed, inout vec3 firstP) {\n    \n    // Raytracing primary ray\n    vec3 p = raymarch(ro,rd, vec2(1.,60.));\n    firstP = p;\n    vec3 n = normal(p);\n    float d = map(p);\n    vec3 sky = skyColor(rd);\n    if (d > .3) return sky;\n    \n    \n    vec3 col;\n    \n    // Fake foam\n    float foam = saturate((fbm(p.xz*70.-time*0.25)+fbm(p.xz*50.+time*0.25))*.5-.34);\n    \n    if (terrain(p) == d) {\n        col = shade(ro,rd, p, n);\n        col = mix(col, vec3(.1), smoothstep(.025,.0,water(p))*foam);\n    } else {\n        \n        // Reflection\n        vec3 rro = p;\n        vec3 rrd = reflect(rd,n);\n        rrd = normalize(hash3(p+rand())*2.-1.+reflect(rd,n)*3000.);\n        \n        vec3 rp = raymarch(rro,rrd, vec2(.1,10.));\n        vec3 rn = normal(p);\n\n        vec3 reflectedCol = shade(rro,rrd, rp, rn);\n        // hackish sun specular \n        reflectedCol += vec3(1.,.7,.5)*30. * pow(max(dot(reflect(rd,n), sundir), 0.), 1024.);\n        \n        // Refraction\n        rro = p;\n        rrd = refract(rd,n, 1./1.33);\n        \n        rp = raymarchUnderwater(rro,rrd, vec2(.1,10.));\n        rn = normal(p);\n        vec3 refractedCol = shade(rro,rrd, rp, rn);\n        refractedCol *= exp( -vec3(1.,.4,.2) * length(rp-p)*50.2); // Beer law for absorption! great blog post -> https://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n        \n        // Mix it with fresnel\n        float fre = pow( saturate( 1.0 + dot(n,rd)), 16.0 );\n        col = mix(refractedCol, reflectedCol , fre);\n        \n        col = mix(col, vec3(.1), smoothstep(.075,.0,terrain(p))*foam);\n    }\n    col = mix(col, sky, smoothstep(10.,60., length(ro-p)));\n    \n    return col;\n}\n\n// ---------------------------------------------------------------------------------\n// Entrypoint\n// ---------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    vec2 uv = fragCoord * invRes;\n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    vec2 v = -1.0+2.0*(uv);\n    v.x *= iResolution.x/iResolution.y;\n    \n    // Camera ray\n    vec3 ro = vec3(-1.,.5,0.);\n    vec3 rd = normalize( vec3(v.x, v.y, 5.) );\n    \n    // Depth of field\n    float focusDistance = 1.5;\n    float blurAmount = max(0., 0.02*uv.x);\n    vec3 go = blurAmount*vec3( normalize(vec2(rand(),rand())*2.-1.)*sqrt(rand()), 0.0 );\n    vec3 gd = normalize( rd*focusDistance - go );\n    vec3 uu = vec3(1.,0.,0.);\n    vec3 vv = vec3(0.,1.,0.);\n    ro += go.x*uu + go.y*vv;\n    rd += gd.x*uu + gd.y*vv;\n    rd = normalize(rd);\n    \n    \n    // Compute color\n    vec3 p;\n    vec3 col = calcPixel(ro, rd, seed, p);\n    \n    \n    // Output with temporal accumulation\n    vec4 lastCol = texture(iChannel0,uv);\n    \n    // Nice tricks here : more temporal accumulation when we are out of focus :)\n    float taaFactor = (1.05-saturate(abs(focusDistance-length(p-ro))/1.)) *0.75;\n    if (iFrame == 0) taaFactor = 1.;\n    //taaFactor = 1.;\n    fragColor = mix(lastCol, vec4(saturate(col), length(ro-p)), taaFactor);\n}", "buffer_b_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldSRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[191, 191, 246, 246, 781]], "test": "untested"}
{"id": "sttXzS", "name": "depth of field focus study 31", "author": "morisil", "description": "Testing something out", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 13, "viewed": 282, "published": 3, "date": "1639353804", "time_retrieved": "2024-07-30T18:42:27.260965", "image_code": "// Fork of \"depth of field focus study 3\" by morisil. https://shadertoy.com/view/stdGRf\n// 2021-12-12 23:47:31\n\n// Fork of \"depth of field focus study 2\" by morisil. https://shadertoy.com/view/flc3zX\n// 2021-11-09 21:23:07\n\n// Fork of \"depth of field focus study\" by morisil. https://shadertoy.com/view/sld3zB\n// 2021-11-08 19:52:49\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Fork of \"depth of field focus study 2\" by morisil. https://shadertoy.com/view/flc3zX\n// 2021-11-09 21:23:07\n\n// Fork of \"depth of field focus study\" by morisil. https://shadertoy.com/view/sld3zB\n// 2021-11-08 19:52:49\n\nconst float SHAPE_SIZE = .2;\nconst float CHROMATIC_ABBERATION = .01;\nconst float ITERATIONS = 20.;\nconst float INITIAL_LUMA = .1;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y);\n    float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, dist);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    st *= 3.;\n    st *= rotate2d(sin(iTime * .01) * 2.3);\n    st *= 1. + (sin(iTime * .1) + 1.) * 1.2;\n\n    float modScale = 1.;\n\n    vec3 color = texture(iChannel0, uv).rgb * .9;    \n    float luma = INITIAL_LUMA;\n    float blur = .4;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .5), cos(iTime * .3));\n        //center += pow(length(center), 1.);\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur),\n            getColorComponent(center, modScale, blur),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur)        \n        ) * luma;\n        st *= 1.1;\n        st *= rotate2d(sin(iTime  * .05) * .3);\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        if (color == vec3(1)) break;\n        luma *= .8;\n        blur *= .63;\n    }\n    fragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttXzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[334, 334, 389, 389, 473]], "test": "untested"}
{"id": "sltSzS", "name": "QuasiRandomR2", "author": "Del", "description": "just a quick test of the r2 sequence to see how it looks...", "tags": ["quasirandom", "r2"], "likes": 4, "viewed": 233, "published": 3, "date": "1639349532", "time_retrieved": "2024-07-30T18:42:28.373989", "image_code": "// quasirandom test - from http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n#define NPOINTS 500.0\n#define DOTSIZE 0.01\n\n// r2 as a function\nvec2 quasi(float n)\n{\n    float g = 1.32471795;\n    float a1 = 1.0/g;\n    float a2 = 1.0/(g*g);\n    float x = fract((a1*n));//float x = mod((0.5+a1*n),1.0);\n    float y = fract((a2*n));//float y = mod((0.5+a2*n),1.0);\n    return vec2(x,y);\n}\nconst vec2 quasi2 = vec2(.754877,.569840);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float zoomval = 1.25 + (sin(iTime)*0.5);\n    vec3 col = vec3(0.05,0.2,0.05);\n    // btw, never do this :)\n    for (float i=0.0;i<NPOINTS;i+=1.0)\n    {\n        //vec2 pos = quasi(i+1.0);          // R2 func\n        vec2 pos = fract(quasi2*(i+1.0));   // R2 inline\n        pos = (pos-0.5)*(zoomval);\n        float d = length(pos-uv)-(DOTSIZE*zoomval);\n        col.r += step(d,0.0)*0.4;\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltSzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 174, 195, 195, 415], [460, 460, 517, 517, 1015]], "test": "untested"}
{"id": "stdSRS", "name": "Lost structure", "author": "z0rg", "description": "Playing with some raymarching", "tags": ["3d", "tesseract", "cubeception", "cucube"], "likes": 23, "viewed": 482, "published": 3, "date": "1639344967", "time_retrieved": "2024-07-30T18:42:29.397254", "image_code": "// Fork of \"Wir\" by z0rg. https://shadertoy.com/view/NldXWN\n// 2021-12-12 21:22:54\n\n// Fork of \"2022 20ans voeux onepoint3\" by z0rg. https://shadertoy.com/view/fltXz7\n// 2021-12-08 12:25:38\n\n// Fork of \"2022 20ans voeux onepoint\" by z0rg. https://shadertoy.com/view/fltXRN\n// 2021-12-07 13:33:26\n\n// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        //if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb, vec3(2.2));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    rgb *= 1.-sat(length(cuv*2.)-.5);\n\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 4.5;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(uv.x*r+-uv.y*u));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.);\n    for (int i = 0; i < 15; ++i)\n    {\n        float fi = float(i);\n        vec3 pl = p;\n        pl.xy *= r2d(sin(iTime*.5-fi*.1)*2.);   \n        float cucube = _cucube(pl, 5.*vec3(.5, .1, .5)*(fi/15.), vec3(.0001));\n        acc = _min(acc, vec2(cucube, float(i)));\n    }\n    \n    return acc;\n}\nvec3 grad(float f)\n{\n    vec3 cols[4];\n    cols[0] = vec3(0.05);\n    cols[1] = vec3(0.859,0.039,0.286);\n    cols[2] = vec3(1.);\n    cols[3] = vec3(1.0);\n    \n    \n    f = pow(sat(sin(f*3.-iTime*1.5)*.5+.5), 2.)*3.0;\n    vec3 prev = cols[int(f)];\n    vec3 next = cols[int(min(f+1.,3.))];\n    return mix(prev, next, fract(f))*1.2;\n}\nvec3 getCol(float id)\n{\n    return grad(id/15.);\n}\n\nvec3 accCol;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    accCol = vec3(0.);\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        accCol += pow(1.-sat(res.x/.3),5.)*.07*getCol(res.y).yzx;\n        p+= rd*res.x;\n    }\n    vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n    float d = 3.;\n    vec3 ro = vec3(sin(iTime*.25)*d,0.,cos(iTime*.25)*d);\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    rd = getCam(rd, uv);\n    vec3 col = texture(iChannel2, rd*vec3(1.,1.,1.)).xxx*.25*vec3(0.400,0.643,0.961);\n    vec3 res = trace(ro, rd, 48);\n    if (res.y > 0.)\n    {\n        vec3 p = ro + rd*res.y;\n\n        col = getCol(res.z);\n    }\n    col += accCol;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv);\n\n    col = mix(col, texture(iChannel1, ouv).xyz, .5);\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        //if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 40\n#define GLOW_DISTANCE 0.1\n#define GLOW_POW .95\n#define GLOW_OPACITY .9\n\n// Stolen from 0b5vr here https://www.shadertoy.com/view/ss3SD8\nfloat hash11(float p)\n{\n    return (fract(sin((p)*114.514)*1919.810));\n}\n\n#define sat(a) clamp(a, 0., 1.)\nmat2 r2d(float a){float cosa = cos(a);float sina = sin(a);return mat2(cosa,sina,-sina,cosa);}\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdSRS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[694, 694, 751, 751, 1417]], "test": "untested"}
{"id": "fltSzB", "name": "Coupled Springs", "author": "oneshade", "description": "Practicing modelling with differential equations.", "tags": ["physics", "springs", "coupled"], "likes": 15, "viewed": 225, "published": 3, "date": "1639342626", "time_retrieved": "2024-07-30T18:42:30.273909", "image_code": "// SDFs\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\n// https://www.shadertoy.com/view/tlcBW2\nfloat udTriangleWave(in vec2 p, in float freq, in float amp) {\n    float pw = 1.0 / abs(freq), qw = 0.25 * pw;\n    p.x = abs(mod(p.x * sign(freq) + qw, pw) - 0.5 * pw) - qw;\n\n    vec2 sc = vec2(2.0 * amp, pw);\n    float l = length(sc);\n    sc /= l;\n\n    p *= mat2(sc, -sc.y, sc.x);\n    return length(vec2(p.x, max(0.0, abs(p.y) - 0.25 * l)));\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 12.0;\n    vec3 color = 1.0 - texture(iChannel1, fragCoord / iResolution.xy).rgb;\n    float unit = 24.0 / iResolution.y;\n\n    // Load mass data\n    vec4 mass1 = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 mass2 = texelFetch(iChannel0, ivec2(1, 0), 0);\n\n    // Draw fixtures\n    drawSDF(sdDisk(uv, vec2(fa, 0.0), 0.25), vec3(0.0));\n    drawSDF(sdDisk(uv, vec2(fb, 0.0), 0.25), vec3(0.0));\n\n    // Draw the springs\n    if (min(fa, mass1.x) < uv.x && uv.x < max(fa, mass1.x)) {\n        drawSDF(udTriangleWave(uv - vec2(fa, 0.0), 8.0 / (mass1.x - fa), 1.5), vec3(0.0));\n    }\n\n    if (min(mass1.x, mass2.x) < uv.x && uv.x < max(mass1.x, mass2.x)) {\n        drawSDF(udTriangleWave(uv - vec2(mass1.x, 0.0), 8.0 / (mass2.x - mass1.x), 1.5), vec3(0.0));\n    }\n\n    if (min(mass2.x, fb) < uv.x && uv.x < max(mass2.x, fb)) {\n        drawSDF(udTriangleWave(uv - vec2(mass2.x, 0.0), 8.0 / (fb - mass2.x), 1.5), vec3(0.0));\n    }\n\n    // Draw the masses\n    drawSDF(sdBox(uv - vec2(mass1.x, 0.0), vec2(sqrt(m1))), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdBox(uv - vec2(mass2.x, 0.0), vec2(sqrt(m2))), vec3(0.0, 0.0, 1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFrame == 0) {\n        if (iFragCoord == ivec2(0, 0)) fragColor = vec4(-3.0, 0.0, 0.0, 0.0);\n        if (iFragCoord == ivec2(1, 0)) fragColor = vec4(4.0, 0.0, 0.0, 0.0);\n    }\n\n    if (iFrame > 0) {\n        vec4 mass1 = texelFetch(iChannel0, ivec2(0, 0), 0);\n        vec4 mass2 = texelFetch(iChannel0, ivec2(1, 0), 0);\n\n        mass1.y -= ((mass1.x - (fa + l1)) * k1 + (mass1.x - (mass2.x - l2)) * k2 + u1 * mass1.y) / m1 * dt;\n        mass1.x += mass1.y * dt;\n\n        mass2.y -= ((mass2.x - (mass1.x + l2)) * k2 + (mass2.x - (fb - l3)) * k3 + u2 * mass2.y) / m2 * dt;\n        mass2.x += mass2.y * dt;\n\n        if (iFragCoord == ivec2(0, 0)) fragColor = mass1;\n        if (iFragCoord == ivec2(1, 0)) fragColor = mass2;\n    }\n\n    if (iFrame == 0 || iMouse.z > 0.0) {\n        if (iFragCoord == ivec2(0, 0)) fragColor = vec4(-3.0, 0.0, 0.0, 0.0);\n        if (iFragCoord == ivec2(1, 0)) fragColor = vec4(4.0, 0.0, 0.0, 0.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Fixtures\n#define fa -7.5\n#define fb 7.5\n\n// Spring lengths\n#define l1 5.0\n#define l2 5.0\n#define l3 5.0\n\n// Spring constants\n#define k1 1.0\n#define k2 3.0\n#define k3 1.0\n\n// Friction\n#define u1 0.1\n#define u2 0.1\n\n// Masses\n#define m1 1.0\n#define m2 3.0\n\n// Time step hack\n#define dt 0.05\n#define iTime (float(iFrame) * dt)", "buffer_b_code": "float sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n#define drawSDF(dist) color = max(color,  smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 12.0;\n    float pix = 1.0 / iResolution.y;\n    float unit = 24.0 * pix;\n\n    vec2 st = fragCoord / iResolution.xy;\n    st.y += pix;\n    vec3 color = texture(iChannel1, st).rgb;\n\n    // Load mass data\n    vec4 mass1 = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 mass2 = texelFetch(iChannel0, ivec2(1, 0), 0);\n\n    // Draw the current motion segments\n    drawSDF(sdLine(uv, vec2(mass1.x - mass1.y * dt, -pix), vec2(mass1.x, 0.0)));\n    drawSDF(sdLine(uv, vec2(mass2.x - mass2.y * dt, -pix), vec2(mass2.x, 0.0)));\n\n    fragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fltSzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 8, 55, 55, 163], [165, 165, 213, 213, 245], [247, 247, 282, 282, 362], [364, 405, 467, 467, 749], [831, 831, 886, 886, 2098]], "test": "untested"}
{"id": "NttSzB", "name": "Random sunday shader", "author": "mrange", "description": "Random sunday shader", "tags": ["colors", "abstract", "planes"], "likes": 18, "viewed": 446, "published": 3, "date": "1639337451", "time_retrieved": "2024-07-30T18:42:31.333077", "image_code": "// CC0: Random sunday shader\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define PI_2        (0.5*3.141592654)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)     (0.5+0.5*cos(x))\n#define BPM         125.0\n\n//#define CRT_EFFECT\n\nconst float planeDist = 1.0-0.825;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat planex(vec2 p, float w) {\n  return abs(p.y) - w;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n  float ndbuffer = dbuffer/sph.w;\n  vec3  rc = (ro - sph.xyz)/sph.w;\n\n  float b = dot(rd,rc);\n  float c = dot(rc,rc) - 1.0;\n  float h = b*b - c;\n  if( h<0.0 ) return 0.0;\n  h = sqrt( h );\n  float t1 = -b - h;\n  float t2 = -b + h;\n\n  if( t2<0.0 || t1>ndbuffer ) return 0.0;\n  t1 = max( t1, 0.0 );\n  t2 = min( t2, ndbuffer );\n\n  float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n  float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n  return (i2-i1)*(3.0/4.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 p) {\n  float a = dot (p, vec2 (127.1, 311.7));\n  return fract(sin(a)*43758.5453123);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n#ifdef CRT_EFFECT  \n  col *= 1.5*smoothstep(-2.0, 1.0, sin(0.5*PI*q.y*RESOLUTION.y));\n#endif  \n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nconst float logo_radius= 0.25;\nconst float logo_off   = 0.25;\nconst float logo_dx    = 0.5/sqrt(3.0);\nconst float logo_width = 0.1;\n\nfloat rcp(float x) {\n  return 1.0 / x;\n}\n\n//P. Gilcher '21, strange approximation\n// Source found at: https://www.shadertoy.com/view/flSXRV\nfloat fast_atan2(float y, float x) {\n  float cosatan2 = x * rcp(abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r) {\n  const vec3 k = vec3(-sqrt(3.0)*0.5,0.5,sqrt(1.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = 2.0*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat stripes(float d) {\n  const float cc = 0.42;\n  d = abs(d)-logo_width*cc;\n  d = abs(d)-logo_width*cc*0.5;\n  return d;\n}\n\nvec4 merge(vec4 s0, vec4 s1) {\n  bool dt = s0.z < s1.z; \n  vec4 b = dt ? s0 : s1;\n  vec4 t = dt ? s1 : s0;\n\n  b.x *= 1.0-exp(-max(80.0*(t.w), 0.0));\n\n  vec4 r = vec4(\n      mix(b.xy, t.xy, t.y)\n    , b.w < t.w ? b.z : t.z \n    , min(b.w, t.w)\n    );\n  \n  return r;\n}\n\nvec4 figure_8(float aa, vec2 p) {\n  vec2  p1 = p-vec2(logo_dx, -logo_off);\n  float d1 = abs(circle(p1, logo_radius));\n  float a1 = fast_atan2(-p1.x, -p1.y);\n  float s1 = stripes(d1);\n  float o1 = d1 - logo_width;\n\n  vec2  p2 = p-vec2(logo_dx, logo_off);\n  float d2 = abs(circle(p2, logo_radius));\n  float a2 = fast_atan2(p2.x, p2.y);  \n  float s2 = stripes(d2);\n  float o2 = d2 - logo_width;\n\n  vec4 c0 = vec4(smoothstep(aa, -aa, s1), smoothstep(aa, -aa, o1), a1, o1);\n  vec4 c1 = vec4(smoothstep(aa, -aa, s2), smoothstep(aa, -aa, o2), a2, o2);\n\n  return merge(c0, c1);\n}\n\nvec4 figure_half_8(float aa, vec2 p) {\n  vec2  p1 = p-vec2(logo_dx, -logo_off);\n  float d1 = abs(circle(p1, logo_radius));\n  float a1 = fast_atan2(-p1.x, -p1.y);\n  float s1 = stripes(d1);\n  float o1 = d1 - logo_width;\n\n  vec4 c0 = vec4(smoothstep(aa, -aa, s1), smoothstep(aa, -aa, o1), a1, o1);\n\n  return c0;\n}\n\nvec2 flipy(vec2 p) {\n  return vec2(p.x, -p.y);\n}\n\nvec4 clogo(vec2 p, float aa, float z, out float d) {\n  float iz = 1.0/z;\n  p *= iz;\n  float  n = modPolar(p, 3.0);\n\n  vec4 s0 = figure_8(aa, p);\n  vec4 s1 = figure_half_8(aa, p*ROT(2.0*PI/3.0));\n  vec4 s2 = figure_half_8(aa, flipy(p*ROT(4.0*PI/3.0)));\n  s1.z += -PI;\n  \n  vec4 s = s0;\n  s = merge(s, s1);\n  s = merge(s, s2);\n\n  d = s.w;\n  vec3 hsv = vec3(fract(s.z/PI+TIME*0.5), 0.9, 1.0);\n  return vec4(hsv2rgb(hsv)*s.x, s.y);\n}\n\n\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.15*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.5*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {\n  float hn = hash(n);\n  float hn0 = hn;\n  float hn1 = fract(137.0*hn);\n  float z = mix(0.1, 0.3, hn0);\n  \n  float pd = length(ro - pp);\n  aa *= mix(1.0, 15.0, smoothstep(planeDist*4.0, 0.0, pd));\n\n  vec2 p = (pp-off*1.0*vec3(1.0, 1.0, 0.0)).xy;\n  p *= ROT(mix(0.125, 0.66, hn1)*TIME);\n  p /= z;\n  aa /= z;\n  float d;\n  float a = TAU*TIME/300.0;\n\n  float cd = hex(p.yx, 0.5);\n  vec2 hp = p;\n  vec2 np = hextile(hp);\n  vec2 cp = hp;\n  float h = hash(np);\n  float hh = fract(137.0*h);\n  float sm = mix(mix(0.025, 0.25, hh), 0.025, h);\n  float rep = 2.0*floor(mix(8.0, 30.0, h));\n  float cn = 0.0; \n  cn = smoothKaleidoscope(cp, sm, rep);\n  cp *= ROT(TIME*0.2+TAU*h);\n  \n  vec4 ccol = clogo(cp, aa, 0.6, d);\n  vec3 gcol = hsv2rgb(vec3(h, 0.8, 4.0));\n  vec3 col  = vec3(0.0);\n  float g = exp(-40.0*max(d, 0.0));\n  col += gcol*g;\n  col = mix(col, ccol.xyz, ccol.w);\n\n  float t0 = smoothstep(aa, -aa, d);\n  float t1 = smoothstep(aa, -aa, -cd);\n  float t2 = 2.0*g;\n  float t = t1*tanh_approx(t0 +t2);\n  \n//  return vec4(col, tanh_approx(t+g));\n  return vec4(col, t);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  return col;\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  const float rdd_per   = 5.0;\n  //float rdd = (2.0+1.0*tanh_approx(lp));  // Playing around with rdd can give interesting distortions\n  //float rdd = 2.0;\n  float rdd =  (1.75+0.75*pow(lp,1.5)*tanh_approx(lp+0.9*PCOS(rdd_per*p.x)*PCOS(rdd_per*p.y)));\n  \n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const int furthest = 8;\n  const int fadeFrom = max(furthest-6, 0);\n\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.95;\n  bool cutOut = false;\n\n  float maxpd = 0.0;\n\n  // Steps from nearest to furthest plane and accumulates the color \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      maxpd = pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = smoothstep(planeDist*float(furthest), planeDist*float(fadeFrom), nz);\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n//      pcol.xyz = mix(skyCol, pcol.xyz, fadeIn);\n      pcol.w *= fadeOut*fadeIn;\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      acol.w = acol.w > cutOff ? 1.0 : acol.w;\n      break;\n    }\n\n  }\n\n  vec3  glowCol   = hsv2rgb(vec3(fract(dot(p, p)-0.25*TIME), 0.66, 1.0));\n  vec3  glowDown  = 2.5*glowCol;\n  vec3  glowUp    = 5.0*glowCol;\n  \n  float beat = smoothstep(0.5, 1.0, sin(BPM*TIME*TAU/60.0));\n  \n  float glowRadius = mix(0.4, 0.5, beat);\n  vec3 pp    = ro + rd*planeDist*float(furthest-1);\n  vec3 off   = offset(pp.z);\n  float sd   = sphered(ro, rd, vec4(off, glowRadius), mix(1E6, maxpd, acol.w));\n  vec3 bcol  = mix(glowDown, glowUp, beat);\n  vec3 gcol  = tanh(sd*bcol);\n  skyCol += gcol;\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm  = planeDist*TIME*BPM/60.0;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  col *= smoothstep(0.0, 4.0, TIME);\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NttSzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[519, 519, 541, 541, 687], [982, 1042, 1082, 1082, 1241], [1243, 1303, 1343, 1343, 1385], [1387, 1473, 1512, 1512, 1637], [1639, 1639, 1670, 1670, 1695], [1697, 1697, 1728, 1728, 1754], [1756, 1807, 1865, 1865, 2314], [2316, 2399, 2438, 2438, 2523], [2525, 2613, 2652, 2652, 2681], [2683, 2743, 2771, 2837, 2913], [2915, 2975, 2997, 2997, 3045], [3047, 3107, 3127, 3127, 3209], [3211, 3294, 3330, 3330, 3658], [3793, 3793, 3813, 3813, 3833], [3835, 3933, 3969, 3969, 4079], [4081, 4175, 4203, 4203, 4387], [4389, 4490, 4518, 4617, 4944], [4946, 5032, 5081, 5081, 5483], [5485, 5573, 5603, 5603, 5630], [5632, 5718, 5763, 5763, 5917], [5920, 6008, 6030, 6030, 6074], [6076, 6164, 6185, 6185, 6230], [6232, 6320, 6381, 6381, 6594], [6596, 6596, 6620, 6620, 6719], [6721, 6721, 6751, 6751, 6987], [6989, 6989, 7022, 7022, 7560], [7562, 7562, 7600, 7600, 7872], [7874, 7874, 7894, 7894, 7922], [7924, 7924, 7976, 7976, 8353], [8356, 8356, 8378, 8378, 8511], [8513, 8513, 8536, 8536, 8611], [8613, 8613, 8637, 8637, 8714], [8716, 8716, 8784, 8784, 9845], [9847, 9847, 9880, 9880, 9920], [9922, 9922, 9978, 9978, 12237], [12239, 12239, 12268, 12268, 12583], [12585, 12585, 12640, 12640, 12866]], "test": "untested"}
{"id": "NttSRB", "name": "Repeating pattern", "author": "jorgemoag", "description": "Repeating pattern with raymarching", "tags": ["spheres"], "likes": 1, "viewed": 119, "published": 3, "date": "1639333490", "time_retrieved": "2024-07-30T18:42:32.086065", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sp = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec3 co = vec3(5. * sin(.5*iTime) + cos(3.*iTime), .5*cos(2.*iTime)+.75*sin(1.5*iTime + .2), 5. * cos(.5*iTime));\n    vec3 ct = vec3(0);\n    \n    vec3 cam_ww = normalize(ct - co);\n    vec3 cam_uu = normalize(cross(cam_ww, vec3(0,1,0)));\n    vec3 cam_vv = cross(cam_uu, cam_ww);\n    \n    vec3 rd = sp.x * cam_uu + sp.y * cam_vv + 1.0 * cam_ww;\n    vec3 col = vec3(0);\n    \n    float tot_dist = 0.0;\n    \n    for (int st = 0; st < 512; ++st) {\n        vec3 pos = co + tot_dist * rd;        \n        \n        vec3 q = (mod(pos, 3.) - 1.5) / 3.;\n        float h = length(q) - 0.2;        \n        if (h < 0.0001) {\n            vec3 N = normalize(q);\n            col = 0.5 * N + vec3(0.5);\n            float ee = exp(-.15*tot_dist);\n            col *= ee;\n            col *= pow(dot(N, rd),2.0);\n            \n            col += ee*clamp(1.0 - pow(abs(dot(N, rd)),5.0), 0.0, 1.0)*texture(iChannel0, reflect(rd, N)).rgb;\n            \n            break;\n        }\n        tot_dist += h;\n    }\n    \n    col = sqrt(col);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NttSRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1173]], "test": "untested"}
{"id": "7t3XzB", "name": "Mandelbrot 252", "author": "tungster24", "description": "mandelbrot set in 252 chars.", "tags": ["fractal", "mandelbrot", "short"], "likes": 1, "viewed": 244, "published": 3, "date": "1639319706", "time_retrieved": "2024-07-30T18:42:33.029541", "image_code": "void mainImage( out vec4 j, in vec2 J )\n{\n    vec2 q,r = iResolution.xy;\n    vec4 c,z = vec4(q , (J.x*2.4-1.5*r.x)/r.y , J.y/r.y*2.4-1.2);\n    int t,i=t=0;\n    for (;i<98 && z.x*z.x+z.y*z.y < 4.0;i++,t++)\n        z = vec4(z.x*z.x-z.y*z.y+z.z,2.0*z.x*z.y+z.w,z.zw);\n    c = vec4(t>97?0.0:float(t)/50.0);\n    j=c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3XzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 313]], "test": "untested"}
{"id": "st3XzB", "name": "rotate_shape", "author": "newJasper", "description": "rotate", "tags": ["2d"], "likes": 0, "viewed": 190, "published": 3, "date": "1639319555", "time_retrieved": "2024-07-30T18:42:33.823419", "image_code": "float rectshape(vec2 position, vec2 scale){\n\tscale = vec2(0.5) - scale * 0.7;\n\tvec2 shaper = vec2(step(scale.x, position.x), step(scale.y, position.y));\n    shaper *= vec2(step(scale.x, 1.0 - position.x), step(scale.y, 1.0 - position.y));\n\treturn shaper.x * shaper.y; \n}\n\nmat2 rotate(float angle){\n\treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 coord = fragCoord/iResolution.y;\n\n    vec3 color = vec3(0.0);\n\n\tcoord -= vec2(0.5);\n    coord = (fragCoord - .5* iResolution.xy ) /iResolution.y;\n\tcoord = rotate(0.3*sin(iTime))*coord ;\n\t//coord += vec2(0.5);\n\n\tcolor += vec3(rectshape(coord, vec2(0.3, 0.3)));\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3XzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 270], [272, 272, 297, 297, 362], [364, 364, 421, 471, 800]], "test": "untested"}
{"id": "stcXzS", "name": "cardioid drawing animation", "author": "krasnikov05", "description": "https://en.wikipedia.org/wiki/Cardioid", "tags": ["animation", "cardioid"], "likes": 4, "viewed": 247, "published": 3, "date": "1639313637", "time_retrieved": "2024-07-30T18:42:34.729995", "image_code": "#define PI 3.141592653589793\n#define THICKNESS .04\n#define DELTA .1\n\nfloat circle(float x0, float y0, vec2 uv) {\n    float pix = 8./iResolution.y;\n    return smoothstep(THICKNESS-pix, THICKNESS+pix,\n    abs(distance(uv, vec2(x0, y0))-1.));\n}\n\nfloat line(float x1, float y1, float x2, float y2, vec2 uv) {\n  float t = THICKNESS;\n  if(uv.x <= min(x1,x2)-t ||\n     uv.x >= max(x1,x2)+t ||\n     uv.y <= min(y1,y2)-t ||\n     uv.y >= max(y1,y2)+t\n  ) return 1.;\n  float pix = 8./iResolution.y;\n  vec2 lineDir = vec2(x2, y2) - vec2(x1, y1);\n  vec2 perpDir = vec2(lineDir.y, -lineDir.x);\n  vec2 dirToPt1 = vec2(x1, y1) - uv;\n  float d = abs(dot(normalize(perpDir), dirToPt1));\n  return smoothstep(THICKNESS-pix, THICKNESS+pix, d);\n}\n\n\nvec3 cardioid(float n, vec2 uv) {\n    float x1 = 0.;\n    float y1 = 0.;\n    float x2 = 0.;\n    float y2 = 0.;\n    float o = 1.;\n    for(float t = 0.; t < n; t += DELTA) {\n        x1 = 2.*cos(t)-cos(2.*t);\n        y1 = 2.*sin(t)-sin(2.*t);\n        x2 = 2.*cos(t-DELTA)-cos(2.*(t-DELTA));\n        y2 = 2.*sin(t-DELTA)-sin(2.*(t-DELTA));\n        o *= line(x1,y1,x2,y2,uv);\n    }\n    x2 = 2.*cos(n)-cos(2.*n);\n    y2 = 2.*sin(n)-sin(2.*n);\n    o *= line(x1,y1,x2,y2,uv);\n    return vec3(1.)-(1.-o)*vec3(0.,1.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 8.*( fragCoord - .5*iResolution.xy ) / iResolution.y;\n\n    float time = abs(mod(.1*iTime, 2.)-1.)*PI*2.;\n\n    vec3 col = vec3(1.);\n\n    col *= circle(0., 0., uv);\n    \n    col *= circle(2.*cos(time), 2.*sin(time), uv);\n    \n    col *= line(2.*cos(time), 2.*sin(time),\n    2.*cos(time)-cos(2.*time), 2.*sin(time)-sin(2.*time), uv);\n\n    col *= cardioid(time, uv);\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcXzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 112, 112, 241], [243, 243, 304, 304, 724], [727, 727, 760, 760, 1238], [1240, 1240, 1297, 1297, 1708]], "test": "untested"}
{"id": "7t3Gz7", "name": "[TDF2021]Toy Duck", "author": "EvilRyu", "description": "1st place of Tokyo Demo Fest 2021 Graphics Compo", "tags": ["duck", "cloth", "tdf", "fabric"], "likes": 43, "viewed": 623, "published": 3, "date": "1639311667", "time_retrieved": "2024-07-30T18:42:36.016555", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// 4kb executable for Tokyo Demo Fest 2021 Graphics Compo\n\n\n// This FXAA pass brings some fluffy effect on the fabric part of the final image\n#define REDUCE_MUL (1. / 8.)\n#define REDUCE_MIN (1. / 128.)\n#define INTENSITY 3.1\n\nfloat rgb2luma(vec4 col)\n{\n\treturn col.y *(.587 / .299) + col.x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n\tvec2 eps = 2. / iResolution.xy;\n\n\tfloat topLeft   = rgb2luma(texture(iChannel0, uv + vec2(-eps.x, eps.y)));\n\tfloat topRight  = rgb2luma(texture(iChannel0, uv + eps.xy));\n\tfloat downLeft  = rgb2luma(texture(iChannel0, uv - eps.xy));\n\tfloat downRight = rgb2luma(texture(iChannel0, uv + vec2(eps.x, -eps.y)));\n\tfloat center    = rgb2luma(texture(iChannel0, uv));\n\n\tvec2 dir        = vec2((topLeft + topRight) - (downLeft + downRight),\n\t\t                  (downLeft + topLeft) - (downRight + topRight));\n\tfloat dirReduce = max((downLeft + downRight + topLeft + topRight) * REDUCE_MUL * 0.25, REDUCE_MIN);\n\tfloat dirMin    = 1. / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\tdir             = min(vec2(INTENSITY), max(-vec2(INTENSITY), dir * dirMin)) * eps.xy;\n\n\tvec4 colA       = (texture(iChannel0, uv - .166667 * dir) + texture(iChannel0, uv + .166667 *dir)) *.5;\n\tvec4 colB       = colA *.5 + .25 * (texture(iChannel0, uv - .5 * dir) + texture(iChannel0, uv + .5 * dir));\n\tfloat LumB = rgb2luma(colB);\n\n\tif (LumB < min(center, min(min(downLeft, downRight), min(topLeft, topRight))) ||\n\t\tLumB > max(center, max(max(downLeft, downRight), max(topLeft, topRight))))\n\t\tfragColor = colA;\n\telse\n\t\tfragColor = colB;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define MAT_HEAD 0.\n#define MAT_BODY 1.\n#define MAT_SCARF 2.\n#define MAT_BEAK 3.\n#define MAT_BALL 4.\n#define MAT_CARPET 5.\n#define MAT_TORUS 6.\n\n#define PI 3.1415926535\n\nvoid rot2d(inout vec2 p, float t)\n{\n    float ct = cos(t), st = sin(t);\n    vec2 q = p;\n    p.x = ct * q.x + st * q.y;\n    p.y = -st * q.x + ct * q.y;\n}\n\nvec2 hash22(vec2 p)\n{\n    p = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\n// iq: https://www.shadertoy.com/view/XdXBRH\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    vec2 u = f * f * (3. - 2. * f);\n    vec2 du = 6. * f * (1. - f);\n\n    vec2 ga = hash22(i + vec2(0));\n    vec2 gb = hash22(i + vec2(1, 0));\n    vec2 gc = hash22(i + vec2(0, 1));\n    vec2 gd = hash22(i + vec2(1));\n\n    float va = dot(ga, f - vec2(0));\n    float vb = dot(gb, f - vec2(1, 0));\n    float vc = dot(gc, f - vec2(0, 1));\n    float vd = dot(gd, f - vec2(1));\n\n    return vec3(va + u.x * (vb - va) + u.y * (vc - va) + u.x * u.y * (va - vb - vc + vd),  // value\n                ga + u.x * (gb - ga) + u.y * (gc - ga) + u.x * u.y * (ga - gb - gc + gd) + // derivatives\n                    du * (u.yx * (va - vb - vc + vd) + vec2(vb, vc) - va));\n}\n\nvec2 fibers(vec2 p)\n{\n    vec3 f = noised(p) + noised(p* vec2(2.6, 1.3)) * vec3(.64, .3, .3);\n    return f.yz;\n}\n\n// it's not very useful eventually\nvec3 cloth(vec2 p)\n{\n    float c = (2. * smoothstep(-1., 1., sin(p.x * 100.)) - 1.) * (2. * smoothstep(-1., 1., sin(p.y * 100.)) - 1.);\n    c = smoothstep(-.2, .2, c);\n    return normalize(vec3(mix(fibers(p * vec2(4., 300.)), fibers(p * vec2(300., 4.)), c), 1));\n}\n\nfloat noise(vec3 p)\n{\n    const vec3 s = vec3(7, 157, 113);\n    vec3 ip = floor(p);\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p -= ip;\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec3 p)\n{\n    mat3 m = mat3(.0, .8, .6, -.8, .36, -.48, -.6, -.48, .64);\n    float f = 0., s = .5;\n    for (int i = 0; i < 4; ++i)\n    {\n        f += s * noise(p);\n        p = m * p * 2.01;\n        s *= .5;\n    }\n\n    return f;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(.5 + .5 * (b - a) / k, .0, 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nvec2 opU(vec2 obj0, vec2 obj1)\n{\n    return obj0.x < obj1.x ? obj0 : obj1;\n}\n\nvec2 opSU(vec2 obj0, vec2 obj1, float s)\n{\n    return vec2(smin(obj0.x, obj1.x, s), obj0.x < obj1.x ? obj0.y : obj1.y);\n}\n\nfloat opOnion(float sdf, float thickness)\n{\n    return abs(sdf) - thickness;\n}\n\nfloat capsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat cylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat ellipsoid(vec3 p, vec3 r)\n{\n    float k0 = length(p / r);\n    return k0 * (k0 - 1.) / length(p / (r * r));\n}\n\n// This is the star pattern on duck's body\n// It's also used as displacement map for some fabric\nfloat starInner(vec2 f)\n{\n    rot2d(f, 1.6);\n    f = fract(f) * 2. - 1.;\n    float a = PI / 5.;\n    f.x = abs(f.x);\n    vec2 v = vec2(cos(a), sin(a));\n    for (int i = 0; i < 3; i++)\n        f -= 2. * min(0., dot(f, v)) * v, v = normalize(vec2(v.x - 1., v.y));\n\n    return abs(f.y - f.x * .9) - .4;\n}\n\nfloat star(vec3 p, float s)\n{\n    return starInner(vec2(atan(p.z, p.x), p.y * 3.) * s);\n}\n\nfloat box(vec2 p, vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return smoothstep(0., .01, length(max(d, 0.0)) + min(max(d.x, d.y), .0));\n}\n\nfloat sph(vec2 p, float r)\n{\n    return p.x > 0. ? smoothstep(0., .01, length(p) - r) : 0.;\n}\n\n// T D F text\nfloat text(vec2 uv)\n{\n    uv*=.5;\n    rot2d(uv,.3);\n    uv += vec2(2.2, -1.5);\n    uv -= vec2(sin(uv.y) * .5, sin(uv.x) * .1);\n    float d =\n        min(box(uv, vec2(.4, .1)), min(box(uv + vec2(0, .5), vec2(.1, .4)), box(uv - vec2(.7, -.4), vec2(.1, .5))));\n    d = min(d, smoothstep(0., .01, sph(uv - vec2(.8, -.4), .5)) + abs(1. - sph(uv - vec2(.8, -.4), .3)) * 1.);\n    d = min(d, min(box(uv - vec2(1.6, -.4), vec2(.1, .5)), box(uv - vec2(1.95, 0), vec2(.25, .1))));\n    return min(d, box(uv - vec2(1.85, -.4), vec2(.15, .1)));\n}\n\n#define S(p,r) step(length(p)-r,.001)\n// Siggraph logo, TDF is held as a co-located event of SIGGRAPH ASIA\nfloat siggraph(vec2 p)\n{\n    p*=mat2(1,.7,-.7,1);\n    p-=vec2(3,-1);\n    float d=S(p,1.)*(1.-S(p*vec2(.49,1.),.55));\n    vec2 a=vec2(.41,1.1), b=vec2(.44,1.1), c=vec2(.0,.15), e=vec2(.1,.08);\n    d+=S(p*a-c,.4);\n    d*=1.-S(p*b*1.15-e, .42);\n    float k=S(p*a+c,.4) * (1.-S(p*b*1.15+e, .42));\n    \n    return 1.-max(k,d);\n}\n\nvec2 duck(vec3 p)\n{\n    vec3 p0 = p;\n\n    vec2 head =\n        vec2(capsule(p, vec3(0, 1. + sin(p.x) * .1, 0), vec3(0, .4, .1), .4 + sin(p.y * 10. - 4.) * .01), MAT_HEAD);\n    vec2 body = vec2(capsule(p - vec3(0, -.2, .13), vec3(0, .4, 0), vec3(0, -.5, 0), .37 + sin(p.y) * .02), MAT_BODY);\n\n    vec2 beak = vec2(\n        capsule((p - vec3(0, .1, -.5)) * vec3(1, 1.2, 1), vec3(0, .0, 0), vec3(0, .4, .3), .12 - sin(p.z) * .1) / 1.2,\n        MAT_BEAK);\n\n    rot2d(p0.xz, -.5);\n    p0 -= vec3(.1, 1.5, -.05);\n    p0.x = abs(p0.x) - .08;\n    rot2d(p0.xy, -.4);\n    rot2d(p0.yz, .5);\n    p0.z -= .1 * sin(p0.y * 8. - 1.);\n    p0.x = abs(p0.x) + .64;\n    vec2 hair = vec2(cylinder(p0.xzy, vec2(.68, .001)), MAT_HEAD);\n\n    p0 = p;\n    p0.x = abs(p0.x) - .45;\n    rot2d(p0.xz, -.4);\n\n    rot2d(p0.xy, -.3);\n    p0.y += .2;\n    vec2 wing = vec2(ellipsoid(p0, vec3(.3, .16, .04)), MAT_BEAK);\n\n    p0 = p;\n    rot2d(p0.yz, -.2);\n    float t = .01 * sin(p.x * 20.) + .07 * sin(p.x);\n    vec2 scarf =\n        vec2(cylinder(p0 - vec3(0, .15, .16),\n                      vec2(.38 + .005 * sin(p0.y * 50. - sin(p0.z) * 10. + .1 * sin(p0.x * 500. + p0.y * 500.)),\n                           .1 + t + .01 * sin(p0.y * 20. - 1.))),\n             MAT_SCARF);\n\n    scarf.x += .005 * smoothstep(.01, .0, abs(opOnion(p0.y -.035 + t, .0))) - .03;\n    scarf.x += .001 * smoothstep(.05, 0., star(p, iResolution.x / 55.));\n\n    p0 = p;\n    rot2d(p0.xy, .1);\n    p0 = vec3(abs(p0.x - .07) - .15, p0.y - .67, p0.z + .3);\n    vec2 eyes = vec2(cylinder(p0.xzy * vec3(.8, 1, 1), vec2(.04)), MAT_HEAD);\n\n    p0 = vec3(abs(p.x) - .25, p.y - .58, p.z + .3);\n    vec2 cheek = vec2(cylinder(p0.xzy * vec3(.8, 1, 1), vec2(.05, .1)), MAT_HEAD);\n\n    float l = (.003 - .0015 * sin(p.y * 300.));\n    head.x += l * smoothstep(.01, .0, abs(opOnion(p.x+.003*sin(p0.y*20.), .0)));\n    p0 = p;\n    rot2d(p0.yz, -0.2);\n    head.x += l * smoothstep(.01, .0, abs(opOnion(p0.z - .1, .0)));\n    head.x += .002 * smoothstep(.01, .0, abs(opOnion(eyes.x, .0)));\n    head.x += .002 * smoothstep(.0, .005, abs(opOnion(cheek.x, .0)));\n    head.x -= .005 * smoothstep(-.0, .07, abs(opOnion(scarf.x, .0)));\n    head.x += .0007 * smoothstep(.05, 0., star(p, iResolution.x / 95.));\n    \n    rot2d(p.yz, -.9);\n    beak.x += (.002 - .0015 * sin(p.z * 500.)) * smoothstep(.01, .0, abs(opOnion(p.y - .45, 0.)));\n\n    vec2 res = opSU(head, body, .05);\n    res = opSU(res, beak, .02);\n    res = opU(res, hair);\n    res = opSU(res, wing,.01);\n    res = opU(res, scarf);\n\n    return res;\n}\nvec2 polarRep(vec2 p, float n)\n{\n    n = PI * .5 / n;\n    float a = atan(p.y, p.x), r = length(p);\n    a = mod(a + n / 2., n) - n / 2.;\n    p = r * vec2(cos(a), sin(a));\n    return .5 * (p + p - vec2(1, 0));\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// the dots on the carpet, TDF logo\nfloat tdf(vec2 p)\n{\n    float t = 10., r = .05;\n    p *= 1.5;\n    rot2d(p, -.7);\n    p = p - vec2(1,.8);\n    for (int i = 6; i > 0; --i)\n    {\n        for (int j = 0; j < i; ++j)\n        {\n            t = min(t, smoothstep(.0, .05, length(p) - r));\n            p.y += 5. * r;\n        }\n        p.x -= 2.5 * r;\n        p.y -= 5. * float(i) * r - 2.5 * r;\n    }\n\n    return 1. - t;\n}\n\nfloat shadowRay = 0.;\nvec2 map(vec3 p)\n{\n    vec3 q = p + vec3(1.3, .45, .2);\n    vec2 ssph = vec2(1e10, 0);\n    q.y = abs(q.y);\n    for (int i = 0; i < 4; ++i)\n    {\n        vec2 qq = polarRep(q.xz, 3. - float(i * i) * .3);\n        ssph = opU(ssph, vec2(length(vec3(qq.x + float(i * i) * .05, q.y, qq.y)) - .07, MAT_BALL));\n        if (i == 2)\n            q.y -= .1;\n        else\n            q.y -= .2;\n    }\n    vec2 sph = vec2(length(p + vec3(1.3, .45, .2)) - .5, MAT_BALL);\n    \n    vec2 flr = vec2(p.y + 1.02 + .003 * smoothstep(.2, 0., starInner(p.xz * iResolution.x / 55.)) +\n                        .4 * sin((p.x + 10.) * (p.z + 7.) * .2) * smoothstep(0., 6., length(vec2(p.x + .6, p.z))),\n                    MAT_CARPET);\n    float k = .003 * smoothstep(.0, .005, abs(opOnion(pow(abs(sin(p.x * 10.)), 10.), .0)));\n    flr.x -= k;\n    vec2 back = vec2(abs(p.z - 2.5 - 0.2 * p.y - 0.1 * sin(p.x * p.y * 1. - 2.) * (1. - smoothstep(0., 10., length(vec2(p.x + .6, p.y))))),\n                     MAT_CARPET);\n    back.x += .003 * smoothstep(.05,.0, starInner(p.xy * iResolution.x / 55.)) + k;\n\n    flr = opSU(flr, back, .5);\n    flr.x -= .01 * tdf(p.xz);\n    flr.x -= .01 * text(p.xy);\n    flr.x -= .01 * siggraph(p.xy);\n\n    q = p + vec3(.5, .875, 1.);\n    k=.02 * sin(q.x * 15.);\n    vec2 to = vec2(torus(q, vec2(.4 + k + .01 * sin(q.z * 20.), .09 + .01 * sin(q.x * 10.))), MAT_TORUS);\n\n    vec2 edge =\n        vec2(torus(q*vec3(1,1.5,1), vec2(.55 + k + .01 * sin(q.z * 20.) - .1 * shadowRay, 1e-3)), MAT_TORUS);\n\n    to = opSU(to, edge, .11);\n    to.x += (.002 - .0015 * sin(atan(q.z,q.x) * 200.)) * smoothstep(.01, .0, abs(opOnion(edge.x - .03, 0.)));\n    to.x += .0001 * smoothstep(.05, 0., star(q, iResolution.x / 55.)) + .002*sin(atan(q.z,q.x)*20.);\n    to.x -= .001 * smoothstep(.1, .8, fbm(q * 300.));\n\n\n    vec2 res = opU(sph, flr);\n    res = opSU(res, ssph, .04);\n    res = opU(res, duck(p));\n\n    res = opU(res, to);\n\n    return res;\n}\n\nfloat shadow(vec3 ro, vec3 rd, float k)\n{\n    float res = 1., t = .01, h;\n    shadowRay = 1.;\n    for (int i = 0; i < 96; i++)\n    {\n        h = map(ro + rd * t).x;\n        res = min(res, k * h / t);\n        t += clamp(h, .005, .1);\n        if (res < .002 || t > 50.)\n            break;\n    }\n    shadowRay = 0.;\n    return max(res, .0);\n}\n\nfloat getAO(vec3 p, vec3 n)\n{\n    float occ = .0, sca = 1., h, d;\n    for (int i = 0; i < 5 && occ < .35; i++, sca*=.95)\n    {\n        h = 1e-5 + .1 * float(i) / 4.;\n        d = map(p + h * n).x;\n        occ += (h - d) * sca;\n    }\n\n    return clamp(1. - 3. * occ, .1, 1.) * (.5 + .5 * n.y);\n}\n\nfloat sss(vec3 p, vec3 n, float d, float i) \n{ \n    float o,v; \n    for(o=0.;i>0.;i--) \n        o+=(i*d+map(p+n*i*d).x)/exp2(i); \n    return o; \n}\n\nvec2 intersect(vec3 ro, vec3 rd)\n{\n    float t = .1;\n\n    vec2 res = vec2(1e10, 0);\n\n    for (int i = 0; i < 256; ++i)\n    {\n        if (res.x < .005 * t || t > 100.)\n            break;\n\n        res = map(ro + t * rd);\n        t += res.x * .5;\n    }\n\n    return vec2(t, res.y);\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 n = vec3(0);\n    for (int i = 0; i < 4; i++)\n    {\n        vec3 e = .5773 * (2. * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.);\n        n += e * map(p + .001 * e * t).x;\n    }\n    return normalize(n);\n}\n\nvec3 SHIrradiance(vec3 n)\n{\n    return (vec3(.11959, .09155, .09027) * (n.x * n.x - n.y * n.y) + vec3(-.13644, -.10004, -.1046) * n.z * n.z +\n            vec3(.50681, .37237, .35038) + vec3(.27551, .21303, .22091) * n.x * n.y +\n            vec3(-.07177, -.05691, -.05647) * n.x * n.z + vec3(-.04908, -.04005, -.03579) * n.y * n.z +\n            vec3(.36545, .27871, .28709) * n.x + vec3(.22691, .17525, .17384) * n.y +\n            vec3(-.11745, -.09585, -.08932) * n.z);\n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec3 g = cloth(p.xy) * abs(n.z) + cloth(p.xz) * abs(n.y) + cloth(p.yz) * abs(n.x);\n    g = (g - n * dot(g, n));\n    return normalize(n + g * weight);\n}\n\n\nstruct Material\n{\n    vec3 baseCol, specularCol;\n    float roughness;\n};\n\nfloat specularBRDF(float roughness, vec3 n, vec3 v, vec3 l)\n{\n    vec3 h = normalize(v + l);\n    float NoV = abs(dot(n, v)) + .1;\n    float NoL = clamp(dot(n, l), 0., 1.);\n    float NoH = clamp(dot(n, h), 0., 1.);\n    float D = (2. + 1. / roughness) * pow(max(1. - NoH * NoH, .0078125), 1. / roughness * .5) / (2. * PI);\n    return D / (4. * (NoL + NoV - NoL * NoV));\n}\n\nvec3 carpetCol = vec3(0.322,0.078,0.078);\n\nMaterial getMaterial(float id, vec3 n, vec3 v, vec3 l, vec3 p, out vec3 n2, float t)\n{\n    Material mate;\n    float s;\n    n2=n;\n    if (id == MAT_CARPET)\n    {\n        s = smoothstep(.1, .8, fbm(p * 100.));\n        n2 = bump_mapping(p * 50., n, mix(.1, .3, s));\n        mate.baseCol = mix(carpetCol, vec3(.490,.212,.212), s);\n        mate.baseCol = mix(mate.baseCol, vec3(.463,.278,.278), smoothstep(.2,.0,abs(sin(p.x * 10.))));\n        mate.baseCol = mix(mate.baseCol, vec3(.592,.169,.169), smoothstep(.2,.0,abs(sin(p.x * 20.-1.))));\n        mate.baseCol = mix(mate.baseCol, vec3(0), tdf(p.xz));\n        mate.baseCol = mix(vec3(1), mate.baseCol, text(p.xy));       \n        mate.baseCol = mix(vec3(1), mate.baseCol, siggraph(p.xy));\n\n        mate.roughness = .7;\n        mate.specularCol = vec3(0.604,0.455,0.455);\n    }\n    else if(id >= MAT_HEAD && id <= MAT_SCARF)\n    {\n        mate.baseCol = mix(vec3(1), vec3(.3, 0, 0), smoothstep(.05, .0, star(p, 2.)));\n        mate.roughness = .6;\n        mate.specularCol = vec3(1);\n        n2 = bump_mapping(p * 50., n, .2);\n\n        if (id == MAT_HEAD)\n        {\n            mate.baseCol = mix(vec3(1), vec3(.8), smoothstep(.05, .0, star(p, iResolution.x / 95.)));\n\n            float scale = 2.;\n            if (p.z < 0.)\n            {\n                vec2 q = p.xy;\n                rot2d(q, .1);\n                q = vec2(abs(q.x - .07) - .15, q.y - .68);\n                mate.baseCol *= pow(smoothstep(.009, .01, length(q * vec2(.8, 1.)) - .03 + sin(q.y * 50.) * .005), 10.);\n\n                q = vec2(abs(p.x) - .25, p.y - 0.58);\n                float k = 1. - smoothstep(0., .001, length(q * vec2(.8, 1.)) - .05);\n                mate.baseCol = mix(mate.baseCol, vec3(.6, 0., 0.), k);\n                scale = mix(2., 100., k);\n            }\n        }\n        else if (id == MAT_SCARF)\n        {\n            mate.baseCol = vec3(.38, .02, .02);\n            mate.specularCol = vec3(1, .64, .64);\n        }        \n    }\n    else if (id == MAT_BEAK)\n    {\n        s = smoothstep(.4, .8, fbm(p * 4.));\n        n2 = bump_mapping(p * 50., n, mix(.2, .5, s));\n        mate.baseCol = mix(vec3(.561, .353, 0), vec3(1, .8, 0), s);\n        mate.roughness = .2;\n        mate.specularCol = vec3(.82, .655, 0);\n    }\n    else if (id == MAT_TORUS)\n    { \n        s = smoothstep(.1, .8, fbm(p * 300.));\n                \n        mate.baseCol = mix(vec3(.016,.082,.145), vec3(.004,.027,.055), s);\n        mate.specularCol = vec3(.208,.329,.431);\n        n2 = bump_mapping(p*50., n, .2);\n        mate.roughness = .5;\n    }\n\n    return mate;\n}\n\nvec3 scene(vec3 ro, vec3 rd, vec2 payload)\n{\n    float t = payload.x, mId = payload.y, sha,ao,k;\n\n    vec3 pos,n,n2,Ld1,Lc,Lp1,L1,drt,bac,bac2,sky,L2,indi,env,brdf,sca=vec3(0);\n\n    pos = ro + t * rd;\n    n2 = n = getNormal(pos, t);\n\n    Lp1 = vec3(1, 2, -1);\n    L1 = normalize(Lp1 - pos);\n    Ld1 = normalize(Lp1 - vec3(.3, 0, 0));\n    Lc = vec3(.973, .902, .749) * smoothstep(.75, .85, dot(L1, Ld1));\n\n    Material mate = getMaterial(mId, n, -rd, L1, pos, n2, t);\n    sha = shadow(pos + .001 * n2, L1, 10.);\n    ao = getAO(pos + .0001 * n2, n2);\n    drt = max(0., dot(n2, L1)) * 5. * Lc;\n    bac = max(0., dot(n2, -L1)) * 1.5 * Lc * carpetCol * smoothstep(.3, -.5, pos.y);\n    bac2 = max(0., -n2.y) * 2. * Lc * carpetCol * smoothstep(.5, .0, pos.y);\n    sky = max(0., n2.y) * vec3(.627, .906, .973);\n    \n    L2 = vec3(-1.4, -.45, -.2)-pos;\n    k=length(L2);\n    indi = max(0., dot(n2,L2/k))*vec3(.549,.2,.012) * exp(-k);\n    \n    env = 2. * SHIrradiance(n2) * exp(-length(rd.xy));\n    \n    brdf = mate.baseCol / PI + specularBRDF(mate.roughness, n, -rd, L1) * mate.specularCol;\n\n   \n    if(mId == MAT_BALL)\n    {\n        sca=sss(pos,-n,.6,20.)*vec3(.925,.612,.318)*2.;\n        sca*=sca;\n        float spe=pow(max(0.,dot(rd,reflect(Ld1,n))), 24.);\n        float fre=clamp(1.-dot(n,-rd),0.,1.);\n        brdf=vec3(.549,.200,.012)/PI+spe*.5*fre;\n        indi = vec3(0);\n    }\n\n    return (drt * sha + (sca + bac + bac2 + sky + env + indi) * ao) * brdf * .2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p=(2.*uv-1.)*iResolution.xy/iResolution.y;\n    \n    vec3 ro = vec3(0, .1, -3.8), ta = vec3(-.6, .1, 1), l,r,u,rd,col=vec3(0);\n    float time = iTime;\n\n    vec2 m = vec2(0.5);\n\n    if (iMouse.z > .0)\n    {\n        m = iMouse.xy / iResolution.xy;\n        float an = 2.0 + 0.3 * time - 12.0 * (m.x - 0.5);\n        ro = vec3(abs(ro.z) * sin(an), 0.2, abs(ro.z) * cos(an));\n    }\n\n    l = normalize(ta - ro);\n    r = normalize(cross(vec3(0, 1, 0), l));\n    u = normalize(cross(l, r));\n\n    rd = normalize(mat3(r, u, l) * vec3(p.xy, 2));\n\n    vec2 res = intersect(ro, rd);\n\n    float t = res.x;\n\n    if (t < 100.)\n    {\n        col = scene(ro, rd, res);\n    }\n  \n    col = pow(col*vec3(2.8,2.79,2.78),vec3(.585));\n    col = (col*(2.51*col+.03))/(col*(2.43*col+.59)+.14);\n    col *= .5 + .5 * pow(16. * uv.x * uv.y * (1. - uv.x) * (1. - uv.y), .15);\n    fragColor.xyz = col;\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3Gz7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[334, 334, 360, 360, 400], [402, 402, 457, 457, 1705]], "test": "untested"}
{"id": "slcSRS", "name": "cyclics 15  ( 194 chars )", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "2tweets", "short", "cyclic"], "likes": 14, "viewed": 249, "published": 3, "date": "1639310654", "time_retrieved": "2024-07-30T18:42:36.865286", "image_code": "/**  // 212 chars  ( see golfing below )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y /.1; \n    float t = mod(iTime,2.),\n    \n          z = t < 1.           ? exp2(fract(iTime))     // phase1: expend\n            : mod(U.x,2.) > 1. ? U.y -=  (2.-t)/.1 , 1. // phase2: insert fall\n            :                       2. ;\n    U.x = fract(U.x/z) * z - .5;                        // lateral expend\n    \n    O = 1.- (length(U)-.47) *R.yyyy/30.;                // draw discs\n    \n}\n/**/\n\n\n\n\n\n/**/ // 194:  -7 by Xor\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U += U - (O.xy=iResolution.xy);\n    U /= O.y * .1;\n    float t = mod(iTime,2.);\n    U.x = mod( U,  t  < 1.          ? exp2(fract(t))\n                 : mod(U.x,2.) > 1. ? U.y -=  20.-t/.1, 1.\n                 :                    2. \n             ).x - .5;\n    \n    O = (.55-length(U)) * O.yyyy/30.;\n}\n/**/\n\n\n\n\n\n/** // 201: -9 chars by Greg, Xor \n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = ( U+U - (O.xy=iResolution.xy) ) / O.y / .1; \n    float t = mod(iTime,2.),\n    \n          z = t < 1.           ? exp2(fract(t))       // phase1: expend\n            : mod(U.x,2.) > 1. ? U.y -=  20.-t/.1, 1. // phase2: insert fall\n            :                       2. ;\n    U.x = mod(U.x,z) - .5;                            // lateral expend\n    \n    O = 1.- (length(U)-.47) * O.yyyy/30.;             // draw discs\n    \n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcSRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[568, 568, 606, 606, 912]], "test": "untested"}
{"id": "7lcSWn", "name": "Truchet Experiment 023", "author": "byt3_m3chanic", "description": "a very lazy way to dither stuff / fun UI editable version using dat.gui - [url]https://codepen.io/pjkarlik/pen/QWqKvbV[/url]", "tags": ["raymarching", "truchet", "tiles"], "likes": 19, "viewed": 353, "published": 3, "date": "1639309582", "time_retrieved": "2024-07-30T18:42:37.759894", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Truchet Experiment 023\n    12/12/2021  @byt3_m3chanic\n    \n*/\n\n#define R           iResolution\n#define M           iMouse\n#define T           iTime\n#define PI          3.14159265358\n#define PI2         6.28318530718\n#define MIN_DIST    .0001\n#define MAX_DIST    50.\n\n// globals & const\nvec3 hit,hitPoint;\nvec4 gtile,stile;\nmat2 flip;\n\nconst vec3 colorA = vec3(0.890,0.722,0.110);\nconst vec3 colorB = vec3(0.039,0.322,0.741);\nconst vec3 colorC = vec3(0.831,0.125,0.047);\n// cell size\nconst float size = 2.75;\nconst float hlf = size/2.;\n// grid size\nconst vec2  grid = vec2(5,2);\n// tube size\nconst float thick = .85/size;\n// floor tile scale\nconst vec3 bs = vec3(hlf*.95);\n// random hash - in a steady state\nfloat u_hash = 0.12482938;\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234); }\n\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\nfloat cap(vec3 p,float r,float h){\n    vec2 d = abs(vec2(length(p.xy),p.z))-vec2(h,r);\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n \nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nvec2 map(vec3 p){\n    vec2 res = vec2(1e5,0.);\n    p.yz*=flip;\n    vec3 q = p;\n\n    vec2 id = floor((q.xz + hlf)/size)-grid;\n\n    q.xz = q.xz-size*clamp(round(q.xz/size),-grid,grid);\n    vec3 fq = q;\n\n    float ht = .75+.75*sin(p.x*.3+T*.8);\n    q.y-=ht;\n    float hs = hash21(id+u_hash);\n    if(hs>.5) q.z*=-1.;\n\n    vec2 d2 = vec2(length(q.xz-hlf), length(q.xz+hlf));\n    vec2 gx = d2.x<d2.y ? vec2(q.xz-hlf) : vec2(q.xz+hlf);\n    vec3 tq = vec3(gx.x,q.y,gx.y);\n\n    float xhs = fract(2.*hs+id.y);\n    float rhs = fract(hs+id.x);\n    float trh = 1e5;\n    if(rhs>.9){\n        trh = length(vec3(abs(q.x),q.yz)-vec3(hlf,.25,0))-thick;\n        trh = min(length(vec3(q.xy,abs(q.z))-vec3(0,.25,hlf))-thick,trh);\n    }else if(rhs>.7){\n        //if(fract(xhs+id.x)>.75) q.zx*=rot(1.5707);\n        float qy = .15+.15*sin((q.z+.5)*size);\n        float qx = .15+.15*sin((q.x+.5)*size);\n        trh = cap(q-vec3(0,.25+qy,0),hlf,thick);\n        trh = min(cap(q.zyx-vec3(0,.25-qx,0),hlf,thick),trh);\n    } else{\n        trh = trs(tq-vec3(0,.25,0),vec2(hlf,thick));\n\n    }\n    \n    float brh=trh;\n    trh=max(abs(trh)-.075,-trh);\n    trh=max(trh,box(q,bs));\n\n    if(trh<res.x ) {\n        float mt = xhs>.725?5.:xhs>.61?4.:xhs>.25?2.:3.;\n        gtile.xyz = vec3(id,1.);\n        gtile.w=mt;\n        res = vec2(trh,mt);\n        hit = tq;\n    } \n    \n    float bls = cap(vec3(q.xy,abs(q.z))-vec3(0,.25,hlf),thick*.4,thick*1.1);\n    bls = min(cap(vec3(q.zy,abs(q.x))-vec3(0,.25,hlf),thick*.4,thick*1.1),bls);\n    \n    float crt = cap(vec3(q.xy,abs(q.z))-vec3(0,.25,hlf),thick*.34,thick*1.45);  \n    crt = min(cap(vec3(q.zy,abs(q.x))-vec3(0,.25,hlf),thick*.34,thick*1.45),crt);\n    \n    bls=max(crt,-bls);\n    \n    if(bls<res.x) {\n       res = vec2(bls,1.);\n       hit = q;\n    } \n    \n    float flr = box(fq+vec3(0,2,0),vec3(bs.x,.05,bs.xy));\n    flr=max(flr,-brh);\n    if(flr<res.x) {\n       res = vec2(flr,7.);\n       gtile.xyz = vec3(id,0.);\n       gtile.w=6.;\n       hit = fq;\n    } \n    \n    return res;\n}\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nfloat stripes(vec3 p){\n    vec2 uv = p.xz;\n    uv*=rot(.785);\n    vec2 ff = floor(uv);\n    float f = clamp(mod(ff.x,2.)*1.-.5,0.,1.);\n    float h = mix(1.,.0,f);\n    return h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    uv = floor(uv*(216.*R.x/R.y))/(126.*R.x/R.y);\n\n    u_hash+=floor(T*.3);\n    vec3 ro = vec3(0, -1.5, 12.5);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    // mouse //\n    float x = M.z < 0. || M.xy==vec2(0) ? 0.0 : (M.y/R.y*2.-1.)*PI;\n    float y = M.z > 0. ? (M.x/R.x * 2. - 1.) * PI : T*.1;\n    mat2 rx =rot(-.65);\n    mat2 ry =rot(y);\n    flip=rot(x);\n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C = vec3(.0);\n    float m = 0.;\n    float d = 0.;\n    vec3 p = ro;\n    \n    for(int i=0;i<128;i++)\n    {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<32? ray.x*.75: ray.x *.95;\n        m  = ray.y;\n    } \n\n    \n    float alpha = 1.;\n    if(d<MAX_DIST)\n    {\n    \n        hitPoint = hit;\n        alpha *=1e-5;\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(0,15,-5.);\n        vec3 l = normalize(lpos);\n        float spec = pow(max(dot(reflect(l, n), rd ), .1), 32.)*.75;\n        float shdw = 1.0;\n        float t=.001;\n        for( int i =1; i<20; i++ ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 24.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n\n        vec3 h = vec3(.0);\n        float diff = clamp(dot(n,l),0. , 1.);\n        if(m==1.) {h=vec3(.43);}\n        if(m==2.) {h=colorB;}\n        if(m==3.) {h=colorC;}\n        if(m==4.) {h=colorA;}\n        if(m==5.) {h=vec3(.075);}\n        if(m==7.) {h=mix(colorB*.3,colorB*.1,stripes(hitPoint));}\n        \n        h = mix(h,h*shdw,.15);\n        if(diff<.3) h=clamp(h*.5,vec3(0),vec3(1));\n        if(diff<.4&&(mod(F.x,4.)==mod(F.y,4.))) h*=.3;\n        if(shdw<.5&&(mod(F.x,2.)==mod(F.y,2.))) h*=.2;\n        if(spec>.25) h=clamp(h*1.15,vec3(0),vec3(1));\n        if(spec>.5&&(mod(F.x,2.)==mod(F.y,2.))) h=clamp(h*1.5,vec3(0),vec3(1));\n        C = h;\n    }\n    float mask = smoothstep(.1,.7,length(uv)-.5);\n    vec3 clr = mix(colorA,colorA*.05 ,mask );\n    \n    uv*=rot(.785);\n    vec2 ff = floor(uv*8.);\n    float f = clamp(mod(ff.x,2.)*1.-.5,0.,1.);\n    clr = mix(clr*.5,clr*.2,f);\n    C = mix(C,clr,alpha);\n    if(C.r<.2&&C.g<.2&&C.b<.2) C = hash21(uv)>.5 ? C+.005 : C;\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcSWn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[838, 838, 856, 856, 900], [901, 901, 922, 922, 978], [980, 980, 1005, 1005, 1090], [1091, 1091, 1125, 1125, 1230], [1233, 1233, 1259, 1259, 1328], [1330, 1330, 1347, 1347, 3323], [3324, 3399, 3429, 3429, 3668], [3670, 3670, 3692, 3692, 3847], [3849, 3849, 3890, 3890, 6218]], "test": "untested"}
{"id": "st3XRS", "name": "[TDF21]Footwear concept demo", "author": "yasuo", "description": "TDF2021", "tags": ["tdf2021"], "likes": 6, "viewed": 193, "published": 3, "date": "1639308310", "time_retrieved": "2024-07-30T18:42:38.746257", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Slice(p,a) dot(p,vec2(cos(a),sin(a)))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define MATERIAL_UPPER 0\n#define MATERIAL_OUTSOLE 1\n#define MATERIAL_EFFECT 2\n#define SCENE0 3.0\n#define SCENE1 10.0\n#define SCENE2 20.0\n#define SCENE3 30.0\n#define SCENE_LENGTH 38.0\n\nfloat getSceneTime(){\n    return mod(iTime,SCENE_LENGTH);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n    const vec3 s = vec3(27, 111, 57);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nvec2 combine(vec2 val1, vec2 val2  ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\nvec2 smoothCombine(vec2 val1, vec2 val2, float k ){\n    if(val1.x < val2.x){\n        val1.x = opSmoothUnion(val1.x,val2.x,k);\n        return val1;\n    }\n    val2.x = opSmoothUnion(val1.x,val2.x,k);\n    return val2;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdSimpleCylinder(vec3 p, float r, float h){\n    float d = length(p.xz)-r;\n    d = max(abs(p.y)-h,d);\n    return d;\n}\n\n// =========== 3D Model ===========\n\nfloat baseOutsole(vec3 p, float h){\n    vec3 prevP = p;\n    \n    p.xz*=Rot(radians(17.0));\n    p.z*=0.4;\n    p.x*=0.57;\n    p.x+=0.03;\n    p.z-=0.07;\n    \n    float d =sdSimpleCylinder(p,0.1,h);\n    \n    p = prevP;\n    p.xy*=Rot(radians(90.0));\n    p.y*=1.5;\n    p.z*=1.2;\n    float d2 = sdCappedCylinder(p-vec3(0.0,0.0,-0.25),h,0.2);\n    d = opSmoothUnion(d, d2,0.13);\n    \n    p = prevP;\n    d = max(abs(p.y)-h,d);\n    \n    return (d)*0.6;\n}\n\nfloat outsole(vec3 p){\n    p.z*=0.9;\n    vec3 prevP = p;\n    \n    float d = baseOutsole(p-vec3(0.0,0.02,0.),0.06);\n    \n    // wave traction pattern\n    float scene = getSceneTime();\n    if(scene<SCENE0){\n        p.z+=scene*0.1;\n    }\n    p.z+=sin(p.x*80.0)*0.01;\n    p.z = mod(p.z,0.09)-0.045;\n    float d2 = sdBox(p,vec3(0.2,0.03,0.03));\n    \n\n    d = max(d,d2);\n    p = prevP;\n    d2 = baseOutsole(p-vec3(0.0,0.025,0.0),0.035);\n    d = min(d,d2);\n    \n    p = prevP;\n    float a  = radians(4.0);\n    p.y-=0.06;\n    float mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    p = prevP;\n    a  = radians(-8.0);\n    p.y+=0.07;\n    mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    \n    p = prevP;\n    a  = radians(10.0);\n    p.y+=0.08;\n    mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    \n    p = prevP;\n    p.xz*=0.95;\n    p.y+=sin(p.x*50.0)*0.01;\n    d2 = baseOutsole(p-vec3(0.0,0.017,0.),0.002);\n    d = min(d,d2);\n\n    return d;\n}\n\nfloat upperBase(vec3 p){\n    p.z*=0.9;\n    vec3 prevP2 = p;\n    p.z+=sin(p.x*300.0)*0.005;\n    p.x+=cos(p.y*70.0)*0.005;\n    vec3 prevP = p;\n\n    //p.x*=1.;\n    p.z*=0.8;\n    \n    float d =sdCappedCone(p-vec3(0.0,0.18,-0.15),0.13,0.15,0.06);\n    \n    p = prevP;\n    p.xz*=Rot(radians(15.0));\n    p.yz*=Rot(radians(-6.0));\n    p.x*=1.2;\n    p.z*=0.8;\n    \n    float d2 = sdEllipsoid(p-vec3(-0.05,0.1,0.14),vec3(0.2,0.08,0.2));\n    d = opSmoothUnion(d,d2,0.1);//0.1\n    \n    p = prevP;\n    p.xz*=Rot(radians(0.0));\n    p.x*=1.1;\n    p.z*=0.8;\n    p.yz*=Rot(radians(-35.0));\n\n    d2 = sdEllipsoid(p-vec3(0.0,0.21,-0.1),vec3(0.1,0.04,0.15));\n\n    d = opSmoothUnion(d,d2,0.17);//0.15\n    \n    p = prevP2;\n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(18.0));\n    p.y*=1.5;\n    p.z*=1.0;\n    d2 = sdCappedCylinder(p-vec3(-0.1,0.0,-0.2),0.001,0.2);\n    d = opSmoothUnion(d, d2,0.07);\n    \n    p = prevP2;\n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(15.0));\n    p.y*=1.3;\n    p.z*=0.99;\n    d2 = sdCappedCylinder(p-vec3(-0.04,0.0,-0.22),0.001,0.2);\n    d = opSmoothUnion(d, d2,0.07);\n    \n    return d;\n}\n\nfloat upper(vec3 p){\n    vec3 prevP = p;\n    float d = upperBase(p);\n    p.x*=1.5;\n    p.y*=1.1;\n    p.z*=1.12;\n    \n    float d2 = upperBase(p-vec3(0.0,0.02,0.0));\n    d = max(-d2,d);\n    \n    p = prevP;\n    \n    p.x*=1.6;\n    p.z*=0.7;\n    \n    d2 =sdCappedCone(p-vec3(-0.01,0.25,-0.1),0.14,0.14,0.09);\n    d = max(-d2,d);\n    \n    p = prevP;\n    float a  = radians(8.0);\n    p.y-=0.31;\n    float mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    p = prevP;\n    p.yz*=Rot(radians(-15.0));\n    p.x*=1.2;\n    p.y*=1.1;\n    p.z*=0.65;\n    d2 = sdTorus(p-vec3(-0.005,0.31,-0.145),vec2(0.1,0.02));\n    \n    d = opSmoothUnion(d,d2,0.05);\n    \n    p = prevP;\n    p.x*=1.4;\n    p.z*=0.75;\n    d2 =sdSimpleCylinder(p-vec3(-0.005,0.35,-0.115),0.1,0.2);\n    d = max(-d2,d);\n    \n    return d*0.8;\n}\n\nvec2 GetDist(vec3 p) {\n    //p+=noise3d(p*600.0)*0.0002;\n    vec3 prevP = p;\n    \n    p.y+=0.125;\n   \n    float d = outsole(p);\n    float d2 = upper(p-vec3(0.0,0.0,0.0));\n    \n    vec2 model = vec2(d2,MATERIAL_UPPER);\n    vec2 model2 = vec2(d,MATERIAL_OUTSOLE);\n    \n    float scene = getSceneTime();\n    if(scene>=SCENE3){\n        p.xz*=Rot(radians(iTime*50.0));\n        d = sdTorus(p,vec2(0.45,0.005));\n        d = max(-(abs(p.x)-0.455),d);\n\n        p = prevP;\n        p.y+=0.125;\n        p.xy*=Rot(radians((iTime*-50.0)));\n        p.yz*=Rot(radians(90.0));\n        d2 = sdTorus(p,vec2(0.45,0.005));\n        d2 = max(-(abs(p.x)-0.455),d2);\n\n        vec2 model3 = vec2(min(d,d2),MATERIAL_EFFECT);\n        return combine(smoothCombine(model,model2,0.03),model3);\n    }\n    return smoothCombine(model,model2,0.03);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<3; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.1)*diff*occ;\n    diffCol += col*vec3(1.0,0.95,1.0)*skyDiff*occ;\n    diffCol += col*vec3(1.0,0.9,0.85)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 evaTex(vec2 uv, vec3 col){\n    uv.y+=iTime*0.1;\n    vec2 prevUV = uv;\n    uv*=30.0;\n    \n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    \n    float n = Hash21(id);\n    gv.y*=n;\n    \n    gv.x+=cos(uv.y*5.0)*0.2+sin(uv.y*2.0)*0.05;\n    float d = length(gv)-0.5*abs(n);\n    if(n<0.5){\n        col = mix(col,vec3(1.3),S(d,0.0));\n    }\n    \n    return col;\n}\n\nvec3 upperTex(vec2 uv, vec3 col){\n    vec2 prevUV = uv;\n    uv.y*=0.3;\n    uv.x*=1.5;\n    uv.x+=cos(uv.y*100.0)*0.01+sin(uv.y*80.0)*0.02;\n    float d = -uv.x+0.13;\n    col = mix(col,vec3(1.5,1.4,1.4),S(d,0.0));\n\n    return col;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL_UPPER){\n        col = diffuseMaterial(n,rd,p,vec3(0.7,0.6,0.6)*evaTex(p.xz+p.yy,col)*upperTex(p.yz,col));\n    }\n     if(mat == MATERIAL_OUTSOLE){\n        col = diffuseMaterial(n,rd,p,vec3(0.9));\n    }\n    if(mat == MATERIAL_EFFECT){\n        col = diffuseMaterial(n,rd,p,vec3(1.2,1.2,1.2));\n    }\n    return col;\n}\n\n// =========== UI part ===========\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c=sin/cos of aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat dTri(vec2 p, vec2 s){\n    p*=-1.0;\n    return Tri(p,s,radians(30.0));\n}\n\nfloat animationMask(vec2 p, float speed){\n    float t = mod(iTime*speed,360.0);\n    float rad = radians(t);\n    float d = sdPie(p,vec2(sin(rad),cos(rad)),0.15);\n    return d;\n}\n\nfloat charT(vec2 p, int animate, float speed) {\n    vec2 prevP = p;\n    float w = 0.03;\n    float size = 0.1;\n    float d = sdBox(p,vec2(size));\n    \n    float mask = sdBox(p-vec2(0.031,-0.031),vec2(0.071));\n    d = max(-mask,d);\n    \n    p*=Rot(radians(45.0));\n    p.x+=0.075;\n    d = max(-p.x,d);\n    \n    p = prevP;\n    p*=Rot(radians(45.0));\n    d = max(p.x,d);\n    \n    p = prevP;\n    if(animate == 1){\n        mask = animationMask(p,speed);\n        d = max(-mask,d);\n    }\n    return d;\n}\n\nfloat charD(vec2 p, int animate, float speed) {\n    vec2 prevP = p;\n    float w = 0.03;\n    float size = 0.1;\n    float d = sdRoundedBox(p,vec2(size),vec4(0.05,0.05,0,0));\n    float d2 = sdRoundedBox(p,vec2(0.04,0.04),vec4(0.025,0.025,0,0));\n    d = max(-d2,d);\n    p*=Rot(radians(45.0));\n    p.x+=0.04;\n    d = max(-p.x,d);\n    \n    p = prevP;\n    \n    if(animate == 1){\n        float mask = animationMask(p,speed);\n        d = max(-mask,d);\n    }\n    \n    return d;\n}\n\nfloat charF(vec2 p, int animate, float speed) {\n    vec2 prevP = p;\n    float size = 0.1;\n    float d = sdBox(p,vec2(size));\n    p*=Rot(radians(45.0));\n    d = max(p.x,d);\n    p = prevP;\n    float mask = sdBox(p-vec2(0.06,0.025),vec2(0.1,0.015));\n    d = max(-mask,d);\n    \n    if(animate == 1){\n        mask = animationMask(p,speed);\n        d = max(-mask,d);\n    }\n    return d;\n}\n\nfloat drawTDFLogo(vec2 p, int animate, float speed){\n    float d = charT(p-vec2(-0.13,0.0),animate,speed);\n    float d2 = charD(p-vec2(-0.05,0.0),animate,speed);\n    d = min(d,d2);\n    d2 = charF(p-vec2(0.17,0.0),animate,speed);\n    \n    return min(d,d2);\n}\n\nfloat drawTDFLogoPararell(vec2 p, int animate, float speed){\n    float d = charT(p-vec2(-0.13,0.0),animate,speed);\n    float d2 = charD(p-vec2(-0.05,0.0),animate,speed*0.5);\n    d = min(d,d2);\n    d2 = charF(p-vec2(0.17,0.0),animate,speed*0.75);\n    \n    return min(d,d2);\n}\n\nvec3 drawHUD(vec2 p, vec3 col){\n    vec2 prevP = p;\n    \n    p*=Rot(radians(-iTime*10.0));\n    p = DF(p,16.0);\n    p = abs(p);\n    p -= vec2(0.215);\n    p*=Rot(radians(45.0));\n    float d = B(p,vec2(0.001,0.005));\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    p = prevP;\n    p*=Rot(radians(-iTime*10.0));\n    p = DF(p,4.0);\n    p = abs(p);\n    p -= vec2(0.21);\n    p*=Rot(radians(45.0));    \n    d = B(p,vec2(0.001,0.015));\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    p = prevP;\n    p*=Rot(radians(iTime*20.0));\n    d = abs(length(p)-0.32)-0.005;\n    d = max(-B(p,vec2(1.0,0.2)),d);\n\n    p = mod(p,0.005)-0.0025;\n    d = max(-B(p,vec2(0.003)),d);\n\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    p = prevP;\n    p*=Rot(radians(sin(iTime*1.0)*45.0));\n    p = DF(p,1.0);\n    p = abs(p);\n    p -= vec2(0.24);\n    p*=Rot(radians(45.0));   \n    d = dTri(p,vec2(0.015));\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    return col;\n}\n\nvec3 drawUI(vec2 p, vec3 col){\n    vec2 prevP = p;\n    \n    p*=3.5;\n    p = abs(p);\n    p.x -=2.7;\n    p.y -=1.3;\n    p*=Rot(radians(-90.0));\n    \n    float d = drawTDFLogo(p,1,0.0);\n    col = mix(col,vec3(1.0),S(d,0.0));\n    p = prevP;\n    p*=0.8;\n    \n    float scene = getSceneTime();\n    if((scene>=SCENE0 && scene<SCENE1)||(scene>=SCENE2 && scene<SCENE3)){\n        col = drawHUD(p,col);\n    }\n    return col;\n}\n\nvec3 startSceneBg(vec2 p, vec3 col){\n    p = mod(p,0.2)-0.1;\n    float d = B(p,vec2(0.00001,0.01));\n    float d2 = B(p,vec2(0.01,0.00001));\n    d = min(d,d2);\n    col = mix(col,vec3(0.9,0.9,0.1)*0.5,S(d,0.0));\n    \n    return col;\n}\n\nvec3 endSceneBg(vec2 p, vec3 col){\n    vec2 gv = fract(p)-0.5;\n    vec2 id = floor(p);\n    \n    float n = Hash21(id);\n\n    gv*=0.3;\n    float d = charT(gv,1,100.0);    \n    if(n>=0.4 && n<0.7){\n        d = charD(gv,1,120.0*n);\n    } else if(n>=0.7){\n        d = charF(gv,1,140.0*n);\n    }\n    \n    col = mix(col,vec3(0.9,0.9,0.1),S(d,0.0));\n    \n    return col;\n}\n\nvec3 postEffect(vec2 p, vec3 col){\n    p*=8.0;\n\n    float y = fract(p.y)-0.5;\n    vec2 gv = fract(p)-0.5;\n    vec2 id = floor(p);\n    float n = Hash21(id);\n    \n    p.y = y;\n    \n    float d = B(p,vec2(cos(iTime*n*20.0)*100.0*n*n,sin(iTime*n*20.0)*100.0*n*n));\n    col = mix(col,vec3(0.9,0.9,0.1)*0.75,S(d,0.0));\n    return col;\n}\n\nvec3 logoAnimationBg(vec2 p, vec3 col){\n    float brightness = 0.2;\n    vec2 prevP = p;\n    p.x+=iTime*0.1;\n    p.x = mod(p.x,0.54)-0.27;\n    p.y = mod(p.y,0.45)-0.225;\n    float d = drawTDFLogoPararell(p,1,100.0);\n    col = mix(col,vec3(0.9,0.9,0.1)*brightness,S(d,0.0));\n    p = prevP;\n    p.x-=iTime*0.1;\n    p.y+=0.225;\n    p.x = mod(p.x,0.54)-0.27;\n    p.y = mod(p.y,0.45)-0.225;\n    d = drawTDFLogoPararell(p,1,120.0);\n    col = mix(col,vec3(0.9,0.9,0.1)*brightness,S(d,0.0));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    \n    float scene = getSceneTime();\n    \n    if(scene>=SCENE1 && scene<SCENE2){\n        uv.y+=scene*0.1;\n        uv*=2.4;\n        uv = fract(uv)-0.5;\n    } else if(scene>=SCENE3){\n        uv.y+=scene*0.1;\n        uv*=1.4;\n        uv.y = fract(uv.y)-0.5;\n    }\n    \n    vec2 m = iMouse.xy/iResolution.xy -.3;\n    \n    float cz = 0.85;\n    if(scene>=SCENE0 && scene<=SCENE1){\n        cz = 1.;\n    }  else if(scene>=SCENE1 && scene<=SCENE2){\n        cz = 1.2;\n    } else if(scene>=SCENE2){\n        cz = 1.0;\n    }\n    \n    vec3 ro = vec3(0, 0, cz);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    if(scene<SCENE0){\n        ro.yz *= Rot(radians(90.0));\n        ro.xz *= Rot(radians(-90.0));\n    } else {\n        if(scene>=SCENE1 && scene<SCENE2){\n            ro.yz *= Rot(radians(-35.0));\n            ro.xz *= Rot(radians(-5.0+scene*20.0));\n        } else if(scene>=SCENE2 && scene<SCENE3){\n            ro.yz *= Rot(radians(30.0));\n            ro.xz *= Rot(radians(-5.0+scene*20.0));\n        } else if(scene>=SCENE3){\n           \n            ro.xz *= Rot(radians(-25.0+scene*20.0));\n            ro.yz *= Rot(radians(85.0));\n           \n        } else {\n            ro.xz *= Rot(radians(-5.0+scene*20.0));\n        }\n       \n    }\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        //col *= exp( -0.038*d.x*d.x*d.x );//fog\n    } else {\n        //col = upperTex(uv,col);\n        uv = prevUV;\n        \n        col = vec3(0.0);\n        \n        uv.y+=scene*0.1;\n        uv*=0.5;\n        \n        if(scene<SCENE0){\n            uv = prevUV;\n            uv.y+=scene*0.1;\n            col = startSceneBg(uv,col);\n        }\n\n        if(scene>=SCENE0 && scene<SCENE1){\n            uv.y = mod(uv.y,0.4)-0.2;\n            float ld = drawTDFLogo(uv-vec2(0.0,0.08),0,0.0);\n            col = mix(col,vec3(0.9,0.9,0.1)*0.25,S(ld,0.0));\n            ld = drawTDFLogo(uv,0,0.0);\n            col = mix(col,vec3(0.9,0.9,0.1)*0.5,S(ld,0.0));\n            ld = drawTDFLogo(uv-vec2(0.0,-0.08),0,0.0);\n            col = mix(col,vec3(0.9,0.9,0.1),S(ld,0.0));\n        }\n        \n        uv = prevUV;\n        if(scene>=SCENE2 && scene<SCENE3){\n                uv.xy *= Rot(radians(sin(scene*.3)*20.0));\n                float d2 = abs(uv.y);\n                float k = 0.5 / d2;\n                uv = uv * k + vec2(0, k);\n                uv-=iTime*0.5;\n                col = endSceneBg(uv,col);\n                col*=d2*2.0;\n        }\n\n        if(scene>=SCENE3){\n            col = logoAnimationBg(uv,col);\n        }\n    }\n    \n    // UI\n    //float ld = drawTDFLogo(uv,1,60.0);\n    if(scene<SCENE0){\n        uv = prevUV;\n        float ld = drawTDFLogo(uv,0,0.0);\n        col = mix(col,vec3(0.9,0.9,0.1),S(ld,0.0));\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    uv = prevUV;\n    col = drawUI(uv,col);\n    \n    if(scene>=SCENE0-0.2 && scene<SCENE0+0.1){\n        col = postEffect(uv,col);\n    } else if(scene>=SCENE1-0.2 && scene<SCENE1+0.1){\n        col = postEffect(uv,col);\n    } else if(scene>=SCENE2-0.2 && scene<SCENE2+0.1){\n        col = postEffect(uv,col);\n    } else if(scene>=SCENE3-0.1 && scene<SCENE3+0.1){\n        col = postEffect(uv,col);\n    } else if(scene>SCENE_LENGTH-0.2 || scene<0.1){\n        col = postEffect(uv,col);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3XRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[823, 823, 844, 844, 882], [884, 884, 906, 906, 996], [998, 1047, 1072, 1072, 1091], [1092, 1092, 1117, 1117, 1136], [1137, 1137, 1189, 1189, 1289], [1291, 1403, 1428, 1428, 1773], [1775, 1775, 1812, 1812, 1854], [1856, 1856, 1907, 1907, 2072], [2074, 2123, 2156, 2156, 2221], [2223, 2272, 2324, 2324, 2431], [2433, 2482, 2513, 2513, 2600], [2602, 2651, 2688, 2688, 2771], [2773, 2822, 2881, 2881, 3194], [3196, 3196, 3245, 3245, 3318], [3357, 3357, 3392, 3392, 3800], [3802, 3802, 3824, 3824, 4781], [4783, 4783, 4807, 4807, 5893], [5895, 5895, 5915, 5915, 6702], [6704, 6704, 6726, 6760, 7519], [7521, 7521, 7566, 7566, 7835], [7837, 7837, 7861, 7861, 8062], [8064, 8064, 8106, 8106, 8301], [8303, 8344, 8393, 8393, 8684], [8686, 8686, 8743, 8743, 9290], [9292, 9292, 9323, 9323, 9660], [9662, 9662, 9695, 9695, 9891], [9893, 9893, 9952, 9952, 10289], [10327, 10378, 10415, 10415, 10495], [10497, 10548, 10603, 10603, 10760], [10762, 10813, 10862, 10862, 11030], [11032, 11032, 11059, 11059, 11109], [11111, 11111, 11152, 11152, 11287], [11289, 11289, 11336, 11336, 11783], [11785, 11785, 11832, 11832, 12254], [12256, 12256, 12303, 12303, 12638], [12640, 12640, 12692, 12692, 12897], [12899, 12899, 12959, 12959, 13173], [13175, 13175, 13206, 13206, 14106], [14108, 14108, 14138, 14138, 14523], [14525, 14525, 14561, 14561, 14757], [14759, 14759, 14793, 14793, 15122], [15124, 15124, 15158, 15158, 15454], [15456, 15456, 15495, 15495, 15961], [15963, 15963, 16020, 16020, 19669]], "test": "untested"}
{"id": "7tcSRS", "name": "Infy (rainbow)", "author": "avin", "description": "rgb spinner like animation", "tags": ["meta", "rgb", "rainbow", "hue", "infinity", "spinner", "loader"], "likes": 15, "viewed": 520, "published": 3, "date": "1639307345", "time_retrieved": "2024-07-30T18:42:39.629894", "image_code": "#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{           \n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x; \n          \n    float t = iTime*5.;\n    \n    vec3 rd = vec3(0.);\n    \n    for(float i=0.; i< 30.;i+=.8){\n    \n        float tt = t + sqrt(100. - i)*2.0;        \n        vec2 m = vec2(cos(tt), sin(2. * tt) / 3.5)*.3;\n        \n        float ift = i*.0015;\n        float d = smoothstep(.06 - ift, .00 - ift,  length(uv + m));\n        \n        rd = rd + d * hue(-tt*.33).rgb;       \n    }\n    \n   \n    fragColor = vec4(vec3(rd), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tcSRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 123, 123, 635]], "test": "untested"}
{"id": "Nt3SRB", "name": "Infy (b/w)", "author": "avin", "description": "spinner like animation", "tags": ["meta", "infinity", "spinner", "loader"], "likes": 11, "viewed": 271, "published": 3, "date": "1639300097", "time_retrieved": "2024-07-30T18:42:40.608278", "image_code": "#define BLACK_COL vec3(32,43,51)/255.\n#define WHITE_COL vec3(235,241,245)/255.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;   \n    \n    float c = texture(iChannel0, uv).r;\n    \n    float fc = smoothstep(.2, 0.19, c);\n    \n    vec3 col = mix(BLACK_COL, WHITE_COL, fc);    \n                \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = fragCoord.xy / iResolution.xy;       \n    float pc = texture(iChannel0, ouv).r * 1.15;\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x; \n          \n    float t = iTime*5.;        \n    \n    vec2 mf = vec2(cos(t), sin(2. * t) / 3.5);\n        \n    float d = length(uv + mf*.3);\n    \n    float s = smoothstep(.05, 0.0, d)*10.;\n    \n    fragColor = mix(vec4(s), vec4(pc), .8);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3SRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 137, 137, 380]], "test": "untested"}
{"id": "NlcSRB", "name": "Mandala flowers", "author": "mrange", "description": "CCO: Mandala flowers\nSmoooth kaleidoscope + abstract shape + colors\n", "tags": ["2s", "mandala"], "likes": 72, "viewed": 1238, "published": 3, "date": "1639299234", "time_retrieved": "2024-07-30T18:42:41.718310", "image_code": "// CCO: Mandala flowers\n//  Smoooth kaleidoscope + abstract shape + colors\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define PI_2        (0.5*3.141592654)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 p) {\n  float a = dot (p, vec2 (127.1, 311.7));\n  return fract (sin(a)*43758.5453123);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float logo_radius= 0.25;\nconst float logo_off   = 0.25;\nconst float logo_dx    = 0.5/sqrt(3.0);\nconst float logo_width = 0.1;\n\nfloat rcp(float x) {\n  return 1.0 / x;\n}\n\n//P. Gilcher '21, strange approximation\n// Source found at: https://www.shadertoy.com/view/flSXRV\nfloat fast_atan2(float y, float x) {\n  float cosatan2 = x * rcp(abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r) {\n  const vec3 k = vec3(-sqrt(3.0)*0.5,0.5,sqrt(1.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = 2.0*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  //  Found this somewhere on the interwebs\n  col = clamp(col, 0.0, 1.0);\n  // Gamma correction\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  // Vignetting\n  col*= 0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat stripes(float d) {\n  const float cc = 0.42;\n  d = abs(d)-logo_width*cc;\n  d = abs(d)-logo_width*cc*0.5;\n  return d;\n}\n\nvec4 merge(vec4 s0, vec4 s1) {\n  bool dt = s0.z < s1.z; \n  vec4 b = dt ? s0 : s1;\n  vec4 t = dt ? s1 : s0;\n\n  b.x *= 1.0-exp(-max(80.0*(t.w), 0.0));\n\n  vec4 r = vec4(\n      mix(b.xy, t.xy, t.y)\n    , b.w < t.w ? b.z : t.z \n    , min(b.w, t.w)\n    );\n  \n  return r;\n}\n\nvec4 figure_8(float aa, vec2 p) {\n  vec2  p1 = p-vec2(logo_dx, -logo_off);\n  float d1 = abs(circle(p1, logo_radius));\n  float a1 = fast_atan2(-p1.x, -p1.y);\n  float s1 = stripes(d1);\n  float o1 = d1 - logo_width;\n\n  vec2  p2 = p-vec2(logo_dx, logo_off);\n  float d2 = abs(circle(p2, logo_radius));\n  float a2 = fast_atan2(p2.x, p2.y);  \n  float s2 = stripes(d2);\n  float o2 = d2 - logo_width;\n\n  vec4 c0 = vec4(smoothstep(aa, -aa, s1), smoothstep(aa, -aa, o1), a1, o1);\n  vec4 c1 = vec4(smoothstep(aa, -aa, s2), smoothstep(aa, -aa, o2), a2, o2);\n\n  return merge(c0, c1);\n}\n\nvec4 figure_half_8(float aa, vec2 p) {\n  vec2  p1 = p-vec2(logo_dx, -logo_off);\n  float d1 = abs(circle(p1, logo_radius));\n  float a1 = fast_atan2(-p1.x, -p1.y);\n  float s1 = stripes(d1);\n  float o1 = d1 - logo_width;\n\n  vec4 c0 = vec4(smoothstep(aa, -aa, s1), smoothstep(aa, -aa, o1), a1, o1);\n\n  return c0;\n}\n\nvec2 flipy(vec2 p) {\n  return vec2(p.x, -p.y);\n}\n\nvec4 clogo(vec2 p, float z, out float d) {\n  float iz = 1.0/z;\n  p *= iz;\n  float aa = iz*2.0/RESOLUTION.y;\n  float  n = modPolar(p, 3.0);\n\n  vec4 s0 = figure_8(aa, p);\n  vec4 s1 = figure_half_8(aa, p*ROT(2.0*PI/3.0));\n  vec4 s2 = figure_half_8(aa, flipy(p*ROT(4.0*PI/3.0)));\n  s1.z += -PI;\n  \n  vec4 s = s0;\n  s = merge(s, s1);\n  s = merge(s, s2);\n\n  d = s.w;\n  vec3 hsv = vec3(fract(s.z/PI+TIME*0.5), 0.9, 1.0);\n  return vec4(hsv2rgb(hsv)*s.x, s.y);\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float aa = 2.0/RESOLUTION.y;\n\n  float d;\n  float a = TAU*TIME/300.0;\n  p += 10.0*vec2(sin(a), sin(sqrt(0.5)*a));\n  vec2 hp = p;\n  vec2 np = hextile(hp);\n  float hd = hex(hp.yx, 0.5);\n  hd = abs(hd) - 2.0*aa;\n  vec2 cp = hp;\n  float h = hash(np);\n  float hh = fract(137.0*h);\n  float sm = mix(mix(0.025, 0.25, hh), 0.025, h);\n  float rep = 2.0*floor(mix(8.0, 30.0, h));\n  float cn = smoothKaleidoscope(cp, sm, rep);\n  cp *= ROT(TIME*0.2+TAU*h);\n  \n  vec4 ccol = clogo(cp, 0.6, d);\n  vec3 gcol = hsv2rgb(vec3(h, 0.8, 4.0));\n  vec3 col  = vec3(0.0);\n  col += gcol*exp(-50.0*max(d, 0.0));\n  col = mix(col, vec3(0.2), smoothstep(aa, -aa, hd));\n  col = mix(col, ccol.xyz, ccol.w);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcSRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[292, 352, 372, 372, 455], [609, 609, 631, 631, 777], [1205, 1205, 1225, 1225, 1245], [1247, 1345, 1381, 1381, 1491], [1493, 1493, 1524, 1524, 1550], [1552, 1646, 1674, 1674, 1858], [1860, 1961, 1989, 2088, 2415], [2417, 2503, 2552, 2552, 2954], [2956, 3039, 3075, 3119, 3390], [3392, 3475, 3514, 3514, 3599], [3601, 3689, 3728, 3728, 3757], [3759, 3847, 3877, 3877, 3904], [3906, 3992, 4037, 4037, 4191], [4193, 4281, 4303, 4303, 4347], [4349, 4437, 4458, 4458, 4503], [4505, 4593, 4654, 4654, 4867], [4869, 4869, 4893, 4893, 4992], [4994, 4994, 5024, 5024, 5260], [5262, 5262, 5295, 5295, 5833], [5835, 5835, 5873, 5873, 6145], [6147, 6147, 6167, 6167, 6195], [6197, 6197, 6239, 6239, 6650], [6652, 6652, 6681, 6681, 7374], [7376, 7376, 7431, 7431, 7620]], "test": "untested"}
{"id": "Nl3SRB", "name": "TDF Semi Final Plan ", "author": "sp4ghet", "description": "I'm sad that I couldn't show everyone what I intended to do in time, but hopefully you like it.\nOriginally coded on Bonzomatic, thank you Nerumae for the music! Congrats to phi16 for advancing.", "tags": ["shadershowdown", "tdf", "tokyodemofest"], "likes": 11, "viewed": 308, "published": 3, "date": "1639298629", "time_retrieved": "2024-07-30T18:42:42.470299", "image_code": "#define texPreviousFrame iChannel0\nconst vec3 up = vec3(0,1,0);\n\nvoid chmin(inout vec4 a, vec4 b, float k){\n  float h = max(0., k-abs(a.x-b.x))/k;\n  float x = min(a.x, b.x) - h*h*h*k/6.;\n  vec3 aa = a.x < b.x ? a.yzx : b.yzw;\n  vec3 bb = a.x < b.x ? b.yzx : a.yzw;\n\n  a = vec4(x, mix(aa,bb, h*h*h*k/6.));\n}\n\nfloat box(vec3 p, vec3 b){\n  p = abs(p) - b;\n  return length(max(p,0.)) + min(0., max(p.x, max(p.y, p.z)));\n}\n\nvec4 map(vec3 q){\n  vec4 d = vec4(1000, 0,0,0);\n  vec3 p = q;\n\n  for(int i=0; i<n_part; i++){\n    float sp = length(p - psn[i]) - rad[i];\n    chmin(d, vec4(sp, 1, length(vel[i]), 0.), 3.);\n  }\n\n  float bx = box(p, vec3(12));\n  bx = max(bx, -box(p - vec3(0,0,2), vec3(10)) + .5);\n  chmin(d, vec4(bx, 0,0,0), 0.01);\n  return d;\n}\n\nvec3 normal(vec3 p, vec2 e){\n  return normalize(vec3(\n    map(p + e.xyy).x - map(p - e.xyy).x,\n    map(p + e.yxy).x - map(p - e.yxy).x,\n    map(p + e.yyx).x - map(p - e.yyx).x\n  ));\n}\n\n\n\nfloat shad(vec3 ro, vec3 rd, vec3 sp, float r, float k, float maxt){\n  vec3 oc = ro-sp;\n  float b = dot(oc,rd);\n  float c = dot(oc,oc) - r*r;\n  float h = b*b -c;\n  float d = -r + sqrt(max(0., r*r-h));\n  float t = -b - sqrt(max(0., h));\n  bool hit = (t < 0. || t > maxt);\n  float sh;\n  if(hit){\n      sh =1.;\n  }else{\n      sh = smoothstep(0., 1., k*d/t);\n  }\n  return sh;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 pt = uv - 0.5;\n\tpt /= vec2(iResolution.y / iResolution.x, 1.);\n    vec3 c = vec3(0);\n\n    int seed = int(fragCoord.x + 8000.) * int(fragCoord.y + 7777.) + int(1000. * time);\n\n  for(int i=0; i<n_part; i++){\n    float pu = (float(i)*2. + 0.5) / float(2*n_part);\n    float vu = (float(i)*2. + 1.5) / float(2*n_part);\n    float px = texture(texPreviousFrame, vec2(pu, 1. / 12.)).a\n             + texture(texPreviousFrame, vec2(pu, 3. / 12.)).a / 255.;\n    float py = texture(texPreviousFrame, vec2(pu, 5. / 12.)).a\n             + texture(texPreviousFrame, vec2(pu, 7. / 12.)).a/ 255.;\n    float pz = texture(texPreviousFrame, vec2(pu, 9. / 12.)).a\n             + texture(texPreviousFrame, vec2(pu, 11. / 12.)).a/ 255.;\n    float vx = texture(texPreviousFrame, vec2(vu, 1. / 12.)).a\n             + texture(texPreviousFrame, vec2(vu, 3. / 12.)).a/ 255.;\n    float vy = texture(texPreviousFrame, vec2(vu, 5. / 12.)).a\n             + texture(texPreviousFrame, vec2(vu, 7. / 12.)).a/ 255.;\n    float vz = texture(texPreviousFrame, vec2(vu, 9. / 12.)).a\n             + texture(texPreviousFrame, vec2(vu, 11. / 12.)).a/ 255.;\n\n    psn[i] = vec3(px, py, pz) * pRange - pRange / 2.;\n    vel[i] = vec3(vx, vy, vz) * vRange - vRange / 2.;\n  }\n  \n  vec3 ro = vec3(0,0,30);\n  vec3 rd = normalize(vec3(pt,-1));\n\n  vec3 p = ro;\n  vec4 d;\n  float t=0.;\n  for(int i=0; i<128; i++){\n    p = ro + rd*t;\n    d = map(p);\n    t += d.x;\n    if(abs(d.x) < 0.001 || t > 60.){\n      break;\n    }\n  }\n\n  if(abs(d.x) < 0.001){\n    vec3 n = normal(p, vec2(.01, 0));\n    vec3 al = vec3(.5);\n    vec3 lp = vec3(0,8, 14);\n    vec3 l = normalize(lp-p);\n    float ld = length(lp-p);\n    float li = 30. / pow(ld,2.);\n\n    c = li * al * max(dot(n,l),0.);\n    for(int i=0; i<n_part; i++){\n      c *= shad(p, l, psn[i], rad[i], 15., ld);\n    }\n    c += vec3(.2, .8, .9) * pow(d.z / 15., 3.);\n  }\n\n  c *= (.8 + .4 * rnd(seed));\n  //c += .01 * vec3(a);\n\n  c = pow(c, vec3(.4545));\n  \n  //c = texture(iChannel0, uv).rgb;\n\n  // Output to screen\n  fragColor = vec4(c,0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define texPreviousFrame iChannel0\n\nvoid calcVelo(){\n    for(int i=0; i<n_part; i++) for(int j=0; j<n_part; j++){\n      if(i==j){continue;}\n      float m1 = 1.3333 * rad[i]*rad[i]*rad[i];\n      float m2 = 1.3333 * rad[j]*rad[j]*rad[j];\n      vec3 r = psn[j]-psn[i];\n      vec3 rh = normalize(r);\n      float rl = length(r);\n      vel[i] += 0.05 * m2 * rh / max(.005, pow(rl,2.));\n\n      vec3 b = abs(psn[i]);\n      if(b.x > pRange/2.-1.){\n        vel[i].x = .9 * abs(vel[i].x) * -sign(psn[i].x);\n      }\n\n      if(b.y > pRange/2.-1.){\n        vel[i].y = .9 * abs(vel[i].y) * -sign(psn[i].y);\n      }\n\n      if(b.z > pRange/2.-1.){\n        vel[i].z = .9 * abs(vel[i].z) * -sign(psn[i].z);\n      }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    for(int i=0; i<n_part; i++){\n    float pu = (float(i)*2. + 0.5) / float(2*n_part);\n    float vu = (float(i)*2. + 1.5) / float(2*n_part);\n    float px = texture(texPreviousFrame, vec2(pu, 1. / 12.)).a\n             + texture(texPreviousFrame, vec2(pu, 3. / 12.)).a / 255.;\n    float py = texture(texPreviousFrame, vec2(pu, 5. / 12.)).a\n             + texture(texPreviousFrame, vec2(pu, 7. / 12.)).a/ 255.;\n    float pz = texture(texPreviousFrame, vec2(pu, 9. / 12.)).a\n             + texture(texPreviousFrame, vec2(pu, 11. / 12.)).a/ 255.;\n    float vx = texture(texPreviousFrame, vec2(vu, 1. / 12.)).a\n             + texture(texPreviousFrame, vec2(vu, 3. / 12.)).a/ 255.;\n    float vy = texture(texPreviousFrame, vec2(vu, 5. / 12.)).a\n             + texture(texPreviousFrame, vec2(vu, 7. / 12.)).a/ 255.;\n    float vz = texture(texPreviousFrame, vec2(vu, 9. / 12.)).a\n             + texture(texPreviousFrame, vec2(vu, 11. / 12.)).a/ 255.;\n\n    psn[i] = vec3(px, py, pz) * pRange - pRange / 2.;\n    vel[i] = vec3(vx, vy, vz) * vRange - vRange / 2.;\n  }\n  calcVelo();\n\n    vec2 parts = get_id(uv, vec2(n_part, 3)*2.);\n    int id = int(parts.x / 2.);\n    bool isP = mod(parts.x, 2.) == 0.;\n    int xyz = int(parts.y / 2.);\n    bool isU = mod(parts.y, 2.) == 0.;\n    if(mod(time, 1000.) < 0.1){\n        psn[id] = vec3(rnd(id + 17), rnd(id+5), rnd(id+ 23)) * pRange * .8 - pRange/2.3;\n        vel[id] = vec3(0);\n    }\n    \n    psn[id] += dt * vel[id];\n    vec3 val = isP ? clamp(psn[id] + pRange/2., 0., pRange) / pRange : clamp(vel[id] + vRange/2., 0., vRange) / vRange;\n    val = isU ? floor(val * 255.) / 255. : mod(val, 1. / 255.) * 255.;\n    float a = val[xyz];\n    \n    fragColor = vec4(a);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define time iTime\n#define dt iTimeDelta\n#define get_id(x,n) floor((x) * (n))\n\n\nfloat pRange = 20.;\nfloat vRange = 30.;\nconst int n_part = 5;\nvec3 psn[n_part], vel[n_part];\nfloat rad[n_part] = float[](1., 1.5, 2., 3., 0.5);\n\nfloat rnd(int n){\n  n = (n<<13) ^ n;\n  return 1. - float((n * (n*n*12351 + 45803) + 7082934) & 0x7fffffff) / pow(2.,30.);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3SRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 107, 107, 306], [308, 308, 334, 334, 417], [419, 419, 436, 436, 746], [748, 748, 776, 776, 931], [935, 935, 1003, 1003, 1308]], "test": "untested"}
{"id": "fltXD8", "name": "Colour Studies", "author": "davidar", "description": "Every few seconds, a new palette is generated (using some simple colour harmony principles) and visualised with some randomly-placed shapes. Occasionally it even produces something aesthetically pleasing!", "tags": ["procedural", "color", "palette", "generative", "lab", "colour", "colorspace", "geometric", "colourspace", "harmony", "oklab"], "likes": 12, "viewed": 312, "published": 3, "date": "1639295492", "time_retrieved": "2024-07-30T18:42:43.238247", "image_code": "// 2021 David A Roberts <https://davidar.io>\n\n#define PI 3.14\n#define mx(a,b,v) mix(a, b, smoothstep(-texel, texel, v))\n\n#define U(lo,hi) (float(lo) + (float(hi) - float(lo)) * hash12(vec2(seed, nonce++)))\n#define RC palette[int(U(0,6))]\n#define RB palette[int(U(0,3))]\n#define RA palette[int(U(2,6))]\n\n#define mix22(i) mix(hash22(vec2(seed, -i)), hash22(vec2(seed, -float(i) - 0.5)), t)\n#define mix12(i) mix(hash12(vec2(seed, -i)), hash12(vec2(seed, -float(i) - 0.5)), t)\n\n#define C1 mx(RA, RB, length(uv - mix22(1)) - 0.1-0.4*mix12(2))\n#define C2 mx(RC, RA, length(uv - mix22(3)) - (0.1+0.4*mix12(4))*(0.25+0.5*mix12(6)))\n#define C3 mx(RA, C1, length(uv - mix22(7)) - 0.1-0.4*mix12(8))\n#define C  mx(C2, C3, length(uv - mix22(3)) - 0.1-0.4*mix12(4))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float texel = 1. / iResolution.y;\n    vec2 uv = fragCoord / iResolution.y;\n    uv.x -= (iResolution.x / iResolution.y - 1.) / 2.;\n    \n    float seed = floor(iTime/2.);\n    float t = 0.4 + 0.1 * fract(iTime/2.);\n    \n    float q = 2.*PI*hash12(vec2(seed,1)) - 1.2; // base hue\n    float qo = q + ceil(3. * hash12(vec2(seed,2))) * PI/2.; // accent hue\n    vec2 ab1 = 0.25 * vec2(cos(q), sin(q));\n    vec2 ab1x = 0.2 * vec2(ab1.y, -ab1.x);\n    vec2 ab2 = 0.25 * vec2(cos(qo), sin(qo));\n    \n    vec3 palette[6] = vec3[](\n        // medium base\n        linear_srgb_from_oklab(vec3(0.40 * (hash12(vec2(seed,6))) + 0.10, ab1 * sqrt(hash12(vec2(seed,3))) + (hash12(vec2(seed,11)) * 2. - 1.) * ab1x)),\n        // light base\n        linear_srgb_from_oklab(vec3(0.50 * (hash12(vec2(seed,7))) + 0.50, ab1 * sqrt(hash12(vec2(seed,4))) + (hash12(vec2(seed,12)) * 2. - 1.) * ab1x)),\n        // dark base\n        linear_srgb_from_oklab(vec3(0.15 * (hash12(vec2(seed,12))) + 0.10, ab1 * sqrt(hash12(vec2(seed,5))) + (hash12(vec2(seed,13)) * 2. - 1.) * ab1x)),\n        // off-white\n        linear_srgb_from_oklab(vec3(0.95, ab1/9.)),\n        // mix of base and accent\n        linear_srgb_from_oklab(vec3(0.50 * (hash12(vec2(seed,10))) + 0.50, mix(ab1, ab2, 0.33))),\n        // accent\n        linear_srgb_from_oklab(vec3(0.50 + 0.30 * (hash12(vec2(seed,11))), ab2)));\n    \n    int nonce = 20;\n\n    float x1 = mix(U(0.5,1.5), U(0.5,1.5), t);\n    float x0 = mix(U(0.1,x1-0.1), U(0.1,x1-0.1), t);\n    float x2 = mix(U(x1+0.1,1.9), U(x1+0.1,1.9), t);\n    float y1 = mix(U(-0.5,0.5), U(-0.5,0.5), t);\n    float y0 = mix(U(-0.9,y1-0.1), U(-0.9,y1-0.1), t);\n    float y2 = mix(U(y1+0.1,0.9), U(y1+0.1,0.9), t);\n\n    vec3 col = mx(\n        mx(\n            mx(\n                mx(C, C, uv.x - uv.y - y0),\n                mx(C, C, uv.x - uv.y - y0),\n                uv.x - uv.y - y1),\n            mx(\n                mx(C, C, uv.x - uv.y - y2),\n                mx(C, C, uv.x - uv.y - y2),\n                uv.x - uv.y - y1),\n            uv.x + uv.y - x0),\n        mx(\n            mx(\n                mx(C, C, uv.x - uv.y - y0),\n                mx(C, C, uv.x - uv.y - y0),\n                uv.x - uv.y - y1),\n            mx(\n                mx(C, C, uv.x - uv.y - y2),\n                mx(C, C, uv.x - uv.y - y2),\n                uv.x - uv.y - y1),\n            uv.x + uv.y - x2),\n        uv.x + uv.y - x1);\n\n    fragColor = vec4(srgb_from_linear_srgb(col), 1);\n}", "image_inputs": [], "common_code": "// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////\n//\n// Visualizing Bjrn Ottosson's \"oklab\" colorspace\n//\n// shadertoy implementation by mattz\n// https://www.shadertoy.com/view/WtccD7\n//\n// license CC0 (public domain)\n// https://creativecommons.org/share-your-work/public-domain/cc0/\n//\n//////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////\n// sRGB color transform and inverse from \n// https://bottosson.github.io/posts/colorwrong/#what-can-we-do%3F\n\nvec3 srgb_from_linear_srgb(vec3 x) {\n\n    vec3 xlo = 12.92*x;\n    vec3 xhi = 1.055 * pow(x, vec3(0.4166666666666667)) - 0.055;\n    \n    return mix(xlo, xhi, step(vec3(0.0031308), x));\n\n}\n\nvec3 linear_srgb_from_srgb(vec3 x) {\n\n    vec3 xlo = x / 12.92;\n    vec3 xhi = pow((x + 0.055)/(1.055), vec3(2.4));\n    \n    return mix(xlo, xhi, step(vec3(0.04045), x));\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// oklab transform and inverse from\n// https://bottosson.github.io/posts/oklab/\n\n\nconst mat3 fwdA = mat3(1.0, 1.0, 1.0,\n                       0.3963377774, -0.1055613458, -0.0894841775,\n                       0.2158037573, -0.0638541728, -1.2914855480);\n                       \nconst mat3 fwdB = mat3(4.0767245293, -1.2681437731, -0.0041119885,\n                       -3.3072168827, 2.6093323231, -0.7034763098,\n                       0.2307590544, -0.3411344290,  1.7068625689);\n\nconst mat3 invB = mat3(0.4121656120, 0.2118591070, 0.0883097947,\n                       0.5362752080, 0.6807189584, 0.2818474174,\n                       0.0514575653, 0.1074065790, 0.6302613616);\n                       \nconst mat3 invA = mat3(0.2104542553, 1.9779984951, 0.0259040371,\n                       0.7936177850, -2.4285922050, 0.7827717662,\n                       -0.0040720468, 0.4505937099, -0.8086757660);\n\nvec3 oklab_from_linear_srgb(vec3 c) {\n\n    vec3 lms = invB * c;\n            \n    return invA * (sign(lms)*pow(abs(lms), vec3(0.3333333333333)));\n    \n}\n\nvec3 linear_srgb_from_oklab(vec3 c) {\n\n    vec3 lms = fwdA * c;\n    \n    return fwdB * (lms * lms * lms);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fltXD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "sttSW7", "name": "Jump + Run", "author": "lennyjpg", "description": "Click to run.", "tags": ["circles", "loop", "dots", "white", "black"], "likes": 6, "viewed": 228, "published": 3, "date": "1639278447", "time_retrieved": "2024-07-30T18:42:43.994225", "image_code": "float random (vec2 st) {\n  return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\nvec2 u = 10. * fragCoord / iResolution.y - .05;\nfloat rnd = random(floor(u));\nu = fract(u);\nbool rev = iMouse.z < 0.;\nfloat a = (rev ? 0. : 2.9) - sin(iTime * 4.0 + rnd*5.5)*1.8;\nvec2 r = u + vec2(sin(a),cos(a)) * .3;\nfloat c = length(r - .5);\nfloat z = smoothstep(c, c *1.1 , .2);\nfragColor = vec4(rev ? z : 1. - z);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttSW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 94], [95, 95, 151, 151, 471]], "test": "untested"}
{"id": "sldSDM", "name": "- matrix tunnel -", "author": "anahit_movsesyan", "description": ":octopus:", "tags": ["tunnel", "matrix", "letters", "symbols"], "likes": 13, "viewed": 392, "published": 3, "date": "1639259344", "time_retrieved": "2024-07-30T18:42:44.872876", "image_code": "#define t(X, Y) + texture(iChannel0, vec2(X + x, 2. * fract(log(l) + x) Y) + .437).x * l * vec4(\n\nvoid mainImage(out vec4 o, vec2 u) {\n    u += u - (o.xy = iResolution.xy);\n\n    float x = .318 * (atan(u.x, u.y) - iTime / 2.),\n          l = length(u) / o.y;\n          \n    o = t(   , / 16.)              2.5)\n        t(-.9, / 16.) .8, 1.3,  1,   0) * .8\n        t(-.9,      ) .4, 1.3, .9,   0)\n        t(   ,      )               .9) / l;\n    o *= o;\n}\n\n/*\n// 288 chars - by GregRostami (Approximating the o *= o with a / 9.)\n\n#define t(X, Y) + texture(iChannel0, vec2(X + x, 2.* fract(log(L) + x) Y) + .437).x * L * vec4(\n\nvoid mainImage(out vec4 o, vec2 u) {\n    u += u - (o.xy = iResolution.xy);\n\n    float x = .318 * (atan(u.x, u.y) - iTime / 2.),\n          L = length(u) / o.y;\n          \n    o = t(, / 16. - .06) 1.2, 3, 1.2, 0) \n        t( - .9, / 16. - .063) .8, 1.5, 1, 0) * .7\n        t( - .9, -.003) .7, 1.3, .9, 0)\n        t(,) 1) / L / 9.;\n}\n\n\n\n// 292 chars - by GregRostami (with no floats)\n\n#define t(X, Y) + texture(iChannel0, vec2(X + (o.z = .318 * (atan(u.x, u.y) - iTime / 2.)), 2. * fract(log(o.a = length(u) / o.y) + o.z) Y) + .437).x * o.a * vec4(\n\nvoid mainImage(out vec4 o, vec2 u) {\n    u += u - (o.xy = iResolution.xy);\n          \n    o = t(, / 16. - .06) 1.2, 3, 1.2, 0) \n        t( - .9, / 16. - .063) .8, 1.5, 1, 0) * .7\n        t( - .9, -.003) .7, 1.3, .9, 0)\n        t(,) 1) / o.a;\n    o *= o;\n}\n\n\n\n// 290 chars - by FabriceNeyret2\n\n#define t(X,Y) + texture(iChannel0, vec2(X+x, 2.* fract(log(L)+x) Y) + .437).x * L * vec4(\n\nvoid mainImage(out vec4 o, vec2 u) {\n\n    u += u - (o.xy=iResolution.xy);\n\n    float x = .318 * ( atan(u.x, u.y) - iTime / 2.),\n          L = length(u) / o.y;\n          \n    o = t(,  / 16.-.06) 1.2, 3, 1.2,0) \n        t( - .9, /16. - .063) .8, 1.5, 1,0) * .7\n        t( - .9 ,  - .003 ) .7, 1.3, .9,0)\n        t(, ) 1) / L;\n    o *= o;  \n}\n\n\n\n// 308 chars - by FabriceNeyret2\n\n#define t(X,Y) + texture(iChannel0, vec2(X+x, y Y) + .437).x * L * vec3(\n\nvoid mainImage(out vec4 o, vec2 u) {\n\n    u += u - (o.xy=iResolution.xy);\n\n    float x = .318 * ( atan(u.x, u.y) - iTime / 2.),\n          L = length(u) / o.y,\n          y = 2. * fract(log(L) + x) - 1.;\n          \n    o.rgb = pow( t(,  / 16.) 1.2, 3, 1.2) \n                 t( - .9, /16. - .003) .8, 1.5, 1) * .7\n                 t( - .9 ,  - .003 ) .7, 1.3, .9)\n                 t(, ) .9, 1, .9) / L,\n                vec3(2.5));\n}\n\n\n\n// 322 chars - by GregRostami\n\n#define t(X,Y) texture(iChannel0, vec2(X,Y) + .437).x * L * vec3(\n\nvoid mainImage(out vec4 o, vec2 u) {\n    u = (u + u - (o.xy = iResolution.xy)) / o.y;\n    \n    float x = .318 * (atan(u.x, u.y) - iTime / 2.),\n          L = length(u),\n          y = 2. * fract(log(L) + x) - 1.;\n\n    o.rgb = pow( t(x, y / 16.) 1.2, 3, 1.2) + \n                 t(x - .9, (y - .05) / 16.) .8, 1.5, 1) * .7 +\n                 t(x - .9, y - .05 / 16.) .7, 1.3, .9) +\n                 t(x, --y) .9, 1, .9) / L,\n                vec3(2.5));\n}\n\n\n\n// 458 chars - by anahit\n\n#define PI 3.14159\nvec4 t(float x, float y) {\n    return vec4(texture(iChannel0, vec2(x, y) + 7. / 16.).x);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (iResolution.xy - 2. * fragCoord) / iResolution.y;\n    float x = (atan(uv.x, uv.y) - iTime / 2.) / PI;\n    float y = fract(log(length(uv)) + x) * 2. - 1.;\n    float l = length(uv);\n    vec4 col = t(x, y / 16.) * l * vec4(1.2, 3, 1.2, 0) + \n               t(x - 0.9, (y - 0.05) / 16.) * 0.7 * l * vec4(.8, 1.5, 1, 0) +\n               t(x - 0.9, y - 0.05 / 16.) * l * vec4(.7, 1.3, .9, 0) +\n               t(x, y);\n    fragColor = pow(col, vec4(2.5));\n}\n*/\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldSDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7ttXWM", "name": "Metaballs by @johnjelatis", "author": "johnjelatis", "description": "Drag the mouse to interact\nhttps://en.wikipedia.org/wiki/Metaballs", "tags": ["simple", "mouse", "interactive", "metaballs"], "likes": 1, "viewed": 217, "published": 3, "date": "1639254643", "time_retrieved": "2024-07-30T18:42:45.728588", "image_code": "vec3 balls[] = vec3[] (\n    vec3(128, 128, 64),\n    vec3(192, 256, 48),\n    vec3(512, 384, 48),\n    vec3(384, 448, 96)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float val = 0.0;\n\n    for(int ix = 0; balls.length() - ix != 0; ++ ix) {\n        vec3 ball = balls[ix];\n\n        float ball_xd = (fragCoord.x - ball.x) * (fragCoord.x - ball.x);\n        float ball_yd = (fragCoord.y - ball.y) * (fragCoord.y - ball.y);\n        float ball_zd = ball.z * ball.z;\n\n        val += ball_zd / (ball_xd + ball_yd);\n    }\n\n    float mouse_xd = (fragCoord.x - iMouse.x) * (fragCoord.x - iMouse.x);\n    float mouse_yd = (fragCoord.y - iMouse.y) * (fragCoord.y - iMouse.y);\n    float mouse_zd = 72.0 * 72.0;\n\n    val += mouse_zd / (mouse_xd + mouse_yd);\n\n    // float col = 1.0 / val > 1.0 ? 1.0 : 0.0;\n    float col = 1.0 - smoothstep(0.98, 1.02, val); // Thanks, FabriceNeyret2, for mentioning smoothstep\n\n    fragColor = vec4(col,col,col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttXWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 180, 180, 953]], "test": "untested"}
{"id": "ftcSDr", "name": "Raymarched Autostereogram", "author": "personalizedrefrigerator", "description": "Renders an autostereogram  replace get_color with get_debug_color in mainImage to see the source image's normals.", "tags": ["autostereogram"], "likes": 6, "viewed": 371, "published": 3, "date": "1639254226", "time_retrieved": "2024-07-30T18:42:47.868865", "image_code": "/*\n\n    Copyright (c) 2021 H Heino\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/ \n\n#define MAX_MARCH_STEPS 40\n#define MAX_DEPTH 40.3\n#define MIN_STEP 0.001\n#define SMALL 0.001\n\nconst float CAM_Z = -2.0;\nconst float SCREEN_Z = 0.1;\nconst vec3 EYES[2] = vec3[2]( vec3(0.0, 0.0, CAM_Z), vec3(0.1, 0.0, CAM_Z) );\n\nfloat map(vec3 p)\n{\n    float orbiterX = 0.5 * sin(iTime);\n    float orbiterZ = 0.5 * cos(iTime);\n    \n    // Stretch everything  emphasize depth!\n    p = vec3(p.x, p.y, p.z / 3.0);\n    \n    //p = vec3(p.x - floor(p.x/10.0) * 10.0, p.y, p.z);\n    return min(\n        Sphere_SDF(p, Sphere(vec3(0.0, 0.0, -CAM_Z), 0.5)),\n        Sphere_SDF(p, Sphere(vec3(orbiterX, orbiterZ, -CAM_Z), 0.3))\n    );\n}\n\n/// Return the depth of the scene that [ray].\nfloat get_depth(in Ray ray)\n{\n    float dist = 0.0;\n    ray.direction = normalize(ray.direction);\n    \n    // March the ray!\n    for (int i = 0; i < MAX_MARCH_STEPS; i++)\n    {\n        vec3 p = ray.origin + dist * ray.direction;\n        \n        if (abs(p.z) > MAX_DEPTH)\n        {\n            return MAX_DEPTH;\n        }\n        \n        float currentDist = map(p);\n        \n        dist += currentDist;\n        \n        if (abs(currentDist) < MIN_STEP)\n        {\n            return dist;\n        }\n    }\n    \n    return dist;\n}\n\nvec3 get_hit_pt(in Ray ray)\n{\n    float depth = get_depth(ray);\n    return ray.origin + depth * ray.direction;\n}\n\nvec3 proj_to_screen(vec3 pt, vec3 rel_to)\n{\n    vec3 dir = normalize(pt - rel_to);\n    return dir / dir.z * (SCREEN_Z - rel_to.z);\n}\n\nvec3 screen_to_world(vec2 pt)\n{\n    return vec3(pt, SCREEN_Z);\n}\n\n/// Get the color \nvec3 get_color(vec2 p)\n{\n    // Cast right\n    for (int i = 0; i < 60; i++) {\n        vec3 w1 = get_hit_pt(Ray(EYES[1], screen_to_world(p) - EYES[1]));\n        vec2 s1 = proj_to_screen(w1, EYES[0]).xy;\n        \n        if (s1.x > -1.0) {\n            p = s1;\n        } else {\n            break;\n        }\n    }\n    \n    // Change background position with time.\n    vec2 timeDisplacement = vec2(sin(iTime / 32.0), cos(iTime / 24.0));\n    vec3 col = texture(iChannel0, abs(vec2(sin(p.x), p.y) - timeDisplacement) * 8.0).rgb;\n    \n    return col;\n}\n\n\nvec3 getNormal(in vec3 p)\n{\n    float distAt = map(p);\n\n    return normalize(vec3\n    (\n        map(p + vec3(SMALL, 0.0, 0.0)) - distAt,\n        map(p + vec3(0.0, SMALL, 0.0)) - distAt,\n        map(p + vec3(0.0, 0.0, SMALL)) - distAt\n    ));\n}\n\nvec3 get_depth_map(vec2 p)\n{\n    Ray r = Ray(EYES[1], vec3(p, 1.0));\n    float depth = get_depth(r);\n    \n    vec3 world = r.origin + depth * r.direction;\n    return 1.0 - vec3(depth) / MAX_DEPTH;\n}\n\n\nvec3 get_debug_color(vec2 p)\n{\n    Ray r = Ray(EYES[1], vec3(p, 1.0));\n    float depth = get_depth(r);\n    \n    vec3 world = r.origin + depth * r.direction;\n    vec3 norm = getNormal(world);\n    \n    return norm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy/2.0) / iResolution.x;\n    vec3 col = get_color(uv);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\n// Get the distance from a point to a sphere.\nfloat Sphere_SDF(vec3 point, in Sphere sphere)\n{\n    return length(sphere.center - point) - sphere.radius;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcSDr.jpg", "access": "api", "license": "mit", "functions": [[1304, 1304, 1323, 1323, 1703], [1705, 1751, 1780, 1780, 2280], [2282, 2282, 2311, 2311, 2394], [2396, 2396, 2439, 2439, 2528], [2530, 2530, 2561, 2561, 2594], [2596, 2615, 2639, 2657, 3159], [3162, 3162, 3189, 3189, 3405], [3407, 3407, 3435, 3435, 3605], [3608, 3608, 3638, 3638, 3822], [3824, 3824, 3881, 3881, 4008]], "test": "untested"}
{"id": "ftdXD7", "name": "More abstract saturday", "author": "mrange", "description": "More abstract saturday\nInspired by: https://www.logomoose.com/featured/abstract-logo/", "tags": ["2d"], "likes": 21, "viewed": 298, "published": 3, "date": "1639245808", "time_retrieved": "2024-07-30T18:42:48.794391", "image_code": "// CCO: More abstract saturday\n\n// Inspired by: https://www.logomoose.com/featured/abstract-logo/\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define PI_2        (0.5*3.141592654)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float logo_radius= 0.25;\nconst float logo_off   = 0.25;\nconst float logo_dx    = 0.5/sqrt(3.0);\nconst float logo_width = 0.1;\n\nfloat rcp(float x) {\n  return 1.0 / x;\n}\n\n//P. Gilcher '21, strange approximation\n// Source found at: https://www.shadertoy.com/view/flSXRV\nfloat fast_atan2(float y, float x) {\n  float cosatan2 = x * rcp(abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r) {\n  const vec3 k = vec3(-sqrt(3.0)*0.5,0.5,sqrt(1.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\nfloat stripes(float d) {\n  const float cc = 0.42;\n  d = abs(d)-logo_width*cc;\n  d = abs(d)-logo_width*cc*0.5;\n  return d;\n}\n\nvec4 merge(vec4 s0, vec4 s1) {\n  bool dt = s0.z < s1.z; \n  vec4 b = dt ? s0 : s1;\n  vec4 t = dt ? s1 : s0;\n\n  b.x *= 1.0 - exp(-max(80.0*(t.w), 0.0));\n\n  vec4 r = vec4(\n      mix(b.xy, t.xy, t.y)\n    , b.w < t.w ? b.z : t.z \n    , min(b.w, t.w)\n    );\n  \n  return r;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = 2.0*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\nvec4 figure_8(float aa, vec2 p) {\n  vec2  p1 = p-vec2(logo_dx, -logo_off);\n  float d1 = abs(circle(p1, logo_radius));\n  float a1 = fast_atan2(-p1.x, -p1.y);\n  float s1 = stripes(d1);\n  float o1 = d1 - logo_width;\n\n  vec2  p2 = p-vec2(logo_dx, logo_off);\n  float d2 = abs(circle(p2, logo_radius));\n  float a2 = fast_atan2(p2.x, p2.y);  \n  float s2 = stripes(d2);\n  float o2 = d2 - logo_width;\n\n  vec4 c0 = vec4(smoothstep(aa, -aa, s1), smoothstep(aa, -aa, o1), a1, o1);\n  vec4 c1 = vec4(smoothstep(aa, -aa, s2), smoothstep(aa, -aa, o2), a2, o2);\n\n  return merge(c0, c1);\n}\n\nvec4 figure_half_8(float aa, vec2 p) {\n  vec2  p1 = p-vec2(logo_dx, -logo_off);\n  float d1 = abs(circle(p1, logo_radius));\n  float a1 = fast_atan2(-p1.x, -p1.y);\n  float s1 = stripes(d1);\n  float o1 = d1 - logo_width;\n\n  vec4 c0 = vec4(smoothstep(aa, -aa, s1), smoothstep(aa, -aa, o1), a1, o1);\n\n  return c0;\n}\n\nvec2 flipy(vec2 p) {\n  return vec2(p.x, -p.y);\n}\n\nvec4 clogo(vec2 p, float z, out float d) {\n  float iz = 1.0/z;\n  p *= iz;\n  float aa = iz*2.0/RESOLUTION.y;\n  float  n = modPolar(p, 3.0);\n  vec4 s0 = figure_8(aa, p);\n  vec4 s1 = figure_half_8(aa, p*ROT(2.0*PI/3.0));\n  vec4 s2 = figure_half_8(aa, flipy(p*ROT(4.0*PI/3.0)));\n  \n  s1.z -= PI;\n  \n  vec4 s = s0;\n  s = merge(s, s1);\n  s = merge(s, s2);\n\n  d = s.w;\n  return vec4(vec3(1.0)*s.x, s.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  //  Found this somewhere on the interwebs\n  col = clamp(col, 0.0, 1.0);\n  // Gamma correction\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  // Vignetting\n  col*= 0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float aa = 2.0/RESOLUTION.y;\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col  = vec3(1.0);\n  float d;\n  float a = TAU*TIME/240.0;\n  p += 10.0*vec2(sin(a), sin(sqrt(0.5)*a));\n  vec2 hp = p;\n  vec2 np = hextile(hp);\n  float hd = hex(hp.yx, 0.5);\n  hd = abs(hd) - 2.0*aa;\n  vec4 ccol = clogo(hp, 0.66, d);\n  col = mix(col, vec3(0.25), exp(-9.0*max(d+0.025, 0.0)));\n  col = mix(col, vec3(0.0), smoothstep(aa, -aa, hd));\n  col = mix(col, ccol.xyz, ccol.w);\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdXD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[448, 448, 468, 468, 488], [490, 588, 624, 624, 734], [736, 736, 767, 767, 793], [795, 889, 917, 917, 1101], [1103, 1204, 1232, 1331, 1658], [1660, 1660, 1684, 1684, 1783], [1785, 1785, 1815, 1815, 2053], [2055, 2141, 2190, 2190, 2592], [2594, 2594, 2627, 2627, 3165], [3167, 3167, 3205, 3205, 3477], [3479, 3479, 3499, 3499, 3527], [3529, 3529, 3571, 3571, 3927], [3929, 4012, 4048, 4092, 4363], [4365, 4365, 4420, 4420, 4998]], "test": "untested"}
{"id": "ftdSD7", "name": "Nyan will be back. - episode 1", "author": "IWBTShyGuy", "description": "Drag to rotate the sphere. However, Nyan will be back by the shortest route!", "tags": ["math", "rotation"], "likes": 3, "viewed": 210, "published": 3, "date": "1639242713", "time_retrieved": "2024-07-30T18:42:49.704957", "image_code": "// The MIT License\n// Copyright  2021 IWBTShyGuy\n\nmat3 rotMatrix() {\n    vec4 a = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 b = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 c = texelFetch(iChannel0, ivec2(2, 0), 0);\n    return mat3(\n        a[0], a[1], a[2],\n        a[3], b[0], b[1],\n        b[2], b[3], c[0]\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    mat3 mat = rotMatrix();\n    vec3 dir = mat * vec3(0, 0, -1);\n    Camera camera = newCamera(\n        -3.0 * dir,\n        dir,\n        mat * vec3(0, 1, 0),\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, fragCoord / iResolution.xy);\n\n    float midDist = -dot(ray.origin, ray.direction);\n    float r0 = dot(ray.origin, ray.origin) - midDist * midDist;\n    if (r0 > 1.0) {\n        fragColor = vec4(0, 0, 0, 1);\n        return;\n    }\n    float diff = sqrt(1.0 - r0 * r0);\n    vec3 p = ray.origin + (midDist - diff) * ray.direction;\n    vec3 q = ray.origin + (midDist + diff) * ray.direction;\n\n    vec3 col = vec3(-dot(ray.direction, p));\n    if (p.z > 0.0) {\n        vec2 uv = clamp(p.xy, -1.0, 1.0);\n        uv = uv + 0.5;\n        uv = clamp(uv, 0.0, 0.99);\n        uv.x /= 6.0;\n        col *= texture(iChannel1, uv).xyz;\n    }\n    if (q.z > 0.0) {\n        vec2 uv = clamp(q.xy, -1.0, 1.0);\n        uv = uv + 0.5;\n        uv = clamp(uv, 0.0, 0.99);\n        uv.x /= 6.0;\n        col *= (0.8 + 0.2 * texture(iChannel1, uv).xyz);\n    }\n\n    fragColor = vec4(pow(col, vec3(0.4545)), 1);\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nCamera newCamera(vec3 position, vec3 direction, vec3 up_direction, float fov, float aspect) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float radian = camera.fov;\n    float h = tan(radian * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\nmat3 rot(vec3 axis, float angle) {\n    return mat3(\n        axis[0] * axis[0] * (1.0 - cos(angle)) + cos(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) + axis[2] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) - axis[1] * sin(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) - axis[2] * sin(angle),\n        axis[1] * axis[1] * (1.0 - cos(angle)) + cos(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) + axis[0] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) + axis[1] * sin(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) - axis[0] * sin(angle),\n        axis[2] * axis[2] * (1.0 - cos(angle)) + cos(angle)\n    );\n}\n", "buffer_a_code": "// The MIT License\n// Copyright  2021 IWBTShyGuy\n\n// get the current matrix from texture\nmat3 rotMatrix() {\n    vec4 a = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 b = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 c = texelFetch(iChannel0, ivec2(2, 0), 0);\n    return mat3(\n        a[0], a[1], a[2],\n        a[3], b[0], b[1],\n        b[2], b[3], c[0]\n    );\n}\n\nvec4 matrixColor(in mat3 m, in int idx) {\n    switch (idx) {\n        case 0:\n            return vec4(m[0][0], m[0][1], m[0][2], m[1][0]);\n        case 1:\n            return vec4(m[1][1], m[1][2], m[2][0], m[2][1]);\n        case 2:\n            return vec4(m[2][2], 0, 0, 0);\n        default:\n            return vec4(0);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iCoord = ivec2(fragCoord);\n    if (iCoord.y != 0 || iCoord.x > 3) {\n        fragColor = vec4(0);\n        return;\n    } else if (iCoord.x == 3) {\n        fragColor = iMouse;\n        return;\n    } else if (iFrame == 0) {\n        mat3 mat = rot(normalize(vec3(0, 1, 1)), 1.0);\n        fragColor = matrixColor(mat, iCoord.x);\n        return;\n    }\n\n    mat3 mat = rotMatrix();\n    vec4 prevMouse = texelFetch(iChannel0, ivec2(3, 0), 0);\n\n    if (prevMouse.z > 0.0) {\n        // rotation by drag\n        vec2 diff = iMouse.xy - prevMouse.xy;\n        float theta = length(diff);\n        if (theta < 0.1) {\n            fragColor = texelFetch(iChannel0, iCoord, 0);\n            return;\n        }\n        diff /= theta;\n        theta /= (iResolution.y * 0.5);\n        vec3 axis = -diff.y * mat[0] + diff.x * mat[1];\n        mat = rot(axis, -theta) * mat;\n    } else if (\n        // rotation matrix is not identity\n        abs(mat[0][0] - 1.0) >= 1.0e-4 ||\n        abs(mat[1][1] - 1.0) >= 1.0e-4 ||\n        abs(mat[2][2] - 1.0) >= 1.0e-4\n    ) {\n        // calculate axis\n        mat3 m = transpose(mat - mat3(1));\n        vec3 axis_0 = cross(m[0], m[1]);\n        vec3 axis_1 = cross(m[1], m[2]);\n        vec3 axis_2 = cross(m[2], m[0]);\n        vec3 axis = length(axis_0) > length(axis_1) ? axis_0 : axis_1;\n        axis = length(axis) > length(axis_2) ? axis : axis_2;\n        axis = normalize(axis);\n        vec3 axis2 = axis * axis;\n\n        // cosine of angle\n        float co;\n        if (axis2.x < 0.33333) \n            co = (mat[0][0] - axis2.x) / (1.0 - axis2.x);\n        else if (axis2.y < 0.33333) \n            co = (mat[1][1] - axis2.y) / (1.0 - axis2.y);\n        else\n            co = (mat[2][2] - axis2.z) / (1.0 - axis2.z);\n        \n        // sine of angle\n        float si;\n        if (axis2.x > 0.33333) \n            si = (axis.y * axis.z * (1.0 - co) - mat[2][1]) / axis.x;\n        else if (axis2.y > 0.33333) \n            si = (axis.z * axis.x * (1.0 - co) - mat[0][2]) / axis.y;\n        else\n            si = (axis.x * axis.y * (1.0 - co) - mat[1][0]) / axis.z;\n        \n        // Turn slightly in the opposite direction.\n        float theta = acos(clamp(co, -1.0, 1.0)) * sign(si);\n        mat = rot(axis, -theta * 0.05) * mat;\n    }\n\n    // It should be orthogonalized because of the error accumulation.\n    mat[0] = normalize(mat[0]);\n    mat[1] = mat[1] - dot(mat[0], mat[1]) * mat[0];\n    mat[1] = normalize(mat[1]);\n    mat[2] = mat[2] - dot(mat[0], mat[2]) * mat[0] - dot(mat[1], mat[2]) * mat[1];\n    mat[2] = normalize(mat[2]);\n\n    // give the current matrix to texture\n    fragColor = matrixColor(mat, iCoord.x);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdSD7.jpg", "access": "api", "license": "mit", "functions": [[52, 52, 70, 70, 329], [331, 331, 386, 386, 1518]], "test": "untested"}
{"id": "NtdSD7", "name": "Footwear Design 007", "author": "yasuo", "description": "tried to experiment with the wavy upper and fractal textures", "tags": ["footwear"], "likes": 4, "viewed": 222, "published": 3, "date": "1639242483", "time_retrieved": "2024-07-30T18:42:50.467916", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Slice(p,a) dot(p,vec2(cos(a),sin(a)))\n#define S(p,d,b) smoothstep(fwidth(p.y),0.0,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define MATERIAL 0\n\n#define ZERO (min(iFrame,0))\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n    const vec3 s = vec3(27, 111, 57);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdSimpleCylinder(vec3 p, float r, float h){\n    float d = length(p.xz)-r;\n    d = max(abs(p.y)-h,d);\n    return d;\n}\n\nfloat baseOutsole(vec3 p, float h){\n    vec3 prevP = p;\n    \n    p.xz*=Rot(radians(17.0));\n    p.z*=0.4;\n    p.x*=0.57;\n    p.x+=0.03;\n    p.z-=0.07;\n    \n    float d =sdSimpleCylinder(p,0.1,h);\n    \n    p = prevP;\n    p.xy*=Rot(radians(90.0));\n    p.y*=1.5;\n    p.z*=1.2;\n    float d2 = sdCappedCylinder(p-vec3(0.0,0.0,-0.25),h,0.2);\n    d = opSmoothUnion(d, d2,0.13);\n    \n    p = prevP;\n    d = max(abs(p.y)-h,d);\n    \n    return (d)*0.6;\n}\n\nfloat outsole(vec3 p){\n    p.z*=0.9;\n    vec3 prevP = p;\n    \n    float d = baseOutsole(p-vec3(0.0,0.02,0.),0.06);\n    \n    p.z+=sin(p.x*150.0)*0.01;\n    p.x = mod(p.x,0.06)-0.03;\n    p.z = mod(p.z,0.08)-0.04;\n    p.xy*=Rot(radians(90.));\n    p.y*=1.5;\n    float d2 = sdCappedCylinder(p-vec3(0.19,0.0,0.0),0.2,0.035)*0.6;\n    \n\n    d = max(d,d2);\n    p = prevP;\n    d2 = baseOutsole(p-vec3(0.0,0.035,0.0),0.035);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.xz*=0.96;\n    p.yz*=Rot(radians(-3.0));\n    d2 = baseOutsole(p-vec3(0.0,0.03,0.0),0.005);\n    d = min(d,d2);\n    \n    p = prevP;\n    float a  = radians(4.0);\n    p.y-=0.06;\n    float mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    p = prevP;\n    a  = radians(-8.0);\n    p.y+=0.07;\n    mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    \n    p = prevP;\n    a  = radians(10.0);\n    p.y+=0.08;\n    mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    \n    return d;\n}\n\n\nfloat upperBase(vec3 p){\n    p.z*=0.9;\n    vec3 prevP2 = p;\n    p.x+=cos(p.y*160.0)*0.006;\n    p.y+=cos(p.x*160.0)*0.006;\n    vec3 prevP = p;\n\n    p.z*=0.8;\n    \n    float d =sdCappedCone(p-vec3(0.0,0.18,-0.15),0.13,0.15,0.06);\n    \n    p = prevP;\n    p.xz*=Rot(radians(15.0));\n    p.yz*=Rot(radians(-6.0));\n    p.x*=1.2;\n    p.z*=0.8;\n    \n    float d2 = sdEllipsoid(p-vec3(-0.05,0.1,0.14),vec3(0.2,0.08,0.2));\n    d = opSmoothUnion(d,d2,0.1);//0.1\n    \n    p = prevP;\n    p.xz*=Rot(radians(0.0));\n    p.x*=1.1;\n    p.z*=0.8;\n    p.yz*=Rot(radians(-35.0));\n\n    d2 = sdEllipsoid(p-vec3(0.0,0.21,-0.1),vec3(0.1,0.04,0.15));\n\n    d = opSmoothUnion(d,d2,0.17);//0.15\n    \n    p = prevP2;\n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(13.0));\n    p.y*=1.5;\n    p.z*=1.0;\n    d2 = sdCappedCylinder(p-vec3(-0.1,0.0,-0.18),0.03,0.2)-0.025;\n    d = opSmoothUnion(d, d2,0.07);\n\n    return d;\n}\n\nfloat upper(vec3 p){\n    vec3 prevP = p;\n    float d = upperBase(p);\n    p.x*=1.5;\n    p.y*=1.1;\n    p.z*=1.12;\n    \n    float d2 = upperBase(p-vec3(0.0,0.02,0.0));\n    d = max(-d2,d);\n    \n    p = prevP;\n    \n    p.x*=1.6;\n    p.z*=0.7;\n    \n    d2 =sdCappedCone(p-vec3(-0.01,0.25,-0.1),0.14,0.14,0.09)*0.6;\n    d = max(-d2,d);\n    \n    p = prevP;\n    float a  = radians(8.0);\n    p.y-=0.31;\n    float mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    p = prevP;\n    p.yz*=Rot(radians(-12.0));\n    p.x*=1.2;\n    p.y*=1.2;\n    p.z*=0.65;\n    d2 = sdTorus(p-vec3(-0.005,0.35,-0.125),vec2(0.1,0.02));\n    \n    d = opSmoothUnion(d,d2,0.04);\n    \n    p = prevP;\n    p.x*=1.4;\n    p.z*=0.75;\n    d2 =sdSimpleCylinder(p-vec3(-0.005,0.35,-0.1),0.1,0.2);\n    d = max(-d2,d);\n    \n    return d*0.8;\n}\n\nvec2 GetDist(vec3 p) {\n    p+=noise3d(p*600.0)*0.0002;\n    vec3 prevP = p;\n    \n    p.y+=0.075;\n    //p.z+=0.1;\n    float d = outsole(p);\n    p.yz*=Rot(radians(-3.0));\n    float d2 = upper(p-vec3(0.0,0.02,0.0));\n    d =  opSmoothUnion(d,d2,0.035);\n    \n    vec2 model = vec2(d,MATERIAL);\n\n    return model;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<3; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nfloat fractalBlock(vec2 p){\n    p*=0.7;\n    p*=Rot(radians(10.0+iTime*-30.));\n    vec2 prevP = p;\n    float d = B(p,vec2(0.01));\n    \n    p.x = abs(p.x);\n    p.x-=0.04;\n    float d2 = B(p,vec2(0.007));\n    \n    d = min(d,d2);\n    \n    p = prevP;\n    p.y = abs(p.y);\n    p.y-=0.04;\n    d2 = B(p,vec2(0.007));\n    \n    d = min(d,d2);\n    \n    p = prevP;\n    p = abs(p);\n    p-=0.06;\n    d2 = min(length(p)-0.005,d2);\n    d = min(d,d2);\n    \n    return d;\n}\n\nvec3 evaTex(vec2 uv, vec3 col, vec3 fcol){\n    float d = fractalBlock(uv);\n    float depth = 7.;\n    for(float i = 0.; i<depth; i++){\n        uv*= 1.0+i*0.03;\n        uv*=Rot(radians(i*10.0+iTime*5.));\n        uv = abs(uv);\n        uv-=0.05+i*0.02;\n        float d2 = fractalBlock(uv);\n        d = min(d,d2);\n    }\n    \n    col = mix(col,fcol,S(uv,d,0.0));\n    \n    return col;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL){\n        col = diffuseMaterial(n,rd,p,mix(vec3(0.2,0.3,0.7),vec3(0.9,0.1,0.5),p.z)*evaTex(p.xz+p.yy,col,vec3(0.0,0.8,0.6)*2.0));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy -.3;\n    \n    vec3 ro = vec3(0, 0, 1.1);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    if(iMouse.z>0.){\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.xz *= Rot(radians(-5.0+iTime*20.0));\n        \n        //ro.yz *= Rot(radians(120.0));\n        //ro.xz *= Rot(radians(45.0));\n    }\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        //col *= exp( -0.038*d.x*d.x*d.x );//fog\n    } else {\n        //col = upperTex(uv,col);\n        col = evaTex(uv,col,mix(vec3(0.2,0.3,0.7),vec3(0.9,0.1,0.5),uv.y));\n    }\n    \n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdSD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[390, 390, 415, 415, 434], [435, 435, 460, 460, 479], [480, 480, 532, 532, 632], [634, 746, 771, 771, 1116], [1118, 1118, 1154, 1154, 1196], [1198, 1247, 1280, 1280, 1345], [1347, 1396, 1448, 1448, 1555], [1557, 1606, 1637, 1637, 1724], [1726, 1775, 1812, 1812, 1895], [1897, 1946, 2005, 2005, 2318], [2320, 2320, 2369, 2369, 2442], [2444, 2444, 2479, 2479, 2887], [2889, 2889, 2911, 2911, 3855], [3858, 3858, 3882, 3882, 4749], [4751, 4751, 4771, 4771, 5560], [5562, 5562, 5584, 5584, 5870], [5872, 5872, 5930, 5930, 6197], [6199, 6199, 6223, 6223, 6424], [6426, 6426, 6468, 6468, 6663], [6665, 6706, 6755, 6755, 7049], [7051, 7051, 7108, 7108, 7727], [7729, 7729, 7751, 7751, 7841], [7843, 7843, 7870, 7870, 8297], [8299, 8299, 8341, 8341, 8678], [8680, 8680, 8739, 8739, 8916], [8918, 8918, 8975, 8975, 10095]], "test": "untested"}
{"id": "NldXDM", "name": "Triangle Image Effect", "author": "Daizuukee", "description": "Here i have created a shader that splits the grid into infinite triangles that move around, to continue i would like to add subtriangles to the project as i believe that it would add a lot of life to the image.", "tags": ["grid", "triangles", "colors", "imageprocessing", "random", "imageeffect", "interpolation", "colormixing"], "likes": 28, "viewed": 593, "published": 3, "date": "1639234592", "time_retrieved": "2024-07-30T18:42:51.229879", "image_code": "/*\nPARAMETERS FEEL FREE TO CHANGE\n*/\n\n//Difference between triangles -> 0 - 1\n#define multiplier 0.71\n//Amount of traingles on X axis\n#define zoom 20.\n\n//position of the camera (can be an animation, dont place below 0)\n#define position vec2(85,483);\n\n//Lighting\n//strength of the lights\n#define normals 0.25\n//Direction of the light\n#define light vec2(2,1)\n\n//Uncomment to use iCHannel0 as source for colors\n//#define colFromImage\n\n//colors (can be animated)\n//only apply when colFromImage is undefined\n#define color0 vec3(1.0, 0.0, 1.0)\n#define color1 vec3(0.2157, 0.0, 1.0)\n#define color2 vec3(0.502, 0.9686, 1.0)\n#define color3 vec3(0.702, 0.4235, 0.2353)\n#define BG vec3(1,1,1)\n//Strength of the colors to be aplied to the BG\n#define strength 0.71\n\n\n/*\nCODE BEGINS HERE\n*/\n\n\n//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n\n//const uint k = 1103515245U;  // GLIB C\nconst uint k = 134775813U;   // Delphi and Turbo Pascal\n//const uint k = 1664525U;     // Numerical Recipes\nvec3 hash(uvec3 x)\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU)) * 2. - 1.;\n}\n\n\n\n\n\n#define lerp(from,to,x) (((to)-(from))*(x)+(from))\n#define map(from,to,fromX,toX,x) lerp((from),(to),((x)-(fromX))/((toX)-(fromX)))\n#define zFunc iTime\n//Gets the vertice at x,y with z time having passed\n//only value that is animated is z\nvec3 getVertice(vec3 pos) {\n    //give every tiangle a different time offset\n    float t = pos.z+hash(uvec3(pos.xy + 748.,0)).x;\n    //interpolate between current and next triangle position\n    vec3 a = hash(uvec3(pos.xy,floor(t))) * multiplier * 0.5 + 0.5;\n    vec3 b = hash(uvec3(pos.xy,ceil(t))) * multiplier * 0.5 + 0.5;\n    //make normals stronger\n    a.z *= normals;\n    b.z *= normals;\n    return lerp(a,b,fract(t));\n}\n\n//Gets the triangle that p will be in\n//x -> x quad\n//y -> y quad\n//z -> upper or lower triangle\n/*\nEach quad looks like this\neach + can be moved freely\n\n+----+\n|\\   |\n| \\  |\n|  \\ |\n|   \\|\n+----+\n\n*/\n\nuvec3 bindToTris(vec2 p) {\n    //current grid Tile\n    ivec2 floorP = ivec2(p);\n    //relative Position to Tile\n    vec2 modP = p-vec2(floorP);\n    //time\n    float z = zFunc;\n    //check in which quad we are relative to the middle of the current grid Tile\n    vec2 mid = getVertice(vec3(floorP,z)).xy;\n    ivec2 nextOffset = ivec2(mid.x < modP.x,mid.y < modP.y) * 2 - 1;\n\n    //check in which quad we are by looking if we are above/below and to the right/left of line between the dots\n    //that make up the current quad\n    vec2 yOff = getVertice(vec3(floorP.x, floorP.y + nextOffset.y, z)).xy;\n    vec2 xOff = getVertice(vec3(floorP.x + nextOffset.x, floorP.y, z)).xy;\n    float yLine = map(mid.x,yOff.x,mid.y,yOff.y+float(nextOffset.y),modP.y);\n    float xLine = map(mid.y,xOff.y,mid.x,xOff.x+float(nextOffset.x),modP.x);\n\n    ivec2 quad = ivec2(modP.x > yLine, modP.y > xLine);\n    \n    //check wether we are in the upper or lower triangle of the current quad\n    vec2 dOff0 = getVertice(vec3(floorP + quad + ivec2(-1, 0), z)).xy;\n    vec2 dOff1 = getVertice(vec3(floorP + quad + ivec2( 0,-1), z)).xy;\n\n    float dLine = map(dOff0.y+1.,dOff1.y,dOff0.x,dOff1.x+1.,modP.x+1.-float(quad.x))-1.+float(quad.y);\n    \n    //return the data for further use (mostly unusable as is)\n    return uvec3(quad+floorP,modP.y > dLine);\n}\n\n//returns the middle of the triangle given the data from bindToTris() and the height gradient\n\nvec4 getTriangle(uvec3 data) {\n    float z = zFunc;\n    int up = int(data.z);\n    //get all the different vertices\n    vec3 p1 = getVertice(vec3(vec2(data.xy)+vec2(0,-1),z)) + vec3(0,-1, 0);\n    vec3 p2 = getVertice(vec3(vec2(data.xy)+vec2(-1,0),z)) + vec3(-1, 0, 0);\n    vec3 p3 = getVertice(vec3(vec2(data.xy)+vec2(up-1,up-1),z)) + vec3(up-1,up-1,0);\n\n    //gradient from p1 to the other corners\n    vec3 gradient0 = p1-p2;\n    vec3 gradient1 = p1-p3;\n    vec3 g = cross(gradient0,gradient1);\n    //amount you need to move x and y to add 1 to z\n    g.xyz /= g.z;\n    \n    return vec4(((p1.xy+p2.xy+p3.xy)/3.)+vec2(data.xy),g.xy);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n    vec2 uv=fragCoord/iResolution.xx;\n    uv *= zoom;\n    uv += position;\n    \n    //standardize everything\n    vec3 interpCol0 = color0;\n    vec3 interpCol1 = color1;\n    vec3 interpCol2 = color2;\n    vec3 interpCol3 = color3;\n    //get triangle under current pixel and immediately turn into usable data\n    vec4 Triangle = getTriangle(bindToTris(uv));\n    Triangle.xy -= position;\n    Triangle.xy /= zoom;\n\n    vec3 cur;\n\n#ifdef colFromImage\n    cur = texture(iChannel0,Triangle.xy).xyz;\n#else\n    //interpolate the colors\n    float l0 = clamp((1.-distance(Triangle.xy,vec2(0,0)))*strength,0.,1.);\n    float l1 = clamp((1.-distance(Triangle.xy,vec2(0,1)))*strength,0.,1.);\n    float l2 = clamp((1.-distance(Triangle.xy,vec2(1,0)))*strength,0.,1.);\n    float l3 = clamp((1.-distance(Triangle.xy,vec2(1,1)))*strength,0.,1.);\n    cur = lerp(BG,interpCol0,l0);\n    cur = lerp(cur,interpCol1,l1);\n    cur = lerp(cur,interpCol2,l2);\n    cur = lerp(cur,interpCol3,l3);\n#endif\n    //calculate lighting through dot product between lighting normal and triangle normal\n    cur *= dot(Triangle.zw,normalize(light))/2.+1.;\n\n    fragColor = vec4(cur,1);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldXDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[858, 1007, 1027, 1027, 1165], [1323, 1410, 1437, 1486, 1835], [2038, 2038, 2064, 2088, 3363], [3460, 3460, 3490, 3490, 4093], [4095, 4095, 4149, 4149, 5293]], "test": "untested"}
{"id": "ftdSWM", "name": "My idol", "author": "cxm", "description": "Paint triangle method by movAX13h\nhttps://www.shadertoy.com/view/4dsGRs", "tags": ["lowpoly", "cineshader", "painttriangle", "imageevolution"], "likes": 16, "viewed": 5114, "published": 3, "date": "1639230200", "time_retrieved": "2024-07-30T18:42:52.425682", "image_code": "\nfloat dir(vec2 a, vec2 b, vec2 c)\n{\n\treturn (a.x - c.x) * (b.y - c.y) - (b.x - c.x) * (a.y - c.y);\n}\n\nbool insideTri(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n\tbool b1 = dir(p, a, b) < 0.0;\n\tbool b2 = dir(p, b, c) < 0.0;\n\tbool b3 = dir(p, c, a) < 0.0;\n  \treturn ((b1 == b2) && (b2 == b3));\n}\n\nfloat distRect(vec2 p, vec2 rect)\n{\n  vec2 d = abs(p) - rect;\n  return smoothstep(rect.y, 0.0, min(max(d.x, d.y),0.0) + length(max(d, 0.0)));\n}\n\nvoid applyColor(vec3 paint, inout vec3 col, vec2 p, vec2 a, vec2 b, vec2 c, in vec2 iRes)\n{\n    vec2 aa = a * iRes;\n    vec2 bb = b * iRes;\n    vec2 cc = c * iRes;\n\tif (insideTri(p, aa, bb, cc)) col = mix(col, paint, max(col.r, 1.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n\n\tvec3 col;\n    vec2 Res = iResolution.xy;\n\n    //applyColor(vec3(0.77, 0.19, 0.14), col, uv, vec2(20., 20.), vec2(0., 30.), vec2( 50., 86. ));\n    //applyColor(vec3(0.77, 0.19, 0.14), col, uv, vec2(.03, .05), vec2(0., .08), vec2( .07, .23 ), iResolution.xy);\n    \n    \n    applyColor(vec3(0.31, 0.25, 0.24), col, uv, vec2(0.09, 0.65), vec2(0.09, 0.63), vec2( 0., 0.76 ), Res);\n    applyColor(vec3(0.25, 0.23, 0.14), col, uv, vec2(0.09, 0.63), vec2(0., 0.51), vec2( 0., 0.76 ), Res);\n    applyColor(vec3(0.31, 0.23, 0.23), col, uv, vec2(0.10, 0.76), vec2(0.10, 0.70), vec2( 0., 0.76 ), Res);\n    applyColor(vec3(0.30, 0.24, 0.28), col, uv, vec2(0.10, 0.70), vec2(0.09, 0.65), vec2( 0., 0.76 ), Res);\n    applyColor(vec3(0.26, 0.26, 0.15), col, uv, vec2(0.10, 0.60), vec2(0., 0.51), vec2( 0.09, 0.63 ), Res);\n    applyColor(vec3(0.45, 0.38, 0.32), col, uv, vec2(0.10, 0.74), vec2(0.10, 0.70), vec2( 0.10, 0.76 ), Res);\n    applyColor(vec3(0.27, 0.23, 0.18), col, uv, vec2(0.10, 0.55), vec2(0., 0.51), vec2( 0.10, 0.60 ), Res);\n    applyColor(vec3(0.32, 0.29, 0.22), col, uv, vec2(0.11, 0.76), vec2(0.10, 0.74), vec2( 0.10, 0.76 ), Res);\n    applyColor(vec3(0.37, 0.29, 0.24), col, uv, vec2(0.11, 0.81), vec2(0.11, 0.77), vec2( 0.10, 0.76 ), Res);\n    applyColor(vec3(0.23, 0.22, 0.18), col, uv, vec2(0.11, 0.81), vec2(0.10, 0.76), vec2( 0., 0.76 ), Res);\n    applyColor(vec3(0.43, 0.34, 0.32), col, uv, vec2(0.11, 0.77), vec2(0.11, 0.76), vec2( 0.10, 0.76 ), Res);\n    applyColor(vec3(0.71, 0.31, 0.37), col, uv, vec2(0.12, 0.65), vec2(0.09, 0.63), vec2( 0.09, 0.65 ), Res);\n    applyColor(vec3(0.84, 0.30, 0.30), col, uv, vec2(0.12, 0.56), vec2(0.10, 0.55), vec2( 0.10, 0.60 ), Res);\n    applyColor(vec3(0.29, 0.23, 0.18), col, uv, vec2(0.12, 0.80), vec2(0.11, 0.77), vec2( 0.11, 0.81 ), Res);\n    applyColor(vec3(0.19, 0.15, 0.15), col, uv, vec2(0.12, 0.76), vec2(0.11, 0.76), vec2( 0.11, 0.77 ), Res);\n    applyColor(vec3(0.27, 0.22, 0.14), col, uv, vec2(0.12, 0.46), vec2(0., 0.51), vec2( 0.10, 0.55 ), Res);\n    applyColor(vec3(0.27, 0.27, 0.26), col, uv, vec2(0.12, 0.83), vec2(0.11, 0.81), vec2( 0., 1. ), Res);\n    applyColor(vec3(1.00, 0.53, 0.54), col, uv, vec2(0.12, 0.65), vec2(0.09, 0.65), vec2( 0.10, 0.70 ), Res);\n    applyColor(vec3(0.22, 0.15, 0.26), col, uv, vec2(0.11, 0.81), vec2(0., 0.76), vec2( 0., 1. ), Res);\n    applyColor(vec3(0.55, 0.38, 0.32), col, uv, vec2(0.13, 0.77), vec2(0.12, 0.76), vec2( 0.11, 0.77 ), Res);\n    applyColor(vec3(0.36, 0.27, 0.18), col, uv, vec2(0.13, 0.77), vec2(0.11, 0.77), vec2( 0.12, 0.80 ), Res);\n    applyColor(vec3(0.15, 0.09, 0.02), col, uv, vec2(0.12, 0.80), vec2(0.11, 0.81), vec2( 0.12, 0.83 ), Res);\n    applyColor(vec3(0.00, 0.00, 0.00), col, uv, vec2(0.12, 0.76), vec2(0.10, 0.74), vec2( 0.11, 0.76 ), Res);\n    applyColor(vec3(0.88, 0.38, 0.39), col, uv, vec2(0.12, 0.65), vec2(0.10, 0.60), vec2( 0.09, 0.63 ), Res);\n    applyColor(vec3(0.62, 0.54, 0.40), col, uv, vec2(0.13, 0.83), vec2(0.13, 0.81), vec2( 0.12, 0.83 ), Res);\n    applyColor(vec3(0.58, 0.45, 0.37), col, uv, vec2(0.13, 0.81), vec2(0.12, 0.80), vec2( 0.12, 0.83 ), Res);\n    applyColor(vec3(0.54, 0.44, 0.35), col, uv, vec2(0.13, 0.42), vec2(0., 0.25), vec2( 0., 0.51 ), Res);\n    applyColor(vec3(0.27, 0.22, 0.16), col, uv, vec2(0.13, 0.42), vec2(0., 0.51), vec2( 0.12, 0.46 ), Res);\n    applyColor(vec3(0.98, 0.70, 0.64), col, uv, vec2(0.14, 0.77), vec2(0.12, 0.76), vec2( 0.13, 0.77 ), Res);\n    applyColor(vec3(0.99, 0.55, 0.53), col, uv, vec2(0.14, 0.72), vec2(0.10, 0.70), vec2( 0.10, 0.74 ), Res);\n    applyColor(vec3(0.95, 0.56, 0.46), col, uv, vec2(0.14, 0.72), vec2(0.10, 0.74), vec2( 0.12, 0.76 ), Res);\n    applyColor(vec3(0.26, 0.25, 0.29), col, uv, vec2(0.13, 0.86), vec2(0.12, 0.83), vec2( 0., 1. ), Res);\n    applyColor(vec3(0.16, 0.14, 0.13), col, uv, vec2(0.13, 0.86), vec2(0.13, 0.83), vec2( 0.12, 0.83 ), Res);\n    applyColor(vec3(0.67, 0.55, 0.42), col, uv, vec2(0.13, 0.81), vec2(0.13, 0.77), vec2( 0.12, 0.80 ), Res);\n    applyColor(vec3(0.07, 0.05, 0.04), col, uv, vec2(0.14, 0.84), vec2(0.13, 0.83), vec2( 0.13, 0.86 ), Res);\n    applyColor(vec3(0.40, 0.36, 0.26), col, uv, vec2(0.14, 0.36), vec2(0., 0.25), vec2( 0.13, 0.42 ), Res);\n    applyColor(vec3(0.82, 0.28, 0.27), col, uv, vec2(0.14, 0.77), vec2(0.14, 0.72), vec2( 0.12, 0.76 ), Res);\n    applyColor(vec3(0.77, 0.25, 0.25), col, uv, vec2(0.14, 0.72), vec2(0.12, 0.65), vec2( 0.10, 0.70 ), Res);\n    applyColor(vec3(0.62, 0.20, 0.18), col, uv, vec2(0.14, 0.48), vec2(0.10, 0.55), vec2( 0.12, 0.56 ), Res);\n    applyColor(vec3(0.55, 0.29, 0.23), col, uv, vec2(0.14, 0.48), vec2(0.12, 0.46), vec2( 0.10, 0.55 ), Res);\n    applyColor(vec3(0.65, 0.53, 0.35), col, uv, vec2(0.15, 0.82), vec2(0.13, 0.81), vec2( 0.13, 0.83 ), Res);\n    applyColor(vec3(0.56, 0.45, 0.38), col, uv, vec2(0.15, 0.88), vec2(0.15, 0.86), vec2( 0.13, 0.86 ), Res);\n    applyColor(vec3(0.00, 0.00, 0.00), col, uv, vec2(0.15, 0.86), vec2(0.14, 0.84), vec2( 0.13, 0.86 ), Res);\n    applyColor(vec3(0.82, 0.70, 0.64), col, uv, vec2(0.15, 0.82), vec2(0.13, 0.83), vec2( 0.14, 0.84 ), Res);\n    applyColor(vec3(0.32, 0.19, 0.16), col, uv, vec2(0.15, 0.44), vec2(0.13, 0.42), vec2( 0.12, 0.46 ), Res);\n    applyColor(vec3(0.84, 0.71, 0.55), col, uv, vec2(0.15, 0.44), vec2(0.12, 0.46), vec2( 0.14, 0.48 ), Res);\n    applyColor(vec3(0.38, 0.24, 0.11), col, uv, vec2(0.15, 0.38), vec2(0.14, 0.36), vec2( 0.13, 0.42 ), Res);\n    applyColor(vec3(0.93, 0.88, 0.81), col, uv, vec2(0.14, 0.77), vec2(0.13, 0.77), vec2( 0.13, 0.81 ), Res);\n    applyColor(vec3(0.34, 0.17, 0.00), col, uv, vec2(0.15, 0.42), vec2(0.15, 0.38), vec2( 0.13, 0.42 ), Res);\n    applyColor(vec3(0.33, 0.15, 0.05), col, uv, vec2(0.15, 0.42), vec2(0.13, 0.42), vec2( 0.15, 0.44 ), Res);\n    applyColor(vec3(0.71, 0.58, 0.37), col, uv, vec2(0.15, 0.36), vec2(0.14, 0.36), vec2( 0.15, 0.38 ), Res);\n    applyColor(vec3(0.67, 0.56, 0.41), col, uv, vec2(0.15, 0.36), vec2(0.15, 0.34), vec2( 0.14, 0.36 ), Res);\n    applyColor(vec3(0.67, 0.18, 0.11), col, uv, vec2(0.12, 0.65), vec2(0.12, 0.56), vec2( 0.10, 0.60 ), Res);\n    applyColor(vec3(0.17, 0.00, 0.05), col, uv, vec2(0.15, 0.57), vec2(0.12, 0.56), vec2( 0.12, 0.65 ), Res);\n    applyColor(vec3(0.91, 0.88, 0.80), col, uv, vec2(0.15, 0.82), vec2(0.14, 0.77), vec2( 0.13, 0.81 ), Res);\n    applyColor(vec3(0.39, 0.30, 0.26), col, uv, vec2(0.16, 0.85), vec2(0.14, 0.84), vec2( 0.15, 0.86 ), Res);\n    applyColor(vec3(0.45, 0.29, 0.22), col, uv, vec2(0.16, 0.61), vec2(0.15, 0.57), vec2( 0.12, 0.65 ), Res);\n    applyColor(vec3(0.65, 0.57, 0.53), col, uv, vec2(0.16, 0.89), vec2(0.15, 0.86), vec2( 0.15, 0.88 ), Res);\n    applyColor(vec3(0.18, 0.11, 0.06), col, uv, vec2(0.15, 0.57), vec2(0.14, 0.48), vec2( 0.12, 0.56 ), Res);\n    applyColor(vec3(0.54, 0.43, 0.37), col, uv, vec2(0.17, 0.87), vec2(0.15, 0.86), vec2( 0.16, 0.89 ), Res);\n    applyColor(vec3(0.18, 0.12, 0.09), col, uv, vec2(0.17, 0.87), vec2(0.16, 0.85), vec2( 0.15, 0.86 ), Res);\n    applyColor(vec3(0.54, 0.05, 0.08), col, uv, vec2(0.17, 0.70), vec2(0.17, 0.69), vec2( 0.14, 0.72 ), Res);\n    applyColor(vec3(0.74, 0.22, 0.19), col, uv, vec2(0.17, 0.69), vec2(0.12, 0.65), vec2( 0.14, 0.72 ), Res);\n    applyColor(vec3(0.71, 0.57, 0.35), col, uv, vec2(0.17, 0.54), vec2(0.14, 0.48), vec2( 0.15, 0.57 ), Res);\n    applyColor(vec3(0.20, 0.06, 0.01), col, uv, vec2(0.17, 0.38), vec2(0.15, 0.36), vec2( 0.15, 0.38 ), Res);\n    applyColor(vec3(0.46, 0.31, 0.15), col, uv, vec2(0.17, 0.38), vec2(0.17, 0.36), vec2( 0.15, 0.36 ), Res);\n    applyColor(vec3(0.56, 0.37, 0.24), col, uv, vec2(0.17, 0.38), vec2(0.15, 0.38), vec2( 0.15, 0.42 ), Res);\n    applyColor(vec3(0.63, 0.40, 0.29), col, uv, vec2(0.17, 0.36), vec2(0.15, 0.34), vec2( 0.15, 0.36 ), Res);\n    applyColor(vec3(0.85, 0.78, 0.71), col, uv, vec2(0.16, 0.85), vec2(0.15, 0.82), vec2( 0.14, 0.84 ), Res);\n    applyColor(vec3(0.34, 0.24, 0.16), col, uv, vec2(0.17, 0.64), vec2(0.16, 0.61), vec2( 0.12, 0.65 ), Res);\n    applyColor(vec3(0.44, 0.35, 0.26), col, uv, vec2(0.17, 0.64), vec2(0.12, 0.65), vec2( 0.17, 0.69 ), Res);\n    applyColor(vec3(0.47, 0.36, 0.22), col, uv, vec2(0.17, 0.36), vec2(0.17, 0.32), vec2( 0.15, 0.34 ), Res);\n    applyColor(vec3(0.42, 0.37, 0.30), col, uv, vec2(0.15, 0.34), vec2(0., 0.25), vec2( 0.14, 0.36 ), Res);\n    applyColor(vec3(0.34, 0.28, 0.22), col, uv, vec2(0.18, 0.88), vec2(0.17, 0.87), vec2( 0.16, 0.89 ), Res);\n    applyColor(vec3(0.05, 0.02, 0.05), col, uv, vec2(0.18, 0.60), vec2(0.15, 0.57), vec2( 0.16, 0.61 ), Res);\n    applyColor(vec3(0.39, 0.24, 0.05), col, uv, vec2(0.18, 0.35), vec2(0.17, 0.32), vec2( 0.17, 0.36 ), Res);\n    applyColor(vec3(0.23, 0.23, 0.28), col, uv, vec2(0.15, 0.88), vec2(0.13, 0.86), vec2( 0., 1. ), Res);\n    applyColor(vec3(0.73, 0.67, 0.58), col, uv, vec2(0.18, 0.84), vec2(0.16, 0.85), vec2( 0.17, 0.87 ), Res);\n    applyColor(vec3(0.24, 0.08, 0.05), col, uv, vec2(0.18, 0.70), vec2(0.17, 0.69), vec2( 0.17, 0.70 ), Res);\n    applyColor(vec3(0.14, 0.06, 0.02), col, uv, vec2(0.18, 0.60), vec2(0.16, 0.61), vec2( 0.17, 0.64 ), Res);\n    applyColor(vec3(0.56, 0.06, 0.09), col, uv, vec2(0.17, 0.70), vec2(0.14, 0.72), vec2( 0.14, 0.77 ), Res);\n    applyColor(vec3(0.41, 0.27, 0.16), col, uv, vec2(0.19, 0.65), vec2(0.17, 0.64), vec2( 0.17, 0.69 ), Res);\n    applyColor(vec3(0.94, 0.88, 0.80), col, uv, vec2(0.18, 0.84), vec2(0.15, 0.82), vec2( 0.16, 0.85 ), Res);\n    applyColor(vec3(0.27, 0.25, 0.20), col, uv, vec2(0.18, 0.84), vec2(0.17, 0.87), vec2( 0.18, 0.88 ), Res);\n    applyColor(vec3(0.17, 0.07, 0.06), col, uv, vec2(0.18, 0.60), vec2(0.17, 0.54), vec2( 0.15, 0.57 ), Res);\n    applyColor(vec3(0.34, 0.22, 0.13), col, uv, vec2(0.18, 0.35), vec2(0.17, 0.36), vec2( 0.17, 0.38 ), Res);\n    applyColor(vec3(0.24, 0.13, 0.04), col, uv, vec2(0.19, 0.61), vec2(0.19, 0.58), vec2( 0.18, 0.60 ), Res);\n    applyColor(vec3(0.15, 0.11, 0.10), col, uv, vec2(0.19, 0.61), vec2(0.18, 0.60), vec2( 0.17, 0.64 ), Res);\n    applyColor(vec3(0.39, 0.23, 0.09), col, uv, vec2(0.19, 0.58), vec2(0.17, 0.54), vec2( 0.18, 0.60 ), Res);\n    applyColor(vec3(0.41, 0.30, 0.12), col, uv, vec2(0.19, 0.61), vec2(0.17, 0.64), vec2( 0.19, 0.65 ), Res);\n    applyColor(vec3(0.31, 0.22, 0.12), col, uv, vec2(0.19, 0.65), vec2(0.17, 0.69), vec2( 0.18, 0.70 ), Res);\n    applyColor(vec3(0.69, 0.54, 0.35), col, uv, vec2(0.17, 0.54), vec2(0.15, 0.44), vec2( 0.14, 0.48 ), Res);\n    applyColor(vec3(0.46, 0.43, 0.39), col, uv, vec2(0.20, 0.93), vec2(0.18, 0.88), vec2( 0.16, 0.89 ), Res);\n    applyColor(vec3(0.18, 0.09, 0.06), col, uv, vec2(0.20, 0.63), vec2(0.19, 0.61), vec2( 0.19, 0.65 ), Res);\n    applyColor(vec3(0.16, 0.00, 0.00), col, uv, vec2(0.19, 0.71), vec2(0.18, 0.70), vec2( 0.17, 0.70 ), Res);\n    applyColor(vec3(0.78, 0.71, 0.65), col, uv, vec2(0.21, 0.90), vec2(0.18, 0.88), vec2( 0.20, 0.93 ), Res);\n    applyColor(vec3(0.04, 0.07, 0.08), col, uv, vec2(0.21, 0.61), vec2(0.19, 0.61), vec2( 0.20, 0.63 ), Res);\n    applyColor(vec3(0.44, 0.31, 0.21), col, uv, vec2(0.21, 0.61), vec2(0.19, 0.58), vec2( 0.19, 0.61 ), Res);\n    applyColor(vec3(0.71, 0.55, 0.26), col, uv, vec2(0.20, 0.57), vec2(0.17, 0.54), vec2( 0.19, 0.58 ), Res);\n    applyColor(vec3(0.67, 0.62, 0.61), col, uv, vec2(0.20, 0.05), vec2(0., 0.00), vec2( 0., 0.25 ), Res);\n    applyColor(vec3(0.75, 0.19, 0.16), col, uv, vec2(0.19, 0.71), vec2(0.17, 0.70), vec2( 0.14, 0.77 ), Res);\n    applyColor(vec3(0.42, 0.35, 0.28), col, uv, vec2(0.17, 0.32), vec2(0., 0.25), vec2( 0.15, 0.34 ), Res);\n    applyColor(vec3(0.39, 0.25, 0.06), col, uv, vec2(0.21, 0.66), vec2(0.19, 0.65), vec2( 0.19, 0.71 ), Res);\n    applyColor(vec3(0.47, 0.35, 0.07), col, uv, vec2(0.21, 0.66), vec2(0.20, 0.63), vec2( 0.19, 0.65 ), Res);\n    applyColor(vec3(0.78, 0.69, 0.60), col, uv, vec2(0.21, 0.90), vec2(0.18, 0.84), vec2( 0.18, 0.88 ), Res);\n    applyColor(vec3(0.56, 0.36, 0.20), col, uv, vec2(0.21, 0.61), vec2(0.20, 0.57), vec2( 0.19, 0.58 ), Res);\n    applyColor(vec3(0.53, 0.42, 0.43), col, uv, vec2(0.20, 0.05), vec2(0., 0.25), vec2( 0.17, 0.32 ), Res);\n    applyColor(vec3(0.39, 0.30, 0.15), col, uv, vec2(0.19, 0.71), vec2(0.19, 0.65), vec2( 0.18, 0.70 ), Res);\n    applyColor(vec3(0.77, 0.19, 0.14), col, uv, vec2(0.19, 0.71), vec2(0.15, 0.82), vec2( 0.18, 0.84 ), Res);\n    applyColor(vec3(0.70, 0.15, 0.13), col, uv, vec2(0.19, 0.71), vec2(0.14, 0.77), vec2( 0.15, 0.82 ), Res);\n    applyColor(vec3(0.25, 0.24, 0.24), col, uv, vec2(0.16, 0.89), vec2(0.15, 0.88), vec2( 0., 1. ), Res);\n    applyColor(vec3(0.69, 0.62, 0.54), col, uv, vec2(0.21, 0.90), vec2(0.21, 0.90), vec2( 0.20, 0.93 ), Res);\n    applyColor(vec3(0.64, 0.11, 0.08), col, uv, vec2(0.20, 0.72), vec2(0.19, 0.71), vec2( 0.18, 0.84 ), Res);\n    applyColor(vec3(0.18, 0.13, 0.13), col, uv, vec2(0.22, 0.94), vec2(0.22, 0.92), vec2( 0.20, 0.93 ), Res);\n    applyColor(vec3(0.45, 0.40, 0.37), col, uv, vec2(0.22, 0.92), vec2(0.21, 0.90), vec2( 0.20, 0.93 ), Res);\n    applyColor(vec3(0.32, 0.25, 0.18), col, uv, vec2(0.22, 0.89), vec2(0.21, 0.90), vec2( 0.21, 0.90 ), Res);\n    applyColor(vec3(0.60, 0.38, 0.11), col, uv, vec2(0.22, 0.68), vec2(0.21, 0.66), vec2( 0.20, 0.72 ), Res);\n    applyColor(vec3(0.11, 0.05, 0.06), col, uv, vec2(0.22, 0.63), vec2(0.21, 0.61), vec2( 0.20, 0.63 ), Res);\n    applyColor(vec3(0.26, 0.15, 0.04), col, uv, vec2(0.22, 0.63), vec2(0.20, 0.63), vec2( 0.21, 0.66 ), Res);\n    applyColor(vec3(0.71, 0.56, 0.35), col, uv, vec2(0.21, 0.66), vec2(0.19, 0.71), vec2( 0.20, 0.72 ), Res);\n    applyColor(vec3(0.14, 0.08, 0.03), col, uv, vec2(0.22, 0.64), vec2(0.22, 0.63), vec2( 0.21, 0.66 ), Res);\n    applyColor(vec3(0.58, 0.38, 0.22), col, uv, vec2(0.22, 0.59), vec2(0.20, 0.57), vec2( 0.21, 0.61 ), Res);\n    applyColor(vec3(0.47, 0.33, 0.12), col, uv, vec2(0.22, 0.59), vec2(0.22, 0.57), vec2( 0.20, 0.57 ), Res);\n    applyColor(vec3(0.32, 0.20, 0.14), col, uv, vec2(0.22, 0.59), vec2(0.21, 0.61), vec2( 0.22, 0.63 ), Res);\n    applyColor(vec3(0.59, 0.39, 0.16), col, uv, vec2(0.22, 0.57), vec2(0.22, 0.54), vec2( 0.20, 0.57 ), Res);\n    applyColor(vec3(0.73, 0.59, 0.36), col, uv, vec2(0.22, 0.54), vec2(0.17, 0.54), vec2( 0.20, 0.57 ), Res);\n    applyColor(vec3(0.70, 0.47, 0.22), col, uv, vec2(0.22, 0.54), vec2(0.22, 0.48), vec2( 0.17, 0.54 ), Res);\n    applyColor(vec3(0.47, 0.33, 0.24), col, uv, vec2(0.22, 0.48), vec2(0.15, 0.42), vec2( 0.15, 0.44 ), Res);\n    applyColor(vec3(0.66, 0.45, 0.21), col, uv, vec2(0.22, 0.48), vec2(0.15, 0.44), vec2( 0.17, 0.54 ), Res);\n    applyColor(vec3(0.36, 0.28, 0.16), col, uv, vec2(0.22, 0.41), vec2(0.18, 0.35), vec2( 0.17, 0.38 ), Res);\n    applyColor(vec3(0.38, 0.28, 0.22), col, uv, vec2(0.22, 0.41), vec2(0.17, 0.38), vec2( 0.15, 0.42 ), Res);\n    applyColor(vec3(0.36, 0.31, 0.27), col, uv, vec2(0.22, 0.15), vec2(0.20, 0.05), vec2( 0.17, 0.32 ), Res);\n    applyColor(vec3(0.38, 0.29, 0.22), col, uv, vec2(0.22, 0.27), vec2(0.17, 0.32), vec2( 0.18, 0.35 ), Res);\n    applyColor(vec3(0.47, 0.40, 0.27), col, uv, vec2(0.23, 0.45), vec2(0.22, 0.41), vec2( 0.22, 0.48 ), Res);\n    applyColor(vec3(0.99, 0.99, 0.98), col, uv, vec2(0.23, 0.10), vec2(0.22, 0.04), vec2( 0.20, 0.05 ), Res);\n    applyColor(vec3(0.25, 0.15, 0.12), col, uv, vec2(0.23, 0.10), vec2(0.20, 0.05), vec2( 0.22, 0.15 ), Res);\n    applyColor(vec3(0.27, 0.13, 0.07), col, uv, vec2(0.22, 0.64), vec2(0.21, 0.66), vec2( 0.22, 0.68 ), Res);\n    applyColor(vec3(0.44, 0.29, 0.13), col, uv, vec2(0.22, 0.48), vec2(0.22, 0.41), vec2( 0.15, 0.42 ), Res);\n    applyColor(vec3(0.55, 0.38, 0.30), col, uv, vec2(0.22, 0.15), vec2(0.17, 0.32), vec2( 0.22, 0.27 ), Res);\n    applyColor(vec3(0.76, 0.63, 0.46), col, uv, vec2(0.22, 0.89), vec2(0.18, 0.84), vec2( 0.21, 0.90 ), Res);\n    applyColor(vec3(0.25, 0.22, 0.16), col, uv, vec2(0.23, 0.94), vec2(0.22, 0.92), vec2( 0.22, 0.94 ), Res);\n    applyColor(vec3(0.65, 0.45, 0.15), col, uv, vec2(0.23, 0.67), vec2(0.22, 0.64), vec2( 0.22, 0.68 ), Res);\n    applyColor(vec3(0.67, 0.45, 0.26), col, uv, vec2(0.23, 0.59), vec2(0.22, 0.57), vec2( 0.22, 0.59 ), Res);\n    applyColor(vec3(0.54, 0.29, 0.12), col, uv, vec2(0.23, 0.51), vec2(0.22, 0.48), vec2( 0.22, 0.54 ), Res);\n    applyColor(vec3(0.67, 0.42, 0.25), col, uv, vec2(0.24, 0.57), vec2(0.22, 0.54), vec2( 0.22, 0.57 ), Res);\n    applyColor(vec3(0.96, 0.91, 0.81), col, uv, vec2(0.24, 0.57), vec2(0.22, 0.57), vec2( 0.23, 0.59 ), Res);\n    applyColor(vec3(0.24, 0.16, 0.13), col, uv, vec2(0.24, 0.19), vec2(0.22, 0.15), vec2( 0.22, 0.27 ), Res);\n    applyColor(vec3(0.68, 0.45, 0.25), col, uv, vec2(0.23, 0.59), vec2(0.22, 0.59), vec2( 0.22, 0.63 ), Res);\n    applyColor(vec3(0.69, 0.60, 0.61), col, uv, vec2(0.23, 0.10), vec2(0.23, 0.04), vec2( 0.22, 0.04 ), Res);\n    applyColor(vec3(0.10, 0.07, 0.03), col, uv, vec2(0.22, 0.92), vec2(0.22, 0.89), vec2( 0.21, 0.90 ), Res);\n    applyColor(vec3(0.00, 0.01, 0.04), col, uv, vec2(0.24, 0.54), vec2(0.23, 0.51), vec2( 0.22, 0.54 ), Res);\n    applyColor(vec3(0.18, 0.13, 0.09), col, uv, vec2(0.24, 0.54), vec2(0.22, 0.54), vec2( 0.24, 0.57 ), Res);\n    applyColor(vec3(0.82, 0.56, 0.55), col, uv, vec2(0.24, 0.06), vec2(0.23, 0.04), vec2( 0.23, 0.10 ), Res);\n    applyColor(vec3(0.22, 0.22, 0.24), col, uv, vec2(0.20, 0.93), vec2(0.16, 0.89), vec2( 0., 1. ), Res);\n    applyColor(vec3(0.28, 0.25, 0.33), col, uv, vec2(0.25, 1.), vec2(0.23, 0.94), vec2( 0.22, 0.94 ), Res);\n    applyColor(vec3(0.36, 0.32, 0.34), col, uv, vec2(0.25, 1.), vec2(0.22, 0.94), vec2( 0.20, 0.93 ), Res);\n    applyColor(vec3(0.98, 0.83, 0.79), col, uv, vec2(0.25, 0.00), vec2(0.22, 0.04), vec2( 0.23, 0.04 ), Res);\n    applyColor(vec3(0.73, 0.45, 0.22), col, uv, vec2(0.25, 0.57), vec2(0.24, 0.54), vec2( 0.24, 0.57 ), Res);\n    applyColor(vec3(0.42, 0.36, 0.26), col, uv, vec2(0.25, 0.49), vec2(0.23, 0.45), vec2( 0.22, 0.48 ), Res);\n    applyColor(vec3(0.16, 0.07, 0.05), col, uv, vec2(0.25, 0.49), vec2(0.22, 0.48), vec2( 0.23, 0.51 ), Res);\n    applyColor(vec3(0.16, 0.08, 0.11), col, uv, vec2(0.25, 0.49), vec2(0.23, 0.51), vec2( 0.24, 0.51 ), Res);\n    applyColor(vec3(0.43, 0.32, 0.28), col, uv, vec2(0.25, 0.27), vec2(0.22, 0.27), vec2( 0.24, 0.30 ), Res);\n    applyColor(vec3(0.83, 0.24, 0.20), col, uv, vec2(0.25, 0.05), vec2(0.23, 0.04), vec2( 0.24, 0.06 ), Res);\n    applyColor(vec3(0.25, 0.10, 0.07), col, uv, vec2(0.24, 0.54), vec2(0.24, 0.51), vec2( 0.23, 0.51 ), Res);\n    applyColor(vec3(0.54, 0.38, 0.27), col, uv, vec2(0.24, 0.38), vec2(0.18, 0.35), vec2( 0.22, 0.41 ), Res);\n    applyColor(vec3(0.42, 0.33, 0.21), col, uv, vec2(0.24, 0.38), vec2(0.24, 0.30), vec2( 0.18, 0.35 ), Res);\n    applyColor(vec3(0.35, 0.24, 0.21), col, uv, vec2(0.24, 0.30), vec2(0.22, 0.27), vec2( 0.18, 0.35 ), Res);\n    applyColor(vec3(0.73, 0.56, 0.26), col, uv, vec2(0.25, 0.70), vec2(0.22, 0.68), vec2( 0.20, 0.72 ), Res);\n    applyColor(vec3(0.76, 0.62, 0.20), col, uv, vec2(0.25, 0.70), vec2(0.23, 0.67), vec2( 0.22, 0.68 ), Res);\n    applyColor(vec3(0.35, 0.18, 0.17), col, uv, vec2(0.25, 0.00), vec2(0.23, 0.04), vec2( 0.25, 0.05 ), Res);\n    applyColor(vec3(0.84, 0.67, 0.35), col, uv, vec2(0.25, 0.57), vec2(0.24, 0.57), vec2( 0.23, 0.59 ), Res);\n    applyColor(vec3(0.62, 0.56, 0.47), col, uv, vec2(0.23, 0.94), vec2(0.22, 0.89), vec2( 0.22, 0.92 ), Res);\n    applyColor(vec3(0.56, 0.37, 0.18), col, uv, vec2(0.23, 0.59), vec2(0.22, 0.63), vec2( 0.22, 0.64 ), Res);\n    applyColor(vec3(0.85, 0.72, 0.45), col, uv, vec2(0.26, 0.75), vec2(0.25, 0.70), vec2( 0.20, 0.72 ), Res);\n    applyColor(vec3(0.55, 0.40, 0.16), col, uv, vec2(0.26, 0.50), vec2(0.25, 0.49), vec2( 0.24, 0.51 ), Res);\n    applyColor(vec3(0.30, 0.21, 0.16), col, uv, vec2(0.26, 0.44), vec2(0.22, 0.41), vec2( 0.23, 0.45 ), Res);\n    applyColor(vec3(0.33, 0.14, 0.07), col, uv, vec2(0.26, 0.44), vec2(0.26, 0.40), vec2( 0.22, 0.41 ), Res);\n    applyColor(vec3(0.00, 0.00, 0.00), col, uv, vec2(0.26, 0.40), vec2(0.24, 0.38), vec2( 0.22, 0.41 ), Res);\n    applyColor(vec3(0.41, 0.33, 0.30), col, uv, vec2(0.25, 0.27), vec2(0.24, 0.19), vec2( 0.22, 0.27 ), Res);\n    applyColor(vec3(0.20, 0.15, 0.12), col, uv, vec2(0.26, 0.90), vec2(0.22, 0.89), vec2( 0.23, 0.94 ), Res);\n    applyColor(vec3(0.74, 0.59, 0.53), col, uv, vec2(0.26, 0.38), vec2(0.24, 0.38), vec2( 0.26, 0.40 ), Res);\n    applyColor(vec3(0.15, 0.12, 0.05), col, uv, vec2(0.26, 0.30), vec2(0.25, 0.27), vec2( 0.24, 0.30 ), Res);\n    applyColor(vec3(0.65, 0.11, 0.08), col, uv, vec2(0.26, 0.75), vec2(0.20, 0.72), vec2( 0.18, 0.84 ), Res);\n    applyColor(vec3(0.31, 0.15, 0.08), col, uv, vec2(0.26, 0.44), vec2(0.23, 0.45), vec2( 0.25, 0.49 ), Res);\n    applyColor(vec3(0.37, 0.06, 0.04), col, uv, vec2(0.26, 0.05), vec2(0.25, 0.00), vec2( 0.25, 0.05 ), Res);\n    applyColor(vec3(0.10, 0.07, 0.12), col, uv, vec2(0.26, 0.05), vec2(0.25, 0.05), vec2( 0.24, 0.06 ), Res);\n    applyColor(vec3(0.29, 0.16, 0.08), col, uv, vec2(0.27, 0.51), vec2(0.24, 0.51), vec2( 0.24, 0.54 ), Res);\n    applyColor(vec3(0.61, 0.44, 0.23), col, uv, vec2(0.27, 0.51), vec2(0.26, 0.50), vec2( 0.24, 0.51 ), Res);\n    applyColor(vec3(0.27, 0.22, 0.21), col, uv, vec2(0.27, 0.25), vec2(0.27, 0.24), vec2( 0.25, 0.27 ), Res);\n    applyColor(vec3(0.37, 0.27, 0.24), col, uv, vec2(0.27, 0.24), vec2(0.24, 0.19), vec2( 0.25, 0.27 ), Res);\n    applyColor(vec3(0.32, 0.21, 0.18), col, uv, vec2(0.26, 0.38), vec2(0.24, 0.30), vec2( 0.24, 0.38 ), Res);\n    applyColor(vec3(0.77, 0.17, 0.12), col, uv, vec2(0.26, 0.75), vec2(0.18, 0.84), vec2( 0.22, 0.89 ), Res);\n    applyColor(vec3(0.70, 0.62, 0.64), col, uv, vec2(0.25, 0.00), vec2(0.20, 0.05), vec2( 0.22, 0.04 ), Res);\n    applyColor(vec3(0.81, 0.71, 0.54), col, uv, vec2(0.27, 0.76), vec2(0.27, 0.73), vec2( 0.26, 0.75 ), Res);\n    applyColor(vec3(0.44, 0.31, 0.11), col, uv, vec2(0.27, 0.73), vec2(0.25, 0.70), vec2( 0.26, 0.75 ), Res);\n    applyColor(vec3(0.61, 0.37, 0.15), col, uv, vec2(0.27, 0.67), vec2(0.23, 0.67), vec2( 0.25, 0.70 ), Res);\n    applyColor(vec3(0.56, 0.32, 0.07), col, uv, vec2(0.27, 0.54), vec2(0.24, 0.54), vec2( 0.25, 0.57 ), Res);\n    applyColor(vec3(0.64, 0.41, 0.18), col, uv, vec2(0.27, 0.54), vec2(0.27, 0.51), vec2( 0.24, 0.54 ), Res);\n    applyColor(vec3(0.32, 0.22, 0.19), col, uv, vec2(0.27, 0.19), vec2(0.24, 0.19), vec2( 0.27, 0.24 ), Res);\n    applyColor(vec3(0.11, 0.10, 0.09), col, uv, vec2(0.27, 0.25), vec2(0.25, 0.27), vec2( 0.26, 0.30 ), Res);\n    applyColor(vec3(0.27, 0.18, 0.17), col, uv, vec2(0.26, 0.38), vec2(0.26, 0.30), vec2( 0.24, 0.30 ), Res);\n    applyColor(vec3(0.10, 0.09, 0.02), col, uv, vec2(0.28, 0.92), vec2(0.26, 0.90), vec2( 0.23, 0.94 ), Res);\n    applyColor(vec3(0.43, 0.25, 0.10), col, uv, vec2(0.28, 0.71), vec2(0.27, 0.67), vec2( 0.25, 0.70 ), Res);\n    applyColor(vec3(0.40, 0.28, 0.00), col, uv, vec2(0.28, 0.71), vec2(0.25, 0.70), vec2( 0.27, 0.73 ), Res);\n    applyColor(vec3(0.30, 0.22, 0.10), col, uv, vec2(0.28, 0.57), vec2(0.27, 0.54), vec2( 0.25, 0.57 ), Res);\n    applyColor(vec3(0.44, 0.24, 0.16), col, uv, vec2(0.26, 0.50), vec2(0.26, 0.44), vec2( 0.25, 0.49 ), Res);\n    applyColor(vec3(0.87, 0.75, 0.55), col, uv, vec2(0.23, 0.67), vec2(0.23, 0.59), vec2( 0.22, 0.64 ), Res);\n    applyColor(vec3(0.36, 0.23, 0.07), col, uv, vec2(0.28, 0.67), vec2(0.27, 0.67), vec2( 0.28, 0.71 ), Res);\n    applyColor(vec3(0.29, 0.29, 0.27), col, uv, vec2(0.28, 0.92), vec2(0.23, 0.94), vec2( 0.25, 1. ), Res);\n    applyColor(vec3(0.98, 0.89, 0.76), col, uv, vec2(0.28, 0.57), vec2(0.25, 0.57), vec2( 0.23, 0.59 ), Res);\n    applyColor(vec3(0.93, 0.80, 0.55), col, uv, vec2(0.28, 0.57), vec2(0.23, 0.59), vec2( 0.27, 0.67 ), Res);\n    applyColor(vec3(0.39, 0.21, 0.08), col, uv, vec2(0.28, 0.37), vec2(0.26, 0.30), vec2( 0.26, 0.38 ), Res);\n    applyColor(vec3(0.94, 0.84, 0.59), col, uv, vec2(0.27, 0.67), vec2(0.23, 0.59), vec2( 0.23, 0.67 ), Res);\n    applyColor(vec3(0.32, 0.22, 0.21), col, uv, vec2(0.27, 0.19), vec2(0.22, 0.15), vec2( 0.24, 0.19 ), Res);\n    applyColor(vec3(0.26, 0.22, 0.27), col, uv, vec2(0.25, 1.), vec2(0.20, 0.93), vec2( 0., 1. ), Res);\n    applyColor(vec3(0.44, 0.36, 0.28), col, uv, vec2(0.29, 0.87), vec2(0.26, 0.90), vec2( 0.28, 0.92 ), Res);\n    applyColor(vec3(0.81, 0.69, 0.58), col, uv, vec2(0.29, 0.64), vec2(0.28, 0.57), vec2( 0.27, 0.67 ), Res);\n    applyColor(vec3(0.70, 0.58, 0.29), col, uv, vec2(0.29, 0.64), vec2(0.27, 0.67), vec2( 0.28, 0.67 ), Res);\n    applyColor(vec3(0.58, 0.40, 0.25), col, uv, vec2(0.29, 0.51), vec2(0.27, 0.51), vec2( 0.27, 0.54 ), Res);\n    applyColor(vec3(0.20, 0.08, 0.07), col, uv, vec2(0.29, 0.34), vec2(0.26, 0.30), vec2( 0.28, 0.37 ), Res);\n    applyColor(vec3(0.53, 0.27, 0.20), col, uv, vec2(0.28, 0.37), vec2(0.26, 0.38), vec2( 0.26, 0.40 ), Res);\n    applyColor(vec3(0.70, 0.10, 0.09), col, uv, vec2(0.27, 0.76), vec2(0.26, 0.75), vec2( 0.26, 0.90 ), Res);\n    applyColor(vec3(0.38, 0.27, 0.18), col, uv, vec2(0.27, 0.19), vec2(0.23, 0.10), vec2( 0.22, 0.15 ), Res);\n    applyColor(vec3(0.85, 0.25, 0.15), col, uv, vec2(0.26, 0.90), vec2(0.26, 0.75), vec2( 0.22, 0.89 ), Res);\n    applyColor(vec3(0.34, 0.22, 0.12), col, uv, vec2(0.30, 0.68), vec2(0.28, 0.67), vec2( 0.28, 0.71 ), Res);\n    applyColor(vec3(0.85, 0.72, 0.54), col, uv, vec2(0.30, 0.62), vec2(0.28, 0.57), vec2( 0.29, 0.64 ), Res);\n    applyColor(vec3(0.80, 0.20, 0.12), col, uv, vec2(0.29, 0.87), vec2(0.27, 0.76), vec2( 0.26, 0.90 ), Res);\n    applyColor(vec3(0.84, 0.71, 0.54), col, uv, vec2(0.30, 0.64), vec2(0.30, 0.62), vec2( 0.29, 0.64 ), Res);\n    applyColor(vec3(0.89, 0.72, 0.60), col, uv, vec2(0.30, 0.50), vec2(0.26, 0.50), vec2( 0.27, 0.51 ), Res);\n    applyColor(vec3(0.54, 0.37, 0.20), col, uv, vec2(0.30, 0.50), vec2(0.27, 0.51), vec2( 0.29, 0.51 ), Res);\n    applyColor(vec3(0.73, 0.62, 0.42), col, uv, vec2(0.30, 0.68), vec2(0.29, 0.64), vec2( 0.28, 0.67 ), Res);\n    applyColor(vec3(0.63, 0.42, 0.33), col, uv, vec2(0.31, 0.42), vec2(0.26, 0.40), vec2( 0.26, 0.44 ), Res);\n    applyColor(vec3(0.85, 0.76, 0.55), col, uv, vec2(0.31, 0.88), vec2(0.30, 0.86), vec2( 0.29, 0.87 ), Res);\n    applyColor(vec3(0.81, 0.60, 0.44), col, uv, vec2(0.31, 0.42), vec2(0.28, 0.37), vec2( 0.26, 0.40 ), Res);\n    applyColor(vec3(0.72, 0.45, 0.28), col, uv, vec2(0.31, 0.42), vec2(0.31, 0.38), vec2( 0.28, 0.37 ), Res);\n    applyColor(vec3(0.22, 0.10, 0.04), col, uv, vec2(0.31, 0.38), vec2(0.29, 0.34), vec2( 0.28, 0.37 ), Res);\n    applyColor(vec3(0.56, 0.38, 0.21), col, uv, vec2(0.30, 0.64), vec2(0.29, 0.64), vec2( 0.30, 0.68 ), Res);\n    applyColor(vec3(0.59, 0.35, 0.12), col, uv, vec2(0.30, 0.50), vec2(0.26, 0.44), vec2( 0.26, 0.50 ), Res);\n    applyColor(vec3(0.24, 0.15, 0.07), col, uv, vec2(0.30, 0.16), vec2(0.24, 0.06), vec2( 0.23, 0.10 ), Res);\n    applyColor(vec3(0.38, 0.28, 0.20), col, uv, vec2(0.30, 0.16), vec2(0.23, 0.10), vec2( 0.27, 0.19 ), Res);\n    applyColor(vec3(0.58, 0.45, 0.31), col, uv, vec2(0.31, 0.65), vec2(0.30, 0.64), vec2( 0.30, 0.68 ), Res);\n    applyColor(vec3(0.47, 0.31, 0.13), col, uv, vec2(0.31, 0.44), vec2(0.26, 0.44), vec2( 0.30, 0.50 ), Res);\n    applyColor(vec3(0.27, 0.17, 0.15), col, uv, vec2(0.31, 0.44), vec2(0.31, 0.42), vec2( 0.26, 0.44 ), Res);\n    applyColor(vec3(0.67, 0.47, 0.27), col, uv, vec2(0.31, 0.35), vec2(0.29, 0.34), vec2( 0.31, 0.38 ), Res);\n    applyColor(vec3(0.17, 0.15, 0.06), col, uv, vec2(0.31, 0.88), vec2(0.29, 0.87), vec2( 0.28, 0.92 ), Res);\n    applyColor(vec3(0.81, 0.18, 0.13), col, uv, vec2(0.30, 0.86), vec2(0.27, 0.76), vec2( 0.29, 0.87 ), Res);\n    applyColor(vec3(0.22, 0.13, 0.08), col, uv, vec2(0.30, 0.16), vec2(0.26, 0.05), vec2( 0.24, 0.06 ), Res);\n    applyColor(vec3(0.60, 0.44, 0.32), col, uv, vec2(0.29, 0.51), vec2(0.27, 0.54), vec2( 0.28, 0.57 ), Res);\n    applyColor(vec3(0.63, 0.54, 0.31), col, uv, vec2(0.32, 0.75), vec2(0.27, 0.73), vec2( 0.27, 0.76 ), Res);\n    applyColor(vec3(0.78, 0.66, 0.37), col, uv, vec2(0.32, 0.75), vec2(0.28, 0.71), vec2( 0.27, 0.73 ), Res);\n    applyColor(vec3(0.64, 0.53, 0.31), col, uv, vec2(0.32, 0.50), vec2(0.32, 0.48), vec2( 0.30, 0.50 ), Res);\n    applyColor(vec3(0.71, 0.54, 0.32), col, uv, vec2(0.32, 0.48), vec2(0.32, 0.45), vec2( 0.30, 0.50 ), Res);\n    applyColor(vec3(0.54, 0.26, 0.09), col, uv, vec2(0.32, 0.45), vec2(0.31, 0.44), vec2( 0.30, 0.50 ), Res);\n    applyColor(vec3(0.74, 0.44, 0.27), col, uv, vec2(0.32, 0.39), vec2(0.31, 0.38), vec2( 0.31, 0.42 ), Res);\n    applyColor(vec3(0.35, 0.29, 0.16), col, uv, vec2(0.32, 0.86), vec2(0.30, 0.86), vec2( 0.31, 0.88 ), Res);\n    applyColor(vec3(0.70, 0.46, 0.55), col, uv, vec2(0.32, 0.86), vec2(0.32, 0.84), vec2( 0.30, 0.86 ), Res);\n    applyColor(vec3(0.76, 0.21, 0.19), col, uv, vec2(0.32, 0.84), vec2(0.32, 0.80), vec2( 0.30, 0.86 ), Res);\n    applyColor(vec3(0.77, 0.15, 0.15), col, uv, vec2(0.32, 0.80), vec2(0.27, 0.76), vec2( 0.30, 0.86 ), Res);\n    applyColor(vec3(0.73, 0.09, 0.07), col, uv, vec2(0.32, 0.80), vec2(0.32, 0.75), vec2( 0.27, 0.76 ), Res);\n    applyColor(vec3(0.76, 0.59, 0.32), col, uv, vec2(0.32, 0.75), vec2(0.30, 0.68), vec2( 0.28, 0.71 ), Res);\n    applyColor(vec3(0.20, 0.13, 0.15), col, uv, vec2(0.29, 0.34), vec2(0.27, 0.25), vec2( 0.26, 0.30 ), Res);\n    applyColor(vec3(0.72, 0.60, 0.80), col, uv, vec2(0.33, 0.78), vec2(0.32, 0.75), vec2( 0.32, 0.80 ), Res);\n    applyColor(vec3(0.57, 0.40, 0.24), col, uv, vec2(0.33, 0.69), vec2(0.31, 0.65), vec2( 0.30, 0.68 ), Res);\n    applyColor(vec3(0.87, 0.75, 0.61), col, uv, vec2(0.33, 0.69), vec2(0.33, 0.67), vec2( 0.31, 0.65 ), Res);\n    applyColor(vec3(0.29, 0.16, 0.02), col, uv, vec2(0.33, 0.69), vec2(0.30, 0.68), vec2( 0.32, 0.75 ), Res);\n    applyColor(vec3(0.59, 0.43, 0.27), col, uv, vec2(0.32, 0.50), vec2(0.30, 0.50), vec2( 0.29, 0.51 ), Res);\n    applyColor(vec3(0.45, 0.24, 0.01), col, uv, vec2(0.32, 0.39), vec2(0.31, 0.35), vec2( 0.31, 0.38 ), Res);\n    applyColor(vec3(0.25, 0.18, 0.08), col, uv, vec2(0.33, 0.85), vec2(0.32, 0.84), vec2( 0.32, 0.86 ), Res);\n    applyColor(vec3(0.58, 0.36, 0.54), col, uv, vec2(0.33, 0.81), vec2(0.32, 0.80), vec2( 0.32, 0.84 ), Res);\n    applyColor(vec3(0.80, 0.09, 0.00), col, uv, vec2(0.33, 0.75), vec2(0.32, 0.75), vec2( 0.33, 0.78 ), Res);\n    applyColor(vec3(0.53, 0.13, 0.04), col, uv, vec2(0.33, 0.75), vec2(0.33, 0.73), vec2( 0.32, 0.75 ), Res);\n    applyColor(vec3(0.82, 0.67, 0.35), col, uv, vec2(0.33, 0.73), vec2(0.33, 0.69), vec2( 0.32, 0.75 ), Res);\n    applyColor(vec3(0.56, 0.40, 0.16), col, uv, vec2(0.33, 0.48), vec2(0.32, 0.48), vec2( 0.32, 0.50 ), Res);\n    applyColor(vec3(0.75, 0.58, 0.34), col, uv, vec2(0.33, 0.48), vec2(0.32, 0.45), vec2( 0.32, 0.48 ), Res);\n    applyColor(vec3(0.87, 0.73, 0.71), col, uv, vec2(0.32, 0.39), vec2(0.31, 0.42), vec2( 0.31, 0.44 ), Res);\n    applyColor(vec3(0.64, 0.42, 0.20), col, uv, vec2(0.31, 0.65), vec2(0.30, 0.62), vec2( 0.30, 0.64 ), Res);\n    applyColor(vec3(0.22, 0.12, 0.07), col, uv, vec2(0.34, 0.08), vec2(0.26, 0.05), vec2( 0.30, 0.16 ), Res);\n    applyColor(vec3(0.00, 0.13, 0.71), col, uv, vec2(0.33, 0.81), vec2(0.33, 0.78), vec2( 0.32, 0.80 ), Res);\n    applyColor(vec3(0.47, 0.68, 1.00), col, uv, vec2(0.34, 0.77), vec2(0.33, 0.75), vec2( 0.33, 0.78 ), Res);\n    applyColor(vec3(0.86, 0.69, 0.39), col, uv, vec2(0.34, 0.72), vec2(0.33, 0.69), vec2( 0.33, 0.73 ), Res);\n    applyColor(vec3(0.73, 0.42, 0.18), col, uv, vec2(0.30, 0.62), vec2(0.29, 0.51), vec2( 0.28, 0.57 ), Res);\n    applyColor(vec3(0.18, 0.14, 0.13), col, uv, vec2(0.35, 0.86), vec2(0.35, 0.84), vec2( 0.33, 0.85 ), Res);\n    applyColor(vec3(0.47, 0.35, 0.26), col, uv, vec2(0.35, 0.84), vec2(0.33, 0.81), vec2( 0.33, 0.85 ), Res);\n    applyColor(vec3(0.69, 0.37, 0.31), col, uv, vec2(0.35, 0.84), vec2(0.35, 0.82), vec2( 0.33, 0.81 ), Res);\n    applyColor(vec3(0.79, 0.64, 0.40), col, uv, vec2(0.35, 0.36), vec2(0.31, 0.35), vec2( 0.32, 0.39 ), Res);\n    applyColor(vec3(0.80, 0.64, 0.33), col, uv, vec2(0.35, 0.36), vec2(0.34, 0.33), vec2( 0.31, 0.35 ), Res);\n    applyColor(vec3(0.40, 0.45, 0.87), col, uv, vec2(0.34, 0.77), vec2(0.33, 0.78), vec2( 0.33, 0.81 ), Res);\n    applyColor(vec3(0.59, 0.23, 0.11), col, uv, vec2(0.34, 0.72), vec2(0.33, 0.73), vec2( 0.33, 0.75 ), Res);\n    applyColor(vec3(0.78, 0.25, 0.26), col, uv, vec2(0.33, 0.85), vec2(0.33, 0.81), vec2( 0.32, 0.84 ), Res);\n    applyColor(vec3(0.24, 0.15, 0.03), col, uv, vec2(0.30, 0.16), vec2(0.27, 0.19), vec2( 0.27, 0.24 ), Res);\n    applyColor(vec3(0.15, 0.08, 0.05), col, uv, vec2(0.35, 0.04), vec2(0.26, 0.05), vec2( 0.34, 0.08 ), Res);\n    applyColor(vec3(0.08, 0.06, 0.11), col, uv, vec2(0.35, 0.86), vec2(0.33, 0.85), vec2( 0.32, 0.86 ), Res);\n    applyColor(vec3(0.95, 0.78, 0.86), col, uv, vec2(0.35, 0.82), vec2(0.34, 0.77), vec2( 0.33, 0.81 ), Res);\n    applyColor(vec3(0.95, 0.86, 0.66), col, uv, vec2(0.32, 0.50), vec2(0.29, 0.51), vec2( 0.30, 0.62 ), Res);\n    applyColor(vec3(0.72, 0.59, 0.36), col, uv, vec2(0.36, 0.35), vec2(0.34, 0.33), vec2( 0.35, 0.36 ), Res);\n    applyColor(vec3(0.20, 0.14, 0.05), col, uv, vec2(0.35, 0.04), vec2(0.25, 0.00), vec2( 0.26, 0.05 ), Res);\n    applyColor(vec3(0.28, 0.16, 0.02), col, uv, vec2(0.34, 0.33), vec2(0.27, 0.25), vec2( 0.29, 0.34 ), Res);\n    applyColor(vec3(0.87, 0.75, 0.59), col, uv, vec2(0.34, 0.33), vec2(0.29, 0.34), vec2( 0.31, 0.35 ), Res);\n    applyColor(vec3(0.80, 0.16, 0.17), col, uv, vec2(0.36, 0.74), vec2(0.34, 0.72), vec2( 0.33, 0.75 ), Res);\n    applyColor(vec3(0.61, 0.04, 0.03), col, uv, vec2(0.36, 0.74), vec2(0.33, 0.75), vec2( 0.34, 0.77 ), Res);\n    applyColor(vec3(0.55, 0.43, 0.43), col, uv, vec2(0.25, 0.00), vec2(0., 0.00), vec2( 0.20, 0.05 ), Res);\n    applyColor(vec3(0.93, 0.29, 0.21), col, uv, vec2(0.37, 0.80), vec2(0.34, 0.77), vec2( 0.35, 0.82 ), Res);\n    applyColor(vec3(0.20, 0.17, 0.12), col, uv, vec2(0.35, 0.86), vec2(0.32, 0.86), vec2( 0.31, 0.88 ), Res);\n    applyColor(vec3(0.89, 0.77, 0.73), col, uv, vec2(0.32, 0.45), vec2(0.32, 0.39), vec2( 0.31, 0.44 ), Res);\n    applyColor(vec3(0.29, 0.17, 0.07), col, uv, vec2(0.37, 0.27), vec2(0.30, 0.16), vec2( 0.27, 0.25 ), Res);\n    applyColor(vec3(0.05, 0.04, 0.05), col, uv, vec2(0.37, 0.27), vec2(0.27, 0.25), vec2( 0.34, 0.33 ), Res);\n    applyColor(vec3(0.29, 0.19, 0.09), col, uv, vec2(0.30, 0.16), vec2(0.27, 0.24), vec2( 0.27, 0.25 ), Res);\n    applyColor(vec3(0.83, 0.20, 0.08), col, uv, vec2(0.38, 0.70), vec2(0.34, 0.72), vec2( 0.36, 0.74 ), Res);\n    applyColor(vec3(0.78, 0.59, 0.29), col, uv, vec2(0.38, 0.70), vec2(0.33, 0.67), vec2( 0.33, 0.69 ), Res);\n    applyColor(vec3(0.83, 0.64, 0.34), col, uv, vec2(0.38, 0.70), vec2(0.38, 0.65), vec2( 0.33, 0.67 ), Res);\n    applyColor(vec3(0.74, 0.58, 0.29), col, uv, vec2(0.38, 0.70), vec2(0.33, 0.69), vec2( 0.34, 0.72 ), Res);\n    applyColor(vec3(0.37, 0.24, 0.07), col, uv, vec2(0.38, 0.15), vec2(0.34, 0.08), vec2( 0.30, 0.16 ), Res);\n    applyColor(vec3(0.44, 0.33, 0.13), col, uv, vec2(0.37, 0.36), vec2(0.36, 0.35), vec2( 0.35, 0.36 ), Res);\n    applyColor(vec3(0.17, 0.15, 0.18), col, uv, vec2(0.37, 0.80), vec2(0.35, 0.82), vec2( 0.35, 0.84 ), Res);\n    applyColor(vec3(0.80, 0.20, 0.13), col, uv, vec2(0.37, 0.80), vec2(0.36, 0.74), vec2( 0.34, 0.77 ), Res);\n    applyColor(vec3(0.37, 0.33, 0.27), col, uv, vec2(0.38, 0.82), vec2(0.37, 0.80), vec2( 0.35, 0.84 ), Res);\n    applyColor(vec3(0.76, 0.61, 0.27), col, uv, vec2(0.38, 0.63), vec2(0.33, 0.67), vec2( 0.38, 0.65 ), Res);\n    applyColor(vec3(0.82, 0.67, 0.32), col, uv, vec2(0.38, 0.63), vec2(0.38, 0.60), vec2( 0.33, 0.67 ), Res);\n    applyColor(vec3(0.93, 0.82, 0.59), col, uv, vec2(0.38, 0.60), vec2(0.31, 0.65), vec2( 0.33, 0.67 ), Res);\n    applyColor(vec3(0.98, 0.93, 0.80), col, uv, vec2(0.38, 0.60), vec2(0.30, 0.62), vec2( 0.31, 0.65 ), Res);\n    applyColor(vec3(0.93, 0.84, 0.64), col, uv, vec2(0.38, 0.60), vec2(0.32, 0.50), vec2( 0.30, 0.62 ), Res);\n    applyColor(vec3(0.28, 0.22, 0.13), col, uv, vec2(0.38, 0.07), vec2(0.35, 0.04), vec2( 0.34, 0.08 ), Res);\n    applyColor(vec3(0.24, 0.16, 0.11), col, uv, vec2(0.37, 0.27), vec2(0.34, 0.33), vec2( 0.36, 0.35 ), Res);\n    applyColor(vec3(0.62, 0.46, 0.35), col, uv, vec2(0.33, 0.48), vec2(0.32, 0.39), vec2( 0.32, 0.45 ), Res);\n    applyColor(vec3(0.37, 0.00, 0.00), col, uv, vec2(0.38, 0.07), vec2(0.34, 0.08), vec2( 0.38, 0.15 ), Res);\n    applyColor(vec3(0.44, 0.31, 0.02), col, uv, vec2(0.38, 0.15), vec2(0.30, 0.16), vec2( 0.37, 0.27 ), Res);\n    applyColor(vec3(0.77, 0.61, 0.29), col, uv, vec2(0.35, 0.36), vec2(0.32, 0.39), vec2( 0.33, 0.48 ), Res);\n    applyColor(vec3(0.30, 0.26, 0.29), col, uv, vec2(0.39, 0.84), vec2(0.38, 0.82), vec2( 0.35, 0.86 ), Res);\n    applyColor(vec3(0.90, 0.35, 0.38), col, uv, vec2(0.39, 0.76), vec2(0.36, 0.74), vec2( 0.37, 0.80 ), Res);\n    applyColor(vec3(0.70, 0.38, 0.39), col, uv, vec2(0.39, 0.76), vec2(0.39, 0.74), vec2( 0.36, 0.74 ), Res);\n    applyColor(vec3(0.76, 0.16, 0.09), col, uv, vec2(0.39, 0.74), vec2(0.38, 0.70), vec2( 0.36, 0.74 ), Res);\n    applyColor(vec3(0.24, 0.13, 0.02), col, uv, vec2(0.39, 0.61), vec2(0.38, 0.60), vec2( 0.38, 0.63 ), Res);\n    applyColor(vec3(0.24, 0.15, 0.09), col, uv, vec2(0.39, 0.33), vec2(0.37, 0.27), vec2( 0.36, 0.35 ), Res);\n    applyColor(vec3(0.55, 0.39, 0.23), col, uv, vec2(0.39, 0.33), vec2(0.36, 0.35), vec2( 0.37, 0.36 ), Res);\n    applyColor(vec3(0.35, 0.31, 0.29), col, uv, vec2(0.38, 0.82), vec2(0.35, 0.84), vec2( 0.35, 0.86 ), Res);\n    applyColor(vec3(0.88, 0.75, 0.41), col, uv, vec2(0.38, 0.60), vec2(0.33, 0.48), vec2( 0.32, 0.50 ), Res);\n    applyColor(vec3(0.85, 0.68, 0.44), col, uv, vec2(0.40, 0.79), vec2(0.37, 0.80), vec2( 0.38, 0.82 ), Res);\n    applyColor(vec3(0.38, 0.27, 0.24), col, uv, vec2(0.40, 0.79), vec2(0.39, 0.76), vec2( 0.37, 0.80 ), Res);\n    applyColor(vec3(0.70, 0.17, 0.15), col, uv, vec2(0.40, 0.70), vec2(0.38, 0.70), vec2( 0.39, 0.74 ), Res);\n    applyColor(vec3(0.77, 0.61, 0.18), col, uv, vec2(0.40, 0.57), vec2(0.33, 0.48), vec2( 0.38, 0.60 ), Res);\n    applyColor(vec3(0.40, 0.32, 0.27), col, uv, vec2(0.39, 0.33), vec2(0.39, 0.27), vec2( 0.37, 0.27 ), Res);\n    applyColor(vec3(0.68, 0.53, 0.18), col, uv, vec2(0.37, 0.36), vec2(0.35, 0.36), vec2( 0.33, 0.48 ), Res);\n    applyColor(vec3(1.00, 0.98, 0.91), col, uv, vec2(0.40, 0.81), vec2(0.38, 0.82), vec2( 0.39, 0.84 ), Res);\n    applyColor(vec3(0.67, 0.46, 0.33), col, uv, vec2(0.40, 0.81), vec2(0.40, 0.79), vec2( 0.38, 0.82 ), Res);\n    applyColor(vec3(0.46, 0.08, 0.03), col, uv, vec2(0.40, 0.64), vec2(0.38, 0.63), vec2( 0.38, 0.65 ), Res);\n    applyColor(vec3(0.67, 0.35, 0.17), col, uv, vec2(0.40, 0.64), vec2(0.39, 0.61), vec2( 0.38, 0.63 ), Res);\n    applyColor(vec3(0.68, 0.46, 0.15), col, uv, vec2(0.40, 0.53), vec2(0.33, 0.48), vec2( 0.40, 0.57 ), Res);\n    applyColor(vec3(0.70, 0.54, 0.25), col, uv, vec2(0.40, 0.53), vec2(0.40, 0.49), vec2( 0.33, 0.48 ), Res);\n    applyColor(vec3(0.69, 0.17, 0.11), col, uv, vec2(0.40, 0.70), vec2(0.38, 0.65), vec2( 0.38, 0.70 ), Res);\n    applyColor(vec3(0.57, 0.33, 0.08), col, uv, vec2(0.40, 0.57), vec2(0.38, 0.60), vec2( 0.39, 0.61 ), Res);\n    applyColor(vec3(0.91, 0.79, 0.45), col, uv, vec2(0.41, 0.61), vec2(0.39, 0.61), vec2( 0.40, 0.64 ), Res);\n    applyColor(vec3(0.59, 0.34, 0.09), col, uv, vec2(0.41, 0.56), vec2(0.40, 0.53), vec2( 0.40, 0.57 ), Res);\n    applyColor(vec3(0.67, 0.45, 0.27), col, uv, vec2(0.41, 0.44), vec2(0.37, 0.36), vec2( 0.33, 0.48 ), Res);\n    applyColor(vec3(0.67, 0.53, 0.22), col, uv, vec2(0.41, 0.44), vec2(0.33, 0.48), vec2( 0.40, 0.49 ), Res);\n    applyColor(vec3(0.60, 0.09, 0.06), col, uv, vec2(0.40, 0.64), vec2(0.38, 0.65), vec2( 0.40, 0.70 ), Res);\n    applyColor(vec3(0.41, 0.30, 0.15), col, uv, vec2(0.41, 0.42), vec2(0.37, 0.36), vec2( 0.41, 0.44 ), Res);\n    applyColor(vec3(0.69, 0.46, 0.20), col, uv, vec2(0.41, 0.61), vec2(0.40, 0.57), vec2( 0.39, 0.61 ), Res);\n    applyColor(vec3(0.66, 0.44, 0.35), col, uv, vec2(0.39, 0.27), vec2(0.38, 0.15), vec2( 0.37, 0.27 ), Res);\n    applyColor(vec3(0.97, 0.90, 0.81), col, uv, vec2(0.42, 0.82), vec2(0.40, 0.81), vec2( 0.39, 0.84 ), Res);\n    applyColor(vec3(0.95, 0.84, 0.76), col, uv, vec2(0.42, 0.74), vec2(0.40, 0.70), vec2( 0.39, 0.74 ), Res);\n    applyColor(vec3(0.38, 0.30, 0.29), col, uv, vec2(0.42, 0.74), vec2(0.39, 0.74), vec2( 0.39, 0.76 ), Res);\n    applyColor(vec3(0.38, 0.17, 0.02), col, uv, vec2(0.42, 0.57), vec2(0.41, 0.56), vec2( 0.40, 0.57 ), Res);\n    applyColor(vec3(0.79, 0.62, 0.23), col, uv, vec2(0.42, 0.57), vec2(0.40, 0.57), vec2( 0.41, 0.61 ), Res);\n    applyColor(vec3(0.70, 0.55, 0.30), col, uv, vec2(0.41, 0.27), vec2(0.39, 0.27), vec2( 0.39, 0.33 ), Res);\n    applyColor(vec3(0.22, 0.22, 0.23), col, uv, vec2(0.42, 0.97), vec2(0.31, 0.88), vec2( 0.28, 0.92 ), Res);\n    applyColor(vec3(0.29, 0.26, 0.25), col, uv, vec2(0.42, 0.97), vec2(0.35, 0.86), vec2( 0.31, 0.88 ), Res);\n    applyColor(vec3(0.64, 0.44, 0.32), col, uv, vec2(0.42, 0.71), vec2(0.40, 0.70), vec2( 0.42, 0.74 ), Res);\n    applyColor(vec3(0.35, 0.14, 0.01), col, uv, vec2(0.42, 0.61), vec2(0.42, 0.57), vec2( 0.41, 0.61 ), Res);\n    applyColor(vec3(0.78, 0.76, 0.88), col, uv, vec2(0.42, 0.09), vec2(0.38, 0.07), vec2( 0.38, 0.15 ), Res);\n    applyColor(vec3(1.00, 1.00, 1.00), col, uv, vec2(0.42, 0.09), vec2(0.42, 0.06), vec2( 0.38, 0.07 ), Res);\n    applyColor(vec3(0.36, 0.25, 0.14), col, uv, vec2(0.41, 0.42), vec2(0.39, 0.33), vec2( 0.37, 0.36 ), Res);\n    applyColor(vec3(0.30, 0.18, 0.14), col, uv, vec2(0.42, 0.67), vec2(0.40, 0.64), vec2( 0.40, 0.70 ), Res);\n    applyColor(vec3(0.18, 0.05, 0.05), col, uv, vec2(0.42, 0.67), vec2(0.40, 0.70), vec2( 0.42, 0.71 ), Res);\n    applyColor(vec3(0.64, 0.45, 0.29), col, uv, vec2(0.42, 0.38), vec2(0.39, 0.33), vec2( 0.41, 0.42 ), Res);\n    applyColor(vec3(0.67, 0.46, 0.30), col, uv, vec2(0.42, 0.23), vec2(0.38, 0.15), vec2( 0.39, 0.27 ), Res);\n    applyColor(vec3(0.44, 0.39, 0.37), col, uv, vec2(0.42, 0.23), vec2(0.39, 0.27), vec2( 0.41, 0.27 ), Res);\n    applyColor(vec3(0.65, 0.57, 0.61), col, uv, vec2(0.42, 0.15), vec2(0.42, 0.09), vec2( 0.38, 0.15 ), Res);\n    applyColor(vec3(0.40, 0.20, 0.04), col, uv, vec2(0.42, 0.61), vec2(0.41, 0.61), vec2( 0.40, 0.64 ), Res);\n    applyColor(vec3(0.35, 0.28, 0.25), col, uv, vec2(0.42, 0.74), vec2(0.39, 0.76), vec2( 0.40, 0.79 ), Res);\n    applyColor(vec3(0.32, 0.28, 0.24), col, uv, vec2(0.43, 0.95), vec2(0.39, 0.84), vec2( 0.42, 0.97 ), Res);\n    applyColor(vec3(0.16, 0.04, 0.05), col, uv, vec2(0.43, 0.70), vec2(0.42, 0.67), vec2( 0.42, 0.71 ), Res);\n    applyColor(vec3(0.25, 0.09, 0.04), col, uv, vec2(0.43, 0.49), vec2(0.40, 0.49), vec2( 0.40, 0.53 ), Res);\n    applyColor(vec3(0.38, 0.20, 0.10), col, uv, vec2(0.43, 0.49), vec2(0.41, 0.44), vec2( 0.40, 0.49 ), Res);\n    applyColor(vec3(0.70, 0.55, 0.32), col, uv, vec2(0.43, 0.31), vec2(0.41, 0.27), vec2( 0.39, 0.33 ), Res);\n    applyColor(vec3(0.63, 0.43, 0.27), col, uv, vec2(0.42, 0.81), vec2(0.40, 0.79), vec2( 0.40, 0.81 ), Res);\n    applyColor(vec3(0.87, 0.71, 0.58), col, uv, vec2(0.42, 0.81), vec2(0.40, 0.81), vec2( 0.42, 0.82 ), Res);\n    applyColor(vec3(0.64, 0.02, 0.06), col, uv, vec2(0.42, 0.23), vec2(0.42, 0.15), vec2( 0.38, 0.15 ), Res);\n    applyColor(vec3(0.31, 0.29, 0.22), col, uv, vec2(0.42, 0.97), vec2(0.39, 0.84), vec2( 0.35, 0.86 ), Res);\n    applyColor(vec3(0.25, 0.24, 0.24), col, uv, vec2(0.42, 0.97), vec2(0.28, 0.92), vec2( 0.25, 1. ), Res);\n    applyColor(vec3(0.32, 0.18, 0.06), col, uv, vec2(0.43, 0.51), vec2(0.43, 0.49), vec2( 0.40, 0.53 ), Res);\n    applyColor(vec3(0.56, 0.33, 0.24), col, uv, vec2(0.43, 0.47), vec2(0.41, 0.44), vec2( 0.43, 0.49 ), Res);\n    applyColor(vec3(0.77, 0.79, 0.89), col, uv, vec2(0.43, 0.11), vec2(0.42, 0.09), vec2( 0.42, 0.15 ), Res);\n    applyColor(vec3(0.72, 0.57, 0.31), col, uv, vec2(0.43, 0.31), vec2(0.39, 0.33), vec2( 0.42, 0.38 ), Res);\n    applyColor(vec3(0.28, 0.17, 0.13), col, uv, vec2(0.42, 0.81), vec2(0.42, 0.74), vec2( 0.40, 0.79 ), Res);\n    applyColor(vec3(0.71, 0.47, 0.35), col, uv, vec2(0.42, 0.67), vec2(0.42, 0.61), vec2( 0.40, 0.64 ), Res);\n    applyColor(vec3(0.00, 0.00, 0.00), col, uv, vec2(0.44, 0.17), vec2(0.42, 0.15), vec2( 0.42, 0.23 ), Res);\n    applyColor(vec3(0.61, 0.62, 0.79), col, uv, vec2(0.44, 0.12), vec2(0.43, 0.11), vec2( 0.42, 0.15 ), Res);\n    applyColor(vec3(0.31, 0.15, 0.03), col, uv, vec2(0.43, 0.51), vec2(0.40, 0.53), vec2( 0.41, 0.56 ), Res);\n    applyColor(vec3(0.39, 0.30, 0.20), col, uv, vec2(0.43, 0.47), vec2(0.41, 0.42), vec2( 0.41, 0.44 ), Res);\n    applyColor(vec3(0.98, 0.99, 1.00), col, uv, vec2(0.42, 0.06), vec2(0.35, 0.04), vec2( 0.38, 0.07 ), Res);\n    applyColor(vec3(0.43, 0.25, 0.15), col, uv, vec2(0.44, 0.78), vec2(0.44, 0.77), vec2( 0.42, 0.81 ), Res);\n    applyColor(vec3(0.42, 0.30, 0.20), col, uv, vec2(0.44, 0.77), vec2(0.42, 0.74), vec2( 0.42, 0.81 ), Res);\n    applyColor(vec3(0.44, 0.39, 0.34), col, uv, vec2(0.44, 0.77), vec2(0.44, 0.75), vec2( 0.42, 0.74 ), Res);\n    applyColor(vec3(0.88, 0.77, 0.66), col, uv, vec2(0.44, 0.75), vec2(0.42, 0.71), vec2( 0.42, 0.74 ), Res);\n    applyColor(vec3(0.00, 0.00, 0.00), col, uv, vec2(0.44, 0.18), vec2(0.44, 0.17), vec2( 0.42, 0.23 ), Res);\n    applyColor(vec3(0.36, 0.18, 0.07), col, uv, vec2(0.43, 0.51), vec2(0.41, 0.56), vec2( 0.42, 0.57 ), Res);\n    applyColor(vec3(0.93, 0.82, 0.70), col, uv, vec2(0.45, 0.84), vec2(0.42, 0.81), vec2( 0.42, 0.82 ), Res);\n    applyColor(vec3(0.64, 0.47, 0.30), col, uv, vec2(0.45, 0.72), vec2(0.43, 0.70), vec2( 0.42, 0.71 ), Res);\n    applyColor(vec3(0.79, 0.68, 0.56), col, uv, vec2(0.45, 0.72), vec2(0.42, 0.71), vec2( 0.44, 0.75 ), Res);\n    applyColor(vec3(0.33, 0.18, 0.02), col, uv, vec2(0.45, 0.54), vec2(0.43, 0.51), vec2( 0.42, 0.57 ), Res);\n    applyColor(vec3(1.00, 1.00, 1.00), col, uv, vec2(0.45, 0.11), vec2(0.43, 0.11), vec2( 0.44, 0.12 ), Res);\n    applyColor(vec3(0.08, 0.07, 0.07), col, uv, vec2(0.44, 0.38), vec2(0.43, 0.31), vec2( 0.42, 0.38 ), Res);\n    applyColor(vec3(0.40, 0.40, 0.66), col, uv, vec2(0.44, 0.17), vec2(0.44, 0.12), vec2( 0.42, 0.15 ), Res);\n    applyColor(vec3(0.33, 0.29, 0.29), col, uv, vec2(0.43, 0.95), vec2(0.42, 0.82), vec2( 0.39, 0.84 ), Res);\n    applyColor(vec3(0.59, 0.38, 0.21), col, uv, vec2(0.45, 0.90), vec2(0.43, 0.95), vec2( 0.45, 0.93 ), Res);\n    applyColor(vec3(0.33, 0.30, 0.25), col, uv, vec2(0.45, 0.90), vec2(0.42, 0.82), vec2( 0.43, 0.95 ), Res);\n    applyColor(vec3(0.35, 0.31, 0.30), col, uv, vec2(0.45, 0.90), vec2(0.45, 0.86), vec2( 0.42, 0.82 ), Res);\n    applyColor(vec3(0.67, 0.59, 0.53), col, uv, vec2(0.45, 0.86), vec2(0.45, 0.84), vec2( 0.42, 0.82 ), Res);\n    applyColor(vec3(0.95, 0.84, 0.72), col, uv, vec2(0.45, 0.74), vec2(0.45, 0.72), vec2( 0.44, 0.75 ), Res);\n    applyColor(vec3(0.62, 0.45, 0.35), col, uv, vec2(0.45, 0.30), vec2(0.41, 0.27), vec2( 0.43, 0.31 ), Res);\n    applyColor(vec3(0.80, 0.67, 0.46), col, uv, vec2(0.45, 0.84), vec2(0.44, 0.78), vec2( 0.42, 0.81 ), Res);\n    applyColor(vec3(0.26, 0.20, 0.16), col, uv, vec2(0.44, 0.38), vec2(0.42, 0.38), vec2( 0.41, 0.42 ), Res);\n    applyColor(vec3(0.78, 0.62, 0.41), col, uv, vec2(0.43, 0.51), vec2(0.43, 0.47), vec2( 0.43, 0.49 ), Res);\n    applyColor(vec3(0.85, 0.71, 0.55), col, uv, vec2(0.46, 0.76), vec2(0.44, 0.75), vec2( 0.44, 0.77 ), Res);\n    applyColor(vec3(0.94, 0.82, 0.70), col, uv, vec2(0.46, 0.76), vec2(0.45, 0.74), vec2( 0.44, 0.75 ), Res);\n    applyColor(vec3(0.66, 0.46, 0.30), col, uv, vec2(0.46, 0.27), vec2(0.42, 0.23), vec2( 0.41, 0.27 ), Res);\n    applyColor(vec3(0.69, 0.57, 0.40), col, uv, vec2(0.46, 0.27), vec2(0.41, 0.27), vec2( 0.45, 0.30 ), Res);\n    applyColor(vec3(0.15, 0.19, 0.46), col, uv, vec2(0.46, 0.18), vec2(0.44, 0.17), vec2( 0.44, 0.18 ), Res);\n    applyColor(vec3(0.20, 0.14, 0.11), col, uv, vec2(0.44, 0.38), vec2(0.41, 0.42), vec2( 0.43, 0.47 ), Res);\n    applyColor(vec3(0.67, 0.43, 0.27), col, uv, vec2(0.46, 0.79), vec2(0.44, 0.78), vec2( 0.45, 0.84 ), Res);\n    applyColor(vec3(0.88, 0.74, 0.56), col, uv, vec2(0.46, 0.79), vec2(0.46, 0.76), vec2( 0.44, 0.78 ), Res);\n    applyColor(vec3(0.91, 0.81, 0.71), col, uv, vec2(0.46, 0.73), vec2(0.45, 0.72), vec2( 0.45, 0.74 ), Res);\n    applyColor(vec3(0.42, 0.28, 0.24), col, uv, vec2(0.46, 0.76), vec2(0.44, 0.77), vec2( 0.44, 0.78 ), Res);\n    applyColor(vec3(0.36, 0.16, 0.04), col, uv, vec2(0.45, 0.54), vec2(0.42, 0.57), vec2( 0.42, 0.61 ), Res);\n    applyColor(vec3(1.00, 1.00, 1.00), col, uv, vec2(0.43, 0.11), vec2(0.42, 0.06), vec2( 0.42, 0.09 ), Res);\n    applyColor(vec3(0.91, 0.81, 0.69), col, uv, vec2(0.47, 0.77), vec2(0.46, 0.76), vec2( 0.46, 0.79 ), Res);\n    applyColor(vec3(0.72, 0.15, 0.13), col, uv, vec2(0.47, 0.25), vec2(0.44, 0.18), vec2( 0.42, 0.23 ), Res);\n    applyColor(vec3(0.65, 0.32, 0.25), col, uv, vec2(0.47, 0.25), vec2(0.42, 0.23), vec2( 0.46, 0.27 ), Res);\n    applyColor(vec3(1.00, 0.95, 0.89), col, uv, vec2(0.46, 0.73), vec2(0.45, 0.74), vec2( 0.46, 0.76 ), Res);\n    applyColor(vec3(1.00, 1.00, 1.00), col, uv, vec2(0.46, 0.18), vec2(0.45, 0.11), vec2( 0.44, 0.17 ), Res);\n    applyColor(vec3(0.22, 0.18, 0.16), col, uv, vec2(0.45, 0.30), vec2(0.43, 0.31), vec2( 0.44, 0.38 ), Res);\n    applyColor(vec3(1.00, 1.00, 1.00), col, uv, vec2(0.45, 0.11), vec2(0.44, 0.12), vec2( 0.44, 0.17 ), Res);\n    applyColor(vec3(0.78, 0.62, 0.42), col, uv, vec2(0.48, 0.77), vec2(0.48, 0.72), vec2( 0.46, 0.73 ), Res);\n    applyColor(vec3(1.00, 0.94, 0.84), col, uv, vec2(0.48, 0.77), vec2(0.46, 0.73), vec2( 0.46, 0.76 ), Res);\n    applyColor(vec3(0.97, 0.91, 0.80), col, uv, vec2(0.48, 0.77), vec2(0.46, 0.76), vec2( 0.47, 0.77 ), Res);\n    applyColor(vec3(0.44, 0.36, 0.27), col, uv, vec2(0.48, 0.28), vec2(0.46, 0.27), vec2( 0.45, 0.30 ), Res);\n    applyColor(vec3(0.32, 0.07, 0.07), col, uv, vec2(0.48, 0.28), vec2(0.47, 0.25), vec2( 0.46, 0.27 ), Res);\n    applyColor(vec3(0.97, 0.95, 1.00), col, uv, vec2(0.47, 0.25), vec2(0.46, 0.18), vec2( 0.44, 0.18 ), Res);\n    applyColor(vec3(0.96, 0.81, 0.62), col, uv, vec2(0.49, 0.88), vec2(0.45, 0.86), vec2( 0.45, 0.90 ), Res);\n    applyColor(vec3(0.99, 0.94, 0.86), col, uv, vec2(0.49, 0.94), vec2(0.45, 0.90), vec2( 0.45, 0.93 ), Res);\n    applyColor(vec3(0.96, 0.84, 0.75), col, uv, vec2(0.48, 0.72), vec2(0.45, 0.72), vec2( 0.46, 0.73 ), Res);\n    applyColor(vec3(0.17, 0.09, 0.07), col, uv, vec2(0.45, 0.72), vec2(0.42, 0.67), vec2( 0.43, 0.70 ), Res);\n    applyColor(vec3(0.73, 0.58, 0.36), col, uv, vec2(0.49, 0.74), vec2(0.48, 0.72), vec2( 0.48, 0.77 ), Res);\n    applyColor(vec3(0.59, 0.34, 0.20), col, uv, vec2(0.49, 0.70), vec2(0.45, 0.72), vec2( 0.48, 0.72 ), Res);\n    applyColor(vec3(1.00, 1.00, 0.92), col, uv, vec2(0.49, 0.94), vec2(0.49, 0.88), vec2( 0.45, 0.90 ), Res);\n    applyColor(vec3(0.68, 0.47, 0.34), col, uv, vec2(0.45, 0.93), vec2(0.43, 0.95), vec2( 0.42, 0.97 ), Res);\n    applyColor(vec3(0.00, 0.00, 0.07), col, uv, vec2(0.45, 0.11), vec2(0.42, 0.06), vec2( 0.43, 0.11 ), Res);\n    applyColor(vec3(0.34, 0.29, 0.31), col, uv, vec2(0.50, 1.), vec2(0.45, 0.93), vec2( 0.42, 0.97 ), Res);\n    applyColor(vec3(0.36, 0.33, 0.38), col, uv, vec2(0.50, 1.), vec2(0.49, 0.94), vec2( 0.45, 0.93 ), Res);\n    applyColor(vec3(0.92, 0.89, 0.91), col, uv, vec2(0.50, 0.00), vec2(0.42, 0.06), vec2( 0.45, 0.11 ), Res);\n    applyColor(vec3(0.76, 0.60, 0.44), col, uv, vec2(0.50, 0.78), vec2(0.49, 0.74), vec2( 0.48, 0.77 ), Res);\n    applyColor(vec3(0.87, 0.73, 0.62), col, uv, vec2(0.50, 0.78), vec2(0.48, 0.77), vec2( 0.46, 0.79 ), Res);\n    applyColor(vec3(0.60, 0.37, 0.22), col, uv, vec2(0.49, 0.74), vec2(0.49, 0.70), vec2( 0.48, 0.72 ), Res);\n    applyColor(vec3(0.72, 0.54, 0.32), col, uv, vec2(0.49, 0.70), vec2(0.42, 0.67), vec2( 0.45, 0.72 ), Res);\n    applyColor(vec3(0.12, 0.13, 0.06), col, uv, vec2(0.49, 0.28), vec2(0.47, 0.25), vec2( 0.48, 0.28 ), Res);\n    applyColor(vec3(0.87, 0.71, 0.56), col, uv, vec2(0.49, 0.88), vec2(0.46, 0.79), vec2( 0.45, 0.86 ), Res);\n    applyColor(vec3(0.95, 0.90, 0.81), col, uv, vec2(0.48, 0.77), vec2(0.47, 0.77), vec2( 0.46, 0.79 ), Res);\n    applyColor(vec3(1.00, 1.00, 0.95), col, uv, vec2(0.46, 0.79), vec2(0.45, 0.84), vec2( 0.45, 0.86 ), Res);\n    applyColor(vec3(0.26, 0.16, 0.15), col, uv, vec2(0.45, 0.54), vec2(0.43, 0.47), vec2( 0.43, 0.51 ), Res);\n    applyColor(vec3(0.89, 0.77, 0.65), col, uv, vec2(0.51, 0.84), vec2(0.46, 0.79), vec2( 0.49, 0.88 ), Res);\n    applyColor(vec3(0.79, 0.64, 0.53), col, uv, vec2(0.51, 0.84), vec2(0.50, 0.78), vec2( 0.46, 0.79 ), Res);\n    applyColor(vec3(0.53, 0.29, 0.10), col, uv, vec2(0.49, 0.70), vec2(0.42, 0.61), vec2( 0.42, 0.67 ), Res);\n    applyColor(vec3(0.92, 0.83, 0.67), col, uv, vec2(0.52, 0.88), vec2(0.51, 0.84), vec2( 0.49, 0.88 ), Res);\n    applyColor(vec3(0.38, 0.20, 0.07), col, uv, vec2(0.49, 0.70), vec2(0.45, 0.54), vec2( 0.42, 0.61 ), Res);\n    applyColor(vec3(0.96, 0.90, 0.80), col, uv, vec2(0.52, 0.88), vec2(0.49, 0.88), vec2( 0.49, 0.94 ), Res);\n    applyColor(vec3(0.56, 0.40, 0.38), col, uv, vec2(0.48, 0.28), vec2(0.45, 0.30), vec2( 0.44, 0.38 ), Res);\n    applyColor(vec3(0.80, 0.68, 0.47), col, uv, vec2(0.53, 0.90), vec2(0.53, 0.87), vec2( 0.52, 0.88 ), Res);\n    applyColor(vec3(0.91, 0.81, 0.67), col, uv, vec2(0.53, 0.90), vec2(0.52, 0.88), vec2( 0.49, 0.94 ), Res);\n    applyColor(vec3(0.81, 0.67, 0.53), col, uv, vec2(0.53, 0.87), vec2(0.51, 0.84), vec2( 0.52, 0.88 ), Res);\n    applyColor(vec3(0.85, 0.81, 0.87), col, uv, vec2(0.53, 0.14), vec2(0.45, 0.11), vec2( 0.46, 0.18 ), Res);\n    applyColor(vec3(0.42, 0.28, 0.15), col, uv, vec2(0.52, 0.65), vec2(0.45, 0.54), vec2( 0.49, 0.70 ), Res);\n    applyColor(vec3(0.46, 0.35, 0.32), col, uv, vec2(0.49, 0.28), vec2(0.48, 0.28), vec2( 0.44, 0.38 ), Res);\n    applyColor(vec3(0.69, 0.54, 0.37), col, uv, vec2(0.54, 0.76), vec2(0.49, 0.74), vec2( 0.50, 0.78 ), Res);\n    applyColor(vec3(0.85, 0.79, 0.86), col, uv, vec2(0.53, 0.14), vec2(0.50, 0.00), vec2( 0.45, 0.11 ), Res);\n    applyColor(vec3(0.80, 0.75, 0.83), col, uv, vec2(0.50, 0.00), vec2(0.35, 0.04), vec2( 0.42, 0.06 ), Res);\n    applyColor(vec3(0.87, 0.76, 0.65), col, uv, vec2(0.54, 0.81), vec2(0.51, 0.84), vec2( 0.54, 0.86 ), Res);\n    applyColor(vec3(0.83, 0.71, 0.59), col, uv, vec2(0.54, 0.81), vec2(0.54, 0.79), vec2( 0.51, 0.84 ), Res);\n    applyColor(vec3(0.70, 0.55, 0.37), col, uv, vec2(0.54, 0.79), vec2(0.50, 0.78), vec2( 0.51, 0.84 ), Res);\n    applyColor(vec3(0.64, 0.45, 0.32), col, uv, vec2(0.54, 0.79), vec2(0.54, 0.76), vec2( 0.50, 0.78 ), Res);\n    applyColor(vec3(0.75, 0.61, 0.41), col, uv, vec2(0.54, 0.86), vec2(0.51, 0.84), vec2( 0.53, 0.87 ), Res);\n    applyColor(vec3(0.45, 0.35, 0.30), col, uv, vec2(0.54, 0.33), vec2(0.49, 0.28), vec2( 0.44, 0.38 ), Res);\n    applyColor(vec3(0.89, 0.87, 0.93), col, uv, vec2(0.53, 0.14), vec2(0.46, 0.18), vec2( 0.47, 0.25 ), Res);\n    applyColor(vec3(0.89, 0.89, 0.93), col, uv, vec2(0.53, 0.14), vec2(0.47, 0.25), vec2( 0.49, 0.28 ), Res);\n    applyColor(vec3(0.46, 0.34, 0.26), col, uv, vec2(0.55, 0.77), vec2(0.54, 0.76), vec2( 0.54, 0.79 ), Res);\n    applyColor(vec3(0.78, 0.66, 0.56), col, uv, vec2(0.54, 0.86), vec2(0.53, 0.87), vec2( 0.53, 0.90 ), Res);\n    applyColor(vec3(0.30, 0.18, 0.02), col, uv, vec2(0.54, 0.76), vec2(0.49, 0.70), vec2( 0.49, 0.74 ), Res);\n    applyColor(vec3(0.81, 0.69, 0.57), col, uv, vec2(0.55, 0.82), vec2(0.54, 0.81), vec2( 0.54, 0.86 ), Res);\n    applyColor(vec3(0.91, 0.85, 0.75), col, uv, vec2(0.55, 0.82), vec2(0.54, 0.86), vec2( 0.55, 0.86 ), Res);\n    applyColor(vec3(0.30, 0.16, 0.07), col, uv, vec2(0.54, 0.76), vec2(0.52, 0.65), vec2( 0.49, 0.70 ), Res);\n    applyColor(vec3(0.45, 0.41, 0.42), col, uv, vec2(0.53, 0.90), vec2(0.49, 0.94), vec2( 0.50, 1. ), Res);\n    applyColor(vec3(0.42, 0.35, 0.34), col, uv, vec2(0.56, 0.80), vec2(0.54, 0.79), vec2( 0.54, 0.81 ), Res);\n    applyColor(vec3(1.00, 0.96, 0.87), col, uv, vec2(0.56, 0.86), vec2(0.55, 0.82), vec2( 0.55, 0.86 ), Res);\n    applyColor(vec3(0.58, 0.45, 0.37), col, uv, vec2(0.56, 0.80), vec2(0.54, 0.81), vec2( 0.55, 0.82 ), Res);\n    applyColor(vec3(0.32, 0.27, 0.22), col, uv, vec2(0.56, 0.80), vec2(0.55, 0.77), vec2( 0.54, 0.79 ), Res);\n    applyColor(vec3(0.33, 0.20, 0.12), col, uv, vec2(0.56, 0.71), vec2(0.52, 0.65), vec2( 0.54, 0.76 ), Res);\n    applyColor(vec3(0.89, 0.78, 0.66), col, uv, vec2(0.55, 0.86), vec2(0.54, 0.86), vec2( 0.53, 0.90 ), Res);\n    applyColor(vec3(0.67, 0.62, 0.58), col, uv, vec2(0.57, 0.84), vec2(0.55, 0.82), vec2( 0.56, 0.86 ), Res);\n    applyColor(vec3(0.23, 0.16, 0.11), col, uv, vec2(0.57, 0.77), vec2(0.55, 0.77), vec2( 0.56, 0.80 ), Res);\n    applyColor(vec3(0.01, 0.02, 0.07), col, uv, vec2(0.57, 0.77), vec2(0.54, 0.76), vec2( 0.55, 0.77 ), Res);\n    applyColor(vec3(0.02, 0.03, 0.04), col, uv, vec2(0.57, 0.77), vec2(0.56, 0.71), vec2( 0.54, 0.76 ), Res);\n    applyColor(vec3(0.79, 0.76, 0.74), col, uv, vec2(0.57, 0.85), vec2(0.57, 0.84), vec2( 0.56, 0.86 ), Res);\n    applyColor(vec3(0.36, 0.22, 0.15), col, uv, vec2(0.57, 0.70), vec2(0.52, 0.65), vec2( 0.56, 0.71 ), Res);\n    applyColor(vec3(0.62, 0.07, 0.02), col, uv, vec2(0.57, 0.38), vec2(0.57, 0.35), vec2( 0.54, 0.33 ), Res);\n    applyColor(vec3(0.25, 0.19, 0.15), col, uv, vec2(0.57, 0.84), vec2(0.57, 0.80), vec2( 0.55, 0.82 ), Res);\n    applyColor(vec3(0.59, 0.43, 0.28), col, uv, vec2(0.57, 0.80), vec2(0.57, 0.77), vec2( 0.56, 0.80 ), Res);\n    applyColor(vec3(0.35, 0.33, 0.30), col, uv, vec2(0.57, 0.80), vec2(0.56, 0.80), vec2( 0.55, 0.82 ), Res);\n    applyColor(vec3(1.00, 0.92, 0.79), col, uv, vec2(0.56, 0.86), vec2(0.55, 0.86), vec2( 0.53, 0.90 ), Res);\n    applyColor(vec3(0.35, 0.24, 0.23), col, uv, vec2(0.54, 0.33), vec2(0.44, 0.38), vec2( 0.43, 0.47 ), Res);\n    applyColor(vec3(1.00, 0.95, 0.84), col, uv, vec2(0.58, 0.88), vec2(0.56, 0.86), vec2( 0.53, 0.90 ), Res);\n    applyColor(vec3(0.96, 0.94, 0.86), col, uv, vec2(0.58, 0.88), vec2(0.57, 0.85), vec2( 0.56, 0.86 ), Res);\n    applyColor(vec3(0.00, 0.03, 0.02), col, uv, vec2(0.58, 0.69), vec2(0.58, 0.67), vec2( 0.57, 0.70 ), Res);\n    applyColor(vec3(0.44, 0.31, 0.25), col, uv, vec2(0.58, 0.67), vec2(0.52, 0.65), vec2( 0.57, 0.70 ), Res);\n    applyColor(vec3(0.21, 0.15, 0.12), col, uv, vec2(0.57, 0.38), vec2(0.43, 0.47), vec2( 0.45, 0.54 ), Res);\n    applyColor(vec3(0.36, 0.29, 0.22), col, uv, vec2(0.57, 0.38), vec2(0.54, 0.33), vec2( 0.43, 0.47 ), Res);\n    applyColor(vec3(0.85, 0.75, 0.64), col, uv, vec2(0.59, 0.81), vec2(0.57, 0.80), vec2( 0.57, 0.84 ), Res);\n    applyColor(vec3(0.13, 0.15, 0.17), col, uv, vec2(0.59, 0.67), vec2(0.58, 0.67), vec2( 0.58, 0.69 ), Res);\n    applyColor(vec3(0.27, 0.15, 0.10), col, uv, vec2(0.57, 0.70), vec2(0.56, 0.71), vec2( 0.57, 0.77 ), Res);\n    applyColor(vec3(0.91, 0.91, 0.91), col, uv, vec2(0.60, 0.87), vec2(0.57, 0.85), vec2( 0.58, 0.88 ), Res);\n    applyColor(vec3(0.71, 0.58, 0.45), col, uv, vec2(0.59, 0.81), vec2(0.57, 0.77), vec2( 0.57, 0.80 ), Res);\n    applyColor(vec3(0.86, 0.76, 0.66), col, uv, vec2(0.59, 0.81), vec2(0.57, 0.84), vec2( 0.57, 0.85 ), Res);\n    applyColor(vec3(0.87, 0.89, 0.99), col, uv, vec2(0.54, 0.33), vec2(0.53, 0.14), vec2( 0.49, 0.28 ), Res);\n    applyColor(vec3(0.84, 0.73, 0.61), col, uv, vec2(0.60, 0.80), vec2(0.59, 0.81), vec2( 0.60, 0.87 ), Res);\n    applyColor(vec3(0.56, 0.37, 0.31), col, uv, vec2(0.60, 0.80), vec2(0.58, 0.69), vec2( 0.57, 0.77 ), Res);\n    applyColor(vec3(0.69, 0.58, 0.44), col, uv, vec2(0.60, 0.80), vec2(0.57, 0.77), vec2( 0.59, 0.81 ), Res);\n    applyColor(vec3(0.93, 0.85, 0.78), col, uv, vec2(0.60, 0.87), vec2(0.59, 0.81), vec2( 0.57, 0.85 ), Res);\n    applyColor(vec3(0.45, 0.40, 0.44), col, uv, vec2(0.58, 0.88), vec2(0.53, 0.90), vec2( 0.50, 1. ), Res);\n    applyColor(vec3(0.34, 0.23, 0.12), col, uv, vec2(0.58, 0.69), vec2(0.57, 0.70), vec2( 0.57, 0.77 ), Res);\n    applyColor(vec3(0.23, 0.18, 0.18), col, uv, vec2(0.57, 0.38), vec2(0.45, 0.54), vec2( 0.52, 0.65 ), Res);\n    applyColor(vec3(0.30, 0.23, 0.18), col, uv, vec2(0.64, 0.45), vec2(0.57, 0.38), vec2( 0.58, 0.67 ), Res);\n    applyColor(vec3(0.27, 0.25, 0.24), col, uv, vec2(0.64, 0.45), vec2(0.58, 0.67), vec2( 0.59, 0.67 ), Res);\n    applyColor(vec3(0.38, 0.24, 0.17), col, uv, vec2(0.60, 0.80), vec2(0.59, 0.67), vec2( 0.58, 0.69 ), Res);\n    applyColor(vec3(0.27, 0.22, 0.22), col, uv, vec2(0.58, 0.67), vec2(0.57, 0.38), vec2( 0.52, 0.65 ), Res);\n    applyColor(vec3(0.56, 0.00, 0.04), col, uv, vec2(0.57, 0.35), vec2(0.53, 0.14), vec2( 0.54, 0.33 ), Res);\n    applyColor(vec3(0.32, 0.27, 0.27), col, uv, vec2(0.66, 0.49), vec2(0.64, 0.45), vec2( 0.59, 0.67 ), Res);\n    applyColor(vec3(0.39, 0.29, 0.24), col, uv, vec2(0.68, 0.72), vec2(0.59, 0.67), vec2( 0.60, 0.80 ), Res);\n    applyColor(vec3(0.19, 0.17, 0.15), col, uv, vec2(0.68, 0.65), vec2(0.59, 0.67), vec2( 0.68, 0.72 ), Res);\n    applyColor(vec3(0.34, 0.26, 0.32), col, uv, vec2(0.69, 0.54), vec2(0.66, 0.49), vec2( 0.59, 0.67 ), Res);\n    applyColor(vec3(0.32, 0.28, 0.31), col, uv, vec2(0.69, 0.54), vec2(0.59, 0.67), vec2( 0.68, 0.65 ), Res);\n    applyColor(vec3(0.67, 0.58, 0.58), col, uv, vec2(0.64, 0.45), vec2(0.57, 0.35), vec2( 0.57, 0.38 ), Res);\n    applyColor(vec3(0.74, 0.62, 0.53), col, uv, vec2(0.71, 0.77), vec2(0.68, 0.72), vec2( 0.60, 0.80 ), Res);\n    applyColor(vec3(0.30, 0.22, 0.27), col, uv, vec2(0.71, 0.61), vec2(0.70, 0.55), vec2( 0.69, 0.54 ), Res);\n    applyColor(vec3(0.34, 0.30, 0.32), col, uv, vec2(0.71, 0.61), vec2(0.69, 0.54), vec2( 0.70, 0.63 ), Res);\n    applyColor(vec3(0.33, 0.28, 0.30), col, uv, vec2(0.70, 0.63), vec2(0.69, 0.54), vec2( 0.68, 0.65 ), Res);\n    applyColor(vec3(0.80, 0.26, 0.16), col, uv, vec2(0.71, 0.64), vec2(0.70, 0.63), vec2( 0.68, 0.65 ), Res);\n    applyColor(vec3(0.33, 0.26, 0.29), col, uv, vec2(0.72, 0.57), vec2(0.70, 0.55), vec2( 0.71, 0.61 ), Res);\n    applyColor(vec3(0.70, 0.59, 0.53), col, uv, vec2(0.72, 0.57), vec2(0.71, 0.54), vec2( 0.70, 0.55 ), Res);\n    applyColor(vec3(0.79, 0.27, 0.19), col, uv, vec2(0.71, 0.64), vec2(0.71, 0.61), vec2( 0.70, 0.63 ), Res);\n    applyColor(vec3(0.66, 0.33, 0.29), col, uv, vec2(0.71, 0.64), vec2(0.68, 0.65), vec2( 0.68, 0.72 ), Res);\n    applyColor(vec3(0.86, 0.75, 0.66), col, uv, vec2(0.71, 0.54), vec2(0.69, 0.54), vec2( 0.70, 0.55 ), Res);\n    applyColor(vec3(0.85, 0.76, 0.69), col, uv, vec2(0.71, 0.77), vec2(0.60, 0.80), vec2( 0.60, 0.87 ), Res);\n    applyColor(vec3(0.80, 0.28, 0.22), col, uv, vec2(0.73, 0.68), vec2(0.71, 0.64), vec2( 0.68, 0.72 ), Res);\n    applyColor(vec3(0.39, 0.24, 0.04), col, uv, vec2(0.73, 0.04), vec2(0.50, 0.00), vec2( 0.53, 0.14 ), Res);\n    applyColor(vec3(0.88, 0.38, 0.30), col, uv, vec2(0.74, 0.72), vec2(0.68, 0.72), vec2( 0.71, 0.77 ), Res);\n    applyColor(vec3(0.75, 0.25, 0.18), col, uv, vec2(0.74, 0.72), vec2(0.73, 0.68), vec2( 0.68, 0.72 ), Res);\n    applyColor(vec3(0.29, 0.24, 0.28), col, uv, vec2(0.74, 0.57), vec2(0.72, 0.57), vec2( 0.71, 0.61 ), Res);\n    applyColor(vec3(0.58, 0.41, 0.29), col, uv, vec2(0.74, 0.57), vec2(0.74, 0.55), vec2( 0.72, 0.57 ), Res);\n    applyColor(vec3(0.73, 0.61, 0.45), col, uv, vec2(0.74, 0.55), vec2(0.71, 0.54), vec2( 0.72, 0.57 ), Res);\n    applyColor(vec3(0.75, 0.62, 0.45), col, uv, vec2(0.74, 0.55), vec2(0.73, 0.51), vec2( 0.71, 0.54 ), Res);\n    applyColor(vec3(0.85, 0.76, 0.63), col, uv, vec2(0.73, 0.51), vec2(0.66, 0.49), vec2( 0.69, 0.54 ), Res);\n    applyColor(vec3(0.85, 0.76, 0.64), col, uv, vec2(0.73, 0.51), vec2(0.69, 0.54), vec2( 0.71, 0.54 ), Res);\n    applyColor(vec3(0.67, 0.60, 0.53), col, uv, vec2(0.75, 0.51), vec2(0.73, 0.51), vec2( 0.74, 0.55 ), Res);\n    applyColor(vec3(0.91, 0.42, 0.25), col, uv, vec2(0.74, 0.79), vec2(0.74, 0.72), vec2( 0.71, 0.77 ), Res);\n    applyColor(vec3(0.63, 0.16, 0.12), col, uv, vec2(0.74, 0.57), vec2(0.71, 0.61), vec2( 0.71, 0.64 ), Res);\n    applyColor(vec3(0.75, 0.20, 0.12), col, uv, vec2(0.76, 0.70), vec2(0.73, 0.68), vec2( 0.74, 0.72 ), Res);\n    applyColor(vec3(0.84, 0.26, 0.23), col, uv, vec2(0.76, 0.70), vec2(0.74, 0.72), vec2( 0.75, 0.72 ), Res);\n    applyColor(vec3(0.55, 0.11, 0.09), col, uv, vec2(0.76, 0.57), vec2(0.74, 0.55), vec2( 0.74, 0.57 ), Res);\n    applyColor(vec3(0.58, 0.13, 0.10), col, uv, vec2(0.76, 0.57), vec2(0.76, 0.54), vec2( 0.74, 0.55 ), Res);\n    applyColor(vec3(0.77, 0.23, 0.21), col, uv, vec2(0.76, 0.54), vec2(0.75, 0.51), vec2( 0.74, 0.55 ), Res);\n    applyColor(vec3(0.18, 0.13, 0.15), col, uv, vec2(0.75, 1.), vec2(0.71, 0.77), vec2( 0.60, 0.87 ), Res);\n    applyColor(vec3(0.24, 0.19, 0.21), col, uv, vec2(0.75, 1.), vec2(0.58, 0.88), vec2( 0.50, 1. ), Res);\n    applyColor(vec3(0.20, 0.16, 0.15), col, uv, vec2(0.75, 1.), vec2(0.60, 0.87), vec2( 0.58, 0.88 ), Res);\n    applyColor(vec3(0.80, 0.25, 0.16), col, uv, vec2(0.75, 0.72), vec2(0.74, 0.72), vec2( 0.74, 0.79 ), Res);\n    applyColor(vec3(0.29, 0.15, 0.09), col, uv, vec2(0.73, 0.04), vec2(0.53, 0.14), vec2( 0.57, 0.35 ), Res);\n    applyColor(vec3(1.00, 1.00, 1.00), col, uv, vec2(0.50, 0.00), vec2(0.25, 0.00), vec2( 0.35, 0.04 ), Res);\n    applyColor(vec3(0.64, 0.18, 0.15), col, uv, vec2(0.77, 0.57), vec2(0.76, 0.54), vec2( 0.76, 0.57 ), Res);\n    applyColor(vec3(0.35, 0.32, 0.33), col, uv, vec2(0.75, 1.), vec2(0.74, 0.79), vec2( 0.71, 0.77 ), Res);\n    applyColor(vec3(0.45, 0.20, 0.16), col, uv, vec2(0.75, 0.00), vec2(0.73, 0.04), vec2( 0.75, 0.07 ), Res);\n    applyColor(vec3(0.41, 0.27, 0.10), col, uv, vec2(0.75, 0.07), vec2(0.73, 0.04), vec2( 0.57, 0.35 ), Res);\n    applyColor(vec3(0.69, 0.21, 0.16), col, uv, vec2(0.74, 0.57), vec2(0.71, 0.64), vec2( 0.73, 0.68 ), Res);\n    applyColor(vec3(0.55, 0.07, 0.09), col, uv, vec2(0.76, 0.57), vec2(0.74, 0.57), vec2( 0.73, 0.68 ), Res);\n    applyColor(vec3(0.71, 0.15, 0.14), col, uv, vec2(0.79, 0.72), vec2(0.79, 0.64), vec2( 0.76, 0.70 ), Res);\n    applyColor(vec3(0.82, 0.30, 0.20), col, uv, vec2(0.79, 0.72), vec2(0.76, 0.70), vec2( 0.75, 0.72 ), Res);\n    applyColor(vec3(0.89, 0.33, 0.20), col, uv, vec2(0.79, 0.72), vec2(0.75, 0.72), vec2( 0.74, 0.79 ), Res);\n    applyColor(vec3(0.96, 0.47, 0.33), col, uv, vec2(0.79, 0.72), vec2(0.74, 0.79), vec2( 0.78, 0.84 ), Res);\n    applyColor(vec3(0.44, 0.04, 0.08), col, uv, vec2(0.79, 0.64), vec2(0.77, 0.57), vec2( 0.76, 0.57 ), Res);\n    applyColor(vec3(0.59, 0.06, 0.03), col, uv, vec2(0.79, 0.64), vec2(0.73, 0.68), vec2( 0.76, 0.70 ), Res);\n    applyColor(vec3(0.42, 0.04, 0.09), col, uv, vec2(0.79, 0.64), vec2(0.76, 0.57), vec2( 0.73, 0.68 ), Res);\n    applyColor(vec3(0.19, 0.16, 0.21), col, uv, vec2(0.78, 0.84), vec2(0.74, 0.79), vec2( 0.75, 1. ), Res);\n    applyColor(vec3(0.26, 0.15, 0.05), col, uv, vec2(0.75, 0.00), vec2(0.50, 0.00), vec2( 0.73, 0.04 ), Res);\n    applyColor(vec3(0.39, 0.25, 0.13), col, uv, vec2(0.75, 0.07), vec2(0.57, 0.35), vec2( 0.64, 0.45 ), Res);\n    applyColor(vec3(0.87, 0.76, 0.65), col, uv, vec2(0.73, 0.51), vec2(0.64, 0.45), vec2( 0.66, 0.49 ), Res);\n    applyColor(vec3(0.20, 0.15, 0.18), col, uv, vec2(0.50, 1.), vec2(0.42, 0.97), vec2( 0.25, 1. ), Res);\n    applyColor(vec3(0.56, 0.10, 0.11), col, uv, vec2(0.85, 0.56), vec2(0.77, 0.57), vec2( 0.79, 0.64 ), Res);\n    applyColor(vec3(0.45, 0.31, 0.21), col, uv, vec2(0.75, 0.07), vec2(0.64, 0.45), vec2( 0.73, 0.51 ), Res);\n    applyColor(vec3(0.95, 0.53, 0.32), col, uv, vec2(0.86, 0.84), vec2(0.79, 0.72), vec2( 0.78, 0.84 ), Res);\n    applyColor(vec3(0.71, 0.21, 0.07), col, uv, vec2(0.85, 0.56), vec2(0.76, 0.54), vec2( 0.77, 0.57 ), Res);\n    applyColor(vec3(0.40, 0.31, 0.20), col, uv, vec2(0.75, 0.07), vec2(0.73, 0.51), vec2( 0.75, 0.51 ), Res);\n    applyColor(vec3(0.82, 0.27, 0.23), col, uv, vec2(0.88, 0.65), vec2(0.79, 0.64), vec2( 0.79, 0.72 ), Res);\n    applyColor(vec3(0.69, 0.18, 0.11), col, uv, vec2(0.88, 0.65), vec2(0.85, 0.56), vec2( 0.79, 0.64 ), Res);\n    applyColor(vec3(0.29, 0.23, 0.27), col, uv, vec2(0.86, 0.84), vec2(0.78, 0.84), vec2( 0.75, 1. ), Res);\n    applyColor(vec3(0.89, 0.36, 0.27), col, uv, vec2(0.89, 0.72), vec2(0.79, 0.72), vec2( 0.86, 0.84 ), Res);\n    applyColor(vec3(0.78, 0.24, 0.21), col, uv, vec2(0.89, 0.72), vec2(0.88, 0.65), vec2( 0.79, 0.72 ), Res);\n    applyColor(vec3(0.53, 0.09, 0.11), col, uv, vec2(0.85, 0.56), vec2(0.75, 0.51), vec2( 0.76, 0.54 ), Res);\n    applyColor(vec3(0.72, 0.19, 0.15), col, uv, vec2(0.94, 0.56), vec2(0.88, 0.65), vec2( 0.89, 0.72 ), Res);\n    applyColor(vec3(0.70, 0.18, 0.04), col, uv, vec2(0.94, 0.56), vec2(0.85, 0.56), vec2( 0.88, 0.65 ), Res);\n    applyColor(vec3(0.46, 0.34, 0.21), col, uv, vec2(0.85, 0.56), vec2(0.75, 0.07), vec2( 0.75, 0.51 ), Res);\n    applyColor(vec3(0.33, 0.29, 0.29), col, uv, vec2(1.00, 1.), vec2(0.86, 0.84), vec2( 0.75, 1. ), Res);\n    applyColor(vec3(0.29, 0.22, 0.21), col, uv, vec2(1.00, 1.), vec2(1.00, 0.76), vec2( 0.86, 0.84 ), Res);\n    applyColor(vec3(0.44, 0.33, 0.29), col, uv, vec2(1.00, 0.00), vec2(0.75, 0.00), vec2( 0.75, 0.07 ), Res);\n    applyColor(vec3(0.31, 0.22, 0.22), col, uv, vec2(1.00, 0.00), vec2(0.75, 0.07), vec2( 1.00, 0.25 ), Res);\n    applyColor(vec3(0.37, 0.29, 0.31), col, uv, vec2(1.00, 0.51), vec2(1.00, 0.25), vec2( 0.94, 0.56 ), Res);\n    applyColor(vec3(0.30, 0.24, 0.25), col, uv, vec2(1.00, 0.51), vec2(0.94, 0.56), vec2( 1.00, 0.76 ), Res);\n    applyColor(vec3(0.83, 0.27, 0.12), col, uv, vec2(1.00, 0.76), vec2(0.94, 0.56), vec2( 0.89, 0.72 ), Res);\n    applyColor(vec3(0.92, 0.45, 0.29), col, uv, vec2(1.00, 0.76), vec2(0.89, 0.72), vec2( 0.86, 0.84 ), Res);\n    applyColor(vec3(0.07, 0.08, 0.16), col, uv, vec2(1.00, 0.25), vec2(0.75, 0.07), vec2( 0.85, 0.56 ), Res);\n    applyColor(vec3(0.35, 0.32, 0.34), col, uv, vec2(1.00, 0.25), vec2(0.85, 0.56), vec2( 0.94, 0.56 ), Res);\n    applyColor(vec3(0.58, 0.41, 0.29), col, uv, vec2(0.752, 0.082), vec2(0.85, 0.56), vec2( 0.94, 0.56 ), Res);\n    applyColor(vec3(0.9, 0.79, 0.69), col, uv, vec2(0.6, 0.87), vec2(0.74, 0.79), vec2( 0.7, 0.75 ), Res);\n    applyColor(vec3(1., 0.94, 0.83), col, uv, vec2(0.6, 0.87), vec2(0.74, 0.79), vec2( 0.775, 0.835 ), Res);\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdSWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 36, 36, 101], [103, 103, 151, 151, 284], [286, 286, 321, 321, 429], [431, 431, 522, 522, 667], [670, 670, 727, 727, 70135]], "test": "untested"}
{"id": "ftcXDM", "name": "mmm objkt", "author": "lennyjpg", "description": "[url]https://hicetnunc.art/objkt/581738[/url]\n[url]https://ipfs.io/ipfs/QmdbqnNZcr1mzePBnKzF8RZRnC2cgWEUJ1t6XoHJ2sr4uX[/url]", "tags": ["round", "blob", "loop", "mono"], "likes": 4, "viewed": 241, "published": 3, "date": "1639229662", "time_retrieved": "2024-07-30T18:42:53.193629", "image_code": "float grid(vec2 p, vec2 res){\n    p = mod(p,res.y);\n    float d = length(p-res.y*.5);\n    return smoothstep(d,d+1.5/iResolution.y, res.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    vec2 res = vec2(.25, .5);\n    vec2 u = uv;\n    u.y += sin(u.x * 7.7) * .05 * uv.y;\n    u.y += cos(u.x * 4.2) * .05;\n    u.y = abs(u.y - .5);\n    u.x = sin(uv.x * 3.) * .5;\n    u.x += mod(u.y, res.x);\n    u.x -= u.y + iTime * .14;\n    u.x += sin(u.y * .1) * .5;\n    float mmm = grid(u, res);\n    fragColor = vec4(mmm);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcXDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 140], [142, 142, 199, 199, 564]], "test": "untested"}
{"id": "NtdSWM", "name": "auto-normalization for free", "author": "FabriceNeyret2", "description": "Computed values might be hard to bound in [0,1] or [-1,1].   ( red where > 1 , blue where < -1. ).\nright: use MIPmap to compute the (approx) max value of a buffer for free ( used for instance for normalizing the values).", "tags": ["gpmipmap"], "likes": 11, "viewed": 287, "published": 3, "date": "1639229365", "time_retrieved": "2024-07-30T18:42:53.968557", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, U = u/R;\n    O = texture(iChannel0, U );\n    if (U.x > .5 ) O /= decodeMax( texture(iChannel0, U ,99.).a);\n    \n    if (O.x> 1.) O = vec4(1,0,0,0);               // show overfow in red\n    if (O.x<-1.) O = vec4(0,0,1,0);               // show overfow in red\n    if ( int(u) == int(R)/2 ) O = vec4(0,1,0,0);  // green separator\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    U *= 10./iResolution.xy;\n    float x = U.x, y = U.y,\n          v =    sin(x+sin(y+iTime)) + cos(x-iTime)\n               + cos(y+cos(x)-iTime)\n               + sin(5.*x+9.*length(U))\n               + cos(5.*y+9.*length(U));\n               \n    O = vec4( vec3(v), encodeMax(v) );\n}", "buffer_a_inputs": [], "common_code": "// POW must be highest possible not causing overflow: adapt it to your range of values.\n#define POW 55.\n#define encodeMax(v) pow(max(0.,v),POW)\n#define decodeMax(v) pow(v,1./POW)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdSWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 397]], "test": "untested"}
{"id": "7lcXD7", "name": "Saturday abstract logo", "author": "mrange", "description": "CC0 : Saturday abstract logo\nTinkering with recreating an abstract logo.\nNot perfect but good enough for my standard.\nInspired by: https://www.logomoose.com/featured/abstract-logo/", "tags": ["logo"], "likes": 13, "viewed": 332, "published": 3, "date": "1639225871", "time_retrieved": "2024-07-30T18:42:54.865159", "image_code": "// CC0 : Saturday abstract logo\n//  Tinkering with recreating an abstract logo.\n//  Not perfect but good enough for my standard.\n//  Inspired by: https://www.logomoose.com/featured/abstract-logo/\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define PI_2        (0.5*3.141592654)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float logo_radius= 0.25;\nconst float logo_off   = 0.25;\nconst float logo_width = 0.1;\n\nfloat rcp(float x) {\n  return 1.0 / x;\n}\n\n//P. Gilcher '21, strange approximation\n// Source found at: https://www.shadertoy.com/view/flSXRV\nfloat fast_atan2(float y, float x) {\n  float cosatan2 = x * rcp(abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat stripes(float d) {\n  const float cc = 0.42;\n  d = abs(d)-logo_width*cc;\n  d = abs(d)-logo_width*cc*0.5;\n  return d;\n}\n\nvec4 merge(vec4 s0, vec4 s1) {\n  bool dt = s0.z < s1.z; \n  vec4 b = dt ? s0 : s1;\n  vec4 t = dt ? s1 : s0;\n\n  b.x *= 1.0 - exp(-max(80.0*(t.w), 0.0));\n\n  vec4 r = vec4(\n      mix(b.xy, t.xy, t.y)\n    , b.w < t.w ? b.z : t.z \n    , min(b.w, t.w)\n    );\n  \n  return r;\n}\n\nvec4 figure_8(vec2 p) {\n  float aa = 2.0/RESOLUTION.y;\n  vec2  p1 = p-vec2(logo_off, -logo_off);\n  float d1 = abs(circle(p1, logo_radius));\n  float a1 = fast_atan2(-p1.x, -p1.y);\n  float s1 = stripes(d1);\n  float o1 = d1 - logo_width;\n\n  vec2  p2 = p-vec2(logo_off, logo_off);\n  float d2 = abs(circle(p2, logo_radius));\n  float a2 = fast_atan2(p2.x, p2.y);  \n  float s2 = stripes(d2);\n  float o2 = d2 - logo_width;\n\n  vec4 c0 = vec4(smoothstep(aa, -aa, s1), smoothstep(aa, -aa, o1), a1, o1);\n  vec4 c1 = vec4(smoothstep(aa, -aa, s2), smoothstep(aa, -aa, o2), a2, o2);\n\n  return merge(c0, c1);\n}\n\nvec4 clogo(vec2 p, out float d) {\n  p *= ROT(TAU*TIME/60.0);\n\n  float sgn = sign(p.y);\n  p *= sgn;\n\n  vec4 s0 = figure_8(p);\n  vec4 s1 = figure_8(p*ROT(PI/4.0));\n  vec4 s2 = figure_8(p-vec2(-0.5, 0.0));\n  vec4 s3 = figure_8((p*ROT(5.0*PI/4.0)));\n  \n  // This is very hackish to get it to look reasonable\n  \n  const float off = -PI;\n  s1.z -= off;\n  s3.z -= off;\n  \n  vec4 s = s0;\n  s = merge(s, s1);\n  s = merge(s, s2);\n  s = merge(s, s3);\n\n  d = s.w;\n  return vec4(vec3(1.0)*s.x, s.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  //  Found this somewhere on the interwebs\n  col = clamp(col, 0.0, 1.0);\n  // Gamma correction\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  // Vignetting\n  col*= 0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float aa = 2.0/RESOLUTION.y;\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col  = vec3(1.0);\n  float d;\n  vec4 ccol = clogo(p, d);\n  \n  col = mix(col, vec3(.25), exp(-9.0*max(d+0.025, 0.0)));\n  col = mix(col, ccol.xyz, ccol.w);\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcXD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[506, 506, 526, 526, 546], [548, 646, 682, 682, 792], [794, 794, 825, 825, 851], [853, 853, 877, 877, 976], [978, 978, 1008, 1008, 1246], [1248, 1248, 1271, 1271, 1842], [1844, 1844, 1877, 1877, 2332], [2334, 2417, 2453, 2497, 2768], [2770, 2770, 2825, 2825, 3177]], "test": "untested"}
{"id": "7tcXWM", "name": "procedural pattern", "author": "WingStone", "description": "some single  and efficient procedural patterns", "tags": ["hexagon", "pattern", "checkboard"], "likes": 8, "viewed": 495, "published": 3, "date": "1639217295", "time_retrieved": "2024-07-30T18:42:55.616151", "image_code": "#define AA 1\n\n// smoothfloor ref: https://www.shadertoy.com/view/tsyXzV\n#if AA\n    #  define sfloor(x) ( floor(x-pix/2.) + max( 0., 1.-fract(-x+pix/2.) / pix ) ) \n    #  define sfloor2(x) ( floor(x-vec2(pix/2.)) + max( vec2(0.), vec2(1.)-fract(-x+vec2(pix/2.)) / vec2(pix) ) ) \n    #  define sfloor3(x) ( floor(x-vec3(pix/2.)) + max( vec3(0.), vec3(1.)-fract(-x+vec3(pix/2.)) / vec3(pix) ) ) \n#else\n    #  define sfloor(x) floor(x)\n    #  define sfloor2(x) floor(x)\n    #  define sfloor3(x) floor(x)\n#endif\n\n\nfloat CheckBoard(vec2 uv, float pix)\n{\n    uv *= 10.0;\n    vec2 id = floor(uv);\n    \n    float factor = mod(id.x+id.y, 2.0);\n    \n    return factor;\n}\n\nfloat Vertical(vec2 uv, float pix)\n{\n    uv *= 10.0;\n    vec2 id = floor(uv);\n    \n    float factor = mod(id.x, 2.0);\n    \n    return factor;\n}\n\nfloat Diamond(vec2 uv, float pix)\n{\n    uv *= 10.0;\n    pix *= 10.0;\n    vec2 newuv = vec2(0.0);\n    newuv.x = uv.x - uv.y;\n    newuv.y = uv.x + uv.y;\n    \n    vec2 id = sfloor2(newuv);\n    \n    float factor = mod(id.x+id.y, 2.0);\n    \n    return factor;\n}\n\nfloat Slash(vec2 uv, float pix)\n{\n    uv *= 10.0;\n    pix *= 10.0;\n    vec2 newuv = vec2(0.0);\n    newuv.x = uv.x - uv.y;\n    newuv.y = uv.x + uv.y;\n    \n    vec2 id = sfloor2(newuv);\n    \n    float factor = mod(id.x, 2.0);\n    \n    return factor;\n}\n\n// ref https://www.shadertoy.com/view/4dKXR3\nfloat Triangle(vec2 uv, float pix)\n{\n    uv *= 10.0;\n    pix *= 10.0;\n    vec2 U = uv;               // centered coords\n    \n    U *= mat2(1,-1./1.73, 0,2./1.73);      // conversion to\n    vec3 g = vec3(U,1.-U.x-U.y);          // hexagonal coordinates\n    vec3 id = sfloor3(g);                         // cell id\n    \n    float factor = id.x + id.y + id.z+1.0;\n    \n    return factor;\n}\n\n// ref https://www.shadertoy.com/view/4dKXR3\nfloat Hexagon1(vec2 uv, float pix)\n{\n    uv *= 10.0;\n    pix *= 10.0;\n    vec2 U = uv;               // centered coords\n    \n    U *= mat2(1,-1./1.73, 0,2./1.73);      // conversion to\n    vec3 g = vec3(U,1.-U.x-U.y);           // hexagonal coordinates\n    \n    g = fract(g);                              // diamond coords\n    if (length(g)>1.) g = 1.-g;                // barycentric coords\n    vec3 g2 = abs(2.*fract(g)-1.);                  // distance to borders\n    g -= 0.5;\n    \n    #if AA\n        float threshold = pix/1.73;\n        float factor = smoothstep(0.0, 1.5,g.x/min(threshold, fwidth(g.x)))\n            + smoothstep(0.0, 1.5, g.y/min(threshold, fwidth(g.y)))\n            + smoothstep(0.0, 1.5, g.z/min(threshold, fwidth(g.z)));\n    #else\n        float factor = step(0.0,g.x)+step(0.0,g.y)+step(0.0,g.z);\n    #endif\n    \n    return factor;\n}\n\nfloat Hexagon2(vec2 uv, float pix)\n{\n    float factor = 1.0 - Hexagon1(uv, pix);\n    \n    return factor;\n}\n\nfloat Circle(vec2 uv, float pix)\n{\n    uv *= 10.0;\n    \n    vec2 id = floor(uv);\n    uv = fract(uv)*2.0-1.0;\n    \n    float len = length(uv)-0.9;\n    \n    #if AA\n        float factor = smoothstep(0.0, 1.5, len/fwidth(len)); // aa\n    #else\n        float factor = step(0.0, len);\n    #endif\n    \n    factor = mod(id.x+id.y, 2.0)>0.5 ? factor : 1.0-factor;\n    return factor;\n}\n\t\nfloat Pattern(vec2 uv, float pix)\n{\n   // return Triangle(uv, pix);\n    float patternNumber = 8.0;\n    \n    float time = fract(iTime/patternNumber)*patternNumber;\n    \n    if(time < 1.0)\n        return CheckBoard(uv, pix);\n        \n    if(time < 2.0)\n        return Vertical(uv, pix);\n        \n    if(time < 3.0)\n        return Diamond(uv, pix);\n        \n    if(time < 4.0)\n        return Slash(uv, pix);\n        \n    if(time < 5.0)\n        return Triangle(uv, pix);\n        \n    if(time < 6.0)\n        return Hexagon1(uv, pix);\n        \n    if(time < 7.0)\n        return Hexagon2(uv, pix);\n        \n    if(time < patternNumber)\n        return Circle(uv, pix);\n        \n    return 0.0;\n}\n    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    float pix = 1. / iResolution.y;    // pixel width \n    float factor = Pattern(uv, pix);\n    \n    vec3 col = vec3(factor);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tcXWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[509, 509, 547, 547, 659], [661, 661, 697, 697, 804], [806, 806, 841, 841, 1062], [1064, 1064, 1097, 1097, 1313], [1315, 1360, 1396, 1396, 1746], [1748, 1793, 1829, 1829, 2651], [2653, 2653, 2689, 2689, 2759], [2761, 2761, 2795, 2795, 3136], [3139, 3139, 3174, 3206, 3826], [3834, 3834, 3891, 3941, 4164]], "test": "untested"}
{"id": "stcSDM", "name": "TDF Shader Showdown Quarterfinal", "author": "sp4ghet", "description": "Shoutout tdhooper, you are God Tier\nnoise is shit as usual", "tags": ["shadershowdown", "tdf", "tokyodemofest"], "likes": 14, "viewed": 373, "published": 3, "date": "1639209656", "time_retrieved": "2024-07-30T18:42:56.525719", "image_code": "#define time iTime\n#define v2Resolution iResolution\n#define saturate(x) clamp((x), 0.,1.)\nconst vec3 up = vec3(0,1,0);\nconst float PI = acos(-1.);\nconst float TAU = 2. * PI;\n\nmat3 ortho(vec3 z, vec3 up){\n  vec3 cu = normalize(cross(z, up));\n  vec3 cv = cross(cu, z);\n  return mat3(cu,cv, z);\n}\n\nfloat box(vec3 p, vec3 b){\n  p = abs(p) - b;\n  return length(max(p, 0.)) + min(0., max(p.x, max(p.y, p.z)));\n}\n\nvoid chmin(inout vec4 a, in vec4 b){\n  a = a.x < b.x ? a : b;\n}\n\nvec4 to(vec3 p){\n  float s = 2. / (1. + dot(p,p));\n  return vec4(s*p, s-1.);\n}\n\nvec3 from(vec4 p){\n  float s = 1. / (1. + p.w);\n  return s * p.xyz;\n}\n\nmat2 r2d(float t){\nfloat c = cos(t), s = sin(t);\nreturn mat2(c,s,-s,c);\n}\n\nvec4 map(vec3 q){\n  vec4 d = vec4(1000, 0,0,0);\n  vec3 p = q;\n  float f = length(p);\n  vec4 p4 = to(p);\n  float t = time * .2;\n  p4.zw *= r2d(-t);\n  p4.yw *= r2d(3.*t);\n  p = from(p4);\n  float e = length(p);\n  float cor = max(1., f) * min(1., 1./e);\n\n  float bx = box(p, vec3(1.1));\n  bx = max(bx, -box(p, vec3(1)));\n  bx = max(bx, -box(p, vec3(2, .5, .5)));\n  bx = max(bx, -box(p, vec3(.5, 2, .5)));\n  bx = max(bx, -box(p, vec3(.5, .5, 2)));\n  bx = max(bx, -box(vec3(abs(p.yz)-1., p.x).zxy, vec3(.5, .3, .3)));\n  bx = max(bx, -box(vec3(abs(p.xz)-1., p.y).xzy, vec3(.3, .5, .3)));\n  bx = max(bx, -box(vec3(abs(p.xy)-1., p.z).xyz, vec3(.3, .3, .5)));\n  bx *= cor * .5;\n  chmin(d, vec4(bx, 1,0,0));\n\n  bx = box(p, vec3(2.1));\n  bx = max(bx, -box(p, vec3(2)));\n  bx = max(bx, -box(p, vec3(3, 1, 1)));\n  bx = max(bx, -box(p, vec3(1, 3, 1)));\n  bx = max(bx, -box(p, vec3(1, 1, 3)));\n  bx = max(bx, -box(vec3(abs(p.yz)-2., p.x).zxy, vec3(1, .5, .5)));\n  bx = max(bx, -box(vec3(abs(p.xz)-2., p.y).xzy, vec3(.5, 1, .5)));\n  bx = max(bx, -box(vec3(abs(p.xy)-2., p.z).xyz, vec3(.5, .5, 1)));\n  bx *= cor * .5;\n  chmin(d, vec4(bx, 1,0,0));\n\n  vec2 xy = vec2(length(p.xz) - .5, p.y);\n  float thk = length(xy);\n  float th = atan(p.x, p.z);\n  float ph = atan(xy.y, xy.x);\n  vec3 pp = vec3(mod(24. * th, TAU) - PI, thk - .2, mod(12. * ph, TAU) - PI);\n  pp.xz /= TAU;\n  float tr = box(pp, vec3(.3, .01, .45));\n  tr *= cor * .5;\n  chmin(d, vec4(tr, 2, 0,0));\n\n  return d;\n}\n\nvec3 normal(vec3 p, vec2 e){\n return normalize(vec3(\n  map(p + e.xyy).x - map(p - e.xyy).x,\n  map(p + e.yxy).x - map(p - e.yxy).x,\n  map(p + e.yyx).x - map(p - e.yyx).x\n  ));\n}\n\nfloat rnd(int n){\n  n = (n << 13) ^ n;\n  return 1.0 - float((n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / pow(2.,30.);\n}\n\nconst vec3 l = normalize(vec3(.2, 1, .2));\nvec3 bg(vec3 n){\n  float qq = dot(l,n) * .5 + .5;\n  float q = qq + pow(qq, 16.) * 2.;\n  vec3 p = ortho(l, up) * n;\n  vec2 tp = vec2(atan(p.z, length(p.xy)), atan(p.y, p.x)) / TAU;\n  q += texture(iChannel0, fract(tp*5. + time*.2)).x;\n\n  return vec3(1) * q;\n}\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(fragCoord.x / v2Resolution.x, fragCoord.y / v2Resolution.y);\n\tvec2 pt = uv - 0.5;\n\tpt/= vec2(v2Resolution.y / v2Resolution.x, 1);\n\n\tvec3 c = vec3(0);\n  vec3 ro = vec3(0,1.7, 8);\n  vec3 fo = vec3(0);\n  float ct = time * 2.;\n  float pre = rnd(int(ct));\n  float now = rnd(int(ct) + 1);\n  ct = 0.5 + 0.5 * cos(PI * exp(-5. * fract(ct)));\n  pt *= r2d(PI * .2 *  mix(pre, now, ct));\n  vec3 rd = ortho(normalize(fo-ro), up) * normalize(vec3(pt, 1));\n\n  vec3 p = ro;\n  float t = 0.;\n  vec4 d;\n  for(int i=0; i<256; i++){\n    p = ro + rd*t;\n    d = map(p);\n    t += d.x;\n    if(abs(d.x) < 0.001 || t > 50.){break;}\n  }\n\n  if(abs(d.x) < .001){\n    vec3 n = normal(p, vec2(.01,0));\n    vec3 h = normalize(l-rd);\n    vec3 re = reflect(rd, n);\n    vec3 al = d.y == 1. ? vec3(.99, .2, .1) : vec3(.2, .7, .8);\n    float fre = pow(1. - saturate(dot(n,-rd)), 5.);\n    float nh = saturate(dot(n,h));\n    c += fre * vec3(.1, .7, .3);\n    c += (.1 + pow(nh, 20.)) * al;\n    c += saturate(dot(n,l)) * al;\n    c += al * bg(re);\n\n    float ao = 0.;\n    for(int i=1; i<=20; i++){\n      ao += saturate(map(p + n * .1 * float(i)).x / (.1 * float(i)));\n    }\n    c *= ao / 20.;\n  }else{\n    c = bg(rd);\n  }\n\n  c = pow(c, vec3(.4545));\n  c *= 1. - dot(pt,pt);\n  out_color = vec4(c,0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// From Dave Hoskins: https://www.shadertoy.com/view/4djSRW.\nfloat hoskins_hash(vec3 p3){\n    p3 = fract(p3 * 0.1031);\n    p3 += dot(p3,p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// https://www.shadertoy.com/view/4sfGzS\nfloat value_noise(vec3 x){\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix(hoskins_hash(i+vec3(0, 0, 0)),\n                       hoskins_hash(i+vec3(1, 0, 0)),f.x),\n                   mix(hoskins_hash(i+vec3(0, 1, 0)),\n                       hoskins_hash(i+vec3(1, 1, 0)),f.x),f.y),\n               mix(mix(hoskins_hash(i+vec3(0, 0, 1)),\n                       hoskins_hash(i+vec3(1, 0, 1)),f.x),\n                   mix(hoskins_hash(i+vec3(0, 1, 1)),\n                       hoskins_hash(i+vec3(1, 1, 1)),f.x),f.y),f.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(value_noise(vec3(fragCoord / 20., 0.)));\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcSDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 203, 203, 293], [295, 295, 321, 321, 405], [407, 407, 443, 443, 470], [472, 472, 488, 488, 550], [552, 552, 570, 570, 621], [623, 623, 641, 641, 696], [698, 698, 715, 715, 2154], [2156, 2156, 2184, 2184, 2332], [2334, 2334, 2351, 2351, 2468], [2513, 2513, 2529, 2529, 2770], [2772, 2772, 2829, 2829, 4104]], "test": "untested"}
{"id": "Nt3XDM", "name": "Niolon", "author": "XT95", "description": "A remake of my old shader \"La calanque\" with everything I learned since this time.. :)!\n\nDepending on your GPU, you can switch to low or high quality in the Common tab.", "tags": ["raymarching", "water", "ao", "caustic", "rock", "softshadow"], "likes": 89, "viewed": 3104, "published": 3, "date": "1639188467", "time_retrieved": "2024-07-30T18:42:57.571922", "image_code": "// ---------------------------------------------------------------------------------\n// Compositing pass\n// ---------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    vec2 uv = fragCoord * invRes;\n\n    // Chromatic aberration\n    vec2 offset = (uv*2.-1.)/iResolution.xy*0.5;\n    vec4 col = vec4(0.);\n    col.r = texture(iChannel0, uv/SCALE_FACTOR+offset).r;\n    col.g = texture(iChannel0, uv/SCALE_FACTOR-offset).g;\n    col.b = texture(iChannel0, uv/SCALE_FACTOR-offset).b;\n\n    // Light scattering\n    col += texture(iChannel1,uv*.5);\n\n    // Vignetting\n    col *= (pow( uv.x * uv.y * (1.-uv.x) * (1.-uv.y)*100., .2 ));\n    \n    // Gamma correction\n    fragColor = pow(col*2., vec4(1./2.2));\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ---------------------------------------------------------------------------------\n// Switch to high quality if you have no fear!\n// ---------------------------------------------------------------------------------\n//#define HIGH_QUALITY\n#define MEDIUM_QUALITY\n//#define LOW_QUALITY\n\n#ifdef HIGH_QUALITY\n    #define SCALE_FACTOR 1. \n    #define RAYTRACED_WATER 1 \n#endif\n\n#ifdef MEDIUM_QUALITY\n    #define SCALE_FACTOR 1. \n    #define RAYTRACED_WATER 0\n#endif\n\n#ifdef LOW_QUALITY\n    #define SCALE_FACTOR 2. \n    #define RAYTRACED_WATER 0 \n#endif\n\n\n\n\n#define saturate(x) clamp(x,0.,1.)\n#define PI 3.141592653589\n#define GOLDEN_RATIO 0.61803398875\n#define time iTime\n#define frame iFrame\n\nvec3 sundir = normalize( vec3(.5,1.,-2.) );\n\n\n\n// ---------------------------------------------------------------------------------\n// Maths toolbox\n// ---------------------------------------------------------------------------------\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\nvec3 hash3(vec3 p) {\n    uvec3 x = uvec3(p*100000.+1000.);\n    const uint k = 1103515245U; \n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec3 cosineDirection( vec3 p, in vec3 n)\n{\n    vec3 rnd = hash3(p+11.);\n\n    float a = 6.2831853 * rnd.y;\n    rnd.x = 2.0*rnd.x - 1.0;\n    return normalize( n + vec3(sqrt(1.0-rnd.x*rnd.x) * vec2(cos(a), sin(a)), rnd.x) );\n\n}\n\n// Still the same noise function from \"La calanque\"\n//Thx to Las^Mercury\nfloat noise(vec3 p)\n{\n    vec3 i = floor(p);\n    vec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n    vec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n    a = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n    a.xy = mix(a.xz, a.yw, f.y);\n    return mix(a.x, a.y, f.z)*.5+.5;\n}\n\n\n// ---------------------------------------------------------------------------------\n// Triplanar mapping + bump mapping! \n// clever code taken from Shane\n// https://www.shadertoy.com/view/MscSDB\n// ---------------------------------------------------------------------------------\nvec3 tex3D( sampler2D tex, vec3 p, vec3 n )\n{\n    n = abs(n);\n    vec4 col = texture(tex, p.yz)*n.x + texture(tex, p.xz)*n.y + texture(tex, p.xy)*n.z;\n    return pow(col.rgb,vec3(2.2));\n}\nvec3 bumpMapping( sampler2D tex, vec3 p, vec3 n, float bf )\n{\n    const vec2 e = vec2(0.001, 0);\n    \n    mat3 m = mat3( tex3D(tex, p - e.xyy, n).rgb,\n                   tex3D(tex, p - e.yxy, n).rgb,\n                   tex3D(tex, p - e.yyx, n).rgb);\n    \n    vec3 g = vec3(0.299, 0.587, 0.114) * m;\n    g = (g - dot( tex3D(tex,  p , n).rgb, vec3(0.299, 0.587, 0.114)) )/e.x;\n    g -= n * dot(n, g);\n                      \n    return normalize( n + g*bf );\n    \n}", "buffer_a_code": "// ---------------------------------------------------------------------------------\n// Water heightmap + caustic pass\n// I don't remember from where this code from... it's not mine for sure!\n// ---------------------------------------------------------------------------------\n\n#define DRAG_MULT 0.048\n\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\n    float x = dot(direction, position) * frequency + timeshift * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\nfloat getwaves(vec2 position, int iterations, float weight, float speed){\n    float iter = 0.0;\n    float phase = 6.0;\n    float w = 0.0;\n    float ws = 0.0;\n    for(int i=0;i<iterations;i++){\n        vec2 p = vec2(sin(iter), cos(iter));\n        vec2 res = wavedx(position, p, speed, phase, time);\n        position += normalize(p) * res.y * weight * DRAG_MULT;\n        w += res.x * weight;\n        iter += 12.0;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.2);\n        phase *= 1.18;\n        speed *= 1.07;\n    }\n    return w / ws;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    vec2 uv = fragCoord * invRes;\n    \n    float wave = getwaves(uv*15.,10,1., 0.5);\n    float caustic = pow(getwaves(uv*15.,10, 5., 1.), 5.);\n    fragColor = vec4(wave, caustic, 0., 0.);\n}", "buffer_a_inputs": [], "buffer_b_code": "// ---------------------------------------------------------------------------------\n// Raytracing pass\n// ---------------------------------------------------------------------------------\n\n\n\n\n// ---------------------------------------------------------------------------------\n// Signed Distance Field\n// ---------------------------------------------------------------------------------\nfloat terrain(vec3 p) {\n    \n    float d = length(abs(p.xy)+vec2(-220.,50.))-200.;\n    d = min(d, length(p.zy-vec2(-10.,60.))-50.+cos(p.x*.04)*10.);\n    d = min(d, length(p.zy-vec2(-400.,0.))-150.);\n    d = min(d, length(p.zy-vec2(400.,0.))-150.);\n    d = d*.2  + noise(p*.04-.9)*10. - noise(p*.2)*0.9+.5;\n    d = min(d, p.y*.5 + d);\n    return d;\n}\nfloat water(vec3 p) {\n#if RAYTRACED_WATER\n    return p.y - texture(iChannel2,p.xz*.01-.5).r;\n#else\n    return p.y;\n#endif\n}\n\nfloat map(vec3 p) {\n    float d1 = terrain(p);\n    float d2 = water(p);\n    float d = min(d1,d2);\n    return d;\n    \n}\n\n\n// ---------------------------------------------------------------------------------\n// Raytracing toolbox\n// ---------------------------------------------------------------------------------\n#define ZERO (min(iFrame,0)) // skip unroll loop\n\nvec3 raymarch(vec3 ro, vec3 rd, const vec2 nf) {\n    vec3 p = ro + rd * nf.x;\n    float l = 0.;\n    for(int i=ZERO; i<180; i++) {\n        float d = map(p)*2.;\n        l += d;\n        p += rd * d;\n        \n        if(abs(d)<.05 || l > nf.y)\n            break;\n    }\n    \n    return p;\n}\n\nvec3 normal( vec3 p )\n{\n    const float h = 0.1;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h);\n    }\n    return normalize(n);\n}\n\n\nvec3 raymarchUnderwater(vec3 ro, vec3 rd, const vec2 nf) {\n    vec3 p = ro + rd * nf.x;\n    float l = 0.;\n    for(int i=ZERO; i<64; i++) {\n        float d = terrain(p)*2.;\n        l += d;\n        p += rd * d;\n        \n        if(abs(d)<.05 || l > nf.y)\n            break;\n    }\n    \n    return p;\n}\n// Simplified version of https://www.shadertoy.com/view/4sdGWN - http://www.aduprat.com/portfolio/?page=articles/hemisphericalSDFAO\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n    const int nbIte = 6;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv;\n    \n    float ao = 0.0;\n    \n    for( int i=ZERO+1; i<nbIte; i++ )\n    {\n        float l = float(i)/float(nbIte)*maxDist;\n        vec3 rd = cosineDirection(p,n)*l;\n        \n        ao += (l - max(terrain( p + rd ),0.)) / maxDist * falloff;\n    }\n    \n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n// iq Soft Shadow - https://iquilezles.org/articles/rmshadows\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = terrain(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n// ---------------------------------------------------------------------------------\n// Shading\n// ---------------------------------------------------------------------------------\nvec3 sky( in vec3 rd )\n{\n    return mix(vec3(1.), vec3(0.2,.6,1.)*.5, 1.-exp(-rd.y*3.));\n}\n\nvec3 shade(vec3 ro, vec3 rd, vec3 p, vec3 n) {\n    float d = map(p);\n    \n    if (d > 3.) return sky(rd);\n    \n    vec3 albedo = tex3D(iChannel1,p*0.05,n)*.5;\n    //albedo = mix(albedo, vec3(1.)*sqrt(dot(albedo,albedo)), 0.2);\n    albedo *= mix(vec3(1.), vec3(1.,1.,0.3), smoothstep(0.6,1.,n.y)*smoothstep(0.0,2.,p.y));\n    n = bumpMapping(iChannel1,p*.05,n,.08);\n\n    // inspired by https://iquilezles.org/articles/outdoorslighting\n    float shad = shadow(p,sundir, .5,150., 50.);\n    float ao = pow(ambientOcclusion(p,n, 40.,2.7),1.25);\n    \n    vec3 diff = vec3(1.,.7,.3) * max(dot(n,sundir),0.) * pow(vec3(shad),vec3(1.0,1.2,1.7));\n    vec3 skyl = vec3(0.1,0.2,0.3) * (n.y*.5+.5) * ao;\n    vec3 bounce = vec3(1.,.7,.3) * max(dot( n, normalize(sundir*vec3(-1.0,0.0,-1.0))), 0.0) * ao;\n    vec3 caustic = vec3(1.) * texture(iChannel2,p.xz*0.02).g * smoothstep(50.,0.,p.y) * smoothstep(-.5,-1.,n.y) *(ao*.5+.5);\n    \n    return albedo * (diff*3. + skyl*6. + bounce*1. + caustic*2.);\n}\n\nvec3 calcPixel(vec3 ro, vec3 rd, float seed, inout vec3 firstP) {\n    \n    // Raytracing primary ray\n    vec3 p = raymarch(ro,rd, vec2(.1,600.));\n    firstP = p;\n    vec3 n = normal(p);\n    float d = map(p);\n    \n    \n    vec3 col;\n    if (terrain(p) == d) {\n        col = shade(ro,rd, p, n);\n    } else {\n    \n#if !RAYTRACED_WATER\n        n = bumpMapping(iChannel2, p*0.01-.7, n, 0.5/length(ro-p));\n#endif\n        \n        // Reflection\n        vec3 rro = p;\n        vec3 rrd = reflect(rd,n);\n        rrd = normalize(hash3(p+rand())*2.-1.+reflect(rd,n)*3000.);\n        \n        vec3 rp = raymarch(rro,rrd, vec2(.1,600.));\n        vec3 rn = normal(p);\n\n        vec3 reflectedCol = shade(rro,rrd, rp, rn);\n        \n        // Refraction\n        rro = p;\n        rrd = refract(rd,n, 1./1.33);\n        \n        rp = raymarchUnderwater(rro,rrd, vec2(.1,500.));\n        rn = normal(p);\n        vec3 refractedCol = shade(rro,rrd, rp, rn);\n        refractedCol += vec3(0.5) * pow(texture(iChannel2,rp.xz*0.02).g,2.) * smoothstep(0.,-30.,rp.y);// Add more fake caustics\n        refractedCol *= exp( -vec3(1.,.2,.1) * length(rp-p)*0.2); // Beer law for absorption! great blog post -> https://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n        \n        // Mix it with fresnel\n        float fre = pow( saturate( 1.0 + dot(n,rd)), 8.0 );\n        col = mix(refractedCol, reflectedCol , fre);\n    }\n    \n    return col;\n}\n\n// ---------------------------------------------------------------------------------\n// Entrypoint\n// ---------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    vec2 uv = fragCoord * invRes * SCALE_FACTOR;\n    \n    if(uv.x>1. || uv.y>1. )\n    {\n        fragColor = vec4(0.);\n        return;\n    } \n    \n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    vec2 jitt = vec2(0.);\n    jitt = vec2(rand()-.5, rand()-.5) * invRes;\n    vec2 v = -1.0+2.0*(uv+jitt);\n    v.x *= iResolution.x/iResolution.y;\n    \n    \n    // Camera ray\n    vec3 ro = vec3(0.,10.,185.-time*0.1);\n    vec3 rd = normalize( vec3(v.x, v.y, -4.) );\n    \n    // Depth of field\n    float focusDistance = 80.3;\n    float blurAmount = 0.1;\n    vec3 go = blurAmount*vec3( vec2(rand(),rand())*2.-1., 0.0 );\n    vec3 gd = normalize( rd*focusDistance - go );\n    vec3 uu = vec3(1.,0.,0.);\n    vec3 vv = vec3(0.,1.,0.);\n    ro += go.x*uu + go.y*vv;\n    rd += gd.x*uu + gd.y*vv;\n    \n    // Comput color\n    vec3 p;\n    vec3 col = calcPixel(ro, rd, seed, p);\n    \n    \n    // Output with temporal accumulation\n    vec4 lastCol = texture(iChannel0,uv/SCALE_FACTOR);\n    fragColor = mix(lastCol, vec4(saturate(col), length(ro-p)), .15);\n}", "buffer_b_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------\n// Light scattering pass\n// ---------------------------------------------------------------------------------\n\n\n// ---------------------------------------------------------------------------------\n// Signed Distance Field\n// ---------------------------------------------------------------------------------\nfloat terrain(vec3 p) {\n    \n    float d = length(abs(p.xy)+vec2(-220.,50.))-200.; // 2 cylinders \n    d = min(d, length(p.zy-vec2(-10.,60.))-50.+cos(p.x*.04)*10.);\n    d = min(d, length(p.zy-vec2(-400.,0.))-150.);\n    d = min(d, length(p.zy-vec2(400.,0.))-150.);\n    d = d*.2  + noise(p*.04-.9)*10. - noise(p*.2)*0.9+.5;\n    d = min(d, p.y*.5 + d);\n    return d;\n}\n// iq Soft Shadow - https://iquilezles.org/articles/rmshadows\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = terrain(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n// ---------------------------------------------------------------------------------\n// Scattering phase\n// ---------------------------------------------------------------------------------\nfloat phaseFunction(float lightDotView)\n{\n    const float k = .9;\n\tfloat v = 1.0 - k * k;\n\tv /= (4.0 * PI * pow(1.0 + k * k - (2.0 * k)*lightDotView, 1.5));\n\treturn v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    \n    // early exit (half resolution here)\n    vec2 uv = fragCoord * invRes * 2.;\n\tfloat l = texture(iChannel1, uv/SCALE_FACTOR).a;\n    if(uv.x>1. || uv.y>1. )\n    {\n        fragColor = vec4(0.);\n        return;\n    } \n    \n    // camera ray\n    vec2 v = -1.0+2.0*(uv);\n    v.x *= iResolution.x/iResolution.y;\n    vec3 ro = vec3(0.,10.,185.-time*0.1);\n    vec3 rd = normalize( vec3(v.x, v.y, -2.) );\n    \n    \n    \n    // blue noise jittering\n    const float eps = 0.1;\n    float jitt = fract(texture(iChannel2, fragCoord/1024.).r + float(frame)*GOLDEN_RATIO) * eps;\n    \n    // scatter loop\n    float phase = phaseFunction(dot(sundir,rd));\n    vec3 scattering = vec3(0.);\n    for(float i=jitt; i<1.; i+=eps) {\n       vec3 p = ro+rd*l*i;\n       float d = shadow(p,sundir, 2.,200., 500.);\n       scattering += d * phase;\n    }\n    \n    fragColor = mix(texture(iChannel0,uv*.5), vec4(vec3(1.,.7,.5)*scattering*.15, l), .15);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3XDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[191, 191, 246, 246, 823]], "test": "untested"}
{"id": "7tKGDW", "name": "closed fractional julia: c = -2", "author": "incription", "description": "(MOVE MOUSE TO SET S) this is the fractional julia for c = -2. The fractional iterate M[s] has a closed form. For other values of C there is no known closed form, and it is likely that there is none. Set the escape radius to 2 to see the regular julia.", "tags": ["fractal", "julia", "fractional"], "likes": 12, "viewed": 254, "published": 3, "date": "1639182866", "time_retrieved": "2024-07-30T18:42:58.407688", "image_code": "#define ONE vec2(1., 0.)\n#define TWO vec2(2., 0.)\n\nfloat dot2(vec2 a) { return a.x * a.x + a.y * a.y; }\nvec2 c(float x){return vec2(x, 0.);}\nvec2 c_mul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\nvec2 c_div(vec2 a, vec2 b) {\n    return c_mul(a.yx,b.xy).yx/dot2(b);\n}\nvec2 c_exp(in vec2 a) {\n    float ea = exp(a.x);\n    float vl = a.y;\n    return ea * vec2( cos(vl), sin(vl) );\n}\nvec2 c_ln(in vec2 a) {\n    float ql = length(a);\n    return vec2( log(ql), atan(a.y, a.x));\n}\nvec2 c_pow(in vec2 a, in vec2 b) {\n    return c_exp(c_mul(c_ln(a), b));   \n}\nvec2 c_sqrt(vec2 a) {\n    return c_pow(a, c(.5));\n}\nvec2 c_cosh(vec2 a) {\n    return c_div( c_exp(a) + c_exp(-a), TWO);\n}\nvec2 c_acosh(vec2 z) {\n  return c_ln(z+c_mul(c_sqrt(z+vec2(1,0)),c_sqrt(z-vec2(1,0))));\n}\n\nvec2 Mint(vec2 x) { return c_mul(x, x) - TWO; }\n\nvec2 M(vec2 x, vec2 s) {\n    //float rt = 1.4142;\n    //vec2 sum = vec2(0);\n    //float[10] m = float[10](1., rt, -rt, rt - 2., 1., -rt, 1.-3./rt, rt-4., rt, -2.-rt);\n    //for(int i=0;i<5;i++){\n    //    float mult = m[i*2];\n    //    float power = m[i*2+1];\n    //    sum += c_mul( c(mult), c_pow( x, c(power)));\n    //}\n    //return sum;\n    //return c_mul(x, x) - c(2.);\n    //return c_mul( TWO, c_cosh( c_mul( TWO, c_acosh( c_div( x, TWO )))));\n    return c_mul( TWO, c_cosh( c_mul( c_pow(TWO, s), c_acosh( c_div( x, TWO )))));\n}\n\nfloat Miter(vec2 x, vec2 s, int iter) {\n    vec2 z = x; int i;\n    for(i=0;i<iter;i++) {\n        if(dot2(z) > 2000.) break; //iTime*100. -> ~2000 or 4.\n        z = M(z, s);\n    }\n    return float(i)/float(iter);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n    //uv *= iMouse.x/iResolution.x;\n    vec2 z = uv.xy * 4.;\n    vec2 s = 4. * (iMouse.xy/iResolution.xy - .5);\n    if (iMouse.xy==vec2(0)) s = vec2(.35-iTime/80., -2.63-iTime/60.);\n    int i = 100;\n    float iter = Miter(z, s, i);\n    \n    fragColor = vec4(vec3(iter), 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKGDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 71, 71, 103], [104, 104, 120, 120, 140], [141, 141, 169, 169, 222], [223, 223, 251, 251, 293], [294, 294, 317, 317, 406], [407, 407, 429, 429, 500], [501, 501, 535, 535, 577], [578, 578, 599, 599, 629], [630, 630, 651, 651, 699], [700, 700, 722, 722, 789], [791, 791, 810, 810, 838], [840, 840, 864, 1289, 1374], [1376, 1376, 1415, 1415, 1589], [1591, 1591, 1648, 1698, 2062]], "test": "untested"}
{"id": "ft3XDM", "name": "Custom Runtime Palettes", "author": "mthompsen", "description": "Is designed to run off any input array of colors and palletize the image, limiting the colors to the colors within the array. Click down to transition to palettized colors.", "tags": ["palette"], "likes": 1, "viewed": 413, "published": 3, "date": "1639178399", "time_retrieved": "2024-07-30T18:42:59.492787", "image_code": "/*\nFinally, actual screen output.\n*/\n\n//Blur stuff, might be used at a later date\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nfloat lookup(vec2 p, float dx, float dy, float d)\n{\n    vec2 uv = (p.xy + vec2(dx * d, dy * d)) / iResolution.xy;\n    vec4 col = texture(iChannel1, uv.xy);\n\t\n\t// return as luma\n    return 0.2126*col.r + 0.7152*col.g + 0.0722*col.b;\n}\n//Edge detection, maybe combine this to help find pixel transitions?\nfloat getEdge(vec2 p, float d) {\n    // simple sobel edge detection\n    float gx = 0.0;\n    gx += -1.0 * lookup(p, -1.0, -1.0, d);\n    gx += -2.0 * lookup(p, -1.0,  0.0, d);\n    gx += -1.0 * lookup(p, -1.0,  1.0, d);\n    gx +=  1.0 * lookup(p,  1.0, -1.0, d);\n    gx +=  2.0 * lookup(p,  1.0,  0.0, d);\n    gx +=  1.0 * lookup(p,  1.0,  1.0, d);\n    \n    float gy = 0.0;\n    gy += -1.0 * lookup(p, -1.0, -1.0, d);\n    gy += -2.0 * lookup(p,  0.0, -1.0, d);\n    gy += -1.0 * lookup(p,  1.0, -1.0, d);\n    gy +=  1.0 * lookup(p, -1.0,  1.0, d);\n    gy +=  2.0 * lookup(p,  0.0,  1.0, d);\n    gy +=  1.0 * lookup(p,  1.0,  1.0, d);\n    \n\t// hack: use g^2 to conceal noise in the video\n    return gx*gx + gy*gy;\n}\n\n//Gaussian Blurring\nvec3 gaussBlur( sampler2D tex, vec2 uv, float lod, float sigma)\n{\n    float rounds = sigma * 2.;\n    float invTwoSigmaSqr = 1. / (2. * sigma * sigma);\n    vec2 d = vec2(exp2(lod)/iChannelResolution[0].xy);\n    vec4 col = textureLod(tex, uv, lod);\n    \n    for (float i = 1.; i < rounds; ++i) {\n        col += (\n        textureLod(tex, uv + d * i, lod) +\n        textureLod(tex, uv - d * i, lod)\n        ) * exp(- i * i * invTwoSigmaSqr);\n    }\n    \n    return col.rgb/col.a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col;\n    //Unneccessary Currently\n    //float edge = getEdge(fragCoord.xy, 1.2);\n    \n    if (iMouse.z > 0.0) {\n        col = texture(iChannel1, uv).rgb; //gaussBlur(iChannel1, uv, 1., 4.*max(edge-0.2, 0.0)); //My attempt to blur around the edges.\n    } else {\n        col = texture(iChannel0, uv).rgb;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "precision highp float;\nprecision highp int;\n\nconst float EPSILON = 1e-10;\n\nconst float eps = 216.f/24389.f;\nconst float kap = 24389.f/27.f;\nconst vec3  d65_2deg = vec3(0.95047,1.00000,1.08883);\nconst mat3 rgb2xyz_mat = \n    mat3(0.4124564,0.3575761,0.1804375,\n         0.2126729,0.7151522,0.0721750,\n         0.0193339,0.1191920,0.9503041);\nconst mat3 xyz2rgb_mat =\n\tmat3( 3.2404542, -1.5371385, -0.4985314,\n\t\t -0.9692660,  1.8760108,  0.0415560,\n\t      0.0556434, -0.2040259,  1.0572252);\n          \n\n//controls palette array size\nconst float iter = 10.;\nconst int numColors = int(iter*iter*iter);\nconst float oneOver = 1./iter;\n\n//testing for color space conversions as RGB differences don't match the eyes that well\n#define convert false\n#define method 0\n\nvec3 HUEtoRGB(in float hue)\n{\n    // Hue [0..1] to RGB [0..1]\n    // See http://www.chilliant.com/rgb2hsv.html\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\n\nvec3 RGBtoHCV(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Chroma-Value [0..1]\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1., 2. / 3.) : vec4(rgb.gb, 0., -1. / 3.);\n    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);\n    float c = q.x - min(q.w, q.y);\n    float h = abs((q.w - q.y) / (6. * c + EPSILON) + q.z);\n    return vec3(h, c, q.x);\n}\n\nvec3 HSVtoRGB(in vec3 hsv)\n{\n    // Hue-Saturation-Value [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsv.x);\n    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nvec3 HSLtoRGB(in vec3 hsl)\n{\n    // Hue-Saturation-Lightness [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsl.x);\n    float c = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * c + hsl.z;\n}\n\nvec3 RGBtoHSV(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Saturation-Value [0..1]\n    vec3 hcv = RGBtoHCV(rgb);\n    float s = hcv.y / (hcv.z + EPSILON);\n    return vec3(hcv.x, s, hcv.z);\n}\n\nvec3 RGBtoHSL(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Saturation-Lightness [0..1]\n    vec3 hcv = RGBtoHCV(rgb);\n    float z = hcv.z - hcv.y * 0.5;\n    float s = hcv.y / (1. - abs(z * 2. - 1.) + EPSILON);\n    return vec3(hcv.x, s, z);\n}\n\nfloat compand(float f){\n    return pow(f,2.2f);//>0.04045? pow(((f+0.055f)/1.055f),2.4f): f/12.92f;\n}\nfloat invcompand(float f){\n    return pow(f,1.f/2.2f);\n}\n\n\nvec3 rgb2xyz(vec3 rgb){\n\trgb.r = compand(rgb.r);\n\trgb.g = compand(rgb.g);\n\trgb.b = compand(rgb.b);\n    return rgb*rgb2xyz_mat;\n}\nvec3 xyz2rgb(vec3 xyz){\n    xyz *= xyz2rgb_mat;\n\txyz.x = invcompand(xyz.x);\n\txyz.y = invcompand(xyz.y);\n\txyz.z = invcompand(xyz.z);\n    return xyz;\n}\n\nvec3 xyz2lab(vec3 xyz){\n    vec3 f;\n    f.x = xyz.x>eps? pow(xyz.x,1.f/3.f) : (kap*xyz.x+16.f)/116.f;\n    f.y = xyz.y>eps? pow(xyz.y,1.f/3.f) : (kap*xyz.y+16.f)/116.f;\n    f.z = xyz.z>eps? pow(xyz.z,1.f/3.f) : (kap*xyz.z+16.f)/116.f;\n    return vec3(116.f* f.y-16.f,\n                500.f*(f.x-f.y),\n                200.f*(f.y-f.z))/vec3(100)/d65_2deg;\n}\n\nvec3 lab2xyz(vec3 lab){\n    lab *= 100.f;\n    lab *= d65_2deg;\n    float fy = (lab.x+16.f)/116.f;\n    float fx = lab.y/500.f + fy;\n    float fz = fy - (lab.z/200.f);\n    float fx3 = pow(fx,3.f);\n    float fz3 = pow(fz,3.f);\n    return vec3(\n    \tfx3>eps? fx3: (116.f*fx-16.f)/kap,\n        lab.x > (kap*eps)? pow((lab.x+16.f)/116.f,3.f): lab.x/kap,\n        fz3>eps? fz3: (116.f*fz-16.f)/kap);\n}\n\n#define PI 3.1415926535897932384626433832795\n#define EULER 2.7182818284590452353602874713527\n\n\n/*\n * Structures\n */\n\n// Parameters for transfer characteristics (gamma curves)\nstruct transfer {\n\t// Exponent used to linearize the signal\n\tfloat power;\n\n\t// Offset from 0.0 for the exponential curve\n\tfloat off;\n\n\t// Slope of linear segment near 0\n\tfloat slope;\n\n\t// Values below this are divided by slope during linearization\n\tfloat cutoffToLinear;\n\n\t// Values below this are multiplied by slope during gamma correction\n\tfloat cutoffToGamma;\n};\n\n// Parameters for a colorspace\nstruct rgb_space {\n\t// Chromaticity coordinates (xyz) for Red, Green, and Blue primaries\n\tmat3 primaries;\n\n\t// Chromaticity coordinates (xyz) for white point\n\tvec3 white;\n\n\t// Linearization and gamma correction parameters\n\ttransfer trc;\n};\n\n\n/*\n * Preprocessor 'functions' that help build colorspaces as constants\n */\n\n// Turns 6 chromaticity coordinates into a 3x3 matrix\n#define Primaries(r1, r2, g1, g2, b1, b2)\\\n\tmat3(\\\n\t\tr1, r2, 1.0 - r1 - r2,\\\n\t\tg1, g2, 1.0 - g1 - g2,\\\n\t\tb1, b2, 1.0 - b1 - b2)\n\n// Creates a whitepoint's xyz chromaticity coordinates from the given xy coordinates\n#define white(x, y)\\\n\tvec3(x, y, (1.0 - x - y))\n\n#define Bright(w)\\\n\t((w)/w.y)\n\n// Creates a scaling matrix using a vec3 to set the xyz scalars\n#define diag(v)\\\n\tmat3(\\\n\t\t(v).x, 0.0, 0.0,\\\n\t\t0.0, (v).y, 0.0,\\\n\t\t0.0, 0.0, (v).z)\n\n// Creates a conversion matrix that turns RGB colors into XYZ colors\n#define rgbToXyz(space)\\\n\tspace.primaries*diag((inverse(space.primaries)*Bright(space.white)))\n\n// Creates a conversion matrix that turns XYZ colors into RGB colors\n#define xyzToRgb(space)\\\n\tinverse(rgbToXyz(space))\n\n// Creates a conversion matrix converts linear RGB colors from one colorspace to another\n#define conversionMatrix(f, t)\\\n\txyzToRgb(t)*rgbToXyz(f)\n\n\nconst mat3 CIECAM02 = mat3(\n\t0.7328, -0.7036, 0.003,\n\t0.4296, 1.6975, 0.0136,\n\t-0.1624, 0.0061, 0.9834\n);\n\nconst mat3 HUNT = mat3(\n\t0.38971, -0.22981, 0,\n\t0.68898, 1.1834, 0,\n\t-0.07868, 0.04641, 1\n);\n\nconst mat3 CIECAM97_1 = mat3(\n\t0.8951, -0.7502, 0.0389,\n\t0.2664, 1.7135, -0.0685,\n\t-0.1614, 0.0367, 1.0296\n);\n\nconst mat3 CIECAM97_2 = mat3(\n\t0.8562, -0.836, 0.0357,\n\t0.3372, 1.8327, -0.0469,\n\t-0.1934, 0.0033, 1.0112\n);\n\n\n/*\n * Chromaticities for RGB primaries\n */\n\n// Identity RGB\nconst mat3 primariesIdentity = mat3(1.0);\n\n// CIE 1931 RGB\nconst mat3 primariesCie = Primaries(\n\t0.72329, 0.27671,\n\t0.28557, 0.71045,\n\t0.15235, 0.02\n);\n\n// Original 1953 NTSC primaries\nconst mat3 primariesNtsc = Primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.14, 0.08\n);\n\n// Never-popular and antiquated 'HDTV' primaries based mostly on 1953 NTSC\nconst mat3 primaries240m = Primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.15, 0.06\n);\n\n// European Broadcasting Union primaries for SDTV and Rec. 601 (625 lines)\nconst mat3 primariesEbu = Primaries(\n\t0.64, 0.33,\n\t0.29, 0.6,\n\t0.15, 0.06\n);\n\n// P22 Phosphor primaries (allegedly; only found one source)\n// Used by older versions of SMPTE-C, before specific chromaticities were given\nconst mat3 primariesP22 = Primaries(\n\t0.61, 0.342,\n\t0.298, 0.588,\n\t0.151, 0.064\n);\n\n// Modern day SMPTE-C primaries, used in modern NTSC and Rec. 601 (525 lines)\nconst mat3 primariesSmpteC = Primaries(\n\t0.63, 0.34,\n\t0.31, 0.595,\n\t0.155, 0.07\n);\n\n// Alleged primaries for old Sony TVs with a very blue whitepoint\nconst mat3 primariesSony = Primaries(\n\t0.625, 0.34,\n\t0.28, 0.595,\n\t0.155, 0.07\n);\n\n// Rec. 709 (HDTV) and sRGB primaries\nconst mat3 primaries709 = Primaries(\n\t0.64, 0.33,\n\t0.3, 0.6,\n\t0.15, 0.06\n);\n\n// Rec. 709 (HDTV) and sRGB primaries\nconst mat3 primariesAdobe = Primaries(\n\t0.64, 0.33,\n\t0.21, 0.71,\n\t0.15, 0.06\n);\n\n// DCI-P3 primaries\nconst mat3 primariesDciP3 = Primaries(\n\t0.68, 0.32,\n\t0.265, 0.69,\n\t0.15, 0.06\n);\n\n// Rec. 2020 UHDTV primaries\nconst mat3 primaries2020 = Primaries(\n\t0.708, 0.292,\n\t0.17, 0.797,\n\t0.131, 0.046\n);\n\n// If the HUNT XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesHunt = Primaries(\n\t0.8374, 0.1626,\n\t2.3, -1.3,\n\t0.168, 0.0\n);\n\n// If the CIECAM97_1 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam971 = Primaries(\n\t0.7, 0.306,\n\t-0.357, 1.26,\n\t0.136, 0.042\n);\n\n// If the CIECAM97_2 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam972 = Primaries(\n\t0.693, 0.316,\n\t-0.56, 1.472,\n\t0.15, 0.067\n);\n\n// If the CIECAM02 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam02 = Primaries(\n\t0.711, 0.295,\n\t-1.476, 2.506,\n\t0.144, 0.057\n);\n\n// LMS primaries as chromaticity coordinates, computed from\n// http://www.cvrl.org/ciepr8dp.htm, and\n// http://www.cvrl.org/database/text/cienewxyz/cie2012xyz2.htm\n/*const mat3 primariesLms = Primaries(\n\t0.73840145, 0.26159855,\n\t1.32671635, -0.32671635,\n\t0.15861916, 0.0\n);*/\n\n// Same as above, but in fractional form\nconst mat3 primariesLms = Primaries(\n\t194735469.0/263725741.0, 68990272.0/263725741.0,\n\t141445123.0/106612934.0, -34832189.0/106612934.0,\n\t36476327.0/229961670.0, 0.0\n);\n\n\n/*\n * Chromaticities for white points\n */\n\n// Standard Illuminant C. White point for the original 1953 NTSC color system\nconst vec3 whiteC = white(0.310063, 0.316158);\n\n// Standard illuminant E (also known as the 'equal energy' white point)\nconst vec3 whiteE = vec3(1.0);\n\n// Alleged whitepoint to use with the P22 phosphors (D65 might be more proper)\nconst vec3 whiteP22 = white(0.313, 0.329);\n\n// Standard illuminant D65. Note that there are more digits here than specified\n// in either sRGB or Rec 709, so in some cases results may differ from other\n// software. Color temperature is roughly 6504 K (originally 6500K, but complex\n// science stuff made them realize that was innaccurate)\nconst vec3 whiteD65 = white(0.312713, 0.329016);\n\n// Standard illuminant D65 according to sRGB, Rec. 709, and other display standards\nconst vec3 whiteD65S = white(0.3127, 0.3290);\n\n// Standard illuminant D50. Just included for the sake of including it. Content\n// for Rec. 709 and sRGB is recommended to be produced using a D50 whitepoint.\n// For the same reason as D65, the color temperature is 5003 K instead of 5000 K\nconst vec3 whiteD50 = white(0.34567, 0.35850);\n\n// Standard illuminant D50 according to ICC standards (they specify a hex value\n// for the 16-bit integer representation, as well as a specific way to decode it,\n// so I did some math to figure out exactly the values they expect)\n\n// Floating point representation of ICC D50\nconst vec3 whiteD50I = white(3214.0/9297.0, 10000.0/27891.0);\n\n// White point for DCI-P3 Theater\nconst vec3 whiteTheater = white(0.314, 0.351);\n\n// Very blue white point for old Sony televisions. Color temperature of 9300 K.\n// Use with the 'primariesSony' RGB primaries defined above\nconst vec3 whiteSony = white(0.283, 0.298);\n\n\n/*\n * Gamma curve parameters\n */\n\n// Linear gamma\nconst transfer gam10 = transfer(1.0, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.2; not linear near 0. Was defined abstractly to be used by early\n// NTSC systems, before SMPTE 170M was modified to specify a more exact curve\nconst transfer gam22 = transfer(2.2, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.4; not linear near 0. Seems a popular choice among some people\n// online, so I included it. I don't think any standard uses this\nconst transfer gam24 = transfer(2.4, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.5; not linear near 0. Approximately what old Sony TVs used\nconst transfer gam25 = transfer(2.5, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.8; not linear near 0. Loosely defined gamma for European SDTV\nconst transfer gam28 = transfer(2.8, 0.0, 1.0, 0.0, 0.0);\n\n// Modern SMPTE 170M, as well as Rec. 601, Rec. 709, and a rough approximation\n// for Rec. 2020 content as well. Do not use with Rec. 2020 if you work with\n// high bit depths!\nconst transfer gam170m = transfer(1.0/0.45, 0.099, 4.5, 0.0812, 0.018);\n\n// Gamma for sRGB. This is the only difference between sRGB and Rec. 709\nconst transfer gamSrgb = transfer(2.4, 0.055, 12.92, 0.04045, 0.0031308);\n\n// Gamma for the CIE L*a*b* Lightness scale\nconst transfer gamLab = transfer(3.0, 0.16, 243.89/27.0, 0.08, 216.0/24389.0);\n\n\n/*\n * RGB Colorspaces\n */\n\n// CIE 1931 RGB\nconst rgb_space Cie1931 = rgb_space(primariesCie, whiteE, gam10);\n\n// Identity RGB\nconst rgb_space Identity = rgb_space(primariesIdentity, whiteE, gam10);\n\n// Original 1953 NTSC\nconst rgb_space Ntsc = rgb_space(primariesNtsc, whiteC, gam22);\n\n// Mostly unused and early HDTV standard (SMPTE 240M)\nconst rgb_space Smpte240m = rgb_space(primaries240m, whiteD65S, gam22);\n\n// European Broadcasting Union SDTV\nconst rgb_space Ebu = rgb_space(primariesEbu, whiteD65S, gam28);\n\n// Original, imprecise colorspace for NTSC after 1987 (probably incorrect)\nconst rgb_space SmpteC = rgb_space(primariesP22, whiteD65S, gam22);\n\n// Modern SMPTE \"C\" colorimetry\nconst rgb_space Smpte170m = rgb_space(primariesSmpteC, whiteD65S, gam170m);\n\n// Old Sony displays using high temperature white point\nconst rgb_space Sony = rgb_space(primariesSony, whiteSony, gam25);\n\n// Rec. 709 (HDTV)\nconst rgb_space Rec709 = rgb_space(primaries709, whiteD65S, gam170m);\n\n// sRGB (mostly the same as Rec. 709, but different gamma)\nconst rgb_space Srgb = rgb_space(primaries709, whiteD65S, gamSrgb);\n\n// Adobe RGB monitors\nconst rgb_space AdobeRgb = rgb_space(primariesAdobe, whiteD65S, gam22);\n\n// DCI-P3 D65\nconst rgb_space DciP3D65 = rgb_space(primariesDciP3, whiteD65S, gam170m);\n\n// DCI-P3 D65\nconst rgb_space DciP3Theater = rgb_space(primariesDciP3, whiteTheater, gam170m);\n\n// Rec. 2020\nconst rgb_space Rec2020 = rgb_space(primaries2020, whiteD65S, gam170m);\n\n// Hunt primaries, balanced against equal energy white point\nconst rgb_space HuntRgb = rgb_space(primariesHunt, whiteE, gam10);\n\n// CIE CAM 1997 primaries v1, balanced against equal energy white point\nconst rgb_space Ciecam971Rgb = rgb_space(primariesCiecam971, whiteE, gam10);\n\n// CIE CAM 1997 primaries v2, balanced against equal energy white point\nconst rgb_space Ciecam972Rgb = rgb_space(primariesCiecam972, whiteE, gam10);\n\n// CIE CAM 2002 primaries, balanced against equal energy white point\nconst rgb_space Ciecam02Rgb = rgb_space(primariesCiecam02, whiteE, gam10);\n\n// Lms primaries, balanced against equal energy white point\nconst rgb_space LmsRgb = rgb_space(primariesLms, whiteE, gam10);\n\n\n/**********************************************************\n *                                                        *\n *  Change these to adjust various conversion parameters  *\n *                                                        *\n **********************************************************/\n\n// Display colorspace\nconst rgb_space disp = rgb_space(primaries709, whiteD65S, gamSrgb);\n\n// Color Appearance Model (or 'reference') white point\nconst vec3 whiteCam = whiteD50I;\n\n// camMat is an easy way to set the transformation matrix, but both\n// toCam and frCam are what should be used, as they're adapted to the\n// color appearance model white point\nconst mat3 camMat = CIECAM97_1;\nconst mat3 toCam = inverse(diag(camMat*Bright(whiteCam)))*camMat;\nconst mat3 frCam = inverse(camMat)*diag(camMat*Bright(whiteCam));\n\n// Modify XYZRGB matrices to perform whitepoint adaptation using a\n// wrong Von Kries transformation matrix (CIECAM97_1 has nonlinearities\n// in the 'S' cone that is not accounted for in ICC profiles)\nconst mat3 toRgb = xyzToRgb(disp)*frCam*diag((toCam*Bright(disp.white))/(toCam*Bright(whiteCam)))*toCam;\nconst mat3 toXyz = frCam*diag((toCam*Bright(whiteCam))/(toCam*Bright(disp.white)))*toCam*rgbToXyz(disp);\n\n// This might be easier to understand ( shows matrix multiplication):\n// toRgb = XYZtoRGBLMStoXYZdiag(whiteDispInLMS/whiteCamInLMS)XYZtoLMS\n// toXyz = LMStoXYZdiag(whiteCamInLMS/whiteDispInLMS)XYZtoLMSRGBtoXYZ\n\n\n/*\n * Conversion Functions\n */\n\nvec4 gamutScale(vec4 color, float luma)\n{\n\tfloat low = min(color.r, min(color.g, min(color.b, 0.0)));\n\tfloat high = max(color.r, max(color.g, max(color.b, 1.0)));\n\n\tfloat lowScale = low/(low - luma);\n\tfloat highScale = max((high - 1.0)/(high - luma), 0.0);\n\tfloat scale = max(lowScale, highScale);\n\tcolor.rgb += scale*(luma - color.rgb);\n\n\treturn color;\n}\n\n// Converts display RGB colors to a linear light scale\nvec4 toLinear(vec4 color, const transfer trc)\n{\n\tbvec4 cutoff = lessThan(color, vec4(trc.cutoffToLinear));\n\tvec4 higher = pow((color + trc.off)/(1.0 + trc.off), vec4(trc.power));\n\tvec4 lower = color/trc.slope;\n\n\tcolor = mix(higher, lower, cutoff);\n\n\treturn color;\n}\n\n// Gamma-corrects RGB colors to be sent to a display\nvec4 toGamma(vec4 color, const transfer trc)\n{\n\tbvec4 cutoff = lessThan(color, vec4(trc.cutoffToGamma));\n\tvec4 higher = (1.0 + trc.off)*pow(color, vec4(1.0/trc.power)) - trc.off;\n\tvec4 lower = color*trc.slope;\n\n\tcolor = mix(higher, lower, cutoff);\n\n\treturn color;\n}\nvec3 lab2rgb(vec3 col) {\n    vec4 color = vec4(col, 1.0);\n    // Convert to XYZ\n\tcolor.y = (color.y + 16.0)/116.0;\n\tcolor.xz = color.y + color.xz/vec2(500, -200);\n\tcolor.xyz = (116.0*color.xyz - 16.0)/100.0;\n\tcolor = toLinear(color, gamLab);\n\tcolor.xyz *= Bright(whiteCam);\n\n\t// Convert to RGB\n\tfloat luma = color.y;\n\tcolor.rgb = toRgb*color.xyz;\n\tcolor = gamutScale(color, luma);\n\tcolor = toGamma(color, disp.trc);\n    if (method == 1) {\n        return color.rgb;\n    } else {\n        return xyz2rgb(lab2xyz(col));\n    }\n}\nvec3 rgb2lab(vec3 col) {\n    vec4 color = vec4(col, 1.0);\n    // Convert to XYZ\n\tcolor = toLinear(color, disp.trc);\n\tcolor.xyz = toXyz*color.rgb;\n\n\t// Convert to L*a*b*\n\t// L* is held in .y (to match XYZ luminosity); a*b* is held in .xz\n\tcolor.xyz /= Bright(whiteCam);\n\tcolor = toGamma(color, gamLab);\n\tcolor.xyz = (color.xyz*100.0 + 16.0)/116.0;\n\tcolor.xz = (color.xz - color.y)*vec2(500, -200);\n\tcolor.y = color.y*116.0 - 16.0;\n    vec3 _col = color.yzx;\n    if (method == 1) {\n        return _col.rgb;\n    } else {\n        return xyz2lab(rgb2xyz(col));\n    }\n}\n\n", "buffer_b_code": "/*\nIn this buffer we do the heavy lifting of converting the image to the palette colors.\nDesigned to be used with still images, this makes certain that it is only run when needed instead of each frame.\nThat way, we can save on GPU time without compromising the intended purpose.\n*/\n//Blur stuff, might be used at a later date\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nfloat lookup(vec2 p, float dx, float dy, float d)\n{\n    vec2 uv = (p.xy + vec2(dx * d, dy * d)) / iResolution.xy;\n    vec4 col = texture(iChannel1, uv.xy);\n\t\n\t// return as luma\n    return 0.2126*col.r + 0.7152*col.g + 0.0722*col.b;\n}\n#define useArray false\n//Edge detection, maybe combine this to help find pixel transitions?\nfloat getEdge(vec2 p, float d) {\n    // simple sobel edge detection\n    float gx = 0.0;\n    gx += -1.0 * lookup(p, -1.0, -1.0, d);\n    gx += -2.0 * lookup(p, -1.0,  0.0, d);\n    gx += -1.0 * lookup(p, -1.0,  1.0, d);\n    gx +=  1.0 * lookup(p,  1.0, -1.0, d);\n    gx +=  2.0 * lookup(p,  1.0,  0.0, d);\n    gx +=  1.0 * lookup(p,  1.0,  1.0, d);\n    \n    float gy = 0.0;\n    gy += -1.0 * lookup(p, -1.0, -1.0, d);\n    gy += -2.0 * lookup(p,  0.0, -1.0, d);\n    gy += -1.0 * lookup(p,  1.0, -1.0, d);\n    gy +=  1.0 * lookup(p, -1.0,  1.0, d);\n    gy +=  2.0 * lookup(p,  0.0,  1.0, d);\n    gy +=  1.0 * lookup(p,  1.0,  1.0, d);\n    \n\t// hack: use g^2 to conceal noise in the video\n    return gx*gx + gy*gy;\n}\n\n//Gaussian Blurring\nvec3 gaussBlur( sampler2D tex, vec2 uv, float lod, float sigma)\n{\n    float rounds = sigma * 2.;\n    float invTwoSigmaSqr = 1. / (2. * sigma * sigma);\n    vec2 d = vec2(exp2(lod)/iChannelResolution[0].xy);\n    vec4 col = textureLod(tex, uv, lod);\n    \n    for (float i = 1.; i < rounds; ++i) {\n        col += (\n        textureLod(tex, uv + d * i, lod) +\n        textureLod(tex, uv - d * i, lod)\n        ) * exp(- i * i * invTwoSigmaSqr);\n    }\n    \n    return col.rgb/col.a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int index = 0;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Get original color variables\n    vec3 col = texture(iChannel0, uv).rgb;\n    vec3 ocol = col;\n    vec3 newCol;\n    \n    //Sample pixel for storing data [not working currently]\n    vec4 samplePix = texture(iChannel1, vec2(1.0));\n    if (iFrame < 3) {\n        //For sample pixel, not working currently though\n        /*if (fragCoord.x >= iResolution.x-1.5 && fragCoord.y >= iResolution.y-1.5) {\n            newCol = vec3(1.0);\n        } else {*/\n            if (convert) {\n                col = RGBtoHSV(col);\n            }\n            float minDist = 10000.0;\n            float dist = 0.0;\n            vec3 colRedef;\n            newCol = col;\n            if (useArray) {\n                for (int i = 0; i < numColors; i++) {\n                    int indexA = i;\n                    float j = mod(float(i), 100.0);\n                    float k = round(float(i)/100.0);\n                    colRedef = texture(iChannel1, vec2(float(i)/iChannelResolution[1].x, 0.0)).rgb;\n                    dist = distance(col, colRedef);\n                    if (dist < minDist) {\n                        minDist = dist;\n                        newCol = colRedef;\n                    }\n                }\n            } else {\n                //Define outside for loop, per AMD: https://www.amd.com/system/files/TechDocs/25112.PDF\n                float i,j,k;\n                for (i = 0.0; i <= 1.0; i += oneOver) {\n                    for (k = 0.0; k <= 1.0; k += oneOver) {\n                        for (j = 0.0; j <= 1.0; j += oneOver) {\n                            //Get the new color\n                            colRedef = vec3(i, j, k);\n                            //Compare with old color\n                            dist = distance(col, colRedef);\n                            //if less than old record holder then we have a winner (until the new record is broken)\n                            if (dist < minDist) {\n                                //was testing blurring distances. No significant impact until too extreme using this implementation.\n                                /*for (float d = 0.; d < 360.; d += 45.) {\n                                    float _d = (d/180.0)*3.1415982;\n                                    float dx = cos(d)/iResolution.x;\n                                    float dy = sin(d)/iResolution.y;\n                                    vec3 ncol = texture(iChannel0, uv+vec2(dx, dy)*2.).rgb;\n                                    dist += distance(ncol, colRedef)/3.0;\n                                }\n                                if (dist < minDist) {*/\n                                    //Award them their titles.\n                                    minDist = dist;\n                                    newCol = colRedef;\n                                //}\n                            }\n                        }\n                    } \n                }\n            }\n            if (convert) {\n                newCol = HSVtoRGB(newCol);\n            }\n        //}\n    } else {\n        //If not first frame just skip over it, no need to do the work again.\n        newCol = texture(iChannel1, uv).rgb;\n    }\n    // Output color\n    fragColor = vec4((newCol), 1.0);\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "/*\nThis shader just holds whatever image we want to operate on. Useful for changing the image quicker.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "buffer_c_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3XDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 82, 125, 125, 178], [180, 180, 231, 231, 413], [414, 483, 515, 550, 1192], [1194, 1214, 1279, 1279, 1690], [1692, 1692, 1749, 1799, 2224]], "test": "untested"}
{"id": "NtcSWM", "name": "Deep in the Woods", "author": "xavierseb", "description": "Another lucky find, reminds me of Little Red Riding Hood fairytale in the enchanted forest.", "tags": ["3d", "geometry"], "likes": 10, "viewed": 271, "published": 3, "date": "1639170007", "time_retrieved": "2024-07-30T18:43:00.377421", "image_code": "// Deep in the Woods\n\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\nconst float TAU = 6.28;   //atan(1.0) * 8.0;\n#define A(u,w) \tk=length(p.xy);p.x=k*(mod(atan(p.y,p.x),TAU/u)-TAU/u/2.);p.y=k-w\t\t\n#define B(u,w) \tk=length(p.yz);p.y=k*(mod(atan(p.z,p.y),TAU/u)-TAU/u/2.);p.z=k-w\t\n\n// FabriceNeyret2's suggestion\n#define C(u,w) \tk=length(p.yz); p.y=k*(p.z/k-.5)*6.28/12., p.z=k-10.   \t\n\n// previously\n//#define C(u,w) \tk=length(p.yz); p.y=k*abs(sin(atan(p.z,p.y))-.5)*TAU/u;p.z=k-w\t\n\nvec3 map(vec3 p, float u, float v) {\n\tfloat k;\n\tp.xy *= rot(u);\n\tp.yz *= rot(v);\n\t\t\n\tA(10.,0.);   // 0 here makes a sphere, easier to control color according to p\n\tB(12.,10.);\n\tA(10.,2.7); //A(18.,.7); \n\tC(12.,10.0);\n\tA(10.,2.7); \n\tB(12.,-5.7);\n\tA(10.,1.97); // 1.97+.05*cos(p.z*20.-time*8.)\n\tB(12.,10.5);\n\tA(16.,2.7); //10,2.7\n\tB(12.,-10.);\n\tA(10.,2.7); \n\tB(12.,10.);\n\t\n\tp.x = dot(abs(p), normalize(vec3(6.9,5,2.2))) - 1.6 ;\n\treturn p; \n}\n\n// code from FabriceNeyret2 thanks!\nvoid mainImage( out vec4 O, vec2 U ) \n{\n\tvec3 R = iResolution,\n         M = iMouse.xyz / R,\n         rd= normalize(vec3(U - .5 * R.xy, R.y)), p, d=R;\n\tfloat v= -8.*iTime/66., u=M.x+.25, c=.11, x, i=0.; \n\t p = vec3(0, (50.+20.*M.y)*c+3., -5.25*c-3.);\n\n\tfor (; i++ < 160. && d.x > .001; p += rd * d.x )\n\t    d = map(p, u, v);\n\n    x = max(0.,length(p)-12.) *4e2;\n    O = vec4( 144.-x,100.+x,80.-x,10) /i/i;\t\t\t\n}\n\n\n\n/*\n// FabriceNeyret2 's golfing \n#define r(a)     mat2(cos(a+vec4(0,11,33,0)))                           //\n#define A(u)     k = length(p.xy), m(u,x,y)                             //\n#define B        k = length(p.yz), m(12.,y,z)                           //\n#define m(u,x,y) p.x = k*( mod(atan(p.y,p.x), 6.28/u) -6.28/u/2. ), p.y = k\n\nvoid mainImage( out vec4 O, vec2 U ) \n{\n    vec3 R = iResolution, M = iMouse.xyz / R , p, q,\n         D = normalize( vec3(U - .5 * R.xy, R.y) );\n    float c=.11, i=0.,k=c; \n\n    for (q = vec3(0, (50.+20.*M.y)*c+3., -5.25*c-3.) ; \n         i++ < 160. && k > .001; q += D * k )\n        p = q,\n        p.xy *= r(M.x+.25),\n        p.yz *= r(-8.*iTime/66.),\t\n        A(10.),     B-10.,       A(10.)-2.7, \n        k = length(p.yz), p.y = k*(p.z/k-.5)*.524, p.z = k-10.,\n        A(10.)-2.7, B+5.7,       A(10.)-1.97,\n        B-10.5,     A(16.)-2.7,  B+10.,\n        A(10.)-2.7, B-10.,\n        k = dot(abs(p), vec3(.78,.57,.25) ) - 1.6;\n\n    k = max(0.,length(q)-12.) *4e2;\n    O = vec4( 144.-k,100.+k,80.-k,10) /i/i;\t\t\t\n}\n*/\n\n\n// previous code for mainImage()\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y, mouse=iMouse.xy/iResolution.xy;\n\tvec3 rd = normalize(vec3(uv, 1));\n\tfloat v=-8.*mod(iTime/66.,TAU), u=mouse.x, c=.11; \n\tvec3 p = vec3(0, (45.+25.*mouse.y)*c+3., -5.25*c-3.); // +-171.+262.*mouse.y  <- y term\n\tfragColor = vec4(0);\n\tfor (int i = 1; i < 160; i++) {\n\t\tvec3 d = map(p, u, v); \t\t\t\n\t\tif (d.x < 0.001) {\n\t\t\t//float x=max(0.,length(p)-11.7)*300.;\n\t\t\t//gl_FragColor = vec4( 144.-x*20.,100.+x,80.-x*200.,100)/float(4*i*i);\t\t\t\n\t\t\tfloat x=max(0.,length(p)-12.)*400.;\n\t\t\tfragColor = vec4( 144.-x,100.+x,80.-x,10)/float(i*i);\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\tp += rd * d.x;\n\t}\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtcSWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[488, 488, 524, 524, 927], [929, 965, 1004, 1004, 1374]], "test": "untested"}
{"id": "ftcXDN", "name": "Complex planetoids", "author": "cyperus", "description": "Nyancats living on complex planetoids.", "tags": ["nyan", "nyancat", "complex"], "likes": 10, "viewed": 371, "published": 3, "date": "1639167707", "time_retrieved": "2024-07-30T18:43:01.147363", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"Complex planetoids\" created by Colling Patrik (cyperus) in 2021\n//\n// BASED ON\n// - mu6k \n//     \"Nyancat\" https://www.shadertoy.com/view/4dXGWH\n//\n////////////////////////////////////////////////////////////////////////////////\n#define CENTER\n#define COMPLEX\n\nconst float\n    period = 12., // animation loop time in seconds\n    scale  = 12.; // inside one unit\n\nvec4 stars(vec2 p, float time)\n{\n\tvec4 color = vec4(0);\n\tvec2 ps;\n\tfloat stars; float ss = 0.04, s1 = 16.;\n    \n\tfor (float i = 1.; i < 7.; i++)\n\t{\n        time /= i; ps = i*p;\n\t\tps = ps + time*vec2(1, 0) - mod(ps + vec2(time,i*s1) ,vec2(ss));\n        \n\t\tstars = noise(s1 * ps);\n\t\tif (stars > 0.97) color = vec4(1);\n\t}   \n\treturn color;\n}\n\nvec4 nyancat(vec2 z, vec2 z0, float scale, float time)\n{\n    z = scale * vec2(fract(z.x - time) , z.y); z -= z0;\n    return ((0. < z.x && z.x < 0.9) && (0. < z.y && z.y < 0.6))\n    ? texture(iChannel0, \n        vec2(40./256. * (z.x + floor(6. * fract(3. * scale * time))), z.y + 0.2 ))\n    : vec4(0.);\n}    \n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    float time = iTime/period,\n          PI2time = PI2*time,\n          ps_t = 0.2*PI2time; // planet system t\n    vec2 uv0;      \n    \n    float pix = scale*3./R.x;\n    #ifdef CENTER\n    vec2 uv = (2.*U.xy-R.xy)/R.x; // uv.x  [-1, 1.], uv.y  [-R.y/R.x, R.y/R.x];\n    #else\n    vec2 uv = U.xy/R.x; // uv.x  [0., 1.], uv.y  [0., R.y/R.x];\n    #endif\n    \n    // planetoid system\n    float a, id;\n    #ifdef COMPLEX\n    uv *= 1.4; uv = cmul(uv,uv); uv.x -= .5+.2*cos(ps_t*.125); // (s*z)-z0 -> z\n    uv *= 2.;  uv = crpt(uv, 1./6.*ps_t, 3, 6.*sin(ps_t*.25)); // (s*z*e^(j*a))-z0 -> z                                           // 1/z -> z\n    uv.yx = uv.xy;                                             // continuity\n    \n    a = atan(-uv.y, uv.x) + ps_t;        // planetoid  number nyancats, spin,\n    uv = vec2(log(length(uv)), a)/PI_2;  // cartesian -> polar coords\n    id = floor(uv.y)/2.;                 // mountain color hue\n    uv.yx = 0.25 * uv.xy;\n    #endif\n    \n    // sky & ground\n    float  f_sy = 5., f_gr = 8.;\n    vec3 T = (texture(iChannel2, U.xy/R.x , 0.)).rgb; T = 0.3*pow(T,vec3(5)); // texture   \n\n    vec3 c_sy = mix(vec3(.0,.1,.7),T, sqrt(f_sy*uv.y));\n         c_sy = mix(vec3(0.,0.,0.),c_sy, sqrt(f_sy*uv.y));\n       \n         //c_sy = mix(c_sy, T.rgb, 0.2);\n    \n    vec3 c_gr = mix(texture(iChannel1, uv).rgb, vec3(1.,0.,0.), sqrt(-f_gr*uv.y));\n         c_gr = mix(c_gr.rgb, vec3(1.,1.,0.), sqrt (-f_gr*uv.y)-1.);\n    vec4 sg = vec4( uv.y >= 0. ? c_sy : c_gr ,1.);\n    \n    // stars     \n    vec4 st = stars(10. * uv, 5. * time);\n         st.a = uv.y > 0. ? st.a : 0.;\n    \n    // floor\n    float fl_height = scale *0.03;\n    vec2 fl_uv = scale * uv; // uv-transformation\n    float fl_sdf = fl_height - abs(fl_uv.y) ; // signed distance function\n    vec4 fl = vec4(0.9 * h2rgb(uv.x), S(fl_sdf, 1.5*pix)); // color, alpha\n    \n    // mountain\n    float mo_height = scale * (0.07 +  0.02 * sin(2.*a) + 0.01 * sin(7.*a));\n    mo_height = uv.y > 0. ? mo_height : 0.;\n    vec2 mo_uv = scale * uv; // uv-transformation\n    float mo_sdf = mo_height - abs(mo_uv.y); // signed distance function\n    vec4 mo = vec4(0.9 * h2rgb(id), S(mo_sdf, 1.5*pix)); // color, alpha\n\n    // ball\n    float ba_r = 0.1;\n    vec2 ba_uv = uv;\n         ba_uv = scale * vec2(fract(ba_uv.x - time), ba_uv.y ); // uv-transformation\n         ba_uv -= vec2(1.2, fl_height + ba_r + 0.2 * abs(cos(PI2time * scale)));\n    float ba_sdf = ba_r - length(ba_uv); // signed distance function\n    vec4 ba = vec4(1.2 * vec3(.8,.2,0.), S(ba_sdf, pix )); // color, alpha\n    \n    // nyancat\n    uv0 = vec2(0., fl_height);\n    vec4 na = nyancat(uv, uv0, scale, time); na.xyz *= na.xyz;// gamma,color, alpha\n    \n    // compose\n    O = vec4(0.7 *sg.rgb * sg.a, sg.a);\n    st *= 0.5;\n    O = mix(O, st, st.a);\n    mo.rgb *= 0.5;\n    O = mix(O, mo, mo.a);\n    fl.rgb *= 0.8;\n    O = mix(O, fl, fl.a);\n    O = mix(O, ba, ba.a);\n    O = mix(O, na, na.a);\n    O = vec4(O.rgb / O.a, O.a);  \n    \n    // gamma\n    O = vec4(sqrt(O.rgb), 1.);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "# define R iResolution\n\nconst float PI_2 = acos(0.), PI = 2.*PI_2, PI2 = 2.*PI;\n\n// complex\nvec2 cmul(vec2 za,vec2 zb) // za*zb\n{\n    return za*mat2(zb.x,-zb.y,zb.yx);\n}\n\nvec2 cinv(vec2 z) // 1/z\n{\n    return vec2(z.x,-z.y)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z, vec2 w) // z/w\n{\n    return cmul(z,cinv(w));\n}\n\nvec2 cpow(vec2 z, int n) // z^n\n{\n    vec2 w = z;\n    for (int i = 1; i < n; i++){\n        w = cmul(w,z);\n    }\n    return w;\n}\n\nvec2 crot(vec2 z,float a) // z*e^(i*a)\n{\n    return cmul(z, vec2(cos(-a),sin(-a)));\n}\n\nvec2 crpt(vec2 z,float a, int n, float x0) // (z*e^ia)^n-x0\n{\n\treturn cpow(crot(z, a), n) - vec2(x0, 0.);\n}\n\n// noise \n// https://www.shadertoy.com/view/4dXGWH \"Nyancat\" by mu6k\n\nfloat hash(float x)\n{\n\treturn fract(sin(x*.0127863)*17143.321);\n}\n\nfloat hashmix(float x0, float x1, float interp)\n{\n\tx0 = hash(x0);\n\tx1 = hash(x1);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(0.0,1.0,interp);\n\t#endif\n\treturn mix(x0,x1,interp);\n}\n\nfloat hashmix(vec2 p0, vec2 p1, vec2 interp)\n{\n\tfloat v0 = hashmix(p0[0]+p0[1]*128.0,p1[0]+p0[1]*128.0,interp[0]);\n\tfloat v1 = hashmix(p0[0]+p1[1]*128.0,p1[0]+p1[1]*128.0,interp[0]);\n\tinterp = smoothstep(vec2(0.0),vec2(1.0),interp);\n\treturn mix(v0,v1,interp[1]);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 pm = mod(p,1.0);\n\tvec2 pd = p-pm;\n\treturn hashmix(pd,(pd+vec2(1.0,1.0)), pm);\n}\n\n// smooth\nfloat S(float sdf, float pix)\n{\n    return smoothstep(-pix, +pix, sdf);\n}\n\n// color\nvec3 h2rgb(float h)\n{\n    return .5*(1.+cos(PI2*(h+vec3(0,1,2)/3.)));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcXDN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[544, 544, 576, 576, 882], [884, 884, 940, 940, 1187], [1193, 1193, 1234, 1234, 4261]], "test": "untested"}
{"id": "stdSW4", "name": "Light Ball - cheap version ", "author": "FabriceNeyret2", "description": "trying to redo ( 3181 chars) IWBTShyGuy's [url]https://www.shadertoy.com/view/NldSD4[/url] in cheaper way.\n\nNote that dots are drawn in screen space, without loop. \nBut they currently get clamped on silhouette.", "tags": ["short", "loopless"], "likes": 20, "viewed": 505, "published": 3, "date": "1639155374", "time_retrieved": "2024-07-30T18:43:02.277341", "image_code": "//           P = intersec, F = polar grid cells -inward offset, then local cells coords \n#define A(s) P = ( s sqrt(d) - b ) * D/z, P.z += 5.,                                    \\\n             F = round( vec2( atan(P.x,P.z) -t, asin(P.y/r) ) * V ) / V, F.x += t,      \\\n             abs(F.y) < 1. ? Z = ( 5.-r*cos(F.y)*cos(F.x) ),                            \\\n                             F-= .1*P.xy, Z -= .1*P.z,                                  \\\n                             F = r* vec2( cos(F.y)*sin(F.x) , sin(F.y) ) / Z + U/z : F, \\\n             O +=  3e-6/(Z-3.7) / dot(F,F)\n//                               r* vec2( cos(F.y)*sin(F.x) , sin(F.y) ) - P.xy : F, \\\n\n//#define S   d > 0. ? A(), A(-) : O // buggy on some Windows\n  #define S   if (d > 0.) A(), A(-)\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2  R = iResolution.xy, F, V = vec2(6.37,5.09); // vec2(20,16) / 3.14\n    vec3  D = vec3( U = 1.2 * ( U+U - R ) / R.y, 5 ), P;\n    O -= O;\n    float z = length(D), Z, r = 1., t = -.4*iTime,\n          b = D.z/z*5., d = b*b-24.;  // ray inter sph: l + 2(D.C).l + C = r\n    S;                                // outer sphere\n    r = .7, d -= .5; t=-t;  S;        // inner sphere\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdSW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[770, 770, 808, 808, 1197]], "test": "untested"}
{"id": "sltXW4", "name": "Innerspace", "author": "dean_the_coder", "description": "Shader inspired by 'Innerspace (1989)' staring Dennis Quaid and Meg Ryan.", "tags": ["3d", "raymarching", "blood", "movie", "cineshader"], "likes": 35, "viewed": 4720, "published": 3, "date": "1639151957", "time_retrieved": "2024-07-30T18:43:03.458184", "image_code": "// 'Innserspace' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/sltXW4 (YouTube: https://youtu.be/TonMoR0KI_E)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Another 80s film I grew up loving, so I thought it would be a\n// good challenge to make a shader from it.\n//\n// Things to note:\n//   - I only add three blood cells into the tunnel, and use\n//     domain repetition to clone them for (nearly) free.\n//   - Lots of axis symmetry in the 'pod' to reduce complexity.\n//   - As only the cockpit glass is transparent, it is rendered\n//     separately (using ray/sphere intersection).\n//   - Re-using my handy 'honk' function (Blame evvvvil for the name)\n//     for the robot arm. Very handy for chaining together capsules\n//     which move relative to each other.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n//\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n#define minH(a, b, c)\t{ float h_ = a; if (h_ < h.d) h = Hit(h_, b, c); }\n\nfloat t, fade,\n      g = 0.,\n      arm = 0.;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 p;\n};\n\n// Thnx Dave_Hoskins - https://www.shadertoy.com/view/4djSRW\nfloat h31(vec3 p3) {\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 3.3456);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat h21(vec2 p) { return h31(p.xyx); }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat remap(float f, float in1, float in2) { return sat((f - in1) / (in2 - in1)); }\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 rep(vec3 p) { return mod(p + 10., 20.) - 10.; }\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.zy), p.x)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0., h);\n\treturn length(p) - r;\n}\n\nfloat tor(vec3 p) {\n\treturn length(vec2(length(p.xz) - 1., p.y)) - .4;\n}\n\nfloat honk(inout vec3 p, vec2 r) {\n\tfloat d = cap(p, r.x, r.y);\n\tp.x -= r.x;\n\treturn d;\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nHit pod(vec3 p, float sha) {\n\tvec3 tp,\n\t     op = p;\n\tfloat f,\n\t      d = cap(p, .5, 1.);\n\n\t// Rear box.\n\tf = min(d, max(box(p, vec3(2, .32, .32)) - .7, abs(p.x - .9) - .6));\n\td = mix(d, f, .7);\n\n\t// Rear slope cut.\n\tf = max(d, p.x + p.y * .5 - 1.4);\n\td = mix(d, f, .5);\n\n\t// Sphere straps.\n\tf = max2(S(.06, .04, abs(abs(p.xz) - vec2(0.0, p.y * .16 + .28))));\n\td -= f * .02;\n\n\t// Front glass.\n\tp.y -= .64;\n\tf = box(p, vec3(1, .18, p.y * .16 + .26));\n\td = max(d, -f);\n\n\t// Side glass.\n\tp.xy += vec2(.35, -.08);\n\tf = max(box(p, vec3(.22, .12, 2)), p.y - sin(p.x + 1.58) * 1.96 + 1.9 - p.x * .4);\n\td = max(d, -f);\n\tp = op;\n\n\t// Square base.\n\tp.xy += vec2(-.21, .2);\n\tf = max(box(p, vec3(1.15, .85, .58)) - .15, abs(p.y) - .2);\n\td = mix(d, min(max(d, -p.y), f), .8);\n\tp = op;\n\tHit h = Hit(d, 3, p);\n\n\t// Top turbines.\n\tp.z = abs(p.z) - .75;\n\tp.xy -= vec2(.7, 1);\n\tf = cyl(p, vec2(.02 * S(.24, .2, abs(p.x)) + .2, .5));\n\ttp = p;\n\tp.x = abs(p.x) - .74;\n\tf = min(max(f, .28 - length(p)), cap(p + vec3(.94, 0, 0), .62, .08));\n\tminH(f, 4, tp);\n\tp = op;\n\n\t// Lights.\n\tp.y -= .73 - .47 * step(p.x, 0.);\n\tp.xz = abs(p.xz - vec2(.14, 0)) - vec2(1.25, .2);\n\tf = cap(p - vec3(2, 0, 0), .5, p.x * .4 + .2);\n\tg += .002 / (.2 + f * f * f * f) * S(-1., -3., op.x);\n\tf = max(length(p + vec3(.43, 0, 0)) - .46, -p.x);\n\tg += .003 / (.003 + f * f * 1e2);\n\tf = min(max(length(p) - .18, p.x), f);\n\td = min(d, f);\n\tp = op;\n\n\t// Skids.\n\tp.z = abs(p.z);\n\tp -= vec3(.29, -.45, .8);\n\tf = box(p, vec3(1, .03, .08));\n\tp.x++;\n\tp.xy *= mat2(.70721, -.707, .707, .70721);\n\tp.x += .047;\n\tf = min(f, box(p, vec3(.06, .03, .08)));\n\td = min(d, f);\n\tp = op;\n\n\t// Rear canisters.\n\tp.z = abs(p.z);\n\tp -= vec3(1.38, .16, .45);\n\tmat2 r = mat2(.95534, .29552, -.29552, .95534);\n\tp.yz *= r;\n\tp.xy *= r;\n\td = min(d, cap(p.yxz, .4, .1));\n\tp = op;\n\n\t// Arm.\n\tp += vec3(1.08, .23, .3);\n\tp.xz *= rot(-4.71225 + S(0., .5, arm) * 1.3);\n\tf = min(honk(p, vec2(.6, .03)), cap(p.yxz, .06, .04));\n\tp.y -= .06;\n\tr = mat2(-1, 0, 0, -1);\n\tp.xz *= r;\n\tp.xy *= rot(S01(arm) * 2.);\n\tf = min(min(f, honk(p, vec2(.6, .03))), cap(p.yxz, .06, .04));\n\tp.y -= .06;\n\tp.xz *= r;\n\tp.xy *= rot(S(.7, 1., arm) * 2.);\n\tf = min(f, honk(p, vec2(.1, .01)));\n\tminH(min(d, f), 3, p);\n\tif (t * sha * step(t, 36.) > 25.5) {\n\t\tp.xy *= rot(sin(t * .55) * .5);\n\t\tp.x -= .02;\n\t\td = honk(p, vec2(2, .01));\n\t\tg += 2e-4 * (sin(p.x * 10. - t * 5.) * .5 + 1.) / (1e-5 + d * d);\n\t\tminH(d, 7, p);\n\t}\n\n\treturn h;\n}\n\nfloat tube(vec3 p) {\n\tfloat d = abs(26.5 - pow(abs(sin(p.x * .16)), 14.) - length(p.yz)) - .5;\n\tif (t > 41.) {\n\t\tp.y++;\n\t\td = smin(d, 2. - length(p.xy) + dot(sin(vec2(5, 10) * atan(p.x, p.y)), vec2(.1, .05)), -.4);\n\t}\n\n\treturn d;\n}\n\nfloat cell(vec3 p, float rnd) {\n\tp.xy -= vec2(15. * t - 7. * cos(t * 2.), 1);\n\tfloat i = h31(floor((p - 10.) / 20.) + vec3(rnd, rnd, -rnd));\n\tp = rep(p);\n\tmat2 m = rot(10. * i + t * rnd * sin(i * 10.));\n\tp.yz *= m;\n\tp.xy *= -m;\n\treturn smin(tor(p), cyl(p.yxz, vec2(1, .1)), .4);\n}\n\nfloat cells(vec3 p) { return min(min(cell(p, 1.), cell(p + vec3(5), 2.)), cell(p + vec3(12), 3.)); }\n\nvec3 podP = vec3(0),\n     podR = vec3(0);\nvec3 lp() {\n\tvec3 p = vec3(3, 0, 0);\n\tp.xz *= rot(-podR.y);\n\treturn podP - p;\n}\n\nHit map(vec3 p, float sha) {\n\tHit h2,\n\t    h = Hit(tube(p), 5, p);\n\tvec3 op = p;\n\tminH(cells(p), 6, p);\n\tp = op - podP;\n\tp.yz *= rot(podR.x);\n\tp.xz *= rot(podR.y);\n\th2 = pod(p, sha);\n\tif (h2.d < h.d) return h2;\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h, 1.).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 lp) {\n\tfloat d,\n\t      s = 1.,\n\t      t = .1,\n\t      mxt = length(p - lp);\n\tvec3 ld = normalize(lp - p);\n\tfor (float i = Z0; i < 30.; i++) {\n\t\td = map(t * ld + p, 0.).d;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.01, d);\n\t\tif (mxt - t < .5 || s < .001 || t > 45.) break;\n\t}\n\n\treturn S01(s);\n}\n\nfloat aof(vec3 p, vec3 n, float h) { return sat(map(h * n + p, 0.).d / h); }\n\nfloat fog(float d) { return exp(d * d * -.001); }\n\nvoid dtc(vec2 p, inout vec3 c) {\n\tif (abs(p.x) > .6 || abs(p.y) > .5) return;\n\tfloat dc,\n\t      f = step(min2(abs(p - vec2(0, .2))), .08) * step(p.y, .3) * step(abs(p.x), .4);\n\tif (f > 0.) {\n\t\tc = vec3(8);\n\t\treturn;\n\t}\n\n\tdc = step(.5, p.x);\n\tp.x = abs(p.x) - .46;\n\tf = dot(p, p);\n\tdc += step(f, .25) * step(.16, f);\n\tif (dc > 0.) c = vec3(3);\n}\n\nvec3 lights(vec3 p, vec3 rd, vec3 n, Hit h) {\n\tvec3 c,\n\t     l = lp(),\n\t     ld = normalize(l - p),\n\t     noise = vec3(n31(h.p * .3), n31(h.p.zxy * 3.3), n31(h.p.zxy * 60.)) - .5;\n\tvec2 spe = vec2(10, 1);\n\tif (h.id <= 4) {\n\t\tc = vec3(.34, .3, .32);\n\t\tc *= 1. + dot(noise, vec3(1, .5, .15));\n\t\tn = normalize(n + dot(noise, vec3(.11, .13, .036)));\n\t\tspe.y = 8.;\n\t\tif (h.id == 4) {\n\t\t\tfloat l = length(h.p.yz),\n\t\t\t      v = step(l, .13) * step(.06, l) * sat(1. + sin(t * -80. + 18. * atan(h.p.y, h.p.z)));\n\t\t\tc = mix(c, vec3(.005), v * .6);\n\t\t\tif (h.p.z > 0.) dtc(h.p.xy * vec2(sign(p.x), 1) * 4.5, c);\n\t\t\tn = normalize(n + v * .2);\n\t\t}\n\t}\n\telse if (h.id == 6) {\n\t\tc = vec3(.2, 0, 0);\n\t\tn = normalize(n + noise.z * .25);\n\t}\n\telse if (h.id == 5) {\n\t\tc = vec3(.1, 0, 0);\n\t\tc.r *= 1. - S(.4, 0., abs(dot(sin(p * .16), cos(p.zxy * .07)))) * .5;\n\t\tc *= 1. + dot(noise.xy, vec2(1, .2)) + sat(noise.z) * .7;\n\t}\n\telse c = vec3(1);\n\n\tfloat ao = mix(aof(p, n, .2), aof(p, n, 2.), .7),\n          sha = shadow(p, l),\n\tl1 = sat(.1 + .9 * dot(ld, n))\n         * (0.3 + 0.7 * sha)\n         * (0.3 + 0.7 * ao),\n\tl2 = sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * 0.025\n\t     + pow(sat(dot(rd, reflect(ld, n))), spe.x) * spe.y * sat(sha + 0.5),\n\tfre = 1.0 - S(.7, 1., 1. + dot(rd, n));\n\n\treturn mix(vec3(0.005, 0, 0), (l1 + l2 * ao) * c * vec3(1, .7, .7), fre);\n}\n\nvec3 scene(vec3 p, vec3 rd) {\n\tvec3 n, col, wp = p;\n\tfloat i, gg, sum,\n\t      d = 0.;\n\tHit h;\n\tfor (i = Z0; i < 90.; i++) {\n\t\th = map(p, 1.);\n\t\tif (abs(h.d) < .0015 || d > 70.) break;\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\tgg = g;\n\tn = N(p, d);\n\tcol = mix(vec3(.0025, .5e-4, .5e-4), gg * vec3(2, .91, .7) + lights(p, rd, n, h), fog(d));\n\n\t// March the window.\n\t{\n\t\tfloat b = 2. * dot(rd, wp - podP),\n\t\t      dis = b * b - 4. * dot(rd, rd) * (dot(podP, podP) + dot(wp, wp) - 2. * dot(podP, wp) - .99);\n\t\tif (dis > 0.) {\n\t\t\tfloat sd = (-b - sqrt(dis)) * 0.5;\n\t\t\tif (sd < d && sd > 0.0) {\n\t\t\t\tp = wp + sd * rd;\n\t\t\t\tif (p.y > podP.y + .4) {\n\t\t\t\t\tn = normalize(podP - p);\n\t\t\t\t\tcol += vec3(1, .7, .7) * (.02 + pow(sat(dot(rd, reflect(normalize(lp() - p), n))), 3.5));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Particles.\n\tsum = 0.;\n\tfor (float dist = 1.; dist < d; dist += 5.) {\n\t\tvec3 vp = wp + rd * dist;\n\t\tvp.yz -= t * .1;\n\t\tsum += 1. - S(0., mix(.15, .02, remap(dist, 1., 20.)), length(fract(vp - wp) - .5));\n\t}\n\tcol += sum * vec3(.03, .003, .003);\n    \n    // Light cone.\n    {\n        vec3 podD = vec3(-1, 0, 0);\n        podD.xz *= rot(-podR.y);\n        vec3 H = podP + vec3(0, 0.3, 0) + podD * 0.4,\n             C = podP + podD * 6.,\n             h = C - H,\n             hCap = normalize(h),\n             w = wp - H;\n        float rdc = dot(rd, hCap), wc = dot(w, hCap),\n              m = 2.25 / dot(h, h),\n              a = dot(rd, rd) - m * rdc * rdc - rdc * rdc,\n              b = 2. * (dot(rd, w) - m * rdc * wc - rdc * wc),\n              c = dot(w, w) - m * wc * wc - wc * wc;\n\n        float f = b * b - 4. * a * c;\n        if (f > 0.0) {\n            float t1 = (-b + sqrt(f)) / (2. * a), t2 = (-b - sqrt(f)) / (2. * a);\n            if (max(t1, t2) < d) {\n                vec3 L1 = wp + t1 * rd, L2 = wp + t2 * rd;\n                float l1 = dot(L1 - H, hCap);\n                float l2 = dot(L2 - H, hCap);\n                if ((0.0 <= l1 && l1 < length(h)) || (0.0 <= l2 && l2 < length(h)))\n                    col += length(L1 - L2) * 0.004 * S(5., 0., min(l1, l2)) * S(8.3, 10., t);\n            }\n        }\n    }\n    \n\treturn col;\n}\n\nfloat addFade(float a) { return min(1., abs(t - a)); }\n\n#define rgba(col)\tvec4(pow(max(vec3(0), col), vec3(.45)) * fade, 0)\n\nvec3 cam(inout vec3 at) {\n\tt = mod(iTime, 55.);\n\tfade = addFade(0.) * addFade(21.) * addFade(41.) * addFade(55.);\n\n\t// Stage 1a - Pod travels towards viewer.\n\tpodP = mix(vec3(-70, 1, 3), vec3(0, -1, 3), S(0., 12., t));\n\tpodR = vec3(sin(t) * .2, 3.141, 0);\n\tfloat f = remap(t, 0., 7.);\n\tvec3 ro = mix(vec3(-20, 0, 0), vec3(-3, 0, 6), f);\n\tat = mix(vec3(-20, 0, 10), podP, remap(t, 0., 7.));\n\n\t// Stage 1b - Pod rotate to wall, extend arm.\n\tpodR = mix(podR, vec3(0, 4.7, 0), S(10., 15., t));\n\tarm = S(14., 18., t);\n\tpodP = mix(podP, vec3(0, -1, 8), S(16., 21., t));\n\n\t// Stage 2 - Pod cutting wall.\n\tfloat drift = .3;\n\tif (t > 21.) {\n\t\tdrift *= 1. - remap(t, 22., 25.) * .8;\n\t\tpodP.yz += vec2(-.6, mix(8., 14.4, S(20., 25., t)));\n\t\tat = podP;\n\t\tf = S(20., 25., t);\n\t\tro += 5. + vec3(5. * f, -3.2 * f, 11.2) - vec3(4.1, 2.35, -1.8) * S(27., 33., t);\n\t\tarm *= S(40.5, 37.5, t);\n\t\tpodP.z += S(38., 41., t);\n\n\t\t// Stage 3 - Entering hole.\n\t\tif (t > 41.) {\n\t\t\tdrift = .3;\n\t\t\tro = vec3(-1.921875, 15. - 10. * S(41., 44., t), 15);\n\t\t\tf = S(48., 53., t);\n\t\t\tpodR.y -= f;\n\t\t\tpodP.xz += vec2(f, S(43., 55., t) * 13.);\n\t\t}\n\t}\n\n\t// Pod drift.\n\tpodP += vec3(sin(t), sin(t * 1.1), cos(t)) * drift;\n\treturn ro;\n}\n\nvoid mainVR(out vec4 fragColor, vec2 fc, vec3 ro, vec3 rd) {\n\trd.xz *= mat2(1, 0, 0, -1);\n\tvec3 dummy;\n\tfragColor = rgba(scene(cam(dummy), rd));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tvec2 R = iResolution.xy,\n         uv = (fc - .5 * R.xy) / R.y,\n\t     v = fc.xy / R.xy;\n\tvec3 at,\n\t     ro = cam(at),\n\t     col = scene(ro, rayDir(ro, at, uv));\n\tcol *= .5 + .5 * pow(16. * v.x * v.y * (1. - v.x) * (1. - v.y), .4);\n\tcol -= h21(fc * .3) * .001;\n\tfragColor = rgba(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltXW4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1412, 1473, 1493, 1493, 1590], [1592, 1592, 1611, 1611, 1632], [1634, 1634, 1653, 1653, 1994], [1996, 1996, 2035, 2035, 2117], [2119, 2119, 2139, 2139, 2163], [2165, 2165, 2185, 2185, 2209], [2211, 2211, 2231, 2231, 2265], [2267, 2267, 2311, 2311, 2350], [2352, 2352, 2371, 2371, 2438], [2440, 2440, 2458, 2458, 2492], [2494, 2494, 2521, 2521, 2592], [2594, 2594, 2622, 2622, 2722], [2724, 2724, 2761, 2761, 2813], [2815, 2815, 2834, 2834, 2887], [2889, 2889, 2923, 2923, 2978], [2980, 2980, 3024, 3024, 3160], [3162, 3162, 3190, 3190, 5581], [5583, 5583, 5603, 5603, 5814], [5816, 5816, 5847, 5847, 6096], [6098, 6098, 6119, 6119, 6198], [6242, 6242, 6253, 6253, 6321], [6323, 6323, 6351, 6351, 6546], [6548, 6548, 6573, 6573, 6796], [6798, 6798, 6829, 6829, 7112], [7114, 7114, 7150, 7150, 7190], [7192, 7192, 7212, 7212, 7241], [7243, 7243, 7275, 7275, 7587], [7589, 7589, 7634, 7634, 8932], [8934, 8934, 8963, 8963, 11050], [11052, 11052, 11076, 11076, 11106], [11177, 11177, 11202, 11202, 12372], [12374, 12374, 12434, 12434, 12520], [12522, 12522, 12567, 12567, 12853]], "test": "untested"}
{"id": "NldSWN", "name": "bug: -a % b on  OpenGL", "author": "FabriceNeyret2", "description": "(-a)%b used to be mod(-a,b) ob OpenGL and  -(a%b) on Windows.\nthings are now stranger on OpenGL ( or is it only nVidia ? )\nHere: computing -1 % y ,  value = white x block.\nFor reference: blue: mod(-1,y)=x", "tags": ["glsl", "mod", "bug", "compatibility"], "likes": 6, "viewed": 264, "published": 3, "date": "1639142170", "time_retrieved": "2024-07-30T18:43:04.274004", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    U = floor(32.*U/iResolution.xy);\n    ivec2 I = ivec2(U);\n    \n    O = vec4( min(-1,iFrame)%I.y==I.x);  // min(-1,iFrame) = not const( -1 )\n\n    O.b  += .4*float(mod(-1.,U.y)==U.x); // blue reference with mod()\n    O.rg += .2*vec2(I%2);                // checker\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldSWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 306]], "test": "untested"}
{"id": "NldSD4", "name": " -- Light Ball", "author": "IWBTShyGuy", "description": "It's been a while since I wrote a simple effect.", "tags": ["pattern"], "likes": 9, "viewed": 297, "published": 3, "date": "1639136718", "time_retrieved": "2024-07-30T18:43:05.147667", "image_code": "// Copyright  2021 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\nconst int UN = 40;\nconst int VN = 16;\n\nvec2 nearUVN(in vec3 p, in float radius) {\n    vec3 n = normalize(p);\n\n    vec2 x = normalize(n.zx);\n    float u = acos(clamp(x.x, -1.0, 1.0)) * sign(x.y);\n    float v = n.y;\n\n    float un = floor(float(UN) * radius);\n    u = (1.0 + u / PI) * 0.5;\n    u = floor(u * un + 0.5);\n\n    float vn = floor(float(VN) * radius);\n    v = (1.0 + v) * 0.5;\n    v = floor(v * vn + 0.5);\n\n    return vec2(u, v);\n}\n\nvec3 getPoint(in vec2 uvn, in float radius) {\n    float un = floor(float(UN) * radius);\n    float vn = floor(float(VN) * radius);\n\n    vec2 uv = vec2(\n        uvn.x / un,\n        clamp(uvn.y, 1.0, vn - 1.0) / vn\n    );\n    uv.x = (2.0 * uv.x - 1.0) * PI;\n    uv.y = 2.0 * uv.y - 1.0;\n    float r = sqrt(1.0 - uv.y * uv.y);\n    return vec3(r * sin(uv.x), uv.y, r * cos(uv.x)) * radius;\n}\n\nfloat halfMap(in Ray ray, in vec3 p0, in float radius) {\n    float c0 = 0.0;\n    vec2 uvn0 = nearUVN(p0, radius);\n    for (int i = 0; i < 49; i++) {\n        vec2 e = vec2(i / 7 - 3, i % 7 - 3);\n        vec3 p = getPoint(uvn0 + e, radius);\n        float dist = dot(p - ray.origin, ray.direction);\n        dist = length(ray.origin + dist * ray.direction - p);\n        float c = clamp(1.0e-4 / (1.0e-5 + dist * dist), 0.0, 1.0);\n        dist = clamp(dist / 0.05, 0.0, 1.0);\n        dist = dist * dist;\n        c = mix(c * c, 0.0, dist);\n        c0 = max(c0, c);\n    }\n    return c0;\n}\n\nfloat sphereMap(in Camera camera, in vec2 uv, in float theta, in float radius) {\n    Ray ray = cameraRay(camera, uv);\n\n    ray.origin = rot(vec3(0, 1, 0), theta) * ray.origin;\n    ray.direction = rot(vec3(0, 1, 0), theta) * ray.direction;\n\n    float midDist = -dot(ray.origin, ray.direction);\n    float r0 = length(ray.origin + midDist * ray.direction);\n    if (r0 > radius + 0.05) return 0.0;\n\n    float diff = radius + 0.05;\n    diff = sqrt(diff * diff - r0 * r0);\n    vec3 p0 = ray.origin + (midDist - diff) * ray.direction;\n    vec3 p1 = ray.origin + (midDist + diff) * ray.direction;\n\n    float c = 0.0;\n    c = max(c, halfMap(ray, p0, radius));\n    c = max(c, halfMap(ray, p1, radius));\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 dir = normalize(vec3(0, sin(iTime * 0.3) * 0.2, 1));\n    Camera camera = Camera(\n        dir * 3.0,\n        -dir,\n        vec3(0, 1, 0),\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n\n    vec2 uv = fragCoord / iResolution.xy;\n    float c = max(\n        sphereMap(camera, uv, -iTime * 0.4, 1.0),\n        sphereMap(camera, uv, iTime * 0.7, 0.7)\n    );\n\n    c = pow(c, 0.4545);\n    fragColor = vec4(c, c, c, 1);\n}\n", "image_inputs": [], "common_code": "const float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float radian = camera.fov;\n    float h = tan(radian * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\nmat3 rot(vec3 axis, float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat3(\n        axis[0] * axis[0] * (1.0 - c) + c,\n        axis[0] * axis[1] * (1.0 - c) + axis[2] * s,\n        axis[0] * axis[2] * (1.0 - c) - axis[1] * s,\n        axis[0] * axis[1] * (1.0 - c) - axis[2] * s,\n        axis[1] * axis[1] * (1.0 - c) + c,\n        axis[1] * axis[2] * (1.0 - c) + axis[0] * s,\n        axis[0] * axis[2] * (1.0 - c) + axis[1] * s,\n        axis[1] * axis[2] * (1.0 - c) - axis[0] * s,\n        axis[2] * axis[2] * (1.0 - c) + c\n    );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldSD4.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[117, 117, 159, 159, 516], [518, 518, 563, 563, 904], [906, 906, 962, 962, 1487], [1489, 1489, 1569, 1569, 2197], [2199, 2199, 2254, 2254, 2691]], "test": "untested"}
{"id": "7tcSW4", "name": "Subconscious Orb", "author": "cdata", "description": "Playing around, exploring possible surface effects for a corner of the Subconscious UI.\n\nNo optimization pass has been done, please consider everything WIP.", "tags": ["prototype"], "likes": 2, "viewed": 308, "published": 3, "date": "1639116558", "time_retrieved": "2024-07-30T18:43:05.983433", "image_code": "precision highp float;\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n  // Precompute values for skewed triangular grid\n  const vec4 C = vec4(0.211324865405187,\n                      // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,\n                      // 0.5*(sqrt(3.0)-1.0)\n                      -0.577350269189626,\n                      // -1.0 + 2.0 * C.x\n                      0.024390243902439);\n                      // 1.0 / 41.0\n\n  // First corner (x0)\n  vec2 i  = floor(v + dot(v, C.yy));\n  vec2 x0 = v - i + dot(i, C.xx);\n\n  // Other two corners (x1, x2)\n  vec2 i1 = vec2(0.0);\n  i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n  vec2 x1 = x0.xy + C.xx - i1;\n  vec2 x2 = x0.xy + C.zz;\n\n  // Do some permutations to avoid\n  // truncation effects in permutation\n  i = mod289(i);\n  vec3 p = permute(\n          permute( i.y + vec3(0.0, i1.y, 1.0))\n              + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(\n                      dot(x0,x0),\n                      dot(x1,x1),\n                      dot(x2,x2)\n                      ), 0.0);\n\n  m = m*m ;\n  m = m*m ;\n\n  // Gradients:\n  //  41 pts uniformly over a line, mapped onto a diamond\n  //  The ring size 17*17 = 289 is close to a multiple\n  //      of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n  // Normalise gradients implicitly by scaling m\n  // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n  m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n  // Compute final noise value at P\n  vec3 g = vec3(0.0);\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n  return 130.0 * dot(m, g);\n}\n\n// Copyright 2021 Chris Joel\n// All works not covered by a license are CC-BY-NC\nfloat PHI = 1.61803398874989484820459;\n\nfloat turbulence(vec2 viewport_xy, float t) {\n  float scale = 3.0;\n  float x = snoise(viewport_xy * scale + t);\n  float y = snoise(viewport_xy.yx * scale - t);\n  float l = length(vec2(x, y));\n\n  float e = 1.0;\n  float s = 1.0 - smoothstep(0.500, e, l)/e;\n\n  float e2 = 2.000;\n  float s2 = 1.0 - smoothstep(0.15, e2, l)/e2;\n\n  return clamp(pow((s + s2) / 2.0, 4.0), 0.0, 1.0);\n}\n\nfloat soft_circle(vec2 viewport_xy, vec2 xy, float radius, float blur) {\n  float blur_half = blur / 2.0;\n  float d = distance(viewport_xy, xy);\n  return 1.0 - smoothstep(radius - blur_half, radius + blur_half, d);\n}\n\nvec4 rgb(float r, float g, float b) {\n  return vec4(r/255., g/255., b/255., 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = iResolution.x > iResolution.y \n        ? vec2(1.0, iResolution.y / iResolution.x) \n        : vec2(iResolution.x / iResolution.y, 1.0);\n\n    vec2 viewport_xy = fragCoord / iResolution.xy * aspect;\n    vec2 midpoint_xy = 0.5 * aspect;\n\n    vec4 purple = rgb(110., 90., 200.);\n    vec4 red = rgb(255., 110., 100.);\n    vec4 orange = rgb(255., 190., 100.);\n    vec4 green = rgb(110., 190., 90.);\n    vec4 blue = rgb(100., 140., 230.);\n\n    float p = turbulence(viewport_xy * 1., iTime/80.0);\n    float pp = clamp(abs(log(p)) / 10.0, 0.0, 1.0);\n\n    float t = turbulence(viewport_xy * 0.4 + pp/5., iTime/20.0);\n    float tt = turbulence(viewport_xy * 0.2 - pp/9., iTime/30.);\n\n    float t0 = smoothstep(0.0, 0.0045, t);\n    float t1 = smoothstep(0.06, 0.1, t);\n    float t2 = smoothstep(0.2, 0.4, t);\n    float t3 = smoothstep(0.3, 0.8, t);\n    float t4 = smoothstep(0.925, .985, t);\n\n    float l0 = (t0 - t1);\n    float l1 = (t1 - t2);\n    float l2 = (t2 - t3);\n    float l3 = (t3 - t4);\n    float l4 = t4;\n\n    float circle = soft_circle(viewport_xy, midpoint_xy, 0.1, 0.001);\n    float rot_time = PHI * iTime / 10.0;\n    vec2 glow_offset = vec2(cos(rot_time) * -0.015, sin(rot_time) * 0.015);\n    float inner_glow = soft_circle(viewport_xy, midpoint_xy - glow_offset, 0.095, 0.1);\n    float outer_glow = clamp(soft_circle(viewport_xy, midpoint_xy, 0.115, 0.15) - circle, 0.0, 1.0);\n\n    vec4 c0 = l0 * blue + l1 * purple + l2 * green + l3 * orange + l4 * red;\n    vec4 c1 = l0 * orange + l1 *green + l2 * blue  + l3 * purple + l4 * red;\n    vec4 cc = mix(c0, c1, tt) * mix(c0, c1, tt) * 0.85 + vec4(0.25);\n\n    cc = mix(cc, vec4(1.0), (1. - inner_glow) * 0.5) * circle + outer_glow * (t * .25 + tt * .05);\n\n    vec4 out_color = vec4(1.0) - (vec4(1.0) - cc);\n    \n    fragColor = out_color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tcSW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 45, 45, 92], [93, 93, 114, 114, 161], [162, 162, 184, 184, 219], [221, 542, 564, 614, 2221], [2343, 2343, 2388, 2388, 2720], [2722, 2722, 2794, 2794, 2937], [2939, 2939, 2976, 2976, 3022], [3024, 3024, 3081, 3081, 4889]], "test": "untested"}
{"id": "ftdSR4", "name": "simplex_noise + FBM", "author": "luolin", "description": "test simplex noise + FBM", "tags": ["noise"], "likes": 0, "viewed": 295, "published": 3, "date": "1639105160", "time_retrieved": "2024-07-30T18:43:08.000041", "image_code": "\n\n\nvec2 grad_simplex(int hash, float x, float y)\n{\n\tvec2 p = vec2(x, y);\n\tvec2 g0 = normalize(vec2(-1., 1.));\n\tvec2 g1 = normalize(vec2(1., 1.));\n\tvec2 g2 = normalize(vec2(-1., -1.));\n\tvec2 g3 = normalize(vec2(1., -1.));\n\n\tvec2 g4 = normalize(vec2(1., 0.5));\n\tvec2 g5 = normalize(vec2(-0.5, 1.));\n\tvec2 g6 = normalize(vec2(-1., -0.5));\n\tvec2 g7 = normalize(vec2(-1., -0.5));\n\n\tint h = hash & 7;\n\tif (h == 0) return g0;\n\telse if (h == 1) return g1;\n\telse if (h == 2) return g2;\n\telse if (h == 3) return g3;\n\telse if (h == 4) return g4;\n\telse if (h == 5) return g5;\n\telse if (h == 6) return g6;\n\telse if (h == 7) return g7;\n\n\treturn vec2(0., 0.);\n}\n\nvec2 hash22(vec2 vec)\n{\n\t\tint p[256] = int[256](\n\t\t\t\t\t\t151,160,137,91,90,15,                 \n\t\t\t\t\t\t131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,  \n\t\t\t\t\t\t190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n\t\t\t\t\t\t88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n\t\t\t\t\t\t77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n\t\t\t\t\t\t102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n\t\t\t\t\t\t135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n\t\t\t\t\t\t5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n\t\t\t\t\t\t223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n\t\t\t\t\t\t129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n\t\t\t\t\t\t251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n\t\t\t\t\t\t49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n\t\t\t\t\t\t138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n\t\t\t\t\t\t);\n\n\tfloat x  = vec.x;\n\tfloat y = vec.y;\n\n\tint xi = int(x) & 255;\n\tint yi = int(y) & 255;\n\tfloat xf = fract(x);\n\tfloat yf = fract(y);\n\tint aaa = p[p[    xi ]+    yi ];\n\treturn grad_simplex (aaa, xf  , yf);\n\n}\n\nfloat simplex_noise(vec2 vec)\n{\n\t\n    const float F = 0.366025404; // (sqrt(3)-1)/2;\n    const float G = 0.211324865; // (3-sqrt(3))/6;\n\n    vec2 i = floor(vec + (vec.x + vec.y) * F);//P\n\n    vec2 a = vec - (i - (i.x + i.y) * G);//(0, 0)\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    vec2 b = a - o + G;//(1, 0)(0, 1)\n    vec2 c = a - 1.0 + 2.0 * G;//(1, 1)\n\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n\n    return dot(vec3 (70.0, 70.0, 70.0), n);\n}\n\n\nfloat fbm(vec2 st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // \n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    // \n\n    for (int i = 0; i < 3; ++i) {\n        v+= a * simplex_noise(st);\n        st =  st * 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\n#define shadow vec3(0.101961,0.619608,0.666667)\n#define hightlight vec3(0.666667,0.666667,0.498039)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n        vec2 st = fragCoord/iResolution.xy;\n        st *= 5.;\n\n\tvec3 color = vec3(0.0);\n\n    vec2 q = vec2(0.0);\n    q.x = fbm(fbm(st + 0.20 * iTime) + st + 0.20 * iTime);\n    q.y = fbm(fbm(st + 0.30 * iTime) + st + 0.30 * iTime);\n\n    vec2 r = vec2(0.0);\n    r.x = fbm(st + 1.0 * q + vec2(1.7, 9.2) + 0.15 * iTime);\n    r.y = fbm(st + 1.0 * q + vec2(8.3, 2.8) + 0.126 * iTime);   \n\n    float f = fbm(st + r);\n\n    color = mix(shadow,\n                hightlight,\n                clamp((f*f)*4.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0,0,0.164706),\n                clamp(length(q),0.0,1.0));\n    color = mix(color,\n                vec3(0.666667,1,1),\n                clamp(length(r.x),0.0,1.0));\n                \n    vec2 qq = vec2( fbm( st + vec2(0.0,0.0) ),\n                   fbm( st + vec2(5.2,1.3) ) );\n\n    vec2 rr = vec2( fbm( st + 4.0*qq + vec2(1.7,9.2) ),\n                   fbm( st + 4.0*q + vec2(8.3,2.8) ) );\n\n    f = fbm( st + 4.0*rr );\n    \n    float radom = fbm( st + fbm(st +fbm(st + 0.2*iTime)));\n\n    vec3 col = mix(shadow, vec3(1.,1., 1.), radom);\n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdSR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 50, 50, 646], [648, 648, 671, 671, 1949], [1951, 1951, 1982, 1982, 2727], [2730, 2730, 2750, 2750, 3084], [3187, 3187, 3244, 3294, 4413]], "test": "untested"}
{"id": "7tcSD4", "name": "2d girl face", "author": "jorge2017a2", "description": "2d girl face", "tags": ["2d", "bezier", "gir", "lface"], "likes": 12, "viewed": 234, "published": 3, "date": "1639100893", "time_retrieved": "2024-07-30T18:43:08.885673", "image_code": "//por jorge2017a2\n//2d girl face---9-dic-2021\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(8.0*antialiasing(0.5),b,d)\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n    colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0));\nreturn colOut;\n}\n\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.0001,0.0));\nreturn colOut;\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{   p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat ellipse(vec2 p, vec2 focus0, vec2 focus1, float radius) \n{  return distance(p, focus0) + distance(p, focus1) - distance(focus0, focus1) * radius;}\n\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\n\nfloat HacerBoca(vec2 p)\n{vec2 p0=p;\n     \n    vec2 A,B,C ;\n    A=vec2(-0.1,0.0);\n    B=vec2(0.1,-0.1);\n    C=vec2(0.2,0.1);\n\n    float d1= sdBezier(p,A,B,C );\n    return d1;\n}\n\nfloat HacerNariz(vec2 p)\n{vec2 p0=p;\n     \n    vec2 A,B,C ;\n    A=vec2(0.0,0.1);\n    B=vec2(-0.1,-0.1);\n    C=vec2(0.1,-0.1);\n\n    float d1= sdBezier(p,A,B,C );\n    return d1;\n}\n\n\nfloat HacerPestanaIzq(vec2 p)  //hacer pestaas\n{ vec2 p0=p;\n     \n    vec2 A,B,C ;\n    A=vec2(0.0,0.15);\n    B=vec2(0.0,-0.01);\n    C=vec2(0.15,0.0);\n    p*=vec2(1.5,1.5);\n    float d1= sdBezier(p,A,B,C );\n    return d1;\n}\n\n\nfloat HacerPestanaDer(vec2 p)  //hacer pestaas\n{ vec2 p0=p;\n     \n    vec2 A,B,C ;\n    A=vec2(0.0,0.1);\n    B=vec2(0.0, 0.0);\n    C=vec2(-0.15,-0.05);\n    \n    p*=vec2(1.5,1.5);\n    float d1= sdBezier(p,A,B,C );\n    return d1;\n}\n\nfloat HacerBanda(vec2 p, float distOld)\n{ vec2 p0=p;\n    p.x= opRep1D(p.x, 0.4 );\n    float d2=sdCircle(p, 0.2 );\n    d2= intersectSDF(d2, distOld);\n    \n    return d2;\n    \n}\n\nvec3 HacerRostro2d(vec2 p, vec3 col)\n{\n    vec2 p0=p;     \n    //cabeza-pelo\n    float da1=sdCircle(p-vec2(0.0,1.2), 0.9 );\n    float da2=sdBox(p-vec2(0.0,0.0), vec2(1.2,0.5) );\n    da1= differenceSDF(da1, da2);\n    \n    //pelo der\n    p= rotatev2(p0-vec2(0.25,0.0), radians(-20.0));\n    float da2a=sdCircle(p-vec2(2.5,0.5), 2.5 );\n    float da2b=sdCircle(p-vec2(-1.5,0.5), 2.5 );\n    float da2a2b= intersectSDF(da2a,da2b);\n    \n    //pelo izq\n    p= rotatev2(p0-vec2(-1.25,0.35), radians(20.0));\n    float db2a=sdCircle(p-vec2(2.5,0.5), 2.5 );\n    float db2b=sdCircle(p-vec2(-1.5,0.5), 2.5 );\n    float db2a2b= intersectSDF(db2a,db2b);\n    \n    //unir pelo\n    float dpelo=da1;\n    dpelo=unionSDF(dpelo,db2a2b);\n    dpelo=unionSDF(dpelo,da2a2b);\n    \n    float r1, r2, he;\n    r1=0.35; r2=1.0; he=0.7;\n    p=p0;\n    float dr1= sdTrapezoid(p-vec2(0.0,-0.2),r1,r2,he);\n    r1=0.015; r2=0.375; he=0.135;\n    float dr2= sdTrapezoid(p-vec2(0.0,-1.0),r1,r2,he);\n     //dr1= unionSDF(dr1, dr2);\n     float t=iTime;\n     dr1=opSmoothUnion(dr1, dr2,0.025+abs(0.35*sin(0.5*sin(1.0-t)+cos(t+1.0))));\n    \n    //hacer Ojo izq\n    p= rotatev2(p0-vec2(-0.25,-0.4), radians(-35.0));\n    float dc1a=sdCircle(p*vec2(1.2,1.0), 0.2 );\n    \n    //ojo\n    p= rotatev2(p0-vec2(0.25,-0.4), radians(35.0));\n    float dc2a=sdCircle(p*vec2(1.2,1.0), 0.2 );\n    \n    //pupila izq\n    p= rotatev2(p0-vec2(-0.12,-0.45), radians(-1.0));\n    float dd1a=sdCircle(p*vec2(1.0,0.7), 0.06 );\n    dd1a= intersectSDF(dc1a,dd1a);\n    \n    //pupila der\n    p= rotatev2(p0-vec2(0.12,-0.45), radians(1.0));\n    float dd1b=sdCircle(p*vec2(1.0,0.7), 0.06 );\n    dd1b= intersectSDF(dc2a,dd1b);\n    \n    //ceja izq\n    p= rotatev2(p0-vec2(-0.2,-0.15), radians(35.0));\n    float de1a= sdBox(p, vec2(0.2,0.01) );\n    //ceja der\n     p= rotatev2(p0-vec2(0.2,-0.15), radians(-35.0));\n    float de1b= sdBox(p, vec2(0.2,0.01) );\n    \n    p=p0;\n    float df1a=HacerBoca(p-vec2(0.0,-0.85));\n    \n    \n    float dg1=HacerNariz(p-vec2(0.0,-0.65));\n    float dh1a=HacerPestanaIzq(p-vec2(-0.5,-0.25));\n    float dh1b=HacerPestanaIzq(p-vec2(-0.5,-0.35));\n    float dh1c=HacerPestanaIzq(p-vec2(-0.5,-0.45));\n    \n    float dh2a=HacerPestanaDer(p-vec2(0.4,-0.25));\n    float dh2b=HacerPestanaDer(p-vec2(0.5,-0.35));\n    float dh2c=HacerPestanaDer(p-vec2(0.5,-0.45));\n    \n    //cuello\n    float dia= sdBox(p-vec2(0.0,-1.2), vec2(0.25,0.4) );\n    \n    p.x=abs(p.x)-0.5;\n    float dja= sdCircle(p*vec2(1.0,0.8)-vec2(0.0,-0.4), 0.2 );//oreja izq\n    \n    p=p0;\n    float dka=HacerBanda(p-vec2(0.0,1.2),dpelo);\n    \n    \n    col= DrawFigBorde(vec3(1.0,0.878,0.878), col, dia);// cuello\n    col= DrawFigBorde(vec3(1.0,0.878,0.878), col, dja);// oreja\n    \n    \n    col= DrawFigBorde(vec3(1.0,0.878,0.878), col, dr1); //rostro\n    col= DrawFig(vec3(0.0,0.0,0.0), col, dpelo);\n    col= DrawFigBorde(vec3(1.0,0.0,0.0), col, dka);\n    \n    col= DrawFigDelgado(vec3(0.0), col, dh1a);//pestaa\n    col= DrawFigDelgado(vec3(0.0), col, dh1b);//pestaa\n    col= DrawFigDelgado(vec3(0.0), col, dh1c);//pestaa\n    \n    col= DrawFigDelgado(vec3(0.0), col, dh2a);//pestaa\n    col= DrawFigDelgado(vec3(0.0), col, dh2b);//pestaa\n    col= DrawFigDelgado(vec3(0.0), col, dh2c);//pestaa\n    \n    \n    col= DrawFigBorde(vec3(1.0), col, dc1a);  //ojo\n    col= DrawFigBorde(vec3(1.0), col, dc2a);//ojo\n    \n    col= DrawFigBorde(vec3(0.0), col, dd1a);//pupila izq\n    col= DrawFigBorde(vec3(0.0), col, dd1b);//pupila der\n    \n    col= DrawFigBorde(vec3(1.0), col, de1a); //ceja izq\n    col= DrawFigBorde(vec3(1.0), col, de1b); //ceja der\n    col= DrawFigBorde(vec3(1.0), col, df1a); //boca\n    \n    col= DrawFigBorde(vec3(1.0), col, dg1); //nariz\n    \n    \n    return col;\n}\n    \n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    uv-=vec2(0.0,-0.2);\n    float esc=2.0+sin(iTime*2.0);\n    uv*=esc;\n    float t=iTime;\n   vec3 col=vec3(55,171,224)/255.0;\n   \n\n    uv.x= opRep1D(uv.x, 2.5);\n\n    col= HacerRostro2d(uv-vec2(0.0,0.3),col);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tcSD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[330, 330, 355, 355, 374], [375, 375, 400, 400, 419], [420, 420, 456, 456, 484], [487, 487, 539, 539, 638], [640, 640, 698, 698, 798], [800, 800, 859, 859, 958], [960, 991, 1027, 1027, 1072], [1077, 1121, 1168, 1168, 1195], [1196, 1196, 1239, 1239, 1266], [1267, 1267, 1315, 1315, 1343], [1349, 1349, 1411, 1411, 1545], [1547, 1547, 1628, 1628, 1758], [1760, 1760, 1817, 1817, 1888], [1891, 1891, 1955, 1955, 2027], [2029, 2029, 2063, 2063, 2158], [2160, 2160, 2197, 2197, 2271], [2273, 2273, 2308, 2308, 2331], [2334, 2334, 2396, 2396, 2633], [2635, 2635, 2699, 2699, 2787], [2790, 2790, 2855, 2855, 3165], [3167, 3167, 3231, 3231, 4269], [4272, 4272, 4297, 4297, 4447], [4449, 4449, 4475, 4475, 4626], [4629, 4629, 4679, 4679, 4853], [4856, 4856, 4906, 4906, 5086], [5088, 5088, 5129, 5129, 5263], [5265, 5265, 5303, 5303, 8963], [8972, 8972, 9029, 9029, 9370]], "test": "untested"}
{"id": "st3SW4", "name": "[SIG15] sig-n-sine, impr. mblur", "author": "Hatchling", "description": "improvised some psychedelic nonsense... getting 2001 and enter the void vibes\n\nEDIT: improved motion blur using blue noise", "tags": ["procedural", "2d", "psychedelic"], "likes": 7, "viewed": 308, "published": 3, "date": "1639088887", "time_retrieved": "2024-07-30T18:43:09.749364", "image_code": "const float pi = 3.14159;\n\nfloat sigmoid(float x){\n \treturn x/(1.+abs(x));   \n}\n\nfloat iter(vec2 p, vec4 a, vec4 wt, vec4 ws, float t, float m, float stereo){\n    float wp = .2;\n    vec4 phase = vec4(mod(t, wp), mod(t+wp*.25, wp), mod(t+wp*.5, wp), mod(t+wp*.75, wp))/wp;\n    float zoom = 1./(1.+.5*(p.x*p.x+p.y*p.y));\n    vec4 scale = zoom*pow(vec4(2.), -4.*phase);\n    vec4 ms = .5-.5*cos(2.*pi*phase);\n    vec4 pan = stereo/scale*(1.-phase)*(1.-phase);\n    vec4 v = ms*sin( wt*(t+m) + (m+ws*scale)*((p.x+pan) * cos((t+m)*a) + p.y * sin((t+m)*a)));\n    return sigmoid(v.x+v.y+v.z+v.w+m);\n}\n\nvec3 scene(float gt, vec2 uv, vec4 a0, vec4 wt0, vec4 ws0, float blur){\n    gt *= 2.;\n    //time modulation\n    float tm = mod(.0411*gt, 1.);\n    tm = sin(2.*pi*tm*tm);\n    float t = (.04*gt + .05*tm);\n    \n    float stereo = 1.*(sigmoid(2.*(sin(1.325*t*cos(.5*t))+sin(-.7*t*sin(.77*t)))));//+sin(-17.*t)+sin(10.*t))));\n    //t = 0.;\n    //also apply spatial offset\n    uv+= .5*sin(.33*t)*vec2(cos(t), sin(t));\n    \n    //wildly iterate and divide\n    float p0 = iter(uv, a0, wt0, ws0, t, 0., stereo);\n    \n   \tfloat p1 = iter(uv, a0, wt0, ws0, t, p0, stereo);\n    \n    float p2 = sigmoid(p0/(p1+blur));\n    \n    float p3 = iter(uv, a0, wt0, ws0, t, p2, stereo);\n    \n    float p4 = sigmoid(p3/(p2+blur));\n    \n    float p5 = iter(uv, a0, wt0, ws0, t, p4, stereo);\n    \n    float p6 = sigmoid(p4/(p5+blur));\n    \n    float p7 = iter(uv, a0, wt0, ws0, t, p6, stereo);\n    \n    float p8 = sigmoid(p4/(p2+blur));\n    \n    float p9 = sigmoid(p8/(p7+blur));\n    \n    float p10 = iter(uv, a0, wt0, ws0, t, p8, stereo);\n    \n    float p11 = iter(uv, a0, wt0, ws0, t, p9, stereo);\n    \n    float p12 = sigmoid(p11/(p10+blur));\n    \n    float p13 = iter(uv, a0, wt0, ws0, t, p12, stereo);\n    \n    //colors\n    vec3 accent_color = vec3(1.,0.2,0.);//vec3(0.99,0.5,0.2);\n    /*float r = sigmoid(-1.+2.*p0+p1-max(1.*p3,0.)+p5+p7+p10+p11+p13);\n    float g = sigmoid(-1.+2.*p0-max(1.*p1,0.)-max(2.*p3,0.)-max(2.*p5,0.)+p7+p10+p11+p13);\n    float b = sigmoid(0.+1.5*p0+p1+p3+-max(2.*p5,0.)+p7+p10+p11+p13);\n    */\n    float r = sigmoid(p0+p1+p5+p7+p10+p11+p13);\n    float g = sigmoid(p0-p1+p3+p7+p10+p11);\n    float b = sigmoid(p0+p1+p3+p5+p11+p13);\n    \n    \n    vec3 c = max(vec3(0.), .4+.6*vec3(r,g,b));\n    \n    float eps = .4;\n    float canary = min(abs(p1), abs(p2));\n    canary = min(canary, abs(p5));\n    //canary = min(canary, abs(p6));\n    canary = min(canary, abs(p7));\n    canary = min(canary, abs(p10));\n    float m = max(0.,eps-canary)/eps;\n    m = sigmoid((m-.5)*700./(1.+10.*blur))*.5+.5;\n    //m = m*m*m*m*m*m*m*m*m*m;\n    vec3 m3 = m*(1.-accent_color);\n    c *= .8*(1.-m3)+.3;//mix(c, vec3(0.), m);\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s = min(iResolution.x, iResolution.y);\n   \tvec2 uv = (2.*fragCoord.xy - vec2(iResolution.xy)) / s;\n    \n    float blur = .5*(uv.x*uv.x+uv.y*uv.y);\n    \n    //angular, spatial and temporal frequencies\n    vec4 a0 = pi*vec4(.1, -.11, .111, -.1111); \n    vec4 wt0 = 2.*pi*vec4(.3);//.3333, .333, .33, .3);\n    vec4 ws0 = 2.5*vec4(11., 13., 11., 5.);\n\n    vec2 blueNoiseUV = fragCoord.xy / iChannelResolution[0].xy;\n    \n    float blueNoise = texture(iChannel0, blueNoiseUV).r / 9.;\n    \n\n    //aa and motion blur\n    float mb = iTimeDelta*1.;\n    float t = 1100.+iTime + blueNoise*mb;\n    vec3 c = scene(t, uv, a0, wt0, ws0, blur)\n        + scene(t-mb*(1./9.), uv+(1.+blur)*vec2(.66/s, 0.), a0, wt0, ws0, blur)\n        + scene(t-mb*(2./9.), uv+(1.+blur)*vec2(-.66/s, 0.), a0, wt0, ws0, blur)\n        + scene(t-mb*(3./9.), uv+(1.+blur)*vec2(0., .66/s), a0, wt0, ws0, blur)\n        + scene(t-mb*(4./9.), uv+(1.+blur)*vec2(0., -.66/s), a0, wt0, ws0, blur)\n        + scene(t-mb*(5./9.), uv+(1.+blur)*vec2(.5/s, .5/s), a0, wt0, ws0, blur)\n        + scene(t-mb*(6./9.), uv+(1.+blur)*vec2(-.5/s, .5/s), a0, wt0, ws0, blur)\n        + scene(t-mb*(7./9.), uv+(1.+blur)*vec2(-.5/s, -.5/s), a0, wt0, ws0, blur)\n        + scene(t-mb*(8./9.), uv+(1.+blur)*vec2(.5/s, -.5/s), a0, wt0, ws0, blur)\n\n        ;\n    c/=9.;\n    \n    fragColor = vec4(c,1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3SW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 50, 50, 79], [81, 81, 158, 158, 591], [593, 593, 664, 664, 2715], [2717, 2717, 2774, 2774, 4120]], "test": "untested"}
{"id": "Nl3XD4", "name": "Fork tv noise tshepang 009", "author": "tshepang", "description": "tv noise shader with chromatic aberration\n\n\n\n", "tags": ["noise", "tv", "shader"], "likes": 3, "viewed": 265, "published": 3, "date": "1639078322", "time_retrieved": "2024-07-30T18:43:10.496367", "image_code": "\n#define noiselevel 0.4\n#define rgbshiftlevel 0.01\n#define ghostreflectionlevel 0.03\n#define bypass false\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float randomValue = rand(vec2(uv.x+sin(iTime), uv.y+cos(iTime)));\n    float rgbShift = sin(iTime+randomValue)*rgbshiftlevel;\n    \n    if(randomValue > 0.95-ghostreflectionlevel)\n    \tuv.x+=sin(iTime/5.0)*0.5;\n   \n    uv.y += (cos(iTime*randomValue)+0.5) * (randomValue*0.01);\n    \n    float colorr = texture(iChannel0, vec2(uv.x+rgbShift, uv.y)).r;\n    float colorg = texture(iChannel0, vec2(uv.x, uv.y)).g;\n    float colorb = texture(iChannel0, vec2(uv.x-rgbShift, uv.y)).b;\n    \n  \tvec4 movieColor = vec4(colorr,colorg,colorb, 1.0);\n    vec4 noiseColor = vec4(randomValue,randomValue,randomValue,1.0);\n \n    if(randomValue > 0.55-ghostreflectionlevel)\n    \tnoiseColor = abs(noiseColor - 0.2);\n \n    if(bypass)\n        fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy); \n    else\n      \tfragColor = mix(movieColor, noiseColor, noiselevel);  \n    \n\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3XD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 127, 127, 199], [201, 201, 258, 258, 1173]], "test": "untested"}
{"id": "7ttSDH", "name": "No nearclip", "author": "theraot", "description": "This is a simulation of what happens without near clipping such that we can see the object behind the camera. This demonstrate the topological distortion of perspective projection.", "tags": ["3d", "raycasting", "clipping"], "likes": 2, "viewed": 246, "published": 3, "date": "1639066331", "time_retrieved": "2024-07-30T18:43:11.427876", "image_code": "#define PI 3.1415926\n#define MAX 1000000.0;\n\n// Transform functions\n\nmat4 rotate_xz(float t)\n{\n    return mat4(\n        cos(t) , 0.0, sin(t), 0.0,\n        0.0    , 1.0, 0.0   , 0.0,\n        -sin(t), 0.0, cos(t), 0.0,\n        0.0    , 0.0, 0.0   , 1.0\n    );\n}\n\nmat4 rotate_yz(float t)\n{\n    return mat4(\n        1.0 , 0.0    , 0.0   , 0.0,\n        0.0 , cos(t) , sin(t), 0.0,\n        0.0 , -sin(t), cos(t), 0.0,\n        0.0 , 0.0    , 0.0   , 1.0\n    );\n}\n\nmat4 translate(vec3 v)\n{\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                v.x, v.y, v.z, 1.0);\n}\n\nmat4 scale(vec3 s)\n{\n    return mat4(s.x, 0.0, 0.0, 0.0,\n                0.0, s.y, 0.0, 0.0,\n                0.0, 0.0, s.z, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\n// Ray and Ray functions\n\nstruct Ray {vec3 direction; vec3 position; };\n\nvoid rayAdvance(inout Ray ray, float dist)\n{\n    ray.position = (ray.direction * dist) + ray.position;\n}\n\nRay rayTransform(Ray ray, mat4 transformation)\n{\n    return Ray\n    (\n        normalize((transformation * vec4(ray.direction, 0.0)).xyz),\n        (transformation * vec4(ray.position, 1.0)).xyz\n    );\n}\n\n// Ray Casting\n\n#define OBJ_COUNT 6\n\nvec3 raycast(Ray camRay)\n{\n    // Note: we could get these transforms and colors as uniforms\n\n    // Object transform (these are actually inverse transform, so we can apply them to the ray):\n    mat4 transforms[] = mat4[](\n        translate(vec3(0.0, 0.0, 0.5)),\n        translate(vec3(0.0, 0.0, -0.5)),\n        rotate_xz(PI * 0.5) * translate(vec3(0.5, 0.0, 0.0)),\n        rotate_xz(PI * 0.5) * translate(vec3(-0.5, 0.0, 0.0)),\n        rotate_yz(PI * 0.5) * translate(vec3(0.0, 0.5, 0.0)),\n        rotate_yz(PI * 0.5) * translate(vec3(0.0, -0.5, 0.0))\n    );\n\n    // Object color:\n    vec3 colors[] = vec3[](\n        vec3(1.0, 0.0, 0.0),\n        vec3(1.0, 1.0, 0.0),\n        vec3(0.0, 1.0, 0.0),\n        vec3(0.0, 1.0, 1.0),\n        vec3(0.0, 0.0, 1.0),\n        vec3(1.0, 0.0, 1.0)\n    );\n\n    // Cast Setup:\n    float r = MAX;\n    vec3 color = vec3(0.0);\n\n    // Cast (we are not marching):\n    for (int i = 0; i < OBJ_COUNT; i++)\n    {\n        Ray modelRay = rayTransform(camRay, transforms[i]);\n        float dist = -modelRay.position.z/modelRay.direction.z;\n        rayAdvance(modelRay, dist);\n        vec2 check = sign(vec2(0.5) - abs(modelRay.position.xy));\n        // float nearClipMask = clamp(sign(dist), 0.0, 1.0); // This is the correct one\n        float nearClipMask = clamp(abs(dist), 0.0, 1.0); // Incorrect one for demostration purposes\n        float hitMask = nearClipMask * clamp(sign(check.x + check.y), 0.0, 1.0);\n        float got = dist * hitMask + (1.0 - hitMask) * MAX;\n        // ---\n        // float betterMask = clamp(sign(abs(r) - abs(got)), 0.0, 1.0); // Use this to fix face culling\n        float betterMask = clamp(sign(r - got), 0.0, 1.0);\n        vec3 candidateColor = colors[i] * texture(iChannel0, modelRay.position.xy + 0.5).rgb;\n        color = candidateColor * betterMask + color * (1.0 - betterMask);\n        r = got * betterMask + r * (1.0 - betterMask);\n    }\n\n    // // We could advance the ray, compute simple reflection, loop mixing colors until some max reflections\n    // rayAdvance(camRay, r);\n\n    // Fog\n    vec3 fogcolor = vec3(1.0);\n    color = mix(fogcolor, color, exp(-r * r / 200.0));\n\n    // Output\n    return color;\n}\n\n// Main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Basic setup:\n    vec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    Ray camRay = Ray\n    (\n        normalize(vec3(screenPos.x, screenPos.y * (iResolution.y/iResolution.x), 1.0)),\n         vec3(0.0, 0.0, 0.0)\n    );\n\n    // Camera transform (I apply an scaling transform to the ray to make the world appear stretched in z):\n    float verticalOscilation = sin(iTime * 0.7) * 1.0;\n    float forth = sin(iTime) * 5.0;\n    float zStreching = 5.0;\n    mat4 camTransform = scale(vec3(1.0, 1.0, 1.0/zStreching)) * translate(vec3(2.0, verticalOscilation, forth));\n    camRay = rayTransform(camRay, camTransform);\n\n    // Cast:\n    fragColor = vec4(raycast(camRay), 0.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttSDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 94, 94, 259], [261, 261, 286, 286, 455], [457, 457, 481, 481, 628], [630, 630, 650, 650, 797], [872, 872, 916, 916, 976], [978, 978, 1026, 1026, 1179], [3402, 3402, 3459, 3479, 4145]], "test": "untested"}
{"id": "sttSDH", "name": "fractal animation 001", "author": "yasuo", "description": "fractal animation", "tags": ["fractal"], "likes": 14, "viewed": 388, "published": 3, "date": "1639066129", "time_retrieved": "2024-07-30T18:43:12.266633", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 64\n#define MAX_DIST 64.\n#define SURF_DIST .0001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n\n#define ZERO (min(iFrame,0))\n\nvec3 directions[5] = vec3[](vec3(0,-1.,0),vec3(1.,0,0),vec3(-1.,0,0),vec3(0,0,1.),vec3(0,0,-1.));\n\nfloat B3D(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat childBlock(vec3 p){\n    float childScale = 0.1;\n    float d = B3D(p,vec3(childScale));\n    childScale*=0.5;\n    int index = 0;\n    for(float i = 0.; i<5.0; i++){\n        vec3 dir = (directions[index]*0.1);\n        \n        vec3 pos = p+(dir+(dir*0.5));\n       \n        float d2 = B3D(pos,vec3(childScale));\n        d = min(d,d2);\n        index++;\n    }\n    return d;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    p*=3.0;\n    float d = childBlock(p);\n    float depth = 5.;\n    int index = 0;\n    for(float i = 0.; i<depth; i++){\n        p*= 1.0+i*0.1;\n        p*=matRotateX(radians(i*10.0+iTime*20.1))*matRotateZ(radians(i*20.0+iTime*32.2));\n        p = abs(p);\n        p-=0.2+i*0.01;\n        float d2 = childBlock(p);\n        d = min(d,d2);\n        index++;\n    }\n    p = prevP;\n    d = min(d,p.y+0.8);\n    vec2 model = vec2(d*0.2,0);\n\n    \n    return model;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<3; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n\n\n    return diffuseMaterial(n,rd,p,0.5 + 0.5*sin(iTime+p.xyz+vec3(0,2,3))*cos(iTime+p.xyz+vec3(0,2,3)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy -.3;\n    \n    vec3 ro = vec3(0, 0, 1.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    if(iMouse.z>0.){\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.xz *= Rot(radians(-15.0+iTime*20.0));\n    }\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        col *= exp( -0.038*d.x*d.x*d.x );//fog\n    } else {\n        col = vec3(0.0);\n    }\n    \n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttSDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[715, 715, 742, 742, 796], [798, 798, 823, 823, 1172], [1174, 1174, 1196, 1196, 1673], [1675, 1675, 1733, 1733, 2000], [2002, 2002, 2026, 2026, 2227], [2229, 2229, 2271, 2271, 2466], [2468, 2509, 2558, 2558, 2849], [2851, 2851, 2908, 2908, 3527], [3529, 3529, 3551, 3551, 3641], [3643, 3643, 3702, 3702, 3810], [3812, 3812, 3869, 3869, 4815]], "test": "untested"}
{"id": "stdXD8", "name": "testing % : Win vs OpenGL vs mod", "author": "FabriceNeyret2", "description": "testing % (top) vs mod (bottom)  on OpenGL vs Windows\nramp -5...4 % 10\n red = positive, green = negative.\n\nsee screen dumps below. ", "tags": ["glsl", "mod", "bug", "compatibility"], "likes": 4, "viewed": 255, "published": 3, "date": "1639061196", "time_retrieved": "2024-07-30T18:43:13.120351", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n  //O = vec4( min(-1,iFrame)%10==5); return;  // OpenGL: WTF !!!\n  //O = vec4( (-1)%10==0); return;            // OpenGL: WTF !!!\n  //O = vec4( min(-1,iFrame)%10==-1); return; // Windows\n  //O = vec4( int(min(-1.,float(iFrame)))%10==5); return; // same\n  \n    U *= 10./iResolution.xy;\n    float x = floor(U.x) - 5.;\n    int v = U.y>5. ? int(     x )%10        // top : %\n                   : int( mod(x , 10.) );   // bot : mod\n    O = vec4( v, -v, 0,0 ) / 10.;\n    O = sqrt(O);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdXD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 291, 519]], "test": "untested"}
{"id": "sttXW8", "name": "spacial gamma homogeneity", "author": "FabriceNeyret2", "description": "use in fullscreen. Mouse.y tune the gamma. \nsqueeze your eyes and try to fit either the grey ramps or mid-grey.\nIn addition to check your gamma value ( must be 2.2 ), check how it is stable or not along the screen (or view angle).", "tags": ["gamma", "bluenoise"], "likes": 12, "viewed": 314, "published": 3, "date": "1639056753", "time_retrieved": "2024-07-30T18:43:13.995012", "image_code": "// variant of https://shadertoy.com/view/NldXDH\n\nvec4 char(vec2 p, int c) { // from https://www.shadertoy.com/view/llySRh\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy );\n}\nvec4 pF11(vec2 p, float n) {\n    vec4 v = char(p, 48+ int(n) );\n         p.x -= .3;\n         v += char(p, 46);\n         p.x -= .3;\n         v += char(p, 48+ int(fract(n)*10.) );\n    return v;\n}\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, U = 4.*u/R;\n    if (U.y<.25)   U.y-=.125;\n    if (U.y >3.75) U.y=fract(U.y)+.125;\n    U = fract(U-vec2(0,.25));\n    float g = length(iMouse.xy)<10. ? 2.2 : 1. + 2.*iMouse.y/R.y,\n          y = pow(U.x,1./g);\n    float n = step(texelFetch(iChannel0, ivec2(u)%1024, 0 ).r,U.x);\n    int i = int( 4.*U.y);\n    O = vec4( i==0 ? y : i==1 ? n : i==2 ? pow(.5,1./g) : mod(u.x+u.y,2.) );\n\n    O = mix(O, vec4(1), pF11(3.*(2.*u-R)/R.y,g).r );\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttXW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 75, 121, 352], [353, 353, 381, 381, 546], [547, 547, 585, 585, 1048]], "test": "untested"}
{"id": "NldXDH", "name": "gamma grey+RGB vs blue dither", "author": "FabriceNeyret2", "description": "one more gamma tuning,  squeeze your eyes and try to fit the grey ramps, or the color ramps.\nusing blue noise for dither, +separating RGB vs grey.\nNB: on my screens, the gamma is not the same on the 4corners of the screen :-(\n\nMouse.y tune the gamma.", "tags": ["gamma", "bluenoise"], "likes": 10, "viewed": 326, "published": 3, "date": "1639055405", "time_retrieved": "2024-07-30T18:43:14.864686", "image_code": "\nvec4 char(vec2 p, int c) { // from https://www.shadertoy.com/view/llySRh\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy );\n}\nvec4 pF11(vec2 p, float n) {\n    vec4 v = char(p, 48+ int(n) );\n         p.x -= .3;\n         v += char(p, 46);\n         p.x -= .3;\n         v += char(p, 48+ int(fract(n)*10.) );\n    return v;\n}\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, U = u/R;\n    int   x = int( 8. * U.x );\n    float g = length(iMouse.xy)<10. ? 2.2 : 1. + 2.*iMouse.y/R.y,\n          y = pow(U.y,1./g);\n    float n = step(texelFetch(iChannel0, ivec2(u)%1024, 0 ).r,U.y);\n    O-=O;\n    if (x<2) O = vec4( x==0 ? n : y) ;\n    else     O[x/2-1] = x%2==0 ? n : y;\n    \n    O = mix(O, vec4(1), pF11(3.*(2.*u-R)/R.y,g).r );\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldXDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 27, 73, 304], [305, 305, 333, 333, 498], [499, 499, 537, 537, 918]], "test": "untested"}
{"id": "NtdXWH", "name": "Seizure Warning", "author": "Wykes", "description": "First test with shaping functions. Works best when projected on a big wall.", "tags": ["function", "shaping"], "likes": 0, "viewed": 234, "published": 3, "date": "1639047791", "time_retrieved": "2024-07-30T18:43:15.629642", "image_code": "float plot(vec2 st, float pct){\n  return  smoothstep( pct-0.7, pct, st.y) -\n          smoothstep( pct, pct+0.684, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv*2.0 - 1.0) * 1.184 ;\n    vec2 m = iMouse.xy / iResolution.xy;\n    float time = iTime;\n    m -= 100.0*sin(time);\n\n    float y = 0.0;\n    y = (((sin( uv.y*m.x / 0.334 ) + uv.x / -2.224) + fract( uv.x*m.y / -0.282 )) + fract( uv.x / uv.y )) * m.x;\n\n    vec3 color = vec3(y);\n\n    float pct = plot(uv,y);\n\n    // Time varying pixel color\n    vec3 col = vec3(pct);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdXWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 122], [124, 124, 181, 231, 702]], "test": "untested"}
{"id": "7ttXRn", "name": "kyu190a", "author": "soma_arc", "description": "SDF to render kyu190a", "tags": ["3d"], "likes": 8, "viewed": 271, "published": 3, "date": "1639040907", "time_retrieved": "2024-07-30T18:43:16.646921", "image_code": "// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                 fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst vec3 BLACK = vec3(0);\nconst vec3 LIGHT_POS = vec3(100, 100, 100);\nconst vec3 LIGHT_DIR = normalize(LIGHT_POS);\nconst float AMBIENT_FACTOR = 0.1;\nconst int OBJ_PLANE = 0;\n\nconst float EPSILON = 0.001;\nconst float PI = 3.14159265;\nconst float PI_2 = 3.14159265 / 2.;\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 deGamma(vec3 rgb){\n  return vec3((min(pow(rgb.r, 2.2), 1.)),\n              (min(pow(rgb.g, 2.2), 1.)),\n              (min(pow(rgb.b, 2.2), 1.)));\n}\n\nmat3 getRotationX(float rotationDegrees) {\n    float thetaRad = radians(rotationDegrees);\n    float cosTheta = cos(thetaRad);\n    float sinTheta = sin(thetaRad);\n    return mat3(1, 0, 0,\n                0, cosTheta, -sinTheta,\n                0, sinTheta, cosTheta);\n}\n\nmat3 getRotationY(float rotationDegrees){\n    float thetaRad = radians(rotationDegrees);\n    float cosTheta = cos(thetaRad);\n    float sinTheta = sin(thetaRad);\n    return mat3(cosTheta, 0, sinTheta,\n                0, 1, 0,\n                -sinTheta, 0, cosTheta);\n}\n\nmat3 getRotationZ(float rotationDegrees){\n    float thetaRad = radians(rotationDegrees);\n    float cosTheta = cos(thetaRad);\n    float sinTheta = sin(thetaRad);\n    return mat3(cosTheta, -sinTheta, 0,\n                sinTheta, cosTheta, 0,\n                0, 0, 1);\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat distSphere(vec3 p, vec4 sphere){\n\treturn distance(p, sphere.xyz) - sphere.w;\n}\n\nfloat distPlane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat distEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat distTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat distVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat distCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nconst int OBJ_KYU_BODY = 1;\nconst int OBJ_KYU_EYE = 2;\nconst int OBJ_KYU_BROW = 3;\nconst int OBJ_KYU_MOUTH = 4;\nconst int OBJ_KYU_CHEEK = 5;\nconst int OBJ_KYU_ARM = 6;\nconst int OBJ_KYU_TAIL = 7;\n\nvec2 distKyuBrow(vec3 p) {\n    mat3 r1 = getRotationX(135.) * getRotationY(-70.) * getRotationZ(-30.);\n    mat3 r2 = getRotationX(135.) * getRotationY(70.) * getRotationZ(30.);\n    vec3 t1 = vec3(130, -260, -180);\n    vec3 t2 = vec3(-130, -260, -180);\n    return opUnion(vec2(distVerticalCapsule(r1 * (p + t1), 100., 20.),\n                   OBJ_KYU_BROW),\n                   vec2(distVerticalCapsule(r2 * (p + t2), 100., 20.),\n                   OBJ_KYU_BROW));\n}\n\nvec2 distKyuEye(vec3 p) {\n    mat3 r1 = getRotationX(40.) * getRotationZ(15.);\n    mat3 r2 = getRotationX(40.) * getRotationZ(-15.);\n    vec3 t1 = vec3(120, -200, -280);\n    vec3 t2 = vec3(-120, -200, -280);\n    return opUnion(vec2(distTorus(r1 * (p + t1), vec2(50, 20)),\n                   OBJ_KYU_EYE),\n                   vec2(distTorus(r2 * (p + t2), vec2(50, 20)),\n                   OBJ_KYU_EYE));\n}\n\nvec2 distKyuMouth(vec3 p){\n    mat3 r = getRotationX(30.) * getRotationZ(180.);\n    vec3 t1 = vec3(120 -70, -120, -350);\n    vec3 t2 = vec3(10  -70, -120, -350);\n    float an = radians(90.);\n    return opUnion(vec2(distCappedTorus(r * (p + t1), vec2(sin(an),cos(an)), 50., 20.),\n                        OBJ_KYU_MOUTH),\n                   vec2(distCappedTorus(r * (p + t2), vec2(sin(an),cos(an)), 50., 20.),\n                        OBJ_KYU_MOUTH));\n}\n\nvec2 distKyuCheek(vec3 p ) {\n    mat3 r1 = getRotationX(130.) * getRotationY(-40.) * getRotationZ(-20.);\n    mat3 r2 = getRotationX(130.) * getRotationY(40.) * getRotationZ(20.);\n    vec3 t1 = vec3(-260, -140, -280);\n    vec3 t2 = vec3(260, -140, -280);\n    return opUnion(vec2(distVerticalCapsule(r1 * (p + t1), 100., 20.),\n                   OBJ_KYU_BROW),\n                   vec2(distVerticalCapsule(r2 * (p + t2), 100., 20.),\n                   OBJ_KYU_BROW));\n}\n\nvec2 distKyuArm(vec3 p){\n    return opUnion(vec2(distEllipsoid(p + vec3(400, 0, -100),\n                                      vec3(100, 100, 200)),\n                   OBJ_KYU_ARM),\n                   vec2(distEllipsoid(p + vec3(-400, 0, -100),\n                                      vec3(100, 100, 200)),\n                   OBJ_KYU_ARM));\n}\n\nvec2 distKyuTail(vec3 p){\n    return vec2(distEllipsoid(p + vec3(0, 0, 500), \n                              vec3(200, 100, 200)),\n                OBJ_KYU_TAIL);\n}\n\nvec2 distKyu190a(vec3 p) {\n    vec2 d = vec2(distEllipsoid(p, vec3(500, 300, 400)), OBJ_KYU_BODY);\n    d = opUnion(d, distKyuEye(p));\n    d = opUnion(d, distKyuBrow(p));\n    d = opUnion(d, distKyuMouth(p));\n    d = opUnion(d, distKyuCheek(p));\n    d = opUnion(d, distKyuArm(p));\n    d = opUnion(d, distKyuTail(p));\n    return d;\n}\n\nvec3 getMatKyu190a(int objId) {\n    if(objId == OBJ_KYU_BODY){\n        return vec3(1);\n    } else if(objId == OBJ_KYU_EYE) {\n        return vec3(0);\n    } else if(objId == OBJ_KYU_BROW) {\n        return vec3(0);\n    } else if (objId== OBJ_KYU_MOUTH) {\n        return vec3(0);\n    } else if(objId == OBJ_KYU_CHEEK) {\n        return vec3(0);\n    } else if(objId == OBJ_KYU_ARM) {\n        return vec3(1);\n    } else if(objId == OBJ_KYU_TAIL) {\n        return vec3(1);\n    }\n}\n\nvec2 distFunc(vec3 p, float time) {\n\tvec2 d = vec2(distPlane(p, vec4(0, 1, 0, 300)), OBJ_PLANE);\n    d = opUnion(d, distKyu190a(p + vec3(0,-200. + -400. * sin(iTime) * sin(iTime), 0)));\n    return d;\n}\n\nconst vec2 NORMAL_COEFF = vec2(1., 0.);\nvec3 computeNormal(const vec3 p, const float t){\n  return normalize(vec3(distFunc(p + NORMAL_COEFF.xyy, t).x - distFunc(p - NORMAL_COEFF.xyy, t).x,\n                        distFunc(p + NORMAL_COEFF.yxy, t).x - distFunc(p - NORMAL_COEFF.yxy, t).x,\n                        distFunc(p + NORMAL_COEFF.yyx, t).x - distFunc(p - NORMAL_COEFF.yyx, t).x));\n}\n\nconst int MAX_MARCH = 500;\nint march (vec3 rayOrg, vec3 rayDir, float time, inout float minDist,\n           float maxDist,\n           inout vec3 intersection, inout vec3 normal) {\n    vec3 rayPos = rayOrg + minDist * rayDir;\n    vec2 dist = vec2(-1);\n    float rayLength = 0.;\n    for(int i = 0 ; i < MAX_MARCH ; i++){\n        if(rayLength > maxDist) return -1;\n        dist = distFunc(rayPos, time);\n        rayLength += dist.x;\n        rayPos = rayOrg + rayDir * rayLength;\n        if(dist.x < EPSILON){\n            int objId = int(dist.y);\n            intersection = rayPos;\n            normal = computeNormal(intersection, time);\n            minDist = rayLength;\n            return objId;\n        }\n    }\n    return -1;\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(fov * .5);\n  vec3 v = normalize(target - eye);\n  vec3 xaxis = normalize(cross(v, up));\n  vec3 yaxis =  normalize(cross(v, xaxis));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nvec3 getMatColor(int objId, vec3 normal, vec3 intersection){\n    if(objId == OBJ_PLANE){\n        vec2 p = fract(intersection.xz / iChannelResolution[0].xy);\n        vec3 col = deGamma(texture(iChannel0, p).rgb);\n        return mix(col, vec3(0.7, 0.8, 1.), 0.); \n    }else if(objId != -1){\n        return getMatKyu190a(objId);\n    }\n\treturn BLACK;\n}\n\nvec3 sky(vec3 rayDir){\n\treturn clamp(vec3(.7, .8, 1.) + exp(dot(rayDir, LIGHT_DIR))*0.1, 0.0, 1.0);\n}\n\nfloat computeShadowFactor (vec3 rayOrg, vec3 rayDir,\n                           float mint, float maxt, float k) {\n    float shadowFactor = 1.0;\n    for(float t = mint ; t < maxt ;){\n        float d = distFunc(rayOrg + rayDir * t, 0.).x;\n        if(d < EPSILON) break;\n\n        shadowFactor = min(shadowFactor, k * d / t);\n        t += d;\n    }\n    return clamp(shadowFactor, 0.0, 1.0);\n}\n\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    return pow(clamp(dot(reflect(e,n),l),0.0, 1.),s);\n}\n\n// p: center of the plane\n// n: normal of the plane\nbool intersectPlane(vec3 p, vec3 n, \n                    vec3 rayOrigin, vec3 rayDir,\n                     inout float minDist,\n                    inout vec3 intersection, inout vec3 normal){\n    float d = -dot(p, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(EPSILON < t && t < minDist){\n\t\tintersection = rayOrigin + t * rayDir;\n        normal = n;\n        minDist = t;\n        return true;\n    }\n    return false;\n}\n\n\nbool intersectSphere(vec3 sphereCenter, float radius, \n                     vec3 rayOrigin, vec3 rayDir, \n                     inout float minDist,\n                     inout vec3 intersection, inout vec3 normal){\n  \tvec3 v = rayOrigin - sphereCenter;\n  \tfloat b = dot(rayDir, v);\n  \tfloat c = dot(v, v) - radius * radius;\n  \tfloat d = b * b - c;\n  \tif(d >= 0.){\n    \tfloat s = sqrt(d);\n    \tfloat t = -b - s;\n    \tif(t <= EPSILON) t = -b + s;\n    \tif(EPSILON < t && t < minDist){\n      \t\tintersection = (rayOrigin + t * rayDir);\n      \t\tminDist = t;\n            normal = normalize(intersection - sphereCenter);\n      \t\treturn true;\n    \t}\n  \t}\n  \treturn false;\n}\n\nbool intersectBox(vec3 rayOrg, vec3 rayDir, vec3 boxMin, vec3 boxMax,\n                  out float hit0, out float hit1) {\n\tfloat t0 = -10000.0, t1 = 10000.0;\n    hit0 = t0;\n    hit1 = t1;\n    \n    vec3 tNear = (boxMin - rayOrg) / rayDir;\n    vec3 tFar  = (boxMax - rayOrg) / rayDir;\n    \n    if (tNear.x > tFar.x) {\n        float tmp = tNear.x;\n        tNear.x = tFar.x;\n        tFar.x = tmp;\n    }\n    t0 = max(tNear.x, t0);\n    t1 = min(tFar.x, t1);\n\n    if (tNear.y > tFar.y) {\n        float tmp = tNear.y;\n        tNear.y = tFar.y;\n        tFar.y = tmp;\n    }\n    t0 = max(tNear.y, t0);\n    t1 = min(tFar.y, t1);\n\n    if (tNear.z > tFar.z) {\n        float tmp = tNear.z;\n        tNear.z = tFar.z;\n        tFar.z = tmp;\n    }\n    t0 = max(tNear.z, t0);\n    t1 = min(tFar.z, t1);\n\n    if (t0 <= t1) {\n        hit0 = t0;\n        hit1 = t1;\n        return true;\n    }\n    return false;\n}\n\n\nvec3 calcColor(float time, vec3 eye, vec3 ray){\n  \tvec3 l = BLACK;\n\n    float t = 999999.;\n    vec3 intersection, normal;\n    int objId = -1;\n    float t0, t1;\n    bool hitPlane = false;\n    \n    bool hitBox = intersectBox(eye, ray, \n                               vec3(-700, 0, -800), \n                               vec3(700, 900, 500),\n                               t0, t1);\n    if(hitBox){\n        objId = march(eye, ray, time, t0, t1,\n                      intersection, normal);\n    }\n    if(objId < 1){\n        hitPlane = intersectPlane(vec3(0, -100, 0), \n                                  vec3(0, 1, 0), \n                                  eye, ray, t,\n                       intersection, normal);\n        if(hitPlane) objId = OBJ_PLANE;\n    } else {\n        t = t0;\n    }\n    if(objId != -1){\n        vec3 matColor = BLACK;\n        matColor = getMatColor(objId, normal, intersection);\n        float k = computeShadowFactor(intersection + normal, LIGHT_DIR,\n                                      0., 1000., 5.);\n        vec3 diffuse =  clamp(dot(normal, LIGHT_DIR), 0., 1.) * matColor;\n        vec3 ambient = matColor * AMBIENT_FACTOR;\n        l += k * diffuse + ambient;\n    } else {\n        l = sky(ray);\n    }\n\n    l = mix( sky(ray), l, exp( -0.000000009*t * t ) );\n\n  \treturn l;\n}\n\n\nconst vec3 target = vec3(0, 300, 0);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nconst float SAMPLE_NUM = 5.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 eye = vec3(900. * sin(iTime) , 1000., \n                    900. * cos(iTime) );\n  \tvec3 sum = vec3(0);\n    float t = iTime;\n  \tfor(float i = 0. ; i < SAMPLE_NUM ; i++){\n    \tvec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n          \n    \tvec3 ray = calcRay(eye, target, up, fov,\n        \t               iResolution.x, iResolution.y,\n            \t           gl_FragCoord.xy + coordOffset);\n          \n    \tsum += calcColor(t, eye, ray);\n  \t}\n \tvec3 col = (sum/SAMPLE_NUM);\n  \n    \n  \tfragColor = vec4(gammaCorrect(col), 1.);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttXRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 89, 130, 130, 411], [729, 729, 758, 758, 935], [937, 937, 960, 960, 1089], [1091, 1091, 1133, 1133, 1359], [1361, 1361, 1402, 1402, 1628], [1630, 1630, 1671, 1671, 1897], [1899, 1899, 1931, 1931, 1966], [1968, 1968, 2006, 2006, 2052], [2054, 2054, 2087, 2087, 2121], [2123, 2123, 2169, 2169, 2258], [2260, 2260, 2295, 2295, 2360], [2362, 2362, 2417, 2417, 2476], [2478, 2478, 2550, 2550, 2684], [2883, 2883, 2909, 2909, 3347], [3349, 3349, 3374, 3374, 3753], [3755, 3755, 3781, 3781, 4204], [4206, 4206, 4234, 4234, 4672], [4674, 4674, 4698, 4698, 5012], [5014, 5014, 5039, 5039, 5176], [5178, 5178, 5204, 5204, 5508], [5510, 5510, 5541, 5541, 5982], [5984, 5984, 6019, 6019, 6185], [6227, 6227, 6275, 6275, 6576], [6605, 6605, 6757, 6757, 7303], [7305, 7305, 7457, 7457, 7817], [7819, 7819, 7879, 7879, 8167], [8169, 8169, 8191, 8191, 8270], [8272, 8272, 8386, 8386, 8660], [8662, 8662, 8708, 8708, 8768], [8770, 8822, 9014, 9014, 9279], [9282, 9282, 9495, 9495, 9945], [9947, 9947, 10068, 10068, 10834], [10837, 10837, 10884, 10884, 12130], [12257, 12257, 12313, 12313, 12847]], "test": "untested"}
{"id": "slcXW8", "name": "Synthwave canyon", "author": "mrange", "description": "Synthwave landscape", "tags": ["planemarching"], "likes": 59, "viewed": 1757, "published": 3, "date": "1638993692", "time_retrieved": "2024-07-30T18:43:17.467727", "image_code": "// CC0 - Synthwave canyon\n#define RESOLUTION    iResolution\n#define TIME          iTime\n#define PI            3.141592654\n\n//#define CRT_EFFECT\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat planex(vec2 p, float w) {\n  return abs(p.y) - w;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 p) {\n  float a = dot (p, vec2 (127.1, 311.7));\n  return fract(sin(a)*43758.5453123);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n#ifdef CRT_EFFECT  \n  col *= 1.5*smoothstep(-2.0, 1.0, sin(0.5*PI*q.y*RESOLUTION.y));\n#endif  \n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\n// Value noise: https://iquilezles.org/articles/morenoise\nfloat vnoise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n    \n  vec2 u = f*f*(3.0-2.0*f);\n//  vec2 u = f;\n\n  float a = hash(i + vec2(0.0,0.0));\n  float b = hash(i + vec2(1.0,0.0));\n  float c = hash(i + vec2(0.0,1.0));\n  float d = hash(i + vec2(1.0,1.0));\n  \n  float m0 = mix(a, b, u.x);\n  float m1 = mix(c, d, u.x);\n  float m2 = mix(m0, m1, u.y);\n  \n  return m2;\n}\n\n// FBM: https://iquilezles.org/articles/fbm\nfloat fbm(vec2 p) {\n  const float aa = 0.35;\n  const float pp = 2.2-0.4;\n\n  float sum = 0.0;\n  float a   = 1.0;\n  \n  for (int i = 0; i < 3; ++i) {\n    sum += a*vnoise(p);\n    a *= aa;\n    p *= pp;\n  }\n  \n  return sum;\n}\n\nfloat height(vec2 p) {\n  return fbm(p)*smoothstep(0.0, 1.25+0.25*sin(0.5*p.y), abs(p.x))-0.35;\n}\n\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.05*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.5*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {\n  float h = hash(n);\n  float s = mix(0.05, 0.25, h);\n\n  vec3 hn;\n  vec2 p = (pp-off*2.0*vec3(1.0, 1.0, 0.0)).xy;\n\n  float he = height(vec2(p.x, pp.z));\n\n  float d = p.y-he;\n  float t = smoothstep(aa, -aa, d);\n\n  vec3 hsv = vec3(fract(0.7+0.125*sin(0.6*pp.z)), 0.5, smoothstep(aa, -aa, abs(d)-aa));\n  float g = exp(-90.*max(abs(d), 0.0));\n  hsv.z += g;\n  hsv.z += (he*he-pp.y-0.125)*0.5;\n  vec3 col = hsv2rgb(hsv);\n  \n  return vec4(col, tanh_approx(t+g));\n}\n\nfloat sun(vec2 p) {\n  const float ch = 0.0125;\n  vec2 sp = p;\n  vec2 cp = p;\n  mod1(cp.y, ch*6.0);\n  float d0 = circle(sp, 0.5);\n  float d1 = planex(cp, ch);\n  float d2 = p.y+ch*3.0;\n  float d = d0;\n  d = pmax(d, -max(d1, d2), ch*2.0);\n  return d;\n}\n\nfloat df(vec2 p) {\n  const vec2 off = vec2(0.0, -10.0+0.5);\n  const vec2 coff = vec2(0);\n  const float si = 5.0;\n  const float sc = 25.0;\n  float ds = sun(p/sc)*sc;\n  float d = ds;\n  return d;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float aa = 2.0/RESOLUTION.y;\n\n  vec2 p = rd.xy*2.0;\n  p.y -= 0.25;\n  vec3 sunCol = mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 1.0), clamp((0.85 - p.y)*0.75, 0.0, 1.0));\n  vec3 glareCol = sqrt(sunCol);\n  float ss = smoothstep(-1.05, 0.0, p.y);\n  vec3 glow = mix(vec3(1.0, 0.7, 0.6).zyx, glareCol, ss);\n \n  float s = 15.0;\n  float d = df(p*s)/s;\n  float db = abs(d) - 0.0025;\n \n  vec3 col = vec3(1.0, 0.0, 1.0)*0.125;\n  vec3 corona = 0.65*glow*exp(-2.5*d)*ss;\n  col += corona;\n  col = mix(col, sunCol*ss, smoothstep(-aa, aa, -d));\n  col = mix(col, glow*1.55, smoothstep(-aa, aa, -db));\n\n  return col;\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n//  float rdd = (2.0-1.0*tanh_approx(lp));  // Playing around with rdd can give interesting distortions\n  float rdd = 2.0;\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const float planeDist = 1.0-0.5;\n  const int furthest = 24;\n  const int fadeFrom = max(furthest-2, 0);\n\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.95;\n  bool cutOut = false;\n\n  // Steps from nearest to furthest plane and accumulates the color \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    vec3 pp = ro + rd*pd;\n    \n    if (pp.y < 1.25 && pd > 0.0 && acol.w < cutOff) {\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = smoothstep(planeDist*float(furthest), planeDist*float(fadeFrom), nz);\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.xyz = mix(skyCol, pcol.xyz, fadeIn);\n      pcol.w *= fadeOut;\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      acol.w = acol.w > cutOff ? 1.0 : acol.w;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm  = TIME*0.25;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p, q);\n  col *= smoothstep(0.0, 4.0, TIME);\n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcXW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 297, 319, 319, 465], [760, 820, 860, 860, 1019], [1021, 1081, 1121, 1121, 1163], [1165, 1251, 1290, 1290, 1415], [1417, 1417, 1448, 1448, 1473], [1475, 1475, 1506, 1506, 1532], [1534, 1617, 1656, 1656, 1741], [1743, 1831, 1870, 1870, 1899], [1901, 1961, 1989, 2055, 2131], [2133, 2193, 2215, 2215, 2263], [2265, 2325, 2345, 2345, 2427], [2429, 2512, 2548, 2548, 2876], [2878, 2936, 2958, 2958, 3308], [3310, 3354, 3373, 3373, 3573], [3575, 3575, 3597, 3597, 3671], [3673, 3673, 3695, 3695, 3828], [3830, 3830, 3853, 3853, 3928], [3930, 3930, 3954, 3954, 4031], [4033, 4033, 4101, 4101, 4558], [4560, 4560, 4579, 4579, 4809], [4811, 4811, 4829, 4829, 5005], [5007, 5007, 5040, 5040, 5640], [5642, 5642, 5698, 5698, 7327], [7329, 7329, 7358, 7358, 7659], [7661, 7661, 7716, 7716, 7957]], "test": "untested"}
{"id": "7t3SW8", "name": "Shuffle box", "author": "tdhooper", "description": "Just some more noodling with dispersion", "tags": ["refraction", "dispersion"], "likes": 177, "viewed": 3564, "published": 3, "date": "1638990293", "time_retrieved": "2024-07-30T18:43:18.448105", "image_code": "\n#if HW_PERFORMANCE==1\n    const float MAX_DISPERSE = 10.;\n    const float MAX_BOUNCE = 5.;\n#else\n    const float MAX_DISPERSE = 5.;\n    const float MAX_BOUNCE = 5.;\n#endif\n\n//#define ALTERNATIVE\n//#define ALTERNATIVE2\n\n\n\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n\n#define PI 3.14159265359\n\n#define saturate(x) clamp(x, 0., 1.)\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smax(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat fBox(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat sdLine( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n// Spectrum palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n//========================================================\n// Modelling\n//========================================================\n\n\nfloat time;\n\nfloat invertg;\n\nfloat sin3(vec3 v) {\n    return sin(v.x) * sin(v.y) * sin(v.z);\n}\n\nvec2 map(vec3 p) {\n\n    float scl = 1.3;\n    p /= scl;\n\n    pR(p.yz, .2 * PI);\n    pR(p.xz, -.25 * PI);\n    \n    float flr = p.y+.5;\n    \n    #ifdef ALTERNATIVE\n    p += sin(p * 08. + (time * vec3(-1,-1,-1) + vec3(0,.5,.75)) * PI * 2.) * .1;\n    #else \n    p += sin(p * 08. + time * vec3(1,3,2) * PI * 2. + vec3(0,.5,3)) * .1;\n    #endif\n    // p += sin(p * 07. + (time * vec3(-1,1,1) + vec3(0)) * PI * 2.) * .1;\n\n    vec3 p2 = p;\n    \n    p += sin3(p * 80.) * .0015;\n    \n    float b = length(p) - .66;\n    b = fBox(p, vec3(.5 - .01)) - .01;\n    \n    float d3 = 1e12;\n    float rr = .0025;\n    p2 = abs(p2);\n    p2 = vec3(vmin(p2.xz), p2.y, vmax(p2.xz));\n    d3 = min(d3, sdLine(p2.xzy - vec3(.5,.7,.5), .2, rr));\n    d3 = max(d3, -vmax(p*vec3(1,-1,-1)));\n\n    #ifdef ALTERNATIVE\n    float e = .1;\n    p.x += sin(p.x * 04. + (time * -1. + .0) * PI * 2.) * e;\n    p.z += sin(p.z * 04. + (time * -1. + sign(p.x) * .25 + .25) * PI * 2.) * e;\n    p.y += sin(p.y * 04. + (time * -1. + sign(p.z) * .25) * PI * 2.) * e;\n    #else\n    p += sin(p * 06. + time * vec3(-3,2,1) * PI * 2. * 1. + vec3(.1,.5,.6)) * .1;\n    #endif\n\n    b = smax(b, -vmin(abs(p)) + .0125, .01);\n\n    float d2 = b + .1;\n    \n    float d = max(b, -d2 + .01);\n    \n    d *= invertg;\n    \n    d2 = max(d2+.001, b);\n    \n    float id = 1.;\n    \n    if (d2 < d) \n    {\n        id = 3.;\n        d = d2;\n    }\n    \n    #ifndef ALTERNATIVE2\n    if (d3 < d) {\n        d = d3;\n        id = 4.;\n    }\n    #endif\n   \n    d *= scl;\n    return vec2(d, id);\n}\n\n//========================================================\n// Lighting\n//========================================================\n\nvec3 BGCOL = vec3(.86,.8,1);\n\nfloat intersectPlane(vec3 rOrigin, vec3 rayDir, vec3 origin, vec3 normal, vec3 up, out vec2 uv) {\n    float d = dot(normal, (origin - rOrigin)) / dot(rayDir, normal);\n  \tvec3 point = rOrigin + d * rayDir;\n\tvec3 tangent = cross(normal, up);\n\tvec3 bitangent = cross(normal, tangent);\n    point -= origin;\n    uv = vec2(dot(tangent, point), dot(bitangent, point));\n    return max(sign(d), 0.);\n}\n\nmat3 envOrientation;\n\nvec3 light(vec3 origin, vec3 rayDir) {\n    origin = -origin;\n    rayDir = -rayDir;\n\n    origin *= envOrientation;\n    rayDir *= envOrientation;\n\n    vec2 uv;\n    vec3 pos = vec3(-6);\n    float hit = intersectPlane(origin, rayDir, pos, normalize(pos), normalize(vec3(-1,1,0)), uv);\n    float l = smoothstep(.75, .0, fBox(uv, vec2(.5,2)) - 1.);\n    l *= smoothstep(6., 0., length(uv));\n\treturn vec3(l) * hit;\n}\n\nvec3 env(vec3 origin, vec3 rayDir) {    \n    origin = -(vec4(origin, 1)).xyz;\n    rayDir = -(vec4(rayDir, 0)).xyz;\n\n    origin *= envOrientation;\n    rayDir *= envOrientation;\n\n    float l = smoothstep(.0, 1.7, dot(rayDir, vec3(.5,-.3,1))) * .4;\n   \treturn vec3(l) * BGCOL;\n}\n\n\n//========================================================\n// Marching\n//========================================================\n\n#define ZERO (min(iFrame,0))\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal( in vec3 pos )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e).x;\n    }\n    return normalize(n);\n}\n\nstruct Hit {\n    vec2 res;\n    vec3 p;\n    float len;\n    float steps;\n};\n\nHit march(vec3 origin, vec3 rayDir, float invert, float maxDist, float understep) {\n    vec3 p;\n    float len = 0.;\n    float dist = 0.;\n    vec2 res = vec2(0.);\n    vec2 candidate = vec2(0.);\n    float steps = 0.;\n    invertg = invert;\n\n    for (float i = 0.; i < 800.; i++) {\n        len += dist * understep;\n        p = origin + len * rayDir;\n        candidate = map(p);\n        dist = candidate.x;\n        steps += 1.;\n        res = candidate;\n        if (dist < .00005) {\n            break;\n        }\n        if (len >= maxDist) {\n            len = maxDist;\n            res.y = 0.;\n            break;\n        }\n    }   \n\n    return Hit(res, p, len, steps);\n}\n\nmat3 sphericalMatrix(vec2 tp) {\n    float theta = tp.x;\n    float phi = tp.y;\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\n// Hex tiling, FabriceNeyret2\n// https://www.shadertoy.com/view/4dKXR3\nfloat hex(vec2 U) { \n    \n    U *= mat2(1,-1./1.73, 0,2./1.73) *5.;      // conversion to\n    vec3 g = vec3(U,1.-U.x-U.y), g2,           // hexagonal coordinates\n        id = floor(g);                         // cell id\n\n    g = fract(g);                              // diamond coords\n    if (length(g)>1.) g = 1.-g;                // barycentric coords\n    g2 = abs(2.*fract(g)-1.);                  // distance to borders\n    // length(g2)     = distance to center  \n    return length(1.-g2);\n\n}\n\n// http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 tonemap2(vec3 texColor) {\n    texColor /= 2.;\n   \ttexColor *= 16.;  // Hardcoded Exposure Adjustment\n   \tvec3 x = max(vec3(0),texColor-0.004);\n   \treturn (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef ALTERNATIVE\n    float duration = 4.;\n    #else\n    float duration = 8.;\n    #endif\n    time = mod(iTime / duration + .1, 1.);\n    //time= 0.;\n    \n    envOrientation = sphericalMatrix(((vec2(81.5, 119) / vec2(187)) * 2. - 1.) * 2.);\n\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    #ifdef ALTERNATIVE2\n    uv /= 3.;\n    #endif\n    \n    #ifdef ALTERNATIVE\n    float h = hex(uv.yx * 1.08 + time * vec2(.1,.172) * -2.);\n    #else\n    float h = hex(uv.yx * 1.08 + time * vec2(.1,.172) * 2.);\n    #endif\n    h -= .03;\n    h /= length(fwidth(uv * 10.));\n    h = 1. - saturate(h);\n\n    Hit hit, firstHit;\n    vec2 res;\n    vec3 p, rayDir, origin, sam, ref, raf, nor, camOrigin, camDir;\n    float invert, ior, offset, extinctionDist, maxDist, firstLen, bounceCount, wavelength;\n    \n    vec3 col = vec3(0);\n\n    vec3 bgCol = BGCOL * .08 * .5;\n    vec3 bgCol2 = bgCol * .3;\n    bgCol = mix(bgCol, bgCol2, h);\n\n    invert = 1.;\n    maxDist = 15.; \n    \n    float fl = 20.;\n    \n\tcamOrigin = vec3(0,0,9.5 * fl);\n   \tcamDir = normalize(vec3(uv * .168, -fl));\n\n\n    firstHit = march(camOrigin, camDir, invert, maxDist * fl, .6);\n    firstLen = firstHit.len;\n\n    float steps = 0.;\n    \n    for (float disperse = 0.; disperse < MAX_DISPERSE; disperse++) {\n        invert = 1.;\n    \tsam = vec3(0);\n\n        origin = camOrigin;\n        rayDir = camDir;\n\n        extinctionDist = 0.;\n        wavelength = disperse / MAX_DISPERSE;\n\t\tfloat rand = texture(iChannel0, (fragCoord + floor(iTime * 60.) * 10.) / iChannelResolution[0].xy).r;\n        wavelength += (rand * 2. - 1.) * (.5 / MAX_DISPERSE);\n        \n\t\tbounceCount = 0.;\n        vec3 nor;\n\n        for (float bounce = 0.; bounce < MAX_BOUNCE; bounce++) {\n\n            if (bounce == 0.) {\n                hit = firstHit;\n            } else {\n                hit = march(origin, rayDir, invert, 1.2, .6);\n            }\n            \n            steps += hit.steps;\n            \n            res = hit.res;\n            p = hit.p;\n            \n            if (invert < 0.) {\n\t            extinctionDist += hit.len;\n            }\n\n            // hit background\n            if ( res.y == 0.) {\n                break;\n            }\n            \n            if ( res.y == 4.) {\n                break;\n            }\n            \n            nor = normal(p);            \n            ref = reflect(rayDir, nor);\n            \n            if (res.y > 1.) {\n                break;\n            }\n\n            // shade\n            sam += light(p, ref) * .5;\n            sam += pow(max(1. - abs(dot(rayDir, nor)), 0.), 5.) * .1;\n            sam *= vec3(.85,.85,.98);\n\n\n            // refract\n            float ior = mix(1.2, 1.8, wavelength);\n            ior = invert < 0. ? ior : 1. / ior;\n            raf = refract(rayDir, nor, ior);\n            bool tif = raf == vec3(0); // total internal reflection\n            rayDir = tif ? ref : raf;\n            offset = .01 / abs(dot(rayDir, nor));\n            origin = p + offset * rayDir;\n            //invert = tif ? invert : invert * -1.;\n            invert *= -1.; // not correct but gives more interesting results\n\n            bounceCount = bounce;\n            \n        }\n        \n        if (res.y > 1.) {\n            sam = vec3(0);\n            sam += light(p, ref) * .5;\n            sam += pow(max(1. - abs(dot(rayDir, nor)), 0.), 5.) * .1;\n            sam *= vec3(.85,.85,.98);\n            vec3 cc = res.y == 2. ? vec3(1) : vec3(.033);\n            rayDir = refract(rayDir, nor, 1./1.3);\n            sam += env(p, rayDir) * cc;\n        }\n\n        if (bounceCount == 0.) {\n            // didn't bounce, so don't bother calculating dispersion\n            col += sam * MAX_DISPERSE;\n            break;\n        }\n        \n        if (res.y < 2.) {\n            sam += env(p, rayDir);\n        }\n\n        vec3 extinction = vec3(.5,.5,.5) * .0;\n        extinction = 1. / (1. + (extinction * extinctionDist));\t\n        col += sam * extinction * spectrum(-wavelength+.25);\n\t}\n    \n    col /= MAX_DISPERSE;\n\n    if (bounceCount == 0. && res.y == 0.) {\n        col = bgCol;\n    }\n\n    if (res.y == 4.) {\n        col = bgCol2;\n    }\n    \n    col = pow(col, vec3(1.19)) * 2.5;\n    \n    col = tonemap2(col);\n        \n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3SW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 338, 370, 370, 415], [417, 417, 456, 456, 548], [550, 550, 570, 570, 595], [597, 597, 617, 617, 642], [644, 644, 664, 664, 699], [701, 701, 721, 721, 756], [758, 758, 786, 786, 867], [869, 869, 897, 897, 978], [980, 980, 1022, 1022, 1081], [1148, 1148, 1216, 1216, 1259], [1261, 1261, 1285, 1285, 1383], [1548, 1548, 1568, 1568, 1613], [1615, 1615, 1633, 1633, 3126], [3289, 3289, 3386, 3386, 3681], [3705, 3705, 3743, 3743, 4113], [4115, 4115, 4151, 4151, 4390], [4554, 4600, 4628, 4628, 4831], [4908, 4908, 4991, 4991, 5571], [5573, 5573, 5604, 5604, 5862], [5864, 5864, 5914, 5914, 6057], [6059, 6130, 6149, 6149, 6628], [6630, 6692, 6722, 6722, 6889], [6891, 6891, 6948, 6948, 11189]], "test": "untested"}
{"id": "Nl3XD8", "name": "2.5D sphere 2", "author": "SnoopethDuckDuck", "description": "bit of a mess,\nbasically cut out 1 section of equation from here:\nhttps://math.stackexchange.com/questions/1353065/function-that-graphs-repeating-upper-halves-of-circles\n...then copy + paste + rotated a few times", "tags": ["e"], "likes": 16, "viewed": 382, "published": 3, "date": "1638984225", "time_retrieved": "2024-07-30T18:43:19.470372", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nvec2 rot(vec2 uv, float a) {\n    //float s = 2. + cos(a + iTime);\n    //mat2 m = mat2(thc(s,a), ths(s,a), -ths(s,a), thc(s,a));\n\n    mat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n    return m * uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv2 = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    float r = 0.3;\n    float s = 0.;\n    \n    // not consistently using this (given up on keeping things tidy)\n    float time = 0.3 * iTime;\n       \n    for (float i = 0.; i<20.; i++ ) {\n        float n = i / 8. * pi ;\n        vec2 uv = rot(uv2, i * 10. + iTime * (0.1 + i / 40.));\n        \n        //--\n        vec2 p = vec2(r * cos(iTime) * cos(4. * uv.y), 0.);\n\n        float k = 0.5 * thc(1., iTime) + 3.;\n   \n\n        float y = k * uv.y;\n    \n        float m = 0.08;\n        float se = smoothstep(-m, m, 1. - y) * smoothstep(-m, m, y + 1.);\n        //--\n        \n        \n        // circle equation\n        float a = mod(y + 1., 2.) - 1.;  \n        float b = pow(a, 2.);\n        float c = cos(n + time) * sqrt(1. - b);\n        float c2 = cos(pi + n + time) * sqrt(1. - b);\n\n        float d = abs(uv.x - 1./k * c);//abs(uv.x - 0.4 * cos(iTime) * cos(10. * uv.y));\n        float d2 = abs(uv.x - 1./k * c2);\n   \n       \n        float k2 = 0.4 + 0.4 * thc(2., 0.1 * i + 4. * uv.y + time);\n        \n        k2 = 0.4 + 4. * pow(cos(10. * i + uv.y - time), 11.);\n        k2 *= 0.2;//0.3 + 0.1 * cos(time + 10. * i);\n       \n        float s1 = smoothstep(-k2, k2,        \n        -d + 0.012 * (1. - 0.5 * thc(4., 20. * uv.y - 10. * n - 8. * time)) );\n        s1 -= smoothstep(-0.01,0.01, -d + 0.005 * (1. - 0.5 * thc(4., 20. * uv.y - 10. * n - 8. * time)) );\n        s1 *= 3. * s1 * s1 * se;\n          \n        float s2 = smoothstep(-k2, k2,        \n        -d2 + 0.012 * (1. - 0.5 * thc(4., 20. * uv.y - 10. *  n - 8. * time)));\n        s2 -= smoothstep(-0.01,0.01, -d2 + 0.005 * (1. - 0.5 * thc(4., 20. * uv.y - 10. *  n - 8. * time)));\n        s2 *= 3. * s2 * s2 * se; // 3. * s1 * s2 * se;\n        \n        s += (s1 + s2) * 0.5 * (1. + thc(4., i + 4. * time));\n    }\n    \n    s = clamp(s, 0., 1.);\n    vec3 col = vec3(s);\n    col += .25 * s * pal(2. * s + 0.1 * iTime, vec3(1.), vec3(1.), vec3(1.), 0.5 * vec3(0.,0.33,0.66));\n    col += vec3(0.025,0.,0.05);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3XD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 191, 191, 232], [234, 234, 261, 261, 302], [304, 304, 372, 372, 415], [417, 417, 437, 437, 512], [514, 514, 538, 538, 578], [580, 580, 608, 707, 781], [783, 783, 840, 840, 2918]], "test": "untested"}
{"id": "ft3XWH", "name": "eindacor_spacecubes", "author": "Eindacor_DS", "description": "Space cubes!", "tags": ["kaleidoscope"], "likes": 2, "viewed": 179, "published": 3, "date": "1638983768", "time_retrieved": "2024-07-30T18:43:20.500618", "image_code": "\n\n#define TWOPI 6.28318530718f\n#define PI 3.14159f\n#define AA 0.001f\n#define SIXTY_DEGREES 1.0471975512f\n#define RENDER_VERTICES false\n\n#define CYAN vec3(0., 1., 1.)\n#define MAGENTA vec3(1., 0., 1.)\n#define YELLOW vec3(1., 1., 0.)\n#define RED vec3(1., 0., 0.)\n#define GREEN vec3(0., 1., 0.)\n#define BLUE vec3(0., 0., 1.)\n#define ORANGE vec3(1., .75, .25)\n#define PINK vec3(1., .25, .75)\n#define WHITE vec3(1.)\n#define BLACK vec3(0.)\n\n#define u_TimeScaleModifier 0.1f\n#define u_HexRadius .15f\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n    float val = sin(dot(p, vec2(12.9898f, 78.233f))) * 43758.5453f;\n    return val - floor(val);\n}\n\nvec3 getRandomColor(float seed) {\n    seed = clamp(seed, 0., 1.);\n    float colorCount = 6.;\n    float colorIncrement = 1.f / colorCount;\n    float seedFloor = floor(seed / colorIncrement) * colorIncrement;\n    float lerpVal = smoothstep(seedFloor, seedFloor + colorIncrement, seed);\n\n    if (seed <= colorIncrement * 1.) {\n        return mix(RED, YELLOW, lerpVal);\n    } else if (seed <= colorIncrement * 2.) {\n        return mix(YELLOW, GREEN, lerpVal);\n    } else if (seed <= colorIncrement * 3.) {\n        return mix(GREEN, CYAN, lerpVal);\n    } else if (seed <= colorIncrement * 4.) {\n        return mix(CYAN, BLUE, lerpVal);\n    } else if (seed <= colorIncrement * 5.) {\n        return mix(BLUE, MAGENTA, lerpVal);\n    } else {\n        return mix(MAGENTA, vec3(1.), lerpVal);\n    }\n}\n\nstruct AspectRatioData {\n    mat2x2 scaleMatrix;\n    mat2x2 inverseScaleMatrix;\n    float aspectRatio;\n};\n\nAspectRatioData getAspectRatioData(vec2 uvSize) {\n    float aspectRatio = uvSize.x / uvSize.y;\n    AspectRatioData aspectRatioData;\n    aspectRatioData.aspectRatio = aspectRatio;\n    aspectRatioData.scaleMatrix = mat2x2(\n        aspectRatio, 0.f,\n        0.f, 1.f\n    );\n    \n    aspectRatioData.inverseScaleMatrix = mat2x2(\n        1.f / aspectRatio, 0.f,\n        0.f, 1.f\n    );\n\n    return aspectRatioData;\n}\n\nbool isHexCenter(vec2 pos, float hexXIncrement, float hexYIncrement) {\n    float columnIndex = round(pos.x / hexXIncrement);\n    float rowIndex = round(pos.y / hexYIncrement);\n    return int(round(mod(abs(columnIndex), 2.f))) == int(round(mod(abs(rowIndex), 2.f)));\n}\n\nfloat getOffsetAngle(vec2 first, vec2 second) {\n    vec2 offsetVec = second - first;\n    float angle = atan(offsetVec.y / offsetVec.x);\n    \n    \n    if (first.x < second.x) {\n        angle = TWOPI / 2.f + angle;\n    } else if (first.y > second.y) {\n        angle = TWOPI + angle;\n    }\n    \n    return angle;\n}\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nvec3 vec2Tovec3(vec2 vec) {\n    return vec3(vec.x, vec.y, 0.f);\n}\n\nstruct HexData {\n    float radialVal;\n    float distFromHexCenter; // float representing approximity to center compared to hex radius\n    vec2 hexCenter;\n    vec2[6] hexVertices;\n    float edgeCoefficient; // float representing approximity to center compared to hex edge\n    float radialLerp; // linear interpolation or radians between local triangle vertices\n    float sumDistCoefficient;\n};\n\nvec2 getHexCenter(vec2 aspectUV, \n                    vec2 leftBottom, \n                    vec2 leftTop, \n                    vec2 rightBottom, \n                    vec2 rightTop,\n                    float aspectHexGridXIncrement, \n                    float hexGridYIncrement,\n                    float aspectHexRadius) {\n    vec2 hexCenter = vec2(-1.f, -1.f); \n\n    if (isHexCenter(leftBottom, aspectHexGridXIncrement, hexGridYIncrement)) {\n        vec2 hexDiagRight = leftBottom + vec2(aspectHexRadius, 0.f);\n        vec2 hexDiagLeft = leftTop + vec2(aspectHexRadius / 2.f, 0.f);\n        vec2 sharedEdgeVector = normalize(vec2(hexDiagLeft - hexDiagRight));\n        vec2 sharedToRightTopVector = normalize(vec2(rightTop - hexDiagRight));\n        vec2 sharedToUVVector = normalize(vec2(aspectUV - hexDiagRight));\n\n        vec3 crossRightTop = cross(vec2Tovec3(sharedEdgeVector), \n                                    vec2Tovec3(sharedToRightTopVector));\n        vec3 crossUV = cross(vec2Tovec3(sharedEdgeVector), \n                                vec2Tovec3(sharedToUVVector));\n\n        hexCenter = (crossRightTop.z == crossUV.z) || \n            (crossRightTop.z < 0.f && crossUV.z < 0.f) || \n            (crossRightTop.z > 0.f && crossUV.z > 0.f) ? rightTop : leftBottom;\n    } else {\n        vec2 hexDiagRight = leftTop + vec2(aspectHexRadius, 0.f);\n        vec2 hexDiagLeft = rightBottom - vec2(aspectHexRadius, 0.f);\n        vec2 sharedEdgeVector = normalize(vec2(hexDiagRight - hexDiagLeft));\n        vec2 sharedToRightBottomVector = normalize(vec2(rightBottom - hexDiagLeft));\n        vec2 sharedToUVVector = normalize(vec2(aspectUV - hexDiagLeft));\n\n        vec3 crossRightBottom = cross(vec2Tovec3(sharedEdgeVector), \n                                        vec2Tovec3(sharedToRightBottomVector));\n        vec3 crossUV = cross(vec2Tovec3(sharedEdgeVector), \n                                vec2Tovec3(sharedToUVVector));\n\n        hexCenter = crossRightBottom.z == crossUV.z || \n            (crossRightBottom.z < 0.f && crossUV.z < 0.f) || \n            (crossRightBottom.z > 0.f && crossUV.z > 0.f) ? rightBottom : leftTop;\n    }\n\n    return hexCenter;\n}\n\nvec2[6] getHexVertices(vec2 hexCenter, float hexRadius) {\n    vec2[6] hexVertices;\n    \n    float rotationIncrement = TWOPI / 6.;\n    \n    vec2 firstVertex = vec2(hexRadius, 0.) * createRotationMatrix(rotationIncrement * 2.);\n    \n    for (int i=0; i<6; ++i) {\n        hexVertices[i] = firstVertex * createRotationMatrix(rotationIncrement * float(i)) + hexCenter;\n    }\n    \n    return hexVertices;\n}\n\nfloat getEdgeCoefficient(vec2 uv, vec2 hexCenter, float hexRadius, float radialVal) {\n    vec2 adjustedUv = uv - hexCenter;\n    float adjustmentRotation = mod(radialVal, TWOPI / 6.);\n    mat2x2 adjsutmentRotationMatrix = createRotationMatrix(adjustmentRotation);\n    adjustedUv = adjustedUv * adjsutmentRotationMatrix;\n    \n    float radialLerp = mod(radialVal, 1./6.) / (1./6.);\n    radialLerp = .5 - (radialLerp > .5 ? 1. - radialLerp : radialLerp);\n    float operativeAngle = radialLerp * TWOPI / 6.;\n    \n    float tangentDistance = cos(TWOPI / 12.) * hexRadius;\n    \n    float maxToEdge = tangentDistance / cos(operativeAngle);\n    return distance(uv, hexCenter) / maxToEdge;\n}\n\nfloat getRadialVal(vec2 hexCenter, vec2 p) {\n    float offsetAngle = getOffsetAngle(hexCenter, p);\n    offsetAngle = mod(TWOPI - offsetAngle + 5.f * TWOPI / 6.f, TWOPI);\n    return offsetAngle / TWOPI;\n}\n\nHexData getHexData(\n    vec2 uv, \n    float hexRadius, \n    float hexGridXIncrement,\n    float hexGridYIncrement) \n{\n    float aspectHexGridXIncrement = hexGridXIncrement;\n\n    float leftEdge = floor(uv.x / aspectHexGridXIncrement) * aspectHexGridXIncrement;\n    float rightEdge = leftEdge + aspectHexGridXIncrement;\n    float bottomEdge = floor(uv.y / hexGridYIncrement) * hexGridYIncrement;\n    float topEdge = bottomEdge + hexGridYIncrement;\n\n    \n    vec2 leftBottom = vec2(leftEdge, bottomEdge);\n    vec2 leftTop = vec2(leftEdge, topEdge);\n    vec2 rightTop = vec2(rightEdge, topEdge);\n    vec2 rightBottom = vec2(rightEdge, bottomEdge);\n\n    float aspectHexRadius = hexRadius;\n    vec2 hexCenter = getHexCenter(uv,\n                            leftBottom, \n                            leftTop, \n                            rightBottom, \n                            rightTop, \n                            aspectHexGridXIncrement, \n                            hexGridYIncrement,\n                            aspectHexRadius);\n\n    float offsetAngle = getOffsetAngle(hexCenter, uv);\n    // mulitplying by 5 rotates the uv so the default orientation (0 radians) is facing downward\n    offsetAngle = mod(TWOPI - offsetAngle + 5.f * TWOPI / 6.f, TWOPI);\n    \n    float distMin = 6. * u_HexRadius;\n    float distMax = 4. * u_HexRadius + 4. * cos(SIXTY_DEGREES / 2.) * u_HexRadius;\n    \n    HexData hexData;\n    hexData.radialVal = getRadialVal(hexCenter, uv);\n    hexData.hexCenter = hexCenter;\n    hexData.distFromHexCenter = distance(uv, hexCenter) / hexRadius;\n    hexData.hexVertices = getHexVertices(hexCenter, hexRadius);\n    hexData.edgeCoefficient = getEdgeCoefficient(uv, hexCenter, hexRadius, hexData.radialVal);\n    hexData.radialLerp = mod(hexData.radialVal, 1./6.) / (1./6.);\n     \n    float distTotal = 0.;\n    for (int i=0; i<6; ++i) {\n        distTotal += distance(uv, hexData.hexVertices[i]);\n    }\n    hexData.sumDistCoefficient = (distTotal - distMin) / (distMax - distMin);\n    \n    return hexData;\n}\n\nvec2 getRandomVector(float seed) {\n    vec2 outVec;\n    if (seed < .25) {\n        outVec = vec2(1., 1.);\n    } else if (seed < .5) {\n        outVec = vec2(-1., 1.);\n    } else if (seed < .75) {\n        outVec = vec2(1., -1.);\n    } else {\n        outVec = vec2(-1., -1.);\n    }\n    \n    return outVec;\n}\n\nfloat getHexVertexHash(vec2 hexVertex) {\n    return hash(vec2(floor(hexVertex.x * 100.), floor(hexVertex.y * 100.)));\n}\n\nfloat getAngleBetweenPoints(vec2 first, vec2 second) {\n    return atan(abs(second.y - first.y)/abs(second.x - first.x));\n}\n\nvec2 getAxisMixAndProximity(vec2 first, vec2 second, vec2 p) {\n    vec2 A = second - first;\n    vec2 B = p - first;\n    \n    float cosAngle = dot(A, B) / dot(length(A), length(B));\n\n    float targetLength = cosAngle * length(B);\n    float mixVal = targetLength / length(A);\n    \n    float shortRadius = u_HexRadius * sin(SIXTY_DEGREES);\n    \n    float deviation = 1. - (sin(acos(cosAngle)) * length(B) / shortRadius);\n    return vec2(mixVal, deviation);\n}\n\nfloat getHexLerp(vec2[6] hexVertices, vec2 hexCenter, vec2 uv) {\n    return 1.;   \n}\n\nfloat dotToNormal(float dotVal) {\n    return (dotVal + 1.) / 2.;\n}\n\nfloat getTriangleArea(vec2 first, vec2 second, vec2 third) {\n    return abs(.5 * (first.x * (second.y - third.y) + second.x * (third.y - first.y) + third.x * (first.y - second.y)));\n}\n\nvec3 getBarycentricValue(vec2 A, vec2 B, vec2 C, vec2 p) {\n    float totalArea = getTriangleArea(A, B, C);\n    float alpha = getTriangleArea(B, C, p) / totalArea;\n    float beta = getTriangleArea(A, C, p) / totalArea;\n    float gamma = getTriangleArea(A, B, p) / totalArea;\n\n    return vec3(alpha, beta, gamma);\n}\n\nfloat getHoldTransitionValue(float lower, float upper, float holdTime, float transitionTime, float time) {\n    float period = 2. * holdTime + 2. * transitionTime;\n    float halfPeriod = period / 2.;\n    float relativeTime = fract(time / halfPeriod);\n    float halfHoldTime = holdTime / 2.;\n    \n    float val = smoothstep(halfHoldTime, halfHoldTime + transitionTime, relativeTime * halfPeriod);\n    \n    if (int(time / halfPeriod) % 2 == 0) {\n        val = 1. - val;\n    }\n\n    return mix(lower, upper, val);\n}\n\nfloat biLerp(float f0, float f1, float f2, float f3, float lerpX, float lerpY) {\n    float upper = mix(f1, f2, lerpX);\n    float lower = mix(f0, f3, lerpX);\n    \n    return mix(lower, upper, lerpY);\n}\n\nfloat getModifiedDot(vec2 uv, vec2 p, float gridDimension, float pHash) {\n    return dot((uv - p) / gridDimension, getRandomVector(pHash));\n}\n\nfloat getPerlinValue(vec2 uv, float gridDimension) {\n    float xCoord = floor(uv.x / gridDimension) * gridDimension;\n    float yCoord = floor(uv.y / gridDimension) * gridDimension;\n    \n    float xIndex = floor(uv.x / gridDimension);\n    float yIndex = floor(uv.y / gridDimension);\n    \n    float p0Hash = hash(vec2(xIndex, yIndex));\n    float p1Hash = hash(vec2(xIndex, yIndex + 1.));\n    float p2Hash = hash(vec2(xIndex + 1., yIndex + 1.));\n    float p3Hash = hash(vec2(xIndex + 1., yIndex));\n    \n    vec2 p0 = vec2(xCoord, yCoord);\n    vec2 p1 = vec2(xCoord, yCoord + gridDimension);\n    vec2 p2 = vec2(xCoord + gridDimension, yCoord + gridDimension);\n    vec2 p3 = vec2(xCoord + gridDimension, yCoord);\n\n    float dot0 = getModifiedDot(uv, p0, gridDimension, p0Hash);\n    float dot1 = getModifiedDot(uv, p1, gridDimension, p1Hash);\n    float dot2 = getModifiedDot(uv, p2, gridDimension, p2Hash);\n    float dot3 = getModifiedDot(uv, p3, gridDimension, p3Hash);\n    \n    float xInterp = smoothstep(p0.x, p2.x, uv.x);\n    float yInterp = smoothstep(p0.y, p2.y, uv.y);\n    \n    return biLerp(dot0, dot1, dot2, dot3, xInterp, yInterp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    AspectRatioData aspectRatioData = getAspectRatioData(iResolution.xy);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * aspectRatioData.scaleMatrix;\n    uv += vec2(5., iTime * .075);\n    uv = uv * createRotationMatrix(TWOPI / 12.);\n    \n    vec2 parallaxUv = fragCoord/iResolution.xy * aspectRatioData.scaleMatrix + vec2(5., iTime * .01);\n    vec2 starUv = fragCoord/iResolution.xy * aspectRatioData.scaleMatrix + vec2(5., iTime * .01);\n    \n    float shortRadius = u_HexRadius * sin(SIXTY_DEGREES);\n\n    float hexGridXIncrement = 1.5f * u_HexRadius;\n    float hexGridYIncrement = shortRadius;\n    \n    HexData hexData = getHexData(\n        uv, \n        u_HexRadius, \n        hexGridXIncrement,\n        hexGridYIncrement);\n \n    vec3 averageColor = vec3((sin(iTime * .5 + hexData.distFromHexCenter) + 1.) / 2.);\n    for (int i=0; i<6; ++i) {\n        float vertexHash = getHexVertexHash(hexData.hexVertices[i]);\n        //averageColor += getRandomColor(vertexHash) / 6.;\n    }\n\n    float centerToEdgeCoeff = 1.6;\n    float centerToEdgeFactor = hexData.edgeCoefficient; // TODO change back to edgeCoeff to fix\n    float radialBlendCoeff = mix(.8, 1., hexData.edgeCoefficient);\n    \n    \n    vec3 color = vec3(0.);\n    \n    //color *= step(.01, starHash);\n    \n    for (int i=0; i<6; ++i) {\n        int firstIndex = i;\n        int secondIndex = (i + 1) % 6;\n        \n        vec2 firstVertex = hexData.hexVertices[firstIndex];\n        vec2 secondVertex = hexData.hexVertices[secondIndex];\n        \n        float firstHash = getHexVertexHash(hexData.hexVertices[firstIndex]);\n        float secondHash = getHexVertexHash(hexData.hexVertices[secondIndex]);\n        \n        vec3 firstColor =  getRandomColor(firstHash);\n        vec3 secondColor =  getRandomColor(secondHash);\n        \n        vec3 baryCoords = getBarycentricValue(firstVertex, secondVertex, hexData.hexCenter, uv);\n        if (baryCoords.x + baryCoords.y + baryCoords.z > 1.0001) {\n            continue;\n        }\n        \n        if (i == 0) {\n            //fragColor = vec4(1.);\n            //return;\n        }\n\n        float radialLerp = 1. - hexData.radialLerp;\n        vec3 combinedColor = mix(firstColor, secondColor, .5);\n        vec3 outColor;\n        if (radialLerp < .5) {\n            float localLerp = radialLerp / .5;\n            outColor = mix(firstColor, combinedColor, pow(localLerp, radialBlendCoeff));\n        } else {\n            float inverseLerp = (1. - radialLerp) / .5;\n            outColor = mix(secondColor, combinedColor, pow(inverseLerp, radialBlendCoeff));\n        }\n\n        color = mix(averageColor, outColor, pow(centerToEdgeFactor, centerToEdgeCoeff));\n        vec3 baryColor = baryCoords.x * firstColor + baryCoords.y * secondColor + baryCoords.z * averageColor;\n        break;\n    }\n\n    if (RENDER_VERTICES) {\n        for (int i=0; i<6; i++) {\n            vec2 hexVertex = hexData.hexVertices[i];\n\n            float distFromVert = distance(uv, hexVertex);\n            float vertexSize = .01;\n            if (distFromVert < vertexSize) {\n                float distVal = smoothstep(vertexSize, vertexSize - AA * 4., distFromVert);\n                color = mix(vec3(0.), vec3(getRandomColor(getHexVertexHash(hexVertex))), distVal);\n                fragColor = vec4(color, 1.);\n                return;\n            }   \n        }\n    }\n    \n    int hexColumnIndex = int(hexData.hexCenter.x / (u_HexRadius + shortRadius / 2.));\n    int hexRowIndex = int(hexData.hexCenter.y / (u_HexRadius * 2.));\n    hexColumnIndex += hexRowIndex % 2 == 0 ? 0 : 1;\n    \n    float offsetCoeff = getHoldTransitionValue(0., 1., 10., 3., iTime);\n    float offsetVal = mix(.0, 1., hexColumnIndex % 2 == 0 ? 1. - offsetCoeff : offsetCoeff);\n    float dropoff = .05 * (1. - offsetVal);\n    float edgeVal = smoothstep(offsetVal + AA, offsetVal - AA, hexData.edgeCoefficient);\n \n    vec3 outColor1 = color * vec3(1., .25, .25);\n    vec3 cubeColor = mix(1. - outColor1, outColor1, (sin(iTime * .086) + 1.) / 2.) * edgeVal;\n\n    int shadeIndex = int(mod(hexData.radialVal + .5, 1.) * 3.);\n    \n    float shadeValue;\n    switch(shadeIndex) {\n        case 0: shadeValue = 1.; break;\n        case 1: shadeValue = .75; break;\n        case 2: shadeValue = .5; break;\n        default: shadeValue = -1.; break;\n    }\n    \n    cubeColor *= shadeValue;\n    \n    float starGridDimension = .005;\n    vec2 starCoords = vec2(floor(parallaxUv.x / starGridDimension), floor(parallaxUv.y / starGridDimension));\n    vec2 starValVec = vec2(fract(parallaxUv.x / starGridDimension), fract(parallaxUv.y / starGridDimension));\n    vec2 starCoordCenter = starCoords + starValVec * starGridDimension;\n    float starHash = hash(starCoords);\n    float maxStarRadius = .5;\n    float starVariation = .35;\n    float starRadius = mix(maxStarRadius, maxStarRadius - starVariation, hash(vec2(starCoords.y, starCoords.x)));\n    float starVal = smoothstep(\n        starRadius, \n        starRadius - AA, \n        distance(starValVec, vec2(.5)));\n        \n    float starBrightness = mix(.2, .7, hash(vec2(starHash * 100., starHash - 10.))); \n    float starNoise = mix(.8, 1., (sin(iTime * 50. + hash(vec2(-starCoords.y, starCoords.x)) * 100.) + 1.) / 2.);\n\n    float starAppearance = 1. - step(.001, starHash);\n    vec3 starColor = vec3(starVal) * starAppearance;\n\n    starColor *= starNoise * starBrightness;\n    float perlinSize = .3;\n    vec3 perlinColor = vec3(getPerlinValue(starUv, perlinSize)) * vec3(0.1, 0., .05);\n    perlinColor += vec3(getPerlinValue(vec2(starUv.y, starUv.x), perlinSize)) * vec3(0.02, 0., .12);\n    \n    cubeColor = mix(mix(perlinColor, starColor, starAppearance), cubeColor, edgeVal);\n    \n    fragColor = vec4(cubeColor, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3XWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[493, 539, 559, 559, 658], [660, 660, 693, 693, 1449], [1558, 1558, 1607, 1607, 1969], [1971, 1971, 2041, 2041, 2238], [2240, 2240, 2287, 2287, 2551], [2553, 2553, 2598, 2598, 2702], [2704, 2704, 2731, 2731, 2769], [3165, 3165, 3487, 3487, 5325], [5729, 5729, 5814, 5814, 6411], [6413, 6413, 6457, 6457, 6616], [6618, 6618, 6734, 6734, 8635], [8637, 8637, 8671, 8671, 8940], [8942, 8942, 8982, 8982, 9061], [9063, 9063, 9117, 9117, 9185], [9187, 9187, 9249, 9249, 9642], [9730, 9730, 9763, 9763, 9796], [9798, 9798, 9858, 9858, 9981], [9983, 9983, 10041, 10041, 10296], [10298, 10298, 10404, 10404, 10808], [10810, 10810, 10890, 10890, 11010], [11012, 11012, 11085, 11085, 11153], [11155, 11155, 11207, 11207, 12292], [12294, 12294, 12351, 12351, 18044]], "test": "untested"}
{"id": "Nt3SD8", "name": "simple_fft_sound_visualizer", "author": "SimonOakey", "description": "simple fft reactive shader with pseudo bands - hi mid low - work in progress here :)", "tags": ["fft", "reactive", "bands"], "likes": 5, "viewed": 289, "published": 3, "date": "1638978753", "time_retrieved": "2024-07-30T18:43:21.265572", "image_code": "\nfloat hi_sum = 0.;\nfloat mid_sum = 0.;\nfloat low_sum = 0.;\n\n\nvec2 center = vec2(.5, .5);\nvec2 left = vec2(.25, .5);\nvec2 right = vec2(.75, .5);\nvec3 ringColor = vec3(0.);\nvec3 bgColor = vec3(1., 1., 1.);\n\nvec2 fixAspect(vec2 _vec) {\n  _vec -= .5;\n  _vec.x /= iResolution.y / iResolution.x;\n  _vec += .5;\n  return _vec;\n}\n\nfloat circleLight(vec2 _uv, vec2 _pos, float _radius) {\n  float dist = _radius / length(_pos - _uv);\n  return dist;\n}\n\nfloat ringLight(vec2 _uv, vec2 _pos, float _radius, float _strokeWidth) {\n  float dist = length(_pos - _uv);\n  float dist2 = _strokeWidth / length(dist - _radius);\n  return dist2;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n \n float low_sum = 0.;\n for(int i=0;i<20;i++){\n \n     low_sum += texelFetch( iChannel0, ivec2(i,0), 0 ).x; \n     \n }\n \n    low_sum /=20.;\n    \n    \n    mid_sum = 0.;\n for(int i=100;i<200;i++){\n \n    mid_sum += texelFetch( iChannel0, ivec2(i,0), 0 ).x; \n     \n }\n \n    mid_sum /=100.;\n    \n    \n        hi_sum = 0.;\n for(int i=250;i<450;i++){\n \n    hi_sum += texelFetch( iChannel0, ivec2(i,0), 0 ).x; \n     \n }\n \n    hi_sum /=200.;\n \n  \n   \n \n  uv = fixAspect(uv);\n  vec2 mpos = fixAspect(iMouse.xy);\n\n  float mask = 0.;\n  mask += ringLight(uv, left, 0.4, low_sum*.02);\n  mask += ringLight(uv, center, 0.4, mid_sum*.02);\n  mask += ringLight(uv, right, 0.4, hi_sum*.02);\n  \n\n \n  //mask = step(.5, mask);\n  mask = smoothstep(.48,.52,mask);\n\n  vec3 color = mix(bgColor, ringColor, mask);\n\n fragColor = vec4(color, 1.);\n \n   \n \n \n \n\n  \n}", "image_inputs": [{"id": 34, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3SD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[206, 206, 233, 233, 321], [323, 323, 378, 378, 440], [442, 442, 515, 515, 623], [629, 629, 686, 736, 1610]], "test": "untested"}
{"id": "sttSDn", "name": "2.5D \"sphere\"", "author": "SnoopethDuckDuck", "description": "equations aren't quite correct but distortion makes it look more sphere-like", "tags": ["e"], "likes": 39, "viewed": 662, "published": 3, "date": "1638976572", "time_retrieved": "2024-07-30T18:43:22.063440", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nconst float num = 32.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    float r = 0.35 + 0.13 * thc(3.5, 8. * length(uv) - 1.5 * iTime);\n    //float r = 0.35 + 0.13 * thc(3.5, iTime + 10. * h21(uv));\n    vec2 p;\n    float s = 0.;\n    for (float i = 0.; i < num; i++) {\n        p = vec2(r * sin(pi * i / num) * cos(i + iTime), -r + 2. * r * i / num);\n        vec2 uv2 = uv;\n\n        float d = 4. * length(uv2 - p);\n        float R = r * sin(pi * i / num);\n        float k = 0.1 + 0. * cos(10. * i + iTime) + 0.2 * R;\n        s += smoothstep(-k, k, 0.5 * R * (1. + sin(i + iTime))-d);\n        s += step(d, 0.4 * R * (1. + sin(i + iTime))) - step(d, 0.35 * R * (1. + sin(i + iTime)));\n        s *= 0.99 * (1. - 0.22 * length(uv));\n       // s += 0.28 * max(s,smoothstep(-0.2,0.5, 0.5 * R * (1. + sin(i + iTime))-d));\n    }\n    \n    vec3 col = vec3(s);\n    col = s * pal(s, vec3(1.), vec3(1.), vec3(1.), length(uv) + 0.35 * vec3(0.,0.33,0.66));\n    col += vec3(0.025,0.,0.05);\n   // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttSDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 232, 232, 275], [277, 277, 297, 297, 372], [398, 398, 455, 455, 1477]], "test": "untested"}
{"id": "NddGRS", "name": "Interpolated Pixelization Blur", "author": "stoman", "description": "Blur the right side of your webcam!", "tags": ["blur"], "likes": 2, "viewed": 335, "published": 3, "date": "1638974761", "time_retrieved": "2024-07-30T18:43:22.827397", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int blurSize = 50;\n    \n    if(fragCoord.x < iResolution.x/2.0) {\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    }\n    else {\n        vec3 col = vec3(0, 0, 0);\n        float totalDist = 0.0;\n        for(int x = 0; x <= 1; x++) {\n            for(int y = 0; y <= 1; y++) {\n                vec2 coordMod = fragCoord - mod(fragCoord, vec2(float(blurSize), float(blurSize)));\n                vec2 offset = vec2(float(x*blurSize), float(y*blurSize));\n                vec2 coord = coordMod + offset;\n                float dist = float(blurSize*blurSize) / abs(coord.x - fragCoord.x) / abs(coord.y - fragCoord.y);\n                totalDist += dist;\n                col += dist * texture(iChannel0, coord/iResolution.xy).xyz;\n            }\n        }\n\n        fragColor = vec4(col / totalDist, 1.0);\n    }\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddGRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 882]], "test": "untested"}
{"id": "7dtXRj", "name": "PCG Beer Bottles", "author": "Pelegefen", "description": "10,000 bowls of oatmeal? \nhow about some proccesed oats instead?\n\nA Procedurally generated assortment of beer bottles.\nYou can change the defines in the Image buffer to change amount of bottles and the seed.", "tags": ["procedural", "3d", "raymarching", "sdf", "wip", "beer", "bottle"], "likes": 5, "viewed": 229, "published": 3, "date": "1638970075", "time_retrieved": "2024-07-30T18:43:23.662165", "image_code": "#define MAX_STEPS 100.\n#define MAX_DIST 40.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\n#define NUM_BOTTLES 3.\n#define NUM_ROWS 3.\n\n\n\n\nconst float seed = 22155.;\n\n\n\nfloat GetDist(vec3 p) {\n p.x -= NUM_BOTTLES * .5;\n p.y += NUM_ROWS * .5;\n    \n    float d  = 1.;\n    \n    //float sdBeerBottle(vec3 p, float width, float highet, float neckS, float lip, float labelS){\n  \n    \n    float NumBottles = NUM_BOTTLES * .75;\n    float NumRows = NUM_ROWS * .75;\n        \n    for(float x = 0.;x < NumRows; x+= .75){\n        \n     // d = min(d,sdBox(p - vec3(-15.5,-2.8,0), vec3(18.,2.,2.5)));\n\n        for(float i = 0.;i < NumBottles; i+= .75){\n    \n              float t = floor(iTime*.8 + seed);\n            float h = hash11(t + i + x);\n                float h1 = hash11(t     +214312./*salt*/ + i + x);\n            float h2 = hash11(floor(t   +2142.  /*salt*/ + i + x));\n            float h3 = hash11(floor(t   +12431. /*salt*/ + i + x));\n            float h4 = hash11(floor(t   +21334. /*salt*/ + i + x));\n\n\n\n            d = min(d, sdBeerBottle(p + vec3(3. * i,-3. * x,3.*x),\n\n            h * .15 ,\n            //^ float width,\n\n            h1* .5,\n            //^ float highet,\n\n            h2,\n            //^ float neckS,\n\n            h3* .8,\n            //^ float lip,\n\n            h4 *2.-1.\n            //^ float labelSh, \n\n            ))\n            ;\n    \n    \n        }\n    }\n\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\t\n    float dv =0.;\n    float dO=dv;\n    \n    \n    for(float i=0.; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n \n        dO += dS;\n        \n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    dv = dO;\n    return dv;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(-5, 2, -5);\n      //  ro +=  vec3(5.,0.,0.);\n\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(uv, ro , vec3(0,1.0,0), 1.);\n    vec3 col = texture(iChannel0,rd).rgb;\n    //vec3 col = vec3(0);\n    float d = RayMarch(ro, rd);\n    float glow = d * .005;\n    \n    \n\n    const float reflectV = .1;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd , n);\n            vec3 blending = getTriPlanarBlend(n);\n\n        \n        vec4 texRef = texture(iChannel0,r);\n\n      //  r *= tex.rgb;\n      \n      float scale = 0.1;\n      float t = floor(iTime*.8 + seed);\n              \n      vec2 off = vec2(t,-t);\n        vec3 texX = texture(iChannel1  ,p.yz- off *scale).rgb;\n        vec3 texY = texture(iChannel1  ,p.xz- off *scale).rgb;\n        vec3 texZ = texture(iChannel1  ,p.xy- off *scale).rgb;\n\n        vec3 normalTex = texX * blending.x + texY * blending.y + texZ * blending.z;\n        \n        \n\n        vec3 T = vec3(0.3,1.,0.);\n        vec3 BT = normalize( cross( n, T ) * 1.0 );\n\n        mat3 tsb = mat3( normalize( T ), normalize( BT ), normalize( n ) );\n        vec3 N = tsb * normalTex.rgb;\n        \n\n\n        float dif = dot(max(N.rgb,.3),n);\n        \n        \n        \n        \n        col = min(col , vec3(dif*.2,dif*.7   ,dif*.2));\n        col += min(texRef.rgb ,dif) * .4;//add reflections\n      \n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nvec3 getTriPlanarBlend(vec3 _wNorm){\n\t// in wNorm is the world-space normal of the fragment\n\tvec3 blending = abs( _wNorm );\n\tblending = normalize(max(blending, 0.00001)); // Force weights to sum to 1.0\n\tfloat b = (blending.x + blending.y + blending.z);\n\tblending /= vec3(b, b, b);\n\treturn blending;\n}\n\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n\nfloat Union( float d1, float d2 ) { return min(d1,d2); }\n\nfloat Sub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat Intrs( float d1, float d2 ) { return max(d1,d2); }\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat sdSphere(vec3 p, float s) {\n\n\treturn length(p ) - s;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\n\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdBeerBottle(vec3 p, float width, float highet, float neckS, float lip, float labelS){\n  float d  = 0.;\n  float label = smoothstep(neckS - labelS,.14+ labelS,p.y)*(labelS * .125);\n\n  float body = sdRoundedCylinder(p, .35 + width- label,.8,0.7 + highet);\n    \n\n\n    float neck = sdRoundedCylinder(p - vec3(0,1.0 + highet,0),.25+ width - label  ,.32,1.4+ highet);\n    neck += p.y * .1;\n    \n    float nb = body+neck;\n   \n    \n    \n    float mp = sdRoundedCylinder(p - vec3(0,2.35+ highet,0),.14+ width - label ,.04,0.08)*.8; //mouthpiece\n    float mph = sdRoundedCylinder(p - vec3(0,2.35+ highet,0),.12+ width- label,.1,2.38) * .8; //mouthpiece hole\n    mp -= abs(p.y - (2.4+ highet)) *.2 ;//shaping the mouthpiece\n    d = min(nb , min(neck,mp));\n    d = max(d,-p.y - .7);\n    \n    \n    \n    float elp = sdEllipsoid(p - vec3(0,-.7,0)  ,vec3(.5 + width,.1,.5 + width));\n    \n  \n    d = Sub (elp,d);\n\n    d = Sub(mph,d) ;\n\n    \n    d *= .9;\n    return d;\n   \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtXRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 206, 206, 1411], [1413, 1413, 1447, 1447, 1713], [1715, 1715, 1739, 1739, 1929], [1931, 1931, 1981, 1981, 2172], [2174, 2174, 2231, 2231, 3845]], "test": "untested"}
{"id": "fltSWn", "name": "Kleurstaal", "author": "davidar", "description": "Animation of a piece from Bram Vanhaeren's Kleurstaal series:\n\n[url]https://www.behance.net/gallery/53570349/Kleurstaal[/url]", "tags": ["color", "palette", "colour", "geometric"], "likes": 14, "viewed": 313, "published": 3, "date": "1638959800", "time_retrieved": "2024-07-30T18:43:24.515882", "image_code": "#define rgb(r,g,b) pow(vec3(r,g,b) / 255., vec3(2.2));\n#define mx(a,b,v) mix(a, b, smoothstep(-texel, texel, v))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float texel = 1. / iResolution.y;\n    vec2 uv = fragCoord / iResolution.y;\n    uv.x -= (iResolution.x / iResolution.y - 1.) / 2.;\n    \n    vec3 pink = rgb(255, 147, 249);\n    vec3 purple = rgb(32, 16, 63);\n    vec3 red = rgb(249, 14, 29);\n    vec3 skyblue = rgb(184, 229, 250);\n    vec3 deepblue = rgb(49, 108, 244);\n    vec3 white = rgb(240, 238, 249);\n    \n    float r1 = 0.2 + 0.02 * cos(iTime);\n    float r2 = 0.3 + 0.03 * cos(1.2 * iTime + 1.);\n    float r3 = 0.18 + 0.02 * cos(1.2 * iTime + 2.);\n    float r4 = 0.15 + 0.01 * cos(3. * iTime);\n    \n    float t1 = 1. + 0.1 * cos(0.5 * iTime);\n    float t2 = 0.6 + 0.05 * cos(0.3 * iTime);\n    float t3 = -0.6 + 0.05 * cos(0.2 * iTime + 1.);\n    float t4 = 0. + 0.1 * cos(0.6 * iTime + 2.);\n\n    vec3 col = mx(\n        mx(\n            mx(\n                mx(white, skyblue, length(uv - vec2(0.75,0.25)) - r1),\n                mx(\n                    mx(purple, deepblue, length(uv - vec2(0.75,0.25)) - r1),\n                    mx(white, purple, length(uv - vec2(0.75,0.25)) - r1),\n                    length(uv - 0.5) - r2),\n                uv.y - uv.x - t3),\n            mx(\n                mx(\n                    mx(purple, red, length(uv - 0.5) - r3),\n                    skyblue,\n                    length(uv - 0.5) - r2),\n                mx(purple, deepblue, length(uv - vec2(0,1)) - r4),\n                uv.y - uv.x - t2),\n            uv.y - uv.x - t4),\n        mx(\n            mx(\n                mx(red, white, length(uv - vec2(0.75,0.25)) - r1),\n                mx(pink, purple, length(uv - vec2(0.75,0.25)) - r1),\n                length(uv - 0.5) - r2),\n            mx(\n                mx(\n                    mx(skyblue, purple, length(uv - 0.5) - r3),\n                    pink,\n                    length(uv - 0.5) - r2),\n                mx(red, skyblue, length(uv - vec2(0,1)) - r4),\n                uv.y - uv.x - t2),\n            uv.y - uv.x - t4),\n        uv.x + uv.y - t1);\n\n    fragColor = vec4(pow(col, vec3(1./2.2)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fltSWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 171, 171, 2172]], "test": "untested"}
{"id": "7l3SDn", "name": "Tron's over, go home!", "author": "toomuchvoltage", "description": "Inspired by: https://www.shadertoy.com/view/Ns3XWf <-- When I saw this for the first time I felt intimidated. After thinking about it a bit, decided to replicate it myself without using SDFs.", "tags": ["raymarching", "field", "twisting", "scalar"], "likes": 18, "viewed": 391, "published": 3, "date": "1638945001", "time_retrieved": "2024-07-30T18:43:25.316741", "image_code": "/***********************************************************\n\n   Tron's over, go home!\n   Inspired by: https://www.shadertoy.com/view/Ns3XWf\n\n   When I saw it for the first time I felt intimidated.\n   I was like: Woah! how do you distort SDFs so much without breaking the field?\n   Then I realized that there's a decent degree of field correction there.\n   Then I decided to try and replicate it without really studying the code.... aaaand here we are.\n   I realized it's probably a lot easier to heavily twist a scalar field without ending up in an infinite marching loop...\n   ... unlike what you get with distance fields.\n   I use that same approach here and it gives me pretty good normals: https://www.shadertoy.com/view/3s33Rn\n   It's a lot harder here to get good normals as discontinuities are severe.\n   However, if you do smoothen out the field, good normals are totally possible.\n\n   Covered under the MIT license:\n\n   Copyright (c) 2021 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n#define FXAA_SPAN_MAX 8.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/4.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 rcpFrame = vec2 (1.0/iResolution.x, 1.0/iResolution.y);\n    vec3 rgbNW = texture(iChannel0, uv).xyz;\n    vec3 rgbNE = texture(iChannel0, uv + vec2(1,0)*rcpFrame.xy).xyz;\n    vec3 rgbSW = texture(iChannel0, uv + vec2(0,1)*rcpFrame.xy).xyz;\n    vec3 rgbSE = texture(iChannel0, uv + vec2(1,1)*rcpFrame.xy).xyz;\n    vec3 rgbM  = texture(iChannel0, uv.xy).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        texture(iChannel0, uv + dir * (1.0/3.0 - 0.5)).xyz +\n        texture(iChannel0, uv + dir * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        texture(iChannel0, uv + dir * (0.0/3.0 - 0.5)).xyz +\n        texture(iChannel0, uv + dir * (3.0/3.0 - 0.5)).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) fragColor = vec4 (rgbA, 1.0);\n    \n    fragColor = vec4 (rgbB, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/***********************************************************\n\n   Tron's over, go home!\n   Inspired by: https://www.shadertoy.com/view/Ns3XWf\n\n   When I saw it for the first time I felt intimidated.\n   I was like: Woah! how do you distort SDFs so much without breaking the field?\n   Then I realized that there's a decent degree of field correction there.\n   Then I decided to try and replicate it without really studying the code.... aaaand here we are.\n   I realized it's probably a lot easier to heavily twist a scalar field without ending up in an infinite marching loop...\n   ... unlike what you get with distance fields.\n   I use that same approach here and it gives me pretty good normals: https://www.shadertoy.com/view/3s33Rn\n   It's a lot harder here to get good normals as discontinuities are severe.\n   However, if you do smoothen out the field, good normals are totally possible.\n\n   Covered under the MIT license:\n\n   Copyright (c) 2021 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n#define MAX_STEPS 2500\n#define MAX_DIST 500.0\n#define M_PI 3.1415926535\n#define ROT_AMT (M_PI*0.1)\n#define GUIDE_W 0.13\n#define GUIDE_WH (GUIDE_W*0.5)\n\nconst mat2 rotABit = mat2(cos(ROT_AMT), -sin(ROT_AMT), sin(ROT_AMT), cos(ROT_AMT));\n\nfloat scene(vec3 pos, float inpTime, out float wireMux)\n{\n    wireMux = 0.0;\n    if ( pos.y < -0.05 ) return 0.0;\n    if ( pos.x > 2.0 ) pos.x = 2.0 - pos.x;\n    inpTime -= floor(pos.z + 1.0);\n    pos.z = mod(pos.z + 1.0, 2.0) - 1.0;\n    if ( inpTime < -2.0 )\n    {\n        if ( abs(pos.y) < 0.02 && abs(pos.z) < 1.0 )\n        {\n            wireMux = (fract(pos.x + GUIDE_WH) < GUIDE_W || fract(pos.z + GUIDE_WH) < GUIDE_W) ? 1.0 : 0.0;\n            return 1.0;\n        }\n        return 0.0;\n    }\n    \n    float elevation = abs(inpTime) * 0.1 + 0.2;\n    if ( pos.y > elevation * 2.0 ) return 0.0;\n    \n    float elevationSq = elevation * elevation;\n    vec3 gravityCenter = vec3 ((2.0 - inpTime * 2.0), elevation, 0.0);\n    int i = 0, j = 0;\n    float distTravelled = 0.0;\n    for (j = 0; j != int (inpTime * 15.0); j++)\n    {\n        vec2 posxyCached = pos.xy;\n        vec2 subLine = pos.xy - gravityCenter.xy;\n        if ( dot(subLine, subLine) > elevationSq )\n        {\n            if ( pos.x > gravityCenter.x ) return 0.0;\n            break;\n        }\n        pos.xy = gravityCenter.xy + rotABit * subLine;\n        pos.xy += (pos.xy - gravityCenter.xy) * 0.04;\n        distTravelled += length(posxyCached - pos.xy);\n    }\n    if ( abs(pos.y) < 0.02 && abs(pos.z) < 1.0 )\n    {\n        if ( j > 1 ) pos.x += distTravelled;\n        wireMux = (fract(pos.x + GUIDE_WH) < GUIDE_W || fract(pos.z + GUIDE_WH) < GUIDE_W) ? 1.0 : 0.0;\n        return 1.0;\n    }\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvDeNorm = fragCoord/iResolution.xy;\n    vec2 uv = uvDeNorm * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    float timeScaled = mod(iTime, 10.0) * 2.0;\n    \n    vec3 eyePos = vec3 (-4.0, 1.5, -7.0 + timeScaled);\n    vec3 look = normalize (vec3 (sin(iTime), 0.0, 1.0));\n    vec3 globalUp = vec3 (0.0, 1.0, 0.0);\n    vec3 side = normalize (cross (globalUp, look));\n    vec3 up = cross (look, side);\n    \n    vec3 traceDir = normalize (look + up * uv.y + side * uv.x);\n    vec3 tracePos = eyePos;\n    float outVal = 0.0;\n    float scaleTrace = 0.01;\n    float wireMux;\n    \n    for (int i = 0; i != MAX_STEPS; i++)\n    {\n        if ( scene (tracePos, timeScaled, wireMux) > 0.0 )\n        {\n            outVal = 3.0 / length(tracePos - eyePos);\n            vec3 outColor = pow (vec3 (0.25, outVal, 0.25) * wireMux, vec3 (1.0/2.2));\n            fragColor = vec4 (outColor, 1.0);\n            return ;\n        }\n        tracePos += traceDir * scaleTrace;\n        vec3 diffVec = tracePos - eyePos;\n        if ( dot (diffVec, diffVec) > MAX_DIST ) break;\n        if ( timeScaled - floor(tracePos.z + 1.0) < -2.0 ) scaleTrace *= 1.03;\n    }\n    \n    vec3 blue = vec3 (0.5, 0.5, 1.0);\n    vec3 purple = vec3 (1.0, 0.25, 1.0);\n    vec3 outColor = pow (mix (purple, blue, uvDeNorm.y), vec3(1.0/2.2));\n    fragColor = vec4 (outColor, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3SDn.jpg", "access": "api", "license": "mit", "functions": [[2425, 2425, 2482, 2482, 4238]], "test": "untested"}
{"id": "7tcSDn", "name": "Voronoi [Border Skipping]", "author": "Yusef28", "description": "In this version I am reducing the number of border intersection tests by approximately half for each step. I discard any borders created with cells that are outside a given angle from the ray direction since it can't hit those. \nit's like +20 fps! lol", "tags": ["2d", "voronoi", "commented", "borders", "edges", "comments", "traversal"], "likes": 13, "viewed": 351, "published": 3, "date": "1638937885", "time_retrieved": "2024-07-30T18:43:26.136549", "image_code": "/* \nThis Voronoi Shader is based on:\n\n1. An article by IQ: \n    https://iquilezles.org/articles/voronoilines\n2. Tomkh's method where you get borders based around uv\\\n    https://www.shadertoy.com/view/llG3zy\n3.Shane's Rounded border shader::\n    https://www.shadertoy.com/view/ll3GRM\n4. Tomkh, Abje and glk7 all have some sort of voronoi traversal\n   algorithm\n5. My first attempt at a voronoi traversal with comments\n   https://www.shadertoy.com/view/NltSRM\n=============================================================\n\nA new thing I thought of. We don't need to check 9 borders\n(I mean since that's how I've been doing it), because we know\nthe direction of the rd and we know that we check cells roughly at\nspecific angles on the cartesian grid based on the for i for j loop.\nso we can take the dot product of each id and the rd and if that\nangle is greater than 180 degrees we can skip the whole calculation\nincluding the intersection because the ray isn't moving in that\ndirection. \n\nMy only issue is that the border segments I am testing against\nare a set length and that leads to the rare case where a segment\ngets intersected with that shouldn't. Increasing the test angle \n(by reducing \"TEST_ANGLE\") from 0. to -0.1 or even -0.3 should get rid\nof this.\n\nSo the maximum gain is x2 since for every step we do only 4 intersections\ninstead of 8.\n\n*/\n\n\n#define pi acos(-1.)\n#define eps 8./iResolution.y\n\n#define maxPoints 16.\n#define screenSize 4.\n\n#define bg (0.5+0.5*sin(vec3(iTime,iTime*3.+403.,iTime*1.3+902.)))\n#define fg (0.5+0.5*sin(vec3(-iTime*2.1,-iTime*0.9+403.,-iTime+902.)))\n\n\n///////////////////////////////////////////////////////////////\n//\n// TEST_ANGLE is the angle between the rd and the id that\n// we check. So if rd is (1.,0.) and the current for loop id\n// is (-1.,0.) that border will be in close to the opposite\n// direction of the rd so we don't need to check for an intersection\n// with that border!\n//\n// 0. fails in only one spot as far as I could tell. \n// So anything more that 180 degrees\n// from the rd's direction doesn't need to be checked\n// 0.3 is max and you get some issues already there\n//\n////////////////////////////////////////////////////////////////\n\n//to be safe I went -0.1\n#define TEST_ANGLE -0.1\n\n//a method for finding the intersection between\n//two rays. Not effienct but very memorable.\nfloat seg_seg(vec2 ro1, vec2 rd1, vec2 A, vec2 B){\n    vec2 ro2 = A;\n    vec2 rd2 = normalize(B-A);\n    float maxABLange = length(B-A);\n    \n    vec2 perp = rd1.yx*vec2(-1.,1.);\n    float s = (dot(ro1,perp) - dot(ro2,perp))/dot(rd2,perp);\n    perp = rd2.yx*vec2(-1.,1.);\n    float t = (dot(ro2,perp) - dot(ro1,perp))/dot(rd1,perp);\n    return t >= 0. && s >= 0.? t : 100.;\n}\n\n\nvec2 rnd2(vec2 id){\n    return vec2(fract(sin(dot(id,vec2(14.27,74.97)))*54329.34),\n           fract(sin(dot(id+912.35,vec2(49.27,102.74)))*54329.34));\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin2(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\nfloat point(vec2 uv, float r){\n    return smoothstep(r+eps,r-eps,length(uv));\n}\n\nfloat ring(vec2 uv, float r){\n    return smoothstep(eps+0.03, 0., abs(length(uv)-r+0.03));\n}\n\nfloat line(vec2 P, vec2 A, vec2 B, float r){\n    vec2 PA = P-A;\n    vec2 AB = B-A;\n    float t = clamp(dot(PA,AB)/dot(AB,AB),0.,1.);\n    return smoothstep(r+eps,r-eps,length(PA-AB*t));\n   \n}\n\n/***************************************************\n\nHere is the actual voronoi traversal algorithm\n\n*************************************************** */\nfloat voronoiEdgeHit(vec2 uv, vec2 ro, vec2 rd, inout vec3 line_color){\n\n    vec2 st = fract(ro);\n    vec2 stFL = floor(ro);\n    vec2 d = vec2(10.);\n\n    vec2 pointA;\n    vec2 pointB;\n\n\n    float minT = 100.;\n    float t;\n\n    \n    //in this loop we are just looking for the closest point\n    //to the curent ro. It's a standard voronoi but instead of uv\n    //for every pixel we just have ro (the same value) being looked at\n    //every pixel (you wont see \"ro\" here because of what I did above.\n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime);\n        vec2 testA = stFL + coords;\n        float c = length(coords.xy - st);//max(abs(coords.x),abs(coords.y));\n        \n        if(c < d.x){\n            d.x = c;\n            d.y = (stFL+id).x*20.+(stFL+id).y;\n            pointA = testA;\n            \n            }\n        }\n    }    \n    \n    //In this loop I am finding every edge based on Iq's article\n    //meaning I get a new st an stFLoor based on pointA\n    //and find borders around pointA based on that.\n    \n    //so for each edge I check to see where it intersects \n    //with the ray based on ro and rd. We look at 25 edges\n    //around our pointA and the edge that we hit first (minimum t value)\n    //is what we hit so we return that t value and traverse that amount\n    //along the ray.\n    \n    //get a new st and stFL based on the point in this cell that\n    //we've found. This way we are garanteed that the edges will be \n    //the ones that fully enclose the cell!\n    st = fract(pointA);\n    stFL = floor(pointA+0.001);\n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        //and I almost forgot to normalize!!!\n        if(dot(normalize(vec2(i,j)),rd) > TEST_ANGLE){\n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime);\n        vec2 testB = stFL + coords;\n        \n        float distAB = length(testB-pointA);\n        if( distAB > 0.001 && distAB < 2.){\n            vec2 edgePoint =(pointA+testB)/2.;\n            vec2 perp = normalize(testB-pointA).yx*vec2(-1.,1.);\n            vec2 edgeSideA = edgePoint - perp*0.7;\n            vec2 edgeSideB = edgePoint + perp*0.7;\n            //Check where we intersect the current found edge\n            minT = min(minT, seg_seg(ro,rd,edgeSideA,edgeSideB));\n            line_color = mix(line_color,vec3(0.,0.9,1.),0.8*line(uv,edgeSideA,edgeSideB,0.05));\n            //faster version\n            //minT = min(minT, seg_seg_new(ro,rd,edgeSideA,edgeSideB));\n           }\n           \n       }\n      }\n    }\n    return minT;\n}\n\n\n\n\n//Basic Voronoi for coloring\nvec4 voronoi(vec2 uv){\n\n    vec2 st = fract(uv);\n    vec2 stFL = floor(uv);\n    vec2 d = vec2(10.);\n    vec2 A, B=vec2(100.);\n\n    vec2 mind;\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);//max(abs(coords.x),abs(coords.y));\n        \n        if(c < d.x){\n            d.x = c;\n            d.y = (stFL+id).x*20.+(stFL+id).y;\n            A = coords;\n\n            }\n        }\n    }\n    \n  \n    mind = d;\n    \n    d = vec2(10.);\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);//max(abs(coords.x),abs(coords.y));\n        \n        if(length(A-coords) > 0.00){\n            //d.x = c;\n            //d.y = rnd2(stFL+id).y;\n            B.x = smin2(B.x, dot( 0.5*(A+coords), \n                       normalize(coords-A) ), 0.06 );\n            }\n        }\n    }\n    B.y = B.x;\n    return vec4(mind,B);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    float globalScale = 4.;\n    uv*=globalScale ;\n\n    //get a voronoi for coloring cells an edges\n    vec4 voronoXY = voronoi(uv);\n    \n    //set basic color for all voronoi cells\n    vec3 col = 0.2+0.5*sin(vec3(1., 2., 3.)/1.2+ rnd2(voronoXY.yy).y*200.);\n    //col.zy *= rot(.1);\n\n    //add some color to the eddges of the voronoi\n    col = mix(col, vec3(0.), smoothstep(0.1,0.095,voronoXY.z));\n    col = mix(col, vec3(1.,0.4,0.), smoothstep(0.02,0.01,voronoXY.z));\n    col += smoothstep(0.05,0.03,voronoXY.z)*(0.5+0.5*sin(voronoXY.z*10.))/1.5;\n    col = col.xxx;\n   //define ro, rd, and set default rotation of rd\n   vec2 ro = vec2(0.,0.);\n   vec2 rd = vec2(1.,0.);\n   rd *= rot(iTime/2.);\n   \n   //adust mouse\n   vec2 m = (iMouse.xy*2.-iResolution.xy)/iResolution.y;\n   //rotate ray based on mouse if mouse press\n   if(iMouse.z > 0.5){rd = normalize(m.xy+ro);}\n   \n   //draw Ray\n   col = mix(col, vec3(1.,0.5,0.), line(uv, ro, ro + rd*30., 0.04));\n\n   //Draw RO\n   col = mix(col, vec3(.0,.4,.9),point(uv-ro,0.1));\n   \n   //t value for traversing\n   float t;\n   \n   /****************************************************\n\n                  THIS IS THE MAIN EVENT\n   \n   ****************************************************/\n   \n    \n    //we can do 40 x 8 seg-seg intersections without getting slow.\n    //I do 15 to be nice lol\n   for(float i = 0.; i < 15.; i++){\n       t = voronoiEdgeHit(uv,ro,rd,col);\n       ro += rd*t*1.001;\n       col = mix(col, vec3(1.0,.0,.0),point(uv-ro,0.1));\n       col = mix(col, vec3(1.0,.0,.0),\n           ring(uv-ro,0.24+sin(iTime*4.+i/10.)*0.07));\n   }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tcSDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2248, 2341, 2391, 2391, 2715], [2718, 2718, 2737, 2737, 2871], [2873, 2873, 2891, 2891, 2954], [2956, 2956, 2996, 2996, 3072], [3074, 3074, 3104, 3104, 3153], [3155, 3155, 3184, 3184, 3247], [3249, 3249, 3293, 3293, 3439], [3441, 3598, 3669, 3669, 6371], [6376, 6405, 6427, 6427, 7654], [7656, 7656, 7713, 7763, 9446]], "test": "untested"}
{"id": "fldSz7", "name": "", "author": "Program_Jin", "description": "Mind of Kim,TrueDragon", "tags": ["kim", "truedragon"], "likes": 3, "viewed": 219, "published": 3, "date": "1638934205", "time_retrieved": "2024-07-30T18:43:27.068058", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //  UV\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float Time = iTime*0.025f;\n    vec2 AnimUV1 = Time+uv.xy;\n    vec2 AnimUV2 = vec2(Time+(-uv.x), Time+uv.y);\n    \n    vec2 GetAnimUV1 = texture(iChannel0, AnimUV1).xy;\n    vec2 GetAnimUV2 = texture(iChannel0, AnimUV2).xy;\n    \n    vec2 FinalAnimUV = GetAnimUV1 + GetAnimUV2;\n    float NoiseRef = texture(iChannel0, FinalAnimUV).x;\n    \n    fragColor = mix(vec4(0.0f, 0.5f, 1.0f, 1.0f), vec4(1.0f, 1.0f, 1.0f, 0.3f), NoiseRef);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldSz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 77, 550]], "test": "untested"}
{"id": "7ltXR7", "name": "Voronoi (Borders Around Point A]", "author": "Yusef28", "description": "It seems in this case that IQ's voronoi edges method makes more sense than Tomkh's. If we want to find borders so we can find the nearest intersection, we actually need to find all the borders around pointA, NOT around the uv (or in this case the ro).", "tags": ["2d", "voronoi", "commented", "borders", "edges", "comments", "traversal"], "likes": 8, "viewed": 340, "published": 3, "date": "1638902881", "time_retrieved": "2024-07-30T18:43:28.090325", "image_code": "/* \nThis Voronoi Shader is based on:\n\n1. An article by IQ: \n    https://iquilezles.org/articles/voronoilines\n2. Tomkh's method where you get borders based around uv\\\n    https://www.shadertoy.com/view/llG3zy\n3.Shane's Rounded border shader::\n    https://www.shadertoy.com/view/ll3GRM\n4. Tomkh, Abje and glk7 all have some sort of voronoi traversal\n   algorithm\n\n=============================================================\n\nAn important discorvery I made, assuming I am understanding\ntomkh's and Iq's work is that actually:\n\nIt seems in this case that IQ's method makes \nmore sense than tomkh's. If we want to find borders \nso we can find the nearest intersection, we actually \nneed to find all the borders around pointA, NOT around \nthe uv (or in this case the ro).\n\nThis way we are garanteed that the edges will be \nthe ones that fully enclose the cell.\n    \nIf you check for borders around ro, you will get borders\nclose to ro for the 3x3 loop which may not find the borders\nin the direction ro+rd*t is even going. So you would then need \na 5x5 loop to do that which is super slow.\n\n==========================================================\n\nHere is a voronoi traversal algorithm I came up with.\nThere are a few hacks involved:\n\n1. When I check edges for a hit I actually check a 5x5 neighborhood\nbecause otherwise the way I do things there are times when not all\nthe correct edges are drawn.\n\n2. The weirdest thing. I find I can't use a constant value \n(such as ray origin) as an input to this algorithm. It has to \nbe moving even a little bit so I jitter with sin(iTime)*0.001\n\nNo idea why. A mouse position will work find and give me the edges, \nbut a set value like vec2(1.,0.) will not. \n\nEDIT: The jitter can be a constant value, we just need to \nbe a tiny bit off from pointA when we checkk pointB for some reason.\nso eps = 0.001 wo\n\n*/\n\n//I used this visual to create \"Border Skipping\"\n//where we don't check every border\n//https://www.shadertoy.com/view/7tcSDn\n\n#define pi acos(-1.)\n#define eps 8./iResolution.y\n\n#define maxPoints 16.\n#define screenSize 4.\n\n#define bg (0.5+0.5*sin(vec3(iTime,iTime*3.+403.,iTime*1.3+902.)))\n#define fg (0.5+0.5*sin(vec3(-iTime*2.1,-iTime*0.9+403.,-iTime+902.)))\n\nvec2 rnd2(vec2 id){\n    return vec2(fract(sin(dot(id,vec2(14.27,74.97)))*54329.34),\n           fract(sin(dot(id+912.35,vec2(49.27,102.74)))*54329.34));\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin2(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\nfloat point(vec2 uv, float r){\n    return smoothstep(r+eps,r-eps,length(uv));\n}\n\nfloat ring(vec2 uv, float r){\n    return smoothstep(eps+0.03, 0., abs(length(uv)-r+0.03));\n}\n\nfloat line(vec2 P, vec2 A, vec2 B, float r){\n    vec2 PA = P-A;\n    vec2 AB = B-A;\n    float t = clamp(dot(PA,AB)/dot(AB,AB),0.,1.);\n    return smoothstep(r+eps,r-eps,length(PA-AB*t));\n}\n\n/***************************************************\n\nHere is the actual voronoi border finding algorithm\nusing IQ's method of search for point Bs around PointA.\nThis is more effective in the case where you have a single\ncell that you want to find all the borders around.\n\nUsing just a given point in the cell (like a mouse position)\nwould lead to you finding all the borders closest to the \nmoust position. When we only look for 9 borders (3x3 double for loop)\nwe risk getting some of the wrong borders.\n\nWhen we instead check for borders around the \"pointA\"\nthat we found from the first voronoi loop, we get all the \ncorrect borders!\n\n*************************************************** */\n\n\nvec4 voronoiLine(vec2 uv, vec2 m, inout vec3 col){\n\n    vec2 st = fract(m);\n    vec2 stFL = floor(m);\n    vec2 d = vec2(10.);\n    vec2 pointA;\n    vec2 pointB;\n\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n            vec2 id = vec2(i,j);\n            vec2 rndShift = rnd2(stFL+id);\n            vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime);\n            vec2 testA = stFL + coords;\n            float c = length(coords.xy - st);\n            \n            if(c < d.x){\n                d.x = c;\n                pointA = testA;\n                \n                }\n             }\n          }\n    col = mix(col,vec3(1.,1.,0.),\n                      clamp( point(uv-pointA, 0.1), 0., 1.));\n                      \n    //we want to find the next point from pointA to get \n    //correct edges. Like in IQ's article\n    st = fract(pointA);\n    stFL = floor(pointA+sin(iTime)*0.001);\n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){   \n        \n            vec2 id = vec2(i,j);\n            vec2 rndShift = rnd2(stFL+id);\n            vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime);\n            vec2 testB = coords+stFL;\n            \n            //check edge\n            \n            if(length(testB-pointA) > 0.001){\n                vec2 edgePoint = (pointA+testB) / 2.;\n                \n                col = mix(col,vec3(0.,0.,1.),\n                      clamp( point(uv-edgePoint, 0.1), 0., 1.));\n                \n                vec2 perp = normalize(testB-pointA).yx*vec2(-1.,1.);\n                vec2 edgeSideA = edgePoint - perp;\n                vec2 edgeSideB = edgePoint + perp;\n                \n                col = mix(col, vec3(1.), \n                          line(uv, edgeSideA, edgeSideB, 0.04));\n            }\n        }\n    }\n    \n    return vec4(pointA, d);\n}\n\n///////////////////////////////////////////\n\n//Another voronoi function just for the cell the mouse is in...\n\n//////////////////////////////////////////\n\nvec2 voronoiMouseID(vec2 uv){\n\n    vec2 st = fract(uv);\n    vec2 stFL = floor(uv);\n    vec2 d = vec2(10.);\n    vec2 A, B=vec2(100.);\n    vec2 mind;\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) ;\n        vec2 testB = coords + stFL;\n        \n        float c = length(coords.xy- st);\n        if(c < d.x){\n            d.x = c;\n            d.y = (stFL+id).x*20.+(stFL+id).y;\n            A = coords;\n            \n            }\n        }\n    }\n\n    return vec2(d);\n}\n\n\n///////////////////////////////////////////\n\n//voronoi edge function just for coloring\n\n//////////////////////////////////////////\nvec4 voronoi(vec2 uv, inout vec2 pos){\n\n    vec2 st = fract(uv);\n    vec2 stFL = floor(uv);\n    vec2 d = vec2(10.);\n    vec2 A, B=vec2(100.);\n    pos = stFL;\n    vec2 mind;\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);\n        \n        if(c < d.x){\n            d.x = c;\n            d.y = (stFL+id).x*20.+(stFL+id).y;\n            A = coords;\n            pos = stFL+id;\n            }\n        }\n    }\n    \n  \n    mind = d;\n    \n    d = vec2(10.);\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);\n        \n        if(length(A-coords) > 0.00){\n            B.x = smin2(B.x, dot( 0.5*(A+coords), \n                       normalize(coords-A) ), 0.06 );\n            }\n        }\n    }\n    B.y = B.x;\n    return vec4(mind,0.5+0.5*sin(pow(B*100.,vec2(1./2.))));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    float globalScale = 4.;\n    uv*=globalScale ;\n    vec2 pos;\n    vec4 voronoXY = voronoi(uv,pos);\n    \n    \n    //====================START OF FANCY COLORING====================\n    vec3 light = vec3(1.,0.,2.);\n    vec3 ldir = normalize(vec3(0.)-light);\n    \n    vec3 light2 = vec3(2.,1.,1.);\n    vec3 ldir2 = normalize(vec3(0.)-light2);\n    vec3 col = 0.2+0.5*sin(vec3(1., 2., 3.)/1.2+ rnd2(voronoXY.yy).y*200.);\n    col.zy *= rot(.1);\n    col = mix(col, vec3(.9,0.6,0.0), smoothstep(0.3,.5,voronoXY.z)*0.3 );\n\n    vec3 n = vec3(\n                  voronoi(uv-vec2(eps,0.),pos).x-voronoi(uv+vec2(eps,0.),pos).x,\n                  voronoi(uv-vec2(eps,0.).yx,pos).x-voronoi(uv+vec2(eps,0.).yx,pos).x,\n                  voronoi(uv-vec2(eps,0.),pos).z\n                  -voronoi(uv+vec2(eps,0.).yy,pos).z\n \n                  );\n         n = normalize(n);\n         \n    float diff = max(dot(ldir,n),0.);\n    \n    float spec = pow( max(\n                 dot( reflect(-ldir,n),vec3(0.,0.,1.)),0.),5.);\n    col += diff*0.6+vec3(0.9,0.5,0.1)*spec;\n \n    float diff2 = max(dot(ldir,n),0.);\n    \n    float spec2 = pow( max(\n                 dot( reflect(-ldir2,n),vec3(0.,0.,1.)),0.),5.);\n    col += diff2*0.8+vec3(0.1,0.5,0.9)*spec2;\n    col = mix(col, vec3(0.), smoothstep(0.1,0.095,voronoXY.z));\n    col = mix(col, vec3(1.,0.4,0.)/2., smoothstep(0.02,0.01,voronoXY.z));\n    col += smoothstep(0.05,0.03,voronoXY.z)*(0.5+0.5*sin(voronoXY.z*10.))/1.5;\n    \n    //====================END OF FANCY COLORING====================\n    \n  \n    \n    vec2 m = (iMouse.xy*2.-iResolution.xy)/iResolution.y;\n    if(iMouse.z < 0.5){ m = vec2(0.);}\n    \n    \n    //call voronoi to get the mouse id. This could be\n    //probably done in one of the other voronoi calls\n    vec2 vMouse = voronoiMouseID(m*globalScale );\n    //color the cell black that the mouse is currently in \n    //if the mouse is pressed, otherwise it will be the (0.,0.) point.\n    if(vMouse.y==voronoXY.y)col = \n                vec3(0.,0.0,0.)\n                    *smoothstep(0.9,0.99,voronoXY.z);\n   \n                    \n                    \n                    \n   vec3 lines = vec3(0.);\n   //calling voronoiLine to color \"lines\".\n   //super messy code here and the return isn't used\n   vec4 not_used = voronoiLine(uv,m*globalScale,lines);\n\n    col /= 1.88;\n    //col = mix(col, vec3(1.,0.,0.), lines);\n    col = mix(col, vec3(1.), lines);\n    col= pow(col, vec3(1.4));\n   // col = tx0;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltXR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2211, 2211, 2230, 2230, 2364], [2366, 2366, 2384, 2384, 2447], [2449, 2449, 2489, 2489, 2565], [2567, 2567, 2597, 2597, 2646], [2648, 2648, 2677, 2677, 2740], [2742, 2742, 2786, 2786, 2928], [3624, 3624, 3674, 3674, 5482], [5638, 5638, 5667, 5667, 6278], [6369, 6412, 6450, 6450, 7624], [7626, 7626, 7683, 7733, 10263]], "test": "untested"}
{"id": "stdXz7", "name": "pmptos", "author": "lorenzowy", "description": "peiramatisms", "tags": ["threejs", "cineshader"], "likes": 23, "viewed": 5148, "published": 3, "date": "1638902399", "time_retrieved": "2024-07-30T18:43:29.036794", "image_code": "precision highp float;\n\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nconst float pi = acos(-1.0);\nconst float pi2 = pi*2.0;\n\nvec2 pmod(vec2 p, float r) {\n    float a = atan(p.x, p.y) + pi/r;\n    float n = pi2 / r;\n    float k = a * n;\n    a = floor(a/n)*n;\n    return p*rot(-a);\n}\n\nfloat box( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    // return d.z;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,-0.1));\n}\n\nfloat ifsBox(vec3 p) {\n    for (int i=1; i<3; i++) {\n        p = abs(p) - 1.0;\n        p.xy *= rot(iTime*0.3);\n        p.xz *= rot(iTime*0.1);\n    }\n    p.xz *= rot(iTime);\n    return box(p, vec3(0.4,0.8,0.3));\n}\n\nfloat map(vec3 p, vec3 cPos) {\n    vec3 p1 = p;\n    p1.x = mod(p1.x-5., 10.) - 5.;\n    p1.y = mod(p1.y-5., 10.) - 5.;\n    p1.z = mod(p1.z, 16.)-8.;\n    p1.xy = pmod(p1.xy, 5.0);\n    return ifsBox(p1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 cPos = vec3(0.0,0.0, -3.0 * iTime);\n    // vec3 cPos = vec3(0.3*sin(iTime*0.8), 0.4*cos(iTime*0.3), -6.0 * iTime);\n    vec3 cDir = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 cUp  = vec3(cos(iTime), 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir);\n\n    // Phantom Mode https://www.shadertoy.com/view/MtScWW by aiekick\n    float acc = 0.0;\n    float acc2 = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < 99; i++) {\n        vec3 pos = cPos + ray * t;\n        float dist = map(pos, cPos);\n        dist = max(abs(dist), 0.02);\n        float a = exp(-dist*3.0);\n        if (mod(length(pos)+24.0*iTime, 30.0) < 3.0) {\n            a *= 2.0;\n            acc2 += a;\n        }\n        acc += a;\n        t += dist * 0.5;\n    }\n\n    vec3 col = vec3(acc * 0.01, acc * 0.011 + acc2*0.01, acc * 0.012+ acc2*0.015);\n    fragColor = vec4(col, 1.0 - t * 0.3);\n}", "image_inputs": [{"id": 13, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdXz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 44, 44, 107], [165, 165, 193, 193, 320], [322, 322, 351, 351, 462], [464, 464, 486, 486, 676], [678, 678, 708, 708, 880], [882, 882, 939, 939, 1936]], "test": "untested"}
{"id": "NltSRM", "name": "Voronoi Traversal [comments]", "author": "Yusef28", "description": "It seems in this case that IQ's voronoit edges method makes more sense than Tomkh's. If we want to find borders so we can find the nearest intersection, we actually need to find all the borders around pointA, NOT around the uv (or in this case the ro).", "tags": ["2d", "voronoi", "commented", "borders", "edges", "comments", "traversal"], "likes": 12, "viewed": 440, "published": 3, "date": "1638902173", "time_retrieved": "2024-07-30T18:43:29.877547", "image_code": "/* \nThis Voronoi Shader is based on:\n\n1. An article by IQ: \n    https://iquilezles.org/articles/voronoilines\n2. Tomkh's method where you get borders based around uv\\\n    https://www.shadertoy.com/view/llG3zy\n3.Shane's Rounded border shader::\n    https://www.shadertoy.com/view/ll3GRM\n4. Tomkh, Abje and glk7 all have some sort of voronoi traversal\n   algorithm\n\n=============================================================\n\nAn important discorvery I made, assuming I am understanding\ntomkh's and Iq's work correctly is that actually:\n\nIQ's method makes more sense than tomkh's here. \nIf we want to find borders \nso we can find the nearest intersection, we actually \nneed to find all the borders around pointA, NOT around \nthe uv (or in this case the ro).\n\nThis way we are garanteed that the edges will be \nthe ones that fully enclose the cell.\n    \nIf you check for borders around ro, you will get borders\nclose to ro for the 3x3 loop which may not find the borders\nin the direction ro+rd*t is even going. So you would then need \na 5x5 loop to do that which is super slow.\n\n==========================================================\n\nHere is a voronoi traversal algorithm I came up with.\nThere are a few hacks involved:\n\n1. When I check edges for a hit I actually check a 5x5 neighborhood\nbecause otherwise the way I do things there are times when not all\nthe correct edges are drawn.\n\n2. The weirdest thing. I find I can't use a constant value \n(such as ray origin) as an input to this algorithm. It has to \nbe moving even a little bit so I jitter with sin(iTime)*0.001\n\nNo idea why. A mouse position will work find and give me the edges, \nbut a set value like vec2(1.,0.) will not. \n\nEDIT: The jitter can be a constant value, we just need to \nbe a tiny bit off from pointA when we checkk pointB for some reason.\n\n*/\n\n/*/////////////////////////////////////////\n\n                  UPDATE\n                  \n    I found a way to make voronoi traversal close to x2 faster!\n    https://www.shadertoy.com/view/7tcSDn\n        \n\n\n////////////////////////////////////////*/\n\n#define pi acos(-1.)\n#define eps 8./iResolution.y\n\n#define maxPoints 16.\n#define screenSize 4.\n\n#define bg (0.5+0.5*sin(vec3(iTime,iTime*3.+403.,iTime*1.3+902.)))\n#define fg (0.5+0.5*sin(vec3(-iTime*2.1,-iTime*0.9+403.,-iTime+902.)))\n\n//a method for finding the intersection between\n//two rays. Not effienct but very memorable.\nfloat seg_seg(vec2 ro1, vec2 rd1, vec2 A, vec2 B){\n    vec2 ro2 = A;\n    vec2 rd2 = normalize(B-A);\n    float maxABLange = length(B-A);\n    \n    vec2 perp = rd1.yx*vec2(-1.,1.);\n    float s = (dot(ro1,perp) - dot(ro2,perp))/dot(rd2,perp);\n    perp = rd2.yx*vec2(-1.,1.);\n    float t = (dot(ro2,perp) - dot(ro1,perp))/dot(rd1,perp);\n    return t >= 0. && s >= 0.? t : 100.;\n}\n\n\nvec2 rnd2(vec2 id){\n    return vec2(fract(sin(dot(id,vec2(14.27,74.97)))*54329.34),\n           fract(sin(dot(id+912.35,vec2(49.27,102.74)))*54329.34));\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin2(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\nfloat point(vec2 uv, float r){\n    return smoothstep(r+eps,r-eps,length(uv));\n}\n\nfloat ring(vec2 uv, float r){\n    return smoothstep(eps+0.03, 0., abs(length(uv)-r+0.03));\n}\n\nfloat line(vec2 P, vec2 A, vec2 B, float r){\n    vec2 PA = P-A;\n    vec2 AB = B-A;\n    float t = clamp(dot(PA,AB)/dot(AB,AB),0.,1.);\n    return smoothstep(r+eps,r-eps,length(PA-AB*t));\n   \n}\n\n/***************************************************\n\nHere is the actual voronoi traversal algorithm\n\n*************************************************** */\nfloat voronoiEdgeHit(vec2 uv, vec2 ro, vec2 rd){\n\n    vec2 st = fract(ro);\n    vec2 stFL = floor(ro);\n    vec2 d = vec2(10.);\n\n    vec2 pointA;\n    vec2 pointB;\n\n\n    float minT = 100.;\n    float t;\n\n    \n    //in this loop we are just looking for the closest point\n    //to the curent ro. It's a standard voronoi but instead of uv\n    //for every pixel we just have ro (the same value) being looked at\n    //every pixel (you wont see \"ro\" here because of what I did above.\n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime);\n        vec2 testA = stFL + coords;\n        float c = length(coords.xy - st);//max(abs(coords.x),abs(coords.y));\n        \n        if(c < d.x){\n            d.x = c;\n            d.y = (stFL+id).x*20.+(stFL+id).y;\n            pointA = testA;\n            \n            }\n        }\n    }    \n    \n    //In this loop I am finding every edge based on Iq's article\n    //meaning I get a new st an stFLoor based on pointA\n    //and find borders around pointA based on that.\n    \n    //so for each edge I check to see where it intersects \n    //with the ray based on ro and rd. We look at 25 edges\n    //around our pointA and the edge that we hit first (minimum t value)\n    //is what we hit so we return that t value and traverse that amount\n    //along the ray.\n    \n    //get a new st and stFL based on the point in this cell that\n    //we've found. This way we are garanteed that the edges will be \n    //the ones that fully enclose the cell!\n    st = fract(pointA);\n    stFL = floor(pointA+0.001);\n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime);\n        vec2 testB = stFL + coords;\n        \n        float distAB = length(testB-pointA);\n        if( distAB > 0.001 && distAB < 2.){\n            vec2 edgePoint =(pointA+testB)/2.;\n            vec2 perp = normalize(testB-pointA).yx*vec2(-1.,1.);\n            vec2 edgeSideA = edgePoint - perp;\n            vec2 edgeSideB = edgePoint + perp;\n          \n          \n          //Check where we intersect the current found edge\n          minT = min(minT, seg_seg(ro,rd,edgeSideA,edgeSideB));\n          //faster version\n          //minT = min(minT, seg_seg_new(ro,rd,edgeSideA,edgeSideB));\n         \n        }\n      }\n    }\n    return minT;\n}\n\n\n\n\n//Basic Voronoi for coloring\nvec4 voronoi(vec2 uv){\n\n    vec2 st = fract(uv);\n    vec2 stFL = floor(uv);\n    vec2 d = vec2(10.);\n    vec2 A, B=vec2(100.);\n\n    vec2 mind;\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);//max(abs(coords.x),abs(coords.y));\n        \n        if(c < d.x){\n            d.x = c;\n            d.y = (stFL+id).x*20.+(stFL+id).y;\n            A = coords;\n\n            }\n        }\n    }\n    \n  \n    mind = d;\n    \n    d = vec2(10.);\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);//max(abs(coords.x),abs(coords.y));\n        \n        if(length(A-coords) > 0.00){\n            //d.x = c;\n            //d.y = rnd2(stFL+id).y;\n            B.x = smin2(B.x, dot( 0.5*(A+coords), \n                       normalize(coords-A) ), 0.06 );\n            }\n        }\n    }\n    B.y = B.x;\n    return vec4(mind,B);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    float globalScale = 4.;\n    uv*=globalScale ;\n\n    //get a voronoi for coloring cells an edges\n    vec4 voronoXY = voronoi(uv);\n    \n    //set basic color for all voronoi cells\n    vec3 col = 0.2+0.5*sin(vec3(1., 2., 3.)/1.2+ rnd2(voronoXY.yy).y*200.);\n    //col.zy *= rot(.1);\n\n    //add some color to the eddges of the voronoi\n    col = mix(col, vec3(0.), smoothstep(0.1,0.095,voronoXY.z));\n    col = mix(col, vec3(1.,0.4,0.), smoothstep(0.02,0.01,voronoXY.z));\n    col += smoothstep(0.05,0.03,voronoXY.z)*(0.5+0.5*sin(voronoXY.z*10.))/1.5;\n    \n   //define ro, rd, and set default rotation of rd\n   vec2 ro = vec2(0.,0.);\n   vec2 rd = vec2(1.,0.);\n   rd *= rot(iTime/2.);\n   \n   //adust mouse\n   vec2 m = (iMouse.xy*2.-iResolution.xy)/iResolution.y;\n   //rotate ray based on mouse if mouse press\n   if(iMouse.z > 0.5){rd = normalize(m.xy+ro);}\n   \n   //draw Ray\n   col = mix(col, vec3(1.), line(uv, ro, ro + rd*30., 0.04));\n\n   //Draw RO\n   col = mix(col, vec3(.0,.4,.9),point(uv-ro,0.1));\n   \n   //t value for traversing\n   float t;\n   \n   /****************************************************\n\n                  THIS IS THE MAIN EVENT\n   \n   ****************************************************/\n   \n\n    //we can do 40 x 8 seg-seg intersections without getting slow.\n   for(float i = 0.; i < 15.; i++){\n       t = voronoiEdgeHit(uv,ro,rd);\n       ro += rd*t*1.001;\n       col = mix(col, vec3(1.0,.0,.0),point(uv-ro,0.1));\n       col = mix(col, vec3(1.0,.0,.0),\n           ring(uv-ro,0.24+sin(iTime*4.+i/10.)*0.07));\n   }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltSRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2305, 2398, 2448, 2448, 2772], [2775, 2775, 2794, 2794, 2928], [2930, 2930, 2948, 2948, 3011], [3013, 3013, 3053, 3053, 3129], [3131, 3131, 3161, 3161, 3210], [3212, 3212, 3241, 3241, 3304], [3306, 3306, 3350, 3350, 3496], [3498, 3655, 3703, 3703, 6200], [6205, 6234, 6256, 6256, 7483], [7485, 7485, 7542, 7592, 9217]], "test": "untested"}
{"id": "7ltSR7", "name": " -- twinkling star", "author": "IWBTShyGuy", "description": "In any case, I can never describe the beauty of the starry sky I saw that day.", "tags": ["2d", "fbm", "hash"], "likes": 9, "viewed": 1197, "published": 3, "date": "1638892574", "time_retrieved": "2024-07-30T18:43:31.158123", "image_code": "// Copyright  2021 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\nconst float STAR_INTERVAL = 1.0 / 15.0;\n\nconst vec3 MOUNTAIN = pow(vec3(0, 0, 0) / 255.0, vec3(2.2));\nconst vec3 BACK_GROUND = pow(vec3(0, 5, 58) / 255.0, vec3(2.2));\nconst vec3 STAR = pow(vec3(1, 1, 1), vec3(2.2));\n\nfloat fbm( in float x, in float H ) {\n    float G = exp2(-H), f = 1.0, a = 1.0, t = 0.0;\n    for(int i = 0; i < 5; i++) {\n        t += a*smoothnoise11(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\nfloat mountain(in vec2 uv) {\n    float f = uv.y - fbm(uv.x * 1.5 + 0.2 * iTime + 1.5, 0.0) / 8.0 + 0.15;\n    return clamp(f / 0.005, 0.0, 1.0);\n}\n\nfloat cellstar(in vec2 uv, in vec2 nbr) {\n    vec2 xy = uv + nbr;\n    float rand = noise13(vec3(floor(xy), 1));\n    if (rand < 0.7) return 0.0;\n    vec2 disp = (2.0 * noise22(floor(xy)) - 1.0) * 0.6;\n    vec2 r = fract(xy) + uv - xy - disp - 0.5;\n    float dist = length(r) * STAR_INTERVAL;\n    float c = clamp(0.0005 / dist, 0.0, 1.0);\n    float irr = noise13(vec3(floor(xy), -1));\n    irr = mix(0.5, 0.9, irr);\n    irr = mix(\n        0.1,\n        1.0,\n        noise13(vec3(floor(xy), iTime * 30.0 * noise12(floor(xy))))\n    );\n    return c * c * irr;\n}\n\nfloat star(in vec2 uv) {\n    uv.x += iTime * 0.01;\n    uv /= STAR_INTERVAL;\n    float c = 0.0;\n    for (int k = 0; k < 9; k++)\n#ifdef GLES3\n        c = max(c, cellstar(uv, vec2(k / 3 - 1, k % 3 - 1)));\n#else\n    {\n        int l = k - k / 3 * 3;\n        c = max(c, cellstar(uv, vec2(k / 3 - 1, l - 1)));\n    }\n#endif\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y;\n    float c = star(uv);\n    vec3 col = BACK_GROUND * (1.0 - c) + STAR * c;\n    c = mountain(uv);\n    col = MOUNTAIN * (1.0 - c) + col * c;\n    fragColor = vec4(pow(col, vec3(0.4545)), 1);\n}\n", "image_inputs": [], "common_code": "// if you cannot use GLES3, remove this macro\n#define GLES3\n\n#ifdef GLES3\n// based on https://www.shadertoy.com/view/XlXcW4\n// with some minor changes...\nvec3 hash(uvec3 x) {\n    const uint k = 1103515245U;\n    x.y = ((x.y>>8U)^x.y)*k;\n    x.z = ((x.z>>8U)^x.z)*k;\n    x.z = ((x.z>>8U)^x.z)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)/float(0xffffffffU);\n}\n\nvec3 noise31(float x) {\n    uint s = uint(int(floor(x)) + 2147483647);\n    float t = fract(x);\n    return mix(hash(uvec3(s)), hash(uvec3(s + 1u)), t);\n}\n\nfloat noise11(float x) {\n    return noise31(x).x;\n}\n\nvec2 noise21(float x) {\n    return noise31(x).xy;\n}\n\nvec3 noise32(vec2 x) {\n    uvec3 s = uvec3(ivec2(floor(x)) + 2147483647, 1);\n    vec2 t = fract(x);\n    uvec2 e = uvec2(0, 1);\n    return mix(\n        mix(hash(s + e.xxx), hash(s + e.yxx), t.x),\n        mix(hash(s + e.xyx), hash(s + e.yyx), t.x),\n        t.y\n    );\n}\n\nfloat noise12(vec2 x) {\n    return noise32(x).x;\n}\n\nvec2 noise22(vec2 x) {\n    return noise32(x).xy;\n}\n\nvec3 noise33(vec3 x) {\n    uvec3 s = uvec3(ivec3(floor(x)) + 2147483647);\n    vec3 t = fract(x);\n    uvec2 e = uvec2(0, 1);\n    return mix(\n        mix(\n            mix(hash(s + e.xxx), hash(s + e.yxx), t.x),\n            mix(hash(s + e.xyx), hash(s + e.yyx), t.x),\n            t.y\n        ),\n        mix(\n            mix(hash(s + e.xxy), hash(s + e.yxy), t.x),\n            mix(hash(s + e.xyy), hash(s + e.yyy), t.x),\n            t.y\n        ),\n        t.z\n    );\n}\n\nfloat noise13(vec3 x) {\n    return noise33(x).x;\n}\n\nvec2 noise23(vec3 x) {\n    return noise33(x).xy;\n}\n\n#define three_mix(a0, a1, a2, t) (\\\n      a0 * (1.0 - t) * (1.0 - t) * 0.5\\\n    + a1 * ((t + 1.0) * (1.0 - t) + t * (2.0 - t)) * 0.5\\\n    + a2 * t * t * 0.5\\\n)\n\nvec3 smoothnoise31(float x) {\n    uint s = uint(int(floor(x)) + 2147483647);\n    float t = fract(x);\n    return three_mix(\n        hash(uvec3(s - 2u)),\n        hash(uvec3(s - 1u)),\n        hash(uvec3(s)),\n        t\n    );\n}\n\nfloat smoothnoise11(float x) {\n    return smoothnoise31(x).x;\n}\n\nvec2 smoothnoise21(float x) {\n    return smoothnoise31(x).xy;\n}\n\nvec3 smoothnoise32(vec2 x) {\n    const int k = 2147483647;\n    uvec2 s = uvec2(ivec2(floor(x)) + k);\n    vec2 t = fract(x);\n    uvec3 e = uvec3(0, 1, 2);\n    return three_mix(\n        three_mix(\n            hash(uvec3(s - e.zz, k)),\n            hash(uvec3(s - e.yz, k)),\n            hash(uvec3(s - e.xz, k)),\n            t.x\n        ),\n        three_mix(\n            hash(uvec3(s - e.zy, k)),\n            hash(uvec3(s - e.yy, k)),\n            hash(uvec3(s - e.xy, k)),\n            t.x\n        ),\n        three_mix(\n            hash(uvec3(s - e.zx, k)),\n            hash(uvec3(s - e.yx, k)),\n            hash(uvec3(s - e.xx, k)),\n            t.x\n        ),\n        t.y\n    );\n}\n\nfloat smoothnoise12(vec2 x) {\n    return smoothnoise32(x).x;\n}\n\nvec2 smoothnoise22(vec2 x) {\n    return smoothnoise32(x).xy;\n}\n\nvec3 smoothnoise33(vec3 x) {\n    uvec3 s = uvec3(ivec3(floor(x)) + 2147483647);\n    vec3 t = fract(x);\n    uvec3 e = uvec3(0, 1, 2);\n    return three_mix(\n        three_mix(\n            three_mix(hash(s - e.zzz), hash(s - e.yzz), hash(s - e.xzz), t.x),\n            three_mix(hash(s - e.zyz), hash(s - e.yyz), hash(s - e.xyz), t.x),\n            three_mix(hash(s - e.zxz), hash(s - e.yxz), hash(s - e.xxz), t.x),\n            t.y\n        ),\n        three_mix(\n            three_mix(hash(s - e.zzy), hash(s - e.yzy), hash(s - e.xzy), t.x),\n            three_mix(hash(s - e.zyy), hash(s - e.yyy), hash(s - e.xyy), t.x),\n            three_mix(hash(s - e.zxy), hash(s - e.yxy), hash(s - e.xxy), t.x),\n            t.y\n        ),\n        three_mix(\n            three_mix(hash(s - e.zzx), hash(s - e.yzx), hash(s - e.xzx), t.x),\n            three_mix(hash(s - e.zyx), hash(s - e.yyx), hash(s - e.xyx), t.x),\n            three_mix(hash(s - e.zxx), hash(s - e.yxx), hash(s - e.xxx), t.x),\n            t.y\n        ),\n        t.z\n    );\n}\n#else\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// noises (original code)\n\n#define three_mix(a0, a1, a2, t) (\\\n      a0 * (1.0 - t) * (1.0 - t) * 0.5\\\n    + a1 * ((t + 1.0) * (1.0 - t) + t * (2.0 - t)) * 0.5\\\n    + a2 * t * t * 0.5\\\n)\n\n#define DEFINE_ONE_DIM_NOISE(type, noise, smoothnoise, hash) \\\ntype noise(float p) { \\\n    float t = fract(p); \\\n    p = floor(p) + 1.465; \\\n    return mix(hash(p), hash(p + 1.0), t); \\\n} \\\ntype smoothnoise(float p) { \\\n    float t = fract(p); \\\n    p = floor(p) + 1.465; \\\n    return three_mix(hash(p - 2.0), hash(p - 1.0), hash(p), t); \\\n}\n\nDEFINE_ONE_DIM_NOISE(float, noise11, smoothnoise11, hash11)\nDEFINE_ONE_DIM_NOISE(vec2, noise21, smoothnoise21, hash21)\nDEFINE_ONE_DIM_NOISE(vec3, noise31, smoothnoise31, hash31)\nDEFINE_ONE_DIM_NOISE(vec4, noise41, smoothnoise41, hash41)\n\n#define DEFINE_TWO_DIM_NOISE(type, noise, smoothnoise, hash) \\\ntype noise(vec2 p) { \\\n    vec2 t = fract(p); \\\n    p = floor(p) + vec2(1.365, -0.593); \\\n    vec2 e = vec2(0, 1); \\\n    return mix( \\\n        mix(hash(p + e.xx), hash(p + e.yx), t.x), \\\n        mix(hash(p + e.yx), hash(p + e.yy), t.x), \\\n        t.y \\\n    ); \\\n} \\\ntype smoothnoise(vec2 p) { \\\n    vec2 t = fract(p); \\\n    p = floor(p) + vec2(1.365, -0.593); \\\n    vec3 e = vec3(0, 1, 2); \\\n    return three_mix( \\\n        three_mix(hash(p - e.zz), hash(p - e.yz), hash(p - e.xz), t.x), \\\n        three_mix(hash(p - e.zy), hash(p - e.yy), hash(p - e.xy), t.x), \\\n        three_mix(hash(p - e.zx), hash(p - e.yx), hash(p - e.xx), t.x), \\\n        t.y \\\n    ); \\\n}\n\nDEFINE_TWO_DIM_NOISE(float, noise12, smoothnoise12, hash12)\nDEFINE_TWO_DIM_NOISE(vec2, noise22, smoothnoise22, hash22)\nDEFINE_TWO_DIM_NOISE(vec3, noise32, smoothenoise32, hash32)\nDEFINE_TWO_DIM_NOISE(vec4, noise42, smoothnoise42, hash42)\n\n#define DEFINE_THREE_DIM_NOISE(type, noise, smoothnoise, hash) \\\ntype noise(vec3 p) { \\\n    vec3 t = fract(p); \\\n    p = floor(p) + vec3(1.465, -0.593, 2.1985); \\\n    vec2 e = vec2(0, 1); \\\n    return mix( \\\n        mix( \\\n            mix(hash(p + e.xxx), hash(p + e.yxx), t.x), \\\n            mix(hash(p + e.xyx), hash(p + e.yyx), t.x), \\\n            t.y \\\n        ), \\\n        mix( \\\n            mix(hash(p + e.xxy), hash(p + e.yxy), t.x), \\\n            mix(hash(p + e.xyy), hash(p + e.yyy), t.x), \\\n            t.y \\\n        ), \\\n        t.z \\\n    ); \\\n} \\\ntype smoothnoise(vec3 p) { \\\n    vec3 t = fract(p); \\\n    p = floor(p) + vec3(1.465, -0.593, 2.1985); \\\n    vec3 e = vec3(0, 1, 2); \\\n    return three_mix( \\\n        three_mix( \\\n            three_mix(hash(p - e.zzz), hash(p - e.yzz), hash(p - e.xzz), t.x), \\\n            three_mix(hash(p - e.zyz), hash(p - e.yyz), hash(p - e.xyz), t.x), \\\n            three_mix(hash(p - e.zxz), hash(p - e.yxz), hash(p - e.xxz), t.x), \\\n            t.y \\\n        ), \\\n        three_mix( \\\n            three_mix(hash(p - e.zzy), hash(p - e.yzy), hash(p - e.xzy), t.x), \\\n            three_mix(hash(p - e.zyy), hash(p - e.yyy), hash(p - e.xyy), t.x), \\\n            three_mix(hash(p - e.zxy), hash(p - e.yxy), hash(p - e.xxy), t.x), \\\n            t.y \\\n        ), \\\n        three_mix( \\\n            three_mix(hash(p - e.zzx), hash(p - e.yzx), hash(p - e.xzx), t.x), \\\n            three_mix(hash(p - e.zyx), hash(p - e.yyx), hash(p - e.xyx), t.x), \\\n            three_mix(hash(p - e.zxx), hash(p - e.yxx), hash(p - e.xxx), t.x), \\\n            t.y \\\n        ), \\\n        t.z \\\n    ); \\\n}\n\nDEFINE_THREE_DIM_NOISE(float, noise13, smoothnoise13, hash13)\nDEFINE_THREE_DIM_NOISE(vec2, noise23, smoothnoise23, hash23)\nDEFINE_THREE_DIM_NOISE(vec3, noise33, smoothnoise33, hash33)\nDEFINE_THREE_DIM_NOISE(vec4, noise43, smoothnoise43, hash43)\n#endif", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltSR7.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[295, 295, 332, 332, 507], [509, 509, 537, 537, 654], [656, 656, 697, 697, 1210], [1545, 1545, 1600, 1600, 1831]], "test": "untested"}
{"id": "7tdXzM", "name": "Random Walk e", "author": "SnoopethDuckDuck", "description": "Goes to bottom left corner after a while. (i think h21 is used not randomly idk)", "tags": ["e"], "likes": 20, "viewed": 425, "published": 3, "date": "1638891535", "time_retrieved": "2024-07-30T18:43:32.069685", "image_code": "float h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// number of points\nconst float m = 50.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n       \n    // increment time (60. * iTime looks smooth, but bugs out faster)\n    float t = floor(20. * iTime) - 1000.;\n\n    // start point\n    vec2 p = vec2(0.);\n    \n    // initialise d with \"large\" number\n    float d = 1.;\n    float k = 0.01;\n    for (float i = 0.; i < m; i++) {\n        t++;\n    \n        // next point in sequence, move further if further along the sequence\n        // (bad use of h21)\n        vec2 p2 = p + 0.2 * (i/m) * (vec2(h21(k * vec2(t, t + 1.)), \n                                          h21(k * vec2(t, t - 1.))) - 0.5);\n                                          \n        // keep points on screen\n        p2 = clamp(p2, -0.48, 0.48);\n    \n        // length from points / segments\n        float d2 = min(0.5 * length(uv - p2), 2. * sdSegment(uv, p, p2));\n        \n        //float k = step(h21(vec2(t, t + 1.)), 0.5);\n        p = p2; //mix(vec2(0.), p2, k);\n        d = min(d, d2);\n        \n        // fade points \n        d += 0.0005; // + 0.0007 * cos(3. * iTime + i / m);\n    }\n    \n    // draw stuff\n    float s = smoothstep(-0.03, 0.03, -d + 0.005); //-step(d, 0.01);\n    s = clamp(s, 0., 1.);\n    s *= 4. * s;//4.2 * s * cos(4. * s + 10. * iTime) + 4.5 *s;\n    vec3 col = vec3(s);\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "float sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdXzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 95], [139, 139, 196, 196, 1517]], "test": "untested"}
{"id": "NldSzM", "name": "Gold Edifices", "author": "dr2", "description": "Auric architecture", "tags": ["wave", "hexagon", "building"], "likes": 39, "viewed": 419, "published": 3, "date": "1638868361", "time_retrieved": "2024-07-30T18:43:33.059040", "image_code": "// \"Gold Edifices\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Auric architecture (based on \"Edible Edifices\")\n\n#define AA  0  // (= 0/1) optional antialiasing\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 qHit, ltDir;\nvec2 gId, trkF, trkA, bldCs;\nfloat tCur, dstFar, hgSize, wavHt, emFrac, grRad, pR, pA, bldTp, rc;\nint idObj;\nbool isOcc, isSh;\nconst float pi = 3.1415927, sqrt2 = 1.41421, sqrt3 = 1.7320508;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat CasBldgDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  float d, a;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * (pA - 0.5) + 0.5) / 4.));\n  qq = q;\n  q.xy -= vec2 (-5., 1.2);\n  d = PrRoundBoxDf (q, vec3 (0.15, 1.2 + rc, 5.) - rc, rc);\n  d = max (d, - PrRoundBox2Df (vec2 (q.y - 1.2, mod (q.z + 0.25, 0.5) - 0.25), vec2 (0.2, 0.1), rc));\n  d = max (d, - PrRoundBox2Df (vec2 (q.yz - vec2 (-0.6, 0.)), vec2 (0.6, 0.4), rc));\n  dMin = min (dMin, d);\n  q.z = abs (q.z) - 5.;\n  q.y -= 0.2;\n  d = min (PrCylAnDf (q.xzy, 0.45, 0.05, 1.2 + 0.2), PrCylDf (q.xzy, 0.4, 1.2));\n  dMin = min (dMin, d);\n  q = qq;\n  q.xy -= vec2 (-2., 2.);\n  d = max (max (q.y - 1.8 - 0.3 * q.x, - q.x), - p.y);\n  dMin = min (dMin, d);\n  d = PrRoundBoxDf (q, vec3 (0.15, 2.2 + rc, 2.) - rc, rc);\n  d = max (d, - PrRoundBox2Df (vec2 (q.y - 2.2, mod (q.z + 0.25, 0.5) - 0.25), vec2 (0.2, 0.1), rc));\n  dMin = min (dMin, d);\n  q.z = abs (q.z) - 2.;\n  d = PrCylDf (q.xzy, 0.3, 2.3);\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat TwrBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.y -= 3.5 - rc;\n  d = PrRoundBoxDf (q, vec3 (vec2 (1.3) * (1. - 0.05 * q.y), 3.5).xzy - rc, rc);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * (pA - 0.5) + 0.5) / 4.));\n  q.xy -= vec2 (-4., -1.);\n  d = min (d, PrRoundCylDf (q.xzy, 0.8 * (1. - 0.05 * q.y) - rc, rc, 2.5 - rc));\n  q.x -= 1.7;\n  d = min (d, PrRoundBoxDf (vec3 (q.xz, q.y - 0.8 + 0.2 * q.x * q.x).xzy, vec3 (2., 0.4, 0.1), rc));\n  q.z = abs (q.z);\n  q -= vec3 (-2.5, -1., 1.1);\n  d = min (d, PrRoundCylDf (q.xzy, 0.7 * (1. - 0.05 * q.y)- rc, rc, 1.5 - rc));\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat PyrBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * (pA - 0.5) + 0.5) / 4.));\n  q.xy -= vec2 (-3.5, 2.);\n  d = max (max (abs (q.y) - 2., - q.x + q.y), min (0.4 - abs (abs (q.z) - 0.6), (q.y - q.x + 0.18 -\n     abs (mod (q.x + q.y - 0.02, 0.4) - 0.2) / sqrt2)));\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 4.2;\n  d = PrCylAnDf (q.xzy, 0.5, 0.05, 0.2);\n  dMin = min (dMin, d);\n  return 0.5 * dMin;\n}\n\nfloat TajBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  d = PrRoundBoxDf (q, vec3 (5.8, 0.1, 5.8) - rc, rc);\n  dMin = min (dMin, d);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (8. * (pA - 0.5) + 0.5) / 8.));\n  q.xy -= vec2 (-3.5, 2.);\n  d = abs (q.y) - 2.;\n  q.y = mod (q.y + 0.4, 2.) - 1.;\n  q.z = abs (q.z) - 0.6;\n  d = max (d, max (- q.x, - max (PrCapsDf ((q - vec3 (0., -0.5, 0.)).xzy, 0.4, 1.), - q.y - 0.2)));\n  dMin = min (dMin, d);\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * (pA - 0.5) + 0.5) / 4.));\n  q.z = abs (q.z);\n  q -= vec3 (-5., 3.1, 5.);\n  d = PrCylDf (q.xzy, 0.3 - 0.1 * q.y / 3., 3.);\n  dMin = min (dMin, d);\n  q.y -= 3.2;\n  d = PrSphDf (q, 0.3);\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 4.6;\n  d = PrSphDf (q, 2.);\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat PisBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, ht, dh, a, ai, nf, na;\n  nf = 8.;\n  na = 12.;\n  ht = 3.5;\n  q = p;\n  d = PrCylDf (q.xzy, 3., 0.05);\n  dMin = min (dMin, d);\n  q.xz = Rot2D (q.xz, pi / 4.);\n  q.y -= ht + 0.05;\n  q.xy = Rot2D (q.xy, 0.025 * pi);\n  a = atan (q.z, - q.x) / (2. * pi) + 0.5;\n  d = PrCylDf (q.xzy, 1., ht);\n  dh = abs (q.y) - ht * (1. + 1. / (4. * nf));\n  q.y = mod (q.y + ht / nf, 2. * ht / nf) - ht / nf;\n  d = min (d, max (dh, PrRoundCylDf (q.xzy, 1.2 - rc, rc, ht / (4. * nf) - rc)));\n  ai = floor (na * (a - 0.5) + 0.5) / na;\n  q.xz = Rot2D (q.xz, 2. * pi * ai);\n  q.y = abs (q.y) - ht / nf;\n  d = max (d, - PrRoundBoxDf (vec3 (length (q.xz) - 1., q.y, 2. * pi * (abs (a - ai - 0.5) - 0.5 / na)),\n     vec3 (0.2, 0.55 * ht / nf, 0.12) - rc, rc));\n  q.x -= -1.05;\n  d = min (d, max (dh, PrCylDf (q.xzy, 0.08, ht / nf)));\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 0.4;\n  d = PrRoundBox2Df (vec2 (pR - 6.5, abs (q.y) - 0.4), vec2 (0.25, 0.01), rc);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (64. * (pA - 0.5) + 0.5) / 64.));\n  q.x = abs (q.x + 6.5) - 0.15;\n  d = min (d, PrCylDf (q.xzy, 0.08, 0.4));\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat FrtBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, r;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (5. * (pA - 0.5) + 0.5) / 5.));\n  q.xy -= vec2 (-2., 1.4);\n  d = max (max (- q.x, abs (q.y) - 1.4), - PrRoundBoxDf (vec3 (q.x, abs (q.y) - 0.5,\n     mod (q.z + 0.5, 1.) - 0.5), vec3 (0.1, 0.2, 0.15), rc));\n  d = min (d, PrRoundBox2Df (vec2 (q.x - 2., q.y - 1.4 - 0.3 * q.x), vec2 (2.2, 0.06) - rc, rc));\n  dMin = min (dMin, d);\n  q.xy -= vec2 (-3.5, -0.6);\n  d = max (max (abs (q.x) - 0.4, abs (q.y) - 0.8),\n     - PrRoundBox2Df (vec2 (q.yz - vec2 (-0.2, 0.)), vec2 (0.4, 0.3), rc));\n  d = min (d, PrRoundBox2Df (vec2 (q.x, q.y - 0.9 + 0.4 * abs (q.x)), vec2 (0.6, 0.06) - rc, rc));\n  dMin = min (dMin, d);\n  q.y -= 0.3;\n  q.z = abs (q.z) - 5.5 * tan (pi / 5.);\n  d = PrCylDf (q.xzy, 0.8, 1.1);\n  r = 0.2 * length (q.xz);\n  q.y -= 1.4 - r;\n  d = min (d, PrCylDf (q.xzy, 1.1, 0.3 - r));\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat WvnBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, rs, s, h, f, yy;\n  h = 2.5;\n  rs = 0.15;\n  q = p;\n  q.y -= h + rs;\n  f = q.y / h - 1.;\n  yy = abs (q.y) - h;\n  d = max (pR - 2.3 - 0.7 * f * f, yy);\n  q.xz *= 1.4 + 0.4 * f;\n  q.xz = vec2 (20. * pA, length (q.xz) - 10. / pi);\n  d = min (d, length (vec2 (yy, q.z)) - 2. * rs);\n  s = 0.4 * rs * cos (2. * pi * q.x);\n  d = min (d, max (min (length (vec2 ((mod ((q.x + q.y) + 0.5, 1.) - 0.5) / sqrt2, q.z + s)),\n     length (vec2 ((mod ((q.x - q.y) + 0.5, 1.) - 0.5) / sqrt2, q.z - s))) - rs, yy));\n  dMin = min (dMin, d);\n  return 0.5 * dMin;\n}\n\nfloat PstBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, s, ss;\n  s = 1.7;\n  q = p;\n  q.xz = Rot2D (q.xz, 0.25 * pi);\n  for (int j = VAR_ZERO; j < 5; j ++) {\n    q.xz = Rot2D (q.xz, 0.25 * pi);\n    q.xz = abs (q.xz) - 0.75 * s;\n    ss = s * s;\n    q.xz = mix (q.xz, q.zx, step (q.x, q.z));\n    d = min (PrRoundBoxDf (q - vec3 (0., 0.6 * ss - rc, 0.), s * vec3 (0.3, 0.6 * s, 0.3) - rc, rc),\n       PrCylDf ((q - vec3 (0., 1.45 * ss - rc, 0.)).xzy, 0.12 * s, 0.25 * ss));\n    dMin = min (dMin, d);\n    s *= 0.85;\n  }\n  return 0.9 * dMin;\n}\n\nfloat BrgBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.y -= 0.1 + 0.01 * sin (8. * pi * pR);\n  d = max (abs (abs (pR - 5.2) - 1.4) - 0.4, abs (q.y) - 0.1);\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 1.5;\n  d = min (PrCylDf (q.xzy, 2.5, 1.5),\n     PrCylDf (vec3 (q.xz, q.y - (2.2 - 0.25 * pR + 0.1 * sin (32. * pi * pA))), 2.8, 0.07));\n  q.y -= 2.16;\n  d = min (d, PrCylDf (q.xzy, 0.5, 0.22));\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (3. * (pA - 0.5) + 0.5) / 3.));\n  d = max (d, - PrRoundBoxDf (q - vec3 (-2.5, 0.8, 0.), vec3 (0.7, 0.8, 0.7), rc));\n  dMin = min (dMin, d);\n  q.x += 5.2;\n  q.y -= 0.5 - 0.2 * q.x * q.x;\n  d = PrBoxDf (q, vec3 (1.6, 0.1, 0.6));\n  q.z = abs (q.z);\n  q.yz -= vec2 (0.3, 0.5);\n  d = min (d, PrRoundBoxDf (q, vec3 (1.6, 0.3, 0.1) - rc, rc));\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat PanBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  p.y -= 1.8;\n  q = p;\n  d = PrRoundBoxDf (q, vec3 (4.9, 1.6, 2.9) - rc, rc);\n  q.y = abs (q.y) - 1.5;\n  d = min (d, PrRoundBoxDf (q, vec3 (5.4, 0.1, 3.4) - rc, rc));\n  q = p;\n  q.y -= -1.7;\n  d = min (d, PrRoundBoxDf (q, vec3 (6., 0.1, 4.) - rc, rc));\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 2.2;\n  d = PrCylDf (q.xzy, 1.7, 0.75);\n  q.y -= 0.75;\n  d = min (d, max (max (PrSphDf (q, 2.), - q.y), 0.2 - pR));\n  dMin = min (dMin, d);\n  q = p;\n  q.xz = mod (q.xz + 0.5, 1.) - 0.5;\n  d = max (PrCylDf (q.xzy, 0.2, 1.5), max (abs (p.x) - 5.5, abs (p.z) - 3.5));\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (16. * (pA - 0.5) + 0.5) / 16.));\n  q.xy -= vec2 (-1.85, 2.2);\n  d = min (d, PrCylDf (q.xzy, 0.15, 0.75));\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  p.xz -= HexToPix (gId * hgSize);\n  dMin = dstFar;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * atan (q.z, - q.x) / (2. * pi) + 0.5)) / 6.);\n  q.y -= wavHt - 0.05;\n  d = SmoothMax (abs (q.x) - 0.48 * sqrt3 * hgSize, q.y, 0.05);\n  DMINQ (1);\n  if (isOcc) {\n    q = p;\n    q.xz = Rot2Cs (q.xz, bldCs);\n    q.y -= wavHt + 0.35;\n    pR = length (q.xz);\n    pA = ((pR > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.) + 0.5;\n    rc = 0.05;\n    if (! isSh) d = PrCylDf ((q - vec3 (0., 3.8, 0.)).xzy, 8.21, 3.8);\n    if (isSh || d < 0.1) {\n      if (bldTp <= 4.) {\n        if      (bldTp == 1.) d = CasBldgDf (q, dMin);\n        else if (bldTp == 2.) d = TwrBldgDf (q, dMin);\n        else if (bldTp == 3.) d = PyrBldgDf (q, dMin);\n        else /*if (bldTp == 4.)*/ d = TajBldgDf (q, dMin);\n      } else if (bldTp <= 7.) {\n        if      (bldTp == 5.) d = PisBldgDf (q, dMin);\n        else if (bldTp == 6.) d = FrtBldgDf (q, dMin);\n        else /*if (bldTp == 7.)*/ d = WvnBldgDf (q, dMin);\n      } else /*if (bldTp <= 10.)*/ {\n        if      (bldTp == 8.) d = PstBldgDf (q, dMin);\n        else if (bldTp == 9.) d = BrgBldgDf (q, dMin);\n        else if (bldTp == 10.) d = PanBldgDf (q, dMin);\n      }\n      DMINQ (2);\n    } else dMin = min (dMin, d);\n    q.y -= -0.2;\n    d = PrRoundCylDf (q.xzy, 8.2 - rc, rc, 0.15 - rc);\n    DMINQ (3);\n  }\n  return dMin;\n}\n\nvoid SetGrObjConf ()\n{\n  vec2 p, u, fRand;\n  p = HexToPix (gId * hgSize);\n  u = mod (0.1 * vec2 (p.x + p.y, p.x - p.y) * (1. + 0.4 * sin (0.2 * 2. * pi * p)) +\n     0.1 * tCur, 1.) - 0.5;\n  wavHt = dot (exp (-100. * u * u), vec2 (1.));\n  fRand = Hashv2v2 (gId * vec2 (37.31, 43.11) + 27.11);\n  isOcc = (fRand.y > emFrac);\n  if (isOcc) {\n    bldTp = 1. + floor (10. * (fRand.y - emFrac) / (1. - emFrac));\n    bldCs = sin (2. * pi * fRand.x + vec2 (0.5 * pi, 0.));\n  }\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  int idObjT;\n  isSh = true;\n  idObjT = idObj;\n  sh = 1.;\n  gIdP = vec2 (-999.);\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > 2. * hgSize) break;\n  }\n  idObj = idObjT;\n  isSh = false;\n  return 0.8 + 0.2 * sh;\n}\n\nfloat BgCol (vec3 rd)\n{\n  vec3 col;\n  vec2 u;\n  float el, f;\n  rd.xz = Rot2D (rd.xz, 0.01 * tCur);\n  el = asin (rd.y);\n  u = vec2 (atan (rd.z, - rd.x) + pi, tan (2. * atan (0.5 * el))) / (2. * pi);\n  f = 64.;\n  col = mix (vec3 (0., 0.1, 0.3), vec3 (0.8), mix (Fbm2 (f * u),\n     Fbm2 (f * (u - vec2 (1., 0.))), u.x));\n  col = mix (col, vec3 (0.2, 0.3, 0.4), smoothstep (0.95, 0.98, abs (el) / (0.5 * pi)));\n  f = Maxv3 (col);\n  return f * sqrt (f);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn, vnn;\n  vec2 vf;\n  float dstObj, nDotL, sh, glit;\n  bgCol = BgCol (rd) * vec3 (1., 1., 0.3);\n  emFrac = 0.02;\n  isSh = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    gId = PixToHex (ro.xz / hgSize);\n    SetGrObjConf ();\n    vn = ObjNf (ro);\n    vf = vec2 (0.);\n    if (idObj == 1) {\n      if (vn.y > 0.5) {\n        col4 = vec4 (0.2, 0.4, 0.2, 0.1) * (0.8 + 0.2 * Fbm2 (ro.xz));\n        if (isOcc) col4 = mix (vec4 (0.4, 0.3, 0., 0.1), col4,\n           smoothstep (8.2, 8.25, length (ro.xz - HexToPix (gId * hgSize))));\n        vf = vec2 (4., 1.);\n      } else col4 = vec4 (0.1, 0.3, 0.1, 0.) * (0.9 + 0.1 * sin (4. * pi * qHit.y));\n    } else if (idObj == 2) {\n      col4 = vec4 (0.7, 0.7, 0.1, 0.2);\n      vf = vec2 (512., 8.);\n    } else if (idObj == 3) {\n      col4 = vec4 (0.5, 0.4, 0.1, 0.1);\n      vf = vec2 (8., 0.5);\n    }\n    if (vf.y > 0.) {\n      vnn = VaryNf (vf.x * qHit, vn, vf.y);\n      if (idObj != 2) vn = vnn;\n    }\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (idObj == 2) nDotL *= nDotL;\n    sh = (idObj != 2) ? ObjSShadow (ro + 0.1 * vn, ltDir) : 1.;\n    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.8 * sh * nDotL) +\n       step (0.95, sh) * col4.a * pow (max (dot (reflect (ltDir, vn), rd), 0.), 32.);\n    if (idObj == 2) {\n      col = mix (col, BgCol (reflect (rd, vn)) * vec3 (1., 1., 0.3), 0.3);\n      glit = 32. * pow (max (0., dot (ltDir, reflect (rd, vn))), 16.) *\n         pow (1. - 0.6 * abs (dot (normalize (ltDir - rd), vnn)), 8.);\n      col += vec3 (1., 1., 0.8) * glit;\n    }\n    col = mix (col, bgCol, smoothstep (0.5, 1., dstObj / dstFar));\n  } else col = (0.1 + 0.9 * step (-0.1, rd.y)) * bgCol;\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkA, sin (trkF * t)), dot (trkA.yx, cos (trkF * t)), t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (dot (trkF * trkA, cos (trkF * t)), dot (trkF * trkA.yx, - sin (trkF * t)), 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, asp, sr, vFly;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  tCur = mod (tCur, 1200.);\n  hgSize = 11.;\n  az = 0.;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.2 * pi * mPtr.y;\n  } else {\n    az += 0.2 * pi * sin (0.02 * pi * tCur);\n  }\n  trkF = 0.2 * vec2 (0.1, 0.17);\n  trkA = 2. * vec2 (1.25, 0.45);\n  vFly = 3.;\n  ro = TrackPath (vFly * tCur);\n  ro.xy += vec2 (3.5, 30.);\n  vd = normalize (TrackVel (vFly * tCur));\n  el += asin (vd.y);\n  az += atan (vd.x, vd.z);\n  el = clamp (el, -0.25 * pi, -0.12 * pi);\n  vuMat = StdVuMat (el, az);\n  zmFac = 3.;\n  dstFar = 500.;\n  ltDir = vuMat * normalize (vec3 (1., 0.7, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldSzM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1292, 1292, 1330, 1330, 2294], [2296, 2296, 2334, 2334, 2934], [2936, 2936, 2974, 2974, 3394], [3396, 3396, 3434, 3434, 4201], [4203, 4203, 4241, 4241, 5386], [5388, 5388, 5426, 5426, 6331], [6333, 6333, 6371, 6371, 6934], [6936, 6936, 6974, 6974, 7477], [7479, 7479, 7517, 7517, 8320], [8322, 8322, 8360, 8360, 9142], [9144, 9144, 9166, 9166, 10549], [10551, 10551, 10573, 10573, 11019], [11021, 11021, 11054, 11054, 12129], [12131, 12131, 12152, 12152, 12409], [12411, 12411, 12448, 12448, 12940], [12942, 12942, 12965, 12965, 13392], [13394, 13394, 13429, 13429, 15188], [15190, 15190, 15216, 15216, 15296], [15298, 15298, 15323, 15323, 15420], [15422, 15422, 15478, 15478, 16916], [16918, 16918, 16950, 16950, 17050], [17052, 17052, 17098, 17098, 17145], [17147, 17147, 17194, 17194, 17241], [17243, 17243, 17276, 17276, 17303], [17305, 17305, 17347, 17347, 17398], [17400, 17400, 17453, 17453, 17514], [17516, 17516, 17573, 17573, 17649], [17651, 17651, 17694, 17694, 17758], [17760, 17760, 17784, 17784, 18014], [18016, 18016, 18040, 18040, 18100], [18102, 18102, 18124, 18124, 18162], [18164, 18164, 18186, 18186, 18224], [18226, 18226, 18271, 18271, 18363], [18365, 18365, 18410, 18410, 18448], [18450, 18450, 18486, 18486, 18692], [18693, 18693, 18723, 18723, 18836], [18838, 18838, 18869, 18869, 18933], [18967, 18967, 18991, 18991, 19103], [19105, 19105, 19130, 19130, 19316], [19318, 19318, 19339, 19339, 19494], [19496, 19496, 19525, 19525, 19737], [19739, 19739, 19778, 19778, 20030]], "test": "untested"}
{"id": "NtdSRM", "name": "Camera Driven Game of Life", "author": "soofgo", "description": "Game of life, but with your camera as input.\nCamera -> adaptive threshold -> Game of Life -> some coloring.", "tags": ["feedback", "buffer", "conway", "gameoflife", "conways", "gol"], "likes": 2, "viewed": 354, "published": 3, "date": "1638863730", "time_retrieved": "2024-07-30T18:43:33.917745", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define brushSize 20.0\n\n#define T(i,j) texture(iChannel0, (uv + vec2(i,j)*vec2(1.0/R) )).r \n#define N(i,j)  + float( T(i,j) > 0.)\n\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\nvec3 HueShift (in vec3 Color, in float Shift)\n{\n    vec3 P = vec3(0.55735)*dot(vec3(0.55735),Color);\n    \n    vec3 U = Color-P;\n    \n    vec3 V = cross(vec3(0.55735),U);    \n\n    Color = U*cos(Shift*6.2832) + V*sin(Shift*6.2832) + P;\n    \n    return vec3(Color);\n}\n//noise see https://www.shadertoy.com/view/ltB3zD\nfloat snoise(in vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// set value for r key to reset with\nconst int Key_R = 82;\n\n// process keyboard input\nbool ReadKey( int key )//, bool toggle )\n{\n\tbool toggle = false;\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 c )\n{\n\tvec2 R = iResolution.xy;\n    \n    // retrieve the texture coordinate\n    vec2 uv = c.xy / R;\n    \n    // get the current pixel\n    float v = texture(iChannel0, uv).r;\n    \n    // check to seee if we are at the start of the timeline or if the R key is pressed.\n    if(iFrame > 4 && !ReadKey(Key_R))\n    {\n        // draw a circle if the mouse is clicked\n        if(distance(iMouse.xy, c) < brushSize && iMouse.z > .0)\n        {\n        \tO = vec4(1.0);\n        }\n        else\n        {\n            float n =   N(-1,-1) + N(-1, 0) + N(-1, 1)\n                      + N( 0,-1)            + N( 0, 1)\n                      + N( 1,-1) + N( 1, 0) + N( 1, 1);\n\n\n            // resurect if we are not live, and have 3 live neighrbours\n            v += (1.0-float(v > 0.0)) * float(n == 3.0);\n\n            // kill if we do not have either 3 or 2 neighbours\n            v *= float(n == 2.0 || n == 3.0);\n\n            // fade the current pixel as it ages\n            v -= float(v > 0.4)*0.05;\n\n            // write out the pixel\n            \n            vec3 val = HueShift(hsl2rgb(vec3(v)),float(iTime));\n            float pi = 3.141;\n            float F = 0.5 * pi *(uv.x - uv.y + 1.);\n            float F2 = 0.5 * pi *(uv.x + uv.y);\n            O = abs(vec4(sin(val.r * F),sin(val.g* F2), sin(val.b * 0.7), 1.0));\n        }\n    }\n    //Generate some noise to get things going\n    else\n    {\n        O = vec4(snoise(c) > 0.8 ? 1.0 : 0.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// 16x acceleration of https://www.shadertoy.com/view/4tSyzy\n// by applying gaussian at intermediate MIPmap level.\n\nconst int samples = 35,\n          LOD = 2,         // gaussian done on MIPmap at scale LOD\n          sLOD = 1 << LOD; // tile size = 2^LOD\nconst float sigma = float(samples) * .25;\n\nfloat gaussian(vec2 i) {\n    return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );\n}\n\nvec4 blur(sampler2D sp, vec2 U, vec2 scale) {\n    vec4 O = vec4(0);  \n    int s = samples/sLOD;\n    \n    for ( int i = 0; i < s*s; i++ ) {\n        vec2 d = vec2(i%s, i/s)*float(sLOD) - float(samples)/2.;\n        O += gaussian(d) * textureLod( sp, U + scale * d , float(LOD) );\n    }\n    \n    return O / O.a;\n}\n\nvec4 threshold(in vec4 tx){\n    const float Soft = 0.001;\n    const float Threshold = 0.02;\n    float f = Soft/5.0;\n\tfloat a = Threshold - f;\n\tfloat b = Threshold + f;\n    float l = (tx.x + tx.y + tx.z) / 3.0;\n\t\n\tfloat v = smoothstep(a, b, l);\n\t\n\treturn vec4(v);\n\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    vec4 blurred = blur( iChannel0, U/iResolution.xy, 1./iChannelResolution[0].xy);\n    vec4 subbed = texture(iChannel0, U/iResolution.xy) - blurred;\n    O = threshold(subbed);\n    \n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//thanks to Fabrice Neyret for algorhitm https://www.shadertoy.com/view/llySRh\n//and thanks to otaviogood for font texture\n#define C(c) \n#define countdown 5.0\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel2, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    if (int(iTime / countdown) % 3 != 0) {\n        // From Game of Life\n        fragColor = texture(iChannel1, fragCoord/iResolution.xy);\n        return;\n    }\n        \n    // From Sobel\n    vec4 s = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    // Draw text\n    vec2 uv = fragCoord / iResolution.y;\n    vec2 position = vec2(0, 0);\n    float FontSize = 15.;\n    vec2 U = ( uv - position)*64.0/FontSize;\n    int sec = int(countdown) - int(mod(iTime, countdown));\n    fragColor = char(U, 48+sec);\n    fragColor = vec4(fragColor.x,fragColor.x,0.0,1.0);\n    fragColor += texture(iChannel0, fragCoord/iResolution.xy);\n    \n\n}\n\n\n//line 12 -> x,y coordinates of text, counted from left down corner\n//line 13 -> higher value = greater font size\n//line 15 -> Every argument is another char", "buffer_c_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//thanks to Fabrice Neyret for algorhitm https://www.shadertoy.com/view/llySRh\n//and thanks to otaviogood for font texture\n#define C(c) U.x-=.5; O+= char(U,48+c)\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nvoid mainImage( out vec4 O, vec2 uv )\n{\n    O = vec4(0.0);\n    uv /= iResolution.y;\n    vec2 position = vec2(.5);\n    float FontSize = 8.;\n    vec2 U = ( uv - position)*64.0/FontSize;\n    C(5 - int(mod(iTime, 5.0)));\n    O = O.xxxx;\n}\n\n\n//line 12 -> x,y coordinates of text, counted from left down corner\n//line 13 -> higher value = greater font size\n//line 15 -> Every argument is another char", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdSRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 116]], "test": "untested"}
{"id": "wtcBWf", "name": "Shader a day 1", "author": "MinimilisticBits", "description": "day 1", "tags": ["fractal", "abstract"], "likes": 8, "viewed": 292, "published": 3, "date": "1638856095", "time_retrieved": "2024-07-30T18:43:35.121526", "image_code": "vec2 rot(vec2 a, float c){\nfloat l = length(a);\na/=l;\nfloat ang = (a.y<0.)?acos(a.x):2.*3.14159 - acos(a.x);\nang += c;\nreturn vec2(l*cos(ang), l*sin(ang));\n}\n\nfloat DE(vec3 p0){\nvec4 p = vec4(p0, 1.);\nfor(int i = 0; i < 20; i++){\n\np*=5.2 + sin(iTime)*1.4;\np.xyz = mod(p.xyz-1.5, 3.)-1.5;\np.xyz -= vec3(0.4,0.2,0.1)*0.5;\np/=dot(p.xyz,p.xyz);\n}\n\nreturn length(p.xyz)/p.w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 a = vec3(0.2,0.5,0.3);\n    vec3 b = vec3(0.6,0.2,0.1);\n    vec3 c = vec3(0.2,0.1,0.4);\n    vec3 d = vec3(0.9,0.5,0.5);\n    vec3 color = a + b*cos(6.28318*(c*uv.y+d + iTime));\n   \n   \n   \n    uv = uv * 2.0 - 1.0;\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n   \n    uv = abs(uv);\n    uv = rot(uv, iTime*0.4);\n   \n    uv *= 10.;\n    float dist = DE((mod(vec3(uv.x, uv.y,1.), 12.)-6.)/20.)*20.;\n    vec3 col;\n    //if(dist < 0.01){\n    //col = vec3(1.);  \n   // }\n   col+=dist*0.9;\n    col-=color;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcBWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 157], [159, 159, 177, 177, 371], [373, 373, 430, 480, 1071]], "test": "untested"}
{"id": "stcXR7", "name": "Balanced Entropy", "author": "scry", "description": "https://youtu.be/DJ-6s62WcMo", "tags": ["3d", "raymarched", "psychedelic", "trippy"], "likes": 21, "viewed": 753, "published": 3, "date": "1638850552", "time_retrieved": "2024-07-30T18:43:36.180694", "image_code": "#define deg (3.14159/180.)\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n//rgb2hsv2rgb from https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// All components are in the range [01], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// All components are in the range [01], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n//from https://www.shadertoy.com/view/ttBXRG\nfloat staircase( in float x, in float k )\n{\n    float i = floor(x);\n    float f = fract(x);\n    \n    float a = 0.5*pow(2.0*((f<0.5)?f:1.0-f), k);\n    f = (f<0.5)?a:1.0-a;\n    \n    return i+f;\n}\n\n\nfloat bitm(vec2 uv,int c) {\n    float h = 5.;\n    float w = 3.;\n    int p = int(pow(2.,(w)));\n    float line1 = 9591.;\n    uv = floor(vec2(uv.x*w,uv.y*h))/vec2(w,w);\n    float c1 = 0.;\n    float cc = uv.x + uv.y*w;\n    c1 = mod( floor( float(c) / exp2(ceil(cc*w-0.6))) ,2.);\n    c1 *= step(0.,uv.x)*step(0.,uv.y);\n    c1 *= step(0.,(-uv.x+0.99))*step(0.,(-uv.y+1.6));\n    return (c1);\n}\n#define logo 1\nvec3 slogo(vec2 uv, float ar) {\n    if (logo == 0) {\n        return vec3(0.);\n    }\n    vec2 px = vec2(1./3.,1./5.);\n    float ls = 4.1;\n    uv.x = 0.993-uv.x;\n    uv *= 8.*ls;\n    ls += 2.;\n    float ul = length(uv);\n    uv -= px.yx*0.5*0.5*ls;\n    ul = length(vec2(uv.x*0.5,uv.y)-0.5);\n    uv.x *= ar*1.75;\n    int s = 29671;\n    int c = 29263;\n    int r = 31469;\n    int y = 23186;\n    uv.x= 5.-uv.x;\n    float b = bitm(uv,s);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,c);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,r);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,y);\n    float rr = step(0.,uv.x+px.x*13.)*step(0.,uv.y+px.y)*step(0.,(-uv.x+px.x*4.))*step(0.,(-uv.y+px.y*6.));\n    b = clamp(b,0.,1.);\n    //b = rr*floor(b);\n    float ptime = iTime;\n    vec3 l = hsv2rgb(vec3(b+ptime,0,rr-b*1.9))*rr;\n    //l -= length(uv)*0.5;\n    //l -= ul*rr*0.6;\n    l -= 0.1-clamp(ul*0.1,rr*1.-b,0.1);\n    //l -= 3.-ul*2;\n    //l = clamp(l,-1.,1.);\n    return vec3(l);\n}\n\n//iq sdbox and sdvertcalcapsule functions :)\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat abx(float a,float b) {\n    return abs(abs(a)-b)-b;\n}\n\nfloat dty(vec3 p, vec3 s) {\n    float ls = s.x;\n    float lr = s.y;\n    //p.zy *= r2d((3.14159/180.)*-sin(iTime+p.y*20));\n    //p.xy *= r2d((3.14159/180.)*iTime);\n    float d = sdBox(p+vec3(0.,0,0.),vec3(lr*1.));\n    //float d = sdVerticalCapsule(p+vec3(0.,ls/2,0.),ls,lr);\n    //float d = length(p)-0.001;\n    //d = length(p)-0.014;\n    return d;\n}\n\nvec4 fr(vec3 p) {\n    //p.z = 0.;\n    //float pfd = 0.95;\n    //p = (fract((p*pfd))-0.5)/pfd;\n    //p.xz *= r2d((3.14159/180.)*-90);\n    float st = iTime*0.2;\n    float sm = sin(st*10.)*0.5+0.5;\n    //sm = 0.;\n    //sm += sin(st*2.)*0.25;\n    //sm *= 1.;\n    float lp = length(p);\n    //sm += sin(st*1)*0.125;\n    //float lr = -0.001-sin(lp*20.+iTime)*0.0015;\n    float lr = 0.13;\n    float ls = 0.5;\n    //p *= 2.;\n    //ls += spectrum1.y*16.;\n    lr += 0.001;\n    float d = 10000.;\n    float u = 1.;\n\n    float lsm = 0.495;\n    vec3 dp = p;\n\n    float rt = iTime*2.;\n\n    float pd = 0.185;\n    //float pm = 1.-(sin(iTime)*0.5+0.5);\n    float pm = 1.;\n    //p *=  2.;\n    float tm = iTime;\n    tm *= 0.1;\n    float ia = -1.;\n    float pdm = sin(iTime*1.1+lp*dp.z*29.)*0.5+0.5;\n    pdm *= 0.2;\n    pdm += 0.3;\n    pdm = 0.5;\n    //p += sin(p*20.+iTime)/24.;\n    float lss = 2.8;\n    st += sin(st*2.)*0.25+sin(st*3.)*0.25;\n    int sps = 7;\n    vec3 rp = p;\n    //rp.xy *= r2d(deg*90*floor(iTime*8.));\n    //rp.xz *= r2d(deg*90*floor(iTime*20.3));\n    //sps += int(rp.x*15.);\n    //sps += (sin(iTime)*0.5+0.5)*10.; \n    sps = clamp(sps,1,18);\n    //lr = deg*15.;\n   lr = 0.2;\n   float ad = (sin(iTime*0.4+lp*29.)*0.5+0.5);\n    \n    for (int i=0;i<sps;i++) {\n    d = min(d,dty(p,vec3(ls,lr,0.)));\n    //d -= sin(d*80.)*0.005;\n    //p += sin(d*200.)*0.001;\n    \n    //d = min(d,dty(p.yxz,vec3(ls,lr,0.)));\n    //d = min(d,dty(p.xzy,vec3(ls,lr,0.)));\n    //p.x += 0.1;\n    ia += 1.;\n    //lr *= 2.9;\n    lr *= .5;\n    //lr += 0.000002;\n    //lr = sin(lr+iTime*0.1)*0.1+0.1;\n    //lr += 0.01;\n    //lr *= ia+0.0003;\n    pd *= u;\n    \n    p.yz *= r2d((3.14159/180.)*-45.);\n    p.zy = abs(p.zy);\n    //p.x = abs(p.x)-0.09;\n    \n    p.yz *= r2d((3.14159/180.)*+45.);\n    \n    p.xy *= r2d((3.14159/180.)*-45.);\n\n    p.xy = abs(p.xy)-pd;\n\n    pd *= pdm;\n    //pd *= sin(iTime*0.1+dp.z*2.)*0.5+0.5;\n\n    p.xy *= r2d((3.14159/180.)*+45.);\n    \n    //p = abs(p)-0.02;\n    \n    ls *= lsm;\n    ls += 0.002;\n    \n    }\n    //d += sin(p.z*200.)*0.001;\n    //p += iTime*0.1;\n    //dp.xy *= r2d((iTime*0.1));\n    //dp.xz *= r2d((iTime*0.3));\n    //p = fract(p*0.5)/0.5;\n    d = min(d,dty(p,vec3(ls,lr,0.)));\n    //p *= sin(p*10.)*0.5;\n    d += (sin(p.y*90.+iTime+dp.x*5.)*0.5+0.5)*0.1;\n    d += (sin(p.y*30.+iTime*0.2+dp.x*2.)*0.5+0.5)*0.1;\n    //d -= (sin(dp.y*7.+iTime*0.2)*0.5+0.5)*0.05;\n    d *= 0.5;\n    //d = min(d,dty(p.yxz,vec3(ls,lr,0.)));\n    //d = min(d,dty(p.xzy,vec3(ls,lr,0.)));\n\n    return vec4(p,d*0.5);\n}\n\n\nvec4 map(vec3 p) {\n    //p += 1.;\n    //p.xy *= r2d(1.);\n    //p.xz *= r2d(1.);\n    \n   \n    //p.xy += 2.;\n    //\n    vec3 c = p;\n    p.z -= 1.;\n    \n    //vec3 c = p;\n    float cd = 12.*(sin(iTime*0.002+5.)*0.5+0.5);\n    //c.z = (fract(c.z*cd))/cd;\n    float rt = iTime*0.1;\n    //p.xy *= r2d((3.14159/180.)*-45*iTime*9.);\n    //p = abs(p);\n    //p = abs(p+0.5);\n    p.yz *= r2d(deg*35.264);\n    p.xz *= r2d(-deg*90.);\n    //p.z += 0.5;\n    //p = abs(p)-0.5;\n    float pfd = 0.9;\n    //p = (fract((p-0.25)*pfd)-0.5)/pfd;\n    //p.xz *= r2d(.75);\n    //p += 0.89;\n    p.xy *= r2d(sin(rt*0.5)*0.5);\n    p.yz *= r2d(rt);\n\n    \n    float d = length(p)-3.;\n    //float env = d;\n    //float env = mix(d,sdBox(p,vec3(1.966)),0.001+sin(p.x*13.)*0.001);\n    float env = mix(d,sdBox(p,vec3(1.966)),0.002);\n    //p.xz *= r2d(-rt);\n    //p.z += iTime;\n    \n    //float pz = p.z;\n    vec4 frd = fr(p);\n    //d = sdf(p);\n    \n    //d = abs(d)-0.0008;\n    \n    \n    d = frd.w;\n    d = min(d,-env);\n    //float dl = (sin(iTime)*0.5+0.5)*0.1;\n    //d = abs(d+0.01)-0.01;\n    float dl = 0.001;\n    d = abs(d+dl)-dl;\n    //d = mix(d,(length(p)-0.28)*0.7,0.9);\n   // d = min(d,sdBox(p,vec3(0.3)));\n    c.z *= 2.;\n    d = max(d, -(length(c)-0.5));\n    //d = max(d, -(length(c)-01.2));\n    \n    return vec4(p,d);\n}\n\nvec3 calcNorm(vec3 p) {\n    //float eps = 0.01*(sin(p.z*0.1)*0.5+0.5);\n    float eps = 0.0008;\n    vec2 h = vec2(eps,0.);\n    return normalize(vec3(map(p-h.xyy).w-map(p+h.xyy).w,\n                          map(p-h.yxy).w-map(p+h.yxy).w,\n                          map(p-h.yyx).w-map(p+h.yyx).w));\n}\n\nfloat edges(vec3 p) {\n    float eps = 0.001;\n    //return calcNorm(p)\n    vec3 n1 = calcNorm(p*(1.-eps));\n    vec3 n2 = calcNorm(p*(1.));\n    return clamp(abs((n1.x+n1.y+n1.z)-(n2.x+n2.y+n2.z)),0.,1.);\n    //return (map(p+(eps)).w-map(p-(eps)).w)*18.;\n}\n\n\n#define render 0\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    int steps = 130;\n    //steps = int(steps*(sin(iTime)*0.5+0.5));\n    if (render == 1) {\n        steps = 150;\n    }\n    float d = 130.;\n    for (int i=0;i<steps;i++) {\n        vec3 p = ro+rd*dO;\n        //ro += calcNormL(p)*0.02;\n        //ro += lens(p).xyz*0.2;\n        float dS = map(p).w;\n        dO += dS*(d/float(steps));\n        //dO += dS*(100./float(steps))*(dO+2.)*0.15;\n        ii += 0.5*d/float(steps);\n        if (dO > 1000. || dS < 0.00009) {\n            break;\n        }\n    }\n    return vec2(dO,ii);\n}\n\nvec3 color(vec3 p, vec2 d) {\n    return vec3(p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 tv = fragCoord.xy / iResolution.xy;\n    \n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    //uv.x *= ar;\n    \n    uv -= 0.5;\n    uv.x *= ar;\n    float c= length(uv);\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.,0.,0);\n    //ro.z = -2.;\n    vec3 rd = normalize(vec3(uv,1.));\n    \n        vec3 bak = texture(iChannel0, tv).rgb;\n    float rn = noise(vec2(noise(fract(rd.xy*220.+iTime*0.01)*90.)*100.));\n    //if (rn > 0.2) {\n    //if (1 == 1) {\n    if (rn < clamp(c*.7,0.,1.0)+0.3 && render != 0) {\n        col = bak;\n        fragColor = vec4(col,1.0);\n        return;\n    }\n    \n    vec2 d = RM(ro,rd);\n    vec3 p = ro+rd*d.x;\n    vec4 mp = map(p);\n    vec3 n = calcNorm(p);\n    float lp = length(p);\n    \n    vec3 na = n;\n    //vec3\n\n    \n    vec2 dd = d;\n    float ga = 1.;\n    float time = iTime;\n    vec4 m = mp;\n    vec4 mr = mp;\n    vec3 b = vec3(0.);\n    float e = edges(p);\n    //e = clamp(e,0.,0.1)*8;\n    //col += d.x*ga*0.1;\n    //col += n*ga*0.1+d.y*ga*0.05;\n    //col += d.x*.1;\n    \n    for(int i=0;i<2;i++) {\n        if (d.x > 1000.) {\n            //col *= 0.;\n            ga = 0.;\n        }\n        //col += d.y*0.02*ga;\n        col += hsv2rgb(vec3(d.x+iTime*0.01,d.y*0.015,d.y*0.02*ga));\n        //col += (abs(e)*30.-0.3)*ga;\n        //col += n+d.y*0.1-2.;\n        //col += (n+d.y*0.1-2.+d.x*0.1)*ga;\n        //col += abs((n*1.8+d.y*0.05-2.+d.x*0.1))*ga;\n        //col += n*d.y*ga*0.01;\n        //col += n*ga;\n        //col += n*ga*d.x;\n        //col += vec3(d.x*0.1)*ga;\n        //col += d.x*ga*0.1;\n        //col += n*ga*0.1+d.y*ga*0.05;\n        ga *= .3;\n        //ga -= 0.2;\n        //ga *= 0.2;\n        ro = p-n*0.002;\n        rd = reflect(rd,n);\n        d = RM(ro,rd);\n        //b += d.x*0.02*ga;\n        p = ro+rd*d.x;\n        n = calcNorm(p);\n        e = edges(p);\n        mr = map(p);\n        //col += d.x*.1;\n        \n        //col += n*ga*0.1+d.y*ga*0.25;\n    }\n    //col += d.y*ga*0.01;\n    //col += e;\n    col += hsv2rgb(vec3(d.x,d.y*0.015,d.y*0.02*ga));\n    //col *= 0.6;\n    col = rgb2hsv(col);\n    col.x += 0.7;\n    //col.x += iTime;\n    col.y *= 1.2;\n    col.z -= dd.x*0.15;\n    col = hsv2rgb(col);\n    vec2 ttv = tv;\n    ttv -= 0.5;\n    //ttv *= 0.99;\n    ttv += 0.5;\n\n    col += slogo(ttv,ar)*.6;\n    vec2 ux = uv;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcXR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 46, 46, 95], [97, 251, 273, 273, 604], [606, 665, 687, 687, 856], [857, 870, 897, 897, 1014], [1016, 1103, 1129, 1129, 1646], [1648, 1693, 1736, 1736, 1886], [1889, 1889, 1916, 1916, 2275], [2291, 2291, 2322, 2322, 3238], [3240, 3285, 3316, 3316, 3403], [3405, 3405, 3458, 3458, 3517], [3519, 3519, 3547, 3547, 3577], [3579, 3579, 3606, 3606, 3928], [3930, 3930, 3947, 4062, 6431], [6434, 6434, 6452, 6547, 7726], [7728, 7728, 7751, 7798, 8024], [8026, 8026, 8047, 8047, 8279], [8299, 8299, 8326, 8326, 8883], [8885, 8885, 8913, 8913, 8935], [8937, 8937, 8992, 8992, 11337]], "test": "untested"}
{"id": "7t3XR7", "name": "fork a head", "author": "jorge2017a2", "description": "fork a head", "tags": ["forkahead"], "likes": 2, "viewed": 230, "published": 3, "date": "1638849985", "time_retrieved": "2024-07-30T18:43:37.507148", "image_code": "///------------image\n//por jorge2017a2-\n//referencia\n//fork---------------------https://www.shadertoy.com/view/Nly3Rz\n//https://www.shadertoy.com/view/ft3SRr\n//https://www.shadertoy.com/view/4l3SWf\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ; vec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{   float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) \n{   float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) \n{   float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{ float k0 = length(p/r);  float k1 = length(p/(r*r));  return k0*(k0-1.0)/k1;}\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{ float c = cos(phi);float s = sin(phi);return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);}\nvec3 rotate_y(vec3 p, float phi)\n{float c = cos(phi);float s = sin(phi);\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);}\nvec3 rotate_z(vec3 p, float phi)\n{float c = cos(phi);float s = sin(phi);\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);}\nvec2 rotatev2(vec2 p, float ang)\n{float c = cos(ang); float s = sin(ang); return vec2(p.x*c - p.y*s, p.x*s + p.y*c);}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0); \n    p.y=p.y-10.0;\n    vec3 p0=p;\n    \n\tfloat planeDist1 = p.y+10.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,-1.0,7.0)); //inf\n   \n     //cabeza \n    float dCabeza= sdEllipsoid( p- vec3(0.0,0.0,0.0), vec3(5.0,6.0,4.0) ) ;\n    p.x=abs(p.x)-1.5;\n    float dOjosHueco=sdEllipsoid(p-vec3(0.0,0.0,-2.5), vec3(1.5,1.5,1.5) );\n    dCabeza= opSmoothSubtraction( dOjosHueco, dCabeza, 0.35) ;\n\n    float t=iTime*2.0;\n    vec3 pos=vec3(0.0+0.3*sin(t),0.3*cos(t),0.0);\n    float  dIrisG=sdEllipsoid(p-vec3(0.0,0.0,-4.0)+pos, vec3(0.9,1.0,1.5) );\n    float  dPupilaCh=sdEllipsoid(p-vec3(0.0,0.0,-4.0)+pos*0.8, vec3(0.5,0.7,1.5) );\n\n    vec3 p2=p0;\n    float  dPupilaRefA=sdEllipsoid(p2-vec3(-1.7+0.25,0.25,-4.0)-vec3(pos.x,-pos.y,pos.z)*0.5, vec3(0.25,0.27,1.5) );\n    float  dPupilaRefB=sdEllipsoid(p2-vec3( 1.7-0.25,0.25,-4.0)+pos*0.5, vec3(0.25,0.27,1.5) );\n    \n    dIrisG= intersectSDF(dOjosHueco,dIrisG);\n    dPupilaCh= intersectSDF(dOjosHueco,dPupilaCh);\n    dPupilaRefA= intersectSDF(dOjosHueco,dPupilaRefA);\n    dPupilaRefB= intersectSDF(dOjosHueco,dPupilaRefB);\n    \n    p=p0;\n    float dBocaHueco=sdEllipsoid(p-vec3(0.0,-3.0,-3.0), vec3(1.5,0.8+0.3*sin(iTime),1.5) );\n    float dBocaDif=sdEllipsoid(p-vec3(0.0,-3.0,-1.5), vec3(2.5,1.0,1.6) );\n    float dBocaFondo=sdEllipsoid(p-vec3(0.0,-3.0,-1.0), vec3(2.5,1.0,1.5) );\n    float dBocaDientesA=sdEllipsoid(p-vec3(-0.5,-2.3,-1.5), vec3(0.5,0.85,1.5) );\n    float dBocaDientesB=sdEllipsoid(p-vec3( 0.0,-2.3,-1.5), vec3(0.5,0.95,1.5) );\n    float dBocaDientesC=sdEllipsoid(p-vec3( 0.5,-2.4,-1.5), vec3(0.5,0.85,1.5) );\n\n    dCabeza= opSmoothSubtraction( dBocaHueco,dCabeza, 0.35) ;\n    dCabeza= differenceSDF(dCabeza,dBocaDif);\n\n    vec3 prn=rotate_x(p-vec3(0.,-1.0,-2.7), radians(-30.0));\n    float dNariz= sdRoundBox(prn, vec3(0.065,0.8,1.5), 0.25 );\n    dCabeza= opSmoothUnion( dCabeza, dNariz, 0.25 ) ;\n    res =opU3(res, vec3(dCabeza,33.0,-1.0));\n    res =opU3(res, vec3(dOjosHueco,1.0,-1.0));\n    res =opU3(res, vec3(dIrisG,-1.0,10.0));\n    res =opU3(res, vec3(dPupilaCh,0.0,-1.0));\n    res =opU3(res, vec3(dPupilaRefA,1.0,-1.0));\n    res =opU3(res, vec3(dPupilaRefB,1.0,-1.0));\n    res =opU3(res, vec3(dBocaFondo,0.0,-1.0));\n    res =opU3(res, vec3(dBocaDientesA,1.0,-1.0));\n    res =opU3(res, vec3(dBocaDientesB,1.0,-1.0));\n    res =opU3(res, vec3(dBocaDientesC,1.0,-1.0));\n\n    //pelo\n    p=p0;\n    float dpelo1=sdTorus( p.xzy-vec3(0.0,-2.5,-0.5), vec2(5.0,0.3) );\n    vec3 pr1=rotate_y(p, radians(-10.0));\n    float dpelo2=sdTorus( pr1.xzy-vec3(0.0,-1.5,-1.5), vec2(7.0,0.28) );\n    vec3 pr2=rotate_y(p, radians(10.0));\n    float dpelo3=sdTorus( pr2.xzy-vec3(0.0,-1.5,-1.5), vec2(7.0,0.28) );\n    \n    float dpelodif= sdBox( p- vec3(0.0,-5.5,0.0), vec3(8.0,3.0,3.0) );\n    dpelo1= differenceSDF(dpelo1,dpelodif);\n    dpelo2= differenceSDF(dpelo2,dpelodif);\n    dpelo3= differenceSDF(dpelo3,dpelodif);\n    res =opU3(res, vec3(dpelo1,2.0,-1.0));\n    res =opU3(res, vec3(dpelo2,5.0,-1.0));\n    res =opU3(res, vec3(dpelo3,6.0,-1.0));\n    \n    //ceja\n    p.x=abs(p.x)-2.0;\n    float dCeja= sdBox( p-vec3(0.0,2.0,-2.0), vec3(1.0,0.125,2.0) );\n    dCeja= intersectSDF(dCeja,dCabeza);\n    \n    res =opU3(res, vec3(dCeja,0.0,-1.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 nor = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    nor= normalize(nor);\n    return nor;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n        {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; }         \n        t += dS.x;\n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nfloat FakeSoftShadow(float result, vec3 LightPos,vec3 point,vec3 normal)\n{    vec3 shadowOffset = normal * 0.2 ;\n    //float result = 0.2;\n    int epoch = 5;\n    float delta = result/float(epoch);\n    float lightOffset = 0.2;\n    \n    for(int i = 0; i<epoch; i++)\n    {\n        vec3 tmp = LightPos +vec3(0,0,i)*lightOffset;\n        float dis=RayMarch(point + shadowOffset,normalize(tmp-point), int( MAX_DIST));\n        if (dis< length(tmp-point))\n        {\n            result -= delta;\n        }\n    }\n    return result;\n}\n\n// util\n#define saturate(x) clamp(x, 0.0, 1.0)\nfloat calcAo(in vec3 p, in vec3 n)\n{\n    float k = 1.0, occ = 0.0;\n    for(int i = 0; i < 5; i++){\n        float len = 0.15 + float(i) * 0.15;\n        float distancee = GetDist(n * len + p).x;\n        occ += (len - distancee) * k;\n        k *= 0.5;\n    }\n    return saturate(1.0 - occ);\n}\n\n//----------------------------------------------------\n//https://www.shadertoy.com/view/ft3SRr\n//y\n//https://www.shadertoy.com/view/4l3SWf\nvec3 Shading(vec3 LightPos, vec3 pos, vec3 ro, vec3 baseColor)\n{\n    //ro=eye\n    float roughness=0.5;\n    float alpha = roughness*roughness;\n    vec3 L = normalize(LightPos - pos);\n    vec3 V = normalize(ro - pos);\n    vec3 N = GetNormal(pos);\n    vec3 H = normalize(L+V);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotNL = clamp (dot (N, L), 0.0, 1.0);\n\tfloat dotNV = clamp (dot (N, V), 0.0, 1.0);\n\tfloat dotNH = clamp (dot (N, H), 0.0, 1.0);\n\tfloat dotLH = clamp (dot (L, H), 0.0, 1.0);\n    \n    float reflectance=0.0125;\n    float metalMask=0.23;\n    vec3 F0 = 0.16*reflectance*reflectance * (1.0-metalMask) + baseColor*metalMask;\n    \n    float Ambient = 0.1;\n    float D, vis=1.0;\n    vec3 F;\n    // Fresnel (Schlick)\n\tfloat dotLH5 = pow (1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n     \n    // NDF : GGX\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.1415926535;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr / (pi * denom * denom);\n   \n    float result = max(dotNL,0.0)*0.5 + pow(max(dotNH,0.0),20.)*0.9;\n    result = FakeSoftShadow(result, LightPos,pos,N);\n    \n    vec3 specular =  D * F * vis;  \n      return (result+Ambient)*baseColor+specular;    \n    \n    \n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    vec3 col= Shading(plight_pos,p,ro,colobj);\n    return col;\n}\n\n\nvec3 render_sky_color(vec3 rd)\n{return vec3(0.0);}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==7.0)\n    {return pattern( p.xz );}\n        if (id_material==8.0)\n        {return pattern( p.xy );}\n            if (id_material==9.0)\n            {return pattern( p.zy );}\n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5); colobj*=getMaterial(p, id_material); return colobj;}\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2)*light_color2;\n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);    \n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n// Tone mapping\n\n// See: http://filmicgames.com/archives/75\nvec3 Uncharted2ToneMapping(vec3 color)\n{\n    float gamma = 2.2;\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n\tfloat exposure = 0.012;\n\tcolor *= exposure;\n\tcolor = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n\tfloat white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n\tcolor /= white;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n\n \tlight_pos1= vec3(5.0, 10.0, -10.0 );    light_color1=vec3(0.6,0.3,0.1);\n \tlight_pos2= vec3( -10.0, 30.0, -10.0 ); light_color2 = vec3(0.3,0.6,0.6);\n   vec3 ro=vec3(0.0,10.0,-15.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n\n    //light_pos1+=ro;\n    ///light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    col+=Uncharted2ToneMapping(col);\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "//--------------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3XR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[595, 595, 631, 631, 652], [653, 653, 685, 685, 769], [770, 770, 816, 816, 903], [904, 904, 938, 938, 1000], [1001, 1001, 1040, 1040, 1135], [1136, 1136, 1175, 1175, 1270], [1271, 1271, 1310, 1310, 1405], [1407, 1407, 1460, 1460, 1557], [1559, 1559, 1618, 1618, 1716], [1718, 1718, 1778, 1778, 1875], [1877, 1877, 1914, 1914, 1992], [1994, 2038, 2085, 2085, 2112], [2113, 2113, 2156, 2156, 2183], [2184, 2184, 2232, 2232, 2260], [2262, 2287, 2321, 2321, 2408], [2409, 2409, 2443, 2443, 2530], [2531, 2531, 2565, 2565, 2652], [2653, 2653, 2687, 2687, 2770], [2772, 2772, 2797, 2797, 6036], [6038, 6038, 6062, 6062, 6242], [6244, 6244, 6293, 6293, 6928], [6930, 6930, 6966, 6966, 7211], [7213, 7213, 7287, 7287, 7735], [7784, 7784, 7820, 7820, 8072], [8074, 8213, 8277, 8290, 9424], [9426, 9426, 9506, 9506, 9611], [9614, 9614, 9646, 9646, 9664], [9666, 9714, 9742, 9742, 9930], [9932, 9932, 9979, 9979, 10222], [10224, 10276, 10369, 10369, 10676], [10678, 10678, 10709, 10709, 11328], [11330, 11330, 11356, 11356, 11466], [11468, 11468, 11526, 11526, 11578], [11596, 11639, 11679, 11679, 12117], [12120, 12169, 12226, 12226, 12806]], "test": "untested"}
{"id": "7tG3Dm", "name": "cyclic nyancat", "author": "cyperus", "description": "cyclic Nyancat", "tags": ["nyancat"], "likes": 11, "viewed": 315, "published": 3, "date": "1638840874", "time_retrieved": "2024-07-30T18:43:38.462593", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"cyclic nyancat\" created by Colling Patrik (cyperus) in 2021\n//\n// References:\n// - \"Nyancat\" by mu6k https://www.shadertoy.com/view/4dXGWH\n//\n////////////////////////////////////////////////////////////////////////////////\n\n#define COMPLEX\n\nconst float\n    period = 10., // animation loop time in seconds\n    scale  = 7.,  // nyancat inside cell\n    fl_height = scale * 0.03; // floor hight\n\nvec4 stars(vec2 p, float time) {\n\tvec4 color = vec4(0);\n\tvec2 ps;\n\tfloat stars; float ss = 0.04, s1 = 16.;\n    \n\tfor (float i = 1.; i < 7.; i++) {\n        time /= i; ps = i*p;\n\t\tps = ps + time*vec2(1, 0) - mod(ps + vec2(time,i*s1) ,vec2(ss));\n        \n\t\tstars = noise(s1 * ps);\n        \n\t\tif (stars > 0.98) {\n            color = vec4(1);\n        }       \n\t}   \n\treturn color;\n}\n\nvec4 nyancat(vec2 z, vec2 z0, float scale, float time) {\n    z = scale * vec2(fract(z.x - time) , z.y); z -= z0;\n    return ((0. < z.x && z.x < 0.9) && (0. < z.y && z.y < 0.6))\n    ? texture(iChannel0, \n        vec2(40./256. * (z.x + floor(6. * fract(3. * scale * time))), z.y + 0.2 ))\n    : vec4(0.);\n}    \n\nvoid mainImage( out vec4 O, in vec2 U ) {\n    float ntime = iTime/period,\n          PI2ntime = PI2*ntime;\n    \n\n    vec2 uv = (2.*U.xy-R.xy)/R.x; // uv.x  [-1, 1.], uv.y  [-R.y/R.x, R.y/R.x];\n\n   // vec2 uv = U.xy/R.x; // uv.x  [0., 1.], uv.y  [0., R.y/R.x];\n\n    \n    // complex stuff! \n    #ifdef COMPLEX\n    uv = crpt(2.* uv, .0*PI2ntime * .25, 2, .7 +.1*cos(PI2ntime*.15));\n    uv = crpt(2.* uv, .3*PI2ntime * -.5, 3,    1.4*sin(PI2ntime*.25));\n    \n    uv.xy = uv.yx;\n    uv = cinv(uv);\n    #endif\n    \n    uv.y = abs(uv.y); // mirror along x-axis\n    \n    // draw texture\n    float sdf, px;\n    vec4 C = vec4(0); O = C;\n    \n    // nyancat\n    #if 1\n    if(O.a<1.) {\n        C = nyancat(uv, vec2(0., fl_height), scale, ntime);\n        C.rgb = pow(C.rgb, vec3(2.2));\n        O += (1.-O.a) * vec4( C.rgb, 1 ) * C.a;\n    }\n    #endif\n    \n    // ball\n    #if 1\n    if(O.a<1.) {\n        float ba_r = 0.1;\n        vec2 ba_uv  = scale * vec2(fract(uv.x - ntime), uv.y ); // NOTE 0: #fract() creats artefacts\n             ba_uv -= vec2(1.2, fl_height + ba_r + 0.2 * abs(cos(PI2ntime * scale)));\n        sdf = sdCircle(ba_uv, ba_r);\n        px = fwidth(sdf);\n        px = px > 1. ? 0.: px; // NOTE 0: Eliminate artefact. Don't know exactly why it works. It was a guess.\n        C = vec4(1.2 * vec3(.8,.2,0.), S(sdf, px));\n        O += (1.-O.a) * vec4( C.rgb, 1 ) * C.a;\n    }\n    #endif\n        \n    // floor\n    #if 1\n    if(O.a<1.) {\n        vec2 fl_uv = scale * uv;       \n        sdf = sdPlane( fl_uv, vec2(0.,1.), - fl_height);       \n        px = fwidth(sdf);\n        C = vec4(0.9 * h2rgb(uv.x), S(sdf, px));\n        O += (1.-O.a) * vec4( C.rgb, 1 ) * C.a;\n    }   \n    #endif\n    \n    // stars\n    #if 1\n    if(O.a<1.) {\n        C = stars(10. * uv, 5. * ntime);\n        O += (1.-O.a) * vec4( C.rgb, 1 ) * C.a;\n    }\n    #endif\n    \n    // background\n    #if 1\n    if(O.a<1.) {\n        C = vec4(mix(vec3(0.0,0.1,0.7),vec3(0.8,0.8,0.0), sqrt(uv.y)), 1.);\n        O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;\n    }   \n    #endif\n       \n    // gamma\n    O = vec4(pow(O.rgb, vec3(1./2.2)), 1.);\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "# define R iResolution\n\nconst float\n    PI = abs(atan(0.,-1.)),\n    PI2 = 2.*PI;\n\n// complex\nvec2 cmul(vec2 za,vec2 zb) {\n    return za*mat2(zb.x,-zb.y,zb.yx);\n}\n\nvec2 cinv(vec2 z) {\n    return vec2(z.x,-z.y)/dot(z,z);\n}\n\nvec2 cdiv(vec2 za, vec2 zb) {\n    return cmul(za,cinv(zb));\n}\n\nvec2 cpow(vec2 z, int n) {\n    vec2 w = z;\n    for (int i = 1; i < abs(n); i++) {\n        w = cmul(w,z);\n    }\n    return w;\n}\n\nvec2 crot(vec2 z,float a) {\n    return cmul(z, vec2(cos(-a),sin(-a)));\n}\n\nvec2 crpt(vec2 z,float a, int n, float x0) {\n\treturn cpow(crot(z, a), n) - vec2(x0, 0.);\n}\n\n// noise\nfloat hash(float x) {\n\treturn fract(sin(x*.0127863)*17143.321);\n}\n\nfloat hashmix(float x0, float x1, float interp) {\n\tx0 = hash(x0);\n\tx1 = hash(x1);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(0.0,1.0,interp);\n\t#endif\n\treturn mix(x0,x1,interp);\n}\n\nfloat hashmix(vec2 p0, vec2 p1, vec2 interp) {\n\tfloat v0 = hashmix(p0[0]+p0[1]*128.0,p1[0]+p0[1]*128.0,interp[0]);\n\tfloat v1 = hashmix(p0[0]+p1[1]*128.0,p1[0]+p1[1]*128.0,interp[0]);\n\tinterp = smoothstep(vec2(0.0),vec2(1.0),interp);\n\treturn mix(v0,v1,interp[1]);\n}\n\nfloat noise(vec2 p) {\n\tvec2 pm = mod(p,1.0);\n\tvec2 pd = p-pm;\n\treturn hashmix(pd,(pd+vec2(1.0,1.0)), pm);\n}\n\n// sdf\nfloat sdPlane( vec2 p, vec2 n, float h ) {\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdCircle( vec2 p, float r ) {\n    return length(p) - r;\n}\n\n// smooth\nfloat S(float sdf, float pix) {\n    return smoothstep(pix, -pix, sdf);\n}\n\n// color\nvec3 h2rgb(float h) {\n    return .6 * (1.+cos(PI2*(h+vec3(0,1,2)/3.)));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tG3Dm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[573, 573, 605, 605, 950], [952, 952, 1008, 1008, 1255], [1261, 1261, 1302, 1302, 3364]], "test": "untested"}
{"id": "slcSRM", "name": "Watercolor Vignette", "author": "FroggerGuy", "description": "A Simple effect I created =D", "tags": ["watercolornoisevingettesimple"], "likes": 6, "viewed": 478, "published": 3, "date": "1638834216", "time_retrieved": "2024-07-30T18:43:39.285393", "image_code": "#define M_PI 3.14159265358979323846\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n\nfloat simp(vec2 uv) {\n    uv *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n    f = 0.2 + 0.8*f;\n    return f;\n}\n\n\nvec4 bumpFromDepth(vec2 uv, vec2 resolution, float scale) {\n  vec2 step = 1. / resolution;\n    \n  float height = simp(uv);\n    \n  vec2 dxy = height - vec2(\n      simp(uv + vec2(step.x, 0.)), \n      simp(uv + vec2(0., step.y))\n  );\n    \n  return vec4(normalize(vec3(dxy * scale / step, 1.)), height);\n}\n\nvec4 bumpFromTex(vec2 uv, vec2 resolution, float scale) {\n  vec2 step = 1. / resolution;\n    \n  float height = simp(uv);\n    \n  vec2 dxy = height - vec2(\n      length(texture(iChannel0, uv + vec2(step.x, 0.))), \n      length(texture(iChannel0, uv + vec2(0., step.y)))\n  );\n    \n  return vec4(normalize(vec3(dxy * scale / step, 1.)), height);\n}\n\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 offset = bumpFromDepth(uv + vec2(floor(iTime*4.0)/4.0), iResolution.xy, .1)/80.0;\n    \n\n    // Output to screen\n                 texture(iChannel0, uv + offset.xy)*0.4;\n     \n                 \n    fragColor = (texture(iChannel0, uv + offset.xy)*0.4) + (texture(iChannel0, uv)*0.6);\n    fragColor += length(bumpFromDepth(uv, iResolution.xy, .1))*0.25;\n    fragColor += smoothstep(-0.4, 0.0, sdRoundedBox((uv + offset.xy) - vec2(0.5), vec2(0.65), vec4(0.25)));\n    \n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcSRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 93, 93, 208], [210, 210, 236, 236, 715], [718, 718, 739, 739, 988], [991, 991, 1050, 1050, 1292], [1294, 1294, 1351, 1351, 1637], [1640, 1640, 1695, 1695, 1852], [1854, 1854, 1911, 1961, 2476]], "test": "untested"}
{"id": "NlcSR7", "name": "copy_star", "author": "pc6270", "description": "star from https://www.shadertoy.com/view/4tyfWy", "tags": ["star"], "likes": 10, "viewed": 294, "published": 3, "date": "1638820142", "time_retrieved": "2024-07-30T18:43:40.149084", "image_code": "float cheap_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    uv *= 2.0 * ( cos(iTime * 2.0) -2.5);\n    \n    // anim between 0.9 - 1.1\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;    \n\n    fragColor = vec4(cheap_star(uv,anim) * vec3(0.35,0.2,0.15), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcSR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 185], [187, 187, 244, 244, 511]], "test": "untested"}
{"id": "sdKGz3", "name": "fire Sun", "author": "pc6270", "description": "color adjust from https://www.shadertoy.com/view/ltBfDt", "tags": ["fire"], "likes": 9, "viewed": 377, "published": 3, "date": "1638819950", "time_retrieved": "2024-07-30T18:43:41.182321", "image_code": "precision highp float;\n\n\n\nfloat random (in vec2 p) { \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3. - 2.0 * f);\n\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1. - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nfloat light(in vec2 pos,in float size,in float radius,in float inner_fade,in float outer_fade){\n\tfloat len = length(pos/size);\n\treturn pow(clamp((1.0 - pow( clamp(len-radius,0.0,1.0) , 1.0/inner_fade)),0.0,1.0),1.0/outer_fade);\n}\n\n\nfloat flare(in float angle,in float alpha,in float time){\n\tfloat t = time;\n    float n = noise(vec2(t+0.5+abs(angle)+pow(alpha,0.6),t-abs(angle)+pow(alpha+0.1,0.6))*7.0);\n   //\tn = 1.0;\n    float split = (15.0+sin(t*2.0+n*4.0+angle*20.0+alpha*1.0*n)*(.3+.5+alpha*.6*n));\n   \n    float rotate = sin(angle*20.0 + sin(angle*15.0+alpha*4.0+t*30.0+n*5.0+alpha*4.0))*(.5 + alpha*1.5);\n   \n    float g = pow((2.0+sin(split+n*1.5*alpha+rotate)*1.4)*n*4.0,n*(1.5-0.8*alpha));\n\t\n    g *= alpha * alpha * alpha * .5;\n\tg += alpha*.7 + g * g * g;\n\treturn g;\n}\n\n#define SIZE 2.8\n#define RADIUS 0.07\n#define INNER_FADE .85\n#define OUTER_FADE 0.02\n#define SPEED .1\n#define BORDER 0.19\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5)/iResolution.y;\n\tfloat f = .0;\n    float f2 = .0;\n    float t = iTime * SPEED;\n\tfloat alpha = light(uv,SIZE,RADIUS,INNER_FADE,OUTER_FADE);\n\tfloat angle = atan(uv.x,uv.y);\n    float n = noise(vec2(uv.x*20.+iTime,uv.y*20.+iTime));\n   \n\tfloat l = length(uv);\n\tif(l < BORDER){\n        t *= .8;\n        alpha = (1. - pow(((BORDER - l)/BORDER),0.22)*0.7);\n        alpha = clamp(alpha-light(uv,0.2,0.0,1.3,.5)*.55,.0,1.);\n        f = flare(angle*1.0,alpha,-t*.5+alpha);\n        f2 = flare(angle*1.0,alpha*1.2,((-t+alpha*.5+0.38134)));\n\n\t}else if(alpha < 0.1){\n\t\tf = alpha;\n\t}else{\n\t\tf = flare(angle,alpha,t)*1.3;\n\t}\n\tfragColor = vec4(vec3(f*1.5+f2*f2,f*alpha*0.5+f2*f2*.5,f*alpha*0.0+f2*(sin(angle-t*.5)*.0)),.5);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKGz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 52, 52, 173], [175, 175, 202, 202, 584], [586, 586, 681, 681, 815], [818, 818, 875, 875, 1364], [1488, 1488, 1543, 1543, 2303]], "test": "untested"}
{"id": "ft3XzM", "name": "Painting with maths", "author": "gubebra", "description": "Simple shader that gives an effect of painting. https://gubebra.itch.io/", "tags": ["cineshader"], "likes": 15, "viewed": 4699, "published": 3, "date": "1638816978", "time_retrieved": "2024-07-30T18:43:42.266423", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    for (float i = 2.0; i < 13.0; i++)\n    {\n        uv.x += 0.4 / i * cos(i * 2.0 * uv.y + iTime) * cos(i * 1.5 * uv.y + iTime);\n        uv.y += 0.4 / i * cos(i * 2.0 * uv.x + iTime);\n    }\n    \n    vec3 col = cos(iTime / 4.0 - uv.xyx);\n    col = step(0.0, col);\n    col.b = col.g;\n    \n    // alpha for cineshader\n    float alpha = 0.0;\n    if (col.g > 0.0 || col.r > 0.0) alpha = 0.6;\n    \n    fragColor = vec4(col, alpha);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Painting with maths\",\n\t\"description\": \"Simple shader that gives an effect of painting. https://gubebra.itch.io/\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3XzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 575]], "test": "untested"}
{"id": "fttXRN", "name": "Branchless Voxel Raycasting Tex", "author": "theraot", "description": "This is yet another recreation of https://www.shadertoy.com/view/4dX3zl based on https://www.shadertoy.com/view/7dK3D3.", "tags": ["3d", "raytracing", "raycasting", "voxel", "fork", "dda", "textured"], "likes": 10, "viewed": 532, "published": 3, "date": "1638816219", "time_retrieved": "2024-07-30T18:43:43.171004", "image_code": "#define PI 3.1415926\n\n// Helper functions for the camera transform\n\nmat4 rotate_xz(float t)\n{\n    return mat4(\n        cos(t) , 0.0, sin(t), 0.0,\n        0.0    , 1.0, 0.0   , 0.0,\n        -sin(t), 0.0, cos(t), 0.0,\n        0.0    , 0.0, 0.0   , 1.0\n    );\n}\n\nmat4 translate (vec3 v)\n{\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                v.x, v.y, v.z, 1.0); \n}\n\n// Helper functions for voxel geometry\n\nfloat sdSphere(vec3 p, float d)\n{ \n    return length(p) - d;\n} \n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat getVoxel(vec3 c) {\n\tvec3 p = c + vec3(0.5);\n\tfloat d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 25.0));\n    return step(0.0, -d);\n}\n\n// Main\n\n#define MAX_RAY_STEPS 128\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Basic setup:\n    float aspect = iResolution.x / iResolution.y;\n    vec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0; \n    vec3 rayDir = normalize(vec3(screenPos.x, screenPos.y * (1.0/aspect), 1.0));\n    vec3 rayPos = vec3(0.0, 0.0, 0.0);\n    \n    // Camera transform:\n    float verticalOscilation = sin(iTime * 2.7) * 0.0;\n    float orbitDistance = 14.0;\n    float orbitAngle = (iTime / 5.0);\n    mat4 cam_position = translate(vec3(0.0, verticalOscilation, orbitDistance));\n    mat4 orbit = rotate_xz(orbitAngle);\n    mat4 look = rotate_xz(orbitAngle + PI);\n    rayPos = (orbit * cam_position * vec4(rayPos, 1.0)).xyz;\n    rayDir = (look * vec4(rayDir, 1.0)).xyz;\n\n    // Voxel traversal setup:\n    vec3 raySgn = sign(rayDir);\n    vec3 next = floor(rayPos) + clamp(raySgn, 0.0, 1.0);\n    vec3 lengthBetween = raySgn / rayDir;\n    \n    // Vext traversal (first step unrolled):\n    vec3 current = rayPos;\n    vec3 lengthToNext = (next - rayPos) / rayDir;\n    float voxel = getVoxel(floor(current));\n    vec3 mask = step(0.0, min(lengthToNext.yzx, lengthToNext.zxy) - lengthToNext.xyz);   \n    vec3 lastMask; // This allows me to keep the last mask even without shortcircuiting the loop.\n    \n    for (int i = 0; i < MAX_RAY_STEPS; i++)\n    {\n        vec3 effectiveMask = (1.0 - voxel) * mask;\n        current += effectiveMask * raySgn;\n        lengthToNext += effectiveMask * lengthBetween;\n        voxel = sign(voxel + getVoxel(floor(current)));\n        // if (voxel == 1.0) break;\n        mask = step(0.0, min(lengthToNext.yzx, lengthToNext.zxy) - lengthToNext.xyz);\n        lastMask = mask * (1.0 - voxel) + lastMask * (voxel);\n    }\n    \n    // Correct position (the above code does integer steps):\n    lengthToNext = lengthToNext - lastMask * lengthBetween; // Step back once\n    float traversedLength = min(lengthToNext.x, min(lengthToNext.y, lengthToNext.z));\n    current = rayPos + rayDir * traversedLength;\n    \n    // Compute UV (we use the fractional part of the position): \n    vec3 f = current - floor(current);\n    vec2 uv = lastMask.x * f.yz + lastMask.y * f.xz + lastMask.z * f.xy;\n\n    // Texture:\n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    // Shade: \n    color *= vec3(dot(lastMask, vec3(0.5, 1.0, 0.75)));\n    \n    // Fog:\n    vec3 fogcolor = vec3(0.25, 0.4, 0.5);\n    color *= mix(fogcolor, color, exp(-traversedLength * traversedLength / 200.0));\n    \n    // Output:\n\tfragColor.rgb = color;\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttXRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 93, 93, 258], [260, 260, 285, 285, 433], [475, 475, 508, 508, 537], [540, 540, 571, 571, 662], [664, 664, 688, 688, 822], [860, 860, 917, 937, 3359]], "test": "untested"}
{"id": "NttSRN", "name": "Simple tiles v2.0", "author": "theraot", "description": "Simple square tiles with mod\n\n- Solved edge cross color\n- Simpler math", "tags": ["tiles"], "likes": 0, "viewed": 605, "published": 3, "date": "1638800468", "time_retrieved": "2024-07-30T18:43:43.992807", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy;\n    float size = 1.0/8.0;   // size of the tile\n    float edge = size/32.0; // size of the edge\n    float face_tone = 0.9; // 0.9 for the face of the tile\n    float edge_tone = 0.5; // 0.5 for the edge\n    uv = sign(vec2(edge) - mod(uv, size));\n    fragColor = vec4(face_tone - sign(uv.x + uv.y + 2.0) * (face_tone - edge_tone));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NttSRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 429]], "test": "untested"}
{"id": "stcSRN", "name": "Some nice background ", "author": "MrOkiDoki", "description": "No color bandings, I didn't know you could remove them so easily. Thank you iq ! ", "tags": ["colorbandingremoval"], "likes": 2, "viewed": 297, "published": 3, "date": "1638778015", "time_retrieved": "2024-07-30T18:43:44.876444", "image_code": "//Taken from iq: https://www.shadertoy.com/view/sl3XRn\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // background\n    vec3 col = vec3(0.15) - 0.04*length(p);\n    \n    // cheap dither (color banding removal)\n    col += (1.0/512.0)*sin(fragCoord.x*2.0+13.0*fragCoord.y);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcSRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 113, 113, 388]], "test": "untested"}
{"id": "ft3XzN", "name": "Mosaic fractal 2", "author": "jarble", "description": "A fractal with mosaic-like patterns.", "tags": ["fractal", "mosaic"], "likes": 11, "viewed": 389, "published": 3, "date": "1638765382", "time_retrieved": "2024-07-30T18:43:45.721185", "image_code": "//change these constants to get different patterns!\n#define c1 vec3(2.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 36.*16.;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    for(int i=0;i<6;i++)\n    {\n        vec2 t2 = vec2(0.);\n        for(int k = 0; k < 9; k++){    \n            uv += (t2.yx)/(scale);\n            //uv += (t2.yx)/(scale-col.x/scale);\n            t2 = triangle_wave(uv.yx-.5,scale)*scale;\n            vec2 t3 = triangle_wave(uv,scale)/scale;\n            uv.yx = -(t2+t3);\n        }\n        col.x = abs(uv.y-uv.x+col.x);\n        col = col.yzx;\n    }\n    fragColor = vec4(col,1.0);   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3XzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 120, 120, 165], [167, 167, 224, 224, 855]], "test": "untested"}
{"id": "stGGzz", "name": "Kaleidocycles", "author": "amhall", "description": "Traveling through spinning kaleidocycles with a kaleidoscope sky. Variable number of tetrahedron pairs. Mouse to move/rotate.", "tags": ["3d", "raymarching", "mouse", "kaleidoscope", "tetrahedron", "kaleidocycle"], "likes": 21, "viewed": 607, "published": 3, "date": "1638765001", "time_retrieved": "2024-07-30T18:43:48.683266", "image_code": "// A kaleidocycle is created by attaching an even number of tetrahedrons by their\n// edges in a ring. Try changing the number of tetrahedron pairs.\n// Created by Anthony Hall\n\n#define PAIRS 5\n#if PAIRS < 4\n#error\n#endif\n\nconst float pi = radians(180.0);\nconst float twoPi = radians(360.0);\nconst float radialSlice = twoPi / float(PAIRS);\n\nconst float maxDistance = 80.0;\nconst float epsilon = 0.004;\n\n// Many of these globals are set/modified in mainImage\nvec3 cameraPos = vec3(0.0);\nvec3 cameraDest = vec3(0.0, 0.0, -15.0); // z is relative to cameraPos\nconst float fov = radians(50.0); // FOV of y axis\n\n// Transforms the point evaluating the SDF\nmat4 sceneTransform = mat4(1.0);\n\n// Transforms actual points on the tetrahedron\nmat4 forwardTransform = mat4(1.0);\n\n// Must be strictly greater than 2sqrt6 (4.899)\nconst float zRepeat = 15.0;\n\nfloat time;\n\nfloat linestep(float a, float b, float x)\n{\n    return clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\nmat2 rotate(float theta)\n{\n    vec2 cs = vec2(cos(theta), sin(theta));\n    return mat2(\n        cs.x, cs.y,\n        -cs.y, cs.x);\n}\n\nmat4 translate(vec3 offset)\n{\n    return mat4(\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        offset, 1);\n}\n\nmat4 xyRotate(float theta)\n{\n    vec2 cs = vec2(cos(theta), sin(theta));\n    return mat4(\n        cs.x, cs.y, 0, 0,\n        -cs.y, cs.x, 0, 0,\n        0, 0, 1, 0,\n        0, 0, 0, 1);\n}\n\nmat4 yzRotate(float theta)\n{\n    vec2 cs = vec2(cos(theta), sin(theta));\n    return mat4(\n        1, 0, 0, 0,\n        0, cs.x, cs.y, 0,\n        0, -cs.y, cs.x, 0,\n        0, 0, 0, 1);\n}\n\nmat4 xzRotate(float theta)\n{\n    vec2 cs = vec2(cos(theta), sin(theta));\n    return mat4(\n        cs.x, 0, cs.y, 0,\n        0, 1, 0, 0,\n        -cs.y, 0, cs.x, 0,\n        0, 0, 0, 1);\n}\n\n// Tetrahedron bound SDF by yx\n// https://www.shadertoy.com/view/Ws23zt\nfloat sdTetrahedron(vec3 p)\n{\n    return (max(\n        abs(p.x+p.y)-p.z,\n        abs(p.x-p.y)+p.z\n    )-1.)/sqrt(3.);\n}\n\n// This scene transforms space for a tetrahedron. The original tetrahedron is at the top\n// just right of the x axis\nfloat scene(vec3 point)\n{\n    // Repeat z regions\n    point.z = mod(point.z, zRepeat) - 0.5 * zRepeat;\n    \n    // Worst case distance for nearest neighboring z region\n    float bound = zRepeat - sqrt(6.0) - abs(point.z);\n    \n    // Duplicate radially\n    float r = length(point.xy);\n    float theta = atan(point.y, point.x);\n    theta = mod(theta - 0.5 * pi + 0.5 * radialSlice, radialSlice) - 0.5 * radialSlice;\n    point.xy = r * vec2(-sin(theta), cos(theta));\n    \n    // Fold in each radial region\n    point.x = abs(point.x);\n    \n    // Rotate/translate\n    point = (sceneTransform * vec4(point, 1.0)).xyz;\n    \n    return min(sdTetrahedron(point), bound);\n}\n\nvec3 estimateNormal(vec3 point, float distAtIntersect)\n{\n    const vec2 k = vec2(0.0, epsilon);\n\treturn normalize(vec3(\n        scene(point + k.yxx),\n        scene(point + k.xyx),\n        scene(point + k.xxy)) - distAtIntersect);\n}\n\n// Inspired by Inigo Quilez's procedural color palette method\n// https://iquilezles.org/articles/palettes\nvec3 palette(float t)\n{\n    return vec3(\n        0.3 + 0.3 * cos(t + 2.0),\n        0.5 + 0.5 * cos(t + 1.0),\n        0.8 + 0.2 *cos(t));\n}\n\n// Perpendicular distance to the edges of an equilateral triangle\nfloat pdTriangle(vec2 point)\n{\n    float r = length(point);\n    float theta = atan(point.y, point.x);\n    theta = mod(theta - pi / 6.0, twoPi / 3.0) + pi / 6.0;\n    return r * sin(theta);\n}\n\n// Makes a kaleidoscope of various triangles using distance functions. Perhaps it's\n// a bit bright/distracting but the glow coloring was my best color attempt\nvec3 sky(vec3 normal)\n{\n    // Maps the range [-1, 1] onto the sphere. Pretty wonky around the meridian\n    vec2 point = 2.0 * asin(normal.xy) / pi;\n    \n    // Duplicate radially\n    float r = length(point.xy);\n    float theta = atan(point.y, point.x);\n    theta = mod(theta - 0.5 * pi + 0.5 * radialSlice, radialSlice) - 0.5 * radialSlice;\n    point.xy = r * vec2(-sin(theta), cos(theta));\n    \n    // Fold in each radial region\n    point.x = abs(point.x);\n    \n    // Get the minimum distance to a bunch of shapes\n    float dist = 1e5;\n    \n    // First, 6 inscribed triangles that rotate, move a bit, and change size\n    float rotTheta = mod(0.2 * time, twoPi / 3.0) - pi / 3.0;\n    mat2 triRotate = rotate(rotTheta + pi / 3.0);\n    float inscribeScale = 0.5 / cos(rotTheta);\n    \n    vec2 triPoint = triRotate * (point - vec2(0.05 + 0.05 * cos(0.11 * time), 0.2));\n    float scale = 1.0;\n    float baseSize = 0.1 + 0.1 * cos(0.23 * time);\n    \n    for (int i = 0; i < 6; i++)\n    {\n        dist = min(dist, abs(pdTriangle(triPoint) - baseSize * scale));\n        scale *= inscribeScale;\n        triPoint = triRotate * triPoint;\n    }\n    \n    // Next, a triangle that \"radiates\" fading rings\n    triPoint = point;\n    triPoint.y = 0.5 - abs(triPoint.y - 0.5);\n    triPoint -= vec2(0.0, 0.35 + 0.05 * cos(0.212 * time));\n    triPoint.y = -triPoint.y;\n    dist = min(dist, abs(pdTriangle(triPoint)));\n    \n    float partialLevel = fract(0.333 * time);\n    float spacing = 0.075;\n    float radius = spacing * partialLevel;\n    \n    for (float i = 0.0; i < 4.0; i+= 1.0)\n    {\n        float level = i + partialLevel;\n        float extraDist = 0.01 * pow(level, 1.8);\n        dist = min(dist, abs(pdTriangle(triPoint) - radius) + extraDist);\n        radius += spacing;\n    }\n    \n    // Finally, collection of triangles by the meridian. This is mainly so that the\n    // reflection of the tetrahedrons will catch something interesting\n    triPoint = (point - vec2(0.15, 0.7)) * triRotate;\n    dist = min(dist, abs(pdTriangle(triPoint) - 0.05));\n    \n    float triR = length(triPoint);\n    float triTheta = atan(triPoint.x, triPoint.y);\n    triTheta = mod(triTheta, twoPi / 3.0) + pi / 6.0;\n    triPoint = triR * vec2(cos(triTheta), sin(triTheta));\n    triPoint -= vec2(0., 0.1);\n    dist = min(dist, abs(pdTriangle(triPoint) - 0.035));\n    \n    // Vary the glow intensity over time, with a slight wave effect\n    float intensity = 3.0 - sin(60.0 * point.y - 3.0 * time) * sin(2.22 * time) - cos(time);\n    return pow( vec3(linestep(1.0, 0.0, dist)), intensity * vec3(20.0, 50.0, 7.0));\n}\n\nvec3 shadeSurface(vec3 point, vec3 normal, vec3 incident)\n{\n    // Since the brightest parts of the sky are around +/- z, the lights are close to \n    // the axis. They are not exactly on the axis because this causes mirrored faces\n    // to have the exact same shading and it's too hard to distinguish them\n    const vec3 toLight1 = normalize(vec3(2, 1, 6));\n    const vec3 toLight2 = normalize(vec3(-2, 1, -6));\n    \n    float diffuse1 = max(dot(normal, toLight1), 0.0);\n    float diffuse2 = max(dot(normal, toLight2), 0.0);\n    \n    // Add a bit of ambient\n    float diffuse = 0.1 + 0.9 * (diffuse1 + diffuse2);\n    \n    // The \"specular\" lighting glows purple toward the lights. It can be thought of\n    // as an approximation of a very blurred version of the sky map\n    vec3 bisector1 = normalize(toLight1 - incident);\n    vec3 bisector2 = normalize(toLight2 - incident);\n    \n    // Linesteps make sure no specular reflection happens when the surface normal faces\n    // away from the light\n    float specular1 = dot(normal, bisector1) * linestep(0.0, 0.15, diffuse1);\n    float specular2 = dot(normal, bisector2) * linestep(0.0, 0.15, diffuse2);\n    \n    vec3 specular = pow(vec3((specular1 + specular2)), vec3(3.0, 6.0, 1.5));\n    \n    vec3 skyColor = sky(reflect(incident, normal));\n    vec3 surface = palette(atan(point.y, point.x) + 0.475 * point.z + 0.8 * time);\n    \n    // Gamma correct diffuse intensity\n    return min(0.9 * pow(diffuse, 1.0 / 2.2) * surface + 0.3 * specular  + 0.2 * skyColor, 1.0);\n}\n\n// Returns the result color of casting any ray\nvec3 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    vec3 skyColor = sky(rayDir);\n    vec3 color = skyColor;\n    vec3 point = rayOrigin;\n    float t;\n    \n    for (t = 0.0; t < maxDistance; point = rayOrigin + t*rayDir)\n    {\n     \tfloat dist = scene(point);\n        if (dist <= epsilon)\n        {\n            vec3 normal = estimateNormal(point, dist);\n            color = shadeSurface(point, normal, rayDir);\n        \tbreak;\n        }\n        t += dist;\n    }\n    // Fade into distance\n    float distFade = t / maxDistance;\n    distFade = linestep(0.4, 1.0, distFade);\n    return mix(color, skyColor, distFade);\n}\n\n//Rotates rays so that they point to the center from the camera\nmat3 rotateRay(vec3 camera, vec3 center, vec3 up)\n{\n    vec3 forward = normalize(center - camera);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    return mat3(right, up, -forward);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Globals - time, mouse, rotation matrices\n    time = iTime;\n    \n    vec2 mouse = float(iMouse.z > 0.0) * vec2(\n        4.0 * iMouse.x / iResolution.x - 2.0,\n        iMouse.y / iResolution.y);\n    \n    // First, spin the tetrahedron around the x axis\n    mat4 spin = yzRotate(0.6 * time +  mouse.x);\n    \n    // Use the spin to figure out how much we need to rotate on the hinge\n    // in order to be facing the proper direction to connect with the neighbor\n    float thetaToNeighbor = -pi / float(PAIRS);\n    vec2 cs = vec2(cos(thetaToNeighbor), sin(thetaToNeighbor));\n    vec4 hingeDir = vec4(cs.x, cs.y, 0.0, 1.0);\n    hingeDir = spin * hingeDir;\n    float hingeTheta = atan(hingeDir.y, hingeDir.x);\n    \n    // Rotate on the hinge about (-1, 0, 0)\n    mat4 translate1 = translate(vec3(1, 0, 0));  \n    mat4 hingeRot = xyRotate(-hingeTheta);\n    mat4 translate2 = translate(vec3(-1, 0, 0));\n        \n    // Final correction\n    mat4 finalRot = yzRotate(0.25 * pi);\n    \n    forwardTransform = transpose(spin) \n        * transpose(hingeRot)\n        * translate1\n        * transpose(finalRot);\n    \n    // The last thing to do is figure out how much to raise the tetrahedron\n    // This is done by rotating one vertex and calculating its new offset from\n    // the plane bordering the radial neighbor\n    \n    vec2 vertexPos = ((forwardTransform) * vec4(1.0)).xy;\n    float yOffset = cs.x * vertexPos.x / cs.y + vertexPos.y;\n    \n    sceneTransform = finalRot\n        * translate2\n        * hingeRot\n        * translate1\n        * spin\n        * translate(vec3(-1, yOffset, 0));\n\n    cameraPos.z = -2.0 * time - 30.0 * mouse.y;  \n    \n    vec2 point = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\tvec3 rayDir = normalize(vec3(point * tan(fov/2.0), -1.0));\n    \n    // Since the camera is looking along the -z axis, we don't need full rotation matrices\n    // for the rays or up vector. If you want to change the camera destination, replace\n    // the following 2D rotation with the commented code\n    \n    rayDir.xy = rotate(0.05 * time) * rayDir.xy;\n    //vec3 up = vec3(sin(0.05 * time), cos(0.05 * time), 0.0);\n    //up = rotateRay(cameraPos, vec3(0, 0, cameraPos.z) + cameraDest, vec3(0, 1, 0) * up;\n    //rayDir = rotateRay(cameraPos, vec3(0, 0, cameraPos.z) + cameraDest, up) * rayDir;\n \n    fragColor = vec4(castRay(cameraPos, rayDir), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGGzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[856, 856, 899, 899, 948], [950, 950, 976, 976, 1081], [1083, 1083, 1112, 1112, 1211], [1213, 1213, 1241, 1241, 1398], [1400, 1400, 1428, 1428, 1585], [1587, 1587, 1615, 1615, 1772], [1774, 1846, 1875, 1875, 1965], [1967, 2084, 2109, 2133, 2749], [2751, 2751, 2807, 2807, 2982], [2984, 3090, 3113, 3113, 3228], [3230, 3296, 3326, 3326, 3485], [3487, 3647, 3670, 3750, 6233], [6235, 6235, 6294, 6542, 7753], [7755, 7802, 7845, 7845, 8411], [8413, 8477, 8528, 8528, 8698], [8700, 8700, 8757, 8805, 11123]], "test": "untested"}
{"id": "ft3Xz4", "name": "Welcome to Sphere World", "author": "ASchneidman", "description": "WASD to move, shift to speed up, drag to rotate.", "tags": ["mouse", "rays", "camera", "webcam", "keyboard", "flycam"], "likes": 1, "viewed": 410, "published": 3, "date": "1638757572", "time_retrieved": "2024-07-30T18:43:49.580866", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screen_coord = fragCoord / iResolution.xy;\n\n    fragColor = vec4(texture(iChannel0, screen_coord));\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float traceSphere(Ray ray, Sphere sphere) {\n    vec3 L = sphere.center - ray.origin;\n\n    float tca = dot(L, ray.direction);\n    if (tca < 0.0) {\n        return -1.0;\n    } \n\n    float d = dot(L, L) - tca * tca;\n    float r2 = sphere.radius * sphere.radius;\n    if (d > r2) {\n        return -1.0;\n    }\n\n    float thc = sqrt(r2 - d);\n\n    float t0 = tca - thc;\n    float t1 = tca + thc;\n\n    if (t0 < 0.0) {\n        if (t1 < 0.0) {\n            return -1.0;\n        }\n        return t1;\n    } else {\n        if (t1 < 0.0) {\n            return t0;\n        }\n        return min(t0, t1);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // TODO: THIS NEEDS TO GET THE CURRENT STATE STORED IN SOME BUFFER\n    // INSTEAD OF RESETTING EVERY FRAME\n    Camera camera = Camera_Get_Cached(iChannel1, iResolution);\n\n    mat4 model, view, rotation;\n    Camera_Model_View(camera, model, view, rotation);\n\n\n    // Generate ray and transform to world space\n    vec2 screen_coord = fragCoord / iResolution.xy;\n    vec2 centered = vec2(screen_coord.x - 0.5, screen_coord.y - 0.5);\n\n    float sensor_v = 2.0 * tan(Radians(camera.fov / 2.0));\n    float sensor_h = camera.aspect_ratio * sensor_v;\n\n    // In camera space, lies on plane at z = -1\n    vec3 scaled = vec3(centered.x * sensor_h, centered.y * sensor_v, -1.0);\n    Ray ray = Ray(vec3(0.0), normalize(scaled));\n    Ray_Transform(ray, model);\n\n\n    \n    Sphere sphere = Sphere(vec3(0.0, 0.0, -3.), 4.0);\n    float t = traceSphere(ray, sphere);\n    if (t >= 0.0) {\n        vec3 intersection_point = ray.origin + ray.direction * t - sphere.center;\n        \n        float r = length(intersection_point);\n        float theta = acos(intersection_point.z / r);\n        float phi = atan(intersection_point.y, intersection_point.x);\n        \n        theta /= PI;\n        phi = (phi + PI) / (2.0 * PI);\n        \n        \n        fragColor = texture(iChannel2, vec2(theta, phi));\n        return;\n    }\n\n    \n    fragColor = vec4(0.0,0.0,0.0,1.0);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define VSCODE 0\n\n#define PI 3.14159\n#define UP vec3(0.0, 1.0, 0.0)\n#define Radians(x) ((x) * PI / 180.0)\n#define Degrees(x) ((x) * 180.0 / PI)\n\n\n// Utility Functions\n\nvec3 hsv2rgb(vec3 c)\n{\n    // from https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nmat4 euler_angles_to_rotation(vec3 ea) {\n    mat4 X = mat4(\n        vec4(1.0, 0.0, 0.0, 0.0),\n        vec4(0.0, cos(ea.x), -sin(ea.x), 0.0),\n        vec4(0.0, sin(ea.x), cos(ea.x), 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    mat4 Y = mat4(\n        vec4(cos(ea.y), 0.0, sin(ea.y), 0.0),\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(-sin(ea.y), 0.0, cos(ea.y), 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    mat4 Z = mat4(\n        vec4(cos(ea.z), -sin(ea.z), 0.0, 0.0),\n        vec4(sin(ea.z), cos(ea.z), 0.0, 0.0),\n        vec4(0.0, 0.0, 1.0, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n\n\n    return Z * Y * X;\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nvec3 Vector_Transform(vec3 v, mat4 m) {\n    return (m * vec4(v, 0.0)).xyz;\n}\n\nvoid Ray_Transform(inout Ray ray, mat4 m) {\n    vec4 homogeneous = m * vec4(ray.origin, 1.0);\n    ray.origin = homogeneous.xyz / homogeneous.w;\n\n    ray.direction = Vector_Transform(ray.direction, m);\n}\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\nstruct Camera {\n    vec3 position;\n    vec3 euler_angles;\n    //mat4 rotation;\n\n    float fov;\n    float aspect_ratio;\n\n    float move_sens;\n};\n\nCamera Camera_Reset(vec3 iResolution) {\n    // Matrices are in column major order\n    vec3 euler_angles = vec3(0.0, Radians(-100.0), 0.0);\n\n    return Camera(\n        vec3(6.0, 0.0, -4.0),\n        euler_angles,\n        90.0,\n        iResolution.x / iResolution.y,\n        0.015\n    );\n}\n\nvoid Camera_Model_View(Camera camera, out mat4 model, out mat4 view, out mat4 rotation) {\n    rotation = euler_angles_to_rotation(camera.euler_angles);\n    // Precomputes view\n    model = mat4(\n            vec4(1.0, 0.0, 0.0, 0.0),\n            vec4(0.0, 1.0, 0.0, 0.0),\n            vec4(0.0, 0.0, 1.0, 0.0),\n            vec4(camera.position.xyz, 1.0)\n        ) * rotation;\n\n    view = inverse(model);\n}\n\nCamera Camera_Get_Cached(sampler2D camera_channel, vec3 iResolution) {\n    vec3 position = texelFetch(camera_channel, ivec2(4, 0), 0).xyz;\n    vec3 euler_angles = texelFetch(camera_channel, ivec2(0, 0), 0).xyz;\n\n    return Camera(\n        position,\n        euler_angles,\n        90.0,\n        iResolution.x / iResolution.y,\n        0.015\n    );\n}", "buffer_b_code": "\n#if VSCODE\n#else\n#define KEYBOARD iChannel2\n\nconst int Key_W = 87;\nconst int Key_A = 65;\nconst int Key_S = 83;\nconst int Key_D = 68;\nconst int Key_Shift = 16;\nconst int Key_R = 82;\n\n\nbool isKeyDown(int key) {\n    return texelFetch(KEYBOARD, ivec2(key, 0), 0).x > 0.0;\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    int id = int(floor(fragCoord.x));\n    if (id >= 6 || fragCoord.y > 0.5) {\n        discard;\n    }\n\n    // id 0 computes position\n    // id 1 + i computes ith column of rotation\n    Camera camera = Camera_Reset(iResolution);\n    if (iFrame > 0) {\n        vec4 prev_iMouse = texelFetch(iChannel1, ivec2(5, 0), 0);\n        camera = Camera_Get_Cached(iChannel1, iResolution);\n\n        mat4 model, view, rotation;\n        Camera_Model_View(camera, model, view, rotation);\n\n        vec3 total_move = vec3(0.0);\n\n        if (isKeyDown(Key_Shift)) {\n            camera.move_sens *= 2.0;\n        }\n        if (isKeyDown(Key_W)) {\n            // Camera looks along -z axis, so \n            // take vector going along -z axis and transform\n            total_move += Vector_Transform(vec3(0.0, 0.0, -1.0), model);\n        }\n        if (isKeyDown(Key_S)) {\n            total_move += Vector_Transform(vec3(0.0, 0.0, 1.0), model);\n        }\n        if (isKeyDown(Key_D)) {\n            total_move += Vector_Transform(vec3(1.0, 0.0, 0.0), model);\n        }\n        if (isKeyDown(Key_A)) {\n            total_move += Vector_Transform(vec3(-1.0, 0.0, 0.0), model);\n        }\n\n        // Do translation\n        if (iMouse.z > 0.0) {\n            // Mouse is pressed, check if it was pressed last frame\n            if (prev_iMouse.z > 0.0) {\n                vec2 offset = (iMouse.xy - prev_iMouse.xy) * vec2(1.0, -1.0) * camera.move_sens;\n                //vec3 euler_change = vec3(0.0, offset.yx);\n                vec3 euler_change = vec3(offset.yx, 0.0);\n                \n                camera.euler_angles += euler_change;\n            }\n        }\n\n        if (length(total_move) > 0.0) {\n            camera.position += normalize(total_move) * camera.move_sens;\n        }\n\n        if (isKeyDown(Key_R)) {\n            camera = Camera_Reset(iResolution);\n        }\n    }\n\n    if (id == 0) {\n        fragColor = vec4(camera.euler_angles, 0.0);\n        return;\n    }\n    if (id == 4) {\n        fragColor = vec4(camera.position, 0.0);\n        return;\n    }\n    if (id == 5) {\n        fragColor = iMouse;\n        return;\n    }\n    //fragColor = camera.rotation[id];\n\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3Xz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 168]], "test": "untested"}
{"id": "7lyGRz", "name": "Crystal Tetrahedron Fractal", "author": "amhall", "description": "Infinite zoom of a snowflake-esque fractal constructed from tetrahedrons. The surface coloring involves thin-film interference. Click to zoom / change level of detail.", "tags": ["3d", "raymarching", "fractal", "mouse", "zoom", "tetrahedron", "rainbow", "infinite", "iridescent"], "likes": 20, "viewed": 651, "published": 3, "date": "1638757308", "time_retrieved": "2024-07-30T18:43:50.686909", "image_code": "// Infinite zoom of a snowflake-esque fractal constructed from tetrahedrons. The self-\n// similarity is exploited to appear as an infinite zoom despite never zooming beyond\n// two iterations.\n// Created by Anthony Hall\n\nconst float pi = radians(180.0);\nconst float twoPi = radians(360.0);\nconst vec3 rgbWavelengths = vec3(0.612, 0.549, 0.464) / pi;\n\nconst float maxDistance = 40.0;\nconst float epsilon = 0.003;\n\n// Many of the following globals are set/modified in mainImage\nvec3 cameraPos = vec3(0.0, 0.0, 4.0);\nvec3 cameraDest = vec3(0.0);\nconst float fov = radians(50.0);\n\nfloat time;\n\n// The base number of iterations at no zoom, and the amount each iteration scales\n// the size down. The bound lobes in the SDF were crafted for these values, so raising\n// baseLevels or lowering levelScale will cause glitches. See scene for details/fixes\nfloat baseLevels = 7.0;\nconst float levelScale = 2.0;\n\nconst float zoomPeriod = 4.0; // Time to zoom through one level\nfloat zoomTotal; // Number of levels it looks like we have zoomed\nfloat zoomBase; // Percentage of the first level we have zoomed\nfloat zoomRepeat; // Percentage of the second level we have zoomed\nfloat zoom; // Number of levels we have actually zoomed (zoomBase + zoomRepeat)\n\n// Transforms the point evaluating the SDF (only rotation/scale)\nmat3 sceneTransform = mat3(1.0);\n\n// The amount the scene is zoomed in\nfloat sceneScale;\n\n// Translation component of the SDF point transformation. It's separate because\n// mat3 * vec3 + vec3 is slightly cheaper than mat4 * vec4 (please correct me if wrong)\nvec3 sceneOffset;\n\nfloat linestep(float a, float b, float x)\n{\n    return clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\nmat2 rotate(float theta)\n{\n    vec2 cs = vec2(cos(theta), sin(theta));\n    return mat2(\n        cs.x, cs.y,\n        -cs.y, cs.x);\n}\n\n// Tetrahedron's vertices\nconst vec3[4] vertices = vec3[4](\n    vec3(1, 1, 1),\n    vec3(-1, 1, -1),\n    vec3(-1, -1, 1),\n    vec3(1, -1, -1));\n\n// Tetrahedron bound SDF by yx\n// https://www.shadertoy.com/view/Ws23zt\nfloat sdTetrahedron(vec3 p)\n{\n    return (max(\n        abs(p.x+p.y)-p.z,\n        abs(p.x-p.y)+p.z\n    )-1.)/sqrt(3.);\n}\n\n// Arbitrarily oriented flat disk\nfloat sdDisk(vec3 point, vec3 normal, float radius)\n{\n    float dist = dot(point, normal);\n    vec3 planePoint = point - dist * normal;\n    float l = length(planePoint);\n    float r = min(l, radius);\n    planePoint = planePoint / l * r;\n    return distance(point, planePoint);\n}\n\n// Folds space about a plane, and scales only the mirrored side without branching.\n// scale returns how much the space was scaled\nvec3 scaleFold(vec3 point, vec3 planePoint, vec3 normal, out float scale)\n{\n    float planeDist = dot(point - planePoint, normal);\n    float reflected = float(planeDist < 0.0);\n    scale = 1.0 - reflected + levelScale * reflected;\n  \n    // min(0.0, planeDist) seems to be slightly faster than reflected * planeDist\n    point -= 2.0 * min(0.0, planeDist) * normal;\n    point -= planePoint;\n    point *= scale;\n    point += planePoint;\n    return point;\n}\n\n// Distance to the scene\nfloat scene(vec3 point)\n{\n    point = sceneTransform * point + sceneOffset;\n    float dist = 1e10;\n    float scaleAcc = 1.0;\n    float levels = baseLevels + zoom;\n\n    for (float i = 0.0; i < ceil(levels); i += 1.0)\n    {\n        // The magic here is that each vertex of the tetrahedrons has an even number\n        // of negative signs. This means we can easily transform the vertex octants to\n        // the [+, +, +] octant and leave the others alone.\n        \n        float signs = (sign(point.x) * sign(point.y) * sign(point.z));\n        point = mix(point, abs(point), 0.5 + 0.5 * signs);\n        \n        float scale;\n        point = scaleFold(point, vertices[0], -vertices[0] / sqrt(3.0), scale);\n        scaleAcc *= scale;\n\n        // When the level is fractional, blend the last and second to last distances\n        if (levels - i < 1.0)\n        {\n            float newDist = min(dist, sdTetrahedron(point) / scaleAcc);\n            dist = mix(dist, newDist, levels - i);\n        }\n        // Take the initial distance when we are at the final whole level\n        else if (levels - i < 2.0)\n            dist = min(dist, sdTetrahedron(point) / scaleAcc); // TODO\n    }\n    // The SDF is now super messed up because the transformations above are not uniformly\n    // applied to space. A point may not know it is near something because it's in a \"less\"\n    // transformed region of space. To fix this, we will add lobe bounds that fully cover\n    // the regions that may be overestimated. \n    \n    // Slight optimization: by mapping every non-vertex octant to the [-, +, +] octant,\n    // we only need to check the neighboring three lobes instead of all four. This also\n    // maps all vertex octants to [+, +, +], so they're covered by the first lobe check.\n    \n    // It's not perfect, there are still viewing conditions in which glitching can occur\n    // and I'm stumped\n    \n    float signs = sign(point.x) * sign(point.y) * sign(point.z);\n    point = mix(vec3(-abs(point.x), abs(point.yz)), abs(point), 0.5 + 0.5 * signs);\n    float boundDist = 1e10;\n    \n    for (int i = 0; i < 3; i++)\n    {\n        boundDist = min(boundDist, sdDisk(point - (1.205 + 1.0 / levelScale) * vertices[i],\n            vertices[i] / sqrt(3.0), 1.3));\n    }\n    // Lower the epsilon multiplier to raise baseLevels over 7\n    // Raise the disk size (0.95) to lower levelScale below 2\n    dist = min(dist, abs((boundDist - 0.95) / scaleAcc) + 3.0 * epsilon);\n    return dist * sceneScale;\n}\n\nvec3 estimateNormal(vec3 point, float distAtIntersect)\n{\n    const vec2 k = vec2(0.0, epsilon);\n    return normalize(vec3(\n        scene(point + k.yxx),\n        scene(point + k.xyx),\n        scene(point + k.xxy)) - distAtIntersect);\n}\n\n// Rather than use the depth and refractive index ratio, \"incident distance\"\n// is used to save a couple operations. I define it as double the depth of the film\n// multiplied by the speed of light outside the film over the speed of light inside\n// the film. Think of it as the distance the light wave travels when hitting the\n// film straight on,  accounting for the fact that the wavelength changes while\n// inside the different medium.\n\nvec3 filmInterference(vec3 incident, vec3 normal, float incidentDist)\n{\n    // Extra distance traveled by the light that goes through the film\n    float dist = incidentDist / dot(-incident, normal);\n    return abs(cos(dist / rgbWavelengths));\n}\n\n// Rainbow sky\nvec3 sky(vec3 normal)\n{\n    float y = 2.0 * asin(normal.y) / pi; // Phi normalized to [-1, 1] \n    float phase = 1.3 * (y + 1.0) - 0.01;\n    vec3 color = 0.5 + 0.5 * cos(phase / rgbWavelengths);\n    \n    // Wave-like function for changing brightness and color exponent\n    float theta = atan(normal.z, normal.x);\n    float intensity = cos(5.0 * theta - 0.7 * time)\n        * cos(6.0 * theta)\n        * cos(3.0 * theta + 0.82 * time);\n        \n    // Push values away from 0 a little\n    intensity = sign(intensity) * pow(abs(intensity), 0.875);\n    \n    // Get rid of the weirdness at the poles\n    intensity = mix(intensity, 0.4, linestep(0.5, 0.85, abs(y)));\n    \n    return (0.8 + 0.2 * intensity) * pow(color, vec3(pow(2.0, -2.0 * intensity)));\n}\n\nvec3 shadeSurface(vec3 point, vec3 normal, vec3 incident)\n{\n    // Make the surface white with a little bit of thin film interference from the\n    // sky reflection. I chose the refractive index and \"incident distance\" arbitrarily\n    // for aesthetic reasons. In order to accurately model the phenomenon, incident\n    // distance must be caculated as 2 * depth * R_film / R_air (see filmInterference)\n    \n    vec3 skyColor = sky(reflect(incident, normal));\n    vec3 filmRefraction = refract(incident, normal, 0.8);\n    vec3 surface = 0.65 + 0.6 * skyColor * filmInterference(filmRefraction, normal, 2.5);\n    \n    // The lighting model is essentially a ring around the hemisphere that gets dark\n    // very fast, with a ton of ambient light. This completely throws the sRGB color space\n    // out the window, but the result has enough contrast without overwhelming brightness.\n    float diffuse = dot(normal.xz, normal.xz); \n    diffuse = 0.5 + 0.5 * diffuse;\n    return min(diffuse * surface, 1.0); // Surface color can exceed 1 so it needs clamping\n}\n\nvec3 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    vec3 color;\n    vec3 point = rayOrigin;\n    float t;\n    bool hit = false;\n\n    for (t = 0.0; t < maxDistance; point = rayOrigin + t*rayDir)\n    {\n        float dist = scene(point);\n        if (dist <= epsilon)\n        {\n            vec3 normal = estimateNormal(point, dist);\n            color = shadeSurface(point, normal, rayDir);\n            hit = true;\n            break;\n        }\n        t += dist;\n    }\n    if (!hit)\n        // There's not quite enough contrast without darkening the sky a bit\n        color = 0.75 * sky(rayDir);\n\n    return color;\n}\n\n// Changes t [0, 1] to an exponential curve such that its derivative at 0 is levelScale\n// times its derivative at 1. That is, its speed exponentially decreases\nfloat expT(float t)\n{\n    return 1.0 - (pow(levelScale, 1.0 - t) - 1.0) / (levelScale - 1.0);\n}\n\n// Given 3 points that lie on an arc, this interpolates between two of them on the arc.\n// previous -> start and start -> end must be equidistant on the arc for this to work.\nvec3 arcInterp(vec3 previous, vec3 start, vec3 end, float t)\n{\n    vec3 toPrev = previous - start;\n    vec3 toEnd = end - start;\n    vec3 toCenter = normalize(toPrev + toEnd);\n    float cDot = dot(toPrev, toCenter);\n    float radius = dot(toPrev, toPrev) / (2.0 * cDot);\n    vec3 center = start + radius * toCenter;\n\n    // Correct t so that the angle change is constant\n    float theta = 0.5 * (pi - 2.0 * acos(cDot / length(toPrev)));\n    t = 2.0 * t - 1.0;\n    t = tan(t * theta) / tan(theta);\n    t = 0.5 + 0.5 * t;\n\n    vec3 raw = mix(start, end, t);\n    return center + radius * normalize(raw - center);\n}\n\nmat3 rotateRay(vec3 camera, vec3 dest, vec3 up)\n{\n    vec3 forward = normalize(dest - camera);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    return mat3(right, up, -forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // First, there's a whole lot of globals calculation to do\n    time = iTime;\n    \n    float click = float(iMouse.z > 0.0);\n    vec2 mouse = click * iMouse.xy / iResolution.xy;\n    mouse.y += 1.0 - click;\n    \n    baseLevels = max(baseLevels - (4.0 - 4.0 * mouse.y), 1.0); // Must be >= 1 for SDF to work\n  \n    if (time < 2.0)\n        time = 0.25 * time * time;\n    else\n        time = time - 1.0;\n\n    zoomTotal = time / zoomPeriod + 3.0 * mouse.x;\n    zoomBase = min(zoomTotal, 1.0);\n    zoomRepeat = fract(zoomTotal - zoomBase);\n    zoom = zoomBase + zoomRepeat;\n    sceneScale = pow(levelScale, zoom);\n\n    // The rotation matrix from one level to the next is calculated from the perspective\n    // of directly facing the center tetrahedron (kind of how the camera is at the\n    // beginning). Thus, that rotation must be corrected for that orientation.\n    // f, u, r = forward, up, right vectors\n    \n    const vec3 f0 = vertices[3] / sqrt(3.0);\n    const vec3 u0Init = vec3(0, 1, 0);\n    const vec3 r0 = normalize(cross(f0, u0Init));\n    const vec3 u0 = cross(f0, -r0);\n    const mat3 correction = transpose(mat3(r0, u0, -f0));\n\n    // Now, rotate from one level to the next\n    const vec3 mirrorNormal = vertices[0] / sqrt(3.0);\n    const vec3 f1 = f0 - 2.0 * dot(f0, mirrorNormal) * mirrorNormal; // Mirrors f0\n    const vec3 u1Init = vertices[0];\n    const vec3 r1 = normalize(cross(f1, u1Init));\n    const vec3 u1 = cross(f1, -r1);\n\n    const mat3 fullRot = mat3(r1, u1, -f1) * correction;\n    const mat3 invRot = transpose(fullRot);\n    \n    // Directly interpolating the rotation of each axis doesn't work well because \n    // the rotation takes a sharp turn at the border of each level. Considering the\n    // original axes and the axes after the first and second rotations, these three\n    // points will lie on an arc. When doing partial rotations, we want to figure out\n    // where along this arc the new axis should lie. See arcInterp\n    \n    const vec3 prevU = invRot[1];\n    const vec3 prevF = -invRot[2];\n\n    const vec3 destU = fullRot[1];\n    const vec3 destF = -fullRot[2];\n\n    float zoomFract = fract(zoom);\n\n    vec3 partialF = arcInterp(\n        prevF,\n        vec3(0, 0, -1),\n        destF,\n        zoomFract);\n\n    vec3 partialU = arcInterp(\n        prevU,\n        vec3(0, 1, 0),\n        destU,\n        zoomFract);\n\n    vec3 partialR = normalize(cross(partialF, partialU));\n    partialU = cross(partialF, -partialR);\n    mat3 partialRot = mat3(partialR, partialU, -partialF);\n\n    // The idea for the offset is similar. The actual path of the offset should be a\n    // logarithmic spiral centered at wherever the zoom is converging. I don't know how\n    // to actually solve for the center of this logarithmic spiral, so we can utilize\n    // the fact that logarithmic spirals are closely approximated by tangent arcs of\n    // exponentially decreasing size. This approximation isn't perfect, hence you may\n    // notice the figure wobble a bit especially when zooming quickly.\n    \n    const vec3 destOffset = vertices[0] * (1.0 + 1.0 / levelScale);\n    const vec3 prevOffset = -invRot * destOffset;\n    \n    vec3 partialOffset = arcInterp(\n        prevOffset,\n        vec3(0),\n        destOffset,\n        expT(zoomFract));\n    \n    if (zoom < 1.0)\n    {\n        sceneTransform = partialRot;\n        sceneOffset = partialOffset;\n    }\n    else\n    {\n        sceneTransform = partialRot * fullRot;\n        sceneOffset = destOffset + fullRot * partialOffset / levelScale;\n    }\n    sceneTransform /= sceneScale;\n\n    // Percentage that approaches 1 as time goes on\n    float startExp = 1.0 - exp(-0.1 * time);\n\n    // The camera is placed such that it's never looking toward the part that\n    // disappears when the zoom repeats. It also avoids sky reflections that directly\n    // face the poles.\n    \n    float xzTheta = -0.5 + 0.25 * cos(0.1 * time);\n    cameraPos = (-6.0 + 1.5 * startExp) * vertices[3];\n    cameraPos.xz = rotate(xzTheta) * cameraPos.xz;\n    cameraPos.y -= 2.0 * startExp;\n    \n    // The camera approaches looking close to where the fractal path converges\n    cameraDest = startExp * vec3(1.6, 1.6, 1.3);\n\n    // Rotate the up vector around slowly\n    vec3 up = vec3(sin(0.12 * time), cos(0.12 * time), 0.0);\n    up = rotateRay(cameraPos, cameraDest, vec3(0, 1, 0)) * up;\n    \n    vec2 point = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 rayDir = normalize(vec3(point * tan(fov/2.0), -1.0));\n    rayDir = rotateRay(cameraPos, cameraDest, up) * rayDir;\n    \n    fragColor = vec4(castRay(cameraPos, rayDir), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyGRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1583, 1583, 1626, 1626, 1675], [1677, 1677, 1703, 1703, 1808], [1954, 2026, 2055, 2055, 2145], [2147, 2181, 2234, 2234, 2459], [2461, 2591, 2666, 2666, 3045], [3047, 3072, 3097, 3097, 5550], [5552, 5552, 5608, 5608, 5786], [6227, 6227, 6298, 6369, 6471], [6473, 6488, 6511, 6511, 7238], [7240, 7240, 7299, 7641, 8294], [8296, 8296, 8339, 8339, 8902], [8904, 9065, 9086, 9086, 9160], [9162, 9337, 9399, 9399, 9948], [9950, 9950, 9999, 9999, 10164], [10166, 10166, 10221, 10284, 14810]], "test": "untested"}
{"id": "Nt3SRr", "name": "Camera Model, Flycam, Raytracing", "author": "ASchneidman", "description": "Some base code for future projects. Includes a flycam that can be controlled with WASD, Shift to go faster, drag to rotate. Also basic raytracing code to get started. ", "tags": ["mouse", "rays", "camera", "keyboard", "flycam"], "likes": 4, "viewed": 240, "published": 3, "date": "1638755845", "time_retrieved": "2024-07-30T18:43:51.559575", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screen_coord = fragCoord / iResolution.xy;\n\n    fragColor = vec4(texture(iChannel0, screen_coord));\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat traceSphere(Ray ray, Sphere sphere) {\n    vec3 L = sphere.center - ray.origin;\n\n    float tca = dot(L, ray.direction);\n    if (tca < 0.0) {\n        return -1.0;\n    } \n\n    float d = dot(L, L) - tca * tca;\n    float r2 = sphere.radius * sphere.radius;\n    if (d > r2) {\n        return -1.0;\n    }\n\n    float thc = sqrt(r2 - d);\n\n    float t0 = tca - thc;\n    float t1 = tca + thc;\n\n    if (t0 < 0.0) {\n        if (t1 < 0.0) {\n            return -1.0;\n        }\n        return t1;\n    } else {\n        if (t1 < 0.0) {\n            return t0;\n        }\n        return min(t0, t1);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // TODO: THIS NEEDS TO GET THE CURRENT STATE STORED IN SOME BUFFER\n    // INSTEAD OF RESETTING EVERY FRAME\n    Camera camera = Camera_Get_Cached(iChannel1, iResolution);\n\n    mat4 model, view, rotation;\n    Camera_Model_View(camera, model, view, rotation);\n\n\n    // Generate ray and transform to world space\n    vec2 screen_coord = fragCoord / iResolution.xy;\n    vec2 centered = vec2(screen_coord.x - 0.5, screen_coord.y - 0.5);\n\n    float sensor_v = 2.0 * tan(Radians(camera.fov / 2.0));\n    float sensor_h = camera.aspect_ratio * sensor_v;\n\n    // In camera space, lies on plane at z = -1\n    vec3 scaled = vec3(centered.x * sensor_h, centered.y * sensor_v, -1.0);\n    Ray ray = Ray(vec3(0.0), normalize(scaled));\n    Ray_Transform(ray, model);\n\n\n    \n    Sphere sphere = Sphere(vec3(0.0, 0.0, -3.), 2.0);\n    float t = traceSphere(ray, sphere);\n    if (t >= 0.0) {\n        vec3 intersection_point = ray.origin + ray.direction * t;\n        vec3 color_norm = normalize(intersection_point - sphere.center);\n\n        color_norm = (color_norm + 1.) / 2.;\n        fragColor = vec4(color_norm, 1.0);\n        return;\n    }\n\n    \n    fragColor = vec4(0.0,0.0,0.0,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define VSCODE 0\n\n#define PI 3.14159\n#define UP vec3(0.0, 1.0, 0.0)\n#define Radians(x) ((x) * PI / 180.0)\n#define Degrees(x) ((x) * 180.0 / PI)\n\n\n// Utility Functions\n\nvec3 hsv2rgb(vec3 c)\n{\n    // from https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nmat4 euler_angles_to_rotation(vec3 ea) {\n    mat4 X = mat4(\n        vec4(1.0, 0.0, 0.0, 0.0),\n        vec4(0.0, cos(ea.x), -sin(ea.x), 0.0),\n        vec4(0.0, sin(ea.x), cos(ea.x), 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    mat4 Y = mat4(\n        vec4(cos(ea.y), 0.0, sin(ea.y), 0.0),\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(-sin(ea.y), 0.0, cos(ea.y), 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    mat4 Z = mat4(\n        vec4(cos(ea.z), -sin(ea.z), 0.0, 0.0),\n        vec4(sin(ea.z), cos(ea.z), 0.0, 0.0),\n        vec4(0.0, 0.0, 1.0, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n\n\n    return Z * Y * X;\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nvec3 Vector_Transform(vec3 v, mat4 m) {\n    return (m * vec4(v, 0.0)).xyz;\n}\n\nvoid Ray_Transform(inout Ray ray, mat4 m) {\n    vec4 homogeneous = m * vec4(ray.origin, 1.0);\n    ray.origin = homogeneous.xyz / homogeneous.w;\n\n    ray.direction = Vector_Transform(ray.direction, m);\n}\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\nstruct Camera {\n    vec3 position;\n    vec3 euler_angles;\n    //mat4 rotation;\n\n    float fov;\n    float aspect_ratio;\n\n    float move_sens;\n};\n\nCamera Camera_Reset(vec3 iResolution) {\n    // Matrices are in column major order\n    vec3 euler_angles = vec3(0.0, 0.0, 0.0);\n\n    return Camera(\n        vec3(0.0),\n        euler_angles,\n        90.0,\n        iResolution.x / iResolution.y,\n        0.015\n    );\n}\n\nvoid Camera_Model_View(Camera camera, out mat4 model, out mat4 view, out mat4 rotation) {\n    rotation = euler_angles_to_rotation(camera.euler_angles);\n    // Precomputes view\n    model = mat4(\n            vec4(1.0, 0.0, 0.0, 0.0),\n            vec4(0.0, 1.0, 0.0, 0.0),\n            vec4(0.0, 0.0, 1.0, 0.0),\n            vec4(camera.position.xyz, 1.0)\n        ) * rotation;\n\n    view = inverse(model);\n}\n\nCamera Camera_Get_Cached(sampler2D camera_channel, vec3 iResolution) {\n    vec3 position = texelFetch(camera_channel, ivec2(4, 0), 0).xyz;\n    vec3 euler_angles = texelFetch(camera_channel, ivec2(0, 0), 0).xyz;\n\n    return Camera(\n        position,\n        euler_angles,\n        90.0,\n        iResolution.x / iResolution.y,\n        0.015\n    );\n}", "buffer_b_code": "\n#if VSCODE\n#else\n#define KEYBOARD iChannel2\n\nconst int Key_W = 87;\nconst int Key_A = 65;\nconst int Key_S = 83;\nconst int Key_D = 68;\nconst int Key_Shift = 16;\nconst int Key_R = 82;\n\n\nbool isKeyDown(int key) {\n    return texelFetch(KEYBOARD, ivec2(key, 0), 0).x > 0.0;\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    int id = int(floor(fragCoord.x));\n    if (id >= 6 || fragCoord.y > 0.5) {\n        discard;\n    }\n\n    // id 0 computes position\n    // id 1 + i computes ith column of rotation\n    Camera camera = Camera_Reset(iResolution);\n    if (iFrame > 0) {\n        vec4 prev_iMouse = texelFetch(iChannel1, ivec2(5, 0), 0);\n        camera = Camera_Get_Cached(iChannel1, iResolution);\n\n        mat4 model, view, rotation;\n        Camera_Model_View(camera, model, view, rotation);\n\n        vec3 total_move = vec3(0.0);\n\n        if (isKeyDown(Key_Shift)) {\n            camera.move_sens *= 2.0;\n        }\n        if (isKeyDown(Key_W)) {\n            // Camera looks along -z axis, so \n            // take vector going along -z axis and transform\n            total_move += Vector_Transform(vec3(0.0, 0.0, -1.0), model);\n        }\n        if (isKeyDown(Key_S)) {\n            total_move += Vector_Transform(vec3(0.0, 0.0, 1.0), model);\n        }\n        if (isKeyDown(Key_D)) {\n            total_move += Vector_Transform(vec3(1.0, 0.0, 0.0), model);\n        }\n        if (isKeyDown(Key_A)) {\n            total_move += Vector_Transform(vec3(-1.0, 0.0, 0.0), model);\n        }\n\n        // Do translation\n        if (iMouse.z > 0.0) {\n            // Mouse is pressed, check if it was pressed last frame\n            if (prev_iMouse.z > 0.0) {\n                vec2 offset = (iMouse.xy - prev_iMouse.xy) * vec2(1.0, -1.0) * camera.move_sens;\n                //vec3 euler_change = vec3(0.0, offset.yx);\n                vec3 euler_change = vec3(offset.yx, 0.0);\n                \n                camera.euler_angles += euler_change;\n            }\n        }\n\n        if (length(total_move) > 0.0) {\n            camera.position += normalize(total_move) * camera.move_sens;\n        }\n\n        if (isKeyDown(Key_R)) {\n            camera = Camera_Reset(iResolution);\n        }\n    }\n\n    if (id == 0) {\n        fragColor = vec4(camera.euler_angles, 0.0);\n        return;\n    }\n    if (id == 4) {\n        fragColor = vec4(camera.position, 0.0);\n        return;\n    }\n    if (id == 5) {\n        fragColor = iMouse;\n        return;\n    }\n    //fragColor = camera.rotation[id];\n\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3SRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 168]], "test": "untested"}
{"id": "7tK3Wd", "name": "Time Gem", "author": "ruojake", "description": "A spinning cube, with a twist. A number of temporal modulations by scene depth, to be precise.", "tags": ["3d", "raytracing", "abstract"], "likes": 2, "viewed": 242, "published": 3, "date": "1638754568", "time_retrieved": "2024-07-30T18:43:52.325527", "image_code": "// Time Gem by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n#define LUM_COEFFS vec3(.2126, .7152, .0722)\n\nmat2 rot(float a)\n{\n    float s = sin(a),\n          c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 erot(vec3 p, vec3 ax, float a)\n{\n  return mix(dot(ax, p) * ax, p, cos(a)) + cross(ax, p) * sin(a);\n}\n\n// https://iquilezles.org/articles/intersectors\n// axis aligned box centered at the origin, extruded by radius r\nfloat rbi(vec3 ro, vec3 rd, float r)\n{\n    vec3 m = 1. / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * (r + 1.);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if(tN > tF || tF < 0.)\n        return -1.;\n    float t = tN;\n    \n    vec3 pos = ro + rd * t;\n    vec3 s = sign(pos);\n    ro  *= s;\n    rd  *= s;\n    pos *= s;\n        \n    pos -= 1.;\n    pos = max(pos.xyz, pos.yzx);\n    if(min(min(pos.x, pos.y), pos.z) < 0.) \n        return t;\n        \n    vec3 oc = ro - 1.;\n    vec3 dd = rd * rd;\n    vec3 oo = oc * oc;\n    vec3 od = oc * rd;\n    float ra2 = r * r;\n\n    t = 1e20;        \n\n    // corner\n    {\n        float b = od.x + od.y + od.z;\n        float c = oo.x + oo.y + oo.z - ra2;\n        float h = b * b - c;\n        if(h > 0.) t = -b - sqrt(h);\n    }\n    // edge X\n    {\n        float a = dd.y + dd.z;\n        float b = od.y + od.z;\n        float c = oo.y + oo.z - ra2;\n        float h = b * b - a * c;\n        if(h > 0.)\n        {\n            h = (-b - sqrt(h)) / a;\n            if(h > 0. && h < t && abs(ro.x + rd.x * h) < 1.)\n                t = h;\n        }\n    }\n    // edge Y\n    {\n        float a = dd.z + dd.x;\n        float b = od.z + od.x;\n        float c = oo.z + oo.x - ra2;\n        float h = b * b - a * c;\n        if(h > 0.)\n        {\n            h = (-b - sqrt(h)) / a;\n            if(h > 0. && h < t && abs(ro.y + rd.y * h) < 1.)\n                t = h;\n        }\n    }\n    // edge Z\n    {\n        float a = dd.x + dd.y;\n        float b = od.x + od.y;\n        float c = oo.x + oo.y - ra2;\n        float h = b * b - a * c;\n        if( h > 0. )\n        {\n            h = (-b - sqrt(h)) / a;\n            if(h > 0. && h < t && abs(ro.z + rd.z * h) < 1.)\n                t = h;\n        }\n    }\n\n    if( t > 1e19 ) t = -1.;\n    \n    return t;\n}\n\nvec4 render(vec3 ro, vec3 rd, float time)\n{\n    ro.xz *= -rot(time * .5);\n    ro.yx *= -rot(time * .4);\n    \n    rd.xz *= -rot(time * .5);\n    rd.yx *= -rot(time * .4);\n    \n    float t = rbi(ro, rd, .1);\n    if (t < 0.)\n        t = 100.;\n    vec3 p = ro + rd * t;\n    \n    return vec4(p, t);\n}\n\nvec3 normal(vec3 p, float t)\n{\n\treturn sign(p) * normalize(max(abs(p) - 1., 0.));\n}\n\nvec3 dither(vec2 p)\n{\n    float r = dot(vec3(p,float(iFrame % 60)), vec3(7., 11., 9.) / 13.);\n    return fract(vec3(r, r + .3334, r + .6667)) * 2. - 1.;\n}\n\nfloat lum(vec3 c)\n{\n    return dot(c, LUM_COEFFS);\n}\n\nvec3 color(float t)\n{\n    vec3 c = vec3(.4,.7,.01);\n    c *= LUM_COEFFS;\n    c = c * 2. - 1.;\n    c = erot(c, normalize(vec3(1, 1, 1)), -t) * .5 + .5;\n    c /= LUM_COEFFS;\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    vec3 ro = vec3(0, 0, -4);\n    vec3 rd = normalize(vec3(uv, 1.3));\n    \n    float t = iTime;\n    vec4 p = vec4(0);\n    for(int i = 0; i < 6; ++i)\n    {\n        ro -= rd * .3;\n        p = render(ro, rd, t);\n        t += p.w * (.5 + .5 * sin(iTime * .02));\n        if (p.w > 10.)\n            break;\n    }\n    \n    ro.xz *= -rot(t * .5);\n    ro.yx *= -rot(t * .4);\n    \n    rd.xz *= -rot(t * .5);\n    rd.yx *= -rot(t * .4);\n    \n    vec3 n = normal(p.xyz, t);\n    vec3 ld = normalize(vec3(1,0,1));\n    \n    ld.xz *= -rot(t * .5);\n    ld.yx *= -rot(t * .4);\n    \n    float l = dot(n, ld) * .5 + .5;\n    float spec = pow(dot(ld, reflect(rd, n)) * .5 + .5, 40.);\n    vec3 col = mix(color(iTime * .01) * l, vec3(l * 5.), l * l);\n    col += spec * 5.;\n    if (length(p.xyz) > 8.)\n        col = vec3(.85);\n\n    // reinhard tonemapping\n    float lumC = lum(col);\n    col *= (1. + lumC / 25.) / (1. + lumC);\n    \n    // saturation\n    col = mix(vec3(lum(col)), col, 1.5);\n    \n    // gamma\n    col = pow(col, vec3(1./2.2));\n    \n    // vignette\n    col *= smoothstep(1.5, .5, length(fragCoord - iResolution.xy * .5) / iResolution.y);\n    \n    // dithering\n    col += dither(fragCoord) / 256. - 1. / 512.;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tK3Wd.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[155, 155, 174, 174, 250], [252, 252, 289, 289, 357], [359, 472, 510, 510, 2323], [2325, 2325, 2368, 2368, 2619], [2621, 2621, 2651, 2651, 2704], [2706, 2706, 2727, 2727, 2860], [2862, 2862, 2881, 2881, 2914], [2916, 2916, 2937, 2937, 3103], [3105, 3105, 3160, 3160, 4461]], "test": "untested"}
{"id": "7lGGzc", "name": "chroma collapse", "author": "medium_fi", "description": "yet another color mixer", "tags": ["procedural"], "likes": 7, "viewed": 312, "published": 3, "date": "1638739283", "time_retrieved": "2024-07-30T18:43:53.141346", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = (iTime + 50.4)/ 14.;\n    float p = 0.4;\n    float c = 0.7;\n    float radius = 0.15;\n\n    // inside out\n    vec2 xy = fragCoord/min(iResolution.xy.x, iResolution.xy.y) - 0.5;\n    xy = 1. * (xy - 0.3 * vec2(cos(t*5.), sin(t*5.)));\n    vec2 uv = vec2(sqrt(xy.x * xy.x + xy.y * xy.y), atan(xy.y, xy.x));\n    float r = uv.x;\n    float inside = float(r < radius);\n    uv.x  = (1. -inside) * (r-radius) + (inside) * (radius / r - 1.);\n    uv.y  = (1. -inside) * uv.y + (inside) * -uv.y;\n    \n    // fold it\n    for (int i=0; i < 3; i++) {\n        uv = uv + t * 5. + cos(sin(t*7.) * uv.x * uv.y);\n        uv = 3. * cos(uv) * cos(uv);\n    }\n \n    // glow it\n    uv = p * floor(c * uv) / c + (1.- p) * uv * r;\n    fragColor = vec4(0.5 * cos(uv) + 0.5, 0.5 * sin(uv.x) + 0.5, 1.0);\n\n    float b = max((1. - inside) * cos(r/1.5),  0.);\n    b = b + exp(-20. * abs(r - radius));\n    fragColor = fragColor * vec4(b, b, b, 1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGGzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 990]], "test": "untested"}
{"id": "fldXRH", "name": "veinss", "author": "lomateron", "description": "this only has 2D velocity vectors\noriginally wanted the velocity to get atracted to neighbor velocity that is spining\naccidentally put an abs() in that calculation and this came out", "tags": ["convolution"], "likes": 72, "viewed": 916, "published": 3, "date": "1638717583", "time_retrieved": "2024-07-30T18:43:54.150648", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    vec4 a = texture(iChannel0,u);\n    fragColor =+sin(a.x*4.+vec4(1,3,5,4))*.25\n               +sin(a.y*4.+vec4(1,3,2,4))*.25\n               +.5;\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = vec4(0);\n    vec4  a = A(u);\n    float z = 6.;\n    float t = 0.;\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        vec2  ij= vec2(i,j);\n        vec2  c = ij*(3./z);\n        float l = length(ij);\n        ij /= l; if(l==0.){ij= vec2(0);}\n        float e = exp(-dot(c,c)); t+=e;\n        vec4 b = A(u+vec2(i,j))-a;\n        r.x += e*dot(b.xy,ij);\n        r.y += abs(e*dot(b.xy,ij.yx*vec2(-1,1)));\n    }}\n    fragColor = r/t;\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = A(u);\n    vec4  a = B(u);\n    float z = 6.;\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        vec2  ij= vec2(i,j);\n        vec2  c = ij*(3./z);\n        float l = length(ij);\n        ij /= l; if(l==0.){ij= vec2(0);}\n        float e = exp(-dot(c,c));\n        vec4 b = B(u+vec2(i,j));\n        r.xy += +(b.x)    *ij*e*.1\n                +(b.y-a.y)*ij*e*.5;\n    }}\n\n    fragColor = r;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\n#define C(u) texture(iChannel2,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 t = A(u);\n    vec2 m = +t.xy\n             +B(u).xy*(t.z-.5)*0.\n             +t.z*vec2(0,.0)\n             -C(u).x*t.xy*.0;\n    float s = 0.;\n    float z    = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n      vec2 c = (m+vec2(i,j))*1.;\n      s += exp(-dot(c,c));\n    }}\n    if(s==0.){s = 1.;}\n    s = 1./s;\n    \n    fragColor = vec4(m,s,0);\n}", "buffer_c_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 a = vec4(0);\n    float z    = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n      vec4 t = A(u+vec2(i,j)); t.z = 1.;\n      vec4 m = B(u+vec2(i,j));\n      vec2 c = (m.xy-vec2(i,j))*1.;\n      float z = exp(-dot(c,c))*m.z*t.z;\n      a.xy += z*m.xy;\n      a.z  += z;\n    }}\n    float tz = 1./a.z; if(a.z==0.){tz = 0.;}\n    a.xy *= tz;\n    //a = A(u);\n    if(iMouse.z>0.)\n    {\n        vec2 m = 22.*(u-iMouse.xy)/iResolution.y;\n        a += vec4(m,0,0)*exp(-dot(m,m))*-.2;\n    }\n    if(iFrame==0)\n    {\n        vec2 m = 22.*(u-iResolution.xy*.5)/iResolution.y;\n        a = vec4(m,1,1)*exp(-dot(m,m));\n    }\n    fragColor = a;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldXRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 245]], "test": "untested"}
{"id": "fltXRH", "name": "connected compo.in hexatruchets4", "author": "FabriceNeyret2", "description": "boost connected components calc. in hexatruchets https://shadertoy.com/view/fttXzn\nas in the quadri-truchet series ( e.g. https://www.shadertoy.com/view/NlGGRV )\nBoost done in current windows\nMouse.y: zoom     SPACE: reset    TAB: highlight 10% components", "tags": ["connected", "doodles", "truchets", "entanglement"], "likes": 13, "viewed": 368, "published": 3, "date": "1638716896", "time_retrieved": "2024-07-30T18:43:55.017330", "image_code": "// boost connected components calculation of https://shadertoy.com/view/fttXzn\n// coloring connected componant variant of https://shadertoy.com/view/flK3zc\n// variant with shadows https://shadertoy.com/view/flGGR3\n\n#define hue(v) vec4( .6 + .6 * cos( .5+(v)  + vec3(0,23,21)  ) ,1 )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    N*= 1.5;\n    if (length(iMouse.xy)>10.) N *= exp2(4.*(iMouse.y/R.y-.2)); // mouse zoom\n    float s = sqrt(3.), r = 1./s, a;\n    vec2 U = (N * u / R.y) * mat2(s,-1,0,2)/4. + 4.*iTime, // to tilted space\n         I = floor(U), V;                                // I : hexa tile ID\n    U = fract(U) *  mat2(1,.5,0,s/2.) - vec2(1,r)/2.;    // U : local coords\n    U += U.y*s+abs(U.x) < 0. ? I.y--,   + vec2( 0,r)     // Set to hexagon over the 3\n        : U.x < 0.           ? I.x--, -.5*vec2(-1,r)     //   covered by the tilted cell\n        :                             -.5*vec2( 1,r);\n // I.x += N;\n    O-=O;                                                // --- draw tiles\n\n    int t = typ(I);                                      // random tile type\n    a = float(ang(I))/6. *6.2831853;                     // random tile rotation\n    U *= mat2( cos( a - vec4(0,1.57,-1.57,0) ) );        // do rotation\n\n#define S(n,v)   vec2(n, smoothstep( N/R.y, 0., v ) )    // Draw among 3 types:\n#define C(n,v,r) S(n, abs(length(v)-r/2.) )           \n#define sha(x,y) S(0, length(U-vec2(x,y))-.1)    \n#define max(a,b) ( (a).y>(b).y ? a : b )\n    V = t==0 ?  max(max(C(1, U - vec2(.5,-r/2.) , r),    // 3 short turns\n                        C(2, U + vec2(.5, r/2.) , r)),\n                        C(0, U - vec2(0,r), r) )\n      : t==1 ?  max(max(C(1, U - vec2(.5,-s/2.), s),     // 2 larges + 1 short\n                        C(2, U + vec2(.5, s/2.), s) - sha(0,-.17) ),   // - shadow\n                        C(0, U - vec2(0,r), r))\n      :         max(max(C(2, U - vec2(.5,-s/2.), s),     // 2 larges + 1 line\n                        C(1, U + vec2(.5,-s/2.), s) - sha(-.08,.12) ), // - shadow\n                        S(0, abs(U.x*s+U.y) / 2.)   - sha(.08,-.12) ); // - shadow\n    O += V.y;                                            // Vx: #thread Vy: mask\n\n    O *= hue(T(I)[int(V.x)] );                     // show connected components\n    if ( keyToggle(9) && int(T(I)[int(V.x)])%10 > 0) O*=.3; // TAB: enlight 10%\n // if (iMouse.z > 0.) { O += (1.-O.a)*.4*hue(6.28*fract(1e4*sin(I.y + I.x*N))); return; } // if click show tiling\n} ", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define H(p)   fract(sin(dot(p, vec2(12.9898, 78.233))-floor(iTime)) * 43758.5453)\n\n// the define version doesn't work on Windows\nint t,a; vec2 U;\nfloat n( int d) {\n    vec4 T = T( U+ vec2[](vec2(-1,1),vec2(-1,0),vec2(0,-1),vec2(1, -1),vec2(1,0),vec2(0,1))[(d+a)%6] );\n    int  A = ( d + a - (int(T.a)%8) +3 +6 )%6,\n         n = int(T.a)/8;\n    return T[ int[](0, n>1?1:2, n==1?1:2, (n+1)%3, n<2?1:2, n<2?0:1)[A] ];\n}\n//#define n(d) ( T = T( U+ vec2[](vec2(-1,1),vec2(-1,0),vec2(0,-1),vec2(1, -1),vec2(1,0),vec2(0,1))[(d+a)%6] ), \\\n//               A = ( d + a - (int(T.a)%8) +3 +6 )%6,    \\\n//               n = int(T.a)/8,                          \\\n//               T[ int[](0, n>1?1:2, n==1?1:2, (n+1)%3, n<2?1:2, n<2?0:1)[A] ] )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    U = u-.5;\n    if (iFrame < 1 || keyDown(32) ) {\n        O.a = 8.* floor(3.*H(U))                       // random tile type\n            + floor(6.*H(U+.5));                       // random tile rotation\n        O.xyz = U.y + U.x*4096. + vec3(0,.3,.6);       // init ids#1,2,3\n        return;\n    }\n    O = T(U);                                 // recover previous state\n    t = typ(U), a = ang(U);                   // tile type and angle\n    \n                                              // --- propagate id along connections\n                                              // read id in neighbor in direction d\n\n    if (t==0) {       // tile type #0   For each thread, new id = min(connections)\n        O.x = min( O.x, min( n(5), n(0) ));\n        O.y = min( O.y, min( n(3), n(4) ));\n        O.z = min( O.z, min( n(1), n(2) ));\n    }\n    else if (t==1) {  // tile type #1   For each thread, new id = min(connections)\n        O.x = min( O.x, min( n(5), n(0) ));\n        O.y = min( O.y, min( n(2), n(4) ));\n        O.z = min( O.z, min( n(1), n(3) ));\n    }\n    else  {           // tile type #2   For each thread, new id = min(connections)\n        O.x = min( O.x, min( n(0), n(3) ));\n        O.y = min( O.y, min( n(1), n(5) ));\n        O.z = min( O.z, min( n(2), n(4) ));\n    }\n                  // --- shortcut: at color change, update the color source pixel\n  //if (iFrame%2<1) return; // to not count twice the same change\n    N *= 2.;\n    float Nx = floor(N*R.x/R.y), s = sqrt(3.);\n    vec2 //D = mat2(1,.5,0,s/2.) * vec2(4.*iTime);       // track only the screen region\n         D = vec2(4.*iTime);\n  //D = floor(R*fract(1e3*iTime*vec2(1,.7813)));         // random updates pages\n  //D = floor(R*fract(1e3*sin(U*mat2(R,174.-R)-iTime))); // full random updates\n    for( float j = 0.; j < N/8.; j++)\n        for( float i = 0.; i < Nx/8.; i++) {\n            vec4 T = T1( mod(D/8.+vec2(i,j),R/8.) );\n            vec2 o = T.xy, n = T.zw;          // changed old->new value\n            if (O.x==o.x) O.x = n.x;          // oldvalue was my seg1 : update\n            if (O.x==o.y) O.x = n.y;          // (only 2 values are stored in bufB)\n            if (O.y==o.x) O.y = n.x;          // oldvalue was my seg2 : update\n            if (O.y==o.y) O.y = n.y;\n            if (O.z==o.x) O.z = n.x;          // oldvalue was my seg3 : update\n            if (O.z==o.y) O.z = n.y;\n        }\n} ", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float N = 32.;                                    // vertical number of tiles\n\n#define typ(U) int(T(U).a)/8                      // decode tile type and angle\n#define ang(U) int(T(U).a)%8\n\n#define R               iResolution.xy\n#define T(U)            texelFetch(iChannel0, ivec2(U+R) % ivec2(R), 0 )\n#define T1(U)           texelFetch(iChannel1, ivec2(U), 0 )\n#define keyToggle(c)  ( texelFetch(iChannel3,ivec2(c,2),0).x > 0.)\n#define keyDown(c)    ( texelFetch(iChannel3,ivec2(c,1),0).x > 0.)\n", "buffer_b_code": "// --- reduction map of change\n// We should treat the change in any 3 threads per tile, but this requires storing 6 floats.\n// -> instead of duplicating loops and storage to fit vec4, we just test 2 threads.\n// Correlation in neighbor tiles should capture the 3rd.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U-=.5;\n    if (U.x > R.x/8. || U.y > R.y/8. ) return;\n    \n    O-=O;\n    for (int k=0; k < 64; k++ ) {\n        vec2 V = 8.*U + vec2(k%8,k/8);\n        vec4 o = T1(V),                         // old vs new value\n             n = T (V);\n        if ( o.x != n.x ) O.xz = vec2(o.x,n.x); // if changed, store \n        if ( o.y != n.y ) O.yw = vec2(o.y,n.y);\n        if (O.x*O.y!=0.) break;\n    }    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// --- keep previous version\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T(U);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fltXRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[284, 284, 322, 322, 2449]], "test": "untested"}
{"id": "fttXRH", "name": "SCOTLAND FOREVER", "author": "RubberDuck55", "description": "still need to add music", "tags": ["scotland"], "likes": 3, "viewed": 246, "published": 3, "date": "1638716839", "time_retrieved": "2024-07-30T18:43:56.028627", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv *= 1.2;\n    \n    uv.y += sin((uv.x+iTime/2.5)*10.)/15.;\n    uv.x += sin((uv.y+iTime/2.5)*2.)/20.;\n\n    vec3 col = vec3(0);\n    if(uv.x <= 0.5 && uv.x >= -0.5 && uv.y <= 0.5 && uv.y >= -0.5) {\n        col = vec3(0, 65./255., 191./255.);\n        float w = fwidth(uv.x);\n        col += vec3(smoothstep(0.9-w, 0.9+w, 1.-abs(uv.x+uv.y)));\n        col += vec3(smoothstep(0.9-w, 0.9+w, 1.-abs(uv.x-uv.y)));\n        col = clamp(col, 0., 1.);\n        col *= (sin((uv.x+iTime/2.5)*10.)/9.)+0.8;\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "vec2 mainSound( int samp, float time )\n{\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttXRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 684]], "test": "untested"}
{"id": "fttSR8", "name": "Forkscape", "author": "dr2", "description": "Hills covered with bending reflective forks (why?)", "tags": ["reflection", "landscape", "fork"], "likes": 13, "viewed": 369, "published": 3, "date": "1638703203", "time_retrieved": "2024-07-30T18:43:57.201490", "image_code": "// \"Forkscape\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec4 Hashv4v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nstruct GrParm {\n  float gFac, hFac, fWav, aWav;\n};\nGrParm gr;\n\nstruct Arc {\n  vec2 cs;\n  float chDist, rad, ang;\n};\nArc arcc[3];\n\nstruct GrStat {\n  vec3 rPos;\n  float sAng, fSize;\n  Arc arc;\n};\nGrStat gst;\n\nvec4 dateCur;\nvec3 sunDir, qHit;\nvec2 gId;\nfloat tCur, dstFar, hgSize;\nint idObj;\nconst float pi = 3.1415927, sqrt3 = 1.732051;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GrndHt (vec2 p)\n{ // (from \"Desert Reflections 2\")\n  mat2 qRot;\n  vec2 q;\n  float f, wAmp;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8) * gr.fWav;\n  q = gr.gFac * p;\n  wAmp = 4. * gr.hFac;\n  f = 0.;\n  for (int j = 0; j < 4; j ++) {\n    f += wAmp * Noisefv2 (q);\n    wAmp *= gr.aWav;\n    q *= qRot;\n  }\n  return f;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 0.8 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nfloat GrndHtN (vec2 p)\n{\n  return GrndHt (p) + 0.04 * Fbm2 (8. * p.yx);\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHtN (p.xz) - vec2 (GrndHtN (p.xz + e.xy),\n     GrndHtN (p.xz + e.yx)), e.x)).xzy;\n}\n\nvoid SetGrdConf ()\n{\n  vec4 h;\n  vec2 p;\n  int j;\n  p = HexToPix (gId * hgSize);\n  h = Hashv4v2 (17.1 * gId + 0.3);\n  gst.rPos.xz = 0.2 * hgSize * sin (2. * pi * h.x + vec2 (0.5 * pi, 0.));\n  gst.rPos.y = GrndHt (HexToPix (gId * hgSize) + gst.rPos.xz);\n  gst.sAng = 0.1 * (h.z - 0.5) * tCur;\n  j = int (mod (2. * gId + gId.yx, 3.));\n  if (j == 0) gst.arc = arcc[0];\n  else if (j == 1) gst.arc = arcc[1];\n  else gst.arc = arcc[2];\n  gst.fSize = 0.8 + 0.2 * h.w;\n  if (abs (p.x) < 0.5 * sqrt3 * hgSize || h.y < 0.2) gst.fSize = 0.;\n}\n\n#define F(x) (sin (x) / x - b)\n\nfloat SecSolve (float b)\n{  // (from \"Bucking Bronco\")\n  vec3 t;\n  vec2 f;\n  float x;\n  if (b < 0.95) {\n    t.yz = vec2 (0.7, 1.2);\n    f = vec2 (F(t.y), F(t.z));\n    for (int nIt = 0; nIt < 4; nIt ++) {\n      t.x = (t.z * f.x - t.y * f.y) / (f.x - f.y);\n      t.zy = t.yx;\n      f = vec2 (F(t.x), f.x);\n    }\n    x = t.x;\n  } else if (b < 1.) {\n    x = sqrt (10. * (1. - sqrt (1. - 1.2 * (1. - b))));\n  } else {\n    x = 0.;\n  }\n  return x;\n}\n\nvoid ArcConf ()\n{\n  float segRot, chLen;\n  for (int k = 0; k < 3; k ++) {\n    segRot = 0.99 * pi * (0.5 + 0.5 * sin ((1. + 0.1 * float (k)) * 0.5 * tCur));\n    chLen = length (vec2 (2. * sin (0.5 * segRot), 1.));\n    arcc[k].ang = max (1e-4, SecSolve (chLen / sqrt(5.)));\n    arcc[k].chDist = chLen / tan (arcc[k].ang);\n    arcc[k].rad = sqrt (arcc[k].chDist * arcc[k].chDist + chLen * chLen);\n    arcc[k].cs = sin (- arcc[k].ang + vec2 (0.5 * pi, 0.));\n  }\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, rr, sk, bLen[2];\n  dMin = dstFar;\n  if (gst.fSize > 0.) {\n    p.xz -= HexToPix (gId * hgSize);\n    p -= gst.rPos;\n    q = p;\n    q.y -= -1.;\n    d = PrCylDf (q.xzy, 0.5, 2.);\n    DMINQ (1);\n    p.y -= 1.;\n    dMin /= gst.fSize;\n    p /= gst.fSize;\n    bLen[0] = 1.;\n    bLen[1] = 1.;\n    rr = gst.arc.rad * gst.arc.cs.y;\n    p.y -= 1.;\n    p.xz = Rot2D (p.xz, gst.sAng);\n    p.xy = vec2 (- p.y, p.x) - vec2 (1.5 * rr - bLen[1], gst.arc.chDist - gst.arc.rad);\n    for (int k = 0; k < 2; k ++) {\n      sk = sign (float (k) - 0.5);\n      q = p;\n      q.y *= - sk;\n      q.xy -= vec2 (rr * (sk - 0.5), - gst.arc.chDist);\n      d = max (max (PrRoundBox2Df (vec2 (length (q.xy) - gst.arc.rad, abs (q.z) - 0.27),\n         vec2 (0., 0.18), 0.07), dot (vec2 (abs (q.x), q.y), gst.arc.cs)), - sk * q.x);\n      DMINQ (2);\n      q.xy -= vec2 (- bLen[k] * sk, gst.arc.rad);\n      d = PrRoundBoxDf (vec3 (q.xy, abs (q.z) - 0.27), vec3 (bLen[k], 0., 0.18), 0.07);\n      if (k == 1) d = SmoothMax (SmoothMin (d, PrRoundBoxDf (q - vec3 (-0.1 * bLen[1], 0., 0.),\n         vec3 (0.9 * bLen[1], 0.05, 0.5), 0.05), 0.1), - max (PrCaps2Df (vec2 (mod (q.z + 0.15, 0.3) -\n         0.15, q.x + 0.5), 0.08, 1.), abs (q.z) - 0.5), 0.03);\n      else d = SmoothMin (d, PrRoundBoxDf (q - vec3 (0.1 * bLen[0], 0., 0.),\n         vec3 (0.9 * bLen[0], 0.05, 0.6), 0.1), 0.1);\n      DMINQ (2);\n    }\n    dMin *= gst.fSize;\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.01;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrdConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) dHit += d;\n    else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.2, 0.3, 0.7), vec3 (0.4, 0.4, 0.7), pow (1. - max (rd.y, 0.), 8.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float sd, f;\n  ro.x -= tCur;\n  sd = max (dot (rd, sunDir), 0.);\n  f = Fbm2 (0.05 * (ro + rd * (100. - ro.y) / (rd.y + 0.0001)).xz);\n  return mix (SkyBg (rd) + vec3 (1., 1., 0.9) * (0.3 * pow (sd, 32.) + 0.2 * pow (sd, 512.)),\n     vec3 (1., 1., 0.95) * (1. - 0.1 * smoothstep (0.8, 0.95, f)), clamp (0.9 * f * rd.y, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstGrnd, dstObj, dFac, dMin, f, sh;\n  bool isRef;\n  ArcConf ();\n  dstObj = ObjRay (ro, rd);\n  dstGrnd = GrndRay (ro, rd);\n  isRef = false;\n  if (dstObj < min (dstGrnd, dstFar) && idObj == 2) {\n    isRef = true;\n    ro += dstObj * rd;\n    gId = PixToHex (ro.xz / hgSize);\n    vn = ObjNf (ro);\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n    dstGrnd = GrndRay (ro, rd);\n  }\n  dMin = min (dstObj, dstGrnd);\n  if (dMin < dstFar) {\n    dFac = 1. - smoothstep (0.35, 0.5, dMin / dstFar);\n    ro += dMin * rd;\n    if (dstObj < dstGrnd) {\n      vn = ObjNf (ro);\n      if (idObj == 1) {\n        vn = VaryNf (8. * qHit, vn, 4. * dFac);\n        col = vec3 (0.8);\n      } else if (idObj == 2) {\n        col = vec3 (0.8, 0.8, 1.);\n      }\n      col *= 0.7 + 0.3 * dFac;\n    } else {\n      vn = GrndNf (ro);\n      col = 0.9 * mix (vec3 (0.7, 0.9, 0.5), vec3 (0.8, 1., 0.5), smoothstep (3., 4., ro.y)) *\n         (1. - 0.3 * dFac * Fbm2 (2. * ro.xz));\n      if (dFac > 0.) {\n        gId = PixToHex (ro.xz / hgSize);\n        SetGrdConf ();\n        if (gst.fSize > 0.) col *= 0.8 + 0.2 * smoothstep (0.5, 0.8, length (ro.xz -\n           HexToPix (gId * hgSize) - gst.rPos.xz));\n      }\n    }\n    sh = 1. - 0.5 * smoothstep (0.3, 0.7, Fbm2 (0.03 * ro.xz - tCur * vec2 (0.15, 0.)));\n    col *= 0.2 + 0.1 * max (0., vn.y) + 0.7 * sh * max (0., dot (vn, sunDir));\n    if (isRef) col = vec3 (1., 0.9, 0.8) * mix (col, vec3 (1.), 0.1);\n    col = mix (col, SkyBg (rd), pow (dMin / dstFar, 4.));\n  } else if (rd.y < 0.) {\n    col = SkyBg (rd);\n  } else col = SkyCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, t, hSum;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur + 10., 2400.) + 30. * floor (dateCur.w / 7200.);\n  az = 0.;\n  el = -0.01 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.2 * pi * sin (0.03 * pi * tCur);\n  }\n  hgSize = 8.;\n  gr.gFac = 0.1;\n  gr.hFac = 1.3;\n  gr.fWav = 1.9;\n  gr.aWav = 0.45;\n  dstFar = 150.;\n  vuMat = StdVuMat (el, az);\n  t = 3. * tCur;\n  hSum = 0.;\n  for (float k = 0.; k < 5.; k ++) hSum += GrndHt (vec2 (0., t + 0.7 * (k - 1.)));\n  ro = vec3 (0.1, 4. * gr.hFac + hSum / 5., t);\n  sunDir = normalize (vec3 (-1., 1., -1.));\n  rd = vuMat * normalize (vec3 (uv, 3.));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39);\n  return fract (sin (dot (p, cHashVA2) + vec4 (0., cHashVA2.xy, cHashVA2.x + cHashVA2.y)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttSR8.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1111, 1111, 1134, 1167, 1423], [1425, 1425, 1459, 1459, 1939], [1941, 1941, 1965, 1965, 2014], [2016, 2016, 2038, 2038, 2185], [2187, 2187, 2207, 2207, 2718], [2752, 2752, 2778, 2806, 3194], [3196, 3196, 3213, 3213, 3655], [3657, 3657, 3679, 3679, 5115], [5117, 5117, 5150, 5150, 6324], [6326, 6326, 6347, 6347, 6602], [6604, 6604, 6626, 6626, 6739], [6741, 6741, 6773, 6773, 7103], [7105, 7105, 7140, 7140, 8781], [8783, 8783, 8839, 8839, 9792], [9794, 9794, 9836, 9836, 9887], [9889, 9889, 9935, 9935, 9982], [9984, 9984, 10031, 10031, 10078], [10080, 10080, 10124, 10124, 10184], [10186, 10186, 10210, 10210, 10440], [10442, 10442, 10466, 10466, 10526], [10528, 10528, 10573, 10573, 10665], [10667, 10667, 10712, 10712, 10750], [10752, 10752, 10774, 10774, 10812], [10814, 10814, 10844, 10844, 10957], [10959, 10959, 10995, 10995, 11201], [11235, 11235, 11259, 11259, 11371], [11373, 11373, 11397, 11397, 11534], [11536, 11536, 11561, 11561, 11747], [11749, 11749, 11770, 11770, 11925], [11927, 11927, 11956, 11956, 12168], [12170, 12170, 12209, 12209, 12461]], "test": "untested"}
{"id": "stcXzH", "name": "connected compo.in hexatruchets5", "author": "FabriceNeyret2", "description": "stochastic rather than window boost connected components calc. in hexatruchets https://shadertoy.com/view/fttXzn\nas in the quadri-truchet series ( e.g. https://www.shadertoy.com/view/NlGGRV )\nMouse.y: zoom     SPACE: reset    TAB: highlight 10% components", "tags": ["connected", "doodles", "truchets", "entanglement"], "likes": 9, "viewed": 391, "published": 3, "date": "1638700467", "time_retrieved": "2024-07-30T18:43:58.322493", "image_code": "// faster boost version of https://www.shadertoy.com/view/fltXRH\n// boost connected components calculation of https://shadertoy.com/view/fttXzn\n// coloring connected componant variant of https://shadertoy.com/view/flK3zc\n// variant with shadows https://shadertoy.com/view/flGGR3\n\n#define hue(v) vec4( .6 + .6 * cos( .5+(v)  + vec3(0,23,21)  ) ,1 )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    N*= 1.5;\n    if (length(iMouse.xy)>10.) N *= exp2(4.*(iMouse.y/R.y-.2)); // mouse zoom\n    float s = sqrt(3.), r = 1./s, a;\n    vec2 U = (N * u / R.y) * mat2(s,-1,0,2)/4. + 4.*iTime, // to tilted space\n         I = floor(U), V;                                // I : hexa tile ID\n    U = fract(U) *  mat2(1,.5,0,s/2.) - vec2(1,r)/2.;    // U : local coords\n    U += U.y*s+abs(U.x) < 0. ? I.y--,   + vec2( 0,r)     // Set to hexagon over the 3\n        : U.x < 0.           ? I.x--, -.5*vec2(-1,r)     //   covered by the tilted cell\n        :                             -.5*vec2( 1,r);\n // I.x += N;\n    O*=0.;                                               // --- draw tiles\n\n    int t = typ(I);                                      // random tile type\n    a = float(ang(I))/6. *6.2831853;                     // random tile rotation\n    U *= mat2( cos( a - vec4(0,1.57,-1.57,0) ) );        // do rotation\n\n#define S(n,v)   vec2(n, smoothstep( N/R.y, 0., v ) )    // Draw among 3 types:\n#define C(n,v,r) S(n, abs(length(v)-r/2.) )           \n#define sha(x,y) S(0, length(U-vec2(x,y))-.1)    \n#define max(a,b) ( (a).y>(b).y ? a : b )\n    V = t==0 ?  max(max(C(1, U - vec2(.5,-r/2.) , r),    // 3 short turns\n                        C(2, U + vec2(.5, r/2.) , r)),\n                        C(0, U - vec2(0,r), r) )\n      : t==1 ?  max(max(C(1, U - vec2(.5,-s/2.), s),     // 2 larges + 1 short\n                        C(2, U + vec2(.5, s/2.), s) - sha(0,-.17) ),   // - shadow\n                        C(0, U - vec2(0,r), r))\n      :         max(max(C(2, U - vec2(.5,-s/2.), s),     // 2 larges + 1 line\n                        C(1, U + vec2(.5,-s/2.), s) - sha(-.08,.12) ), // - shadow\n                        S(0, abs(U.x*s+U.y) / 2.)   - sha(.08,-.12) ); // - shadow\n    O += V.y;                                            // Vx: #thread Vy: mask\n\n    O *= hue(T(I)[int(V.x)] );                     // show connected components\n    if ( keyToggle(9) && int(T(I)[int(V.x)])%10 > 0) O*=.3; // TAB: enlight 10%\n // if (iMouse.z > 0.) { O += (1.-O.a)*.4*hue(6.28*fract(1e4*sin(I.y + I.x*N))); return; } // if click show tiling\n} ", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define H(p)   fract(sin(dot(p, vec2(12.9898, 78.233))-floor(iTime)) * 43758.5453)\n\n// the #define version doesn't work on Windows\nint t,a; vec2 U;\nfloat n( int d) {\n    vec4 T = T( U+ vec2[](vec2(-1,1),vec2(-1,0),vec2(0,-1),vec2(1, -1),vec2(1,0),vec2(0,1))[(d+a)%6] );\n    int  A = ( d + a - (int(T.a)%8) +3 +6 )%6,\n         n = int(T.a)/8;\n    return T[ int[](0, n>1?1:2, n==1?1:2, (n+1)%3, n<2?1:2, n<2?0:1)[A] ];\n}\n//#define n(d) ( T = T( U+ vec2[](vec2(-1,1),vec2(-1,0),vec2(0,-1),vec2(1, -1),vec2(1,0),vec2(0,1))[(d+a)%6] ), \\\n//               A = ( d + a - (int(T.a)%8) +3 +6 )%6,    \\\n//               n = int(T.a)/8,                          \\\n//               T[ int[](0, n>1?1:2, n==1?1:2, (n+1)%3, n<2?1:2, n<2?0:1)[A] ] )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    U = u-.5;\n    if (iFrame < 1 || keyDown(32) ) {\n        O.a = 8.* floor(3.*H(U))                       // random tile type\n            + floor(6.*H(U+.5));                       // random tile rotation\n        O.xyz = U.y + U.x*4096. + vec3(0,.3,.6);       // init ids#1,2,3\n        return;\n    }\n    O = T(U);                                 // recover previous state\n    t = typ(U), a = ang(U);                   // tile type and angle\n    \n                                              // --- propagate id along connections\n                                              // read id in neighbor in direction d\n\n    if (t==0) {       // tile type #0   For each thread, new id = min(connections)\n        O.x = min( O.x, min( n(5), n(0) ));\n        O.y = min( O.y, min( n(3), n(4) ));\n        O.z = min( O.z, min( n(1), n(2) ));\n    }\n    else if (t==1) {  // tile type #1   For each thread, new id = min(connections)\n        O.x = min( O.x, min( n(5), n(0) ));\n        O.y = min( O.y, min( n(2), n(4) ));\n        O.z = min( O.z, min( n(1), n(3) ));\n    }\n    else  {           // tile type #2   For each thread, new id = min(connections)\n        O.x = min( O.x, min( n(0), n(3) ));\n        O.y = min( O.y, min( n(1), n(5) ));\n        O.z = min( O.z, min( n(2), n(4) ));\n    }\n                      // --- shortcut: at color change, update the color source pixel\n  //if (iFrame%2<1) return; // to not count twice the same change\n    N *= 2.;\n    float Nx = floor(N*R.x/R.y), s = sqrt(3.);\n    vec2 //D = mat2(1,.5,0,s/2.) * vec2(4.*iTime);       // track only the screen region\n         D = vec2(4.*iTime);\n  //D = floor(R*fract(1e3*iTime*vec2(1,.7813)));         // random updates pages\n    D = floor(R*fract(1e3*sin(U*mat2(R,174.-R)-iTime))); // full random updates\n    for( float j = 0.; j < N/8.; j++)\n        for( float i = 0.; i < Nx/8.; i++) {\n            vec4 T = T1( mod(D/8.+vec2(i,j),R/8.) );\n            vec2 o = T.xy, n = T.zw;          // changed old->new value\n            if (O.x==o.x) O.x = n.x;          // oldvalue was my seg1 : update\n            if (O.x==o.y) O.x = n.y;          // (only 2 values are stored in bufB)\n            if (O.y==o.x) O.y = n.x;          // oldvalue was my seg2 : update\n            if (O.y==o.y) O.y = n.y;\n            if (O.z==o.x) O.z = n.x;          // oldvalue was my seg3 : update\n            if (O.z==o.y) O.z = n.y;\n        }\n} ", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float N = 32.;                                    // vertical number of tiles\n\n#define typ(U) int(T(U).a)/8                      // decode tile type and angle\n#define ang(U) int(T(U).a)%8\n\n#define R               iResolution.xy\n#define T(U)            texelFetch(iChannel0, ivec2(U+R) % ivec2(R), 0 )\n#define T1(U)           texelFetch(iChannel1, ivec2(U), 0 )\n#define keyToggle(c)  ( texelFetch(iChannel3,ivec2(c,2),0).x > 0.)\n#define keyDown(c)    ( texelFetch(iChannel3,ivec2(c,1),0).x > 0.)\n", "buffer_b_code": "// --- reduction map of change\n// We should treat the change in any 3 threads per tile, but this requires storing 6 floats.\n// -> instead of duplicating loops and storage to fit vec4, we just test 2 threads.\n// Correlation in neighbor tiles should capture the 3rd.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U-=.5;\n    if (U.x > R.x/8. || U.y > R.y/8. ) return;\n    \n    O*=0.;\n    for (int k=0; k < 64; k++ ) {\n        vec2 V = 8.*U + vec2(k%8,k/8);\n        vec4 o = T1(V),                         // old vs new value\n             n = T (V);\n        if ( o.x != n.x ) O.xz = vec2(o.x,n.x); // if changed, store \n        if ( o.y != n.y ) O.yw = vec2(o.y,n.y);\n        if (O.x*O.y!=0.) break;\n    }    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// --- keep previous version\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T(U);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcXzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[349, 349, 387, 387, 2514]], "test": "untested"}
{"id": "ft3XR8", "name": "Wave propagation in an ellipse", "author": "Dev1ati0n", "description": "Uses Euler's wave equation to calculate wave propagation.\n\n\nMore info here: wikipedia.org/wiki/Wave_equation", "tags": ["wave", "waveequation", "wavepropagation"], "likes": 3, "viewed": 291, "published": 3, "date": "1638693001", "time_retrieved": "2024-07-30T18:43:59.166237", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if(texture(iChannel1,uv).r==0.){\n        vec2 diff = fragCoord-0.5*iResolution.xy;\n        if(0.51*diff.x*diff.x+diff.y*diff.y<95000.){fragColor = vec4(0.1,0.1,0.9,1.0);}\n        else{fragColor = vec4(0.,0.,0.1,1.0);}\n    }\n    else{\n        fragColor = texture(iChannel0,uv)+0.5;\n        fragColor.rgb *= vec3(0.5,0.5,0.2);\n        fragColor.rgb += vec3(0.1,0.5,0.9);\n    }\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// The derivative (rate of change) of the wave amplitude\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = 1./iResolution.xy;\n    vec2 uv = fragCoord*pixel;\n    // Fetch values of neighcoring pixels\n    float values[5];\n    values[0] = texture(iChannel1,uv).r;\n    values[1] = texture(iChannel1,uv+vec2(0.0, 1.0)*pixel).r;\n    values[2] = texture(iChannel1,uv+vec2(0.0,-1.0)*pixel).r;\n    values[3] = texture(iChannel1,uv+vec2(1.0, 0.0)*pixel).r;\n    values[4] = texture(iChannel1,uv+vec2(-1.0,0.0)*pixel).r;\n    // Wave Equation: du/dt=c(du/dx+du/dy)\n    float deriv = values[1]+values[2]+values[3]+values[4]-4.*values[0]; // Calculates du/dx+du/dy\n    float c = texture(iChannel2,uv).r; // Fetch value of c\n    fragColor = vec4(texture(iChannel0,uv).r+timescale*c*c*deriv); // Add c(du/dx+du/dy) to the previous value\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(timescale*texture(iChannel0,uv)+texture(iChannel1,uv)); // Add the derivative to the previous value\n    // Add disturbance\n    vec2 diff = fragCoord-0.5*iResolution.xy;\n    diff.x += 300.;\n    fragColor += 0.05*sin(.1*float(iFrame))*exp(-0.05*dot(diff,diff));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Wave propagation speed\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame>0){fragColor = texture(iChannel0,fragCoord/iResolution.xy); return;} // Reload previous\n    // Draw ellipse\n    vec2 diff = fragCoord-0.5*iResolution.xy;\n    if(0.5*diff.x*diff.x+diff.y*diff.y>90000.){fragColor = vec4(0.);}\n    else{fragColor = vec4(1.);}\n}", "buffer_c_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Speed of simulation. Higher values are faster, but less accurate and more buggy. \nfloat timescale = 0.5;", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3XR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 478]], "test": "untested"}
{"id": "7t3Xz8", "name": "Relaxed Sphere Marching", "author": "paniq", "description": "Analytic RDF functions for circles and rectangles. Also demonstrates relaxed sphere marching through a relaxed distance field :) see https://www.shadertoy.com/view/flcXRH for more information.", "tags": ["2d", "vector", "library", "graphics"], "likes": 15, "viewed": 470, "published": 3, "date": "1638687094", "time_retrieved": "2024-07-30T18:44:00.295219", "image_code": "//////////////////////////////////////////////////////////\n\nvec2 rd_rect(vec2 p, vec2 r) {\n    vec2 ap = abs(p);\n    vec2 q = ap - r;\n    vec2 s = ap + r;\n    float h;\n    if (q.x*q.y > 0.0) { // corner\n        vec2 qa = vec2(q.x, s.y);\n        vec2 qb = vec2(s.x, q.y);\n        h = sqrt(min(dot(qa,qa),dot(qb,qb)));\n    } else { // edge\n        h = (ap.x > ap.y)?s.x:s.y;\n        h = min(h, length(q));\n    }\n    float d = length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n    return vec2(d, (d < 0.)?(1./0.):h);\n}\n\nvec2 rd_circle(vec2 p, float r) {\n    float dd = dot(p,p);\n    float d = sqrt(dd) - r;\n    float h = dd - r*r;\n    h = (h < 0.0)?(1./0.):sqrt(h);\n    return vec2(d, h);\n}\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c) * p;\n}\n\nvec2 rd_neg(vec2 a) {\n    return vec2(-a.x, a.y);\n}\n\nvec2 rd_min(vec2 a, vec2 b) {\n    int s = int(a.y == (1./0.)) + int(b.y == (1./0.));\n    float r;\n    float d = min(a.x, b.x);\n    if (s == 2) {\n        r = 1./0.;\n    } else if (s == 1) {\n        r = min(min(a.y, b.y), max(abs(a.x),abs(b.x)));\n    } else {\n        r = max(-d, min(a.y, b.y));\n    }\n    return vec2(d, r);\n}\n\nvec2 map(vec2 q) {\n#if 0\n    vec2 d1 = rd_circle(q - vec2(0.3,0.4), 0.2);\n    vec2 d2 = rd_circle(q - vec2(0.2), 0.3);\n    return rd_neg(rd_min(rd_neg(d1),rd_neg(d2)));\n#else\n    vec2 d1 = rd_circle(q - vec2(0.3,0.4), 0.2);\n    vec2 d2 = rd_circle(q - vec2(-0.2,-0.3), 0.3);\n    vec2 d4 = rd_rect(rotate(q - vec2(0.5, 0.0),radians(iTime*10.0)), vec2(0.3,0.1));\n    \n    vec2 d5 = rd_rect(q, vec2(0.3,0.1));\n    \n    float b = (sin(iTime)*0.5+0.5)*0.1;\n    return rd_min(d2,rd_min(d4, d1));\n#endif\n}\n\nvec2 grad(vec2 q) {\n    vec2 eps = vec2(1e-4,0);\n    return normalize(vec2(\n        map(q + eps.xy).x - map(q - eps.xy).x,\n        map(q + eps.yx).x - map(q - eps.yx).x));\n}\n\nfloat map_d(vec2 q) {\n    return map(q).x;\n}\n\n//////////////////////////////////////////////////////////\n\nvoid paint() {\n#if 0\n    set_source_rgb(vec3(1,1,0.96)*0.95);\n    clear();\n\n    grid(vec2(1.0/10.0));\n    set_line_width_px(1.0);\n    set_source_rgba(vec4(vec3(0.0),0.3));\n    stroke();\n#else\n    {\n        vec2 o = get_origin();    \n        vec2 m = map(o);\n        vec2 g = grad(o);\n        #if 1\n        set_source_rgb(hsl(m.y*5.0, 0.5, 0.7));\n        #elif 1\n        set_source_rgb(vec3(g.xy*0.5+0.5,mod(abs(m.x),0.1)/0.1));\n        #endif\n        clear();\n    }\n#endif\n    \n    set_source_rgb(vec3(0));\n    set_line_width_px(2.0);\n    graph2D(map_d);\n    stroke();\n    \n    const float limit = 3.0;\n    \n    vec2 ro = vec2(-1.0, 0.0);\n    vec2 rd = normalize(get_query() - ro);\n    \n    #if 1\n    set_source_rgb(vec3(0.5,0,1));\n    move_to(ro);\n    line_to(ro + rd * limit);\n    stroke();\n    #endif\n\n    {\n        vec2 o = get_query();\n        vec2 m = map(o);\n        set_source_rgb(vec3(0.5,0,1));\n        circle_px(o, 3.0);\n        fill();\n        set_source_rgb(vec3(1,0.7,0));\n        circle(o, abs(m.x));\n        stroke();\n        set_source_rgb(vec3(0.5,0,1));\n        circle(o, m.y);\n        stroke();\n    }\n#if 1\n\n    {\n        vec2 q = get_query();\n        vec2 mq = map(q);\n        vec2 o = get_origin();    \n        vec2 m = map(o);\n        vec2 g = grad(o);\n        vec2 d = normalize(vec2(o - q));\n        float a = dot(d, g)*sign(mq.x);\n        bool boundary = abs(m.x) < (4.0/min(iResolution.x,iResolution.y));\n        if (boundary && (a > 0.0)) {\n            set_source_rgb(vec3(0,0.5,1));\n            clear();\n        }\n        set_source_rgb(vec3(1.0));\n        circle_px(q, 3.0);\n        fill();\n    }\n    \n    set_source_rgb(vec3(1,0.,0.5));\n    float t = 0.0;\n    float th = 0.0;\n    for (int i = 0; i < 20; ++i) {\n        if (t > limit)\n            break;\n        vec2 q = ro + rd*t;\n        vec2 d = map(q);\n        circle(q, abs(d.y));\n        stroke();\n        if (d.x < 1e-3) {\n            break;\n        }\n        th = t + d.x;\n        t += d.y;\n    }\n    set_source_rgb(vec3(1,0.7,0));\n    if (t < limit) {\n        // bisect\n        vec2 iv = vec2(th, t);\n        for (int i = 0; i < 10; ++i) {\n            t = (iv[0] + iv[1])/2.0;\n            vec2 q = ro + rd*t;\n            circle_px(q, 3.0);\n            fill();\n            vec2 d = map(q);\n            if (abs(d.x) < 1e-3) {\n                set_source_radial_gradient(vec4(0,0,0,1),vec4(0,0,0,0),q,AAINV*50.0);\n                rings(q, AAINV*7.0, 0.0);\n                stroke();\n                break;\n            }\n            iv[(d.x < 0.)?1:0] = t + d.x;\n        }\n    }\n#endif    \n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord, iMouse.xy, iResolution.xy);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "// 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.16\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2020-12-02: 0.16\n// * support for drawing concentric rings\n\n// 2020-11-30: 0.15\n// * support for drawing orthogonal grids\n// * adjusted uv so corners are centered on pixels\n// * small adjustment to line pixel width computation\n\n// 2020-11-12: 0.14\n// * added support for depth testing\n\n// 2020-11-11: 0.13\n// * fixed 2D graphs not filling\n// * added circle_px()\n\n// 2019-06-06: 0.12\n// * split implementation and demo into common and image tab\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\nvoid set_source_depth(float depth);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the old source with the new one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n// if enabled, use the depth value for testing;\n// smaller values win\nvoid depth_test(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add a circle path at P with pixel radius R\nvoid circle_px(vec2 p, float r);\nvoid circle_px(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// add an orthogonal grid with cell size S\nvoid grid(vec2 s);\nvoid grid(float w, float h);\nvoid grid(float s);\n// draw concentric rings around origin p, with spacing r and offset phase\nvoid rings(vec2 p, float r, float phase);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// draw a letter with the given texture coordinate\nvoid letter(sampler2D font_texture_source, ivec2 l);\nvoid letter(sampler2D font_texture_source, int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    bool depth_test;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n    float source_z;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n#define DEFAULT_DEPTH 1e+30\n\nContext _stack;\n\nvoid init (vec2 fragCoord, vec2 mouse, vec2 resolution) {\n\taspect = vec2(resolution.x / resolution.y, 1.0);\n\tScreenH = min(resolution.x,resolution.y);\n\tAA = ScreenH*0.5;\n\tAAINV = 1.0 / AA;\n    \n    uv = (fragCoord.xy - 0.5) / resolution;\n    vec2 m = mouse / resolution;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false,\n        DEFAULT_DEPTH\n    );\n}\n\nvec3 _color = vec3(1);\nfloat _depth = DEFAULT_DEPTH;\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color.rgb = mix(_color.rgb, _stack.source.rgb, _stack.source.a);\n    _depth = (_stack.source.a == 1.0)?_stack.source_z:_depth;\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(pow(_color.rgb, vec3(1.0/2.2)), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color.rgb;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    if (_stack.depth_test) {\n        if ((w == 1.0) && (_stack.source_z <= _depth)) {\n            _depth = _stack.source_z;\n        } else if ((w == 0.0) || (_stack.source_z > _depth)) {            \n            return;\n        }\n    }\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color.rgb = _color.rgb * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\n\nvoid depth_test(bool enable) {\n    _stack.depth_test = enable;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_depth(float depth) {\n    _stack.source_z = depth;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(sampler2D font_texture_source, ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(sampler2D font_texture_source, int lx, int ly) {\n    letter(font_texture_source, ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid grid(vec2 size) {\n    vec4 f = abs(fract(_stack.position/size.xyxy+0.5)-0.5)*size.xyxy;\n    add_field(vec2(min(f.x,f.y),min(f.z,f.w)));\n}\nvoid grid(float w, float h) {\n    grid(vec2(w,h));\n}\nvoid grid(float s) {\n    grid(vec2(s));\n}\nvoid rings(vec2 p, float r, float phase) {\n    vec4 q = _stack.position - p.xyxy;\n    vec2 f = abs(fract(vec2(length(q.xy),length(q.zw))/r-phase+0.5)-0.5)*r;\n    add_field(f);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid circle_px(vec2 p, float r) {\n    circle(p, r/(0.5*ScreenH));\n}\nvoid circle_px(float x, float y, float r) {\n    circle_px(vec2(x,y), r);\n}\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(f_x / length(df_x));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3Xz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 90, 90, 509], [511, 511, 544, 544, 681], [683, 683, 713, 713, 790], [792, 792, 813, 813, 843], [845, 845, 874, 874, 1169], [1171, 1171, 1189, 1189, 1669], [1671, 1671, 1690, 1690, 1844], [1846, 1846, 1867, 1867, 1890], [1952, 1952, 1966, 1966, 4526], [4588, 4588, 4645, 4645, 4731]], "test": "untested"}
{"id": "flcXRH", "name": "Relaxed Distance Field (JFA)", "author": "paniq", "description": "using jump flooding to generate a \"relaxed distance field\" which is guaranteed to contain only one root in every radial direction. See common tab for more info. Euclidean and maxnorm distances are supported. drag mouse to simulate raymarching steps.", "tags": ["jump", "flooding", "jfa"], "likes": 17, "viewed": 788, "published": 3, "date": "1638685952", "time_retrieved": "2024-07-30T18:44:01.375331", "image_code": "// presentation\n\nvoid paint() {\n    vec4 ui_state = texelFetch(iChannel0, ivec2(0), 0);\n    vec2 uv = get_origin();\n\n    vec2 m = get_query();\n\n    vec2 p = fetch(iChannel1, uv).xy;\n\n#if USE_MAXNORM\n    float d = Linf_length(uv - p);\n#else\n    float d = length(uv - p);\n#endif\n    \n    vec3 col = vec3(p*0.5+0.5, 0.0);\n    {\n        col = vec3(sin((d*5.0-iTime*0.3)*radians(360.))*0.5+0.5);\n        if (map(uv) < 0.0) {\n            col = (1.0 - col)*0.5;\n        } else {\n            col = 0.3 * col + 0.7;\n        }\n    }\n    \n    set_source_rgb(col);\n    clear();\n\n    set_line_width_px(2.0);\n    \n    set_source_rgb(vec3(0.5,0,1));\n#if VIZ_QUADTREE\n    vec4 r = vec4(-1, -1, 1, 1);\n    rectangle(r.xy, r.zw - r.xy);\n    stroke();\n    \n    for (int i = 0; i < 6; ++i) {\n        vec2 c = (r.xy + r.zw) / 2.0;\n        vec2 p = fetch(iChannel1, c).xy;\n        #if USE_MAXNORM\n        float d = Linf_length(c - p);\n        float w = Linf_length(c - r.xy);\n        #else\n        float d = length(c - p);\n        float w = length(c - r.xy);\n        #endif\n        if (w <= d)\n            break;    \n        if (uv.x >= c.x)\n            r.x = c.x;\n        else\n            r.z = c.x;\n        if (uv.y >= c.y)\n            r.y = c.y;\n        else\n            r.w = c.y;\n        rectangle(r.xy, r.zw - r.xy);\n        stroke();        \n    }    \n#endif\n    vec2 s = fetch(iChannel1, m).xy;\n#if USE_MAXNORM\n    float rd = Linf_length(s - m);\n    rectangle(m - rd, vec2(rd) * 2.0);\n#else\n    float rd = length(s - m);\n    circle(m, rd);\n#endif\n    stroke();\n        \n    if (ui_state.w > 0.5) {\n        // raymarch\n        vec2 ro = ui_state.xy;\n#if USE_MAXNORM\n        float max_t = Linf_length(m - ro);\n        vec2 rd = Linf_normalize(m - ro);\n#else        \n        float max_t = length(m - ro);\n        vec2 rd = normalize(m - ro);\n#endif\n        \n        move_to(ro);\n        line_to(ro + rd*max_t);\n        stroke();\n        \n        set_source_rgb(vec3(1,0.,0.5));\n        float t = 0.0;\n        float th = 0.0;\n        float sg = sign(map(ro));\n        for (int i = 0; i < 20; ++i) {\n            if (t > max_t)\n                break;\n            vec2 q = ro + rd*t;\n#if USE_MAXNORM\n            vec2 d = vec2(map(q), Linf_length(fetch(iChannel1, q).xy - q));\n            rectangle(q - abs(d.y), 2.0 * vec2(abs(d.y)));\n#else\n            vec2 d = vec2(map(q), length(fetch(iChannel1, q).xy - q));\n            circle(q, abs(d.y));\n#endif\n            stroke();\n            if (d.x*sg < 1e-3) {\n                break;\n            }\n            th = t + d.x;\n            t += d.y;\n        }\n        set_source_rgb(vec3(1,0.7,0));\n        if (t < max_t) {\n            // bisect\n            vec2 iv = vec2(th, t);\n            for (int i = 0; i < 10; ++i) {\n                t = (iv[0] + iv[1])/2.0;\n                vec2 q = ro + rd*t;\n                circle_px(q, 3.0);\n                fill();\n                float d = map(q)*sg;\n                if ((abs(d) < 1e-3)||(i == 9)) {\n                    set_source_radial_gradient(vec4(0,1,0,1),vec4(0,0,0,0),q,AAINV*50.0);\n                    rings(q, AAINV*7.0, 0.0);\n                    stroke();\n                    break;\n                }\n                iv[(d < 0.)?1:0] = t + d;\n            }\n        }\n    \n        \n    }   \n\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord, iMouse.xy, iResolution.xy);\n\n    paint();\n\n    blit(fragColor);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// channel 1: JFA steps\n\nconst vec4 NULL_PIXEL = vec4(-1000.0);\nbool is_null(vec4 p) {\n    return p.w < -500.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5) / iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    int iter = iFrame % 13;\n    if (iter == 0) {\n        // init\n        float d = map(uv);\n        if (abs(d) <= (sqrt(2.0)/(min(iResolution.x,iResolution.y)))) {\n            fragColor = vec4(uv,uv);\n        } else {\n            fragColor = NULL_PIXEL;\n        }\n    } else {\n        // JFA step (for up to 4096x4096)\n        int level = clamp(iter-1,0,11);\n        int stepwidth = 1<<(11 - level);\n        \n        ivec2 tc = ivec2(fragCoord);\n        ivec2 res = ivec2(iChannelResolution[0].xy);\n        \n        float best_dist = 999999.0;\n        vec4 best_coord = NULL_PIXEL;\n        for (int y = -1; y <= 1; ++y) {\n            for (int x = -1; x <= 1; ++x) {\n                ivec2 fc = tc + ivec2(x,y)*stepwidth;\n\t\t        vec4 ntc = texelFetch(iChannel0, (fc + 16 * res) % res, 0);\n                if (is_null(ntc))\n                    continue;\n                vec2 dv = ntc.xy - uv;\n                vec2 g = grad(ntc.xy);\n                float qsd = map(uv);\n                #if USE_SDF\n                const float a = 1.0;\n                #else\n                float a = dot(normalize(dv), g)*sign(qsd);\n                #endif\n                #if USE_MAXNORM\n                float d = Linf_length(dv);\n                #else\n                float d = length(dv);\n                #endif\n                if ((d <= 0.0) || ((a > max_rdf_angle_cos) && (d < best_dist))) {\n                    best_dist = d;\n                    best_coord = ntc;\n                }\n            }\n        }        \n        fragColor = best_coord;\n    }\n}\n", "buffer_a_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// channel 2: take snapshot of stage\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 tc = ivec2(fragCoord);\n    int iter = int(mod(float(iFrame),13.0));\n    int frame = int(mod(iTime,15.0));\n    if (iter == 12) {\n        // snapshot    \n        fragColor = fetch(iChannel0, ivec2(iChannelResolution[0].xy), tc);\n    } else {\n        // copy\n        fragColor = fetch(iChannel1, ivec2(iChannelResolution[1].xy), tc);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\nby Leonard Ritter, Duangle GbR\n\nThis shadertoy uses the jump flooding algorithm[1] to generate a \nRelaxed Distance Field from a signed distance field, inspired by\nrelaxed cone stepping[2]. \n\nThe RDF can be used to raymarch through a signed distance field \nin fewer steps, guaranteeing that we never skip more than one\nsurface. We step until the signed distance is negative, indicating\nthat we have landed inside the surface. The root can then be\nsearched either using bisection of the interval between our latest\nposition and the current one, by regular sphere marching,\nor by a combination of the two.\n\nA RDF can also be used to partition a volume into polarconvex\ncells, so that the content of each cell can be trivially represented\nby a height/depth map embeddable on the surface of a convex \npolyhedron, such as a tetrahedron, octahedron, cube or any other\nspherical approximation.\n\nThe relaxed distance is defined as the distance to the nearest\nbackfacing surface point. A surface point is backfacing when\nthe dot product of its local gradient and the distance vector\nfrom query to surface point is greater than zero. When the\nquery point is inside a volume (that is, its SDF is negative),\nthen the dot product must be negated before querying.\n\nAlthough no errors are known to the author, the RDF generated by \nthis shader might possibly be spotty in places. It is to the author's\nknowledge though the first attempt at an algorithm that performs \nbetter than O(n), or, in the 3d case, O(n).\n\n[1] https://en.wikipedia.org/wiki/Jump_flooding_algorithm\n[2] https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-18-relaxed-cone-stepping-relief-mapping\n*/\n\n// if 1, use maxnorm rather than euclidean distance\n#define USE_MAXNORM 1\n// if 1, use strict signed distance field rather than relaxed distance field\n#define USE_SDF 0\n// if 1 visualize a quadtree over the domain\n#define VIZ_QUADTREE 0\n\n// maximum angle in degrees between view ray and surface normal permitted to be contained in cell\nconst float max_rdf_angle = 90.0;\nconst float max_rdf_angle_cos = -cos(radians(min(90.0, max_rdf_angle)));\n\nfloat Linf_length(vec2 v) {\n    v = abs(v);\n    return max(v.x, v.y);\n}\n\nvec2 Linf_normalize(vec2 v) {\n    float L = Linf_length(v);\n    return (L == 0.0)?v:(v / L);\n}\n\n// from https://www.shadertoy.com/view/XdXBRH\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n\nfloat rect(vec2 p, vec2 r) {\n    vec2 q = abs(p) - r;\n    return max(q.x, q.y);\n}\n\nfloat map(vec2 p) {\n#if 1\n    return (noised(p*4.0).x + noised(p).x + 0.2 /*+ noised(p*20.0).x * 0.2*/) * 0.25;\n#elif 1\n    float c1 = length(p + 0.2) - 0.3;\n    float c2 = length(p - 0.2) - 0.2;\n    float c4 = length(p + 0.3) - 0.2;\n    \n    float c3 = rect(p - vec2(0.4,-0.1), vec2(0.1,0.3));\n\n    return min(max(min(c1,c2),-c4),c3);\n#else\n    float d5 = rect(p, vec2(0.3,0.1));\n    return d5;\n#endif\n}\n\nvec2 grad(vec2 p) {\n    vec2 eps = vec2(1e-4, 0.0);\n    return normalize(vec2(    \n        map(p + eps.xy) - map(p - eps.xy),\n        map(p + eps.yx) - map(p - eps.yx)\n    ));\n}\n\nvec4 fetch(sampler2D sampler, ivec2 res, ivec2 p) {\n    return texelFetch(sampler, p, 0);\n}\n\n//////////////////////////////////////////////////////////////////////\n\n// 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.16\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2020-12-02: 0.16\n// * support for drawing concentric rings\n\n// 2020-11-30: 0.15\n// * support for drawing orthogonal grids\n// * adjusted uv so corners are centered on pixels\n// * small adjustment to line pixel width computation\n\n// 2020-11-12: 0.14\n// * added support for depth testing\n\n// 2020-11-11: 0.13\n// * fixed 2D graphs not filling\n// * added circle_px()\n\n// 2019-06-06: 0.12\n// * split implementation and demo into common and image tab\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\nvoid set_source_depth(float depth);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the old source with the new one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n// if enabled, use the depth value for testing;\n// smaller values win\nvoid depth_test(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add a circle path at P with pixel radius R\nvoid circle_px(vec2 p, float r);\nvoid circle_px(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// add an orthogonal grid with cell size S\nvoid grid(vec2 s);\nvoid grid(float w, float h);\nvoid grid(float s);\n// draw concentric rings around origin p, with spacing r and offset phase\nvoid rings(vec2 p, float r, float phase);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// draw a letter with the given texture coordinate\nvoid letter(sampler2D font_texture_source, ivec2 l);\nvoid letter(sampler2D font_texture_source, int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    bool depth_test;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n    float source_z;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 _resolution;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n#define DEFAULT_DEPTH 1e+30\n\nContext _stack;\n\nvoid init (vec2 fragCoord, vec2 mouse, vec2 resolution) {\n    _resolution = resolution;\n\taspect = vec2(resolution.x / resolution.y, 1.0);\n\tScreenH = min(resolution.x,resolution.y);\n\tAA = ScreenH*0.5;\n\tAAINV = 1.0 / AA;\n    \n    uv = (fragCoord.xy - 0.5) / resolution;\n    vec2 m = mouse / resolution;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false,\n        DEFAULT_DEPTH\n    );\n}\n\nvec3 _color = vec3(1);\nfloat _depth = DEFAULT_DEPTH;\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color.rgb = mix(_color.rgb, _stack.source.rgb, _stack.source.a);\n    _depth = (_stack.source.a == 1.0)?_stack.source_z:_depth;\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(pow(_color.rgb, vec3(1.0/2.2)), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color.rgb;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    if (_stack.depth_test) {\n        if ((w == 1.0) && (_stack.source_z <= _depth)) {\n            _depth = _stack.source_z;\n        } else if ((w == 0.0) || (_stack.source_z > _depth)) {            \n            return;\n        }\n    }\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color.rgb = _color.rgb * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\n\nvoid depth_test(bool enable) {\n    _stack.depth_test = enable;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_depth(float depth) {\n    _stack.source_z = depth;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(sampler2D font_texture_source, ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(sampler2D font_texture_source, int lx, int ly) {\n    letter(font_texture_source, ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid grid(vec2 size) {\n    vec4 f = abs(fract(_stack.position/size.xyxy+0.5)-0.5)*size.xyxy;\n    add_field(vec2(min(f.x,f.y),min(f.z,f.w)));\n}\nvoid grid(float w, float h) {\n    grid(vec2(w,h));\n}\nvoid grid(float s) {\n    grid(vec2(s));\n}\nvoid rings(vec2 p, float r, float phase) {\n    vec4 q = _stack.position - p.xyxy;\n    vec2 f = abs(fract(vec2(length(q.xy),length(q.zw))/r-phase+0.5)-0.5)*r;\n    add_field(f);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid circle_px(vec2 p, float r) {\n    circle(p, r/(0.5*ScreenH));\n}\nvoid circle_px(float x, float y, float r) {\n    circle_px(vec2(x,y), r);\n}\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(f_x / length(df_x));\n}\n\n//////////////////////////////////////////////////////////////////////\n\nvec4 fetch(sampler2D sampler, vec2 uv) {\n    uv /= aspect;\n    uv = (uv + 1.0)/2.0 * _resolution + 0.5;\n    return fetch(sampler, ivec2(_resolution), ivec2(uv));    \n}\n\n\n//////////////////////////////////////////////////////////////////////\n", "buffer_c_code": "\n// UI state\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    ivec2 fc = ivec2(fragCoord);\n    if (iFrame == 0) {\n        fragColor = vec4(0.0);\n    } else {\n        if (fc == ivec2(0)) {\n            init(fragCoord, iMouse.xy, iResolution.xy);\n            vec4 state = texelFetch(iChannel0, fc, 0);\n            if (iMouse.w > 0.5) {\n                state = vec4(get_query(),0,1);\n            }\n            fragColor = state;\n        }\n    }\n}\n", "buffer_c_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcXRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 31, 31, 3269], [3331, 3331, 3388, 3388, 3474]], "test": "untested"}
{"id": "flcSRH", "name": "screen tearing tester", "author": "ekaunt", "description": "A small shader to test screen tearing based on https://www.lexaloffle.com/bbs/?pid=tearing_test", "tags": ["test", "linux", "vsync", "tearing", "screentear", "gsync", "freesync"], "likes": 1, "viewed": 277, "published": 3, "date": "1638676031", "time_retrieved": "2024-07-30T18:44:02.162227", "image_code": "\n#define BARS 8.0\n#define SPEED 4.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 xy = fragCoord/(iResolution.xy/ BARS );\n\n\t// Time varying pixel color\n\tvec3 pixel = vec3(0.0);\n\n\tfloat lineDistance = 1.0;\n\tfloat lineThickness = lineDistance / 2.0;\n\tif (mod(xy.x + iTime*SPEED, lineDistance) < lineThickness)\n\t\tpixel = vec3(1.0);\n\n\t// Output to screen\n\tfragColor = vec4(pixel, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcSRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 93, 140, 448]], "test": "untested"}
{"id": "NlcXR8", "name": "screenburnsmooth", "author": "Del", "description": "playing with these trails! it looks like my old plasma tv!! (smooth, remix)", "tags": ["sin", "pattern", "trig"], "likes": 15, "viewed": 389, "published": 3, "date": "1638669845", "time_retrieved": "2024-07-30T18:44:02.932168", "image_code": "// 'screenburn' smooth remix - Del 05/12/2021\n\nvec2 smoothRot(vec2 p,float s,float m,float c,float d)\n{\n  s*=0.5;\n  float k=length(p);\n  float x=asin(sin(atan(p.x,p.y)*s)*(1.0-m))*k;\n  float ds=k*s;\n  float y=mix(ds,2.0*ds-sqrt(x*x+ds*ds),c);\n  return vec2(x/s,y/s-d);\n}\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n} \n#define PI 3.14159\n\nfloat vDrop(vec2 uv,float t)\n{\n    float xoff = sin(uv.y*25.0)*0.16;\n     xoff *= smoothstep(0.0,1.0,0.5+sin(length(uv)+iTime*0.3)*0.5);\n    uv.x+=xoff;\n    uv.y *= 2.;\n    uv.x = uv.x*16.0;\t\t\t\t\t\t// H-Count\n    float dx = fract(uv.x);\n    uv.x = floor(uv.x);\n    uv.y *= 0.5;\t\t\t\t\t\t\t// stretch\n    float o=sin(uv.x*215.4);\t\t\t\t// offset\n    float s=cos(uv.x*33.1)*.3 +.7;\t\t\t// speed\n    float trail = mix(18.0,5.0,s);\t\t\t// trail length\n    //float trail = 5.0;\n    float yv = fract(uv.y + t*s + o) * (trail*1.5);\n    yv = 1.0/yv;\n    yv = smoothstep(0.0,1.0,yv*yv);\n    yv = sin(yv*PI)*(s*5.0);\n    float d2 = sin(dx*PI);\n    return yv*(d2*d2);\n}\n\nvoid mainImage(out vec4 k, vec2 p)\n{\n    vec2 uv = (p.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float dd0 = length(uv);\n    float dd1 = smoothstep(0.0,0.3,dd0);\n    uv *= rotate(fract(0.6+iTime*-0.01)*6.28);\n//    uv = smoothRot(uv,8.0,0.05,0.0,-0.1);\n      uv = smoothRot(uv,4.0,0.35,16.0,0.05);\n        \n    if (iMouse.z<0.5)\n        uv *= 0.5;\n    float drop = vDrop(uv.yx,iTime*0.5);\n    vec3 linecol1 = vec3(0.75,0.45,0.325)*1.5;\n    vec3 linecol2 = vec3(0.4,0.75,0.325)*1.5;\n    vec3 linecol = mix(linecol1,linecol2,0.5+sin(iTime*0.2+dd0*.7)*0.5);\n    \n    vec3 backcol = vec3(0.01,0.04,0.1);\n    vec3 col = mix(backcol,linecol,drop)*dd1;\n    k = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcXR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 103, 103, 270], [272, 272, 294, 294, 361], [383, 383, 413, 413, 1027], [1029, 1029, 1065, 1065, 1704]], "test": "untested"}
{"id": "7ldSzr", "name": "eurgnheorowrg", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 2, "viewed": 248, "published": 3, "date": "1638658038", "time_retrieved": "2024-07-30T18:44:03.720061", "image_code": "float thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec3 thc(float a, vec3 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*thc(2. * cos(t), 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    uv.y += 0.04 * cos(iTime);\n    uv *= 1.1;\n    \n    float v = 0.5 * iTime;\n    mat2 m = mat2( cos(v), -sin(v), sin(v), cos(v));\n    uv *= m;\n    \n    //uv.x = 0.02 * thc(2., 80. * uv.y + iTime) + 1. -1./(cosh(4. * uv.x));\n    float a = 0.5 + 0.5 * thc(4., 1.7 * length(uv));\n    float a2 = 0.5 + 0.5 * thc(4., 1.7 / (1. - 0.005 * length(uv)));\n    a = mix(a, a2, 0.5 + 0.5 * thc(10000., 8. * uv.x + 0.3 * cos(4. * uv.y + 2. * iTime) + iTime));\n    float time = 1000. + 1.5 * iTime;\n    float t = a * floor(time) + min(fract(time), a);\n\n    vec2 p = (0.1 + 0.1 * thc(4., 10. * uv.x - 2.5 *  t)) * vec2(thc(4., t), ths(4., t));\n    \n    float d = length(uv - p);\n    float k = 0.5;\n    float s = smoothstep(-k, k, 0.2 - d);\n    s *= 3. * s * s;\n    vec3 col;// = vec3(s);\n    col = 2. * s * pal(s * cos(2. * s + iTime) + 0.3 * t, vec3(1.), vec3(1.), vec3(1.), 0.2 * cos(100. * s) * vec3(0.,0.33,0.66));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldSzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 70], [72, 72, 99, 99, 140], [143, 143, 172, 172, 213], [215, 215, 283, 283, 338], [340, 340, 397, 447, 1472]], "test": "untested"}
{"id": "sttSzr", "name": "screenburn", "author": "Del", "description": "these trails look like my old plasma tv!!", "tags": ["voronoi", "sin", "pattern", "trig"], "likes": 12, "viewed": 347, "published": 3, "date": "1638654584", "time_retrieved": "2024-07-30T18:44:04.512942", "image_code": "// 'screenburn' - Del 04/12/2021\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n// Voronoi (IQ) - slightly modified to return get the ID etc.\nvec4 VoronoiGrid( in vec2 x, out vec2 id )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    // first pass: regular voronoi\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n    \n    // second pass: distance to borders\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n    \n    id = (n+mg)+vec2(0.5); // ID is n+mg\n    return vec4(md, length(mr), mr);\n}\n\nvec2 smoothRot(vec2 p,float s,float m,float c,float d)\n{\n  s*=0.5;\n  float k=length(p);\n  float x=asin(sin(atan(p.x,p.y)*s)*(1.0-m))*k;\n  float ds=k*s;\n  float y=mix(ds,2.0*ds-sqrt(x*x+ds*ds),c);\n  return vec2(x/s,y/s-d);\n}\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n} \n#define PI 3.14159\n\nfloat vDrop(vec2 uv,float t)\n{\n    if (iMouse.z>0.5)\n        uv.y *= 12.0;\n    else\n        uv.y *= 2.;\n    uv.x = uv.x*16.0;\t\t\t\t\t\t// H-Count\n    float dx = fract(uv.x);\n    uv.x = floor(uv.x);\n    uv.y *= 0.5;\t\t\t\t\t\t\t// stretch\n    float o=sin(uv.x*215.4);\t\t\t\t// offset\n    float s=cos(uv.x*33.1)*.3 +.7;\t\t\t// speed\n    float trail = mix(18.0,5.0,s);\t\t\t// trail length\n    //float trail = 5.0;\n    float yv = fract(uv.y + t*s + o) * (trail*1.5);\n    yv = 1.0/yv;\n    yv = smoothstep(0.0,1.0,yv*yv);\n    yv = sin(yv*PI)*(s*5.0);\n    float d2 = sin(dx*PI);\n    return yv*(d2*d2);\n}\n\nvoid mainImage(out vec4 k, vec2 p)\n{\n    vec2 uv = (p.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float dd0 = length(uv);\n    float dd1 = smoothstep(0.0,0.3,dd0);\n    uv *= rotate(fract(0.6+iTime*-0.01)*6.28);\n    vec2 id;\n    float scale = 64.0;\n    vec4 grid = VoronoiGrid(uv*scale,id);\n    uv = id/scale;\n\n//    uv = smoothRot(uv,8.0,0.05,0.0,-0.1);\n      uv = smoothRot(uv,4.0,0.35,16.0,0.05);\n        \n    uv *= 0.5;\n    float drop = vDrop(uv.yx,iTime*0.5);\n    vec3 linecol1 = vec3(0.185,0.395,0.5)*2.5;\n    vec3 linecol2 = vec3(0.8,0.75,0.325)*1.5;\n    \n    vec3 linecol = mix(linecol1,linecol2,0.5+sin(iTime*0.2+dd0*0.7)*0.5);\n    \n    vec3 backcol = vec3(0.01,0.04,0.1);\n    vec3 col = mix(backcol,linecol,drop)*dd1;\n    k = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttSzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 56, 87, 177], [178, 240, 284, 284, 1117], [1119, 1119, 1175, 1175, 1342], [1344, 1344, 1366, 1366, 1433], [1455, 1455, 1485, 1485, 2034], [2036, 2036, 2072, 2072, 2790]], "test": "untested"}
{"id": "fttXzn", "name": "connected compo.in hexatruchets3", "author": "FabriceNeyret2", "description": "computed connected components in hexatruchets tiles from [url]https://shadertoy.com/view/flK3zc[/url]\nNo convergence booster for now: funny to see the snakes propagate :-)\n\nMouse.y: zoom     SPACE: reset    TAB: highlight 10% components", "tags": ["short", "connected", "doodles", "truchets", "entanglement"], "likes": 18, "viewed": 509, "published": 3, "date": "1638648294", "time_retrieved": "2024-07-30T18:44:05.351699", "image_code": "// coloring connected componant variant of https://shadertoy.com/view/flK3zc\n// variant with shadows https://shadertoy.com/view/flGGR3\n\n#define hue(v) vec4( .6 + .6 * cos( .5+(v)  + vec3(0,23,21)  ) ,1 )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    N*= 1.5;\n    if (length(iMouse.xy)>10.) N *= exp2(4.*(iMouse.y/R.y-.2)); // mouse zoom\n    float s = sqrt(3.), r = 1./s, a;\n    vec2 U = (N * u / R.y) * mat2(s,-1,0,2)/4. + 4.*iTime, // to tilted space\n         I = floor(U), V;                                // I : hexa tile ID\n    U = fract(U) *  mat2(1,.5,0,s/2.) - vec2(1,r)/2.;    // U : local coords\n    U += U.y*s+abs(U.x) < 0. ? I.y--,   + vec2( 0,r)     // Set to hexagon over the 3\n        : U.x < 0.           ? I.x--, -.5*vec2(-1,r)     //   covered by the tilted cell\n        :                             -.5*vec2( 1,r);\n // I.x += N;\n    O-=O;                                                // --- draw tiles\n\n    int t = typ(I);                                      // random tile type\n    a = float(ang(I))/6. *6.2831853;                     // random tile rotation\n    U *= mat2( cos( a - vec4(0,1.57,-1.57,0) ) );        // do rotation\n\n#define S(n,v)   vec2(n, smoothstep( N/R.y, 0., v ) )    // Draw among 3 types:\n#define C(n,v,r) S(n, abs(length(v)-r/2.) )           \n#define sha(x,y) S(0, length(U-vec2(x,y))-.1)    \n#define max(a,b) ( (a).y>(b).y ? a : b )\n    V = t==0 ?  max(max(C(1, U - vec2(.5,-r/2.) , r),    // 3 short turns\n                        C(2, U + vec2(.5, r/2.) , r)),\n                        C(0, U - vec2(0,r), r) )\n      : t==1 ?  max(max(C(1, U - vec2(.5,-s/2.), s),     // 2 larges + 1 short\n                        C(2, U + vec2(.5, s/2.), s) - sha(0,-.17) ),   // - shadow\n                        C(0, U - vec2(0,r), r))\n      :         max(max(C(2, U - vec2(.5,-s/2.), s),     // 2 larges + 1 line\n                        C(1, U + vec2(.5,-s/2.), s) - sha(-.08,.12) ), // - shadow\n                        S(0, abs(U.x*s+U.y) / 2.)   - sha(.08,-.12) ); // - shadow\n    O += V.y;                                            // Vx: #thread Vy: mask\n\n    O *= hue(T(I)[int(V.x)] );                     // show connected components\n    if ( keyToggle(9) && int(T(I)[int(V.x)])%10 > 0) O*=.3; // TAB: enlight 10%\n // if (iMouse.z > 0.) { O += (1.-O.a)*.4*hue(6.28*fract(1e4*sin(I.y + I.x*N))); return; } // if click show tiling\n} ", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define H(p)   fract(sin(dot(p, vec2(12.9898, 78.233))-floor(iTime)) * 43758.5453)\n\n// the #define version doesn't work on Windows\nint t,a; vec2 U;\nfloat n( int d) {\n    vec4 T = T( U+ vec2[](vec2(-1,1),vec2(-1,0),vec2(0,-1),vec2(1, -1),vec2(1,0),vec2(0,1))[(d+a)%6] );\n    int  A = ( d + a - (int(T.a)%8) +3 +6 )%6,\n         n = int(T.a)/8;\n    return T[ int[](0, n>1?1:2, n==1?1:2, (n+1)%3, n<2?1:2, n<2?0:1)[A] ];\n}\n//#define n(d) ( T = T( U+ vec2[](vec2(-1,1),vec2(-1,0),vec2(0,-1),vec2(1, -1),vec2(1,0),vec2(0,1))[(d+a)%6] ), \\\n//               A = ( d + a - (int(T.a)%8) +3 +6 )%6,    \\\n//               n = int(T.a)/8,                          \\\n//               T[ int[](0, n>1?1:2, n==1?1:2, (n+1)%3, n<2?1:2, n<2?0:1)[A] ] )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    U = u-.5;\n    if ( iFrame < 1 || keyDown(32) ) {\n        O.a = 8.* floor(3.*H(U))                       // random tile type\n            + floor(6.*H(U+.5));                       // random tile rotation\n        O.xyz = U.y + U.x*4096. + vec3(0,.3,.6);       // init ids#1,2,3\n        return;\n    }\n    O = T(U);                                 // recover previous state\n    t = typ(U), a = ang(U);                   // tile type and angle\n    \n    vec4 T;                                   // --- propagate id along connections\n                                              // read id in neighbor in direction d\n\n    if (t==0) {       // tile type #0   For each thread, new id = min(connections)\n        O.x = min( O.x, min( n(5), n(0) ));\n        O.y = min( O.y, min( n(3), n(4) ));\n        O.z = min( O.z, min( n(1), n(2) ));\n    }\n    else if (t==1) {  // tile type #1   For each thread, new id = min(connections)\n        O.x = min( O.x, min( n(5), n(0) ));\n        O.y = min( O.y, min( n(2), n(4) ));\n        O.z = min( O.z, min( n(1), n(3) ));\n    }\n    else  {           // tile type #2   For each thread, new id = min(connections)\n        O.x = min( O.x, min( n(0), n(3) ));\n        O.y = min( O.y, min( n(1), n(5) ));\n        O.z = min( O.z, min( n(2), n(4) ));\n    }\n} ", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float N = 32.;                                    // vertical number of tiles\n\n#define typ(U) int(T(U).a)/8                      // decode tile type and angle\n#define ang(U) int(T(U).a)%8\n\n#define R               iResolution.xy\n#define T(U)            texelFetch(iChannel0, ivec2(U+R) % ivec2(R), 0 )\n#define keyToggle(c)  ( texelFetch(iChannel3,ivec2(c,2),0).x > 0.)\n#define keyDown(c)    ( texelFetch(iChannel3,ivec2(c,1),0).x > 0.)\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttXzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 243, 243, 2370]], "test": "untested"}
{"id": "7tdSRn", "name": "noise thingy thing", "author": "SnoopethDuckDuck", "description": "e?", "tags": ["e"], "likes": 7, "viewed": 330, "published": 3, "date": "1638639460", "time_retrieved": "2024-07-30T18:44:06.232344", "image_code": "// The MIT License\n// Copyright  2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n\n// Simplex Noise (http://en.wikipedia.org/wiki/Simplex_noise), a type of gradient noise\n// that uses N+1 vertices for random gradient interpolation instead of 2^N as in regular\n// latice based Gradient Noise.\n\n\n// Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n// Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n// Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n// Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n// Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n// Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n// Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n// Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n// Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n// Wave     Noise 2D             : https://www.shadertoy.com/view/tldSRj\n\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat superDuperNoise(vec2 uv) {\n    float f = 0.;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n        \n\treturn 0.5 + 0.5*f;\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/ iResolution.y;\n    vec2 ouv = uv;\n    \n   \n    float sc = 132.;\n    vec2 ipos = floor(sc * uv)/sc;\n    vec2 fpos = fract(sc * uv) - 0.5;\n \n    ipos *= 1.5 + 0.5 * thc(4., 4. * length(ipos) - iTime);\n \n    float a = atan(ipos.y, ipos.x);\n    float r = length(ipos);\n \n\n\tfloat f = superDuperNoise(0.8 * ipos);\n\t\n \n    float t = f * 5. + 0.3 * iTime;\n    ipos += vec2(cos(t), sin(t));\n    \n\tipos = mix(ipos, ouv, 0.5 + 0.5 * thc(1., 20. * r + a - iTime + 4. * f));\n    \n    f = superDuperNoise(ipos);\n\n   \n    float k = 0.1;\n    //f = smoothstep(-k, k ,0.35 + 0.25 * cos(length(uv) * 3.3 + atan(uv.y, uv.x) + 20. * f - iTime) - f);\n    f *= 3.5 * f * f;\n    f *= step(length(fpos), 0.6 * f);\n    //f *= smoothstep(-0.02, 0.02, -f * 0.1 + 0.5 - length(ouv));\n    \n    vec3 col = 1.4 * f *  pal(0.1 * iTime + 0.15 * f + 0.1 * t, vec3(1.), vec3(1.), vec3(1.), 0.5 * vec3(0.,0.33,0.66));\n    \n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdSRn.jpg", "access": "api", "license": "mit", "functions": [[2089, 2089, 2118, 2118, 2159], [2161, 2161, 2218, 2218, 2333], [2335, 2335, 2361, 2361, 2840], [2842, 2842, 2874, 2874, 3116], [3118, 3118, 3186, 3186, 3229], [3283, 3283, 3340, 3340, 4306]], "test": "untested"}
{"id": "7ltXRn", "name": "Triangle expression fork", "author": "oneshade", "description": "Fork of [url=https://www.shadertoy.com/view/fltXRr]https://www.shadertoy.com/view/fltXRr[/url]", "tags": ["triangle", "equation"], "likes": 6, "viewed": 180, "published": 3, "date": "1638638631", "time_retrieved": "2024-07-30T18:44:07.216713", "image_code": "float tri(in vec2 p, in vec2 a, in vec2 b, in vec2 c)  {\n    p = inverse(mat2(b - a, c - a)) * (p - a);\n    return max(1.0 - min(p.x, p.y), p.x + p.y) - 1.0;\n\n    // For those picky people who prefer abs() instead\n    //p.x = 2.0 * p.x + p.y - 1.0;\n    //return abs(p.x) + abs(2.0 * p.y + abs(p.x) - 1.0) - 1.0;\n}\n\n/*float tri(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 ba = b - a;\n    vec2 ca = c - a;\n\n    p -= a;\n    p = mat2(ba.x, -ba.y, ba.y, ba.x) * p / length(ba);\n    p.x /= length(ba);\n\n    float proj = dot(ca, ba) / dot(ba, ba);\n    p.y /= length(ca - ba * proj) * sign(dot(ca, vec2(-ba.y, ba.x)));\n    p.x -= (proj - 0.5) * p.y;\n\n    p *= 2.0;\n    p -= 1.0;\n\n    return abs(p.x) + abs(p.y + abs(p.x)) - 1.0;\n}*/\n\n#define draw(dist, col) color = mix(color, col, smoothstep(pix, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y * 4.0;\n    float pix = 8.0 / iResolution.y; // 2x pixel width\n\n    vec2 a = 3.0 * vec2(sin(iTime * 0.75), cos(iTime));\n    vec2 b = 3.0 * vec2(cos(iTime), sin(iTime * 1.25));\n    vec2 c = 3.0 * vec2(cos(iTime * 1.25), cos(iTime * 0.5));\n\n    float triangle = tri(uv, a, b, c);\n    vec3 color = vec3(0.0, smoothstep(fwidth(triangle), 0.0, triangle), 0.0);\n\n    draw(length(uv - a) - 0.1, vec3(1.0, 0.0, 0.0));\n    draw(length(uv - b) - 0.1, vec3(1.0, 0.0, 0.0));\n    draw(length(uv - c) - 0.1, vec3(1.0, 0.0, 0.0));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltXRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 313], [813, 813, 868, 868, 1484]], "test": "untested"}
{"id": "NldSzr", "name": "Thindal twitch logo", "author": "mrange", "description": "License: CC0, author: Mrten Rnge\nInspired by: https://www.twitch.tv/thindal\nNet of stars very obviously inspired by BigWings - The Universe Within:\n https://www.shadertoy.com/view/lscczl\n", "tags": ["2d", "twitch"], "likes": 17, "viewed": 540, "published": 3, "date": "1638625776", "time_retrieved": "2024-07-30T18:44:08.306798", "image_code": "// License: CC0, author: Mrten Rnge\n//  Inspired by: https://www.twitch.tv/thindal\n//  Net of stars very obviously inspired by BigWings - The Universe Within:\n//   https://www.shadertoy.com/view/lscczl\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define RESOLUTION      iResolution\n#define TIME            iTime\n#define TTIME           (TAU*TIME)\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)         (0.5+0.5*cos(x))\n#define LINECOL(x,y)    lineCol(aa, z, np, cp, cps[x], cps[y]);\n\n\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3 baseLogoCol = HSV2RGB(vec3(0.715, 0.333, 0.8));\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec2 hash(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n  return length(pa - ba*h);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec2 cellPos(vec2 np) {\n  vec2 hp = hash(np);\n  return 0.3*vec2(sin(hp*TIME));   \n}\n\nvec3 lineCol(float aa, float z, vec2 np, vec2 cp, vec2 p0, vec2 p1) {\n  float l = length(p0 - p1);\n  float d = segment(cp, p0, p1)-1.5*aa/z;\n\n  float cd = min(length(cp-p0), length(cp-p1));\n\n  float v = 2.0*exp(-1.75*l)*exp(-15.*max(d, 0.0));\n  float s = 1.0-tanh_approx(v);\n  vec3 hsv = vec3(0.715, s, v);\n\n  return hsv2rgb(hsv);\n}\n\nfloat plane(vec2 p, vec2 n, float m) {\n  return dot(p, n) + m;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat polygon4(vec2[4] v, vec2 p) {\n  const int N = 4;\n  float d = dot(p-v[0],p-v[0]);\n  float s = 1.0;\n  for( int i=0, j=N-1; i<N; j=i, ++i) {\n    vec2 e = v[j] - v[i];\n    vec2 w =    p - v[i];\n    vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n    d = min( d, dot(b,b) );\n    bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n    if( all(c) || all(not(c)) ) s*=-1.0;  \n  }\n  return s*sqrt(d);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat isosceles(vec2 p, vec2 q) {\n  p.x = abs(p.x);\n  vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n  float s = -sign( q.y );\n  vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n               vec2( dot(b,b), s*(p.y-q.y)  ));\n  return -sqrt(d.x)*sign(d.y);\n}\n\nfloat dthindal(vec2 p) {\n  vec2 p0 = -p.yx;\n  vec2 q0 = vec2(0.57, 0.96);\n\n  vec2 p1 = -p.yx;\n  vec2 q1 = vec2(0.31, 0.575);\n\n  if (p.y > 0.0) {\n    q0 = vec2(0.524, 0.88);\n    q1 = vec2(0.29, 0.5);\n  }\n\n  p0.y += 0.59;\n  p1.y += 0.35;\n\n  const vec2 p2[] = vec2[](vec2(-0.62, 0.075), vec2(-0.035, 0.075), vec2(-0.035, -0.075), vec2(-0.365, -0.075));\n\n  float d0 = isosceles(p0, q0);\n  float d1 = isosceles(p1, q1);\n  float d2 = polygon4(p2, p);\n  float d3 = plane(p, normalize(vec2(1.0, 1.7)), -0.055);\n\n  d0 = max(d0, -d1);\n  if (p.y > 0.0) {\n    d0 = max(d0, -d3);\n  }\n  \n  float d = d0;\n  d = min(d, d2);\n  \n  return d;\n}\n\nvec4 gridColor(vec2 p) {\n  float z = 0.2;\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 col = vec3(0.0);\n  p /= z;\n  vec2 cp = fract(p) - 0.5;\n  vec2 np = floor(p);\n\n  vec2 cps[9];\n  int idx = 0;\n\n  for (float y = -1.0; y <= 1.0; ++y) {\n    for (float x = -1.0; x <= 1.0; ++x) {\n      vec2 off = vec2(x, y);\n      cps[idx++] = cellPos(np+off) + off;\n    }\n  }\n\n  col += LINECOL(4, 0);\n  col += LINECOL(4, 1);\n  col += LINECOL(4, 2);\n  col += LINECOL(4, 3);\n\n  col += LINECOL(4, 5);\n  col += LINECOL(4, 6);\n  col += LINECOL(4, 7);\n  col += LINECOL(4, 8);\n\n  col += LINECOL(1, 3);\n  col += LINECOL(1, 5);\n  col += LINECOL(7, 3);\n  col += LINECOL(7, 5);\n\n  float i = col.x+col.y+col.z;\n\n  return vec4(col, tanh_approx(i));\n}\n\nvec3 thindal(vec3 col, vec2 p, vec2 q) {\n  const float zi = 1.1;\n  vec2 op = p;\n  float aa = 2.0/RESOLUTION.y;\n\n  float fade = 0.9*mix(0.9, 1.0, PCOS(0.25*TTIME+10.0*q.x));\n\n  vec2 pi = p;\n  const float period = 10.0;\n  const float coff = PI;\n  float ptime = (1.0/period)*TIME;\n  float mtime = mod(ptime, 2.0);\n  float ntime = floor(ptime/2.0);\n  float anim = min(1.0, mtime)*step(1.0, ptime); \n  float h = hash(ntime+123.4);\n  float s = floor(h*5.0);\n  float off = 0.6*p.x+p.y;\n  if (s == 1.0) {\n    off = p.x+p.y*p.y;\n  }  else if (s == 2.0) {\n    off = p.x+p.y*p.y*p.y;\n  } else if (s == 3.0) {\n    off = p.x*p.y+p.y*p.x;\n  } else if (s == 4.0) {\n    off = p.x+p.y*p.x;\n  }\n\n  off += -2.0/3.0+PI*anim;\n  float angle = off+mix(coff*0.42, -coff*0.42 , fade);\n  float split = angle+coff;\n  int _nsplit = int(mod1(split, 1.0*coff));\n\n  pi /= zi;\n  float di  = dthindal(pi);\n  float dii = abs(di-0.0125) - 0.0025;\n  di = min(di, dii);\n  di *= zi;\n  \n  float dg = di;\n\n  const vec3 lcol2 = vec3(2.0, 1.55, 1.25).xzy*0.85;\n\n  float gmix = pow(abs(cos(angle)), 8.0);\n  float gmix2 = abs(1.0/tanh_approx(split))*0.5;\n\n  dg = abs(dg-0.025);\n  float glow = exp(-10.0*max(dg+0., 0.0));\n  vec3 glowCol = mix(lcol2.zyx*lcol2.zyx/6.0, lcol2.zyx, glow*glow)*gmix2;\n  col -= 0.5*exp(-10.0*max(di+0.1, 0.0));\n  col = mix(col, vec3(mix(baseLogoCol, sqrt(glowCol*0.5), gmix)), smoothstep(-aa, aa, -di));\n  col += 0.5*smoothstep(0.5, 0.45, abs(anim-0.5))*glowCol*glow*gmix;\n\n  return col;\n}\n\n// The path function\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.075*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\n// The derivate of the path function\n//  Used to generate where we are looking\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\n// The second derivate of the path function\n//  Used to generate tilt\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.125*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {\n  float h = hash(n);\n  float s = mix(0.05, 0.25, h);\n\n  vec3 hn;\n  vec2 p = (pp-off*vec3(1.0, 1.0, 0.0)).xy;\n  p *= ROT(TAU*h);\n\n  return gridColor(p);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  return vec3(0.0);\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = (2.0+1.0*tanh_approx(lp));  // Playing around with rdd can give interesting distortions\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const float planeDist = 1.0-0.;\n  const int furthest = 4;\n  const int fadeFrom = max(furthest-3, 0);\n\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.95;\n  bool cutOut = false;\n\n  // Steps from nearest to furthest plane and accumulates the color \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = smoothstep(planeDist*float(furthest), planeDist*float(fadeFrom), nz);\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.xyz = mix(skyCol, pcol.xyz, fadeIn);\n      pcol.w *= fadeOut;\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm  = TIME*0.3;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, q);\n  col *= smoothstep(3.0, 6.0, TIME);\n  col = thindal(col, p, q);\n  col *= smoothstep(0.0, 10.0*q.y, TIME);\n  col = postProcess(col, q);\n \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldSzr.jpg", "access": "api", "license": "cc0-1.0", "functions": [[607, 607, 629, 629, 775], [1130, 1190, 1230, 1230, 1389], [1391, 1451, 1491, 1491, 1533], [1535, 1595, 1617, 1617, 1665], [1667, 1727, 1746, 1746, 1869], [1871, 1957, 1996, 1996, 2121], [2123, 2217, 2256, 2256, 2365], [2367, 2427, 2455, 2521, 2597], [2599, 2599, 2622, 2622, 2682], [2684, 2684, 2753, 2753, 3016], [3018, 3018, 3056, 3056, 3082], [3590, 3684, 3717, 3717, 4010], [4638, 4638, 4662, 4662, 5352], [5354, 5354, 5394, 5394, 6826], [6828, 6849, 6871, 6871, 7005], [7007, 7086, 7109, 7109, 7184], [7186, 7256, 7280, 7280, 7359], [7361, 7361, 7429, 7429, 7583], [7585, 7585, 7618, 7618, 7640], [7642, 7642, 7698, 7698, 9239], [9241, 9324, 9360, 9360, 9593], [9595, 9595, 9624, 9624, 9924], [9926, 9926, 9981, 9981, 10278]], "test": "error"}
{"id": "NltSzn", "name": "Electro Dynamics", "author": "wyatt", "description": "A relativistic simulation of a continuum of electrons. \nWave simulation propagates electromagnetic force fields (Buffer A and B)\nElectromagnetic force accelerates the electron continuum (Buffer C)\nElectrons are transported as a continuum  (Buffer D)", "tags": ["relativity"], "likes": 20, "viewed": 571, "published": 3, "date": "1638606270", "time_retrieved": "2024-07-30T18:44:09.209385", "image_code": "// Display \nMain {\n    vec4 a = A(U);\n    vec4 b = B(U);\n    float n = B(U+vec2(0,1)).w;\n    float e = B(U+vec2(1,0)).w;\n    float s = B(U-vec2(0,1)).w;\n    float w = B(U-vec2(1,0)).w;\n    vec3 no = normalize(vec3(e-w,n-s,1));\n    Q = .8*atan(10.*b.wwww);\n    Q *= 1.-.5*texture(iChannel2,no);\n}", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)", "buffer_a_code": "// Electric Field \nMain {\n    Q = A(U);\n    vec4 b = B(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    /*  \n        E/dt = -D*V+M       \n    */  Q.x += -b.w*b.x-e.z+w.z;\n        Q.y += -b.w*b.y-n.z+s.z;\n    \n    \n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Magnetic Feild \nMain {\n    Q = A(U);\n    vec4 b = B(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    /*\n        M/dt = -D*V-dE\n    */  Q.z += b.w-Q.z-.25*(e.x-w.x+n.y-s.y);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Electron Force \nMain {\n    Q = A(U);\n    vec4 b = B(U);\n    \n    /*    \n        V/dt = -D/m*E-D/m*VM\n    */  Q.x += Q.w/2000.*(b.x-Q.x*b.z);\n        Q.y += Q.w/2000.*(b.y-Q.y*b.z);\n    \n    if (iFrame < 1) {\n        Q.w=2.*exp(-.05*length(U-.5*R+60.));\n        Q.w+=2.*exp(-.05*length(U-.5*R-60.));\n    } \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Transport Electrons \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    for (int x=-1;x<=1;x++)\n    for (int y=-1;y<=1;y++)\n    if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = .5*Q.xy*inversesqrt(1.+dot(Q.xy,Q.xy)),\n             b = .5*q.xy*inversesqrt(1.+dot(q.xy,q.xy))+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,0.5*u-a)/ab;\n       float wa = 0.5*Q.w*min(i,.5);\n       float wb = 0.5*q.w*max(i-.5,0.);\n       dQ.xyz += Q.xyz*wa+q.xyz*wb;\n       dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltSzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NtdXRn", "name": "Voronoi-ed-Voronoi", "author": "Del", "description": "test", "tags": ["voronoi"], "likes": 25, "viewed": 376, "published": 3, "date": "1638598092", "time_retrieved": "2024-07-30T18:44:10.090031", "image_code": "// wat?\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 GetWater(vec2 p)\n{\n    const vec3 col = vec3(0.02,.3,.55);\n    const mat3 _m = mat3(-2.0,-1.0,2.0, 3.0,-2.0,1.0, 1.0,2.0,2.0);\n    vec4 d = vec4(iDate*.122);\n    d.xy = p;\n    d.xyw *=_m*.5;\n    float v1 = length(.5-fract(d.xyw));\n    d.xyw *=_m*.4;\n    float v2 = length(.5-fract(d.xyw));\n    d.xyw *=_m*.3;\n    float v3 = length(.5-fract(d.xyw));\n    float v = pow(min(min(v1,v2),v3), 5.)*15.;\n    return col+vec3(v,v,v);\n}\n\n// Voronoi (IQ) - slightly modified to return get the ID etc.\nvec4 VoronoiGrid( in vec2 x, out vec2 id )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    // first pass: regular voronoi\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n    \n    // second pass: distance to borders\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n    \n    id = (n+mg)+vec2(0.5); // ID is n+mg\n    return vec4(md, length(mr), mr);\n}\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= rotate(fract(iTime*0.025)*6.28);\n    vec2 id;\n    float scale = 24.0+(5.0*sin(iTime));\n    vec4 grid = VoronoiGrid(uv*scale,id);\n    uv = id/scale;\n    \n    uv.xy += iTime*0.01;\n\n    float dd = smoothstep(0.0,0.25,(grid.x));\n\n\tfragColor = vec4( GetWater(uv)*dd, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdXRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[9, 9, 31, 62, 152], [154, 154, 177, 177, 584], [586, 648, 692, 692, 1525], [1526, 1526, 1548, 1548, 1615], [1621, 1621, 1678, 1678, 2028]], "test": "untested"}
{"id": "ftdXRn", "name": "raycasting a sphere :D", "author": "lordadamson", "description": "raycasting a sphere :D\n\nI stole the code from this video and turned it into a shader: https://www.youtube.com/watch?v=ARn_yhgk7aE", "tags": ["raytracing", "raycasting", "pathtracing"], "likes": 1, "viewed": 253, "published": 3, "date": "1638598014", "time_retrieved": "2024-07-30T18:44:10.936766", "image_code": "struct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n\nstruct Sphere\n{\n    vec3 c;\n    float r;\n};\n\nvoid\nsphere_intersect(in Sphere sphere, in Ray ray,\n                 out float t, out bool intersected)\n{\n    vec3 o = ray.o;\n    vec3 d = ray.d;\n    vec3 oc = o - sphere.c;\n    float b = 2.0f * dot(oc, d);\n    float c = dot(oc, oc) - sphere.r*sphere.r;\n    float disc = b*b - 4.0f * c;\n    \n    if (disc < 1e-4)\n    {\n        intersected = false;\n        return;\n    }\n    \n    disc = sqrt(disc);\n    float t0 = -b - disc;\n    float t1 = -b + disc;\n    t = (t0 < t1) ? t0 : t1;\n    intersected = true;\n}\n\nvoid sphere_normal(in Sphere sphere, in vec3 pi,\n                   out vec3 normal)\n{\n    normal = (pi - sphere.c) / sphere.r;\n}\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float H = iResolution.y;\n    float W = iResolution.x;\n    \n    Sphere sphere = Sphere(vec3(W*0.5, H*0.5, 50), 50.0f);\n    vec3 light= vec3(iMouse.x, iMouse.y, -10);\n    \n    vec3 light_color = vec3(1.0, 1.0, 1.0);\n    vec3 bg_color = vec3(0.0, 0.0, 0.0);\n    vec3 sphere_color = vec3(0.0, 0.4, 0.2);\n    \n    vec3 col = vec3(0,0,0);\n    float x = fragCoord.x;\n    float y = fragCoord.y;\n\n    Ray ray = Ray(vec3(x, y, 0),vec3(0, 0, 1));\n    \n    bool intersected = false;\n    \n    float t;\n    sphere_intersect(sphere, ray, t, intersected);\n    \n    if(intersected)\n    {\n        vec3 pi = ray.o + ray.d*t;\n        vec3 L = light - pi;\n        vec3 N;\n        sphere_normal(sphere, pi, N);\n        float dt = dot(normalize(L), normalize(N));\n\n        col = (sphere_color + light_color*dt);\n        clamp(col, vec3(0.0,0.0,0.0), vec3(1.0,1.0,1.0));\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdXRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 191, 191, 590], [592, 592, 678, 678, 721], [723, 723, 778, 778, 1669]], "test": "untested"}
{"id": "7t3Xzr", "name": "SnakePortal", "author": "Del", "description": "just some green stuff", "tags": ["sin", "pattern", "polar"], "likes": 13, "viewed": 378, "published": 3, "date": "1638595250", "time_retrieved": "2024-07-30T18:44:12.032836", "image_code": "// green stuff - Del 04/12/2021\n\nvec2 smoothRot(vec2 p,float s,float m,float c,float d){\n  s*=0.5;\n  float k=length(p);\n  float x=asin(sin(atan(p.x,p.y)*s)*(1.0-m))*k;\n  float ds=k*s;\n  float y=mix(ds,2.0*ds-sqrt(x*x+ds*ds),c);\n  return vec2(x/s,y/s-d);\n}\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n} \nvoid mainImage(out vec4 k, vec2 p)\n{\n    vec3 col1 = vec3(0.01,0.03,0.01);\n    vec3 col2 = vec3(0.5,0.9,0.3);\n    vec2 uv = (p.xy - 0.5 * iResolution.xy) / iResolution.y;\n\nuv *= rotate(fract(iTime*0.01)*6.28);\n    \n    float dd2 = length(uv);\n    float dd1 = smoothstep(0.0,0.3,dd2);\n\n    //if (abs(uv.x)>0.2)\n        col2 *= 1.0-abs(uv.x*0.75);\n        col1 *= 1.0-abs(uv.x*0.75);\n\n    float dnoise = 15.0*(dd1);\n    //uv *= rotate(-dnoise*0.05);\n    \n    float dns = 0.5+sin(iTime*.45)*0.5;\n    dnoise = mix(dnoise,0.0,dns);\n    \n    float oo = 0.5+sin(dnoise+uv.y+uv.x*12.0+iTime*0.5)*0.5;\n    uv = smoothRot(uv,6.0,0.085,16.0,.075*oo);\n    vec2 d = uv*5.0;\n    d.x += fract(iTime);\n    float v1=length(0.5-fract(d.xy))+0.58;\n    d = (uv*1.75);\t\t\t// zoom\n    float v2=length(0.5-fract(d.yy))-0.1525;\t\t// border\n    v1 *= 1.2-v2*v1;\n    v1 = smoothstep(0.1,0.9,v1);\n    vec3 col = mix(col2,col1,v1)*dd1;\n    k = vec4(col*4.75,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3Xzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 88, 88, 255], [257, 257, 279, 279, 346], [348, 348, 384, 384, 1283]], "test": "untested"}
{"id": "sl3Szr", "name": "nice girl-haha-2d", "author": "jorge2017a2", "description": "nice girl-haha-2d", "tags": ["nicegirlhaha2d"], "likes": 9, "viewed": 345, "published": 3, "date": "1638588055", "time_retrieved": "2024-07-30T18:44:12.797791", "image_code": "//por jorge2017a2\n//nice girl-haha-2d\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(8.*antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(6.*antialiasing(0.85),b,d)\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0));\nreturn colOut;\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{   p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\n\nvec3 HacerFigura(vec2 p, vec3 col)\n{   vec2 p0=p;\n\n    float r01a, r01b,h01;\n    float ra1,ra2,ha, rb1,rb2,hb ;\n    ra1=0.2; ra2=0.27; ha=1.2; //pierna\n    rb1=0.1;rb2=0.2; hb=1.2; //rodilla\n    r01a=0.56; r01b=0.40; h01=1.5; //cuerpo\n    \n    //cabeza\n    float ra4, rb4,h4;\n    ra4=0.45; rb4=0.32;h4=0.4;\n    float d7a= sdUnevenCapsule(p-vec2(-0.5,3.65),ra4,rb4,h4);  //cabeza\n    \n    //cuello\n    float ra3, rb3,h3;\n    ra3=0.15; rb3=0.12;h3=0.3;\n    float d6a= sdUnevenCapsule(p-vec2(-0.5,3.0),ra3,rb3,h3);  //cuello\n    \n    //cuerpo\n    p=rotatev2(p0, radians(-10.0));\n    float d0a= sdUnevenCapsule(p-vec2(0.0,1.3),r01a,r01b,h01);  //cuerpo\n    float d0b= sdCircle(p*vec2(0.9,0.65)-vec2(-1.1,1.5), 0.8 ); //curva izq\n    float d0c= sdCircle(p*vec2(0.9,0.65)-vec2( 1.1,1.5), 0.8 ); //curva der\n    d0a=differenceSDF(d0a,d0b);\n    d0a=differenceSDF(d0a,d0c);\n    \n    //brazo izq\n    float r21a,r21b,h21;\n    r21a=0.12; r21b=0.15; h21=1.0;\n    vec2 p1a=rotatev2(p0-vec2(-1.3,2.0), radians(25.0));\n    vec2 p1b=rotatev2(p0-vec2(-1.3,2.0), radians(-45.0));\n    float d4a= sdUnevenCapsule(p1a,r21a,r21b,h21);  //brazo izq\n    float d4b= sdUnevenCapsule(p1b,r21b,r21a,h21);  //ante brazo izq\n    \n    //brazo der\n    float r22a,r22b,h22;\n    r22a=0.12; r22b=0.15; h22=1.0;\n    vec2 p2a=rotatev2(p0-vec2(0.2,2.0), radians(10.0));\n    vec2 p2b=rotatev2(p0-vec2(0.2,2.0), radians(10.0));\n    \n    p2a=rotatev2(p2a, radians(-25.0));\n    p2b=rotatev2(p2b, radians(55.0));\n    float d5a= sdUnevenCapsule(p2a,r22a,r22b,h22);  //brazo izq\n    float d5b= sdUnevenCapsule(p2b,r22b,r22a,h22);  //ante brazo izq\n    \n    //pierna izq\n    p=rotatev2(p0-vec2(-0.05,0.0), radians(-20.0));\n    float d1a= sdUnevenCapsule(p-vec2(0.0,0.0),ra1,ra2,ha);\n    //------rodilla\n    p=rotatev2(p0, radians(10.0));\n    float d1b= sdUnevenCapsule(p-vec2(0.0,-1.3),rb1,rb2,hb);\n    \n    //pierna der\n    p=rotatev2(p0, radians(10.0));\n    float d2a= sdUnevenCapsule(p-vec2(-0.1,0.0),ra1,ra2,ha);\n    //-------rodilla\n    p=rotatev2(p0, radians(20.0));\n    float d2b= sdUnevenCapsule(p-vec2(-0.1,-1.3),rb1,rb2,hb);\n    \n    //calzon 2\n    p=rotatev2(p0, radians(-10.0));\n    float dbx1=sdBox(p-vec2(0.0,2.8),vec2(0.8,1.0) );\n    dbx1=differenceSDF(d0a,dbx1);\n    \n    //pies\n    p1a=rotatev2(p0-vec2(-0.4,-1.1), radians(45.0));\n    p1b=rotatev2(p0-vec2(-0.1,-1.2), radians(45.0));\n    float d8a= sdCircle(p1a*vec2(0.9,0.5), 0.15 );\n    float d8b= sdCircle(p1b*vec2(0.9,0.5),0.15 );\n    \n    float k=0.07;\n    d0a=opSmoothUnion(d0a ,d4a,k);\n    d0a=opSmoothUnion(d0a ,d4b,k);\n    d0a=opSmoothUnion(d0a ,d5a,k);\n    d0a=opSmoothUnion(d0a ,d5b,k);\n    \n    col= DrawFigBorde(vec3(1.0,0.7,0.0), col, d0a);  //cuerpo\n    col= DrawFigBorde(vec3(0.4), col, d8a); //pies 1\n    col= DrawFigBorde(vec3(0.4), col, d8b); //pies 2\n    col= DrawFigBorde(vec3(1.0,0.7,0.0), col, d1b); //rodilla izq\n    col= DrawFigBorde(vec3(1.0,0.7,0.0), col, d1a); //pierna izq\n    col= DrawFigBorde(vec3(1.0,0.7,0.0), col, d2a); //pierna der\n    col= DrawFigBorde(vec3(1.0,0.7,0.0), col, d2b); //rodilla der\n    col= DrawFigBorde(vec3(1.0,0.5,0.0), col, d6a);\n    col= DrawFigBorde(vec3(0.4), col, d7a);\n   col= DrawFigBorde(vec3(0.4), col, dbx1);    \n    return col;\n}\n\nvec3 HacerFiguraOpScale( in vec2 p,vec3 col , float s)\n{\n    \n    col=HacerFigura(p/s,col)*s;\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=3.0;\n    uv*=esc;\n    vec3  col=vec3(0.45,0.7,1.0)-uv.y*0.5/esc;\n\n    float s1=1.0*sin(iTime*0.25+1.0);\n    float s2=1.0*sin(iTime*0.5 +2.0);\n    float s3=1.0*sin(iTime*0.75+4.0);\n    float s4=clamp(fract(iTime*2.0),0.2,s1);\n\n\n    col=HacerFiguraOpScale(uv,col,abs(s1));\n    col=HacerFiguraOpScale(uv-vec2( 2.0,0.0),col,abs(s2));\n    col=HacerFiguraOpScale(uv-vec2(-2.0,0.0),col,abs(s3));\n    col=HacerFiguraOpScale(uv,col,abs(s4));\n\n    \n    col=pow(col, vec3(0.65454));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3Szr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[324, 355, 391, 391, 436], [441, 485, 532, 532, 559], [560, 560, 603, 603, 630], [631, 631, 679, 679, 707], [713, 713, 775, 775, 972], [974, 974, 1055, 1055, 1185], [1187, 1187, 1244, 1244, 1315], [1317, 1317, 1351, 1351, 1446], [1448, 1448, 1473, 1473, 1492], [1493, 1493, 1518, 1518, 1537], [1541, 1541, 1593, 1593, 1692], [1694, 1694, 1752, 1752, 1852], [1854, 1854, 1913, 1913, 2012], [2015, 2015, 2052, 2052, 2126], [2128, 2128, 2163, 2163, 2186], [2189, 2189, 2251, 2251, 2488], [2491, 2491, 2527, 2527, 5705], [5707, 5707, 5763, 5763, 5818], [5821, 5821, 5878, 5878, 6513]], "test": "untested"}
{"id": "7tcXRn", "name": "eindacor_perlinfun", "author": "Eindacor_DS", "description": "It's fun with perlin noise, you dolt!", "tags": ["perlin"], "likes": 4, "viewed": 329, "published": 3, "date": "1638577661", "time_retrieved": "2024-07-30T18:44:13.725311", "image_code": "#define PI 3.1415926\n#define INVERT true\n\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 getRandomVector(float seed) {\n    vec2 outVec;\n    if (seed < .25) {\n        outVec = vec2(1., 1.);\n    } else if (seed < .5) {\n        outVec = vec2(-1., 1.);\n    } else if (seed < .75) {\n        outVec = vec2(1., -1.);\n    } else {\n        outVec = vec2(-1., -1.);\n    }\n    \n    return outVec;\n}\n\nfloat biLerp(float f0, float f1, float f2, float f3, float lerpX, float lerpY) {\n    float upper = mix(f1, f2, lerpX);\n    float lower = mix(f0, f3, lerpX);\n    \n    return mix(lower, upper, lerpY);\n}\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nfloat getModifiedDot(vec2 uv, vec2 p, float gridDimension, float pHash) {\n    float rotation = sin(iTime * .15 + pHash) * 2. * PI;\n    if (pHash < .5) {\n        rotation *= -1.;\n    }\n    mat2x2 rotationMatrix = createRotationMatrix(rotation);\n    \n    return dot((uv - p) / gridDimension, getRandomVector(pHash) * rotationMatrix);\n}\n\n\nfloat getPerlinValue(vec2 uv, float gridDimension, bool hideLines) {\n    float xCoord = floor(uv.x / gridDimension) * gridDimension;\n    float yCoord = floor(uv.y / gridDimension) * gridDimension;\n    \n    float xIndex = floor(uv.x / gridDimension);\n    float yIndex = floor(uv.y / gridDimension);\n    \n    float p0Hash = hash(vec2(xIndex, yIndex));\n    float p1Hash = hash(vec2(xIndex, yIndex + 1.));\n    float p2Hash = hash(vec2(xIndex + 1., yIndex + 1.));\n    float p3Hash = hash(vec2(xIndex + 1., yIndex));\n    \n    vec2 p0 = vec2(xCoord, yCoord);\n    vec2 p1 = vec2(xCoord, yCoord + gridDimension);\n    vec2 p2 = vec2(xCoord + gridDimension, yCoord + gridDimension);\n    vec2 p3 = vec2(xCoord + gridDimension, yCoord);\n    \n    float rotation = sin(iTime * .15) * 2. * PI;\n    mat2x2 rotationMatrix = createRotationMatrix(rotation);\n    \n    float dot0 = getModifiedDot(uv, p0, gridDimension, p0Hash);\n    float dot1 = getModifiedDot(uv, p1, gridDimension, p1Hash);\n    float dot2 = getModifiedDot(uv, p2, gridDimension, p2Hash);\n    float dot3 = getModifiedDot(uv, p3, gridDimension, p3Hash);\n    \n    float xInterp = smoothstep(p0.x, p2.x, uv.x);\n    float yInterp = smoothstep(p0.y, p2.y, uv.y);\n    \n    float val = biLerp(dot0, dot1, dot2, dot3, xInterp, yInterp);\n\n    float xLerp = mod(uv.x / 2., gridDimension);\n    float revealMargin = gridDimension * .95;\n\n    if (hideLines || xLerp < revealMargin) {\n        return abs(val);\n    } else {\n        float marginLerp = (xLerp - revealMargin) / (1. - revealMargin);\n        float distFromCenterMargin = abs(.5 - marginLerp);\n        float marginSmooth = smoothstep(0.499, .5, distFromCenterMargin);\n        return mix(clamp(val, 0., 1.), abs(val), marginSmooth);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n\n    float timeScale = .08;\n    \n    uv += vec2(sin(iTime * timeScale), iTime * timeScale);\n    \n    vec3 background = vec3(0.2, 0., 0.);\n    vec3 color1 = vec3(1., 0.75, .25);\n    vec3 color2 = vec3(1.);\n    vec3 color3 = vec3(2.5);\n    \n    float gridSize = .15;\n    \n    float perlinVal1 = pow(getPerlinValue(uv, gridSize, false), .15);\n    float perlinVal2 = log(getPerlinValue(uv, gridSize, false)) / 4.;\n    float perlinVal3 = pow(getPerlinValue(uv, gridSize * 5., true), 2.);\n    \n    vec3 color = mix(mix(mix(background, color1, perlinVal1), color2, perlinVal2), color3, perlinVal3 * .7);\n    \n    if (INVERT) {\n        fragColor = vec4(1. - clamp(color.r, 0., 1.), 1. - clamp(color.g, 0., 1.), 1. - clamp(color.b, 0., 1.), 1.);\n    } else {\n        fragColor = vec4(vec3(color), 1.);\n    }\n    \n    return;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tcXRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 89, 109, 109, 175], [177, 177, 211, 211, 480], [482, 482, 562, 562, 682], [684, 684, 729, 729, 833], [835, 835, 908, 908, 1168], [1171, 1171, 1239, 1239, 2903], [2905, 2905, 2962, 2962, 3900]], "test": "untested"}
{"id": "sl3XRn", "name": "Segments - intersection", "author": "iq", "description": "Intersecting two line segments. Performance improvement and math simplification of [url]https://www.shadertoy.com/view/sl3SRn[/url]", "tags": ["2d", "line", "intersection", "segment"], "likes": 37, "viewed": 943, "published": 3, "date": "1638577123", "time_retrieved": "2024-07-30T18:44:14.546116", "image_code": "// The MIT License\n// Copyright  2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Intersecting two line segments\n//  l1(s) = a1 + s*(b1-a1)\n//  l2(t) = a2 + t*(b2-a2)\n// by equating them:\n//  l1(s) = l2(t) -> a1 + s*(b1-a1) = a2 + t*(b2-a2)\n// This is two equations with two unkowns:\n//  a1.x + s*(b1-a1).x = a2.x + t*(b2-a2).x\n//  a1.y + s*(b1-a1).y = a2.y + t*(b2-a2).y\n// So solve for s and t, for example like this:\n//  [(b1-a1).x (a2-b2).x][s] = (a2-a1).x\n//  [(b1-a1).y (a2-b2).y][t] = (a2-a1).y\n//\n// The little rectangle is the st space, and the yellow dot in it\n// the intersection point.\n\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nfloat vmax( in vec2 v ) { return max(v.x,v.y); }\n\nbool intersect( vec2 a1, vec2 b1, vec2 a2, vec2 b2, out vec2 point )\n{\n    float d = cro(b2-a2,b1-a1);\n    float s = cro(a1-a2,b1-a1) / d;\n    float t = cro(a1-a2,b2-a2) / d;\n    point = a1 + (b1-a1)*t; // or point = a2 + (b2-a2)*s;\n    return s>=0.0 && s<=1.0 && t>=0.0 && t<=1.0;\n    \n    // alternative test with one scalar comparisonss but more arithmetic\n    // return vmax(abs(vec2(s,t)-0.5))<0.5; \n}\n\n// same math as above, alternative writing by mla (see comments)\n/*\nbool intersect( vec2 a1, vec2 b1, vec2 a2, vec2 b2, out vec2 point )\n{\n    vec2 st = inverse(mat2(b1-a1,a2-b2))*(a2-a1);\n    point = a1 + (b1-a1)*st.x;\n    return st.x>=0.0 && st.x<=1.0 && st.y>=0.0 && st.y<=1.0;\n}\n*/\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/(dot(ba,ba)),0.0, 1.0);\n    return length(pa-ba*h);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdDisk( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c)-r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // animate\n    vec2 a1 = vec2(-2.0+vec2(1.5,1.0)*sin(iTime*1.1+vec2(0.0,0.5)));\n    vec2 b1 = vec2( 2.0+vec2(1.5,1.0)*sin(iTime*1.2+vec2(5.0,2.0)));\n    vec2 a2 = vec2(-2.0+vec2(1.5,1.0)*sin(iTime*1.3+vec2(3.0,1.0)));\n    vec2 b2 = vec2( 2.0+vec2(1.5,1.0)*sin(iTime*1.4+vec2(1.5,4.5)));\n\n    // NDC coords\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // background\n    vec3 col = vec3(0.15) - 0.04*length(p);\n\n    p *= 3.5;\n        \n    // segment 1\n    {\n    float    d = sdLine(p,a1,b1)-0.02;\n    d = min( d,  sdDisk(p,a1,0.06) );\n    d = min( d,  sdDisk(p,b1,0.06) );\n    col = mix(col, vec3(0.0,0.7,0.7), smoothstep(0.01,0.0,d) );\n    }\n    \n    // segment 2\n    {\n    float    d = sdLine(p,a2,b2)-0.02;\n    d = min( d,  sdDisk(p,a2,0.06) );\n    d = min( d,  sdDisk(p,b2,0.06) );\n    col = mix(col, vec3(0.2,0.5,1.0), smoothstep(0.01,0.0,d) );\n    }\n\n    // intersection\n    vec2 pos;\n    if( intersect(a1, b1, a2, b2, pos) )\n    {\n        float d = sdDisk(p,pos,0.03);\n        d = min( d, abs(d-0.2) ) - 0.01; // onion, see https://iquilezles.org/articles/distfunctions2d\n        col = mix(col, vec3(1.0,0.7,0.0), smoothstep(0.01,0.0,d));\n    }    \n\n    // draw intersection point in st space\n    {\n        vec2 p = fragCoord/iResolution.y;\n        float px = 1.0/iResolution.y;\n\n        // draw box\n        float br = 0.1;\n        vec2 bc = vec2(iResolution.x/iResolution.y-br-0.05,0.05+br);\n        float s = vmax(abs(p-bc)) - br;\n        // fill\n        col += 0.1*step(s,0.0);\n        // border\n        col += smoothstep(px,0.0,abs(s));\n        \n        // compute intersecton point again\n        vec2 st = inverse(mat2(b1-a1,a2-b2))*(a2-a1);\n        if( vmax(abs(st-0.5))<0.5 )\n        {\n            st = bc + br*(2.0*st-1.0);\n            float d = sdDisk(p,st,0.006);\n            col = mix(col, vec3(1.0,0.7,0.0), smoothstep(px,-px,d));\n        }\n    }\n\n    // cheap dither (color banding removal)\n    col += (1.0/512.0)*sin(fragCoord.x*2.0+13.0*fragCoord.y);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3XRn.jpg", "access": "api", "license": "mit", "functions": [[1598, 1598, 1633, 1633, 1661], [1662, 1662, 1687, 1687, 1710], [1712, 1712, 1782, 1782, 2118], [2407, 2458, 2506, 2506, 2620], [2622, 2673, 2723, 2723, 2751], [2753, 2753, 2810, 2825, 4846]], "test": "error"}
{"id": "flcSzr", "name": "Hybrid Virtual Particle Fluid", "author": "cornusammonis", "description": "Hybrid fluid solver using both forward and reverse advection.", "tags": ["simulation", "fluid", "poisson", "particle", "virtual"], "likes": 36, "viewed": 1160, "published": 3, "date": "1638575940", "time_retrieved": "2024-07-30T18:44:15.946372", "image_code": "/*\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n***Click to paint.***\n\nAutomatic mouse movement can be turned off using the ENABLE_AUTO_MOUSE #define\nThe bounding box can be turned off using the ENABLE_BOUNDS #define.\n\nThis is a hybrid fluid simulation that combines both forward and reverse\nadvection techniques to achieve a high-quality pressure solution,\naccurate advection, and decent performance while also remaining \nconservative unless under extreme velocities. The virtual particle\nmethod used here is based on Michael Moroz' Reintegration Tracking \nmethod, extended to support Gaussian particle kernels:\nhttps://www.shadertoy.com/view/WtfyDj\n\nIn the low-velocity regime, forward advection with virtual particles is\nused. Virtual particle size is controlled according to the magnitude of\nvelocity; low velocity particles increase in size while high velocity\nparticle decrease in size. The virtual particle size scaling measure\ncan be changed using the VIRTUAL_PARTICLE_SIZE #define.\n\nVirtual particles use a gaussian kernel. In order to conserve velocity\nand mass in forward advection, masses and velocities from neighboring\nparticles are accumulated according to box integrals of the error function\n(approximated here as tanh, but a more accurate approximation is provided\nby toggling the USE_TANH #define). Both the integral and center of mass\nof box intersections with a gaussian kernel are computed here.\n\nWhen particle velocities exceed the forward advection integration range, \nreverse advection is used, using the RK4 method. Using this method,\nit is possible to achieve forward advection without also setting a hard\nupper bound on velocity.\n\nThe Poisson pressure solver kernel used here is precomputed using a custom solver.\nFirst, a 2D kernel is computed, then a separable kernel is derived using\nSingular Value Decomposition. The separable kernel method used here can\nachieve a nearly-perfect pressure solve in 4 steps, but a single step is\nused here for interactivity. The number of pressure solver steps per\nfluid solver steps can be changed with the FRAME_DIVIDER #define (set to 1\nby default, but can be changed to 4 for a high quality pressure solve).\n\nAdditional methods are implemented here in order to increase fluid detail.\nThis simulation implements multiscale Vorticity Confinement, a kernel-based\nturbulence method based on my earlier Multiscale MIP Fluid simulation:\nhttps://www.shadertoy.com/view/tdVSDh\nand Florian Berger's work:\nhttps://www.shadertoy.com/view/MsGSRd\nThis work also implements multiscale viscosity. The size and shape of\nthe kernels for these methods can be changed using the\nMULTISCALE_KERNEL_POWER and MULTISCALE_KERNEL_STEPS #defines.\n\n\n*/\n\n#define THIN_FILM\n#ifdef NORMAL\nvoid mainImage( out vec4 c, in vec2 p )\n{    \n    initialize(p, iFrame, iResolution);\n\n    vec4 fluid = texture(iChannel1, uv);\n    #ifdef USE_VORTICITY\n        float v = 0.5*fluid.w + 0.5;\n    #else\n        float v = fluid.w;\n    #endif\n    c = v*(0.5 + 1.0*fluid);\n    \n    vec4 curlcol =  mix(vec4(1,0,0,0),vec4(0,0,1,0),smoothstep(0.,1.,fluid.w + 0.5));\n    curlcol = mix(vec4(1), curlcol, smoothstep(0.,1.,pow(abs(4.0*fluid.w),0.5)));\n    \n    float p0 = textureLod(iChannel1, uv, 0.).x;\n    float p1 = textureLod(iChannel1, uv, 12.).x;\n    float h = smoothstep(-1.,1., 0.2*(p0-p1));\n    c = vec4(smoothstep(-.4,1.2,2.0*h * length(fluid.xy) * curlcol));\n    //c = vec4(length(fluid.xy));\n    c = fluid.zzzz;\n    \n    vec2 comt = textureLod(iChannel2, uv, 0.).zw;\n    c = vec4(4.0*comt + 0.5,8.0*length(comt),0);\n}\n#endif\n\n#ifdef HEIGHT\nvoid mainImage( out vec4 c, in vec2 p )\n{    \n    initialize(p, iFrame, iResolution);\n    \n    vec4 tx = texelFetch(iChannel3, ivec2(p), 0);\n    vec2 t1 = unpack2x16(tx.x);\n    vec2 t2 = unpack2x16(tx.y);\n    vec2 t3 = unpack2x16(tx.z);\n\n    float height = texture(iChannel2, uv).x;\n    vec4 fluid = texture(iChannel1, uv);\n    \n    //c = 0.5 + 0.5*vec4(height);\n    //c = length(fluid.xy) * (0.5+fluid);\n    //c = 0.3*vec4(fluid.zzz,1);\n    c = 0.15*vec4(fluid.zzz,1) * vec4(length(fluid.xy));\n}\n#endif\n\n\n#ifdef THIN_FILM\n/*\n\tFast Thin-Film Interference\n\n\tThis is a performance-optimized version of my previous \n\tthin-film interference shader here: https://www.shadertoy.com/view/XddXRj\n\tThis version also fixes a platform-specific bug and has\n\ta few other tweaks as well.\n\n\tThin-film interference and chromatic dispersion are simulated at\n\tsix different wavelengths and then downsampled to RGB.\n*/\n\n// To see just the reflection (no refraction/transmission) uncomment this next line:\n//#define REFLECTANCE_ONLY\n\n// performance and raymarching options\n#define INTERSECTION_PRECISION 0.01  // raymarcher intersection precision\n#define ITERATIONS 20\t\t\t\t // max number of iterations\n#define AA_SAMPLES 1\t\t\t\t // anti aliasing samples\n#define BOUND 6.0\t\t\t\t\t // cube bounds check\n#define DIST_SCALE 0.9   \t\t\t // scaling factor for raymarching position update\n\n// optical properties\n#define DISPERSION 0.05\t\t\t     // dispersion amount\n#define IOR 0.9     \t\t\t\t // base IOR value specified as a ratio\n#define THICKNESS_SCALE 32.0\t\t // film thickness scaling factor\n#define THICKNESS_CUBEMAP_SCALE 0.1  // film thickness cubemap scaling factor\n#define REFLECTANCE_SCALE 3.0        // reflectance scaling factor\n#define REFLECTANCE_GAMMA_SCALE 1.0  // reflectance gamma scaling factor\n#define FRESNEL_RATIO 0.1\t\t\t // fresnel weight for reflectance\n#define SIGMOID_CONTRAST 10.0         // contrast enhancement\n\n#define GAMMA_CURVE 1.0\n#define GAMMA_SCALE 1.0\n\n#define TWO_PI 6.28318530718\n#define WAVELENGTHS 6\t\t\t\t // number of wavelengths, not a free parameter\n\n// iq's cubemap function\nvec3 fancyCube( sampler2D sam, in vec3 d, in float s, in float b )\n{\n    vec3 colx = textureLod( sam, 0.5 + s*d.yz/d.x, b ).xyz;\n    vec3 coly = textureLod( sam, 0.5 + s*d.zx/d.y, b ).xyz;\n    vec3 colz = textureLod( sam, 0.5 + s*d.xy/d.z, b ).xyz;\n    \n    vec3 n = d*d;\n    \n    return (colx*n.x + coly*n.y + colz*n.z)/(n.x+n.y+n.z);\n}\n\n// iq's 3D noise function\nfloat hash( float n ){\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nvec3 noise3(vec3 x) {\n\treturn vec3( noise(x+vec3(123.456,.567,.37)),\n\t\t\t\t noise(x+vec3(.11,47.43,19.17)),\n\t\t\t\t noise(x) );\n}\n\n// a sphere with a little bit of warp\nfloat sdf( vec3 p ) {\n\tvec3 n = vec3(sin(iDate.w * 0.5), sin(iDate.w * 0.3), cos(iDate.w * 0.2));\n\tvec3 q = 0.1 * (noise3(p + n) - 0.5);\n  \n\treturn length(q + p) - 3.5;\n}\n\nvec3 fresnel( vec3 rd, vec3 norm, vec3 n2 ) {\n   vec3 r0 = pow((1.0-n2)/(1.0+n2), vec3(2));\n   return r0 + (1. - r0)*pow(clamp(1. + dot(rd, norm), 0.0, 1.0), 5.);\n}\n\nvec3 calcNormal( in vec3 pos ) {\n    const float eps = INTERSECTION_PRECISION;\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*sdf( pos + v1*eps ) + \n\t\t\t\t\t  v2*sdf( pos + v2*eps ) + \n\t\t\t\t\t  v3*sdf( pos + v3*eps ) + \n\t\t\t\t\t  v4*sdf( pos + v4*eps ) );\n}\n\nvec3 filmic_gamma(vec3 x) {\n\treturn log(GAMMA_CURVE * x + 1.0) / GAMMA_SCALE;    \n}\n\nvec3 filmic_gamma_inverse(vec3 y) {\n\treturn (1.0 / GAMMA_CURVE) * (exp(GAMMA_SCALE * y) - 1.0); \n}\n\n// sample weights for the cubemap given a wavelength i\n// room for improvement in this function\n#define GREEN_WEIGHT 2.8\nvec3 texCubeSampleWeights(float i) {\n\tvec3 w = vec3((1.0 - i) * (1.0 - i), GREEN_WEIGHT * i * (1.0 - i), i * i);\n    return w / dot(w, vec3(1.0));\n}\n\nvec3 sampleCubeMap(vec3 i, vec3 rd) {\n\tvec3 col = textureLod(iChannel0, rd * vec3(1.0,-1.0,1.0), 0.0).xyz; \n    return vec3(\n        dot(texCubeSampleWeights(i.x), col),\n        dot(texCubeSampleWeights(i.y), col),\n        dot(texCubeSampleWeights(i.z), col)\n    );\n}\n\nvec3 sampleCubeMap(vec3 i, vec3 rd0, vec3 rd1, vec3 rd2) {\n\tvec3 col0 = textureLod(iChannel0, rd0 * vec3(1.0,-1.0,1.0), 0.0).xyz;\n    vec3 col1 = textureLod(iChannel0, rd1 * vec3(1.0,-1.0,1.0), 0.0).xyz; \n    vec3 col2 = textureLod(iChannel0, rd2 * vec3(1.0,-1.0,1.0), 0.0).xyz; \n    return vec3(\n        dot(texCubeSampleWeights(i.x), col0),\n        dot(texCubeSampleWeights(i.y), col1),\n        dot(texCubeSampleWeights(i.z), col2)\n    );\n}\n\n\n\nvec3 sampleWeights(float i) {\n\treturn vec3((1.0 - i) * (1.0 - i), GREEN_WEIGHT * i * (1.0 - i), i * i);\n}\n\nvec3 resample(vec3 wl0, vec3 wl1, vec3 i0, vec3 i1) {\n\tvec3 w0 = sampleWeights(wl0.x);\n    vec3 w1 = sampleWeights(wl0.y);\n    vec3 w2 = sampleWeights(wl0.z);\n    vec3 w3 = sampleWeights(wl1.x);\n    vec3 w4 = sampleWeights(wl1.y);\n    vec3 w5 = sampleWeights(wl1.z);\n    \n    return i0.x * w0 + i0.y * w1 + i0.z * w2\n         + i1.x * w3 + i1.y * w4 + i1.z * w5;\n}\n\n// downsample to RGB\nvec3 resampleColor(vec3[WAVELENGTHS] rds, vec3 refl0, vec3 refl1, vec3 wl0, vec3 wl1) {\n\n    \n    #ifdef REFLECTANCE_ONLY\n    \tvec3 intensity0 = refl0;\n    \tvec3 intensity1 = refl1;\n    #else\n        vec3 cube0 = sampleCubeMap(wl0, rds[0], rds[1], rds[2]);\n    \tvec3 cube1 = sampleCubeMap(wl1, rds[3], rds[4], rds[5]);\n    \n        vec3 intensity0 = filmic_gamma_inverse(cube0) + refl0;\n    \tvec3 intensity1 = filmic_gamma_inverse(cube1) + refl1;\n    #endif\n    vec3 col = resample(wl0, wl1, intensity0, intensity1);\n\n    return col / float(WAVELENGTHS);\n}\n\n// compute the wavelength/IOR curve values.\nvec3 iorCurve(vec3 x) {\n\treturn x;\n}\n\nvec3 attenuation(float filmThickness, vec3 wavelengths, vec3 normal, vec3 rd) {\n\treturn 0.5 + 0.5 * cos(((THICKNESS_SCALE * filmThickness)/(wavelengths + 1.0)) * dot(normal, rd));    \n}\n\nvec3 contrast(vec3 x) {\n\treturn 1.0 / (1.0 + exp(-SIGMOID_CONTRAST * (x - 0.5)));    \n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec4 m ) {\n    camTar = vec3(0.0,0.0,0.0); \n    if (max(m.z, m.w) <= 0.0) {\n    \tfloat an = 1.5 + sin(time * 0.05) * 4.0;\n\t\tcamPos = vec3(6.5*sin(an), 0.0 ,6.5*cos(an));   \n    } else {\n    \tfloat an = 10.0 * m.x - 5.0;\n\t\tcamPos = vec3(6.5*sin(an),10.0 * m.y - 5.0,6.5*cos(an)); \n    }\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{   \n    initialize(p, iFrame, iResolution);\n    vec3 col = vec3(0.0);\n    \n    Vec4Neighborhood pn = GetVec4Neighborhood(iChannel2);\n    vec2 dp = Delta(pn, 0);\n    \n    vec3 wavelengths0 = vec3(1.0, 0.8, 0.6);\n    vec3 wavelengths1 = vec3(0.4, 0.2, 0.0);\n    vec3 iors0 = IOR + iorCurve(wavelengths0) * DISPERSION;\n    vec3 iors1 = IOR + iorCurve(wavelengths1) * DISPERSION;\n    \n    vec3 rds[WAVELENGTHS];\n    \n\n    vec3 normal = normalize(vec3(dp,10.0));\n    vec3 nggx = normalize(vec3(dp,0.1));\n    \n    /*\n    mat3 camMat = calcLookAtMatrix( vec3(1.0*(uv-0.5),1), vec3(1,0,-1), 0.0 );\n    vec3 rd = camMat*vec3(0,0,1);*/\n    \n    #define TIME (0.05*(15.0*sin(iTime/30.0)+60.0))\n    //#define TIME 16.2+sin(0.05*51.2)\n    vec2 lookat = vec2(sin(TIME*1.1), cos(TIME));\n    mat3 camMat = calcLookAtMatrix( vec3(0,0,0), vec3(lookat,-1), PI );\n    vec3 rd = camMat*vec3(uv-0.5,1.0);\n    \n    float spec = 1.0*ggx(nggx, normalize(rd), vec3(0,1,8), 0.02, 1.0);\n\n    float filmThickness = 0.1+.2*textureLod(iChannel1, uv, 0.).z;\n\n    vec3 att0 = attenuation(filmThickness, wavelengths0, normal, rd);\n    vec3 att1 = attenuation(filmThickness, wavelengths1, normal, rd);\n\n    vec3 rrd = reflect(rd, normal);\n    vec3 f0 = (1.0 - FRESNEL_RATIO) + FRESNEL_RATIO * fresnel(rd, normal, 1.0 / iors0);\n    vec3 f1 = (1.0 - FRESNEL_RATIO) + FRESNEL_RATIO * fresnel(rd, normal, 1.0 / iors1);\n\n    //vec3 rrd = reflect(rd, normal);\n\n    vec3 cube0 = REFLECTANCE_GAMMA_SCALE * att0 * filmic_gamma_inverse(sampleCubeMap(wavelengths0, rrd));\n    vec3 cube1 = REFLECTANCE_GAMMA_SCALE * att1 * filmic_gamma_inverse(sampleCubeMap(wavelengths1, rrd));\n\n    vec3 refl0 = REFLECTANCE_SCALE * mix(vec3(0), cube0, f0);\n    vec3 refl1 = REFLECTANCE_SCALE * mix(vec3(0), cube1, f1);\n\n    rds[0] = refract(rd, normal, iors0.x);\n    rds[1] = refract(rd, normal, iors0.y);\n    rds[2] = refract(rd, normal, iors0.z);\n    rds[3] = refract(rd, normal, iors1.x);\n    rds[4] = refract(rd, normal, iors1.y);\n    rds[5] = refract(rd, normal, iors1.z);\n\n    col += resampleColor(rds, refl0, refl1, wavelengths0, wavelengths1);\n        \n    //c = vec4( contrast(col)+spec*col, 1.0 );\n    //c = vec4(contrast(0.6*filmic_gamma(spec*col)),1);\n    //c = vec4(contrast(filmic_gamma(col/1.0)),4);\n    c = vec4(contrast(filmic_gamma(col/2.0)),1);\n    //c += 0.25*spec;\n}\n#endif", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 c, in vec2 p )\n{\n    initialize(p, iFrame, iResolution);\n    if (iFrame <= 1) {\n        c = vec4(0,0,INIT_MASS,0);\n    } else {\n        if (FRAME_MOD(0)) {\n            Fluid(c, uv*R, iChannel0, iChannel1, iMouse);\n        } else {\n            c = texelFetch(iChannel0, ivec2(p), 0);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265\n#define TWO_PI 6.28318530718\n\n#define TURBULENCE_SCALE 0.1\n#define VORTICITY_SCALE 0.005\n#define VISCOSITY_SCALE 0.01\n#define MAX_CONSERVATIVE_DISTANCE 4.0\n\n#define MULTISCALE_KERNEL_POWER 3.0\n#define MULTISCALE_KERNEL_STEPS 1\n\n#define ENABLE_BOUNDS\n#define USE_TANH\n#define ENABLE_AUTO_MOUSE\n\n//#define VIRTUAL_PARTICLE_SIZE mix(0.4, 0.01, smoothstep(0., 3., mass * length(v)))\n#define VIRTUAL_PARTICLE_SIZE mix(1.0, 0.15, smoothstep(0., 3., length(v)))\n//#define VIRTUAL_PARTICLE_SIZE 0.15\n\n#define INIT_MASS 0.01\n#define FRAME_DIVIDER 1\n#define FRAME_MOD(x) ((iFrame % FRAME_DIVIDER)==0)\n\n\n\n\nvec2 R;\nint F;\nvec2 uv;\nvec2 texel;\n\nvec4 bounds;\n\n//internal RNG state \nuvec4 s0; \n\nvoid initialize(inout vec2 p, int frame, vec3 res)\n{\n    uv = p / res.xy;\n    p = floor(p);\n    R = res.xy;\n    texel = 1.0/R;\n    F = frame;\n    \n    bounds = vec4(2.0*texel,1.-2.0*texel);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\n\n#define _PH_COMP xy\n\nvec2 normz(vec2 x) {\n\treturn length(x) < 1e-6 ? vec2(0) : normalize(x);\n}\n\nvec4 normz(vec4 x) {\n\treturn length(x) < 1e-6 ? vec4(0) : normalize(x);\n}\n\n#define pack2x16(d) uintBitsToFloat(packHalf2x16(d))\n#define unpack2x16(d) unpackHalf2x16(floatBitsToUint(d))\n\nbool reset(sampler2D ch) {\n    return texture(ch, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\n\nfloat G1V(float dnv, float k){\n    return 1.0/(dnv*(1.0-k)+k);\n}\n\nfloat ggx(vec3 n, vec3 v, vec3 l, float rough, float f0){\n    float alpha = rough*rough;\n    vec3 h = normalize(v+l);\n    float dnl = clamp(dot(n,l), 0.0, 1.0);\n    float dnv = clamp(dot(n,v), 0.0, 1.0);\n    float dnh = clamp(dot(n,h), 0.0, 1.0);\n    float dlh = clamp(dot(l,h), 0.0, 1.0);\n    float f, d, vis;\n    float asqr = alpha*alpha;\n    const float pi = 3.14159;\n    float den = dnh*dnh*(asqr-1.0)+1.0;\n    d = asqr/(pi * den * den);\n    dlh = pow(1.0-dlh, 5.0);\n    f = f0 + (1.0-f0)*dlh;\n    float k = alpha/1.0;\n    vis = G1V(dnl, k)*G1V(dnv, k);\n    float spec = dnl * d * f * vis;\n    return spec;\n}\n\n\n\nstruct Vec4Neighborhood {\n    vec4 c; vec4 n; vec4 e; vec4 w; vec4 s; vec4 ne; vec4 nw; vec4 sw; vec4 se;\n};\n\nvec4 GetCenter(Vec4Neighborhood n) {\n    return n.c;\n}\n\nstruct Vec4Kernel {\n    vec4 c; vec4 n; vec4 e; vec4 w; vec4 s; vec4 ne; vec4 nw; vec4 sw; vec4 se;\n};\n\nvec4 ApplyVec4KernelVector(Vec4Neighborhood n, Vec4Kernel k) {\n    return n.c*k.c + n.n*k.n + n.e*k.e + n.w*k.w + n.s*k.s + n.ne*k.ne + n.nw*k.nw + n.sw*k.sw + n.se*k.se;\n}\n\nfloat ApplyVec4KernelScalar(Vec4Neighborhood n, Vec4Kernel k) {\n    return dot(n.c,k.c) + dot(n.n,k.n) + dot(n.e,k.e) + dot(n.w,k.w) + dot(n.s,k.s) \n         + dot(n.ne,k.ne) + dot(n.nw,k.nw) + dot(n.sw,k.sw) + dot(n.se,k.se);\n}\n\nvec4 ApplyVec4KernelPermutationVector(Vec4Neighborhood n, Vec4Kernel k, int v) {\n    return n.c[v]*k.c + n.n[v]*k.n + n.e[v]*k.e + n.w[v]*k.w + n.s[v]*k.s \n         + n.ne[v]*k.ne + n.nw[v]*k.nw + n.sw[v]*k.sw + n.se[v]*k.se;\n}\n\nvec4 ApplyVec4KernelPermutationVectorAbs(Vec4Neighborhood n, Vec4Kernel k, int v) {\n    return abs(n.c[v])*k.c + abs(n.n[v])*k.n + abs(n.e[v])*k.e + abs(n.w[v])*k.w + abs(n.s[v])*k.s \n         + abs(n.ne[v])*k.ne + abs(n.nw[v])*k.nw + abs(n.sw[v])*k.sw + abs(n.se[v])*k.se;\n}\n\nfloat ApplyVec4KernelPermutationScalar(Vec4Neighborhood n, Vec4Kernel k, int v) {\n    return dot(vec4(n.c[v]),k.c) + dot(vec4(n.n[v]),k.n) + dot(vec4(n.e[v]),k.e) \n         + dot(vec4(n.w[v]),k.w) + dot(vec4(n.s[v]),k.s) + dot(vec4(n.ne[v]),k.ne) \n         + dot(vec4(n.nw[v]),k.nw) + dot(vec4(n.sw[v]),k.sw) + dot(vec4(n.se[v]),k.se);\n}\n\n\nbool BoundsCheck(vec2 ouv) {\n    #ifdef ENABLE_BOUNDS\n        return (ouv.x < bounds.x || ouv.y < bounds.y || ouv.x > bounds.z || ouv.y > bounds.w);\n    #else\n        return false;\n    #endif\n}\n\nvec2 BoundsClamp(vec2 ouv) {\n    return clamp(ouv, bounds.xy, bounds.zw);\n}\n\nvec4 BoundedTex(sampler2D ch, vec2 p) {\n    if (BoundsCheck(p)) {\n        return vec4(0,0,0,0);\n    } else {\n        return textureLod(ch, p, 0.);\n    }\n}\n\nvec4 BoundedTex(sampler2D ch, vec2 off, int x, int y) {\n    vec2 ouv = uv + texel * (off + vec2(x,y));\n    return BoundedTex(ch, ouv);\n}\n\nvec4 BoundedTex(sampler2D ch, vec2 off, float x, float y) {\n    vec2 ouv = uv + texel * (off + vec2(x,y));\n    return BoundedTex(ch, ouv);\n}\n\n#define U(name,x,y) vec3 name = BoundedTex(ch, vec2(0), x, y)\n#define S(name,x,y) name = BoundedTex(ch, vec2(0), x, y)\n#define COM(name,x,y) name = BoundedTex(ch_com, vec2(0), x, y).zw\n#define SO(name,x,y) name = BoundedTex(ch, off, float(x), float(y))\n#define SR(name,x,y) name = BoundedTex(ch, off - RK4(ch, uv + texel*(off+vec2(x,y)), 1.0).xy, float(x), float(y))\n#define K(name,x,y,z,w) name = vec4(x,y,z,w)\n#define KV(name,x) name = vec4(x)\n\nvec2 RK4(sampler2D ch, vec2 p, float h){\n    vec2 k1 = BoundedTex(ch,p).xy;\n    vec2 k2 = BoundedTex(ch,p - texel*0.5*h*k1).xy;\n    vec2 k3 = BoundedTex(ch,p - texel*0.5*h*k2).xy;\n    vec2 k4 = BoundedTex(ch,p - texel*h*k3).xy;\n    return h/3.*(0.5*k1+k2+k3+0.5*k4);\n}\n\nvec2 RK4(sampler2D ch, float h){\n    return RK4(ch, uv, h);\n}\n\nVec4Neighborhood GetVec4Neighborhood(sampler2D ch) {\n    Vec4Neighborhood n;\n    S(n.c,0,0); S(n.n,0,1); S(n.e,1,0); S(n.s,0,-1); S(n.w,-1,0);\n    S(n.nw,-1,1); S(n.sw,-1,-1); S(n.ne,1,1); S(n.se,1,-1);\n    return n;\n}\n\nVec4Neighborhood GetVec4Neighborhood(sampler2D ch, vec2 off) {\n    Vec4Neighborhood n;\n    SO(n.c,0,0); SO(n.n,0,1); SO(n.e,1,0); SO(n.s,0,-1); SO(n.w,-1,0);\n    SO(n.nw,-1,1); SO(n.sw,-1,-1); SO(n.ne,1,1); SO(n.se,1,-1);\n    return n;\n}\n\nVec4Neighborhood GetVec4NeighborhoodRK4(sampler2D ch) {\n    Vec4Neighborhood n;\n    vec2 off = vec2(0);\n    SR(n.c,0,0); SR(n.n,0,1); SR(n.e,1,0); SR(n.s,0,-1); SR(n.w,-1,0);\n    SR(n.nw,-1,1); SR(n.sw,-1,-1); SR(n.ne,1,1); SR(n.se,1,-1);\n    return n;\n}\n\nVec4Neighborhood GetStridedVec4Neighborhood(sampler2D ch, float stride) {\n    Vec4Neighborhood n;\n    vec2 off = vec2(0);\n    float s = stride;\n    SO(n.c,0,0); SO(n.n,0,s); SO(n.e,s,0); SO(n.s,0,-s); SO(n.w,-s,0);\n    SO(n.nw,-s,1); SO(n.sw,-s,-s); SO(n.ne,s,s); SO(n.se,s,-s);\n    return n;\n}\n\nVec4Neighborhood GetStridedVec4NeighborhoodRK4(sampler2D ch, float stride) {\n    Vec4Neighborhood n;\n    vec2 off = vec2(0);\n    float s = stride;\n    SR(n.c,0,0); SR(n.n,0,s); SR(n.e,s,0); SR(n.s,0,-s); SR(n.w,-s,0);\n    SR(n.nw,-s,1); SR(n.sw,-s,-s); SR(n.ne,s,s); SR(n.se,s,-s);\n    return n;\n}\n\n\nVec4Neighborhood GetVec4NeighborhoodRK4(sampler2D ch, vec2 off) {\n    Vec4Neighborhood n;\n    SR(n.c,0,0); SR(n.n,0,1); SR(n.e,1,0); SR(n.s,0,-1); SR(n.w,-1,0);\n    SR(n.nw,-1,1); SR(n.sw,-1,-1); SR(n.ne,1,1); SR(n.se,1,-1);\n    return n;\n}\n\nVec4Kernel Vec4NeighborhoodToVec4KernelTransform(Vec4Neighborhood n, Vec4Kernel k) {\n    Vec4Kernel k2;\n    KV(k2.nw,n.nw*k.nw); KV(k2.n,n.n*k.n); KV(k2.ne,n.ne*k.ne);\n    KV(k2.w,n.w*k.w); KV(k2.c,n.c*k.c); KV(k2.e,n.e*k.e);\n    KV(k2.sw,n.sw*k.sw); KV(k2.s,n.s*k.s); KV(k2.se,n.se*k.se);\n    return k2;\n}\n\nVec4Kernel GetCurlKernel() {\n    const float D = 0.5;\n    Vec4Kernel k;\n    K(k.c, 0, 0, 0, 0);\n    K(k.n, 1, 0, 0, 0);\n    K(k.s,-1, 0, 0, 0);\n    K(k.e, 0,-1, 0, 0);\n    K(k.w, 0, 1, 0, 0);\n    K(k.nw, D, D, 0, 0);\n    K(k.ne, D,-D, 0, 0);\n    K(k.sw,-D, D, 0, 0);\n    K(k.se,-D,-D, 0, 0);\n    return k;\n}\n\n\nVec4Kernel GetDivKernel() {\n    const float D = 0.5;\n    Vec4Kernel k;\n    K(k.c, 0, 0, 0, 0);\n    K(k.n, 0,-1, 0, 0);\n    K(k.s, 0, 1, 0, 0);\n    K(k.e,-1, 0, 0, 0);\n    K(k.w, 1, 0, 0, 0);\n    K(k.nw, D,-D, 0, 0);\n    K(k.ne,-D,-D, 0, 0);\n    K(k.sw, D, D, 0, 0);\n    K(k.se,-D, D, 0, 0);\n    return k;\n}\n\nvec2 Turbulence(Vec4Neighborhood n) {\n    return  - 4.0 * n.c.xy \n            + 2.0 * vec2(n.n.x + n.s.x, n.e.y + n.w.y)\n            + (n.se - n.ne - n.sw + n.nw).yx;\n}\n\n\nVec4Kernel GetScalarKernel(float center, float edge, float vertex) {\n    Vec4Kernel k;\n    KV(k.c, center);\n    KV(k.n, edge);\n    KV(k.s, edge);\n    KV(k.e, edge);\n    KV(k.w, edge);\n    KV(k.nw, vertex);\n    KV(k.ne, vertex);\n    KV(k.sw, vertex);\n    KV(k.se, vertex);\n    return k;\n}\n\nVec4Kernel GetGaussianKernel() {\n    const float G0 = 0.25;\n    const float G1 = 0.125;\n    const float G2 = 0.0625;\n    return GetScalarKernel(G0, G1, G2);\n}\n\nVec4Kernel GetNeighborAvgKernel() {\n    const float G0 = 0.0;\n    const float G1 = 1.0/6.0;\n    const float G2 = 1.0/12.0;\n    return GetScalarKernel(G0, G1, G2);\n}\n\nVec4Kernel GetNeighborAvgVonNeumannKernel() {\n    const float G0 = 0.0;\n    const float G1 = 0.25;\n    const float G2 = 0.0;\n    return GetScalarKernel(G0, G1, G2);\n}\n\nVec4Kernel GetLaplacianKernel() {\n    const float L0 = -20.0/6.0;\n    const float L1 = 4.0/6.0;\n    const float L2 = 1.0/6.0;\n    return GetScalarKernel(L0, L1, L2);\n}\n\nvec4 Advect(sampler2D ch, float timestep) {\n    return textureLod(ch,fract(uv - texel*RK4(ch,timestep)), 0.);\n}\n\nvec2 Rotate(vec2 v, float r) {\n    float s = sin(r);\n    float c = cos(r);\n    return mat2(c, -s, s, c) * v;\n}\n\nvec2 SoftBound(vec2 x, float p) {\n    vec2 soft = normz(x) * pow(dot(x,x),1.5);\n    return x - p * soft;\n}\n\nfloat SoftBound(float x, float p) {\n    float soft = sign(x) * pow(abs(x),3.0);\n    return x - p * soft;\n}\n\nvec2 SoftBound(vec2 x, float s, float p) {\n    vec2 soft = normz(x) * pow(dot(s*x,s*x),1.5);\n    return x - p * soft;\n}\n\nfloat SoftBound(float x, float s, float p) {\n    float soft = sign(x) * pow(abs(s*x),3.0);\n    return x - p * soft;\n}\n\nvec2 HardBound(vec2 x, float p) {\n    return max(min((length(x) / p) > 1.0 ? (p * normz(x)) : x, p), -p);\n}\n\nfloat HardBound(float x, float p) {\n    return max(min(x, p), -p);\n}\n\nvec2 Vorticity(Vec4Neighborhood n, float curl) {\n    return  -curl * normz(ApplyVec4KernelPermutationVectorAbs(n, GetCurlKernel(), 3).xy);\n}\n\nvec2 Delta(Vec4Neighborhood n, int channel) {\n    return ApplyVec4KernelPermutationVector(n, GetDivKernel(), channel).xy;\n}\n\nvec4 getAutoMouse() {\n    int stage = (F/120)%4;\n    vec4 auto = vec4(0);\n    switch(stage) {\n        case 0:\n            auto = vec4(0.2, 0.5, 1.0, 0.0); break;\n        case 1:\n            auto = vec4(0.5, 0.2, 0.0, 1.0); break;\n        case 2:\n            auto = vec4(0.8, 0.5, -1.0, 0.0); break;\n        case 3:\n            auto = vec4(0.5, 0.8, 0.0, -1.0); break;\n    }\n    return auto * vec4(R,1,1);\n}\n\nvec4 MouseSpace(vec4 mouse, vec4 phase, vec2 p, float width, float strength) {\n    if (mouse.z > 0.) {\n        phase.xy += strength * exp(-length(p-mouse.xy) / width) * normz(mouse.xy-abs(mouse.zw));\n    } else {\n        #ifdef ENABLE_AUTO_MOUSE\n            vec4 auto = getAutoMouse();\n            phase.xy += strength * exp(-length(p-auto.xy) / width) * auto.zw;\n        #endif\n    }\n    return phase;\n}\n\nvec4 MouseMass(vec4 mouse, vec4 phase, vec2 p, float width, float strength) {\n    if (mouse.z > 0.) {\n        phase.z += strength * exp(-length(p-mouse.xy) / width);\n    } else {\n        #ifdef ENABLE_AUTO_MOUSE\n            vec4 auto = getAutoMouse();\n            phase.z += strength * exp(-length(p-auto.xy) / width);\n        #endif\n    }\n    return phase;\n}\n\n#undef T\n#undef V\n\n\nfloat erf(float x) {\n    #ifdef USE_TANH\n        return tanh(1.22848*x);\n    #elif USE_SMOOTHSTEP\n        return -1.+2.*smoothstep(-1.657,1.657,sign(x)*pow(abs(x),0.85715));\n    #else\n    if (x > 9.0) {\n        return 1.0;\n    } else if (x < -9.0) {\n        return -1.0;\n    } else if (abs(x) < 1e-9) {\n        return x;\n    }\n    const float p = 0.3275911;\n    const float a1 = 0.254829592;\n    const float a2 = -0.284496736;\n    const float a3 = 1.421413741;\n    const float a4 = -1.453152027;\n    const float a5 = 1.061405429;\n    float sx = sign(x);\n    x *= sx;\n    float t = 1.0 / (1.0 + p * x);\n    return clamp(sx * (1.0 - (a1*t + a2*t*t + a3*t*t*t + a4*t*t*t*t + a5*t*t*t*t*t) * exp(-x*x)),-1.0,1.0);\n    #endif\n}\n\n\nfloat safeexp(float x) {\n    return exp(clamp(x, -87.0, 87.0));\n}\n\n//https://www.wolframalpha.com/input/?i=%28%28sqrt%28k%29+e%5E%28-%28a%5E2+%2B+b%5E2%29%2Fk%29+%28e%5E%28a%5E2%2Fk%29+-+e%5E%28b%5E2%2Fk%29%29+%28erf%28c%2Fsqrt%28k%29%29+-+erf%28d%2Fsqrt%28k%29%29%29%29%2F%284+sqrt%28%CF%80%29%29%29++%2F+%281%2F4+%28erf%28a%2Fsqrt%28k%29%29+-+erf%28b%2Fsqrt%28k%29%29%29+%28erf%28c%2Fsqrt%28k%29%29+-+erf%28d%2Fsqrt%28k%29%29%29%29\nfloat center_of_mass(vec2 b, float K) {\n    float sqK = sqrt(K);\n    float sqP = sqrt(PI);\n    float erax = erf(b.x/sqK);\n    float erbx = erf(b.y/sqK);\n    float exabx = safeexp((b.x*b.x + b.y*b.y)/K);\n    float exax = safeexp(-(b.x*b.x)/K);\n    float exbx = safeexp(-(b.y*b.y)/K);\n    \n    //return clamp((sqK * (exax - exbx)) / (sqP * (erbx - erax)),-4.0,4.0);\n    return HardBound((sqK * (exax - exbx)) / (sqP * (erbx - erax)),16.0);\n}\n\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec2 omin = p - 0.5;\n    vec2 omax = p + 0.5; \n    \n    float sqK = sqrt(K);\n    float sqP = sqrt(PI);\n    \n    //https://www.wolframalpha.com/input/?i=integral+of+%28integral+of+exp%28-%28x%5E2%2By%5E2%29%2Fk%29+with+respect+to+x+from+a+to+b%29+with+respect+to+y+from+c+to+d\n    float masst = 0.25 *\n                    ((erf((omin.x - x.x)/sqK) - erf((omax.x - x.x)/sqK)) * \n                    (erf((omin.y - x.y)/sqK) - erf((omax.y - x.y)/sqK)));\n    \n    vec2 com2 = x-p+vec2(center_of_mass(vec2(omin.x - x.x,omax.x - x.x), K), center_of_mass(vec2(omin.y - x.y,omax.y - x.y), K));\n    return vec3(com2, masst);\n}\n\n#define range(i, r) for(int i = -r; i < r; i++)\n\n\n\n\nvec2 com(vec2 p, sampler2D ch, sampler2D ch_com) {\n    float mass_t = 0.0;\n    vec2 com_t = vec2(0);\n    range(i, 5) {\n        range(j, 5) {\n            vec2 off = vec2(0);\n            S(vec4 u,i,j);\n            COM(vec2 com_p,i,j);\n            float mass = u.z;\n            float curl = u.w;\n            vec2 v = u.xy;\n            vec2 p0 = com_p + vec2(i,j) + v;\n            vec3 d = distribution(p0, vec2(0), VIRTUAL_PARTICLE_SIZE);\n            float mass_p = mass * d.z;\n            mass_t += mass_p;\n            com_t += mass_p * d.xy;\n        }\n    }\n    if (mass_t != 0.0) {\n        com_t /= mass_t;\n    }\n    return vec2(com_t);\n}\n\nvec4 ForwardAdvection(vec2 p, sampler2D ch, sampler2D ch_com) {\n    float mass_t = 0.0;\n    vec2 vel_t = vec2(0);\n    float curl_t = 0.0;\n    range(i, 5) {\n        range(j, 5) {\n            vec2 off = vec2(0);\n            S(vec4 u,i,j);\n            COM(vec2 com_p,i,j);\n            float mass = u.z;\n            float curl = u.w;\n            vec2 v = u.xy;\n            vec2 p0 = com_p + vec2(i,j) + v;\n            vec3 d = distribution(p0, vec2(0), VIRTUAL_PARTICLE_SIZE);\n            float mass_p = mass * d.z;\n            mass_t += mass_p;\n            vel_t += v * mass_p;\n            curl_t += curl * mass_p;\n        }\n    }\n    if (mass_t != 0.0) {\n        vel_t /= mass_t;\n        curl_t /= mass_t;\n    }\n    return vec4(vel_t, mass_t, curl_t);\n}\n\n\nvec2 MultiscaleTurbulence(sampler2D ch) {\n    vec2 turbulence = vec2(0);\n    for (int i = 1; i <= MULTISCALE_KERNEL_STEPS; i++) {\n        float stride = float(i);\n        Vec4Neighborhood n = GetStridedVec4NeighborhoodRK4(ch, stride);\n        vec4 U = GetCenter(n);\n        float M = length(U.xy);\n        turbulence += M*(1.0/pow(stride,MULTISCALE_KERNEL_POWER))*Turbulence(n);  \n    }\n    return turbulence;\n}\n\nvec2 MultiscaleVorticity(sampler2D ch) {\n    vec2 vorticity = vec2(0);\n    for (int i = 1; i <= MULTISCALE_KERNEL_STEPS; i++) {\n        float stride = float(i);\n        Vec4Neighborhood n = GetStridedVec4NeighborhoodRK4(ch, stride);\n        vec4 U = GetCenter(n);\n        float M = length(U.xy);\n        float curl = ApplyVec4KernelScalar(n, GetCurlKernel());\n        vorticity += M*(1.0/pow(stride,MULTISCALE_KERNEL_POWER))*Vorticity(n, curl);\n    }\n    return vorticity;\n}\n\nvec4 MultiscaleViscosity(sampler2D ch) {\n    vec4 viscosity = vec4(0);\n    for (int i = 1; i <= MULTISCALE_KERNEL_STEPS; i++) {\n        float stride = float(i);\n        Vec4Neighborhood n = GetStridedVec4NeighborhoodRK4(ch, stride);\n        vec4 U = GetCenter(n);\n        vec4 laplacian = ApplyVec4KernelVector(n, GetLaplacianKernel());\n        viscosity += (1.0/pow(stride,MULTISCALE_KERNEL_POWER))*laplacian;\n    }\n    return viscosity;\n}\n\nvoid MultiscaleKernels(sampler2D ch, out vec2 turbulence, out vec2 vorticity, out vec2 viscosity) {\n    turbulence = vec2(0);\n    vorticity = vec2(0);\n    viscosity = vec2(0);\n    for (int i = 1; i <= MULTISCALE_KERNEL_STEPS; i++) {\n        float stride = float(i);\n        Vec4Neighborhood n = GetStridedVec4NeighborhoodRK4(ch, stride);\n        vec4 U = GetCenter(n);\n        float M = length(U.xy);\n        float curl = ApplyVec4KernelScalar(n, GetCurlKernel());\n        vec4 laplacian = ApplyVec4KernelVector(n, GetLaplacianKernel());\n        float W = (1.0/pow(stride,MULTISCALE_KERNEL_POWER));\n        viscosity += W*laplacian.xy;\n        turbulence += M*W*Turbulence(n);  \n        vorticity += M*W*Vorticity(n, curl);\n    }\n}\n\n\nvoid Fluid( out vec4 U, in vec2 p, sampler2D ch, sampler2D ch_com, vec4 mouse )\n{\n    vec2 turbulence, viscosity, vorticity;\n    MultiscaleKernels(ch, turbulence, vorticity, viscosity);\n\n    Vec4Neighborhood neighborhood = GetVec4NeighborhoodRK4(ch, TURBULENCE_SCALE * turbulence);\n\n    vec4 dist = ForwardAdvection(p, ch, ch_com);\n    U = GetCenter(neighborhood);\n    //U = mix(dist,U,smoothstep(0.0,MAX_CONSERVATIVE_DISTANCE,length(U.xy)));\n    U = mix(dist,U,smoothstep(MAX_CONSERVATIVE_DISTANCE - 1.0,MAX_CONSERVATIVE_DISTANCE,length(U.xy)));\n    \n    //float lU = length(U.xy);\n\n    // Laplacian/Viscosity\n    U.xy += VISCOSITY_SCALE*viscosity;\n\n    // Curl/Vorticity\n    U.w = ApplyVec4KernelScalar(neighborhood, GetCurlKernel());\n    U.xy += VORTICITY_SCALE*vorticity; \n    \n    //U.xy = lU*normz(U.xy);\n\n    // Add mass with the mouse\n    U = MouseMass(mouse, U, p, 10.0, 0.2);\n    \n    // Mouse interaction in phase domain/space domain\n    U = MouseSpace(mouse, U, p, 20.0, 0.3);\n\n    U.xy = SoftBound(U.xy, 1.0, 0.00001);\n    U.xy = HardBound(U.xy, 16.0);\n    U.z = max(0.0, SoftBound(U.z, 0.00001));\n}", "buffer_b_code": "bool reset() {\n    return iFrame <= 1 || texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvec4 Po(int m, int n) {\n    vec2 ouv = uv + texel * vec2(m,n);\n    if (BoundsCheck(ouv)) {\n        return vec4(pack2x16(vec2(0)),pack2x16(vec2(0)),pack2x16(vec2(0)),0);\n    } else {\n        return textureLod(iChannel0, ouv, 0.0);\n    }\n}\n\nfloat Go(int m, int n) {\n    vec2 ouv = uv + texel * vec2(m,n);\n    if (BoundsCheck(ouv)) {\n        return 0.0;\n    } else {\n        return textureLod(iChannel1, ouv, 0.0).x;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initialize(fragCoord, iFrame, iResolution);\n    \n    vec3 p_y[151] = vec3[](vec3(-0.00039936512386562484,-0.0013037830496811509,-0.003024369266497462),vec3(-0.00043479272952107184,-0.001418247837094988,-0.0032841431420175815),vec3(-0.00047311175208775147,-0.0015418984185112672,-0.0035640171624620187),vec3(-0.0005145378703601011,-0.0016753999013442086,-0.003865351345832546),vec3(-0.0005593015430286112,-0.00181946044562425,-0.004189581775882141),vec3(-0.0006076489826017296,-0.001974833797626846,-0.004538223620654535),vec3(-0.0006598431999115183,-0.002142321974855929,-0.004912874168389093),vec3(-0.0007161651258619417,-0.0023227781140663494,-0.005315215867981123),vec3(-0.0007769148178819725,-0.0025171094952469407,-0.00574701935895483),vec3(-0.0008424127594587307,-0.002726280755872174,-0.0062101464732849465),vec3(-0.0009130012621639432,-0.002951317311279131,-0.006706553188329675),vec3(-0.0009890459807688295,-0.003193308998756704,-0.007238292506523368),vec3(-0.0010709375533892544,-0.0034534139648667857,-0.007807517233220254),vec3(-0.001159093380140449,-0.003732862817675909,-0.008416482619054973),vec3(-0.0012539595555377625,-0.004032963067987648,-0.009067548827244675),vec3(-0.0013560129718921017,-0.004355103886359663,-0.009763183179221676),vec3(-0.0014657636132559054,-0.004700761205697934,-0.010505962123640127),vec3(-0.0015837570621268875,-0.0050715032025820585,-0.011298572863887848),vec3(-0.001710577244168271,-0.005468996194229675,-0.01214381456744096),vec3(-0.0018468494397243054,-0.005895010992201898,-0.01304459906634993),vec3(-0.0019932435949786592,-0.006351429758636426,-0.014003950941382284),vec3(-0.0021504779703164487,-0.006840253416027218,-0.015025006862317022),vec3(-0.0023193231689242525,-0.007363609667412167,-0.016111014032915174),vec3(-0.002500606595033479,-0.007923761690353888,-0.017265327560358507),vec3(-0.002695217398648073,-0.008523117575376556,-0.018491406534454295),vec3(-0.002904111972299025,-0.009164240587639544,-0.019792808560418648),vec3(-0.0031283200755794476,-0.00984986033967067,-0.021173182439071275),vec3(-0.003368951675232755,-0.01058288497304438,-0.022636258627945997),vec3(-0.0036272046027564153,-0.01136641445806573,-0.02418583704385647),vec3(-0.0039043731482907218,-0.012203755132905171,-0.025825771679025524),vec3(-0.004201857729535902,-0.013098435617310009,-0.027559951395473018),vec3(-0.00452117579826187,-0.01405422425106731,-0.029392276131583135),vec3(-0.00486397417548751,-0.015075148223856253,-0.0313266275951637),vec3(-0.005232043040666073,-0.016165514581003473,-0.03336683332200887),vec3(-0.00562733184154224,-0.017329933308865297,-0.03551662273933928),vec3(-0.0060519674414129645,-0.018573342723915864,-0.037779573578614306),vec3(-0.006508274881439065,-0.01990103741075051,-0.040159046618245986),vec3(-0.006998801210110017,-0.021318698975493443,-0.0426581062860751),vec3(-0.007526342923405148,-0.022832429901508428,-0.04527942409155754),vec3(-0.008093977672062791,-0.024448790812264518,-0.048025161159515134),vec3(-0.008705101032420682,-0.026174841459272888,-0.05089682526368315),vec3(-0.009363469312043276,-0.028018185757524506,-0.05389509666073895),vec3(-0.010073249580677117,-0.029987021181332632,-0.05701961564096375),vec3(-0.01083907839404583,-0.03209019280176492,-0.06026872295763385),vec3(-0.011666131030046848,-0.03433725218081176,-0.0636391420650306),vec3(-0.012560203507485332,-0.03673852121908325,-0.06712558924087116),vec3(-0.013527810238371974,-0.03930516085637037,-0.07072029400179898),vec3(-0.014576300919535715,-0.04204924420785956,-0.07441240748450588),vec3(-0.015714001257992345,-0.04498383322316428,-0.07818727031588318),vec3(-0.016950383431117873,-0.04812305719009568,-0.08202550346745388),vec3(-0.018296273925712297,-0.051482190232598785,-0.08590187504816119),vec3(-0.01976410874874513,-0.05507772316147769,-0.0897838820674849),vec3(-0.02136824920173702,-0.05892742230067349,-0.09362996770370406),vec3(-0.02312537581916243,-0.06305036371943105,-0.09738726988920325),vec3(-0.025054984222680283,-0.06746692484105196,-0.10098876378585503),vec3(-0.02718001534382911,-0.07219870536957633,-0.10434961578501721),vec3(-0.02952766495752478,-0.07726833375162516,-0.10736250560624028),vec3(-0.03213043568796663,-0.08269909044537457,-0.10989158977713533),vec3(-0.03502752169832732,-0.08851423913888098,-0.11176466592987913),vec3(-0.03826665722222464,-0.09473589144745072,-0.11276294193733785),vec3(-0.041906623421512364,-0.10138312131867837,-0.11260760327593745),vec3(-0.04602070835716154,-0.10846885934496983,-0.11094209169468648),vec3(-0.050701578024441495,-0.1159947726771164,-0.10730865033138975),vec3(-0.05606828993205902,-0.12394275393722222,-0.10111727591157052),vec3(-0.06227665518595623,-0.13226056303078285,-0.09160486258770702),vec3(-0.06953501099043398,-0.14083708737623918,-0.077782417479591),vec3(-0.07812908130749861,-0.149458503599576,-0.058369977232929894),vec3(-0.08846282054472075,-0.15772775580732623,-0.031725854990398726),vec3(-0.10112895949827036,-0.1649097516191365,0.004199908847829801),vec3(-0.11703860203562352,-0.16961595360355963,0.05178318985988212),vec3(-0.13767855574664672,-0.16911182932471974,0.11316073490042394),vec3(-0.16567645398825667,-0.15763971441508162,0.18793345990415217),vec3(-0.2062192509611813,-0.12179330842214287,0.2642830614724927),vec3(-0.2713074094027817,-0.02537420724641723,0.28182569573805677),vec3(-0.395760620255607,0.2520387049261719,-0.04827629938430805),vec3(-0.4794057541719356,0.45941736433304614,-0.35998402950121244),vec3(-0.39576062025560704,0.25203870492617186,-0.04827629938430784),vec3(-0.27130740940278164,-0.02537420724641726,0.2818256957380568),vec3(-0.20621925096118135,-0.12179330842214289,0.2642830614724926),vec3(-0.16567645398825667,-0.15763971441508165,0.18793345990415228),vec3(-0.13767855574664675,-0.1691118293247198,0.1131607349004239),vec3(-0.11703860203562354,-0.1696159536035597,0.05178318985988209),vec3(-0.10112895949827036,-0.1649097516191365,0.004199908847829665),vec3(-0.0884628205447208,-0.1577277558073263,-0.03172585499039877),vec3(-0.07812908130749864,-0.14945850359957605,-0.05836997723292993),vec3(-0.06953501099043398,-0.14083708737623918,-0.07778241747959105),vec3(-0.06227665518595623,-0.13226056303078287,-0.09160486258770703),vec3(-0.05606828993205902,-0.12394275393722226,-0.10111727591157058),vec3(-0.050701578024441495,-0.11599477267711644,-0.10730865033138978),vec3(-0.04602070835716156,-0.10846885934496989,-0.1109420916946865),vec3(-0.04190662342151239,-0.10138312131867841,-0.11260760327593748),vec3(-0.03826665722222467,-0.09473589144745076,-0.11276294193733784),vec3(-0.03502752169832737,-0.08851423913888105,-0.1117646659298792),vec3(-0.032130435687966606,-0.0826990904453746,-0.10989158977713538),vec3(-0.029527664957524794,-0.0772683337516252,-0.10736250560624033),vec3(-0.027180015343829116,-0.07219870536957636,-0.1043496157850173),vec3(-0.025054984222680304,-0.06746692484105203,-0.10098876378585511),vec3(-0.023125375819162436,-0.06305036371943108,-0.09738726988920338),vec3(-0.02136824920173702,-0.058927422300673514,-0.09362996770370416),vec3(-0.019764108748745155,-0.05507772316147772,-0.08978388206748496),vec3(-0.01829627392571232,-0.05148219023259884,-0.08590187504816127),vec3(-0.01695038343111789,-0.04812305719009571,-0.08202550346745398),vec3(-0.015714001257992355,-0.0449838332231643,-0.07818727031588321),vec3(-0.014576300919535724,-0.04204924420785958,-0.07441240748450599),vec3(-0.013527810238371971,-0.039305160856370404,-0.07072029400179902),vec3(-0.012560203507485332,-0.036738521219083255,-0.06712558924087117),vec3(-0.011666131030046859,-0.03433725218081179,-0.0636391420650307),vec3(-0.01083907839404584,-0.03209019280176495,-0.06026872295763393),vec3(-0.010073249580677119,-0.029987021181332653,-0.05701961564096378),vec3(-0.009363469312043281,-0.02801818575752456,-0.05389509666073898),vec3(-0.008705101032420694,-0.026174841459272933,-0.0508968252636832),vec3(-0.008093977672062803,-0.024448790812264518,-0.04802516115951517),vec3(-0.007526342923405146,-0.02283242990150845,-0.04527942409155761),vec3(-0.006998801210110013,-0.021318698975493443,-0.04265810628607512),vec3(-0.006508274881439066,-0.01990103741075051,-0.040159046618246),vec3(-0.00605196744141298,-0.018573342723915892,-0.03777957357861436),vec3(-0.005627331841542247,-0.017329933308865328,-0.03551662273933936),vec3(-0.005232043040666078,-0.016165514581003487,-0.033366833322008904),vec3(-0.004863974175487524,-0.015075148223856267,-0.031326627595163734),vec3(-0.004521175798261876,-0.01405422425106733,-0.029392276131583166),vec3(-0.004201857729535902,-0.013098435617310021,-0.027559951395473042),vec3(-0.0039043731482907213,-0.012203755132905178,-0.025825771679025535),vec3(-0.003627204602756424,-0.01136641445806575,-0.024185837043856497),vec3(-0.003368951675232753,-0.010582884973044387,-0.022636258627946024),vec3(-0.0031283200755794494,-0.009849860339670675,-0.021173182439071295),vec3(-0.002904111972299031,-0.009164240587639563,-0.019792808560418675),vec3(-0.002695217398648074,-0.00852311757537658,-0.01849140653445433),vec3(-0.002500606595033485,-0.007923761690353899,-0.017265327560358527),vec3(-0.0023193231689242495,-0.007363609667412189,-0.016111014032915188),vec3(-0.002150477970316447,-0.006840253416027219,-0.01502500686231705),vec3(-0.001993243594978657,-0.006351429758636433,-0.014003950941382294),vec3(-0.0018468494397243095,-0.005895010992201904,-0.013044599066349954),vec3(-0.0017105772441682716,-0.005468996194229684,-0.012143814567440982),vec3(-0.0015837570621268916,-0.0050715032025820655,-0.011298572863887869),vec3(-0.0014657636132559086,-0.004700761205697936,-0.010505962123640147),vec3(-0.0013560129718921034,-0.004355103886359678,-0.009763183179221696),vec3(-0.0012539595555377642,-0.004032963067987664,-0.009067548827244698),vec3(-0.0011590933801404499,-0.003732862817675913,-0.00841648261905499),vec3(-0.0010709375533892564,-0.003453413964866797,-0.007807517233220275),vec3(-0.0009890459807688297,-0.0031933089987567142,-0.007238292506523384),vec3(-0.0009130012621639455,-0.002951317311279133,-0.006706553188329679),vec3(-0.0008424127594587336,-0.002726280755872182,-0.006210146473284956),vec3(-0.0007769148178819765,-0.002517109495246948,-0.005747019358954837),vec3(-0.0007161651258619422,-0.002322778114066351,-0.005315215867981134),vec3(-0.0006598431999115193,-0.0021423219748559342,-0.004912874168389099),vec3(-0.0006076489826017314,-0.0019748337976268505,-0.004538223620654547),vec3(-0.0005593015430286124,-0.001819460445624252,-0.004189581775882171),vec3(-0.0005145378703601023,-0.001675399901344218,-0.00386535134583253),vec3(-0.00047311175208774605,-0.001541898418511293,-0.003564017162461541),vec3(-0.0004347927295209686,-0.0014182478370946185,-0.003284143142016918),vec3(-0.0003993651238658139,-0.0013037830496811053,-0.003024369266498018));\n    vec3 p_x[151] = vec3[](vec3(-0.002137124133264062,-0.0045652949750816674,-0.007944999489624014),vec3(-0.002300156955533428,-0.004908806940460253,-0.008525633362203022),vec3(-0.0024740180160609526,-0.0052745508615946735,-0.009141755140060714),vec3(-0.0026593024187144994,-0.005663677685852353,-0.009794948578414675),vec3(-0.0028566298846672803,-0.006077377342767512,-0.010486819494099436),vec3(-0.0030666454073479945,-0.006516878738501725,-0.011218991293007716),vec3(-0.0032900199322388997,-0.0069834496606139915,-0.011993099926857181),vec3(-0.0035274510673012965,-0.007478396589859675,-0.012810788233390612),vec3(-0.0037796638307912127,-0.008003064415882877,-0.013673699609992897),vec3(-0.004047411444335345,-0.008558836053786144,-0.014583470965923965),vec3(-0.004331476180377802,-0.009147131958638085,-0.015541724892891462),vec3(-0.00463267027449884,-0.009769409534995865,-0.01655006098737826),vec3(-0.004951836914666999,-0.010427162438453347,-0.017610046250856503),vec3(-0.005289851321237063,-0.011121919766049194,-0.018723204485601174),vec3(-0.005647621933474761,-0.011855245132051603,-0.019891004594067244),vec3(-0.006026091720604429,-0.012628735625135244,-0.02111484767848965),vec3(-0.0064262396378738365,-0.013444020642236373,-0.02239605282424208),vec3(-0.006849082250952507,-0.014302760593353525,-0.02373584143523893),vec3(-0.007295675555175712,-0.015206645470184573,-0.025135319971921),vec3(-0.0077671170197740995,-0.01615739326966947,-0.026595460921701564),vec3(-0.008264547891358274,-0.01715674826113821,-0.02811708180766433),vec3(-0.008789155795641856,-0.0182064790827157,-0.02970082201319753),vec3(-0.009342177681784285,-0.019308376648754934,-0.031347117167421494),vec3(-0.00992490315993552,-0.02046425184516241,-0.03305617079787943),vec3(-0.010538678289711445,-0.021675932983309377,-0.03482792291202483),vec3(-0.011184909885595262,-0.022945262975493885,-0.036662015116369455),vec3(-0.011865070414853763,-0.024274096185269295,-0.03855775182034264),vec3(-0.01258070357473496,-0.025664294893927936,-0.040514056999271006),vec3(-0.013333430648782561,-0.02711772530945963,-0.042529425905391674),vec3(-0.01412495775744369,-0.028636253025678345,-0.04460187101503015),vec3(-0.014957084136223639,-0.030221737816030457,-0.04672886138108205),vec3(-0.01583171159602881,-0.031876027617728446,-0.04890725441919534),vec3(-0.016750855345744924,-0.03360095152585251,-0.051133218989284704),vec3(-0.01771665638740403,-0.03539831157208638,-0.0534021484360339),vec3(-0.018731395730599044,-0.03726987300644707,-0.055708562016558806),vec3(-0.019797510716488533,-0.0392173527296855,-0.05804599286274144),vec3(-0.020917613794531456,-0.04124240543505191,-0.06040686029055546),vec3(-0.02209451415920214,-0.043346606905710634,-0.06278232386756345),vec3(-0.023331242732158364,-0.045531433771570005,-0.06516211616871623),vec3(-0.024631081071251157,-0.04779823884785927,-0.06753435057251908),vec3(-0.02599759490599191,-0.05014822094579368,-0.06988529975365311),vec3(-0.02743467314560627,-0.05258238774762672,-0.07219913968862342),vec3(-0.028946573388404322,-0.05510150995351754,-0.07445765297670581),vec3(-0.03053797519013025,-0.05770606440794075,-0.07663988405127538),vec3(-0.03221404263776634,-0.0603961632607468,-0.07872173737035694),vec3(-0.033980498142029227,-0.06317146536031418,-0.08067550787447306),vec3(-0.035843709830794705,-0.06603106494154067,-0.08246933081865009),vec3(-0.03781079552984435,-0.0689733511594637,-0.08406653544718634),vec3(-0.03988974710170204,-0.07199582998922682,-0.08542488379813157),vec3(-0.042089579940160424,-0.07509489726503166,-0.08649567210767374),vec3(-0.044420513774308154,-0.0782655478780229,-0.0872226677458533),vec3(-0.046894192744119025,-0.0815010009801992,-0.08754084929384119),vec3(-0.04952395514522684,-0.08479221383871625,-0.08737491127852688),vec3(-0.052325166556904924,-0.08812724684632407,-0.0866374883735367),vec3(-0.05531563463635159,-0.09149042775415551,-0.08522704702612285),vec3(-0.05851613023760088,-0.09486124236558141,-0.0830253865465934),vec3(-0.06195104853165206,-0.09821284847174405,-0.0798946889222969),vec3(-0.06564925675340012,-0.10151006459451122,-0.07567406140614437),vec3(-0.06964519409927278,-0.1047066168725813,-0.07017553687965904),vec3(-0.07398031737724835,-0.10774132259935602,-0.06317955075217202),vec3(-0.0787050285543731,-0.11053272464789683,-0.054430032064937746),vec3(-0.08388128622421473,-0.11297142788834234,-0.0436294939520135),vec3(-0.08958620751898465,-0.1149089568361548,-0.03043501110604133),vec3(-0.09591713730219445,-0.11614122538666281,-0.014456986894158296),vec3(-0.10299894760598283,-0.11638344275691273,0.004735321117216877),vec3(-0.11099482783905858,-0.11523099884933204,0.027593267367261202),vec3(-0.12012272629777299,-0.1120965987947297,0.054535916053032214),vec3(-0.13068130718798532,-0.10610553463683693,0.08582732348023998),vec3(-0.1430926878027598,-0.09591364237278834,0.12130023611322262),vec3(-0.15797644463814361,-0.07937430036055836,0.15972950012046713),vec3(-0.17628590900450966,-0.05289019694443883,0.1973636686263485),vec3(-0.19957914170178254,-0.010050447660950014,0.22428672225770246),vec3(-0.23061230582092926,0.06152568473621712,0.21465485784075855),vec3(-0.2748091985304043,0.18844826204726473,0.09754352781288295),vec3(-0.3445128239871801,0.4367329316543684,-0.34280145660982947),vec3(3.01878863857207e-17,2.1657391732312188e-17,2.1073950360688117e-17),vec3(0.3445128239871802,-0.4367329316543684,0.3428014566098292),vec3(0.27480919853040436,-0.18844826204726473,-0.09754352781288317),vec3(0.23061230582092923,-0.061525684736217036,-0.21465485784075863),vec3(0.19957914170178256,0.01005044766095007,-0.2242867222577026),vec3(0.17628590900450966,0.0528901969444389,-0.19736366862634852),vec3(0.15797644463814361,0.07937430036055836,-0.15972950012046708),vec3(0.14309268780275983,0.09591364237278836,-0.1213002361132226),vec3(0.13068130718798535,0.10610553463683695,-0.08582732348023968),vec3(0.12012272629777299,0.11209659879472973,-0.054535916053032235),vec3(0.11099482783905856,0.11523099884933206,-0.027593267367261167),vec3(0.10299894760598281,0.11638344275691272,-0.004735321117216822),vec3(0.09591713730219444,0.11614122538666284,0.014456986894158358),vec3(0.08958620751898468,0.11490895683615483,0.03043501110604141),vec3(0.08388128622421473,0.11297142788834233,0.04362949395201367),vec3(0.0787050285543731,0.11053272464789683,0.054430032064937794),vec3(0.07398031737724835,0.10774132259935604,0.06317955075217199),vec3(0.06964519409927278,0.10470661687258127,0.07017553687965912),vec3(0.06564925675340012,0.10151006459451126,0.07567406140614436),vec3(0.06195104853165206,0.09821284847174405,0.0798946889222969),vec3(0.05851613023760088,0.09486124236558141,0.08302538654659344),vec3(0.05531563463635159,0.09149042775415551,0.08522704702612297),vec3(0.05232516655690491,0.08812724684632407,0.08663748837353664),vec3(0.04952395514522684,0.08479221383871625,0.08737491127852687),vec3(0.046894192744119025,0.08150100098019919,0.0875408492938412),vec3(0.044420513774308154,0.0782655478780229,0.0872226677458533),vec3(0.04208957994016041,0.07509489726503163,0.08649567210767378),vec3(0.03988974710170204,0.07199582998922681,0.08542488379813157),vec3(0.037810795529844336,0.0689733511594637,0.08406653544718634),vec3(0.03584370983079468,0.06603106494154064,0.0824693308186501),vec3(0.03398049814202922,0.06317146536031418,0.08067550787447306),vec3(0.03221404263776634,0.0603961632607468,0.07872173737035698),vec3(0.03053797519013025,0.05770606440794075,0.07663988405127538),vec3(0.02894657338840431,0.055101509953517515,0.07445765297670578),vec3(0.02743467314560627,0.05258238774762672,0.07219913968862343),vec3(0.025997594905991905,0.05014822094579368,0.06988529975365308),vec3(0.024631081071251146,0.04779823884785925,0.06753435057251908),vec3(0.02333124273215836,0.04553143377157,0.06516211616871614),vec3(0.022094514159202137,0.04334660690571063,0.06278232386756344),vec3(0.020917613794531453,0.041242405435051886,0.060406860290555434),vec3(0.019797510716488522,0.039217352729685476,0.05804599286274142),vec3(0.01873139573059904,0.03726987300644707,0.05570856201655882),vec3(0.017716656387404026,0.035398311572086366,0.05340214843603387),vec3(0.016750855345744917,0.0336009515258525,0.051133218989284704),vec3(0.015831711596028804,0.03187602761772843,0.04890725441919533),vec3(0.01495708413622363,0.030221737816030454,0.04672886138108203),vec3(0.014124957757443688,0.028636253025678342,0.04460187101503013),vec3(0.013333430648782552,0.02711772530945961,0.04252942590539163),vec3(0.012580703574734953,0.025664294893927922,0.040514056999270985),vec3(0.011865070414853759,0.024274096185269285,0.03855775182034264),vec3(0.011184909885595262,0.022945262975493878,0.036662015116369455),vec3(0.010538678289711445,0.02167593298330937,0.0348279229120248),vec3(0.009924903159935513,0.020464251845162408,0.03305617079787941),vec3(0.00934217768178428,0.019308376648754923,0.03134711716742148),vec3(0.00878915579564185,0.01820647908271569,0.029700822013197525),vec3(0.008264547891358267,0.017156748261138197,0.028117081807664302),vec3(0.007767117019774098,0.016157393269669456,0.026595460921701543),vec3(0.0072956755551757,0.015206645470184556,0.02513531997192098),vec3(0.0068490822509524995,0.014302760593353517,0.023735841435238908),vec3(0.006426239637873832,0.013444020642236359,0.022396052824242063),vec3(0.006026091720604427,0.012628735625135236,0.02111484767848964),vec3(0.0056476219334747595,0.011855245132051592,0.019891004594067244),vec3(0.005289851321237059,0.01112191976604919,0.018723204485601167),vec3(0.0049518369146669934,0.010427162438453336,0.017610046250856482),vec3(0.004632670274498837,0.009769409534995856,0.016550060987378257),vec3(0.004331476180377796,0.009147131958638074,0.015541724892891445),vec3(0.004047411444335342,0.008558836053786137,0.014583470965923953),vec3(0.0037796638307912088,0.008003064415882869,0.013673699609992889),vec3(0.0035274510673012917,0.007478396589859665,0.012810788233390602),vec3(0.003290019932238895,0.006983449660613981,0.011993099926857178),vec3(0.0030666454073479924,0.006516878738501718,0.011218991293007703),vec3(0.002856629884667277,0.006077377342767509,0.01048681949409938),vec3(0.0026593024187144963,0.005663677685852356,0.00979494857841503),vec3(0.0024740180160610133,0.0052745508615947585,0.009141755140060302),vec3(0.0023001569555331914,0.004908806940460417,0.00852563336220343),vec3(0.0021371241332640567,0.0045652949750816605,0.007944999489623995));\n    float s_i[3] = float[](0.2424503566193514,0.10170785486914974,0.03723335168874466);\n    float g_x[151] = float[](-0.012893115592183313,-0.013698670060406285,-0.01454270853033401,-0.015426186340698034,-0.01635001813564313,-0.01731507233271321,-0.018322165451038992,-0.01937205631983224,-0.020465440189183726,-0.021602942767020888,-0.022785114207886127,-0.024012423080935617,-0.025285250346210764,-0.02660388336978562,-0.02796851000982456,-0.029379212806879423,-0.030835963312895207,-0.03233861659436575,-0.03388690594586321,-0.03548043785074925,-0.03711868722624115,-0.03880099299014412,-0.04052655398645646,-0.0422944253066969,-0.04410351504318662,-0.04595258150963188,-0.047840230963193016,-0.0497649158607877,-0.0517249336806611,-0.05371842633826146,-0.05574338022319264,-0.057797626881478534,-0.059878844364578875,-0.06198455926355096,-0.06411214944346842,-0.06625884748970856,-0.068421744874013,-0.07059779684434063,-0.07278382803848439,-0.07497653881724314,-0.07717251230864798,-0.0793682221503752,-0.08156004091305374,-0.08374424918274104,-0.0859170452764106,-0.08807455555991833,-0.09021284533361659,-0.09232793024659676,-0.0944157881965094,-0.09647237166805361,-0.09849362045958987,-0.10047547474393566,-0.10241388840629213,-0.10430484259943712,-0.10614435945385038,-0.10792851587831802,-0.109653457384833,-0.11131541187027436,-0.11291070328643685,-0.11443576512950307,-0.11588715368001017,-0.1172615609247814,-0.11855582709315698,-0.11976695274118251,-0.12089211031918369,-0.12192865516037081,-0.12287413583076501,-0.12372630378379504,-0.12448312226638165,-0.12514277442715682,-0.1257036705816586,-0.12616445459385237,-0.126524009338131,-0.12678146121101333,-0.12693618366704282,-0.1269877997588608,-0.12693618366704285,-0.12678146121101333,-0.12652400933813102,-0.12616445459385237,-0.12570367058165863,-0.12514277442715685,-0.12448312226638174,-0.12372630378379511,-0.12287413583076504,-0.12192865516037085,-0.1208921103191837,-0.11976695274118256,-0.11855582709315705,-0.11726156092478153,-0.11588715368001025,-0.11443576512950313,-0.1129107032864369,-0.11131541187027441,-0.10965345738483308,-0.10792851587831806,-0.10614435945385046,-0.10430484259943716,-0.10241388840629222,-0.1004754747439357,-0.09849362045958993,-0.09647237166805367,-0.09441578819650946,-0.09232793024659687,-0.09021284533361669,-0.08807455555991844,-0.08591704527641067,-0.08374424918274113,-0.08156004091305383,-0.07936822215037528,-0.07717251230864812,-0.07497653881724321,-0.07278382803848449,-0.07059779684434074,-0.06842174487401309,-0.06625884748970862,-0.06411214944346849,-0.06198455926355104,-0.05987884436457899,-0.057797626881478596,-0.05574338022319272,-0.05371842633826156,-0.05172493368066117,-0.04976491586078776,-0.047840230963193085,-0.04595258150963194,-0.04410351504318669,-0.04229442530669699,-0.040526553986456555,-0.03880099299014417,-0.0371186872262412,-0.03548043785074932,-0.033886905945863265,-0.03233861659436582,-0.03083596331289527,-0.029379212806879485,-0.02796851000982462,-0.026603883369785666,-0.02528525034621083,-0.02401242308093568,-0.022785114207886165,-0.02160294276702093,-0.020465440189183767,-0.019372056319832277,-0.018322165451039044,-0.017315072332713243,-0.016350018135643175,-0.015426186340698074,-0.014542708530334052,-0.013698670060406317,-0.012893115592183577);\n\n    \n    #define RANGE 75\n    \n    vec2 P1 = vec2(0);\n    vec2 P2 = vec2(0);\n    vec2 P3 = vec2(0);\n    float G = 0.0;\n    float Gw = 0.0;\n    for (int i = -RANGE; i <= RANGE; i++) {\n        int index = RANGE + i;\n\n        vec2 t = Po(i,0).xy;\n        float g = Go(i,0);\n        \n        vec3 py = p_y[index];\n        vec3 px = p_x[index];\n        \n        P1 += vec2(px.x, py.x) * t;\n        P2 += vec2(px.y, py.y) * t;\n        P3 += vec2(px.z, py.z) * t;\n        \n        Gw += abs(g_x[index]);\n        G  += abs(g_x[index]) * g;\n    }\n    \n    G /= Gw;\n    \n    if(reset()) {\n        fragColor = vec4(0);\n    } else {\n        fragColor = vec4(pack2x16(P1),pack2x16(P2),pack2x16(P3), G);\n    }\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "bool reset() {\n    return iFrame <= 1 || texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvec4 Po(int m, int n) {\n    vec2 ouv = uv + texel * vec2(m,n);\n    if (BoundsCheck(ouv)) {\n        return vec4(pack2x16(vec2(0)),pack2x16(vec2(0)),pack2x16(vec2(0)),0);\n    } else {\n        return textureLod(iChannel0, ouv, 0.);\n    }\n}\n\nfloat Go(int m, int n) {\n    vec2 ouv = uv + texel * vec2(m,n);\n    if (BoundsCheck(ouv)) {\n        return 0.0;\n    } else {\n        return textureLod(iChannel1, ouv, 0.0).x;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initialize(fragCoord, iFrame, iResolution);\n    \n    \n    vec3 p_y[151] = vec3[](vec3(-0.00039936512386562484,-0.0013037830496811509,-0.003024369266497462),vec3(-0.00043479272952107184,-0.001418247837094988,-0.0032841431420175815),vec3(-0.00047311175208775147,-0.0015418984185112672,-0.0035640171624620187),vec3(-0.0005145378703601011,-0.0016753999013442086,-0.003865351345832546),vec3(-0.0005593015430286112,-0.00181946044562425,-0.004189581775882141),vec3(-0.0006076489826017296,-0.001974833797626846,-0.004538223620654535),vec3(-0.0006598431999115183,-0.002142321974855929,-0.004912874168389093),vec3(-0.0007161651258619417,-0.0023227781140663494,-0.005315215867981123),vec3(-0.0007769148178819725,-0.0025171094952469407,-0.00574701935895483),vec3(-0.0008424127594587307,-0.002726280755872174,-0.0062101464732849465),vec3(-0.0009130012621639432,-0.002951317311279131,-0.006706553188329675),vec3(-0.0009890459807688295,-0.003193308998756704,-0.007238292506523368),vec3(-0.0010709375533892544,-0.0034534139648667857,-0.007807517233220254),vec3(-0.001159093380140449,-0.003732862817675909,-0.008416482619054973),vec3(-0.0012539595555377625,-0.004032963067987648,-0.009067548827244675),vec3(-0.0013560129718921017,-0.004355103886359663,-0.009763183179221676),vec3(-0.0014657636132559054,-0.004700761205697934,-0.010505962123640127),vec3(-0.0015837570621268875,-0.0050715032025820585,-0.011298572863887848),vec3(-0.001710577244168271,-0.005468996194229675,-0.01214381456744096),vec3(-0.0018468494397243054,-0.005895010992201898,-0.01304459906634993),vec3(-0.0019932435949786592,-0.006351429758636426,-0.014003950941382284),vec3(-0.0021504779703164487,-0.006840253416027218,-0.015025006862317022),vec3(-0.0023193231689242525,-0.007363609667412167,-0.016111014032915174),vec3(-0.002500606595033479,-0.007923761690353888,-0.017265327560358507),vec3(-0.002695217398648073,-0.008523117575376556,-0.018491406534454295),vec3(-0.002904111972299025,-0.009164240587639544,-0.019792808560418648),vec3(-0.0031283200755794476,-0.00984986033967067,-0.021173182439071275),vec3(-0.003368951675232755,-0.01058288497304438,-0.022636258627945997),vec3(-0.0036272046027564153,-0.01136641445806573,-0.02418583704385647),vec3(-0.0039043731482907218,-0.012203755132905171,-0.025825771679025524),vec3(-0.004201857729535902,-0.013098435617310009,-0.027559951395473018),vec3(-0.00452117579826187,-0.01405422425106731,-0.029392276131583135),vec3(-0.00486397417548751,-0.015075148223856253,-0.0313266275951637),vec3(-0.005232043040666073,-0.016165514581003473,-0.03336683332200887),vec3(-0.00562733184154224,-0.017329933308865297,-0.03551662273933928),vec3(-0.0060519674414129645,-0.018573342723915864,-0.037779573578614306),vec3(-0.006508274881439065,-0.01990103741075051,-0.040159046618245986),vec3(-0.006998801210110017,-0.021318698975493443,-0.0426581062860751),vec3(-0.007526342923405148,-0.022832429901508428,-0.04527942409155754),vec3(-0.008093977672062791,-0.024448790812264518,-0.048025161159515134),vec3(-0.008705101032420682,-0.026174841459272888,-0.05089682526368315),vec3(-0.009363469312043276,-0.028018185757524506,-0.05389509666073895),vec3(-0.010073249580677117,-0.029987021181332632,-0.05701961564096375),vec3(-0.01083907839404583,-0.03209019280176492,-0.06026872295763385),vec3(-0.011666131030046848,-0.03433725218081176,-0.0636391420650306),vec3(-0.012560203507485332,-0.03673852121908325,-0.06712558924087116),vec3(-0.013527810238371974,-0.03930516085637037,-0.07072029400179898),vec3(-0.014576300919535715,-0.04204924420785956,-0.07441240748450588),vec3(-0.015714001257992345,-0.04498383322316428,-0.07818727031588318),vec3(-0.016950383431117873,-0.04812305719009568,-0.08202550346745388),vec3(-0.018296273925712297,-0.051482190232598785,-0.08590187504816119),vec3(-0.01976410874874513,-0.05507772316147769,-0.0897838820674849),vec3(-0.02136824920173702,-0.05892742230067349,-0.09362996770370406),vec3(-0.02312537581916243,-0.06305036371943105,-0.09738726988920325),vec3(-0.025054984222680283,-0.06746692484105196,-0.10098876378585503),vec3(-0.02718001534382911,-0.07219870536957633,-0.10434961578501721),vec3(-0.02952766495752478,-0.07726833375162516,-0.10736250560624028),vec3(-0.03213043568796663,-0.08269909044537457,-0.10989158977713533),vec3(-0.03502752169832732,-0.08851423913888098,-0.11176466592987913),vec3(-0.03826665722222464,-0.09473589144745072,-0.11276294193733785),vec3(-0.041906623421512364,-0.10138312131867837,-0.11260760327593745),vec3(-0.04602070835716154,-0.10846885934496983,-0.11094209169468648),vec3(-0.050701578024441495,-0.1159947726771164,-0.10730865033138975),vec3(-0.05606828993205902,-0.12394275393722222,-0.10111727591157052),vec3(-0.06227665518595623,-0.13226056303078285,-0.09160486258770702),vec3(-0.06953501099043398,-0.14083708737623918,-0.077782417479591),vec3(-0.07812908130749861,-0.149458503599576,-0.058369977232929894),vec3(-0.08846282054472075,-0.15772775580732623,-0.031725854990398726),vec3(-0.10112895949827036,-0.1649097516191365,0.004199908847829801),vec3(-0.11703860203562352,-0.16961595360355963,0.05178318985988212),vec3(-0.13767855574664672,-0.16911182932471974,0.11316073490042394),vec3(-0.16567645398825667,-0.15763971441508162,0.18793345990415217),vec3(-0.2062192509611813,-0.12179330842214287,0.2642830614724927),vec3(-0.2713074094027817,-0.02537420724641723,0.28182569573805677),vec3(-0.395760620255607,0.2520387049261719,-0.04827629938430805),vec3(-0.4794057541719356,0.45941736433304614,-0.35998402950121244),vec3(-0.39576062025560704,0.25203870492617186,-0.04827629938430784),vec3(-0.27130740940278164,-0.02537420724641726,0.2818256957380568),vec3(-0.20621925096118135,-0.12179330842214289,0.2642830614724926),vec3(-0.16567645398825667,-0.15763971441508165,0.18793345990415228),vec3(-0.13767855574664675,-0.1691118293247198,0.1131607349004239),vec3(-0.11703860203562354,-0.1696159536035597,0.05178318985988209),vec3(-0.10112895949827036,-0.1649097516191365,0.004199908847829665),vec3(-0.0884628205447208,-0.1577277558073263,-0.03172585499039877),vec3(-0.07812908130749864,-0.14945850359957605,-0.05836997723292993),vec3(-0.06953501099043398,-0.14083708737623918,-0.07778241747959105),vec3(-0.06227665518595623,-0.13226056303078287,-0.09160486258770703),vec3(-0.05606828993205902,-0.12394275393722226,-0.10111727591157058),vec3(-0.050701578024441495,-0.11599477267711644,-0.10730865033138978),vec3(-0.04602070835716156,-0.10846885934496989,-0.1109420916946865),vec3(-0.04190662342151239,-0.10138312131867841,-0.11260760327593748),vec3(-0.03826665722222467,-0.09473589144745076,-0.11276294193733784),vec3(-0.03502752169832737,-0.08851423913888105,-0.1117646659298792),vec3(-0.032130435687966606,-0.0826990904453746,-0.10989158977713538),vec3(-0.029527664957524794,-0.0772683337516252,-0.10736250560624033),vec3(-0.027180015343829116,-0.07219870536957636,-0.1043496157850173),vec3(-0.025054984222680304,-0.06746692484105203,-0.10098876378585511),vec3(-0.023125375819162436,-0.06305036371943108,-0.09738726988920338),vec3(-0.02136824920173702,-0.058927422300673514,-0.09362996770370416),vec3(-0.019764108748745155,-0.05507772316147772,-0.08978388206748496),vec3(-0.01829627392571232,-0.05148219023259884,-0.08590187504816127),vec3(-0.01695038343111789,-0.04812305719009571,-0.08202550346745398),vec3(-0.015714001257992355,-0.0449838332231643,-0.07818727031588321),vec3(-0.014576300919535724,-0.04204924420785958,-0.07441240748450599),vec3(-0.013527810238371971,-0.039305160856370404,-0.07072029400179902),vec3(-0.012560203507485332,-0.036738521219083255,-0.06712558924087117),vec3(-0.011666131030046859,-0.03433725218081179,-0.0636391420650307),vec3(-0.01083907839404584,-0.03209019280176495,-0.06026872295763393),vec3(-0.010073249580677119,-0.029987021181332653,-0.05701961564096378),vec3(-0.009363469312043281,-0.02801818575752456,-0.05389509666073898),vec3(-0.008705101032420694,-0.026174841459272933,-0.0508968252636832),vec3(-0.008093977672062803,-0.024448790812264518,-0.04802516115951517),vec3(-0.007526342923405146,-0.02283242990150845,-0.04527942409155761),vec3(-0.006998801210110013,-0.021318698975493443,-0.04265810628607512),vec3(-0.006508274881439066,-0.01990103741075051,-0.040159046618246),vec3(-0.00605196744141298,-0.018573342723915892,-0.03777957357861436),vec3(-0.005627331841542247,-0.017329933308865328,-0.03551662273933936),vec3(-0.005232043040666078,-0.016165514581003487,-0.033366833322008904),vec3(-0.004863974175487524,-0.015075148223856267,-0.031326627595163734),vec3(-0.004521175798261876,-0.01405422425106733,-0.029392276131583166),vec3(-0.004201857729535902,-0.013098435617310021,-0.027559951395473042),vec3(-0.0039043731482907213,-0.012203755132905178,-0.025825771679025535),vec3(-0.003627204602756424,-0.01136641445806575,-0.024185837043856497),vec3(-0.003368951675232753,-0.010582884973044387,-0.022636258627946024),vec3(-0.0031283200755794494,-0.009849860339670675,-0.021173182439071295),vec3(-0.002904111972299031,-0.009164240587639563,-0.019792808560418675),vec3(-0.002695217398648074,-0.00852311757537658,-0.01849140653445433),vec3(-0.002500606595033485,-0.007923761690353899,-0.017265327560358527),vec3(-0.0023193231689242495,-0.007363609667412189,-0.016111014032915188),vec3(-0.002150477970316447,-0.006840253416027219,-0.01502500686231705),vec3(-0.001993243594978657,-0.006351429758636433,-0.014003950941382294),vec3(-0.0018468494397243095,-0.005895010992201904,-0.013044599066349954),vec3(-0.0017105772441682716,-0.005468996194229684,-0.012143814567440982),vec3(-0.0015837570621268916,-0.0050715032025820655,-0.011298572863887869),vec3(-0.0014657636132559086,-0.004700761205697936,-0.010505962123640147),vec3(-0.0013560129718921034,-0.004355103886359678,-0.009763183179221696),vec3(-0.0012539595555377642,-0.004032963067987664,-0.009067548827244698),vec3(-0.0011590933801404499,-0.003732862817675913,-0.00841648261905499),vec3(-0.0010709375533892564,-0.003453413964866797,-0.007807517233220275),vec3(-0.0009890459807688297,-0.0031933089987567142,-0.007238292506523384),vec3(-0.0009130012621639455,-0.002951317311279133,-0.006706553188329679),vec3(-0.0008424127594587336,-0.002726280755872182,-0.006210146473284956),vec3(-0.0007769148178819765,-0.002517109495246948,-0.005747019358954837),vec3(-0.0007161651258619422,-0.002322778114066351,-0.005315215867981134),vec3(-0.0006598431999115193,-0.0021423219748559342,-0.004912874168389099),vec3(-0.0006076489826017314,-0.0019748337976268505,-0.004538223620654547),vec3(-0.0005593015430286124,-0.001819460445624252,-0.004189581775882171),vec3(-0.0005145378703601023,-0.001675399901344218,-0.00386535134583253),vec3(-0.00047311175208774605,-0.001541898418511293,-0.003564017162461541),vec3(-0.0004347927295209686,-0.0014182478370946185,-0.003284143142016918),vec3(-0.0003993651238658139,-0.0013037830496811053,-0.003024369266498018));\n    vec3 p_x[151] = vec3[](vec3(-0.002137124133264062,-0.0045652949750816674,-0.007944999489624014),vec3(-0.002300156955533428,-0.004908806940460253,-0.008525633362203022),vec3(-0.0024740180160609526,-0.0052745508615946735,-0.009141755140060714),vec3(-0.0026593024187144994,-0.005663677685852353,-0.009794948578414675),vec3(-0.0028566298846672803,-0.006077377342767512,-0.010486819494099436),vec3(-0.0030666454073479945,-0.006516878738501725,-0.011218991293007716),vec3(-0.0032900199322388997,-0.0069834496606139915,-0.011993099926857181),vec3(-0.0035274510673012965,-0.007478396589859675,-0.012810788233390612),vec3(-0.0037796638307912127,-0.008003064415882877,-0.013673699609992897),vec3(-0.004047411444335345,-0.008558836053786144,-0.014583470965923965),vec3(-0.004331476180377802,-0.009147131958638085,-0.015541724892891462),vec3(-0.00463267027449884,-0.009769409534995865,-0.01655006098737826),vec3(-0.004951836914666999,-0.010427162438453347,-0.017610046250856503),vec3(-0.005289851321237063,-0.011121919766049194,-0.018723204485601174),vec3(-0.005647621933474761,-0.011855245132051603,-0.019891004594067244),vec3(-0.006026091720604429,-0.012628735625135244,-0.02111484767848965),vec3(-0.0064262396378738365,-0.013444020642236373,-0.02239605282424208),vec3(-0.006849082250952507,-0.014302760593353525,-0.02373584143523893),vec3(-0.007295675555175712,-0.015206645470184573,-0.025135319971921),vec3(-0.0077671170197740995,-0.01615739326966947,-0.026595460921701564),vec3(-0.008264547891358274,-0.01715674826113821,-0.02811708180766433),vec3(-0.008789155795641856,-0.0182064790827157,-0.02970082201319753),vec3(-0.009342177681784285,-0.019308376648754934,-0.031347117167421494),vec3(-0.00992490315993552,-0.02046425184516241,-0.03305617079787943),vec3(-0.010538678289711445,-0.021675932983309377,-0.03482792291202483),vec3(-0.011184909885595262,-0.022945262975493885,-0.036662015116369455),vec3(-0.011865070414853763,-0.024274096185269295,-0.03855775182034264),vec3(-0.01258070357473496,-0.025664294893927936,-0.040514056999271006),vec3(-0.013333430648782561,-0.02711772530945963,-0.042529425905391674),vec3(-0.01412495775744369,-0.028636253025678345,-0.04460187101503015),vec3(-0.014957084136223639,-0.030221737816030457,-0.04672886138108205),vec3(-0.01583171159602881,-0.031876027617728446,-0.04890725441919534),vec3(-0.016750855345744924,-0.03360095152585251,-0.051133218989284704),vec3(-0.01771665638740403,-0.03539831157208638,-0.0534021484360339),vec3(-0.018731395730599044,-0.03726987300644707,-0.055708562016558806),vec3(-0.019797510716488533,-0.0392173527296855,-0.05804599286274144),vec3(-0.020917613794531456,-0.04124240543505191,-0.06040686029055546),vec3(-0.02209451415920214,-0.043346606905710634,-0.06278232386756345),vec3(-0.023331242732158364,-0.045531433771570005,-0.06516211616871623),vec3(-0.024631081071251157,-0.04779823884785927,-0.06753435057251908),vec3(-0.02599759490599191,-0.05014822094579368,-0.06988529975365311),vec3(-0.02743467314560627,-0.05258238774762672,-0.07219913968862342),vec3(-0.028946573388404322,-0.05510150995351754,-0.07445765297670581),vec3(-0.03053797519013025,-0.05770606440794075,-0.07663988405127538),vec3(-0.03221404263776634,-0.0603961632607468,-0.07872173737035694),vec3(-0.033980498142029227,-0.06317146536031418,-0.08067550787447306),vec3(-0.035843709830794705,-0.06603106494154067,-0.08246933081865009),vec3(-0.03781079552984435,-0.0689733511594637,-0.08406653544718634),vec3(-0.03988974710170204,-0.07199582998922682,-0.08542488379813157),vec3(-0.042089579940160424,-0.07509489726503166,-0.08649567210767374),vec3(-0.044420513774308154,-0.0782655478780229,-0.0872226677458533),vec3(-0.046894192744119025,-0.0815010009801992,-0.08754084929384119),vec3(-0.04952395514522684,-0.08479221383871625,-0.08737491127852688),vec3(-0.052325166556904924,-0.08812724684632407,-0.0866374883735367),vec3(-0.05531563463635159,-0.09149042775415551,-0.08522704702612285),vec3(-0.05851613023760088,-0.09486124236558141,-0.0830253865465934),vec3(-0.06195104853165206,-0.09821284847174405,-0.0798946889222969),vec3(-0.06564925675340012,-0.10151006459451122,-0.07567406140614437),vec3(-0.06964519409927278,-0.1047066168725813,-0.07017553687965904),vec3(-0.07398031737724835,-0.10774132259935602,-0.06317955075217202),vec3(-0.0787050285543731,-0.11053272464789683,-0.054430032064937746),vec3(-0.08388128622421473,-0.11297142788834234,-0.0436294939520135),vec3(-0.08958620751898465,-0.1149089568361548,-0.03043501110604133),vec3(-0.09591713730219445,-0.11614122538666281,-0.014456986894158296),vec3(-0.10299894760598283,-0.11638344275691273,0.004735321117216877),vec3(-0.11099482783905858,-0.11523099884933204,0.027593267367261202),vec3(-0.12012272629777299,-0.1120965987947297,0.054535916053032214),vec3(-0.13068130718798532,-0.10610553463683693,0.08582732348023998),vec3(-0.1430926878027598,-0.09591364237278834,0.12130023611322262),vec3(-0.15797644463814361,-0.07937430036055836,0.15972950012046713),vec3(-0.17628590900450966,-0.05289019694443883,0.1973636686263485),vec3(-0.19957914170178254,-0.010050447660950014,0.22428672225770246),vec3(-0.23061230582092926,0.06152568473621712,0.21465485784075855),vec3(-0.2748091985304043,0.18844826204726473,0.09754352781288295),vec3(-0.3445128239871801,0.4367329316543684,-0.34280145660982947),vec3(3.01878863857207e-17,2.1657391732312188e-17,2.1073950360688117e-17),vec3(0.3445128239871802,-0.4367329316543684,0.3428014566098292),vec3(0.27480919853040436,-0.18844826204726473,-0.09754352781288317),vec3(0.23061230582092923,-0.061525684736217036,-0.21465485784075863),vec3(0.19957914170178256,0.01005044766095007,-0.2242867222577026),vec3(0.17628590900450966,0.0528901969444389,-0.19736366862634852),vec3(0.15797644463814361,0.07937430036055836,-0.15972950012046708),vec3(0.14309268780275983,0.09591364237278836,-0.1213002361132226),vec3(0.13068130718798535,0.10610553463683695,-0.08582732348023968),vec3(0.12012272629777299,0.11209659879472973,-0.054535916053032235),vec3(0.11099482783905856,0.11523099884933206,-0.027593267367261167),vec3(0.10299894760598281,0.11638344275691272,-0.004735321117216822),vec3(0.09591713730219444,0.11614122538666284,0.014456986894158358),vec3(0.08958620751898468,0.11490895683615483,0.03043501110604141),vec3(0.08388128622421473,0.11297142788834233,0.04362949395201367),vec3(0.0787050285543731,0.11053272464789683,0.054430032064937794),vec3(0.07398031737724835,0.10774132259935604,0.06317955075217199),vec3(0.06964519409927278,0.10470661687258127,0.07017553687965912),vec3(0.06564925675340012,0.10151006459451126,0.07567406140614436),vec3(0.06195104853165206,0.09821284847174405,0.0798946889222969),vec3(0.05851613023760088,0.09486124236558141,0.08302538654659344),vec3(0.05531563463635159,0.09149042775415551,0.08522704702612297),vec3(0.05232516655690491,0.08812724684632407,0.08663748837353664),vec3(0.04952395514522684,0.08479221383871625,0.08737491127852687),vec3(0.046894192744119025,0.08150100098019919,0.0875408492938412),vec3(0.044420513774308154,0.0782655478780229,0.0872226677458533),vec3(0.04208957994016041,0.07509489726503163,0.08649567210767378),vec3(0.03988974710170204,0.07199582998922681,0.08542488379813157),vec3(0.037810795529844336,0.0689733511594637,0.08406653544718634),vec3(0.03584370983079468,0.06603106494154064,0.0824693308186501),vec3(0.03398049814202922,0.06317146536031418,0.08067550787447306),vec3(0.03221404263776634,0.0603961632607468,0.07872173737035698),vec3(0.03053797519013025,0.05770606440794075,0.07663988405127538),vec3(0.02894657338840431,0.055101509953517515,0.07445765297670578),vec3(0.02743467314560627,0.05258238774762672,0.07219913968862343),vec3(0.025997594905991905,0.05014822094579368,0.06988529975365308),vec3(0.024631081071251146,0.04779823884785925,0.06753435057251908),vec3(0.02333124273215836,0.04553143377157,0.06516211616871614),vec3(0.022094514159202137,0.04334660690571063,0.06278232386756344),vec3(0.020917613794531453,0.041242405435051886,0.060406860290555434),vec3(0.019797510716488522,0.039217352729685476,0.05804599286274142),vec3(0.01873139573059904,0.03726987300644707,0.05570856201655882),vec3(0.017716656387404026,0.035398311572086366,0.05340214843603387),vec3(0.016750855345744917,0.0336009515258525,0.051133218989284704),vec3(0.015831711596028804,0.03187602761772843,0.04890725441919533),vec3(0.01495708413622363,0.030221737816030454,0.04672886138108203),vec3(0.014124957757443688,0.028636253025678342,0.04460187101503013),vec3(0.013333430648782552,0.02711772530945961,0.04252942590539163),vec3(0.012580703574734953,0.025664294893927922,0.040514056999270985),vec3(0.011865070414853759,0.024274096185269285,0.03855775182034264),vec3(0.011184909885595262,0.022945262975493878,0.036662015116369455),vec3(0.010538678289711445,0.02167593298330937,0.0348279229120248),vec3(0.009924903159935513,0.020464251845162408,0.03305617079787941),vec3(0.00934217768178428,0.019308376648754923,0.03134711716742148),vec3(0.00878915579564185,0.01820647908271569,0.029700822013197525),vec3(0.008264547891358267,0.017156748261138197,0.028117081807664302),vec3(0.007767117019774098,0.016157393269669456,0.026595460921701543),vec3(0.0072956755551757,0.015206645470184556,0.02513531997192098),vec3(0.0068490822509524995,0.014302760593353517,0.023735841435238908),vec3(0.006426239637873832,0.013444020642236359,0.022396052824242063),vec3(0.006026091720604427,0.012628735625135236,0.02111484767848964),vec3(0.0056476219334747595,0.011855245132051592,0.019891004594067244),vec3(0.005289851321237059,0.01112191976604919,0.018723204485601167),vec3(0.0049518369146669934,0.010427162438453336,0.017610046250856482),vec3(0.004632670274498837,0.009769409534995856,0.016550060987378257),vec3(0.004331476180377796,0.009147131958638074,0.015541724892891445),vec3(0.004047411444335342,0.008558836053786137,0.014583470965923953),vec3(0.0037796638307912088,0.008003064415882869,0.013673699609992889),vec3(0.0035274510673012917,0.007478396589859665,0.012810788233390602),vec3(0.003290019932238895,0.006983449660613981,0.011993099926857178),vec3(0.0030666454073479924,0.006516878738501718,0.011218991293007703),vec3(0.002856629884667277,0.006077377342767509,0.01048681949409938),vec3(0.0026593024187144963,0.005663677685852356,0.00979494857841503),vec3(0.0024740180160610133,0.0052745508615947585,0.009141755140060302),vec3(0.0023001569555331914,0.004908806940460417,0.00852563336220343),vec3(0.0021371241332640567,0.0045652949750816605,0.007944999489623995));\n    float s_i[3] = float[](0.2424503566193514,0.10170785486914974,0.03723335168874466);\n    float g_x[151] = float[](-0.012893115592183313,-0.013698670060406285,-0.01454270853033401,-0.015426186340698034,-0.01635001813564313,-0.01731507233271321,-0.018322165451038992,-0.01937205631983224,-0.020465440189183726,-0.021602942767020888,-0.022785114207886127,-0.024012423080935617,-0.025285250346210764,-0.02660388336978562,-0.02796851000982456,-0.029379212806879423,-0.030835963312895207,-0.03233861659436575,-0.03388690594586321,-0.03548043785074925,-0.03711868722624115,-0.03880099299014412,-0.04052655398645646,-0.0422944253066969,-0.04410351504318662,-0.04595258150963188,-0.047840230963193016,-0.0497649158607877,-0.0517249336806611,-0.05371842633826146,-0.05574338022319264,-0.057797626881478534,-0.059878844364578875,-0.06198455926355096,-0.06411214944346842,-0.06625884748970856,-0.068421744874013,-0.07059779684434063,-0.07278382803848439,-0.07497653881724314,-0.07717251230864798,-0.0793682221503752,-0.08156004091305374,-0.08374424918274104,-0.0859170452764106,-0.08807455555991833,-0.09021284533361659,-0.09232793024659676,-0.0944157881965094,-0.09647237166805361,-0.09849362045958987,-0.10047547474393566,-0.10241388840629213,-0.10430484259943712,-0.10614435945385038,-0.10792851587831802,-0.109653457384833,-0.11131541187027436,-0.11291070328643685,-0.11443576512950307,-0.11588715368001017,-0.1172615609247814,-0.11855582709315698,-0.11976695274118251,-0.12089211031918369,-0.12192865516037081,-0.12287413583076501,-0.12372630378379504,-0.12448312226638165,-0.12514277442715682,-0.1257036705816586,-0.12616445459385237,-0.126524009338131,-0.12678146121101333,-0.12693618366704282,-0.1269877997588608,-0.12693618366704285,-0.12678146121101333,-0.12652400933813102,-0.12616445459385237,-0.12570367058165863,-0.12514277442715685,-0.12448312226638174,-0.12372630378379511,-0.12287413583076504,-0.12192865516037085,-0.1208921103191837,-0.11976695274118256,-0.11855582709315705,-0.11726156092478153,-0.11588715368001025,-0.11443576512950313,-0.1129107032864369,-0.11131541187027441,-0.10965345738483308,-0.10792851587831806,-0.10614435945385046,-0.10430484259943716,-0.10241388840629222,-0.1004754747439357,-0.09849362045958993,-0.09647237166805367,-0.09441578819650946,-0.09232793024659687,-0.09021284533361669,-0.08807455555991844,-0.08591704527641067,-0.08374424918274113,-0.08156004091305383,-0.07936822215037528,-0.07717251230864812,-0.07497653881724321,-0.07278382803848449,-0.07059779684434074,-0.06842174487401309,-0.06625884748970862,-0.06411214944346849,-0.06198455926355104,-0.05987884436457899,-0.057797626881478596,-0.05574338022319272,-0.05371842633826156,-0.05172493368066117,-0.04976491586078776,-0.047840230963193085,-0.04595258150963194,-0.04410351504318669,-0.04229442530669699,-0.040526553986456555,-0.03880099299014417,-0.0371186872262412,-0.03548043785074932,-0.033886905945863265,-0.03233861659436582,-0.03083596331289527,-0.029379212806879485,-0.02796851000982462,-0.026603883369785666,-0.02528525034621083,-0.02401242308093568,-0.022785114207886165,-0.02160294276702093,-0.020465440189183767,-0.019372056319832277,-0.018322165451039044,-0.017315072332713243,-0.016350018135643175,-0.015426186340698074,-0.014542708530334052,-0.013698670060406317,-0.012893115592183577);\n\n\n    #define RANGE 75\n    \n    vec2 P = vec2(0);\n    float G = 0.0;\n    float Gw = 0.0;\n    for (int i = -RANGE; i <= RANGE; i++) {\n        int index = RANGE + i;\n        \n        vec4 tx = Po(0,i);\n        vec2 t1 = unpack2x16(tx.x);\n        vec2 t2 = unpack2x16(tx.y);\n        vec2 t3 = unpack2x16(tx.z);\n\n        float g = tx.w;\n        \n        vec3 py = p_y[index];\n        vec3 px = p_x[index];\n        \n        P += s_i[0] * vec2(px.x, py.x).yx * t1;\n        P += s_i[1] * vec2(px.y, py.y).yx * t2;\n        P += s_i[2] * vec2(px.z, py.z).yx * t3;\n        Gw += abs(g_x[index]);\n        G  += abs(g_x[index]) * g;\n    }\n    \n    G /= Gw;\n\n    if(reset()) {\n        fragColor = vec4(0);\n    } else {\n        vec2 com_n;\n        if (FRAME_MOD(0)) {\n            com_n = com(fragCoord, iChannel2, iChannel1);\n        } else {\n            com_n = textureLod(iChannel1, uv, 0.0).zw;\n        }\n        fragColor = vec4(vec2((P.x + P.y) + G),com_n);\n    }\n\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "bool reset() {\n    return iFrame <= 1 || texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    initialize(p, iFrame, iResolution);\n    Vec4Neighborhood pn = GetVec4Neighborhood(iChannel0);\n    vec4 U = texelFetch(iChannel1, ivec2(p), 0);\n    vec2 dp = Delta(pn, 0);\n    c = U + vec4(dp,0,0)/2.0;\n    \n    if (reset()) {\n        c = vec4(0,0,INIT_MASS,0);\n    }\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcSzr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [], "test": "untested"}
{"id": "sl3SRn", "name": "Intersection rays/segments", "author": "Yusef28", "description": "I stumbled on way more elegant and shorter easier to remember way to calculate ray-ray or even segment-segment intersections.\nhttps://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect/565282#565282", "tags": ["intersection"], "likes": 12, "viewed": 445, "published": 3, "date": "1638574597", "time_retrieved": "2024-07-30T18:44:16.898826", "image_code": "/////////////////////////////////////////////////////////////\n//                                                         //\n// Author:Yusef28                                          //\n// Start Date: 26-07-2021                                  //\n// Status: On Going                                        //\n// Topic: Line Segment Intersection                        //\n// Sources: http://paulbourke.net/geometry                 //\n// Listening to: Andromida - Hellscape (FULL ALBUM STREAM) //\n//                                                         // \n/////////////////////////////////////////////////////////////\n\n/*\nI found a way method of finding intersections between two\nsegments in a plane. \nby found I mean I found it on stackexchange\n\nhttps://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect/565282#565282\n\nThe previous method I had (in the source of this fork) \nrequires way more calculation and if you want something you\ncan whip out of you back pocket in a pinch that isn't the \nthing you'll want.\n\nThis is way cooler.\n\nyou have teh intersection of two rays expressed as:\n\nro1 + rd1*t = ro2 + rd2*s (where s and t are the distances)\n\nYou can just eliminate one by taking the dot product\nof every vector in this equation by a vector perpendicular\nto one of either rd1 or rd2!\n\nBecause dot(rd1,perp_rd1) will be 0, \nyou eliminate that term including the t!\n\nBeautiful!\n\nWe just need to remember to repeat this for s so we can make\nsure we have a valid intersection (s and t both betwen the \nend ranges of the segments. Or in the case of rays, just >= 0)\n\n*/\n#define line1Col vec3(1.,.2,.5)\n#define line2Col vec3(1.,.3,.3)\n\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5,0.5)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////  BACKGROUND GRID DESIGN             //\n      //                                   //\n      /////////////////////////////////////\n      \n    vec2 st = uv;//save the unscaled uv\n    //I'm only making an 8(*aspect)x8 grid, higher variables\n    //may end up with graphs completely outside it\n    uv*=10.;\n    //graph background\n    vec3 col = vec3(0.1);\n    //center highlights\n    col = mix(col,vec3(0.16),1.0-length(uv/8.));\n    //dust \n    float specks = fract(sin(dot(uv,vec2(123.,16.)))*433413.);\n    \n    //nice soft texture \n    float tex = texture(iChannel0,st).x;\n    col = mix(col,vec3(0.25),pow(tex,2.));\n    \n    //small grid lines\n    vec2 lines = fract(uv*5.);\n    lines = smoothstep(0.45,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.24),lines.x);\n    col = mix(col,vec3(0.24),lines.y);\n    \n    //larger grid lines\n    lines = fract(uv);\n    lines = smoothstep(0.47,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.5),lines.x);\n    col = mix(col,vec3(0.5),lines.y);\n    \n    //axis lines\n    lines = smoothstep(0.0,0.02,abs(uv));\n    col = mix(col,vec3(0.6),1.0-lines.x);\n    col = mix(col,vec3(0.6),1.-lines.y);\n    col = mix(col,vec3(0.1),step(0.1,specks)*0.2);\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////  LINE INTERSECTION CALCULATIONS     //\n      //                                   //\n      /////////////////////////////////////\n      \n    //Line Points\n    vec2 A1 = vec2(-3.4+sin(iTime),-2.4+sin(iTime+0.5));\n    vec2 B1 = vec2(3.4+sin(iTime+4.),3.4+sin(iTime+2.));\n    vec2 ro1 = A1;\n    vec2 rd1 = normalize(B1-A1);\n    float maxLength1 = length(B1-A1);\n    \n    vec2 A2 = vec2(-3.3+sin(iTime+1.4),-3.6+sin(iTime+3.));\n    vec2 B2 = vec2(2.3+sin(iTime+0.2),3.1+sin(iTime+0.3))*10.;\n    vec2 ro2 = A2;\n    vec2 rd2 = normalize(B2-A2);\n    float maxLength2 = length(B2-A2);\n    //we know that teh intersection of two rays is\n    // ro1+rd1*t = ro2+rd2*s\n    // There is a really elegant solution for this\n    // use dot everything by a perpendicualr vector\n    // to rd1 and its unknown will cancel out.\n    vec2 perpRD1 = rd1.yx*vec2(-1.,1.);\n    float s = (dot(ro1,perpRD1) - dot(ro2,perpRD1)) / dot(rd2,perpRD1);\n    \n    //we just need to repeat for the other side to check\n    //validity for both rays\n    \n    vec2 perpRD2 = rd2.yx*vec2(-1.,1.);\n    float t = (dot(ro2,perpRD2) - dot(ro1,perpRD2)) / dot(rd1,perpRD2);\n    \n    //when valid, either s or t will lead to the samer\n    // intersection point\n    \n    vec2 validPoint = ro1 + rd1*t;\n    \n\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////        DRAWING EVERYTHING           //\n      //                                   //\n      /////////////////////////////////////\n    \n        \n    //line 1\n    float f = 1.0-smoothstep(0.02,0.06,abs(distToLine(A1, B1, uv)));\n    col = mix(col, vec3(1.,.2,.5), f);//0.5\n    \n    //line 2\n    f = 1.0-smoothstep(0.02,0.06,abs(distToLine(A2, B2, uv)));\n    col = mix(col, vec3(1.,.3,.3), f);\n    \n    \n    //segment end points line 1\n    f = 1.-smoothstep(0.03,0.08,length(uv-A1)-0.02);\n    col = mix(col, line1Col, f);\n    //segment end points line 1\n    f = 1.-smoothstep(0.03,0.08,length(uv-B1)-0.02);\n    col = mix(col, line1Col, f);\n    \n    //segment end points line 2\n    f = 1.-smoothstep(0.03,0.08,length(uv-A2)-0.02);\n    col = mix(col, line2Col, f);\n    //segment end points line 2\n    f = 1.-smoothstep(0.03,0.08,length(uv-B2)-0.02);\n    col = mix(col, line2Col, f);\n    \n    \n    // if s and t are both between 0. and maxLength they are\n    // valid for both the linear interpolations we need.\n    // so show the intersection point.\n    if(s >= 0. && t >= 0. && t <= maxLength1 && s <= maxLength2){\n    \n    //intersection\n    f = 1.-smoothstep(0.02,0.04,abs(length(uv-validPoint)-0.15));\n    col = mix(col, vec3(1.,0.7,0.), f);\n    f = 1.-smoothstep(0.03,0.08,length(uv-validPoint)-0.015);\n    col = mix(col, vec3(1.,0.7,0.), f);\n    \n   }\n    \n    \n      ////////////////////////////////////////////\n      //                                       //\n////////          POST PROCESSING            //\n      //                                   //\n      /////////////////////////////////////\n        \n     \n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    // Output to screen\n    fragColor = vec4(col*vig,1.0);\n}\n", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3SRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1677, 1677, 1718, 1718, 1920], [1922, 1922, 1979, 2031, 6771]], "test": "untested"}
{"id": "fl3Xzr", "name": "GOT2 - The Landscaping", "author": "Arrangemonk", "description": "game of life as noise generatior for domain transformation?", "tags": ["meh"], "likes": 5, "viewed": 238, "published": 3, "date": "1638570812", "time_retrieved": "2024-07-30T18:44:17.781465", "image_code": "vec3 fbm8(sampler2D tex,in vec2 uv)\n{    \nvec3 result = texture(tex,uv).rgb;\nresult += texture(tex,uv*  2.).rgb /  2.;\nresult += texture(tex,uv*  4.).rgb /  4.;\nresult += texture(tex,uv*  8.).rgb /  8.;\nresult += texture(tex,uv* 16.).rgb / 16.;\nresult += texture(tex,uv* 32.).rgb / 32.;\nresult += texture(tex,uv* 64.).rgb / 64.;\nresult += texture(tex,uv* 128.).rgb / 128.;\nreturn result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * .01;\n    \n      vec3 gol = normalize(fbm8(iChannel0,uv));\n\n      \n\n      //fragColor = vec4(gol,1);\n      //fragColor = texture(iChannel1,gol);\n      fragColor = texture(iChannel1,uv*0.1 + 0.25* gol.z *gol.xy);\n  }", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2  fragCoord )\n{\n    ivec2 uv = ivec2(fragCoord);\n\n    if(iFrame < 10 || texelFetch(iChannel2, ivec2(32,0),0).x > 0.){\n    fragColor = texture(iChannel0,fragCoord / iResolution.xy);\n    }\n    else\n    {\n     fragColor = texelFetch(iChannel1,uv,0);\n     \n     ivec3 diff = ivec3(1,0,-1);\n     \n     vec4 sum =  texelFetch(iChannel1,uv + diff.xx,0);\n          sum += texelFetch(iChannel1,uv + diff.xy,0);\n          sum += texelFetch(iChannel1,uv + diff.xz,0);\n          sum += texelFetch(iChannel1,uv + diff.yx,0);\n          sum += texelFetch(iChannel1,uv + diff.yz,0);\n          sum += texelFetch(iChannel1,uv + diff.zx,0);\n          sum += texelFetch(iChannel1,uv + diff.zy,0);\n          sum += texelFetch(iChannel1,uv + diff.zz,0);\n \n     float amount = .01;\n     float minl = 2.;\n     float maxl = 3.;\n     \n     if(sum.x < minl || maxl < sum.x)\n         fragColor.x =  max(0.,fragColor.x -amount);\n     else\n         fragColor.x = min(1.,fragColor.x + amount);\n\n         \n      if(sum.y <minl || maxl < sum.y)\n         fragColor.y =  max(0.,fragColor.y -amount);\n     else\n         fragColor.y = min(1.,fragColor.y + amount);\n\n         \n     if(sum.z < minl ||  maxl < sum.z)\n         fragColor.z =  max(0.,fragColor.z -amount);\n     else\n         fragColor.z = min(1.,fragColor.z + amount);\n\n\n     \n    }\n    \n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3Xzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 389], [391, 391, 448, 498, 754]], "test": "untested"}
{"id": "ft3Szr", "name": "Game of Distortion", "author": "Arrangemonk", "description": "thats boring, i was expecting more... buuuuut i can still fork and implement proper rules, can be reseted on space now", "tags": ["meh"], "likes": 3, "viewed": 266, "published": 3, "date": "1638569009", "time_retrieved": "2024-07-30T18:44:18.836644", "image_code": "vec3 fbm8(sampler2D tex,in vec2 uv)\n{    \nvec3 result = texture(tex,uv).rgb;\nresult += texture(tex,uv*  2.).rgb /  2.;\nresult += texture(tex,uv*  4.).rgb /  4.;\nresult += texture(tex,uv*  8.).rgb /  8.;\nresult += texture(tex,uv* 16.).rgb / 16.;\nresult += texture(tex,uv* 32.).rgb / 32.;\nresult += texture(tex,uv* 64.).rgb / 64.;\nresult += texture(tex,uv* 128.).rgb / 128.;\nreturn result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * .01;\n    \n      vec3 gol = normalize(fbm8(iChannel0,uv));\n\n\n      //fragColor = vec4(gol,1);\n      fragColor = texture(iChannel1,gol);\n      //fragColor = texture(iChannel1,uv*0.1 + 0.25* gol.z *gol.xy);\n  }", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2  fragCoord )\n{\n    ivec2 uv = ivec2(fragCoord);\n\n    if(iFrame < 10 || texelFetch(iChannel2, ivec2(32,0),0).x > 0.){\n    fragColor = texture(iChannel0,fragCoord / iResolution.xy);\n    }\n    else\n    {\n     fragColor = texelFetch(iChannel1,uv,0);\n     \n     ivec3 diff = ivec3(1,0,-1);\n     \n     vec4 sum =  texelFetch(iChannel1,uv + diff.xx,0);\n          sum += texelFetch(iChannel1,uv + diff.xy,0);\n          sum += texelFetch(iChannel1,uv + diff.xz,0);\n          sum += texelFetch(iChannel1,uv + diff.yx,0);\n          sum += texelFetch(iChannel1,uv + diff.yz,0);\n          sum += texelFetch(iChannel1,uv + diff.zx,0);\n          sum += texelFetch(iChannel1,uv + diff.zy,0);\n          sum += texelFetch(iChannel1,uv + diff.zz,0);\n \n     float amount = .01;\n     float minl = 2.;\n     float maxl = 3.;\n     \n     if(sum.x < minl || maxl < sum.x)\n         fragColor.x =  max(0.,fragColor.x -amount);\n     else\n         fragColor.x = min(1.,fragColor.x + amount);\n\n         \n      if(sum.y <minl || maxl < sum.y)\n         fragColor.y =  max(0.,fragColor.y -amount);\n     else\n         fragColor.y = min(1.,fragColor.y + amount);\n\n         \n     if(sum.z < minl ||  maxl < sum.z)\n         fragColor.z =  max(0.,fragColor.z -amount);\n     else\n         fragColor.z = min(1.,fragColor.z + amount);\n\n\n     \n    }\n    \n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3Szr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 389], [391, 391, 448, 498, 747]], "test": "untested"}
{"id": "Nl3XRr", "name": "Green ball", "author": "makipl", "description": "Random playing", "tags": ["raymarching"], "likes": 1, "viewed": 225, "published": 3, "date": "1638568524", "time_retrieved": "2024-07-30T18:44:19.679391", "image_code": "float ray(in vec3 ro, in vec3 rd)\n{\n//float e=0.0000001;\n//h=0.2-rd.y; //plane\n\nfloat t=0.0;\nfloat h=0.;\nfor(int i=0; i<32; i++)\n{\nh=length(ro+rd*t)-0.70;\nh=max(h, -h+cos((ro+rd*t).y*64.)*+sin((ro+rd*t).x*128.)*sin(iTime));\nif(abs(h)<(0.005))\n{ return t;}\nt+=h;\n}\nreturn 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = (16.0*fragCoord.xy +iResolution.xy)/iResolution.y;\n\n    \n    \n    float col =1.0;\n    \n    \n    //uv.v = 1.0-uv.v;\n    \n    uv = (2.0*fragCoord.xy -iResolution.xy)/iResolution.y;\n    vec3 ta = vec3(0.51,1.00,0.0);\n    vec3 ro = vec3(0.0,0,-1.3);\n    \n    vec3 rd = normalize(vec3(uv,2.));\n    \n    \n    \n    vec3 ot = vec3(0.0);\n    float h = ray(ro,rd);\n    ot=mix(vec3(sin(h)),vec3(cos(h),sin(h),cos(h)),h);\n\n    fragColor = vec4(ot.xyz,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3XRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 78, 277], [279, 279, 336, 336, 793]], "test": "untested"}
{"id": "slVGDd", "name": "Packed Game of Life (WIP)", "author": "incription", "description": "I can't get the random to work properly. Also, it doesn't look like it's using the neighbor pixels to update, can anyone help?\nUse mouse to move around", "tags": ["life", "buffer", "packing", "bits", "gol"], "likes": 4, "viewed": 287, "published": 3, "date": "1638564937", "time_retrieved": "2024-07-30T18:44:20.444346", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    ivec2 iuv = ivec2((iMouse.xy - fragCoord) / 8.0 + iResolution.xy/2.0);\n    \n    vec4 d = texelFetch(iChannel0, iuv, 0);\n    float i = bit(ivec2(fragCoord)%8, d);\n    \n    float col = i * sum(d);\n\n    // Output to screen\n    fragColor = vec4(vec3(1.-5.*col), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 rainbow(float level)\n{\n\t/*\n\t\tTarget colors\n\t\t=============\n\t\t\n\t\tL  x   color\n\t\t0  0.0 vec4(1.0, 0.0, 0.0, 1.0);\n\t\t1  0.2 vec4(1.0, 0.5, 0.0, 1.0);\n\t\t2  0.4 vec4(1.0, 1.0, 0.0, 1.0);\n\t\t3  0.6 vec4(0.0, 0.5, 0.0, 1.0);\n\t\t4  0.8 vec4(0.0, 0.0, 1.0, 1.0);\n\t\t5  1.0 vec4(0.5, 0.0, 0.5, 1.0);\n\t*/\n\t\n\tfloat r = float(level <= 2.0) + float(level > 4.0) * 0.5;\n\tfloat g = max(1.0 - abs(level - 2.0) * 0.5, 0.0);\n\tfloat b = (1.0 - (level - 4.0) * 0.5) * float(level >= 4.0);\n\treturn vec3(r, g, b);\n}\n\nvec3 smoothRainbow (float x)\n{\n    float level1 = floor(x*6.0);\n    float level2 = min(6.0, floor(x*6.0) + 1.0);\n    \n    vec3 a = rainbow(level1);\n    vec3 b = rainbow(level2);\n    \n    return mix(a, b, fract(x*6.0));\n}\n\nfloat bit(ivec2 uv, vec4 d) {\n    float x = 0.;\n    if(uv.y > 3)  x = d.y;\n    else x = d.x;\n    \n    return float((floatBitsToInt(x) >> ((uv.y%4)*8+uv.x)) & 1);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 53758.5453);\n}\n\nfloat randPack(vec2 co) {\n    int result = 0;\n    vec2 seed = co;\n    for(int i=0;i<32;i++) {\n        seed = vec2(rand(seed.yx*124.2));\n        result |= ((1 & int(seed.x<.5)) << i);\n    }\n    return intBitsToFloat(result);\n}\n\nfloat sum(vec4 x) {\n    int bits = floatBitsToInt(x.x);\n    float result = 0.;\n    for(int i=0;i<32;i++)\n    {\n        result += float((bits >> i) & 1);\n    } bits = floatBitsToInt(x.y);\n    for(int i=0;i<32;i++)\n    {\n        result += float((bits >> i) & 1);\n    }\n    return result/64.;\n}", "buffer_a_code": "#define FRAME_SKIP 1\n\nvec2 randxy(vec2 seed) {\n    return vec2(rand(seed), rand(vec2(rand(seed))));\n}\n\nint boop(ivec2 e) { return (e.y%4) * 8 + e.x; }\n\nvec4 life(ivec2 uv) {\n    \n    int k = 0; ivec2 u; int bitsu, bitsd;\n    vec4 me = texelFetch(iChannel0, uv, 0);\n    for(int y=0;y<8;y++) {\n        for(int x=0;x<8;x++) {\n            k = 0;\n            for(int _=0;_<8;_++) {\n            \n            ivec2 pos = ivec2(x, y);\n            u = pos;\n            if(_==0)pos+=ivec2(-1,-1);\n            if(_==1)pos+=ivec2(0,-1);\n            if(_==2)pos+=ivec2(1,-1);\n            if(_==3)pos+=ivec2(-1,0);\n            if(_==4)pos+=ivec2(1,0);\n            if(_==5)pos+=ivec2(-1,1);\n            if(_==6)pos+=ivec2(0,1);\n            if(_==7)pos+=ivec2(1,1);\n            \n            ivec2 quad = ivec2(sign(floor(vec2(pos)/8.)));\n            vec4 d = texelFetch(iChannel0, uv + quad, 0);\n            \n            int up = floatBitsToInt(d.x);\n            int down = floatBitsToInt(d.y);\n\n            pos %= ivec2(8);\n            int data = pos.y > 3 ? down : up;\n            \n            int i = (pos.y%4) * 8 + pos.x;\n            \n            k += (data >> i) & 1;\n            }\n            \n            int e = u.y > 3 ? floatBitsToInt(me.y) : floatBitsToInt(me.x);\n            e = (e >> boop(u%ivec2(8))) & 1;\n            //k = 2;\n            int f = ( ((k==2)&&(e==1)) || (k==3) ) ? 1 : 0;\n            if(y>3) bitsd |= f << ((y%4)*8+x);\n            else    bitsu |= f << ((y%4)*8+x);\n        }\n    }\n    \n    return vec4(intBitsToFloat(bitsu), intBitsToFloat(bitsd), 0, 0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = life(ivec2(fragCoord));\n    if(iFrame%FRAME_SKIP!=0)fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if(iFrame==0)\n    {\n        vec2 seed = (fragCoord/iResolution.xy+iDate.w);\n        fragColor = vec4(randPack(seed), randPack(vec2(rand(seed))), 0, 0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVGDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 417]], "test": "untested"}
{"id": "flcXRn", "name": "RayMarching-FBM", "author": "celns", "description": "RayMarching-FBM", "tags": ["raymarchingfbm"], "likes": 2, "viewed": 242, "published": 3, "date": "1638562445", "time_retrieved": "2024-07-30T18:44:21.210298", "image_code": "\nvec2 Random(vec2 iuv)\n{\n    vec2 point = vec2(dot(iuv,vec2(123.45,678.90)),\n                    dot(iuv,vec2(234.56,345.67)));\n    return -1.0+2.0*fract(sin(point)*45678.7654321);\n}\n\n\n\nfloat PerlinNoise(vec2 uv)\n{\n    vec2 iuv = floor(uv);\n    vec2 cuv = ceil(uv);\n    vec2 fuv = fract(uv);\n    \n    float a = dot(Random(iuv),fuv);\n    float b = dot(Random(iuv + vec2(1.0,0.0)),fuv - vec2(1.0,0.0));\n    float c = dot(Random(iuv + vec2(0.0,1.0)),fuv - vec2(0.0,1.0));\n    float d = dot(Random(cuv),fuv - vec2(1.0,1.0));\n    \n    vec2 interuv = fuv*fuv*(3.0-2.0*fuv);\n    \n    return mix(mix(a,b,interuv.x),mix(c,d,interuv.x),interuv.y) *1.5;\n    \n  \n}\n\nfloat FBM(vec2 uv)\n{\n    float fbm = 0.0;\n    float amp = 0.6;\n    float freq = 0.4;\n    float offset = 1.0;\n    int epoch = 9;\n    \n    for(int i = 0; i < epoch; i++)\n    {\n        fbm += amp * abs(PerlinNoise(uv*freq));\n        fbm = offset - fbm;\n        //fbm = cos(fbm);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    \n    return smoothstep(0.,1.1,fbm);\n}\n\n\n\n\nfloat SDFPlane(vec3 point)\n{\n    float PlaneHeight = -FBM(point.xz)-0.1;\n    return  point.y - PlaneHeight ;\n}\n\n\n\nfloat SDFScene(vec3 point)\n{\n    float distPlane = SDFPlane(point);\n    return distPlane;\n}\n\n\nfloat RayMarching(vec3 eye, vec3 raydirection)\n{\n    float depth = 0.1;\n    int epoch = 15;\n    \n    float MaxDist = 5.;\n    float epsilon = 0.01;\n    \n    for (int i=0; i < epoch; i++)\n    {\n        vec3 point = eye + raydirection * depth;\n        float dist = SDFScene(point);\n \n        depth = depth + dist;\n        if(depth > MaxDist || depth < epsilon)\n            return -1.;  \n    }\n    return depth;\n}\n\n\nvec3 GetNormal(vec3 point)\n{\n    float delta = 0.01;\n    return normalize(vec3(\n                        SDFScene(vec3(point.x + delta, point.y, point.z))\n                        -SDFScene(vec3(point.x - delta, point.y, point.z)),\n                        SDFScene(vec3(point.x, point.y + delta, point.z))\n                        -SDFScene(vec3(point.x, point.y - delta, point.z)),\n                        SDFScene(vec3(point.x, point.y, point.z + delta))\n                        -SDFScene(vec3(point.x, point.y, point.z - delta))\n                    ));\n}\n\n\n\nfloat Shading(vec3 LightPos, vec3 point, vec3 eye)\n{\n\n    vec3 L = normalize(LightPos - point);\n    vec3 V = normalize(eye - point);\n    vec3 N = GetNormal(point);\n    vec3 H = normalize(L+V);\n    //vec3 R = normalize(reflect(-L, N));\n    \n    float Ambient = 0.2;\n\n    float result = dot(H,N);\n    return result+Ambient;\n        \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy) /iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 3.;\n    \n    vec3 eye = vec3(0.0,0.0,-iTime);\n    vec3 raydirection = normalize(vec3(uv.x,uv.y,-1.0));\n    \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(0.0);\n    \n    float depth = RayMarching(eye, raydirection);\n    vec3 point =  eye + raydirection * depth;\n   \n    vec3 LightPos = vec3(1.);\n    float value = 0.0;\n    if(depth == -1.)\n    {\n        value = FBM(vec2(FBM(uv+iTime),0.0));\n        vec3 LightColor = vec3(0.1,0.2,0.3);\n        col = value*LightColor;\n               \n    }\n    else\n    {\n        value = Shading(LightPos, point, eye);\n        vec3 LightColor = vec3(0.7,0.3,0.1);\n        col = value*LightColor;\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcXRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 182], [186, 186, 214, 214, 652], [654, 654, 674, 674, 1018], [1023, 1023, 1051, 1051, 1133], [1137, 1137, 1165, 1165, 1228], [1231, 1231, 1279, 1279, 1640], [1643, 1643, 1671, 1671, 2197], [2201, 2201, 2253, 2253, 2533], [2536, 2536, 2593, 2643, 3521]], "test": "untested"}
{"id": "stV3Wd", "name": "idk what to call this", "author": "SnoopethDuckDuck", "description": "testing a few techniques (please ignore the black line lol)", "tags": ["e"], "likes": 1, "viewed": 242, "published": 3, "date": "1638559129", "time_retrieved": "2024-07-30T18:44:22.032101", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nfloat sinc( float x, float k )\n{\n    float a = pi * (k*x-1.0);\n    return sin(a)/a;\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    float sc = 12.;\n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    \n    float t = (1. / cosh(30. * cos(0.5 * iTime))) *  h21(ipos) + iTime;\n    \n    //uv = fract(2. * uv)-0.5;\n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n    \n    //a = a + 10. * r - iTime + 0.1 * cos(10. * r + 10. * a - iTime);\n    uv = r * vec2(thc(1., a), ths(1., a));\n\n    float p = mix(0.1, 0.5, 0.5 - 0.5 * thc(4., 0.43 * t));\n    float q = pi * (p * uv.x);\n    float h = sin(q) / q;\n    \n    //uv.y += abs(uv.x) - 0.2;\n    \n    float k0 = mix(0.1, 0.2, 0.5 + 0.5 * cos(t));\n    float k = k0 + 0.025 * thc(4., 32. * uv.x + t + 10. * thc(4., t));\n    float f = (0.5 - k) * thc(2., 32. * h + 1.5 * t) - 0.;\n    float s = smoothstep(-k, k, f - uv.y);\n    \n    vec3 col = vec3(s);\n\n    col = s * pal(9. * s + 0.8 * uv.y * thc(12000., 10. * f + t), vec3(1.), vec3(1.), vec3(1.), 0.2 * vec3(0.,0.33,0.66));\n    // Output to screen\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stV3Wd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 191, 191, 232], [234, 234, 261, 261, 302], [304, 304, 336, 336, 389], [391, 391, 459, 459, 502], [504, 504, 524, 524, 599], [601, 601, 625, 625, 665], [667, 667, 724, 724, 1771]], "test": "untested"}
{"id": "7lV3Wd", "name": "HexaGold", "author": "aiekick", "description": "An HexaGold :-,)", "tags": ["hexagon", "hex", "hexa", "gold"], "likes": 61, "viewed": 1234, "published": 3, "date": "1638558995", "time_retrieved": "2024-07-30T18:44:22.841936", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2021 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned with Noodlesplate (https://github.com/aiekick/NoodlesPlate)\n\n// turning table angle offset for the thumbnail at time 0\n#define THUMBNAIL_ANGLE_OFFSET 0.35\n\n// from IQ, https://www.shadertoy.com/view/Xds3zN\n// sdf of heaxagong\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// hexagons repeat placement\n#define ox 1.3\n#define oz 1.5\n\n// hexacone :-,)\n// reduce hexagon size with height\n#define hex_size vec2(0.5 - p.y * 0.1, 10)\n\t\n// common part used by the map and mat functions\n// return the two sdf's\nvoid common_map(vec3 p, out float df0, out float df1)\n{\n    // the horizontal wave\n\tdf0 = p.y - 1.0 + sin(length(p.xz) * 0.8 - iTime);\n\t\n    // first hexagones row\n\tvec3 q0 = p;\n\tq0.x = mod(q0.x - ox, ox + ox) - ox;\n\tq0.z = mod(q0.z - oz * 0.5, oz) - oz * 0.5;\n\tfloat hex0 = sdHexPrism(q0.xzy, hex_size) - 0.2; \n\t\n    // second hexagones row\n\tvec3 q1 = p;\n\tq1.x = mod(q1.x, ox + ox) - ox;\n\tq1.z = mod(q1.z, oz) - oz * 0.5;\n\tfloat hex1 = sdHexPrism(q1.xzy, hex_size) - 0.2; \n\t\n    // the hexagones\n\tdf1 = min(hex0, hex1);\n}\n\n// from IQ\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\n// return the final SDF\nfloat map(vec3 p)\n{\n    float df0, df1;\n    common_map(p, df0, df1);\n    \n    // final df\n    return smax(df0, df1, 0.1);\n    //return max(df0, df1);\n}\n\n// same code as map but with decomposition of the last max()\n// for return the material id\nfloat mat(vec3 p)\n{\n\tfloat df0, df1;\n    common_map(p, df0, df1);\n    \n    // max() decomposition for get df id\n\tif (df0 > df1)\n\t\treturn 1.0;\n\treturn 0.0;\n}\n\n// get normal for the surface point and a precision\nvec3 getNormal(vec3 p, float prec)\n{\n\tvec3 e = vec3(prec, 0, 0);\n\treturn normalize(vec3(\n\t\tmap(p+e)-map(p-e),\n\t\tmap(p+e.yxz)-map(p-e.yxz),\n\t\tmap(p+e.zyx)-map(p-e.zyx)));\n}\n\n// IQ Occ\nfloat getAmbiantOcclusion(vec3 p, vec3 n, float k)\n{\n    const float aoStep = 0.1; \n\tfloat occl = 0.;\n    for(int i = min(iFrame,0); i < 6; ++i)\n    {\n        float diff = float(i)*aoStep;\n        float d = map(p + n*diff);\n        occl += (diff - d) * pow(2., float(-i));\n    }\n    return min(1., 1. - k*occl);\n}\n\n// IQ Shadow\nfloat getShadow(vec3 ro, vec3 rd, float minD, float maxD, float k)\n{\n    float res = 1.0;\n    float d = minD;\n\tfloat s = 0.;\n    for(int i = min(iFrame,0); i < 20; ++i)\n    {\n        s = map(ro + rd * d);\n        if( abs(s)<d*d*1e-5 ) return 0.0;\n        res = min( res, k * s / d );\n\t\td += s;\n        if(d >= maxD) break;\n    }\n    return res;\n}\n\n// get the perpsective camera\nvec3 cam(vec2 uv, vec3 ro, vec3 cv, float fov)\n{\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n  \treturn normalize(z + fov*uv.x*x + fov*uv.y*y);\n}\n\n// from IQ https://www.shadertoy.com/view/MsS3Wc\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 si = iResolution.xy;\n    \n    // central uv\n    vec2 uvc = (2.*fragCoord.xy-si)/si.y;\n    \n    // classice turning table camera\n\tfloat a = iTime * 0.1 + THUMBNAIL_ANGLE_OFFSET;\n\tvec3 ro = vec3(cos(a), 0.0, sin(a)) * 20.0;\n\tro.y = 20.0;\n\tvec3 rd = cam(uvc, ro, vec3(0), 0.4);\n\n    vec3 col = vec3(0.1);\n\n    // log raymarching\n    float s = 1., d = 0., md = 100.;\n\tfor (int i = min(iFrame,0); i < 200; i++)\n\t{\n\t\tif (d*d/s>1e8 || d > 70.) break;\n\t\ts = map(ro + rd * d);\n\t\td += s * 0.5;\n\t}\n\t\n\tif (d < md)\n\t{\n        // surface point\n\t\tvec3 p = ro + rd * d;\n        \n        // surface normal, precision of 0.1 for remove some aliasing\n\t\tvec3 n = getNormal(p, 0.1);\n\t\t\n\t\t// light pos\n\t\tvec3 lp = vec3(0,5,0);\n\t\t\n\t\t// light dir\n\t\tvec3 ld = normalize(lp - p);\n\t\t\t\t\t\t\t\t\n        // diffuse, ambiant occlusion, shadow, specular\n\t\tfloat diff = pow(dot(n, ld) * .5 + .5,2.0);\n\t\tfloat ao = getAmbiantOcclusion(p, n, 40.0);\n\t\tfloat sha = clamp(getShadow(p, ld, 0.01, 150.0, 5.0), 0. ,0.9);\n\t\tfloat spe = pow(max(dot(-rd, reflect(-ld, n)), 0.0), 32.0);\n\t\t\n\t\tif (mat(p) < 0.5) // hexa sides\n        { \n\t\t\t// smooht hsv\n            vec3 base = hsv2rgb_smooth(vec3(atan(p.x,p.z)/3.14159*0.5 - iTime * 0.1, 0.8, 0.8)); \n            \n            // vary base color according to ao\n\t\t\tcol = mix(base, vec3(1), ao) * 0.5;\n\t\t} \n        else // hexa face\n        { \n            // reflected gold\n            col = vec3(1.0, 0.85, 0.0) * texture(iChannel0, reflect(rd, n)).rgb;\t\n        }\n\t\t\n        // final brdf\n\t\tcol += diff * sha * 0.5 + spe;\n        \n        // clamp for avoid overlight\n\t\tcol = clamp(col, 0., 1.);\n\t}\n\t\n    // distance fog\n\tcol *= exp(1.0-d*d*0.001);\n\t\n    // final color\n\tfragColor = vec4(col,1);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lV3Wd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[321, 391, 427, 427, 737], [896, 969, 1024, 1051, 1491], [1493, 1504, 1545, 1545, 1634], [1636, 1636, 1675, 1675, 1704], [1706, 1730, 1749, 1749, 1881], [1883, 1974, 1993, 1993, 2130], [2132, 2184, 2220, 2220, 2355], [2357, 2367, 2419, 2419, 2680], [2682, 2695, 2763, 2763, 3041], [3043, 3073, 3121, 3121, 3299], [3301, 3383, 3417, 3417, 3593], [3595, 3595, 3652, 3652, 5360]], "test": "untested"}
{"id": "ftV3Dd", "name": "RayMarching-Sphere", "author": "celns", "description": "RayMarching-Sphere", "tags": ["raymarching"], "likes": 11, "viewed": 282, "published": 3, "date": "1638555304", "time_retrieved": "2024-07-30T18:44:23.761477", "image_code": "vec3 worldCenter = vec3(0.0);\n\nfloat SDFSphere(vec3 point)\n{\n    float radius = 3.0;\n    return length(point-worldCenter) - radius;\n}\n\nfloat SDFPlane(vec3 point)\n{\n    float PlaneHeight = -3.0;\n    return point.y - PlaneHeight;\n}\n\n\nfloat SDFScene(vec3 point)\n{\n    float distSphere = SDFSphere(point);\n    float distPlane = SDFPlane(point);\n    return min(distSphere, distPlane);\n}\n\n\nfloat RayMarching(vec3 eye, vec3 raydirection)\n{\n    float depth = 0.;\n    int epoch = 100;\n    \n    float MaxDist = 100.;\n    float epsilon = 0.00001;\n    \n    for (int i=0; i < epoch; i++)\n    {\n        vec3 point = eye + raydirection * depth;\n        float dist = SDFScene(point);\n \n        depth = depth + dist;\n        if(depth > MaxDist || depth < epsilon)\n            break;  \n    }\n    return depth;\n}\n\n\nvec3 GetNormal(vec3 point)\n{\n    float delta = 0.00001;\n    return normalize(vec3(\n                        SDFScene(vec3(point.x + delta, point.y, point.z))\n                        -SDFScene(vec3(point.x - delta, point.y, point.z)),\n                        SDFScene(vec3(point.x, point.y + delta, point.z))\n                        -SDFScene(vec3(point.x, point.y - delta, point.z)),\n                        SDFScene(vec3(point.x, point.y, point.z + delta))\n                        -SDFScene(vec3(point.x, point.y, point.z - delta))\n                    ));\n\n}\n\n\n\nfloat FakeSoftShadow(float result, vec3 LightPos,vec3 point,vec3 normal)\n{\n    vec3 shadowOffset = normal * 0.2 ;\n    //float result = 0.2;\n    int epoch = 10;\n    \n    float delta = result/float(epoch);\n    float lightOffset = 0.2;\n    \n    for(int i = 0; i<epoch; i++)\n    {\n        vec3 tmp = LightPos +vec3(0,0,i)*lightOffset;\n        if(RayMarching(point + shadowOffset,normalize(tmp-point)) < length(tmp-point))\n        {\n            result -= delta;\n        }\n    }\n    return result;\n}\n\n\nfloat Shading(vec3 LightPos, vec3 point, vec3 eye)\n{\n\n    vec3 L = normalize(LightPos - point);\n    vec3 V = normalize(eye - point);\n    vec3 N = GetNormal(point);\n    vec3 H = normalize(L+V);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float Ambient = 0.1;\n       \n    float result = max(dot(L,N),0.0)*0.5 + pow(max(dot(H,N),0.0),20.)*0.9;\n    result = FakeSoftShadow(result, LightPos, point,N);\n    return result+Ambient;\n        \n}\n\n\nvec3 Rendering(vec2 uv)\n{\n    vec3 eye = vec3(2.0,0.0,10.0);\n    vec3 raydirection = normalize(vec3(uv.x,uv.y,-1.0));\n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(0.0);\n    \n    float depth = RayMarching(eye, raydirection);\n    //depth /= 10.;\n    vec3 point =  eye + raydirection * depth;\n    \n    vec3 LightPos = vec3(7.*cos(iTime),6.,sin(iTime)+6.);\n    float value = Shading(LightPos, point, eye);\n    vec3 LightColor = vec3(0.6,0.3,0.1);\n    col = value*LightColor;\n    \n    \n    vec3 LightPos2 = vec3(2.*sin(iTime),5.,2.*cos(iTime)+6.);\n    float value2 = Shading(LightPos2, point, eye);\n    vec3 LightColor2 = vec3(0.3,0.6,0.6);\n    col += value2*LightColor2;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy) /iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Output to screen\n    fragColor = vec4(Rendering(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftV3Dd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 60, 60, 133], [135, 135, 163, 163, 229], [232, 232, 260, 260, 381], [384, 384, 432, 432, 793], [796, 796, 824, 824, 1354], [1358, 1358, 1432, 1432, 1851], [1854, 1854, 1906, 1906, 2293], [2296, 2296, 2321, 2321, 3055], [3057, 3057, 3114, 3164, 3341]], "test": "untested"}
{"id": "7tVGDt", "name": "Eye tracker", "author": "Elohiem", "description": "look at pointer", "tags": ["eyes", "eye", "cursor", "eyeball", "follow", "pointer"], "likes": 0, "viewed": 50, "published": 3, "date": "1638550635", "time_retrieved": "2024-07-30T18:44:24.580288", "image_code": "mat3 calcRot(vec3 n1, vec3 n2)\n{\n    vec3 axis = cross(n1,n2);\n    float cosA = dot(n1,n2);\n    float k = 1.0 / (1.0 + cosA);\n\n    mat3 rot = mat3((axis.x*axis.x*k)+cosA, (axis.x*axis.y*k)+axis.z, (axis.x*axis.z*k)-axis.y, (axis.y * axis.x * k) - axis.z, (axis.y * axis.y * k) + cosA, (axis.y * axis.z * k) + axis.x, (axis.z * axis.x * k) + axis.y, (axis.z * axis.y * k) - axis.x, (axis.z * axis.z * k) + cosA);\n    return rot;\n}\n        \nvec2 mapCircle2Square(vec2 uv)\n{\n    float u = uv.x;\n    float v = uv.y;\n    \n    float x = 0.5 * sqrt(2.0+pow(u,2.0) - pow(v,2.0) + 2.0*u*sqrt(2.0)) - 0.5 * sqrt(2.0+pow(u,2.0) - pow(v,2.0) - 2.0*u*sqrt(2.0));\n    float y = 0.5 * sqrt(2.0-pow(u,2.0) + pow(v,2.0) + 2.0*v*sqrt(2.0)) - 0.5 * sqrt(2.0-pow(u,2.0) + pow(v,2.0) - 2.0*v*sqrt(2.0));\n    return vec2(x,y);\n}\n\nmat3 matrixMakeRotation(float xr, float yr, float zr) {\n    float cosA = cos(xr);\n    float cosB = cos(yr);\n    float cosC = cos(zr);\n    float sinA = sin(xr);\n    float sinB = sin(yr);\n    float sinC = sin(zr);\n\n    mat3 matrix = mat3(cosB*cosC, sinA*sinB*cosC+cosA*sinC,-cosA*sinB*cosC+sinA*sinC,-cosB*sinC,-sinA*sinB*sinC+cosA*cosC,cosA*sinB*sinC+sinA*cosC, sinB, -sinA*cosB,cosA*cosB); \n    return matrix;\n}\n\nfloat convertRange(float sourceMin, float sourceMax, float targetMin, float targetMax, float value) {\n    float o = (targetMax-targetMin);\n    o /= (sourceMax-sourceMin);\n    o *= (value-sourceMin);\n    return o +targetMin;\n}\n\n\nvec4 createEye(vec2 uv, vec2 pos, float rad_eye, float rad_iris, float rad_pupil) {\n\n    // bounds eyeball\n\tfloat d1 = length(pos - uv) - rad_eye;\n\tfloat t1 = clamp(-d1, 0.0, 1.0);\n\n    // normal eyeball\n    float sX = (pos - uv).x;\n    float sY = (pos - uv).y;\n    float sZ = -sqrt(abs(pow(rad_eye, 2.0) - pow(sX, 2.0) - pow(sY, 2.0)));\n    vec3 N = normalize(vec3(sX,sY,sZ));\n    \n    // get normal view sphere\n    float rad_sphere = length(iResolution.xy - iResolution.xy*0.5);\n    float sX2 = (iResolution.x*0.5 - iMouse.x);\n    float sY2 = (iResolution.y*0.5 - iMouse.y);\n    if (iMouse.x == 0.0 && iMouse.y == 0.0) { // default condition\n        sX2 = 0.0;\n        sY2 = 0.0;\n    }\n    float sZ2 = -sqrt(abs(pow(rad_sphere,2.0) - pow(sX2, 2.0) - pow(sY2, 2.0)));\n    vec3 N2 = normalize(vec3(sX2, sY2, sZ2) - vec3(iResolution.x*0.5-pos.x, iResolution.y*0.5-pos.y, 0.0));\n    \n    // unrotate iris\n    vec3 dir = vec3(0.0,0.0,1.0);\n    mat3 rotMat = calcRot(dir, N2);\n    vec3 rot = normalize(N * rotMat);\n\n    // check if unrotated normal is within circle\n\tfloat d2 = length(rot.xy * rad_eye) - rad_iris;\n\tfloat t2 = clamp(-d2, 0.0, 1.0) * float(rot.z > 0.0) * t1;\n\n    // do the same for pupil\n\tfloat d3 = length(rot.xy * rad_eye) - rad_pupil;\n\tfloat t3 = clamp(-d3, 0.0, 1.0) * float(rot.z > 0.0) * t1;\n    \n    // light dir opposite of iris\n    vec3 L = -N2;\n\n    // shadow\n    float NdotL = max(dot(N, -L), 0.0);\n    \n    // layer eyeball\n    vec4 layer_eyeball = vec4(vec3(1,0.95,0.95)*NdotL, t1);\n    vec4 layer_iris = vec4(vec3(0.7, 0.7,0.95)*NdotL, t2);\n    vec4 layer_pupil = vec4(vec3(0.05,0.05,0.05)*NdotL, t3);\n\n    vec4 blend = mix(layer_eyeball, layer_iris, layer_iris.a);\n    blend = mix(blend, layer_pupil, layer_pupil.a);\n    \n\treturn blend;\n}\n\n\nfloat bounce(float time, float width)\n{\n    float res = mod(time,width*2.0);\n    \n    if (res > width)\n    {\n        res = width - res + width;\n    }\n    return res;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n\n    // Background layer\n\tvec4 frag = vec4(0.1,0.1,0.1, 1.0);\n\t\n    vec2 center = vec2(bounce(iResolution.y,iResolution.x),iResolution.y * 0.5);\n    \n    vec2 center1 = vec2(iResolution.x * 0.25, iResolution.y * 0.5);\n    vec2 center2 = vec2(iResolution.x * 0.75, iResolution.y * 0.5);\n    \n\t// eyes\n\tvec4 eye1 = createEye(uv, center1, 0.25 * iResolution.y, 0.1 * iResolution.y, 0.05 * iResolution.y);\n    vec4 eye2 = createEye(uv, center2, 0.25 * iResolution.y, 0.1 * iResolution.y, 0.05 * iResolution.y);\n  \n  \t// blend\n    frag = mix(frag, eye1, eye1.a);   \n    frag = mix(frag, eye2, eye2.a);\n    \n    \n    \n    //for (float i = 0.0; i < 20.0; i++) {\n    //    for (float j = 0.0; j < 15.0; j++) {\n    //       vec2 center = vec2(iResolution.x/20.0*i + i*2.0 + 2.0, iResolution.y/15.0*j + 18.0);\n    //        vec4 eye = createEye(uv, center, 0.25 * iResolution.y*0.2, 0.1 * iResolution.y*0.2, 0.05 * iResolution.y*0.2);\n    //        frag = mix(frag, eye, eye.a);\n    //    }\n    //}\n    \n\tfragColor = frag;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVGDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 429], [439, 439, 471, 471, 806], [808, 808, 863, 863, 1219], [1221, 1221, 1322, 1322, 1446], [1449, 1449, 1532, 1555, 3215], [3218, 3218, 3257, 3257, 3390], [3392, 3392, 3449, 3449, 4491]], "test": "untested"}
{"id": "NlV3Dt", "name": "DoF shadows ( fake 3D )", "author": "FabriceNeyret2", "description": "blurry shadow of a spring (fake 3D)\n\nmouse controls camera.", "tags": ["dof", "shadows", "depthoffield", "fake3d", "short"], "likes": 35, "viewed": 547, "published": 3, "date": "1638549098", "time_retrieved": "2024-07-30T18:44:25.503818", "image_code": "float line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return length(p - b * h);\n}\n\n#define P       vec3(cos(t),sin(t),.2*t)           // helicoid\n#define proj(P) P * mat2x3(cos(a),0,-sin(a),0,1,0) // projection\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float d = 9.,z,_z,Z=1.1, t, l,_l, \n          a = length(iMouse.xy)>10. ? 6.3*iMouse.x/iResolution.x : iTime;\n    vec3 p = vec3(sin(a),0,cos(a));\n    vec2 R = iResolution.xy, B, A, \n         U = ( 3.*u - R ) / R.y -.4;\n    O-=O;     \n    Z = 99.;   // --- compute dist to wall. analytic estimate instead ?\n    for( t = -8.; t < 8.; t+=.02) Z = min(Z,dot(p,P));\n    Z = -Z + .05;\n    for( t=-8.,A = proj(P); t < 8.; t+=.02) { // --- draw shadow projection\n        B = A, A = proj(P);\n        z = ( Z + dot(p,P) )/9.; \n        l = line(U,B,A);\n   //  _l = line(U-.2,B,A); if ( _l < d ) d=_l, _z=z; // if draw shape\n        l /= z;// O = max(O,  .2*exp(-.5*l*l) / sqrt(6.28*z*z) );\n                  O += .006 * exp(-.5*l*l) / sqrt(6.28*z*z);\n    }\n\n    O = 1.-O;\n  //O = mix( clamp(O,0.,1.), vec4(0,cos(50.*d),0,0), smoothstep(5./R.y,0.,d-.02) ); // show shape\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlV3Dt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 140], [271, 271, 309, 309, 1173]], "test": "untested"}
{"id": "7lV3Wt", "name": "Spiral Gallery", "author": "SnoopethDuckDuck", "description": "It's nothing special but I like how it looks", "tags": ["e"], "likes": 13, "viewed": 402, "published": 3, "date": "1638548918", "time_retrieved": "2024-07-30T18:44:26.430341", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv -= 0.2 * vec2(cos(0.2 * iTime), sin(0.2 * iTime));\n    \n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n\n    float sc = 12. + 1. * cos(10. * uv.x + iTime);\n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    \n    float v = h21(ipos);\n    float t = 11. * v + iTime;\n    vec2 p = cos(t) * 0.2 * vec2(cos(2. * v * t), sin(2. * (1.-v) * t));\n    float d = mlength(fpos - p);\n    float k = 0.5 + 0.4 * cos(t);\n    float s = smoothstep(-k,k, 0.25 + 0.25 * thc(4., 20. * v + iTime) - d);\n    s *= 2. * s;\n    vec3 col = step(d, 0.45) * pal(1. * mlength(uv) + 0.08 * fract(s + atan(fpos.y, fpos.x)/pi + t) - 0.2 * t, vec3(0.6), vec3(0.6), vec3(1.), 0.22 * (1. + cos(ceil(4. * v) * s + t)) * vec3(0.,0.33,0.66));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lV3Wt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 191, 191, 232], [234, 234, 261, 261, 302], [304, 304, 372, 372, 415], [417, 417, 437, 437, 512], [514, 514, 538, 538, 578], [580, 580, 637, 637, 1508]], "test": "untested"}
{"id": "stVGRy", "name": "Improved terraforming", "author": "hamtarodeluxe", "description": "Improved version of my terraforming shader. Better sphere mapping (still imperfect), and better interactivity. Click to add matter, use the left side buttons to change element type.", "tags": ["interactive", "planet", "diffusion", "reaction"], "likes": 38, "viewed": 674, "published": 3, "date": "1638548003", "time_retrieved": "2024-07-30T18:44:27.616172", "image_code": "#define RMSTEPS 75\n\nvec4 getData(vec3 p)\n{\n    vec4 v = texture(iChannel0, dirToUV(p)*simResRatio);\n    return vec4(v.x, v.y, v.z, v.w);\n}\n\nfloat hash( uint n ) //iq\n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat getHeight(vec4 data, vec3 p)\n{\n    vec3 type = typeCoefs(data);\n    float h = 0.01;\n    h += (MAXDISP * ((1.-data.x)*0.2 + 0.3))*type.x;\n    h += (MAXDISP * (pow(data.y, 0.125)*0.4 + 0.3))*type.y ;\n    h += (MAXDISP * (pow(1.-data.y,0.5)*0.5 + 0.3))*type.z ;\n\n    return h;//*0. + 0.3;\n}\n\nvec3 normals(vec3 p)\n{\n    vec3 n;\n    float EPS = 0.01f;\n    vec3 e = vec3(EPS,0.,0.);\n    float baseR = RADIUS-MAXDISP;\n    n.x = length(p + e) - getHeight(getData(p+e), p+e) - (length(p - e) - getHeight(getData(p-e), p-e));\n    \n    e = vec3(0.,EPS,0.);\n    n.y = length(p + e) - getHeight(getData(p+e), p+e) - (length(p - e) - getHeight(getData(p-e), p-e));\n\n    e = vec3(0.,0., EPS);\n    n.z = length(p + e) - getHeight(getData(p+e), p+e) - (length(p - e) - getHeight(getData(p-e), p-e));\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 dc = (vec2(fragCoord)/iResolution.xy)*2.-1.;\n\tdc.y *= float(iResolution.y)/float(iResolution.x);\n    \n    vec3 ro = cameraPos(iTime);\n\tvec3 rd = cameraRay(dc, ro);\n    \n    float h = hash(uint(fragCoord.x)+uint(fragCoord.y*iResolution.x)+uint(iFrame)*uint(iResolution.x*iResolution.y));\n    \n    vec3 hitSphP = vec3(1000., 1000.,1000.);\n    vec2 hitTs = vec2(1000.,1000.);\n    bool hitSph = isecSphere(ro, rd, vec3(0.), RADIUS, hitTs, hitSphP);\n    bool hitSurf = false;\n    vec3 p = vec3(0.);\n    vec4 data = vec4(1.);\n\n    if (hitSph)\n    {\n        vec3 hitSphPIn = vec3(1.,1.,1.);\n        vec2 hitTsSphIn = vec2(100.);\n        bool hitSphIn = isecSphere(ro, rd, vec3(0.), RADIUS-MAXDISP, hitTsSphIn, hitSphPIn);\n        float maxT = min(hitTs.y, hitTsSphIn.x) - hitTs.x;\n\n        float d = 500.;\n        ro = hitSphP;\n        float tLength = maxT / float(RMSTEPS);\n        float t = tLength * h;\n\n        float prevSurfH = MAXDISP;\n        \n        float baseR = RADIUS-MAXDISP;\n\n        for (int i = 0; i<RMSTEPS; i++)\n        {\n            p = ro + t*rd;\n            vec3 pNorm = normalize(p);\n            \n            data = getData(p);     \n            float surfH = getHeight(data, pNorm);\n            float h = length(p) - baseR; \n            \n            if(h<surfH)\n            {           \n                float maxSurfH = prevSurfH;\n                float minSurfH = surfH; \n                float maxT = t - tLength;\n                float minT = t;\n                float maxDelta = (length(ro + maxT*rd) - baseR)-maxSurfH;\n                float minDelta = minSurfH-h;\n\n                t = mix(minT, maxT, minDelta / (maxDelta+minDelta));\n                p = ro + t*rd;\n                pNorm = normalize(p);\n                h = length(p) - baseR;\n                data = getData(pNorm); \n                surfH = getHeight(data, pNorm);\n\n                for (int j = 0; j < 3; j++)\n                {\n                    if (h < surfH)\n                    {\n                        minT = t;\n                        minSurfH = surfH;\n                    }\n                    else\n                    {\n                        maxT = t;\n                        maxSurfH = surfH;\n                    }\n                    maxDelta = (length(ro + maxT*rd) - baseR)- maxSurfH;\n                    minDelta = minSurfH-(length(ro + minT*rd) - baseR);\n                  \n                    t = mix(minT, maxT, minDelta / (maxDelta+minDelta));\n                    p = ro + t*rd;\n                    pNorm = normalize(p);\n                    h = length(p) - baseR;\n                    data = getData(pNorm); \n                    surfH = getHeight(data, pNorm);\n                }\n\n                hitSurf = true;\n                t = t; \n                break;\n            }\n            prevSurfH = surfH;\n            t+=tLength;\n        }\n\n    }\n    \n    vec3 col = vec3(0.05);\n    \n    // Shading\n    if (hitSurf)\n    {\n        vec3 type = typeCoefs(data);\n        \n        float maxType = max(type.y,max(type.x,type.z));\n        float trans = maxType - (type.x+type.y+type.z-maxType)*0.5; // transition between types\n        trans = pow(trans,3.);\n        \n        vec3 col0 = mix(vec3(0.,0.2,0.35),0.8*vec3(0.05,0.8,1.),1.-data.x);\n        col0 = 0.8*mix(col0,vec3(0.025,0.8,1.), clamp(((1.-data.x)-0.7)/0.3, 0., 1.));\n\n        vec3 col1 = mix(vec3(0.05, 0.1, 0.05), vec3(0.5, 0.7, 0.05),pow(data.y,0.7));\n        \n        vec3 col2 = mix(vec3(0.15, .075, 0.1)*0.5,vec3(1., .5, 0.15),pow(data.x,2.5));\n\n        col = col0 * type.x + col1 * type.y + col2 * type.z;\n                        \n        float e =0.1f;\n        vec3 n = normals(p);\n        vec3 lightDir = vec3(0.57);\n        \n        vec3 ref = normalize(reflect (lightDir, n));\n        \n        float spec = clamp(dot(ref,rd),0.,1.);\n        spec = 0.75*type.x*pow(spec, 40.) + \n               0.2* type.y*pow(spec, 1.) + \n               0.2* type.z*pow(spec, 3.);\n\n        col += vec3(1.) * spec * trans;\n        \n        float fresnel = 1.-abs(dot(rd, n));\n        col += vec3(0.5,1.,1.)*0.125*type.x * pow(fresnel, 1.);\n        col += 0.3*type.y * pow(fresnel, 2.);\n        col += 0.1*type.z * pow(fresnel, 1.25);\n     }\n    \n    col *= 1./pow((pow(sqrt(0.05*h+dot(dc * 2., dc * 2.)*.4),2.)+1.),3.);\n    \n    // UI\n    {\n        float fl = clamp(floor((dc.y + UIRADIUS * 2.)/(UIRADIUS*4.)),-1., 1.);\n        \n        vec2 discPos = vec2(UIXOFFSET, fl*UIRADIUS*4.) ;\n        float l = length(dc-discPos);    \n        \n        uint typeI = uint(texelFetch(iChannel0, ivec2(iResolution.xy - 1.0), 0).w);\n        float ss = 0.005*(800./iResolution.x);\n        float tSelect = typeI == uint(fl + 1.) ? smoothstep(UIRADIUS+0.01, UIRADIUS+0.01+ss, l) : 1.;\n        col.rgb = mix(vec3(1.,1.,1.), col.rgb, tSelect);\n        \n        col.rgb = mix(typeColors[uint(fl + 1.)], col.rgb, smoothstep(UIRADIUS, UIRADIUS+ss, l));\n    }\n    vec3 hTexCoords = fract(vec3(fragCoord, iFrame)/32.);\n\n    float d = texture(iChannel1, vec3(hTexCoords)).r;\n\n    fragColor = vec4(pow(col, vec3(1. / 2.2)),1.0) + d * (2./255.);\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define RADIUS 0.6\n#define MAXDISP 0.3\n#define UIRADIUS 0.04\n#define UIXOFFSET -0.85\n\n#define simRes min(iResolution.yy, vec2(450, 450))\n#define simResRatio ((simRes-1.)/(iResolution.xy-1.))\n\nvec2 fks[] = vec2[](vec2(0.014, 0.045), vec2(0.03, 0.0565), vec2(.0545, 0.062));\nvec3 typeColors[] = vec3[](vec3(0., 1., 1.), vec3(.2, 1., 0.13), vec3(1., .5, 0.15));\n\nfloat linstep(float x, float y, float t)\n{\n    return clamp((t-x)/(y-x), 0.,1.);\n}\n\nfloat noise (vec3 x, sampler3D tex)\n{\n    // Smoothing distance to texel\n    // https://iquilezles.org/articles/texture\n    x*=32.;\n    x += 0.5;\n    \n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\tx = f+i;    \n    x -= 0.5;\n    \n    return texture(tex, x/32.0).x;\n}\n\nbool isecSphere(vec3 ro, vec3 rd, vec3 pos, float r, out vec2 outT, out vec3 outP)\n{\n    float a = dot(rd,rd);\n    float b = 2.*dot(rd,(ro-pos));\n    float c = dot((ro-pos),(ro-pos))-r*r;\n    float d = b*b-4.*a*c;\n    outP = vec3(0.);\n    outT = vec2(100.);\n    if (d<0.)\n        return false;\n\n    float sd = sqrt(d);\n    outT = vec2((-b-sd)/(2.*a),(-b+sd)/(2.*a)); \n    outT = vec2(min(outT.x, outT.y), max(outT.x, outT.y));\n    outP = ro + rd*outT.x;\n    outT = abs(outT);\n    return true;\n}\n\nvec3 cameraPos(float time)\n{\n    time *= 0.25f;\n    float sTime = sin(time);\n    return (1. + 0.1 * sTime) * vec3 (cos(time), 1., sTime);\n}\n\nvec3 cameraRay(vec2 dc, vec3 ro)\n{\n    vec3 lookAt = vec3(0.);\n\tvec3 fw = normalize(lookAt-ro);\n\tvec3 rg = normalize(vec3(-fw.z,0,fw.x));\n\tvec3 up = normalize(cross(rg,fw));\n\tfloat fo = 1.5;\n\tvec3 rd = normalize(fw * fo + up * dc.y + rg * dc.x);\n\treturn rd;\n}\n\nvec3 UVToDir(vec2 uv)\n{\n    vec3 position = vec3(2.0f * (uv.x - 0.5f), 0, 2.0f * (uv.y - 0.5f));                \n\n    vec2 absolute = abs(position.xz);\n    position.y = 1.0f - absolute.x - absolute.y;\n\n    if(position.y < 0.) {\n        position.xz = sign(position.xz) * (1.0-absolute.yx);\n    }\n    \n    return normalize(position);\n}\n\n// Expects normalized input\nvec2 dirToUV(vec3 dir)\n{\n    vec3 s = sign(dir);\n\n    float sum = dot(dir, s);        \n    vec3 oct = dir / sum;    \n\n    if(dir.y < 0.)\n    {\n        vec3 a = abs(oct);\n        oct.xz = s.xz * (vec2(1.0f) - a.zx);\n    }\n\n    return oct.xz * 0.5f + 0.5f;\n}\n\nvec2 os[8] = vec2[](vec2(0,1),\n                    vec2(0,-1),\n                    vec2(1,0),\n                    vec2(-1,0),  \n                    vec2(1,1),   \n                    vec2(1,-1),  \n                    vec2(-1,1), \n                    vec2(-1,-1));                 \n\nvec3 barycentric(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n    vec2 v0 = b - a;\n    vec2 v1 = c - a;\n    vec2 v2 = p - a;\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00 * d11 - d01 * d01;\n    float u = (d11 * d20 - d01 * d21) / denom;\n    float v = (d00 * d21 - d01 * d20) / denom;\n    float w = 1.0f - v - u;\n    return vec3 (w, u, v);\n}\n\nvec3 typeCoefs(vec4 data)\n{\n    return barycentric(data.zw, fks[0], fks[1], fks[2]);\n}\n\nvec4 runKernel(vec2 fragCoord, vec2 iResolution, sampler2D iChannel0, sampler3D noiseTex, float time)\n{  \n    vec4 sampleMid = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    if (fragCoord.x >= iResolution.x || fragCoord.y >= iResolution.y) return sampleMid;\n    \n    vec2 C = sampleMid.xy;  \n    \n    vec2 values[8];\n    vec2 k = vec2(0.);\n    float w = 0.;\n    vec3 debug= vec3(0.);\n    bool toto = false;\n    vec3 cP = UVToDir(fragCoord/iResolution);\n    for (int i = 0; i < 8; i++)\n    {\n        float d = 1.;\n        vec2 samp = fragCoord + os[i];\n        \n        vec2 dd = samp - clamp(samp, vec2(0.), iResolution + vec2(0.,0.));\n        vec2 add = abs(dd);\n        if (add.x > 0.0 && add.y > 0.0)\n        {\n            d = 0.;\n        }\n        if (add.x > 0.)\n        {\n            samp.x = fragCoord.x;\n            samp.y = samp.y - 2. * (samp.y - iResolution.y * 0.5);\n        }\n        else if (add.y >0.)\n        {\n            samp.y = fragCoord.y;\n            samp.x = samp.x - 2. * (samp.x - iResolution.x * 0.5);\n        }\n        vec3 sP = UVToDir(samp/iResolution);\n        vec3 l = cP-sP;\n        d /= dot(l, l);\n        \n    \tk += d*texelFetch(iChannel0, ivec2(samp),0).xy;\n        \n        w += d;\n    } \n\n    k/= w;\n    \n    vec2 D = k-C;\n    float s = 1.;\n    vec2 dr = 1.*vec2(1.,0.5);\n        \n    vec2 fk = sampleMid.zw;\n\n    float feed = fk.x;\n  \tfloat kill = fk.y;\n\n    vec2 nextC;\n\tnextC.x = C.x + (D.x*dr.x-C.x*C.y*C.y + feed*(1.-C.x))*s;\n    nextC.y = C.y + (D.y*dr.y+C.x*C.y*C.y -(kill+feed)*C.y)*s;\n\tC = nextC;\n    \n    return vec4(C, sampleMid.zw);\n}\n\n#define RUNKERNEL runKernel(fragCoord.xy, simRes, iChannel0, iChannel1, iTime);      \n", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n          \n    vec2 mouseDc = (vec2(iMouse.xy)/iResolution.xy)*2.-1.;\n\tmouseDc.y *= float(iResolution.y)/float(iResolution.x);\n    \n    vec3 ro = cameraPos(iTime);\n\tvec3 rd = cameraRay(mouseDc, ro);   \n    vec3 hitSphP = vec3(1.);\n    vec2 outT = vec2(1000.);\n    bool hitSph = isecSphere(ro, rd, vec3(0.), RADIUS-MAXDISP*0.5, outT, hitSphP);\n    \n    vec4 C = RUNKERNEL\n\n    if (iMouse.z > 0. && hitSph && ivec2(fragCoord.xy) != ivec2(iResolution.xy - 1.0))\n    {\n        vec3 pTex = UVToDir(uv/simResRatio);\n        vec3 pMouse = normalize(hitSphP);\n        float l = clamp(length(pTex-pMouse)/0.125, 0., 1.);\n \n    \tC.y += 0.1 * (1.-smoothstep(0.3,0.4, l));\n\n        uint typeI = uint(texelFetch(iChannel0, ivec2(iResolution.xy - 1.0), 0).w);\n\n        C.zw = mix(C.zw, fks[typeI], 0.5*(1.-linstep(0.1,0.8, l)));\n    } \n    \n    C.xy = clamp(C.xy,vec2(0.0),vec2(1.));\n        \n    if (dot(C.zw, C.zw) < 0.001)\n        C.zw = fks[0];\n        \n    fragColor = C;\n    \n    if (iFrame == 0)\n        fragColor = vec4(0.,0., fks[0]);\n    \n    if (ivec2(fragCoord.xy) == ivec2(iResolution.xy - 1.0))\n    {\n        if (iFrame == 0)\n            fragColor.w = 1.0f;\n        else if (iMouse.z > 0.)\n        {\n            float fl = clamp(floor((mouseDc.y + UIRADIUS * 2.)/(UIRADIUS*4.)),-1., 1.);\n            vec2 discPos = vec2(UIXOFFSET, fl*UIRADIUS*4.) ;\n            float l = length(mouseDc-discPos);\n            if (l < UIRADIUS)\n                fragColor.w = floor(fl + 1.);\n        }\n    }  \n}", "buffer_a_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = RUNKERNEL\n}", "buffer_b_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = RUNKERNEL\n}", "buffer_c_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = RUNKERNEL\n}", "buffer_d_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVGRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 42, 42, 138], [140, 140, 167, 210, 348], [350, 350, 386, 386, 643], [645, 645, 667, 667, 1170], [1172, 1172, 1229, 1279, 6395]], "test": "untested"}
{"id": "flVGWt", "name": "Game of Life aint uv coords", "author": "Arrangemonk", "description": "thats boting, i was expectiong more... buuuuut i can still fork and implement proper rules, can be reseted on space now", "tags": ["meh"], "likes": 3, "viewed": 408, "published": 3, "date": "1638530574", "time_retrieved": "2024-07-30T18:44:28.747148", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n      vec3 gol1 = texture(iChannel0,uv).xyz;\n      vec3 gol2 = texture(iChannel0,uv + 0.254).xyz;\n      vec4 gol = vec4(gol1 + gol2,1.)*.5;\n      //fragColor = gol;\n      fragColor = texture(iChannel1,uv*0.1 + 0.25* gol.z *gol.xy);\n  }", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = 2. * fragCoord/iResolution.xx;\n    if(iFrame < 10 || texelFetch(iChannel2, ivec2(32,0),0).x > 0.){\n    fragColor = texture(iChannel0,uv);\n    }\n    else\n    {\n     fragColor = texture(iChannel1,fragCoord/iResolution.xy);\n     \n     vec3 diff = vec3(1,0,-1)/iResolution.x;\n     \n     vec4 sum = texture(iChannel1,fragCoord/iResolution.xy - diff.xx);\n     sum += texture(iChannel1,fragCoord/iResolution.xy - diff.xy);\n     sum += texture(iChannel1,fragCoord/iResolution.xy - diff.xz);\n     sum += texture(iChannel1,fragCoord/iResolution.xy - diff.yx);\n     sum += texture(iChannel1,fragCoord/iResolution.xy - diff.yz);\n     sum += texture(iChannel1,fragCoord/iResolution.xy - diff.zx);\n     sum += texture(iChannel1,fragCoord/iResolution.xy - diff.zy);\n     sum += texture(iChannel1,fragCoord/iResolution.xy - diff.zz);\n     \n     vec4 result = texture(iChannel1,fragCoord/iResolution.xy);\n     float amount = 0.01;\n     float minl = 2.;\n     float maxl = 3.;\n     \n     if(sum.z < minl || sum.y > maxl)\n         fragColor.x =  max(0.,result.x -amount);\n     else \n         fragColor.x = min(1.,result.x + amount);\n         \n      if(sum.x <minl || sum.z >maxl)\n         fragColor.y =  max(0.,result.y -amount);\n     else \n         fragColor.y = min(1.,result.y + amount);\n         \n     if(sum.y < minl || sum.x > maxl)\n         fragColor.z =  max(0.,result.z -amount);\n     else \n         fragColor.z = min(1.,result.z + amount);\n\n     \n    }\n    \n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVGWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 388]], "test": "untested"}
{"id": "NlKGWt", "name": "voronoi splatting", "author": "AnonN10", "description": "convex combination", "tags": ["voronoi"], "likes": 4, "viewed": 173, "published": 3, "date": "1638528561", "time_retrieved": "2024-07-30T18:44:29.950928", "image_code": "#define PI 3.1415926535897932\n#define NUM_POINTS 16\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.0);\n    float pw = ((iMouse.z>0.0)?(iMouse.x/iResolution.x):(sin(iTime*0.5)*0.5+0.5))*18.0;\n    \n    vec2 points[NUM_POINTS];\n    vec3 colors[NUM_POINTS];\n    for(int i = 0; i < NUM_POINTS; ++i)\n    {\n        //[-1; 1]\n        points[i] = vec2(\n            cos(iTime*2.0*PI*0.1*rand(vec2(float(i+1)*0.5574, float(i+1)*0.6425))),\n            sin(iTime*2.0*PI*0.1*rand(vec2(float(i+1)*0.8464, float(i+1)*0.8345)))\n        );\n        //[0; 1]\n        points[i] = points[i]*0.5+0.5;\n        \n        colors[i] = vec3(\n            rand(vec2(float(i+1)*0.1251, float(i+1)*0.2605)),\n            rand(vec2(float(i+1)*0.8681, float(i+1)*0.6385)),\n            rand(vec2(float(i+1)*0.9663, float(i+1)*0.4395))\n        );\n    }\n\n    float nf = 0.0;\n    for(int i = 0; i < NUM_POINTS; ++i)\n    {\n        float dist = length(points[i] - uv);\n        dist = 1.0/dist;\n        dist = pow(dist, pw);\n        nf += dist;\n    }\n    nf = 1.0/nf;\n    \n    for(int i = 0; i < NUM_POINTS; ++i)\n    {\n        float dist = length(points[i] - uv);\n        if(dist < 0.01f)\n        {\n            col = vec3(1.0f);\n            break;\n        }\n        dist = 1.0/dist;\n        dist = pow(dist, pw);\n        col += colors[i]*dist*nf;\n    }\n    \n    col = pow(col, vec3(1.0/2.2));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKGWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 73, 73, 143], [145, 145, 202, 202, 1574]], "test": "untested"}
{"id": "7lG3Wd", "name": "Voronoi Ubung #5", "author": "Yusef28", "description": "more in comments", "tags": ["voronoi"], "likes": 14, "viewed": 354, "published": 3, "date": "1638519009", "time_retrieved": "2024-07-30T18:44:30.945270", "image_code": "/* \nThis Voronoi Shader is based on:\n\n1. An article by IQ: \n    https://iquilezles.org/articles/voronoilines\n2. tomkh's drawing helped it click: \n    https://www.shadertoy.com/view/llG3zy\n3.Shane's Rounded border shader:\n    https://www.shadertoy.com/view/ll3GRM\n*/\n\n\n#define pi acos(-1.)\n#define eps 8./iResolution.y\n\n#define maxPoints 16.\n#define screenSize 4.\n\n#define bg (0.5+0.5*sin(vec3(iTime,iTime*3.+403.,iTime*1.3+902.)))\n#define fg (0.5+0.5*sin(vec3(-iTime*2.1,-iTime*0.9+403.,-iTime+902.)))\n\nvec2 rnd2(vec2 id){\n    return vec2(fract(sin(dot(id,vec2(14.27,74.97)))*54329.34),\n           fract(sin(dot(id+912.35,vec2(49.27,102.74)))*54329.34));\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin2(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\nfloat point(vec2 uv, float r){\n    return smoothstep(r+eps,r-eps,length(uv));\n}\n\nfloat ring(vec2 uv, float r){\n    return smoothstep(eps+0.03, 0., abs(length(uv)-r+0.03));\n}\n\nfloat line(vec2 P, vec2 A, vec2 B, float r){\n    vec2 PA = P-A;\n    vec2 AB = B-A;\n    //dot(AB,P-P3) = 0\n    //dot(AB,P-AB*t)\n    float t = clamp(dot(PA,AB)/dot(AB,AB),0.,1.);\n    return smoothstep(r+eps,r-eps,length(PA-AB*t));\n   \n}\n\n//we are in \"not world/object space\" \n//because we use length on vectors from vec2(0,0.)\n//to get distances\nvec4 voronoi(vec2 uv){\n\n    vec2 st = fract(uv);\n    vec2 stFL = floor(uv);\n    vec2 d = vec2(10.);\n    vec2 A, B=vec2(100.);\n    \n    vec2 mind;\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);//max(abs(coords.x),abs(coords.y));\n        \n        if(c < d.x){\n            d.x = c;\n            d.y = rnd2(stFL+id).y;\n            A = coords;\n            }\n        }\n    }\n    mind = d;\n    \n    d = vec2(10.);\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);//max(abs(coords.x),abs(coords.y));\n        \n        if(length(A-coords) > 0.00){\n            //d.x = c;\n            //d.y = rnd2(stFL+id).y;\n            B.x = smin2(B.x, dot( 0.5*(A+coords), \n                       normalize(coords-A) ), 0.2 );\n            }\n        }\n    }\n    B.y = B.x;\n    return vec4(mind,smoothstep(0.,1.,0.5+0.35*(sin(pow(max(B.x*32.,0.9)-.2,1./2.)))\n    ),B.y);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    vec3 light = vec3(1.,0.,2.);\n    vec3 ldir = normalize(vec3(0.)-light);\n    \n    vec3 light2 = vec3(2.,1.,1.);\n    vec3 ldir2 = normalize(vec3(0.)-light2);\n    \n    // Time varying pixel color\n    //vec3(0.1,1.4,2.)\n    uv*=3.;\n    uv.x+=iTime;\n    vec4 voronoXY = voronoi(uv);\n    //float edges = smoothstep(0.00,0.01,abs(voronoXY.x-voronoXY.z));\n    //vec3 col = 0.5+0.5*sin(vec3(1., 2., 3.)/1.2+ voronoXY.y*pi*200.);\n    vec3 col = 0.5+0.5*sin(vec3(0., 2., 3.)/1.2+ voronoXY.y*pi*20.);\n    col.zy *= rot(.1);\n    \n   // col = mix(col, vec3(voronoXY.y,0., voronoXY.y)/4., smoothstep(0.08,0.05,voronoXY.x));\n  //  col += sin(voronoXY.x*40.);\n    //col += vec3(fract(voronoXY.x*8.));\n    //col = mix(col, vec3(0.), smoothstep(0.14,0.13,voronoXY.z));\n   //col = mix(col, vec3(1.), smoothstep(0.05,0.,voronoXY.z));\n   // col -= sin(voronoXY.z*90.)/10.;\n    //col = mix(col, vec3(0.), 1.-smoothstep(0.5,0.4,voronoXY.x*1.));\n    col = mix(col, vec3(.9,0.6,0.0), smoothstep(0.3,.5,voronoXY.z)*0.3 );\n    // Output to screen\n    \n    vec3 n = vec3(\n                  voronoi(uv-vec2(eps,0.)).x-voronoi(uv+vec2(eps,0.)).x,\n                  voronoi(uv-vec2(eps,0.).yx).x-voronoi(uv+vec2(eps,0.).yx).x,\n                  voronoi(uv-vec2(eps,0.)).z\n                  -voronoi(uv+vec2(eps,0.).yy).z\n                  );\n         n = normalize(n);//smoothstep(vec3(-1.),vec3(1.),;\n         \n    float diff = max(dot(ldir,n),0.);\n    \n    float spec = pow( max(\n                 dot( reflect(-ldir,n),vec3(0.,0.,1.)),0.),5.);\n    col += diff*0.6+vec3(0.9,0.5,0.1)*spec;\n    \n    \n    \n    float diff2 = max(dot(ldir,n),0.);\n    \n    float spec2 = pow( max(\n                 dot( reflect(-ldir2,n),vec3(0.,0.,1.)),0.),5.);\n    col += diff2*0.8+vec3(0.1,0.5,0.9)*spec2;\n    \n \n    col = mix(col, vec3(0.), smoothstep(0.04,0.025,voronoXY.w));\n    col = mix(col, vec3(1.,0.4,0.)/4., smoothstep(0.04,0.0,voronoXY.w));\n    col += smoothstep(0.05,0.03,voronoXY.w)*(0.5+0.5*sin(voronoXY.w*10.))/1.5;\n    \n    col /= 1.5;\n    col= pow(col, vec3(1.4));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lG3Wd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[503, 503, 522, 522, 656], [658, 658, 676, 676, 739], [741, 741, 781, 781, 857], [859, 859, 889, 889, 938], [940, 940, 969, 969, 1032], [1034, 1034, 1078, 1078, 1268], [1270, 1378, 1400, 1400, 2686], [2688, 2688, 2745, 2795, 4928]], "test": "untested"}
{"id": "7tKGRc", "name": "Straight Flagstone Tiles", "author": "gelami", "description": "Flagstone/Asymmetric tiling with tile IDs, sizes, and UVs.\n\nFor a 3D raytraced version: https://www.shadertoy.com/view/cltGRl", "tags": ["grid", "rectangle", "tiling", "bricks", "bricks", "tiles", "asymmetric", "flagstone"], "likes": 127, "viewed": 5567, "published": 3, "date": "1638514531", "time_retrieved": "2024-07-30T18:44:32.286683", "image_code": "\n// Straight Flagstone Tiles (aka Asymmetric Tiles)\n// https://www.shadertoy.com/view/7tKGRc\n\n/**\n * Flagstone/Asymmetric tiling with tile IDs, sizes and UVs.\n * \n * Like with my previous shader (https://www.shadertoy.com/view/flVGzm),\n * the tile IDs are computed first, and the UVs are derived from it,\n * by subtracting from the original position, and scaling by the tile size.\n * \n * This has the advantage of not dealing with the mess that is\n * getting the UVs for each corner, and gives you already the tile ID.\n * It's great for rectangular tilings, as long as you know what the size of the tile is.\n * \n * The distances from this does have discontinuities in the edges\n * \n * Next time, I'd like to try doing the organic flagstone tiles with asymmetric sizes\n * Distance-to-edge voronoi is pretty close to it, but the sizes aren't so varied. :(\n * Maybe there's a way to do it in a similar vein like this one.\n * \n * Many thanks to Shane (hello!) and fizzer for their methods\n * from which this shader is derived from:\n * \n *   Variegated Tiling by fizzer\n *   https://www.shadertoy.com/view/3styzn\n *\n *   Asymmetric Blocks by Shane\n *   https://www.shadertoy.com/view/Ws3GRs\n *\n *   For a 3D raytraced version:\n *   Extruded Flagstone Tiling 3D by gelami\n *   https://www.shadertoy.com/view/cltGRl\n**/\n\n#define ANIMATED\n#define GLOW\n\n#define SCROLLING\n\n//#define SHOW_CHECKER\n//#define SHOW_GRID\n//#define SHOW_ID\n//#define SHOW_UV\n\nconst float SCALE = 4.;\nconst float SMOOTHNESS = 0.15;\n\nfloat randSpan( vec2 p )\n{\n    #ifdef ANIMATED\n    return (sin(iTime*1.6 + hash12(p)*TAU)*.5+.5)*.6+.2;\n    #else\n    return hash12(p)*.6+.2;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    \n    uv *= SCALE;\n    \n    #ifdef SCROLLING\n    uv += vec2(.7, .5) * iTime;\n    #endif\n\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    \n    bool ch = mod(fl.x + fl.y, 2.) > .5;\n    \n    float r1 = randSpan(fl);\n    vec2 ax = ch ? fr.xy : fr.yx;\n    \n    float a1 = ax.x - r1;\n    float si = sign(a1);\n    vec2 o1 = ch ? vec2(si, 0) : vec2(0, si);\n    \n    float r2 = randSpan(fl + o1);\n    float a2 = ax.y - r2;\n    \n    vec2 st = step(vec2(0), vec2(a1, a2));\n    \n    // Tile ID\n    vec2 of = ch ? st.xy : st.yx;\n    vec2 id = fl + of - 1.;\n    \n    bool ch2 = mod(id.x + id.y, 2.) > .5;\n    \n    // Get the random spans\n    float r00 = randSpan(id + vec2(0, 0));\n    float r10 = randSpan(id + vec2(1, 0));\n    float r01 = randSpan(id + vec2(0, 1));\n    float r11 = randSpan(id + vec2(1, 1));\n    \n    // Tile Size\n    vec2 s0 = ch2 ? vec2(r00, r10) : vec2(r01, r00);\n    vec2 s1 = ch2 ? vec2(r11, r01) : vec2(r10, r11);\n    vec2 s = 1. - s0 + s1;\n    \n    // UV\n    vec2 puv = (uv - id - s0) / s;\n    \n    // Border Distance\n    vec2 b = (.5 - abs(puv - .5)) * s;\n    \n    float d = smin(b.x, b.y, SMOOTHNESS);\n    float l = smoothstep(.02, .06, d);\n    \n    // **** Shading ****\n    \n    // Highlights\n    vec2 hp = (1. - puv) * s;\n    float h = smoothstep(.08, .0, max(smin(hp.x, hp.y, SMOOTHNESS), 0.));\n    \n    // Shadows\n    vec2 sp = puv * s;\n    float sh = smoothstep(.05, .12, max(smin(sp.x, sp.y, SMOOTHNESS), 0.));\n    \n    // Texture\n    vec3 tex = pow(texture(iChannel0, puv).rgb, vec3(2.2));\n    \n    // Random Color\n    vec3 col = palette(hash12(id));\n    \n    col *= tex;\n    col *= (vec3(puv, 0) * .6 + .4);\n    col *= sh * .8 + .2;\n    col += h * vec3(.9, .7, .5);\n    col *= l * 5.;\n    \n    // **** Defines ****\n    #ifdef GLOW\n    vec2 gv = (1.1 - fragCoord / iResolution.xy) * iResolution.x / iResolution.y;\n    col += pow(.12 / length(gv), 1.5) * vec3(1., .8, .4) * (l * 0.3 + 0.7);\n    #endif\n    \n    #ifdef SHOW_ID\n    col = vec3(id, 0);\n    #endif\n    \n    #ifdef SHOW_UV\n    col = vec3(puv, 0);\n    #endif\n    \n    #ifdef SHOW_GRID\n    vec2 g = .5 - abs(fr - .5);\n    float grid = smoothstep(.03, .02, min(g.x, g.y));\n    col = mix(col, vec3(.2, .9, 1), grid);\n    #endif\n    \n    #ifdef SHOW_CHECKER\n    col = mix(col, (ch ? vec3(1, .2, .2) : vec3(.2, 1, .2)), .2);\n    #endif\n    \n    // Tonemapping and Gamma Correction\n    col = max(col, vec3(0));\n    col = col / (1. + col);\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define PI (acos(-1.))\n#define TAU (2.*PI)\n\n#define sat(x) clamp(x, 0., 1.)\n\nmat2 rot2D(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n// Cubic smin function\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k - abs(a - b), 0.0 ) / k;\n    return min(a, b) - h*h*h*k * (1.0 / 6.0);\n}\n\nfloat smax( float a, float b, float k )\n{\n    return -smin(-a, -b, k);\n}\n\n// Cosine Color Palette\n// https://iquilezles.org/articles/palettes\nvec3 palette( float t )\n{\n    return 0.52 + 0.48*cos( TAU * (vec3(.9, .8, .5) * t + vec3(0.1, .05, .1)) );\n}\n\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\n// MIT License...\n/* Copyright (c) 2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\nfloat hash12(vec2 p)\n{\n    p = p * 1.1213;\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKGRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1500, 1500, 1526, 1526, 1654], [1656, 1656, 1713, 1713, 4263]], "test": "untested"}
{"id": "stGGWc", "name": "Triquadratic Raymarching", "author": "paniq", "description": "Raymarching a triquadratic volume using segment tracing, gradient intervals and polynomial arithmetic. Takes a while to compile.", "tags": ["marching", "triquadratic", "hextic"], "likes": 17, "viewed": 647, "published": 3, "date": "1638508653", "time_retrieved": "2024-07-30T18:44:33.535344", "image_code": "\n// display iteration heatmap\n//#define SHOW_ITERATION_COST\n\n// evaluate tangent intervals from polynomial rather than interpolant\n#define FOLD_COEFFICIENTS\n// normalize t to 0..1\n#define NORMALIZE_RAY_RANGE\n// normalize t to -1..1\n#define CENTERED_RAY_RANGE\n// when FOLD_COEFFICIENTS is defined, use horner method to evaluate polynomial\n// not as much required when ray range is normalized and centered\n#define USE_HORNER_METHOD\n// undefine to only render frontface\n#define RENDER_BACKFACE\n\n// voxel coordinate in texture\n//const ivec3 patch_coord = ivec3(11);\nconst ivec3 patch_coord = ivec3(7,5,5);\n//const ivec3 patch_coord = ivec3(22,8,16);\n\nconst int max_iterations = 15;\nconst float sigma = 1e-4;\n\n#ifdef NORMALIZE_RAY_RANGE\n#ifdef CENTERED_RAY_RANGE\nconst float start_width = 1.0;\n#else\nconst float start_width = 0.5;\n#endif\n#else\n//const float start_width = 0.15;\nconst float start_width = 0.5;\n#endif\n\n//const float grow_rate = 1.4;\n//const float grow_rate = 1.618;\nconst float grow_rate = 2.0;\n\n//////////////////////////////////////////////////////////\n\n// https://en.wikipedia.org/wiki/Polynomial_arithmetic\n\nstruct poly1 { float c[2]; };\nstruct poly2 { float c[3]; };\nstruct poly3 { float c[4]; };\nstruct poly4 { float c[5]; };\nstruct poly5 { float c[6]; };\nstruct poly6 { float c[7]; };\n\nstruct poly1x3 { poly1 x; poly1 y; poly1 z; };\n\n#define DEFINE_PA_HORNER(T,N) \\\n    T pa_horner(T a, float x0) { \\\n        T c; \\\n        c.c[N] = a.c[N]; \\\n        for (int i = N-1; i >= 0; --i) { \\\n            c.c[i] = a.c[i] + c.c[i+1] * x0; \\\n        } \\\n        return c; \\\n    }\n\n#define DEFINE_PA_EVAL(T,N) \\\n    float pa_eval(T a, float x) { \\\n        float b = a.c[N]; \\\n        for (int i = N-1; i >= 0; --i) { \\\n            b = b*x + a.c[i]; \\\n        } \\\n        return b; \\\n    }\n\n#define DEFINE_PA_MIX(TINAB,TOUT,NOUT) \\\n    TOUT pa_mix(TINAB a, TINAB b, poly1 x) { \\\n        float x0 = x.c[0]; float x1 = x.c[1]; float ix0 = 1. - x0; \\\n        TOUT c; \\\n        for (int i = 0; i < NOUT; ++i) { \\\n            c.c[i] = a.c[i]*ix0 + b.c[i]*x0; \\\n        } \\\n        c.c[NOUT] = 0.; \\\n        for (int i = 0; i < NOUT; ++i) { \\\n            c.c[i+1] += (b.c[i] - a.c[i])*x1; \\\n        } \\\n        return c; \\\n    }\n\npoly1 poly(float c0, float c1) {\n    return poly1(float[](c0, c1));\n}\n\npoly1x3 poly(vec3 c0, vec3 c1) {\n    return poly1x3(poly(c0.x,c1.x),poly(c0.y,c1.y),poly(c0.z,c1.z));\n}\n\npoly1 pa_add(poly1 a, float b) {\n    return poly(a.c[0] + b, a.c[1]);\n}\n\npoly1 pa_mul(poly1 a, float b) {\n    return poly(a.c[0] * b, a.c[1] * b);\n}\n\npoly1x3 pa_add(poly1x3 a, float b) {\n    return poly1x3(pa_add(a.x, b),pa_add(a.y, b),pa_add(a.z, b));\n}\npoly1x3 pa_mul(poly1x3 a, float b) {\n    return poly1x3(pa_mul(a.x, b),pa_mul(a.y, b),pa_mul(a.z, b));\n}\n\npoly1 pa_mix(float a, float b, poly1 x) {\n    float x0 = x.c[0]; float x1 = x.c[1]; float ix0 = 1. - x0;\n    return poly(a*ix0 + b*x0, (b - a)*x1);\n}\n\nDEFINE_PA_MIX(poly1,poly2,2)\nDEFINE_PA_MIX(poly2,poly3,3)\nDEFINE_PA_MIX(poly3,poly4,4)\nDEFINE_PA_MIX(poly4,poly5,5)\nDEFINE_PA_MIX(poly5,poly6,6)\n\nDEFINE_PA_HORNER(poly6,6)\nDEFINE_PA_EVAL(poly6,6)\n\n//////////////////////////////////////////////////////////\n\n// GIA scalar for rays (1D)\nstruct gia1 {\n    // coefficients of f(x) = f0 + s*(f1 - f0)\n    // where s=[0..1]\n    float f0;\n    vec2 f1;\n};\n    \nstruct gia1x2 {\n    gia1 x;\n    gia1 y;\n};\n\nstruct gia1x3 {\n    gia1 x;\n    gia1 y;\n    gia1 z;\n};\n\n//////////////////////////////////////////////////////////\n\ngia1 gia_const(float x) {\n    return gia1(x, vec2(x));\n}\n\ngia1x3 gia_const(vec3 v) {\n    return gia1x3(gia_const(v.x), gia_const(v.y), gia_const(v.z));\n}\n\ngia1 gia_neg(gia1 x) {\n    return gia1(-x.f0, -x.f1.yx);\n}\n\nvec2 ia_sort(vec2 ia) {\n    return (ia.x > ia.y)?ia.yx:ia;\n}\n\nvec2 ia_merge(vec2 a, vec2 b) {\n    return vec2(min(a.x, b.x), max(a.y, b.y));\n}\n\ngia1 gia_add(gia1 a, gia1 b) {\n    return gia1(a.f0 + b.f0, a.f1 + b.f1);\n}\n\ngia1 gia_add(gia1 a, float b) {\n    return gia1(a.f0 + b, a.f1 + b);\n}\n\ngia1x3 gia_add(gia1x3 a, vec3 b) {\n    return gia1x3(gia_add(a.x, b.x), gia_add(a.y, b.y), gia_add(a.z, b.z));\n}\n\ngia1 gia_mul(gia1 a, gia1 b) {    \n\tfloat f0 = a.f0 * b.f0;\n    vec2 f1 = ia_merge(ia_sort(a.f1.x * b.f1), ia_sort(a.f1.y * b.f1));\n    vec2 ff0 = ia_sort(b.f0*a.f1) + ia_sort(a.f0*b.f1) - f0;\n    return gia1(f0, ia_merge(ff0, f1));\n}\n\ngia1 gia_mul(gia1 a, float b) {    \n    vec2 q = a.f1.xy * b;\n    return gia1(a.f0 * b, (b < 0.0)?q.yx:q);\n}\n\ngia1x3 gia_mul(gia1 a, vec3 b) {\n    return gia1x3(gia_mul(a, b.x), gia_mul(a, b.y), gia_mul(a, b.z));\n}\n\ngia1x3 gia_mul(gia1x3 a, vec3 b) {\n    return gia1x3(gia_mul(a.x, b.x), gia_mul(a.y, b.y), gia_mul(a.z, b.z));\n}\n\ngia1 gia_mix(float a, float b, gia1 x) {\n#if 1\n    return gia_add(gia_mul(x, b-a),a);\n#else\n    return gia_add(gia_mul(gia_add(gia_neg(x),1.0), a), gia_mul(x, b));\n#endif\n}\ngia1 gia_mix(gia1 a, gia1 b, gia1 x) {\n    return gia_add(gia_mul(gia_add(gia_neg(x),1.0), a), gia_mul(x, b));\n}\n\ngia1 pa_eval(poly6 a, gia1 x) {\n#ifdef USE_HORNER_METHOD\n    float x0 = x.f0;\n    a = pa_horner(a, x0);\n    gia1 y = gia_const(a.c[6]);\n    for (int i = 5; i >= 1; --i) {\n        y = gia_add(gia_mul(x,y), a.c[i]);\n    }\n    y = gia_add(gia_mul(y, gia_add(x, -x0)), a.c[0]);\n    return y;\n#else\n    gia1 y = gia_const(a.c[6]);\n    for (int i = 5; i >= 0; --i) {\n        y = gia_add(gia_mul(x,y), a.c[i]);\n    }\n    return y;\n#endif\n}\n\nfloat interpolate3x3x3(mat3 s[3], vec3 q) {\n    vec3 q0 = (q+1.0)/2.0;\n    vec3 q1 = q/2.0;\t\n\n    vec3 xf;\n    for (int x = 0; x < 3; ++x) {\n        vec3 yf;\n        for (int y = 0; y < 3; ++y) {\n            yf[y] = mix(mix(s[x][y][0], s[x][y][1], q0.z), mix(s[x][y][1], s[x][y][2], q1.z), q.z);\n        }\n        xf[x] = mix(mix(yf[0], yf[1], q0.y), mix(yf[1], yf[2], q1.y), q.y);\n    }    \n    return mix(mix(xf[0], xf[1], q0.x), mix(xf[1], xf[2], q1.x), q.x);    \n}\n\npoly6 interpolate3x3x3(mat3 s[3], poly1x3 q) {\n    poly1x3 q1 = pa_mul(q,1.0/2.0);\n    poly1x3 q0 = pa_add(q1,1.0/2.0);\n\n    poly4 xf[3];\n    for (int x = 0; x < 3; ++x) {\n        poly2 yf[3];\n        for (int y = 0; y < 3; ++y) {\n            yf[y] = pa_mix(pa_mix(s[x][y][0], s[x][y][1], q0.z), pa_mix(s[x][y][1], s[x][y][2], q1.z), q.z);\n        }\n        xf[x] = pa_mix(pa_mix(yf[0], yf[1], q0.y), pa_mix(yf[1], yf[2], q1.y), q.y);\n    }    \n    return pa_mix(pa_mix(xf[0], xf[1], q0.x), pa_mix(xf[1], xf[2], q1.x), q.x);    \n}\n\nvec3 interpolate3x3x3_normal(mat3 s[3], vec3 q) {\n    vec2 e = vec2(1e-3, 0.0);\n    return -normalize(vec3(\n        interpolate3x3x3(s, q + e.xyy) - interpolate3x3x3(s, q - e.xyy),\n        interpolate3x3x3(s, q + e.yxy) - interpolate3x3x3(s, q - e.yxy),\n        interpolate3x3x3(s, q + e.yyx) - interpolate3x3x3(s, q - e.yyx)));\n}\n\ngia1 gia_interpolate3x3x3(mat3 s[3], gia1x3 q) {\n    gia1x3 q0 = gia_mul(gia_add(q,vec3(1.0)),vec3(1.0/2.0));\n    gia1x3 q1 = gia_mul(q, vec3(1.0/2.0));\n\n    gia1 xf[3];\n    for (int x = 0; x < 3; ++x) {\n        gia1 yf[3];\n        for (int y = 0; y < 3; ++y) {\n            yf[y] = gia_mix(gia_mix(s[x][y][0], s[x][y][1], q0.z), gia_mix(s[x][y][1], s[x][y][2], q1.z), q.z);\n        }\n        xf[x] = gia_mix(gia_mix(yf[0], yf[1], q0.y), gia_mix(yf[1], yf[2], q1.y), q.y);\n    }    \n    return gia_mix(gia_mix(xf[0], xf[1], q0.x), gia_mix(xf[1], xf[2], q1.x), q.x);    \n}\n\nvoid fetch3x3x3(sampler3D channel, ivec3 t, out mat3 s[3]) {\n    ivec3 ires = textureSize(channel, 0);\n    ivec3 e = ivec3(-1, 0, 1);\n\n    ivec3 tx = (t.xxx + e + ires) % ires;\n    ivec3 ty = (t.yyy + e) % ires;\n    ivec3 tz = (t.zzz + e) % ires;\n\n    for (int x = 0; x < 3; ++x) {\n        for (int y = 0; y < 3; ++y) {\n            for (int z = 0; z < 3; ++z) {\n                s[x][y][z] = texelFetch(channel, ivec3(tx[x],ty[y],tz[z]), 0).x;\n            }\n        }\n    }\n}\n\nvec3 orient(vec3 d) {\n    d.yz = rotate(d.yz, radians(20.0));\n    d.xz = rotate(d.xz, radians(iTime*20.0));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = orient(vec3(0,0,-2.0));\n    vec3 rd = orient(normalize(vec3(uv, 2.0)));\n    \n    mat3 field[3];\n    fetch3x3x3(iChannel0, patch_coord, field);\n    \n    vec3 L = normalize(vec3(-1.0,1.0,-1.0));\n\n    vec3 col = pow(plasma(0.0),vec3(2.2));\n    vec2 range;\n    if (icube(ro, rd, range)) {\n        float t = max(range.x, 0.);\n        vec3 ro0 = ro;\n        #ifdef NORMALIZE_RAY_RANGE\n        ro = ro + rd*t;\n        t = (t - range.x) / (range.y - range.x);\n        rd = rd * (range.y - range.x);\n        #ifdef CENTERED_RAY_RANGE\n        t = t*2.0 - 1.0;\n        ro = ro + rd*0.5;\n        rd = rd*0.5;\n        range = vec2(-1.0, 1.0);\n        #else\n        range = vec2(0.0, 1.0);\n        #endif\n        #else\n        #endif\n        ro += 0.5;\n        #ifdef FOLD_COEFFICIENTS\n        poly6 poly_field = interpolate3x3x3(field, poly(ro, rd)); \n        #endif        \n        #ifdef FOLD_COEFFICIENTS\n        float w = pa_eval(poly_field, t);\n        #else\n        float w = interpolate3x3x3(field, ro + rd*t);\n        #endif\n        #ifndef RENDER_BACKFACE\n        if ((t == range.x) && (w < 0.5)) {\n            col = vec3(0.0);\n        } else\n        #endif\n        {\n            float h = start_width;\n            int steps = 0;\n            for (int i = 0; i < max_iterations; ++i) {\n                steps += 1;\n                #ifdef FOLD_COEFFICIENTS\n                gia1 w = pa_eval(poly_field, gia1(t, vec2(t + h)));\n                #else\n                gia1x3 p = gia_add(gia_mul(gia1(t, vec2(t + h)),rd),ro);\n                gia1 w = gia_interpolate3x3x3(field, p);\n                #endif\n                w = gia_add(w,-0.5);\n                if (abs(w.f0) < sigma) {\n                    vec3 p_t = (ro + rd*t);\n                    vec3 n = interpolate3x3x3_normal(field, p_t);\n                    bool backfacing = dot(rd, n) < 0.0;\n                    if (backfacing) {\n                        n = -n;\n                    }\n                    float a = max(0.0, dot(n, -L)*0.5+0.5);\n                    vec3 albedo = (p_t*0.5+0.5);\n                    #ifndef RENDER_BACKFACE\n                    if (backfacing) {\n                        albedo = vec3(0.0);\n                    }\n                    #endif\n                    col = albedo * (col * 0.5 + a);\n                    float d = max(0.0, dot(ro0,reflect(-L,n))-0.95);\n                    col += albedo*pow(d, 20.0);\n                    break;\n                }\n                float st = ((w.f0 > 0.0)?w.f1[0]:w.f1[1]) - w.f0;\n                float z = -h*w.f0 / st; // extrapolate possible root\n                float rd = (z < 0.0)?h:z;\n                float s = min(h, rd);\n                t += s;\n                if (t >= range.y) {\n                    // no root in interval\n                    break;     \n                }\n                h = grow_rate*s;\n            }            \n            #ifdef SHOW_ITERATION_COST\n            col = plasma(clamp(float(steps) / float(max_iterations),0.0,1.0));\n            #endif\n        }\n    }\n    #ifndef SHOW_ITERATION_COST\n    col *= 2.0;\n    col = ACESFitted(col);\n    // Output to screen\n    fragColor = vec4(pow(col,vec3(1.0/2.2)),1.0);\n    #else\n    fragColor = vec4(col,1.0);\n    #endif\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nbool icube(vec3 ro, vec3 rd, out vec2 range) {\n    vec3 stp = sign(rd) * 0.5;\n    vec3 p = -ro;\n    vec3 h0 = (p - stp) / rd;\n    vec3 h1 = (p + stp) / rd; \n    float near = max(h0.x,max(h0.y,h0.z));\n    float far = min(h1.x,min(h1.y,h1.z));\n    range = vec2(near, far);\n    return (near <= far) && (far >= 0.0);\n}\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c) * p;\n}\n\n// from https://www.shadertoy.com/view/WlfXRN\nvec3 plasma(float t) {\n\n    const vec3 c0 = vec3(0.05873234392399702, 0.02333670892565664, 0.5433401826748754);\n    const vec3 c1 = vec3(2.176514634195958, 0.2383834171260182, 0.7539604599784036);\n    const vec3 c2 = vec3(-2.689460476458034, -7.455851135738909, 3.110799939717086);\n    const vec3 c3 = vec3(6.130348345893603, 42.3461881477227, -28.51885465332158);\n    const vec3 c4 = vec3(-11.10743619062271, -82.66631109428045, 60.13984767418263);\n    const vec3 c5 = vec3(10.02306557647065, 71.41361770095349, -54.07218655560067);\n    const vec3 c6 = vec3(-3.658713842777788, -22.93153465461149, 18.19190778539828);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\n\n// presentation related functions\n\n///////////////////////////////////////////////\n\n// ACES fitted\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGGWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2301, 2301, 2333, 2333, 2404], [2406, 2406, 2438, 2438, 2477], [2479, 2479, 2511, 2511, 2554], [2556, 2556, 2592, 2592, 2660], [2661, 2661, 2697, 2697, 2765], [2767, 2767, 2808, 2808, 2916], [3481, 3481, 3506, 3506, 3537], [3539, 3539, 3565, 3565, 3634], [3636, 3636, 3658, 3658, 3694], [3696, 3696, 3719, 3719, 3756], [3758, 3758, 3789, 3789, 3838], [3840, 3840, 3870, 3870, 3915], [3917, 3917, 3948, 3948, 3987], [3989, 3989, 4023, 4023, 4101], [4103, 4103, 4133, 4133, 4337], [4339, 4339, 4370, 4370, 4447], [4449, 4449, 4481, 4481, 4553], [4555, 4555, 4589, 4589, 4667], [4669, 4669, 4709, 4709, 4841], [4842, 4842, 4880, 4880, 4954], [4956, 4956, 4987, 4987, 5388], [5390, 5390, 5433, 5433, 5858], [5860, 5860, 5906, 5906, 6390], [6392, 6392, 6441, 6441, 6722], [6724, 6724, 6772, 6772, 7294], [7296, 7296, 7356, 7356, 7770], [7772, 7772, 7793, 7793, 7895]], "test": "untested"}
{"id": "stGGDt", "name": "Voronoi Ubung #4", "author": "Yusef28", "description": "more in comments", "tags": ["voronoi"], "likes": 12, "viewed": 283, "published": 3, "date": "1638506162", "time_retrieved": "2024-07-30T18:44:34.343185", "image_code": "/* \nThis Voronoi Shader is based on:\n\n1. An article by IQ: \n    https://iquilezles.org/articles/voronoilines\n2. tomkh's drawing helped it click: \n    https://www.shadertoy.com/view/llG3zy\n3.Shane's Rounded border shader::\n    https://www.shadertoy.com/view/ll3GRM\n*/\n\n\n#define pi acos(-1.)\n#define eps 8./iResolution.y\n\n#define maxPoints 16.\n#define screenSize 4.\n\n#define bg (0.5+0.5*sin(vec3(iTime,iTime*3.+403.,iTime*1.3+902.)))\n#define fg (0.5+0.5*sin(vec3(-iTime*2.1,-iTime*0.9+403.,-iTime+902.)))\n\nvec2 rnd2(vec2 id){\n    return vec2(fract(sin(dot(id,vec2(14.27,74.97)))*54329.34),\n           fract(sin(dot(id+912.35,vec2(49.27,102.74)))*54329.34));\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin2(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\nfloat point(vec2 uv, float r){\n    return smoothstep(r+eps,r-eps,length(uv));\n}\n\nfloat ring(vec2 uv, float r){\n    return smoothstep(eps+0.03, 0., abs(length(uv)-r+0.03));\n}\n\nfloat line(vec2 P, vec2 A, vec2 B, float r){\n    vec2 PA = P-A;\n    vec2 AB = B-A;\n    //dot(AB,P-P3) = 0\n    //dot(AB,P-AB*t)\n    float t = clamp(dot(PA,AB)/dot(AB,AB),0.,1.);\n    return smoothstep(r+eps,r-eps,length(PA-AB*t));\n   \n}\n\n//we are in \"not world/object space\" \n//because we use length on vectors from vec2(0,0.)\n//to get distances\nvec4 voronoi(vec2 uv){\n\n    vec2 st = fract(uv);\n    vec2 stFL = floor(uv);\n    vec2 d = vec2(10.);\n    vec2 A, B=vec2(100.);\n    \n    vec2 mind;\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);//max(abs(coords.x),abs(coords.y));\n        \n        if(c < d.x){\n            d.x = c;\n            d.y = rnd2(stFL+id).y;\n            A = coords;\n            }\n        }\n    }\n    mind = d;\n    \n    d = vec2(10.);\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);//max(abs(coords.x),abs(coords.y));\n        \n        if(length(A-coords) > 0.00){\n            //d.x = c;\n            //d.y = rnd2(stFL+id).y;\n            B.x = smin2(B.x, dot( 0.5*(A+coords), \n                       normalize(coords-A) ), 0.15 );\n            }\n        }\n    }\n\n    return vec4(mind,B);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    uv.x+=iTime*0.5;\n    vec3 light = vec3(1.,0.,2.);\n    vec3 ldir = normalize(vec3(0.)-light);\n    \n    vec3 light2 = vec3(2.,1.,1.);\n    vec3 ldir2 = normalize(vec3(0.)-light2);\n    \n    // Time varying pixel color\n    //vec3(0.1,1.4,2.)\n    uv*=6.;\n    vec4 voronoXY = voronoi(uv);\n    //float edges = smoothstep(0.00,0.01,abs(voronoXY.x-voronoXY.z));\n    vec3 col = 0.5+0.5*sin(vec3(1., 2., 3.)/1.2+ voronoXY.y*pi*200.);\n    col.zy *= rot(.1);\n    \n    col = mix(col, vec3(voronoXY.y,0., voronoXY.y)/4., smoothstep(0.08,0.05,voronoXY.x));\n  //  col += sin(voronoXY.x*40.);\n    //col += vec3(fract(voronoXY.x*8.));\n    //col = mix(col, vec3(0.), smoothstep(0.14,0.13,voronoXY.z));\n   //col = mix(col, vec3(1.), smoothstep(0.05,0.,voronoXY.z));\n    col -= sin(voronoXY.z*90.)/10.;\n    //col = mix(col, vec3(0.), 1.-smoothstep(0.5,0.4,voronoXY.x*1.));\n    col = mix(col, vec3(.9,0.6,0.0), smoothstep(0.3,.5,voronoXY.z)*0.3 );\n    // Output to screen\n    \n    vec3 n = vec3(\n                  voronoi(uv-vec2(eps,0.)).x-voronoi(uv+vec2(eps,0.)).x,\n                  voronoi(uv-vec2(eps,0.).yx).x-voronoi(uv+vec2(eps,0.).yx).x,\n                  voronoi(uv-vec2(eps,0.)).z-voronoi(uv+vec2(eps,0.)).z\n                  );\n         n = normalize(n);//smoothstep(vec3(-1.),vec3(1.),;\n         \n    float diff = max(dot(ldir,n),0.);\n    \n    float spec = pow( max(\n                 dot( reflect(-ldir,n),vec3(0.,0.,1.)),0.),5.);\n    col += diff*0.6+vec3(0.9,0.5,0.1)*spec;\n    \n    \n    \n    float diff2 = max(dot(ldir,n),0.);\n    \n    float spec2 = pow( max(\n                 dot( reflect(-ldir2,n),vec3(0.,0.,1.)),0.),5.);\n    col += diff2*0.8+vec3(0.1,0.5,0.9)*spec2;\n    \n    col = mix(col, vec3(0.), smoothstep(0.1,0.095,voronoXY.z));\n    col = mix(col, vec3(1.,0.4,0.)/2., smoothstep(0.02,0.01,voronoXY.z));\n    col += smoothstep(0.05,0.03,voronoXY.z)*(0.5+0.5*sin(voronoXY.z*10.))/1.5;\n    \n    col /= 1.5;\n    col= pow(col, vec3(1.4));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGGDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[504, 504, 523, 523, 657], [659, 659, 677, 677, 740], [742, 742, 782, 782, 858], [860, 860, 890, 890, 939], [941, 941, 970, 970, 1033], [1035, 1035, 1079, 1079, 1269], [1271, 1379, 1401, 1401, 2602], [2604, 2604, 2661, 2711, 4748]], "test": "untested"}
{"id": "fty3Dd", "name": "Voronoi Ubung #3", "author": "Yusef28", "description": "More in comments", "tags": ["voronoi"], "likes": 8, "viewed": 280, "published": 3, "date": "1638505591", "time_retrieved": "2024-07-30T18:44:35.395371", "image_code": "/* \nThis Voronoi Shader is based on:\n\n1. An article by IQ: \n    https://iquilezles.org/articles/voronoilines\n2. tomkh's drawing helped it click: \n    https://www.shadertoy.com/view/llG3zy\n3.Shane's Rounded border shader::\n    https://www.shadertoy.com/view/ll3GRM\n*/\n\n\n#define pi acos(-1.)\n#define eps 8./iResolution.y\n\n#define maxPoints 16.\n#define screenSize 4.\n\n#define bg (0.5+0.5*sin(vec3(iTime,iTime*3.+403.,iTime*1.3+902.)))\n#define fg (0.5+0.5*sin(vec3(-iTime*2.1,-iTime*0.9+403.,-iTime+902.)))\n\nvec2 rnd2(vec2 id){\n    return vec2(fract(sin(dot(id,vec2(14.27,74.97)))*54329.34),\n           fract(sin(dot(id+912.35,vec2(49.27,102.74)))*54329.34));\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin2(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\nfloat point(vec2 uv, float r){\n    return smoothstep(r+eps,r-eps,length(uv));\n}\n\nfloat ring(vec2 uv, float r){\n    return smoothstep(eps+0.03, 0., abs(length(uv)-r+0.03));\n}\n\nfloat line(vec2 P, vec2 A, vec2 B, float r){\n    vec2 PA = P-A;\n    vec2 AB = B-A;\n    //dot(AB,P-P3) = 0\n    //dot(AB,P-AB*t)\n    float t = clamp(dot(PA,AB)/dot(AB,AB),0.,1.);\n    return smoothstep(r+eps,r-eps,length(PA-AB*t));\n   \n}\n\n//we are in \"not world/object space\" \n//because we use length on vectors from vec2(0,0.)\n//to get distances\nvec4 voronoi(vec2 uv){\n\n    vec2 st = fract(uv);\n    vec2 stFL = floor(uv);\n    vec2 d = vec2(10.);\n    vec2 A, B=vec2(100.);\n    \n    vec2 mind;\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);//max(abs(coords.x),abs(coords.y));\n        \n        if(c < d.x){\n            d.x = c;\n            d.y = rnd2(stFL+id).y;\n            A = coords;\n            }\n        }\n    }\n    mind = d;\n    \n    d = vec2(10.);\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);//max(abs(coords.x),abs(coords.y));\n        \n        if(length(A-coords) > 0.00){\n            //d.x = c;\n            //d.y = rnd2(stFL+id).y;\n            B.x = smin2(B.x, dot( 0.5*(A+coords), \n                       normalize(coords-A) ), 0.03 );\n            }\n        }\n    }\n\n    return vec4(mind,B);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    uv.x+=iTime*0.5;\n    vec3 light = vec3(1.,0.,2.);\n    vec3 ldir = normalize(vec3(0.)-light);\n    \n    vec3 light2 = vec3(2.,1.,1.);\n    vec3 ldir2 = normalize(vec3(0.)-light2);\n    \n    // Time varying pixel color\n    //vec3(0.1,1.4,2.)\n    uv*=4.;\n    vec4 voronoXY = voronoi(uv);\n    //float edges = smoothstep(0.00,0.01,abs(voronoXY.x-voronoXY.z));\n    vec3 col = 0.5+0.5*cos(vec3(0.4,1.2,1.6) + voronoXY.y*pi*2.);\n    //col = mix(col, vec3(0.), smoothstep(0.06,0.05,voronoXY.x));\n  //  col += sin(voronoXY.x*40.);\n    //col += vec3(fract(voronoXY.x*8.));\n    //col = mix(col, vec3(0.), smoothstep(0.14,0.13,voronoXY.z));\n   //col = mix(col, vec3(1.), smoothstep(0.05,0.,voronoXY.z));\n    col -= sin(voronoXY.z*90.)/10.;\n    col += pow(voronoXY.z,2.)*1.;\n    //col = mix(col, vec3(0.), 1.-smoothstep(0.5,0.4,voronoXY.x*1.));\n    col = mix(col, vec3(.9,0.6,0.0), smoothstep(0.3,.5,voronoXY.z)*0.3 );\n    // Output to screen\n    \n    vec3 n = vec3(\n                  voronoi(uv-vec2(eps,0.)).x-voronoi(uv+vec2(eps,0.)).x,\n                  voronoi(uv-vec2(eps,0.).yx).x-voronoi(uv+vec2(eps,0.).yx).x,\n                  voronoi(uv-vec2(eps,0.)).z-voronoi(uv+vec2(eps,0.)).z\n                  );\n         n = normalize(n);//smoothstep(vec3(-1.),vec3(1.),;\n         \n    float diff = max(dot(ldir,n),0.);\n    \n    float spec = pow( max(\n                 dot( reflect(-ldir,n),vec3(0.,0.,1.)),0.),5.);\n    col += diff*0.6+vec3(0.9,0.5,0.1)*spec;\n    \n    \n    \n    float diff2 = max(dot(ldir,n),0.);\n    \n    float spec2 = pow( max(\n                 dot( reflect(-ldir2,n),vec3(0.,0.,1.)),0.),5.);\n    col += diff2*0.8+vec3(0.1,0.5,0.9)*spec2;\n    \n    col = mix(col, vec3(0.), smoothstep(0.1,0.095,voronoXY.z));\n    col = mix(col, vec3(1.,0.6,0.)/2., smoothstep(0.02,0.01,voronoXY.z));\n    \n    col /= 1.6;\n    col= pow(col, vec3(1.4));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fty3Dd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[504, 504, 523, 523, 657], [659, 659, 677, 677, 740], [742, 742, 782, 782, 858], [860, 860, 890, 890, 939], [941, 941, 970, 970, 1033], [1035, 1035, 1079, 1079, 1269], [1271, 1379, 1401, 1401, 2602], [2604, 2604, 2661, 2711, 4643]], "test": "untested"}
{"id": "NlyGWd", "name": "hexagonal grid", "author": "jorge2017a2", "description": "hexagonal grid", "tags": ["hexagonalgrid"], "likes": 16, "viewed": 306, "published": 3, "date": "1638498242", "time_retrieved": "2024-07-30T18:44:36.538316", "image_code": "///-------------image\n//por jorge2017a2-\n//hexagonal grid\n//https://iquilezles.org/articles/distfunctions\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 opRep3D( in vec3 p, in vec3 c )\n\t{ vec3 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3  opRep(vec3 p, vec3 r)\n   { return mod(p,r)-0.5*r; }\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  \n    vec3 p0=p;\n    \n    p= opRep(p, vec3(11.7,9.5,10.0) );\n    p.z=abs(p.z)-3.0;\n    float d1= sdHexPrism(p, vec2(5.0,0.5) );\n    float d2= sdHexPrism(p, vec2(4.5,1.0) );\n    float d1d2=differenceSDF(d1, d2);\n    \n    p.x=abs(p.x)-2.7;\n    p.y=abs(p.y)-4.70;\n    float d3=sdBox( p-vec3(0.0,0.0,-1.0), vec3(0.25,0.25,3.0)  );\n    \n    res =opU3(res, vec3(d1d2,1.0,-1.0));\n    res =opU3(res, vec3(d3,2.0,-1.0));\n \n   \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float spe= spec(  p,  lp, rd, n );\n    float occ = 0.5 + 0.5*n.y;\n\n    float fshadow;\n    if (mObj.blnShadow==true) {fshadow=GetShadow(p,lp);}\n    else {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*occ;\n\n    lin += 1.0*(dif)*occ;\n    lin += 2.5*spe*vec3(1.0);\n    lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545)); \n    return lin;\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n   \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        col= result;\n        col *= 1.0 - pow(d/(MAX_DIST) , 2.5);    \n    }\n   \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n// See: http://filmicgames.com/archives/75\nvec3 Uncharted2ToneMapping(vec3 color)\n{\n    float gamma = 2.2;\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n\tfloat exposure = 0.012;\n\tcolor *= exposure;\n\tcolor = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n\tfloat white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n\tcolor /= white;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 5.0,10.0 ); light_color2 =vec3( 1.0 ); \n \n   vec3 ro;\n   ro=vec3(6.0,15.0,-25.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n   float tt=iTime*2.5;\n   float t1=mod(iTime,4.0);\n   float t2=mod(iTime,8.0);\n   \n   if (t1<t2)\n   {    \n       ro=vec3(6.0,15.0+t,-25.0);\n       rd= rotate_y(rd, radians(tt));\n   }    \n      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    col=exposureToneMapping(2.0, col);\n    col=linear2srgb(col);\n    col+=Uncharted2ToneMapping(col);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlyGWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[567, 567, 599, 599, 683], [684, 728, 775, 775, 802], [803, 803, 846, 846, 873], [874, 874, 922, 922, 950], [951, 989, 1025, 1025, 1070], [1071, 1071, 1110, 1110, 1154], [1155, 1155, 1194, 1194, 1238], [1239, 1239, 1271, 1271, 1296], [1297, 1362, 1396, 1396, 1492], [1493, 1493, 1527, 1527, 1618], [1619, 1619, 1653, 1653, 1744], [1746, 1746, 1780, 1780, 1875], [1878, 1878, 1914, 1914, 2187], [2189, 2189, 2214, 2214, 2685], [2687, 2687, 2711, 2711, 2873], [2875, 2875, 2924, 2924, 3591], [3593, 3593, 3629, 3629, 3874], [3876, 3876, 3903, 3903, 3920], [3922, 3922, 3958, 3958, 4050], [4051, 4051, 4097, 4097, 4222], [4224, 4224, 4298, 4298, 5048], [5050, 5050, 5130, 5130, 5253], [5255, 5255, 5348, 5348, 5450], [5452, 5452, 5483, 5483, 6069], [6071, 6120, 6146, 6146, 6256], [6258, 6258, 6316, 6316, 6368], [6370, 6413, 6453, 6453, 6891], [6893, 6942, 6999, 6999, 7814]], "test": "untested"}
{"id": "NtGGWt", "name": "Noise Blur ", "author": "SnoopethDuckDuck", "description": "a bit dizzying but the effects interesting", "tags": ["e"], "likes": 9, "viewed": 328, "published": 3, "date": "1638490627", "time_retrieved": "2024-07-30T18:44:37.348150", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    float sc = 32.;\n    \n    uv *= 1.5;\n    uv.x += cos(0.01 * uv.y + 0.5 * iTime) * thc(12., -0.3 * iTime + 0.1 * h21(uv));// + thc(1., 6. * length(uv) - iTime);\n    uv.y += sin(0.01 * uv.x + 0.5 * iTime) * ths(12., -0.3 * iTime + 0.1 * h21(uv));\n    \n    vec2 ipos = floor(sc * uv)/sc + 0.;\n    \n    float a = atan(ipos.y, ipos.x);\n    float r = length(ipos);\n    r = log(r) + 0.4 * thc(3.,4. * r + iTime);\n\n    float sc2 = 3. + 2. * cos(3. * a + iTime);\n    \n    \n    float val = 5. * r + a + iTime;\n    vec2 fpos = fract(vec2(thc(1., val), ths(1.,val)) + sc2 * ipos) - 0.5;\n    \n    float d = length(fract(thc(4.,a + iTime) * fpos) - 0.5);\n    float rd = 1. + thc(1., a + 4. * r - iTime);\n    float k = 0.4;\n    float s = 1.-smoothstep(-k,k,rd-d);  \n    //s -= step(d, 0.2 * rd);\n    s = clamp(4. * s * s, 0., 1.);\n    \n    fpos = fract(sc * uv) - 0.5;\n    \n    d = mlength(fpos);\n    rd = min(0.45, 0.1 * thc(40., r + 1.5 * h21(ipos) + iTime) + 0.4 * s);\n    rd *= step(0.11, rd);\n    float s2 = step(d, rd) - smoothstep(-0.5,0.5, rd -d);\n    s2 = clamp(5. * s2 * s2, 0., 1.);\n    s *= 2. * pow(1.-length(uv),4.);\n    vec3 col = s2 * pal(s +10.* h21(ipos) + iTime, vec3(1.), vec3(1.), vec3(1.), vec3(0.,0.33,0.66));\n    \n\n\n\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGGWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 191, 191, 232], [234, 234, 261, 261, 302], [304, 304, 372, 372, 415], [417, 417, 437, 437, 512], [514, 514, 538, 538, 578], [580, 580, 637, 637, 1990]], "test": "untested"}
{"id": "NtG3Wt", "name": "Cowblob", "author": "Jabo", "description": "Moo. The lavalamp of cows. 2D wallpaper inspired by Gateway computer mousepads.", "tags": ["metaball"], "likes": 1, "viewed": 193, "published": 3, "date": "1638488593", "time_retrieved": "2024-07-30T18:44:38.258716", "image_code": "// https://www.shadertoy.com/view/lt3BW2\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\nfloat meta(vec2 p, float r)\n{\n\t//return r / dot(p, p);\n    return length(p)-r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat blob(vec2 p, float t)\n{\n    float smoothness = 0.2 + cos(0.03 * t) * 0.1;\n    vec2 offset = vec2(sin(0.1 * t) * 0.1, cos(0.1 * t) * 0.1);\n    float d = meta(p, 0.3 + cos(0.2 * t) * 0.05);\n    offset = vec2(0.1 + sin(0.3 * t) * 0.1, -0.15 + cos(0.07 * t) * 0.1);\n    d = opSmoothUnion(d, meta(p+offset, 0.32), smoothness);\n    offset = vec2(0.05 - sin(0.2 * t) * 0.05, 0.05 + cos(0.05 * t) * 0.05);\n    d = opSmoothUnion(d, meta(p+offset, 0.3), smoothness);\n    return d;\n}\n\nvec3 mysample(vec2 uv, float t) {\n    // speed me up by increasing\n    t *= 1.0;\n\n    // top right\n    float d = blob(uv - vec2(0.8, 0.3), t); \n    d = opSmoothUnion(d, blob(uv - vec2(0.9, 0.4), t-2.0), 0.3);\n    \n    // top left\n    d = opSmoothUnion(d, blob(uv - vec2(-0.6, 0.65), 1.1 * t-1.0), 0.1); \n    d = opSmoothUnion(d, blob(uv - vec2(-0.8, 0.75), 1.1 * t+2.0), 0.3);\n    \n    // bottom left\n    d = opSmoothUnion(d, blob(uv * vec2(0.5, 1.0) - vec2(-0.25, -0.6), 0.9 * t+5.0), 0.1);\n    d = opSmoothUnion(d, blob(uv * vec2(0.8, 1.1) - vec2(-0.6, -0.7), 0.9 * t-4.0), 0.3);\n    d = opSmoothUnion(d, blob(uv - vec2(0.1, -0.7), 0.8 * t-3.0), 0.3);\n    \n    // border effect\n    d = opSmoothUnion(d, -sdBox(uv, vec2(0.95, 0.55)), 0.15);\n    \n    \n    if(iMouse.z > 0.001) {\n        // non AA original\n        vec3 col = vec3(min(\n            step(0.000001, d),\n            smoothstep(-0.5, 0.2, d)\n        ));\n        return col;\n    }\n    \n    // AA smoothstep\n    float e = 0.99/iResolution.y;\n    float c = smoothstep(-e,e, d);\n    c = min(c, smoothstep(-0.5, 0.2, d));\n    return vec3(c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;    \n    // shift to 0.0 center\n    uv -= 0.5;\n    // squish for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;    \n    \n    // pixel color\n    vec3 col = mysample(uv, iTime);\n\n    // Output to screen\n    fragColor = pow(vec4(col, 1.0), vec4(1./2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtG3Wt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 41, 93, 93, 169], [171, 171, 200, 225, 251], [253, 253, 290, 290, 370], [372, 372, 401, 401, 850], [852, 852, 885, 918, 1951], [1953, 1953, 2010, 2060, 2362]], "test": "untested"}
{"id": "stKGDc", "name": "tiny voxels", "author": "flockaroo", "description": "...originally done in twigl.app (266 chars there)\n[url]https://twitter.com/flockaroo/status/1466494447525539843[/url]", "tags": ["voxel", "golfing", "tinycode"], "likes": 25, "viewed": 642, "published": 3, "date": "1638480142", "time_retrieved": "2024-07-30T18:44:39.111436", "image_code": "// created by florian berger (flockaroo) - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// tiny voxels\n//\n// ...not quite as minimal as on twigl (266 chars)\n// https://twitter.com/flockaroo/status/1466494447525539843\n//\n\n/*\nvoid mainImage( out vec4 o, in vec2 F )\n{\n#define C(p) max(c=abs(p),max(c.y,c.z)).x\n#define L(N) for(int i=0;i<N;i++){\n// had to trick a bit on the rotation - only diagonal rotation (full blown up rotate/axis func is quite big)\n   //vec3 e=cos(iTime-vec3(0,1.6,-1.6));e.yz/=sqrt(3.); mat3 R=mat3(e,e.zxy,e.yzx)+(1.-e.x)/3.;\n   float e=cos(iTime),a=sin(iTime)*.58; mat3 R=mat3(e,a,-a,-a,e,a,a,-a,e)+(1.-e)/3.;\n   vec3 p=R*vec3(0,0,40),v=R*vec3(F/iResolution.y-.5,1),m,c,d;\n   L(99)\n       d.x=9.;\n       L(8)\n           m=floor(p)+vec3(i&1,i/2&1,i/4&1);\n           d=min(d,C(R*m)>9.?.5:C(p-m)-.4);\n       }\n       p-=d.x*v;\n   }\n   o=abs(p*R).zzzz*.07;\n}\n*/\n\n// fabrice's breakdown - minus another 6 chars (vec3 d now float (prev e))\n#define C(p) max(c = abs(p), max(c.y, c.z)).x//\n#define L for(int i=0; i++ < \n\nvoid mainImage(out vec4 o, vec2 F) \n{\n    float d = cos(iTime), a = sin(iTime) * .58;\n    mat3 R = mat3(d, a, -a, -a, d, a, a, -a, d) + (1. - d) / 3.;\n    vec3 p = R * vec3(0, 0, 40), \n    v = R * vec3(F / iResolution.y - .5, 1), m, c;\n    L 99; p -= d * v ) {\n        d = 9.;\n        L 8; d = min(d, C(R * m) > 9. ? .5 : C(p - m) - .4) ) \n          m = floor(p) + vec3(i&1,i/2&1,i/4&1);\n    }\n\n    //o += abs(p * R).z * .07 - o;\n    o = abs(p * R).zzzz * .07;\n    // bit longer, but i also like this one - gives some central gradent on the depth field\n    //o += abs(dot(p,v)) * .07 - o;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKGDc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [], "test": "untested"}
{"id": "7lV3W3", "name": "islandshapes3d", "author": "Del", "description": "same as the 2d version...", "tags": ["sdf", "bezier", "island", "extrude"], "likes": 7, "viewed": 336, "published": 3, "date": "1638468367", "time_retrieved": "2024-07-30T18:44:40.180577", "image_code": "// island 3d (extrude) - added the colouring from the 2d version + 3 islands\n//\n// This is basically a fork of the Original SDF Quadratic Bzier Shape here: https://www.shadertoy.com/view/ftdGDB\n// slightly modified to produce random Island shapes from a vec2 seed value.\n// Golf anyone? :)\n\n// Author: Thomas Stehle\n// Title: SDF Quadratic Bzier Shape\n//\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// Signed distance function for a shape made out of quadratic\n// Bzier curves in the tradition of iq's series such as this\n// one: https://www.shadertoy.com/view/MlKcDD.\n//\n// The only real contribution of this shader is that it postpones\n// the call to the costly Bzier SDF up until the point it has\n// identified the closest segment of the control polygon.\n// So instead of iterating over all Bzier curves, we iterate\n// over the line segments of the control polygon and identify the\n// closest segment. We then call the Bzier SDF for this segment\n// only. This approach is correct since quadratic Bzier curves\n// are always contained in the triangle formed by its three\n// control points.\n// Constants\nconst int CAPACITY = 8; // Control polygon capacity\nconst float INF   = 1.0 / 0.0;\nconst float SQRT3 = 1.732050807568877;\n\n// Cross-product of two 2D vectors\nfloat cross2(in vec2 a, in vec2 b) {\n    return a.x*b.y - a.y*b.x;\n}\n\n// Clamp a value to [0, 1]\nfloat saturate(in float a) {\n    return clamp(a, 0.0, 1.0);\n}\nvec3 saturate(in vec3 a) {\n    return clamp(a, 0.0, 1.0);\n}\n\n// Minimum of the absolute of two values\nfloat abs_min(float a, float b) {\n    return abs(a) < abs(b) ? a : b;\n}\n\n// SDF for a line segment\nfloat sdf_line(in vec2 p, in vec2 a, in vec2 b) {\n    float h = saturate(dot(p - a, b - a) /\n                       dot(b - a, b - a));\n    return length(p - a - h * (b - a));\n}\n\n// Like the SDF for a line but partitioning space into positive and negative\nfloat sdf_line_partition(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = saturate(dot(pa, ba) / dot(ba, ba));\n    vec2 k = pa - h * ba;\n    vec2 n = vec2(ba.y, -ba.x);\n    return (dot(k,n) >= 0.0) ? length(k) : -length(k);\n}\n\n// Signed distance to a quadratic Bzier curve\n// Mostly identical to https://www.shadertoy.com/view/MlKcDD\n// with some additions to combat degenerate cases.\nfloat sdf_bezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    const float EPSILON = 1e-3;\n    const float ONE_THIRD = 1.0 / 3.0;\n\n    // Handle cases where points coincide\n    bool abEqual = all(equal(A, B));\n    bool bcEqual = all(equal(B, C));\n    bool acEqual = all(equal(A, C));\n    \n    if (abEqual && bcEqual) {\n        return distance(pos, A);\n    } else if (abEqual || acEqual) {\n        return sdf_line_partition(pos, B, C);\n    } else if (bcEqual) {\n        return sdf_line_partition(pos, A, C);\n    }\n    \n    // Handle colinear points\n    if (abs(dot(normalize(B - A), normalize(C - B)) - 1.0) < EPSILON) {\n        return sdf_line_partition(pos, A, C);\n    }\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) * ONE_THIRD;\n    float kz = kk * dot(d,a);\n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if (h >= 0.0) {\n        // One root\n        h = sqrt(h);\n        vec2 x = 0.5 * (vec2(h, -h) - q);\n        vec2 uv = sign(x) * pow(abs(x), vec2(ONE_THIRD));\n        float t = saturate(uv.x + uv.y - kx) + EPSILON;\n        vec2 q = d + (c + b*t) * t;\n        res = dot(q, q);\n        sgn = cross2(c + 2.0*b*t, q);\n    } else {\n        // Three roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0)) * ONE_THIRD;\n        float m = cos(v);\n        float n = sin(v) * SQRT3;\n        vec3 t = saturate(vec3(m+m,-n-m,n-m)*z-kx) + EPSILON;\n        vec2 qx = d + (c+b*t.x)*t.x;\n        float dx = dot(qx, qx);\n        float sx = cross2(c+2.0*b*t.x, qx);\n        vec2 qy = d + (c+b*t.y)*t.y;\n        float dy = dot(qy, qy);\n        float sy = cross2(c+2.0*b*t.y, qy);\n        res = (dx < dy) ? dx : dy;\n        sgn = (dx < dy) ? sx : sy;\n    }\n    \n    return sign(sgn) * sqrt(res);\n}\n\n// Signed distance to a segment of a control polygon\nfloat sdf_control_segment(in vec2 p, in vec2 A, in vec2 B, in vec2 C) {\n    return abs_min(sdf_line(p, A, B), sdf_line(p, B, C));\n}\n\n\n// Signed distance to a quadratic Bezier shape made from a given control polygon\nfloat sdf_bezier_shape(in vec2 p, in vec2 controlPoly[CAPACITY])\n{\n    // Determine closest segment in control polygon\n    vec2 closest[3];\n    \n    // Signed distance to a control polygon\n    // Identifies and returns distance to the closest segment.\n    // Cycle through segments and track the closest\n    float d = INF;\n    float ds = 0.0;\n\n    // First n-2 segments\n    vec2 c = 0.5 * (controlPoly[0] + controlPoly[1]);\n    vec2 prev = c;\n    for (int i = 1; i < CAPACITY - 1; ++i) {\n        prev = c;\n        c = 0.5 * (controlPoly[i] + controlPoly[i+1]);\n        ds = sdf_control_segment(p, prev, controlPoly[i], c);\n        if (abs(ds) < abs(d)) {\n            closest[0] = prev;\n            closest[1] = controlPoly[i];\n            closest[2] = c;\n            d = ds;\n        }\n    }\n\n    // Last-but-one segment\n    prev = c;\n    c = 0.5 * (controlPoly[CAPACITY-1] + controlPoly[0]);\n    ds = sdf_control_segment(p, prev, controlPoly[CAPACITY-1], c);\n    if (abs(ds) < abs(d)) {\n        closest[0] = prev;\n        closest[1] = controlPoly[CAPACITY-1];\n        closest[2] = c;\n        d = ds;\n    }\n\n    // Last segment\n    prev = c;\n    c = 0.5 * (controlPoly[0] + controlPoly[1]);\n    ds = sdf_control_segment(p, prev, controlPoly[0], c);\n    if (abs(ds) < abs(d)) {\n        closest[0] = prev;\n        closest[1] = controlPoly[0];\n        closest[2] = c;\n        d = ds;\n    }\n    // d = distance to outer control polygon\n    // Refine by determining actual distance to curve of closest segment\n    return sdf_bezier(p, closest[0], closest[1], closest[2]);\n}\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat remap(float s, float a1, float a2, float b1, float b2)\n{\n    return b1 + (s-a1)*(b2-b1)/(a2-a1);\n}\n\n// min/max polynomial\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdIsland(vec2 p,vec2 seed)\n{\n    // Control polygon shape\n    vec2 controlPoints[CAPACITY];\n    \n    float tt1 = seed.x;\n    float tt2 = seed.y;\n    for (int i=0;i<8;i++)\n    {\n        float a = ((-6.28)/8.0) * float(i);\n        float x = sin(a)*1.4;\n        float y = cos(a);\n        vec2 pos = vec2(x,y);\n        vec2 hash = hash2(pos+vec2(tt1*0.15,tt1*0.35));\n        hash = 0.5+sin(tt2+sin(hash*151.45))*0.5;\n        float rad = 0.65+(hash.x*0.6);\n        rad -= hash.y*0.55;\n        controlPoints[i] = vec2(x,y)*rad;\n    }\n    // Distance to shape\n    return sdf_bezier_shape(p, controlPoints);\n}\n\nfloat opExtrusion( in vec3 p, float dd, in float h )\n{\n    float d = dd;\n    vec2 w = vec2( d, abs(p.y) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nvec3 GetWater(vec2 p)\n{\n    const vec3 col = vec3(0.02,.3,.55);\n    const mat3 _m = mat3(-2.0,-1.0,2.0, 3.0,-2.0,1.0, 1.0,2.0,2.0);\n    vec4 d = vec4(iDate*.22);\n    d.xy = p;\n    d.xyw *=_m*.5;\n    float v1 = length(.5-fract(d.xyw));\n    d.xyw *=_m*.4;\n    float v2 = length(.5-fract(d.xyw));\n    d.xyw *=_m*.3;\n    float v3 = length(.5-fract(d.xyw));\n    float v = pow(min(min(v1,v2),v3), 7.)*15.;\n    return col+vec3(v,v,v);\n}\n\nfloat basemat;\n\nvec3 GetCol(float mat,vec3 pos)\n{\n    if (mat<=1.0)\n    {\n        float sandline = abs(sin(fract(22.0*(pos.z+sin(pos.x*6.0)*0.02))));\n        sandline = (1.0-step(sandline,0.5))*0.05;\n        vec3 sandcol =  vec3(0.9,0.85,0.2);  \n        return sandcol+=sandcol*sandline;    \n    }\n    else if (mat<=2.0)\n    {\n        float grassline = 0.5+sin(fract(5.0*(pos.x-pos.z*1.2))*6.28)*0.5;\n        grassline = smoothstep(0.35,0.65,grassline)*0.4;\n        vec3 grasscol = vec3(0.05,0.6,0.05);\n        return grasscol += grasscol*grassline;\n    }\n    return GetWater(pos.xz);\n}\n\nfloat map( in vec3 pos )\n{\n    vec2 seed = vec2(floor(iTime*0.25),fract(iTime*0.2)*6.28);\n    float dd1 = sdIsland(pos.xz,seed);\n    \n    float height = 0.05;\n    float d1 = opExtrusion(pos,dd1,height)-0.04;\n\n    height = 0.025;\n    float d2 = opExtrusion(pos+vec3(0.0,0.1,0.0),dd1-0.2,height)-0.02;\n    \n    basemat = 0.5;\n    if (d2>d1)\n      basemat = 1.5;\n    d1 = smin(d1,d2,0.05);\n    \n    float wd = pos.y+0.15;\n    \n    if (wd<d1)\n        basemat=2.5;\n    \n    d1 = smin(d1,wd,0.25);\n    \n    return d1;\n}\n\n\n    \n// https://iquilezles.org/articles/normalsSDF\n#define ZERO (min(iFrame,0))\n\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n//        n += e*map(pos+0.0005*e);\n        n += e*map(pos+0.05*e);\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n    \n    \n#define AA 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n        float an =0.0;//0.25*iTime;\n    float hh = mix(0.75,1.5, 0.5+sin(iTime)*0.5);\n    \n\tvec3 ro = vec3( 3.*cos(an), hh, 3.*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 20.0;\n        float t = 0.0;\n        for( int i=0; i<128; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        vec3 col = vec3(0.4,0.5,0.9);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            vec3 basecol = GetCol(basemat,pos);\n            col = vec3(0.1,0.1,0.1)*amb + basecol*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lV3W3.jpg", "access": "api", "license": "mit", "functions": [[2243, 2278, 2314, 2314, 2346], [2348, 2375, 2403, 2403, 2436], [2437, 2437, 2463, 2463, 2496], [2498, 2539, 2572, 2572, 2610], [2612, 2638, 2687, 2687, 2815], [2817, 2894, 2953, 2953, 3161], [3163, 3323, 3387, 3387, 5305], [5307, 5360, 5431, 5431, 5491], [5494, 5575, 5641, 5693, 7142], [7144, 7144, 7166, 7197, 7287], [7289, 7289, 7351, 7351, 7393], [7395, 7417, 7458, 7458, 7547], [7549, 7549, 7583, 7612, 8156], [8158, 8158, 8212, 8212, 8325], [8327, 8327, 8350, 8350, 8756], [8774, 8774, 8807, 8807, 9344], [9346, 9346, 9372, 9372, 9859], [9943, 9943, 9975, 9975, 10577]], "test": "error"}
{"id": "stK3W3", "name": "islandshapes", "author": "Del", "description": "This is basically a fork of the Original SDF Quadratic Bezier Shape here: https://www.shadertoy.com/view/ftdGDB\n -  slightly modified to produce random Island shapes from a vec2 seed value - base shape seed changes every 4 seconds\n", "tags": ["sdf", "bezier", "island", "shape"], "likes": 7, "viewed": 281, "published": 3, "date": "1638466158", "time_retrieved": "2024-07-30T18:44:41.054241", "image_code": "// This is basically a fork of the Original SDF Quadratic Bzier Shape here: https://www.shadertoy.com/view/ftdGDB\n// slightly modified to produce random Island shapes from a vec2 seed value.\n// Golf anyone? :)\n\n// Author: Thomas Stehle\n// Title: SDF Quadratic Bzier Shape\n//\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// Signed distance function for a shape made out of quadratic\n// Bzier curves in the tradition of iq's series such as this\n// one: https://www.shadertoy.com/view/MlKcDD.\n//\n// The only real contribution of this shader is that it postpones\n// the call to the costly Bzier SDF up until the point it has\n// identified the closest segment of the control polygon.\n// So instead of iterating over all Bzier curves, we iterate\n// over the line segments of the control polygon and identify the\n// closest segment. We then call the Bzier SDF for this segment\n// only. This approach is correct since quadratic Bzier curves\n// are always contained in the triangle formed by its three\n// control points.\n// Constants\nconst int CAPACITY = 8; // Control polygon capacity\nconst float INF   = 1.0 / 0.0;\nconst float SQRT3 = 1.732050807568877;\n\n// Cross-product of two 2D vectors\nfloat cross2(in vec2 a, in vec2 b) {\n    return a.x*b.y - a.y*b.x;\n}\n\n// Clamp a value to [0, 1]\nfloat saturate(in float a) {\n    return clamp(a, 0.0, 1.0);\n}\nvec3 saturate(in vec3 a) {\n    return clamp(a, 0.0, 1.0);\n}\n\n// Minimum of the absolute of two values\nfloat abs_min(float a, float b) {\n    return abs(a) < abs(b) ? a : b;\n}\n\n// SDF for a line segment\nfloat sdf_line(in vec2 p, in vec2 a, in vec2 b) {\n    float h = saturate(dot(p - a, b - a) /\n                       dot(b - a, b - a));\n    return length(p - a - h * (b - a));\n}\n\n// Like the SDF for a line but partitioning space into positive and negative\nfloat sdf_line_partition(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = saturate(dot(pa, ba) / dot(ba, ba));\n    vec2 k = pa - h * ba;\n    vec2 n = vec2(ba.y, -ba.x);\n    return (dot(k,n) >= 0.0) ? length(k) : -length(k);\n}\n\n// Signed distance to a quadratic Bzier curve\n// Mostly identical to https://www.shadertoy.com/view/MlKcDD\n// with some additions to combat degenerate cases.\nfloat sdf_bezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    const float EPSILON = 1e-3;\n    const float ONE_THIRD = 1.0 / 3.0;\n\n    // Handle cases where points coincide\n    bool abEqual = all(equal(A, B));\n    bool bcEqual = all(equal(B, C));\n    bool acEqual = all(equal(A, C));\n    \n    if (abEqual && bcEqual) {\n        return distance(pos, A);\n    } else if (abEqual || acEqual) {\n        return sdf_line_partition(pos, B, C);\n    } else if (bcEqual) {\n        return sdf_line_partition(pos, A, C);\n    }\n    \n    // Handle colinear points\n    if (abs(dot(normalize(B - A), normalize(C - B)) - 1.0) < EPSILON) {\n        return sdf_line_partition(pos, A, C);\n    }\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) * ONE_THIRD;\n    float kz = kk * dot(d,a);\n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if (h >= 0.0) {\n        // One root\n        h = sqrt(h);\n        vec2 x = 0.5 * (vec2(h, -h) - q);\n        vec2 uv = sign(x) * pow(abs(x), vec2(ONE_THIRD));\n        float t = saturate(uv.x + uv.y - kx) + EPSILON;\n        vec2 q = d + (c + b*t) * t;\n        res = dot(q, q);\n        sgn = cross2(c + 2.0*b*t, q);\n    } else {\n        // Three roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0)) * ONE_THIRD;\n        float m = cos(v);\n        float n = sin(v) * SQRT3;\n        vec3 t = saturate(vec3(m+m,-n-m,n-m)*z-kx) + EPSILON;\n        vec2 qx = d + (c+b*t.x)*t.x;\n        float dx = dot(qx, qx);\n        float sx = cross2(c+2.0*b*t.x, qx);\n        vec2 qy = d + (c+b*t.y)*t.y;\n        float dy = dot(qy, qy);\n        float sy = cross2(c+2.0*b*t.y, qy);\n        res = (dx < dy) ? dx : dy;\n        sgn = (dx < dy) ? sx : sy;\n    }\n    \n    return sign(sgn) * sqrt(res);\n}\n\n// Signed distance to a segment of a control polygon\nfloat sdf_control_segment(in vec2 p, in vec2 A, in vec2 B, in vec2 C) {\n    return abs_min(sdf_line(p, A, B), sdf_line(p, B, C));\n}\n\n// Signed distance to a control polygon\n// Identifies and returns distance to the closest segment.\nfloat sdf_control_polygon(in vec2 p, in vec2 controlPoly[CAPACITY], in int controlPolySize, out vec2 closest[3]) {\n    // Cycle through segments and track the closest\n    float d = INF;\n    float ds = 0.0;\n\n    // First n-2 segments\n    vec2 c = 0.5 * (controlPoly[0] + controlPoly[1]);\n    vec2 prev = c;\n    for (int i = 1; i < controlPolySize - 1; ++i) {\n        prev = c;\n        c = 0.5 * (controlPoly[i] + controlPoly[i+1]);\n        ds = sdf_control_segment(p, prev, controlPoly[i], c);\n        if (abs(ds) < abs(d)) {\n            closest[0] = prev;\n            closest[1] = controlPoly[i];\n            closest[2] = c;\n            d = ds;\n        }\n    }\n\n    // Last-but-one segment\n    prev = c;\n    c = 0.5 * (controlPoly[controlPolySize-1] + controlPoly[0]);\n    ds = sdf_control_segment(p, prev, controlPoly[controlPolySize-1], c);\n    if (abs(ds) < abs(d)) {\n        closest[0] = prev;\n        closest[1] = controlPoly[controlPolySize-1];\n        closest[2] = c;\n        d = ds;\n    }\n\n    // Last segment\n    prev = c;\n    c = 0.5 * (controlPoly[0] + controlPoly[1]);\n    ds = sdf_control_segment(p, prev, controlPoly[0], c);\n    if (abs(ds) < abs(d)) {\n        closest[0] = prev;\n        closest[1] = controlPoly[0];\n        closest[2] = c;\n        d = ds;\n    }\n    \n    // Return distance\n    return d;\n}\n\n// Signed distance to a quadratic Bezier shape made from a given control polygon\nfloat sdf_bezier_shape(in vec2 p, in vec2 controlPoly[CAPACITY])\n{\n    // Determine closest segment in control polygon\n    vec2 closest[3];\n    sdf_control_polygon(p, controlPoly, CAPACITY, closest);\n\n    // Refine by determining actual distance to curve of closest segment\n    return sdf_bezier(p, closest[0], closest[1], closest[2]);\n}\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat remap(float s, float a1, float a2, float b1, float b2)\n{\n    return b1 + (s-a1)*(b2-b1)/(a2-a1);\n}\n\nfloat sdIsland(vec2 p,vec2 seed)\n{\n    // Control polygon shape\n    vec2 controlPoints[CAPACITY];\n    \n    float tt1 = seed.x; //floor(iTime*0.25);\n    float tt2 = seed.y; //iTime;\n    for (int i=0;i<8;i++)\n    {\n        float a = ((-6.28)/8.0) * float(i);\n        if (iMouse.z>0.5)\n            a = -a; // invert\n        float x = sin(a)*1.4;\n        float y = cos(a);\n        vec2 pos = vec2(x,y);\n        vec2 hash = hash2(pos+vec2(tt1*0.15,tt1*0.35));\n        hash = 0.5+sin(tt2+sin(hash*151.45))*0.5;\n        float rad = 0.65+(hash.x*0.6);\n        rad -= hash.y*0.55;\n        controlPoints[i] = vec2(x,y)*rad;\n    }\n    \n\n    // Distance to shape\n    float d = sdf_bezier_shape(p, controlPoints);\n    return d;\n}\n\nfloat mysmooth(float v)\n{\n    //return step(v,0.0);\n    return 1.0-smoothstep(0.0,0.02,v);\n    return v;\n}\n\nvec3 GetWater(vec2 p)\n{\n    const vec3 col = vec3(0.02,.3,.55);\n    const mat3 _m = mat3(-2.0,-1.0,2.0, 3.0,-2.0,1.0, 1.0,2.0,2.0);\n    \n    vec4 d = vec4(iDate*.22);\n    d.xy = p;\n\n    d.xyw *=_m*.5;\n    float v1 = length(.5-fract(d.xyw));\n    d.xyw *=_m*.4;\n    float v2 = length(.5-fract(d.xyw));\n    d.xyw *=_m*.3;\n    float v3 = length(.5-fract(d.xyw));\n    \n    \n    float v = pow(min(min(v1,v2),v3), 7.)*15.;\n    return col+vec3(v,v,v);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec2 seed = vec2(floor(iTime*0.25),fract(iTime*0.2)*6.28);\n    float d = sdIsland(p*1.1,seed);\n\n    vec3 watercol = GetWater(p*2.0);\n    vec3 col = watercol;\n\n    float sandwobble = 0.5+sin(p.x*4.0+p.y*7.0+length(p)*4.0)*0.5;\n    \n    vec3 shallow = (vec3(0.1,0.1,0.05)+watercol)*0.6;\n    float d3 = 1.0-smoothstep(0.0,0.8,d-0.3-(0.15*sandwobble));\n    col = mix(col,shallow,d3); \n    \n    float d2 = mysmooth(d-0.1-(0.05*sandwobble));\n\n    float sandline = abs(sin(fract(22.0*(p.y+sin(p.x*6.0)*0.02))));\n    sandline = (1.0-step(sandline,0.5))*0.05;\n    vec3 sandcol =  vec3(0.9,0.85,0.2);  \n    sandcol+=sandcol*sandline;\n    col = mix(col,sandcol,d2);\n    \n    \n\n    float grassline = 0.5+sin(fract(5.0*(p.x-p.y*1.2))*6.28)*0.5;\n    grassline = smoothstep(0.35,0.65,grassline)*0.4;\n    float d1 =mysmooth(d);\n    vec3 grasscol = vec3(0.05,0.6,0.05);\n    grasscol += grasscol*grassline;\n    col = mix(col,grasscol,d1);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stK3W3.jpg", "access": "api", "license": "mit", "functions": [[2163, 2198, 2234, 2234, 2266], [2268, 2295, 2323, 2323, 2356], [2357, 2357, 2383, 2383, 2416], [2418, 2459, 2492, 2492, 2530], [2532, 2558, 2607, 2607, 2735], [2737, 2814, 2873, 2873, 3081], [3083, 3243, 3307, 3307, 5225], [5227, 5280, 5351, 5351, 5411], [5413, 5512, 5626, 5678, 6832], [6834, 6915, 6981, 7033, 7252], [7254, 7254, 7276, 7307, 7397], [7399, 7399, 7461, 7461, 7503], [7505, 7505, 7539, 7568, 8221], [8223, 8223, 8248, 8274, 8329], [8331, 8331, 8354, 8354, 8776], [8778, 8778, 8833, 8858, 9906]], "test": "error"}
{"id": "flVGDc", "name": "fork -bars", "author": "jorge2017a2", "description": "//http://hintz.bplaced.net/en/2013/webgl/bars/", "tags": ["bars", "fork"], "likes": 3, "viewed": 217, "published": 3, "date": "1638458974", "time_retrieved": "2024-07-30T18:44:42.007692", "image_code": "//fork -bars\n//http://hintz.bplaced.net/en/2013/webgl/bars/\n//modificado por jorge2017a2\nvec2 position;\nvec4 color;\nfloat barsize = 0.215;\nfloat barsangle ;\n\nvec4 bar(float pos, float r, float g, float b)\n{\treturn max(0.0, 1.0 - abs(pos - position.y) / barsize) * vec4(r, g, b, 1.0); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float c, s;\n    mat2 R;\n\n     c = cos(iTime/2.0);\n     s = sin(iTime/2.0);\n     R = mat2(c,-s,s,-c);\n     barsangle = 200.0*sin(iTime*0.001);\n    position = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.xx;\n\tposition = 2.0*position*R;\n    \n    float t1=mod(iTime,4.0);\n    float t2=mod(iTime,8.0);\n    \n    if (t1<t2)\n        uv=position;\n    \n    vec4 col =vec4(0.0);\n    float t = iTime*0.5;\n    \n    uv.x+=0.2;\n    col+= bar(uv.x-0.1, 1.0, 0.0, 0.0);\n    col+= bar(uv.x-0.3, 0.0, 1.0, 0.0);\n    col+= bar(uv.x-0.6, 1.0, 1.0, 0.0);\n    col+= bar(uv.x-0.9, 0.0, 0.0, 1.0);\n    col+= bar(uv.x-1.15, 0.0, 1.0, 1.0);\n    col+= bar(uv.x-1.35, 1.0, 0.0, 1.0);\n    col=pow(col,vec4(0.454545));\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVGDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 206, 206, 285], [287, 287, 344, 394, 1178]], "test": "untested"}
{"id": "7ty3zc", "name": "spqr: tube 3", "author": "Fahrenheitrequited", "description": "a", "tags": ["a"], "likes": 5, "viewed": 248, "published": 3, "date": "1638433961", "time_retrieved": "2024-07-30T18:44:43.044919", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CorrodedBeasts.glsl\n*/\n\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat PI = acos(-1.0);\n//float gid;\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat getId(float t) {\n   return fract(sin(t * 478.129) * 992.421);\n}\n\nfloat box( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return max(q.x,q.y);\n}\n\n\nvec2 replim( in vec2 p, in float c, in vec2 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\nfloat m1(vec2 uv) {\n  \n \n  \n  \n  float t = iTime ;\n  float a = 3.141592/4.;\n  \n  \n  float thing = 10000.;\n  \n  for( float i = 0.; i <5.; i++){\n  \n    uv *= rot(i * a *2.);\n   \n    uv = abs(uv); \n    uv -= vec2(2,7);\n    uv = -abs(uv);\n   \n    \n    float x1 =  box(uv, vec2(1,1));\n    float x2 =  box(uv + vec2(2,11), vec2(1.,5.));\n    float x3 =  box(uv + vec2(14,14), vec2(.1,53.));\n    vec2 q = replim(uv, 10., vec2(11,2));\n    float x4 =  box(q , vec2(.2,2.));\n   \n    float x = min(x4,min(x1,(min(x2,x3))));\n    \n    thing = min(thing,x);\n   \n    \n \n\n  }\n  return thing ;\n\n}\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hash21 (vec2 uv) {\n  return (fract(sin(uv.x * 1913.7361) + uv.y) * 4440.321);\n\n}\n\nfloat a = 3.141592;\nfloat glow = 0.;\nfloat m2(vec2 uv,float id) {\n\n\n  float dom = 20.;\n\n  uv = mod(uv,dom) - dom/2.;  \n\n \n  vec2 uv2 = uv;\n  float q = 1.4 ;\n  \n  float z = 10000.;\n  vec2 off = vec2(58,20);\n\n  for (float i = 0.; i <5.; i++) {\n    off *= rot(i/4.);\n   \n    uv.x *= q;\n\n    uv *= rot(a/2.);\n    \n    float a1 = m1(uv  + off );\n\n    z = min(z,a1) ;\n  }\n  vec2 arm = vec2(24);\n  arm *= rot(iTime * 7.1);\n  float u = length(uv2  + arm) -2.;\n  \n  //glow += .01/(.02 + pow(u,4.5));\n \n  return z/1.4;\n}\n\n\n\n\n\nfloat k1(vec2 p, float f1) {\n    vec2 pa = p;\n\n    float pi = 3.141592;\n    float z = 100000.;\n    for ( float j = 0.; j < 5.; j++) {\n        p = p.x > p.y ? p : p.yx;\n        for ( float i=0.; i < 3.; i++) {\n           //p = replim(p,6., vec2(0,50.));\n\n           p.x = abs(p.x) - 30. * f1 * f1;\n           float a= box(p,vec2(3,51) );\n           z = min(z,a);\n           vec2 pa = replim(pa,25., vec2(2. + f1));\n           float y = box(pa, vec2(8. ));\n           z = min(z,y);\n           p *= 1.12 + f1/3. ;\n           p += vec2(-46,0);\n           p *= rot(pi/2.);\n      \n        }\n    }\n \n    float c = box(pa, vec2(10,100));\n    \n   return min(z,c) ;\n \n}\nfloat pi = 3.141592;\nfloat k2(vec2 p, float f1){\n\n    float z = 10000.;\n    vec2 offset = vec2(200.,0) + vec2(45) * f1;\n   \n    for ( float i =1.; i < 3.; i++ ) {\n        //p = replim(p,8., vec2(0,10.));\n        float a = k1(p * 1.2 +vec2(0,70.) - vec2(17,29)  * 2.3, f1);\n        float b = k1(p + vec2(70,60) - vec2(50), f1);\n        float c = k1(p * 1.5+vec2(80,11), f1);\n\n        float d = a;//min(a,min(b,c));\n        z = min(z,d);\n        z = max(z, -b);\n        z = min(z,c);\n        p *= 1.5;\n        \n        offset *= rot(pi/(2.));\n        p += offset / pow(.3 + f1 * 3.,i );\n        p *= rot((pi/2.));\n       \n        \n    }\n     \n       \n       return z;\n}\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nconst float domain_width = 290.;\nconst float domain_height = 27.;//77.;\nvec3 domain = vec3(domain_width,domain_height,domain_width) ;\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\n\nfloat decal(vec3 p, vec3 domain) {\n\n// ink\n  // return m2(uv);\n  //vec2 q = kifs(p + pow(kifs(p),vec2(1. + sin(iTime))*.5+.5) );\n  \n  \n  vec3 id = floor(p/domain);\n  float f1 = fract(hash31(id) + tick(iTime * .13 ));\n  \n  p = mod(p,domain) - domain/2.;\n  //float one =  k1(kifs(p * f1 + kifs(p * f1)), f1);\n  //float one =  k1(kifs(p + kifs(p) + kifs(kifs(p))), f1);\n  //float one = k1(kifs(p + kifs(p)),f1);\n  float one = k2(p.xz,f1);\n  float two = box(p.xz, vec2(300.));\n  float final = max(one,two);\n  return final;\n}\n\n\n\n\n\nfloat tor(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\nvec3 replim( in vec3 p, in float c, in vec3 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\n\n\nvec3 moda(vec3 p, float rep, float off) {\n  vec2 rp = vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  rp.x=(fract(rp.x*rep-0.5+off)-0.5)/rep;\n  rp.x *= 2.0*PI;\n  return vec3(cos(rp.x)*rp.y,p.y,sin(rp.x)*rp.y);\n}\n\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\n  float d=0.5;\n  float f=0.0;\n  for(int i=0; i<5; ++i) {\n    f+=noise(p/d)*d;\n    d*=.5;\n  }\n  return f;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 tunnel(vec3 p){\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.2)*1.5;\n  off.y += sin(p.z*0.3)*1.3;\n  return off;\n}\n\n\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\nvec3 s;\nint matter = 0;\n\nvec3 probe;\nfloat map(vec3 p) {\n\n// geo\n \n\n  // tunell\n  float minimum = 6.74;\n  float seper = .74;\n  \n  float hole1 = -cyl(p.xy,minimum + 0. * seper);\n  float wall1 = cyl(p.xy, minimum + .2 * seper);\n  float tunnel1 = max(hole1,wall1);\n  \n  \n  float hole2 = -cyl(p.xy,minimum + 8. * seper);\n  float wall2 = cyl(p.xy, minimum + 8.2 * seper);\n  float tunnel2 = max(hole2,wall2);\n  \n  float hole3 = -cyl(p.xy,minimum + 16. * seper);\n  float wall3 = cyl(p.xy, minimum + 16.2 * seper);\n  float tunnel3 = max(hole3,wall3);\n  \n  \n  float tunnel = min(min(tunnel1, tunnel2),tunnel3);\n  \n  matter = 1;\n  return tunnel;\n  \n  /*\n  float ball = sph(p - probe, 1.);\n\n \n  float final = min(ball,tunnel);\n  \n  if ( tunnel == final) {\n      matter = 1;\n  }\n  if ( ball == final) {\n      matter =2;\n  }\n  return final;\n  */\n\n \n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    float res = 1.;\n    float k = 2.;\n    \n    \n    for( float t=mint; t<maxt; )\n    {\n        \n        float h = map(ro + rd*t);\n        //h = abs(h);\n        if( h<0.001 ){\n            return 0.0;\n        }\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nfloat sss(vec3 p, vec3 l, float d) {\n  return smoothstep(0.0,1.0,map(p+l*d)/d);\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*789.451)*7541.223);\n}\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\n\n\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\nfloat shadow(vec3 p, vec3 l, float maxdist, int stepcount, float limit) {\n  float shad=1.0;\n  float dd=0.0;\n  for(int i=0; i<stepcount; ++i) {\n    float d=min(map(p), maxdist);\n    if(d<limit) {\n      shad=0.0;\n      break;\n    }\n    if(dd>=maxdist) {\n      break;\n    }\n  \n    p += l*d;\n    dd+= d;\n \n  }\n  return shad;\n}\n\n\n\nfloat intersect(vec3 p, vec3 l, float maxdist, int stepcount, float limit) {\n  float shad=1.0;\n  float dd=0.0;\n  for(int i=0; i<stepcount; ++i) {\n    float d=min(map(p), maxdist);\n    if(d<limit) {\n\n       float granularity = 20. ;\\\n       \n       float z = decal(p  * granularity, domain );\n       if (  z < 4.5) {\n          d = .1;\n       } else {\n         shad=0.0;\n         break;\n       }\n    }\n   \n    if(dd>=maxdist) {\n      break;\n    }\n  \n    p += l*d;\n    dd+= d;\n \n  }\n  return shad;\n}\n\n\nvec3 vollight ( vec3 lightpos, vec3 s, vec3 r, vec2 uv, float limit) {\n\n  float rand=rnd(uv);\n  \n  \n  const int volsteps=120; //50\n  float voldist = 15.0;\n  float stepsize = voldist/float(volsteps);\n  vec3 lr=r*stepsize;\n  vec3 lp=s + lr*rand;\n  float stepdist=rand*stepsize;\n  vec3 atcol=vec3(0);\n  \n  for(int i=0; i<volsteps; ++i) {\n  \n    if(stepdist>limit) {\n      break;\n    }\n    \n    vec3 lv = lightpos-lp;\n    float ldistvol = length(lv);\n    lv = normalize(lv);\n    float shadvol = intersect(lp, lv, ldistvol, 10, 0.01);\n    atcol += 5./(0.01+(pow(ldistvol,2.))) * shadvol;\n   \n \n    lp+=lr;\n    stepdist+=stepsize;\n    \n  }\n  return atcol;\n}\n\\\n\n\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n   float time = iTime;\n\n  // nav\n  \n   float tt = iTime * .35;\n  \n   vec3 source = \n       lattice(tt + 53.1) * 39.3 ;\n  \n   vec3 target = \n        lattice(tt+1.) * 19.;\n        \n        \n   source.z += tt * 20.;\n   target.z += tt * 20.;\n   \n   probe =  vec3(0,0, sin(iTime * .91 + 1.5) * 74. + source.z);\n   \n\n \n  vec3 cz=normalize(target-source);\n\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  \n  //r.xy *= rot(sin(tick(iTime))*.2);\n\n  vec3 p=source;\n  //float i=0.;\n  float mask=1.0;\n  float d = 10000.0;\n  float dd = 0.;\n  float rand=rnd(uv);\n  \n  \n  // march\n  float granularity = 20. ;\n  bool hit = false;\n  float i ;\n  float z;\n  float res = 1.;\n  for( z=0.; z < 1000.; ++z) {\n    i = z;\n    d=map(p);\n    d = abs(d);\n    if(d<0.01) {\n    \n       \n      i = decal(p  * granularity, domain );\n     \n      if (matter == 1) { \n          if (i > 4.5) {\n            d = .1;\n          } else {\n            hit = true;\n            break;\n          }\n      } else {\n           hit = true;\n            break;\n       \n      \n      }\n    }\n    if ( dd > 10000.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n  // hue\n\n  vec3 col = vec3(1.);\n  \n  i = decal(p  * granularity, domain );\n  \n  if ( matter == 1) {\n      if ( i > 0.0 && i < 3.0) {\n          col = vec3(0);\n      }\n\n      if ( i > -12.0 && i < 0.0) {\n          col = vec3(.1,.1,.5)*.3;\n        \n      }\n  }\n  if ( matter == 2) {\n      col = vec3(.8,.4,.2);\n  }\n    if ( matter == 3) {\n      col = vec3(1);\n  }\n \n\n \n \n //vec3 atcol = vollight(probe, source , r, uv, dd);\n //col += atcol * .5;\n \n \n \n \n //vec3 atcol = vollight(probe, s, r, uv, dd);\n //col += atcol * .1;\n \n  // sky\n  if (! hit ) {\n\n  \n    float per = dot(r, normalize(vec3(0,2,2)))  * .5 + .5;\n    per = pow(per,2.);\n   \n    col =   mix(  vec3(.5), vec3 (.5) *.1, per);\n    \n  }\n  \n  fragColor = vec4(col, 1);\n\n}\n\n\n  \n\n\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n\n\n\n/*\n float diff = max(0.0,dot(n,light)*0.5+0.5);\n  float fren = pow(1.+dot(n,r),2.);\n  float sss = sss(p,r,4.) * 2.;\n  float spec= pow(max(dot(reflect(-light,n),-r),.0), 10.) * 5.;\n  float shad = shadow(p, normalize(-light), .1, length(light-p));\n  float fog =  pow(i/1000.,2.);\n  \n  col -= diff * .1;\n  //col += fren;\n  //col += sss;\n  //col += spec;\n  //col *= shad;\n  //col = mix(col, vec3(0), fog);\n  */", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ty3zc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[295, 295, 314, 314, 383], [385, 385, 407, 407, 454], [456, 456, 485, 485, 533], [536, 536, 583, 583, 629], [631, 631, 650, 650, 1209], [1211, 1211, 1253, 1253, 1360], [1362, 1362, 1386, 1386, 1448], [1487, 1487, 1515, 1515, 1960], [1966, 1966, 1994, 1994, 2625], [2647, 2647, 2674, 2674, 3293], [3333, 3333, 3356, 3356, 3471], [3607, 3607, 3630, 3630, 3708], [3710, 3710, 3744, 3838, 4230], [4236, 4236, 4263, 4263, 4331], [4333, 4333, 4361, 4361, 4385], [4386, 4386, 4415, 4415, 4502], [4505, 4505, 4533, 4533, 4559], [4561, 4561, 4589, 4589, 4622], [4625, 4625, 4672, 4672, 4718], [4722, 4722, 4763, 4763, 4931], [4934, 4934, 4955, 4955, 5246], [5248, 5248, 5267, 5267, 5375], [5377, 5377, 5416, 5416, 5493], [5495, 5495, 5531, 5531, 5609], [5611, 5611, 5631, 5631, 5725], [5728, 5728, 5752, 5752, 5807], [5811, 5811, 5832, 5832, 5881], [5883, 5883, 5908, 5908, 6377], [6415, 6415, 6434, 6457, 7215], [7217, 7217, 7281, 7281, 7563], [7566, 7566, 7585, 7585, 7704], [7706, 7706, 7747, 7747, 7793], [7795, 7795, 7831, 7831, 7876], [7878, 7878, 7898, 7898, 7941], [7943, 7943, 7962, 7962, 8041], [8045, 8045, 8065, 8065, 8249], [8251, 8251, 8324, 8324, 8573], [8577, 8577, 8653, 8653, 9073], [9076, 9076, 9146, 9146, 9727], [9733, 9733, 9791, 9791, 11838], [11848, 11848, 11884, 11884, 12224]], "test": "untested"}
{"id": "sldGDf", "name": "in space", "author": "morimea", "description": "simple art scene\nor just playing with colors\n\nCineshader support [url]https://cineshader.com/view/sldGDf[/url]", "tags": ["space", "art", "cineshader"], "likes": 102, "viewed": 6152, "published": 3, "date": "1638424842", "time_retrieved": "2024-07-30T18:44:44.010337", "image_code": "\n\n// Created by Danil (2021+) https://cohost.org/arugl\n\n// License - CC0 or use as you wish\n\n\n\n// using MIT License code\n// using https://www.shadertoy.com/view/wtXfRH\n// using https://www.shadertoy.com/view/ll2GD3\n\n\n#define SS(x, y, z) smoothstep(x, y, z)\n#define MD(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n\n// divx is number of lines on background\n//#define divx floor(iResolution.y/15.)\n\nconst float divx = 35.;\n#define polar_line_scale (2./divx)\n\nconst float zoom_nise = 9.;\n\n\n// Common code moved for Cineshader support\n//-------------Common code\n\n// using MIT License code\n// using https://www.shadertoy.com/view/wtXfRH\n// using https://www.shadertoy.com/view/ll2GD3\n\nmat3 rotx(float a){float s = sin(a);float c = cos(a);return mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, c, s), vec3(0.0, -s, c));  }\nmat3 roty(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, 0.0, s), vec3(0.0, 1.0, 0.0), vec3(-s, 0.0, c));}\nmat3 rotz(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, s, 0.0), vec3(-s, c, 0.0), vec3(0.0, 0.0, 1.0 ));}\n\nfloat linearstep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0.0, 1.0);\n}\n\n\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return -1.+2.*fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( in vec2 p )\n{\n    p*=0.25;\n    float s = 0.5;\n    float f = 0.0;\n    for( int i=0; i<4; i++ )\n    {\n        f += s*noise(p);\n        s *= 0.8;\n        p = 2.01*mat2(0.8,0.6,-0.6,0.8)*p;\n    }\n    return 0.5+0.5*f;\n}\n\nvec2 ToPolar(vec2 v)\n{\n    return vec2(atan(v.y, v.x)/3.1415926, length(v));\n}\n\nvec3 fcos( vec3 x )\n{\n    vec3 w = fwidth(x);\n    return cos(x) * smoothstep(3.14*2.0,0.0,w);\n }\n\nvec3 getColor( in float t )\n{\n    vec3 col = vec3(0.3,0.4,0.5);\n    col += 0.12*fcos(6.28318*t*  1.0+vec3(0.0,0.8,1.1));\n    col += 0.11*fcos(6.28318*t*  3.1+vec3(0.3,0.4,0.1));\n    col += 0.10*fcos(6.28318*t*  5.1+vec3(0.1,0.7,1.1));\n    col += 0.10*fcos(6.28318*t* 17.1+vec3(0.2,0.6,0.7));\n    col += 0.10*fcos(6.28318*t* 31.1+vec3(0.1,0.6,0.7));\n    col += 0.10*fcos(6.28318*t* 65.1+vec3(0.0,0.5,0.8));\n    col += 0.10*fcos(6.28318*t*115.1+vec3(0.1,0.4,0.7));\n    col += 0.10*fcos(6.28318*t*265.1+vec3(1.1,1.4,2.7));\n    return col;\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//----------end of Common\n\nvec3 get_noise(vec2 p,float timer){\n    vec2 res = iResolution.xy/iResolution.y;\n    vec2 shiftx= res*0.5*1.25+.5*(0.5+0.5*vec2(sin(timer*0.0851),cos(timer*0.0851)));\n    vec2 shiftx2= res*0.5*2.+.5*(0.5+0.5*vec2(sin(timer*0.0851),cos(timer*0.0851)));\n    vec2 tp = p + shiftx;\n    float atx = (atan(tp.x+0.0001*(1.-abs(sign(tp.x))),tp.y)/3.141592653)*.5+fract(timer*0.025);\n    vec2 puv = ToPolar(tp);\n    puv.y+=atx;\n    puv.x*=0.5;\n    vec2 tuv = puv*divx;\n    float idx = mod(floor(tuv.y),divx)+200.;\n    puv.y=fract(puv.y);\n    puv.x=abs(fract(puv.x/divx)-0.5)*divx; // mirror seamless noise\n    puv.x+=-.5*timer*(0.075-0.0025*max((min(idx,16.)+2.*sin(idx/5.)),0.));\n    return vec3(SS(0.43,0.73,fbm(((p*0.5+shiftx2)*MD(-timer*0.013951*10./zoom_nise))*zoom_nise*2.+vec2(4.+2.*idx))),SS(0.543,0.73,fbm(((p*0.5+shiftx2)*MD(timer*0.02751*10./zoom_nise))*zoom_nise*1.4+vec2(4.+2.*idx))),fbm(vec2(4.+2.*idx)*puv*zoom_nise/100.));\n}\n\nvec4 get_lines_color(vec2 p, vec3 n, float timer){\n    vec2 res = iResolution.xy/iResolution.y;\n    \n    vec3 col= vec3(0.);\n    float a = 1.;\n    \n    vec2 shiftx= res*0.5*1.25+.5*(0.5+0.5*vec2(sin(timer*0.0851),cos(timer*0.0851)));\n    vec2 tp = p + shiftx;\n    float atx = (atan(tp.x+0.0001*(1.-abs(sign(tp.x))),tp.y)/3.141592653)*(0.5)+fract(timer*0.025);\n    vec2 puv = ToPolar(tp);\n    puv.y+=atx;\n    puv.x*=0.5;\n    vec2 tuv = puv*divx;\n    float idx = mod(floor(tuv.y),divx)+1.;\n    \n    \n    // thin lines\n    float d = length(tp);\n    d+=atx;\n    float v = sin(3.141592653*2.*divx*0.5*d+0.5*3.141592653);\n    float fv =fwidth(v);\n    fv+=0.0001*(1.-abs(sign(fv)));\n    d = 1.-SS(-1.,1., .3*abs(v)/fv);\n    \n    float d2 = 1.-SS(0., 0.473, abs(fract(tuv.y)-0.5));\n    tuv.x+=3.5*timer*(0.01+divx/200.)-0.435*idx;\n    \n    // lines\n    tuv.x=abs(fract(tuv.x/divx)-0.5)*divx;\n    float ld = SS(0.1,.9,(fract(polar_line_scale*tuv.x*max(idx,1.)/10.+idx/3.)))*(1.-SS(0.98,1.,(fract(polar_line_scale*tuv.x*max(idx,1.)/10.+idx/3.))));\n    \n    tuv.x+=1.*timer*(0.01+divx/200.)-01.135*idx;\n    ld *= 1.-SS(0.1,.9,(fract(polar_line_scale*tuv.x*max(idx,1.)/10.+idx/6.5)))*(1.-SS(0.98,1.,(fract(polar_line_scale*tuv.x*max(idx,1.)/10.+idx/6.5))));\n    \n    float ld2 = .1/(max(abs(fract(tuv.y)-0.5)*1.46,0.0001)+ld);\n    ld = .1/((max(abs(fract(tuv.y)-0.5)*1.46,0.0001)+ld)*(2.5-(n.y+1.*max(n.y,n.z))));\n\n    \n    ld=min(ld,13.);\n    ld*=SS(0.0,0.15,0.5-abs(fract(tuv.y)-0.5));\n    \n    // noise\n    d*=n.z*n.z*2.;\n    float d3=(d*n.x*n.y+d*n.y*n.y+(d2*ld2+d2*ld*n.z*n.z));\n    d=(d*n.x*n.y+d*n.y*n.y+(d2*ld+d2*ld*n.z*n.z));\n    \n    a=clamp(d,0.,1.);\n    \n    \n    puv.y=mix(fract(puv.y),fract(puv.y+0.5),SS(0.,0.1,abs(fract(puv.y)-0.5)));\n    col = getColor( .54*length(puv.y) );\n    \n    col = 3.5*a*col*col+2.*(mix(col.bgr,col.grb,0.5+0.5*sin(timer*0.1))-col*0.5)*col;\n    \n    d3=min(d3,4.);\n    d3*=(d3*n.y-(n.y*n.x*n.z));\n    d3*=n.y/max(n.z+n.x,0.001);\n    d3=max(d3,0.);\n    vec3 col2 = .5*d3*vec3(0.3,0.7,0.98);\n    col2=clamp(col2,0.,2.);\n    \n    col=col2*0.5*(0.5-0.5*cos((timer*0.48*2.)))+mix(col,col2,0.45+0.45*cos((timer*0.48*2.)));\n    \n    col=clamp(col,0.,1.);\n    \n    //col=vec3(ld);\n    \n    return vec4(col,a);\n}\n\nvec4 planet(vec3 ro, vec3 rd, float timer, out float cineshader_alpha)\n{   \n    vec3 lgt = vec3(-.523, .41, -.747);\n    float sd= clamp(dot(lgt, rd)*0.5+0.5,0.,1.);\n    float far = 400.;\n    float dtp = 13.-(ro + rd*(far)).y*3.5;\n    float hori = (linearstep(-1900., 0.0, dtp) - linearstep(11., 700., dtp))*1.;\n    hori *= pow(abs(sd),.04);\n    hori=abs(hori);\n    \n    vec3 col = vec3(0);\n    col += pow(hori, 200.)*vec3(0.3, 0.7,  1.0)*3.;\n    col += pow(hori, 25.)* vec3(0.5, 0.5,  1.0)*.5;\n    col += pow(hori, 7.)* pal( timer*0.48*0.1, vec3(0.8,0.5,0.04),vec3(0.3,0.04,0.82),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) )*1.;\n    col=clamp(col,0.,1.);\n    \n    float t = mod(timer,15.);\n    float t2 = mod(timer+7.5,15.);\n    float td = .071*dtp/far+5.1;\n    float td2 = .1051*dtp/far+t*.00715+.025;\n    float td3 = .1051*dtp/far+t2*.00715+.025;\n    vec3 c1=getColor(td);\n    vec3 c2=getColor(td2);\n    vec3 c3=getColor(td3);\n    c2=mix(c2,c3.bbr,abs(t-7.5)/7.5);\n\n    c2=clamp(c2,0.0001,1.);\n    \n    col+=sd*hori*clamp((c1/(2.*c2)),0.0,3.)*SS(0.,50.,dtp);\n    col=clamp(col,0.,1.);\n    \n    float a=1.;\n    a=(0.15+.95*(1.-sd))*hori*(1.-SS(.0,25.,dtp));\n    a=clamp(a,0.,1.);\n    \n    hori = mix(linearstep(-1900., 0.0, dtp), 1. - linearstep(11., 700., dtp), sd);\n    cineshader_alpha=1.-pow(hori,3.5);\n\n    return vec4(col,a);\n}\n\nvec3 cam(vec2 uv, float timer)\n{\n    //vec2 res = (ires.xy / ires.y);\n    //vec2 im = (mouse.xy) / ires.y - res/2.0;\n    timer*=0.48;\n    vec2 im = vec2(cos(mod(timer,3.1415926)),-0.02+0.06*cos(timer*0.17));\n    im*=3.14159263;\n    im.y = -im.y;\n    \n    float fov = 90.;\n    float aspect = 1.;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.14159263 / 180.0)) / 2.0)));\n    vec3 rd = normalize(vec3(uv*screenSize, 1./aspect));\n    rd = (roty(-im.x) * rotx(im.y) * rotz(0.32*sin(timer*0.07))) * rd;\n    return rd;\n}\n\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n    color = clamp(color, 0.0, 1.0);\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n    float timer = .65*iTime+220.;\n    //timer=18.5*iMouse.x/iResolution.x;\n    vec2 res = iResolution.xy/iResolution.y;\n    vec2 uv = fragCoord.xy/iResolution.y-0.5*res;\n    uv*=1.;\n    vec3 noisev = get_noise(uv, timer);\n\n    vec4 lcol = get_lines_color(uv, noisev, timer);\n\n    //fragColor = vec4(lcol.rgba);\n\n    vec3 ro = vec3(1.,40.,1.);\n    vec3 rd = cam(uv, timer);\n    float cineshader_alpha;\n    vec4 planetc = planet(ro,rd,timer,cineshader_alpha);\n\n    vec3 col = lcol.rgb*planetc.a*0.75+0.5*lcol.rgb*min(12.*planetc.a,1.)+planetc.rgb;\n    col=clamp(col,0.,1.);\n    \n    fragColor = vec4(col*0.85+0.15*col*col,1.);\n    \n    // extra color correction\n    fragColor.rgb = fragColor.rgb*0.15+fragColor.rgb*fragColor.rgb*0.65+(fragColor.rgb*0.7+0.3)*ACESFitted(fragColor.rgb);\n    \n    float tfc = fragCoord.x/iResolution.x-0.5;\n    cineshader_alpha*=((1.-(tfc*tfc*4.))*0.15+0.85);\n    fragColor.a = cineshader_alpha;\n    //fragColor=vec4(cineshader_alpha);\n    \n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldGDf.jpg", "access": "api", "license": "cc0-1.0", "functions": [[676, 676, 695, 695, 800], [801, 801, 820, 820, 923], [924, 924, 943, 943, 1047], [1049, 1049, 1100, 1100, 1159], [1162, 1162, 1182, 1182, 1306], [1308, 1308, 1334, 1334, 1625], [1627, 1627, 1651, 1651, 1853], [1855, 1855, 1877, 1877, 1933], [1935, 1935, 1956, 1956, 2031], [2033, 2033, 2062, 2062, 2570], [2572, 2572, 2640, 2640, 2683], [2712, 2712, 2747, 2747, 3643], [3645, 3645, 3695, 3695, 5878], [5880, 5880, 5952, 5952, 7209], [7211, 7211, 7243, 7327, 7730], [7999, 7999, 8026, 8026, 8150], [8152, 8152, 8181, 8181, 8339], [8342, 8342, 8399, 8399, 9396]], "test": "untested"}
{"id": "stG3D3", "name": "English Project", "author": "Benny505", "description": "A shader I made for my English class!", "tags": ["creative"], "likes": 0, "viewed": 185, "published": 3, "date": "1638421858", "time_retrieved": "2024-07-30T18:44:44.959799", "image_code": "float EPSILON = 0.00001;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float coeff = 5.0;\n    float vertical = 0.7 / coeff;\n    float horizontal = 7.0 * coeff;\n    float height = 0.5;\n    \n    vec3 otherShape = texture(iChannel0, uv).rgb;\n    vec3 test = vec3(0.0, 0.0, 0.0);\n    \n    float maxRad = 0.4;\n    float rad = (1.0 / 10.0) * (0.8 + sin(1.0 * iTime));\n    rad = clamp(rad, 0.0, maxRad);\n    \n    float radicand = rad - (uv.x - 0.5) * (uv.x - 0.5);\n    float yUp = (iResolution.x / iResolution.y) * sqrt(radicand) + height;\n    float yDown = -1.0 * (iResolution.x / iResolution.y) * sqrt(rad - (uv.x - 0.5) * (uv.x - 0.5)) + height;\n    bool check = uv.y > yUp || uv.y < yDown || radicand < 0.0;\n    if (check)\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    else\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    \n    if (otherShape != test && !check)\n        fragColor = vec4(otherShape, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// returns the x y and m values based off of the y value of the pixel (uv.y)\nvec3 genCurve(vec2 point1, vec2 point2, vec2 point3, vec2 uv) {\n    // check to see if we should be generating curve\n    float x;\n    float y;\n    // mY is the second derivitave of y with respect to t\n    float mY;\n    // mX is the second derivitave of x with respect to t\n    float mX;\n    // decrease t step for a cleaner curve\n    for (float t = 0.0; t < 1.0; t+=0.001) {\n        // bezier curve equations for 3 points\n        x = (1.0 - t) * (1.0 - t) * point1.x + 2.0 * (1.0 - t) * t * point2.x + t * t * point3.x;\n        y = (1.0 - t) * (1.0 - t) * point1.y + 2.0 * (1.0 - t) * t * point2.y + t * t * point3.y;\n        // first derivitave mY = -2.0 * (1.0 - t) * point1.y + 2.0 * point2.y * (1.0 - (2.0 * t)) + 2.0 * t * point3.y;\n        // first derivitave mX = -2.0 * (1.0 - t) * point1.x + 2.0 * point2.x * (1.0 - (2.0 * t)) + 2.0 * t * point3.x;\n        mY = 2.0 * point1.y - 4.0 * point2.y + 2.0 * point3.y; // second derivitave\n        mX = 2.0 * point1.x - 4.0 * point2.x + 2.0 * point3.x; // second derivitave\n        // must get point in relation to y value\n        if (abs(uv.y - y) < 1.0 / iResolution.y)\n            return vec3(x, y, mY * mX);\n    }\n    return vec3(-1.0, -1.0, -1.0);\n}\n\n// returns the x and y values based off of the x value of the pixel (uv.x)\nvec2 getCurve(vec2 point1, vec2 point2, vec2 point3, vec2 uv) {\n    // check to see if we should be generating curve\n    float x;\n    float y;\n    // decrease t step for a cleaner curve\n    for (float t = 0.0; t < 1.0; t+=0.001) {\n        // bezier curve equations for 3 points\n        x = (1.0 - t) * (1.0 - t) * point1.x + 2.0 * (1.0 - t) * t * point2.x + t * t * point3.x;\n        y = (1.0 - t) * (1.0 - t) * point1.y + 2.0 * (1.0 - t) * t * point2.y + t * t * point3.y;\n        if (abs(uv.x - x) < 1.0 / iResolution.x)\n            return vec2(x, y);\n    }\n    return vec2(-1.0, -1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float maxScale = 0.1;\n    float scale = (0.01) * (0.6 + 30.0 * sin(iTime - 0.01));\n    if (scale > maxScale)\n        scale = maxScale;\n    if (scale < 0.0)\n        scale = 0.0;\n    float midX = 0.5;\n    float midY1 = 0.2;\n    float midY2 = midY1 + 0.4;\n    \n    // points\n    vec2 point1C1 = vec2((midX - 0.1), (midY1 + 0.5));\n    vec2 point2C1 = vec2((midX - 0.2), (midY1 + 0.4));\n    vec2 point3C1 = vec2(midX, midY1);\n    \n    vec2 point1C2 = vec2((midX + 0.1), (midY1 + 0.5));\n    vec2 point2C2 = vec2((midX + 0.2), (midY1 + 0.4));\n    vec2 point3C2 = vec2(midX, midY1);\n    \n    vec2 point1C3 = vec2((midX - 0.1), (midY2 + 0.1));\n    vec2 point2C3 = vec2((midX - 0.05), (midY2 + 0.15));\n    vec2 point3C3 = vec2(midX, midY2);\n    \n    vec2 point1C4 = vec2((midX + 0.1), (midY2 + 0.1));\n    vec2 point2C4 = vec2((midX + 0.05), (midY2 + 0.15));\n    vec2 point3C4 = vec2(midX, midY2);\n    \n    \n    bool draw = false;\n    vec3 vecC1 = genCurve(point1C1, point2C1, point3C1, uv);\n    vec3 vecC2 = genCurve(point1C2, point2C2, point3C2, uv);\n    vec3 vecC3 = genCurve(point1C3, point2C3, point3C3, uv);\n    vec3 vecC4 = genCurve(point1C4, point2C4, point3C4, uv);\n    vec2 vecC3X = getCurve(point1C3, point2C3, point3C3, uv);\n    vec2 vecC4X = getCurve(point1C4, point2C4, point3C4, uv);\n    \n    bool c1Check = vecC1.x == - 1.0 || (vecC1.z > 0.0 && uv.x < vecC1.x) || (vecC1.z < 0.0 && uv.x > vecC1.x);\n    bool c2Check = vecC2.x == - 1.0 || (vecC2.z > 0.0 && uv.x < vecC2.x) || (vecC2.z < 0.0 && uv.x > vecC2.x);\n    bool c3Check = vecC3.x == - 1.0 || vecC3X.x == - 1.0 || (vecC3X.y >= uv.y && vecC3.x != -1.0);\n    bool c4Check = vecC4.x == - 1.0 || vecC4X.x == - 1.0 || (vecC4X.y >= uv.y && vecC4.x != -1.0);\n    \n    if (!c3Check)\n        c4Check = false;\n    else if (!c4Check)\n        c3Check = false;\n    \n    if ((c1Check && c2Check && c3Check) || (c1Check && c2Check && c4Check))\n        draw = true;\n    \n    if (vecC1.x == -1.0 && vecC2.x == -1.0 && (vecC3.x == -1.0 || vecC3X.x == -1.0) && (vecC4.x == -1.0 || vecC4X.x == -1.0))\n        draw = false;\n    \n    if (draw)\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    else \n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stG3D3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 83, 133, 1015]], "test": "untested"}
{"id": "flG3DV", "name": "First Positive Root of Hextic", "author": "paniq", "description": "Iteratively find the first positive root of a 6th degree polynomial using gradient interval arithmetic.", "tags": ["raytracing", "marching", "1d", "polynomial", "root"], "likes": 19, "viewed": 494, "published": 3, "date": "1638418405", "time_retrieved": "2024-07-30T18:44:46.125682", "image_code": "// upper bound of a value sufficiently close to a root\nconst float sigma = 1e-3;\n// maximum number of marching steps\nconst int max_iterations = 25;\n// initial width of search range\nconst float initial_width = 0.15;\n// by which factor to grow the next search range\nconst float grow_ratio = 1.618034;//1.4, 2.0 also good choices\n\n// should be at least 2; has precision issues > 8 \n// 3 = quadratic, 4 = cubic, 5 = quartic, 6 = quintic, 7 = hextic\nconst int max_coeffs = 7;\n\n// GIA scalar for rays (1D)\nstruct gia1 {\n    // describes a triangle of the form f0 + x*f1\n    // which bounds the function on the interval x=0..1\n    float f0;\n    vec2 f1;\n};\n\ngia1 gia_const(float x) {\n    return gia1(x, vec2(0.));\n}\n\nvec2 sort(vec2 ia) {\n    return (ia.x > ia.y)?ia.yx:ia;\n}\n\nvec2 ia_merge(vec2 a, vec2 b) {\n    return vec2(min(a.x, b.x), max(a.y, b.y));\n}\n\nvec2 ia_clamp(vec2 a) {\n    return vec2(min(0., a.x), max(0., a.y));\n}\n\ngia1 gia_add(gia1 a, gia1 b) {\n    return gia1(a.f0 + b.f0, a.f1 + b.f1);\n}\n\ngia1 gia_add(gia1 a, float b) {\n    return gia1(a.f0 + b, a.f1);\n}\n\ngia1 gia_mul(gia1 a, gia1 b) {\n    // bound f'(1)\n    vec2 f1 = ia_merge(sort(a.f1.x * b.f1), sort(a.f1.y * b.f1));\n    // bound f'(0..1) = f(x)*g'(x) + f'*g(x)\n    vec2 ff0 = sort(b.f0*a.f1) + sort(a.f0*b.f1); \n\tfloat f0 = a.f0 * b.f0;\n    // ff0 = tangent, ff0 + f1 = segment connecting f(0) to f(1)\n    return gia1(f0, ff0 + ia_clamp(f1));\n}\n\n//////////////////////////////////////////////////////////\n\nfloat coeffs[max_coeffs];\n\n// this only sets up the demo; we want to inject\n// a root at a particular point, which requires changing\n// all coefficients\nvoid add_root(float r, float a) {\n    float y0 = -r*a; float y1 = a;\n    float c = 0.;\n    for (int k = 0; k < max_coeffs; ++k) {\n        float c1 = coeffs[k];\n        coeffs[k] = (coeffs[k]*y0 + c*y1);\n        if (c1 == 0.)\n            break;\n        c = c1;\n    }\n}\n\nvoid init_coeffs() {\n    for (int i = 0; i < max_coeffs; ++i) {\n        coeffs[i] = 0.;\n    }    \n    coeffs[0] = 0.5;    \n    // add some random roots\n    float r0 = (1. + sqrt(5.)) / 2.;    \n    float amp = sqrt(float(max_coeffs));\n    for (int i = 1; i < max_coeffs; ++i) {\n        float z = sin((iTime*0.1/amp + fract(r0*float(i)))*radians(360.0))*0.5 + 0.5;\n        add_root(z, amp);\n    }\n    coeffs[0] += 0.12;    \n}\n\n//////////////////////////////////////////////////////////\n\nvoid horner_coeffs(out float b_coeffs[max_coeffs], float x0) {\n    b_coeffs[max_coeffs-1] = coeffs[max_coeffs-1];\n    for (int i = max_coeffs-2; i >= 0; --i) {\n        b_coeffs[i] = coeffs[i] + b_coeffs[i+1] * x0;\n    }\n}\n\n// evaluate polynomial at x\nfloat eval(float x) {\n    // horner form, helps keeping float precision stable close to 1\n    float b_coeffs[max_coeffs];\n    float x0 = 1.0;\n    horner_coeffs(b_coeffs, x0);    \n    float y = b_coeffs[max_coeffs-1];\n    for (int i = max_coeffs-2; i >= 1; --i) {\n        y = y*x + b_coeffs[i];\n    }\n    y = y*(x - x0) + b_coeffs[0];\n    return y;\n}\n\n// produce wedge for region x0 .. x1\ngia1 eval_wedge(gia1 x) {\n    // horner form, greatly reduces interval error\n    float x0 = x.f0;\n    float b_coeffs[max_coeffs];\n    horner_coeffs(b_coeffs, x0);\n    gia1 y = gia_const(b_coeffs[max_coeffs-1]);\n    for (int i = max_coeffs-2; i >= 1; --i) {\n        y = gia_add(gia_mul(x,y), b_coeffs[i]);\n    }\n    y = gia_add(gia_mul(y, gia_add(x, -x0)), b_coeffs[0]);\n    return y;\n}\n\n// from https://www.shadertoy.com/view/WlfXRN\nvec3 plasma(float t) {\n\n    const vec3 c0 = vec3(0.05873234392399702, 0.02333670892565664, 0.5433401826748754);\n    const vec3 c1 = vec3(2.176514634195958, 0.2383834171260182, 0.7539604599784036);\n    const vec3 c2 = vec3(-2.689460476458034, -7.455851135738909, 3.110799939717086);\n    const vec3 c3 = vec3(6.130348345893603, 42.3461881477227, -28.51885465332158);\n    const vec3 c4 = vec3(-11.10743619062271, -82.66631109428045, 60.13984767418263);\n    const vec3 c5 = vec3(10.02306557647065, 71.41361770095349, -54.07218655560067);\n    const vec3 c6 = vec3(-3.658713842777788, -22.93153465461149, 18.19190778539828);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\nvoid paint() {\n    scale(2.0);\n    translate(-0.5,0.0);\n    init_coeffs();\n\n    float t = iTime;\n\n    set_source_rgb(vec3(0.925, 0.941, 0.894));\n    clear();\n    \n    set_line_width_px(1.0);\n    grid(1.0);\n    set_source_rgba(0.,0.,0.,.7);\n    stroke();\n    set_source_rgba(0.,0.,0.,.3);\n    grid(1.0/10.0);\n    stroke();\n    grid(1.0/50.0);\n    stroke();\n    \n    set_line_width_px(1.0);\n    set_source_rgba(0.,0.,0.,1.);\n    graph1D(eval);\n    stroke();\n    \n    float x = 0.0;\n    float h = initial_width;\n    for (int i = 0; i < max_iterations; ++i) {\n        gia1 w = eval_wedge(gia1(x, vec2(h)));\n        // draw distance to zero\n        set_source_rgba(vec4(vec3(0.),0.8));\n        move_to(x, 0.0);\n        line_to(x, w.f0);\n        close_path();\n        stroke();        \n        // draw wedge bounds\n        vec3 col = plasma(float(i)/float(max_iterations));\n        move_to(x, w.f0);\n        line_to(x + h, w.f0 + w.f1[0]);\n        line_to(x + h, w.f0 + w.f1[1]);\n        close_path();\n        set_source_rgba(vec4(col,0.3));\n        fill_preserve();        \n        set_source_rgb(col);\n        stroke();\n        circle_px(x, w.f0, 2.0);\n        fill();\n        \n        if (abs(w.f0) < sigma) { // found root\n            // draw root\n            set_line_width_px(2.0);            \n            set_source_radial_gradient(vec4(col,1.), vec4(col,0.), vec2(x, w.f0), AAINV*20.0);\n            rings(vec2(x, w.f0), AAINV*3.0, iTime);\n            stroke();\n            set_line_width_px(1.0);\n            \n            break;\n        } else {\n        }\n        // significant tangent\n        float st = ((w.f0 > 0.0)?w.f1[0]:w.f1[1]);        \n        float z = -h*w.f0 / st; // extrapolate root\n        float rd = (z < 0.0)?h:z;\n        float s = min(h, rd);\n        x += s;\n        if (x >= 1.0) {\n            // no root in interval\n            break;     \n        }\n        h = grow_ratio*s;\n    }\n    \n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord, iMouse.xy, iResolution.xy);\n\n    paint();\n\n    blit(fragColor);\n}\n", "image_inputs": [], "common_code": "// 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.16\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2020-12-02: 0.16\n// * support for drawing concentric rings\n\n// 2020-11-30: 0.15\n// * support for drawing orthogonal grids\n// * adjusted uv so corners are centered on pixels\n// * small adjustment to line pixel width computation\n\n// 2020-11-12: 0.14\n// * added support for depth testing\n\n// 2020-11-11: 0.13\n// * fixed 2D graphs not filling\n// * added circle_px()\n\n// 2019-06-06: 0.12\n// * split implementation and demo into common and image tab\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\nvoid set_source_depth(float depth);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the old source with the new one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n// if enabled, use the depth value for testing;\n// smaller values win\nvoid depth_test(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add a circle path at P with pixel radius R\nvoid circle_px(vec2 p, float r);\nvoid circle_px(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// add an orthogonal grid with cell size S\nvoid grid(vec2 s);\nvoid grid(float w, float h);\nvoid grid(float s);\n// draw concentric rings around origin p, with spacing r and offset phase\nvoid rings(vec2 p, float r, float phase);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// draw a letter with the given texture coordinate\nvoid letter(sampler2D font_texture_source, ivec2 l);\nvoid letter(sampler2D font_texture_source, int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    bool depth_test;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n    float source_z;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n#define DEFAULT_DEPTH 1e+30\n\nContext _stack;\n\nvoid init (vec2 fragCoord, vec2 mouse, vec2 resolution) {\n\taspect = vec2(resolution.x / resolution.y, 1.0);\n\tScreenH = min(resolution.x,resolution.y);\n\tAA = ScreenH*0.5;\n\tAAINV = 1.0 / AA;\n    \n    uv = (fragCoord.xy - 0.5) / resolution;\n    vec2 m = mouse / resolution;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false,\n        DEFAULT_DEPTH\n    );\n}\n\nvec3 _color = vec3(1);\nfloat _depth = DEFAULT_DEPTH;\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color.rgb = mix(_color.rgb, _stack.source.rgb, _stack.source.a);\n    _depth = (_stack.source.a == 1.0)?_stack.source_z:_depth;\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(pow(_color.rgb, vec3(1.0/2.2)), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color.rgb;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    if (_stack.depth_test) {\n        if ((w == 1.0) && (_stack.source_z <= _depth)) {\n            _depth = _stack.source_z;\n        } else if ((w == 0.0) || (_stack.source_z > _depth)) {            \n            return;\n        }\n    }\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color.rgb = _color.rgb * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\n\nvoid depth_test(bool enable) {\n    _stack.depth_test = enable;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_depth(float depth) {\n    _stack.source_z = depth;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(sampler2D font_texture_source, ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(sampler2D font_texture_source, int lx, int ly) {\n    letter(font_texture_source, ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid grid(vec2 size) {\n    vec4 f = abs(fract(_stack.position/size.xyxy+0.5)-0.5)*size.xyxy;\n    add_field(vec2(min(f.x,f.y),min(f.z,f.w)));\n}\nvoid grid(float w, float h) {\n    grid(vec2(w,h));\n}\nvoid grid(float s) {\n    grid(vec2(s));\n}\nvoid rings(vec2 p, float r, float phase) {\n    vec4 q = _stack.position - p.xyxy;\n    vec2 f = abs(fract(vec2(length(q.xy),length(q.zw))/r-phase+0.5)-0.5)*r;\n    add_field(f);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid circle_px(vec2 p, float r) {\n    circle(p, r/(0.5*ScreenH));\n}\nvoid circle_px(float x, float y, float r) {\n    circle_px(vec2(x,y), r);\n}\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(f_x / length(df_x));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flG3DV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[651, 651, 676, 676, 708], [710, 710, 730, 730, 767], [769, 769, 800, 800, 849], [851, 851, 874, 874, 921], [923, 923, 953, 953, 998], [1000, 1000, 1031, 1031, 1066], [1068, 1068, 1098, 1117, 1412], [1501, 1627, 1660, 1660, 1894], [1896, 1896, 1916, 1916, 2319], [2381, 2381, 2443, 2443, 2602], [2604, 2632, 2653, 2721, 2981], [2983, 3020, 3045, 3096, 3405], [3407, 3453, 3475, 3475, 4130], [4132, 4132, 4146, 4146, 6043], [6105, 6105, 6162, 6162, 6248]], "test": "untested"}
{"id": "7lGGWz", "name": "Warped Waves of Color", "author": "flylo", "description": "Based loosedly on Conway's Game of Life [url]https://iquilezles.org/articles/gameoflife/gameoflife.htm[/url], with a study in color mixing.  Combined with a fractal warp effect based on [url]https://iquilezles.org/articles/warp/[/url].", "tags": ["2d", "fractal", "simulation", "warp", "automata", "life", "conway", "gameoflife", "multipass"], "likes": 5, "viewed": 261, "published": 3, "date": "1638404280", "time_retrieved": "2024-07-30T18:44:46.900610", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n      \n    fragColor = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\nfloat rstate;\nvec2 uv;\n\n\nfloat rand(){\n    rstate += dot(uv, vec2(71.9898,123.233));\n    return hash1(rstate*(iTime+1.));\n}\n\n\nvec4 texel( in ivec2 p )\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n    return (texelFetch(iChannel0, p, 0 ));\n}\n\nconst int[18] ns = int[](-1, -1, 0, -1, 1, -1, -1, 0, 1, 0, 0, 0, -1, 1, 0, 1, 1, 1);\nvec4 cur, next;\nbool add; \n\nvec4 avg( in ivec2 px )\n{\n    int idx = int(rand() * 10.) * 2;\n   \n    vec4 r = texel(px);\n    float rv = 0.;\n        \n    for (int i = idx; i < 18 + idx; i += 2) {\n       vec4 n = texel(px+ivec2(ns[i%18],ns[(i%18)+1]));\n\n       if (n.a > r.a) {\n           r = (r + n) / 2.;\n           r.a = n.a;\n       }\n   }\n \n   return r;\n   \n}\n\n\nvec4 sum( in ivec2 px )\n{\n    int idx = int(rand() * 10.) * 2;\n   \n    vec4 r = cur;\n    float rv = 0.;\n        \n    for (int i = idx; i < 18 + idx; i += 2) {\n       vec4 n = texel(px+ivec2(ns[i%18],ns[(i%18)+1]));\n\n       if (n.a > r.a) {\n           r = cur + n;\n           float mx = max(r.r, max(r.g, r.b));\n           if (mx > 1.)\n               r /= mx;\n               \n           //if (r.r > 1.) r.r /= 2.;\n           //if (r.g > 1.) r.g /= 2.;\n           //if (r.b > 1.) r.b /= 2.; \n           r.a = n.a;\n           //if (mx > 1.)\n           //    r.a -= fract(r.a);\n       }\n   }\n \n   return r;\n   \n}\n\n\nvec4 diff( in ivec2 px )\n{\n    int idx = int(rand() * 10.) * 2;\n   \n    vec4 r = texel(px);\n    float rv = 0.;\n        \n    for (int i = idx; i < 18 + idx; i += 2) {\n       vec4 n = texel(px+ivec2(ns[i%18],ns[(i%18)+1]));\n\n       if (n.a > r.a) {\n           r.rgb = min(r.rgb, n.rgb);\n           r.a = n.a;\n       }\n   }\n \n   return r;\n}\n\n\nvec4 copy( in ivec2 px )\n{\n    int idx = int(rand() * 10.) * 2;\n   \n    vec4 r = texel(px);\n    float rv = 0.;\n        \n    for (int i = idx; i < 18 + idx; i += 2) {\n       vec4 n = texel(px+ivec2(ns[i%18],ns[(i%18)+1]));\n\n       if (n.a > rv) {\n           r = n;\n           rv = n.a;\n       }\n   }\n \n   return r;\n}\n\n\nvec4 vsim(in vec2 uv) {\n    next = cur;\n    \n    ivec2 px = ivec2( (uv * iResolution.y + iResolution.xy)/2. );\n\n    bool l, d = false;\n\n    next = diff(px);           \n    if (fract(next.a) > 0.1) {\n           next = cur;   \n           next = sum(px);\n       if (fract(next.a) > .6) {\n             next = cur;\n             next = copy(px);\n           if (fract(next.a) > .8) {\n             next = cur;\n             next = avg(px);\n           }    \n       }       \n    }\n   \n    // decay\n    if (true) {\n        float dk = 2.;\n        next.a = max(0.0, next.a - dk);\n    }\n    \n    // growth\n    if (rand() < 1351e-4 && rand() < 1e-6 ) {\n        vec4 n;\n            \n        n.rgb = vec3(rand(), rand(), rand());\n        n.a = rand() * 1000.; \n        next = n;\n        \n    }\n       \n    if(  iFrame==0 ) {\n        if (rand() < .0002) {\n            next.r = rand();\n            next.g = rand();\n            next.b = rand(); //       fragColor = vec4(step(0.5, hash1(fragCoord.x*13.0+hash1(fragCoord.y*71.1))));\n            next.a = rand() * 1000.;       \n        }\n    } \n    \n    return next;\n}\n\nvec4 clouds(in vec2 uv) {\n    vec4 vs = vsim(uv);\n    \n    int iter = 3;\n    float amp = 112.9;\n    float f = .0342;\n\n    float a = 1.; \n    for (int i = 0; i < iter; i++) {\n       a *= amp;\n    }\n       \n    for (int i = 0; i < iter; i++) {\n        a /= amp;\n        f *= 1.2;\n        vs = a*vsim(uv + f*vec2(vs.r - vs.g, vs.g - vs.b)) ;\n    }\n    return vs;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    ivec2 px = ivec2( fragCoord );\n\n    uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    rstate = dot(uv, vec2(711.9898,1123.233));\n \n    cur = texelFetch(iChannel0, px, 0 );\n\n    fragColor = clouds(uv);\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGGWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 189]], "test": "untested"}
{"id": "slVGWV", "name": "Multibrots", "author": "tungster24", "description": "multibrots, made using polar forms", "tags": ["fractal", "mandelbrot", "multibrot"], "likes": 3, "viewed": 248, "published": 3, "date": "1638387756", "time_retrieved": "2024-07-30T18:44:47.796215", "image_code": "float r(in vec2 z) {return sqrt(z.x*z.x+z.y*z.y);}\nfloat theta(in vec2 z) {return atan(z.y,z.x);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = vec2(fragCoord.x/iResolution.y*2.0-1.0*iResolution.x/iResolution.y,fragCoord.y/iResolution.y*2.0-1.0);\n    vec2 z = vec2(0.0,0.0);\n    float t = iTime;\n    bool inside=true;int iter = 0;\n    for (int i = 0;i<100;i++){\n        z = vec2(cos(t*theta(z))*pow(r(z),t)+p.x,sin(t*theta(z))*pow(r(z),t)+p.y);\n        if (r(z) >= 2.0) {inside = false;break;}\n        iter++;\n    }\n    \n    vec3 col;\n    if (inside == true) col = vec3(0.0,0.0,0.0);\n    else col = vec3(float(iter)/40.0,float(iter)/30.0,float(iter)/20.0);\n    fragColor = vec4(col,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVGWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 50], [51, 51, 75, 75, 97], [99, 99, 156, 156, 715]], "test": "untested"}
{"id": "7lK3WK", "name": "Octahedron, and flipped faces", "author": "stlsnk", "description": "Take the planes corresponding to the sides of the octahedron. How many parts do these planes partition the space?\nI counted 59.", "tags": ["3d", "octahedron", "pimitives"], "likes": 5, "viewed": 290, "published": 3, "date": "1638380970", "time_retrieved": "2024-07-30T18:44:48.744680", "image_code": "// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n#define MOUSECTRL 0\n    \nbool is0mod3(int i) {return i % 3 == 0;}\n//#define STPSTOP   true) && !is0mod3(\n//#define STPSTOP 2 !=\n#define STPSTOP false && -1 < \n\n#define AA 1\n\n// Half space\nfloat sdHspace(vec3 p, vec3 nrm, float d) {\n    return dot(p, normalize(nrm)) - d;\n}\n\n// Step: whics sides should be turned, base-3 encoded\nint stp;\n\n// Octahedron\nfloat sdOctahedron(vec3 p, float s) {\n    // Take the sides, pointing towards the centre.\n    float f0 = sdHspace(p, vec3(+1., +1., +1.), s);\n    float f1 = sdHspace(p, vec3(-1., +1., +1.), s);\n    float f2 = sdHspace(p, vec3(+1., -1., +1.), s);\n    float f3 = sdHspace(p, vec3(-1., -1., +1.), s);\n    float f4 = sdHspace(p, vec3(+1., +1., -1.), s);\n    float f5 = sdHspace(p, vec3(-1., +1., -1.), s);\n    float f6 = sdHspace(p, vec3(+1., -1., -1.), s);\n    float f7 = sdHspace(p, vec3(-1., -1., -1.), s);\n    // Flip some sides. i and ~i can't be flipped the same time.\n    if(stp % 3 == 1) f0 = -f0;\n    if(stp % 3 == 2) f7 = -f7;\n    if(stp/3 %3 == 1) f1 = -f1;\n    if(stp/3 %3 == 2) f6 = -f6;\n    if(stp/9 %3 == 1) f2 = -f2;\n    if(stp/9 %3 == 2) f5 = -f5;\n    if(stp/27 %3 == 1) f3 = -f3;\n    if(stp/27 %3 == 2) f4 = -f4;\n    // Intersect the halfspaces\n    return max(f1, max(f2, max(f3, max(f4, max(f5, max(f6, max(f7, f0)))))));    \n}\n\nfloat drHspace(vec3 p, vec3 pd, vec3 nrm, float d) {\n    nrm = normalize(nrm); /*\n    dot((p + po * t), nrm) - d = 0 ; find t\n    dot(p, nrm) + dot(po * t, nrm) - d = 0;\n    dot(p, nrm) - d + t * dot(po, nrm) = 0;\n    t = (dot(p, nrm) - d) / abs(dot(pd, nrm)); */\n    return (dot(p, nrm) - d) / abs(dot(pd, nrm));\n}\n\nfloat drOctahedron(vec3 p, vec3 pd, float s) {\n     \n    // Take the sides, pointing towards the centre.\n    float f0 = drHspace(p, pd, vec3(+1., +1., +1.), s);\n    float f1 = drHspace(p, pd, vec3(-1., +1., +1.), s);\n    float f2 = drHspace(p, pd, vec3(+1., -1., +1.), s);\n    float f3 = drHspace(p, pd, vec3(-1., -1., +1.), s);\n    float f4 = drHspace(p, pd, vec3(+1., +1., -1.), s);\n    float f5 = drHspace(p, pd, vec3(-1., +1., -1.), s);\n    float f6 = drHspace(p, pd, vec3(+1., -1., -1.), s);\n    float f7 = drHspace(p, pd, vec3(-1., -1., -1.), s);\n    // Flip some sides. i and ~i can't be flipped the same time.\n    if(stp % 3 == 1) f0 = -f0;\n    if(stp % 3 == 2) f7 = -f7;\n    if(stp/3 %3 == 1) f1 = -f1;\n    if(stp/3 %3 == 2) f6 = -f6;\n    if(stp/9 %3 == 1) f2 = -f2;\n    if(stp/9 %3 == 2) f5 = -f5;\n    if(stp/27 %3 == 1) f3 = -f3;\n    if(stp/27 %3 == 2) f4 = -f4;\n    // Intersect the halfspaces\n    return max(f1, max(f2, max(f3, max(f4, max(f5, max(f6, max(f7, f0)))))));    \n}\n\nfloat drmap(vec3 p, vec3 pd) {\n    return drOctahedron(p, pd, 0.1);\n}\n\nfloat map( in vec3 pos )\n{\n    return sdOctahedron(pos,0.1);\n}\n\n// Render code largely copied from iq\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // 81 position\n    fragCoord = (fragCoord) * 9.0;\n    //fragCoord -= iResolution.xy * 4.0;\n    stp = int(floor(fragCoord.x / iResolution.x) + floor(fragCoord.y / iResolution.y) * 9.0);\n    stp += 81;\n    fragCoord = vec2(mod(fragCoord.x, iResolution.x), mod(fragCoord.y, iResolution.y));\n    if(any(lessThan(min(fragCoord, iResolution.xy - fragCoord), vec2(1. * 9.0)))) {\n        fragColor = vec4(1., 1., 1., 1.);\n        return;\n    }\n    \n    if( (STPSTOP\n        +int(stp / 1 % 3 != 0)\n        +int(stp / 3 % 3 != 0)\n        +int(stp / 9 % 3 != 0)\n        +int(stp /27 % 3 != 0)\n        )) {\n        fragColor = vec4(.5, .5, .5, 1.);\n        return;\n    }\n\n     // camera movement\t\n    #if MOUSECTRL\n    float an = iMouse.x / iResolution.x * 2. - 1.;\n    float an2 = -(iMouse.y / iResolution.y * 2. - 1.);\n    #else\n\tfloat an = 0.37*(iTime-10.0);\n    float an2 = 0.98*sin(iTime);\n    #endif\n    vec3 ro = normalize(vec3( cos(3.14*an) , an2 / (1. - an2*an2), sin(3.14*an) )) * 1.0;\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n        \n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww ) * 1.0;\n\n        // raymarch\n        const float tmax = 3.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = drmap(pos, rd);\n            if( h<0.0001 || t>tmax ) {\n                break;\n            }\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,2.0*vec3(0.5,0.4,0.3)), 0.0, 1.0 );\n            float dif2 = clamp( dot(nor,2.0*vec3(0.4,-0.3,-0.5)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.0,0.0,1.0)*amb + vec3(0.0,1.0,0.0)*dif + vec3(1.0, 0.0, 0.0)*dif2;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lK3WK.jpg", "access": "api", "license": "mit", "functions": [[1070, 1070, 1091, 1091, 1110], [1219, 1233, 1276, 1276, 1317], [1383, 1397, 1434, 1486, 2339], [2341, 2341, 2393, 2393, 2656], [2658, 2658, 2704, 2762, 3647], [3649, 3649, 3679, 3679, 3718], [3720, 3720, 3746, 3746, 3782], [3823, 3869, 3901, 3901, 4140]], "test": "ok"}
{"id": "7lVGWK", "name": "crt meme", "author": "pema99", "description": "to show friend how to do crt effect", "tags": ["crt"], "likes": 0, "viewed": 153, "published": 3, "date": "1638380253", "time_retrieved": "2024-07-30T18:44:49.964418", "image_code": "#define CURVE_X 1.0\n#define CURVE_Y 0.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get coords in [-1; 1]\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv *= 2.0;\n    \n    // Scale x and y as a function of the complement\n    uv.y /= (cos(uv.x * CURVE_X)*0.5+0.5);\n    uv.x /= (cos(uv.y * CURVE_Y)*0.5+0.5);\n    \n    // Scale back to [0; 1]\n    uv /= 2.0;\n    uv += 0.5;\n\n    // Sample texture with bent uvs\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    // Just to show black borders\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.0) col = vec3(0.);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVGWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 98, 127, 632]], "test": "untested"}
{"id": "NtV3WV", "name": "little wolf-lobito", "author": "jorge2017a2", "description": "little wolf-lobito", "tags": ["2d", "draw", "littlewolf", "lobito"], "likes": 8, "viewed": 228, "published": 3, "date": "1638372228", "time_retrieved": "2024-07-30T18:44:50.920861", "image_code": "//por jorge2017a2\n//little wolf-lobito-1-dic-2021\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n//#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n//#define S2(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S(d,b) smoothstep(8.*antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(6.*antialiasing(0.85),b,d)\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0));\nreturn colOut;\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{   p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{   vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nvec3 HacerOjos(vec2 p, vec3 colOut, vec3 colIn)\n{   float d1= sdCircle( p-vec2(0.0,-1.70),0.07 );\n    float d2=sdBox(p-vec2(0.1,-1.9), vec2(0.15,0.005) );\n    colOut= DrawFig(colIn, colOut,d1);\n    colOut= DrawFig(colIn, colOut,d2);\n    return colOut;\n}\n\nvec3 HacerOreja(vec2 p, float ang, vec3 colOut, vec3 colIn)\n{ ///Oreja\n   p= rotatev2(p,ang);\n   float r1=0.25;\n   float r2=0.0001;\n   float h=0.3;\n   float d5= sdTrapezoid(p-vec2(0.5,1.0),r1,r2,h);\n   colOut= DrawFigBorde(colIn, colOut,d5); \n    return colOut;\n}\n   \n\nvec3 HacerRostro2d(vec2 p, vec3 col)\n{    vec2 p0=p;  \n    //oreja der\n    col= HacerOreja(p,radians(45.0),col, vec3(0.7));\n    col= HacerOreja(p*1.2-vec2(0.15,0.0),radians(45.0),col, vec3(0.2));\n    //oreja izq\n    p.x+=0.9;\n    p.y-=0.15;\n    col= HacerOreja(p,radians(15.0),col, vec3(0.7));\n    col= HacerOreja(p*1.2-vec2(0.12,0.0),radians(15.0),col, vec3(0.2)); //izq\n    p=p0;\n    \n    //Cuello\n    float d6= sdBox(p-vec2(0.0,-1.4), vec2(0.2,0.8) );\n   col= DrawFigBorde(vec3(0.4), col,d6);\n   \n    //cabeza\n   p= rotatev2(p,radians(25.0));\n   float d1=sdCircle(p*vec2(0.8,1.6)-vec2(0.0,0.0), 1.0 );\n   col= DrawFigBorde(vec3(0.5), col,d1);\n   p=p0;\n      \n   float angN=10.*sin(iTime);\n   //nariz 1 y boca\n   float r1,r2,h;\n   r1=0.3;\n   r2=0.3;\n   h=1.0;\n   p= rotatev2(p,radians(220.0+angN));\n   float d2=sdUnevenCapsule(p-vec2(0.1,0.4),r1,r2,h);\n   float d3=sdUnevenCapsule(p-vec2(-0.2,0.4),r1,r2,h);\n   col= DrawFigBorde(vec3(0.6), col,d3); //boca\n   col= DrawFigBorde(vec3(0.4), col,d2); //nariz\n   \n   //nariz 2\n   p=p0;\n   p= rotatev2(p,radians(220.0+angN));\n   float d4=sdCircle(p*vec2(0.6,1.2)-vec2(0.05,1.85), 0.15);\n   col= DrawFig(vec3(0.0), col,d4); //nariz 2\n   p=p0;\n   p= rotatev2(p-vec2(-1.1,-1.15),radians(220.0));\n   col= HacerOjos(p-vec2(0.3,0.05),col, vec3(0.1));\n   col= HacerOjos(vec2(-p.x,p.y)-vec2(0.5,-0.1),col, vec3(0.1));\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=2.0;\n    uv*=esc;\n    vec3  col=vec3(0.45,0.7,1.0)-uv.y*0.5/esc;\n    col= HacerRostro2d(uv-vec2(0.0,0.8),col);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtV3WV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[439, 470, 506, 506, 551], [556, 600, 647, 647, 674], [675, 675, 718, 718, 745], [746, 746, 794, 794, 822], [828, 828, 890, 890, 1087], [1089, 1089, 1170, 1170, 1300], [1302, 1302, 1359, 1359, 1430], [1432, 1432, 1466, 1466, 1561], [1563, 1563, 1588, 1588, 1607], [1608, 1608, 1633, 1633, 1652], [1654, 1654, 1691, 1691, 1765], [1767, 1767, 1802, 1802, 1825], [1827, 1827, 1879, 1879, 1995], [1997, 1997, 2059, 2059, 2296], [2298, 2298, 2363, 2363, 2671], [2673, 2673, 2722, 2722, 2926], [2928, 2928, 2989, 2998, 3191], [3197, 3197, 3235, 3235, 4569], [4571, 4571, 4628, 4628, 4902]], "test": "untested"}
{"id": "NlVGDK", "name": "Simple audio visualizer test", "author": "mireq", "description": "Simple spectrum analyzer", "tags": ["audio", "spectrumanalyzer"], "likes": 6, "viewed": 280, "published": 3, "date": "1638359505", "time_retrieved": "2024-07-30T18:44:51.956093", "image_code": "#define SPECTRUM_BARS 30\n\n// colormap https://www.shadertoy.com/view/WlfXRN, https://www.shadertoy.com/view/3lBXR3\n\nvec3 inferno(float t)\n{\n\tconst vec3 c0 = vec3(0.0002189403691192265, 0.001651004631001012, -0.01948089843709184);\n\tconst vec3 c1 = vec3(0.1065134194856116, 0.5639564367884091, 3.932712388889277);\n\tconst vec3 c2 = vec3(11.60249308247187, -3.972853965665698, -15.9423941062914);\n\tconst vec3 c3 = vec3(-41.70399613139459, 17.43639888205313, 44.35414519872813);\n\tconst vec3 c4 = vec3(77.162935699427, -33.40235894210092, -81.80730925738993);\n\tconst vec3 c5 = vec3(-71.31942824499214, 32.62606426397723, 73.20951985803202);\n\tconst vec3 c6 = vec3(25.13112622477341, -12.24266895238567, -23.07032500287172);\n\n\treturn c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n\nvec3 turbo(float t) {\n\tconst vec3 c0 = vec3(0.1140890109226559, 0.06288340699912215, 0.2248337216805064);\n\tconst vec3 c1 = vec3(6.716419496985708, 3.182286745507602, 7.571581586103393);\n\tconst vec3 c2 = vec3(-66.09402360453038, -4.9279827041226, -10.09439367561635);\n\tconst vec3 c3 = vec3(228.7660791526501, 25.04986699771073, -91.54105330182436);\n\tconst vec3 c4 = vec3(-334.8351565777451, -69.31749712757485, 288.5858850615712);\n\tconst vec3 c5 = vec3(218.7637218434795, 67.52150567819112, -305.2045772184957);\n\tconst vec3 c6 = vec3(-52.88903478218835, -21.54527364654712, 110.5174647748972);\n\n\treturn c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n\nvoid showWave(out vec4 fragColor, in vec2 uv, in vec2 resolution)\n{\n\t// Value\n\tfloat y = texelFetch(iChannel0, ivec2(int(uv.x * 512.0), 1), 0).x;\n\t// Derivation of value\n\tfloat dy = dFdx(y);\n\t// Average between two samples\n\tfloat center = y + dy / 2.0;\n\t// Vpoet vekosti pixelu\n\tfloat pixelSize = 1.0 / resolution.y;\n\t// Vertial width of line\n\tfloat lineWidth = max(abs(dy), pixelSize);\n\t// White for zero distance\n\tfloat color = (lineWidth - abs(center - uv.y)) / lineWidth;\n\t// Remove negative values\n\tcolor = max(color, 0.0);\n\t// Final color\n\tfragColor = vec4(vec3(color), 1.0);\n}\n\nvoid showSpectrum(out vec4 fragColor, in vec2 uv, in vec2 resolution)\n{\n\t// Bar nuber\n\tint barNumber = int(uv.x * float(SPECTRUM_BARS));\n\t// Spectrum frequency (range [0, 1])\n\tfloat frequency = (float(barNumber)/float(SPECTRUM_BARS + 1)) + 1.0 / float(SPECTRUM_BARS);\n\t// Load frequency\n\tfloat val = texelFetch(iChannel0, ivec2(int(frequency * 512.0), 0), 0).x;\n\t// Color from palette\n\tvec3 color = turbo(min(val * 1.1, 1.0));\n\t// Display bar with selected color\n\tif (val < uv.y || fract(uv.x * float(SPECTRUM_BARS)) < 0.2) {\n\t\tfragColor = vec4(0, 0, 0, 1);\n\t}\n\telse {\n\t\tfragColor = vec4(color, 1);\n\t}\n}\n\nvoid histogramSpectrum(out vec4 fragColor, in vec2 uv, in vec2 resolution)\n{\n\n\t// Signal, x, y derivate\n\tvec3 signal = texture(iChannel1, uv).xyz;\n\t// Normal from x, y derivate\n\tvec3 normal = normalize(vec3(signal.y, signal.z, 0.1));\n\t// Bmmp mapping\n\tfloat bumpMultiplier = dot(normal, vec3(0.0, 1.0, 1.0)) * 0.5 + 0.5;\n\t// Final color\n\tfragColor = vec4(inferno(signal.x) * bumpMultiplier, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Koordinty [0, 1]\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// Vykreslenie deliacej iary\n\tif (uv.x > 0.7) {\n\t\tif (int(fragCoord.y) == int(iResolution.y) / 2) {\n\t\t\tfragColor = vec4(vec3(0.5), 1.0);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (int(fragCoord.x) == int(float(iResolution.x) * 0.7)) {\n\t\tfragColor = vec4(vec3(0.5), 1.0);\n\t\treturn;\n\t}\n\n\tif (uv.x > 0.7) {\n\t\tuv.x = (uv.x - 0.7) / 0.3;\n\t\tif (uv.y < 0.5) {\n\t\t\tshowSpectrum(fragColor, uv * vec2(1.0, 2.0), iResolution.xy * vec2(1.0, 0.5));\n\t\t}\n\t\telse {\n\t\t\tshowWave(fragColor, (uv - vec2(0.0, 0.5)) * vec2(1.0, 2.0), iResolution.xy * vec2(1.0, 0.5));\n\t\t}\n\t}\n\telse {\n        histogramSpectrum(fragColor, uv * vec2(1.0 / 0.7, 1.0), iResolution.xy * vec2(0.7, 1.0));\n\n\t}\n}\n", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tint freq = int(uv.y*512.0);\n\tfloat val;\n\n\tif (int(fragCoord.x) == 0) {\n\t\tval = texelFetch(iChannel0, ivec2(freq, 0), 0).x;\n\t}\n\telse {\n\t\tval = texelFetch(iChannel1, ivec2(fragCoord) + ivec2(-1, 0), 0).x;\n\t}\n\tfragColor = vec4(val, dFdx(val), dFdy(val), 1);\n}\n", "buffer_a_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlVGDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 139, 139, 771], [774, 774, 795, 795, 1421], [1424, 1424, 1491, 1501, 2013], [2620, 2620, 2696, 2723, 3018], [3020, 3020, 3075, 3098, 3788]], "test": "untested"}
{"id": "flKGDK", "name": "Polar Experiment", "author": "lihengc6", "description": "Experiment plotting with polar coordinates. \nStarter kit for messing around with polar coodinates. ", "tags": ["ray", "wave", "polar", "vibration", "standing"], "likes": 2, "viewed": 237, "published": 3, "date": "1638355998", "time_retrieved": "2024-07-30T18:44:52.793853", "image_code": "// Stat\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( fragCoord - .5* iResolution.xy ) / iResolution.y;\n\n    // Time varying pixel color\n    float t = atan(uv.y/uv.x);\n    float r = length(uv);\n\n    float wave = sin(r*100.0); \n    float ray  = sin(t*20.);\n    // Output to screen\n    \n    vec3 col = vec3(ray*wave); \n    col = vec3(ray*wave); \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flKGDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[10, 10, 67, 117, 461]], "test": "untested"}
{"id": "NlV3WK", "name": "Simplex4D", "author": "zovox", "description": "Purr.", "tags": ["simplex", "4d", "meow"], "likes": 4, "viewed": 390, "published": 3, "date": "1638354377", "time_retrieved": "2024-07-30T18:44:53.643581", "image_code": "//\tSimplex 4D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n}\n\nfloat snoise(vec4 v){\n  const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\n                        0.309016994374947451); // (sqrt(5) - 1)/4   F4\n// First corner\n  vec4 i  = floor(v + dot(v, C.yyyy) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C \n  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n// Permutations\n  i = mod(i, 289.0); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n// Gradients\n// ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n\n\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define FAR (GR)\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.0, 1.0, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define circle(x) (vec2(cos((x)*PI), sin((x)*PI)))\n#define saw(x) fract( sign( 1.- mod( abs(x), 2.) ) * abs(x) )\n\n#define TAO 6.283\nvec2 Rotate(in vec2 v, float angle) {return v*mat2(cos(angle),sin(angle),-sin(angle),cos(angle));}\nvec2 Kaleido(in vec2 v,float power){return Rotate(v,floor(.5+atan(v.x,-v.y)*power/TAO)*TAO/power);}\nfloat HTorus(in vec3 z, float radius1, float radius2){return max(-z.y-0.055,length(vec2(length(z.xy)-radius1,z.z))-radius2-z.x*0.035);}\n\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdSphere( vec3 p, vec3 s, float r )\n{\n    return length(p-s)-r;\n}\n\n\nfloat scale = 3.;\nfloat seed;\nvec3 mcol;\nfloat dfScene(in vec3 z0){\n    mcol = z0*GR;\n    return (snoise(vec4(z0,time))*.5+.5)-1./3.; //Occupy 1./3 of the space... I guess?\n}\n\nvec3 surfaceNormal(vec3 p) { \n    vec2 e = vec2(5.0 / iResolution.y, 0);\n\tfloat d1 = dfScene(p + e.xyy), d2 = dfScene(p - e.xyy);\n\tfloat d3 = dfScene(p + e.yxy), d4 = dfScene(p - e.yxy);\n\tfloat d5 = dfScene(p + e.yyx), d6 = dfScene(p - e.yyx);\n\tfloat d = dfScene(p) * 2.0;\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n//main march\nvec3 marchScene(vec3 ro, vec3 rd) {\n    \n    vec3 pc = vec3(0.0); //returned pixel colour\n    float d = 0.0; //distance marched\n    vec3 rp = vec3(0.0); //ray position\n    vec3 lp = normalize(vec3(5.0, 8.0, -3.0)); //light position\n   \tfloat ns;\n    vec3 p;\n    for (int i = 0; i < 48; i++) {\n        rp = ro + rd * d;\n        p = rp;\n        //seed = floor((rp.x)/scale)*1.2345+floor((rp.z)/scale)*5.4321;\n        //p.xz = (fract((rp.xz)/scale)-.5)*scale;\n        ns = dfScene(p);\n        d += ns;\n        if(d > FAR || ns < 0.)\n        {\n            break;\n        }\n        \n    }\n    vec3 sky_color = vec3(.35, .35, .85);\n    float fog = smoothstep(.75, .9, d/FAR);\n    \n\n    vec3 n = surfaceNormal(p);\n    vec3 sc = saw(mcol); //surface colour\n\n    float diff = max(dot(n, lp), 0.0); //diffuse\n    pc = sc * 0.5 + diff * sc ;\n    float spe = pow(max(dot(reflect(rd, n), lp), 0.), 16.); //specular.\n    pc = (pc + spe * vec3(1.0))*(1.-fog)+fog*sky_color;\n    \n    return pc*(1.-smoothstep(.5, 1., d/FAR));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    \n    //coordinate system\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, -2.));\n    vec3 ro = vec3(0.0, 0.0, 2.);\n    \n    float movement = time/PI;\n    \n    //rotate camera\n    rd.xz *= rot(cos(movement)*PI*4.);\n    ro += rd;\n    //*/\n    \n    \n    fragColor = vec4(marchScene(ro, rd), 1.0);    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlV3WK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 54, 75, 75, 112], [113, 113, 136, 136, 180], [181, 181, 208, 208, 256], [257, 257, 286, 286, 334], [336, 336, 365, 365, 626], [628, 628, 649, 649, 2934], [3946, 3946, 3983, 3983, 4044], [4045, 4045, 4081, 4081, 4144], [4145, 4145, 4199, 4199, 4280], [4282, 4282, 4301, 4301, 4353], [4355, 4355, 4398, 4398, 4426], [4470, 4470, 4496, 4496, 4603], [4605, 4605, 4633, 4633, 4935], [4937, 4950, 4985, 4985, 5961], [5964, 5964, 6019, 6053, 6443]], "test": "untested"}
{"id": "NlKGWK", "name": "Lonely Waters", "author": "Tater", "description": "My attempt at a procedural ocean. It should run pretty fast, I got 60fps on my phone. ", "tags": ["3d", "raymarching", "waves", "sea", "sun", "clouds", "water", "ocean", "sky"], "likes": 200, "viewed": 6548, "published": 3, "date": "1638349551", "time_retrieved": "2024-07-30T18:44:54.469373", "image_code": "//Set to 2.0 for AA\n#define AA 1.0\n\n#define STEPS 80.0\n#define MDIST 35.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define sat(a) clamp(a,0.0,1.0)\n\n#define ITERS_TRACE 9\n#define ITERS_NORM 20\n\n#define HOR_SCALE 1.1\n#define OCC_SPEED 1.4\n#define DX_DET 0.65\n\n#define FREQ 0.6\n#define HEIGHT_DIV 2.5\n#define WEIGHT_SCL 0.8\n#define FREQ_SCL 1.2\n#define TIME_SCL 1.095\n#define WAV_ROT 1.21\n#define DRAG 0.9\n#define SCRL_SPEED 1.5\nvec2 scrollDir = vec2(1,1);\n\n\n//Built with some ideas from\n//https://www.shadertoy.com/view/wldBRf\n//https://www.shadertoy.com/view/ssG3Wt\n//https://www.shadertoy.com/view/4dBcRD\n//https://www.shadertoy.com/view/Xdlczl\nvec2 wavedx(vec2 wavPos, int iters, float t){\n    vec2 dx = vec2(0);\n    vec2 wavDir = vec2(1,0);\n    float wavWeight = 1.0; \n    wavPos+= t*SCRL_SPEED*scrollDir;\n    wavPos*= HOR_SCALE;\n    float wavFreq = FREQ;\n    float wavTime = OCC_SPEED*t;\n    for(int i=0;i<iters;i++){\n        wavDir*=rot(WAV_ROT);\n        float x = dot(wavDir,wavPos)*wavFreq+wavTime; \n        float result = exp(sin(x)-1.)*cos(x);\n        //if(result>0.) foam+=result*0.3;\n        result*=wavWeight;\n        dx+= result*wavDir/pow(wavWeight,DX_DET); \n        wavFreq*= FREQ_SCL; \n        wavTime*= TIME_SCL;\n        wavPos-= wavDir*result*DRAG; \n        wavWeight*= WEIGHT_SCL;\n    }\n    float wavSum = -(pow(WEIGHT_SCL,float(iters))-1.)*HEIGHT_DIV; \n    return dx/pow(wavSum,1.-DX_DET);\n}\n\nfloat wave(vec2 wavPos, int iters, float t){\n    float wav = 0.0;\n    vec2 wavDir = vec2(1,0);\n    float wavWeight = 1.0;\n    wavPos+= t*SCRL_SPEED*scrollDir;\n    wavPos*= HOR_SCALE; \n    float wavFreq = FREQ;\n    float wavTime = OCC_SPEED*t;\n    for(int i=0;i<iters;i++){\n        wavDir*=rot(WAV_ROT);\n        float x = dot(wavDir,wavPos)*wavFreq+wavTime;\n        float wave = exp(sin(x)-1.0)*wavWeight;\n        wav+= wave;\n        wavFreq*= FREQ_SCL;\n        wavTime*= TIME_SCL;\n        wavPos-= wavDir*wave*DRAG*cos(x);\n        wavWeight*= WEIGHT_SCL;\n    }\n    float wavSum = -(pow(WEIGHT_SCL,float(iters))-1.)*HEIGHT_DIV; \n    return wav/wavSum;\n}\n\nvec3 norm(vec3 p){\n    vec2 wav = -wavedx(p.xz, ITERS_NORM, iTime);\n    return normalize(vec3(wav.x,1.0,wav.y));\n}\n\nfloat map(vec3 p){\n    float a = 0.;\n    int steps = ITERS_TRACE;\n    p.y-= wave(p.xz,steps,iTime);\n    a = p.y;\n    return a;\n}\n\nvec3 pal(float t, vec3 a, vec3 b, vec3 c, vec3 d){\n    return a+b*cos(2.0*pi*(c*t+d));\n}\nvec3 spc(float n,float bright){\n    return pal(n,vec3(bright),vec3(0.5),vec3(1.0),vec3(0.0,0.33,0.67));\n}\nvec2 sunrot = vec2(-0.3,-0.25);\n\n//Change the color of the scene here, it better withs some colors than others\nfloat spec = 0.13;\n\nvec3 sky(vec3 rd){\n    float px = 1.5/min(iResolution.x,iResolution.y);\n    vec3 rdo = rd;\n    float rad = 0.075;\n    vec3 col = vec3(0);\n\n    //Sun\n    rd.yz*=rot(sunrot.y);\n    rd.xz*=rot(sunrot.x);\n    float sFade = 2.5/min(iResolution.x,iResolution.y);\n    float zFade = rd.z*0.5+0.5;\n    \n    vec3 sc = spc(spec-0.1,0.6)*0.85;\n    float a = length(rd.xy);\n    vec3 sun=smoothstep(a-px-sFade,a+px+sFade,rad)*sc*zFade*2.;\n    col+=sun;\n    col+=rad/(rad+pow(a,1.7))*sc*zFade;\n    col=col+mix(col,spc(spec+0.1,0.8),sat(1.0-length(col)))*0.2;\n    \n    //This code provides the implication of clouds :)\n    float e = 0.;\n    vec3 p = rdo;\n    p.xz*=0.4;\n    p.x+=iTime*0.007;\n    for(float s=200.;s>10.;s*=0.8){\n        p.xz*=rot(s);\n        p+=s;\n        e+=abs(dot(sin(p*s+iTime*0.02)/s,vec3(1.65)));\n    }\n    e*=smoothstep(0.5,0.4,e-0.095);\n    \n    col += (e)*smoothstep(-0.02,0.3,rdo.y)*0.8*(1.0-sun*3.75)*mix(sc,vec3(1),0.4);\n    \n    return (col);\n}\nvoid render( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/min(iResolution.y,iResolution.x);\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,2.25,-3)*1.1;\n    bool click = iMouse.z>0.;\n    if(click){\n    ro.yz*=rot(2.0*min(iMouse.y/iResolution.y-0.5,0.15));\n    ro.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n    }\n    vec3 lk = vec3(0,2,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(0.9)+uv.x*r+uv.y*cross(f,r));\n\n    float dO = 0.;\n    bool hit = false;\n    float d = 0.;\n    vec3 p = ro;\n\n    float tPln = -(ro.y-1.86)/rd.y;\n    if(tPln>0.||click){\n        if(!click)dO+=tPln;\n        for(float i = 0.; i<STEPS; i++){\n            p = ro+rd*dO;d = map(p);dO+=d;\n            if(abs(d)<0.005||i>STEPS-2.0){\n                hit = true;\n                break;\n            }\n            if(dO>MDIST){\n                dO = MDIST;\n                break;\n            }\n        }\n    }\n    vec3 skyrd = sky(rd);\n    if(hit){\n    vec3 n = norm(p);\n    vec3 rfl = reflect(rd,n);\n    rfl.y = abs(rfl.y);\n    vec3 rf = refract(rd,n,1./1.33); \n    vec3 sd = normalize(vec3(0,0.3,-1.0));\n    float fres = clamp((pow(1. - max(0.0, dot(-n, rd)), 5.0)),0.0,1.0);\n\n    vec3 sunDir = vec3(0,0.15,1.0);\n    sunDir.xz*=rot(-sunrot.x);\n    col += sky(rfl)*fres*0.9;\n    float subRefract =pow(max(0.0, dot(rf,sunDir)),35.0);\n    //This effect is exaggerated much more than is realistic because I like it :) \n    col += pow(spc(spec-0.1,0.5),vec3(2.2))*subRefract*2.5;\n    vec3 rd2 = rd;\n    rd2.xz*=rot(sunrot.x);\n    vec3 waterCol = min(sat(spc(spec-0.1,0.4))*0.05*pow(min(p.y+0.5,1.8),4.0)*length(skyrd)*(rd2.z*0.3+0.7),1.0);\n   \n    waterCol = sat(spc(spec-0.1,0.4))*(0.4*pow(min(p.y*0.7+0.9,1.8),4.)*length(skyrd)*(rd2.z*0.15+0.85));\n    col += waterCol*0.17;\n    //col+=smoothstep(0.95,1.55,wave(p.xz,25,iTime))*mix(waterCol*0.3,vec3(1),0.2)*0.2;\n\n    col = mix(col,skyrd,dO/MDIST);\n    }\n    else{\n        col += skyrd;\n    }\n    col = sat(col);\n    col = pow(col,vec3(0.87));\n    col *=1.0-0.8*pow(length(uv*vec2(0.8,1.)),2.7);\n    fragColor = vec4(col,1.0);\n    \n}\n\n#define ZERO min(0.0,iTime)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.0/AA;\n    vec4 col = vec4(0);\n    \n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    \n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKGWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[489, 678, 723, 723, 1443], [1445, 1445, 1489, 1489, 2097], [2099, 2099, 2117, 2117, 2213], [2215, 2215, 2233, 2233, 2343], [2345, 2345, 2395, 2395, 2433], [2434, 2434, 2465, 2465, 2539], [2671, 2671, 2689, 2689, 3628], [3629, 3629, 3682, 3682, 5778], [5808, 5808, 5865, 5865, 6279]], "test": "untested"}
{"id": "NtKGWK", "name": "Texture Pattern 02", "author": "andrinr", "description": "Give it a few seconds", "tags": ["maze"], "likes": 3, "viewed": 254, "published": 3, "date": "1638345799", "time_retrieved": "2024-07-30T18:44:55.267240", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat du = 1. / iResolution.x;\n    float dv = 1. / iResolution.y;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float l = texture(iChannel0,uv + vec2(-du,0)).x;\n    float lu = texture(iChannel0,uv + vec2(-du,dv)).x;\n    float ld = texture(iChannel0,uv + vec2(-du,-dv)).x;\n    \n    float d = texture(iChannel0,uv + vec2(0,-dv)).x;\n    float u = texture(iChannel0,uv + vec2(0,dv)).x;\n    \n    float r = texture(iChannel0,uv + vec2(du,0)).x;\n    float ru = texture(iChannel0,uv + vec2(du,dv)).x;\n    float rd = texture(iChannel0,uv + vec2(du,-dv)).x;\n    \n    float c =  texture(iChannel0,uv).x;\n    \n    float a = 8.0 * c + (-1.0) * (l + lu + ld + d + u + r + ru + rd);\n    \n    vec3 col = vec3(a);\n    fragColor = vec4( col,1.);\n    //fragColor = vec4(buffer,1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Andrin Rehmann\n// 2021\n// andrinrehmann.ch\n// andrinrehmann@gmail.com\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat rand( vec2 uv )\n{\n\tfloat t = fract( iTime );\n\treturn nrand( uv + 0.07*t );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat du = 1. / iResolution.x;\n    float dv = 1. / iResolution.y;\n    \n\tvec2 uv = fragCoord/iResolution.xy;\n    \n    // Cell\n\tfloat y = texture(iChannel0,uv).x;\n    \n    // sum of surrounding y's\n    float l = texture(iChannel0,uv + vec2(-du,0)).x;\n    float d = texture(iChannel0,uv + vec2(0,-dv)).x;\n    float u = texture(iChannel0,uv + vec2(0,dv)).x;\n    float r = texture(iChannel0,uv + vec2(du,0)).x;\n\n    float tl = 0.4;\n    float tu = 0.6;\n    // \n    if (u > tu && d < tl || \n        d > tu  && u < tl || \n        l > tu && r < tl ||  \n        r > tu && l < tl)\n    {\n        y += 0.3;\n    }\n    else\n    {\n        y *= 0.98;\n    }\n    \n    \n    //y *= 0.99;\n    \n    // sum of surrounding y's\n    float s = 1./16. * texture(iChannel0,uv + vec2(-du,-dv)).x +\n              3./16.  * texture(iChannel0,uv + vec2(-du,0)).x + \n              1./16. * texture(iChannel0,uv + vec2(-du,dv)).x + \n              3./16.  * texture(iChannel0,uv + vec2(0,-dv)).x + \n              3./16.  * texture(iChannel0,uv + vec2(0,dv)).x +\n              1./16. * texture(iChannel0,uv + vec2(du,-dv)).x +\n              3./16.  * texture(iChannel0,uv + vec2(du,0)).x + \n              1./16. * texture(iChannel0,uv + vec2(du,dv)).x;\n              \n    y = 0.85 * y + 0.15 * s;\n\n\n    if (rand(uv) > 0.9996)\n    {\n        y = 1.0;\n    }\n    \n    // Mouse interaction\n    if (distance(iMouse.xy, fragCoord) < 20. && iMouse.z > 0.){\n        y = 1.0;\n    }\n    \n    // Init\n    if (iFrame < 1){\n        y = float(int(rand(uv)*2.0));\n    }\n    \n    fragColor = vec4(y, 0, 0, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtKGWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 826]], "test": "untested"}
{"id": "7ly3DV", "name": "Texture Pattern 01", "author": "andrinr", "description": "Give it a few seconds", "tags": ["maze"], "likes": 2, "viewed": 193, "published": 3, "date": "1638345312", "time_retrieved": "2024-07-30T18:44:56.307459", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 buffer = texture(iChannel0,uv).xyz;\n    float r = sin(buffer.x);\n    float g = sin(buffer.x + 2.0);\n    float b = sin(buffer.x + 1.0);\n    //r = float(int(r * 1.7));\n    vec3 col = vec3(r) * buffer.x;\n    fragColor = vec4( col,1.);\n    //fragColor = vec4(buffer,1.);\n    }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Andrin Rehmann\n// 2021\n// andrinrehmann.ch\n// andrinrehmann@gmail.com\n\n#define EXPANSION 2.5\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat rand( vec2 uv )\n{\n\tfloat t = fract( iTime );\n\treturn nrand( uv + 0.07*t );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat du = 1. / iResolution.x;\n    float dv = 1. / iResolution.y;\n    \n\tvec2 uv = fragCoord/iResolution.xy;\n    \n    // Cell\n\tfloat y = texture(iChannel0,uv).x;\n    \n    // sum of surrounding y's\n    float l = texture(iChannel0,uv + vec2(-du,0)).x;\n    float d = texture(iChannel0,uv + vec2(0,-dv)).x;\n    float u = texture(iChannel0,uv + vec2(0,dv)).x;\n    float r = texture(iChannel0,uv + vec2(du,0)).x;\n\n    float tl = 0.4;\n    float tu = 0.6;\n    // \n    if (u > tu && d < tl || \n        d > tu  && u < tl || \n        l > tu && r < tl ||  \n        r > tu && l < tl)\n    {\n        y += 0.15;\n    }\n    else\n    {\n        y *= 0.99;\n    }\n    \n    \n    //y *= 0.99;\n    \n    // sum of surrounding y's\n    float s = 1./16. * texture(iChannel0,uv + vec2(-du,-dv)).x +\n              3./16.  * texture(iChannel0,uv + vec2(-du,0)).x + \n              1./16. * texture(iChannel0,uv + vec2(-du,dv)).x + \n              3./16.  * texture(iChannel0,uv + vec2(0,-dv)).x + \n              3./16.  * texture(iChannel0,uv + vec2(0,dv)).x +\n              1./16. * texture(iChannel0,uv + vec2(du,-dv)).x +\n              3./16.  * texture(iChannel0,uv + vec2(du,0)).x + \n              1./16. * texture(iChannel0,uv + vec2(du,dv)).x;\n              \n    y = 0.91 * y + 0.09 * s;\n\n\n    if (rand(uv) > 0.9998)\n    {\n        y = 1.0;\n    }\n    \n    // Mouse interaction\n    if (distance(iMouse.xy, fragCoord) < 1. && iMouse.z > 0.){\n        y = 1.0;\n    }\n    \n    // Init\n    if (iFrame < 1){\n        y = float(int(rand(uv)*2.0));\n    }\n    \n    fragColor = vec4(y, 0, 0, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ly3DV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 429]], "test": "untested"}
{"id": "7lGGWV", "name": "2d smiling", "author": "jorge2017a2", "description": "2d smiling", "tags": ["2dsmiling"], "likes": 8, "viewed": 215, "published": 3, "date": "1638329023", "time_retrieved": "2024-07-30T18:44:57.393555", "image_code": "//por jorge2017a2\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(8.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0));\nreturn colOut;\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nvec2 RotatePOA(in vec2 p, in vec2 o, in float a) {\n    float c = cos(a), s = sin(a);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{   p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c=sin/cos of aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nvec3 HacerOjos(vec2 p, vec3 col)\n{   vec2 p0=p; \n    float t=radians(37.71);\n    float sn=sin(t);float cs=cos(t);\n    \n    p= RotatePOA(p,vec2(0.0,0.0), radians(90.0));\n    float d1= sdPie(p, vec2(sn,cs), 0.5 );\n    p=p0;\n    float d2=sdCircle(p-vec2(0.3,0.1), 0.05 );\n    \n    col= DrawFigBorde(vec3(1.0,0.8,0.8), col,d1);\n    col= DrawFigBorde(vec3(0.0), col,d2);\n    return col;\n}\n\nvec3 HacerBoca(vec2 p, vec3 col)\n{   vec2 p0=p;\n    float d1= sdCircle(p-vec2(0.0,0.0), 0.8 );\n    float d2= sdCircle(p-vec2(0.2,0.6), 1.2 );\n    float diff=differenceSDF(d1, d2);\n    col= DrawFigBorde(vec3(0.4), col,diff);    \n    return col;\n}\n\nvec3 hacerPelo(vec2 p, vec3 col)\n{   vec2 p0=p;\n    vec2 v0A = vec2(0.0,0.0);\n    vec2 v1A = vec2(-0.5,0.9);\n    vec2 v2A = vec2(-1.0,1.0);\n    float b1 = abs(sdBezier( p-vec2(-0.5,0.6), v0A,v1A,v2A )-0.01); \n    col= DrawFig(vec3(0.), col,b1);\n    return col;\n}\n\nvec3 HacerRostro2d(vec2 p, vec3 col)\n{   vec2 p0=p; \n    //pelo\n    col= hacerPelo(p-vec2(0.0), col);\n    col= hacerPelo(p-vec2(0.2,0.2), col);\n    col= hacerPelo(p-vec2(0.4,0.4), col);\n\n    //Cuello\n    float d3=sdBox(p-vec2(0.0,-0.5), vec2(0.2,1.0) );\n    col= DrawFigBorde(vec3(0.4,0.54,0.87), col,d3);\n\n    //cabeza\n    float d1a= sdCircle(p-vec2(0.0,0.0),1.0 );\n    float d1b= sdCircle(p*vec2(0.5,1.0)-vec2(0.2,-0.3),0.5 );\n    float duni= unionSDF(d1a, d1b);\n    col= DrawFigBorde(vec3(0.4,0.54,0.87), col,duni);\n    //boca\n    col= HacerBoca(p-vec2(0.0), col);\n    \n    //ojos\n     float t=iTime;\n    float sn=0.15*sin(t);\n    p.y+=sn;\n    col= HacerOjos(p-vec2(0.0,0.5), col);\n    col= HacerOjos(p-vec2(-0.5,0.5), col);\n    p=p0;\n    //hacer nariz\n    float d2a=sdCircle(p-vec2(1.0,-0.4),0.0001 );\n    float d2b=sdCircle(p-vec2(1.2,-0.4),0.0001 );\n    col= DrawFig(vec3(0.), col,d2a);\n    col= DrawFig(vec3(0.), col,d2b);\n    return col;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=2.0;\n    uv*=esc;\n\n    vec3  col=vec3(0.45,0.7,1.0)-uv.y*0.5/esc;\n    col= HacerRostro2d(uv-vec2(0.0,0.5),col);\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n\n// signed distance to a quadratic bezier\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p  = ky - kx*kx;\n    float q  = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float p3 = p*p*p;\n    float q2 = q*q;\n    float h  = q2 + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n\n        #if 0\n        // When p0 and p<0, h-q has catastrophic cancelation. So, we do\n        // h=(q+4p)=q(1+4p/q)=q(1+w) instead. Now we approximate\n        //  by a linear Taylor expansion into hq(1+w) so that the q's\n        // cancel each other in h-q. Expanding and simplifying further we\n        // get x=vec2(p/q,-p/q-q). And using a second degree Taylor\n        // expansion instead: x=vec2(k,-k-q) with k=(1-p/q)p/q\n        if( abs(p)<0.001 )\n        {\n            float k = p3/q;              // linear approx\n          //float k = (1.0-p3/q2)*p3/q;  // quadratic approx \n            x = vec2(k,-k-q);  \n        }\n        #endif\n\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        vec2  q = d+(c+b*t)*t;\n        res = dot2(q);\n    \tsgn = cross2(c+2.0*b*t,q);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cross2(c+2.0*b*t.x,qx);\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cross2(c+2.0*b*t.y,qy);\n        if( dx<dy ) { res=dx; sgn=sx; } else {res=dy; sgn=sy; }\n    }\n    \n    return sqrt( res )*sign(sgn);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGGWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[300, 331, 367, 367, 412], [417, 461, 508, 508, 535], [536, 536, 579, 579, 606], [607, 607, 655, 655, 683], [689, 689, 751, 751, 948], [950, 950, 1031, 1031, 1161], [1163, 1163, 1220, 1220, 1291], [1293, 1293, 1327, 1327, 1422], [1425, 1425, 1475, 1475, 1555], [1557, 1557, 1594, 1594, 1668], [1670, 1670, 1705, 1705, 1728], [1730, 1730, 1782, 1782, 1898], [1900, 1900, 1949, 1949, 2115], [2117, 2117, 2151, 2151, 2500], [2502, 2502, 2536, 2536, 2747], [2749, 2749, 2783, 2783, 3011], [3013, 3013, 3051, 3051, 3960], [3966, 3966, 4023, 4023, 4299]], "test": "untested"}
{"id": "NtG3DV", "name": "Grid Segments fork", "author": "SnoopethDuckDuck", "description": "I don't like this + artifact at 0 angle", "tags": ["e"], "likes": 14, "viewed": 437, "published": 3, "date": "1638317533", "time_retrieved": "2024-07-30T18:44:58.358973", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 thc(float a, vec3 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat h21 (float a, float b, float sc) {\n    a = mod(a, sc); b = mod(b, sc);\n    return fract(sin(dot(vec2(a, b), vec2(12.9898, 78.233)))*43758.5453123);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 pnt(vec2 ipos, float sc) {\n    float h = h21(ipos.x, ipos.y, sc);\n    float t = iTime + 10. * h;\n    float k = 1.5 +  h;\n    return 0.4 * vec2(thc(4. * (1.-h), 100. + k * t), \n                      ths(4. * h, 100. + (1.-k) * t));\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b * cos(6.28318*(c*t+d) );\n}\n\n// idk what to call this\nvec2 func(float t) {\n    return vec2(.5 + .5 * cos(t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/ iResolution.y;\n    vec2 ouv = uv;\n    vec2 ms = (iMouse.xy - 0.5 * iResolution.xy)/ iResolution.y;\n    //uv += 2. + 0.04 * iTime;\n    \n    float a = atan(uv.y, uv.x);\n    float r = length(uv); \n    uv = vec2(4. * a/pi, log(r) - 0.1 * iTime);\n    \n    float c = 100.;\n    // cant scale dynamically because sc used in h21 (bad)\n    float sc = 5.;// + 1./length(ouv-ms);\n    vec2 fpos = fract(sc * uv) - 0.;\n    vec2 ipos = floor(sc * uv) + 0.5;    \n    \n    // Generate values for each corner of uv (sloppy)\n    float l  = h21(ipos.x + 1., ipos.y,      c * sc);\n    float t  = h21(ipos.x,      ipos.y + 1., c * sc);\n    float tl = h21(ipos.x + 1., ipos.y + 1., c * sc);\n    float id = h21(ipos.x,      ipos.y,      c * sc);\n\n    // Smooth fpos completely, so v noise looks better\n    vec2 sfpos = fpos * fpos * (3. - 2. * fpos);\n    \n    // Smooth the grid uvs so different uvs meet continuously on the edges\n    //fpos = mix(fpos, fpos * fpos * (3. - 2. * fpos), 0.5 * thc(4., iTime));\n    \n    // Box lerp between the corner values to get a radius value for this pixel\n    float v = l  * sfpos.x      * (1.-sfpos.y)\n     \t    + t  * (1.-sfpos.x) * sfpos.y\n     \t    + tl * sfpos.x      * sfpos.y\n      \t    + id * (1.-sfpos.x) * (1.-sfpos.y);\n    \n    // shift fpos correctly\n    fpos -= 0.5;\n    \n    // moving points for each cell\n    vec2 p = pnt(ipos, sc);\n\n    vec2 pl = -vec2(1.,0.) + pnt(ipos - vec2(1.,0.), sc);\n    vec2 pr =  vec2(1.,0.) + pnt(ipos + vec2(1.,0.), sc);\n    vec2 pt = -vec2(0.,1.) + pnt(ipos - vec2(0.,1.), sc);\n    vec2 pb =  vec2(0.,1.) + pnt(ipos + vec2(0.,1.), sc);\n    \n    // used to change intensity of each segment\n    float rl = h21(vec2((ipos.x - 1.) * ipos.x, ipos.y));\n    float rr = h21(vec2((ipos.x + 1.) * ipos.x, ipos.y));\n    float rt = h21(vec2(ipos.x, (ipos.y - 1.) * ipos.y));\n    float rb = h21(vec2(ipos.x, (ipos.y + 1.) * ipos.y));   \n    \n    // draw half of each segment for each cell\n    float dl = sdSegment(fpos, p, pl);\n    float dr = sdSegment(fpos, p, pr);\n    float dt = sdSegment(fpos, p, pt);\n    float db = sdSegment(fpos, p, pb);\n        \n    // Outline line segments, scale with v\n    // (m = thickness of line, n = thickness of outline)  \n    float m = 0.05 + 0.07 * v;\n    float ml = m + 0.1 * cos(length(p - pl));\n    float mr = m + 0.1 * cos(length(pr - p));\n    float mt = m + 0.1 * cos(length(p - pt));\n    float mb = m + 0.1 * cos(length(pb - p));\n    float mm = 0.1;\n    ml = min(ml, mm);mr = min(mr, mm);mt = min(mt, mm);mb = min(mb, mm);\n      \n    float n = 0.18;\n    float sl = rl * (step(0.,ml - dl)-step(0., n * ml - dl));\n    float sr = rr * (step(0.,mr - dr)-step(0., n * mr - dr));\n    float st = rt * (step(0.,mt - dt)-step(0., n * mt - dt));\n    float sb = rb * (step(0.,mb - db)-step(0., n * mb - db));\n    \n    /*\n    float n2 = 0.08 * h21(uv);  \n    float sl = rl * (smoothstep(-n2,n2,ml - dl)-smoothstep(-n2,n2, n * ml - dl));\n    float sr = rr * (smoothstep(-n2,n2,mr - dr)-smoothstep(-n2,n2, n * mr - dr));\n    float st = rt * (smoothstep(-n2,n2,mt - dt)-smoothstep(-n2,n2, n * mt - dt));\n    float sb = rb * (smoothstep(-n2,n2,mb - db)-smoothstep(-n2,n2, n * mb - db));\n    //*/\n    float s = max(max(sl, sr), max(st, sb));\n    \n    // Segment colors\n    vec3 col = 1. * s + s * pal(0.5 * v + r * 0.5 - 0.3 * iTime, vec3(0.), vec3(1.), vec3(1.),  \n                  2. * r * cos(s + 0.15 * iTime) * vec3(0.,0.33,0.66));\n\n    col = clamp(8. * pow(length(ouv), 2.) * col, vec3(0.), col);\n    \n    fragColor = vec4(col, 1.); //vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtG3DV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 191, 191, 232], [234, 234, 254, 254, 329], [331, 331, 371, 371, 486], [488, 488, 540, 540, 659], [661, 661, 692, 692, 898], [900, 900, 968, 968, 1012], [1014, 1039, 1059, 1059, 1096], [1098, 1098, 1155, 1155, 4727]], "test": "untested"}
{"id": "stGGWK", "name": "Folding Space", "author": "creikey", "description": "Based off of https://www.shadertoy.com/view/ftG3D1", "tags": ["space", "folding"], "likes": 7, "viewed": 226, "published": 3, "date": "1638316375", "time_retrieved": "2024-07-30T18:44:59.345337", "image_code": "\n\n// Based on:\n// KIFS City by leon denise 2021/11/22\n// example of how to go to fractal city\n// which is a cubic kaleidoscopic shape carving volume\n// using code from Inigo Quilez, LJ, Fabrice Neyret and many others\n// licensed under hippie love conspiracy\n\nmat2 rot (float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\nfloat map (vec3 p)\n{\n  float scene = 100.;\n  float t = iTime/5.0;\n  float falloff = 5.0;\n  for (float index = 0.; index < 7.; ++index)\n  {\n    p.xz *= rot(t/falloff);\n    p.yz *= rot(t/falloff);\n    p = abs(p)-0.3*falloff;\n    p *= 0.98;\n    scene = min(scene, max(p.x, max(p.y, p.z)));\n    falloff /= 1.85;\n  }\n  return -scene;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2.*(fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n  vec3 pos = vec3(0);\n  vec3 ray = normalize(vec3(uv * rot(iTime/5.0), 1));\n  float shade = 0.;\n  const float count = 20.;\n  for (float index = count; index > 0.; index -= 1.0)\n  {\n    float dist = map(pos);\n    if (dist < 0.001)\n    {\n      shade = index/count + 0.1;\n      break;\n    }\n    pos += ray * dist;\n  }\n  //fragColor = vec4(1.0 - pow(shade, 0.9));\n  fragColor = vec4(shade*0.7, shade*0.7, shade, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGGWK.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[259, 259, 279, 279, 324], [326, 326, 346, 346, 656], [658, 658, 715, 715, 1195]], "test": "untested"}
