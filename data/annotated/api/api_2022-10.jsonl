{"id": "msf3zl", "name": "Sphere Raytracing 2.0", "author": "FifthStateOfMatter", "description": "Raytracing", "tags": ["3d"], "likes": 0, "viewed": 175, "published": 3, "date": "1667254853", "time_retrieved": "2024-07-30T16:23:34.581043", "image_code": "#define fogDensity 2.0\n#define fogColor vec3(0.4, 0.6, 0.9)\n#define lPos vec3(10, 20, -20)\n#define PI 3.1415926545\n#define degreesToRadians PI/180.0\n#define FOV 70.0*degreesToRadians\n\nconst float f = 1.0/tan(FOV/2.0);\nconst float aperture = 0.015;\nconst float focalLength = 14.1;\n\nstruct material{\n    vec3 col;\n    float intensity;\n    float type;\n};\n\nstruct sphere{\n    vec3 pos;\n    float rad;\n    material mat;\n};\n\nstruct camera{\n    vec3 o;\n    vec3 d;\n};\n\nsphere[] scene = sphere[](\n    sphere(lPos, 1.0, material(vec3(1), 0.0, 0.0)),\n    sphere(vec3(2, -0.5, 2), 0.5, material(vec3(0, 1, 0), 0.8, 3.0)),\n    sphere(vec3(5, 0, 12), 1.0, material(vec3(1, 0, 0.5), 0.9, 3.0)),\n    sphere(vec3(4, -0.3, 6), 0.7, material(vec3(1, 1, 0), 0.3, 3.0)),\n    sphere(vec3(-4, -0.1, 3), 0.9, material(vec3(0, 1, 1), 0.5, 3.0)),\n    sphere(vec3(0, -1001, 5), 1000.0, material(vec3(1), 0.9, 3.0)),\n    sphere(vec3(-2, 1, 8), 2.0, material(vec3(1, 0.4, 0), 0.8, 3.0)),\n    sphere(vec3(3, 0, 12), 1.0, material(vec3(0, 0, 0.5), 0.9, 3.0)),\n    sphere(vec3(6, -0.3, 8), 0.7, material(vec3(1, 0, 0), 0.3, 3.0)),\n    sphere(vec3(-2, -0.7, 5), 0.3, material(vec3(1, 0.3, 0), 0.5, 3.0))\n);\n\nbool raytraceSphere(vec3 o, vec3 d, out float t, sphere s, out material mat){\n    vec3 oc = o - s.pos;\n    float a = dot(d, d);\n    float b = 2.0*dot(oc, d);\n    float c = dot(oc, oc) - s.rad*s.rad;\n    float disc = b*b - 4.0*a*c;\n    t = (-b - sqrt(disc))/2.0*a;\n    mat = s.mat;\n    if(disc >= 0.0){\n        return true;\n    }\n    return false;\n}\n\nbool raytraceScene(float type, vec3 o, vec3 d, out float t, out material mat, out int Index){\n    float initT = 1000000000.0;\n    bool r;\n    int index;\n    for(int i = 0; i < scene.length(); i++){\n        float testT;\n        bool rt = raytraceSphere(o, d, testT, scene[i], mat);\n        if(rt && testT < initT && testT >= 0.0){\n            r = true;\n            initT = testT;\n            index = i;\n        }\n    }\n    t = initT;\n    Index = index;\n    mat = scene[Index].mat;\n    return r;\n}\n\nvec3 getNormals(vec3 h, sphere s){\n    return normalize(h - s.pos);\n}\n\nvec3 reflectRay(vec3 r, vec3 n){\n    return r - 2.0*n*dot(r, n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 initCol = vec3(0);\n    vec3 col = fogColor;\n    \n    //scene[scene.length() - 1].pos = vec3(0, 1, 8);\n\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    mat3 projection;\n    projection[0] = vec3(1, 0, 0);\n    projection[1] = vec3(0, 1, 0);\n    projection[2] = vec3(0, 0, f);\n    \n    camera cam = camera(vec3(0, 5, -6), vec3(20, 0, 0));\n    \n    mat3 xRotation;\n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, cos(cam.d.x*degreesToRadians), -sin(cam.d.x*degreesToRadians));\n    xRotation[2] = vec3(0, sin(cam.d.x*degreesToRadians), cos(cam.d.x*degreesToRadians));\n    \n    mat3 yRotation;\n    yRotation[0] = vec3(cos(cam.d.y*degreesToRadians), 0, -sin(cam.d.y*degreesToRadians));\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sin(cam.d.y*degreesToRadians), 0, cos(cam.d.y*degreesToRadians));\n    \n    vec3 camd = normalize(vec3(uv, 1.0)*projection*xRotation*yRotation);\n    vec3 o = cam.o;\n    \n    float focusRes = 0.05;\n    \n    float iteration = 1.0;\n    \n    for(float originMoveX = -1.0; originMoveX < 1.0; originMoveX += focusRes){\n        for(float originMoveY = -1.0; originMoveY < 1.0; originMoveY += focusRes){\n            o.x += (originMoveX*aperture)/(0.5/focusRes);\n            o.y += originMoveY*aperture;\n            //if(length(o.xy - cam.o.xy) < aperture/1.0){\n                float t;\n                material mat;\n                int i;\n                vec3 focalPoint = cam.o + camd*focalLength;\n                vec3 d = normalize(focalPoint - o);\n                bool r = raytraceScene(0.0, o, d, t, mat, i);\n\n                vec3 n = getNormals(o + d*t, scene[i]);\n\n                vec3 lRay = lPos - (o + d*t);\n\n                float c = dot(n, normalize(lRay));\n\n                float lt;\n                material lMat;\n                int li;\n\n                bool rl;\n\n                if(mat.type != 0.0){\n                    rl = raytraceScene(1.0, o + d*t, lRay, lt, lMat, li);\n                }else{\n                    rl = false;\n                }\n\n                if(rl){\n                    if(lMat.type != 0.0){\n                        c -= 0.4;\n                    }else if(lMat.type == 0.0){\n                        c = dot(n, normalize(lRay));\n                    }\n                }else{\n                    if(lMat.type != 0.0){\n                        c = dot(n, normalize(lRay));\n                    }else{\n                        c = 1.0;\n                    }\n                }\n\n                float spec;\n\n                if(mat.type == 2.0){\n                    spec = pow(max(c, 0.0), 15.0);\n                }else{\n                    spec = 0.0;\n                }\n\n                if(r){\n                    if(mat.type != 3.0){\n                        col = mix(mat.col*max(c, 0.05) + smoothstep(0.0, 1.0, min(spec, 1.0)), fogColor, min(t/(1.0/(fogDensity*0.004)), 1.0));\n                    }else{\n                        vec3 reflectO = o + d*t;\n                        vec3 reflectD = normalize(reflectRay(d, n));\n                        float rt;\n                        material reflectMat;\n                        int reflectI;\n                        bool reflectTrace = raytraceScene(0.0, reflectO, reflectD, rt, reflectMat, reflectI);\n\n                        if(reflectTrace){\n                            vec3 reflectN = getNormals(reflectO + reflectD*rt, scene[reflectI]);\n                            float rc = dot(normalize(lRay), reflectN);\n\n                            bool reflectLight;\n\n                            float rlt;\n                            material rlMat;\n                            int rli;\n\n                            if(reflectMat.type != 0.0){\n                                reflectLight = raytraceScene(1.0, reflectO + reflectD*rt, lRay, rlt, rlMat, rli);\n                            }else{\n                                reflectLight = false;\n                                rc = 1.0;\n                            }\n\n                            if(reflectLight){\n                                if(rlMat.type != 0.0){\n                                    rc -= 0.4;\n                                }\n                            }else{\n                                if(rlMat.type != 0.0){\n                                    rc = dot(normalize(lRay), reflectN);\n                                }\n                            }\n\n                            col = mix(mix(reflectMat.col*max(rc, 0.05), mat.col*max(c, 0.2), mat.intensity)*max(c, 0.7) + smoothstep(0.0, 1.0, min(spec, 1.0)), fogColor, min(t/(1.0/(fogDensity*0.004)), 1.0));\n                        }else{\n                            col = mix(mix(fogColor, mat.col*max(c, 0.2), mat.intensity)*max(c, 0.7), fogColor, min(t/(1.0/(fogDensity*0.004)), 1.0));\n                        }\n                    }\n                }else{\n                    col = fogColor;\n                }\n            //}\n            iteration++;\n            initCol = mix(initCol, col, 1.0/(iteration));\n        }\n    }\n    \n    fragColor = vec4(pow(initCol, vec3(1.0/2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msf3zl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1176, 1176, 1253, 1253, 1524], [1526, 1526, 1619, 1619, 2021], [2023, 2023, 2057, 2057, 2092], [2094, 2094, 2126, 2126, 2160], [2162, 2162, 2216, 2216, 7280]], "test": "untested"}
{"id": "mdB3Rh", "name": "Alien Space Jockey", "author": "dean_the_coder", "description": "Another Alien scene to add to my collection. :)\nYouTube version: https://youtu.be/6ZFq3TlvHBA", "tags": ["3d", "raymarching", "space", "fog", "halloween", "movie", "cineshader", "navigator"], "likes": 58, "viewed": 3586, "published": 3, "date": "1667208284", "time_retrieved": "2024-07-30T16:23:35.642206", "image_code": "// 'Space Jockey' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/mdB3Rh (YouTube: https://youtu.be/6ZFq3TlvHBA)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Another Alien scene to add to my collection. :)\n// I nearly gave up on this one several times as modelling\n// all the details was a bit daunting, but I'm glad I\n// perservered to the end.\n//\n// Tricks to try to improve performance:\n//   - Precalculate function results and simplify calculations\n//     when possible (see GLSL Shader Shrinker).\n//   - Noise functions called once in the lighting code,\n//     and re-used multiple times.\n//   - Bounding shapes are applied to each part of the scene\n//     so the SDF calculations can return early if the ray\n//     position is deemed too far away to warrant calculating\n//     the fine details.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define SKY_RGB\tvec3(.5, .6, .65)\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define I0\tmin(iFrame, 0)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n\nfloat t;\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat sum2(vec2 v) { return dot(v, vec2(1)); }\n\nfloat h31(vec3 p3) {\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 333.3456);\n\treturn fract(sum2(p3.xy) * p3.z);\n}\n\nfloat h21(vec2 p) { return h31(p.xyx); }\n\nfloat n31(vec3 p) {\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, sum2(s.yz)) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\n// Two n31 results from two scales.\nvec2 n331(vec3 p) {\n\tconst vec2 s = vec2(20, 38);\n\tvec2 ns;\n\tfor (int i = I0; i < 2; i++)\n\t\tns[i] = n31(p * s[i]);\n\n\treturn ns;\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 ax(vec3 p) { return vec3(abs(p.x) - .18, p.yz); }\n\nfloat opRep(float p, float c) {\n\tfloat c2 = c * .5;\n\treturn mod(p + c2, c) - c2;\n}\n\nvec2 opModPolar(vec2 p, float n, float o) {\n\tfloat angle = 3.141 / n,\n\t      a = mod(atan(p.x, p.y) + angle + o, 2. * angle) - angle;\n\treturn length(p) * vec2(cos(a), sin(a));\n}\n\nvec3 bend(vec3 p, float k) {\n\tfloat c = cos(k * p.x);\n\tfloat s = sin(k * p.x);\n\tp.xy *= mat2(c, s, -s, c);\n\treturn p;\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat box2(vec2 p, vec2 b) {\n\tvec2 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max2(q), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.zy), p.x)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, -h, 0.);\n\treturn length(p) - r;\n}\n\nfloat capTor(vec3 p, vec2 sc, float r) {\n\tp.x = abs(p.x);\n\treturn sqrt(dot(p, p) + r * r - 2. * r * (sc.y * p.x > sc.x * p.y ? dot(p.xy, sc) : length(p.xy)));\n}\n\nfloat tor(vec3 p, vec2 t) {\n\tvec2 q = vec2(length(p.yz) - t.x, p.x);\n\treturn length(q) - t.y;\n}\n\nvec3 rayDir(vec3 ro, vec2 uv) {\n\tvec3 f = normalize(vec3(0, -1, 0) - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nfloat walls(vec3 p) {\n\tp.y -= 6.;\n\n\t// Walls.\n\tfloat d = 10.75 - length(p.yz);\n\n\t// Ray too far away - Bail early.\n\tif (d > 5.) return d;\n\n\t// Wobbles.\n\tfloat ox = p.x;\n\tp.x = opRep(p.x - 5., 6.);\n\tfloat a = atan(p.y, p.z);\n\td -= .01 * sin(a * 172.);\n\td -= .1 * cos(p.x * p.x * .7);\n\n\t// Main pipes.\n\tp.x = abs(p.x) - .7;\n\tfloat f = S(.5, 1., sin(a * 250.));\n\tf = tor(p, vec2(10, f * -.03 + .5));\n\n\t// Side pipe.\n\tp.x -= .5;\n\tf = min(f, tor(p, vec2(9.7, .15)));\n\n\t// Ball bones.\n\tp.zy = opModPolar(p.zy, 30., 0.);\n\tp.z -= 10.8;\n\tp.y = abs(p.y) - .5;\n\tp = bend(p, .11 * p.x * sin(12. * (a + floor(ox / 2.))));\n\tp.x -= 1.4;\n\treturn smin(min(d, smin(length(p) - .25, cap(p, 1.5, .2), .1)), f, 1.);\n}\n\nfloat dais(vec3 p) {\n\tfloat a = atan(p.z, p.x);\n\tfloat l = length(p.xz);\n\n\t// Inner column.\n\tvec2 q = vec2(l, p.y);\n\tfloat d = box2(q, vec2(1.2 - abs(sin(a * 20.)) * .02, .8));\n\n\t// Ray too far away - Bail early.\n\tif (d > 4.) return d;\n\n\t// Middle ring.\n\tfloat l40 = abs(sin(l * 40.));\n\td = min(d, box2(q - vec2(2.8, -.2), vec2(.16, .7 + l40 * .01)));\n\n\t// Radial pipes.\n\tvec3 v = p;\n\tv.xz = opModPolar(p.xz, 8., .2);\n\td = smin(d, length(v.yz - vec2(.5, 0)) - .15 - l40 * .01, .1);\n\n\t// Radial struts.\n\tv.xz = opModPolar(p.xz, 32., 0.);\n\tv.z = abs(v.z) - .05;\n\td = min(d, box2(v.yz - vec2(.2, 0), vec2(.2, 0)));\n\n\t// Clip content to dais radius.\n\td = max(d, l - 4.12);\n\n\t// Geared outer ring.\n\td = min(d, box2(q - vec2(4, -.1), vec2(.28 - S01(sin(a * 130.)) * .03, .7 + l40 * .02 * step(l, 4.16))));\n\n\t// Round edges off.\n\treturn d - .03;\n}\n\nfloat chair(vec3 p) {\n\tp.y--;\n\tvec3 op = p;\n\n\t// Mounting struts.\n\tfloat d = cyl(ax(p) - vec3(0, 0, .1), vec2(1, S01(.5 - p.y) * .2 + .06));\n\td += .005 * S(0., .03, abs(abs(p.y - .3) - .3));\n\td = smin(d, p.y - .7, -.05);\n\n\t// Ray too far away - Bail early.\n\tif (d > 3.) return d;\n\n\t// Primary base exhaust.\n\tp.x = abs(p.x);\n\tp.y += .3 * S(.8, 1.6, p.x) * sin(p.x * 1.9);\n\tfloat f = cyl(p - vec3(.8, .12, .7), vec2(.2, 1));\n\tf = abs(f) - .005;\n\tf += .05 * S(.04, -.16, abs(p.y - .2));\n\tfloat q = length(p - vec3(1.8, .3, .85));\n\tf = smin(f, .2 - q, -.1);\n\tf += .01 * S(0., .03, abs(q - .35));\n\n\t// Seconardy pipe.\n\tq = S(.2, .9, -op.x);\n\tf = smin(f, cap(p - vec3(.7, .4 - q * .25, .6), .8, .15), .1 * q);\n\td = min(d, f);\n\n\t// Central tube.\n\tf = cyl(op - vec3(.7, .3, 0), vec2(.3, 1.2)) - .1;\n\n\t// Toral pipe.\n\tf = max(f, .44 - length(op.xy - vec2(1.55, 1)));\n\tp = op.zyx - vec3(0, .25, .94);\n\tf = min(f, max(tor(p, vec2(.83, .08 - .005 * abs(sin(atan(p.y, p.z) * 40.)))), -p.z));\n\n\t// Organic scope mount.\n\tp = bend(op, -.08 * p.y);\n\tf = smin(f, box(p - vec3(.75, 1.45, 0), vec3(.2 - p.y * .1, 1, .1)) - .15 - abs(sin(p.y * 10.) * .01), .12);\n\td = min(d, f);\n\n\t// Chair back.\n\tp = op;\n\tp.y -= 1.74;\n\tp.xy *= mat2(-.80114, .59847, -.59847, -.80114);\n\tfloat a = atan(p.x, p.y);\n\tfloat l = length(p);\n\tf = sat(sin(a * 1e2) - .6);\n\tf *= S(1.6, 1.1, l);\n\tconst vec2 v = vec2(.64422, .76484);\n\td = min(d, capTor(p, v, 1.56) - .5 - .02 * S(.7, .75, a) - .02 * f);\n\tf = length(p.xy - vec2(1.35, 0));\n\td = smin(d, 1. - f, -.04);\n\tf *= S(.99, .95, f) * .4;\n\tf *= S(.25, .1, abs(p.x - 1.15));\n\td -= .05 * (S(.2, .1, p.z) + sin(p.x * 50.) * f);\n\n\t// Chair side pipe.\n\tf = sin(a * 50.);\n\td = min(d, capTor(p - vec3(0, 0, .5), v, 1.56) - .05 - .01 * f * f);\n\td = min(d, capTor(p - vec3(0, 0, .5), v, 1.5) - .02);\n\n\t// Torso.\n\tp.xy *= mat2(.98007, .19867, -.19867, .98007);\n\tf *= S(0., .15, p.z);\n\td = min(d, capTor(p, v, 1.25) - .36 - f * .015);\n\n\t// Shoulders.\n\tp -= vec3(.74, .9, .28);\n\td = min(d, length(p) - .16);\n\n\t// Arms.\n\tp.z -= .075;\n\tp.xy *= rot(mix(.06, -.24, S(.15, -.6, op.x)));\n\tf = .086 - f * f * .002 * S(.3, .5, -op.x);\n\tf += .03 * S(.35, .05, abs(p.x + .3));\n\tf = cap(p, 1.4, f);\n\ta = atan(p.y, p.z);\n\tf += .01 * sin(a * 6.5) * S(1.3, 0., abs(p.x));\n\tf += .007 * sin(a * 9.) * S(.035, .3, op.x);\n\td = min(d, f);\n\n\t// Head.\n\tp = op;\n\tp -= vec3(-1, 1.5, 0);\n\tf = mix(box(p, vec3(.25, .28, .26)), length(p) - .23, .9);\n\tp.xy = op.xy * mat2(.07074, -.99749, .99749, .07074);\n\treturn smin(d, max(smin(f, capTor(p + vec3(1, 1.46, 0), v, 1.) - .04, .16), .05 - length(p.xz - vec2(-1.6, .15))), .3 * S(-1.5, -1., p.x)) - .02;\n}\n\nfloat mount(vec3 p, float x, float a) {\n\tp.xy *= rot(-.15 - a);\n\tp = p.zyx * vec3(-1, 1, 1);\n\tfloat d = cap(p, .3, .1);\n\tp.x += .3;\n\tp = p.yxz;\n\tp.xy *= rot(a);\n\tvec3 v = vec3(p.y + .176, opRep(p.x, .08), p.z - .11);\n\tfloat q = 1.1 + x;\n\td = smin(d, cap(p, q, .1), .04);\n\tp.x += q;\n\tp = p.zyx;\n\tp.xz *= mat2(.87758, .47943, -.47943, .87758);\n\td = smin(d, cap(p, .3, .1), .04);\n\tp.x += .3;\n\tp.xz *= mat2(.5403, -.84147, .84147, .5403);\n\td = smin(d, cap(p, .1, .1), .04);\n\td = smin(d, -p.y - .09, -.003);\n\n\t// Square cut-outs.\n\treturn max(d, -box(v, vec3(.1, .02, .1)));\n}\n\nfloat mounts(vec3 p) {\n\tfloat d = mount(p - vec3(.9, 2.95, 0), .2, .05);\n\n\t// Ray too far away - Bail early.\n\tif (d > 3.) return d;\n\treturn min(min(d, mount(p - vec3(1.2, 3.1, 0), .3, .1)), mount(p - vec3(1.5, 3.2, 0), -.2, .2));\n}\n\nfloat scope(vec3 p) {\n\tp.y -= 2.9;\n\tp.xy *= mat2(-.89676, -.44252, .44252, -.89676);\n\tvec3 op = p;\n\n\t// Barrel.\n\tfloat a = atan(p.y, p.z);\n\tfloat f = .005 * sat(-sin(a * 24. + 3.141));\n\tf = max(f, .04 * S(.2, 0., p.x + 2.9 - p.y * .4));\n\tp.y += .8 * S01(p.y + .3) * S(1., 0., p.x + 3.8);\n\tfloat d = cap(p, 3.2, .4 + f);\n\n\t// Ray too far away - Bail early.\n\tif (d > 1.) return d;\n\n\t// Side pipes.\n\tp.y = abs(p.y);\n\tp.zy = opModPolar(p.zy, 9., 0.);\n\tp -= vec3(-.4, 0, .35);\n\td = min(d, cap(p, 2.6, .07 + abs(sin(p.x * 90.)) * .004));\n\n\t// End Bulge.\n\tp = op.zyx;\n\td = smin(d, cyl(p + vec3(0, .2, 0), vec2(.4, .4 - abs(p.y) * .6)), .3);\n\n\t// Viewscreen.\n\tp.yz += vec2(.1, -1.23);\n\treturn min(d, smin(cyl(p, vec2(.8, .2)), -cyl(p - vec3(0, 0, 1.12), vec2(1.8, 1)), -.14));\n}\n\nfloat map(vec3 p) {\n\tfloat d = walls(p);\n\tp.y += 2.8;\n\td = min(d, dais(p));\n\tp.xz *= mat2(.76484, -.64422, .64422, .76484);\n\tp.z = abs(p.z);\n\treturn min(min(min(d, chair(p)), scope(p)), mounts(p));\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .1;\n\tvec3 n = vec3(0);\n\tfor (int i = I0; i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h);\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld, vec3 n) {\n\t// Quick abort if light is behind the normal.\n\tif (dot(ld, n) < -.1) return 0.;\n\tfloat d,\n\t      s = 1.,\n\t      t = .05;\n\tfloat mxt = length(p - vec3(-20, 3, 3));\n\tfor (float i = Z0; i < 30.; i++) {\n\t\td = map(t * ld + p);\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.03, d);\n\t\tif (mxt - t < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\n// Quick 2-level ambient occlusion.\nfloat ao(vec3 p, vec3 n) {\n\tconst vec2 h = vec2(.1, 2);\n\tvec2 ao;\n\tfor (int i = I0; i < 2; i++)\n\t\tao[i] = map(h[i] * n + p);\n\n\treturn sat(min2(ao / h));\n}\n\n// Sub-surface scattering. (Thanks Evvvvil)\nfloat sss(vec3 p, vec3 ld) { return S01(map(1. * ld + p)); }\n\nfloat fog(vec3 p) {\n\tfloat d = abs(p.x);\n\td += 20. * S(-1.3, -4., p.y) * (.7 + .3 * n21(p.xz * 2.));\n\treturn exp(d * d * -2e-4);\n}\n\nvec3 lights(vec3 p, vec3 rd, vec3 n) {\n\tvec2 ns = n331(p); // Cache noise.\n\tvec3 ld = normalize(vec3(-20, 3, 3) - p),\n\t     c = vec3(.5, .8, 1);\n\tc *= .3 - sum2(ns) * .06;\n\tc += sss(p, ld) * .1;\n\tfloat y = S(1.8, 0., length(p));\n\ty *= S(0., -.2, p.y + p.x + .7);\n\tc *= 1. + vec3(21, 19, 13) * (dot(ns, ns) * .6 + .4) * y;\n\n\t// Adjust specular power and brightness.\n\ty = sat(y * 6.);\n\tfloat sh1 = mix(2e2, 10., y);\n\tfloat sh2 = mix(5., .3, y);\n\tsh2 *= .8 * ns.x * ns.y + .2;\n\tvec3 l = sat(vec3(dot(ld, n),  // Key light.\n\tdot(-ld.xz, n.xz),  // Reverse light.\n\tn.y // Sky light.\n\t));\n\tl.xy = .1 + .9 * l.xy; // Diffuse.\n\tl.yz *= .1 + .9 * ao(p, n); // Ambient occlusion.\n\tl *= vec3(.05 + .95 * S(3., -10., p.x), .05, .02); // Light contributions (key, reverse, sky).\n\tl.x += pow(sat(dot(normalize(ld - rd), n)), sh1) * sh2; // Specular (Blinn-Phong)\n\tl.x *= .05 + .95 * shadow(p, ld, n); // Shadow.\n\treturn mix((sum2(l.xy) * vec3(.6, .51, .42) + l.z * SKY_RGB) * c, SKY_RGB, S(.6, 1., 1. + dot(rd, n)) * .02);\n}\n\nfloat addFade(float a) { return min(1., abs(t - a)); }\n\nvec3 scene(vec3 p, vec3 rd) {\n\t// March the scene.\n\tfloat i, h,\n\t      d = 1.;\n\tfor (i = Z0; i < 120.; i++) {\n\t\th = map(p);\n\t\tif (abs(h) < 2e-4 * d || d > 40.) break;\n\t\td += h;\n\t\tp += h * rd;\n\t}\n\n\tvec3 col = mix(SKY_RGB, lights(p, rd, N(p, d)), fog(p));\n\n\t// Gamma.\n\treturn pow(max(vec3(0), col), vec3(.4545));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tt = mod(iTime, 30.);\n\tvec2 uv = (fc - .5 * R.xy) / R.y;\n\tvec3 ro = mix(vec3(-1, -1, -7), vec3(-1.1, -1.8, -3), S(0., 15., t));\n\tfloat f = S(15., 30., t);\n\tif (f > 0.) ro = vec3(1. - f * 4., cos(f * 6.283) + .5, -3);\n\tvec3 col = scene(ro, rayDir(ro, uv));\n\n\t// Blue tint.\n\tcol = pow(col * 1.2, vec3(1.2, 1.1, 1));\n\n\t// Vignette.\n\tcol *= 1. - .3 * dot(uv, uv);\n\n\t// Grain.\n\tcol += (h21(fc) - .5) / 20.;\n\tfragColor = vec4(col * addFade(0.) * addFade(15.), 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdB3Rh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1376, 1376, 1396, 1396, 1420], [1422, 1422, 1442, 1442, 1466], [1468, 1468, 1488, 1488, 1522], [1524, 1524, 1544, 1544, 1570], [1572, 1572, 1592, 1592, 1689], [1691, 1691, 1710, 1710, 1731], [1733, 1733, 1752, 1809, 2093], [2095, 2131, 2150, 2150, 2260], [2262, 2262, 2281, 2281, 2307], [2309, 2309, 2348, 2348, 2430], [2432, 2432, 2451, 2451, 2518], [2520, 2520, 2537, 2537, 2574], [2576, 2576, 2607, 2607, 2658], [2660, 2660, 2703, 2703, 2837], [2839, 2839, 2867, 2867, 2958], [2960, 2960, 2987, 2987, 3058], [3060, 3060, 3088, 3088, 3159], [3161, 3161, 3189, 3189, 3289], [3291, 3291, 3328, 3328, 3381], [3383, 3383, 3423, 3423, 3543], [3545, 3545, 3572, 3572, 3640], [3642, 3642, 3673, 3673, 3817], [3819, 3819, 3840, 3840, 4515], [4517, 4517, 4537, 4537, 5357], [5359, 5359, 5380, 5380, 7981], [7983, 7983, 8022, 8022, 8553], [8555, 8555, 8577, 8577, 8786], [8788, 8788, 8809, 8809, 9558], [9560, 9560, 9579, 9579, 9759], [9761, 9761, 9786, 9786, 9991], [9993, 9993, 10032, 10079, 10363], [10365, 10401, 10427, 10427, 10555], [10557, 10601, 10629, 10629, 10661], [10663, 10663, 10682, 10682, 10793], [10795, 10795, 10833, 10833, 11805], [11807, 11807, 11831, 11831, 11861], [11863, 11863, 11892, 11913, 12175], [12177, 12177, 12222, 12222, 12682]], "test": "untested"}
{"id": "DdB3R1", "name": "Random Path Image", "author": "mla", "description": "Apply a simple random path rewriting automaton to a closed path. Mouse resets (eg. after a window resize).\n\nUses image to control path density. Effect not perfect, but if you squint you can see Britney.", "tags": ["random", "paths"], "likes": 22, "viewed": 388, "published": 3, "date": "1667207673", "time_retrieved": "2024-07-30T16:23:36.402174", "image_code": "///////////////////////////////////////////////////////////////////////\n//\n// Random Path Image, mla, 2022\n//\n// Apply a simple random path rewriting automaton to a closed path.\n// Mouse resets (eg. after a window resize).\n//\n// Uses image to control path density. Effect not perfect, but if\n// you squint you can see Britney. Can probably do better, suggestions\n// welcome. Currently just uses the green channel with a level\n// threshold to incline to towards expanding or contracting moves. \n//\n///////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  vec2 p = 1.02*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n  p = 0.5*(p+1.0); // Move to [0,1] square\n  ivec2 vertex = clamp(ivec2(round(float(N)*p)),ivec2(0),ivec2(N));\n  float px = fwidth(p.x), d = 1e8;\n  // The 4 segments coming off this vertex - the buffer entries\n  // indicate the presence of rightwards and downwards segments.\n  bvec4 a = bvec4(texelFetch(iChannel0,vertex-ivec2(1,0),0).x,\n                  texelFetch(iChannel0,vertex-ivec2(0,1),0).y,\n                  texelFetch(iChannel0,vertex,0).xy);\n  // I don't usually like this sort of macro, but this one is handy.\n  #define S(p,q,r) (segment((p),vec2(q)/float(N),vec2((q)+(r))/float(N)))\n  if (vertex.x > 0 && a.x) d = min(d,S(p,vertex,-ivec2(1,0)));\n  if (vertex.y > 0 && a.y) d = min(d,S(p,vertex,-ivec2(0,1)));\n  if (vertex.x < N && a.z) d = min(d,S(p,vertex, ivec2(1,0)));\n  if (vertex.y < N && a.w) d = min(d,S(p,vertex, ivec2(0,1)));\n  vec3 col = vec3(1,1,0.8);\n  vec3 tex = texture(iChannel1,p).xyz;\n  col *= vec3(smoothstep(0.0,px,d-0.1*length(tex)/float(N)));\n  col *= 0.5+0.5*tex;\n  col = pow(col,vec3(0.4545));\n  if (alert) col.x = 1.0;\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 result, vec2 fragCoord) {\n  ivec2 vertex = ivec2(fragCoord);\n  result = texelFetch(iChannel0,vertex,0);\n  if (any(greaterThan(vertex,ivec2(N)))) {\n    result = vec4(0);\n  } else if (iFrame == 0 || iMouse.z > 0.0 || result.w != 1234.0) {\n    result = vec4(vertex.y == 0 || vertex.y == N,\n                  vertex.x == 0 || vertex.x == N,\n                  0,1234);\n  } else {\n    // Consider a 2x2 grid of vertices, with segments possible between each\n    // horizontal and vertical pair of vertices.\n    int n = irand(iFrame+1,4);\n    ivec2 offset = ivec2(n/2,n%2);\n    if (all(greaterThanEqual(vertex,offset)) && all(lessThan(vertex,N+offset))) {\n      ivec2 base = (vertex-offset)/2*2+offset;\n      bvec4 a = bvec4(texelFetch(iChannel0,base,0).xy,\n                      texelFetch(iChannel0,base+ivec2(0,1),0).x,\n                      texelFetch(iChannel0,base+ivec2(1,0),0).y);\n      vec4 tex = texture(iChannel1,vec2(base)/float(N));\n      float level = length(tex.ggg);\n      float threshold = 0.6;\n      int count = int(dot(vec4(a),vec4(1)));\n      float h = rand(base.x,base.y,iFrame);\n      if ((level < threshold && count == 1 && h < 0.8) || \n          (level > threshold && count == 3 && h < 0.8) || \n          ((count == 1 || count == 3) &&  h < 0.1)) {\n        if (vertex == base) result.xy = vec2(not(a.xy));\n        if (vertex == base+ivec2(0,1)) result.x = float(!a.z);\n        if (vertex == base+ivec2(1,0)) result.y = float(!a.w);\n      }\n    }\n  }\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "int N = 128;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nint irand(int i, int range) {\n return int(ihash(uint(i))%uint(range));\n}\n\nfloat rand(int i, int j) {\n  uint h = ihash(uint(31*i+j));\n  return float(h)/pow(2.0,32.0);\n}\n\nfloat rand(int i, int j, int k) {\n  uint h = ihash(uint(31*i+j));\n  h = ihash(h^uint(k));\n  return float(h)/pow(2.0,32.0);\n}\n\nfloat rand(int i) {\n  uint h = ihash(uint(i));\n  return float(h)/pow(2.0,32.0);\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdB3R1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[570, 570, 623, 623, 1772]], "test": "untested"}
{"id": "ddS3Rh", "name": "1.3-MoveUvsWithMouse", "author": "retonym", "description": "practice shader made while starting to go through thebookofshaders.com", "tags": ["thebookofshaders"], "likes": 1, "viewed": 120, "published": 3, "date": "1667203854", "time_retrieved": "2024-07-30T16:23:37.434414", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy/iResolution.xy; \n\n    //MOVING COLORS AROUND WITH MOUSE POSITION\n    //let's try to have mouse position drive a change in the uv space by \n    //somehow combining mouse position with the uv value.\n    \n    //get the normalized mouse position value.\n    vec2 mouseValue = iMouse.xy/iResolution.xy;\n    //subtract the mousevalue from the uv value.\n    //i'm also going to use fract() to force the value to 'loop around' back to 1 once it dips beneath 0.\n    fragColor = vec4(fract(st.x - mouseValue.x), fract(st.y - mouseValue.y), 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddS3Rh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 623]], "test": "untested"}
{"id": "msBGRh", "name": "1.03-HeartbeatCursor", "author": "retonym", "description": "practice shader made while starting to go through thebookofshaders.com", "tags": ["thebookofshaders"], "likes": 2, "viewed": 139, "published": 3, "date": "1667203725", "time_retrieved": "2024-07-30T16:23:38.318051", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord)  \n{\n    vec2 uv = fragCoord.xy;\n    \n    //squish the uv space from a wide rectangle to a square, so that\n    //our spotlight will be a circle instead of an oval.\n    float screenRatio = iResolution.x/iResolution.y;\n    uv.x *= screenRatio;\n\tvec2 st = uv/iResolution.xy;\n\n\n    //TEST 3: THE ~FOURTH DIMENSION~\n    \n    //HEARTBEAT STRENGTH\n    //i want to get a 'heartbeat effect'\n    //i think i can do this by using sin\n    //sin goes from 1 to -1 across time.\n    //that means it passes through the values .5, .5, -.5, and -.5 -- that's 4 'beats'. \n    //let's say i only want to use the positive beats-- the .5s.\n    //i can check how close a sin value is to .5, and use that to drive the brightness of a color.\n    //so let's get our sin function going...\n    //multiply time by 6 to make it faster.\n    float sinwave = sin(iTime * 6.0);\n    //now, let's check how close sinwave is to our 'trigger point' of .5\n    //FOR FUN -- change the 'trigger point' to .8 or .2 and see how it affects heartbeat rhythm!\n    float sinTriggerPoint = .5;\n    //i'll call this closeness value 'hs' for heartbeatStrength\n    float hs  = abs(sinwave - sinTriggerPoint);\n    //and i'll use oneminus because i want to get a value where the closer we are to a heartbeat, \n    //the closer the heartbeat value is to '1'.\n    hs = 1.0 - hs;\n    //clamp the output to prevent negative values causing weird colors.\n    hs = clamp(hs, 0.0, 1.0);\n       \n    //HEARTBEAT STRENGTH-DRIVEN COLOR\n    //great, we have a heartbeat value that goes from 0 at weakest, to 1 at strongest. \n    //let's use that value to drive a color.\n    //let's make something that goes from purple at weakest, to red at strongest.\n    //color is (r, g, b, alpha)\n    //so i want the red to always be on but to get a bit stronger when the heartbeat is at its strongest\n    //and i want the blue to only show up when the heartbeat is at its weakest -- and mix with the red then to make purple.\n    vec4 color = vec4(.5 + (.3 * hs), 0.0, 1.0-hs, 1.0);\n\n    //SIMPLE SPOTLIGHT AROUND THE MOUSE CURSOR\n    //now let's make our spotlight that follows the mouse.\n    //normalize mouse position\n    vec2 mouseValue = iMouse.xy/iResolution.xy; \n    //at the very start, we squished the wide rectangular screen ratio into a square,\n    //to make the spotlight a circle instead of an oval.\n    //unfortunately that means the mouse x position is now squished to map onto that square space.\n    //so we multiply it by the screenRatio to 'unsquish' it back across a wide rectangular screen space.   \n    mouseValue.x *= screenRatio;\n    //get distance from mouse pos to the pixel being rendered by this fragment...\n    //when rendered out, this value looks like a black 'spotlight' around the mouse.\n    float len = distance(st, mouseValue);\n    //we have a spotlight. now change the spotlight size by multiplying the effect by a constant...\n    len = len * 5.0;\n    //i think it'd be cool to make the length vary with the heartbeat strength as well.\n    len -= hs;\n    vec4 mouseCircle = vec4(len, len, len, 1.0);\n    //invert the color of the circle.\n    vec4 mouseCircleInverted = vec4(1.0-mouseCircle.rgb, 1.0);\n    \n    //PUTTING IT ALL TOGETHER\n    //multiply the simple spotlight by the heartbeat color!\n    fragColor = mouseCircleInverted * color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msBGRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 3353]], "test": "untested"}
{"id": "dsBGRh", "name": "Fractal junkyard (3D)", "author": "jarble", "description": "An endless series of twisted wires and pipes.", "tags": ["3d", "fractal"], "likes": 8, "viewed": 316, "published": 3, "date": "1667203669", "time_retrieved": "2024-07-30T16:23:42.476931", "image_code": "#define t iTime*4.\n#define r iResolution\n#define iterations 250 //number of raymarching steps\n#define EPSILON .001\n#define MAX_DIST 40.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\n//Based on https://www.shadertoy.com/view/3tXyRN\n\nvec3 spaghetti(vec3 uv)\n{\n    vec3 col = vec3(0.);\n    for(int k = 0; k < 6; k++){ \n        vec3 offset =\n            //fract(vec3(uv.x-.45,uv.y+.45,uv.z-uv.x))\n            vec3(uv.x+.35,uv.y+.35,uv.z-uv.x)\n        ;\n        uv =\n            abs(fract(uv.yzx+offset.zxy)-.5)\n            //min(offset,abs(fract(uv.yzx+offset.zxy)-.5))\n        ;\n        //uv.yx *= rot(uv.y/8.);\n        col = vec3(col.yz,uv.x-uv.y);\n    }\n    \n    return\n        col\n        //col - uv;\n    ;\n}\n\nvoid mainImage( out vec4 o, in vec2 U )\n{\n    o = vec4(0.0);\n    vec3 d=vec3(U/r.xy-.5,.5),p0=vec3(0,6,t),p=p0;\n    if (length(iMouse.xy) > 40.0) {\n        d.yz *= rot(-3.14*0.5+iMouse.y/iResolution.y*3.14);\n        d.xz *= rot(-3.14+iMouse.x/iResolution.x*3.14*2.0);\n    }\n    float l1;\n    vec3 col = vec3(0.);\n    for(int i=0;i<iterations;i++)\n    {\n        col = spaghetti(p/16.);\n        float sd1 = col.z-.14;\n        if(-sd1 < EPSILON*(length(l1)+1.0) || l1 > MAX_DIST){ break; }\n        p+=d*(-sd1);\n        l1 = distance(p,p0);\n    }\n    o+=(vec4(col/2.,0)+l1/100.0)*3.0;\n}", "image_inputs": [], "sound_code": "float fmod(float x,float y){\n    //x += floor(x)/y*8.;\n    //x += floor(x/64.);\n    return mod(floor(x),y);\n}\n//#define fmod0(x,y) mod(floor(x)+floor((x)/2.)+floor((x)/4.),y)\n\nvec2 mainSound(int samp, float t){\n  //t += floor(t*4.)/4.;\n  float s1 =\n      8.,\n  m1 =\n      //fmod(t*s1,s1),\n      fmod((t+floor(t/2.+s1)),s1),\n      //fmod(t*s1-floor(t),s1),\n  z1 =\n      (1.+fmod(m1,2.))\n  ;\n  t /=\n      1.+fmod((t*s1+floor(t*s1/2.+s1)),2.)\n  ;\n  float m3 =\n      fmod((t+floor(t/2.+s1))/(m1+.5),s1)\n  ;\n  t *=\n      1.+fmod(((t*s1)+floor(t*s1/2.)),2.)\n  ;\n\n  float a=\n      16.*((1.-(fract(t*s1)/1.125)))\n      //4.*abs(1.-log(.125+fract1(t*s1)/1.125))\n  ,\n\n  nb = t*pow(2.,(m3+z1)/5.+7.);\n\n  return\n      abs(.5-vec2(fract(nb*.998),fract(nb)))*a\n      //abs(a/16.-abs(.5-vec2(fract(nb*.998/2.),fract(nb/2.)))*a)\n  ;\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsBGRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 279, 279, 730], [732, 732, 773, 773, 1314]], "test": "untested"}
{"id": "msSGRh", "name": "1.03 - UVColoredSpotlightCursor", "author": "retonym", "description": "practice shader made while starting to go through thebookofshaders.com", "tags": ["thebookofshaders"], "likes": 1, "viewed": 120, "published": 3, "date": "1667203460", "time_retrieved": "2024-07-30T16:23:43.520142", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord) \n{\n\tvec2 st = fragCoord.xy/iResolution.xy; \n\n    //1. SPOTLIGHT WITH POSITION-BASED COLOR\n    //let's make a spotlight that follows the mouse, and have it change color depending on where the mouse is.\n    \n    //normalize mouse position into a value from 0-1\n    vec2 mouseValue = iMouse.xy/iResolution.xy; \n    //get a value based on distance from the mouse position, to the pixel being rendered by this fragment.\n    float len = distance(st, mouseValue);    \n    //if you render the above values out, it looks like a black circle on a white bg\n    //i'm using 1 minus here to invert it to make it a white circle on a black bg.\n    vec4 spotlight = vec4(1.0-len, 1.0-len, 1.0-len, 1);\n    \n    //then, i can multiply the white circle by a color based on mouse position!\n    fragColor = spotlight * vec4(mouseValue.x, mouseValue.y, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msSGRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 899]], "test": "untested"}
{"id": "cdB3z1", "name": "iFrameRate vs 1./iTimeDelta 2", "author": "FabriceNeyret2", "description": "red: iFrameRate   ( const average over ~40 frames )\ngreen: 1./iTimeDelta\nblue: 1./ mesured frame time   ( appear to be = iTimeDelta )\n\niTimeDelta still steppy on my machine.  because of browser frame sync ?", "tags": ["shadertoy", "iframerate", "itimedelta"], "likes": 9, "viewed": 276, "published": 3, "date": "1667200791", "time_retrieved": "2024-07-30T16:23:44.381838", "image_code": "void mainImage( out vec4 O, vec2 u ) { O = T(u); }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = T(U-vec2(1,0));\n    if ( U.x>1.) return;\n    if (U.y<1.) { O.a = iTime; return; }\n    U /= R;\n#define plot(v)     step( abs( U.y - .8* (v) /60. ) , 1./R.y )\n    O.r = plot( iFrameRate );\n    O.g = plot(1./iTimeDelta  );\n    O.b = plot(1./ (iTime-T(0).a) ); // same that iTimeDelta !\n    \n    O.a = 0.;\n    for (float i = 0.; i < 40000.*(.5+.5*sin(iTime)) ; i++ )\n        O.a--;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdB3z1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 50]], "test": "untested"}
{"id": "DdS3z1", "name": "Fork Moire 1 jarkob 296", "author": "jarkob", "description": "based on https://www.shadertoy.com/view/XsBGWm", "tags": ["2d"], "likes": 2, "viewed": 166, "published": 3, "date": "1667197459", "time_retrieved": "2024-07-30T16:23:45.145796", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p=fragCoord.xy-iResolution.xy*.5;\n    vec2 a = vec2(cos(iTime*0.001),sin(iTime*0.001));\n\tfragColor=sin(vec4(2,4,8,1)*(dot(p*a.x,p*a.y)-iTime));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdS3z1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 209]], "test": "untested"}
{"id": "DsS3R1", "name": "blue rays", "author": "lomateron", "description": "left   side is showing Fouriet transform on previous 128 frames\nright side is showing                               previous 1     frame", "tags": ["automata"], "likes": 5, "viewed": 180, "published": 3, "date": "1667187871", "time_retrieved": "2024-07-30T16:23:45.983556", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec4 tt = floatBitsToUint(texelFetch(iChannel0,ivec2(fragCoord),0));\n    float pi = 3.141592;\n    #define zz 128.\n    #define ww 6\n    float frq = 1.;\n    fragColor = vec4(0);\n    for(int i = 0; i < ww; ++i)\n    {\n        float co = 0.;\n        float si = 0.;\n        for(float y = .5; y < zz; ++y)\n        {\n                               uint t = tt.x;\n            if(y>=32.*1.&&y<32.*2.){t = tt.y;}\n            if(y>=32.*2.&&y<32.*3.){t = tt.z;}\n            if(y>=32.*3.          ){t = tt.w;}\n            float y2 = (y/zz-.5)*20.;\n            float a = float((t>>(int(y)&31))&1U)-.5;\n                  a/= exp(y2*y2);\n            y2 *= frq;\n            co += cos(y2)*a;\n            si += sin(y2)*a;\n        }\n        float l = sqrt(si*si+co*co);\n                vec4 msk = vec4(1,0,0,0);\n      //if((i%3)==0){msk = vec4(1,0,0,0);}\n        if((i%3)==1){msk = vec4(0,1,0,0);}\n        if((i%3)==2){msk = vec4(0,0,1,0);}\n        fragColor += l*msk;\n        frq *= 1.33;\n    }\n    fragColor *= (3./float(ww))*.35;\n    if(fragCoord.x>iResolution.x*.5){fragColor = vec4(tt.x&1U);}\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rz 120.  //size of each world in pixels\n#define sz  3.   //size of kernel across space\n#define tz  3    //size of kernel across time          must be <= 32", "buffer_a_code": "uvec4 read(vec2 u, vec2 m)\n{\n    //vec2 o = mod(u+m,rz);\n    //     u = floor(u/rz)*rz+o;\n    return floatBitsToUint(texelFetch(iChannel0,ivec2(u+m),0));\n}\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    int re = -int((iFrame&3)==0);\n    uvec4 tt = read(u,vec2(0,re));\n    float ck = -floor((sz-1.)*.5);    //center the kernel\n    float ev = float(mod(sz,2.)==0.); //move and resize kernel when sz = even\n    uint o = 0U;                      //sum of all bits\n                          float n = (float(iFrame&1)-1.)*ev;\n    for(int   t=0 ; t<tz; ++t){ float m = n*(1.-float(t&1)); float s2 = sz-float(t&1)*ev; \n    for(float i=0.; i<s2; ++i){ uint r = read(u,vec2(i+ck+m,re)).x;\n                                o += (r>>t)&1U;\n    }}\n    \n    uint a = 16U*6U+7U;\n    //if(o>=32U){a = 1430607221U;}\n    o = ((tt.x)<<1U) | ((a>>(o&31U))&1U);\n    tt = uvec4(o,(tt.x>>31)|(tt.y<<1),\n                 (tt.y>>31)|(tt.z<<1),\n                 (tt.z>>31)|(tt.w<<1));\n    fragColor = uintBitsToFloat(tt);\n    if((iFrame>>2)!=int(u.y)){fragColor = texelFetch(iChannel0,ivec2(u),0);}\n    if(iFrame==0||iMouse.z>.5)\n    {\n        float r = fract(cos(dot(u,vec2(1.76543,iTime+9.)))*5467.5678)*11111.;\n        fragColor = vec4(r);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsS3R1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mdjGRR", "name": "March of Cells", "author": "propagant", "description": "Take a little break and relax with cells marching into darkness...\nPlayaround with CELL_SIZE, CELL_WIBBLE and other params to see various results.", "tags": ["cells", "2draymarching"], "likes": 4, "viewed": 303, "published": 3, "date": "1667172375", "time_retrieved": "2024-07-30T16:23:46.738538", "image_code": "// March of cells shader by Matej Vanco, October 2022.\n// In memory of Ryan Karazija, Low Roar.\n\n// Public defines\n#define ITER 32\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n\n#define CONTROL_LIGHT false\n\n#define CELL_SIZE 1.5\n#define CELL_WIBBLE 1.0\n#define CELL_FLOW_SPEED 1.0\n#define CELL_COUNT 25.\n\t\n// Light structure (for multiple lights)\nstruct light\n{\n\tvec2 p;  // pos\n\tfloat i; // intens+attenuation\n\tvec3 c;  // color\n};\n\t \n#define LINTENS(x, y, lp, uv) (x / pow(length(lp - uv), y))\n\t\n#define Hash1(n) (fract(sin(n) * 43758.5453123))\n\n#define GEN(uv, a) (vec2(uv.x * cos(a) - uv.y * sin(a), uv.y * cos(a) + uv.x * sin(a)))\n\n// Scene content\nfloat generic(vec2 p)\n{\n\tfloat f = 1.;\n    // Angular 'sweeping' + the X 'wibble' effect\n    p.x = p.x + (sin((p.x * 48.) + (iTime * 0.025)) * (0.01 * CELL_WIBBLE)) + (p.y * sin(iTime * 0.15));\n    // A little offset\n\tp.x += 0.25;\n    // The Y 'wibble' effect - creates a \"cell-like-movement\"\n\tp.y = p.y + cos((p.y * 10.) + (iTime * 0.125)) * (0.085 * CELL_WIBBLE);\n    \n\tfor(float i = 1.; i < CELL_COUNT; i++)\n\t{\t\n        // Cells generation (base is a simple sphere formula)\n\t\tvec2 cp = GEN(vec2(p.x - (0.08 * (i * Hash1(i * 1.5))), p.y + sin(iTime * 0.4) * 0.001), iTime * (i * (0.05 * CELL_FLOW_SPEED)));\n\t\tf = min(f, length(p - cp) - (0.005 * CELL_SIZE));\n\t}\n\n\treturn f;\t\n}\n\n// Traditional raymarching algorithm\nfloat march(in vec2 o, in vec2 d)\n{\n\tfloat t = 0.;\n\tfor(int i = 0; i < ITER; i++)\n\t{\n\t\tvec2 cp = o + (d * t);\n\t\tfloat g = generic(cp);\n\t\tt += g;\n\t\tif(g < MIN_DIST || t > MAX_DIST) break;\n\t}\n\t\n\treturn t;\n}\n\n// Low-visible soft shadows\nfloat shading(in vec2 p, in light l)\n{\n\tvec2 ld = normalize(l.p - p);\n\t\n\tfloat r = 1.0;\n\tfloat t = 0.01;\n\tfloat d = length(l.p - p);\n\t// Soft shadows - low 8-tish iteration\n\tfor(int i = 0; i < 8; i++)\n\t{\n\t\tvec2 pp = p + (ld * 0.0025);\n\t\tfloat s = march(pp, ld);\n        // Shadow softness calc\n\t\tr = min(r, 5.0 * s / t);\n\t\tt += s;\n\t\tif(t < 0.0 || s > 1.0) \n\t\t\tbreak;\n\t\tif(t * 0.55 >= d) break;\n\t}\n\n\treturn r ;\n}\n\n// Build a light source (call this for multiple lights)\nvec3 bLight(in light l, in vec2 o)\n{\n\treturn l.c * shading(o, l) * l.i;\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - (0.5 * iResolution.xy)) / iResolution.y;\n    \n    // Lights\n    vec2 l1p = CONTROL_LIGHT ? (iMouse.xy - (0.5 * iResolution.xy)) / iResolution.y : vec2(0.0, sin(iTime * 0.55) * 0.35);\n\tlight l1 = light(l1p, LINTENS(0.09, 1.0, l1p, uv), vec3(0.4, 0.4, 0.8));\n\t\n    // Blinking effect\n\tfloat eff = 0.5 + abs(sin(iTime * Hash1(iTime)) * 0.25);\n    // Scene setup\n\tfloat lDiff = shading(uv, l1);\n\tvec3 fcol = bLight(l1, uv);\n\t\n    // Final mix\n\tfcol = mix(fcol, l1.c * lDiff, smoothstep(1. / iResolution.y, 0.0, generic(uv))) * eff;\n\t\n    fragColor = vec4(fcol, 1.0);\n}\n\n", "image_inputs": [{"id": 30017, "src": "https://soundcloud.com/dsdsdeferadasdasdsadsada/low-roar-give-up", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjGRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[636, 653, 676, 676, 1331], [1333, 1370, 1405, 1405, 1574], [1576, 1604, 1642, 1642, 2015], [2017, 2073, 2109, 2109, 2147], [2149, 2149, 2206, 2206, 2798]], "test": "untested"}
{"id": "dsjGRz", "name": "Random Paths Filled", "author": "mla", "description": "Apply a simple random path rewriting automaton to a closed path. Mouse resets (eg. after a window resize).\n\nNow calculates winding number for cell with corner coordinates (i,j) in Buffer B (can't do in Buffer A as we would always be one frame behind).", "tags": ["random", "paths"], "likes": 7, "viewed": 207, "published": 3, "date": "1667169345", "time_retrieved": "2024-07-30T16:23:47.592255", "image_code": "///////////////////////////////////////////////////////////////////////\n//\n// Random Paths Filled, mla, 2022\n//\n// Apply a simple random path rewriting automaton to a closed path.\n// Mouse resets (eg. after a window resize).\n//\n// Now calculates winding number for cell with corner coordinates (i,j) in\n// Buffer B (can't do in Buffer A as we would always be one frame behind).\n//\n// Path is stored in Buffer A - the x and y components of pixel \n// (i,j) indicate the presence or absence of an edge to (i+1,j), (i,j+1)\n// respectively.\n//\n// There are two types of rewrite, applied to a 2x2 grid:\n//\n// xxxx     x..x    xxxx     ...x\n// .... <-> x..x    x... <-> ...x\n// ....     x..x    x...     ...x\n// ....     xxxx    x...     xxxx\n//\n// Sadly, the algorithm doesn't guarantee that the path remains connected if\n// there is a cross pattern - the wrong side of the cross can get flipped\n// by the second rewrite:\n//\n// ..x..    ..xxx\n// ..x..    ....x\n// xxxxx -> xxx.x\n// ..x..    ..x..\n// ..x..    ..x..\n//\n// I'm not sure what can be done about this without considerably\n// complicating the algorithm.\n//\n///////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  vec2 p = 1.02*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n  p = 0.5*(p+1.0); // Move to [0,1] square\n  ivec2 vertex = clamp(ivec2(round(float(N)*p)),ivec2(0),ivec2(N));\n  float px = fwidth(p.x), d = 1e8;\n  // The 4 segments coming off this vertex - the buffer entries\n  // indicate the presence of rightwards and downwards segments.\n  bvec4 a = bvec4(texelFetch(iChannel0,vertex-ivec2(1,0),0).x,\n                  texelFetch(iChannel0,vertex-ivec2(0,1),0).y,\n                  texelFetch(iChannel0,vertex,0).xy);\n  // I don't usually like this sort of macro, but this one is handy.\n  #define S(p,q,r) (segment((p),vec2(q)/float(N),vec2((q)+(r))/float(N)))\n  if (vertex.x > 0 && a.x) d = min(d,S(p,vertex,-ivec2(1,0)));\n  if (vertex.y > 0 && a.y) d = min(d,S(p,vertex,-ivec2(0,1)));\n  if (vertex.x < N && a.z) d = min(d,S(p,vertex, ivec2(1,0)));\n  if (vertex.y < N && a.w) d = min(d,S(p,vertex, ivec2(0,1)));\n  vec3 col = vec3(1,1,0.8);\n  vec3 tex = texture(iChannel2,fragCoord/iResolution.y).xyz;\n  if (all(greaterThanEqual(p,vec2(0))) && all(lessThanEqual(p,vec2(1)))) {\n    vertex = ivec2(floor(float(N)*p));\n    float sum = texelFetch(iChannel1,vertex,0).x;\n    if (int(sum)%2 != 0) col = vec3(0.8,0,0);\n  }\n  col *= vec3(smoothstep(0.0,px,d-0.1*length(tex)/float(N)));\n  col *= 0.5+0.5*tex;\n  col = pow(col,vec3(0.4545));\n  if (alert) col.x = 1.0;\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 result, vec2 fragCoord) {\n  ivec2 vertex = ivec2(fragCoord);\n  result = texelFetch(iChannel0,vertex,0);\n  if (any(greaterThan(vertex,ivec2(N)))) {\n    result = vec4(0);\n  } else if (iFrame == 0 || iMouse.z > 0.0 || result.w != 1234.0) {\n    result = vec4(vertex.y == 0 || vertex.y == N,\n                  vertex.x == 0 || vertex.x == N,\n                  0,1234);\n  } else {\n    // Consider a 2x2 grid of vertices, with segments possible between each\n    // horizontal and vertical pair of vertices.\n    int n = irand(iFrame+1,4);\n    ivec2 offset = ivec2(n/2,n%2);\n    if (all(greaterThanEqual(vertex,offset)) && all(lessThan(vertex,N+offset))) {\n      ivec2 base = (vertex-offset)/2*2+offset;\n      bvec4 a = bvec4(texelFetch(iChannel0,base,0).xy,\n                      texelFetch(iChannel0,base+ivec2(0,1),0).x,\n                      texelFetch(iChannel0,base+ivec2(1,0),0).y);\n      if (any(a) && !all(a) && a != bvec4(1,0,1,0) && a != bvec4(0,1,0,1)) {\n        if (vertex == base) result.xy = vec2(not(a.xy));\n        if (vertex == base+ivec2(0,1)) result.x = float(!a.z);\n        if (vertex == base+ivec2(1,0)) result.y = float(!a.w);\n      }\n    }\n  }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "int N = 88;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nint irand(int i, int range) {\n return int(ihash(uint(i))%uint(range));\n}\n\nfloat rand(int i, int j) {\n  uint h = ihash(uint(31*i+j));\n  return float(h)/pow(2.0,32.0);\n}\n\nfloat rand(int i) {\n  uint h = ihash(uint(i));\n  return float(h)/pow(2.0,32.0);\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}", "buffer_b_code": "// Calculate fill for cell\nvoid mainImage(out vec4 result, vec2 fragCoord) {\n  ivec2 vertex = ivec2(fragCoord);\n  result = vec4(0);\n  if (all(lessThanEqual(vertex,ivec2(N)))) {\n    float sum = 0.0;\n    // Count the walls off to the right - requires up to N texture\n    // accesses, but doesn't hold things up too much.\n    for (int i = vertex.x+1; i <= N; i++) {\n      // vertex.y indicates presence of vertical segment\n      sum += texelFetch(iChannel0,ivec2(i,vertex.y),0).y;\n    }\n    result.x = sum;\n  }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsjGRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1184, 1184, 1237, 1237, 2622]], "test": "untested"}
{"id": "NtVBWd", "name": "[ConcoursJFIG2022]Pont de pierre", "author": "sukupaper", "description": "Participation in the JFIG 2022 Shadertoy contest.\nInspired by: https://en.wikipedia.org/wiki/Pont_de_pierre_(Bordeaux).", "tags": ["raymarching", "sdf", "spheretracing", "boundingvolume", "contest", "bridge", "boundingbox", "concoursjfig2022"], "likes": 35, "viewed": 812, "published": 3, "date": "1667166688", "time_retrieved": "2024-07-30T16:23:48.731209", "image_code": "// Author: paperu\n// Title: [ConcoursJFIG2022] Pont de pierre\n\n/*\n\n       oYo               oYo\n        |                 |\n    ____|_________________|____\n    ===========================\n        _                 _\n       (o)       _       (o)\n    -_  \"  _-''`` ``''-_  \"  _-\n      \\   /             \\   /\n    ~~|   |~~~~~~~~~~~~~|   |~~\n\nParticipation in the JFIG 2022 Shadertoy contest.\nInspired by: https://en.wikipedia.org/wiki/Pont_de_pierre_(Bordeaux).\n\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 st = (fragCoord.xy - iResolution.xy*.5)/iResolution.x;\n    vec2 st2 = fragCoord.xy/iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    ivec2 uv = ivec2(fragCoord.xy);\n    float dc = length(st);\n    dc = dc*dc;\n    \n    vec3 colorGlow = vec3(0.);\n    for(int i = 0; i < BLUR_FILTER_SZ; i++)\n    {\n        colorGlow += texelFetch(iChannel1, ivec2(uv.x, uv.y + i*GLOW_LEVEL), 0).rgb*GAUSSIAN_KERNEL[i];\n        colorGlow += texelFetch(iChannel1, ivec2(uv.x, uv.y - i*GLOW_LEVEL), 0).rgb*GAUSSIAN_KERNEL[i];\n    }\n    \n    vec3 colorSharp;\n    { // Kind of chromatic aberrations\n        float aa = 1./iResolution.x, b = dc*18.;\n        colorSharp = vec3(\n            texture(iChannel0, st2 + st*aa*b).r,\n            texture(iChannel0, st2).g,\n            texture(iChannel0, st2 - st*aa*b).b\n        );\n    }\n    \n    // Mixing colors\n    vec3 color = vec3(colorGlow*.4 + colorSharp);\n    \n    { // Vignetting effect\n        color *= (1. - dc*ratio*1.25);\n    }\n    \n    { // Gamma correction\n        color = LIN_2_SRGB(color);\n    }\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// --------- Settings\n\n// > Map raymarching steps number to color space (purple/blue = low step count, yellow/red = high step count)\n// #define DEBUG_PERFORMANCES_ENABLED\n\n// > Shows albedo only\n// #define SHADING_DISABLED\n\n// > Shows each individual bounding box with an unique color\n// #define SHOW_BOUNDING_BOXES_ENABLED\n\n// > I tend to believe that 30fps version is better than 60fps (especially for transitions)\n#define FAKE_30_FPS_LIMIT_ENABLED\n\n// > Bruteforce antialiasing\n#define NB_AA_SAMPLE 4\n#define AA_ENABLED\n\n#define RAY_EPSILON 10e-3\n#define NORMAL_EPSILON 10e-4\n\n#define BB_INTERSECT_IT_MAX 6\n\n// --------- Constant and ids\n// Bounding box ids\n#define UNDEFINED_BB_ID 0\n#define BRIDGE_BB_ID 1\n#define FENCE_BB_ID 2\n#define STREET_LAMP_BB_ID 3\n#define WATER_BB_ID 4\n\n// Signed distance functions (sdf) ids\n#define UNDEFINED_SDF_ID -1\n#define S_LAMP_BODY_SDF_ID 0\n#define S_LAMP_WALL_SDF_ID 1\n#define S_LAMP_LIGHTBULB_SDF_ID 2\n#define BRIDGE_MOLDING_SDF_ID 3\n#define BRIDGE_PILLAR_SDF_ID 4\n#define BRIDGE_VAULT_SDF_ID 5\n#define BRIDGE_WALL_SDF_ID 6\n#define BRIDGE_DECO_INTER_SDF_ID 7\n#define BRIDGE_DECO_CORONA_SDF_ID 8\n\n#define JFIG_2022_TEXT_SIZE 9\nconst vec2 JFIG_2022_TEXT[JFIG_2022_TEXT_SIZE] = vec2[](vec2(10.,11.), vec2(6.,11.), vec2(9.,11.), vec2(7.,11.), vec2(0.,5.), vec2(2.,12.), vec2(0.,12.), vec2(2.,12.), vec2(2.,12.));\n\n// --------- Data structures declaration\nstruct Ray          // A 3d ray\n{\n    vec3 o, d;      // origin, direction\n};\n\nstruct Tpos         // Results of bounding box intersection test\n{\n    float min, max; // tmin and tmax position along the ray\n    int bbId;       // bounding box id\n    bool isRm;      // bounding box has to be \"raymarched\"\n};\n\nstruct BBrmSettings // Settings for bounding box with raymarched content\n{\n    int maxStep;    // max number of raymarching step\n    float epsilon;  // epsilon value (performances/quality trade-off)\n};\n\nstruct Result       // Returned at the end of the entire scene intersection test\n{\n    float t;        // t position along the ray at the intersection found\n    int bbId;       // bounding box id (if isRm==true)\n    int sdfId;      // sdf id (if isRm==true)\n    int nbIterations; // raymarching iteration number (if isRm==true)\n    bool isRm;      // if intersection found is in a raymarched bounding box\n    Ray ray;        // ray used for intersection test\n};\n\nstruct SMatSettings // Some basic material settings\n{\n    vec3 albedo;    // material base color/texture\n    float specAmt;  // specular amount\n    float specPow;  // specular size\n    bool isEmissive;// material is emissive\n};\n\nstruct CameraSettings// Same but for camera\n{\n    vec3 pos, target;// position and target (for look at matrix)\n    float fov, sz;   // field of view + sensor size\n    float rotAngle;  // rotation angle\n    vec3 rotAxis;    // rotation axis\n    vec2 st;         // screen coordinates\n};\n\n// --------- Global variables\n// Counter for raymarching steps\n#ifdef DEBUG_PERFORMANCES_ENABLED\nfloat STEP_OBSERVER = 0.;\n#endif\n\n// Some global variables (mainly for animation purpose)\nfloat GRID_MODE_ENABLED = 0.;\nfloat GRID_MODE_POS_ENABLED = 0.;\nfloat GRID_MODE_POS_X = 0.;\nfloat GRID_MODE_SIZE = 1.;\nfloat GRID_MODE_THICKNESS = .0012;\nfloat INFINITE_BRIDGE_ENABLED = 1.;\n\nfloat IS_NIGHT = 0.;\nvec3 SUN_DIRECTION = vec3(0,-1,0);\nvoid setSunDirection(in float a)\n{\n    SUN_DIRECTION = axisRot(vec3(1,0,.25), a)*SUN_DIRECTION;\n}\n\n// Raymarching settings for all bounding box (including not raymarched ones)\n#define DEFAULT_BBRM_SETTINGS BBrmSettings(0, 0.)\nconst BBrmSettings BB_RM_SETTINGS[] = BBrmSettings[]\n(\n    DEFAULT_BBRM_SETTINGS,    // UNDEFINED_BB_ID\n    BBrmSettings(50, .001),   // BRIDGE_BB_ID\n    BBrmSettings(30, .00025), // FENCE_BB_ID\n    BBrmSettings(50, .0005),  // STREET_LAMP_BB_ID\n    DEFAULT_BBRM_SETTINGS     // WATER_BB_ID\n);\n\n#define BB_TPOS_LIST_SIZE 6\nTpos BB_TPOS_LIST[BB_TPOS_LIST_SIZE];\n\n// --------- Utilitary functions\nRay getReflectedRay(in vec3 p, in vec3 n, in vec3 v)\n{\n    vec3 r = reflect(v, n);\n    return Ray(p + r*RAY_EPSILON, r);\n}\n\nRay getShadowRay(in vec3 p, in vec3 n, in vec3 ld)\n{\n    return Ray(p - ld*RAY_EPSILON, -ld);\n}\n\n// ray-box intersection test functions by iq from: https://iquilezles.org/articles/intersectors/\nTpos boxInfXZIntersection(in Ray view, in float boxSize, in int id, in bool isRm) \n{\n    float ro = view.o.y, rd = view.d.y, invRd = 1./rd, invRdRo = invRd*ro;\n    float k = abs(invRd)*boxSize;\n    vec2 tNF = -vec2(invRdRo) + vec2(-k, k);\n    if(tNF.x > tNF.y || tNF.y < 0.) return Tpos(-1., -1., id, isRm);\n    return Tpos(tNF.x, tNF.y, id, isRm);\n}\nTpos boxInfXZIntersection(in Ray view, in float top, in float bottom, in int id, in bool isRm) \n{\n    float boxSize = top - bottom;\n    view.o.y -= top + bottom;\n    return boxInfXZIntersection(view, boxSize, id, isRm);\n}\nTpos boxInfXIntersection(in Ray view, in vec2 boxSize, in int id, in bool isRm) \n{\n    vec2 ro = view.o.yz, rd = view.d.yz, invRd = 1./rd, invRdRo = invRd*ro;\n    vec2 k = abs(invRd)*boxSize;\n    vec4 t12 = -invRdRo.xyxy + vec4(-k, k);\n    vec2 tNF = vec2(max(t12.x, t12.y), min(t12.z, t12.w));\n    if(tNF.x > tNF.y || tNF.y < 0.) return Tpos(-1., -1., id, isRm);\n    return Tpos(tNF.x, tNF.y, id, isRm);\n}\nTpos boxInfXIntersection(in Ray view, in float top, in float bottom, in float width, in float moveZ, in int id, in bool isRm) \n{\n    vec2 boxSize = vec2(top - bottom, width);\n    view.o.yz -= vec2(top + bottom, moveZ);\n    return boxInfXIntersection(view, boxSize, id, isRm);\n}\nTpos boxInfXIntersection(in Ray view, in float top, in float bottom, in float width, in int id, in bool isRm) \n{\n    return boxInfXIntersection(view, top, bottom, width, 0., id, isRm);\n}\n\n// --------- CSG modelisation with SDF\n\n// ----- Street lamp SDF parts\n// tbh I dont know how different street light parts are supposed to be named\nfloat streetLampBodySDF(in vec3 pp)\n{\n    pp.xy = vec2(length(pp.xz), pp.y);\n    \n    const float th1 = .015;\n    const float py1 = .48;\n    const float py2 = -.175;\n    \n    vec2 p = pp.xy;\n    vec2 ap = abs(p.xy);\n    \n    float a = atan(p.x, pp.z);\n    vec2 p1 = vec2(ap.x, p.y + .25)*ROT(0.008) - cos(a*15.)*.0003;\n    float b1 = p1.x - th1;\n    float c1 = length(p.xy + vec2(0., py1 - .06)) - .04;\n    float c2 = length(p.xy + vec2(0., py1 - .015)) - .06;\n    c1 = max(c1, c2);\n    float c3 = length(p.xy + vec2(0., py1 - .1)) - .03;\n    float c4 = length(vec2(ap.x -.065, p.y + py1 - .14)) - .05;\n    c2 = max(c3, -c4);\n    float b2 = length(max(abs(p + vec2(0., py1 - .16)) - vec2(.015, .003), 0.)) - .01;\n    float b3 = max(ap.x - .04, p.y + py1 - .02);\n    float c5 = length(vec2(ap.x - .06, p.y + py1 - .04)) - .05;\n    b3 = max(b3, -c5);\n    float apy2 = abs(p.y + py2) - .019;\n    float b4 = max(ap.x - .022, abs(apy2) - .02);\n    float c6 = length(vec2(ap.x - .026, abs(apy2) - .018)) - .014;\n    b4 = max(b4, -c6);\n    float py3 = py2 - .265;\n    float c7 = (length(vec2(p.x*1.5, p.y + py3)) - .022)/1.5;\n    float c8 = max(length(vec2(p.x, p.y + py3 + .03)) - .016, -(p.y + py3 + .03));\n    c7 = min(c7, c8);\n    \n    float d = b1;\n    d = min(d, c1);\n    d = min(d, c2);\n    d = min(d, b2);\n    d = min(d, b3);\n    d = min(d, b4);\n    d = max(d, p.y + py3);\n    d = min(d, c7);\n    \n    return d;\n}\nfloat lampSupportSubPartSDF(in vec3 pp)\n{\n    const float th1 = .0055;\n    const float r1 = .1;\n    vec2 p = pp.xy;\n    float c1 = length(vec2(length(p) - .1, pp.z)) - th1;\n    c1 = max(c1, max(p.x, -p.y));\n    float c2 = length(vec2(length(vec2(p.x, p.y - r1*(1. - .45))) - r1*.45, pp.z)) - th1;\n    c2 = max(c2, -max(p.x, -p.y));\n    float p1x = p.x + r1*(1. - .35);\n    float c3 = length(vec2(length(vec2(p1x, p.y)) - r1*.35, pp.z)) - th1;\n    c3 = max(c3, max(p1x, p.y));\n    c1 = min(c1, c2);\n    c1 = min(c1, c3);\n    return c1;\n}\nfloat lampSupport1SDF(in vec3 pp)\n{\n    pp.x -= .115;\n    \n    vec2 p = pp.xy;\n    \n    const float th2 = .0025;\n    p.y -= .13;\n    p.x += .055;\n    vec2 pp1 = abs(p) - vec2(.02, .03);\n    float c4 = length(vec2(length(pp1) - .03, pp.z)) - th2;\n    c4 = max(c4, max(-pp1.x, pp1.y));\n    c4 = max(max(c4, -max(p.x, p.y)), -max(-p.x, -p.y));\n    c4 = min(c4, max(length(vec2(p.y, pp.z)) - th2 - smoothstep(0.015, 0.00, abs(p.x))*.005, abs(p.x) - .029));\n    \n    float d = lampSupportSubPartSDF(pp);\n    d = min(d, c4);\n    return d;\n}\nfloat lampSupport2SDF(in vec3 pp)\n{\n    vec3 p = pp;\n    p.y += .3;\n    vec3 ap1 = abs(p);\n    float b1 = max(max(ap1.x - .135, ap1.y - .0075), ap1.z - .0075);\n    float c1 = max(length(ap1.xz*ROT(-T/8.) - .0885) - .007 - p.y*.1, abs(p.y) - .03);\n    b1 = min(b1, c1);\n    const float sz1 = 1.5;\n    vec3 p1 = p*sz1 - vec3(.12,-.112,0.);\n    b1 = min(b1, lampSupportSubPartSDF(p1)/sz1);\n    return b1;\n}\nfloat lampSDF(in vec3 p, inout int sdfId)\n{\n    p.y -= .02;\n    p.x -= .125;\n    \n    vec2 p1 = vec2(length(p.xz), p.y);\n    float py1 = p.y + 0.14;\n    float py2 = p.y + .25;\n    float c2 = length(p.xz);\n    float n1 = max(dot(p1.xy, normalize(vec2(3., 1.))), abs(py1 - .07) - .06);\n    n1 = min(n1, max(c2 - .05, abs(py1) - .008));\n    vec3 p2 = vec3(p.x, py1, p.z);\n    p2.xz = abs(p2.xz) - .03;\n    p2.xz *= ROT(T/8.);\n    p2.yx *= ROT(.068);\n    float lightBulb = c2 - .025*(IS_NIGHT - .1);\n    float c1 = min(length(p2.xz) - .003, lightBulb);\n    c1 = max(max(c1, py1), -py2);\n    float c3 = max(c2 - .04, abs(py2) - .004);\n    vec3 p3 = vec3(p.xz, py2);\n    float s1 = max(length(p3) - .03, abs(py2 + .01) - .01);\n    float s2 = length(p3 + vec3(0.,0.,.03)) - .012;\n    s1 = min(s1, s2);\n    \n    float d = n1;\n    d = min(d, c1);\n    d = min(d, c3);\n    d = min(d, s1);\n\n    sdfId =\n        d == lightBulb ? S_LAMP_LIGHTBULB_SDF_ID\n        : S_LAMP_BODY_SDF_ID;\n\n    return d;\n}\nfloat streetLampBaseSDF(in vec3 pp)\n{\n    vec3 p1 = pp + vec3(0., 0.51, 0.);\n    const vec3 dim = vec3(.1, .05, .035);\n    float b1 = box(p1, dim*vec3(1.,.1,1.));\n    p1.y += .04;\n    b1 = min(b1, box(p1, dim*.8));\n    p1.y += .01;\n    b1 = min(b1, box(p1, dim*vec3(1.3,.1,1.3)));\n    p1.y += .095;\n    b1 = min(b1, box(p1, dim*vec3(1.2, 1.8, 1.2)));\n    return b1;\n}\nfloat streetLampSDF(in vec3 pp, in float type, inout int sdfId)\n{\n    const vec3 position = vec3(0., .785, .7);\n    const float size = .5;\n    \n    pp = vec3(pp.xy, abs(pp.z));\n\n    pp -= position;\n    pp /= size;\n    vec3 q = pp;\n    float ver4 = type; // 1. or 0.\n    float nd = 3. + ver4;\n    float a = atan(q.x, q.z)/T + .5;\n    float aId = floor(a*nd + 1.24 + ver4*(1.5 - 1.24));\n    q.xz *= ROT(-aId*(T/nd));\n    q.y -= .25;\n    \n    float d = streetLampBodySDF(pp);\n    d = min(d, mix(lampSupport1SDF(q), lampSupport2SDF(q), ver4));\n    d = min(d, lampSDF(q, sdfId));\n    d = max(d, -(pp.y + .5));\n    d = min(d, streetLampBaseSDF(pp));\n    \n    return d*size;\n}\n\n// ----- Fences SDF\nfloat fencesSDF(in vec3 p, inout int sdfId)\n{\n    vec3 ap = abs(p);\n    // fencesSDF\n    float aposz = abs(ap.z - 0.7);\n    float aposy = abs(p.y - .435);\n    const float th1 = .002;\n    float b4 = max(abs(p.y - .48) - .005, aposz - .01);\n    float b5 = max((abs(aposy - .025) - th1), aposz - th1);\n    float b6 = max(max(ap.x - .14, aposy - .053), aposz - .015) - step(.465, p.y)*.0015; // bad\n    const float divx1 = .25;\n    float ppx1 = REP(p.x, divx1);\n    float b7 = max(max(abs(ppx1) - .015, aposz - th1), aposy - .05);\n    const float divx2 = .05;\n    float ppx2 = REP(p.x + .025, divx2);\n    float b8 = max(max(abs(ppx2) - th1, aposz - th1), aposy - .05);\n    const float th2 = .001;\n    float ppx3 = REP(p.x, divx2);\n    vec2 ppcr = vec2(ppx3, p.y - .435);\n    ppcr = abs(ppcr);\n    ppcr *= ROT(-T/8.);\n    float ppx4 = REP(p.x + divx1*.5, divx1);\n    float b9 = max(min(max(abs(ppcr.x) - th2, abs(ppcr.y) - .06), abs(length(ppcr) - .0145) - th2), abs(ppx4) - .1);\n    b9 = max(b9, aposz - th2);\n    b4 = min(b5, b4);\n    b4 = min(b4, b7);\n    b4 = min(b4, b8);\n    b4 = min(b4, b9);\n\n    float lampPillar = b6;\n    b4 = min(b4, lampPillar);\n\n    const vec3 position = vec3(0., .785, .7);\n    const float size = .5;\n    vec3 pp  = vec3(p.xy, ap.z);\n    pp -= position;\n    pp /= size;\n    float lampBase = streetLampBaseSDF(pp)*size;\n    b4 = min(b4, lampBase);\n\n    sdfId =\n        b4 == lampPillar ? S_LAMP_WALL_SDF_ID\n        : S_LAMP_BODY_SDF_ID;\n\n    return b4;\n}\n\n// ----- Bridge SDF parts\nfloat bridgePillarSDF(in vec3 p, inout int sdfId)\n{\n    const float rd1 = .25;\n    vec3 ap = abs(p);\n    vec2 k = vec2(\n        mix(\n            length(vec2(p.x, ap.z - .625)) - rd1,\n            ap.x - rd1,\n            step(ap.z, .625)\n        ),\n        p.y + .185\n    );\n    float s1 = max(dot(k, normalize(vec2(.2, 1.))), k.x + .1);\n    s1 = min(s1, max(abs(k.y) - .01, k.x + .09));\n    s1 = min(s1, max(abs(k.y + .005) - .01, k.x + .095));\n    s1 += p.y*.02; // bad\n\n    sdfId = BRIDGE_PILLAR_SDF_ID;\n\n    return s1;\n}\nfloat bridgeDecoSDF(in vec3 p, inout int sdfId)\n{\n    const float szMain = .15;\n    const float rd1 = .5;\n    const float th1 = .05;\n    const float rd2 = .04;\n    const float th2 = .02;\n    const float h = .08;\n    const float rd3 = .04;\n    const float th3 = .005;\n\n    p.z = abs(p.z) - .599;\n    p.y -= .125;\n\n    p /= szMain;\n\n    float c1 = length(p.xy) - rd1;\n    float disc1 = max(abs(p.z - th1*.25) - .05, (c1));\n    float tor1 = RBOX(vec2(c1, p.z), th1, .07);\n\n    vec3 p1 = p;\n    float isUp = step(0., p1.y);\n    p1.y = abs(p1.y);\n    p1.y -= rd1 - .0125*(1. - isUp);\n    p1.xy = abs(p1.xy);\n    p1.xy *= ROT(-.5*isUp);\n    float b1 = RBOX(p1, vec3(.1 + .6*(1. - isUp), 1, 1)*(th1 + .065), .02);\n\n    p.z -= th1*1.25;\n\n    vec3 p2 = vec3(abs(p.x), p.yz);\n    vec3 p3 = p2;\n    p2.y += rd1 + .28;\n    float apx = p2.x - rd2*3.;\n    float sapx1 = sign(apx);\n    float sapx2 = 1. - (sapx1*.5 + .5);\n    float b2 = max(RBOX(vec2(abs(apx) - rd2*2., p2.z), th2, .01), abs(p2.y + h*sapx1*sapx2) - (.02 + .06*sapx2));\n    p2.xy = vec2((p2.x - rd2*3.) - sign(p2.y)*rd2, elong(p2.y, h));\n    float tor2 = RBOX(vec2(length(p2.xy) - rd2, p2.z), th2, .01);\n    tor2 = min(tor2, b2);\n\n    float tor3 = RBOX(vec2(length(p3.xy + vec2(-rd3, rd1 - .185)) - rd3, p3.z), th3, .01);\n\n    float d = tor1;\n    d = min(d, b1);\n    d = min(d, tor2);\n    d = min(d, tor3);\n    d = min(d, disc1);\n\n    sdfId =\n        d == disc1 ? BRIDGE_DECO_INTER_SDF_ID\n        : BRIDGE_DECO_CORONA_SDF_ID;\n\n    return d*szMain;\n}\n\nfloat bridgeSDF(in vec3 p, inout int sdfId)\n{\n    vec3 ap = abs(p);\n\n    const vec2 sz1 = vec2(341./880., 63./105.);\n    \n    float b1 = max(ap.y - sz1.x, ap.z - sz1.y);\n    float c1 = length(vec2(ap.x - 1., p.y + sz1.x*2.15)) - 1.;\n    float c2 = length(vec2(ap.x - 1., p.y + sz1.x*3.2)) - 1.5;\n    \n    float c3 = max(max(min(c2, p.y + .06), -c1), ap.z - sz1.y - .02);\n    vec3 pc4 = vec3(p.xy, ap.z);\n    const float radc4 = 4.2;\n    float dist2c4 = radc4 + sz1.y - .05;\n    pc4.yz *= ROT(0.27);\n    float c4 = length(abs(pc4.xz) - vec2(1., dist2c4)) - radc4;\n    \n    float b2 = max(abs(p.y - .37) - .03, ap.z - .725);\n    vec2 pp = p.xy;\n    const float lll = 1./82.;\n    pp.x = mod(pp.x, lll*4.) - lll*2.;\n    pp = abs(pp - vec2(0., .3));\n    float b3 = max(max(pp.x - lll*1.2, pp.y - .07), abs(ap.z - .75) - .05);\n    b2 = max(b2, -b3);\n\n    int bpSdfId;\n\n    float pillar = bridgePillarSDF(p, bpSdfId);\n\n    int bridgeDecoSdfId;\n    float bridgeDeco = bridgeDecoSDF(p, bridgeDecoSdfId);\n    \n    float d = max(b1, -c1);\n    d = min(d, c3);\n    d = max(d, -c4);\n    d = min(d, pillar);\n    d = min(d, b2);\n    d = min(d, bridgeDeco);\n\n    sdfId =\n        d == b2 ? BRIDGE_MOLDING_SDF_ID\n        : d == pillar ? BRIDGE_PILLAR_SDF_ID\n        : d == -c4 || d == c3 ? BRIDGE_VAULT_SDF_ID\n        : d == bridgeDeco ? bridgeDecoSdfId\n        : BRIDGE_WALL_SDF_ID;\n\n    return d;\n}\n\n// coordinate transformations applied to the scene\nvoid sdfGlobalMap(inout vec3 p, inout float dId)\n{\n    dId = REP_ID_CYCLIC(p.x, 2., 2.);\n    p.x = REP(p.x, 2.);\n}\n\n// compute ALL sdf of the scene, really heavy\nfloat sdfMain1(in vec3 p, inout int sdfId)\n{\n    float dId;\n    sdfGlobalMap(p, dId);\n    float d = bridgeSDF(p, sdfId);\n    d = min(d, fencesSDF(p, sdfId));\n    d = min(d, streetLampSDF(p, dId, sdfId));\n    return d;\n}\nfloat sdfMain1(in vec3 p)\n{\n    int sdfId;\n    return sdfMain1(p, sdfId);\n}\n\n// compute selected sdf with its associated bounding box id\nfloat sdfMain2(in vec3 p, in int bbId, inout int sdfId)\n{\n    float divId, dSurface = 10e9;\n    \n    vec3 pp = p;\n    sdfGlobalMap(pp, divId);\n    \n    switch(bbId)\n    {\n    case BRIDGE_BB_ID:      dSurface = bridgeSDF(pp, sdfId); break;\n    case FENCE_BB_ID:       dSurface = fencesSDF(pp, sdfId); break;\n    case STREET_LAMP_BB_ID: dSurface = streetLampSDF(pp, divId, sdfId); break;\n    }\n    \n    dSurface = mix(max(dSurface, abs(p.x) - 1.52), dSurface, INFINITE_BRIDGE_ENABLED);\n    float dGrid = GRID_SDF(p, GRID_MODE_SIZE, GRID_MODE_THICKNESS, dSurface);\n    return mix(\n        dSurface,\n        dGrid,\n        mix(1., step(p.x - GRID_MODE_POS_X, 0.), GRID_MODE_POS_ENABLED)*GRID_MODE_ENABLED\n    );\n}\n\nfloat sdfMain2(in vec3 p, in int bbId)\n{\n    int sdfId;\n    return sdfMain2(p, bbId, sdfId);\n}\n\n// --------- SDF normal\nvec3 sdfNormal(in vec3 p, in int bbId)\n{\n    vec3 u = vec3(0., BB_RM_SETTINGS[bbId].epsilon, sdfMain2(p, bbId));\n    return normalize(vec3(sdfMain2(p + u.yxx, bbId), sdfMain2(p + u.xyx, bbId), sdfMain2(p + u.xxy, bbId)) - u.z);\n}\n\n// --------- SDF ray marching\nbool intersectSDF(in Tpos tHit, in Ray view, out float t, out int nbIterations, inout int sdfId)\n{\n    nbIterations = 0;\n    int i = BB_RM_SETTINGS[tHit.bbId].maxStep;\n    float d, epsilon = BB_RM_SETTINGS[tHit.bbId].epsilon;\n    for(t = tHit.min; (d = sdfMain2(GET_POS(view, t), tHit.bbId, sdfId)) >= epsilon; t += d)\n    {\n#ifdef DEBUG_PERFORMANCES_ENABLED\n        STEP_OBSERVER++;\n#endif\n        if(t > tHit.max) return false; // no need to iterate outside of the current bounding box (no intersection found)\n        if(i-- < 0) break;             // \"return break\" here is just cheating for removing holes in rendering\n        nbIterations++;\n    }\n    return true;\n}\n\n// --------- Bounding box functions\nvoid keepNearestT(in float t, in Tpos tTest, inout Tpos tOut)\n{\n    if(IS_BETWEEN(tTest.min, t, tOut.min))\n    {\n        tOut.min = tTest.min;\n        tOut.bbId = tTest.bbId;\n        tOut.isRm = tTest.isRm;\n    }\n    else if(IS_BETWEEN(tTest.max, t, tOut.min) || IS_BETWEEN(t, tTest.min, tTest.max))\n    {\n        tOut.min = t;\n        tOut.bbId = tTest.bbId;\n        tOut.isRm = tTest.isRm;\n    }\n    \n    if(IS_BETWEEN(tTest.max, tOut.min, tOut.max))\n        tOut.max = tTest.max;\n    else if(IS_BETWEEN(tTest.min, tOut.min, tOut.max))\n        tOut.max = tTest.min;\n}\n\nvoid updateAllBB(in Ray view)\n{\n    const float bridgeTop = .2005;\n    const float bridgeBottom = -.2;\n    const float bridgeThickness = .789;\n    const float zGap = .7;\n    const float fenceBottom = bridgeTop + 10e-7;\n    const float fenceTop = fenceBottom + .043;\n    const float fenceThickness = .022;\n    const float streetLampBottom = fenceTop;\n    const float streetLampTop = streetLampBottom + .266;\n    const float streetLampThickness = .088;\n    const float waterTop = bridgeBottom;\n    const float waterBottom = waterTop - 10e-5;\n    const float skyBottom = 3.;\n    const float skyTop = skyBottom + 8.;\n    BB_TPOS_LIST[0] = boxInfXIntersection(view, fenceTop, fenceBottom, fenceThickness, zGap, FENCE_BB_ID, true);\n    BB_TPOS_LIST[1] = boxInfXIntersection(view, fenceTop, fenceBottom, fenceThickness, -zGap, FENCE_BB_ID, true);\n    BB_TPOS_LIST[2] = boxInfXIntersection(view, bridgeTop, bridgeBottom, bridgeThickness, BRIDGE_BB_ID, true);\n    BB_TPOS_LIST[3] = boxInfXIntersection(view, streetLampTop, streetLampBottom, streetLampThickness, zGap, STREET_LAMP_BB_ID, true);\n    BB_TPOS_LIST[4] = boxInfXIntersection(view, streetLampTop, streetLampBottom, streetLampThickness, -zGap, STREET_LAMP_BB_ID, true);\n    BB_TPOS_LIST[5] = boxInfXZIntersection(view, waterTop, waterBottom, WATER_BB_ID, false);\n}\n\nvoid intersectAllBB(in float t, out Tpos tHit)\n{\n    tHit = Tpos(10e9, 10e9, UNDEFINED_BB_ID, false);\n    for(int i = 0; i < BB_TPOS_LIST_SIZE; i++)\n        keepNearestT(t, BB_TPOS_LIST[i], tHit);\n}\n\nResult intersectBB(in Ray ray)\n{\n    updateAllBB(ray);\n    Tpos tHit;\n    float t = 0.;\n    int sdfId = UNDEFINED_SDF_ID, nbIterations = 0;\n    for(int i = 0; i < BB_INTERSECT_IT_MAX; i++)\n    {\n        intersectAllBB(t, tHit);\n#ifdef SHOW_BOUNDING_BOXES_ENABLED\n        if(IS_RIGHT_HALF_SCREEN) break;\n#endif\n        if(tHit.isRm)\n        {\n            if(intersectSDF(tHit, ray, t, nbIterations, sdfId))\n                break;\n            t = tHit.max;\n        }\n        else\n        {\n            t = tHit.min;\n            break;\n        }\n    }\n    return Result(t, tHit.bbId, sdfId, nbIterations, tHit.isRm, ray);\n}\n\n// --------- Material and color functions\nfloat starSdf(in vec2 p, in float divVal, in float sizeMin, in float sizeMax, in float seed)\n{\n    p *= ROT(seed);\n    vec2 pId = REP_ID(p, divVal)*seed;\n    p = REP(p, divVal);\n    float rd1 = RAND(pId);\n    float rd = mix(divVal*sizeMin, divVal*sizeMax, rd1);\n    p += vec2(rd1, RAND(pId.yx*12.78))*(divVal*.5 - rd);\n    return length(p) - rd;\n}\n\nfloat starySky(in vec2 uv, in float size)\n{\n    float aa = 10e-4;\n    vec2 minMax = vec2(.05, .1);\n    uv *= size;\n    float fc = .2 + .05; // cnoise(uv*size*.05)*.5 + \n    minMax *= fc;\n    float d = starSdf(uv, .4, minMax.x, minMax.y, 1.);\n    d = min(d, starSdf(uv, .55, minMax.x, minMax.y, 4.));\n    d = min(d, starSdf(uv, .3333, minMax.x, minMax.y, 6.));\n    return smoothstep(0., -aa*2., d/size);\n}\n\nvoid computeSkyColor(in vec3 ray, in vec3 sunDir, inout vec3 outColor, inout vec3 outColorOnly, inout vec3 ambientOut, inout float isNight, inout float isNightTransition)\n{\n    const float sunRadius = 0.;\n    const float sunBlur = .00005;\n    const vec3 sunColor = vec3(1.15, 1.1, 1.)*100.;\n\n    float sunDistReal = dot(ray, sunDir)*.5 + .5;\n    float sunDist = dot(ray, sunDir) + 1. - sunRadius;\n    float sunHeight = sunDir.y*.5 + .5;\n    float horizonDist = dot(vec3(0,1,0), ray) * .5 + .5;\n    float sunInfluenceDist = opSmoothUnion(horizonDist - .5, sunDistReal - .001, .2);\n    \n    float skyDayCurve = SS_QUAD(horizonDist);\n    vec3 skyDay = mix(vec3(0.554,0.909,0.985), vec3(0.159,0.493,0.985)*.5, skyDayCurve);\n    \n    float curveA = POW5(1. - sunDistReal);\n    vec3 colorA = mix(vec3(0.985,0.549,0.218), vec3(0.960,0.690,0.350), curveA);\n    float skyRiseCurve = smoothstep(-.01, .1, sunInfluenceDist);\n    skyRiseCurve = clamp(1. - POW5(1. - sunInfluenceDist), 0., 1.);\n    vec3 skyRise = mix(colorA, vec3(0.226,0.409,0.985)*.5*(1. - .5*sunHeight), skyRiseCurve);\n    \n    float skyNightCurve = SS_QUAD(sunDistReal);\n    vec3 skyNight = mix(vec3(0.031,0.076,0.115)*.5, vec3(0.015,0.075,0.185)*.1, skyNightCurve);\n\n    float nightDayCurve = smoothstep(.45, .55, sunHeight);\n    vec3 sky = mix(skyDay, skyNight, nightDayCurve);\n\n    isNight = smoothstep(.55, .65, sunHeight);\n    isNightTransition = smoothstep(.45, .5, sunHeight)*smoothstep(.65, .60, sunHeight);\n    \n    float transitionCurve = smoothstep(.0, .2, abs(sunHeight - .5));\n    sky = mix(skyRise, sky, transitionCurve);\n\n    ambientOut = mix(\n        vec3(0.438,0.335,0.230),\n        mix(vec3(.122,.438,.985), vec3(.122,.438,.985)*.01, nightDayCurve),\n        transitionCurve\n    );\n\n    outColorOnly = sky;\n\n    sky = mix(sky, sunColor, smoothstep(sunBlur, -sunBlur, sunDist));\n    \n    vec2 pol = vec2(atan(ray.x, ray.z), ray.y);\n    float stars = starySky(pol, 30.);\n    sky = mix(sky, sky + stars*.8, nightDayCurve);\n    \n    outColor = sky;\n}\n\n// A basic procedural brick texture\nvoid brickSdf(in vec2 p, in float aa, inout vec2 pId, inout float dOut,\n    in float gapBase, in float gapRdn, in float sz, in vec2 pat, in float rdBase)\n{\n    pat /= sz;\n    rdBase /= sz;\n    \n    pId = REP_ID(p, pat);\n    p.x += RAND(pId.yy)*pat.x;\n    pId = REP_ID(p, pat);\n    p = REP(p, pat);\n\t\n    float rd1 = RAND(pId.xy);\n    float gap = (gapBase + rd1*gapRdn)/sz;\n    float d = RBOX(p, (pat - rdBase*2. - gap)*.5, rdBase);\n    \n    dOut = smoothstep(-aa, aa, d);\n}\n\n// Set material settings depending on intersected sdf (messy code here)\nvoid getMaterialSettings(in float isNight, in int sdfId, in vec3 p, inout SMatSettings material)\n{\n    const vec3 mainTone = vec3(0.990,0.734,0.538);\n    const vec3 secTone = vec3(0.990,0.666,0.370);\n    const vec3 brickTone = vec3(0.975,0.385,0.273);\n    switch(sdfId)\n    {\n    case S_LAMP_BODY_SDF_ID:\n        material.albedo = vec3(.2);\n        material.specAmt = .9;\n        material.specPow = 20.;\n        break;\n    case S_LAMP_WALL_SDF_ID:\n        {\n            vec2 uv = vec2(REP(p.x, 2.), p.y + .058);\n            vec2 pId;\n            float d;\n            brickSdf(uv, MIN2(fwidth(uv)), pId, d, .005, .05, 22., vec2(1.,.5), .04);\n            vec3 c = mainTone;\n            material.albedo = mix(c*mix(.7, 1., RAND(pId)), c*1.1, d);\n            material.specAmt = 0.;\n        }\n        break;\n    case S_LAMP_LIGHTBULB_SDF_ID:\n        material.isEmissive = true;\n        material.albedo = isNight*vec3(1.,1.,.7)*4.;\n        break;\n    case BRIDGE_MOLDING_SDF_ID:\n        {\n            vec2 uv1 = vec2(REP(p.x, 2.), p.y), uv2 = p.xz, pId1, pId2;\n            float isBridgeFloor = step(max(abs(p.z) - .65, -p.y + .35), 0.), d1, d2;\n            brickSdf(uv1, 10e-3, pId1, d1, .005, .05, 1., vec2(4./82.,1.), .0);\n            brickSdf(uv2, length(fwidth(uv2)), pId2, d2, .001, .002, 1., vec2(.035), .005);\n            vec3 c1 = mainTone, c2 = vec3(secTone);\n            material.albedo = mix(\n                mix(c1*mix(.7, 1., RAND(pId1)), c1*1.1, d1),\n                mix(c2*mix(.7, 1., RAND(pId2)), mainTone*1.1, d2),\n                isBridgeFloor\n            );\n            material.specAmt = 0.;\n        }\n        break;\n    case BRIDGE_PILLAR_SDF_ID:\n        {\n            float apZ = abs(p.z) - .625;\n            vec2 uv1 = vec2(REP(p.x, 2.), apZ);\n            vec2 pol = vec2(atan(uv1.x, uv1.y)/T, p.y);\n            vec2 uv2 = vec2(p.z, p.y);\n            vec2 uv = mix(uv2, pol, step(.0, apZ));\n            vec2 pId;\n            float d;\n            brickSdf(uv, MIN2(fwidth(uv)), pId, d, .005, .05, 20., vec2(1.,.8), .04);\n            vec3 c = mainTone*1.2;\n            material.albedo = mix(c*mix(.5, 1., RAND(pId)), c*.4, d);\n            material.specAmt = 0.;\n        }\n        break;\n    case BRIDGE_VAULT_SDF_ID:\n        {\n            float isVaultInt = step(max(abs(p.z) - .55, -p.y - .2), 0.), d1, d2;\n            p.xy = vec2(REP(p.x + 1., 2.), p.y + .85);\n            vec2 pol1 = vec2(length(p.xy), atan(p.x, p.y)), pId1;\n            vec2 pol2 = vec2(pol1.y, p.z), pId2;\n            brickSdf(pol1, 10e-2, pId1, d1, .005, .01, 7., vec2(1.,.2), .001);\n            brickSdf(pol2, MIN2(fwidth(pol2)), pId2, d2, .02, .01, 25., vec2(1.,.2), .05);\n            vec3 c1 = mainTone, c2 = brickTone;\n            material.albedo = mix(\n                c1*mix(.7, 1., RAND(pId1)),\n                mix(c2*mix(.7, 1., RAND(pId2)), vec3(1.,.8,.5), d2),\n                isVaultInt\n            );\n            material.specAmt = 0.;\n        }\n        break;\n    case BRIDGE_WALL_SDF_ID:\n        {\n            p.xy = vec2(REP(p.x + 1., 2.), p.y + 1.2);\n            vec2 pol = vec2(atan(p.x, p.y), length(p.xy)).yx, pId;\n            float d;\n            brickSdf(pol, MIN2(fwidth(pol)), pId, d, .02, .01, 25., vec2(1.,.2), .05);\n            vec3 c = brickTone;\n            material.albedo = mix(c*mix(.7, 1., RAND(pId)), vec3(1.,.8,.5), d);\n            material.specAmt = 0.;\n        }\n        break;\n    case BRIDGE_DECO_INTER_SDF_ID:\n        {\n            vec2 uv = p.xy;\n            vec2 pId;\n            float d;\n            brickSdf(uv, 10e-5, pId, d, .005, .01, 5., vec2(1.,.2), .01);\n            vec3 c = mainTone*.8;\n            material.albedo = mix(c*mix(.9, 1., RAND(pId)), c*1.05, d);\n            material.specAmt = 0.;\n        }\n        break;\n    case BRIDGE_DECO_CORONA_SDF_ID:\n            material.albedo = mainTone;\n            material.specAmt = 0.;\n        break;\n    }\n}\n\nvoid shadingDay(in SMatSettings mat, in vec3 amb, in vec3 vd, in vec3 n, in vec3 ld, in float penumbra, inout vec3 outColor)\n{\n    amb *= .05 + .1*max(0., dot(reflect(ld, vec3(0,1,0)), n));\n    float diff = max(0., dot(-ld, n));\n    float spec = pow(max(0., dot(-vd, reflect(ld, n))), mat.specPow);\n    outColor = (amb*6. + vec3(mix(mix(diff, spec, mat.specAmt), 0., penumbra)))*mat.albedo;\n}\n\nfloat getLightPower(in SMatSettings mat, in vec3 lpos, in vec3 n, in vec3 vd, in vec2 pw)\n{\n    float dist = length(lpos);\n    vec3 ld = lpos/dist;\n    float diff = max(0., dot(-ld, n));\n    return (pw.x*diff)/pow(dist, pw.y);\n}\n\nvoid computeShading(in Result res, in float isNightTransition, in vec3 ambientColor, inout vec3 outColor)\n{\n    vec3 p = GET_POS(res.ray, res.t), n = sdfNormal(p, res.bbId);\n\n    SMatSettings mat = SMatSettings(vec3(1), .4, 10., false);\n    getMaterialSettings(IS_NIGHT, res.sdfId, p, mat);\n\n#ifdef SHADING_DISABLED\n    outColor = mat.albedo; return;\n#endif\n    \n    // for light bulbs\n    if(mat.isEmissive)\n    {\n        outColor = mat.albedo;\n        return;\n    }\n    \n    vec3 vd = res.ray.d, ldir;\n    float penumbra, lum, isBottomLight;\n\n    { // night lights\n        isBottomLight = step(p.y - .37, 0.);\n        vec3 ppf = vec3(\n            DIV_F(p.x, 2.) + 1.,\n            mix(vec2(1.3, sign(p.z)*.7), vec2(0., sign(p.z)*.75), isBottomLight)\n        );\n        vec2 pw = mix(vec2(.3, 7.), vec2(.03, 3.), isBottomLight)*vec2(IS_NIGHT, 1.);\n        vec3 ld1 = p - ppf; // closest light\n        vec3 ld2 = p - ppf - vec3(2.*sign(REP(p.x, 2.)), 0., 0.); // left and right ligths\n        vec3 ld3 = p - ppf + vec3(0., 0., 1.4*sign(p.z)); // in front light\n        lum = getLightPower(mat, ld1, n, vd, pw)\n            + getLightPower(mat, ld2, n, vd, pw)\n            + getLightPower(mat, ld3, n, vd, pw);\n        lum *= IS_NIGHT;\n\n        ldir = mix(SUN_DIRECTION, ld1, step(.1, IS_NIGHT));\n    }\n\n    { // shadow\n        Result shadowRes = intersectBB(getShadowRay(p, n, ldir));\n        penumbra = float(shadowRes.bbId != UNDEFINED_BB_ID);\n        penumbra = mix(penumbra, penumbra*(1. - isBottomLight), step(.1, IS_NIGHT));\n        penumbra = mix(penumbra, 1., isNightTransition);\n        if(res.bbId == STREET_LAMP_BB_ID) lum = 0.;\n    }\n\n    // little trick (specular lights cannot work during night)\n    mat.specAmt = mix(mat.specAmt, 0., IS_NIGHT);\n    \n    // compute shading\n    shadingDay(mat, ambientColor, vd, n, ldir, penumbra, outColor);\n\n    // adjusting color\n    outColor *= mix(vec3(1), lum*vec3(1.,.9,.6), IS_NIGHT);\n\n    // approximative ambient occlusion\n    {\n        float k = max(0., 1. - float(res.nbIterations)/float(BB_RM_SETTINGS[res.bbId].maxStep));\n        outColor = mix(outColor, outColor*k*k, penumbra*(1. - IS_NIGHT));\n    }\n}\n\n// --------- Scene setting and rendering functions + animations\nvoid computeWaterReflectionIntersection(in float time, inout float fresnelAngle, inout Ray view, inout Result res)\n{\n    vec3 p = GET_POS(view, res.t), n = vec3(0., 1., 0.);\n\n    vec2 uv = p.xz, uv2 = uv + time*.2, uv3 = uv + time*.1;\n    vec2 sh = vec2(cnoise(uv2), cnoise(-uv3*8.5))*.2;\n    float pillarsSdf = sdfMain2(vec3(uv.x, -.95, uv.y), BRIDGE_BB_ID);\n    float pillarWave = mix(cos(pillarsSdf*20. - time*3.), 0.1, min(pillarsSdf*1.5, 1.));\n\n    float a = dot(view.d, n)*.5 + .5;\n    float ma = (1. - pow(a*2.02, 3.5));\n\n    n = normalize(n + vec3(sh.x, 0., sh.y)*pillarWave*ma);\n\n    fresnelAngle = clamp(a*a*a*8., .1, .98);\n\n    view = getReflectedRay(p, n, view.d);\n    res = intersectBB(view);\n}\n\nfloat croissantSdf(in vec2 p, in float off2, in float anim)\n{\n    p = -p;\n    float off1 = mix(.075, .13, anim);\n    float d1 = MOON(p - vec2(0., off1));\n    float d2 = MOON(p*ROT((T/3.)*1.) - vec2(0., off1));\n    float d3 = MOON(p*ROT((T/3.)*2.) - vec2(0., off1));\n    d1 = max(d1, -d3 + off2);\n    d2 = max(d2, -d1 + off2);\n    d3 = max(d3, -d2 + off2);\n    return min(d1, min(d2, d3));\n}\n\nvoid computeScene(in Ray view, in float time,\n    in float pixelateDist, in float tPlane, in vec3 bgColor, inout vec3 colorOut,\n    in vec3 patternColor\n    )\n{\n    vec3 skyColor, skyColorOnly, ambientColor;\n    float isNightTransition;\n    computeSkyColor(view.d, SUN_DIRECTION, skyColor, skyColorOnly, ambientColor, IS_NIGHT, isNightTransition);\n    \n    Result res = intersectBB(view);\n    vec3 pos = GET_POS(res.ray, res.t);\n    \n    float patternOpacity = tPlane <= res.t ? pixelateDist : 0.;\n    \n    if(GRID_MODE_ENABLED*(1. - GRID_MODE_POS_ENABLED) > 0.\n        || (GRID_MODE_POS_ENABLED > 0. && (pos.x < GRID_MODE_POS_X))\n    )\n    {\n        colorOut = res.isRm ? vec3(1.) : bgColor;\n        colorOut = mix(colorOut, patternColor, patternOpacity);\n        return;\n    }\n    \n    float depht = res.t, fresnelAngle = 1.;\n    if(res.bbId == WATER_BB_ID)\n    {\n        computeWaterReflectionIntersection(time, fresnelAngle, view, res);\n        computeSkyColor(view.d, SUN_DIRECTION, skyColor, skyColorOnly, ambientColor, IS_NIGHT, isNightTransition);\n        depht += res.t;\n    }\n    \n    if(res.bbId == UNDEFINED_BB_ID)\n    {\n        colorOut = hsv2rgb(rgb2hsv(skyColor)*vec3(1.,1.2,1.1));\n        colorOut = mix(colorOut, patternColor, patternOpacity);\n        return;\n    }\n    else computeShading(res, isNightTransition, ambientColor, colorOut);\n    \n    colorOut = mix(vec3(0.), colorOut, fresnelAngle);     // reflection mixing\n    colorOut = hsv2rgb(rgb2hsv(colorOut)*vec3(1.03,1.2,1.1));\n    colorOut = mix(skyColorOnly, colorOut, exp(-depht*.005)); // fog\n    \n    colorOut = mix(colorOut, patternColor, patternOpacity);\n    \n    float d = pos.x - GRID_MODE_POS_X;\n    d = min(pow(d*5., .2), 1.);\n    colorOut = mix(mix(colorOut, vec3(2.), GRID_MODE_POS_ENABLED), colorOut, d);\n}\n\nfloat charSdf(in vec2 uv, in vec2 sel)\n{\n    const float sz = 4., u = 1./16.;\n    return max((texture(iChannel3, uv + sel*u + u*.5).a - .5)*u, box(uv, u*.5));\n}\n\nfloat jfig2022textSdf(in vec2 uv, in float spcg)\n{\n    const float jfig2022TextSize = float(JFIG_2022_TEXT_SIZE);\n    float uvx = uv.x, wdth = jfig2022TextSize*.5*spcg;\n    uv.x += wdth - spcg*.5;\n    float idx = floor(uv.x/spcg + .5);\n    int idxInt = int(idx);\n    float d = charSdf(uv - vec2(idx*spcg, 0.), JFIG_2022_TEXT[idxInt]);\n    return max(d, abs(uvx) - wdth);\n}\n\nvec3 backgroundColor(in vec2 uv, in float aa, in float sz, in float t)\n{\n    const mat2 r = ROT(T/8.);\n    const mat2 r2 = ROT(-T/8.);\n    return mix(\n        vec3(BORDEAUX*mix(.9, 1.1, uv.y*10. + .5)),\n        BORDEAUX,\n        smoothstep(-aa, aa, abs(croissantSdf(REP((uv*r)*sz + t, 1.)*r2, 0., 0.))/sz - aa*.25)\n    );\n}\n\nfloat titleScreenSdf(in vec2 uv, in float aa, in float offset, in float sz1, in float ftsz,\n    in float spacing, in float anim)\n{\n    offset *= sz1;\n    spacing /= 16.;\n    uv *= sz1;\n    float dt = jfig2022textSdf(uv/ftsz, spacing)*ftsz;\n    float dc = croissantSdf(uv, offset, anim);\n    float d = max(dc, -dt + offset);\n    d = min(d, dt);\n    return smoothstep(-aa, aa, d/sz1);\n}\n\nbool timingSel(in float tStart, in float tEnd, in float tIn, inout float tOut)\n{\n    tOut = INV_MIX(tStart, tEnd, tIn);\n    return tIn < tEnd;\n}\n\nvoid computeSceneCameraAnim(inout float currT, in vec2 st, in float aa, in vec2 m, inout CameraSettings cam, \ninout float pixelationEnabled, inout float shutterPosOut, inout vec3 bgColorOut)\n{\n    cam.st = st;\n    cam.pos = vec3(0., 0., -5.);\n    cam.target = vec3(0.);\n    cam.fov = 1.;\n    cam.sz = 1.;\n    cam.rotAngle = 0.;\n    cam.rotAxis = vec3(0., 1., 0.);\n    \n    currT = mod(currT, 100.); // time loop\n    \n    bgColorOut = backgroundColor(st, aa, 50., currT*.5);\n    \n    float t0 = SM1(TIMING(currT,.1,2.));\n    INFINITE_BRIDGE_ENABLED = 0.;\n    GRID_MODE_ENABLED = 1.;\n    GRID_MODE_SIZE = 1./5.;\n    shutterPosOut = mix(.2*t0, .5*smoothstep(100., 96., currT), smoothstep(56., 58., currT));\n    \n    float sunDirection = -1.;\n    \n    float t;\n    if(timingSel(0., 2.5, currT, t))\n    {\n        cam.st.y += .75;\n    }\n    else if(timingSel(2.5, 7.5, currT, t))\n    {\n        cam.st.y += mix(.75, 0., SM1(t));\n        GRID_MODE_SIZE = 1./200.;\n        GRID_MODE_THICKNESS = .00001;\n        cam.pos = vec3(0., 0., -5.);\n        cam.target = vec3(1., mix(1., .65, ISM1(t)), -.7);\n        cam.fov = 7.;\n        cam.rotAngle = t*.5 + .15;\n    }\n    else if(timingSel(7.5, 10., currT, t))\n    {\n        GRID_MODE_SIZE = 1./400.;\n        GRID_MODE_THICKNESS = .00001;\n        cam.pos = vec3(2., 0., -5.);\n        cam.target = vec3(mix(0., .25, ISM1(t)), .45, -.7);\n        cam.fov = 10.;\n    }\n    else if(timingSel(10., 15., currT, t))\n    {\n        GRID_MODE_SIZE = 1./5.;\n        float id = step(0., st.x);\n        cam.st.x = REP(st.x, .5);\n        cam.pos = vec3(0., 0.1, 100.*(1. - id)) + vec3(.01, 100.*id, 0.);\n        cam.rotAngle = mix(currT, 0., id);\n        cam.fov = length(cam.pos*mix(.2, .25, id));\n        cam.st.y += sign(st.x)*.5*mix(1., -1., ISM1(t));\n    }\n    else if(timingSel(15., 18., currT, t))\n    {\n        GRID_MODE_POS_ENABLED = 1.;\n        GRID_MODE_POS_X = 1.53;\n        cam.pos = mix(vec3(2., 1., 0.), vec3(2., .25, 0.), ISM1(t));\n        cam.target = vec3(1.5, .5, 0.);\n        cam.fov = length(cam.pos*.2);\n        cam.rotAngle = 0.;\n        pixelationEnabled = max(t - .2, 0.);\n    }\n    else if(timingSel(18., 22., currT, t))\n    {\n        cam.pos = mix(vec3(0., .25, -7.), vec3(-3., 1.5, -4.), ISM1(t));\n        cam.target = vec3(1.75, .5, 0.);\n        cam.fov = 2.;\n        cam.rotAngle = 0.;\n        GRID_MODE_POS_ENABLED = 1.;\n        GRID_MODE_POS_X = 1.53;\n        pixelationEnabled = min(t + .05, 1.);\n    }\n    else if(timingSel(22., 24., currT, t))\n    {\n        cam.pos = mix(vec3(5., 0., -7.), vec3(7., 1.53, -7.), ISM1(t));\n        cam.target = vec3(1.5, .5, 0.);\n        cam.fov = 2.;\n        cam.rotAngle = 0.;\n        GRID_MODE_POS_ENABLED = 1.;\n        GRID_MODE_POS_X = mix(1.75, .5, t);\n        pixelationEnabled = 1.;\n    }\n    else if(timingSel(24., 26., currT, t))\n    {\n        cam.pos = mix(vec3(2., 7., 0.), vec3(2., 20., 0.), ISM1(t));\n        cam.target = vec3(0.5, 0., 0.);\n        cam.fov = 2.;\n        cam.rotAngle = 0.;\n        GRID_MODE_POS_ENABLED = 1.;\n        GRID_MODE_POS_X = mix(1.25, 0., t);\n        pixelationEnabled = 1.;\n    }\n    else if(timingSel(26., 30., currT, t))\n    {\n        cam.pos = vec3(0., 0., -3.);\n        cam.target = vec3(0., .25, 0.);\n        cam.fov = .75;\n        cam.rotAngle = ISM1(t)*T;\n        GRID_MODE_POS_ENABLED = 1.;\n        GRID_MODE_POS_X = mix(.5, 0., t);\n        pixelationEnabled = 1.;\n    }\n    else if(timingSel(30., 34., currT, t))\n    {\n        cam.pos = mix(vec3(-2., 0., -20.), vec3(-5., 8., -20.), ISM1(t));\n        cam.target = vec3(-t*.5, .25, 0.);\n        cam.fov = mix(9.5, .5, ENL(ISM1(t), .25));\n        cam.rotAngle = 0.;\n        GRID_MODE_POS_ENABLED = 1.;\n        GRID_MODE_POS_X = 0.;\n        INFINITE_BRIDGE_ENABLED = 1.;\n        pixelationEnabled = 1.;\n        GRID_MODE_POS_X = mix(0., -5., SM1(max(0., t - .25)));\n    }\n    else if(timingSel(34., 38., currT, t))\n    {\n        cam.pos = mix(vec3(0., 5., 1.), vec3(0., 1., 3.), t);\n        cam.target = mix(vec3(0., .25, 0.), vec3(-10., .25, 0.), ISM1(t));\n        cam.fov = 1.;\n        cam.rotAngle = 0.;\n        GRID_MODE_POS_ENABLED = 1.;\n        GRID_MODE_POS_X = -almostIdentity(t, .5, 0.)*8.;\n        INFINITE_BRIDGE_ENABLED = 1.;\n        pixelationEnabled = 1.;\n    }\n    else if(timingSel(38., 42., currT, t))\n    {\n        cam.pos = mix(vec3(-4., 2., 1.), vec3(-4., .25, 1.), ISM1(t));\n        cam.target = vec3(0., .25, 0.);\n        cam.rotAngle = 0.;\n        GRID_MODE_POS_ENABLED = 1.;\n        GRID_MODE_POS_X = -t*8.;\n        INFINITE_BRIDGE_ENABLED = 1.;\n        pixelationEnabled = 1.;\n    }\n    else if(timingSel(42., 46., currT, t))\n    {\n        cam.pos = vec3(0., .5, mix(2., 30., ISM1(t)));\n        cam.target = vec3(0., .25, 0.);\n        cam.rotAngle = .5*(1. - ISM1(t));\n        GRID_MODE_ENABLED = 0.;\n        INFINITE_BRIDGE_ENABLED = 1.;\n        sunDirection = mix(sunDirection, -.75, t);\n    }\n    else if(timingSel(46., 56., currT, t))\n    {\n        cam.pos = vec3(0., .5, -6.);\n        cam.target = vec3(0., .25, 0.);\n        cam.rotAngle = mix(-T*.4, T*.82, SM1(ENL(t, .75)));\n        cam.rotAxis = vec3(0.125, 1., 0.);\n        GRID_MODE_ENABLED = 0.;\n        INFINITE_BRIDGE_ENABLED = 1.;\n        sunDirection = mix(-.2, -2., t*1.7);\n    }\n    else\n    {\n        cam.pos = vec3(0., 7.*(m.y + .45), -4.5);\n        cam.rotAngle = -(m.x + .5)*T + currT*.1;\n        GRID_MODE_ENABLED = 0.;\n        INFINITE_BRIDGE_ENABLED = 1.;\n        sunDirection = currT*.2 + 4.;\n    }\n    \n    setSunDirection(sunDirection);\n    \n    timingSel(0., 5., currT, t);\n    bgColorOut = mix(\n        vec3(1),\n        bgColorOut,\n        titleScreenSdf(\n            cam.st - vec2(0., .75), aa, aa*2.,\n            1.75,\n            1.4 + t*.1,\n            1. + t,\n            .5 + .5*t\n        )\n    );\n}\n\nvoid getViewFromCameraSettings(in CameraSettings cam, inout Ray view)\n{\n    view.o = cam.pos;\n    view.d = normalize(vec3(cam.st*cam.sz, -cam.fov));\n    view.o = axisRot(cam.rotAxis, cam.rotAngle)*view.o;\n    view.d = lookAt(view.o, cam.target)*view.d;\n}\n\nvoid intersectWithTransitionPlane(in Ray view, inout float t)\n{\n    view.o.x -= GRID_MODE_POS_X;\n    view.d = view.d.zyx;\n    view.o = view.o.zyx;\n    Tpos tBoxRes = boxInfXIntersection(view, vec2(10., 10e-3), 0, false);\n    t = tBoxRes.min;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 st = (fragCoord.xy - iResolution.xy*.5)/iResolution.x;\n    float aa = 1./iResolution.x;\n    vec2 m = (iMouse.xy - iResolution.xy*.5)/iResolution.xy;\n    float t = iTime;\n\n#ifdef FAKE_30_FPS_LIMIT_ENABLED\n    t = DIV_F(t, 1./30.);\n#endif\n\n    CameraSettings camera;\n    vec3 bgColor;\n    float pixelationEnabled = 1., shutterPos = .5;\n    computeSceneCameraAnim(t, st, aa, m, camera, pixelationEnabled, shutterPos, bgColor);\n\n    if(abs(st.y) - shutterPos > 0.)\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n\n    vec4 colorAlpha = vec4(0.);\n\n#ifdef AA_ENABLED\n    vec2 aa2 = 1./iResolution.xy;\n    vec2 cameraStBase = camera.st;\n    for(int i = 0; i < NB_AA_SAMPLE; i++)\n    {\n        camera.st = cameraStBase + randomVec2(vec2(iFrame + i)*10e-5)*aa2;\n#endif\n    \n        Ray view;\n        getViewFromCameraSettings(camera, view);\n\n        float tPlane = 10e9;\n        vec3 patternColor = vec3(0.);\n        float patternOpacity = 0.;\n        { // magical barrier at transition\n            intersectWithTransitionPlane(view, tPlane);\n            if(tPlane > 0. && GRID_MODE_POS_ENABLED > 0.)\n            {\n                vec3 p = GET_POS(view, tPlane);\n\n                float angle = t*.25;\n                mat2 r1 = ROT(angle);\n                mat2 r2 = ROT(-angle);\n                vec2 speed = vec2(.25, -.25)*t*0.;\n                vec2 pidPixel, stPixel, uvPixel, szPixel;\n                randomPixelate(\n                    p.yz*r1 - speed,\n                    vec2(.5), 2., 5,\n                    0., // /*t*10e-7 + */GRID_MODE_POS_X*10e-7\n                    pidPixel, stPixel, uvPixel, szPixel\n                );\n                stPixel += speed;\n                stPixel *= r2;\n                uvPixel *= r2;\n\n                uvPixel = uvPixel.yx;\n\n                float d1 = max(sdfMain1(vec3(p.x, stPixel)), -p.y - .35) - 0.05;\n                d1 = min(d1, p.y + .35);\n                const float smv = .2;\n                d1 = smoothstep(smv*2., -smv, d1);\n\n                float sz = szPixel.x*1.5*d1;\n                float aa = fwidth(tPlane);\n                float d2 = smoothstep(aa, -aa, abs(croissantSdf(uvPixel/sz, 0., 0.)*sz + aa*.5) - aa*.5);\n\n                patternOpacity = d2*pixelationEnabled;\n\n                patternColor = SpectrumPoly((d1 + .1)*.65)*5.;\n            }\n        }\n\n        vec3 color;\n        computeScene(view, t, patternOpacity, tPlane, bgColor, color, patternColor);\n\n\n    #ifdef DEBUG_PERFORMANCES_ENABLED\n        {\n            // color = mix(color, vec3(1.,0.,0.), STEP_OBSERVER > 20.);\n            const float targetItMax = 80.;\n            color = hsv2rgb(vec3(mix(.7, 0., clamp(STEP_OBSERVER/targetItMax, 0., 1.)), 1., 1.));\n        }\n    #endif\n\n    #ifdef SHOW_BOUNDING_BOXES_ENABLED\n        if(IS_RIGHT_HALF_SCREEN)\n        {\n            Result res = intersectBB(view);\n            color = hsv2rgb(vec3(float(res.bbId)/float(BRIDGE_DECO_CORONA_SDF_ID), 1., 1.));\n        }\n    #endif\n\n        float bloomLimit = VEC3_COMP_SUM(color);\n        colorAlpha += vec4(color, step(4., bloomLimit));\n        \n#ifdef AA_ENABLED\n    }\n    colorAlpha /= float(NB_AA_SAMPLE);\n#endif\n    \n    // poor motion blur\n    /*colorAlpha.rgb = mix(\n        colorAlpha.rgb,\n        min(texelFetch(iChannel0, ivec2(fragCoord.xy), 0).rgb, vec3(1.)),\n        min(.008/iTimeDelta, .99)\n    );*/\n    \n    fragColor = colorAlpha;\n}", "buffer_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// --------- Settings\n#define GLOW_LEVEL 1\n\n// --------- Constants\n#define T 6.2831853\n\n// --------- Macro and utilitary functions\n#define ROT(a) (mat2(cos(a), sin(a), -sin(a), cos(a)))\n#define GET_POS(v,t) (v.o + v.d*t)\n#define IS_BETWEEN(a,b,c) (b < a && a < c)\n#define SRGB_2_LIN(c) (pow(c,vec3(2.2)))\n#define LIN_2_SRGB(c) (pow(c,vec3(1./2.2)))\n#define MIX_LIN(a,b,t) (LIN_2_SRGB(mix(SRGB_2_LIN(a),SRGB_2_LIN(b),t)))\n#define RBOX(p,s,r) (length(max(abs(p)-(s),0.))-(r))\n#define SS_QUAD(x) (x*x/(2.*x*x-2.*x+1.))\n#define REP(x,d) (mod(x,d)-d*.5)\n#define REP2(x,d) (mod(x,d))\n#define REP_ID(x,d) (floor(x/d))\n#define REP_ID_CYCLIC(x,d,n) (floor(mod(x, d*n)/d))\n#define DIV_F(a,d) floor((a)/(d))*(d)\n#define VEC3_COMP_SUM(v) (v.x+v.y+v.z)\n#define INV_MIX(s,e,v) (((v)-(s))/((e)-(s)))\n#define RAY3D(q,div,th) (abs(REP(q,div))-th*.5)\n#define MIN3(v) (min((v).x,min((v).y,(v).z)))\n#define MIN2(v) (min((v).x,(v).y))\n#define GRID_SDF(p,div,th,d) (MIN3(max(vec3(abs(d)),RAY3D(p,div,0.)))-th)\n#define RAND_FROM(rdf,lm,mx) (step(lm,floor(rdf*mx)))\n#define COS_ANIM(x) (cos(x)*.5+.5)\n#define POW5(x) ((x)*(x)*(x)*(x)*(x))\n#define CIRCLE(p,r) (length(p)-r)\n#define MOON(p) (max(CIRCLE(p,.25),-CIRCLE(p-vec2(0.,0.09),.24)))\n#define BORDEAUX SRGB_2_LIN(vec3(0.447,0.125,0.267))\n#define RAND(v) (fract(sin(dot((v).xy,vec2(12.9898,78.233)))*43758.585))\n#define IS_RIGHT_HALF_SCREEN ((gl_FragCoord.x - iResolution.x*.5)/iResolution.x > 0.)\n\n// From: https://iquilezles.org/articles/functions/\n#define SM1(x) (x*x*x/(3.*x*x - 3.*x + 1.))\n#define TIMING(t,tS,tE) (clamp(INV_MIX(tS,tE,t), 0., 1.))\n#define ENL(t,s) ((t - .5)*s + .5)\nfloat ISM1(in float x)\n{\n  float a = pow(x, 1./3.);\n  return a/(a + pow(1. - x, 1./3.));\n}\nfloat almostIdentity(in float x, in float m, in float n)\n{\n    if(x > m) return x;\n    float a = 2.*n - m, b = 2.*m - 3.*n, t = x/m;\n    return (a*t + b)*t*t + n;\n}\n\nfloat box(in vec3 p, in vec3 s) { p = abs(p) - s; return max(p.x, max(p.y, p.z)); }\nfloat box(in vec2 p, in float s) { p = abs(p) - s; return max(p.x, p.y); }\nfloat elong(in float x, in float l) { x = abs(x) - l; return x*step(0., x); }\n\nmat3 axisRot(in vec3 ax, in float a)\n{\n    ax = normalize(ax);\n    float s = sin(a), c = cos(a);\n    float oc = 1. - c;\n    return mat3(\n        oc*ax.xxz*ax.xyx + vec3(c, vec2(-ax.z, ax.y)*s),\n        oc*ax.xyy*ax.yyz + vec3(ax.z*s, c, -ax.x*s),\n        oc*ax.zyz*ax.xzz + vec3(-ax.y*s, ax.x*s, c)\n    );\n}\n\nmat3 lookAt(in vec3 cameraPos, in vec3 target)\n{\n    vec3 dir = normalize(target - cameraPos);\n    vec3 right = normalize(cross(vec3(0., 1., 0.), dir));\n    vec3 up = normalize(cross(dir, right));\n    return mat3(-right, up, -dir);\n}\n\nvec2 randomVec2(in vec2 seed)\n{\n    return vec2(cos(RAND(seed)), sin(RAND(seed.yx*vec2(13.41564, -5.8545) + 2.215)));\n}\n\n// generic 2D noise, from: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec4 mod289(vec4 g){return g-floor(g*(1./289.))*289.;}vec4 permute(vec4 g){return mod289((g*34.+1.)*g);}vec4 taylorInvSqrt(vec4 g){return 1.79284-.853735*g;}vec2 fade(vec2 g){return g*g*g*(g*(g*6.-15.)+10.);}float cnoise(vec2 g){vec4 v=floor(g.rgrg)+vec4(0.,0.,1.,1.),d=fract(g.rgrg)-vec4(0.,0.,1.,1.);v=mod289(v);vec4 r=v.rbrb,a=v.ggaa,p=d.rbrb,e=d.ggaa,c=permute(permute(r)+a),f=fract(c*(1./41.))*2.-1.,t=abs(f)-.5,b=floor(f+.5);f=f-b;vec2 m=vec2(f.r,t.r),o=vec2(f.g,t.g),l=vec2(f.b,t.b),u=vec2(f.a,t.a);vec4 n=taylorInvSqrt(vec4(dot(m,m),dot(l,l),dot(o,o),dot(u,u)));m*=n.r;l*=n.g;o*=n.b;u*=n.a;float i=dot(m,vec2(p.r,e.r)),x=dot(o,vec2(p.g,e.g)),s=dot(l,vec2(p.b,e.b)),S=dot(u,vec2(p.a,e.a));vec2 I=fade(d.rg),y=mix(vec2(i,s),vec2(x,S),I.r);float q=mix(y.r,y.g,I.g);return 2.3*q;}\n\n// by iq from: https://iquilezles.org/articles/distfunctions/\nfloat opSmoothUnion(in float d1, in float d2, in float k)\n{\n    float h = clamp(.5 + .5*(d2-d1)/k, 0., 1.);\n    return mix(d2, d1, h) - k*h*(1. - h);\n}\n\n// From: https://www.shadertoy.com/view/lsS3Wc\nvec3 hsv2rgb(in vec3 c)\n{\n    const vec4 k = vec4(1., 2./3., 1./3., 3.);\n    return c.z*mix(k.xxx, clamp(abs(fract(c.xxx + k.xyz)*6. - k.www) - k.xxx, 0., 1.), c.y);\n}\nvec3 rgb2hsv(in vec3 c)\n{\n    const float eps = 0.0000001;\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0*d+eps)), d / (q.x+eps), q.x);\n}\n\n// Create a kind of \"recursive coordinates pixelation\"\nvoid randomPixelate(\n    in vec2 uv, in vec2 div, in float mult, in int nbIt, in float seed,\n    inout vec2 pid, inout vec2 p, inout vec2 uvOut, inout vec2 szOut\n)\n{\n    for(int i = 0; i < nbIt; i++)\n    {\n        pid = REP_ID(uv, div);\n        div /= floor(RAND(pid + seed)*mult + 1.);\n    }\n    \n    pid = REP_ID(uv, div);\n    uvOut = REP(uv, div);\n    szOut = div;\n    p = floor(uv/div)*div; // +.5\n}\n\n// From: https://www.shadertoy.com/view/wlSBzD\nvec3 SpectrumPoly(in float x)\n{\n    return (vec3(1.220023e0,-1.933277e0, 1.623776e0)+(vec3(-2.965000e1, 6.806567e1,-3.606269e1)+(vec3( 5.451365e2,-7.921759e2, 6.966892e2)+(vec3(-4.121053e3, 4.432167e3,-4.463157e3)+(vec3( 1.501655e4,-1.264621e4, 1.375260e4)+(vec3(-2.904744e4, 1.969591e4,-2.330431e4)+(vec3( 3.068214e4,-1.698411e4, 2.229810e4)+(vec3(-1.675434e4, 7.594470e3,-1.131826e4)+ vec3( 3.707437e3,-1.366175e3, 2.372779e3)*x)*x)*x)*x)*x)*x)*x)*x)*x;\n}\n\n\n// --------- Fx functions and var\n// https://www.rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/\nconst int BLUR_FILTER_SZ = 5;\nconst float GAUSSIAN_SUM = 4070.;\nconst float GAUSSIAN_KERNEL[BLUR_FILTER_SZ] = float[]\n(\n    924./GAUSSIAN_SUM,\n    792./GAUSSIAN_SUM,\n    495./GAUSSIAN_SUM,\n    220./GAUSSIAN_SUM,\n    66./GAUSSIAN_SUM\n);", "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 uv = ivec2(fragCoord.xy);\n    \n    vec3 colorGlow = vec3(0.);\n    for(int i = 0; i < BLUR_FILTER_SZ; i++)\n    {\n        vec4 c1 = texelFetch(iChannel0, ivec2(uv.x + i*GLOW_LEVEL, uv.y), 0);\n        vec4 c2 = texelFetch(iChannel0, ivec2(uv.x - i*GLOW_LEVEL, uv.y), 0);\n        colorGlow += c1.rgb*c1.a*GAUSSIAN_KERNEL[i];\n        colorGlow += c2.rgb*c2.a*GAUSSIAN_KERNEL[i];\n    }\n    \n    fragColor = vec4(colorGlow, 1.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtVBWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[465, 465, 520, 520, 1613]], "test": "untested"}
{"id": "msjGzz", "name": "Framerate counter", "author": "fishy", "description": "A simple framerate counter. Also why doesn't iFrameRate show up in the top \"Shader Inputs\" but it does when you click the ? button?", "tags": ["digits", "framerate"], "likes": 5, "viewed": 389, "published": 3, "date": "1667160217", "time_retrieved": "2024-07-30T16:23:49.587919", "image_code": "void join(inout float a, float b)\n{\n    a = min(a, b);\n}\n\nvoid subt(inout float a, float b)\n{\n    a = max(a, -b);\n}\n\nfloat box(vec2 p, vec2 s)\n{\n    return max((abs(p)-s).x,(abs(p)-s).y);\n}\n\nfloat digit(vec2 p, int d)\n{\n    #define join(a) join(r, a)\n    #define subt(a) subt(r, a)\n    float r = 100000000.0;\n    switch(d)\n    {\n        case(0):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p, vec2(0.05, 0.1)));\n            break;\n        case(1):\n            join(box(p, vec2(0.025, 0.15)));\n            break;\n        case(2):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p-vec2(0.15, -0.06), vec2(0.2, 0.035)));\n            subt(box(p-vec2(-0.15, 0.06), vec2(0.2, 0.035)));\n            break;\n        case(3):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p-vec2(-0.15, -0.06), vec2(0.2, 0.035)));\n            subt(box(p-vec2(-0.15, 0.06), vec2(0.2, 0.035)));\n            break;\n        case(4):\n            join(box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(box(p-vec2(0.0, 0.09), vec2(0.05, 0.085)));\n            break;\n        case(5):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p-vec2(0.15, 0.06), vec2(0.2, 0.035)));\n            subt(box(p-vec2(-0.15,-0.06), vec2(0.2, 0.035)));\n            break;\n        case(6):\n            p = -p;\n            join(box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            break;\n        case(7):\n            join(box(p-vec2(0.0), vec2(0.1, 0.15)));\n            subt(box(p-vec2(-0.05), vec2(0.1, 0.15)));\n            break;\n        case(8):\n            join(box(p-vec2(0.0), vec2(0.1, 0.15)));\n            subt(box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            subt(box(p-vec2(0.0, -0.05), vec2(0.05, 0.05)));\n            join(box(p-vec2(0.0), vec2(0.1, 0.025)));\n            break;\n        case(9):\n            join(box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            break;\n    }\n    return r;\n}\n\nfloat getDig(float num, float d)\n{\n    float a = floor(num/pow(10., d));\n    return a - floor(a/10.)*10.;\n}\n\nfloat print(vec2 p, float num, float spacing)\n{\n    float r = 10000.0;\n    int fig = int(ceil(log2(num) / 3.32192809489)); // log base 10 of x equals log base 2 of x divided by log base 2 of 10\n    for(int i = 0; i < fig; i++)\n    {\n        int di = int(getDig(num, float(i)));\n        join(digit(p+vec2(i, 0)*spacing, di));\n    }\n    return r;\n}\n\nvec3 printFR(vec2 p)\n{\n    return 1.-vec3(step(0., print((p-vec2(0.474, 0.25))*9., iFrameRate, 0.3)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 mouse = (iMouse.x == 0.0? vec2(0.0) : iMouse.xy/iResolution.xy-0.5)*vec2(1., iResolution.y/iResolution.x);\n    vec2 uv = (fragCoord/iResolution.xy-0.5)*vec2(1., iResolution.y/iResolution.x);\n\n    // Time varying pixel color\n    //int d = int(getDig(143., 0.0));\n    //vec3 col = vec3(step(0., digit(uv, d))-0.1*step(0., box(uv, vec2(0.1, 0.15))));\n    vec3 col = printFR(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msjGzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 56], [58, 58, 93, 93, 115], [117, 117, 144, 144, 189], [191, 191, 219, 219, 2239], [2241, 2241, 2275, 2275, 2348], [2350, 2350, 2397, 2397, 2696], [2698, 2698, 2720, 2720, 2802], [2804, 2804, 2861, 2911, 3354]], "test": "untested"}
{"id": "Ds23zR", "name": "Random Paths", "author": "mla", "description": "Apply a simple random path rewriting automaton to a closed path. Mouse resets (eg. after a window resize).\n\nPath is stored in Buffer A - the x and y components of pixel (i,j) indicate the presence or absence of an edge to (i+1,j), (i,j+1) respectively.", "tags": ["random", "paths"], "likes": 15, "viewed": 236, "published": 3, "date": "1667149764", "time_retrieved": "2024-07-30T16:23:50.347887", "image_code": "///////////////////////////////////////////////////////////////////////\n//\n// Random Paths, mla, 2022\n//\n// Apply a simple random path rewriting automaton to a closed path.\n// Mouse resets (eg. after a window resize).\n//\n// Next step is to apply some image-based weighting to the randomization.\n//\n// Path is stored in Buffer A - the x and y components of pixel \n// (i,j) indicate the presence or absence of an edge to (i+1,j), (i,j+1)\n// respectively.\n//\n// There are two types of rewrite, applied to a 2x2 grid:\n//\n// xxxx     x..x    xxxx     ...x\n// .... <-> x..x    x... <-> ...x\n// ....     x..x    x...     ...x\n// ....     xxxx    x...     xxxx\n//\n// Sadly, the algorithm doesn't guarantee that the path remains connected if\n// there is a cross pattern - the wrong side of the cross can get flipped\n// by the second rewrite:\n//\n// ..x..    ..xxx\n// ..x..    ....x\n// xxxxx -> xxx.x\n// ..x..    ..x..\n// ..x..    ..x..\n//\n// I'm not sure what can be done about this without considerably\n// complicating the algorithm.\n//\n///////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  vec2 p = 1.1*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n  p = 0.5*(p+1.0); // Move to [0,1] square\n  ivec2 vertex = clamp(ivec2(round(float(N)*p)),ivec2(0),ivec2(N));\n  float px = fwidth(p.x), d = 1e8;\n  // The 4 segments coming off this vertex - the buffer entries\n  // indicate the presence of rightwards and downwards segments.\n  bvec4 a = bvec4(texelFetch(iChannel0,vertex-ivec2(1,0),0).x,\n                  texelFetch(iChannel0,vertex-ivec2(0,1),0).y,\n                  texelFetch(iChannel0,vertex,0).xy);\n  // I don't usually like this sort of macro, but this one is handy.\n  #define S(p,q,r) (segment((p),vec2(q)/float(N),vec2((q)+(r))/float(N)))\n  if (vertex.x > 0 && a.x) d = min(d,S(p,vertex,-ivec2(1,0)));\n  if (vertex.y > 0 && a.y) d = min(d,S(p,vertex,-ivec2(0,1)));\n  if (vertex.x < N && a.z) d = min(d,S(p,vertex, ivec2(1,0)));\n  if (vertex.y < N && a.w) d = min(d,S(p,vertex, ivec2(0,1)));\n  vec3 col = vec3(1,1,0.8);\n  vec3 tex = texture(iChannel1,fragCoord/iResolution.y).xyz;\n  col *= 0.75+0.25*tex;\n  col *= vec3(smoothstep(0.0,px,d-0.1*length(tex)/float(N)));\n  col = pow(col,vec3(0.4545));\n  if (alert) col.x = 1.0;\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 result, vec2 fragCoord) {\n  ivec2 vertex = ivec2(fragCoord);\n  result = texelFetch(iChannel0,vertex,0);\n  if (any(lessThan(vertex,ivec2(0))) || any(greaterThan(vertex,ivec2(N)))) {\n    result = vec4(0);\n  } else if (iFrame == 0 || iMouse.z > 0.0 || result.w != 1234.0) {\n    result = vec4(vertex.y == 0 || vertex.y == N,\n                  vertex.x == 0 || vertex.x == N,\n                  0,1234);\n  } else {\n    // Consider a 2x2 grid of vertices, with segments possible between each\n    // horizontal and vertical pair of vertices.\n    int n = irand(iFrame+1,4);\n    ivec2 offset = ivec2(n/2,n%2);\n    if (all(greaterThanEqual(vertex,offset)) && all(lessThan(vertex,N+offset))) {\n      ivec2 base = (vertex-offset)/2*2+offset;\n      bvec4 a = bvec4(texelFetch(iChannel0,base,0).xy,\n                      texelFetch(iChannel0,base+ivec2(0,1),0).x,\n                      texelFetch(iChannel0,base+ivec2(1,0),0).y);\n      if (any(a) && !all(a) && a != bvec4(1,0,1,0) && a != bvec4(0,1,0,1)) {\n        if (vertex == base) result.xy = vec2(not(a.xy));\n        if (vertex == base+ivec2(0,1)) result.x = float(!a.z);\n        if (vertex == base+ivec2(1,0)) result.y = float(!a.w);\n      }\n    }\n  }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "int N = 100;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nint irand(int i, int range) {\n return int(ihash(uint(i))%uint(range));\n}\n\nfloat rand(int i, int j) {\n  uint h = ihash(uint(31*i+j));\n  return float(h)/pow(2.0,32.0);\n}\n\nfloat rand(int i) {\n  uint h = ihash(uint(i));\n  return float(h)/pow(2.0,32.0);\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds23zR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1101, 1101, 1154, 1154, 2326]], "test": "untested"}
{"id": "msj3RR", "name": "Truchet Nets", "author": "dr2", "description": "More extended hexagonal Truchet tilings (mouseable)", "tags": ["truchet", "path"], "likes": 22, "viewed": 240, "published": 3, "date": "1667148411", "time_retrieved": "2024-07-30T16:23:51.189636", "image_code": "// \"Truchet Nets\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec2 HexMidEdge (vec2 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv3 (vec3 p);\nfloat Noiseff (float p);\n\nvec3 cId, ltDir;\nvec2 cMid, gSize;\nfloat tCur, dstFar, cDir, cType, tWid, rc, ac, spd, dGlow;\nint idObj;\nbool isPano;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat Ddot (vec2 p)\n{\n  return dot (p, p);\n}\n\nfloat TruchDist (vec2 p)\n{ // (from \"Twisted Passages\")\n  vec2 pc, pc1, pc2;\n  float d, d1, d2;\n  if (cType == 1. || cType == 3.) {\n    if (cDir != 0.) p = 0.5 * vec2 (p.x - cDir * sqrt3 * p.y, cDir * sqrt3 * p.x + p.y);\n    pc1 = vec2 (sqrt3/2. * sign (p.x), 0.);\n    pc2 = vec2 (sqrt3 * sign (p.x), 0.);\n    d1 = sqrt (Ddot (p - pc1));\n    d2 = abs (sqrt (Ddot (p - pc2)) - 1.5);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = (d == d1) ? 0.: 1.5;\n  } else if (cType == 2. || cType == 4.) {\n    pc1 = - vec2 (0., cDir);\n    pc2 = vec2 (sqrt3/2. * sign (p.x), 0.5 * cDir);\n    d1 = Ddot (p - pc1);\n    d2 = Ddot (p - pc2);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = 0.5;\n    d = abs (sqrt (d) - rc);\n  }\n  pc = p - pc;\n  ac = - atan (pc.y, - pc.x) / (2. * pi) + 0.5;\n  if (cType == 2. && cId.x - cId.z < 0.) ac = - ac;\n  return d;\n}\n\nbool OnTrk (vec2 w)\n{\n  vec2 wp, wm;\n  float cxz;\n  bool czo, offTrk;\n  if (mod (cId.y, 4.) == 0.) {\n    cxz = cId.x - cId.z;\n    czo = (mod (cId.z, 2.) == 1.);\n    wm = Rot2Cs (w, sin (- pi / 3. + vec2 (0.5 * pi, 0.))) - vec2 (0., 0.3);\n    wp = Rot2Cs (w, sin (pi / 3. + vec2 (0.5 * pi, 0.)));\n    offTrk = (cxz == -2. && wm.y > 0. || ! czo && (abs (cxz) == 2. || cxz == -3. && w.y > -0.3 ||\n       cxz == -1. && wm.y > 0. || cxz == 1. && wm.y < 0.) || czo && (cxz == -3. ||\n       cxz == 0. && wp.x > 0. || cxz == 1. && wm.x < 0. || cxz == 2. && wm.y < 0.));\n  } else offTrk = true;\n  return ! offTrk;\n}\n\nvoid SetCConf ()\n{\n  float h, cxz;\n  cMid = HexToPix (cId.xz * gSize.x);\n  h = Hashfv3 (cId);\n  if (Hashfv3 (17.11 * cId) > 0.4 || cId.y != 0.) {\n    cDir = floor (3. * h) - 1.;\n    cType = 3.;\n  } else {\n    cDir = 2. * floor (2. * h) - 1.;\n    cType = 4.;\n  }\n  if (mod (cId.y, 4.) == 0.) {\n    cxz = cId.x - cId.z;\n    if (cxz == 0.) cType = 1.;\n    else if (abs (cxz) == 1.) cType = mod (cId.x, 2.) + 1.;\n    else if (abs (cxz) == 2. || cxz == -3.) cType = 2.;\n    if (cType <= 2.) cDir = 2. * mod (cId.x, 2.) - 1.;\n  }\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d, dt;\n  dMin = dstFar;\n  p = vec3 ((p.xz - cMid) / gSize.x, p.y / gSize.y - (cId.y + 0.5)).xzy;\n  dt = TruchDist (p.xz);\n  d = PrRoundBox2Df (vec2 (dt, p.y), vec2 (0.04, 0.006), 0.005);\n  DMIN (1);\n  d = SmoothMax (length (HexMidEdge (p.xz)) - 0.08,\n     - PrBox2Df (vec2 (dt, p.y - 0.14), vec2 (0.05, 0.15)), 0.01);\n  DMIN (2);\n  if (cType <= 2. && rc != 0. && OnTrk (p.xz)) {\n    d = PrCylDf (vec3 (dt, p.y - 0.12, fract (6. * (rc * ac - spd * tCur)) - 0.5).xzy,\n       0.25 * tWid, 0.12);\n    DMIN (3);\n    if (idObj == 3) dGlow = min (dGlow, dMin);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec4 vri, hv;\n  vec3 vf, p, cIdP;\n  vec2 edN[3], pM, s;\n  float dHit, d, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = vec4 (gSize.x / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2])),\n     1. / rd.y);\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / gSize.x;\n  pM = HexToPix (PixToHex (ro.xz / gSize.x));\n  cIdP = vec3 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    cId = vec3 (PixToHex (p.xz / gSize.x), floor (p.y / gSize.y)).xzy;\n    if (cId != cIdP) {\n      cIdP = cId;\n      SetCConf ();\n    }\n    hv = vec4 ((vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))),\n       gSize.y * (cId.y + step (0., rd.y))) * vri;\n    s = vec2 (Minv3 (hv.xyz), dHit + abs (hv.w - p.y * vri.w));\n    d = ObjDf (p);\n    if (dHit + d < min (s.x, s.y)) {\n      dHit += d;\n    } else if (s.x < s.y) {\n      dHit = s.x + eps;\n      pM += sqrt3 * ((s.x == hv.x) ? edN[0] : ((s.x == hv.y) ? edN[1] : edN[2]));\n    } else {\n      dHit = s.y + eps;\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn;\n  vec2 w;\n  float dstObj, nDotL, a, dt;\n  bgCol = vec3 (0.1, 0.05, 0.);\n  dGlow = dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      col4 = vec4 (0.9, 0.8, 0.2, 0.2);\n      w = (ro.xz - cMid) / gSize.x;\n      if (vn.y > 0. && cType <= 2. && rc != 0. && OnTrk (w)) {\n        a = 6. * (rc * ac - spd * tCur);\n        dt = TruchDist (w);\n        col4 *= 1. - 0.3 * max (step (dt, 0.25 * tWid) * step (0.4, fract (24. * a)),\n           step (length (vec2 (dt, fract (a) - 0.5)), 0.26 * tWid));\n      }\n    } else if (idObj == 2) {\n      col4 = vec4 (0.8, 0.6, 0.2, 0.2);\n    } else if (idObj == 3) {\n      col4 = vec4 (0.5, 0.5, 0.8, -1.);\n    }\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (idObj == 1) nDotL *= nDotL;\n    if (col4.a >= 0.) col = col4.rgb * (0.2 + 0.2 * max (- dot (rd, vn), 0.) + 0.8 * nDotL) +\n       col4.a * pow (max (dot (reflect (ltDir, vn), rd), 0.), 32.);\n    else col = col4.rgb * (0.5 + 0.5 * max (- dot (rd, vn), 0.));\n    if (! isPano) col = mix (col, bgCol, smoothstep (0.4, 1., dstObj / dstFar));\n  } else {\n    col = bgCol;\n  }\n  if (dstObj >= dstFar || idObj != 3) col = mix (col, vec3 (0.5, 0.5, 0.8),\n     0.9 * exp (- 32. * dGlow) * (1. - 0.5 * Noiseff (tCur)));\n  return clamp (col, 0., 1.);\n}\n\n#define N_WIN  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv, mMid[N_WIN], ut[N_WIN], mSize, msw;\n  float el, az, zmFac, asp, sr;\n  int vuId, regId;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./5.) * vec2 (asp, 1.);\n  mMid[0] = (1. - mSize.y) * vec2 (asp, 1.);\n  for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    for (int k = 0; k < N_WIN; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = k + 1;\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = k + 1;\n      break;\n    }\n  }\n  if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  isPano = (vuId > 0);\n  az = pi / 3.;\n  el = 0.;\n  if (mPtr.z > 0. && vuId == regId) {\n    az += 2. * pi * msw.x;\n    el += 0.5 * pi * msw.y;\n  } else if (! isPano) {\n    az -= 0.6 * pi * sin (0.03 * pi * tCur);\n    el -= 0.2 * pi * sin (0.05 * pi * tCur);\n  }\n  el = clamp (el, -0.3 * pi, 0.3 * pi);\n  vuMat = StdVuMat (el, az);\n  gSize = vec2 (2., 1.);\n  tWid = 0.12;\n  spd = 0.03;\n  ro = vec3 (0., 1.01, 0.5 * tCur);\n  ro.xz = Rot2D (ro.xz, - pi / 3.) + vec2 (0.9);\n  zmFac = isPano ? 0.4 : 2.;\n  uv /= zmFac;\n  dstFar = 60.;\n  ltDir = vuMat * normalize (vec3 (1., 0.8, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi));\n    rd = vuMat * normalize (isPano ? vec3 (2. * sin (uvv.x / asp + vec2 (0., 0.5 * pi)), uvv.y).xzy : \n       vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.3, 0.7, 0.3);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 HexMidEdge (vec2 p)\n{\n  vec2 p1, p2;\n  p = abs (p);\n  p1 = p + vec2 (- sqrt3/2., 0.);\n  p2 = p + vec2 (- sqrt3/4., -0.75);\n  return (length (p1) < length (p2)) ? p1 : p2;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msj3RR.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[904, 904, 925, 925, 948], [950, 950, 976, 1005, 1819], [1821, 1821, 1842, 1842, 2427], [2429, 2429, 2447, 2447, 2954], [2956, 2956, 2978, 2978, 3567], [3569, 3569, 3602, 3602, 5006], [5008, 5008, 5029, 5029, 5286], [5288, 5288, 5323, 5323, 6670], [6690, 6690, 6746, 6746, 9090], [9092, 9092, 9125, 9125, 9214], [9216, 9216, 9263, 9263, 9310], [9312, 9312, 9354, 9354, 9405], [9407, 9407, 9431, 9431, 9661], [9663, 9663, 9687, 9687, 9747], [9749, 9749, 9775, 9775, 9926], [9928, 9928, 9950, 9950, 9977], [9979, 9979, 10001, 10001, 10028], [10030, 10030, 10052, 10052, 10090], [10092, 10092, 10137, 10137, 10229], [10231, 10231, 10276, 10276, 10314], [10316, 10316, 10352, 10352, 10558], [10560, 10560, 10590, 10590, 10703], [10705, 10705, 10736, 10736, 10800], [10834, 10834, 10858, 10858, 10923], [10925, 10925, 10949, 10949, 11002], [11004, 11004, 11029, 11029, 11175]], "test": "untested"}
{"id": "ddS3RR", "name": "etherealm", "author": "kishimisu", "description": "Psychedelic infinite domain repetition\n\nHaving fun trying to make the code as small as possible", "tags": ["domain", "colorful", "repetition", "psychedelic", "rgb"], "likes": 20, "viewed": 583, "published": 3, "date": "1667126204", "time_retrieved": "2024-07-30T16:23:52.083248", "image_code": "#define S(a,b) mix(1., a, sin(b)*.5+.5)\n#define s (iTime*.34-1.)\n#define n iResolution\n\nvoid mainImage(out vec4 O, in vec2 F) {\n    vec3 a,r,t = normalize(vec3((2.*F.xy-n.xy)/n.y*S(2.,s+3.14), 1.)); \n    float i, d, l=1.;\n    while (i++ < 200. && d<150. && l>0.001) {\n        a = r+d*t; a.z+=s;\n        d += l = length(mod(a+2.,4.)-2.) - step(1.,abs(a.y))+.001;\n    }\n    O.rgb = mix(cos(S(2.3,s)*vec3(1.02,1.04,1.06)*d+s)*.5+.5, vec3(1.), d*.008);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddS3RR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 127, 127, 450]], "test": "untested"}
{"id": "cs23RR", "name": "Dynamic system plotter - golf2", "author": "FabriceNeyret2", "description": "deep golfing of Envy24's \"Dynamic system plotter\" https://shadertoy.com/view/fl3GW7", "tags": ["chaos", "dynamic", "plotter", "short", "system", "golf", "attractors", "3tweets"], "likes": 20, "viewed": 297, "published": 3, "date": "1667120836", "time_retrieved": "2024-07-30T16:23:52.928986", "image_code": "// custom-less golfing 540 chars https://shadertoy.com/view/csj3RR\n// custom-keep golfing 1084 chars https://shadertoy.com/view/DdjGRR\n// simplifying Envy24's \"Dynamic system plotter\" https://shadertoy.com/view/fl3GW7\n//    length 5476 - 2684 = 2792 chars ( only initForSystem0 )\n\nvoid mainImage( out vec4 O, vec2 U )  { O = T(U); }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n", "buffer_a_code": "\nvoid mainImage( out vec4 O, vec2 P )  // 428\n{\n    O = T(P) + .022;\n    P = ( P+P - R ) / R.y + vec2(.6, -.48);\n\n    float s = .011, i = 0.,\n          t = mix( .46, .472, .5+.5*sin(iTime*.07*O.x) ),      \n          d = 9., x=t, y=t, _x;\n\n    for ( ; i < 2e3; ++i )\n        _x =   x*x + y*t - t*x - x  ,     \n         y =  -y*y - y*t - t*x - y -x*y - t*t,  \n         x = _x,\n        d = min( d, length( P - vec2(x,y) ) );          \n\n    O *= smoothstep(-s, s, d - .0035 );\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs23RR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 281, 320, 320, 332]], "test": "untested"}
{"id": "msl3Dl", "name": "Pure Simple Circle", "author": "renkin4", "description": "Pure Circle\n", "tags": ["circle"], "likes": 0, "viewed": 170, "published": 3, "date": "1667108254", "time_retrieved": "2024-07-30T16:23:53.685962", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    const float speed = 2.;\n    uv *= 2.0;\n\n    vec4 col = vec4(0.0);\n    \n    vec2 position = -1. * vec2(mod(iTime* speed, 8.) - 4., 0.);\n    \n    float d = length(uv + position);\n    float inverseD = 1. - d;\n     \n    col += smoothstep(0., 0.03, inverseD); \n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msl3Dl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 409]], "test": "untested"}
{"id": "ddS3Rz", "name": "Tangled fractal vines (3D)", "author": "jarble", "description": "3D fractal structures generated using [url=https://en.wikipedia.org/wiki/Triangle_wave]triangle waves[/url].\nUse the mouse to look around.", "tags": ["3d", "fractal", "tree", "vine"], "likes": 9, "viewed": 299, "published": 3, "date": "1667096391", "time_retrieved": "2024-07-30T16:23:54.432965", "image_code": "#define t iTime*4.\n#define r iResolution\n#define iterations 250 //number of raymarching steps\n#define EPSILON .001\n#define MAX_DIST 40.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\n//Based on https://www.shadertoy.com/view/3tXyRN\n\nvec3 spaghetti(vec3 uv)\n{\n    vec3 col = vec3(0.);\n    for(int k = 0; k < 6; k++){ \n        vec3 offset =\n            //vec3(uv.z,uv.x-uv.y,uv.y)\n            vec3(uv.z,uv.x-.5,uv.y)\n            //abs(-.5+fract(vec3(uv.z,uv.x+.5,uv.y+.5)))\n            //vec3(uv.z-uv.x,uv.x-.4,uv.y+.3)\n            //vec3(uv.z-uv.x/2.,uv.x-.5-uv.y/2.,uv.y-.5-uv.z/2.)\n            //vec3(uv.z,uv.x-uv.y,uv.y)\n            //vec3(uv.z-uv.x,uv.x-.45,uv.y+.45)\n            //vec3(uv.z-uv.x/2.,uv.x-uv.y/2.,uv.y-uv.z/2.)\n            //vec3(uv.z-uv.x/2.,uv.x-.5,uv.y-uv.z/2.)\n        ;\n        uv =\n            abs(fract(uv.yzx+offset)-.5)\n        ;\n        col = vec3(col.yz,uv.x-uv.y);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 o, in vec2 U )\n{\n    o = vec4(0.0);\n    vec3 d=vec3(U/r.xy-.5,.5),p0=vec3(0,6,t),p=p0;\n    if (length(iMouse.xy) > 40.0) {\n        d.yz *= rot(-3.14*0.5+iMouse.y/iResolution.y*3.14);\n        d.xz *= rot(-3.14+iMouse.x/iResolution.x*3.14*2.0);\n    }\n    float l1;\n    vec3 col = vec3(0.);\n    for(int i=0;i<iterations;i++)\n    {\n        col = spaghetti(p/16.);\n        float sd1 = col.z-.1;\n        if(-sd1 < EPSILON*(length(l1)+1.0) || l1 > MAX_DIST){ break; }\n        p+=d*(-sd1);\n        l1 = distance(p,p0);\n    }\n    o+=(vec4(col/2.,0)+l1/100.0)*3.0;\n}", "image_inputs": [], "sound_code": "float fmod(float x, float y){\n    //x /= 1. + mod(floor(x/2.),2.);\n    return mod(floor(floor(x)+floor((x)/4.)/4.),y);\n}\n\n//#define fmod(x,y) mod(floor(x),y)\n#define fpow(x,y) pow(y,fmod(x,y))\n//#define fmod0(x,y) mod(floor(x)+floor((x)/2.)+floor((x)/4.),y)\n\nvec2 mainSound(int samp, float t){\n  //t += floor(t*4.)/4.;\n  //t += fmod(t*4.,4.)/4.;\n  float s1 =\n      4.,\n  m1 =\n      //fmod(t*s1,s1),\n      fmod((t+floor(t/2.+fpow(t,5.+fpow(t*8.,2.))+s1)+floor(t*2.)),s1),\n      //fmod(t*s1-floor(t),s1),\n  z1 =\n      (1.+fmod(m1+fpow(t,2.),2.))\n  ;\n  t /=\n      1.+fmod((t+floor(t*s1/2.+s1+fpow(t*2.,2.))),2.)\n  ;\n  float m3 =\n      fmod((t+floor(t/2.+s1+fpow(t*2.,2.))),s1)+m1\n  ;\n  t *=\n      1.+fmod(((t*s1+m3)+floor(t*s1/2.+s1)),2.)\n  ;\n\n  float a=\n      //log((.1+sqrt(fract(t*s1)/2.)))/8.\n      (1.-sqrt(fract(t*s1)/2.))/8.\n      //((1.-sqrt(fract(t*s1))))*.2\n  ,\n\n  nb = pow(2.,(m3+z1)/5.+7.);\n\n  return abs(.5-vec2(fract(t*nb*.998*2.)\n   ,fract(t*nb)))*a;\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddS3Rz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 279, 279, 945], [947, 947, 988, 988, 1528]], "test": "untested"}
{"id": "cds3Dl", "name": "Workplace Hazards", "author": "Tapped", "description": "A character ported from Rootkids latest intro at TRSAC 2022. We are modelling the \"ragdoll\" with a soft body integrator, and from what you can see from the result, it was perfect for the challenge, right?\n\nInteract with the character by using your mouse.\n", "tags": ["physics", "doll"], "likes": 4, "viewed": 256, "published": 3, "date": "1667088757", "time_retrieved": "2024-07-30T16:23:55.461215", "image_code": "/*\nFrom:\nhttps://github.com/mitsuhiko/webgl-meincraft\n\nCopyright (c) 2011 by Armin Ronacher.\n\nSome rights reserved.\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above\n      copyright notice, this list of conditions and the following\n      disclaimer in the documentation and/or other materials provided\n      with the distribution.\n    * The names of the contributors may not be used to endorse or\n      promote products derived from this software without specific\n      prior written permission.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#define FXAA_SPAN_MAX     8.0\n\nvec4 fxaa(sampler2D tex, vec2 uv) {\n    vec4 color;\n    vec2 inverseVP = 1. / vec2(textureSize(tex, 0));\n    vec4 offset = vec4(inverseVP.xy, -inverseVP.xy);\n    vec3 rgbNW = texture(tex, uv + offset.zw).xyz;\n    vec3 rgbNE = texture(tex, uv + offset.xw).xyz;\n    vec3 rgbSW = texture(tex, uv + offset.zy).xyz;\n    vec3 rgbSE = texture(tex, uv + offset.xy).xyz;\n    vec4 texColor = texture(tex, uv);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                    (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n            max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n            dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n        texture(tex, uv + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(tex, uv + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(tex, uv + dir * -0.5).xyz +\n        texture(tex, uv + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = fxaa(iChannel0, fragCoord / iResolution.xy);\n}\n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30023, "src": "https://soundcloud.com/redubb/workplace-hazards", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "// ##################################################################\n// MERCURY SNIPPET START\n// Snippet from http://mercury.sexy/hg_sdf\n// Brought to you by MERCURY\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n// ##################################################################\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\nfloat fOpUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\tp *= mod(c,vec2(2.))*2. - vec2(1.);\n\tp -= size/2.;\n\tif (p.x > p.y) p.xy = p.yx;\n\treturn floor(c/2.);\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n// ##################################################################\n// MERCURY SNIPPET END\n// ##################################################################\n\n// From IQ: https://iquilezles.org/articles/distfunctions/\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n\tvec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n\treturn length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nconst vec3 cam_pos = vec3(0,8,5);\n\nvec3 pose[] = vec3[](\n\tvec3(-.2, 0, -.2), /* leg */\n\tvec3(-.2, .4, 0), /* up leg */\n\tvec3(-.1, 1., .1), /* forearm */\n\tvec3(-.1, 1.2, 0), /* arm */\n\tvec3(.2, 0, -.2), /* leg */\n\tvec3(.2, .4, 0), /* up leg */\n\tvec3(.3, 1., .1), /* forearm */\n\tvec3(.3, 1.2, 0), /* arm */\n\tvec3(0, .9, 0), /* bottom spine */\n\tvec3(0, 1.5, 0), /* top spine */\n\tvec3(0, 1.6, .1) /* neck */\n);\n\nint pose_indices[] = int[](\n\t/* r-leg */\n\t0,\n\t1,\n\t8,\n\n\t/* l-leg */\n\t4,\n\t5,\n\t8,\n\n\t/* spine */\n\t8,\n\t9,\n\t10,\n\n\t/* r-arm */\n\t2,\n\t3,\n\t9,\n\n\t/* l-arm */\n\t6,\n\t7,\n\t9\n);\n\nvec3 char_vertices[11];\nvec4 char_bounding;\n\nstruct SDM {\n\tint   m; // material\n\tfloat d; // distance\n};\n\nvoid load_character(sampler2D char_verts) {\n\tvec3 min_v = vec3(1e5);\n\tvec3 max_v = vec3(-1e5);\n\tfor (int i = 0;i < 11;++i) {\n\t\tchar_vertices[i] = texelFetch(char_verts, ivec2(i, 0), 0).xyz;\n\n\t\tmin_v = mix(min_v, char_vertices[i], lessThan(char_vertices[i], min_v));\n\t\tmax_v = mix(max_v, char_vertices[i], greaterThan(char_vertices[i], max_v));\n\t}\n\n\tchar_bounding = vec4((min_v + max_v)*.5, distance(min_v, max_v)*.5);\n}\n\nmat3 basis_mat(vec3 fwd) {\n\tvec3 up = vec3(0,1,0);\n\tvec3 r = cross(fwd, up);\n\t/*if (length(r) < 1e-4) {\n        r = cross(fwd, vec3(0,.7,.7));\n\t}*/\n\tr = normalize(r);\n\tvec3 u = cross(r, fwd);\n\treturn mat3(\n\t\tvec3(r),\n\t\tvec3(u),\n\t\tvec3(-fwd)\n\t);\n}\n\nSDM sdm_min(SDM a, SDM b) {\n\t\tif (a.d < b.d) return a;\n\t\telse return b;\n}\n\nSDM sdm_paint(SDM base, SDM paint)\n{\n\tif (paint.d < base.d)\n\t\tbase.m = paint.m;\n\n\treturn base;\n}\n\nSDM character(vec3 p, bool with_bounding) {\n\tfloat b = length(p - char_bounding.xyz) - char_bounding.w - 1.8;\n\tif (with_bounding && b > 0.2) {\n\t\treturn SDM(0, b);\n\t}\n\n\tfloat min_d = 1e5;\n\tfor (int line = 0;line < 5;++line) {\n\t\tfor (int x = 0;x < 2;++x) {\n\t\t\tint idx0 = pose_indices[line*3 + x];\n\t\t\tint idx1 = pose_indices[line*3 + x + 1];\n\t\t\tfloat thickness = 0.05;\n\t\t\tif (line == 2)\n\t\t\t\tthickness = 0.1;\n\t\t\tmin_d = fOpUnionSoft(\n\t\t\t\tmin_d,\n\t\t\t\tfCapsule(p, char_vertices[idx0], char_vertices[idx1], thickness)\n\t\t\t, 0.05);\n\t\t}\n\t}\n\tvec3 up = normalize((char_vertices[10] - char_vertices[9]));\n\t\n\tmat3 basis = mat3(basis_mat(up));\n\tvec3 basis_tmp = basis[1];\n\tbasis[1] = -basis[2];\n\tbasis[2] = -basis_tmp;\n\t\n    vec3 p_head = p - up*.2 - char_vertices[10];\n\n\tpR(p_head.xy, 0.3);\n\tpR(p_head.yz, 0.6);\n\n\tconst float fs = 0.6;\n\tp_head = basis * p_head;\n\tmin_d = fOpUnionSoft(min_d, fSphere(p_head, fs*0.4), 0.05);\n\n\n\tvec3 p_mouth = p_head- fs*vec3(0,-0.2,0.35);\n\tpR(p_mouth.yz, 0.5);\n\tvec3 p_eye = p_head;\n\tfloat side = pMirror(p_eye.x, 0.);\n\n\t// SDM head_sdm = SDM(1, fSphere(p_head, .4));\n\tSDM min_sdm = SDM(1, min_d);\n\tfloat wrinkle = 1.2; //noise(vec2(applicationTime*8, 0.1*side));\n\tmin_sdm = sdm_min(min_sdm, SDM(3, fCapsule(p_eye, fs*vec3(0.1, 0.2 + 0.1*wrinkle, 0.3), fs*vec3(0.3,0.3-0.1*wrinkle,0.3), 0.03)));\n\t// min_sdm.d = fOpDifferenceChamfer(min_sdm.d, fSphere(p_eye-vec3(0.0,-0.2,0.3), 0.2), 0.05);\n\tmin_sdm = sdm_min(min_sdm, SDM(0, fSphere(p_eye - fs*vec3(0.15,0.12,0.32), fs*0.09)));\n\tmin_sdm = sdm_paint(min_sdm, SDM(3, fSphere(p_eye - fs*vec3(0.14,0.10,0.38), fs*0.04)));\n\n\tmin_sdm = sdm_paint(min_sdm, SDM(3, sdLink((p_mouth).yxz, fs*0.15, fs*0.01, fs*0.04)));\n\tmin_sdm = sdm_min(min_sdm, SDM(4, sdLink((p_mouth).yxz, fs*0.15, fs*0.06, fs*0.03)));\n\tvec3 p_teeth = p_mouth;\n\t// pModInterval1(p_teeth.x, 0.05, 0, 1);\n\tmin_sdm = sdm_min(min_sdm, SDM(0, fSphere(p_teeth-fs*vec3(0.02,0.03, 0.02), fs*0.02)));\n\tmin_sdm = sdm_min(min_sdm, SDM(0, fSphere(p_teeth-fs*vec3(0.06,0.03, 0.02), fs*0.02)));\n\n\treturn min_sdm;\n}\n\nSDM scene(vec3 p, bool include_character) {    \n    SDM result;\n    SDM room = SDM(0, -fBox(p-vec3(0,5,0), vec3(20,5,20)));\n    float box = fBox(p, vec3(5,.2,5));\n    float box2 = fBox(p - vec3(-5,2,-5), vec3(1,2,1));\n    SDM stuff = SDM(0, fOpUnionStairs(box,box2,5.,6.));\n\n    result = sdm_min(room, stuff);\n\n    result = sdm_paint(result, SDM(2, fBox(p-vec3(0,0,2), vec3(21,2,2))));\n\n    vec3 pole_p = p+vec3(5,0,5);\n    pModGrid2(pole_p.xz, vec2(6,12));\n\n    SDM pole = SDM(0, length(pole_p.xz) - 0.4);\n    pole = sdm_paint(pole, SDM(2, abs(pole_p.y-2.)-.5));\n    result = sdm_min(result, pole);\n    \n    if (include_character) {\n        return sdm_min(result, character(p, true));\n    }\n    return result;\n}\n\nvec3 calc_normal(vec3 p, bool include_character)\n{\n\tvec3 n = vec3(0.0);\n\tfor (int i = min(int(abs(p.x)), 0);i<4;i++)\n\t{\n\t\tvec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n\t\tn += e*scene(p+e*1e-3, include_character).d;\n\t}\n\treturn normalize(n);\n}", "buffer_a_code": "#define NUM_CONSTRAINT_ITERATIONS 40\n\nvoid dist_constraint(inout vec3 p1, inout vec3 p2, float dist_in_between) {\n    vec3 pp = p2 - p1;\n\n    vec3 n = normalize(pp);\n    float delta_dist = distance(p1, p2) - dist_in_between;\n\n    p1 += n * delta_dist * .5;\n    p2 -= n * delta_dist * .5;\n}\n\nvoid update_collision_constraint(inout vec3 p) {\n  SDM result = scene(p, false);\n  if (result.d < .2) {\n    vec3 normal = calc_normal(p, false);\n    p -= normal*(result.d - .2);\n  }\n}\n\nvoid tendons_hinges(vec3 a, vec3 b, vec3 c, out vec3 h0, out vec3 h1) {\n  vec3 hinge_normal = normalize(cross(normalize(a - b), normalize(c - b)));\n  h0 = b + hinge_normal;\n  h1 = b - hinge_normal;\n}\n\nvec3 positions[11];\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 fc = ivec2(fragCoord);\n    if (fc.y == 0 && fc.x < 11) {\n        float reset = texelFetch(iChannel0, ivec2(12, 0), 0).x;\n        if (reset < .5) {\n            vec3 pos = pose[fc.x] + vec3(0, 1.2, 0);\n            fragColor = vec4(pos, 0);\n        }\n        else {\n            vec3 min_v = vec3(1e5);\n            vec3 max_v = vec3(-1e5);\n            for (int i = 0;i < 11;++i) {\n                positions[i] = texelFetch(iChannel0, ivec2(i, 0), 0).xyz;\n                min_v = mix(min_v, positions[i], lessThan(positions[i], min_v));\n                max_v = mix(max_v, positions[i], greaterThan(positions[i], max_v));\n            }\n            vec3 center = (min_v + max_v)*.5;\n            \n            // Verlet integration\n            vec3 force = vec3(0, -6., 0);\n            \n            float mouse_duration = texelFetch(iChannel0, ivec2(1, 2), 0).z;\n            vec2 delta = iMouse.xy - texelFetch(iChannel0, ivec2(0, 2), 0).xy;\n            if (mouse_duration < .25 && fc.x == 10) {\n                vec3 to_character = normalize(center - cam_pos);\n                mat3 look_at = basis_mat(to_character);\n                force += look_at*vec3(delta.x*15., 0, 0) + vec3(0, delta.y*15., 0);\n            }\n            \n            float drag = 0.99;\n            float dt = iTimeDelta;\n            for (int i = 0;i < 11;++i) {\n                vec3 prev_pos = texelFetch(iChannel0, ivec2(i,1), 0).xyz;\n                positions[i] = positions[i] + (positions[i] - prev_pos)*pow(drag, dt / (1./60.)) + dt*dt*force;\n            }\n        \n            for (int i = 0;i < NUM_CONSTRAINT_ITERATIONS;++i) {\n                for (int line = 0;line < 5;++line) {\n                    vec3 expectedh0;\n                    vec3 expectedh1;\n                    tendons_hinges(pose[pose_indices[line*3]], pose[pose_indices[line*3 + 1]], pose[pose_indices[line*3 + 2]], expectedh0, expectedh1);\n\n                    vec3 h0;\n                    vec3 h1;\n\n                    vec3 a = positions[pose_indices[line*3]];\n                    vec3 b = positions[pose_indices[line*3 + 1]];\n                    vec3 c = positions[pose_indices[line*3+2]];\n                    tendons_hinges(\n                        a,\n                        b,\n                        c,\n                        h0,\n                        h1\n                    );\n\n\n                    dist_constraint(a, h0, distance(pose[pose_indices[line*3]], expectedh0));\n                    dist_constraint(a, h1, distance(pose[pose_indices[line*3]], expectedh1));\n                    positions[pose_indices[line*3]] = a;\n                \n                    for (int x = 0;x < 2;++x) {\n                        int pose_idx0 = pose_indices[line*3 + x];\n                        int pose_idx1 = pose_indices[line*3 + x + 1];\n                        vec3 a = pose[pose_idx0];\n                        vec3 b = pose[pose_idx1];\n                        float dist_in_between = distance(a, b);\n                        dist_constraint(positions[pose_idx0], positions[pose_idx1], dist_in_between);\n                    }\n                }\n                \n                for (int k = 0;k < 11;++k) {\n                    update_collision_constraint(positions[k]);\n                }\n            }\n            \n            fragColor = vec4(positions[fc.x], 0);\n        }\n    }\n    else if (fc.y == 1 && fc.x < 11) {\n        float reset = texelFetch(iChannel0, ivec2(12, 0), 0).x;\n        if (reset < .5) {\n            vec3 pos = pose[fc.x] + vec3(0, 1.2, 0);\n            fragColor = vec4(pos, 0);\n        }\n        else {\n            fragColor = texelFetch(iChannel0, ivec2(fc.x, 0), 0);\n        }\n    }\n    else if (fc.x == 12) {\n        fragColor = vec4(1,0,0,0);\n    }\n    else if (fc.y == 2 && fc.x == 0) {\n        fragColor = iMouse;\n    }\n    else if (fc.y == 2 && fc.x == 1) {\n        vec2 prev_mouse = texelFetch(iChannel0, ivec2(0, 2), 0).xy;\n        vec4 prev_data = texelFetch(iChannel0, ivec2(1, 2), 0);\n        if (prev_mouse == prev_data.xy) {\n            prev_data.z += iTimeDelta;\n        } else {\n            prev_data.z = 0.;\n        }\n        prev_data.xy = prev_mouse;\n\n        fragColor = prev_data;\n    }\n    else {\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define ZERO min(int(abs(iResolution.x)), 0)\n#define RAY_MARCH_ITER 120\n\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat fbm(in vec2 p){\n\tfloat f = 0.0;\n\tf += 0.5000*noise(p); p = p*2.02;\n\tf += 0.2500*noise(p); p = p*2.03;\n\tf += 0.1250*noise(p); p = p*2.01;\n\tf += 0.0625*noise(p);\n\treturn f/0.9375;\n}\n\nvec3 shade(vec2 uv, vec2 dUvX, vec2 dUvY, int material) {\n\tint sizeX = 3;\n\tint sizeY = 3;\n\tvec2 stepSize = 1. / vec2(sizeX, sizeY);\n\tvec3 bg;\n\tif (material == 0)\n\t{\n\t\tbg = vec3(0.9);\n\t}\n\telse if (material == 1)\n\t{\n\t\tbg = vec3(0.9, 0.4, 0.02);\n\t}\n\telse if (material == 2)\n\t{\n\t\tfloat t = uv.x + uv.y;\n\t\tfloat f = smoothstep(0.0,0.2,sin(t*4.));\n\t\tbg = mix(vec3(0.035), vec3(0.9, 0.4, 0.02), f);\n\t}\n\telse if (material == 3)\n\t{\n\t\tbg = vec3(0.03);\n\t}\n\telse if (material == 4)\n\t{\n\t\tbg = vec3(0.8, 0.1, 0.02);\n\t}\n    if (material == 0 || material == 2) {\n        vec3 accum = vec3(0);\n        float low_freq = fbm(uv*.7);\n        float very_high_freq = fbm(uv*50.);\n        float high_freq = fbm(vec2(very_high_freq, uv.x*uv.y));\n        for (int y = ZERO;y < sizeY;++y)\n        for (int x = ZERO;x < sizeX;++x) {\n            vec2 step_size = vec2(x,y)*stepSize;\n            vec2 cell = mod(uv + step_size.x*dUvX + step_size.y*dUvY + .25,vec2(.5))-.25;\n            float t = min(abs(cell.x) - .02, abs(cell.y) - .02);\n            float r = saturate(-t/.02);\n\n            accum += mix(bg, vec3(0), r*0.5);\n            accum += mix(bg, vec3(.1), smoothstep(0.38, 3.4, very_high_freq)*9.);\n            accum += mix(bg, vec3(1.,.13,.06)*.5, max(0., (high_freq * smoothstep(0.5, .8, low_freq))*4.));\n        }\n\n        bg = accum / float(sizeX*sizeY*3);\n    }\n        \n\n\treturn bg;\n}\n\nvec3 box_map(vec3 p, vec3 normal, SDM sdm) {\n    vec3 x = shade(p.yz, dFdx(p.yz), dFdy(p.yz), sdm.m);\n    vec3 y = shade(p.zx, dFdx(p.zx), dFdy(p.zx), sdm.m);\n    vec3 z = shade(p.xy, dFdx(p.xy), dFdy(p.xy), sdm.m);\n    vec3 m = pow(abs(normal), vec3(8.));\n    return (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\nfloat spot_light(vec3 p, vec3 spotPos, vec3 spotDir, vec2 spotCutOff) {\n\tvec3 fromLight = p-spotPos;\n\tfloat spotAtt = 0.;\n\tfloat spotOuterCutOff = cos(spotCutOff.x);\n\tfloat spotInnerCutOff = cos(spotCutOff.y);\n\tfloat a = dot(spotDir, normalize(fromLight));\n\tif (a < spotOuterCutOff) {\n\t\tspotAtt = 0.;\n\t} else {\n\t\tfloat spotValue = smoothstep(spotOuterCutOff, spotInnerCutOff, a);\n\t\tspotAtt = pow(spotValue, 2.);\n\t}\n\treturn spotAtt;\n}\n\n// Shadow from iq: https://iquilezles.org/articles/rmshadows\nfloat shadow(vec3 rp, vec3 rd, float min_t, float max_t, float k) {\n    float res = 1.0;\n    float ph = 1e20;\n    float t = min_t;\n    for(int i = 0;i < 64;++i)\n    {\n        float d = character(rp + rd*t, false).d;\n        if (d<1e-3)\n            return 0.;\n        float y = d*d/(2.0*ph);\n        float x = sqrt(d*d-y*y);\n        res = min(res, k*x / max(0.0, t-y));\n        ph = d;\n        t += d;\n        if (t >= max_t) {\n            return res;\n        }\n    }\n\n    return res;\n}\n\nfloat plane_density(vec3 rp, vec3 rd, vec4 plane, float density_height, float depth) {\n    float rp_d = dot(rp, plane.xyz);\n    float rd_d = dot(rd, plane.xyz);\n    \n    float t0 = ((plane.w + density_height) - rp_d) / rd_d;\n    float t1 = (plane.w - rp_d) / rd_d;\n    \n    if (t1 < .0 || t0 > depth) return 0.;\n    t0 = max(t0, 0.);\n    t1 = min(t1, depth);\n    \n    // Analytical density: 1 - (y/density_height)^2\n    \n    float i0 = t0*(3.*rp_d*rp_d + 3.*rp_d*rd_d*t0 - 6.*plane.w*rp_d + rd_d*rd_d*t0*t0 - 3.*plane.w*rd_d*t0 - 3.*density_height*density_height + 3.*plane.w*plane.w);\n    float i1 = t1*(3.*rp_d*rp_d + 3.*rp_d*rd_d*t1 - 6.*plane.w*rp_d + rd_d*rd_d*t1*t1 - 3.*plane.w*rd_d*t1 - 3.*density_height*density_height + 3.*plane.w*plane.w);\n    \n    return (i0-i1)*1./(3.*density_height*density_height);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    load_character(iChannel0);\n    vec2 uv = 2.*(fragCoord - iResolution.xy*.5)/iResolution.yy;\n    \n    if (abs(uv.y) > .7) {\n        fragColor = vec4(0);\n        return;\n    }\n\n    vec3 rp = cam_pos;\n    vec3 fwd = normalize(char_bounding.xyz - rp);\n    mat3 look_at = basis_mat(fwd);\n    vec3 rd = look_at*normalize(vec3(uv, -2.2));\n    rp += fwd*(distance(rp, char_bounding.xyz) - 5.);\n\n    vec3 color = vec3(0);\n    float t = 0.;\n    for (int i = ZERO;i < RAY_MARCH_ITER;++i) {\n        vec3 p = rp + rd * t;\n        SDM sdm = scene(p, true);\n        if (sdm.d < 1e-3 || i + 1 == RAY_MARCH_ITER) {\n            vec3 normal = calc_normal(p, true);\n            vec3 albedo = box_map(p, normal, sdm);\n            vec3 lp = vec3(0, 10, 0);\n            vec3 L = normalize(lp - p);\n            float attenuation = spot_light(p, lp, normalize(char_bounding.xyz - lp), vec2(.15, .05));\n            vec3 radiance = .2*vec3(.63,.98,.95) * attenuation * shadow(p, L, .005, 15., 30.);\n        \n            color = albedo * (.008 + max(dot(normal, L), 0.) * radiance*mix(.88, 1., smoothstep(.0, .3, noise(vec2(iTime, 0)*10.))));\n            break;\n        }\n\n        t += sdm.d;\n    }\n    \n    float mist = pow(saturate(plane_density(rp, rd, vec4(0, 1, 0, 0), .4, t)), 2.);\n    color = mix(color, vec3(0), mist);\n    \n    color = color / (color + 0.155) * 1.019;\n    fragColor = vec4(color, 1.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cds3Dl.jpg", "access": "api", "license": "bsd-new", "functions": [[1655, 1655, 1690, 1690, 3399], [3401, 3401, 3458, 3458, 3521]], "test": "untested"}
{"id": "msBGzR", "name": "Triangle wave spaghetti", "author": "jarble", "description": "A 3D fractal structure using [url=https://en.wikipedia.org/wiki/Triangle_wave]triangle waves[/url].\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal", "spaghetti"], "likes": 8, "viewed": 363, "published": 3, "date": "1667085453", "time_retrieved": "2024-07-30T16:23:56.267061", "image_code": "#define t iTime*4.\n#define r iResolution\n#define iterations 500 //number of raymarching steps\n#define EPSILON .001\n#define MAX_DIST 40.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\n//Based on https://www.shadertoy.com/view/3tXyRN\n\nvec3 spaghetti(vec3 uv)\n{\n    vec3 col = vec3(0.);\n    for(int k = 0; k < 6; k++){ \n        vec3 offset =\n            vec3(uv.x-.5*uv.y,uv.y,uv.z)\n            //fract(vec3(uv.x-uv.y/2.,uv.y-uv.x/2.,uv.z-uv.x/2.))\n        ;\n        //offset -= abs(uv.z)/4.;\n        uv =\n            abs(fract(uv.yzx+offset.yzx)-.5)\n        ;\n        col = vec3(col.yz,uv.x-uv.y);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 o, in vec2 U )\n{\n    o = vec4(0.0);\n    vec3 d=vec3(U/r.xy-.5,.5),p0=vec3(0,6,t),p=p0;\n    if (length(iMouse.xy) > 40.0) {\n        d.yz *= rot(-3.14*0.5+iMouse.y/iResolution.y*3.14);\n        d.xz *= rot(-3.14+iMouse.x/iResolution.x*3.14*2.0);\n    }\n    float l1;\n    vec3 col = vec3(0.);\n    for(int i=0;i<iterations;i++)\n    {\n        col = spaghetti(p/64.);\n        float sd1 = col.z-.35;\n        if(-sd1 < EPSILON*(length(l1)+1.0) || l1 > MAX_DIST){ break; }\n        p+=d*(-sd1);\n        l1 = distance(p,p0);\n    }\n    o+=(vec4(col/2.,0)+l1/100.0)*3.0;\n}", "image_inputs": [], "sound_code": "#define fmod(x,y) mod(floor(x),y)\n//#define fmod(x,y) mod(floor(floor(x)+floor((x)/8.)/8.),y)\n\n#define fpow(x,y) pow(y,fmod(x,y))\n\nvec2 mainSound(int samp, float t){\n  t /= 1.5;\n  //t += floor(t*4.)/4.;\n  float s1 =\n      8.,\n  m1 =\n      fmod(floor(t/s1)+t,s1)+fmod(t*s1,s1),\n  z1 =\n      (1.+fmod(t/s1,2.)+fmod(t*s1,2.))\n  ;\n  t /=\n      1.+fmod(floor(t*s1/z1)+floor(t/s1/z1),2.)\n\n  ;\n  float m3 =\n      fmod((t*8.+fpow(t*s1,3.))/(m1+.5),s1)\n  ;\n  t *=\n      1.+fmod(floor(t*s1/z1)+floor(t/s1/z1),2.)\n      //1.+fmod(floor((t*s1+fpow(t*s1,3.))/z1)+floor(t/s1/z1),2.)\n  ;\n      \n  float a = 64.*sqrt((1.-sqrt(fract(t*s1))))*.2,\n\n  nb = pow(2.,(m3+z1)/5.+7.5);\n\n  return abs(.5-vec2(fract(t*nb*.998/2.)\n   ,fract(t*nb)))*a;\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msBGzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 279, 279, 645], [647, 647, 688, 688, 1229]], "test": "untested"}
{"id": "DsBGRz", "name": "Julia Set Explorer w/ Mandelbrot", "author": "kishimisu", "description": "Use the mouse (clic+drag) to move the julia fractal origin relative to the mandelbrot fractal.", "tags": ["fractal", "mouse", "interactive", "iteration", "explorer"], "likes": 17, "viewed": 681, "published": 3, "date": "1667068081", "time_retrieved": "2024-07-30T16:23:57.405019", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float mouseActive = iMouse.x + iMouse.y;\n    if (mouseActive == 0.) mouse = vec2(cos(iTime*.15-1.4), sin(iTime*.15-1.4))*.98; // default mouse animation\n    \n    vec3 colm, colj;                 // mandelbrot & julia colors\n\n    vec2 zm = vec2(0.);              // mandelbrot starting point\n    vec2 zj = p;                     // julia starting point\n    \n    vec2 cm = p - vec2(.55, .0);     // mandelbrot iteration point\n    vec2 cj = mouse - vec2(.55, .0); // julia iteration point\n    \n    for (float iter = 0.; iter < 200.; iter++) {\n        zm = vec2(zm.x*zm.x - zm.y*zm.y, 2.*zm.x*zm.y) + cm; // mandelbrot iteration\n        zj = vec2(zj.x*zj.x - zj.y*zj.y, 2.*zj.x*zj.y) + cj; // julia iteration\n        \n        if (dot(zm,zm) > 40.) { // stop mandelbrot\n            colm = vec3(iter/80.);\n            zm = vec2(0.); cm = vec2(0.);\n        }\n        \n        if (dot(zj,zj) > 40.) { // stop julia\n            float smooth_iter = iter + 2. - log(log(dot(zj,zj)))/log(2.);\n            colj = clamp(cos(vec3(1.1,1.2,1.3) * pow(smooth_iter*2., .5)), 0., 1.);\n            zj = vec2(0.); cj = vec2(0.);\n        }\n        \n        if(dot(cm, cm) == 0. && dot(cj, cj) == 0.) break; // break if both mandelbrot & julia stopped\n    }\n        \n    if (mouseActive == 0. || iMouse.z > 0.) {\n        colj = mix(colm, colj, clamp(length(colj), 0., 1.)); // mix between mandelbrot and julia\n        colj = mix(colj, vec3(1.,0.,.0), smoothstep(.03, .02, length(mouse - p))); // add dot\n    }\n    \n    fragColor = vec4(colj, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsBGRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1715]], "test": "untested"}
{"id": "cdSGRz", "name": "cafce25's Simple gradient", "author": "cafce25", "description": "A simple gradient rotating around the mouse.", "tags": ["gradient"], "likes": 0, "viewed": 169, "published": 3, "date": "1667063834", "time_retrieved": "2024-07-30T16:23:58.209866", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5)/(.5*iResolution.y);\n    vec2 mouseUV = (iMouse.xy-iResolution.xy*.5)/(.5*iResolution.y);\n    uv -= mouseUV; // rotate around mouseUV\n    float t = iTime;\n    mat2 rot = mat2(cos(t), -sin(t), sin(t), cos(t));\n    uv *= rot;\n    float f = 2.5; // length of the gradient in screen heights\n    // move & scale so origin is at .5 and +- y go from 0 to 1\n    uv += f * vec2(0., 1.);\n    uv /= f * 2.;\n\n    vec3 col1 = vec3(1., 0., 0.);\n    vec3 col2 = vec3(0., 1., 0.);\n    vec3 col = mix(col1, col2, uv.y);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSGRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 711]], "test": "untested"}
{"id": "Ddl3Ds", "name": "Fractal mosaic 34 (music)", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 7, "viewed": 310, "published": 3, "date": "1667020434", "time_retrieved": "2024-07-30T16:24:01.362437", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    vec3 col = vec3(0.);\n        \n    vec2 uv = (fragCoord)/iResolution.y/4.0;\n    \n    uv += vec2(iTime/2.0,iTime/3.0)/16.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/4.;\n    vec2 uv1 = uv;\n    for(int k = 0; k < 6; k++){ \n        vec2 offset =\n            vec2(uv.x*2.+.5,uv.y*2.)\n        ;\n        //offset += floor(uv.x-uv.y)/8.;\n        uv =\n            abs(fract(uv.yx-offset)-.5)\n            //abs(fract(uv.yx/1.5-offset)-.5)\n            //abs(fract(uv.yx+offset)*fract(uv.yx-offset)-.5)\n        ;\n        if(uv.y > uv.x) col = vec3(col.yz,abs(uv.x-uv.y));\n    }\n    \n    fragColor = vec4(min(col*2.,vec3(1.)),1.0);\n}\n", "image_inputs": [], "sound_code": "float fmod2(float a, float b){\n    return mod(floor(a),b)*b;\n}\n\nfloat fmod1(float a, float b){\n    //a += floor(a/pow(2.,fmod2(a/2.,2.)));\n    //a += fmod2(a,4.);\n    //a += pow(b,mod(floor(a/b),2.));\n    //divide by prime numbers to get interesting rhythms\n    \n    /*\n    for(float i = 1.; i < mod(floor(a),8.); i++){\n        a += mod(floor(a/2.),b)*i;\n        a *= 1.+mod(floor(a)*2.,2.);\n        i /= 1.+mod(floor(a)*2.,2.);\n    }\n    */\n    \n    \n    float a1 = floor(a);\n    //a /= 1. + mod(floor(a1/4.),2.);\n    //a /= 1. + mod(floor(a1/8.),2.);\n    return\n        mod(floor(a),b)\n        //mod(floor(a)*floor(a/b),b)\n        //max(mod(floor(a+floor(a/8./8.))*floor(a),b),mod(floor(a),b))\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n    ;\n}\n\nfloat fmod(float a, float b){\n    return\n        fmod1(a,b)\n        //floor(fmod1(a,b*2.)*fmod1(a*2.,b*2.)/b/2./2.)\n    ;\n}\n\n\n//#define fmod(a, b) mod(mod(floor((a)),floor(1.+(a)/5.)),b)\n//#define fmod(x,y) mod(floor((x)/(1.+mod(floor((x)/8.),2.))),y)\n//#define fmod(x,y) mod(floor(floor(x)+floor((x)/8.)/8.),y)\n\n#define fmod1(x,y) mod(floor((x)+mod(floor((x)/y),y)),y)\n#define fmod2(x,y) mod(floor(x-floor((x)/y)),y)\n#define fmod3(x,y) mod(floor(x)+mod(floor(x*2.),y)*2.,y)\n#define fmod4(x,y) mod(floor(x+mod(floor((x)/y)/y,y)),y)\n#define fmod5(t,d) mod((1.+floor(t+d))*(floor(t*2.+d/2.)),d)\n#define fmax(x,y,z) max(fmod(x,z),fmod(y,z))\n#define fmax1(x,y) max(mod(floor((x)/2.),y),mod(floor(x),y))\n#define floor1(x) floor(x)*pow(floor(mod((x)/4.,3.)),2.)\n\n\n\nvec2 mainSound(int samp, float t){\n  float tempo = 1.;\n  t /= tempo;\n  //t = t*(1. + fmod(t*8./2.,2.))/2.;\n  \n  float s1 =\n      8.,\n  t1 = floor(t*s1+floor(t/s1))/s1;\n  t = t + t1;\n  \n  t /=\n      (1.+fmod(t/2.,2.))\n      //(1.+fmod(t/2.+t1*s1,2.))\n      //(1.+fmod(t*pow(2.,fmod(t/4.,3.)),2.))\n      //(1.+fmod(t/2.+floor(t/s1),2.))\n      //(1.+fmod(floor(floor(t*s1+floor(t/s1))/s1/2.),2.))\n  ;\n  float m3 =\n      fmod(t,s1)\n      //fmod(t+floor(t*8.)/8.,s1)\n  ;\n  t *=\n      (1.+fmod(t*s1,2.))\n      //(1.+fmod(floor(t*s1)*floor(t/s1),2.))\n      //(1.+fmod(floor(t*s1)+floor(t/s1),2.))\n  ;\n      \n  float a=\n      32.*sqrt(fract(-t)/2.)\n      //pow(2.-log(fract(t)/2.),2.)\n      //sqrt(fract(-t)*fract(-t*2.)/2.)*.2\n      //log(1.+fract(-t))*.2\n      //sqrt((1.-sqrt(fract(t))))*.2\n  ,\n\n  nb = t*tempo*pow(2.,(m3)/5.+7.);\n\n  return\n      abs(.5-vec2(fract(nb*.998),fract(nb)))*a\n      \n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n      \n      //vec2(fract(t*nb*.998*m1),fract(t*nb*m1))*a\n  ;\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ddl3Ds.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 736]], "test": "untested"}
{"id": "DslGDs", "name": "Fractal mosaic 33 (music)", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 4, "viewed": 288, "published": 3, "date": "1667013302", "time_retrieved": "2024-07-30T16:24:02.755713", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    vec3 col = vec3(0.);\n        \n    vec2 uv = (fragCoord)/iResolution.y/4.0;\n    \n    uv += vec2(iTime/2.0,iTime/3.0)/16.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/4.;\n    vec2 uv1 = uv;\n    for(int k = 0; k < 6; k++){ \n        vec2 offset =\n            vec2(sign(uv.y-uv.x)*uv.x,uv.y)*2.\n            //vec2(sign(uv.y-uv.x)*sign(uv1.x-uv1.y)*mod(uv.x*2.,2.),mod(uv.y,2.)*2.)\n        ;\n        //offset += floor(uv.x-uv.y)/8.;\n\n        uv1 = uv;\n        uv = abs(fract(uv.yx-offset)-.5);\n        if(uv.y > uv.x) col = vec3(col.yz,abs(uv.x-uv.y));\n        //else uv *= uv;\n    }\n    \n    fragColor = vec4(min(col*2.,vec3(1.)),1.0);\n}\n", "image_inputs": [], "sound_code": "#define fmod(x,y) mod(floor(x),y)\n//#define fmod(x,y) mod(floor((x)/(1.+mod(floor((x)/8.),2.))),y)\n#define fpow(x,y) pow(y,mod(floor(x),y))\nvec2 mainSound(int samp, float t){\n\n  //t += fpow(t*2.,2.);\n  //t = t*(1. + fmod(t*8./2.,2.))/2.;\n\n  float s1 =\n      8.,\n  m1 =\n      fmod(floor(t),s1);\n  //t = t + floor(t*s1+floor(t/s1))/s1;\n  t /=\n      (1.+fmod(floor(t*2.),2.))\n      //(1.+fmod(floor(t/(1.+m1)),2.))\n  ;\n  float m3 =\n      fmod((t*s1)/(m1+.5),s1);\n  t *=\n      (1.+fmod(floor(t*s1),2.))\n      //(1.+fmod(floor(t*s1)+floor(t/s1),2.))\n  ;\n      \n  float a=\n      sqrt((1.-sqrt(fract(t/s1))))*.2\n  ,\n\n  nb = pow(2.,(m3)/5.+7.);\n\n  return vec2(fract(t*nb*.998)*a\n   ,fract(t*nb)*a);\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DslGDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 747]], "test": "untested"}
{"id": "fsXcRl", "name": "Rocket Simulation I", "author": "oneshade", "description": "Attempting a better rigid body physics simulation.\nq - fire upper left thruster\na - fire lower left thruster\ns - fire main (bottom) thruster\nd - fire lower right thruster\ne - fire upper right thruster\nspace - increase main thrust", "tags": ["2d", "physics", "flying", "rockets"], "likes": 15, "viewed": 303, "published": 3, "date": "1667004838", "time_retrieved": "2024-07-30T16:24:04.296592", "image_code": "#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    vec4 stateBlock1 = load(iChannel0, ivec2(0, 1));\n    vec4 stateBlock2 = load(iChannel0, ivec2(1, 1));\n\n    vec2 pos = stateBlock1.xy, vel = stateBlock1.zw;\n    float angle = stateBlock2.x, angVel = stateBlock2.y;\n\n    uv += pos;\n\n    // Draw grid\n    drawSDF(abs(mod(uv.x, 0.25) - 0.125), vec3(1.0));\n    drawSDF(abs(mod(uv.y, 0.25) - 0.125), vec3(1.0));\n\n    // Draw ground\n    drawSDF(uv.y - GROUND, vec3(0.8, 0.5, 0.0));\n\n    // Thruster animation\n    vec2 rocketUv = Rotate2D(-angle) * (uv - pos);\n\n    float flameSize = 0.04;\n    float ratio = 0.4; // Changes the size of the inner flame\n\n    // Draw upper right thruster flame\n    if (texelFetch(iChannel1, ivec2(69, 0), 0).x > 0.5) {\n        vec2 thrusterUv = axisAlign(rocketUv - thrusters[0].xy, thrusters[0].zw);\n        drawSDF(sdIsosceles2(thrusterUv, vec2(0.02, flameSize)), vec3(1.0, 0.3, 0.0));\n        drawSDF(sdIsosceles2(thrusterUv, ratio * vec2(0.02, flameSize)), vec3(1.0, 1.0, 0.0));\n    }\n\n    // Draw lower right thruster flame\n    if (texelFetch(iChannel1, ivec2(68, 0), 0).x > 0.5) {\n        vec2 thrusterUv = axisAlign(rocketUv - thrusters[1].xy, thrusters[1].zw);\n        drawSDF(sdIsosceles2(thrusterUv, vec2(0.02, flameSize)), vec3(1.0, 0.3, 0.0));\n        drawSDF(sdIsosceles2(thrusterUv, ratio * vec2(0.02, flameSize)), vec3(1.0, 1.0, 0.0));\n    }\n\n    // Draw main thruster flame\n    if (texelFetch(iChannel1, ivec2(83, 0), 0).x > 0.5) {\n        float mainFlameSize = flameSize * 1.5;\n        if (texelFetch(iChannel1, ivec2(32, 0), 0).x > 0.5) {\n            mainFlameSize *= 1.5;\n        }\n\n        vec2 thrusterUv = axisAlign(rocketUv - thrusters[2].xy, thrusters[2].zw);\n        drawSDF(sdIsosceles2(thrusterUv, vec2(0.02, mainFlameSize)), vec3(1.0, 0.3, 0.0));\n        drawSDF(sdIsosceles2(thrusterUv, ratio * vec2(0.02, mainFlameSize)), vec3(1.0, 1.0, 0.0));\n    }\n\n    // Draw lower left thruster flame\n    if (texelFetch(iChannel1, ivec2(65, 0), 0).x > 0.5) {\n        vec2 thrusterUv = axisAlign(rocketUv - thrusters[3].xy, thrusters[3].zw);\n        drawSDF(sdIsosceles2(thrusterUv, vec2(0.02, flameSize)), vec3(1.0, 0.3, 0.0));\n        drawSDF(sdIsosceles2(thrusterUv, ratio * vec2(0.02, flameSize)), vec3(1.0, 1.0, 0.0));\n    }\n\n    // Draw upper left thruster flame\n    if (texelFetch(iChannel1, ivec2(81, 0), 0).x > 0.5) {\n        vec2 thrusterUv = axisAlign(rocketUv - thrusters[4].xy, thrusters[4].zw);\n        drawSDF(sdIsosceles2(thrusterUv, vec2(0.02, flameSize)), vec3(1.0, 0.3, 0.0));\n        drawSDF(sdIsosceles2(thrusterUv, ratio * vec2(0.02, flameSize)), vec3(1.0, 1.0, 0.0));\n    }\n\n    // Draw rocket\n    rocketUv = vec2(abs(rocketUv.x), rocketUv.y - 0.0243594417401);\n    drawSDF(sdIsosceles(rocketUv + vec2(0.0, 0.09), vec2(0.03, 0.08)), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdIsosceles(Rotate2D(-0.7) * (rocketUv - vec2(0.08, -0.06)), vec2(0.03, 0.08)), vec3(0.0, 1.0, 0.0));\n    drawSDF(sdIsosceles(Rotate2D(-1.8) * (rocketUv - vec2(0.07, 0.03)), vec2(0.03, 0.08)), vec3(0.0, 0.0, 1.0));\n    drawSDF(sdIsosceles(rocketUv, vec2(0.08, 0.2)), vec3(1.0));\n\n    // Draw velocity vector\n    vec2 vectorBase = normalize(vel) * 0.2;\n    drawSDF(sdVectorArrow(uv - pos - vectorBase, 0.005 * vel), vec3(1.0));\n\n    /**\n    // Draw center\n    drawSDF(length(uv - pos) - 0.01, vec3(1.0, 0.7, 0.0));\n\n    // Draw contact points\n    mat2 basis = Rotate2D(angle);\n    vec2[convexHull.length()] curConvHull;\n    for (int i=0; i < convexHull.length(); i++) {\n        curConvHull[i] = basis * convexHull[i] + pos;\n        drawSDF(length(uv - curConvHull[i]) - 0.01, vec3(1.0, 0.7, 0.0));\n    }\n    /**/\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Constants\n#define PI 3.1415926536\n\n#define GRAVITY 9.8\n#define GROUND -0.12\n\n#define MAIN_THRUST 60.0\n#define MAX_THRUST 100.0 // For main thruster\n#define CORRECTION_THRUST 0.2\n\n#define MASS 5.0\n#define MOI 0.000144426534534\n#define FRICTION 0.5\n\n#define dt 0.01 //0.001\n\nconst vec2[] convexHull = vec2[](\n    vec2( 0.0000000000,  0.1576927751),\n    vec2(-0.0891532073,  0.0896335932),\n    vec2(-0.1027853330,  0.0312027353),\n    vec2(-0.1201244039, -0.0367098193),\n    vec2(-0.0742338727, -0.0753628805),\n    vec2(-0.0300000000, -0.0923072249),\n    vec2( 0.0300000000, -0.0923072249),\n    vec2( 0.0742338727, -0.0753628805),\n    vec2( 0.1201244039, -0.0367098193),\n    vec2( 0.1027853330,  0.0312027353),\n    vec2( 0.0891532073,  0.0896335932)\n);\n\n// vec4(pos, dir)\n// 0: top right, 1: bottom right, 2: bottom\n// 3: bottom left, 4: top left\nconst vec4[] thrusters = vec4[](\n    vec4( 0.0959692702,  0.0604181643,  0.9738476309,  0.2272020947),\n    vec4( 0.0971791383, -0.0560363500,  0.6442176872, -0.7648421873),\n    vec4( 0.0000000000, -0.0923072249,  0.0000000000, -1.0000000000),\n    vec4(-0.0971791383, -0.0560363499, -0.6442176872, -0.7648421873),\n    vec4(-0.0959692702,  0.0604181643, -0.9738476309,  0.2272020947)\n);\n\n// Utilities\n#define load(buf, addr) texelFetch(buf, addr, 0)\n\nvec2 perp(in vec2 v) {\n    return vec2(-v.y, v.x);\n}\n\nmat2 Rotate2D(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co, si, -si, co);\n}\n\nvec2 axisAlign(in vec2 p, in vec2 up) {\n    return p * mat2(up.y, -up.x, up);\n}\n\n// SDFs\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdIsosceles(in vec2 p, in vec2 q) {\n    p = vec2(abs(p.x), 2.0 * q.y / 3.0 - p.y);\n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)), vec2(dot(b, b), s * (p.y - q.y)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\n// Uncentered isosceles triangle\nfloat sdIsosceles2(in vec2 p, in vec2 q) {\n    p = vec2(abs(p.x), q.y - p.y);\n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)), vec2(dot(b, b), s * (p.y - q.y)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float mag = length(v);\n    p = axisAlign(p, v / mag);\n    return min(sdVerticalLine(p, mag), sdIsosceles(p - vec2(0.0, mag), vec2(0.02, 0.03)));\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    ivec2 iAddr = ivec2(fragCoord);\n    if (iFrame == 0) {\n        // Initialize position, velocity\n    }\n\n    if (iFrame > 0) {\n        if (iAddr.x < 2 && iAddr.y == 1) {\n            // Load state\n            vec4 stateBlock1 = load(iChannel0, ivec2(0, 1));\n            vec4 stateBlock2 = load(iChannel0, ivec2(1, 1));\n\n            vec2 pos = stateBlock1.xy, vel = stateBlock1.zw;\n            float angle = stateBlock2.x, angVel = stateBlock2.y;\n            float flag1 = stateBlock2.z, flag2 = stateBlock2.w;\n            mat2 basis = Rotate2D(angle);\n\n            // Conversion to object space\n            vec4[5] curThrusters;\n            for (int i=0; i < 5; i++) {\n                curThrusters[i].xy = basis * thrusters[i].xy;\n                curThrusters[i].zw = basis * thrusters[i].zw;\n            }\n\n            // Conversion to world space\n            vec2[11] curConvexHull;\n            for (int i=0; i < 11; i++) {\n                curConvexHull[i] = basis * convexHull[i] + pos;\n            }\n\n            // Calculate lowest point on the rocket\n            vec2 contact = curConvexHull[0];\n            for (int i=1; i < 11; i++) {\n                if (curConvexHull[i].y < contact.y) {\n                    contact = curConvexHull[i];\n                }\n            }\n\n            // Linear and angular forces\n            vec2 force = vec2(0.0);\n            float torque = 0.0;\n\n            // Apply forces\n            force.y -= GRAVITY * MASS;\n\n            // Upper right thruster\n            if (texelFetch(iChannel1, ivec2(69, 0), 0).x > 0.5) {\n                vec2 newForce = -curThrusters[0].zw * CORRECTION_THRUST;\n                force += newForce;\n                torque += cross(vec3(curThrusters[0].xy, 0.0), vec3(newForce, 0.0)).z;\n            }\n\n            // Lower right thruster\n            if (texelFetch(iChannel1, ivec2(68, 0), 0).x > 0.5) {\n                vec2 newForce = -curThrusters[1].zw * CORRECTION_THRUST;\n                force += newForce;\n                torque += cross(vec3(curThrusters[1].xy, 0.0), vec3(newForce, 0.0)).z;\n            }\n\n            // Main thruster\n            if (texelFetch(iChannel1, ivec2(83, 0), 0).x > 0.5) {\n                float mainThrust = MAIN_THRUST;\n                if (texelFetch(iChannel1, ivec2(32, 0), 0).x > 0.5) {\n                    mainThrust = MAX_THRUST;\n                }\n\n                vec2 newForce = -curThrusters[2].zw * mainThrust;\n                force += newForce;\n                torque += cross(vec3(curThrusters[2].xy, 0.0), vec3(newForce, 0.0)).z;\n            }\n\n            // Lower left thruster\n            if (texelFetch(iChannel1, ivec2(65, 0), 0).x > 0.5) {\n                vec2 newForce = -curThrusters[3].zw * CORRECTION_THRUST;\n                force += newForce;\n                torque += cross(vec3(curThrusters[3].xy, 0.0), vec3(newForce, 0.0)).z;\n            }\n\n            // Upper left thruster\n            if (texelFetch(iChannel1, ivec2(81, 0), 0).x > 0.5) {\n                vec2 newForce = -curThrusters[4].zw * CORRECTION_THRUST;\n                force += newForce;\n                torque += cross(vec3(curThrusters[4].xy, 0.0), vec3(newForce, 0.0)).z;\n            }\n\n            // Handle ground collision\n            if (contact.y < GROUND) {\n                vec2 contactNormal = vec2(0.0, 1.0);\n                pos.y += GROUND - contact.y;\n                contact -= pos;\n\n                // Calculate force required to reflect contact point's velocity\n                // I'm not sure if this is correct, but it gives reasonable behavior\n                vec2 contactVel = vel + vec2(-contact.y, contact.x) * angVel;\n                mat2 sys = mat2(\n                    MOI / MASS + contact.y * contact.y, -contact.x * contact.y,\n                    -contact.x * contact.y, MOI / MASS + contact.x * contact.x\n                );\n\n                vec2 deltaV = FRICTION * reflect(contactVel, contactNormal) - contactVel;\n                vec2 collisionForce = inverse(sys) * (deltaV * MOI / dt); // TODO: convert to velocity and acceleration changes directly\n\n                // Apply force\n                force += collisionForce;\n                torque += cross(vec3(contact, 0.0), vec3(collisionForce, 0.0)).z;\n            }\n\n            // Simulation step\n            vel += force / MASS * dt;\n            pos += vel * dt;\n\n            angVel += torque / MOI * dt;\n            angle += angVel * dt;\n\n            // Store state\n            if (iAddr == ivec2(0, 1)) fragColor = vec4(pos, vel);\n            if (iAddr == ivec2(1, 1)) fragColor = vec4(angle, angVel, flag1, flag2);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXcRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 135, 135, 3900]], "test": "untested"}
{"id": "msf3Ds", "name": "Simple star distance field", "author": "mrange", "description": "CC0: Simple star distance field\nNothing fancy, just tinkered with distance fields\n", "tags": ["2d", "distance"], "likes": 8, "viewed": 279, "published": 3, "date": "1666988924", "time_retrieved": "2024-07-30T16:24:05.228102", "image_code": "// CC0: Simple star distance field\n// Nothing fancy, just tinkered with distance fields\n\n#define RESOLUTION  iResolution\n\n// Replaced original star code with IQ's improved star.\nfloat star(vec2 p, float r) {\n    p = abs(p);\n    vec2 q = p-r;\n    return q.x<0.0 && q.y<0.0 ? \n              r-sqrt( q.x*q.x + q.y*q.y ) :  \n            sqrt(min( p.x*p.x + q.y*q.y ,    // top corner\n                      q.x*q.x + p.y*p.y ));  // right corner\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n  float d = star(p, 0.75);\n  \n  vec3 col = vec3(0.0);\n  \n  col = mix(col, vec3(0.75), smoothstep(aa, -aa, d));\n  col += 0.5+vec3(0.95, 0.0, 0.0)*sin(100.0*d);  \n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msf3Ds.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 178, 207, 207, 442], [444, 444, 501, 501, 844]], "test": "untested"}
{"id": "msX3Dl", "name": "generative art deco 5", "author": "morisil", "description": "I just played a bit with the coefficients of my original \"generative art deco\". I changed color grading to be based on polar coordinates and put the shape in motion.", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 11, "viewed": 381, "published": 3, "date": "1666974353", "time_retrieved": "2024-07-30T16:24:05.973110", "image_code": "// Fork of \"generative art deco 4\" by morisil. https://shadertoy.com/view/mds3DX\n// 2022-10-28 16:14:01\n\n// Fork of \"generative art deco 3\" by morisil. https://shadertoy.com/view/mdl3WX\n// 2022-10-28 00:47:55\n\n// Fork of \"generative art deco 2\" by morisil. https://shadertoy.com/view/ftVBDz\n// 2022-10-27 22:34:54\n\n// Fork of \"generative art deco\" by morisil. https://shadertoy.com/view/7sKfDd\n// 2022-09-28 11:25:15\n\n// Copyright Kazimierz Pogoda, 2022 - https://xemantic.com/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// copyright statement borrowed from Inigo Quilez\n\n// Music by Giovanni Sollima, L'invenzione del nero:\n// https://soundcloud.com/giovanni-sollima/linvenzione-del-nero\n\n// See also The Mathematics of Perception to check the ideas behind:\n// https://www.shadertoy.com/view/7sVBzK\n\nconst float SHAPE_SIZE = .618;\nconst float CHROMATIC_ABBERATION = .01;\nconst float ITERATIONS = 10.;\nconst float INITIAL_LUMA = .4;\n\nconst float PI = 3.14159265359;\nconst float TWO_PI = 6.28318530718;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat sdPolygon(in float angle, in float distance) {\n  float segment = TWO_PI / 4.0;\n  return cos(floor(.5 + angle / segment) * segment - angle) * distance;\n}\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y) + sin(iTime * .01) * 9.0;\n    //dist = sdPolygon(angle, dist);\n    //dist += sin(angle * 3. + iTime * .21) * .2 + cos(angle * 4. - iTime * .3) * .1;\n    float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, (sin(dist * 3.1) * .5 + .5));\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float blur = .4 + sin(iTime * .52) * .2;\n\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    vec2 origSt = st;\n    st *= rotate2d(sin(iTime * .041) * .3);\n    st *= (sin(iTime * .15) + 2.) * .3;\n    st *= log(length(st * .428)) * 1.1;\n\n    float modScale = 1.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .012), cos(iTime * .13));\n        //center += pow(length(center), 1.);\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur),\n            getColorComponent(center, modScale, blur),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur)        \n        ) * luma;\n        st *= 1.1 + getColorComponent(center, modScale, .04) * .7;\n        st *= rotate2d(sin(iTime  * .012) * 1.33);\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n//        if (color == vec3(1)) break;\n        luma *= .6;\n        blur *= .63;\n    }\n    const float GRADING_INTENSITY = .4;\n    vec3 topGrading = vec3(\n        1. + sin(iTime * 1.13 * .3) * GRADING_INTENSITY,\n        1. + sin(iTime * 1.23 * .3) * GRADING_INTENSITY,\n        1. - sin(iTime * 1.33 * .3) * GRADING_INTENSITY\n    );\n    vec3 bottomGrading = vec3(\n        1. - sin(iTime * 1.43 * .3) * GRADING_INTENSITY,\n        1. - sin(iTime * 1.53 * .3) * GRADING_INTENSITY,\n        1. + sin(iTime * 1.63 * .3) * GRADING_INTENSITY\n    );\n    float origDist = length(origSt);\n    vec3 colorGrading = mix(topGrading, bottomGrading, origDist - .5);\n    fragColor = vec4(1. - pow(color.rgb, colorGrading), 1.);\n    fragColor *= smoothstep(2.1, .7, origDist);\n}", "image_inputs": [{"id": 29472, "src": "https://soundcloud.com/giovanni-sollima/linvenzione-del-nero", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msX3Dl.jpg", "access": "api", "license": "proprietary-license", "functions": [[1544, 1544, 1572, 1572, 1658], [1660, 1660, 1712, 1712, 1818], [1820, 1820, 1891, 1891, 2298], [2300, 2300, 2355, 2355, 4113]], "test": "untested"}
{"id": "DsXGDl", "name": "Melty LOD Matcap shenanigans", "author": "Trixelized", "description": "aaaaaaaaaaaa", "tags": ["aaaaa"], "likes": 14, "viewed": 361, "published": 3, "date": "1666964854", "time_retrieved": "2024-07-30T16:24:06.720113", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 c = texture(iChannel0, uv);\n    \n    vec3 off = vec3(1.0 / iResolution.x, 1.0 / iResolution.y, 0.0);\n    vec3 normal = normalize(vec3(\n        texture(iChannel0, uv + off.xz).r - texture(iChannel0, uv - off.xz).r,\n        texture(iChannel0, uv + off.zy).r - texture(iChannel0, uv - off.zy).r,\n        pow(c.r, 5.0)) + 0.005);\n    \n    vec3 w = texture(iChannel1, 0.5 + (0.5 * normal.xy)).rgb;\n    \n    // highlighting\n    w += pow(abs(dot(normal, normalize(vec3(0.0, -0.45, 1.0)))), 30.0);\n   \n    \n    fragColor = vec4(mix(vec3(w), vec3(0.0), c.b), 1.0);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float spread = 32.0;\nconst float gravity = 0.1;\n\nconst float SMOKELOD1 = 1.25;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pixel_uv = fragCoord;\n    \n    vec3 buffer = texture(iChannel0, uv).rgb;\n    \n    vec3 off = vec3(1.0 / iResolution.x, 1.0 / iResolution.y, 0.0);\n    \n    vec3 normal = normalize(vec3(\n        texture(iChannel0, uv + off.xz, SMOKELOD1).r - texture(iChannel0, uv - off.xz, SMOKELOD1).r,\n        texture(iChannel0, uv + off.zy, SMOKELOD1).r - texture(iChannel0, uv - off.zy, SMOKELOD1).r,\n        1.0));\n    \n    \n    normal = normalize(normal + vec3(0.0, gravity, 0.0));\n    \n    float turbulence = texture(iChannel1, iTime * vec2(0.001, 0.002) + uv * 0.05, SMOKELOD1).r;\n    \n    float val = texture(iChannel0, uv + ((off.xy * normal.xy) * spread * turbulence), SMOKELOD1).r;\n    \n    val = val * 0.98;\n    \n    // input\n    vec4 winput = texture(iChannel2, uv, SMOKELOD1);\n    float src = (winput.r + winput.g + winput.b);\n    src = step(0.3, distance(winput.rgb, vec3(0.25, 0.65, 0.15)));\n    val = max(val, src);\n    \n    fragColor = vec4(vec3(clamp(val, 0.0, 1.0), src, mix(buffer.b, buffer.g, 0.25)), 1.0);\n    \n}\n", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30016, "src": "https://soundcloud.com/wharfwhit/elbows-evidently-mix", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsXGDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 666]], "test": "untested"}
{"id": "csXGDl", "name": "The Jitters", "author": "ruojake", "description": "Whew, talk about garbage lighting.", "tags": ["2d", "noise", "abstract"], "likes": 8, "viewed": 250, "published": 3, "date": "1666962113", "time_retrieved": "2024-07-30T16:24:07.564854", "image_code": "// The Jitters by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\nfloat hash12(vec2 p)\n{\n    vec3 q = p.xyy + vec3(.1,.2,.3) + p.yxx * .2;\n    q += dot(q, p.yyx * .761) - q.z;\n    return fract((q.x + q.y) * .1 + (q.z - q.x) * .12 - q.z * .52);\n}\n\nfloat pat(vec2 p, vec2 i)\n{\n    float h = hash12(i);\n    float t = iTime * (.2 + fract(h + .672));\n    t -= pow(1. - fract(t * fract(h + .912)), 3.) * .5 * fract(h + .193); \n    float a = fract(h + .789) * 4.;\n    a += (fract(h + .321) < .5 ? t : -t);\n    vec2 d = vec2(sin(a),cos(a));\n    return sin(dot(((p - i) * 2. - 1.) * max(h, .1) * 2., d));\n}\n\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 f2 = f * f;\n    f = (6. * f2 - 15. * f + 10.) * f2 * f; \n    \n    vec2 o = vec2(1,0);\n    \n    return mix(\n        mix(pat(p, i), pat(p, i + o), f.x),\n        mix(pat(p, i + o.yx), pat(p, i + 1.), f.x),\n        f.y\n    );\n}\n\nvec2 der(vec2 p, float v)\n{\n    const vec2 e = vec2(.2, 0);\n    return normalize(\n        v - vec3(\n            noise(p + e),\n            noise(p + e.yx),\n            .2\n        )\n    ).xy * smoothstep(-1., 1., v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5)/iResolution.y * 5.;\n\n    float n = noise(uv);\n    vec2 d = der(uv, n);\n    uv += d * 3.;\n    n = noise(uv);\n    uv -= d * 6.;\n    float m = 1.;\n    \n    for(int i = 0; i < 5; ++i)\n    {\n        uv += n / m + 3.;\n        n += noise(uv) / m;\n        m *= 2.;\n    }\n    n = n * .25 + .5;\n\n    vec3 col = mix(vec3(.5, .1, .2), vec3(.3, .25, .3), 1. - n * n);\n    float l = dot(d, vec2(.7071)) * .5 + .5;\n    col = clamp(mix(col * n, vec3(.7, .75, .8), l * l * l * l) + pow(l * 1.1, 40.), 0., 1.);\n    col = mix(col.ggg, col, 2.5);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csXGDl.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[112, 112, 134, 134, 291], [293, 293, 320, 320, 643], [645, 645, 666, 666, 945], [947, 947, 974, 974, 1163], [1165, 1165, 1222, 1222, 1835]], "test": "untested"}
{"id": "csXGWs", "name": "Simple game of life (by trix)", "author": "Trixelized", "description": "Conway's game of life :)", "tags": ["cellularautomata"], "likes": 4, "viewed": 253, "published": 3, "date": "1666955008", "time_retrieved": "2024-07-30T16:24:08.661921", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // get the uv position\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // sample buffer A\n    vec4 samp = texture(iChannel0, uv);\n    \n    // return buffer A's red and green channel as greyscale\n    fragColor = vec4(vec3(samp.r + (samp.g * 0.75)), 1.0);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    \n    // get the uv position and pixel offset\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 off = vec2(1.0 / iResolution.x, 1.0 / iResolution.y);\n    \n    /*\n        \n        these are the neighbors we will check for\n        1,1 is the current pixel we're on\n        \n         0,0 | 1,0 | 2,0\n        -----------------\n         0,1 | 1,1 | 2,1\n        -----------------\n         0,2 | 1,2 | 2,2\n        \n    */\n    \n    // get current pixel's value\n    vec4 src_11 = texture(iChannel0, uv);\n    \n    // get all neighbor values\n    vec4 src_00 = texture(iChannel0, uv + vec2(-1.0, -1.0) * off);\n    vec4 src_10 = texture(iChannel0, uv + vec2(0.0, -1.0) * off);\n    vec4 src_20 = texture(iChannel0, uv + vec2(1.0, -1.0) * off);\n    vec4 src_21 = texture(iChannel0, uv + vec2(1.0, 0.0) * off);\n    vec4 src_22 = texture(iChannel0, uv + vec2(1.0, 1.0) * off);\n    vec4 src_12 = texture(iChannel0, uv + vec2(0.0, 1.0) * off);\n    vec4 src_02 = texture(iChannel0, uv + vec2(-1.0, 1.0) * off);\n    vec4 src_01 = texture(iChannel0, uv + vec2(-1.0, 0.0) * off);\n    \n    \n    // add all neighbors together\n    vec4 neighbors = (src_00 + src_10 + src_20 + src_21 + src_22 + src_12 + src_02 + src_01);\n    \n    \n    float result = 0.0;\n    \n    // check if the current pixel is inactive or active\n    if (src_11.r == 0.0) {\n    \n        // if inactive, turn on if there's 3 active neighbors\n        result = step(3.0, neighbors.r) * step(neighbors.r, 3.0);\n        \n    } else {\n    \n        // if active, only stay on if there's 2-3 active neighbors\n        result = step(2.0, neighbors.r) * step(neighbors.r, 3.0);\n        \n    }\n    \n    // populate with the mouse\n    if (iMouse.z > 0.0) {\n        float r = length(iMouse.xy - fragCoord);\n        result = max(result, step(r, 5.0));\n    }\n    \n    // return result in red channel\n    // return combined neighbors in green channel for a fancy bloom-like effect\n    fragColor = vec4(result, max(neighbors.g/8.0 * 0.995, neighbors.r/8.0), 0.0, 1.0);\n    \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csXGWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 87, 326]], "test": "untested"}
{"id": "DdsGDf", "name": "Lissajous curves table", "author": "kishimisu", "description": "Mouse click: disable overlay\nOn the left and bottom edges, I'm plotting dots moving along a circle path with increasing frequency, then plot the intersection between each point's x component with the other axis y component, giving nice periodic patterns !", "tags": ["sine", "curve", "plot", "periodic", "trigonometry"], "likes": 34, "viewed": 633, "published": 3, "date": "1666949955", "time_retrieved": "2024-07-30T16:24:09.596422", "image_code": "// Overlay\n\nvec3 palette( in float k, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*k+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    if (iMouse.z > 0.5) return;\n    \n    vec2 uv = (fragCoord.xy)/iResolution.y;\n    vec2 fuv = fract(uv*7.)-.5;\n    vec2 fid = floor(uv*7.);\n    vec2 id0 = fid;\n    \n    if (fid.x+fid.y == 0.) return;\n    if (fid.x*fid.y == 0.) fid = vec2(max(fid.x, fid.y));\n\n    vec2 p = vec2( cos(iTime*.2 * fid.x), sin(iTime*.2 * fid.y) )*.45;\n    \n    // lines overlay\n    float d = 0.;\n    if (id0.y > 0.) d += smoothstep(.03, .0, abs(fuv.y - p.y)); // horizontal\n    if (id0.x > 0.) d += smoothstep(.03, .0, abs(fuv.x - p.x)); // vertical\n\n    float intensity = smoothstep(-1., 1., sin(iTime*.35)*8.)*.75;\n    fragColor.rgb += vec3(d)*intensity;\n    \n    // dots overlay\n    vec3 color = palette((fid.x+fid.y)/14., vec3(.75), vec3(0.5), vec3(1.), vec3(0., .25, .5));\n    fragColor.rgb = mix(fragColor.rgb, color+.4, smoothstep(.06, .04, length(fuv - p)) );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Dots trace\n\nvec3 palette( in float k, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*k+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.y;\n    \n    // nicely handle resize thanks to @mla\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    if (fragColor.a != iResolution.x) {\n      fragColor = vec4(0,0,0,iResolution.x);\n    }\n    \n    // repeat space\n    vec2 fuv = fract(uv*7.)-.5;\n    vec2 fid = floor(uv*7.);\n    \n    // edge cases\n    if (fid.x+fid.y == 0.) return;\n    if (fid.x*fid.y == 0.) fid = vec2(max(fid.x, fid.y));\n    \n    // get cell's dot position\n    vec2 p = vec2( cos(iTime*.2 * fid.x), sin(iTime*.2 * fid.y) )*.45;\n    \n    // plot dot\n    float d = smoothstep(.04, -.04, length(p - fuv));\n    vec3 color = palette((fid.x+fid.y)/14., vec3(.75), vec3(0.5), vec3(1.), vec3(0., .25, .5));\n    fragColor.rgb = mix(fragColor.rgb*.9994, color, d);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdsGDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[12, 12, 84, 84, 127], [129, 129, 186, 186, 1098]], "test": "untested"}
{"id": "cdlGzf", "name": "Shepard Tone Warp (sound)", "author": "fenix", "description": "My first attempt at a sound shader! It...works but I'm not sure I actually like the result. It definitely has an effect! What do you think, is this sound evil?\n*rewind to start sound, or maybe, don't...it's obnoxious*\n*space to reset*\n*mouse to \"steer\"*", "tags": ["2d", "sound", "particles", "warp", "stars", "starfield", "shepard"], "likes": 14, "viewed": 459, "published": 3, "date": "1666928475", "time_retrieved": "2024-07-30T16:24:10.498012", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  My first attempt at a sound shader! It...works but I'm not sure I actually\n//  like the result. It definitely has an effect! What do you think, is this sound evil?\n// \n//  Shepard tones have been done before here, like here:\n//\n//      https://www.shadertoy.com/view/XdlXWX\n//  \n//  but the sound tab on that one takes 332 chars while mine is 140, so this could my\n//  contribution to golfing of Shepard tone genenerators. :)\n//\n//  The idea is that this sound has harmonics that extend beyond hearing range in both\n//  directions. We sweep all the pitches upwards, and the ones disappearing at the top\n//  and appearing at the bottom have such high and low frequencies that we can't hear\n//  them. So, ignoring those extreme pitches we can't hear, after sweeping upwards, the\n//  frequencies of all the harmonics match up exactly and can form a loop.\n//\n//  The particle system is one of the new kind I've been trying lately, where the\n//  particles live \"in\" pixels so there's no need for any neighborhood tracking. It's\n//  stripped down for simplicity and optimization reasons, though. For example the\n//  particles do not need a velocity since their velocity is inferred from their position.\n//\n//  A big optimization is that I don't need to search blindly in a square around each\n//  pixel to find density that wants to move in, because of the same velocity-field\n//  property. I am however still wasting a lot of fetches, because I'm still fetching\n//  all texels within a rectangle. A Bresenham algorithm seems like it would work better\n//  here, and I tried it but it didn't work so I gave up, for now.\n//\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    data d = unpack(texelFetch(iChannel0, ivec2(fragCoord), 0));\n    \n    fragColor = cos(d.c * vec4(6,17,8,0) + .3 * iTime) * d.t;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Particles are created each frame on each pixel with this probability\nconst float SPAWN_PROBABILITY = 5e-5;\nconst float SPEED = 19.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    vec4 s = texelFetch(iChannel0, ivec2(0), 0);\n    \n    if (ifc == ivec2(0))\n    {\n        // Reset if resolution doesn't match\n        if (iFrame == 0 || abs(s.xy) != iResolution.xy || keyDown(KEY_SPACE))\n            fragColor = vec4(-iResolution.xy, iResolution.xy*.5);\n        else\n        {\n            if (iMouse.z > 0.) s.zw = iMouse.xy;\n            fragColor = vec4(abs(s.xy), s.zw);\n        }\n        \n        return;\n    }\n    \n    vec3 h = hash(uvec3(ifc, iFrame));\n    data d;\n    \n    if (iFrame == 0 || s.x < 0.)\n    {\n        // Clear buffer    \n        d.p = vec2(0);\n        d.t = d.c = d.d = 0.;\n    }\n    else if (h.x > 1. - SPAWN_PROBABILITY)\n    {\n        // Spawn new particle\n        d.p = vec2(.5); // Start in the middle of the cell\n        d.d = d.t = 1.;\n        d.c = h.y;\n    }\n    else\n    {\n        d = unpack(texelFetch(iChannel0, ifc, 0));\n        d.d = 0.; // new density will be zero if we don't find any density to move here\n        d.t *= 0.95; // Fade out old density to keep the display from becoming too busy\n \n        vec2 center =  -SPEED * (fragCoord - s.zw)/iResolution.y;\n        ivec2 ci = ivec2(center) + ivec2(sign(center));\n        \n        ivec2 mins = min(ivec2(0), ci - 1);\n        ivec2 maxs = max(ivec2(0), ci);\n        for (int x = mins.x; x <= maxs.x; ++x)\n        for (int y = mins.y; y <= maxs.y; ++y)\n        {\n            if (ifc.x + x < 0 || ifc.x + x >= int(iResolution.x)) continue;\n            if (ifc.y + y < 0 || ifc.y + y >= int(iResolution.y)) continue;\n\n            data n = unpack(texelFetch(iChannel0, ifc + ivec2(x, y), 0));\n\n            vec2 p = n.p + vec2(x, y);\n            vec2 np = p + ((fragCoord + vec2(x, y) - s.zw)/iResolution.y) * float(SPEED);\n\n            if (n.d > 0.)\n            {\n                // Draw smooth line from old position to new, even if it jumped past our position\n                float aa = 1. - smoothstep(.5, 2.5, linePointDist(fragCoord + np, fragCoord + p, fragCoord));\n\n                // Use full color if we're drawing on black\n                d.c = d.t < .2 || aa > .2 ? n.c : d.c;\n                d.t += aa;\n\n                if (all(greaterThan(np, vec2(0))) && all(lessThan(np, vec2(1))))\n                {\n                    d.p = np;\n                    d.d = 1.;\n\n                    d.c = n.c; // Copy over the whole color so it doesnt get lost even with thin lines\n                }\n            }\n        }        \n    }\n\n    fragColor = pack(d);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "struct data\n{\n    vec2 p;  // 0 ... 1, position within the cell\n    float d; // either 0 or 1, depending on if a particle is present\n    float t; // 0 ... 1, allows particles to leave trails behind\n    float c; // 0 ... 1, color of trail\n};\n\ndata unpack(vec4 c)\n{\n    data d;\n    \n    d.p = unpackSnorm2x16(floatBitsToUint(c.x));\n    d.d = c.y;\n    d.t = c.z;\n    d.c = c.w;\n    \n    return d;\n}\n\nvec4 pack(data d)\n{\n    return vec4(uintBitsToFloat(packSnorm2x16(d.p)), d.d, d.t, d.c);\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat linePointDist(in vec2 a, in vec2 b, in vec2 u)\n{\n    vec2 c, d = a - b;\n    float l = dot(d, d), s = inversesqrt(l);\n\n    // Find the closest point on the line segment from old to new\n    if (l > 1e-6)\n    {\n        d *= s;\n        c = b + d * max(0.0, min(1.0 / s, dot(d, u - b)));\n    }\n    else\n    {\n        // Line is very short; either end will do\n        c = b;\n    }\n\n    // Distance to closest point on line segment\n    return distance(c, u);\n}\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n", "sound_code": "vec2 mainSound( int s, float t )\n{\n    float r, i;\n        \n    for (r = i = 0.; i < 40.; ++i)\n        r += sin(t * 40. * pow(1.189, i + fract(t * .3)))\n        \n        // 120 hz modulation, not necessary but makes it sound less annoying, maybe?\n        * (.7 + .3 * sin(120. * t));\n    \n    return vec2(r / 40.);\n}", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdlGzf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1920, 1920, 1977, 1977, 2111]], "test": "untested"}
{"id": "mdsGWf", "name": "Fractal mosaic 32 (music)", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 9, "viewed": 495, "published": 3, "date": "1666926471", "time_retrieved": "2024-07-30T16:24:11.350731", "image_code": "vec2 fract1(vec2 a){\n    return\n        fract(a)\n        //(fract(a)+fract(a/2.+.5))/2.\n        //(fract(a)+fract(a/2.))/2.\n        //fract(a-fract(a*4.)/2.)\n        //fract(a-floor(2.*a.x+1.5)/2.)\n    ;\n}\n\nvec3 mosaic(vec2 uv){\n  vec3 col = vec3(0);\n  vec2 offset = vec2(0);\n  vec2 uv1 = vec2(0);\n  for(int k = 0; k < 6; k++){\n        //another interesting variant:\n        //if(uv.y>uv.x) uv = uv.yx;\n        offset =\n            vec2(-uv.x,uv.y)*2.\n            //vec2(-uv.x,mod(uv.y,uv.x))*2.\n            //fract(vec2(-uv.x,uv.y))*(2.-offset/2.)\n            //vec2(mod(uv.x*2.-.5,2.),mod(uv.y,2.)*2.)\n            //vec2(mod(uv.x*2.,2.),sign(uv.x-uv.y)*mod(uv.y,2.)*2.)\n        ;\n        \n        //offset += floor(uv.x-uv.y)/2.;\n        //offset += floor(uv.x+uv.y+1.5)/2.;\n        //uv += fpow(offset.x*4.,4.)/2.;\n        //if(uv.y>uv.x) k += 1;\n\n        uv =\n            abs(fract1(uv.yx-offset)-.5)\n            //sqrt(abs(fract(uv.yx-offset)-.5))\n            //abs(fract(uv.yx-offset)-.5)*sign(.5-uv.x)\n            //(abs(fract(uv.yx-offset)-.5)*(1.-fmod(offset+2.5,2.)*2.))\n\n            //abs(fract(uv.yx/1.5-offset)-.5)/1.5\n            //abs(fract(uv.yx-offset)-.5+floor(uv.x-uv.y))\n            //abs(fract(uv.yx-offset/(1.+mod(floor(uv.x*4.),2.)))-.5)\n\n            //max(abs(fract(uv.yx-offset)-.5),abs(fract(uv.yx-vec2(uv.x,uv.y)*2.)-.5))\n\n            //abs(fract(uv.yx-offset)*(1.-col.x)-.5)\n            //abs(fract(uv.yx-offset)*abs(.5-col.x)*2.-.5)/2.\n        ;\n        //uv += length(uv/2.);\n        //uv.x *= 1.+uv.x/2.;\n        //uv.y *= 1.+uv.x/2.;\n        \n        //if(offset.x<offset.y) uv = uv.yx;\n        \n        if(uv.y > uv.x)\n        //if(uv.y < .25||uv.x>.25)\n        {col =\n            vec3(col.yz,abs(uv.x-uv.y))\n            //abs(col-vec3(col.yz,(uv.x-uv.y)/2.))\n            //vec3(col.yz,max(abs(uv.x-uv.y),col.x))\n            //vec3(col.yz,abs(uv.y-col.x))\n            //max(vec3(col.yz,abs(uv.x-uv.y)),col.yzx)\n        ;\n        //uv += uv1.yx/4.;\n        //uv /= 2.;\n        }\n        //if(uv.x<.5) col = 1.-col;\n        //uv /= 1.+mod(uv,2.);\n\n        //if(uv.y>uv.x) uv = uv.yx;\n        //if(uv.y<uv.x) uv *= sign(uv-uv.yx);\n        //else uv /= 2.;\n        //if(uv.x>uv.y) {col=col.yzx;}\n        uv1 = uv;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    vec2 uv = (fragCoord)/iResolution.y/4.0;\n    \n    uv += vec2(iTime/2.0,iTime/3.0)/16.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/4.;\n\n    vec3 col = mosaic(uv);\n    \n    fragColor = vec4(min(col*2.,vec3(1.)),1.0);\n}\n", "image_inputs": [], "sound_code": "\n\nvec2 mainSound(int samp, float t){\n\n  t /= 1.5;\n  //t += floor(t*pow(2.,fmod(t/4.,3.)));\n  //t = t*(1. + fmod(t*8./2.,2.))/2.;\n  //t += floor(t) + floor(t/2.)*2.+floor(t/4.)*4.+floor(t/8.)*8.;\n  //t += floor(t) + floor(t*2.)/2.+floor(t*4.)/4.+floor(t*8.)/8.;\n  //t = (t + fract(t*2.)/2.)/2.;\n  //t += fpow(t*16.,2.);\n  \n  float s1 =\n      8.\n      //pow(2.,1.+fmod(t,3.))\n  ;\n  //t *= 1. + fmod(t*s1,2.);\n  \n  //t = t + floor(t/s1+floor(t*s1))/s1;\n  //t = t + fmod(t*s1,floor(t)+1.)/s1;\n\n  //t = t + floor(floor(t*s1)+floor(t/s1))/s1;\n  float\n  m1 =\n      fmod(t,s1)\n      //fmod(t*2.-fmod(t/s1,2.),s1)\n      //fmod(mod(t,2.)/2.+mod(t,4.)/4.,s1)\n      //pow(fmod(t,s1),2.)+pow(fmod(t*s1,s1),2.)\n      //fmod(t*s1,s1)\n      //fmod(t+floor(t*s1),s1)\n      //fmod(t+floor(t)*floor(t/s1),s1)\n  ,\n  z1 =\n      (1.+fmod(t/s1,2.))\n      //(1.+fmod(mod(t,2.)/2.+mod(t,4.)/4.,2.))\n      //(1.+fmod(t/s1+floor(t),2.))\n      //(1.+fmod(t/s1+m1,2.))\n  ;\n\n  t /=\n      1.+fmod(floor(t*s1)*floor(t/s1+z1),2.)\n      //1.+fmod(floor(t*s1*sign(m1-z1))*floor(t/s1*sign(m1-z1)+z1),2.)\n      //1.+fmod(floor(t*s1+m1)*floor(t/s1+z1),2.)\n      //1.+fmod(floor(t/s1)*floor(t/s1+z1),2.)\n      //1.+fmod(floor(t/s1)*floor(t*s1+z1),2.)\n      //1.+fmod(floor(t*s1)*floor(t*s1+z1),2.)\n  ;\n  float m3 =\n      fmod((t*8.)/(m1+.5),s1*z1)\n      //fmod((t*8.)/(m1+.5)*sign(m1-z1),s1*z1)\n      //fmod((t*8.)/(m1+.5-fmod(t,8.)),s1*z1)\n      //fmod((t*8.)/(fmod(t*s1,m1+1.)+.5),s1*z1)\n      //fmod((t*8.+m1),s1*z1)\n  ;\n  //t -= (max(m1,m3)+1.)/2.;\n  t *=\n      1.+fmod(floor(t*s1)*floor(t/s1+z1),2.)\n      //1.+fmod(floor(t*s1-(1.-z1)*floor(t))*floor(t/s1+(1.+z1)*floor(t)),2.)\n      //1.+fmod(floor(t*s1/(.5+m1*2.))*floor(t/s1/(.5+m1*4.)+z1),2.)\n      //1.+fmod(floor(t/s1)*floor(t/s1+z1),2.)\n      //1.+fmod(floor(t/s1)*floor(t*s1+z1),2.)\n      //1.+fmod(floor(t*s1)*floor(t*s1+z1),2.)\n  ;\n  \n      \n  float a=\n      //pow(2.,pow(2.,fract(-t*s1)))\n      //sqrt((1.-sqrt(fract(t*s1))))*.2\n      //64.*(1.-sqrt(fract(t*s1)))*.2\n      //pow(2.,2.-log(fract(t*s1)))\n      pow(log(fract(t*s1)/4.),2.)\n      //pow(8.,1.+log(fract(-t*s1)))/8.\n  ,\n\n  nb = t*pow(2.,(m3+z1)/5.+7.);\n\n  return\n      log(abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a)\n      \n      //sitar\n      //log(abs(a/8.-abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a))\n      \n      //vec2(fract(t*nb*.998*z1),fract(t*nb*z1))*a\n  ;\n\n}", "sound_inputs": [], "common_code": "#define f1(a) floor(a+floor((a)/2.))\n//#define fmod(x,y) mod(f1(f1(x)+f1((x)/8./8.)),y)\n//#define fmod(a,b) max(mod(floor(a+floor(a/8./8.))*floor(a),b),mod(floor(a),b))\n//#define fmod(a, b) mod(mod(floor(a/2.),floor(1.+a*2.)),b)\nfloat fmod(float a, float b){\n    /*\n    for(float i = 1.; i < mod(floor(a/b),8.); i++){\n        //a += floor(pow(2.,b));\n        a += mod(floor(a/b),b);\n    }\n    */\n    return\n        mod(floor(a),b)\n        //mod(floor(floor(a)*b/3.),b)\n        //mod(floor(-a*sign(.5-mod(floor(a/b*8.),2.))),b)\n        //mod(floor(a*8./b+b)*floor(a),b)\n    ;\n}\n\n#define fmod0(x,y) mod(floor(x)+1.5*floor(mod(x,y/2.)),y)\n#define fmod1(x,y) floor(mod(floor(x+floor((x)/y)/y),y))\n#define fmod2(x,y) mod(floor(x+floor(x)*y)/y,y)\n#define fmod3(x,y) mod(floor(x)*floor(x)+floor(x)*floor((x)/y),y)\n#define fmod4(x,y) mod(floor(x)*(1.+mod(floor((x)),y)),y)\n#define fmod5(x,y) mod(floor(floor((x)*2.)*2.+x),y)\n#define sqmod(x,y) floor(mod(floor(1.+x/2.)*floor(1.+x*2.),y))\n#define fmax(x,y,z) max(fmod(x,z),fmod(y,z))\n#define fpow(x,y) pow(y,fmod(x,y))", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdsGWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 205], [207, 207, 228, 228, 2266], [2268, 2268, 2325, 2325, 2600]], "test": "untested"}
{"id": "mds3DX", "name": "generative art deco 4", "author": "morisil", "description": "I just played a bit with the coefficients of my original \"generative art deco\". I changed color grading to be based on polar coordinates and put the shape in motion.", "tags": ["chromaticaberration", "study", "depthoffield", "focus", "cineshader"], "likes": 241, "viewed": 14145, "published": 3, "date": "1666918093", "time_retrieved": "2024-07-30T16:24:12.432839", "image_code": "// Fork of \"generative art deco 3\" by morisil. https://shadertoy.com/view/mdl3WX\n// 2022-10-28 00:47:55\n\n// Fork of \"generative art deco 2\" by morisil. https://shadertoy.com/view/ftVBDz\n// 2022-10-27 22:34:54\n\n// Fork of \"generative art deco\" by morisil. https://shadertoy.com/view/7sKfDd\n// 2022-09-28 11:25:15\n\n// Copyright Kazimierz Pogoda, 2022 - https://xemantic.com/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// copyright statement borrowed from Inigo Quilez\n\n// Music by Giovanni Sollima, L'invenzione del nero:\n// https://soundcloud.com/giovanni-sollima/linvenzione-del-nero\n\n// See also The Mathematics of Perception to check the ideas behind:\n// https://www.shadertoy.com/view/7sVBzK\n\nconst float SHAPE_SIZE = .618;\nconst float CHROMATIC_ABBERATION = .01;\nconst float ITERATIONS = 10.;\nconst float INITIAL_LUMA = .5;\n\nconst float PI = 3.14159265359;\nconst float TWO_PI = 6.28318530718;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat sdPolygon(in float angle, in float distance) {\n  float segment = TWO_PI / 4.0;\n  return cos(floor(.5 + angle / segment) * segment - angle) * distance;\n}\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y) + sin(iTime * .08) * 9.0;\n    //dist = sdPolygon(angle, dist);\n    //dist += sin(angle * 3. + iTime * .21) * .2 + cos(angle * 4. - iTime * .3) * .1;\n    float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, sin(dist * 3.0) * .5 + .5);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float blur = .4 + sin(iTime * .52) * .2;\n\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    vec2 origSt = st;\n    st *= rotate2d(sin(iTime * .14) * .3);\n    st *= (sin(iTime * .15) + 2.) * .3;\n    st *= log(length(st * .428)) * 1.1;\n\n    float modScale = 1.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .12), cos(iTime * .13));\n        float fft = texture(iChannel0, vec2(length(center), .25)).r;\n        \n        //center += pow(length(center), 1.);\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur),\n            getColorComponent(center, modScale, blur),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur)        \n        ) * luma;\n        st *= 1.1 + getColorComponent(center, modScale, .04) * 1.2;\n        st *= rotate2d(sin(iTime  * .05) * 1.33);\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n//        if (color == vec3(1)) break;\n        luma *= .6;\n        blur *= .63;\n    }\n    const float GRADING_INTENSITY = .4;\n    vec3 topGrading = vec3(\n        1. + sin(iTime * 1.13 * .3) * GRADING_INTENSITY,\n        1. + sin(iTime * 1.23 * .3) * GRADING_INTENSITY,\n        1. - sin(iTime * 1.33 * .3) * GRADING_INTENSITY\n    );\n    vec3 bottomGrading = vec3(\n        1. - sin(iTime * 1.43 * .3) * GRADING_INTENSITY,\n        1. - sin(iTime * 1.53 * .3) * GRADING_INTENSITY,\n        1. + sin(iTime * 1.63 * .3) * GRADING_INTENSITY\n    );\n    float origDist = length(origSt);\n    vec3 colorGrading = mix(topGrading, bottomGrading, origDist - .5);\n    fragColor = vec4(pow(color.rgb, colorGrading), 1.);\n    fragColor *= smoothstep(2.1, .7, origDist);\n}", "image_inputs": [{"id": 29472, "src": "https://soundcloud.com/giovanni-sollima/linvenzione-del-nero", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mds3DX.jpg", "access": "api", "license": "proprietary-license", "functions": [[1439, 1439, 1467, 1467, 1553], [1555, 1555, 1607, 1607, 1713], [1715, 1715, 1786, 1786, 2191], [2193, 2193, 2248, 2248, 4077]], "test": "untested"}
{"id": "mdl3WX", "name": "generative art deco 3", "author": "morisil", "description": "I just played a bit with the coefficients of my original \"generative art deco\". I changed color grading to be based on polar coordinates and put the shape in motion.", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 17, "viewed": 327, "published": 3, "date": "1666910111", "time_retrieved": "2024-07-30T16:24:13.420199", "image_code": "// Fork of \"generative art deco 2\" by morisil. https://shadertoy.com/view/ftVBDz\n// 2022-10-27 22:34:54\n\n// Fork of \"generative art deco\" by morisil. https://shadertoy.com/view/7sKfDd\n// 2022-09-28 11:25:15\n\n// Copyright Kazimierz Pogoda, 2022 - https://xemantic.com/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// copyright statement borrowed from Inigo Quilez\n\n// Music by Giovanni Sollima, L'invenzione del nero:\n// https://soundcloud.com/giovanni-sollima/linvenzione-del-nero\n\n// See also The Mathematics of Perception to check the ideas behind:\n// https://www.shadertoy.com/view/7sVBzK\n\nconst float SHAPE_SIZE = .618;\nconst float CHROMATIC_ABBERATION = .02;\nconst float ITERATIONS = 10.;\nconst float INITIAL_LUMA = .4;\n\nconst float PI = 3.14159265359;\nconst float TWO_PI = 6.28318530718;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat sdPolygon(in float angle, in float distance) {\n  float segment = TWO_PI / 4.0;\n  return cos(floor(.5 + angle / segment) * segment - angle) * distance;\n}\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y) + sin(iTime * .08) * 9.0;\n    //dist = sdPolygon(angle, dist);\n    //dist += sin(angle * 3. + iTime * .21) * .2 + cos(angle * 4. - iTime * .3) * .1;\n    float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, dist);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    vec2 origSt = st;\n    st *= rotate2d(sin(iTime * .14) * .3);\n    st *= (sin(iTime * .15) + 2.) * .3;\n    st *= log(length(st * .428)) * .8;\n\n    float modScale = 1.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    float blur = .5 + sin(iTime * .5) * .3;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .12), cos(iTime * .13));\n        //center += pow(length(center), 1.);\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur),\n            getColorComponent(center, modScale, blur),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur)        \n        ) * luma;\n        st *= 1.1 + getColorComponent(center, modScale, .04) * 1.;\n        st *= rotate2d(sin(iTime  * .05) * 1.3);\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        if (color == vec3(1)) break;\n        luma *= .6;\n        blur *= .63;\n    }\n    const float GRADING_INTENSITY = .4;\n    vec3 topGrading = vec3(\n        1. - sin(iTime * 1.1 * .3) * GRADING_INTENSITY,\n        1. - sin(iTime * 1.2 * .3) * GRADING_INTENSITY,\n        1. - sin(iTime * 1.3 * .3) * GRADING_INTENSITY\n    );\n    vec3 bottomGrading = vec3(\n        1. + cos(iTime * 1.4 * .3) * GRADING_INTENSITY,\n        1. - cos(iTime * 1.5 * .3) * GRADING_INTENSITY,\n        1. - cos(iTime * 1.6 * .3) * GRADING_INTENSITY\n    );\n    float origDist = length(origSt);\n    vec3 colorGrading = mix(topGrading, bottomGrading, origDist);\n    fragColor = vec4(pow(color.rgb, colorGrading), 1.);\n    fragColor *= smoothstep(2.1, .7, origDist);\n}", "image_inputs": [{"id": 29472, "src": "https://soundcloud.com/giovanni-sollima/linvenzione-del-nero", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdl3WX.jpg", "access": "api", "license": "proprietary-license", "functions": [[1334, 1334, 1362, 1362, 1448], [1450, 1450, 1502, 1502, 1608], [1610, 1610, 1681, 1681, 2065], [2067, 2067, 2122, 2122, 3855]], "test": "untested"}
{"id": "DdlGDj", "name": "Rocky Puddle With Wave Equation", "author": "ilia87", "description": "A puddle in a rocky terrain with rain falling onto it. Use the mouse to create small water-bug like movement on the water.\nIMPORTANT: Works best with resolution of at least 800x400\nPress: L to move the light.\nC to rotate camera.\nP to see wave simulation.", "tags": ["raymarching", "waves", "rain", "rocks"], "likes": 10, "viewed": 371, "published": 3, "date": "1666909129", "time_retrieved": "2024-07-30T16:24:14.645922", "image_code": "#define MAX_STEPS 100\n#define SURFACE_DIST 0.01\n#define MAX_DIST 100.\n#define PI 3.1415927\n\n#define NO_SUN_BLOCKAGE 0\n#define GOO 0\n#define MURKY 1\n\nvec3 light = normalize(vec3(.4,-1.0,.75));\n\nfloat WaveHeight(vec2 p)\n{\n     return texture(iChannel2, WaterBuffPixelForXY(p.xy,iResolution.xy) / iResolution.xy).z * waterWaveHeight;\n}\n\nvec3 WaterNormal_fine(vec2 p)\n{\n    if ( any(greaterThan(abs(p.xy-waterSimCenter),waterSimSize*.5 )))\n        return vec3(0,0,-1);\n    vec2 dh = texture(iChannel2, WaterBuffPixelForXY(p.xy,iResolution.xy) / iResolution.xy).xy * waterWaveHeight;\n    //return vec3(dh*1000.,-1.);\n    vec2 dxy = GetWaterDXYForPixel(iResolution.xy);\n    return normalize(-cross(vec3(dxy.x,0.,dh.x),vec3(0.,dxy.y,dh.y))); //minus sign because system is left-handed\n}\n\nfloat CloudsFBM(vec3 uvw)\n{\n    float x = 0.;\n    float factor=1.;\n    for ( int i=0;i<6;++i)\n    {\n        vec3 ijk = floor(uvw);\n        float a = noise(ijk);\n        float b = noise(ijk+vec3(1.,0.,0.));\n        float c = noise(ijk+vec3(0.,1.,0.));\n        float d = noise(ijk+vec3(1.,1.,0.));\n        \n        float az = noise(ijk+vec3(0.,0.,1.));\n        float bz = noise(ijk+vec3(1.,0.,1.));\n        float cz = noise(ijk+vec3(0.,1.,1.));\n        float dz = noise(ijk+vec3(1.,1.,1.));\n        \n        float sx = smoothstep(0.,1.,fract(uvw.x));\n        float sy = smoothstep(0.,1.,fract(uvw.y));\n        float sz = smoothstep(0.,1.,fract(uvw.z));\n        \n        \n        \n        float v =\n            a\n            + (b-a)*sx\n            + (c-a)*sy\n            + (a-b-c+d)*sx*sy;\n        float vz =\n            az\n            + (bz-az)*sx\n            + (cz-az)*sy\n            + (az-bz-cz+dz)*sx*sy;\n        x+= factor * (v + (vz-v)*sz);\n            \n        factor *=.59;\n        uvw += vec3(5.3241634,6.35134134,7.7654352);\n        uvw *= 2.2;\n        uvw.z*=1.02113;\n        uvw.xy*=m2;\n        //uvw *= m3;\n        //uvw = uvw.yzx;\n    }\n    return x;\n}\n\nvec3 Sky(vec3 ro, vec3 rd, out float sunBlockage)\n{\n    const float skyHeight = -1000.;\n    float dist = (skyHeight - ro.z)/rd.z; \n    const vec2 speed = vec2(0.,30.);\n    const float morphSpeed = 10.;\n    vec3 p = vec3(ro.xy + rd.xy * dist + iTime*speed,iTime*morphSpeed);\n    float v = 1.-smoothstep(-.9,0.5,CloudsFBM(p*.001));\n    //for ( int j=0;j<1;++j)\n    //{\n    //    v *= 1.-smoothstep(-.9,0.5,CloudsFBM((p+rd*100.*float(j))*.001));\n    //}\n    v = smoothstep(0.,1.,sqrt(v))*2.-1.;\n    vec3 c0 = vec3(.6,.6,1.);\n    vec3 c1 = vec3(1.5);\n    vec3 c2 = vec3(1.2);\n    vec3 c3 = vec3(.6);\n    vec3 col=c0;\n    col = mix(col,c1,smoothstep(-.8,1.,v));\n    //col = mix(col,c2,smoothstep(-.2,.4,v));\n    //col = mix(col,c3,smoothstep(0.,1.,v));\n    vec3 L = light;\n    float cosSunAngle = dot(-L,rd);\n    //float sunRadius = radians(.25);\n    float sunRadius = radians(1.);\n    float sunFactor = (cosSunAngle > cos(sunRadius))? 1.0 : 0.0;;\n    float sunHalo = 1.-smoothstep(cos(sunRadius),cos(sunRadius*4.),cosSunAngle);\n    sunHalo = pow(sunHalo,2.5);\n    vec3 sun = (sunFactor*4. + sunHalo*2.)*vec3(1.,1.,.4);\n    sunBlockage = smoothstep(-.4,1.,v);\n    sunBlockage*=sunBlockage;\n    col += sun * (1.-sunBlockage);\n    sunBlockage*=.5;\n#if NO_SUN_BLOCKAGE\n    sunBlockage = 0.;\n#endif\n    return col*1.5;\n}\n\n\nfloat DX[9] = float[9](\n            -.25,0.,.25,\n            -.5,0.,.5,\n            -.25,0.,.25);\n\nvec3 RocksNormal(vec2 xy)\n{\n    const float d = 0.03;\n    float h = RocksTotal(xy, iChannel0, iChannel1);\n    float dh_dx = 0., dh_dy = 0.;\n    //float dh_dx = RocksHeight(xy + vec2(d,0.)) - h;\n    //float dh_dy = RocksHeight(xy + vec2(0.,d)) - h;\n    for ( int i=0;i<3;++i)\n    {\n        for ( int j=0;j<3;++j)\n        {\n            float dx = d*float(i-1);\n            float dy = d*float(j-1);\n            float v = RocksTotal(xy + vec2(dx,dy), iChannel0, iChannel1);\n            dh_dx += v * DX[j*3+i];\n            dh_dy += v * DX[i*3+j];\n        }\n    }\n    return -normalize(cross(vec3(d,0.,-dh_dx),vec3(0.,d,-dh_dy))); //minus sign because system is left handed\n}\n\nbool MarchTerrain(vec3 ro, vec3 rd, out vec3 p)\n{\n    p = ro;\n    float totalDist = 0.;\n    //float prevDE = 0.;\n    for ( int iStep = 0;iStep < MAX_STEPS;++iStep)\n    {\n        float h = -RocksTotal(p.xy, iChannel0, iChannel1);\n        float de = (h-p.z);\n        if (abs(de) < SURFACE_DIST)\n            return true;\n        //if (de < 0.)\n        //{\n        //    de=prevDE*-.5;\n        //    prevDE *= .5;\n        //}\n        //else\n        //{\n        //    prevDE = de;\n        //}\n        totalDist += .5*de;\n        p = ro + totalDist * rd;\n        if (totalDist > MAX_DIST)\n            return false;\n    }\n    return false;\n}\n\nmat3 MouseToRot()\n{\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy) / iResolution.xy;\n    float phi = mouse.x*PI;\n    float theta = (1.+mouse.y)*PI*.5;\n    float cp = cos(phi);\n    float sp = sin(phi);\n    float ct = cos(theta);\n    float st = sin(theta);\n    mat3 Mp = mat3(\n        cp,-sp,0.,\n        sp,cp,0.,\n        0.,0.,1.);\n    mat3 Mt = mat3(\n        1.,0.,0.,\n        0.,ct,-st,\n        0.,st,ct);\n    return Mp*Mt;\n}\n\nfloat Shadow(vec3 dest, vec3 lightSrc)\n{\n    vec3 L = normalize(dest - lightSrc);\n    vec3 p = lightSrc;\n    float closestDist = MAX_DIST;\n    const float shadowMinDist = 0.1;\n    for ( int iStep = 0;iStep < 50;++iStep)\n    {\n        float h = -RocksTotal_ld(p.xy, iChannel0, iChannel1);\n        float de = (h-p.z);\n        closestDist = min(closestDist,de);\n        if (de < SURFACE_DIST)\n            return 0.;\n        if (abs(de) > MAX_DIST)\n            return 1.;\n        p += (.5*de) * L;\n        if ( dot(dest-p,L)<shadowMinDist )\n        {\n            return smoothstep(0.,0.1,closestDist);\n            return 1.0;\n        }\n        //prevDist = de;\n    }\n    return 0.;//smoothstep(0.,0.05,closestDist);\n}\n\nconst float shadowCheckDist = 100.;\n\nfloat FBM_goo(vec2 uv)\n{\n    float x = 0.;\n    float factor=1.;\n    for ( int i=0;i<8;++i)\n    {\n        vec2 ij = floor(uv);\n        float a = noise(ij);\n        float b = noise(ij+vec2(1.,0.));\n        float c = noise(ij+vec2(0.,1.));\n        float d = noise(ij+vec2(1.,1.));\n        float sx = smoothstep(0.,1.,fract(uv.x));\n        float sy = smoothstep(0.,1.,fract(uv.y));\n        x+= factor*(\n            a\n            + (b-a)*sx\n            + (c-a)*sy\n            + (a-b-c+d)*sx*sy);\n        factor *=.7;\n        uv *= 2.5;\n        uv *= m2;\n    }\n    return x;\n}\n\nvoid GetTerrainColor(vec3 p, vec3 light, out vec3 diffuse, out vec3 ambient)\n{\n    vec3 N = RocksNormal(p.xy);\n#if GOO\n    float goo = FBM_goo((p.xy-vec2(12.5,-3.))*.1);\n    goo = smoothstep(-1.,1.,goo)*.8;\n    goo *= smoothstep(-2.,-.5,p.z - waterLevel);\n#endif\n    if ( abs(p.z + Rocks1(p.xy, iChannel1)+Floor(p.xy)) < .05 )\n    {\n        diffuse = mix(texture(iChannel1,p.xy*.1).xyz,vec3(1.,1.,1.),.5);\n        ambient = diffuse;\n        diffuse *= vec3(1.,.8,.6);\n        ambient *= vec3(.8,.7,.5);\n#if GOO\n        diffuse = mix(diffuse,vec3(0.1,.2,.15),goo);\n        ambient = mix(ambient,vec3(0.2,.35,.3),goo);\n#endif\n    }\n    else\n    {\n        diffuse = mix(texture(iChannel1,p.xy*.2).xyz,vec3(1.,1.,1.),.5);\n        ambient = diffuse;\n        diffuse *= vec3(1.,.9,.8);\n        ambient *= vec3(.8,.75,.7);\n#if GOO\n        diffuse = mix(diffuse,vec3(0.1,.2,.15),goo*goo);\n        ambient = mix(ambient,vec3(0.2,.35,.3),goo*goo);\n#endif\n    }\n    diffuse *=  vec3(.6*sqrt(max(dot(light,-N),0.)))*1.5;\n    ambient *= .9;\n    diffuse *= .8;\n}\n\nvec3 MarchReflection(vec3 ro, vec3 rd)\n{\n    vec3 p;\n    MarchTerrain(ro,rd,p);\n    if ( dot(p-ro,p-ro) > 10000. )\n    {\n        float sunBlockage;\n        return Sky(ro,rd,sunBlockage);\n    }\n    float shadow = Shadow(p,p - light * shadowCheckDist);\n    float sunBlockage;\n    Sky(p,-light,sunBlockage);\n    shadow *= 1.-sunBlockage;\n    \n    vec3 diffuse,ambient;\n    GetTerrainColor(p,light,diffuse,ambient);\n    diffuse *= shadow;\n    return diffuse + ambient;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragColor = texelFetch(iChannel2,ivec2(fragCoord),0)*.5+.5;\n    //return;\n    mat3 mouseRot = MouseToRot();\n    if ( texelFetch(iChannel3,ivec2(76,0),0).x >0.)\n    {\n        light = mouseRot * vec3(0.,0.,-1.);\n    }\n    vec3 rd = vec3((2.*fragCoord-iResolution.xy) / iResolution.x,1.);\n    if ( texelFetch(iChannel3,ivec2(67,0),0).x >0.)\n    {\n        rd = mouseRot * rd;\n    }\n    else\n    {\n        rd = PixelToRay(fragCoord,iResolution.xy);\n    }\n    \n    vec3 ro = camPos + rd;\n    rd = normalize(rd);\n    //fragColor.xyz = Sky(camPos,rd);\n    //return;\n    //fragColor.xyz = TerrainNormal(ro.xy)*.5+.5;\n    //return;\n    \n    fragColor = vec4(0.,0.,0.,1.);\n    vec3 p;\n    if ( !MarchTerrain(ro,rd,p) )\n    {\n        //fragColor = vec4(0.,0.,1.,1.);\n        //return;\n    }\n\n    if (texelFetch(iChannel3,ivec2(80,0),0).x!=0.)\n    {\n        vec2 waterXY = p.xy-rd.xy*(p.z-waterLevel)/rd.z;\n        if ( all(lessThan(abs(waterXY - waterSimCenter),waterSimSize*.5 )) )\n        {\n            fragColor = texture(iChannel2, WaterBuffPixelForXY(waterXY,iResolution.xy) / iResolution.xy);\n            return;\n        }\n    }\n    \n    //\n    \n    float shadow = 1.;\n    vec3 lightEntryPoint = p;\n    float waterReflectionCoeff = 0.;\n    float waterReflectionLightCoeff=0.;\n    bool belowWater = p.z > waterLevel;\n    vec3 lightRefracted = light;\n    float shadowInsideWater = 1.0;\n    vec3 reflectedLight = vec3(0.);\n    float depth = 0.;\n    if ( belowWater)\n    {\n        float eta = .3;\n        float waterDist = (waterLevel - ro.z)/rd.z;\n        vec3 waterPos = ro + waterDist*rd;\n        depth = p.z - (waterLevel + waterWaveHeight*2. + WaveHeight(waterPos.xy)*15.);\n        if ( depth < 0.)\n        {\n            belowWater = false;\n        }\n        else\n        {\n            vec3 waterNormal = WaterNormal_fine(waterPos.xy);\n            vec3 rd_t;\n            float rs,rp;\n            Fresnel(rd,rd_t,waterNormal,eta,rs,rp);\n            vec3 rd_r = reflect(rd,waterNormal);\n            waterReflectionCoeff = .5*(rp+rs);\n            reflectedLight = MarchReflection(waterPos,rd_r) * waterReflectionCoeff;\n            MarchTerrain(waterPos,rd_t,p);\n            rd = rd_t;\n\n            float rsl,rpl;\n            Fresnel(light,lightRefracted,waterNormal,eta,rsl,rpl);\n            waterReflectionLightCoeff = .5*(rsl+rpl);\n            float lightDistInsideWater = depth / lightRefracted.z;\n            lightEntryPoint = p - lightRefracted*lightDistInsideWater;\n            shadowInsideWater = Shadow(p,lightEntryPoint);\n        }\n    }\n    shadow = Shadow(lightEntryPoint,lightEntryPoint - light * shadowCheckDist);\n    float sunBlockage;\n    Sky(lightEntryPoint,-light,sunBlockage);\n    shadow *= 1.-sunBlockage;\n    //reflectedLight *= shadow;\n    shadow *= shadowInsideWater;\n    \n    //vec3 V = camPos - p;\n    vec3 diffuse;\n    vec3 ambient;\n\n    GetTerrainColor(p,lightRefracted,diffuse,ambient);\n    diffuse *= shadow;\n\n\n    //fragColor.xyz *= 1.-.2*smoothstep(.02,3.5,L*.55);\n    //if ( p.z >2.)\n    //{\n    //p.z = max(p.z,2.)-2.;\n    //fragColor.xyz *= exp(-p.z*p.z*vec3(.05,.046,.036)*1.2)*8.;\n    if ( belowWater)\n    {\n#if MURKY\n        float waterDist = depth/rd.z;\n        \n        float depthFactor = clamp(1.-exp(-waterDist*.1)+.4,0.,1.);\n        diffuse = mix(diffuse,vec3(.2,.3,.1),depthFactor);\n        ambient = mix(ambient,vec3(.2,.3,.1),depthFactor);\n        ambient *= pow(abs(1.-depthFactor),0.3);\n#endif   \n        diffuse *= (1.-waterReflectionLightCoeff);\n        //ambient *= (1.-waterReflectionLightCoeff);\n    }\n    \n    fragColor.xyz += (1.-waterReflectionCoeff)*(diffuse + ambient);\n    fragColor.xyz += reflectedLight;\n    //fragColor.xyz = p*.1+.5;\n    //}\n    //else\n    //{\n    //    fragColor.xyz *= 6.;\n    //}\n    //fragColor.xyz = vec3(L*50.);\n\n    //fragColor = vec4(texture(iChannel0,uv).x);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define KEY_SPACE 32\nconst vec3 camPos = vec3(0.,-12.,-7.);\n\nconst vec2 puddleCenter = vec2(0.,0.);\nconst float waterLevel = 2.3;\nconst float waterWaveHeight = .01;\nconst vec2 waterSimCenter = vec2(2.,-8.5);\nconst vec2 waterSimSize = vec2(20.,40.);\nconst vec2 waterBufferIdealSize = vec2(800.,400.);\n\n//const mat2 m2 = mat2(5./13.,12./13.,-12./13.,5./13.);\nconst mat2 m2 = mat2(.6,.8,-.8,.6);\n//const mat3 m3 = mat3(\n//                .6,  0.,  .8,\n//                0.,  1., 0.,\n//                -.8, 0., -.6) \n//                * mat3(\n//                1.,0.,0.,\n//                0.,5./13.,12./13.,\n//                0.,-12./13.,5./13.)*mat3(\n//                .6,  0.,  .8,\n//                0.,  1., 0.,\n//                -.8, 0., -.6) ;\n\nvoid Fresnel(\n    vec3 i,       //incoming ray\n    out vec3 t,   //transmitted ray\n    vec3 n,       //normal\n    float eta,    //ratio of refractive indices (n1/n2)\n    out float rs, //reflection coefficient for s polarization\n    out float rp  //reflection coefficient for p polarization\n)\n{\n    float ci = -dot(i,n);\n    float si = sqrt(1.-ci*ci);\n    float st = si*eta;\n    float ct = sqrt(1.-st*st);\n    t = (eta*ci - ct) * n + eta * i;\n    //t = refract(i,n,eta);\n    rs = (eta * ci - ct)/(eta*ci + ct);\n    rs = rs*rs;\n    rp = (eta * ct - ci)/(eta*ct + ci);\n    rp = rp*rp;\n}\n\n/////////////////////////////////////////////\n\nconst float LaplacianSquaredKernel[25] = float[25](0.02777778,  0.22222222,   0.5,  0.22222222, 0.02777778,\n    0.22222222, -0.22222222,  -4. , -0.22222222, 0.22222222,\n    0.5       , -4.        ,  13. , -4.        , 0.5       ,\n    0.22222222, -0.22222222,  -4. , -0.22222222, 0.22222222,\n    0.02777778,  0.22222222,   0.5,  0.22222222, 0.02777778);\n\n\nconst int LaplacianKernelDeg = 5;\nconst int LaplacianKernelHalfDeg = 2;\n\nconst float LaplacianKernel[25] = float[25]\n(-0.00833333,  0.        , -0.06666667,  0.        , -0.00833333,\n 0.        ,  0.13333333,  1.06666667,  0.13333333,  0.        ,\n-0.06666667,  1.06666667, -4.5       ,  1.06666667, -0.06666667,\n 0.        ,  0.13333333,  1.06666667,  0.13333333,  0.        ,\n-0.00833333,  0.        , -0.06666667,  0.        , -0.00833333);\n\n/////////////////////////////\n\nfloat noise(float i)\n{\n    float x = fract(i*3.453462472+.45623426)*50.;\n    return 2.*fract(x*x)-1.;\n}\n\n\nfloat noise(vec2 ij)\n{\n    vec2 xy = fract(ij*vec2(3.453462472,6.76235421)+vec2(.45623426,.57422783))*50.;\n    return 2.*fract(xy.x*xy.y*(xy.x+xy.y))-1.;\n}\n\nfloat noise(vec3 ijk)\n{\n    vec3 xyz = fract(ijk*vec3(3.453462472,6.76235421,1.2452341)+vec3(.45623426,.57422783,.7552213513))*50.;\n    return 2.*fract((xyz.x*xyz.y + xyz.y*xyz.z + xyz.z*xyz.x)*(xyz.x+xyz.y+xyz.z))-1.;\n}\n\n\nfloat FloorFBM(vec2 uv)\n{\n    float x = 0.;\n    float factor=1.;\n    for ( int i=0;i<5;++i)\n    {\n        vec2 ij = floor(uv);\n        float a = noise(ij);\n        float b = noise(ij+vec2(1.,0.));\n        float c = noise(ij+vec2(0.,1.));\n        float d = noise(ij+vec2(1.,1.));\n        float sx = smoothstep(0.,1.,fract(uv.x));\n        float sy = smoothstep(0.,1.,fract(uv.y));\n        x+= factor*(\n            a\n            + (b-a)*sx\n            + (c-a)*sy\n            + (a-b-c+d)*sx*sy);\n        factor *=.4;\n        uv *= 1.8;\n        uv *= m2;\n    }\n    return x;\n}\n\nfloat Floor(vec2 p)\n{\n    float h =0.;\n    vec2 q = p-puddleCenter;\n    float lq2 = q.x*q.x + q.y*q.y;\n    const float r = 1./11.5;\n    h += -6./(1. + lq2*r*r);\n    float h_fbm = FloorFBM((q.xy+vec2(2.23523,6.75676))*0.1)*3.5;\n    //h_fbm += 1.;\n    h_fbm = pow(abs(h_fbm),2.2)*.4;\n    h_fbm = 1.-h_fbm;\n    h+=h_fbm*1.5;\n    //if ( h < -5.)\n        //h*=1.+pow((-5.-h)*.42,6.);// /pow(q.x*q.x+.4,2.);\n    h += 1.1;\n    //h += texture(iChannel0,(p.xy+vec2(5.8234,.67756))*0.04).x*3.;\n    //h += texture(iChannel0,m2*(p.xy+vec2(1.6246,3.68567))*0.02).x*3.;\n    return h;\n}\n\nfloat Rocks1(vec2 p, sampler2D channel1)\n{\n    float h2 = texture(channel1,(p.xy+vec2(6.23235,3.576588))*.02).x*.05;\n    h2 -= texture(channel1,(p.xy+vec2(8.23235,2.576588))*.04).x*.02;\n    //h2 *= 1.-smoothstep(4.0,10.0,distFromCenter);\n    h2 *= 2.;\n\n    return h2;\n}\n\n\nfloat Rocks2(vec2 p, sampler2D channel0)\n{\n    //float distFromCenter = length(p - puddleCenter);\n    float h = texture(channel0,(p.xy+vec2(-1.53242,5.65252))*0.04).x;\n    //h += texture(iChannel1,m2*(p.xy+vec2(.23235,4.576588))*.015).x*.05;\n    //h *= 1.-smoothstep(15.,100.0,distFromCenter);\n    \n    //h -= .5;\n    //h=max(h,0.);\n    //float h0 = .2;\n    //if ( h>h0)\n    //    h = h0 + pow(h-h0,.6); \n    h = smoothstep(0.5,1.,h*1.0);\n    h *= 3.5;\n        \n    return h;\n}\n\nfloat Rocks3(vec2 p, sampler2D channel0)\n{\n    //float distFromCenter = length(p - puddleCenter);\n    float h2 = texture(channel0,(p.xy+vec2(0.543521,.2766367))*0.16).x;\n    //h += texture(iChannel1,(p.xy+vec2(.23235,.576588)*.02)).x*.02;\n    //h2 *= 1.-smoothstep(15.,100.0,distFromCenter);\n    \n    //h -= .5;\n    //h=max(h,0.);\n    //float h0 = .2;\n    //if ( h>h0)\n    //    h = h0 + pow(h-h0,.6); \n    h2 = smoothstep(0.5,1.,h2*1.0);\n    h2 *= .3;\n    return h2;\n}\n\nfloat RocksTotal(vec2 p, sampler2D channel0, sampler2D channel1)\n{\n    return max(max(Rocks1(p,channel1),Rocks2(p,channel0)),Rocks3(p,channel0)) + Floor(p);\n}\n\nfloat RocksTotal_ld(vec2 p, sampler2D channel0, sampler2D channel1)\n{\n    return max(Rocks2(p,channel0),Rocks3(p,channel0)) + Floor(p);\n}\n\n////////////////////////////////////////\n\nvec2 GetWaterBufferSize(vec2 resolution)\n{\n    float ar = waterSimSize.y/waterSimSize.x;\n    float y = min(waterBufferIdealSize.y,resolution.y);\n    float x = min(y*ar,resolution.x);\n    y = min(y,x/ar);\n    return vec2(x,y);\n}\n\nvec2 GetWaterDXYForPixel(vec2 resolution)\n{\n    return waterSimSize.yx/GetWaterBufferSize(resolution);\n}\n\nvec2 WaterBuffPixelForXY(vec2 xy, vec2 resolution)\n{\n    return clamp(((xy-waterSimCenter) / waterSimSize + 0.5),0.,1.).yx * GetWaterBufferSize(resolution);\n}\n\nvec2 WaterBuffPixelToXY(vec2 pixelCoords, vec2 resolution)\n{\n    return (pixelCoords / GetWaterBufferSize(resolution) - 0.5).yx*waterSimSize + waterSimCenter;\n}\n\n\n\n\n////////////////////////////////////////\n\nvec3 PixelToRay(vec2 pixel,vec2 resolution)\n{\n    vec3 rd = vec3((2.*pixel-resolution) / resolution.x,1.);\n    float a = radians(45.);\n    float c = cos(a);\n    float s = sin(a);\n    mat2 M = mat2(c,-s,s,c);\n    rd.yz = M*rd.yz;\n    return rd;\n}\n", "buffer_a_code": "\nvoid Rain(out vec4 fragColor, in vec2 fragCoord )\n{\n    const float freq = 2.;\n    float t = iTime;\n    float x = fract(t*freq);\n    float fallOff = 30.;\n    vec2 k = vec2(exp(-x*fallOff), -freq*fallOff*exp(-x*fallOff));\n    float i = floor(t*freq);\n    float u = noise(i)*.5+.5;\n    float v = noise(i*7.52341+.57424)*.5+.5;\n    vec2 uv = vec2(u,v);\n    vec2 d = fract(vec2(7.52624514,6.2365432)*texture(iChannel1,uv).xy - texture(iChannel1,fract((uv+vec2(.362456,.678562))*52.16572788)).xy);\n    vec2 waveSrc = d * GetWaterBufferSize(iResolution.xy);\n    float waveSrcSize = 3.0;\n    float srcStrength = .5+.5*u;\n    float d2 = dot(fragCoord - waveSrc,fragCoord-waveSrc);\n    fragColor.xy += srcStrength * exp(-d2/(waveSrcSize*waveSrcSize)) * k;\n}\n\nvec2 SineSrc(float t, float freq)\n{\n    //freq*=2.;\n    return vec2(sin(6.2831853*freq*iTime),6.2831853*freq*cos(6.2831853*freq*iTime));\n}\n\nvec2 KickSrc(float t,float freq)\n{\n    float x = fract(t*freq);\n    float fallOff = 30.;\n    return vec2(exp(-x*fallOff), -freq*fallOff*exp(-x*fallOff));\n}\n\nvec2 MixedSrc(float t,float freq)\n{\n    return SineSrc(t,freq) + KickSrc(t,freq);\n}\n\n//#define SrcFunc SineSrc\n//#define SrcFunc MixedSrc\n#define SrcFunc KickSrc\n\nvec2 waterBufferSize;\n\nvoid AddSource( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 waveSrc = iMouse.xy;\n    //if ( waveSrc.x == 0. && waveSrc.y == 0.)\n        waveSrc =  waterBufferSize * .5;\n    float waveSrcSize = 2.0;\n    float waveSrcFreq = .2;\n    float d2 = dot(fragCoord - waveSrc,fragCoord-waveSrc);\n    fragColor.xy += exp(-d2/(waveSrcSize*waveSrcSize)) * SrcFunc(iTime,waveSrcFreq);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    waterBufferSize = GetWaterBufferSize(iResolution.xy);\n    if ( iFrame < 5 \n    || fragCoord.x >= waterBufferSize.x || fragCoord.y >= waterBufferSize.y )\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    vec2 p = WaterBuffPixelToXY(fragCoord, iResolution.xy);\n    float depth = RocksTotal_ld(p,iChannel0,iChannel1) + waterLevel;\n    if ( depth > 0. )\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    float timeDelta = min(iTimeDelta,0.01);\n\n    fragColor = vec4(0.,0.,0.,1.);\n    \n    //float waveLength = 2.;\n    float waveSpeed = 50. - 15.*smoothstep(-.2,.0,depth);\n    //float waveSpeed = 50.;\n    //float dampRate = .5 + 2.5 * smoothstep(-.1,.0,depth);//waveSpeed * 100.;\n    float dampRate = .5;\n    //float diffusionRate = .1;\n    float k4thOrder = 1.;\n    float k2ndOrder = 1.;\n        \n    \n    //AddSource(fragColor,fragCoord);\n    Rain(fragColor,fragCoord);\n    \n    if ( iMouse.z >0.)\n    {\n        vec3 rd = PixelToRay(iMouse.xy,iResolution.xy);\n        rd = normalize(rd);\n        vec2 srcPos = WaterBuffPixelForXY(camPos.xy + rd.xy * (waterLevel-camPos.z)/rd.z, iResolution.xy);\n        fragColor.x = -.9*exp(-dot(fragCoord - srcPos,fragCoord - srcPos)/4.0);\n    }\n    \n    \n    vec4 prevPixel = texelFetch(iChannel3,ivec2(fragCoord),0);\n    float h = prevPixel.x;\n    float dh_dt = prevPixel.y;\n    \n    \n    //float L = 0.;\n    //float L2 = 0.;\n    //for ( int i=0;i<5;++i)\n    //{\n    //\tfor ( int j=0;j<5;++j)\n    //\t{\n    //\t\tfloat v = texelFetch(iChannel3,ivec2(int(fragCoord.x)+i-2,int(fragCoord.y)+j-2),0).x;\n    //\t\tL -= v;\n    //\t\tL2 += L2kernel[i*5+j] * v;\n    //\t}\n    //}\n    //L += 25.*h;\n    float L = 0.;\n    for ( int i=0;i<LaplacianKernelDeg;++i)\n    {\n        for ( int j=0;j<LaplacianKernelDeg;++j)\n        {\n            L -= LaplacianKernel[i*LaplacianKernelDeg+j] * texelFetch(iChannel2,ivec2(int(fragCoord.x)+i-LaplacianKernelHalfDeg,int(fragCoord.y)+j-LaplacianKernelHalfDeg),0).x;\n        }\n    }\n    float L2 = 0.;\n    for ( int i=0;i<5;++i)\n    {\n    \tfor ( int j=0;j<5;++j)\n    \t{\n    \t\tfloat v = texelFetch(iChannel2,ivec2(int(fragCoord.x)+i-2,int(fragCoord.y)+j-2),0).x;\n    \t\tL2 += LaplacianSquaredKernel[i*5+j] * v;\n    \t}\n    }\n    \n    float d2h_dt2 = (-L*k2ndOrder-L2*k4thOrder) *(waveSpeed*waveSpeed);\n    dh_dt += d2h_dt2 * timeDelta;\n    h += dh_dt * timeDelta;\n    \n    h *= exp(-timeDelta*dampRate);\n    \n    fragColor.x += h;\n    fragColor.y += dh_dt;\n}", "buffer_a_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "const float G[25] = float[25]\n(0.00048091, 0.00501119, 0.01094545, 0.00501119, 0.00048091,\n0.00501119, 0.0522178 , 0.11405416, 0.0522178 , 0.00501119,\n0.01094545, 0.11405416, 0.2491172 , 0.11405416, 0.01094545,\n0.00501119, 0.0522178 , 0.11405416, 0.0522178 , 0.00501119,\n0.00048091, 0.00501119, 0.01094545, 0.00501119, 0.00048091);\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 waterBufferSize = GetWaterBufferSize(iResolution.xy);\n    if ( iFrame < 5 \n        || fragCoord.x >= waterBufferSize.x || fragCoord.y >= waterBufferSize.y )\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    //Apply gaussian kernel\n    fragColor = vec4(0.0,0.0,0.0,0.0);\n    for ( int i=0;i<5;++i)\n        for ( int j=0;j<5;++j)\n            fragColor.x += G[i*5+j] * texelFetch(iChannel0,ivec2(int(fragCoord.x)+i-2,int(fragCoord.y)+j-2),0).x;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "const float D[9] = float[9]\n(-.5,0.,.5,\n -1.,0.,1.,\n -.5,0.,.5);\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 waterBufferSize = GetWaterBufferSize(iResolution.xy);\n    if ( iFrame < 5 \n        || fragCoord.x >= waterBufferSize.x || fragCoord.y >= waterBufferSize.y )\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    //Differentiate by x,y\n    fragColor = vec4(0.0,0.0,0.0,0.0);\n    for ( int i=0;i<3;++i)\n        for ( int j=0;j<3;++j)\n        {\n            float v = texelFetch(iChannel0,ivec2(int(fragCoord.x)+i-1,int(fragCoord.y)+j-1),0).x;\n            fragColor.x += D[i*3+j] * v;\n            fragColor.y += D[j*3+i] * v;\n        }\n    fragColor.z = texelFetch(iChannel0,ivec2(fragCoord),0).x;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdlGDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 193, 219, 219, 332], [334, 334, 365, 365, 779], [781, 781, 808, 808, 1944], [1946, 1946, 1997, 1997, 3257], [3359, 3359, 3386, 3386, 4028], [4030, 4030, 4079, 4079, 4664], [4666, 4666, 4685, 4685, 5092], [5094, 5094, 5134, 5134, 5807], [5846, 5846, 5870, 5870, 6416], [6418, 6418, 6496, 6496, 7466], [7468, 7468, 7508, 7508, 7934], [7936, 7936, 7993, 8073, 11839]], "test": "untested"}
{"id": "Ddl3Wf", "name": "3D-raymarching-2", "author": "Kolya142", "description": "second 3d", "tags": ["3d", "raymarching"], "likes": 0, "viewed": 127, "published": 3, "date": "1666899042", "time_retrieved": "2024-07-30T16:24:15.506620", "image_code": "float distrend = 0.001;\nfloat sphere(vec3 p, vec3 c, float r) {\n    return length(p-c)-r;\n}\nfloat sdBox( vec3 p, vec3 c, vec3 b )\n{\n  vec3 q = abs(p-c) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nvec3 light_pos() {\n    return vec3(vec2(1.6, 7.), .0);\n}\nvec2 rot(vec2 p, float a) {\n    return vec2(p.x * cos(a) - p.y * sin(a), \n                p.x * sin(a) + p.y * cos(a));\n}\n\nvec2 map_the_world(in vec3 p) {\n    vec3 pbi = p;\n    pbi.xy = rot(pbi.xy, sin(iTime));\n    pbi.xz = rot(pbi.xz, cos(iTime));\n    float s = sphere(vec3(p.x, p.y, p.z), vec3(-3., sin(iTime), -3.), 1.0);\n    float swood = sphere(vec3(p.x, p.y, p.z), vec3(-4., -5, -4.), 1.0);\n    float b1 = sdBox(p, vec3(sin(2.68), cos(2.68), -3.), vec3(100., .2, 100.));\n    float bi = sdBox(pbi, vec3(3., 1., 2.), vec3(1.) );\n    float l = sphere(p, light_pos(), .3);\n    float index = 0.;\n    float m = min(s, min(min(b1, swood), min(bi, l)));\n    if (s == m) {\n        index = 1.;\n    }\n    if (b1 == m) {\n        index = 2.;\n    }\n    if (bi == m) {\n        index = 3.;\n    }\n    if (l == m) {\n        index = 4.;\n    }\n    return vec2(m, index);\n}\nvec3 Norm(in vec3 p)\n{\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = map_the_world(p + small_step.xyy).x - map_the_world(p - small_step.xyy).x;\n    float gradient_y = map_the_world(p + small_step.yxy).x - map_the_world(p - small_step.yxy).x;\n    float gradient_z = map_the_world(p + small_step.yyx).x - map_the_world(p - small_step.yyx).x;\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\nfloat shadow(vec3 ro, vec3 rd) {\n    float step_size;\n    vec3 pos;\n    float dist;\n    float d;\n    for (int i = 0; i < 20;i++) {\n        pos = ro + dist * rd;\n        vec2 map = map_the_world(pos);\n        d = map.x;\n        if (d < .0001 && dist > .015) {\n            if (map.y == 4.) return -10.;\n            return .5;\n        }\n        dist += d;\n    }\n    return 0.;    \n}\nvec3 render(vec3 ro, vec3 rd) {\n    float step_size;\n    vec3 pos;\n    float dist;\n    float d;\n    for (int i = 0; i < 100;i++) {\n        pos = ro + dist * rd;\n        vec2 map = map_the_world(pos);\n        d = map.x;\n        if (d < dist*distrend) {\n            float id = map.y;\n            vec3 norm = Norm(pos);\n            float light = max(.1, dot(norm, normalize(light_pos())));\n            vec3 color;\n            light -= shadow(pos, normalize(light_pos()));\n            if (id == 3.) {\n                color = vec3(.2, 1., .2);\n            }\n            if (id == 2.) {\n                color = vec3(1., .1, .1) * sin(length(pos.xyz)) + .15;\n            }\n            if (id == 1.) {\n                color = vec3(.2, .2, 1.);\n            }\n            if (id == 4.) {\n                color = vec3(10.);\n            }\n            return color * light;\n        }\n        dist += d;\n    }\n    return texture(iChannel0, rd).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 vuv = fragCoord/iResolution.xy;\n    vuv.x *= iResolution.x / iResolution.y;\n    vuv.x -= .5;\n    vec2 uv = vuv * 2. - 1.;\n    vec3 ro = vec3(0., 0., -6.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    vec2 mouse = (iMouse.xy/iResolution.xy - .5) * 2.;\n    rd.yz = rot(rd.yz, mouse.y);rd.xz = rot(rd.xz, mouse.x);\n    ro.yz = rot(ro.yz, mouse.y);ro.xz = rot(ro.xz, mouse.x);\n\n    // Time varying pixel color\n    vec3 col = render(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Time varying pixel color\n    vec3 col = texture(iChannel1, vec2(atan(rayDir.x/rayDir.z), sin(rayDir.y))).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "cube_a_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ddl3Wf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 63, 63, 91], [92, 92, 131, 131, 220], [221, 221, 239, 239, 277], [278, 278, 305, 305, 399], [401, 401, 432, 432, 1136], [1137, 1137, 1159, 1159, 1599], [1600, 1600, 1632, 1632, 1979], [1980, 1980, 2011, 2011, 2916], [2918, 2918, 2975, 3025, 3527]], "test": "untested"}
{"id": "msfGDX", "name": "Starfield from noise octaves", "author": "CaffeinePwrdAl", "description": "Simple starfield using multiple octaves of noise being cycled and scaled over time, combined with star shimmer and a small amount of nebulosity in the background.\n\nIt's all a massive hack, but I was after a calm starfield to keep my gpu warm.", "tags": ["noise", "starfield"], "likes": 13, "viewed": 510, "published": 3, "date": "1666893223", "time_retrieved": "2024-07-30T16:24:16.704417", "image_code": "//#define USE_SIMPLE_NOISE\n\n/* ------------------------------------------------------------------------ */\n/*\n    Gradient Noise - https://www.shadertoy.com/view/XdXGW8\n*/\n/* ------------------------------------------------------------------------ */\nvec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n#if defined(USE_SIMPLE_NOISE)\n\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));\n    \n#else\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;\n#endif                              \n}\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n/* ------------------------------------------------------------------------ */\n\nvec3 saturate(vec3 c)\n{\n    return clamp(c, 0.0, 1.0);\n}\n\nfloat saturate(float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\n/* ------------------------------------------------------------------------ */\n\nconst float cycle_len_s = 20.0;\nfloat fade_time = 7.0;\nfloat max_scale_pow = 3.0;\nfloat max_scale = 3.0;\n\nfloat speed_adjust = 1.0;\nfloat global_time = 0.0;\n\nvec2 screen_uv = vec2(0.0);\n\n/* ------------------------------------------------------------------------ */\n\nvec3 stars(vec2 uv, float seed)\n{\n    const float threshold = 0.6;\n    float stars = noise(uv + vec2(seed, seed));\n    \n#if defined(USE_SIMPLE_NOISE)\n    stars *= 1.25;\n#endif\n        \n    vec3 col = vec3(stars) - threshold;\n    col *= (1.0/(1.0 - threshold));\n    return saturate(col);\n}\n\nvec2 stars_uv(vec2 fragCoord, float scale)\n{\n    vec2 uv = screen_uv - vec2(0.5);\n    uv *= iResolution.xy * 0.25;\n    uv /= scale;\n    return uv;\n}\n\nfloat star_fade(float age)\n{\n    float fade_out = 1.0 - smoothstep(cycle_len_s - fade_time, cycle_len_s, age);\n    float fade_in = smoothstep(0.0, fade_time, age);\n    return fade_in * fade_out;\n}\n\nvec3 star_field_octave(float start_age, vec2 fragCoord, float seed)\n{\n    // Draws a plane of stars that fades in, increases in size giving\n    // the impression of movement towards the viewer, and fades out at\n    // the end. Each plane cycles from back-to-front in a loop\n#if 0\n    float fade, scale;\n    if (start_age >= 0.0)\n    {\n        float cycle_time = mod(global_time + start_age, cycle_len_s);\n        float t = (cycle_time / cycle_len_s);\n        fade = star_fade(cycle_time);\n        scale = 1.0 + pow(t, max_scale_pow) * max_scale;\n    }\n    else\n    {\n        fade = 1.0;\n        scale = 1.0;\n    }\n#else\n    \n    float cycle_time = mod(global_time + start_age, cycle_len_s);\n    float t = (cycle_time / cycle_len_s);\n    \n    float fade = star_fade(cycle_time);\n    float scale = 1.0 + pow(t, max_scale_pow) * max_scale;\n    \n    fade = (start_age < 0.0)?(1.0):(fade);\n    scale = (start_age < 0.0)?(1.0):(scale);\n#endif\n\n    vec2 uv = stars_uv(fragCoord, scale);\n    vec3 col = fade * stars(uv, seed);\n    \n    return col;\n}\n\nfloat star_shimmer()\n{\n    // Intersecting noise to modulate the stars but be random enough\n    // that your eye doesn't quite see the scrolling of the pattern\n    vec2 uv = screen_uv;\n    float shimmer_speed = iTime * 2.0;\n    float octave_a = abs(noise(vec2(23.0, 19.0) * uv + vec2(shimmer_speed)));\n    float octave_b = abs(noise(vec2(27.0, -29.0) * uv + vec2(shimmer_speed)));\n    return 0.5 + 0.5 * saturate(octave_a + octave_b);\n}\n\nvec2 rotate2d(vec2 v, float r)\n{\n    float cos_r = cos(r);\n    float sin_r = sin(r);\n    mat2 m = mat2(cos_r, -sin_r, sin_r, cos_r);\n    return v * m;\n}\n\nvec4 nebula()\n{\n    vec2 uv = screen_uv;\n    \n    float debug_rot = 0.2f;\n    vec2 uv_r = rotate2d(uv, global_time * 0.0125 * debug_rot);\n    vec2 uv_g = rotate2d(uv, global_time * -0.00625 * debug_rot);\n    vec2 uv_b = uv;\n    \n    uv_r += vec2(-1.0, 1.0) * vec2(global_time * 0.05 * debug_rot);\n    uv_g += vec2(1.0, 1.0) * vec2(global_time * 0.03 * debug_rot);\n    uv_b += vec2(1.0, -1.0) * (global_time * 0.01 * debug_rot);\n    \n    vec4 neb = vec4(0.0);\n    \n    // Red and green are two independent combinations of multi-octave noise \n    float r = 1.3 * (noise(vec2(192.0) + uv_r * 3.2))\n            + 0.5 * (noise(vec2(1123.0) + uv_r * 5.7))\n            //+ 0.1 * (noise(vec2(173.0) + uv_b * 35.7))\n            + 0.1 * (noise(vec2(173.0) + uv_r * 125.7));\n    \n    float g = 1.1 * (noise(vec2(17.0) + uv_g * 2.3))\n            + 0.6 * (noise(vec2(41.0) + uv_r * 5.2))\n            //+ 0.2 * (noise(vec2(97.0) + uv_g * 19.4))\n            + 0.1 * (noise(vec2(137.0) + uv_g * 65.7));\n    \n    neb.r = saturate(r * 0.5);\n    neb.g = saturate(g * 0.5);\n    \n    // Blue occurs as a noise plane within the green and red areas of nebula\n    neb.b = 1.0 * noise(vec2(179.0) + uv_b * 3.2)\n          //+ 0.4 * noise(vec2(242.0) + uv_b * 17.0)\n          + 0.1 * noise(vec2(342.0) + uv_b * 45.0);\n    neb.b = saturate(2.0 * (neb.r + 0.8*neb.g) * neb.b);\n    \n    // Add a bit of b in r/g\n    neb.g += 0.1 * neb.b;\n    neb.r += 0.2 * neb.b;\n    \n    neb.r += 0.2 * neb.g;\n    \n    // Interstellar dust\n    neb.a = 0.1 * neb.r + 0.2 * neb.g + 0.1 * neb.b;\n    neb.a += saturate(0.25 + 0.75 * noise(vec2(457.0) + uv * 3.12));\n    \n    return neb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate some initial globals\n    screen_uv = fragCoord / iResolution.xy;\n    global_time = iTime * speed_adjust;\n    \n    // Offset the 4 planes of stars by 1/4 cycle length\n    float age_offset = cycle_len_s * 0.25;\n    \n    float shimmer = star_shimmer();\n    vec4 neb = nebula();\n    \n    vec3 col = vec3(0.0)\n        + 0.2 * neb.rgb\n        + neb.a * star_field_octave(-1.0, fragCoord, 265.0) * shimmer;\n        \n    vec3 stars = vec3(0.0) \n        + star_field_octave(0.0 * age_offset, fragCoord, 42.0)\n        + star_field_octave(1.0 * age_offset, fragCoord, 93.0)\n        + star_field_octave(2.0 * age_offset, fragCoord, 137.0)\n        + star_field_octave(3.0 * age_offset, fragCoord, 17.0)\n        ;\n    stars *= shimmer;   \n    col += stars;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msfGDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 251, 328, 382, 886], [888, 888, 914, 914, 1355], [1436, 1436, 1459, 1459, 1492], [1494, 1494, 1519, 1519, 1552], [1901, 1901, 1934, 1934, 2189], [2191, 2191, 2235, 2235, 2339], [2341, 2341, 2369, 2369, 2537], [2539, 2539, 2608, 2812, 3580], [3582, 3582, 3604, 3741, 4018], [4020, 4020, 4052, 4052, 4172], [4174, 4174, 4189, 4189, 5813], [5815, 5815, 5872, 5910, 6695]], "test": "untested"}
{"id": "DdfGW2", "name": "Acidulate Hellscape", "author": "leon", "description": "a bit of color in this world of hell", "tags": ["noise", "terrain", "abstract", "gyroid"], "likes": 39, "viewed": 738, "published": 3, "date": "1666889072", "time_retrieved": "2024-07-30T16:24:17.477351", "image_code": "\n// Acidulate Hellscape\n// who said hell didn't taste sweet and sour?\n\n#define R iResolution.xy\n#define N(a,b,c) normalize(vec3(a,b,c))\n\nfloat noise;\n\nvec3 lookAt (vec3 from, vec3 at, vec2 uv, float fov)\n{\n  vec3 z = normalize(at-from);\n  vec3 x = normalize(cross(z, vec3(0,1,0)));\n  vec3 y = normalize(cross(x, z));\n  return normalize(z * fov + uv.x * x + uv.y * y);\n}\n\n// sinful math\nfloat gyroid (vec3 seed)\n{\n    return dot(sin(seed),cos(seed.yzx));\n}\n\n// spicy noise\nfloat fbm (vec3 seed)\n{\n    float result = 0., a = .5;\n    for (int i = 0; i < 8; ++i, a/=2.)\n    {\n        seed.y += result*.2;\n        result += abs(gyroid(seed/a))*a;\n    }\n    return result;\n}\n\n// signed distance function\nfloat map(vec3 p)\n{\n    float dist = 100.;\n    \n    // travel\n    p.z -= iTime*.2;\n    \n    // displace\n    noise = fbm(p*.4);\n    noise = sin(noise*6.+p.z*.2-iTime*.5);\n    dist = p.y - noise*.5;\n    \n    return dist * .5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    vec3 color = vec3(0);\n    \n    // layers\n    const float frames = 3.;\n    for (float f = 0.; f < frames; ++f)\n    {\n        // blue noise scroll by iq https://www.shadertoy.com/view/tlySzR\n        ivec2 p = ivec2(fragCoord);\n        p = (p+(iFrame*int(frames)+int(f))*ivec2(113,127)) & 1023;\n        vec3 blu = texelFetch(iChannel0,p,0).xyz;\n\n        // coordinates\n        vec3 pos = vec3(0,4,3);\n        vec3 at = vec3(0,0,0);\n        vec3 ray = lookAt(pos, at, uv, 1.);\n\n        // raymarch\n        const float count = 20.;\n        float maxDist = 10.;\n        float steps = 0.;\n        float total = 0.;\n        for (steps = count; steps > 0.; --steps) {\n            float dist = map(pos);\n            if (dist < 2.*total/iResolution.y || total > maxDist) break;\n            dist *= 0.9+0.1*blu.z;\n            pos += ray * dist;\n            total += dist;\n        }\n        \n        // shading\n        float shade = steps/count;\n        if (shade > .1 && total < maxDist) {\n\n            // NuSan https://www.shadertoy.com/view/3sBGzV\n            vec2 noff = vec2(.01,0);\n            vec3 normal = normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n\n            // Inigo Quilez color palette https://iquilezles.org/www/articles/palettes/palettes.htm\n            vec3 tint = .6+.4*cos(vec3(1,2,3)*5. + pos.z + pos.y*2.);\n\n            // lighting\n            if (noise > 0.5) {\n                tint *= pow(dot(normal, N(0,-1,2))*.5+.5, 2.);\n                tint += .3*dot(normal, N(1,1,-2))*.5+.5;\n            } else {\n                tint *= dot(normal, N(0,-1,1))*.5+.5;\n                tint += .8*pow(dot(normal, N(0,1,-2))*.5+.5, 2.);\n            }\n            \n            tint *= smoothstep(5.,0.,pos.z);\n            tint *= pow(shade,3.)*3.;\n            tint *= .5+.5*blu.x;\n            color += tint / frames;\n        }\n    }\n    \n    fragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdfGW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 151, 205, 205, 369], [371, 386, 412, 412, 455], [457, 472, 495, 495, 668], [670, 698, 717, 717, 923], [925, 925, 982, 982, 2951]], "test": "untested"}
{"id": "mdfGDX", "name": "[ConcoursJFIG2022] Cyclide", "author": "T_Rex", "description": "Submitted to JFIG 2022 Shadertoy competition.\n\nDon't look too closely to the source, it is full of dirty hacks to meet the deadline ;-)", "tags": ["concoursjfig2022demosoundretrosynth"], "likes": 2, "viewed": 159, "published": 3, "date": "1666875554", "time_retrieved": "2024-07-30T16:24:19.304466", "image_code": "\n// ------------------------------------------------------------------------------\n// Text drawing routines\n// ------------------------------------------------------------------------------\n// From FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n\n//=== original link for citation: https://www.shadertoy.com/view/llySRh\n\n// --- printing chars, integers and floats ---------------------------\n// --- access to the image of ascii code c\n\n// 2 implementations.\n// Use #if 1 for extensive text use (with no appearance change)\n//           Also correct the windows bug ( light framing of chars. )\n\n#if 1 // immediate draw. (allows for superimposition and appearance change).\n\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n    //if (p.x<.25|| p.x>.75 || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5); // strange bug with an old driver\n\treturn textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx(p/16.), dFdy(p/16.) );\n  // variants:\n  //float l = log2(length(fwidth(p/16.*iResolution.xy)));\n  //return textureLod( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), l);\n                   // manual MIPmap to avoid border artifact. Should be textureLod, but don't available everywhere\n}\n#  define draw_char() vec4(0)  // stub the final call function is used\n\n#else // Deferred draw (call draw_char() ). Run and compiles faster.\n      //     First only determine the valid char id at cur pixel \n      //     then call the draw char once at the end.\n\nint char_id = -1; vec2 char_pos; \nvec4 char(vec2 p, int c) {\n    //if ( p.x>.25&& p.x<.75 && p.y>.0&& p.y<1. )  // normal char box\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) // thighly y-clamped to allow dense text\n        char_id = c, char_pos = p;\n    return vec4(0);\n}\nvec4 draw_char() {\n    int c = char_id; vec2 p = char_pos;\n    return c < 0 \n        ? vec4(0,0,0,1e5)\n        : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                       dFdx(p/16.),dFdy(p/16.) );\n}\n#endif\n\n// --- display int4\n#if 0\nvec4 pInt(vec2 p, float n) {  // webGL2 variant with dynamic size\n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .5 )\n        v += char(p, 48+ i%10 );\n    return v;\n}\n#else\nvec4 pInt(vec2 p, float n, float l) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = l-1.0; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n#endif\n\n// --- chars\nint CAPS=0;\n\n\nvec3 tri_draw_text(vec2 uv)\n{\n    vec4 O = vec4(0);\n    \n    vec2 U = (uv - vec2(0.46, .45)) * 10.;\n    \n    caps;\n    CHR_L CHR_A spc;\n    CHR_C CHR_Y CHR_C CHR_L CHR_I CHR_D CHR_E spc;\n    CHR_B CHR_O CHR_R CHR_D CHR_E CHR_L CHR_A CHR_I CHR_S CHR_E;\n        \n    O += draw_char();\n    \n    return O.xxx;\n}\n\n\nvec3 tri_step_09(vec2 uv, float aspect, float t)\n{\n    vec2 orgUV = uv;\n    //orgUV.y /= aspect;\n    orgUV.x *= aspect;\n    \n    uv = 2. * uv - 1.;\n    uv.y /= aspect;\n    \n    // zoom in\n    uv *= 2.3;\n    \n    float time_fade = .3;\n\n    vec3 col = vec3(0.);\n    \n    float radius_all  = .7;\n    float radius_each = .5;\n    \n    float r_inner_lighting = 0.2;\n    float r_outer_lighting = mix(0.1, 2., place(t, 0., time_fade));\n    \n    vec2 center_circles = vec2(-.8, 0.);\n    \n    //col += lighting_effect(uv, vec2(0.1, 0.3), r_inner_lighting, r_outer_lighting, aspect);\n    col += drawCircles_light(uv, radius_each, center_circles, radius_all, t);\n    col *= drawCircles(uv, radius_each, center_circles, radius_all, t);\n    \n    // fade to white at the very end\n    //col = mix(col, vec3(1.), place(t, .4, .6));\n    \n    col += tri_draw_text(orgUV);\n    \n    return col;\n}\n\n\nvec4 scene_0_trilogy(in vec2 uv, float aspect, float t)\n{\n    float time = t * 1.1;\n\n    vec3 col = vec3(0);\n    \n    if (time < 0.3) {\n        col = tri_step_01(uv, aspect, time);\n    } else if (time < 1.3) {\n        // duration 1\n        col = tri_step_02(uv, aspect, time - 0.3);\n    } else if (time < 2.4) {\n        // duration 1.1\n        col = tri_step_03(uv, aspect, time - 1.3);\n    } else if (time < 3.4) {\n        // duration 1\n        col = tri_step_04(uv, aspect, time - 2.4);\n    } else if (time < 3.5) {\n        // duration .1\n        // Black\n    } else if (time < 4.6) {\n        // duration 1.1\n        col = tri_step_05(uv, aspect, time - 3.5);\n    } else if (time < 5.6) {\n        // duration 1\n        // TODO\n        col = tri_step_04(uv, aspect, time - 4.6);\n    } else if (time < 6.7) {\n        // duration 1.1\n        col = tri_step_07(uv, aspect, time - 5.6);\n    } else if (time < 7.7) {\n        // duration 1\n        // TODO\n        col = tri_step_04(uv, aspect, time - 6.7);\n    } else if (time < 9.5) {\n        col = tri_step_09(uv, aspect, time);\n    } else if (time < 13.) {\n        col = tri_step_09(uv, aspect, 9.5);\n    }\n    \n    //col = tri_step_09(uv, aspect, 9.5);\n    \n    return vec4(col,1.0);\n}\n\n\n\nvec4 scene_msg(in vec2 fragCoord, float t)\n{\n    vec4 fragColor = vec4(0);\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    vec4 O = vec4(0);\n    \n    uv = 2. * uv - vec2(1.);\n    uv.x *= aspect;\n    uv = .5 * (uv + vec2(1.));\n    \n    vec2 U = (uv - vec2(0.27, .8)) * 10.;\n    caps CHR_W CHR_A CHR_R CHR_N CHR_I CHR_N CHR_G;\n    \n    U = (uv - vec2(0.15, .65)) * 15.;\n    CHR_T low CHR_H CHR_I CHR_S spc\n    CHR_S CHR_H CHR_A CHR_D CHR_E CHR_R spc;\n    CHR_H CHR_A CHR_S spc;\n    CHR_A;\n    \n    U = (uv - vec2(0.28, .55)) * 15.;\n    CHR_S CHR_O CHR_U CHR_N CHR_D CHR_T CHR_R CHR_A CHR_C CHR_K;\n    \n    U = (uv - vec2(0.05, .4)) * 15.;\n    caps CHR_E low CHR_N CHR_S CHR_U CHR_R CHR_E spc;\n    CHR_T CHR_O spc;\n    CHR_R CHR_E CHR_S CHR_T CHR_A CHR_R CHR_T spc;\n    CHR_I CHR_T spc;\n    CHR_F CHR_R CHR_O CHR_M;\n    \n    U = (uv - vec2(0.05, .3)) * 15.;\n    CHR_T CHR_H CHR_E spc;\n    CHR_B CHR_E CHR_G CHR_I CHR_N CHR_I CHR_N CHR_G spc;\n    CHR_F CHR_O CHR_R spc;\n    CHR_T CHR_H CHR_E spc;\n    CHR_B CHR_E CHR_S CHR_T;\n    \n    U = (uv - vec2(0.28, .2)) * 15.;\n    CHR_E CHR_X CHR_P CHR_E CHR_R CHR_I CHR_E CHR_N CHR_C CHR_E;\n    \n    O += draw_char();\n    \n    fragColor.xyz = O.xxx;\n    \n    if (uv.y > .8){\n        fragColor.gb = vec2(0.);\n    }\n    \n    return fragColor;\n}\n\n\nvec3 scene_3d_cyclide_alone(vec2 uv, float aspect, float t)\n{\n    uv = (2.0f * uv - 1.0f) * vec2(aspect, 1.0f);\n\n    vec3 fragColor = vec3(0.);\n    // set up translation\n    mat4 toWorld = transpose(mat4(\n        0,-2, 0, 0,\n        2, 0, 0, 0,\n        0, 0, 2, 0,\n        0, 0, 0, 1\n    ));\n    \n    vec3 rayOrg = vec3(2., 0., 0.);\n    vec3 rayDir = vec3(-1., uv);\n    \n    Frame frame = Frame(toWorld, inverse(toWorld));\n    \n    // spawn ray\n    Ray ray = Ray(rayOrg, rayDir);\n    float c = 2.;\n    \n    float distanceToSdf = DistanceToCyclide(ray, c, frame);\n    uint iterationID = 0u;\n    const uint maxIterationCount = 64u; \n    \n    // ray march\n    while (distanceToSdf > 1e-2 && iterationID < maxIterationCount) {\n        ray.origin+= ray.direction * distanceToSdf;\n        distanceToSdf = DistanceToCyclide(ray, c, frame);\n        ++iterationID;\n    }\n    \n    // affect color\n    if (distanceToSdf <= 1e-2 ) {\n        SurfaceInfo info = CyclideSurfaceInfo(ray.origin, c, frame);\n        vec3 albedo = vec3(1.);\n                \n        fragColor = pow(vec3(info.normal.xxx * albedo), vec3(1./2.2));\n    } else {\n        fragColor = vec3(0.0f);\n    }\n    \n    return clamp(fragColor, vec3(0.), vec3(1.));\n}\n\n\nvec4 scene_ika_1(vec2 uv, float aspect, float t)\n{\n    vec3 color = vec3(0.);\n    \n    vec2 oUV = uv;\n\n    uv = (2.0f * uv - 1.0f) * vec2(aspect, 1.0f);\n    \n    float end_1 =  3.9 / TEMPO_IKARUGA;\n    float end_2 =  6.9 / TEMPO_IKARUGA;\n    float end_3 = 15.2 / TEMPO_IKARUGA;\n    float end_4 = 21.2 / TEMPO_IKARUGA;\n    float end_5 = 28.0 / TEMPO_IKARUGA;\n    \n    vec2 c_black = vec2(0.0, 0.);\n    float r_black = .15;\n    \n    vec2 c_light = vec2(0., 0.);\n    float r0_light = .1;\n    float r1_light = 10.;\n    \n    float r0_light_e = .3;\n    float r1_light_e = 1.4;\n    \n    vec2 c_black_e = vec2(0.16, 0.);\n    vec2 c_light_e = vec2(0.6, 0.);\n    \n    if (t < end_1) {\n        // Translate black circle\n        float a = pow(place(t, 0., end_1), .3);\n        c_black = mix(vec2(-3., 0.), c_black, a);\n        r_black = mix(2., r_black, a);\n    } else if (t < end_2) {\n        // Reduce light size\n        float a = pow(place(t, end_1, end_2), .3);\n        r0_light = mix(r0_light, r0_light_e, a);\n        r1_light = mix(r1_light, r1_light_e, a);\n    } else if (t < end_3) {\n        // Translate light\n        float a = place(t, end_2, end_3);\n        r0_light = r0_light_e;\n        r1_light = r1_light_e;\n        c_black = mix(c_black, c_black_e, a);\n        c_light = mix(c_light, c_light_e, a);\n    } else /*if (t < end_4)*/ {\n        r0_light = r0_light_e;\n        r1_light = r1_light_e;\n        c_black = c_black_e;\n        c_light = c_light_e;\n    }\n    \n    // Some image space blending\n    color = lighting_effect(uv, c_light, r0_light, r1_light);\n    color.rgb *= drawCircle(uv, c_black, r_black);\n    \n    vec3 c2 = vec3(0.);\n    if (t > end_3) {\n        vec3 c2;\n        c2 = drawCircle(uv, c_black, r_black) > 0.5 ? vec3(.5) : vec3(0.);\n        c2 += lighting_effect(uv, c_light, r0_light, r1_light);\n        float a = min(place(t, end_3, end_4), 1.);\n        color = mix(color, c2, a);\n        \n    } \n    \n    if (t > end_4) {\n        float a = min(place(t, end_4, end_5), 1.);\n        color = mix(color, scene_3d_cyclide_alone(oUV, aspect, t - end_4), a);\n    }\n    \n    return vec4(color, 1.);\n}\n\n\nvec3 scene_3d_cyclide_tex(vec2 uv, float aspect, float t)\n{\n    uv = (2.0f * uv - 1.0f) * vec2(aspect, 1.0f);\n\n    vec3 fragColor = vec3(0.);\n    // set up translation\n    mat4 toWorld = transpose(mat4(\n        0,-2, 0, 0,\n        2, 0, 0, 0,\n        0, 0, 2, 0,\n        0, 0, 0, 1\n    ));\n    \n    vec3 rayOrg = vec3(2., 0., 0.);\n    vec3 rayDir = vec3(-1., uv);\n    \n    // Camera rotation management\n    /*vec4 q_permanent   = GET_PERMANENT_QUAT;\n    vec4 q_interactive = GET_INTERACTIVE_QUAT;\n    \n    vec4 q = mul_quat(q_interactive, q_permanent);\n    mat3 rot_mat = quat_to_rot(q);*/\n    //toWorld = mat4(rot_mat) * toWorld;\n    /*\n    rayOrg = rot_mat * rayOrg;\n    rayDir = normalize(rot_mat * rayDir);\n    */\n    \n    Frame frame = Frame(toWorld, inverse(toWorld));\n    \n    // spawn ray\n    Ray ray = Ray(rayOrg, normalize(rayDir));\n    \n    float cmin = 0.15f;\n    float cmax = 2.0f;\n    float c = cmax;\n    \n    if (t > 6. / TEMPO_IKARUGA && t < 11. / TEMPO_IKARUGA) {\n        float a = t - 5. / TEMPO_IKARUGA;\n        float a2 = (sin(TEMPO_IKARUGA * 3. * 3.14 * a / 4.) * .5 + .5);\n        c = mix(cmin, cmax, a2);\n    } \n    \n    float distanceToSdf = DistanceToCyclide(ray, c, frame);\n    uint iterationID = 0u;\n    const uint maxIterationCount = 64u; \n    \n    // ray march\n    while (distanceToSdf > 1e-2 && iterationID < maxIterationCount) {\n        ray.origin+= ray.direction * distanceToSdf;\n        distanceToSdf = DistanceToCyclide(ray, c, frame);\n        ++iterationID;\n    }\n    \n    // affect color\n    if (distanceToSdf <= 1e-2 ) {\n        SurfaceInfo info = CyclideSurfaceInfo(ray.origin, c, frame);\n        vec2 c_uv = info.uv;\n        vec3 albedo = vec3(1.);\n        \n        //albedo = vec3(mod(cyclide_uv, 1.), 1.);\n        //*\n        if (t < 1. / TEMPO_IKARUGA) {\n            albedo = vec3(1.);\n        } else if (t < 2. / TEMPO_IKARUGA) {\n            albedo = vec3(c_uv, 1.);\n        } else if (t < 3. / TEMPO_IKARUGA) {\n            albedo = checkerboard(c_uv, 8., 18.) ? vec3(1.) : vec3(mod(8. * c_uv, 1.), 0.);\n        } else if (t < 4. / TEMPO_IKARUGA) {\n            albedo = grid(c_uv* vec2(1, 8)) < 0.1 ? vec3(0., 0.3, 1.) : vec3(1.);\n        } else /*if (t < 5. / TEMPO_IKARUGA) */{\n            albedo = !checkerboard(c_uv, 8., 18.) ? vec3(1.) : vec3(1., 0., 0.);\n        }\n        //*/\n        \n        fragColor = vec3(info.normal.xxx * albedo);\n        fragColor = clamp(fragColor, vec3(0.), vec3(1.));\n    } else {\n        fragColor = vec3(0.0f);\n    }\n    \n    return pow(fragColor, vec3(1./2.2));\n}\n\n\nvec4 scene_ika_2(vec2 uv, float aspect, float t)\n{\n    vec3 col = vec3(0.);\n        \n    col = scene_3d_cyclide_tex(uv, aspect, t);\n    \n    return vec4(col, 1.);\n}\n\n\nvec4 scene_3d_cyclide_transition(vec2 uv, float aspect, float t) \n{\n    vec3 fragColor = vec3(0.);\n    \n    float end_1 =         8. / TEMPO_IKARUGA;\n    float end_2 = end_1 + 5. / TEMPO_IKARUGA;\n    float end_3 = end_2 + 13. / TEMPO_IKARUGA;\n    float end_4 = end_3 + 2. / TEMPO_IKARUGA;\n    \n    float end_5 = end_4 + 2. / TEMPO_IKARUGA;\n    float end_6 = end_5 + 2. / TEMPO_IKARUGA;\n\n    uv = (2.0f * uv - 1.0f) * vec2(aspect, 1.0f);\n    \n    mat4 toWorld = transpose(mat4(\n        0,-2, 0, 0,\n        2, 0, 0, 0,\n        0, 0, 2, 0,\n        0, 0, 0, 1\n    ));\n    float c_cyclide = 2.;\n    \n    vec3 rayOrg       = vec3(2., 0., 0.);\n    vec3 rayOrg_final = vec3(1.8, 0., 1.);\n    vec3 rayDir = vec3(-1., uv);\n    \n    vec4 q = quat_from_angle_axis(0., vec3(1., 0., 0));\n    vec4 q_final = quat_from_angle_axis(.5 * M_PI, vec3(1., 0., 0));\n    \n    vec3 light_dir = vec3(1., 0., 0.);\n    // WOW This is ugly... I know sorry :-*\n    if (t < end_1) {\n        float a = place(t, 0., end_1);\n        //q = mul_quat(a * q_final, q);\n        q = mix(q, q_final, a);\n        //\n    } else if (t < end_2) {\n        float a = place(t, end_1, end_2);\n        q = q_final;\n        rayOrg = mix(rayOrg, rayOrg_final, a);\n    } else if (t < end_3) {\n        float a = cos(2. * M_PI * place(t, end_2, end_3)) * .5 + .5;\n        vec4 q_trans = quat_from_angle_axis(4. * M_PI * a, vec3(0., 1., 0.));\n        q = q_final;\n        q = mul_quat(q, q_trans);\n        rayOrg = rayOrg_final;\n    } else {\n        q = q_final;\n        rayOrg = rayOrg_final;\n    }\n    \n    float a = sin(t) * .5 + .5;\n    \n    mat3 rot_mat = quat_to_rot(q);\n    \n    light_dir = rot_mat * light_dir;\n    rayOrg = rot_mat * rayOrg;\n    rayDir = normalize(rot_mat * rayDir);\n    \n    Frame frame = Frame(toWorld, inverse(toWorld));\n    \n    // spawn ray\n    Ray ray = Ray(rayOrg, rayDir);\n    \n    Hit_rec rec;\n    \n    vec3 shading = vec3(0.);\n    if (t < end_5) {\n        if (hit_cyclide(2., frame, ray, rec)) {\n            vec3 albedo = !checkerboard(rec.uv, 8., 18.) ? vec3(1.) : vec3(1., 0., 0.);\n\n            if (t > end_3) {\n                float a = min(place(t, end_3, end_4), 1.);\n                albedo = mix(albedo, rec.normal, a);\n            }\n\n            shading = dot(rec.normal, light_dir) * albedo;\n        }\n    }\n    \n    if (t > end_4 && t < end_5) {\n        float a = min(place(t, end_4, end_5), 1.);\n        vec3 c2 = trace_ray(c_cyclide, frame, ray, 1);\n        shading = mix(shading, c2, a);\n    } else if (t >= end_5){\n        float a = min(place(t, end_5, end_6), 1.);\n\n        vec3 c1 = trace_ray(c_cyclide, frame, ray, 1);\n        vec3 c2 = trace_ray(c_cyclide, frame, ray, 2);\n\n        shading = mix(c1, c2, a);\n    }\n    \n    return vec4(pow(shading, vec3(1./2.2)), 1.);\n}\n\n\nvec4 draw_scene_3d_cyclide_rt(\n    in mat4 toWorld,\n    in float c,\n    in vec4 q_pov,\n    in vec3 rayOrg,\n    in vec3 rayDir) \n{\n    Frame frame = Frame(toWorld, inverse(toWorld));\n\n    mat3 rot_pov_mat = quat_to_rot(q_pov);\n    rayOrg = rot_pov_mat * rayOrg;\n    rayDir = normalize(rot_pov_mat * rayDir);\n    \n    // spawn ray\n    Ray ray = Ray(rayOrg, rayDir);\n    \n    return vec4(pow(trace_ray(c, frame, ray, 2), vec3(1./2.2)), 1.);\n}\n\n\nvec4 draw_scene_3d_cyclide_sky(\n    in mat4 toWorld,\n    in float c,\n    in vec4 q_pov,\n    in vec3 rayOrg,\n    in vec3 rayDir,\n    in vec2 fragCoord,\n    in float t1)\n    \n{\n    vec4 fragColor = vec4(0.);\n    \n    Frame frame = Frame(toWorld, inverse(toWorld));\n    \n    // spawn ray\n    Ray ray = Ray(rayOrg, rayDir);\n\n    float distanceToSdf = DistanceToCyclide(ray, c, frame);\n    uint iterationID = 0u;\n    const uint maxIterationCount = 256u; \n    \n    // ray march\n    while (distanceToSdf > 1e-2 && iterationID < maxIterationCount) {\n        ray.origin+= ray.direction * distanceToSdf;\n        distanceToSdf = DistanceToCyclide(ray, c, frame);\n        ++iterationID;\n    }\n    \n    // skylight\n    //float t1 = iTime;\n    float lengthT = 10.;\n    float tt = fract(t1 / (2.*lengthT)) * lengthT;\n    float x1 = exp(- (tt - lengthT/2.)*(tt - lengthT/2.) / 12.);\n\n    float lengthP = 2.;\n    float tp = fract(t1 / (2.*lengthP)) * lengthP;\n    float x2 = exp(- (tp - lengthP/2.)*(tp - lengthP/2.) / 12.);\n\n    float sunTheta = clamp(x1 * 3.14/2., 0.001, 3.14/2. - 0.001); //(1. - iMouse.y / iResolution.y) * 3.14/2.; \n    float sunPhi   = clamp(fract(.5*t1 / lengthT) * 2.*3.14, 0.01, 2.*3.14); //3.14 + iMouse.x / iResolution.x * 2.*3.14;\n\n    vec3 sunPos = vec3(\n        sin(sunTheta) * cos(sunPhi), \n        cos(sunTheta), \n        sin(sunTheta) * sin(sunPhi)\n    );\n    \n    // affect color\n    if (distanceToSdf <= 1e-2) {\n        uint randomSeed = BayerMatrixCoefficient(\n            uint(fragCoord.x) & 255u,\n            uint(fragCoord.y) & 255u,\n            8u\n        );\n        SurfaceInfo info = CyclideSurfaceInfo(ray.origin, c, frame);\n        vec3 V = normalize(vec3(4, 0, 0) - ray.origin);\n        vec3 L = vec3(1, 0, 0);\n        float s = sign(dot(info.normal, V));\n        vec3 T = s * info.tangent;\n        vec3 B = s * info.bitangent;\n        vec3 N = s * info.normal;\n        vec2 R = vec2(0.5, 0.1);\n        R = texture(iChannel2, info.uv).rg * 0.2;\n        float fr = Brdf_GGX(T, B, N, L, V, R);\n        vec3 Lo = vec3(0);\n        \n        // IS\n        uint sampleCount = 64u;\n        for (uint sampleID = 0u; sampleID < sampleCount; ++sampleID) {\n            float u1 = Urng(randomSeed);\n            float u2 = Urng(randomSeed);\n            Sample s = Sample_GGX(vec2(u1, u2), T, B, N, V, R);\n                           \n            Lo += clamp(skyColor_hack(s.direction.yzx, sunPos), 0., 1.);\n        }\n        \n        fragColor.rgb = Lo / float(sampleCount);\n\n    } else {\n        fragColor.rgb = skyColor_hack(ray.direction.yzx, sunPos);\n    }\n        \n    return fragColor;\n\n}\n\n\nvec4 scene_3d_cyclide_rt(vec2 uv, float aspect, float t)\n{\n    uv = (2.0f * uv - 1.0f) * vec2(aspect, 1.0f);\n\n    vec3 fragColor = vec3(0.);\n    \n    mat4 toWorld = transpose(mat4(\n        0,-2, 0, 0,\n        2, 0, 0, 0,\n        0, 0, 2, 0,\n        0, 0, 0, 1\n    ));\n    \n    float c = 2.;\n    \n    vec3 rayOrg = vec3(1.8, 0., 1.);\n    vec3 rayDir = vec3(-1., uv);\n    \n    float end_1 =         5. / TEMPO_IKARUGA;\n    float end_2 = end_1 + 5. / TEMPO_IKARUGA;\n    float end_3 = end_2 + 12./ TEMPO_IKARUGA;\n    \n    vec4 q_pov = quat_from_angle_axis(M_PI/2., vec3(1., 0., 0));\n    \n    if (t < end_1) {\n        float a = cos(2. * M_PI * place(t, 0., end_1)) * .5 + .5;\n        vec4 q_trans = quat_from_angle_axis(2.*M_PI * a, vec3(0., 1., 0.));        \n        mat3 rot_mat = quat_to_rot(q_trans);\n        toWorld = mat4(rot_mat * mat3(toWorld));\n    } else if (t < end_2) {\n        float a = place(t, end_1, end_2);\n        vec4 q_pov_t = quat_from_angle_axis(2.*M_PI * a, vec3(0., 0., 1.));\n        q_pov = mul_quat(q_pov_t, q_pov);\n    } else if (t < end_3) {\n        float a = cos(6. * M_PI * place(t, end_2, end_3))* .5 + .5;\n        c = mix(1.25, c, a);\n    }\n    Frame frame = Frame(toWorld, inverse(toWorld));\n\n    mat3 rot_pov_mat = quat_to_rot(q_pov);\n    rayOrg = rot_pov_mat * rayOrg;\n    rayDir = normalize(rot_pov_mat * rayDir);\n    \n    // spawn ray\n    Ray ray = Ray(rayOrg, rayDir);\n    \n    return vec4(pow(trace_ray(c, frame, ray, 2), vec3(1./2.2)), 1.);    \n}\n\n\nvec4 scene_cyclide_3d_sky(vec2 uv, in vec2 fragCoord, float aspect, float t)\n{\n    uv = (2.0f * uv - 1.0f) * vec2(aspect, 1.0f);\n\n    vec3 fragColor = vec3(0.);\n    \n    mat4 toWorld = transpose(mat4(\n        0,-2, 0, 0,\n        2, 0, 0, 0,\n        0, 0, 2, 0,\n        0, 0, 0, 1\n    ));\n    \n    float c = 2.f;\n    \n    vec3 rayOrg = vec3(1.8, 0., 1.);\n    vec3 rayDir = vec3(-1., uv);\n    \n    vec4 q_pov = quat_from_angle_axis(-M_PI/2., vec3(1., 0., 0));\n    mat3 rot_pov_mat = quat_to_rot(q_pov);\n    \n    toWorld = mat4(rot_pov_mat * mat3(toWorld));\n    \n    float end_1 = 6. / TEMPO_IKARUGA;\n    float end_2 = end_1 + 2. / TEMPO_IKARUGA;\n    float end_3 = end_2 + 3. / TEMPO_IKARUGA;\n    float end_4 = end_3 + 6. / TEMPO_IKARUGA;\n    \n    vec3 rayOrg_end = vec3(2., 0., 0.);\n\n    if (t < end_1) {\n        // We rotate the Dupin cyclide\n        float a = sin(2. * M_PI * place(t, 0., end_1)) * .5 + .5;\n\n        vec4 q_trans = quat_from_angle_axis(2.*M_PI * a, vec3(0., 0., 1.));        \n        mat3 rot_mat = quat_to_rot(q_trans);\n        toWorld = mat4(rot_mat * mat3(toWorld));\n    } else if (t < end_2) {\n        //float a = sin(2. * 2. * M_PI * place(t, end_1, end_2)) * .5 + .5;\n        //c = mix(2., 0.1, a);\n        float a = place(t, end_1, end_2);\n        rayOrg = mix(rayOrg, rayOrg_end, a);\n        //vec4 q_trans = quat_from_angle_axis(M_PI * a, vec3(0., 1., 0.));\n    } else if (t < end_3) {\n        float a = place(t, end_2, end_3);\n        \n        vec4 q_trans = quat_from_angle_axis(M_PI * a, vec3(0., 1., 0.));        \n        mat3 rot_mat = quat_to_rot(q_trans);\n        toWorld = mat4(rot_mat * mat3(toWorld));\n        \n        rayOrg = rayOrg_end;\n    } else {\n        float a = min(place(t, end_3, end_4), 1.);\n        vec4 q_trans = quat_from_angle_axis(-M_PI, vec3(0., 1., 0.)); \n        mat3 rot_mat = quat_to_rot(q_trans);\n        toWorld = mat4(rot_mat * mat3(toWorld));\n        \n        rayOrg = rayOrg_end;\n        c = mix(c, 0.8, a);\n    }\n\n    return draw_scene_3d_cyclide_sky(\n        toWorld,\n        c,\n        q_pov,\n        rayOrg,\n        normalize(rayDir),\n        fragCoord,\n        iTime * 2.\n    );\n}\n\n\n\nvec4 scene_cyclide_3d_sky_2(vec2 uv, in vec2 fragCoord, float aspect, float a)\n{\n    uv = (2.0f * uv - 1.0f) * vec2(aspect, 1.0f);\n\n    vec3 fragColor = vec3(0.);\n    \n    mat4 toWorld = transpose(mat4(\n        0,-2, 0, 0,\n        2, 0, 0, 0,\n        0, 0, 2, 0,\n        0, 0, 0, 1\n    ));\n    \n    float c = 0.8;\n    \n    vec3 rayOrg = vec3(2., 0., 0.);\n    vec3 rayDir = vec3(-1., uv);\n    \n    vec4 q_pov = quat_from_angle_axis(-M_PI/2., vec3(1., 0., 0));\n    mat3 rot_pov_mat = quat_to_rot(q_pov);\n    \n    toWorld = mat4(rot_pov_mat * mat3(toWorld));\n\n    float end_1 = 6. / TEMPO_IKARUGA;\n    \n    /*\n    float end_2 = end_1 + 2. / TEMPO_IKARUGA;\n    float end_3 = end_2 + 3. / TEMPO_IKARUGA;\n    float end_4 = end_3 + 6. / TEMPO_IKARUGA;*/\n\n    vec4 q_trans = quat_from_angle_axis(-M_PI, vec3(0., 1., 0.)); \n    mat3 rot_mat = quat_to_rot(q_trans);\n    toWorld = mat4(rot_mat * mat3(toWorld));\n\n    //if (t < end_1) {\n         //float a = sin(M_PI/2. * place(t, 0., end_1)) * .5 + .5;\n\n        //float a = place(t, 0., end_1);\n        \n        vec4 q = quat_from_angle_axis(a * -M_PI/2., vec3(1., 0., 0.));\n        mat3 r = quat_to_rot(q);\n    \n        toWorld = mat4(r * mat3(toWorld));\n    /*\n    } else {\n        vec4 q = quat_from_angle_axis(-M_PI/2., vec3(1., 0., 0.));\n        mat3 r = quat_to_rot(q);\n    \n        toWorld = mat4(r * mat3(toWorld));\n    }*/\n    // return vec4(1.);\n\n    return draw_scene_3d_cyclide_sky(\n        toWorld,\n        c,\n        q_pov,\n        rayOrg,\n        normalize(rayDir),\n        fragCoord,\n        iTime * 2.\n    );\n}\n\nvec4 scene_3d_cyclide_rt_to_sky(vec2 uv, in vec2 fragCoord, float aspect, float a)\n{\n    uv = (2.0f * uv - 1.0f) * vec2(aspect, 1.0f);\n\n    vec3 fragColor = vec3(0.);\n    \n    mat4 toWorld = transpose(mat4(\n        0,-2, 0, 0,\n        2, 0, 0, 0,\n        0, 0, 2, 0,\n        0, 0, 0, 1\n    ));\n    \n    float c = 2.;\n        \n    vec3 rayOrg = vec3(1.8, 0., 1.);\n    vec3 rayDir = vec3(-1., uv);    \n    vec4 q_pov = quat_from_angle_axis(M_PI/2., vec3(1., 0., 0));\n            \n    // From vec3 rayOrg = vec3(1.8, 0., 1.);\n    vec4 rt = draw_scene_3d_cyclide_rt(\n        toWorld,\n        c,\n        q_pov,\n        rayOrg,\n        normalize(rayDir)\n    );\n\n    rt = clamp(rt, vec4(0.), vec4(1.));\n\n    q_pov = quat_from_angle_axis(-M_PI/2., vec3(1., 0., 0));\n    mat3 rot_pov_mat = quat_to_rot(q_pov);\n\n    toWorld = mat4(rot_pov_mat * mat3(toWorld));\n\n    vec4 sk = draw_scene_3d_cyclide_sky(\n        toWorld,\n        c,\n        quat_from_angle_axis(0., vec3(1., 0., 0.)),\n        rayOrg,\n        normalize(rayDir),\n        fragCoord,\n        0.\n    );\n\n    sk = clamp(sk, vec4(0.), vec4(1.));\n\n    return mix(rt, sk, a);\n}\n\n\n//\n\n\n\nvec4 draw_scene_3d_cyclide_tex_end(\n    in mat4 toWorld, \n    in float c,\n    in vec3 rayOrg,\n    in vec3 rayDir,\n    in vec2 fragCoord)\n{\n    vec3 fragColor = vec3(0.);\n    /*\n    vec3 rayOrg = vec3(2., 0., 0.);\n    vec3 rayDir = vec3(-1., uv);\n    \n    // Camera rotation management\n    vec4 q_permanent   = GET_PERMANENT_QUAT;\n    vec4 q_interactive = GET_INTERACTIVE_QUAT;\n    \n    vec4 q = mul_quat(q_interactive, q_permanent);\n    mat3 rot_mat = quat_to_rot(q);\n    //toWorld = mat4(rot_mat) * toWorld;\n    \n    rayOrg = rot_mat * rayOrg;\n    rayDir = normalize(rot_mat * rayDir);\n    */\n    Frame frame = Frame(toWorld, inverse(toWorld));\n    \n    // spawn ray\n    Ray ray = Ray(rayOrg, rayDir); \n    \n    float distanceToSdf = DistanceToCyclide(ray, c, frame);\n    uint iterationID = 0u;\n    const uint maxIterationCount = 64u; \n    \n    // ray march\n    while (distanceToSdf > 1e-2 && iterationID < maxIterationCount) {\n        ray.origin+= ray.direction * distanceToSdf;\n        distanceToSdf = DistanceToCyclide(ray, c, frame);\n        ++iterationID;\n    }\n    \n    \n    // affect color\n    if (distanceToSdf <= 1e-2 ) {\n        SurfaceInfo info = CyclideSurfaceInfo(ray.origin, c, frame);\n        vec2 c_uv = info.uv;\n        vec3 albedo = vec3(1.);\n        \n        if (grid(c_uv* vec2(1, 8)) < 0.1) {\n            albedo = vec3(0., 0.3, 1.);\n        }\n        \n        fragColor = vec3(info.normal.xxx * albedo);\n        fragColor = abs(fragColor);//, vec3(0.), vec3(1.));\n    } else {\n        fragColor = vec3(0.0f);\n    }\n    \n    return vec4(pow(fragColor, vec3(1./2.2)), 1.);\n}\n\n\nvec4 scene_3d_cyclide_sky_to_end(vec2 uv, in vec2 fragCoord, float aspect, float a)\n{\n    uv = (2.0f * uv - 1.0f) * vec2(aspect, 1.0f);\n    \n    mat4 toWorld = transpose(mat4(\n        0,-2, 0, 0,\n        2, 0, 0, 0,\n        0, 0, 2, 0,\n        0, 0, 0, 1\n    ));\n    \n    float c = .8;\n    \n    vec3 rayOrg = vec3(2., 0., 0.);\n    vec3 rayDir = vec3(-1., uv);    \n    vec4 q_pov = quat_from_angle_axis(0., vec3(1., 0., 0));\n    mat3 rot_pov_mat = quat_to_rot(q_pov);\n\n    toWorld = mat4(rot_pov_mat * mat3(toWorld));\n\n    vec4 sk = draw_scene_3d_cyclide_sky(\n        toWorld,\n        c,\n        quat_from_angle_axis(0., vec3(1., 0., 0.)),\n        rayOrg,\n        normalize(rayDir),\n        fragCoord,\n        0.\n    );\n\n    sk = clamp(sk, vec4(0.), vec4(1.));\n    \n    vec4 en = draw_scene_3d_cyclide_tex_end(\n        toWorld,\n        c,\n        //quat_from_angle_axis(0., vec3(1., 0., 0.)),\n        rayOrg,\n        normalize(rayDir),\n        fragCoord\n        );\n        \n    return mix(sk, en, a);\n}\n\n\n\nvec4 scene_ika_6(vec2 uv, in vec2 fragCoord, float aspect, float t)\n{\n    float end_1 = 1.5 / TEMPO_IKARUGA;\n    \n    vec4 fragColor = vec4(0.);\n    \n    if (t < end_1) {\n        float a = place(t, 0., end_1);\n        fragColor = scene_3d_cyclide_rt_to_sky(uv, fragCoord, aspect, a);\n    } else {\n        fragColor = scene_cyclide_3d_sky(uv, fragCoord, aspect, t - end_1);\n    }\n    \n    return fragColor;\n}\n\n\nvec4 scene_ika_7(vec2 uv, in vec2 fragCoord, float aspect, float t)\n{\n    vec4 fragColor = vec4(0.);\n    \n    float end_1 =         6. / TEMPO_IKARUGA;\n    float end_2 = end_1 + 6. / TEMPO_IKARUGA;\n    float end_3 = end_2 + 6. / TEMPO_IKARUGA;\n    \n    if (t < end_1) {\n        float a = place(t, 0., end_1);//sin(M_PI/2. * place(t, 0., end_1)) * .5 + .5;\n        fragColor = scene_cyclide_3d_sky_2(uv, fragCoord, aspect, a);\n    } else if (t < end_2) {\n        float a = place(t, end_1, end_2);\n        fragColor = scene_3d_cyclide_sky_to_end(uv, fragCoord, aspect, a);\n    } else if (t < end_3) {\n        float a = place(t, end_2, end_3);\n        \n        uv = (2.0f * uv - 1.0f) * vec2(aspect, 1.0f);\n        mat4 toWorld = transpose(mat4(\n            0,-2, 0, 0,\n            2, 0, 0, 0,\n            0, 0, 2, 0,\n            0, 0, 0, 1\n        ));\n\n        float c = mix(.8, 2., a);\n        vec3 rayOrg = vec3(2., 0., 0.);\n        vec3 rayDir = vec3(-1., uv);    \n        vec4 q_pov = quat_from_angle_axis(0., vec3(1., 0., 0));\n        mat3 rot_pov_mat = quat_to_rot(q_pov);\n\n        toWorld = mat4(rot_pov_mat * mat3(toWorld));\n        \n        fragColor = draw_scene_3d_cyclide_tex_end(\n            toWorld,\n            c,\n            //quat_from_angle_axis(0., vec3(1., 0., 0.)),\n            rayOrg,\n            normalize(rayDir),\n            fragCoord\n            );\n    }\n    \n    \n    return fragColor;\n}\n\n\n\nvec4 ending_1(in vec2 uv, float aspect)\n{\n    vec4 O = vec4(0);\n    vec4 fragColor = vec4(0);\n    \n    uv = 2. * uv - vec2(1.);\n    uv.x *= aspect;\n    uv = .5 * (uv + vec2(1.));\n    \n    vec2 U;\n    U = (uv - vec2(0.4, .7)) * 15.;\n    CHR_D CHR_E CHR_M CHR_O spc CHR_B CHR_Y;\n        \n    U = (uv - vec2(0.25, .5)) * 8.;\n    CHR_T CHR_R CHR_E CHR_X spc CHR_C CHR_R CHR_E CHR_W \n    \n    O += draw_char();\n    \n    fragColor.xyz = O.xxx;\n    \n    return fragColor;\n}\n\n\nvec4 ending_2(in vec2 uv, float aspect)\n{\n    vec4 O = vec4(0);\n    vec4 fragColor = vec4(0);\n    \n    uv = 2. * uv - vec2(1.);\n    uv.x *= aspect;\n    uv = .5 * (uv + vec2(1.));\n    \n    vec2 U;\n\n    U = (uv - vec2(0.16, .72)) * 8.;\n    CHR_S CHR_C CHR_E CHR_N CHR_E spc CHR_O CHR_N CHR_E \n\n    U = (uv - vec2(0.18, .6)) * 15.;    \n    CHR_M CHR_U CHR_S CHR_I CHR_C spc CHR_I CHR_N CHR_S CHR_P CHR_I CHR_R CHR_E CHR_D spc CHR_B CHR_Y \n    \n    U = (uv - vec2(0.1, .3)) * 15.;\n    CHR_L CHR_A spc CHR_T CHR_R CHR_I CHR_L CHR_O CHR_G CHR_I CHR_E spc CHR_D CHR_U spc CHR_S CHR_A CHR_M CHR_E CHR_D CHR_I \n    U = (uv - vec2(0.22, .22)) * 15.;\n    CHR_O CHR_P CHR_E CHR_N CHR_I CHR_N CHR_G spc CHR_T CHR_H CHR_E CHR_M CHR_E;\n    \n    O += draw_char();\n    \n    fragColor.xyz = O.xxx;\n    \n    return fragColor;\n}\n\nvec4 ending_3(in vec2 uv, float aspect)\n{\n    vec4 O = vec4(0);\n    vec4 fragColor = vec4(0);\n    \n    uv = 2. * uv - vec2(1.);\n    uv.x *= aspect;\n    uv = .5 * (uv + vec2(1.));\n    \n    vec2 U;\n\n    U = (uv - vec2(0.14, .72)) * 8.;\n    CHR_M CHR_A CHR_I CHR_N spc CHR_S CHR_C CHR_E CHR_N CHR_E;\n\n    U = (uv - vec2(0.18, .6)) * 15.;    \n    CHR_M CHR_U CHR_S CHR_I CHR_C spc CHR_I CHR_N CHR_S CHR_P CHR_I CHR_R CHR_E CHR_D spc CHR_B CHR_Y;\n    \n    U = (uv - vec2(0.32, .3)) * 15.;\n    CHR_I CHR_K CHR_A CHR_R CHR_U CHR_G CHR_A;\n    \n    U = (uv - vec2(0.22, .22)) * 15.;\n    CHR_H CHR_I CHR_R CHR_O CHR_S CHR_H CHR_I spc CHR_I CHR_U CHR_C CHR_H CHR_I;\n    \n    O += draw_char();\n    \n    fragColor.xyz = O.xxx;\n    \n    return fragColor;\n}\n\n\nvec4 ending_4(in vec2 uv, float aspect)\n{\n    vec4 O = vec4(0);\n    vec4 fragColor = vec4(0);\n    \n    uv = 2. * uv - vec2(1.);\n    uv.x *= aspect;\n    uv = .5 * (uv + vec2(1.));\n    \n    vec2 U;\n\n    U = (uv - vec2(0.26, .72)) * 8.;\n    CHR_T CHR_H CHR_A CHR_N CHR_K CHR_S;\n    \n    U = (uv - vec2(0.34, .5)) * 8.;    \n    CHR_F CHR_O CHR_R;\n    \n    U = (uv - vec2(0.2, .3)) * 8.;\n    CHR_W CHR_A CHR_T CHR_C CHR_H CHR_I CHR_N CHR_G;\n    \n    O += draw_char();\n    \n    fragColor.xyz = O.xxx;\n    \n    return fragColor;\n}\n\n\n\nvec4 scene_end(vec2 uv, in vec2 fragCoord, float aspect, float t)\n{\n    vec4 fragColor = vec4(0.);\n    \n    vec2 org_uv = uv;\n    \n    float end_1 =         2.;\n    float end_2 = end_1 + 5.;\n    float end_3 = end_2 + 5.;\n    float end_4 = end_3 + 5.;\n    \n    float a = min(1., place(t, 0., end_1));\n\n    float s = mix(1., 2., a);\n    \n    uv = vec2(1.)-uv;\n    uv /= mix(1.,.5, a);\n    uv = vec2(1.)-uv;\n    \n    if (uv.x > 0. && uv.y > 0.) {\n        uv = mod(uv, vec2(1.));\n        uv = s * (2.0f * uv - 1.0f) * vec2(aspect, 1.0f);\n        mat4 toWorld = transpose(mat4(\n            0,-2, 0, 0,\n            2, 0, 0, 0,\n            0, 0, 2, 0,\n            0, 0, 0, 1\n        ));\n\n        float c = 2.;\n        \n        if (t > end_1) {\n            float a_c = .5 * cos(t - end_1) + .5;\n            c = mix(.5, 2., a_c);\n        }\n        \n        vec3 rayOrg = vec3(2., 0., 0.);\n        vec3 rayDir = vec3(-1., uv);    \n        vec4 q_pov = quat_from_angle_axis(0., vec3(1., 0., 0));\n        mat3 rot_pov_mat = quat_to_rot(q_pov);\n\n        toWorld = mat4(rot_pov_mat * mat3(toWorld));\n\n        fragColor = draw_scene_3d_cyclide_tex_end(\n            toWorld,\n            c,\n            //quat_from_angle_axis(0., vec3(1., 0., 0.)),\n            rayOrg,\n            normalize(rayDir),\n            fragCoord\n            );\n            \n         //fragColor = vec4(1.);\n    }\n    \n    vec2 t_uv = org_uv;\n    t_uv.x *= 2.;\n\n    if (t_uv.x < 1.) {\n\n        float screen_fade = .1;\n\n        vec4 ending_screen = vec4(0.);\n        float a = 0.;\n\n        if (t > end_1 && t < end_2) {\n            a = min(1., place(t, end_1, end_1 + screen_fade));\n            ending_screen = ending_1(t_uv, aspect/2.);\n        } else if (t < end_3) {\n            a = min(1., place(t, end_2, end_2 + screen_fade));\n            ending_screen = ending_2(t_uv, aspect/2.);\n        } else if (t < end_4) {\n            a = min(1., place(t, end_3, end_3 + screen_fade));\n            ending_screen = ending_3(t_uv, aspect/2.);\n        } else {\n            a = min(1., place(t, end_4, end_4 + screen_fade));\n            ending_screen = ending_4(t_uv, aspect/2.);\n        }\n    \n        fragColor = mix(fragColor, ending_screen, a);\n    }\n    \n    return fragColor;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float time = iTime;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    \n    if (time < END_MSG) {\n        fragColor = scene_msg(fragCoord, time);\n    } else if (time < END_TRILOGY) {\n        fragColor = scene_0_trilogy(uv, aspect, time - END_MSG);\n    } else if (time < END_IKA_1) {\n        fragColor = scene_ika_1(uv, aspect, time - END_TRILOGY);        \n    } else if (time < END_IKA_2) {\n        fragColor = scene_ika_2(uv, aspect, time - END_IKA_1);\n    } else if (time < END_IKA_3) {\n        fragColor = scene_3d_cyclide_transition(uv, aspect, time - END_IKA_2);\n    } else if (time < END_IKA_5 /* 4 & 5 share the same scene */) {\n        fragColor = scene_3d_cyclide_rt(uv, aspect, time - END_IKA_3);\n    } else if (time < END_IKA_6) {\n        fragColor = scene_ika_6(uv, fragCoord, aspect, time - END_IKA_5);\n    } else if (time < END_IKA_7) {\n        fragColor = scene_ika_7(uv, fragCoord, aspect, time - END_IKA_6);\n        //fragColor = scene_cyclide_3d_sky(uv, fragCoord, aspect, time - (END_IKA_5 + 4. / TEMPO_IKARUGA));\n    } else {\n        fragColor = scene_end(uv, fragCoord, aspect, time - END_IKA_7);\n    }\n    \n    \n    //fragColor = scene_3d_cyclide_rt(uv, aspect, time);\n}\n\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TEMPO_IKARUGA 2.5\n\n#define END_MSG      3.\n#define END_TRILOGY (END_MSG + 10.)\n#define END_IKA_1   (END_TRILOGY + 29. / TEMPO_IKARUGA)\n#define END_IKA_2   (END_IKA_1 + 12. / TEMPO_IKARUGA)\n#define END_IKA_3   (END_IKA_2 + 36. / TEMPO_IKARUGA)\n#define END_IKA_4   (END_IKA_3 + 10. / TEMPO_IKARUGA)\n#define END_IKA_5   (END_IKA_4 + 12. / TEMPO_IKARUGA)\n#define END_IKA_6   (END_IKA_5 + 18. / TEMPO_IKARUGA)\n#define END_IKA_7   (END_IKA_6 + 18. / TEMPO_IKARUGA)\n\n#define T_MIN 1e-2\n#define M_PI 3.14159265358979323846\n\n/*\n// ----------------------------------------------------------------------------\n// Retrieve various status states \n// ----------------------------------------------------------------------------\n// We use Buffer A to store misc. info about the camera / mouse position...\n// We expect iChannel0 to have BufferA binded.\n\n#define MOUSE_P            ivec2(0, 0)\n#define INTERACTIVE_VIEW_P ivec2(0, 1)\n#define PERMANENT_VIEW_P   ivec2(1, 0)\n\n#define GET_PREV_MOUSE_STATE (texelFetch(iChannel0, MOUSE_P, 0))\n#define GET_INTERACTIVE_QUAT (texelFetch(iChannel0, INTERACTIVE_VIEW_P, 0))\n#define GET_PERMANENT_QUAT   (texelFetch(iChannel0, PERMANENT_VIEW_P, 0))\n*/\n\n// ----------------------------------------------------------------------------\n// Data structures\n// ----------------------------------------------------------------------------\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\n\nstruct Frame\n{\n    mat4 toWorld;\n    mat4 toStd; // = inverse(toWorld)\n};\n\n\nstruct Hit_rec \n{\n  vec3 position;\n  vec3 normal;\n  float dist;\n  int diff;\n  vec2 uv;\n};\n\nstruct SurfaceInfo {\n    vec2 uv;\n    vec3 tangent, bitangent, normal;\n};\n\n\nstruct Triangle \n{\n    vec3 a, b, c;\n    vec2 uv_a, uv_b, uv_c;\n   \tint diff;\n};\n\nstruct Sample\n{\n    vec3 direction;\n    float pdf;\n};\n\n\nstruct Light\n{\n    vec3 position;\n    vec3 power;\n};\n\n\n// ----------------------------------------------------------------------------\n// Utility functions\n// ----------------------------------------------------------------------------\n\nvec3 inv(vec3 x) \n{\n    return x / dot(x, x);\n}\n\n\nvec3 CyclideToCylinder(vec3 p, float c)\n{\n    return inv(p) - vec3(c, 0, 0);\n}\n\n\nvec3 CylinderToCyclide(vec3 q, float c)\n{\n    return inv(q + vec3(c, 0, 0));\n}\n\n\n// dithering\nuint Dilate(uint x) {\n    x = (x | (x << 8)) & 0x00FF00FFu;\n    x = (x | (x << 4)) & 0x0F0F0F0Fu;\n    x = (x | (x << 2)) & 0x33333333u;\n    x = (x | (x << 1)) & 0x55555555u;\n\n    return x;\n}\n\nuint BitReverse(uint x)\n{\n    x = ((x & 0x55555555u) <<  1u) | ((x & 0xAAAAAAAAu) >>  1u);\n    x = ((x & 0x33333333u) <<  2u) | ((x & 0xCCCCCCCCu) >>  2u);\n    x = ((x & 0x0F0F0F0Fu) <<  4u) | ((x & 0xF0F0F0F0u) >>  4u);\n    x = ((x & 0x00FF00FFu) <<  8u) | ((x & 0xFF00FF00u) >>  8u);\n    x = ((x & 0x0000FFFFu) << 16u) | ((x & 0xFFFF0000u) >> 16u);\n\n    return x;\n}\n\nuint BayerMatrixCoefficient(uint i, uint j, uint matrixSize)\n{\n    uint x = i ^ j;\n    uint y = j;\n    uint z = Dilate(x) | (Dilate(y) << 1);\n    uint b = BitReverse(z) >> (32u - (matrixSize << 1u));\n\n    return b;\n}\n\nfloat BayerMatrixCoefficient_Float(uint i, uint j, uint matrixSize)\n{\n    uint coeff = BayerMatrixCoefficient(i, j, matrixSize); \n    return float(coeff) * exp2(-float(matrixSize << 1u));\n}\n\n/*\n// Projects a point from screen space to a sphere.\n// This routine is used for the arcball camera.\nvec3 project_point(vec2 p, vec2 wh)\n{\n    float width = wh.x;\n    float height = wh.y;\n    \n    float scale = min(width, height) - 1.;\n    float px = (2. * p.x - width + 1.) / scale;\n    float py = (-2. * p.y + height - 1.) / scale;\n    \n    float len_sqr = px * px + py * py;\n    \n    float pz = 0.;\n    \n    if (len_sqr <= .5) {\n        pz = sqrt(1. - len_sqr);\n    } else {\n        pz = .5f / sqrt(len_sqr);\n    }\n    \n    return normalize(vec3(pz, px, py));\n}\n*/\n\n\nbool checkerboard(in vec2 uv, float cols, float lines)\n{\n    uv = vec2(cols, lines) * uv;\n    \n    return (mod(uv.x + floor(mod(uv.y, 2.0)), 2.0) < 1.0);\n}\n\n/*\n// ---------------------------------------\n// Tetrakis Sampler\nfloat TetrakisStd(vec2 P)\n{\n    const uint res = 6u;\n    const uint mask = ~(~0u << res);\n    uvec2 Q = uvec2(float(1u << res) * P);\n    bvec2 b1 = equal(Q, uvec2(0u));\n    bvec2 b2 = equal(Q, uvec2(mask));\n    \n    return float(Q.x == Q.y || Q.x == Q.y + 1u|| Q.x + 1u == Q.y || any(b1) || any(b2));\n}\n\n\nfloat Tetrakis(vec2 P)\n{\n    // mirrored repeat sampler\n    return td(P);\n    vec2 Q = fract(P / 2.0);\n    Q = 1.0f - abs(2.0f * Q - 1.0f);\n    \n    // evaluate the function\n    return TetrakisStd(Q);\n}\n//*/\n\n\nfloat t_grid(vec2 uv)\n{\n    float d = 2e-2;\n\n    return \n        step(abs(uv.x), d) \n      + step(abs(uv.y), d) \n      + step(abs(uv.x - uv.y), 1.5 * d)\n      + step(abs(1. - uv.x), d)\n      + step(abs(1. - uv.y), d);\n}\n\n\nfloat ts_grid(vec2 uv)\n{\n    float d = 2e-2;\n    float st = d / 4.;\n    return \n        smoothstep(abs(uv.x), abs(uv.x) + st, d)\n      + smoothstep(abs(uv.y), abs(uv.y) + st, d)\n      + smoothstep(abs(uv.x - uv.y), abs(uv.x - uv.y) + 2. * 1.5 * st, 1.5 * d)\n      + smoothstep(abs(1. - uv.x), abs(1. - uv.x + st), d)\n      + smoothstep(abs(1. - uv.y), abs(1. - uv.y + st), d);\n}\n\n\nfloat grid(vec2 uv)\n{\n    uv = fract(uv/2.);\n    uv = 2.*uv-1.;\n    return t_grid(abs(uv));\n}\n\n\nfloat place(float x, float a, float b)\n{\n    return (x - a) / (b - a);\n}\n\n\n// URNG\nfloat Urng(inout uint seed)\n{\n    // LCG values from Numerical Recipes\n    seed = 1664525u * seed + 1013904223u;\n    \n    return float(seed) / float(~0u);\n}\n\n\n// -----------------------------------------------------------------------------\n// GGX BSDF\n// specular reflection\nvec3 Reflect(vec3 wi, vec3 wm)\n{\n    return 2.0f * dot(wi, wm) * wm - wi;\n}\n\n\n// microfacet brdf\nfloat Ndf_Std_GGX(vec3 wm)\n{\n    if (wm.z > 0.0f) {\n        return 1.0f / M_PI;\n    }\n\n    return 0.0f;\n}\n\n\nfloat Ndf_GGX(vec3 wm, vec2 r)\n{\n    vec3 mStd = vec3(wm.x / r.x, wm.y / r.y, wm.z);\n    float nrmSqr = dot(mStd, mStd);\n    float nrmSqrSqr = nrmSqr * nrmSqr;\n    vec3 wmStd = mStd * inversesqrt(nrmSqr);\n\n    return Ndf_Std_GGX(wmStd) / (r.x * r.y * nrmSqrSqr);\n}\n\n\nfloat Sigma_Std_GGX(vec3 wi)\n{\n    return (1.0f + wi.z) / 2.0f;\n}\n\n\nfloat Sigma_GGX(vec3 wi, vec2 r)\n{\n    vec3 iStd = vec3(wi.x * r.x, wi.y * r.y, wi.z);\n    float nrm = inversesqrt(dot(iStd, iStd));\n    vec3 wiStd = iStd * nrm;\n\n    return Sigma_Std_GGX(wiStd) / nrm;\n}\n\n\nfloat Gc_GGX(vec3 wo, vec3 wi, vec2 r)\n{\n    if (wi.z > 0.0f && wo.z > 0.0f) {\n        float sigmaI = Sigma_GGX( wi, r);\n        float sigmaO = Sigma_GGX(-wo, r);\n        float tmp1 = wi.z * sigmaO;\n        float tmp2 = wo.z * sigmaI;\n\n        return tmp2 / (tmp1 + tmp2);\n    } else {\n        return 0.0f;\n    }\n}\n\n\nfloat PhaseFunction_GGX(vec3 wi, vec3 wo, vec2 r)\n{\n    vec3 wh = normalize(wi + wo);\n\n    return Ndf_GGX(wh, r) / (4.0f * Sigma_GGX(wi, r));\n}\n\nfloat PhaseFunction_GGX(\n    vec3 T,\n    vec3 B,\n    vec3 N,\n    vec3 L,\n    vec3 V,\n    vec2 R\n) {\n    mat3 TBN = transpose(mat3(T, B, N));\n    vec3 wi = normalize(TBN * V);\n    vec3 wo = normalize(TBN * L);\n\n    return PhaseFunction_GGX(wi, wo, R);\n}\n\n\nfloat Brdf_GGX(vec3 wi, vec3 wo, vec2 r)\n{\n    return PhaseFunction_GGX(wi, wo, r) * Gc_GGX(wo, wi, r);\n}\n\n\nfloat Brdf_GGX(\n    vec3 T,\n    vec3 B,\n    vec3 N,\n    vec3 L,\n    vec3 V,\n    vec2 R)\n{\n    mat3 TBN = transpose(mat3(T, B, N));\n    vec3 wi = normalize(TBN * V);\n    vec3 wo = normalize(TBN * L);\n\n    return Brdf_GGX(wi, wo, R);\n}\n\n\nvec3 ggxSampleImpl(vec3 Ve, float alpha_x, float alpha_y, float U1, float U2)\n{\n    // Section 3.2: transforming the view direction to the hemisphere configuration\n    vec3 Vh = normalize(vec3(alpha_x * Ve.x, alpha_y * Ve.y, Ve.z));\n    // Section 4.1: orthonormal basis (with special case if cross product is zero)\n    float lensq = Vh.x * Vh.x + Vh.y * Vh.y;\n    vec3 T1 = lensq > 0.0f ? vec3(-Vh.y, Vh.x, 0) * inversesqrt(lensq) : vec3(1,0,0);\n    vec3 T2 = cross(Vh, T1);\n    // Section 4.2: parameterization of the projected area\n    float r = sqrt(U1);\n    float phi = 2.0 * M_PI * U2;\n    float t1 = r * cos(phi);\n    float t2 = r * sin(phi);\n    float s = 0.5 * (1.0 + Vh.z);\n    t2 = (1.0 - s)*sqrt(1.0 - t1*t1) + s*t2;\n    // Section 4.3: reprojection onto hemisphere\n    vec3 Nh = t1*T1 + t2*T2 + sqrt(max(0.0f, 1.0f - t1*t1 - t2*t2))*Vh;\n    // Section 3.4: transforming the normal back to the ellipsoid configuration\n    return normalize(vec3(alpha_x * Nh.x, alpha_y * Nh.y, max(0.0f, Nh.z)));\n}\n\n\nvec3 SampleNormal_GGX(vec2 u, vec3 wi, vec2 r)\n{\n    return ggxSampleImpl(wi, r.x, r.y, u.x, u.y);\n}\n\n\nvec3 Sample_GGX(vec2 u, vec3 wi, vec2 r)\n{\n    vec3 wm = SampleNormal_GGX(u, wi, r);\n\n    return Reflect(wi, wm);\n}\n\n\nSample Sample_GGX(\n    vec2 u,\n    vec3 T,\n    vec3 B,\n    vec3 N,\n    vec3 V,\n    vec2 R)\n{\n    mat3 iTBN = mat3(T, B, N);\n    mat3 TBN = transpose(iTBN);\n    vec3 wi = normalize(TBN * V);\n    vec3 wm = SampleNormal_GGX(u, wi, R);\n    vec3 wo = Reflect(wi, wm);\n\n    return Sample(iTBN * wo, Gc_GGX(wo, wi, R));\n}\n\n// ------------------------------------------------------------------------------\n// Quaternion operations\n// ------------------------------------------------------------------------------\n\nvec4 quat_from_angle_axis(in float angle, in vec3 axis)\n{\n    float a = angle / 2.;\n    \n    return vec4(sin(a) * axis, cos(a));\n}\n\n\nvec4 mul_quat(in vec4 q1, in vec4 q2)\n{\n    vec4 res;\n    \n    res.xyz = cross(q1.xyz, q2.xyz) + q1.w * q2.xyz + q2.w * q1.xyz;\n    res.w = q1.w * q2.w - dot(q1.xyz, q2.xyz);\n    \n    return res;\n}\n\n\nmat3 quat_to_rot(in vec4 quat) \n{    \n    float ii = quat[0]*quat[0];\n    float ij = quat[0]*quat[1];\n    float ik = quat[0]*quat[2];\n\n    float jj = quat[1]*quat[1];\n    float jk = quat[1]*quat[2];\n\n    float kk = quat[2]*quat[2];\n\n    float ir = quat[0]*quat[3];\n    float jr = quat[1]*quat[3];\n    float kr = quat[2]*quat[3];\n\n    return mat3(\n        1. - 2.*(jj + kk), 2.*(ij - kr)     , 2.*(ik + jr),\n        2.*(ij + kr)     , 1. - 2.*(ii + kk), 2.*(jk - ir),\n        2.*(ik - jr)     , 2.*(jk + ir)     , 1. - 2.*(ii + jj)\n    );\n}\n\n\n// ----------------------------------------------------------------------------\n// Materials\n// ----------------------------------------------------------------------------\n\n#define DIFF_GREEN        0\n#define DIFF_YELLOW       1\n#define DIFF_CHECKERBOARD 2\n#define DBG_NORMAL        3\n\n\nvec3 eval_diffuse(in Hit_rec rec) {\n    switch (rec.diff) {\n        case DIFF_GREEN:  return vec3(0.0, 0.8, 0.0);\n        case DIFF_YELLOW: return vec3(0.8, 0.8, 0.0);\n        case DIFF_CHECKERBOARD:\n            if (checkerboard(rec.uv, 20., 20.)) {\n                return vec3(.8, 0., 0.);\n            } else {\n                return vec3(.8);\n            }\n        case DBG_NORMAL: return rec.normal;\n        default: return vec3(0.);\n    }\n}\n\n\n// ------------------------------------------------------------------------------\n// SDF routines\n// ------------------------------------------------------------------------------\n\nfloat DistanceToCylinderStd(in vec3 p)\n{\n    return sqrt(dot(p.xy, p.xy)) - 1.0f;\n}\n\n\nfloat DistanceToCyclideStd(in vec3 p, float c)\n{\n    vec3 pInv = inv(p);\n    vec3 pInvStd = pInv - vec3(c, 0, 0);\n    float rInv = DistanceToCylinderStd(pInvStd);\n    vec3 qInv = pInv - normalize(vec3(pInvStd.xy, 0.0f) - vec3(c, 0, 0)) * rInv;   \n    vec3 q = inv(qInv);\n    \n    return min(distance(p, q), distance(p, vec3(0)));\n}\n\n\n// ---------------------------------------\n// sdf routines with frames\nfloat DistanceToCyclide(in Ray ray, float c, in Frame frame)\n{\n    vec4 oStd = frame.toStd * vec4(ray.origin, 1.0f);\n    vec4 dStd = frame.toStd * vec4(ray.direction, 0.0f);\n    float distanceStd = DistanceToCyclideStd(oStd.xyz, c);\n    vec4 o = frame.toWorld * (oStd + dStd * distanceStd);\n    \n    return distance(ray.origin, o.xyz);\n}\n\n\n// ---------------------------------------\n// Cyclide HitInfo\nSurfaceInfo CyclideSurfaceInfoStd(in vec3 p, float c)\n{\n    const float eps = 1e-4f; \n    const float pi = 3.14159265359f;\n    vec3 q = CyclideToCylinder(p, c);\n    float phi = atan(q.y, q.x);\n    vec3 t = vec3(0.0f, 0.0f, 1.0f);\n    vec3 b = vec3(-sin(phi), cos(phi), 0.0f);\n    vec3 qb = q + b * eps;\n    vec3 qt = q + t * eps;\n    vec3 pb = CylinderToCyclide(qb, c);\n    vec3 pt = CylinderToCyclide(qt, c);\n    vec3 tangent = normalize(pt - p);\n    vec3 bitangent = normalize(pb - p);\n    vec3 normal = normalize(cross(tangent, bitangent));\n    float tmp = phi < 0.0 ? phi + 2.0f * pi : phi;\n    vec2 uv = vec2(q.z, tmp / (2.0f * pi));\n    \n    return SurfaceInfo(uv, tangent, bitangent, normal);    \n}\n\n\nSurfaceInfo CyclideSurfaceInfo(in vec3 hitPos, float c, in Frame frame)\n{\n    vec3 pStd = (frame.toStd * vec4(hitPos, 1.0f)).xyz;\n    SurfaceInfo info = CyclideSurfaceInfoStd(pStd, c);\n    \n    info.tangent = normalize((frame.toWorld * vec4(info.tangent, 0.0f)).xyz);\n    info.bitangent = normalize((frame.toWorld * vec4(info.bitangent, 0.0f)).xyz);\n    info.normal = normalize((transpose(frame.toStd) * vec4(info.normal, 0.0f)).xyz);\n    \n    return info;\n}\n\n\n// ------------------------------------------------------------------------------\n// Hit functions\n// ------------------------------------------------------------------------------\n\nbool hit_cyclide(in float c, in Frame frame, in Ray ray, out Hit_rec rec)\n{\n    float dist_cyclide = DistanceToCyclide(ray, c, frame);\n    vec3 start_pos = ray.origin;\n    uint iterationID = 0u;\n    const uint maxIterationCount = 64u;\n    \n    while (dist_cyclide > T_MIN && iterationID < maxIterationCount) {\n        ray.origin += ray.direction * dist_cyclide;\n        dist_cyclide = DistanceToCyclide(ray, c, frame);\n        ++iterationID;\n    }\n    \n    if (dist_cyclide <= T_MIN) {\n        SurfaceInfo info = CyclideSurfaceInfo(ray.origin, c, frame);\n        rec.dist     = length(start_pos - ray.origin);\n        rec.position = ray.origin;\n        rec.normal   = info.normal;//cyclide_normal(ray, c, frame);\n        rec.diff     = DBG_NORMAL;\n        rec.uv       = info.uv;\n    }\n    \n    return dist_cyclide <= T_MIN;\n}\n\n\nbool hit_triangle(in Triangle t, in Ray r, out Hit_rec rec) \n{\n\tvec3 e1 = t.b - t.a;\n    vec3 e2 = t.c - t.a;\n    vec3 q = cross(r.direction, e2);\n    float a = dot(e1, q);\n    \n    // No hit found so far\n    rec.dist = -1.0;\n    \n    if (a < T_MIN) {\n        return false;\n    }\n    \n    float f = 1. / a;\n    vec3 s = r.origin - t.a;\n    float u = f * dot(s, q);\n    \n    if (u < 0. || u > 1.) {\n        return false;\n    }\n    \n    vec3 rt = cross(s, e1);\n    float v = f * dot(r.direction, rt);\n    \n    if (v < 0.0 || (u + v) > 1.0) {\n        return false;\n    }\n    \n    float w = (1. - u - v);\n\n    // Hit found\n    rec.dist     = f * dot(e2, rt);\n    rec.position = r.origin + rec.dist*r.direction;\n    rec.normal   = normalize(cross(e1, e2));\n    rec.diff = t.diff;\n    rec.uv = u * t.uv_b + v * t.uv_c + w * t.uv_a;\n    \n    return true;\n}\n\n\n// ----------------------------------------------------------------------------\n// Scene definition\n// ----------------------------------------------------------------------------\n\n// Lighting\n\nvec3 ambiant = vec3(0.01, 0.01, 0.05);\n\nconst int n_lights = 1;\n\nLight[1] lights = Light[](\n     Light(vec3(3., 4., 3.), vec3(15.))\n);\n\n\n// Geometry\n\nconst int n_triangles = 2;\n\nTriangle[2] triangles = Triangle[](\n    Triangle(\n        // Coords\n        vec3(-5., 0., -5.), \n        vec3(-5., 0.,  5.),\n        vec3( 5., 0., -5.),\n        // uv\n        vec2(0, 0),\n        vec2(1, 0),\n        vec2(0, 1),\n        // Diffuse\n        DIFF_CHECKERBOARD\n    ),\n    Triangle(\n        // Coords\n        vec3(-5., 0.,  5.),\n        vec3( 5., 0.,  5.), \n        vec3( 5., 0., -5.),\n        // uv\n        vec2(1, 0),\n        vec2(1, 1),\n        vec2(0, 1),\n        // Diffuse\n        DIFF_CHECKERBOARD\n    )\n);\n\n\nbool hit(in float c_cyclide, in Frame frame_cyclide, in Ray r_in, inout Hit_rec rec) \n{\n    Hit_rec curr_rec;\n    rec.dist = -1.;\n    \n    bool hit_found = false;\n    \n    // Find closest sphere intersection\n    /*\n    for (int i = 0; i < n_spheres; i++) {\n        if (   hit_sphere(spheres[i], r_in, curr_rec) \n            && (curr_rec.dist < rec.dist || rec.dist < 0.)) {\n            rec = curr_rec;\n            hit_found = true;\n        }\n    }*/\n\n    // Find closest triangle intersection\n    //*\n    for (int i = 0; i < n_triangles; i++) {\n        if (   hit_triangle(triangles[i], r_in, curr_rec)\n            && (curr_rec.dist < rec.dist || rec.dist < 0.)) {\n            rec = curr_rec;\n            hit_found = true;\n        }  \n    }\n    //*/\n    // Cyclide raymarching :-]\n    if (hit_cyclide(c_cyclide, frame_cyclide, r_in, curr_rec)\n        && (curr_rec.dist < rec.dist || rec.dist < 0.)) {\n        rec = curr_rec;\n        hit_found = true;\n    }\n    \n    return hit_found;\n}\n\n\n// Trace ray and return the resulting contribution of this ray\nvec3 trace_ray(in float c_cyclide, in Frame frame_cyclide, in Ray r, in int n_bounces)\n{\n    Hit_rec rec;\n    \n    vec3 ret_col = vec3(0.);\n    vec3 attenuation = vec3(1.);\n    \n    for (int i = 0; i < n_bounces; i++) {\n        if (hit(c_cyclide, frame_cyclide, r, rec)) {\n            // get the diffuse color\n            vec3 diffuse = eval_diffuse(rec);\n                \n            for (int l = 0; l < n_lights; l++) {\n                vec3 light_dir = lights[i].position - rec.position;\n                float light_dist = length(light_dir);\n\n                light_dir = normalize(light_dir);\n\n                // check if in shade: launch a ray from the lightsource to the sphere\n                Ray shadow_ray = Ray(lights[i].position, -light_dir);\n\n                Hit_rec shadow_ray_rec;\n                hit(c_cyclide, frame_cyclide, shadow_ray, shadow_ray_rec);\n\n                if (shadow_ray_rec.dist > light_dist - 100.*T_MIN) {\n                    // BRDF: the geometry is directly light by the lightsource\n                    float lambert = max(0., dot(light_dir, rec.normal));\n                    vec3 light_power = lights[i].power / (light_dist * light_dist);\n                    ret_col += attenuation * diffuse * lambert * light_power;\n                }\n            }\n            \n            // Ambiant lighting, always affecting the hitpoint\n            ret_col += attenuation * ambiant * diffuse;\n            \n            // Generate the reflected ray\n            r.direction = normalize(reflect(r.direction, rec.normal)); \n            r.origin = rec.position + r.direction * 2. * T_MIN;\n            \n            // Compute the Fresnel term using Schlick's approximation\n            float n1 = 1.;\n            float n2 = 2.1;\n            float r0 = (n1 - n2)/(n1 + n2);\n            r0 = r0*r0;\n            float fresnel = r0 + (1. - r0) * pow(1. - dot(rec.normal, r.direction), 5.);\n            \n            attenuation *= fresnel;\n        } else {\n            // No hit found, use the background instead\n            ret_col += attenuation * ambiant;\n            break;\n        }\n    }\n    \n    return ret_col;\n}\n\n\n// ------------------------------------------------------------------------------\n// Text drawing routines\n// ------------------------------------------------------------------------------\n// From FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define nspc  U.x+=.5;\n#define spct  U.x-=.1;\n#define nspct  U.x+=.1;\n#define C(c) O+= char(U,64+CAPS+c); spc\n#define N(n) O+= pInt(U,float(n),log(float(n))/log(10.0)+1.0);\n#define TWO_DEG N(2) spc spct low C(80)\n\n\n#define CHR_A C(1)\n#define CHR_B C(2)\n#define CHR_C C(3)\n#define CHR_D C(4)\n#define CHR_E C(5)\n#define CHR_F C(6)\n#define CHR_G C(7)\n#define CHR_H C(8)\n#define CHR_I C(9)\n#define CHR_J C(10\n#define CHR_K C(11)\n#define CHR_L C(12)\n#define CHR_M C(13)\n#define CHR_N C(14)\n#define CHR_O C(15)\n#define CHR_P C(16)\n#define CHR_Q C(17)\n#define CHR_R C(18)\n#define CHR_S C(19)\n#define CHR_T C(20)\n#define CHR_U C(21)\n#define CHR_V C(22)\n#define CHR_W C(23)\n#define CHR_X C(24)\n#define CHR_Y C(25)\n#define CHR_Z C(26)\n\n\n// ------------------------------------------------------------------------------\n// Trilogie du samedi\n// ------------------------------------------------------------------------------\n\nfloat drawCircle(vec2 uv, vec2 c, float r) \n{\n    uv = uv - c;\n    \n    if (dot(uv, uv) < r*r) {\n        return 0.;\n    } else {\n        return 1.;\n    }\n}\n\n\nvec3 lighting_effect(vec2 uv, vec2 c, float r0, float r1)\n{\n    vec3 col = vec3(0.69, 0.79, 0.73);\n    uv = uv - c;\n    \n    float dist_center = dot(uv, uv);\n    \n    if (dist_center < r0*r0) {\n        return vec3(1.);\n    } else if (dist_center <= r1*r1) {\n        float a = place(dist_center, r0*r0, r1*r1);      \n        return pow(smoothstep(col, vec3(0) , vec3(a)), vec3(15.));\n    }\n    \n    return vec3(0);\n}\n\n\nfloat drawCircles(vec2 uv, float dist, vec2 c, float r, float t)\n{\n    float rot = t / 3.;\n    float theta_1 = -rot + 2.*M_PI/3.;\n    float theta_2 = -rot + 4.*M_PI/3.;\n    float theta_3 = -rot + 2.*M_PI;\n    \n    float ret = 1.;\n    \n    ret *= drawCircle(uv, dist * vec2(cos(theta_1), sin(theta_1)) + c, r/3.);\n    ret *= drawCircle(uv, dist * vec2(cos(theta_2), sin(theta_2)) + c, r/3.);\n    ret *= drawCircle(uv, dist * vec2(cos(theta_3), sin(theta_3)) + c, r/3.);\n    \n    return ret;\n}\n\n\nvec3 drawCircles_light(vec2 uv, float dist, vec2 c, float r, float t)\n{    \n    float rot = t / 3.;\n    float theta_1 = -rot + 2.*M_PI/3.;\n    float theta_2 = -rot + 4.*M_PI/3.;\n    float theta_3 = -rot + 2.*M_PI;\n    \n    vec3 ret = vec3(0);\n    \n    float r0 = r * .2;\n    float r1 = r * 1.;\n    \n    ret += lighting_effect(uv, dist * vec2(cos(theta_1), sin(theta_1)) + c, r0, r1);\n    ret += lighting_effect(uv, dist * vec2(cos(theta_2), sin(theta_2)) + c, r0, r1);\n    ret += lighting_effect(uv, dist * vec2(cos(theta_3), sin(theta_3)) + c, r0, r1);\n    \n    return ret;\n}\n\n\nvec3 tri_step_01(vec2 uv, float aspect, float t)\n{    \n    uv = 2. * uv - 1.;\n    uv.y /= aspect;\n    \n    // zoom out\n    uv *= 5.;\n    \n    float time_fade = .3;\n\n    vec3 col = vec3(0.);\n    \n    float radius_all  = .7;\n    float radius_each = .5;\n    \n    float r_inner_lighting = 0.2;\n    float r_outer_lighting = mix(1., 20., place(t, 0., time_fade));\n    \n    col += lighting_effect(uv, vec2(0), r_inner_lighting, r_outer_lighting);\n    \n    // Highly deformated one\n    col += lighting_effect(vec2(uv.x, 0.015 *uv.y), vec2(0), 0.01, .1);\n    \n    col *= drawCircles(uv, radius_each, vec2(0), radius_all, t);\n    \n    return col;\n}\n\n\nvec3 tri_step_02(vec2 uv, float aspect, float t)\n{    \n    uv = 2. * uv - 1.;\n    uv.y /= aspect;\n        \n    float time_fade = .3;\n\n    vec3 col = vec3(0.);\n    \n    float radius_all  = .7;\n    float radius_each = .5;\n    \n    float r_inner_lighting = 0.2;\n    float r_outer_lighting = mix(0.1, 2., place(t, 0., time_fade));\n    \n    col += lighting_effect(uv, vec2(0), r_inner_lighting, r_outer_lighting);\n    // Highly deformated one\n    col += lighting_effect(vec2(0.015 * uv.x, uv.y), vec2(0), 0.01, .1);\n    \n    col *= drawCircles(uv, radius_each, vec2(0), radius_all, t);\n    \n    // fade to white at the very end\n    col = mix(col, vec3(1.), place(t, .7, .95));\n    \n    return col;\n}\n\n\nvec3 tri_zoom(vec2 uv, float aspect, vec2 c_lighting, vec2 c_tri, float t) \n{\n    uv = 2. * uv - 1.;\n    uv.y /= aspect;\n    \n    // zoom in\n    uv *= .5;\n    \n    // translate\n    //uv.y += .4;\n    \n    float time_fade = 1.;\n\n    vec3 col = vec3(0.);\n    \n    float radius_all  = .8;\n    float radius_each = .4;\n    \n    float r_inner_lighting = 0.1;\n    \n    float a = clamp(2. * place(t, 0., time_fade), 0., 2.);\n    float r_outer_lighting = mix(0.5, 3., a < 1. ? a : 2. - a);\n    vec3 lighting = lighting_effect(uv, c_lighting, r_inner_lighting, r_outer_lighting);\n    \n    lighting *= sin(M_PI * place(t, 0., time_fade));\n    \n    col += lighting;\n    \n    col *= drawCircles(uv, radius_each, c_tri, radius_all, t);\n        \n    return col;\n}\n\n\nvec3 tri_step_03(vec2 uv, float aspect, float t) \n{\n    return tri_zoom(uv, aspect, vec2(-.2, .0), vec2(0, -.35), t);\n}\n\n\nvec3 tri_step_04(vec2 uv, float aspect, float t)\n{\n    uv = 2. * uv - 1.;\n    uv.y /= aspect;\n    \n    // zoom in\n    uv *= 2.;\n    \n    float time_fade = .3;\n\n    vec3 col = vec3(0.);\n    \n    float radius_all  = .7;\n    float radius_each = .5;\n    \n    float r_inner_lighting = 0.2;\n    float r_outer_lighting = mix(0.1, 2., place(t, 0., time_fade));\n    \n    col += lighting_effect(uv, vec2(0), r_inner_lighting, r_outer_lighting);\n    \n    col *= drawCircles(uv, radius_each, vec2(0.1, 0.3), radius_all, t);\n    \n    // fade to white at the very end\n    col = mix(col, vec3(1.), place(t, .4, .6));\n    \n    return col;\n}\n\n\nvec3 tri_step_05(vec2 uv, float aspect, float t)\n{\n    return tri_zoom(uv, aspect, vec2(.2, -.1), vec2(-0.3, .1), t);\n}\n\n\nvec3 tri_step_07(vec2 uv, float aspect, float t)\n{\n    return tri_zoom(uv, aspect, vec2(-.2, -.1), vec2(0.2, .2), t);\n}\n\n\n\n/*\n Skydome\n =======\n\n This is highly untested code... have to be done on time.\n\n It is taking the implementation of the analytical skylight and\n solar radiance models presented in the SIGGRAPH 2012 paper\n\n\n \"An Analytic Model for Full Spectral Sky-Dome Radiance\"\n\n and the 2013 IEEE CG&A paper\n\n \"Adding a Solar Radiance Function to the Hosek Skylight Model\"\n\n both by \n\n Lukas Hosek and Alexander Wilkie\n Charles University in Prague, Czech Republic\n\n\n It is using the albedo 0 and turbidity 1 coefficients from the\n code provided by the authors.\n\n You can get the code (3-clause BSD license) from there:\n https://cgg.mff.cuni.cz/projects/SkylightModelling/\n*/\n\nvec3 hosek_rgb[] = vec3[](\n    vec3(-1.099459e+000, -1.140530e+000, -1.372629e+000),\n    vec3(-1.335146e-001, -1.982747e-001, -4.905585e-001),\n    vec3(-4.083223e+000, -7.512730e+000, -4.100789e+001),\n    vec3(5.919603e+000, 8.403899e+000, 4.122169e+001),\n    vec3(-1.104166e-001, -5.699038e-002, -7.389360e-003),\n    vec3(1.600158e+000, 9.015907e-001, 4.839359e-001),\n    vec3(-1.326538e-006, 3.392161e-002, 6.474757e-003),\n    vec3(4.917807e+000, 4.772522e+000, 3.471755e+000),\n    vec3(5.127716e-001, 5.111184e-001, 5.092936e-001),\n    vec3(-1.169858e+000, -1.165117e+000, -1.523025e+000),\n    vec3(-1.832793e-001, -1.852955e-001, -6.497084e-001),\n    vec3(9.694744e-001, 2.963684e+000, 6.249857e+000),\n    vec3(9.495762e-002, -2.262274e+000, -5.662543e+000),\n    vec3(-4.738918e-002, -1.571683e-001, -1.908402e-002),\n    vec3(2.194171e-001, 6.339974e-001, 5.512810e-001),\n    vec3(1.095749e-001, 4.977879e-002, -2.181049e-005),\n    vec3(3.603604e+000, 7.243307e+000, 2.507663e+000),\n    vec3(3.815119e-001, 4.220053e-001, 4.339598e-001),\n    vec3(-9.665225e-001, -1.169936e+000, -1.035567e+000),\n    vec3(-1.403888e-001, -3.357429e-001, -7.478740e-002),\n    vec3(5.194457e+000, 1.911291e+000, 9.221030e-001),\n    vec3(-1.107607e+000, -2.391074e-001, -2.140047e+000),\n    vec3(-8.135181e-001, -4.791643e-001, -2.374146e-002),\n    vec3(4.969661e+000, 1.446113e+000, 3.795517e-001),\n    vec3(-2.300508e-001, -9.178108e-002, -1.769134e-002),\n    vec3(-2.489350e+000, -4.700239e+000, 7.479831e+000),\n    vec3(1.279158e+000, 8.096219e-001, 7.729303e-001),\n    vec3(-1.292508e+000, -1.060246e+000, -1.271086e+000),\n    vec3(-1.299552e-001, -1.051633e-001, -5.588190e-001),\n    vec3(-2.071404e+000, 5.013829e-001, 6.908023e-001),\n    vec3(-4.752482e-002, 2.832309e+000, 2.096832e+000),\n    vec3(1.215598e+000, -3.707855e-001, -2.453967e-001),\n    vec3(-1.904179e+000, 1.523131e+000, 1.410648e+000),\n    vec3(3.027985e-001, 9.163749e-002, 4.475036e-002),\n    vec3(8.707768e+000, 5.604183e+000, -4.719115e+000),\n    vec3(6.332446e-002, 7.208566e-001, 5.741186e-001),\n    vec3(-9.264666e-001, -1.089753e+000, -9.712598e-001),\n    vec3(-1.696780e-001, -2.382167e-001, -7.033926e-002),\n    vec3(4.574070e+000, 2.360312e+000, 9.167274e-001),\n    vec3(-4.232936e-001, -5.902562e+000, -9.502097e-001),\n    vec3(-7.575833e+000, -8.799894e+000, 3.004684e-001),\n    vec3(5.079755e+000, 1.377692e+000, 4.547054e-001),\n    vec3(-2.576343e-001, -6.131633e-002, -5.929017e-002),\n    vec3(-4.506805e+000, -1.415472e+000, 5.266196e+000),\n    vec3(6.908129e-001, 6.124057e-001, 7.204135e-001),\n    vec3(-1.139072e+000, -1.075481e+000, -1.087457e+000),\n    vec3(-1.796056e-001, -1.242391e-001, -1.888896e-001),\n    vec3(1.923311e+000, 1.425781e+000, 8.156686e-001),\n    vec3(6.788529e+000, 8.810319e+000, 3.101712e-001),\n    vec3(-2.364389e+000, -2.922646e+000, -2.155419e+000),\n    vec3(-1.064041e+000, 1.486520e+000, 1.422205e+000),\n    vec3(1.717010e-001, 3.270580e-002, 9.692261e-002),\n    vec3(1.534681e+000, 3.889783e+000, 3.122404e+000),\n    vec3(5.015810e-001, 4.999482e-001, 4.999430e-001));\n\n\nvec3 hosek_rad[] = vec3[](\n    vec3(1.962684e+000, 1.590330e+000, 9.926518e-001),\n    vec3(1.159831e+000, 1.355401e+000, 1.999494e+000),\n    vec3(4.450588e+000, 1.151412e+000, -4.136109e+000),\n    vec3(5.079633e+000, 1.359116e+001, 1.856270e+001),\n    vec3(4.437388e+000, 5.857714e+000, 1.351028e+001),\n    vec3(4.324573e+000, 8.090833e+000, 1.390238e+001));\n\n\nvoid getCoefs(float solar_elevation, out vec3 config[9]) \n{\n    solar_elevation = pow(solar_elevation / (3.14 / 2.0), (1.0 / 3.0));\n\n    // albedo 0 & turbidity 1\n    for (int i = 0; i < 9; i++) {\n        config[i] = pow(1.0-solar_elevation, 5.0) * hosek_rgb[i]  + \n            5.0  * pow(1.0-solar_elevation, 4.0) * solar_elevation * hosek_rgb[i+9] +\n            10.0*pow(1.0-solar_elevation, 3.0)*pow(solar_elevation, 2.0) * hosek_rgb[i+18] +\n            10.0*pow(1.0-solar_elevation, 2.0)*pow(solar_elevation, 3.0) * hosek_rgb[i+27] +\n            5.0*(1.0-solar_elevation)*pow(solar_elevation, 4.0) * hosek_rgb[i+36] +\n            pow(solar_elevation, 5.0)  * hosek_rgb[i+45];\n\n    }\n\n}\n\n\nvec3 getRad(float solar_elevation) \n{\n    solar_elevation = pow(solar_elevation / (3.14 / 2.0), (1.0 / 3.0));\n\n    // albedo 0 & turbidity 1\n    return \n        pow(1.0-solar_elevation, 5.0) * hosek_rad[0] +\n        5.0*pow(1.0-solar_elevation, 4.0)*solar_elevation * hosek_rad[1] +\n        10.0*pow(1.0-solar_elevation, 3.0)*pow(solar_elevation, 2.0) * hosek_rad[2] +\n        10.0*pow(1.0-solar_elevation, 2.0)*pow(solar_elevation, 3.0) * hosek_rad[3] +\n        5.0*(1.0-solar_elevation)*pow(solar_elevation, 4.0) * hosek_rad[4] +\n        pow(solar_elevation, 5.0) * hosek_rad[5];\n}\n\n\nvec3 radiance_rgb(float solar_elevation, float theta, float gamma)\n{\n    vec3 config[9];\n    getCoefs(solar_elevation, config);\n\n    vec3 rad = getRad(solar_elevation);\n\n    vec3 expM;\n    expM.r = exp(config[4].r * gamma);\n    expM.g = exp(config[4].g * gamma);\n    expM.b = exp(config[4].b * gamma);\n\n    float rayM = cos(gamma)*cos(gamma);\n\n    vec3 mieM = vec3(0.);\n    mieM.r = (1.0 + rayM) / pow((1.0 + config[8].r*config[8].r - 2.0*config[8].r*cos(gamma)), 1.5);\n    mieM.g = (1.0 + rayM) / pow((1.0 + config[8].g*config[8].g - 2.0*config[8].g*cos(gamma)), 1.5);\n    mieM.b = (1.0 + rayM) / pow((1.0 + config[8].b*config[8].b - 2.0*config[8].b*cos(gamma)), 1.5);\n\n    float zenith = sqrt(cos(theta));\n\n    return rad * (1.0 + config[0] * exp(config[1] / (cos(theta) + 0.01))) *\n        (config[2] + config[3] * expM + config[5] * rayM + config[6] * mieM + config[7] * zenith);\n}\n\n\nvec3 skyColor(in vec3 dir, in vec3 sunPos)\n{\n    // below horizon\n    dir.y = max(dir.y, 0.);\n    \n\tdir = normalize(dir);\n    float gamma = acos(dot(dir, sunPos));\n    float theta = acos(dir.y);\n    float elev = 3.14/2. - acos(sunPos.y);\n    \n    return radiance_rgb(elev, theta, gamma) / 10.;\n}\n\n\n// Add an effect for the ground to avoid hard transition\nvec3 skyColor_hack(in vec3 dir, in vec3 sunPos)\n{\n    if (dir.y < .01) {\n        // Bellow the horizon\n        vec3 sk1 = 0.34 * skyColor(vec3(dir.x, 0.01, dir.z), sunPos);\n        vec3 sk2 = skyColor(vec3(dir.x, -dir.y + 0.01, dir.z), sunPos);\n\n        float a =  clamp(place(-dir.y - 0.1, -.1, .1), 0.01, 1.);\n\n        return mix(sk1, sk2, 1. - a);\n    }\n    \n    return skyColor(dir, sunPos);\n}\n", "sound_code": "// ----------------------\n// Basic sound synthetiser\n// ----------------------\n\n// https://mixbutton.com/mixing-articles/music-note-to-frequency-chart/\n\n#define C0\t16.35\n#define D0\t18.35\n#define E0\t20.60\n#define F0\t21.83\n#define G0\t24.50\n#define A0\t27.50\n#define B0\t30.87\n\n#define C1\t32.70\n#define D1\t36.71\n#define E1\t41.20\n#define F1\t43.65\n#define G1\t49.00\n#define A1\t55.00\n#define B1\t61.74\n\n#define C2\t65.41\n#define D2\t73.42\n#define E2\t82.41\n#define F2\t87.31\n#define G2\t98.00\n#define A2\t110.00\n#define B2\t123.47\n\n#define C3\t130.81\n#define D3\t146.83\n#define E3\t164.81\n#define F3\t174.61\n#define G3\t196.00\n#define A3\t220.00\n#define B3\t246.94\n\n#define C4 261.63\n#define D4 293.66\n#define E4 329.63\n#define F4 349.23\n#define G4 392.00\n#define A4 440.00\n#define B4 493.88\n\n#define C5 523.25\n#define D5 587.33\n#define E5 659.25\n#define F5 698.46\n#define G5 783.99\n#define A5 880.00\n#define B5 987.77\n\n#define C6 1046.50\n#define D6 1174.66\n#define E6 1318.51\n#define F6 1396.91\n#define G6 1567.98\n#define A6 1760.00\n#define B6 1975.53\n\n#define C7 2093.00\n#define D7 2349.32\n#define E7 2637.02\n#define F7 2793.83\n#define G7 3135.96\n#define A7 3520.00\n#define B7 3951.07\n\n#define C8 4186.01\n#define D8 4698.63\n#define E8 5274.04\n#define F8 5587.65\n#define G8 6271.93\n#define A8 7040.00\n#define B8 7902.13\n\n#define CS0\t17.32\n#define DS0\t19.45\n#define FS0\t23.12\n#define GS0\t25.96\n#define AS0\t29.14\n\n#define CS1 34.65\n#define DS1 38.89\n#define FS1 46.25\n#define GS1 51.91\n#define AS1 58.27\n\n#define CS2 69.30\n#define DS2 77.78\n#define FS2 92.50\n#define GS2 103.83\n#define AS2 116.54\n\n#define CS3 138.59\n#define DS3 155.56\n#define FS3 185.00\n#define GS3 207.65\n#define AS3 233.08\n\n#define CS4 277.18\n#define DS4 311.13\n#define FS4 369.99\n#define GS4 415.30\n#define AS4 466.16\n\n#define CS5 554.37\n#define DS5 622.25\n#define FS5 739.99\n#define GS5 830.61\n#define AS5 932.33\n\n#define CS6 1108.73\n#define DS6 1244.51\n#define FS6 1479.98\n#define GS6 1661.22\n#define AS6 1864.66\n\n#define CS7 2217.46\n#define DS7 2489.02\n#define FS7 2959.96\n#define GS7 3322.44\n#define AS7 3729.31\n\n#define CS8 4434.92\n#define DS8 4978.03\n#define FS8 5919.91\n#define GS8 6644.88\n#define AS8 7458.62\n\n\nfloat sawtooth(float f, float t)\n{\n    float v = t * f;\n    return v - floor(v);\n}\n\n\nfloat square(float f, float t)\n{\n    return sawtooth(f, t) < .5 ? 0. : 1.;\n}\n\n\nfloat triang(float f, float t)\n{\n    float v = 2. * sawtooth(f, t);\n    \n    return v < 1. ? v : 2. - v;\n}\n\n\nfloat sine(float f, float t)\n{\n    return (sin(6.2831 * f * t) + 1.) / 2.;\n}\n\n\nfloat noise(vec2 p)\n{\n    p = floor(p*2500.0)/2500.0;\n    return fract(dot(sin(p.x * 123.12)*142.,cos(p.y *34.95)*165.47));\n}\n\n\n// -----\n// Instruments\n// -----\n\nstruct Note\n{\n    float start;\n    float len;\n    float freq;\n};\n\n\nfloat play_standard_note(Note note, float track_pos, float time)\n{   \n    float f = note.freq;// + m;\n    float sound = .8*sawtooth(note.freq, time) + .2*triang(note.freq, time);\n    //sound *= 0.6 * (sine(5., time) + 1.) / 2. + 0.4;\n    \n    // Amplitude modulation\n    float ampl_max     = 1.;\n    float ampl_sustain = .6;\n    float attack  = .05;\n    float decay   = .2;\n    float release = .2;\n    \n    float ampl = 0.;\n    \n    float curr_local_time = track_pos - note.start;\n    \n    if (curr_local_time > note.len) {\n        return 0.;\n    }\n    \n    \n    if (curr_local_time < attack) {\n        float alpha = place(curr_local_time, 0., attack);\n        ampl = mix(0., ampl_max, alpha);\n    } else if (curr_local_time < (attack + decay)) {\n        float alpha = place(curr_local_time, attack, attack + decay);\n        ampl = mix(ampl_max, ampl_sustain, alpha);\n    } else if (curr_local_time > (note.len - release)) {\n        float alpha = place(curr_local_time, note.len - release, note.len);\n        ampl = mix(ampl_sustain, 0., alpha);\n    } else {\n        ampl = ampl_sustain;\n    }\n    \n    return ampl * sound;\n}\n\n\nfloat play_bass_note(Note note, float track_pos, float time)\n{   \n    float sound = noise(vec2(note.freq * time));//triang(note.freq, time) + square(note.freq, time);\n    \n    // Amplitude modulation\n    float ampl = 1.;\n    float attack  = .01;\n    float decay   = .5;\n    float release = .05;\n    \n    float curr_local_time = track_pos - note.start;\n    \n    if (curr_local_time > note.len) {\n        return 0.;\n    }\n    \n    \n    if (curr_local_time < attack) {\n        float alpha = place(curr_local_time, 0., attack);\n        ampl = mix(0., ampl, alpha);\n    } else if (curr_local_time < (attack + decay)) {\n        float alpha = place(curr_local_time, attack, attack + decay);\n        ampl = mix( ampl, .1, alpha);\n    } else if (curr_local_time > (note.len - release)) {\n        float alpha = place(curr_local_time, note.len - release, note.len);\n        ampl = mix(.1, 0., alpha);\n    } else {\n        ampl = .1;\n    }\n    \n    return ampl * sound;\n}\n\n\n// ------\n// Melody\n// ------\n\n// -- TRILOGIE DU SAMEDI --\n\n#define N_NOTES_TRILOGY_HIGH 15\nNote[N_NOTES_TRILOGY_HIGH] score_trilogy_high = Note[](\n    Note(0.000000, 1.000000, G4),\n    Note(1.000000, 1.000000, G4),\n    Note(2.000000, 0.500000, G4),\n    Note(2.500000, 0.500000, AS4),\n    Note(3.000000, 1.000000, G4),\n    Note(4.000000, 1.000000, G4),\n    Note(5.000000, 0.500000, G4),\n    Note(5.500000, 0.500000, C5),\n    Note(6.000000, 1.000000, G4),\n    Note(7.000000, 1.000000, G4),\n    Note(8.000000, 0.500000, G4),\n    Note(8.500000, 0.500000, D5),\n    Note(9.000000, 0.500000, G4),\n    Note(9.500000, 0.500000, D4),\n    Note(10.000000, 1.000000, G4)\n);\n\n#define N_NOTES_TRILOGY_LOW 5\nNote[N_NOTES_TRILOGY_LOW] score_trilogy_low = Note[](\n    Note(0.000000, 3.000000, C2),\n    Note(3.000000, 3.000000, DS2),\n    Note(6.000000, 3.000000, G2),\n    Note(9.000000, 1.000000, D3),\n    Note(10.000000, 1.000000, G2)\n);\n\n#define N_NOTES_TRILOGY_P 4\nNote[N_NOTES_TRILOGY_P] score_trilogy_p = Note[](\n    Note(0.  , 1., 100.),\n    Note(3.  , 1., 100.),\n    Note(6.  , 1., 100.),\n    Note(9.  , 1., 100.)\n);\n\n\nvec2 play_trilogy(float time)\n{\n    vec2 sound = vec2(0);\n    \n    // Adjust tempo\n    float t = time * 1.4;\n    \n    for (int i = 0; i < N_NOTES_TRILOGY_HIGH; i++) {\n        if (score_trilogy_high[i].start <= t \n        && (score_trilogy_high[i].start + score_trilogy_high[i].len) >= t) {\n            //sound += .2 * vec2(sin(6.2831*score[i].freq*time));\n            sound += play_standard_note(score_trilogy_high[i], t, time);\n        }\n    }\n        \n    for (int i = 0; i < N_NOTES_TRILOGY_LOW; i++) {\n        if (score_trilogy_low[i].start <= t \n        && (score_trilogy_low[i].start + score_trilogy_low[i].len) >= t) {\n            sound += .8 * play_standard_note(score_trilogy_low[i], t, time);\n        }\n    }\n    \n    for (int i = 0; i < N_NOTES_TRILOGY_P; i++) {\n        if (score_trilogy_p[i].start <= t \n        && (score_trilogy_p[i].start + score_trilogy_p[i].len) >= t) {\n            sound += play_bass_note(score_trilogy_p[i], t, time);\n        }\n    }\n    \n    return sound;\n}\n\n// -- HIKARUGA --\n\n\n#define N_NOTES_HIKARUGA_HIGH_1 23\nNote[N_NOTES_HIKARUGA_HIGH_1] score_ikaruga_high_1 = Note[](\n    Note(0.000000, 2.000000, C4),\n    Note(2.000000, 0.300000, C4),\n    Note(2.300000, 0.300000, C4),\n    Note(2.600000, 0.300000, C4),\n    Note(2.900000, 1.000000, B3),\n    Note(3.900000, 1.000000, G3),\n    Note(4.900000, 2.000000, E3),\n    Note(6.900000, 1.000000, E3),\n    Note(7.900000, 1.000000, G3),\n    Note(8.900000, 1.000000, E3),\n    Note(9.900000, 3.000000, A3),\n    Note(12.900000, 1.000000, A3),\n    Note(13.900000, 1.000000, B3),\n    Note(14.900000, 1.000000, C4),\n    Note(15.900000, 2.000000, C4),\n    Note(17.900000, 0.300000, B3),\n    Note(18.200000, 3.000000, A3),\n    Note(21.200000, 1.000000, A3),\n    Note(22.200000, 1.000000, B3),\n    Note(23.200000, 1.000000, C4),\n    Note(24.200000, 2.000000, B3),\n    Note(26.200000, 0.300000, E3),\n    Note(26.500000, 2.500000, E4)\n);\n\n#define N_NOTES_HIKARUGA_LOW_1 12\nNote[N_NOTES_HIKARUGA_LOW_1] score_ikaruga_low_1 = Note[](\n    Note(0.000000, 3.000000, F2),\n    Note(3.000000, 2.000000, E2),\n    Note(5.000000, 3.000000, C2),\n    Note(8.000000, 2.000000, E2),\n    Note(10.000000, 3.000000, D2),\n    Note(13.000000, 3.000000, F2),\n    Note(16.000000, 2.330000, E2),\n    Note(18.330000, 2.800000, DS2),\n    Note(21.200000, 3.000000, FS2),\n    Note(24.200000, 2.000000, GS2),\n    Note(26.200000, 0.330000, E2),\n    Note(26.500000, 2.500000, A3)\n);\n// DURATION 29.\n\n// :^)\n\n#define N_NOTES_HIKARUGA_HIGH_2 9\nNote[N_NOTES_HIKARUGA_HIGH_2] score_ikaruga_high_2 = Note[](\n    Note(0., 1., A5),\n    Note(0., 1., C6), \n    Note(0., 1., E6),\n    Note(1., 1., A5),\n    Note(1., 1., C6),\n    Note(1., 1., E6),\n    Note(2., 1., A5),\n    Note(2., 1., C6),\n    Note(2., 1., E6)\n);\n\n#define N_NOTES_HIKARUGA_LOW_2 16\nNote[N_NOTES_HIKARUGA_LOW_2] score_ikaruga_low_2 = Note[](\n    Note(0.00, .25, A2),\n    Note(0.25, .25, E2),\n    Note(0.50, .25, A2),\n    Note(0.75, .25, C3),\n    Note(1.00, .25, A2),\n    Note(1.25, .25, E2),\n    Note(1.50, .25, A2),\n    Note(1.75, .25, C3),\n    Note(2.00, .25, A2),\n    Note(2.25, .25, E2),\n    Note(2.50, .25, A2),\n    Note(2.75, .25, C3),\n    Note(3.00, .25, A2),\n    Note(3.25, .25, E2),\n    Note(3.50, .25, A2),\n    Note(3.75, .25, C3)\n);\n// DURATION 12.\n\n// :^)\n\n#define N_NOTES_HIKARUGA_HIGH_3 20\nNote[N_NOTES_HIKARUGA_HIGH_3] score_ikaruga_high_3 = Note[](\n    Note(0.000000, 1.000000, A3),\n    Note(1.000000, 2.000000, E4),\n    Note(3.000000, 1.000000, D4),\n    Note(4.000000, 1.000000, A3),\n    Note(5.000000, 2.000000, E4),\n    Note(7.000000, 1.000000, D4),\n    Note(8.000000, 1.000000, A3),\n    Note(9.000000, 1.000000, B3),\n    Note(10.000000, 0.500000, C4),\n    Note(10.500000, 2.500000, C4),\n    //////////////////////////////\n    Note(13.000000, 1.000000, A3),\n    Note(14.000000, 2.000000, E4),\n    Note(16.000000, 1.000000, D4),\n    Note(17.000000, 1.000000, A3),\n    Note(18.000000, 2.000000, E4),\n    Note(20.000000, 1.000000, D4),\n    Note(21.000000, 1.000000, G4),\n    Note(22.000000, 1.000000, B4),\n    Note(23.000000, 0.500000, A4),\n    Note(23.500000, 2.500000, E4)\n);\n\n#define N_NOTES_HIKARUGA_LOW_3 8\nNote[N_NOTES_HIKARUGA_LOW_3] score_ikaruga_low_3 = Note[](\n    Note(0.000000, 3.000000, A1),\n    Note(3.000000, 1.000000, D2),\n    Note(4.000000, 4.000000, C2),\n    Note(8.000000, 4.000000, A1),\n    /////////////////////////////\n    Note(13.000000, 3.000000, E2),\n    Note(16.000000, 2.000000, G2),\n    Note(18.000000, 4.000000, A2),\n    Note(22.000000, 4.000000, C3)\n);\n// DURATION 26\n\n// :^)\n\n#define N_NOTES_HIKARUGA_HIGH_4 13\nNote[N_NOTES_HIKARUGA_HIGH_4] score_ikaruga_high_4 = Note[](\n    Note(0.000000, 0.500000, A3),\n    Note(0.500000, 0.500000, B3),\n    Note(1.000000, 0.500000, C4),\n    Note(1.500000, 0.500000, E4),\n    Note(2.000000, 1.000000, G4),\n    Note(3.000000, 0.500000, F4),\n    Note(3.500000, 0.500000, E4),\n    Note(4.000000, 1.000000, D4),\n    Note(5.000000, 1.000000, A3),\n    Note(6.000000, 0.500000, D4),\n    Note(6.500000, 0.500000, D4),\n    Note(7.000000, 1.000000, A3),\n    Note(8.000000, 1.000000, E4)\n);\n\n#define N_NOTES_HIKARUGA_LOW_4 7\nNote[N_NOTES_HIKARUGA_LOW_4] score_ikaruga_low_4 = Note[](\n    Note(0.000000, 1.000000, C2),\n    Note(1.000000, 1.000000, E2),\n    Note(2.000000, 1.000000, D2),\n    Note(3.000000, 1.000000, F2),\n    Note(4.000000, 2.000000, G2),\n    Note(6.000000, 2.000000, E2),\n    Note(8.000000, 2.000000, A2)\n);\n// DURATION 10\n\n// :^)\n\n#define N_NOTES_HIKARUGA_HIGH_5 8\nNote[N_NOTES_HIKARUGA_HIGH_5] score_ikaruga_high_5 = Note[](\n    Note(0.000000, 1.000000, E4),\n    Note(1.000000, 0.500000, D4),\n    Note(1.500000, 0.500000, C4),\n    Note(2.000000, 1.000000, B3),\n    Note(3.000000, 2.000000, G3),\n    Note(5.000000, 0.500000, B3),\n    Note(5.500000, 1.500000, B3),\n    Note(7.000000, 3.000000, A3)\n);\n\n\n#define N_NOTES_HIKARUGA_LOW_5 4\nNote[N_NOTES_HIKARUGA_LOW_5] score_ikaruga_low_5 = Note[](\n    Note(0.000000, 2.000000, E2),\n    Note(2.000000, 3.000000, D2),\n    Note(5.000000, 2.000000, B2),\n    Note(7.000000, 3.000000, A2)\n);\n// DURATION 10\n\n\n#define N_NOTES_HIKARUGA_HIGH_6 24\nNote[N_NOTES_HIKARUGA_HIGH_6] score_ikaruga_high_6 = Note[](\n    Note(0.000000, 0.500000, A3),\n    Note(0.500000, 0.500000, B3),\n    Note(1.000000, 0.500000, C4),\n    Note(1.500000, 0.500000, E4),\n    Note(2.000000, 1.000000, A4),\n    Note(3.000000, 1.000000, A4),\n    Note(4.000000, 1.000000, G4),\n    Note(5.000000, 1.000000, F4),\n    Note(6.000000, 1.000000, E4),\n    Note(7.000000, 1.000000, A3),\n    Note(8.000000, 0.500000, A3),\n    Note(8.500000, 0.500000, B3),\n    Note(9.000000, 0.500000, C4),\n    Note(9.500000, 0.500000, E4),\n    Note(10.000000, 1.000000, A4),\n    Note(11.000000, 0.500000, B4),\n    Note(11.500000, 0.500000, C5),\n    Note(12.000000, 1.000000, B4),\n    Note(13.000000, 1.000000, A4),\n    Note(14.000000, 0.500000, B4),\n    Note(14.500000, 1.000000, A4),\n    Note(15.500000, 1.000000, G4),\n    Note(16.500000, 0.500000, F4),\n    Note(17.000000, 1.000000, E4)\n);\n\n#define N_NOTES_HIKARUGA_LOW_6 14\nNote[N_NOTES_HIKARUGA_LOW_6] score_ikaruga_low_6 = Note[](\n    Note(0.000000, 1.000000, F2),\n    Note(1.000000, 1.000000, E2),\n    Note(2.000000, 2.000000, F2),\n    Note(4.000000, 2.000000, E2),\n    Note(6.000000, 2.000000, A2),\n    Note(8.000000, 1.000000, F2),\n    Note(9.000000, 1.000000, E2),\n    Note(10.000000, 2.000000, F2),\n    Note(12.000000, 1.000000, E2),\n    Note(13.000000, 1.000000, A2),\n    Note(14.000000, 1.000000, B2),\n    Note(15.000000, 1.000000, A2),\n    Note(16.000000, 1.000000, B2),\n    Note(17.000000, 1.000000, A2)\n);\n// DURATION 18\n\n#define N_NOTES_HIKARUGA_HIGH_7 18\nNote[N_NOTES_HIKARUGA_HIGH_7] score_ikaruga_high_7 = Note[](\n    Note(0.000000, 1.000000, A3),\n    Note(1.000000, 2.000000, B3),\n    Note(3.000000, 1.000000, E3),\n    Note(4.000000, 2.000000, D4),\n    Note(6.000000, 0.500000, C4),\n    Note(6.500000, 0.500000, B3),\n    Note(7.000000, 1.000000, C4),\n    Note(8.000000, 1.000000, B3),\n    Note(9.000000, 1.000000, A3),\n    Note(10.000000, 2.000000, E3),\n    Note(12.000000, 1.000000, E3),\n    Note(13.000000, 1.000000, G3),\n    Note(14.000000, 0.500000, E3),\n    Note(14.500000, 0.500000, G3),\n    Note(15.000000, 0.500000, A3),\n    Note(15.500000, 0.500000, A3),\n    Note(16.000000, 1.000000, E3),\n    Note(17.000000, 1.000000, A3)\n);\n\n\n#define N_NOTES_HIKARUGA_LOW_7 9\nNote[N_NOTES_HIKARUGA_LOW_7] score_ikaruga_low_7 = Note[](\n    Note(0.000000, 2.000000, E2),\n    Note(2.000000, 2.000000, D2),\n    Note(4.000000, 2.000000, A2),\n    Note(6.000000, 2.000000, F2),\n    Note(8.000000, 2.000000, E2),\n    Note(10.000000, 2.000000, C2),\n    Note(12.000000, 2.000000, A1),\n    Note(14.000000, 2.000000, A2),\n    Note(16.000000, 2.000000, E2)\n);\n// Duration 18\n\n// Basically the same exact thing, shall be factorized in some way\n\nvec2 play_track_ikaruga_1(float time, float t)\n{\n    vec2 sound = vec2(0.);\n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_HIGH_1; i++) {\n        if (score_ikaruga_high_1[i].start <= t \n        && (score_ikaruga_high_1[i].start + score_ikaruga_high_1[i].len) >= t) {\n            sound += play_standard_note(score_ikaruga_high_1[i], t, time);\n        }\n    }\n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_LOW_1; i++) {\n        if (score_ikaruga_low_1[i].start <= t \n        && (score_ikaruga_low_1[i].start + score_ikaruga_low_1[i].len) >= t) {\n            sound += .5 *  play_standard_note(score_ikaruga_low_1[i], t, time);\n        }\n    }\n    \n    return sound;\n}\n\nvec2 play_track_ikaruga_2(float time, float t)\n{\n    vec2 sound = vec2(0.);\n    // Loop = 4 times\n    t = mod(t, 4.);\n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_HIGH_2; i++) {\n        if (score_ikaruga_high_2[i].start <= t \n        && (score_ikaruga_high_2[i].start + score_ikaruga_high_2[i].len) >= t) {\n            sound += .3 * play_standard_note(score_ikaruga_high_2[i], t, time);\n        }\n    }\n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_LOW_2; i++) {\n        if (score_ikaruga_low_2[i].start <= t \n        && (score_ikaruga_low_2[i].start + score_ikaruga_low_2[i].len) >= t) {\n            sound += .5 * play_standard_note(score_ikaruga_low_2[i], t, time);\n        }\n    }\n    \n    return sound;\n}\n\nvec2 play_track_ikaruga_3(float time, float t)\n{\n    vec2 sound = vec2(0.);\n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_HIGH_3; i++) {\n        if (score_ikaruga_high_3[i].start <= t \n        && (score_ikaruga_high_3[i].start + score_ikaruga_high_3[i].len) >= t) {\n            sound += play_standard_note(score_ikaruga_high_3[i], t, time);\n        }\n    }\n    \n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_LOW_3; i++) {\n        if (score_ikaruga_low_3[i].start <= t \n        && (score_ikaruga_low_3[i].start + score_ikaruga_low_3[i].len) >= t) {\n            sound += .5 * play_standard_note(score_ikaruga_low_3[i], t, time);\n        }\n    }\n    \n    return sound;\n}\n\nvec2 play_track_ikaruga_4(float time, float t)\n{\n    vec2 sound = vec2(0.);\n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_HIGH_4; i++) {\n        if (score_ikaruga_high_4[i].start <= t \n        && (score_ikaruga_high_4[i].start + score_ikaruga_high_4[i].len) >= t) {\n            sound += play_standard_note(score_ikaruga_high_4[i], t, time);\n        }\n    }\n    \n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_LOW_4; i++) {\n        if (score_ikaruga_low_4[i].start <= t \n        && (score_ikaruga_low_4[i].start + score_ikaruga_low_4[i].len) >= t) {\n            sound += .5 * play_standard_note(score_ikaruga_low_4[i], t, time);\n        }\n    }\n    \n    return sound;\n}\n\nvec2 play_track_ikaruga_5(float time, float t)\n{\n    vec2 sound = vec2(0.);\n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_HIGH_5; i++) {\n        if (score_ikaruga_high_5[i].start <= t \n        && (score_ikaruga_high_5[i].start + score_ikaruga_high_5[i].len) >= t) {\n            sound += play_standard_note(score_ikaruga_high_5[i], t, time);\n        }\n    }\n    \n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_LOW_5; i++) {\n        if (score_ikaruga_low_5[i].start <= t \n        && (score_ikaruga_low_5[i].start + score_ikaruga_low_5[i].len) >= t) {\n            sound += .5 * play_standard_note(score_ikaruga_low_5[i], t, time);\n        }\n    }\n    \n    return sound;\n}\n\n\nvec2 play_track_ikaruga_6(float time, float t)\n{\n    vec2 sound = vec2(0.);\n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_HIGH_6; i++) {\n        if (score_ikaruga_high_6[i].start <= t \n        && (score_ikaruga_high_6[i].start + score_ikaruga_high_6[i].len) >= t) {\n            sound += play_standard_note(score_ikaruga_high_6[i], t, time);\n        }\n    }\n    \n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_LOW_6; i++) {\n        if (score_ikaruga_low_6[i].start <= t \n        && (score_ikaruga_low_6[i].start + score_ikaruga_low_6[i].len) >= t) {\n            sound += .5 * play_standard_note(score_ikaruga_low_6[i], t, time);\n        }\n    }\n    \n    return sound;\n}\n\nvec2 play_track_ikaruga_7(float time, float t)\n{\n    vec2 sound = vec2(0.);\n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_HIGH_7; i++) {\n        if (score_ikaruga_high_7[i].start <= t \n        && (score_ikaruga_high_7[i].start + score_ikaruga_high_7[i].len) >= t) {\n            sound += play_standard_note(score_ikaruga_high_7[i], t, time);\n        }\n    }\n    \n    for (int i = 0; i < N_NOTES_HIKARUGA_LOW_7; i++) {\n        if (score_ikaruga_low_7[i].start <= t \n        && (score_ikaruga_low_7[i].start + score_ikaruga_low_7[i].len) >= t) {\n            sound += .5 * play_standard_note(score_ikaruga_low_7[i], t, time);\n        }\n    }\n    \n    return sound;\n}\n\nvec2 play_ikaruga(float time)\n{\n    vec2 sound = vec2(0);\n    \n    // Adjust tempo\n    float t = TEMPO_IKARUGA * time;\n    \n    float end_1 = 29.;\n    float end_2 = end_1 + 12.;\n    float end_3 = end_2 + 26.;\n    float end_4 = end_3 + 10.;\n    float end_5 = end_4 + 10.;\n    float end_6 = end_5 + 12.; // repeat 2\n    \n    // a new loop\n    float end_7 = end_6 + 18.;\n    float end_8 = end_7 + 18.;\n    \n    float end_9 = end_8 + 26.;\n    float end_10 = end_9 + 10.;\n    \n    if ( t < end_1) {\n        sound += play_track_ikaruga_1(time, t);\n    } else if (t < end_2) {\n        sound += play_track_ikaruga_2(time, t - end_1);\n    } else if (t < end_3) {\n        sound += play_track_ikaruga_3(time, t - end_2);\n    } else if (t < end_4) {\n        sound += play_track_ikaruga_4(time, t - end_3);\n    } else if (t < end_5) {\n        sound += play_track_ikaruga_5(time, t - end_4);\n    } else if (t < end_6) {\n        sound += play_track_ikaruga_2(time, t - end_5);\n    } else if (t < end_7) {\n        sound += play_track_ikaruga_6(time, t - end_6);\n    } else if (t < end_8) {\n        sound += play_track_ikaruga_7(time, t - end_7);\n    } else if (t < end_9) {\n        sound += play_track_ikaruga_3(time, t - end_8);\n    } else if (t < end_10) {\n        sound += play_track_ikaruga_4(time, t - end_9);\n    } else {\n        sound += play_track_ikaruga_5(time, t - end_10);\n    }\n    \n    return sound;\n}\n\n\nvec2 mainSound(int samp, float time)\n{\n    vec2 sound = vec2(0);\n    \n    if (time < END_MSG) {\n    \n    } else if (time < END_TRILOGY) {\n        sound += play_trilogy(time - END_MSG);\n    } else {\n        sound += play_ikaruga(time - END_TRILOGY);\n    }    \n    \n    return .5 * sound;\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdfGDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2919, 2919, 2969, 2969, 3794], [3797, 3797, 3854, 3854, 5031], [6364, 6364, 6425, 6425, 7580], [7583, 7583, 7633, 7633, 9699], [9702, 9702, 9761, 9761, 12246], [12249, 12249, 12299, 12299, 12413], [12416, 12416, 12483, 12483, 15181], [15184, 15184, 15313, 15313, 15623], [15626, 15626, 15800, 15800, 18234], [18237, 18237, 18295, 18295, 19718], [19721, 19721, 19799, 19799, 21869], [21873, 21873, 21953, 21953, 23439], [23441, 23441, 23525, 23525, 24564], [24573, 24573, 24711, 24711, 26167], [26170, 26170, 26255, 26255, 27171], [27175, 27175, 27244, 27244, 27582], [27585, 27585, 27654, 27654, 28997], [31552, 31552, 31619, 31619, 33785], [33788, 33788, 33843, 33843, 35138]], "test": "untested"}
{"id": "mssGWj", "name": "cone - box intersection", "author": "sympou", "description": "another cone collision. this was a very nice exercise.\nand now, i can finally do something else !!", "tags": ["cone"], "likes": 6, "viewed": 214, "published": 3, "date": "1666829971", "time_retrieved": "2024-07-30T16:24:20.137239", "image_code": "#define coneWidth .25\n\n#define camPos vec2(0.1,0.2)\n#define lineWidth 2.\n\n#define boxDims    vec2(0.1,0.1)\n#define boxOffset0 vec2(0.5,0.5)\n\n// 30/11/22 : just for fun, implementation of a method to avoid conditionals,\n// inspired by https://theorangeduck.com/page/avoiding-shader-conditionals\n// for the following macro, when n > 0, it returns a, else it returns b\n#define comp(n,a,b) (b-a) * max(sign(n),0.) + a\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //rendered color\n    vec3 col = vec3(1.);\n    \n    //distance between pixel and outlines\n    float d = 99999.;\n\n    //distances between ro and the two collisions points\n    vec2 t2 = vec2(0.);\n    \n    \n    ////finding the distances/////\n\n    //initial values    \n    vec2 p = fragCoord;\n    vec2 m = iMouse.xy;\n\n    if ( m == vec2(0) ) m = vec2(0.5,0.5+cos(iTime)*0.1) * iResolution.xy;\n\n    vec2 ro = camPos * iResolution.xy;\n    vec2 boxSize = boxDims * iResolution.xy;\n    vec2 boxOffset = boxOffset0 * iResolution.xy;\n\n\n    ///////// cone - box intersection ///////\n    \n    // there might be a simpler solution !\n\n\n    //direction between mouse and origin\n    vec2 rd  = normalize(m - ro);\n    \n    \n    //t = distance cone - line for each of the 4 faces\n    vec2 ro2 = ro - boxOffset;\n    vec4 t = vec4( (  boxSize - ro2) / (rd - coneWidth),\n                   (- boxSize - ro2) / (rd + coneWidth)).xzyw;\n    \n    //t.xy = ( ro2.x < 0. || t.x < 0. && t.y > 0. ) ? t.yx : t.xy;\n    //t.zw = ( ro2.y < 0. || t.z < 0. && t.w > 0. ) ? t.wz : t.zw;\n    t = comp( min(max(t.xz,-t.yw),ro2).xxyy, t.yxwz, t);\n    \n    vec2 edgeDist = abs(ro2) - boxSize;\n    vec4 mima = vec4(min(t.x,t.z),max(t.x,t.z),min(t.y,t.w),max(t.y,t.w));\n    \n    //where is ro in relation to the box ?\n    if (edgeDist.x>0. && edgeDist.y>0.) {\n        //corner zone\n        \n        //t2.x = (mima.x < 0.) ? 0.     : mima.y;\n        //t2.y = (mima.z < 0.) ? mima.w : mima.z;\n        t2 = comp(mima.xz, vec2(0.,mima.w), mima.yz);\n        \n    } else if (edgeDist.x>0. || edgeDist.y>0.) {\n        //near a face\n        \n        //t  = ( edgeDist.x < edgeDist.y ) ? t : t.zwxy;\n        //t2 = vec2( t.z, (t.x<0.) ? t.w : min(t.x,t.w));\n        t  = comp(edgeDist.x-edgeDist.y, t, t.zwxy);\n        t2 = vec2( t.z, comp(t.x, t.w, min(t.x,t.w)) );\n        \n    } else {\n        //inside\n        \n        //t2 = vec2( 0., (mima.x < 0.) ?  mima.y : mima.x);\n        t2 = vec2( 0., comp(mima.x, mima.y, mima.x) );\n\n    }\n        \n    //t2 = (t2.x>t2.y) ? vec2(0.) : t2;\n    t2 = comp(t2.y-t2.x,0.,t2);\n    \n    //if the obtained point is in the \"corner zone\",\n    //we compute a collision with one of the corners,\n    //using a simplified version of\n    //https://www.shadertoy.com/view/NtGfzt\n    vec2 hit1 = ro2 + rd * t2.x;\n    vec2 hit2 = ro2 + rd * t2.y;\n    vec2 edgeDist1 = abs(hit1) - boxSize;\n    vec2 edgeDist2 = abs(hit2) - boxSize;\n    float cw2 = 1. - coneWidth*coneWidth;\n    \n    if (edgeDist1.x>0. && edgeDist1.y>0.) {\n        vec2 sr = boxSize * sign(hit1) - ro2;\n        float b = dot( sr, rd );\n        float c = dot( sr, sr ) * cw2;\n        float h = sqrt(b*b - c);\n        t2.x = (b - h) / cw2;\n    }\n\n    if (edgeDist2.x>0. && edgeDist2.y>0.) {\n        vec2 sr = boxSize * sign(hit2) - ro2;\n        float b = dot( sr, rd );\n        float c = dot( sr, sr ) * cw2;\n        float h = sqrt(b*b - c);\n        t2.y = (b + h) / cw2;\n    }\n    \n    /////////////////////\n \n \n    //drawing the starting point\n    d = min(d, circleFillDist(p, ro, 2.5));\n    \n    //drawing the box\n    d = min(d, circleFillDist(p, boxOffset, 2.5));\n    d = min(d, boxDist(p-boxOffset, boxSize));\n\n    //drawing the edges of the cone\n    vec2 offset = vec2(rd.y,-rd.x) * coneWidth / sqrt(cw2);\n    d = min(d, segLineDist(p, ro, ro + rd + offset));\n    d = min(d, segLineDist(p, ro, ro + rd - offset));\n\n    //drawing the two resulting circles\n    if ( t2.x > 0. ) {\n        d = min(d, circleDist(p, ro + rd * t2.x, coneWidth * t2.x));\n        d = min(d, circleFillDist(p, ro + rd * t2.x, 2.5));\n    }\n    if ( t2.y > 0. ) {\n        d = min(d, circleDist(p, ro + rd * t2.y, coneWidth * t2.y));\n        d = min(d, circleFillDist(p, ro + rd * t2.y, 2.5));\n    }\n \n    //distance to color\n    d = smoothLine( d / lineWidth );\n    col = min(col, vec3( d ) );\n \n    //showing \"hidden\" line\n    float d2 = segLineDist(p, ro, ro + rd);\n\n    d2 = smoothLine( d2 / lineWidth );\n    col = min(col, vec3( mix(d2,1.,0.85) ) );\n \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "float circleDist(vec2 pos, vec2 pt, float radius) {\n    return abs(length(pos-pt) - radius);\n}\nfloat circleFillDist(vec2 pos, vec2 pt, float radius) {\n    return max(length(pos-pt) - radius, 0.);\n}\nfloat segLineDist(vec2 pos, vec2 a, vec2 b) {\n    vec2 pa = pos-a, ba = b-a;\n    float h = max( dot(pa,ba) / dot(ba,ba), 0.0);\n    return length( pa - ba*h );\n}\nfloat segDist(vec2 pos, vec2 a, vec2 b) {\n    vec2 pa = pos-a, ba = b-a;\n    float h = clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\n    return length( pa - ba*h );\n}\nfloat boxDist(vec2 pos, vec2 b) {\n    vec2 d = abs(pos)-b;\n    return abs(length(max(d,0.0)) + min(max(d.x,d.y),0.0));\n}\nfloat smoothLine( in float x) {\n    float t = clamp(x , 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mssGWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[415, 415, 472, 498, 4490]], "test": "untested"}
{"id": "dssGWj", "name": "cone - line intersection", "author": "sympou", "description": "another interesting cone collision algorithm.", "tags": ["cone"], "likes": 4, "viewed": 175, "published": 3, "date": "1666828705", "time_retrieved": "2024-07-30T16:24:20.943084", "image_code": "#define coneWidth .25\n#define ptPos  vec2(0.5)\n#define camPos vec2(0.1,0.85)\n#define sphereSize 30.\n#define lineWidth 2.\n\n#define lineOrigin vec2(0.5,0.2)\n#define lineNormal normalize(vec2(-.25,.2))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //initial values\n    \n    vec2 p = fragCoord;\n    vec2 m = iMouse.xy;\n\n    if ( m == vec2(0.) ) m = vec2(0.5,0.5+cos(iTime)*0.1) * iResolution.xy;\n    \n    vec2 ro      = camPos     * iResolution.xy;\n    vec2 linePt  = lineOrigin * iResolution.xy;\n    vec2 lineNor = normalize(lineNormal*iResolution.xy);\n    \n    \n    //render color\n    vec3 col = vec3(1.);\n\n    //distance of closest shape\n    float d = 99999.;\n            \n    //direction between mouse and origin\n    vec2  rd  = normalize( m - ro );\n\n    // cone-line intersection (it's simple)\n    float dot1 = dot(lineNor, ro - linePt);\n    float dot2 = dot(lineNor, rd);\n    float tN = - dot1 / (dot2 - coneWidth);\n    float tF = - dot1 / (dot2 + coneWidth);\n    \n    \n    \n    ////drawing the shapes/////\n \n    //drawing the line \n    d = min(d, lineDist(p, linePt, linePt + vec2(-lineNor.y,lineNor.x)));\n \n    //drawing the starting point\n    d = min(d, circleFillDist(p, ro, 2.5));\n\n    //drawing the edges of the cone\n    vec2 offset  = vec2(rd.y,-rd.x) * coneWidth / sqrt(1.-coneWidth * coneWidth);\n    d = min(d, segLineDist(p, ro, ro + rd + offset));\n    d = min(d, segLineDist(p, ro, ro + rd - offset));\n\n    //drawing the two resulting circles\n    if ( tN > 0. ) {\n        d = min(d, circleDist(p, ro + rd * tN, coneWidth * tN));\n        d = min(d, circleFillDist(p, ro + rd * tN, 2.5));\n    }\n    if ( tF > 0. ) {\n        d = min(d, circleDist(p, ro + rd * tF, coneWidth * tF));\n        d = min(d, circleFillDist(p, ro + rd * tF, 2.5));\n    }\n \n    //distance to color\n    d = smoothLine( d / lineWidth );\n    col = min(col, vec3( d ) );\n \n    //showing \"hidden\" line\n    float d2 = segLineDist(p, ro, ro + rd);\n    d2 = smoothLine( d2 / lineWidth );\n    col = min(col, vec3( mix(d2,1.,0.9) ) );\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "float circleDist(vec2 pos, vec2 pt, float radius) {\n    return abs(length(pos-pt) - radius);\n}\nfloat circleFillDist(vec2 pos, vec2 pt, float radius) {\n    return max(length(pos-pt) - radius, 0.);\n}\nfloat segLineDist(vec2 pos, vec2 a, vec2 b) {\n    vec2 pa = pos-a, ba = b-a;\n    float h = max( dot(pa,ba) / dot(ba,ba), 0.0);\n    return length( pa - ba*h );\n}\nfloat lineDist(vec2 pos, vec2 a, vec2 b) {\n    vec2 pa = pos-a, ba = b-a;\n    float h = dot(pa,ba) / dot(ba,ba);\n    return length( pa - ba*h );\n}\nfloat smoothLine( in float x) {\n    float t = clamp(x , 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssGWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 200, 257, 283, 2065]], "test": "untested"}
{"id": "DssGD2", "name": "Quadruple Dragon", "author": "mla", "description": "Four Dragon Curves link up nicely to form a continuous path. Stack based with heuristic short cuts.\n\n<mouse>: move\n'a': show shortcut lines\n'f': fill\n'z': variable angle\n", "tags": ["lsystem", "stack", "dragon", "curve"], "likes": 11, "viewed": 203, "published": 3, "date": "1666825329", "time_retrieved": "2024-07-30T16:24:23.858290", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Quadruple Dragon Curve. mla, 2022.\n//\n// Four Dragon Curves link up nicely to form a continuous path. Stack based with\n// heuristic short cuts.\n//\n// <mouse>: move\n// 'a': show shortcut lines\n// 'f': fill\n// 'z': variable angle\n//\n// Uses an explicit stack to keep track of the recursion.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int maxdepth = 10; // How deeply to recurse\n\n// Dragon Curve L-system\n#define C(turns,offset) (((turns) << 16) | ((offset) & 0xffff)) // Encoding\nconst int A = 0, B = 3, END = -1, L = -1, R = 1;\nconst int program[6] = int[] (C(0,A),C(R,B),C(0,END),C(0,A),C(L,B),C(0,END));\nconst float factor = sqrt(2.0); // Recursive scale factor\n\n// Global state\nvec2 point = vec2(0);         // The drawing point\nvec2 movingpoint = vec2(0); // The moving point\nbool foundmovingpoint = false;\nfloat pathlen = 0.0;          // Cumulative path length\nint windnum = 0;              // Compute winding number here\n\n// Update winding number for segment (q,r)\nvoid polywind(vec2 p, vec2 q, vec2 r) {\n  // NR winding number computation\n  q -= p; r -= p; // Relative to p\n  float t = determinant(mat2(q,r));\n  if (q.y <= 0.0) {\n    if (r.y > 0.0 && t > 0.0) windnum++;\n  } else {\n    if (r.y <= 0.0 && t < 0.0) windnum--;\n  }\n}\n\n// Calculate and draw segment in final level\nfloat drawsegment(vec2 pos, float seglen, float theta, float t) {\n  vec2 seg = seglen*vec2(cos(theta),sin(theta));\n  if (t >= pathlen && t < pathlen+seglen) {\n    foundmovingpoint = true;\n    movingpoint = point + (t-pathlen)/seglen*seg;\n  }\n  vec2 newpoint = point + seg;\n  float d = segment(pos,point,newpoint);\n  polywind(pos,point,newpoint);\n  pathlen += seglen;\n  point = newpoint;\n  return d;\n}\n\nvec2 map(vec2 pos) {\n  pos = (2.0*pos - iResolution.xy)/iResolution.y;\n  pos *= 1.666;\n  return pos;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 pos = map(fragCoord);\n  pos -= vec2(-0.8,0.71);\n  if (iMouse.z > 0.0) pos -= map(iMouse.xy);\n  int stack[maxdepth];\n  float totalpath = 4.0*pow(factor,float(maxdepth+1));\n  float t = mod(iTime,totalpath); // Moving point position\n  float angledelta = 0.0;\n  if (key(CHAR_Z)) angledelta = sin(0.1*PI*iTime)*0.05;\n  float angle = PI/2.0+angledelta;\n  float sfactor = pow(sqrt(1.0+cos(angle)),float(maxdepth));\n  pos *= sfactor;\n  float magic = 0.5*angle; // Segment rotation at each recursion level\n  float d = 1e8, d1 = 1e8; // Line distances\n  float theta = -4.0*angledelta;//0.0;       // Cumulative angle\n  // Draw four curves, which just happen to join up continuously.\n  for (int i = 0; i < 4; i++,theta+=angledelta){\n    int depth = 0;\n    stack[depth++] = B;\n    float seglen = 1.0;\n    while (depth > 0) {\n      int instr = program[stack[depth-1]++];\n      // Decode instruction\n      int turns = instr>>16;\n      int code = instr<<16>>16;\n      theta += float(turns)*angle; // Apply turn\n      if (code == END) {\n        depth--;    // Terminate level & unwind\n        seglen *= factor;\n      } else if (depth == maxdepth) {\n        d = min(d,drawsegment(pos,seglen,theta,t)); // Segment\n      } else {\n        // Compute the end point of the segment at the current level\n        float depthdelta = float(maxdepth-depth);\n        float theta1 = theta + magic*(depthdelta-1.0);\n        // Adjust for segment type\n        if (code == A) theta1 += magic;\n        else theta1 -= magic;\n        float seglenfactor = pow(sqrt(1.0+cos(angle)),depthdelta);\n        vec2 newpoint = point+seglenfactor*seglen*vec2(cos(theta1),sin(theta1));\n        d1 = min(d1,segment(pos,point,newpoint));\n        if (distance(pos,0.5*(point+newpoint)) < seglenfactor*seglen) {\n          // Do the recursion\n          stack[depth++] = code;\n          seglen /= factor;\n        } else {\n          // Modify state as if we had done the full recursion\n          polywind(pos,point,newpoint);\n          point = newpoint;\n          pathlen += seglen*pow(factor,depthdelta);\n          // Each non-final segment also changes theta.\n          if (code == A) theta += angle;\n          else theta -= angle;\n        }\n      }\n    }\n  }\n  polywind(pos,point,vec2(0)); // Just in case rounding error prevents exact closure...\n  float px = fwidth(pos.x);\n  vec3 col = vec3(1,1,0.8);\n  if (!key(CHAR_F) && (windnum&1) != 0) col.gb *= 0.25;\n  if (key(CHAR_A)) col = mix(vec3(0.4), col,smoothstep(0.0,px,d1));\n  col = mix(vec3(0), col,smoothstep(0.0,px,d));\n  if (foundmovingpoint) {\n    col = mix(vec3(0), col,smoothstep(0.0,px,distance(pos,movingpoint)-0.01*sfactor));\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////////////////////\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst float PI = 3.1415927;\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\nconst int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\n// const int CHAR_R = 82;\n// const int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\n// const int CHAR_X = 88;\n// const int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DssGD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1063, 1106, 1145, 1180, 1371], [1373, 1418, 1483, 1483, 1818], [1820, 1820, 1840, 1840, 1922], [1924, 1924, 1979, 1979, 4712]], "test": "untested"}
{"id": "Ddl3W2", "name": "Volumetric Atmosphere Scattering", "author": "kishimisu", "description": "The planet is rendered using classical raymarching, and the atmosphere is a scattered volume rendered on top\nInspired by Sebastian Lague's Video: https://www.youtube.com/watch?v=DxfEbulyFcY\nBased on GPU Gems 2 Chapter 16: \"Accurate Atmospheric Scattering\"", "tags": ["volume", "cycle", "planet", "animation", "atmospheric"], "likes": 38, "viewed": 1079, "published": 3, "date": "1666816591", "time_retrieved": "2024-07-30T16:24:24.825703", "image_code": "#define MAX_DIST 5.\n#define MAX_ITER 200.\n#define EPSILON .001\n\n// Atmosphere colors\n#define scatteringCoefficients vec3(700., 530., 440.)\n\n// Atmosphere thickness\n#define scatteringIntensity   1.0\n\n// Atmosphere height\n#define atmosphereRadius      1.4\n\n#define numInScatteringPoints 8.\n#define numOpticalDepthPoints 8.\n#define planetRadius          1.15\n#define iTime (iTime - 2.)\n\n// I made these functions in a naive way to have more control over the\n// camera and planet animations. Could they be more optimized ? \nfloat progress(float t, float easeInStart, float easeInStop, float easeOutStart, float easeOutStop, float idleTime) {\n    t = mod(t, easeOutStop + idleTime);\n    t = t < easeInStart || t >= easeOutStop ? 0. :\n        t < easeInStop   ? (t - easeInStart) / (easeInStop - easeInStart) :\n        t < easeOutStart ? 1. : 1. - (t - easeOutStart) / (easeOutStop - easeOutStart);\n    return smoothstep(0., 1., t);\n}\n\nfloat progress(float t, float easeInStart, float easeInStop, float idleTime) {\n    t = mod(t, easeInStop + idleTime);\n    t = t < easeInStart || t >= easeInStop  ? 0. : (t - easeInStart) / (easeInStop - easeInStart);\n    return smoothstep(0., 1., t);\n}\n\n// noise and fbm are from https://www.shadertoy.com/view/XtS3DD\nfloat noise(in vec3 p) {\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rz = textureLod(iChannel0, (tap+0.5)/256.0, 0.0).yx;\n\treturn mix(rz.x, rz.y, fp.z);\n}\n\nfloat fbm(in vec3 x) {\n    float rz = 0.;\n    float a = .35;\n    for (int i = 0; i<4; i++) {\n        rz += noise(x)*a;\n        a*=.35;\n        x*= 4.;\n    }\n    return rz;\n}\n\n// ray-sphere intersection\n// returns the near and far intersection points, or a high value if no hit\nvec2 raySphereIntersect(vec3 ro, vec3 rd, float radius) {\n    vec3 offset = ro;\n    float a = 1.;\n    float b = 2. * dot(offset, rd);\n    float c = dot(offset, offset) - radius * radius;\n    float d = b*b - 4.*a*c;\n\n    if (d > 0.) {\n        float s = sqrt(d);\n        float dstNear = max(0., (-b-s)/(2.*a));\n        float dstFar = (-b+s)/(2.*a);\n\n        if (dstFar >= 0.) {\n            return vec2(dstNear, dstFar - dstNear);\n        }\n    }\n    return vec2(1e9);\n}\n\n// Atmoshperic scattering functions\n\nfloat densityAtPoint(vec3 p) {\n    float height = (length(p) - planetRadius) / (atmosphereRadius - planetRadius);\n    return exp(-height * 2.0) * (1. - height);\n}\n\nfloat opticalDepth(vec3 ro, vec3 rd, float rayLength) {\n    float stepSize = rayLength / (numOpticalDepthPoints - 1.);\n    float depth = 0.;\n\n    for (float i = 0.; i < numInScatteringPoints; i++) {\n        float density = densityAtPoint(ro);\n\n        depth += density * stepSize;\n        ro += rd * stepSize;\n    }\n\n    return depth;\n}\n\nvec3 scatteringCoeffs = pow(400./scatteringCoefficients, vec3(4.)) * scatteringIntensity;\n\nvec3 calculateLight(vec3 ro, vec3 rd, float far, vec3 sunDir, vec3 color) {\n    float stepSize = far / (numInScatteringPoints - 1.);\n    vec3 scatterLight = vec3(0.);\n    float viewRayDepth = 0.;\n\n    for (float i = 0.; i < numInScatteringPoints; i++) {\n        viewRayDepth = opticalDepth(ro, -rd, stepSize * float(i));\n        float sunRayLength = raySphereIntersect(ro, sunDir, atmosphereRadius).y;\n        float sunRayDepth = opticalDepth(ro, sunDir, sunRayLength);\n        float density = densityAtPoint(ro);\n        vec3 transmittance = exp(-(sunRayDepth + viewRayDepth) * scatteringCoeffs);\n\n        scatterLight += density * transmittance * scatteringCoeffs * stepSize;\n        ro += rd * stepSize;\n    }\n\n    return color * exp(-viewRayDepth) + scatterLight;\n}  \n\n// Raymarching functions\n\nvec3 rotateX(vec3 p, float t) { return mat3(1, 0, 0, 0, cos(t), -sin(t), 0, sin(t), cos(t)) * p; }\n\nfloat map(vec3 p) {\n    float timer = progress(iTime, 6., 22., 8.);\n    p = rotateX(p, 6.283185*timer);\n\n    float r = fbm(normalize(p)*4.) * 0.8;\n    float terrain = ( length(p) - 0.8 - r ) * .4;\n    \n    return terrain;\n}\n\nvec3 calcNormal(vec3 pos) {\n    vec2 e = vec2(-1.0,1.0)*0.5773*0.01;\n    return normalize( e.xyy*map( pos + e.xyy) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx) );\n}\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 rd = normalize(vec3(uv, -1.));\n    vec3 sunDir = normalize(vec3(sin(iTime), cos(iTime/2.), cos(iTime)));\n    vec3 p, color;\n    \n    // Camera Origin\n    float timer = progress(iTime, 1., 8., 20., 27., 3.);\n    vec3 ro = mix(vec3(0., 0., 3.), vec3(0., 1.1, .5), timer);\n    ro.y += sin(iTime*2.)*.02*timer;\n    \n    // Raymarch the planet surface\n    float i, dist = 0.;\n    for (i = 0.; i < MAX_ITER; i++) {\n        p = ro + dist*rd;\n\n        float sceneDist = map(p);\n        dist += sceneDist;\n\n        if (sceneDist < EPSILON || dist > MAX_DIST) break;\n    }\n    \n    if (i == MAX_ITER || dist > MAX_DIST) { \n        // Didn't hit anything\n        color = vec3(1., .5, .6) * 10000.*pow(smoothstep(.995, 1., clamp(dot(rd, sunDir), 0., 1.)), 4.); // Sun\n    } else {\n        // Colorize surface\n        vec3 normal = calcNormal(p);\n        float light = clamp(dot(normal, sunDir), 0., 1.);\n        \n        color = mix(vec3(0.,.8,0.), vec3(.15,.11,.12)*.5, smoothstep(0.8, 1., length(p))); // Grass\n        color = mix(color, vec3(1.), smoothstep(1.05, 1.15, length(p))); // Snow\n        color *= light;\n    }\n    \n    // Atmosphere intersection\n    vec2 hit = raySphereIntersect(ro, rd, atmosphereRadius);\n    float near = hit.x;\n    float far = min(hit.y, dist - near);\n    \n    if (far > 0.) { \n        // Ray hit atmosphere\n        vec3 nearPoint = ro + rd * (near + EPSILON);\n        color = calculateLight(nearPoint, rd, far - EPSILON * 2., sunDir, color);\n    } \n    \n    fragColor = vec4(color, 1.);\n}\n\n// === easy adaptive sampling. === https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n    }\n    O.rgb = pow(O.rgb, vec3(0.4545));\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ddl3W2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[384, 520, 637, 637, 928], [930, 930, 1008, 1008, 1182], [1184, 1248, 1272, 1272, 1488], [1490, 1490, 1512, 1512, 1663], [1665, 1767, 1824, 1824, 2234], [2273, 2273, 2303, 2303, 2435], [2437, 2437, 2492, 2492, 2773], [2866, 2866, 2941, 2941, 3635], [3665, 3665, 3696, 3696, 3763], [3765, 3765, 3784, 3784, 3988], [3990, 3990, 4017, 4017, 4211], [4213, 4213, 4271, 4271, 5856], [5858, 5963, 5999, 5999, 6240]], "test": "untested"}
{"id": "ddXGD2", "name": "Circle Joiny Thingy", "author": "SnoopethDuckDuck", "description": "quick and messy idea, might be cool to have a whole bunch of these in a grid or something", "tags": ["e"], "likes": 9, "viewed": 239, "published": 3, "date": "1666803765", "time_retrieved": "2024-07-30T16:24:25.724301", "image_code": "// Maths and stuff:\n// http://jwilson.coe.uga.edu/EMAT6680Su06/Swanagan/Assignment7/BSAssignment7.html\n\n#define pi 3.14159\n#define k 1. / iResolution.y\n\nvec2 getCircle(vec2 uv, vec2 p1, float r1, vec2 p2, float r2, float a) {\n     // maths and stuff\n    vec2 e = p2 - r2 * vec2(cos(a), sin(a));\n    vec2 f = e  + r1 * vec2(cos(a), sin(a));\n    vec2 g = 0.5 * (f + p1);\n    \n    // intersect 2 lines to find 3rd point\n    float v1 = (f.y - p1.y) / (f.x - p1.x);\n    float v2 = (f.y - p2.y) / (f.x - p2.x);\n    vec2 p3;\n    p3.x = (g.x + v1 * v2 * f.x + v1 * (g.y - f.y)) / (v1 * v2 + 1.);\n    p3.y = v2 * (p3.x - f.x) + f.y;\n        \n    return p3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = (fragCoord - 0.5 * res) / res.y;\n    \n    // first 2 circles\n    vec2 p1 = vec2(0.1, 0.1 * cos(0.5 * iTime));\n    vec2 p2 = vec2(-0.3, 0.1 * sin(0.5 * iTime));\n    float l = length(p1 - p2);\n    float r1 = (0.3 + 0.2 * cos(iTime)) * l;\n    float r2 = (0.3 + 0.2 * sin(iTime)) * l;\n    \n    float d1 = length(uv - p1);\n    float d2 = length(uv - p2);\n    float s1 = smoothstep(-k, k, 2. * k - abs(d1 - r1));\n    float s2 = smoothstep(-k, k, 2. * k - abs(d2 - r2));\n     \n    // angle from p2 circle where p3 circle is tangent\n    float a = atan(p2.y - p1.y, p2.x - p1.x);\n    float av = 0.4 * pi; // abs(av) < 0.5 I think\n    vec2 p3 = getCircle(uv, p1, r1, p2, r2, a + av);\n    float r3 = length(p3 - p2) - r2;\n    vec2 e1 = p3 + normalize(p2 - p3) * r3;\n    vec2 e2 = p3 + normalize(p1 - p3) * r3;\n    float de1 = length(uv - e1);\n    float de2 = length(uv - e2);\n    float se1 = smoothstep(-k, k, 0.01 - de1);\n    float se2 = smoothstep(-k, k, 0.01 - de2);\n\n    float d3 = length(uv - p3);\n    float s3 = smoothstep(-k, k, d3 - r3 + 2. * k);\n    \n    vec2 p4 = getCircle(uv, p1, r1, p2, r2, a - av);\n    float r4 = length(p4 - p2) - r2;\n    vec2 e3 = p4 + normalize(p2 - p4) * r4;\n    vec2 e4 = p4 + normalize(p1 - p4) * r4;\n    float de3 = length(uv - e3);\n    float de4 = length(uv - e4);\n    float se3 = smoothstep(-k, k, 0.01 - de3);\n    float se4 = smoothstep(-k, k, 0.01 - de4);\n\n    float d4 = length(uv - p4);\n    float s4 = smoothstep(-k, k, d4 - r4 + 2. * k);\n    \n    float left  = min(min(e1.x,e2.x),min(e3.x,e4.x));\n    float right = max(max(e1.x,e2.x),max(e3.x,e4.x));\n    float top   = min(min(e1.y,e2.y),min(e3.y,e4.y));\n    float bot   = max(max(e1.y,e2.y),max(e3.y,e4.y));\n    float avx = 0.5 * (left + right);\n    float avy = 0.5 * (bot + top);   \n    float w = right - left;\n    float h = bot - top;\n    float sb = step(abs(uv.y - avy), 0.5 * h) *\n               step(abs(uv.x - avx), 0.5 * w);\n    sb *= smoothstep(-k, k, d1 - r1 - k * 2.);\n    sb *= smoothstep(-k, k, d2 - r2 - k * 2.);\n    \n    vec3 col = vec3(0.2,0.6,0.95) * vec3(s1 + s2 + s3 * s4 * sb);\n    //col += se1 + se2 + se3 + se4;\n    col += 0.08;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddXGD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 153, 225, 249, 649], [651, 651, 708, 708, 2921]], "test": "untested"}
{"id": "dsf3Wj", "name": "What Elements Sound Like", "author": "incription", "description": "The spectral frequencies of elements can be expressed in terms of sin waves, which create unique sounds. The frequencies for hydrogen can be calculated analytically but other elements have been found experimentally which I have copied here. ", "tags": ["sound", "iron", "hydrogen"], "likes": 3, "viewed": 108, "published": 3, "date": "1666800645", "time_retrieved": "2024-07-30T16:24:26.494242", "image_code": "vec3 Freq(vec2 uv, float nm) {\n    return mix(vec3(0), vec3(0.03), float(length(uv) < (nm/2.2)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float[] s = ELEMENT;\n    float f = 0.;\n    for(int i=0;i<s.length();i++) {\n        float nm = 950. / (s[i]);\n        col += Freq(uv, sin(nm  * (iTime + 1.) * 6.2831 * 440.));\n    }\n    \n    //if(length(uv-.5) < (f/100.)) col = vec3(0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "const float[] s = ELEMENT;\nvec2 mainSound( int samp, float time )\n{\n    \n    float f = 0.;\n    for(int i=0;i<s.length();i++) {\n        float nm = 950. / (s[i]);\n        f += sin(nm  * (time + 1.) * 6.2831 * 440.);\n    }\n    \n    return vec2( f / float(s.length()) );\n}", "sound_inputs": [], "common_code": "#define ELEMENT Hydrogen\n\nconst float[] Hydrogen = float[]( 926.2256, 930.7482, 937.8034, 949.743, 972.5367, 1025.7222, 1215.66824, 1215.67364, 3835.384, 3889.049, 3970.072, 4101.74, 4340.462, 4861.2786, 4861.287, 4861.3615, 6562.711, 6562.7248, 6562.8518, 9545.97, 10049.4, 10938.1, 12818.07, 18751.01, 21655.3, 26251.5, 40511.6, 46525.1, 74578.0);\nconst float[] Iron = float[]( 30.0, 2178.0808, 2259.5103, 2292.5249, 2298.1689, 2300.1418, 2327.3958, 2331.3084, 2332.799, 2338.0065, 2343.4951, 2343.961, 2344.2816, 2348.1159, 2348.3025, 2359.1322, 2359.9997, 2360.2945, 2363.8612, 2364.8281, 2365.7654, 2368.5964, 2369.9534, 2373.6245, 2373.7357, 2375.194, 2376.4294, 2379.2765, 2380.7616, 2382.0376, 2383.2452, 2388.6289, 2395.6254, 2399.2413, 2404.8858, 2406.6612, 2406.9761, 2410.5192, 2411.0677, 2413.3104, 2417.8707, 2422.6882, 2424.1456, 2428.3638, 2430.0783, 2432.2612, 2432.8732, 2439.3014, 2443.71, 2444.5154, 2445.5732, 2457.5891, 2458.7838, 2460.4404, 2461.2835, 2461.861, 2462.6472, 2465.1492, 2466.6713, 2466.8194, 2468.8799, 2469.5147, 2470.6694, 2472.332, 2472.8713, 2474.8145, 2478.5722, 2479.7764, 2480.1577, 2482.1172, 2482.6577, 2483.2708, 2483.5334, 2484.1875, 2484.2446, 2486.3728, 2488.1426, 2489.4833, 2489.7524, 2490.6443, 2490.8584, 2491.155, 2491.3965, 2493.1846, 2493.2637, 2496.5337, 2501.1318, 2502.393, 2503.8745, 2506.0935, 2507.9004, 2510.835, 2511.7603, 2512.365, 2517.6611, 2518.1018, 2519.0472, 2522.8494, 2524.2925, 2525.3879, 2526.2939, 2527.4351, 2529.135, 2533.6274, 2534.4186, 2535.4856, 2535.6069, 2536.6726, 2536.8, 2538.7987, 2538.9094, 2538.99, 2540.66, 2540.9722, 2541.101, 2541.8358, 2542.1013, 2543.3781, 2545.9785, 2546.6701, 2548.7442, 2549.0833, 2549.3947, 2549.4616, 2549.6133, 2550.0274, 2550.6832, 2562.5356, 2563.4755, 2566.9126, 2574.3662, 2576.6902, 2577.9219, 2582.5832, 2584.5359, 2585.8758, 2591.5428, 2598.3692, 2599.3956, 2599.5669, 2606.5162, 2606.8264, 2607.0871, 2611.8736, 2613.8243, 2617.6174, 2620.41, 2623.5339, 2625.6671, 2628.2931, 2631.0471, 2631.3232, 2635.8088, 2664.6638, 2666.8125, 2679.0242, 2684.7536, 2689.2122, 2692.6019, 2703.9891, 2706.582, 2714.4129, 2719.0273, 2720.9023, 2723.5774, 2727.5392, 2728.9, 2733.5806, 2735.4753, 2737.3091, 2739.5474, 2742.4053, 2743.1969, 2746.4838, 2749.3216, 2749.486, 2750.1406, 2753.2877, 2755.7365, 2761.81, 2772.074, 2778.2202, 2788.1047, 2804.5203, 2806.9841, 2813.2864, 2823.2756, 2825.5557, 2832.4355, 2838.1194, 2843.9763, 2851.7969, 2936.9033, 2947.876, 2953.9399, 2966.8982, 2970.0994, 2973.1323, 2973.2354, 2981.4451, 2983.5696, 2994.4268, 2999.5117, 3000.9478, 3008.1382, 3020.01, 3020.4907, 3020.6389, 3021.0728, 3024.0327, 3025.8423, 3037.3887, 3047.6045, 3057.4458, 3059.0857, 3193.2258, 3193.2998, 3222.0591, 3225.7871, 3236.2224, 3355.2278, 3407.4597, 3427.1194, 3440.606, 3440.9888, 3443.8765, 3465.8606, 3475.4502, 3476.7019, 3490.574, 3497.8406, 3521.2612, 3526.0408, 3541.0833, 3554.9246, 3558.5151, 3565.3789, 3570.0977, 3570.2542, 3581.1931, 3585.3188, 3586.9849, 3606.6794, 3608.8594, 3618.7678, 3631.4631, 3647.8428, 3679.9133, 3687.4568, 3705.5659, 3707.9199, 3709.2463, 3719.9348, 3722.563, 3727.6189, 3733.3176, 3734.8638, 3737.1316, 3743.3621, 3745.5613, 3745.8994, 3748.2622, 3749.4854, 3758.2329, 3760.0498, 3763.7891, 3765.5388, 3767.1919, 3795.0022, 3799.5476, 3812.9646, 3815.8403, 3820.4253, 3824.4436, 3825.8811, 3827.8225, 3834.2224, 3840.4375, 3841.0481, 3856.3716, 3859.9114, 3878.5732, 3886.2822, 3888.5134, 3895.6565, 3899.7075, 3902.9458, 3920.2581, 3922.9119, 3927.9199, 3930.2966, 4005.2419, 4045.8125, 4063.5942, 4071.738, 4132.0581, 4143.8682, 4202.0293, 4216.1836, 4250.7871, 4260.4746, 4271.7607, 4282.4028, 4307.9023, 4325.7622, 4375.9302, 4383.5449, 4404.7505, 4415.1226, 4427.2979, 4461.6528, 4920.5029, 4957.5967, 5167.4883, 5171.5962, 5227.1509, 5269.5376, 5270.3564, 5328.0386, 5328.5317, 5341.0239, 5371.4897, 5397.1279, 6247.56, 6456.38, 11607.5752, 11689.9756, 11882.8467, 11973.0498 );\nconst float[] Carbon = float[]( 687.0526, 687.346, 903.6235, 903.9616, 904.1416, 904.4801, 1036.3367, 1037.0182, 1193.0088, 1193.0308, 1193.2402, 1193.2644, 1261.552, 1277.2452, 1277.2824, 1277.5131, 1277.5497, 1280.333, 1329.5775, 1329.6005, 1334.5323, 1335.7077, 1560.309, 1560.682, 1560.709, 1561.438, 1656.267, 1656.928, 1657.008, 1657.379, 1657.907, 1658.121, 1751.827, 1930.906, 2478.561, 2836.71, 2837.603, 2992.618, 3918.978, 3920.693, 4267.003, 4267.258, 5145.16, 5151.09, 5380.34, 5889.77, 6013.22, 6578.05, 6582.88, 7231.32, 7236.42, 8335.15, 9094.83, 9111.8, 9405.73, 9658.44, 10691.25, 11748.22, 11753.32, 11754.76, 16890.38 );\nconst float[] Uranium = float[]( 120.0, 2635.529, 2793.934, 2802.56, 2807.119, 2817.958, 2821.121, 2828.935, 2832.061, 2865.681, 2889.624, 2906.794, 2908.272, 2931.414, 2941.916, 2943.896, 2956.06, 2967.936, 2971.066, 3022.21, 3031.987, 3050.197, 3057.939, 3062.537, 3072.783, 3093.005, 3102.422, 3111.618, 3124.952, 3149.24, 3229.499, 3232.156, 3291.332, 3305.8912, 3357.8437, 3390.3775, 3424.5566, 3435.4913, 3459.9191, 3462.22, 3463.5479, 3466.301, 3473.4269, 3480.3634, 3482.49, 3489.3672, 3493.9963, 3500.076, 3504.0089, 3507.3442, 3513.6742, 3514.6107, 3533.5659, 3534.3346, 3542.5704, 3549.2018, 3550.8223, 3555.3188, 3561.411, 3561.8038, 3563.6559, 3566.5909, 3569.0781, 3574.7602, 3577.9162, 3578.7211, 3584.8774, 3591.7443, 3605.2742, 3616.3305, 3620.0838, 3622.6987, 3638.1986, 3644.2422, 3651.5366, 3652.0641, 3659.1548, 3670.0701, 3701.5161, 3713.5546, 3738.0405, 3746.419, 3748.6758, 3751.1746, 3758.348, 3763.2643, 3766.8864, 3773.4339, 3782.8407, 3793.1002, 3793.2638, 3808.9207, 3811.9911, 3826.5084, 3831.4593, 3839.6255, 3854.2202, 3854.6448, 3859.5716, 3865.9176, 3871.0353, 3874.0387, 3878.0847, 3881.4546, 3890.3615, 3892.681, 3894.1206, 3899.7775, 3906.453, 3926.2078, 3926.7153, 3932.0221, 3943.8161, 3964.2064, 3966.5211, 3985.7924, 4005.2094, 4017.7163, 4042.7496, 4047.6117, 4050.0412, 4062.544, 4090.1319, 4116.0974, 4153.971, 4156.6483, 4171.5886, 4222.3677, 4241.6646, 4341.6865, 4355.74, 4362.051, 4393.5858, 4472.3297, 4543.6255, 4756.8059, 5027.3841, 5915.385, 6826.913, 8607.95, 8691.282, 8757.76, 10157.91, 10259.55, 10554.93, 11167.84, 11384.13, 11859.42, 11908.83, 13185.16, 13961.58 );\n\nvec3 spectral_spektre (float l)\n{\n\tfloat r=0.0,g=0.0,b=0.0;\n\t\t\tif ((l>=400.0)&&(l<410.0)) { float t=(l-400.0)/(410.0-400.0); r=    +(0.33*t)-(0.20*t*t); }\n\telse if ((l>=410.0)&&(l<475.0)) { float t=(l-410.0)/(475.0-410.0); r=0.14         -(0.13*t*t); }\n\telse if ((l>=545.0)&&(l<595.0)) { float t=(l-545.0)/(595.0-545.0); r=    +(1.98*t)-(     t*t); }\n\telse if ((l>=595.0)&&(l<650.0)) { float t=(l-595.0)/(650.0-595.0); r=0.98+(0.06*t)-(0.40*t*t); }\n\telse if ((l>=650.0)&&(l<700.0)) { float t=(l-650.0)/(700.0-650.0); r=0.65-(0.84*t)+(0.20*t*t); }\n\t\t\tif ((l>=415.0)&&(l<475.0)) { float t=(l-415.0)/(475.0-415.0); g=             +(0.80*t*t); }\n\telse if ((l>=475.0)&&(l<590.0)) { float t=(l-475.0)/(590.0-475.0); g=0.8 +(0.76*t)-(0.80*t*t); }\n\telse if ((l>=585.0)&&(l<639.0)) { float t=(l-585.0)/(639.0-585.0); g=0.82-(0.80*t)           ; }\n\t\t\tif ((l>=400.0)&&(l<475.0)) { float t=(l-400.0)/(475.0-400.0); b=    +(2.20*t)-(1.50*t*t); }\n\telse if ((l>=475.0)&&(l<560.0)) { float t=(l-475.0)/(560.0-475.0); b=0.7 -(     t)+(0.30*t*t); }\n\n\treturn vec3(r,g,b);\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsf3Wj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 99]], "test": "untested"}
{"id": "cssGWS", "name": "BLF Voxel Accelerated Ray March", "author": "iY0Yi", "description": "This shader is almost just my attempt to understand jt's voxel experiments.\n[url]https://www.shadertoy.com/view/flyfRz[/url]\n\n I tweaked it to make it easier to use in my shaders.\nAnd also, now we can use a cuboid as a cell of the voxel :)", "tags": ["voxel", "random"], "likes": 56, "viewed": 738, "published": 3, "date": "1666763902", "time_retrieved": "2024-07-30T16:24:27.611256", "image_code": "// This shader is almost just my attempt to understand jt's voxel experiments.\n// \"primitives in voxels\" https://www.shadertoy.com/view/flyfRz\n// \"Cast Voxels March Sub-Objects\" https://www.shadertoy.com/view/NstSR8\n// I tweaked it to make it easier to use in my shaders.\n// Also now we can use cuboid as cell of voxel :)\n\n// the size of voxel cell. (only integers are allowed)\n//--------------------------------------------------------------------------------------\n#define I_CELL_SIZE ivec3(5,3,5)\n#define V_CELL_SIZE vec3(I_CELL_SIZE)\n\n#define CELL_NUM vec3(4,4,4)\n\n// get cell by ray position.\n//--------------------------------------------------------------------------------------\nivec3 getCell(vec3 p){\n    return ivec3(floor(p/V_CELL_SIZE)*V_CELL_SIZE);\n}\n\n// define active cells of voxel by sdf.\n//--------------------------------------------------------------------------------------\nfloat sdVoxelBound(ivec3 cell){\n    vec3 p = vec3(cell);\n    return length(p)-max(.1,cos(iTime)+.5)*40.;\n}\n\n// return ID of cell.\n// \"0u\" means the cell is empty.\n//--------------------------------------------------------------------------------------\nuint getCellID(ivec3 cell){\n    if(sdVoxelBound(cell)>0.) return 0u;\n    if(any(lessThan(cell, -ivec3(CELL_NUM)*I_CELL_SIZE)) || any(greaterThan(cell, ivec3(CELL_NUM)*I_CELL_SIZE))) return 0u;\n    return 1u + (uhash(uvec3(cell/I_CELL_SIZE)) % 3u);\n}\n\n// the map function of each cell.\n//--------------------------------------------------------------------------------------\nvec4 sdCell(vec3 p, ivec3 icell){\n    vec4 res = vec4(MAX_DIST,MAT_VOID);\n\n    uint id = getCellID(icell);\n    \n    vec3 cell = vec3(icell);\n    float diff = hash13(cell)*PI;\n    vec3 rnd = hash33(cell);\n\n    vec2 sp = bx_cossin((iTime*3.+diff)*sign(rnd.x-.5));\n    float r = .8;\n    vec3 op = vec3(sp.x, abs(sin(5.*(iTime*3.+diff))), sp.y);\n    uint underCellId = getCellID(icell-ivec3(0,V_CELL_SIZE.y,0));\n    if(id == 1u && (underCellId==2u || underCellId==3u)) res = vec4(sdSphere(p+op*(V_CELL_SIZE*.5-r), r), vec3(1.000,0.902,0.6)+rnd*.002);\n    if(id == 2u) res = vec4(sdBoxFrame(p, vec3(.5)*V_CELL_SIZE-.125, .05)-.125, vec3(.3,.8,.5)+rnd*.1);\n    if(id == 3u) res = vec4(sdBox(p, vec3(.5)*V_CELL_SIZE-.125)-.125, vec3(.2,.7,.5)+rnd*.1);\n\n    return res;\n}\n\n// ray march the cell.\n//--------------------------------------------------------------------------------------\nvec4 marchCell(vec3 ro, vec3 rd, float tmin, float tmax, ivec3 cell){\n    for(float t = tmin; t < tmax;){\n        vec4 res = sdCell(ro+rd*t, cell);\n        if(res.x<MIN_DIST)return vec4(t, res.yzw);\n        t += res.x;\n    }\n    return vec4(MAX_DIST,MAT_VOID);\n}\n\n// main function to attempt to intersect\n// http://lodev.org/cgtutor/raycasting.html\n//--------------------------------------------------------------------------------------\nvec4 intersectVoxel(vec3 ro, vec3 rd){\n    ivec3 cell = getCell(ro);\n    \n    // \"Branchless Voxel Raycasting\" by fb39ca4\n    // https://www.shadertoy.com/view/4dX3zl\n    ivec3 rayStep = ivec3(sign(rd))*I_CELL_SIZE;\n    vec3 deltaDist = V_CELL_SIZE/abs(rd);\n    vec3 sideDist = (sign(rd) * (vec3(cell)-ro)/V_CELL_SIZE + sign(rd)*.5+.5) * deltaDist;\n\n    for (int i=0; i<MAX_RAY_STEPS; i++){\n        // if the cell is not empty, do ray marching.\n        if(getCellID(cell)>0u){ \n            vec3 p = ro-vec3(cell)-V_CELL_SIZE*.5;\n            // bounding box\n            vec2 bounds = iBox(p, rd, V_CELL_SIZE*.5);\n            // ray marching in the cell\n            vec4 res = marchCell(p, rd, bounds.x, bounds.y, cell);\n            if(res.x>=bounds.x && res.x<=bounds.y && res.x>0.) return res;\n        }\n        \n        // the branchless tricks\n        bvec3 mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n        sideDist += vec3(mask) * deltaDist;\n        cell += ivec3(vec3(mask)) * rayStep;\n    }\n    return vec4(MAX_DIST,MAT_VOID);\n}\n\n// to calculate ao, mix distances with neighbor cells.\n//--------------------------------------------------------------------------------------\nfloat sdCellNeighbors(ivec3 cell, vec3 offset){\n    float d = MAX_DIST;\n    // kastorp's optimization: traverse only 2x2x2 cells (instead of 3x3x3),\n    // chosen depending on where in the cell the current point is located.\n    // https://www.shadertoy.com/view/Nl3BDj\n    ivec3 off = -ivec3(step(vec3(0), offset));\n    for(int z=off.z; z<=off.z+1; z++)\n    for(int y=off.y; y<=off.y+1; y++)\n    for(int x=off.x; x<=off.x+1; x++){\n        ivec3 ncell = cell-ivec3(x,y,z)*I_CELL_SIZE;\n        if(getCellID(ncell) > 0u){\n            d = min(d, sdCell(offset+vec3(x,y,z)*V_CELL_SIZE, ncell).x);\n        }\n    }\n    return d;\n}\n\n// normal calcutation\n//--------------------------------------------------------------------------------------\nvec3 normalCell(vec3 p, ivec3 cell) {\n    vec3 n = vec3(0.0);\n    for(int i = 0; i < 4; i++) {\n        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);\n        n += e * sdCell(p + MIN_DIST * e, cell).x;\n    }\n    return normalize(n);\n}\n\n// \"Multi Level AO\" by iY0Yi\n// https://www.shadertoy.com/view/fsBfDR\nfloat aoSeed = 0.;\nconst float MAX_SAMP = 4.;\nfloat ao(vec3 p, vec3 n, float radius) {\n    float ao = 0.;\n    for(float i = 0.; i <= MAX_SAMP; i++) {\n        vec2 rnd = hash21(i + 1. + aoSeed);\n\n        float scale = (i + 1.)/MAX_SAMP;\n        scale = mix(.0, 1., pow(scale, .5));\n\n        rnd.x = (rnd.x * 2. - 1.) * PI * .5;\n        rnd.y = (rnd.y * 2. - 1.) * PI;\n        vec3 rd = normalize(n + hash21(i + 2. + aoSeed).xyx);\n        rd.xy *= mat2(cos(rnd.x), sin(rnd.x), -sin(rnd.x), cos(rnd.x));\n        rd.xz *= mat2(cos(rnd.y), sin(rnd.y), -sin(rnd.y), cos(rnd.y));\n\n        rd *= sign(dot(rd, n));\n\n        float raylen = radius * scale;\n        vec3 rndp = p + normalize(n + rd) * raylen;\n        ivec3 cell = getCell(rndp);\n\n        float res = sdCellNeighbors(cell, rndp-vec3(cell)-.5*V_CELL_SIZE);\n        ao += res;\n        aoSeed++;\n    }\n    return ao/float(MAX_SAMP);\n}\n\n// https://hanecci.hatenadiary.org/entry/20130505/p2\n// http://www.project-asura.com/program/d3d11/d3d11_006.html\nfloat normalizedBlinnPhong(float shininess, vec3 n, vec3 vd, vec3 ld) {\n  float norm_factor = (shininess + 5.) / (2. * PI);\n  vec3 h = normalize(-vd + ld);\n  return pow(max(0., dot(h, n)), shininess) * norm_factor;\n}\n\nvec3 ACESFilm(vec3 x) {\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x * (a * x + b))/(x * (c * x + d) + e);\n}\n\nvoid camera(vec2 uv) {\n    const float pY = .5;\n    const float cL = 150.;\n    const vec3 focus = V_CELL_SIZE*.5;\n    const float fov = .1;\n    vec3 up = vec3(0, 1, 0);\n    vec3 pos = vec3(0, .0, -1) * cL;\n    R(pos.xz, iTime*.5);\n    \n    if(iMouse.z > .5) {\n        pos = vec3(\n            -sin(iMouse.x/iResolution.x * PI*2. + PI * .5),\n            sin(iMouse.y/iResolution.y * PI * 2.),\n            -cos(iMouse.x/iResolution.x * PI*2. + PI * .5)\n            ) * cL;\n        R(pos.xz, PI);\n    }\n    \n    vec3 dir = normalize(focus - pos);\n    vec3 target = pos - dir;\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n    mat3 camMat = mat3(cu, cv, cw);\n    rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n    ro = pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = (uv * 2. - 1.);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // set ray vectors\n    camera(uv);\n    \n    // optimization: skip empty voxels\n    ro += rd*iBox(vec3(ro)-V_CELL_SIZE*.5, rd, V_CELL_SIZE*(CELL_NUM+.5)+MIN_DIST ).x;\n\n    // attempt to intersect\n    vec4 res = intersectVoxel(ro, rd);\n\n    // sky color\n    vec3 col = vec3(.5,.8,.8)*(1./PI)*2.;\n    \n    // hit\n    if(res.x < MAX_DIST){\n        vec3 pos = ro+rd*res.x;\n        \n        // calc normal\n        ivec3 cell = getCell(pos+rd*MIN_DIST);\n        vec3 n = normalCell(pos-vec3(cell)-.5*V_CELL_SIZE, cell);\n        \n        vec3 ldir = normalize(vec3(0, 1., 1.));\n        R(ldir.xz, -iTime*.5);\n        \n        // calc shading\n        float diff = max(0., dot(n, ldir))*(1./PI);\n        float indr = (dot(n, -ldir) * .5 + .5)*(1./PI);\n        float rgh = (distance(res.yzw, vec3(1.000,0.902,0.7))<.2) ? .125 : .01;\n        float spec = normalizedBlinnPhong(1./rgh, n, rd, ldir);\n        float a = ao(pos, n, .1);\n        a += ao(pos, n, .9)*.25;\n        a /= 2.;\n        \n        // shadow\n        float sdw = step(MAX_DIST,intersectVoxel(pos,ldir).x);\n\n        col = diff*2.8*sdw*vec3(1.000,0.929,0.541);\n        col += vec3(.65,.8,.8)*.4*(.3+.7*a);\n        col += vec3(.2,.7,.5)*1.*indr*(.3+.7*a);\n        #if 0\n            col *= .8*(.75+.25*sin(res.yzw*5.+vec3(3.+sin(floor(iTime*.125)),1,2.+sin(2.+floor(iTime*.125)))+floor(iTime*.125)));\n        #else\n            col *= res.yzw;\n        #endif\n        col += spec * .25 * sdw;\n    }\n    col = ACESFilm(col);\n\n    // contrast curve\n    col = smoothstep(.05,.9,col);\n\n    fragColor = vec4(pow(col,vec3(.4545)),1);\n}\n", "image_inputs": [], "common_code": "// \"Hash without Sine\" by Dave_Hoskins:\n#define PI 3.1415926\n#define MAX_DIST 100.0\n#define MIN_DIST 0.001\n#define MAX_RAY_STEPS 20\n#define MAT_VOID vec3(-1)\n#define R(p, a) p = cos(a) * p + sin(a) * vec2(p.y, -p.x)\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3) {\n    p3 = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\n// \"Best\" Integer Hash by FabriceNeyret2\n// https://www.shadertoy.com/view/WttXWX\nuint triple32(uint x){\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nfloat hash(uint x){\n    return float(triple32(x))/float(0xffffffffU);\n}\n\nuint uhash(uvec2 v){\n    return triple32(v.x + triple32(v.y));\n}\n\nuint uhash(uvec3 v){\n    return triple32(v.x + triple32(v.y + triple32(v.z)));\n}\n\n// https://iquilezles.org/articles/intersectors\nvec2 iBox( in vec3 ro, in vec3 rd, vec3 boxSize){\n    vec3 m = 1./rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.);\n    return vec2( tN, tF );\n}\n\nfloat sdSphere( vec3 p, float s ){\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e ){\n    p = abs(p  )-b;\n    vec3 q = abs(p+e)-e;\n    return min(min(\n    length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n    length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n    length(max(vec3(q.x,q.y,p.z) ,0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// https://www.shadertoy.com/view/XdV3W3\nvec2 bx_cos(vec2 a){return clamp(abs(mod(a,8.0)-4.0)-2.0,-1.0,1.0);}\nvec2 bx_cossin(float a){return bx_cos(vec2(a,a-2.0));}\n\nvec3 ro, rd;", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cssGWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[569, 687, 709, 709, 763], [765, 894, 925, 925, 1000], [1002, 1146, 1173, 1173, 1395], [1397, 1520, 1553, 1553, 2283], [2285, 2397, 2466, 2466, 2659], [2661, 2835, 2873, 2873, 3896], [3898, 4042, 4089, 4089, 4665], [4667, 4778, 4815, 4815, 5049], [5167, 5167, 5207, 5207, 6006], [6008, 6122, 6193, 6193, 6338], [6340, 6340, 6363, 6363, 6517], [6519, 6519, 6541, 6541, 7352], [7354, 7354, 7410, 7410, 9106]], "test": "untested"}
{"id": "ddlGDS", "name": "Fractal mosaic 31 (music)", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 3, "viewed": 233, "published": 3, "date": "1666760976", "time_retrieved": "2024-07-30T16:24:28.399150", "image_code": "vec2 triangle_wave(vec2 a){\n    \n    vec2 a2 = vec2(1.,0.5),\n    \n    a1 = a-a2;\n    \n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    vec3 col = vec3(0.);\n    \n    float t1 = 1.5;\n    \n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    \n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n        \n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n        \n    vec2 t2 = vec2(0.);\n        \n    for(int k = 0; k < 6; k++){\n        \n        uv = abs(.5+uv+t2);\n                \n        t2 = -triangle_wave(uv-.5)*sign(uv.x-uv.y) ;\n        \n        uv = t2-triangle_wave(uv.yx*sign(uv.x-uv.y));\n\n        float c1 = abs(uv.x-uv.y);\n        \n        col = col.yzx;\n                \n        if(uv.y < uv.x) col = vec3(col.yz,c1);\n        \n    }\n    \n    fragColor = vec4(min(col,vec3(1.)),1.0);\n}\n", "image_inputs": [], "sound_code": "vec2 mainSound(int samp, float time){\n  //time += floor(time/2.)/2.;\n  \n  float s1 =\n      8.,\n  m4 =\n      pow(2.,fmod(floor(time*s1),3.))\n      //pow(2.,fmod((time*2./s1),fmod(time*s1,8.)+8.))\n      //fmod(floor(time/s2)*(floor(time)+floor(time*s2)),2.)\n  ,\n  t=\n      time/(m4)\n  ,\n  m1 =\n      fmod(floor(t+m4),s1)\n  ,\n  m3 =\n      fmod(t*s1/2.,s1);\n  t /=\n      (1.+fmod(floor(t/s1+m3/2.),2.))\n  ;\n  float a=\n      //((1.-sqrt(fract(t/s1))))*.2\n      64.*(pow(fract(-t*s1)/1.25,2.))\n      //pow(2.-log(fract(t/s1)/s1),2.)\n  ,\n\n  nb = time*pow(2.,(m3)/5.+7.);\n\n  return\n      abs(.5-vec2(fract(nb*.998),fract(nb)))*a\n      \n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n  ;\n\n}", "sound_inputs": [], "common_code": "float fmod(float x,float y){\n    return\n        floor(mod(x,y))\n        //mod(floor(x),y)\n        //min(mod(floor(x),y),mod(floor(x),y))\n    ;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddlGDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 131], [133, 133, 190, 190, 894]], "test": "untested"}
{"id": "cdsGzs", "name": "Rounded Rectangle with border2", "author": "i509VCB", "description": "Rounded rectangle with variable radius edges and borders drawn using an SDF. ", "tags": ["sdf", "rectangle", "rounded"], "likes": 0, "viewed": 282, "published": 3, "date": "1666751493", "time_retrieved": "2024-07-30T16:24:29.476269", "image_code": "// The size of the shape as a ratio.\n//\n// One value must always be 1.0. The other value may be greater than 1.0 to create a rectangle.\nconst vec2 size = vec2(1.0, 1.0);\n\n// The radius in a fraction.\n//\n// A value of 0.0 indicates that a quad should be drawn.\n// A value of 1.0 indicates that the radius of the curves should occupy the entire width or height (whichever is shorter).\n// Values between 0.0 and 1.0 will result in a quad with curved edges, with a radius of 1.0 for all edges creating a circle.\n//\n// r.x = top-right radius\n// r.y = bottom-right radius\n// r.z = top-left radius\n// r.w = bottom-left radius\nconst vec4 radius = vec4(0.0, 0.15, 1.0, 0.05);\n\n// The thickness of the shape.\n//\n// A thickness of 1.0 means the shape will be solid.\n// A thickness of 0.0 means the shape will be invisible.\n//\n// Note: With smaller values for radius, the inner border might be a right angle.\nconst float thickness = 0.06;\n\n// The fade applied to edges of the shape.\n//\n// This value is used to smooth the edges of the shape and remove jagged edges.\n//\n// A fade of 0.0 will not smooth the shape.\n// High fade values will cause the shape to become invisible.\nconst float fade = 0.006;\n\nfloat _distance(vec2 position, vec2 size, vec4 radii) {\n    vec2 edges = position.x > 0.0 ? radii.xy : radii.zw;\n    float radius = position.y > 0.0 ? edges.x : edges.y;\n\n    // A quad will be symmetrical along the x and y axis and therefore the absolute value can be taken for symmetry.\n    //\n    // The size is subtracted from the position to effectively center q around some edge of the quad.\n    // The radius however is added to move the edge of the quad further to the middle.\n    vec2 q = abs(position) - size + radius;\n    return min(max(q.x,q.y),0.0)\n        // The essence of an SDF is finding the distance to some mathematically defined shape. To do this we measure the distance\n        // from position q to (0.0, 0.0).\n        + length(max(q, 0.0))\n        // In order to prevent the distance from scaling with the radius, subtract the radius to keep the quad at a fixed size.\n        - radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // 0 -> 1 local space, adjusted for aspect ratio\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n\n    // Subtract half the fade to ensure the rectangle is not clipped.\n    vec2 size = size - (fade / 2.0);\n\n    // Calculate distance and fill circle with white\n    float distance = _distance(uv, size, radius);\n    float smoothed_alpha = 1.0 - smoothstep(0.0, fade, distance);\n    float border_alpha = 1.0 - smoothstep(thickness - fade, thickness, abs(distance));\n\n    vec4 bg_color = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 rect_color = vec4(0.85, 0.35, 0.2, 1.0);\n\n    // Set output color\n    fragColor = mix(bg_color, mix(bg_color, rect_color, border_alpha), smoothed_alpha);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdsGzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1190, 1190, 1245, 1245, 2100], [2102, 2102, 2157, 2210, 2911]], "test": "untested"}
{"id": "Dds3WB", "name": "Fork Nixie Tube Clock", "author": "picoplanetdev", "description": "Fork of https://www.shadertoy.com/view/csl3DS\n\nRemoves gray circle background (I'm using it as a desktop wallpaper) and enables minutes functionality (not just minutes=55)", "tags": ["text", "distance", "font", "digit", "nixie"], "likes": 34, "viewed": 7010, "published": 3, "date": "1666745141", "time_retrieved": "2024-07-30T16:24:30.429720", "image_code": "#define TWELVE_HOUR_CLOCK   1\n#define GLOWPULSE    1\n#define SHOW_GRID\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\nconst float scale = 1.0 / 6.0;\n\nvec2 digitSize = vec2(1.0,1.5) * scale;\nvec2 digitSpacing = vec2(1.1,1.6) * scale;\n\n\n\n// hash function copy from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat noise(vec2 pos) {\n    vec2 i = floor(pos);\n    vec2 f = fract(pos);\n    \n    float a = hash12(i);\n    float b = hash12(i + vec2(1, 0));\n    float c = hash12(i + vec2(0, 1));\n    float d = hash12(i + vec2(1, 1));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n//Distance to a line segment,\nfloat dfLine(vec2 start, vec2 end, vec2 uv)\n{\n\tstart *= scale;\n\tend *= scale;\n    \n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv);\n}\n\n//Distance to the edge of a circle.\nfloat dfCircle(vec2 origin, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n    \n\treturn abs(length(uv - origin) - radius);\n}\n\n//Distance to an arc.\nfloat dfArc(vec2 origin, float start, float sweep, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n    \n\tuv -= origin;\n\tuv *= mat2(cos(start), sin(start),-sin(start), cos(start));\n\t\n\tfloat offs = (sweep / 2.0 - pi);\n\tfloat ang = mod(atan(uv.y, uv.x) - offs, tau) + offs;\n\tang = clamp(ang, min(0.0, sweep), max(0.0, sweep));\n\t\n\treturn distance(radius * vec2(cos(ang), sin(ang)), uv);\n}\n\n//Distance to the digit \"d\" (0-9).\nfloat dfDigit(vec2 origin, float d, vec2 uv)\n{\n\tuv -= origin;\n\td = floor(d);\n\tfloat dist = 1e6;\n\t\n\tif(d == 0.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.000), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,1.000), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 3.142, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 1.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.500,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 2.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,0.000), vec2(0.000,0.000), uv));\n\t\tdist = min(dist, dfLine(vec2(0.388,0.561), vec2(0.806,0.719), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.700,1.000),5.074, 1.209, 0.300, uv));\n\t\tdist = min(dist, dfArc(vec2(0.600,0.000),1.932, 1.209, 0.600, uv));\n\t\treturn dist;\n\t}\n\tif(d == 3.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,1.000), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 4.712, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 4.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.700,1.500), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,0.500), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.700,1.200), vec2(0.700,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 5.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.300,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.300,1.500), vec2(0.200,0.900), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 5.356, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 6.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.067,0.750), vec2(0.500,1.500), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.500), 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 7.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 8.0)\n\t{\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.400), 0.400, uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.150), 0.350, uv));\n\t\treturn dist;\n\t}\n\tif(d == 9.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.933,0.750), vec2(0.500,0.000), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.000), 0.500, uv));\n\t\treturn dist;\n\t}\n\n\treturn dist;\n}\n\n//Distance to a number\nfloat dfNumber(vec2 origin, float num, vec2 uv)\n{\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = 0.0;\n\t\n\tfor(float i = 5.0;i > -3.0;i--)\n\t{\t\n\t\tfloat d = mod(num / pow(10.0,i),10.0);\n\t\t\n\t\tvec2 pos = digitSpacing * vec2(offs,0.0);\n\n\t\tif(i == 0.0)\n\t\t{\n\t\t\tdist = min(dist, dfCircle(vec2(offs+0.9,0.1)*1.1, 0.04,uv));\n\t\t}\n\t\t\n\t\tif(num > pow(10.0,i) || i == 0.0)\n\t\t{\n\t\t\tdist = min(dist, dfDigit(pos, d, uv));\n\t\t\toffs++;\n\t\t}\t\n\t}\n\treturn dist;\t\n}\n\n//Distance to a number This handles 2 digit integers, leading 0's will be drawn\nfloat dfNumberInt(vec2 origin, int inum, vec2 uv)\n{\n    float num = float(inum);\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = 0.0;\n\t\n\tfor(float i = 1.0;i >= 0.0;i--)\n\t{\t\n\t\tfloat d = mod(num / pow(10.0,i),10.0);\n\t\t\n\t\tvec2 pos = digitSpacing * vec2(offs,0.0);\n\t\t\n        dist = min(dist, dfDigit(pos, d, uv));\n        offs++;\n\t}\n\treturn dist;\t\n}\n\nfloat dfColon(vec2 origin, vec2 uv) {\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = 0.0;\n\n    dist = min(dist, dfCircle(vec2(offs+0.9,0.9)*1.1, 0.04,uv));\n    dist = min(dist, dfCircle(vec2(offs+0.9,0.4)*1.1, 0.04,uv));\n    return dist;\n}\n\n//Length of a number in digits\nfloat numberLength(float n)\n{\n\treturn floor(max(log(n) / log(10.0), 0.0) + 1.0) + 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n  // Test outside the circle for round watches\n  /*vec2 uvTest = (gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\n  float absX = uvTest.x*uvTest.x;\n  float absY = uvTest.y*uvTest.y;\n  if(sqrt(absX + absY) >0.5) {\n    fragColor = vec4(0.1);\n    return;\n  }*/\n  // end test\n  \n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = (fragCoord.xy / iResolution.y - aspect/2.0) *0.86;\n\t\n    \n    int hour = int(iDate.w/3600.);\n#if TWELVE_HOUR_CLOCK\n    if( hour > 12 ) hour -= 12;\n    if( hour == 0 ) hour = 12;\n#endif\n    int minute = int(mod(iDate.w/60.,60.));\n    \n\tfloat nsize = numberLength(9999.);\n\tvec2 pos = -digitSpacing * vec2(nsize,1.0)/2.0;\n\n    vec2 basepos = pos;\n    pos.x = basepos.x + 0.16;\n\tfloat dist = 1e6;\n\tdist = min(dist, dfNumberInt(pos, hour, uv));\n    \n    pos.x = basepos.x + 0.39;\n\tdist = min(dist, dfColon( pos, uv ));\n    \n    pos.x = basepos.x + 0.60;\n    float dist2 = 1e6;\n\tdist = min(dist, dfNumberInt(pos, minute, uv));\n\t\n\tvec3 color = vec3(0);\n\t\n\tfloat shade = 0.0;\n\t\n\tshade = 0.004 / (dist);\n\t\n\tcolor += vec3(1,0.2,0) * shade;\n#if GLOWPULSE\n\tcolor += vec3(1,0.2,0) * shade * noise((uv + vec2(iTime*.5)) * 2.5 + .5);// * 10.*(noise(uv.yx));\n#endif\n\n    #ifdef SHOW_GRID\n    float grid = 0.5-max(abs(mod(uv.x*64.0,1.0)-0.5), abs(mod(uv.y*64.0,1.0)-0.5));\n    \n    color *= 0.25+vec3(smoothstep(0.0,64.0 / iResolution.y,grid))*0.75;\n    #endif\n\t\n\tfragColor = vec4( color , 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dds3WB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[244, 309, 331, 331, 451], [454, 454, 477, 477, 766], [768, 798, 843, 843, 1021], [1023, 1059, 1111, 1111, 1197], [1199, 1221, 1296, 1296, 1618], [1620, 1655, 1701, 1701, 3969], [3971, 3994, 4043, 4043, 4432], [4434, 4514, 4565, 4565, 4860], [4862, 4862, 4899, 4899, 5102], [5104, 5135, 5164, 5164, 5223], [5225, 5225, 5283, 5558, 6701]], "test": "untested"}
{"id": "Dss3DS", "name": "BackTracker", "author": "SnoopethDuckDuck", "description": "I had to hit my head against the wall 500 times to make this, it's still quite messy.\nIt's based on the MazeBackTracker rule displayed here: https://github.com/mxgmn/MarkovJunior\n\npress r to reset", "tags": ["automata", "maze", "pathfinding", "pixelart", "ca"], "likes": 18, "viewed": 308, "published": 3, "date": "1666740244", "time_retrieved": "2024-07-30T16:24:31.256510", "image_code": "vec4 cell(ivec2 f) {\n    return texelFetch(iChannel0, f, 0);\n}\n\nvoid mainImage(out vec4 col, in vec2 f)\n{\n    vec2 uv = (f - 0.5 * iResolution.xy) / iResolution.y;\n    float sc = 0.125;\n    col = cell(ivec2(sc * f + (1.-sc) * 0.5 * iResolution.xy));\n    col += col.a;\n    /*\n    col.rb *= 0.5 + 0.5 * thc(4., length(col) * 2. * pi + iTime);   \n    col += 0.05 + 0.1 * uv.y;\n    col.rgb = pal(0.25 * (col.r + 2. * col.g + 3. * col.b), \n                  0.25 * vec3(0,1,2)/3.);    \n    col = 1. - col;\n    col = pow(col, vec4(0.8)); \n    //*/\n    \n    //col += vec4(col.g);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\n#define red vec4(1,0,0,0)\n#define green vec4(0,1,0,0)\n#define blue vec4(0,0,1,0)\n#define spec vec4(1,0,1,0)\n#define spec2 vec4(0,0,1,1)\n\nvec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\n// rand value 0,1,2,3 (change me! looks really cool)\nivec2 rand(float t) {\n    float h = floor(4. * h21(vec2(0.01 * t, 50.)));\n    //float h = mod(floor(0.25 * t), 4.); //2.5*t, 3.9*t\n    //float h = floor(2. + 2. * cos(0.25 * t));\n    //float h = min(3., mod(t,8.));\n    if (h == 0.) return ivec2(0,1);\n    if (h == 1.) return ivec2(1,0);\n    if (h == 2.) return ivec2(0,-1);\n    if (h == 3.) return ivec2(-1,0);\n}\n\nvoid mainImage(out vec4 col, in vec2 f)\n{\n    col = vec4(0.0);\n    ivec2 px = ivec2(f);\n    int frame = iFrame;// % 1800;\n\n    if (frame == 0 || key_down(KEY_RESET)) {     \n        vec2 r = floor(0.5 * vec2(textureSize(iChannel0, 0)));\n        \n        // starting point\n        vec2 q = abs(f-r+0.5);\n        col.r += step(max(q.x, q.y), 0.);\n          \n        // border\n        q = abs(f-r-0.5);\n        col.b += step(abs(max(q.x, q.y) - 21.), 0.);       \n        return;\n    }\n           \n    // Center cell\n    col = cell(px);\n     \n    // Neighbour cells\n    vec4 b = cell(px - ivec2(0,1));\n    vec4 t = cell(px + ivec2(0,1));\n    vec4 l = cell(px - ivec2(1,0));\n    vec4 r = cell(px + ivec2(1,0));   \n    vec4 bb = cell(px - ivec2(0,2));\n    vec4 tt = cell(px + ivec2(0,2));\n    vec4 ll = cell(px - ivec2(2,0));\n    vec4 rr = cell(px + ivec2(2,0));  \n    \n    vec4 sum = l + b + t + r;\n    vec4 sum2 = ll + bb + tt + rr;\n    //float blueSum = (l + b + t + r).b;\n    //float blueSum2 = (ll + bb + tt + rr).b;\n \n    float time = float(iFrame);\n    ivec2 rnd = rand(time);\n\n    vec4 rc   = cell(px + 2 * rnd); // rand cell\n    vec4 orc  = cell(px - 2 * rnd); // rand cell opposite\n    vec4 hrc  = cell(px + rnd);     // half rand cell\n    vec4 ohrc = cell(px - rnd);     // half rand cell opposite\n\n    // red + gap found -> blue\n    if (col == red && orc == vec4(0)) \n        col = blue;\n    \n    if (col == vec4(0) && rc == spec2) \n        col = red; // black->new red\n    else if (col == spec2 && orc == vec4(0))  \n        col = blue; // \n    else if (col == vec4(0) && hrc == spec2 && ohrc == vec4(0))\n        col = green;\n    \n    if (col == vec4(0)) {\n        if (rc == red) {\n            if (sum2.b == 3.) // reach dead-end (3 blues + 1 red)\n                col = spec;\n            else // keep growing\n                col = red;\n        }\n        if (hrc == red && sum.b == 0.) // between red and blue\n            col = green;\n    } \n    else if (col == blue) {\n        if ((tt == spec && t == green) || // connected to a spec col \n            (bb == spec && b == green) ||\n            (rr == spec && r == green) ||\n            (ll == spec && l == green) ) {    \n            if (sum2.b == 4.)     // trapped\n                col = spec;\n            else if (sum.g >= 2.) // not trapped\n                col = spec2;    \n        }    \n    } \n    else if (col == spec) \n        col = spec2;\n    else if (col == red && sum.b == 0. && sum2.b == 4.)\n        col = spec;\n}\n\n\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dss3DS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 62], [64, 64, 105, 105, 574]], "test": "untested"}
{"id": "csl3DS", "name": "Nixie Tube Clock", "author": "timmaffett", "description": "Morphed into nixie tube watch\nadded pulsing of glow a little - added seconds ifdef\n#define TWELVE_HOUR_CLOCK   1\n#define GLOWPULSE    1\n#define SECONDS 1\nneeds better noise\nFork of https://www.shadertoy.com/view/4dc3zr", "tags": ["text", "clock", "distance", "font", "digit", "nixie"], "likes": 7, "viewed": 571, "published": 3, "date": "1666739056", "time_retrieved": "2024-07-30T16:24:32.120200", "image_code": "#define TWELVE_HOUR_CLOCK   1\n#define GLOWPULSE    1\n#define SECONDS      1\n#define SHOW_GRID\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\nconst float scale = 1.0 / 6.0;\n\nvec2 digitSize = vec2(1.0,1.5) * scale;\nvec2 digitSpacing = vec2(1.1,1.6) * scale;\n\n\n\n// hash function copy from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat noise(vec2 pos) {\n    vec2 i = floor(pos);\n    vec2 f = fract(pos);\n    \n    float a = hash12(i);\n    float b = hash12(i + vec2(1, 0));\n    float c = hash12(i + vec2(0, 1));\n    float d = hash12(i + vec2(1, 1));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n//Distance to a line segment,\nfloat dfLine(vec2 start, vec2 end, vec2 uv)\n{\n\tstart *= scale;\n\tend *= scale;\n    \n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv);\n}\n\n//Distance to the edge of a circle.\nfloat dfCircle(vec2 origin, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n    \n\treturn abs(length(uv - origin) - radius);\n}\n\n//Distance to an arc.\nfloat dfArc(vec2 origin, float start, float sweep, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n    \n\tuv -= origin;\n\tuv *= mat2(cos(start), sin(start),-sin(start), cos(start));\n\t\n\tfloat offs = (sweep / 2.0 - pi);\n\tfloat ang = mod(atan(uv.y, uv.x) - offs, tau) + offs;\n\tang = clamp(ang, min(0.0, sweep), max(0.0, sweep));\n\t\n\treturn distance(radius * vec2(cos(ang), sin(ang)), uv);\n}\n\n//Distance to the digit \"d\" (0-9).\nfloat dfDigit(vec2 origin, float d, vec2 uv)\n{\n\tuv -= origin;\n\td = floor(d);\n\tfloat dist = 1e6;\n\t\n\tif(d == 0.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.000), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,1.000), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 3.142, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 1.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.500,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 2.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,0.000), vec2(0.000,0.000), uv));\n\t\tdist = min(dist, dfLine(vec2(0.388,0.561), vec2(0.806,0.719), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.700,1.000),5.074, 1.209, 0.300, uv));\n\t\tdist = min(dist, dfArc(vec2(0.600,0.000),1.932, 1.209, 0.600, uv));\n\t\treturn dist;\n\t}\n\tif(d == 3.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,1.000), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 4.712, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 4.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.700,1.500), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,0.500), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.700,1.200), vec2(0.700,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 5.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.300,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.300,1.500), vec2(0.200,0.900), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 5.356, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 6.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.067,0.750), vec2(0.500,1.500), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.500), 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 7.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 8.0)\n\t{\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.400), 0.400, uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.150), 0.350, uv));\n\t\treturn dist;\n\t}\n\tif(d == 9.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.933,0.750), vec2(0.500,0.000), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.000), 0.500, uv));\n\t\treturn dist;\n\t}\n\n\treturn dist;\n}\n\n//Distance to a number\nfloat dfNumber(vec2 origin, float num, vec2 uv)\n{\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = 0.0;\n\t\n\tfor(float i = 5.0;i > -3.0;i--)\n\t{\t\n\t\tfloat d = mod(num / pow(10.0,i),10.0);\n\t\t\n\t\tvec2 pos = digitSpacing * vec2(offs,0.0);\n\n\t\tif(i == 0.0)\n\t\t{\n\t\t\tdist = min(dist, dfCircle(vec2(offs+0.9,0.1)*1.1, 0.04,uv));\n\t\t}\n\t\t\n\t\tif(num > pow(10.0,i) || i == 0.0)\n\t\t{\n\t\t\tdist = min(dist, dfDigit(pos, d, uv));\n\t\t\toffs++;\n\t\t}\t\n\t}\n\treturn dist;\t\n}\n\n//Distance to a number This handles 2 digit integers, leading 0's will be drawn\nfloat dfNumberInt(vec2 origin, int inum, vec2 uv)\n{\n    float num = float(inum);\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = 0.0;\n\t\n\tfor(float i = 1.0;i >= 0.0;i--)\n\t{\t\n\t\tfloat d = mod(num / pow(10.0,i),10.0);\n\t\t\n\t\tvec2 pos = digitSpacing * vec2(offs,0.0);\n\t\t\n        dist = min(dist, dfDigit(pos, d, uv));\n        offs++;\n\t}\n\treturn dist;\t\n}\n\nfloat dfColon(vec2 origin, vec2 uv) {\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = 0.0;\n\n    dist = min(dist, dfCircle(vec2(offs+0.9,0.9)*1.1, 0.04,uv));\n    dist = min(dist, dfCircle(vec2(offs+0.9,0.4)*1.1, 0.04,uv));\n    return dist;\n}\n\n//Length of a number in digits\nfloat numberLength(float n)\n{\n\treturn floor(max(log(n) / log(10.0), 0.0) + 1.0) + 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = (fragCoord.xy / iResolution.y - aspect/2.0) *0.86;\n\t\n    \n    int hour = int(iDate.w/3600.);\n#if TWELVE_HOUR_CLOCK\n    if( hour > 12 ) hour -= 12;\n    if( hour == 0 ) hour = 12;\n#endif\n    int minute = int(mod(iDate.w/60.,60.));\n    //minute = 55;\n    \n    \n\tfloat nsize = numberLength(9999.);\n\tvec2 pos = -digitSpacing * vec2(nsize,1.0)/2.0;\n\n    vec2 basepos = pos;\n    pos.x = basepos.x + 0.16;\n\tfloat dist = 1e6;\n\tdist = min(dist, dfNumberInt(pos, hour, uv));\n    \n    pos.x = basepos.x + 0.39;\n\tdist = min(dist, dfColon( pos, uv ));\n    \n    pos.x = basepos.x + 0.60;\n    float dist2 = 1e6;\n\tdist = min(dist, dfNumberInt(pos, minute, uv));\n\n \n#ifdef SECONDS\n    int seconds = int(mod(iDate.w,60.));\n\n    uv *= 1.7;\n    pos = basepos;\n    pos.y -= 0.45;\n    pos.x += 0.38;\n\tdist = min(dist, dfNumberInt(pos, seconds, uv));\n#endif\n    \n\tvec3 color = vec3(0);\n\t\n\tfloat shade = 0.0;\n\t\n\tshade = 0.004 / (dist);\n\t\n\tcolor += vec3(1,0.2,0) * shade;\n#if GLOWPULSE\n\tcolor += vec3(1,0.2,0) * shade * noise((uv + vec2(iTime*.5)) * 2.5 + .5);// * 10.*(noise(uv.yx));\n#endif\n\n    #ifdef SHOW_GRID\n    float grid = 0.5-max(abs(mod(uv.x*64.0,1.0)-0.5), abs(mod(uv.y*64.0,1.0)-0.5));\n    \n    color *= 0.25+vec3(smoothstep(0.0,64.0 / iResolution.y,grid))*0.75;\n    #endif\n\t\n\tfragColor = vec4( color , 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csl3DS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[267, 332, 354, 354, 474], [477, 477, 500, 500, 789], [791, 821, 866, 866, 1044], [1046, 1082, 1134, 1134, 1220], [1222, 1244, 1319, 1319, 1641], [1643, 1678, 1724, 1724, 3992], [3994, 4017, 4066, 4066, 4455], [4457, 4537, 4588, 4588, 4883], [4885, 4885, 4922, 4922, 5125], [5127, 5158, 5187, 5187, 5246], [5248, 5248, 5306, 5306, 6663]], "test": "untested"}
{"id": "csf3WB", "name": "Metal'occ", "author": "iapafoto", "description": "using curvature detection to create a bit realistic old metalic effect.\nStarts this shader using edge detecton but curvature do it best and we can easily avoid negative ones.  ", "tags": ["edge", "metal", "cross", "curvature", "metalic", "occitan"], "likes": 36, "viewed": 378, "published": 3, "date": "1666733654", "time_retrieved": "2024-07-30T16:24:33.107561", "image_code": "\n// Created by sebastien durand - 10/2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n\n\n#define WITH_DOF\n\n#ifdef WITH_DOF\n\n//const float fov = 2.5;\nconst float aperture = 2.;\nconst float cosAngle = cos(radians(aperture/2.));\n\nbool inCone(vec3 p, vec3 o, vec3 n, float side) {\n\treturn step(cosAngle,side*dot(normalize(o-p), n)) > 0.5;\n}\n\n\n//--------------------------------------------------------------------------\n// eiffie's code for calculating the aperture size for a given distance...\nfloat coc(float t) {\n\treturn max(t*.04, (2./iResolution.y) * (1.+t));\n}\n\nvec4 bokeh(sampler2D tex, vec2 uv, float fdist) {\n // based on dof by Jochen \"Virgill\" Feldktter, Alcatraz / Rhodium 4k Intro liquid carbon\n  // simplyfied version of Dave Hoskins blur\n  // now bokeh is not cut within dof mask, added alpha blending based on difference of dof mask samples\n    const float GA =2.399; \n\tconst mat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n    vec4 acc = texture(tex,uv);\n    float rad = min(.3, 2.*coc(abs(acc.w-fdist)));//.3; // TODO calculate this for Max distance on picture\n\t acc = vec4(texture(tex,uv).rgb, rad);\n    float d = rad;\n    vec2 pixel=0.0001*vec2(iResolution.y/iResolution.x,7.);\n\tvec2 angle=vec2(0,rad);\n\tfor (int j=0;j<64;j++) {  \n        rad += 1./rad;\n\t    angle*=rot;\n        vec2 tap_uv = uv+pixel*(rad-1.)*angle;\n        vec4 col = texture(iChannel0, tap_uv);\n      \tacc.rgb = max(acc.rgb,col.rgb);\n\t}\n\treturn acc;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    float fdist = texture(iChannel0,vec2(.5)).w;\n\tfragColor = bokeh(iChannel0,uv,fdist);\n    \n#else   \n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tfragColor= texture(iChannel0,uv);\n#endif\n\n  //  vec2 grainuv = fragCoord.xy + floor(iTime*60.)*vec2(37,41);\n//\tvec2 filmNoise = 1.5*textureLod( iChannel1, .5*grainuv/iChannelResolution[0].xy, 0. ).rb;\n//\tfragColor.rgb *= 1.1*mix( vec3(1), mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x), .1*filmNoise.y );\n\n}\n\n\n\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define COLOR_BACK  vec3(.6, .7, 1)*.045\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise3D(in vec3 p){\n\tconst vec3 s = vec3(113, 157, 1);\n\tvec3 ip = floor(p); \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip; \n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    float n = mix(h.x, h.y, p.z);\n    return n;\n}\n\nfloat fbm(in vec3 p){\n    return 0.5333*noise3D( p ) + 0.2667*noise3D( p*2.02 ) + 0.1333*noise3D( p*4.03 ) + 0.0667*noise3D( p*8.03 );\n}\n\n// 2D rotation formula.\nmat2 rot2(float a) { float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\nvec2 hash2(vec2 p) {\n   // Dave Hoskin's hash as in https://www.shadertoy.com/view/4djSRW\n   vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nfloat hash( const in vec3 p ) {\n    return fract(sin(dot(p,vec3(127.1,311.7,758.5453123)))*43758.5453123);\n}\n\n// [iq] https://www.shadertoy.com/view/4lyfzw\nfloat opExtrussion(vec3 p, float sdf, float h) {\n    vec2 w = vec2(sdf, abs(p.z) - h);\n  \treturn min(max(w.x,w.y),0.) + length(max(w,0.));\n}\n\nfloat smin(float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// --------------------------------------\n// Distance Functions\n// --------------------------------------\n\nfloat sdOcc1( in vec2 p) {\n    return min(max(length(p)-2.8, 3.-\n        min(length(p-vec2(0,3.4)), length(p-vec2(5.4,1.75)))), \n        min(length(p-vec2(2.352,1.404)), length(p-vec2(3,0))) - .33);\n}\nfloat sdOcc0( in vec2 p) {\n    return max(length(p)-2.8, 3.-\n        min(length(p-vec2(0,3.4)), length(p-vec2(5.4,1.75))) \n         );\n}\nfloat sdOcc( in vec2 p) {\n    p = abs(p);\n    return min(sdOcc1(p),sdOcc1(p.yx));\n}\nfloat sdOcc00( in vec2 p) {\n    p = abs(p);\n    return min(sdOcc0(p),sdOcc0(p.yx));\n}\n\nfloat sdOcc3D(in vec3 p, float h) {\n    p.z = -abs(p.z);\n    float d1 = opExtrussion(p, sdOcc(p.xy), h);   \n    float d2 = opExtrussion(p+vec3(0,0,h), sdOcc00(p.xy)+.25, h*.15);    \n    return /*max(d1,-d2); //*/smin(d1-.025,-d2,-.05);\n}\n\n", "buffer_a_code": "// Background\n\n#define sharp 35. \n#define thick 0.2\n\nfloat draw_tiles(vec2 uv,float seed) {\n    float k = floor(rand(floor(uv)+(seed/0.12))+0.5);\n    uv = fract(uv);\n    float x = clamp((1.-length(uv-vec2(1.,k))-(0.5-thick))*sharp,0.,1.)+clamp((1.-length(uv-vec2(0.,1.-k))-(0.5-thick))*sharp,0.,1.);\n    x -= clamp((1.-length(uv-vec2(1.,k))-(0.5+thick))*sharp,0.,1.)+clamp((1.-length(uv-vec2(0.,1.-k))-(0.5+thick))*sharp,0.,1.);\n    return x;   \n       \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Background\n    vec2 p = fragCoord/iResolution.y;\n    p=p*(7.+.4*cos(.1*iTime))+vec2(5)*rot2(.04*iTime);\n    p *= rot2(.01*iTime);\n    vec2 q = fragCoord/iResolution.xy;\n    vec3 sceneCol = COLOR_BACK + .05*hash(vec3(q,1.));\n    float k = draw_tiles(p*.5,2.);\n    sceneCol *= .8 + .2*smoothstep(.06,.08,k);\n    fragColor = vec4(sceneCol* pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y),.7f), 0.);\n}", "buffer_a_inputs": [], "buffer_b_code": "\n// Created by sebastien durand - 10/2022\n//-------------------------------------------------------------------------------------\n\n#define FAR 10.\n\nfloat gDist;\nvec3 closest;\n\n#define PI 3.141592\n\nfloat map0(vec3 p) {\n    return .5*sdOcc3D(p.zxy*2., 1.);\n}\n\nfloat map(vec3 p) {\n//return map0(p);\n    // Avarage arround to get a more interesting shape \n    float d = 0.;\n      for( int i=min(iFrame, 0); i<4; i++) {\n        vec3 e = .57735*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);\n        d += map0(p + .045*e);\n    }\n    d /= 4.;\n    return d;\n}\n\n\n//------------------------------------------------------------------------\n// Normal and Curvature (adapted from Shane shader)\n//------------------------------------------------------------------------\nvec3 calcNormal(vec3 p, inout vec3 edge, inout float crv, float t) { \n    float d = map(p);\n    vec2 ec = 7.*vec2(12./450., 0);\n\tfloat d1 = map(p + ec.xyy), d2 = map(p - ec.xyy),\n          d3 = map(p + ec.yxy), d4 = map(p - ec.yxy),\n          d5 = map(p + ec.yyx), d6 = map(p - ec.yyx);\n    crv = (d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5;\n  \n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame, 0); i<4; i++) {\n        vec3 e = .57735*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);\n        n += e*map(p + .001*e);\n    }\n    return normalize(n);\n}\n\nfloat trace(in vec3 ro, in vec3 rd){\n    float t = 0., tmax=FAR, d;\n    for(int i = 0; i<200; i++){\n        d = map(ro + rd*t);\n        if(abs(d)<.001*(1. + t*.05) || t > tmax) break;\n        t += d; // the distance field is over estimated\n    }\n    if(t>tmax) t = FAR;\n    return min(t, FAR);\n}\n\n// Ambient occlusion, for that self shadowed look.\n// Based on the original by IQ.\nfloat calcAO(in vec3 p, in vec3 n) {\n\tfloat sca = 4., occ = 0.;\n    for( int i=1; i<6; i++ ) {\n        float hr = float(i)*.3/5.,       \n              dd = map(p + hr*n);\n        occ += (hr - dd)*sca;\n        sca *= .75;\n    }\n    return clamp(1. - occ, 0., 1.);   \n}\n\n// The iterations should be higher for proper accuracy.\nfloat softShadow(in vec3 ro, in vec3 rd, float t, in float end, in float k){\n    float shade = 1.;\n    float dist = .001*(1. + t*.05) + .001*abs(hash2(ro.xz).x);\n    for (int i = 0; i<32; i++){\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);    \n        dist += clamp(h, .001, .025);        \n        if (h<.001 || dist > end) break; \n    }\n    return min(max(shade, 0.) + .1, 1.); \n}\n\n// Shane magie\nvec3 envMap(vec3 p){\n    p *= 3.;\n    float n3D2 = noise3D(p*3.);\n    float c = noise3D(p)*.57 + noise3D(p*2.)*.28 + noise3D(p*4.)*.15;\n    c = smoothstep(.25, 1., c); \n    p = vec3(c, c*c, c*c*c);\n    return mix(p, p.zyx, n3D2*.5 + .5);\n}\n\n//------------------------------------------------------------------------\n// [Shane] - Desert Canyon - https://www.shadertoy.com/view/Xs33Df\n//------------------------------------------------------------------------\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nfloat tex3D(sampler2D tex, in vec3 p, in vec3 n){\n    n = max(n*n, .001);\n    n /= (n.x + n.y + n.z );  \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).x;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 n, float k){\n    const float ep = .001;\n    vec3 grad = vec3( tex3D(tex, vec3(p.x-ep, p.y, p.z), n),\n                      tex3D(tex, vec3(p.x, p.y-ep, p.z), n),\n                      tex3D(tex, vec3(p.x, p.y, p.z-ep), n));\n    grad = (grad - tex3D(tex, p, n))/ep;             \n    grad -= n*dot(n, grad);          \n    return normalize(n + grad*k);\n}\n\n//------------------------------------------------------------------------\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro),\n         cp = vec3(sin(cr), cos(cr),.0),\n         cu = normalize( cross(cw,cp) ),\n         cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = .1*iTime;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    float a = mix(.3,3.*cos(.4*time),.5+.5*cos(.2*iTime))+3.14*m.x;\n    \n    // camera\t\n    vec3 ta = vec3(0),\n         ro = vec3(2.5*cos(a), 3.*cos(.4*iTime+15.) + 3., 3.5*sin(a)+3.*sin(.4*iTime+15.));\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, .1*cos(.123*iTime) );\n\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n        \n    // ray direction\n    vec3 rd = ca * normalize(vec3(p,2.5)),\n         lp = ro + 3.*vec3(.25, 2, -.1);\n        \n    // Ray march.\n    float t = trace(ro, rd);\n\n    // Background\n    vec2 q = fragCoord/iResolution.xy;\n    vec3 sceneCol = texture(iChannel0, q).xyz; \n\n    if (t < FAR){\n        vec3 col = vec3(.9, .2, .4); // Pink\n        // Position.\n        vec3 pos = ro + rd*t;\n        vec3 edge = vec3(0);\n        float crv = 1.;\n        vec3 nor = calcNormal(pos, edge, crv, t);\n        float border = .015*crv; //length(edge);\n        // Scratchs   \n        nor = doBumpMap(iChannel2, pos, nor, .04*border*fbm(pos*10.)); \n        \n        // Light direction vector.\n        vec3 li = lp - pos;\n        float lDist = max(length(li), .001);\n        li /= lDist;\n       \n        // Light falloff - attenuation.\n        float atten = 1./(1. + lDist*.05 + lDist*lDist*0.025);\n        \n        // Soft shadow and occlusion.\n        float shd = softShadow(pos + nor*.0015, li, t, lDist, 8.); // Shadows.\n        float ao = .3+.7*calcAO(pos, nor);\n        float diff = max(dot(li, nor), .0); // Diffuse.\n        float spec = pow(max(dot(reflect(-li, nor), -rd), 0.), 99.); // Specular.\n        \n        // Ramping up the diffuse. Sometimes, it can make things look more metallic.\n        float od = diff;\n        diff += mix(.1,3.5,smoothstep(0.,.7,border))*spec;\n        diff = pow(diff, 4.)*2.; \n        \n        float Schlick = pow( 1. - max(dot(rd, normalize(rd + li)), 0.), 5.),\n\t\t      fre2 = mix(.5, 1., Schlick);\n        // Metalic effect\n        col *= fbm(pos*64.)*.75 + .5;\n        // Wear effect\n        col = mix(col, vec3(1)*fbm(pos*128.), 3.*border);\n        sceneCol = col*(diff + .25); \n           \n        // Fake environment mapping (Metalic effect)\n        sceneCol += sceneCol*envMap(reflect(rd, nor))*8.;\n        sceneCol *= atten*shd*ao; // Applying the light falloff, shadows and AO.\n    } \n    \n    fragColor = vec4(pow(clamp(sceneCol, 0., 1.),vec3(.47)), t);\n}\n", "buffer_b_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csf3WB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [], "test": "untested"}
{"id": "msf3DB", "name": "Quiet Storm", "author": "leon", "description": "finding calm and peace in noise and chaos", "tags": ["noise", "cloud", "abstract", "gyroid", "short"], "likes": 36, "viewed": 577, "published": 3, "date": "1666731574", "time_retrieved": "2024-07-30T16:24:33.921384", "image_code": "\n// Quiet Storm\n// Another gyroid noise that looks like hell\n// variation of Evil Membrane https://www.shadertoy.com/view/ddX3WB\n\n#define R iResolution.xy\n\n// sinful maths\nfloat gyroid (vec3 seed)\n{\n    return dot(sin(seed),cos(seed.yzx));\n}\n\nfloat noise (vec3 seed)\n{\n    float result = 0., a = .5;\n    for (int i = 0; i < 6; ++i, a/=2.)\n    {\n        // twist and animate\n        seed.z += result*.5 - iTime*.03;\n        \n        // bounces it with an abs\n        result += abs(gyroid(seed/a))*a;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // sweet noise\n    vec3 blu = texture(iChannel0, fragCoord/1024.).xyz;\n    \n    // cocoordinates\n    vec3 p = vec3(2.*(2.*fragCoord-R)/R.y,0);\n    p.z = length(p);\n    \n    // noise grayscale\n    float shade = noise(p);\n    \n    // normal gradient with weighted range to fake volume and perspective\n    float range = abs(p.y+1.) * 0.5 * blu.z + 0.02;\n    vec3 normal = normalize(vec3(shade-vec2(noise(p+vec3(range,0,0)), noise(p+vec3(0,range,0))), .3));\n    \n    // simple lighting from up and sides\n    float light = max(0.,normal.y) + abs(normal.x)*.33;\n    \n    fragColor = vec4(light*shade);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msf3DB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 172, 198, 198, 241], [243, 243, 268, 268, 525], [527, 527, 584, 603, 1186]], "test": "untested"}
{"id": "dsX3DB", "name": "Greyscale with black border", "author": "nuudl3", "description": "You can mouse click to trigger a transition into greyscale and black extension on top and bottom.", "tags": ["mouse", "greyscale"], "likes": 1, "viewed": 210, "published": 3, "date": "1666729572", "time_retrieved": "2024-07-30T16:24:34.760142", "image_code": "float border = 0.12f;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 m = iMouse / iResolution.x;\n    float clickTime = 0.;\n    if( m.w>0.0 ) // button click\n\t{\n        clickTime = iTime;\n    }\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //float time = clamp((iTime - clickTime)/2.4, 0., 1.);\n    float time = texture(iChannel1, uv).x;\n    border *= time;\n    // Normalized pixel coordinates (from 0 to 1)\n\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec4 col = texture(iChannel0, uv);\n    // Output to screen\n    fragColor = mix(col,vec4(vec3((col.x + col.y + col.z)/3.),1.), time);\n    \n    if(uv.y < border || uv.y > 1. - border)\n    {\n        fragColor = vec4(0);\n    }\n    \n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec4 m = iMouse / iResolution.x;\n\n    float col = texture(iChannel0, fragCoord).x;\n    \n    if(iTime < 1.)\n    {\n        col = 0.0001;\n    }\n    \n    if( m.w> 0.0 ) // button click\n\t{\n        if(col > 0.)\n        {\n            col = 0.;\n        }\n        else\n        {\n            col = 0.0001;\n        }\n    }\n    if(col > 0.)\n    {\n        col = col + (0.5 * iTimeDelta);\n    }\n    col = clamp(col, 0., 1.);\n    fragColor = vec4(col);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsX3DB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 80, 80, 752]], "test": "untested"}
{"id": "ddX3WB", "name": "Evil Membrane", "author": "leon", "description": "devil's brain full of sin", "tags": ["noise", "abstract", "gyroid", "short"], "likes": 71, "viewed": 1168, "published": 3, "date": "1666718181", "time_retrieved": "2024-07-30T16:24:35.510137", "image_code": "\n// Evil Membrane\n// Another gyroid noise with light and color\n\n#define R iResolution.xy\n#define N(x,y,z) normalize(vec3(x,y,z))\n\nfloat gyroid (vec3 seed)\n{\n    return dot(sin(seed),cos(seed.yzx));\n}\n\nfloat fbm (vec3 seed)\n{\n    float result = 0., a = .5;\n    for (int i = 0; i < 6; ++i)\n    {\n        // extra spicy twist\n        seed.z += result*.5;\n        \n        // bounce it with abs\n        result += abs(gyroid(seed/a))*a;\n        \n        a /= 2.;\n    }\n    return result;\n}\n\nfloat noise (vec2 p)\n{\n    // improvise 3d seed from 2d coordinates\n    vec3 seed = vec3(p, length(p) - iTime * .1) * 1.;\n    \n    // make it slide along the sin wave\n    return sin(fbm(seed)*6.+iTime)*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 p = (2.*fragCoord-R)/R.y;\n    \n    // noise grayscale\n    float shade = noise(p);\n    \n    // normal gradient\n    vec3 normal = normalize(vec3(shade-vec2(noise(p+vec2(.01,0)), noise(p+vec2(0,.01))), .2));\n    \n    vec3 color = vec3(0.);\n    \n    // light from above\n    color += .5*pow(dot(normal, N(0,1,1))*.5+.5, 10.);\n    \n    // tinted light\n    vec3 tint = .5+.5*cos(vec3(1,2,3)*5.+shade+p.x+normal.y*2.);\n    color += tint*.3*pow(dot(normal, N(0,0,1))*.5+.5, 10.);\n    \n    // pink light from below\n    color += .5*vec3(1.000,0.580,0.580)*pow(dot(normal, N(0,-2,1))*.5+.5, 2.);\n    \n    fragColor = vec4(color*shade, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddX3WB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 156, 156, 199], [201, 201, 224, 224, 484], [486, 486, 508, 553, 696], [698, 698, 755, 774, 1412]], "test": "untested"}
{"id": "csX3DB", "name": "cyberpunk 1024", "author": "lasoy", "description": "cyberpunk 1024", "tags": ["noise", "effect", "cyberpunk"], "likes": 5, "viewed": 344, "published": 3, "date": "1666712570", "time_retrieved": "2024-07-30T16:24:36.252152", "image_code": "// segment function modified from https://www.shadertoy.com/view/MdfGzf\nfloat segment(vec2 uv, bool On)\n{\n\tif (!On) return 0.0;\n\tfloat seg = (1.0-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\n\t\t\t    (1.0-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)));\n\tif (On) seg *= (1.0-length(uv*vec2(3.8,0.9)));//-sin(iTime*25.0*6.26)*0.04;\n\telse seg *= -(0.05+length(uv*vec2(0.2,0.1)));\n\treturn seg;\n}\n\n// sevenSegment function modified from https://www.shadertoy.com/view/MdfGzf\nfloat sevenSegment(vec2 uv,int num)\n{\n\tfloat seg= 0.0;\n    seg += segment(uv.yx+vec2(-1.0, 0.0),num!=-1 && num!=1 && num!=4                    );\n\tseg += segment(uv.xy+vec2(-0.5,-0.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\n\tseg += segment(uv.xy+vec2( 0.5,-0.5),num!=-1 && num!=5 && num!=6                    );\n   \tseg += segment(uv.yx+vec2( 0.0, 0.0),num!=-1 && num!=0 && num!=1 && num!=7          );\n\tseg += segment(uv.xy+vec2(-0.5, 0.5),num==0 || num==2 || num==6 || num==8           );\n\tseg += segment(uv.xy+vec2( 0.5, 0.5),num!=-1 && num!=2                              );\n    seg += segment(uv.yx+vec2( 1.0, 0.0),num!=-1 && num!=1 && num!=4 && num!=7          );\n\t\n\treturn seg;\n}\n\n// showNum function modified from https://www.shadertoy.com/view/MdfGzf\nfloat showNum(vec2 uv,int nr)\n{\n\tif (abs(uv.x)>1.5 || abs(uv.y)>1.2) return 0.0;\n\tfloat seg= 0.0;\n\tif (uv.x>0.0){\n\t\tnr /= 10;\n\t\tseg += sevenSegment(uv+vec2(-0.75,0.0),nr);\n\t} else seg += sevenSegment(uv+vec2( 0.75,0.0),int(mod(float(nr),10.0)));\n\treturn seg;\n}\n\n// hash function copy from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 colorPalette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(2.*3.1415926*(c*t+d));\n}\n\nfloat noise(vec2 pos) {\n    vec2 i = floor(pos);\n    vec2 f = fract(pos);\n    \n    float a = hash12(i);\n    float b = hash12(i + vec2(1, 0));\n    float c = hash12(i + vec2(0, 1));\n    float d = hash12(i + vec2(1, 1));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tvec2 uv = (fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n    vec3 color0 = 0.1 + 0.2*cos(iTime*2.+uv.xyx+vec3(0,2,4));\n\n\tuv *= vec2(-4, 4);\n\tuv.x += uv.y/12.0*sin(iTime*2.);\n    uv = rotate2d(noise((uv + vec2(iTime*.5)) * 2.5 + .5) * .2) * uv;\n\n    uv.x += 1.;\n\tfloat seg = 0.0;\n\tseg += showNum(uv,24);\n    uv.x -= 3.;\n    seg += showNum(uv,10);\n    \n    vec3 color1 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec3 finalColor = vec3(0);\n    finalColor = colorPalette(uv.x*.1 + iTime*.5, vec3(.5), vec3(.5), vec3(1.), vec3(0, .33, .67));\n\tfinalColor *= seg;\n    finalColor = smoothstep(color1, finalColor, 1. - vec3(seg));\n    finalColor += smoothstep(0.8, 0.9, 1. - seg) * color0;\n\n\tfragColor = vec4(finalColor,1.0);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csX3DB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 72, 105, 105, 404], [406, 483, 520, 520, 1179], [1181, 1253, 1284, 1284, 1513], [1515, 1580, 1602, 1602, 1722], [1724, 1724, 1784, 1784, 1832], [1834, 1834, 1857, 1857, 2146], [2148, 2148, 2175, 2175, 2257], [2260, 2260, 2317, 2317, 3050]], "test": "untested"}
{"id": "dsXGWS", "name": "Ivean Polkka (UQ) - Sound Shader", "author": "BigETI", "description": "You are free to play around the code and do something else.", "tags": ["sound", "music", "audio"], "likes": 11, "viewed": 464, "published": 3, "date": "1666708741", "time_retrieved": "2024-07-30T16:24:38.751470", "image_code": "// Ivean Polkka - loituma\n\n#ifdef LOW_RESOLUTION_MODE\nconst int imageWidth = 32;\n\nconst int imageHeight = 32;\n#else\nconst int imageWidth = 64;\n\nconst int imageHeight = 64;\n#endif\n\nconst int imageCount = 4;\n\nconst int indicesPerBitmapBitsElement = 8;\n\nconst int primaryBorderSize = 2;\n\nconst int primaryBorderColorIndex = 10;\n\nconst int secondaryBorderColorIndex = 12;\n\nconst vec3 bitmapPalette[] = vec3[]\n(\n        vec3(0.9215686274509803, 0.7215686274509804, 0.6352941176470588),\n        vec3(0.9490196078431372, 0.7843137254901961, 0.7058823529411765),\n        vec3(0.7058823529411765, 0.807843137254902, 0.792156862745098),\n        vec3(0.6196078431372549, 0.43529411764705883, 0.34509803921568627),\n        vec3(0.6274509803921569, 0.3803921568627451, 0.19215686274509805),\n        vec3(0.7686274509803922, 0.5294117647058824, 0.32941176470588235),\n        vec3(0.8392156862745098, 0.5372549019607843, 0.3058823529411765),\n        vec3(0.788235294117647, 0.47058823529411764, 0.23921568627450981),\n        vec3(0.9450980392156862, 0.8588235294117647, 0.8196078431372549),\n        vec3(0.6745098039215687, 0.6235294117647059, 0.6039215686274509),\n        vec3(0.4666666666666667, 0.611764705882353, 0.5607843137254902),\n        vec3(0.396078431372549, 0.38823529411764707, 0.38823529411764707),\n        vec3(0.3607843137254902, 0.5137254901960784, 0.42745098039215684),\n        vec3(0.38823529411764707, 0.23137254901960785, 0.2784313725490196),\n        vec3(0.4823529411764706, 0.3254901960784314, 0.5333333333333333),\n        vec3(0.5490196078431373, 0.37254901960784315, 0.596078431372549)\n);\n\nconst ivec4 bitmapBits[] = ivec4[]\n(\n#ifdef LOW_RESOLUTION_MODE\n    ivec4(0x01000000, 0x03000022, 0x66776666, 0x00666666),\n    ivec4(0x00000000, 0x34000012, 0x66757677, 0x00664666),\n    ivec4(0x00000000, 0x47000011, 0x66057646, 0x70674766),\n    ivec4(0x00100000, 0x77000000, 0x66056776, 0x75674466),\n    ivec4(0x009222A2, 0x77000000, 0x36135577, 0x67664456),\n    ivec4(0x10CA22CA, 0x74190000, 0x57893535, 0x67763335),\n    ivec4(0x00BC2ACC, 0x75150100, 0x80883035, 0x67779913),\n    ivec4(0x00CC9BCC, 0x43050111, 0x88888880, 0x67469981),\n    ivec4(0x00CAACCC, 0x75051111, 0x11881810, 0x67461388),\n    ivec4(0x11C0BCBC, 0x75051111, 0xB388B0BB, 0x654680DB),\n    ivec4(0x11A1CC9C, 0x75151111, 0x88888888, 0x75478982),\n    ivec4(0x1122CC29, 0x77151111, 0x88888888, 0x50461581),\n    ivec4(0x1181CC81, 0x45101111, 0x81881888, 0x52770588),\n    ivec4(0x11010B11, 0x45111111, 0xDDDDDD88, 0x92649588),\n    ivec4(0x11911911, 0x76111111, 0x3D333388, 0x92443788),\n    ivec4(0x11011011, 0x76111111, 0x18998843, 0x22473789),\n    ivec4(0x11801011, 0x57111811, 0x09114344, 0x824747D4),\n    ivec4(0x11898128, 0x67888888, 0x00304444, 0x184774DD),\n    ivec4(0x81811182, 0x64812282, 0xBDB044D4, 0x11444DDD),\n    ivec4(0x81888888, 0x64812288, 0xDDEFDDDD, 0x1144DDDB),\n    ivec4(0x81882228, 0x54882282, 0xDDDDDDFF, 0x11BDDBB3),\n    ivec4(0x90882922, 0x5D812288, 0xDDDDDDFF, 0x81FEEF34),\n    ivec4(0x11889828, 0x3D818888, 0xEEDEEEFF, 0x08EEFF4D),\n    ivec4(0x10882888, 0xBD898888, 0xFFEFFFFF, 0xF8FFFFDB),\n    ivec4(0x10881188, 0xFDEF8888, 0xFFFFFFFF, 0xF1FFEEDE),\n    ivec4(0x09888088, 0xEFFF8088, 0xFFFFFEFF, 0xFFFFFE9F),\n    ivec4(0x88098888, 0xFFFF9E88, 0xFFFFEEFF, 0xFFFEE999),\n    ivec4(0x88088888, 0xFFFEDE01, 0xFFFFEFFF, 0xFF8F88EE),\n    ivec4(0x88088888, 0xFFEE9081, 0xFFFFEFFF, 0xFF818828),\n    ivec4(0x28288888, 0xFF3E1088, 0xFFFFEFFF, 0xFF888898),\n    ivec4(0x98288888, 0xFF038888, 0xFFFFEFFF, 0xF9888898),\n    ivec4(0x21988288, 0xFF008888, 0xFFFFDDFE, 0x993B09AA),\n    ivec4(0x01000000, 0x03000022, 0x66776666, 0x00666666),\n    ivec4(0x01000000, 0x34000022, 0x66757677, 0x00664666),\n    ivec4(0x00000000, 0x47000011, 0x66057676, 0x70674766),\n    ivec4(0x00100011, 0x77000000, 0x66056776, 0x75674466),\n    ivec4(0x00822282, 0x77000000, 0x36135577, 0x67664456),\n    ivec4(0x11882222, 0x74190000, 0x57893535, 0x67663335),\n    ivec4(0x10882222, 0x75150011, 0x80883035, 0x67779913),\n    ivec4(0x11822222, 0x43050111, 0x88888880, 0x67469981),\n    ivec4(0x01222822, 0x75051111, 0x11881810, 0x67461388),\n    ivec4(0x11112282, 0x75051111, 0xB388B0BB, 0x654680DB),\n    ivec4(0x11212282, 0x75151111, 0x88888888, 0x75478982),\n    ivec4(0x11222222, 0x77151111, 0x88888888, 0x50461581),\n    ivec4(0x11118111, 0x45101111, 0x88888888, 0x52770588),\n    ivec4(0x11111111, 0x45111111, 0x18118188, 0x92649588),\n    ivec4(0x11111111, 0x76111111, 0x88888888, 0x92443788),\n    ivec4(0x11111111, 0x76111111, 0x88888849, 0x12473789),\n    ivec4(0x11111111, 0x57112818, 0x09014344, 0x814747D4),\n    ivec4(0x11111128, 0x67888888, 0x00404444, 0x184774DD),\n    ivec4(0x11111182, 0x64818282, 0xBDB044D4, 0x11444DDD),\n    ivec4(0x18818888, 0x54889982, 0xDDEFDDDD, 0x1144DDDB),\n    ivec4(0x11812228, 0x54288888, 0xDDDDDDFF, 0x11BDDB33),\n    ivec4(0x90908822, 0x5D188888, 0xDDDDDDFF, 0x81FEEF34),\n    ivec4(0x81882228, 0x3D118818, 0xEEDEEEFF, 0x08EEFF4D),\n    ivec4(0x88880188, 0xBD898888, 0xFFFFFFFF, 0xF8FFFFDB),\n    ivec4(0x81881888, 0xFDEF8888, 0xFFFFFFFF, 0xF1FFEEDE),\n    ivec4(0x09881181, 0xFFFF8088, 0xFFFFFEFF, 0xFFFFFE9F),\n    ivec4(0x88991118, 0xFFFF9E88, 0xFFFFEEFF, 0xFFFEE999),\n    ivec4(0x88808888, 0xFFFEDE08, 0xFFFFEFFF, 0xFF8F88EE),\n    ivec4(0x88818818, 0xFFEE9081, 0xFFFFEFFF, 0xFF818828),\n    ivec4(0x88888888, 0xFF3E1088, 0xFFFFEFFF, 0xFF888898),\n    ivec4(0x28228888, 0xFF038888, 0xFFFFEFFF, 0xF9888898),\n    ivec4(0x21888288, 0xFF008888, 0xFFFFDDFE, 0x993B09AA),\n    ivec4(0x00000000, 0x03002012, 0x66776666, 0x00666666),\n    ivec4(0x00000000, 0x34001012, 0x66757677, 0x00664666),\n    ivec4(0x00000000, 0x47000011, 0x66057676, 0x70674766),\n    ivec4(0x00111111, 0x77000000, 0x66056776, 0x75674466),\n    ivec4(0x10882282, 0x77000000, 0x36135577, 0x67664456),\n    ivec4(0x11882222, 0x74100000, 0x53893535, 0x67763335),\n    ivec4(0x11822222, 0x75150010, 0x80883035, 0x67779913),\n    ivec4(0x11222222, 0x43050111, 0x88888880, 0x67469981),\n    ivec4(0x11212222, 0x75051111, 0x11881810, 0x67461388),\n    ivec4(0x11112282, 0x75051111, 0xB388B0BB, 0x654680DB),\n    ivec4(0x11212222, 0x75151111, 0x88888888, 0x75478982),\n    ivec4(0x11212228, 0x77101111, 0x88888818, 0x50461581),\n    ivec4(0x11111111, 0x45101111, 0x88888888, 0x52670588),\n    ivec4(0x11111111, 0x45111111, 0x18118188, 0x02649588),\n    ivec4(0x11111111, 0x76111111, 0x88888888, 0x02443788),\n    ivec4(0x11111111, 0x76118111, 0x88888843, 0x11473789),\n    ivec4(0x11111111, 0x56118218, 0x09014344, 0x184747D4),\n    ivec4(0x11111121, 0x67882288, 0x00404444, 0x114774DD),\n    ivec4(0x11118882, 0x64812282, 0xBDE044D4, 0x11444DDD),\n    ivec4(0x11118228, 0x64282288, 0xDDE3DDDD, 0x1144DDDB),\n    ivec4(0x18818822, 0x54882288, 0xDDDDDDFF, 0x11B4DBB3),\n    ivec4(0x18009922, 0x5D818888, 0xDDDDDDFF, 0x81FEEF34),\n    ivec4(0x01888888, 0x3D818888, 0xEEDEEEFF, 0x08EEFF4D),\n    ivec4(0x80888810, 0xBD898888, 0xFFFFFFFF, 0xF8FFFFDB),\n    ivec4(0x89888888, 0xFDEF8801, 0xFFFFFFFF, 0xF1FFEEDF),\n    ivec4(0x99180188, 0xEFEF8888, 0xFFFFFEFF, 0xFFFFFE9F),\n    ivec4(0x88888888, 0xBBCC9981, 0xFFFFEEFF, 0xFFFEE999),\n    ivec4(0x88198888, 0xCCEBDE01, 0xFFFFEFCB, 0xFF8F88EE),\n    ivec4(0x88818888, 0xCCEE9011, 0xFFFFBBCC, 0xFF818828),\n    ivec4(0x88228888, 0xCC3E109A, 0xFFBECCCC, 0xFF888898),\n    ivec4(0x28228888, 0xCC0388CC, 0xEFCCCCBB, 0xF9888898),\n    ivec4(0x21882288, 0xBC9098CC, 0xEFBBBCBB, 0x993B09AA),\n    ivec4(0x00000000, 0x03001011, 0x66776666, 0x00666666),\n    ivec4(0x00000000, 0x34001011, 0x66757677, 0x00664666),\n    ivec4(0x00000000, 0x47000010, 0x66057676, 0x70674766),\n    ivec4(0x00082211, 0x77000000, 0x66056776, 0x75664466),\n    ivec4(0x00DBAC22, 0x77000000, 0x36135577, 0x67664456),\n    ivec4(0x00BC9C22, 0x74100000, 0x53893535, 0x67763335),\n    ivec4(0x11CCAC22, 0x75150000, 0x80883035, 0x67779913),\n    ivec4(0x00CBAC22, 0x430300B5, 0x88888880, 0x67469981),\n    ivec4(0x3BCCCC82, 0x750500D3, 0x11881810, 0x67461A88),\n    ivec4(0xBBC9CC22, 0x470500C0, 0xB388B0BB, 0x654680DB),\n    ivec4(0xCCBCCC22, 0xBB030090, 0x88888888, 0x75478982),\n    ivec4(0xC9CCCC11, 0xBBBB0111, 0x88888891, 0x50461588),\n    ivec4(0x11CCBC11, 0xBBCC9311, 0x81881181, 0x52670588),\n    ivec4(0x11913C11, 0xB9CCBC11, 0xDDDDDD88, 0x02649588),\n    ivec4(0x11819B11, 0x44C9CC10, 0x3D333388, 0x12443788),\n    ivec4(0x11119B11, 0xBDBBCC9C, 0x189919D3, 0x11473789),\n    ivec4(0x11110011, 0xCCCCCCCC, 0x09014444, 0x114747D4),\n    ivec4(0x11110021, 0xBBCCACCA, 0x00304444, 0x114774DD),\n    ivec4(0x11018282, 0x44282292, 0xBDB044D4, 0x11444DDD),\n    ivec4(0x11212228, 0x74282228, 0xDDEFDDDD, 0x1144DDDB),\n    ivec4(0x11802222, 0x7D882288, 0xDDDDDDFF, 0x11B4DBB3),\n    ivec4(0x01818222, 0x5D818888, 0xDDDDDDFF, 0x81FEEF34),\n    ivec4(0x89882822, 0x3D818888, 0xEEDBEEFF, 0x08EEFF4D),\n    ivec4(0x19881888, 0xBD898888, 0xFFEFFFFF, 0xF8FFFFDB),\n    ivec4(0x18880888, 0xFDEF8888, 0xFFEFFFFF, 0xF1FFEEDF),\n    ivec4(0x99881188, 0xEFFF8188, 0xFFFFFFFF, 0xFFEFFE9F),\n    ivec4(0x88888188, 0xFFFF9E88, 0xFFFFEEFF, 0xFFFEE999),\n    ivec4(0x88008888, 0xFFFEDE08, 0xFFFFEFFF, 0xFF8F88EE),\n    ivec4(0x88888888, 0xFFEE9081, 0xFFFFEFFF, 0xFF818828),\n    ivec4(0x88888888, 0xFF3E1088, 0xFFFFEFFF, 0xFF888898),\n    ivec4(0x28828288, 0xFF038888, 0xFFFFEFFF, 0xF9888898),\n    ivec4(0x2289A288, 0xFF908888, 0xFFFFDDFE, 0x993B09AA)\n#else\n    ivec4(0x0, 0x12010000, 0x2122, 0x45030000),\n    ivec4(0x66666666, 0x66666677, 0x66667766, 0x6066),\n    ivec4(0x0, 0x18010000, 0x2222, 0x76640000),\n    ivec4(0x66776667, 0x66666677, 0x66667766, 0x7666),\n    ivec4(0x0, 0x11000000, 0x2212, 0x77340000),\n    ivec4(0x67766777, 0x66666675, 0x66466466, 0x6766),\n    ivec4(0x0, 0x11000000, 0x1111, 0x77440000),\n    ivec4(0x65766777, 0x66666655, 0x66476466, 0x606667),\n    ivec4(0x0, 0x0, 0x1011, 0x77470500),\n    ivec4(0x70766446, 0x66666605, 0x66476766, 0x707667),\n    ivec4(0x0, 0x0, 0x0, 0x77770400),\n    ivec4(0x58667446, 0x76677705, 0x66446766, 0x767667),\n    ivec4(0x10000000, 0x10, 0x0, 0x77776400),\n    ivec4(0x68677776, 0x47667705, 0x66447766, 0x757767),\n    ivec4(0x9001191, 0x1001, 0x0, 0x77575400),\n    ivec4(0x8657576, 0x77565503, 0x66447766, 0x657766),\n    ivec4(0xAB2222A2, 0x1192, 0x0, 0x74773400),\n    ivec4(0x88555577, 0x55365013, 0x56447456, 0x677766),\n    ivec4(0xCC2222C9, 0x20C2, 0x0, 0x74743419),\n    ivec4(0x88350977, 0x59975185, 0x56446456, 0x677766),\n    ivec4(0xCC2222CA, 0x1022CA, 0x1000000, 0x43743719),\n    ivec4(0x88359535, 0x39573089, 0x56337335, 0x60677776),\n    ivec4(0xCC2292CC, 0xA2BC, 0x1000000, 0x45745415),\n    ivec4(0x88391035, 0x30153981, 0x56395355, 0x60677777),\n    ivec4(0xCC2AA2CC, 0xA2BC, 0x11010100, 0x35755715),\n    ivec4(0x88308835, 0x31809188, 0x36993913, 0x60677777),\n    ivec4(0xCC2CC2CC, 0x100A1BC, 0x11011011, 0x39455705),\n    ivec4(0x88188893, 0x1888888, 0x33993989, 0x60676776),\n    ivec4(0xCC9BC9CC, 0x110091CC, 0x11011011, 0x8435605),\n    ivec4(0x88888880, 0x88888888, 0x94991181, 0x60676746),\n    ivec4(0xCCACCCCC, 0x110021CC, 0x11010010, 0x88456605),\n    ivec4(0x88881188, 0x88888888, 0x93198888, 0x676746),\n    ivec4(0xCCACCCCC, 0x110011CA, 0x11111111, 0x88756705),\n    ivec4(0x88189010, 0x1118888, 0xB3138888, 0x1677746),\n    ivec4(0xCCBCCCCC, 0x111111C9, 0x11111111, 0x1756705),\n    ivec4(0x8898DB93, 0x33938188, 0x35898890, 0x1677746),\n    ivec4(0xCCBCCCBC, 0x111110C0, 0x11111111, 0x9756705),\n    ivec4(0x88B099BB, 0x9BB38088, 0x558008DB, 0x657746),\n    ivec4(0xCCBCCC3C, 0x111111C1, 0x10111111, 0x9B756715),\n    ivec4(0x88188831, 0x88088888, 0x5789B89D, 0x10667747),\n    ivec4(0xCCCCCC9C, 0x111111A1, 0x11111111, 0x59757715),\n    ivec4(0x88888888, 0x88888888, 0x5789B982, 0x11757747),\n    ivec4(0xCCCCCC2C, 0x11111192, 0x11111111, 0x8757715),\n    ivec4(0x88888888, 0x88888888, 0x57851188, 0x88707746),\n    ivec4(0xCACCCC29, 0x11112122, 0x11111111, 0x8777715),\n    ivec4(0x88888888, 0x88888888, 0x54158881, 0x22507646),\n    ivec4(0xBACC2C28, 0x11111122, 0x11111111, 0x18457710),\n    ivec4(0x88888888, 0x88888888, 0x54058888, 0x22507576),\n    ivec4(0xCACC1081, 0x11111181, 0x11111111, 0x88455710),\n    ivec4(0x88188188, 0x18818888, 0x54058888, 0x22527577),\n    ivec4(0xCC9C1111, 0x11111111, 0x11111111, 0x88455710),\n    ivec4(0x39331388, 0xB3333339, 0x74058888, 0x22527767),\n    ivec4(0xCC0B1111, 0x11111101, 0x11111111, 0x88455311),\n    ivec4(0xDDDD1B88, 0xD3DDDDDD, 0x77958888, 0x22927564),\n    ivec4(0xBB1A1111, 0x11111191, 0x11111111, 0x8550411),\n    ivec4(0x3DDD8988, 0xD9BDDDBB, 0x46558188, 0x22925574),\n    ivec4(0xAA191111, 0x11111191, 0x11111111, 0x50760411),\n    ivec4(0x33338188, 0x383D3333, 0x76378088, 0x82925544),\n    ivec4(0x88101111, 0x11111191, 0x11111111, 0x43760411),\n    ivec4(0x33198808, 0x18393353, 0x77371388, 0x88225544),\n    ivec4(0x88101111, 0x11111101, 0x11111111, 0x44760311),\n    ivec4(0x9881843, 0x88189099, 0x74373489, 0x88227547),\n    ivec4(0x88101111, 0x11111110, 0x11111811, 0x44761311),\n    ivec4(0x88084544, 0x80888888, 0x74474434, 0x28127047),\n    ivec4(0x18101111, 0x11111180, 0x81181811, 0x44571511),\n    ivec4(0x59434444, 0x93091111, 0x4D4744D4, 0x28825047),\n    ivec4(0x8811111, 0x11111189, 0x81288818, 0x44571511),\n    ivec4(0x4D444444, 0x9900030, 0xDD7444DD, 0x22885047),\n    ivec4(0x8811128, 0x11111189, 0x88888888, 0x44671588),\n    ivec4(0x4D444D44, 0x9B000030, 0xD474D4DD, 0x22185047),\n    ivec4(0x8818122, 0x11111889, 0x28228281, 0x4D671581),\n    ivec4(0x4D44DD44, 0xDD0300B0, 0x4D4DD7DD, 0x82115047),\n    ivec4(0x8112182, 0x18810881, 0x28228882, 0x4D641581),\n    ivec4(0xDD444DD4, 0xDDBD19B0, 0x4D4D44DD, 0x88115044),\n    ivec4(0x98812882, 0x88810888, 0x22228828, 0xDD640581),\n    ivec4(0xDDDD4D44, 0xDDDD9D30, 0x4DDD44DD, 0x11115143),\n    ivec4(0x98882888, 0x82810888, 0x22222288, 0xDD640581),\n    ivec4(0xDDDDDDDD, 0xDDDDDDEF, 0xDDDD34DB, 0x11115144),\n    ivec4(0x22882888, 0x82180888, 0x22222282, 0xDB540328),\n    ivec4(0xDDDDED33, 0xDDDDDDDD, 0xDDDD44D3, 0x111151D4),\n    ivec4(0x22222228, 0x82819188, 0x22222282, 0xDE540388),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xEEDB4DB3, 0x111151BD),\n    ivec4(0xA9292822, 0x18999920, 0x22222282, 0xBF540381),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xFFBF4D34, 0x111131FB),\n    ivec4(0x28292822, 0x8908988, 0x28222288, 0xEF5D0381),\n    ivec4(0xDDDDFFFF, 0xDDDDDDDD, 0xFFEFDD34, 0x1181E0FE),\n    ivec4(0x88982222, 0x8188188, 0x88888888, 0xEF3D0388),\n    ivec4(0xDDEDFFFF, 0xEBEEDDDD, 0xFFEFDB3D, 0x8818E9FE),\n    ivec4(0x88988228, 0x8118188, 0x88888888, 0xEF3D9D81),\n    ivec4(0xEDEEFFFF, 0xEBEEEEDE, 0xFFFFDB4D, 0x8108FEEE),\n    ivec4(0x88988888, 0x18098888, 0x88888888, 0xEF3DEE80),\n    ivec4(0xFEFFFFFF, 0xE3EEFFEF, 0xFEFFDE4D, 0x1198FEEF),\n    ivec4(0x88288888, 0x88108888, 0x88888888, 0xEEBDEE89),\n    ivec4(0xFEFFFFFF, 0xFEFFFFEF, 0xFEFFBDDB, 0x88F8FFFF),\n    ivec4(0x88018888, 0x88818888, 0x88888888, 0xDFEDFF9E),\n    ivec4(0xFEFFFFFF, 0xFBFFFFFF, 0xEEEFEBDE, 0x88F8FFFF),\n    ivec4(0x88118888, 0x88108888, 0x80888888, 0xEFFDFFEF),\n    ivec4(0xEEFFFFFF, 0xFEFFFFFF, 0xEFEEFEDE, 0x88F1FFFF),\n    ivec4(0x88108888, 0x88098888, 0xF888888, 0xEEEEFFFF),\n    ivec4(0xEFFFFFFF, 0xFEFFFFFF, 0xFFFEFFBF, 0x88F9FFFF),\n    ivec4(0x88808888, 0x18098888, 0xFF808888, 0xFFEFFEFF),\n    ivec4(0xEFFEFFFF, 0xF9FFFFFF, 0xEEFEFF9F, 0x88FFFFFF),\n    ivec4(0x8818888, 0x8088088, 0xEF8F8888, 0xFFFFFEFF),\n    ivec4(0xFFEEFFFF, 0x99FFFFFF, 0x82E9FF9F, 0x98FFFFFF),\n    ivec4(0x10888888, 0x11889909, 0xFF9E8888, 0xFFFFEFFF),\n    ivec4(0xFFEEFFFF, 0x99FFFFFF, 0x10E9EE99, 0xF8FFFFFE),\n    ivec4(0x81888888, 0x80888998, 0xFFEF8918, 0xFFFFEFFF),\n    ivec4(0xFFEFFFFF, 0xF9FFFFFF, 0x1192EC9E, 0xE9FFFF9E),\n    ivec4(0x88888888, 0x88888808, 0xFFDE8001, 0xFFFFFFFE),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x888892EE, 0xFFFFEF8F),\n    ivec4(0x88888888, 0x88888808, 0xFFBF8110, 0xFFFFFFFE),\n    ivec4(0xFFEFFFFF, 0xFFFFFFFF, 0x10888898, 0xFEFFEF89),\n    ivec4(0x88888888, 0x88888808, 0x9E909981, 0xFFFFFFEE),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x19888828, 0xFFFFEE81),\n    ivec4(0x88888888, 0x88188808, 0x9109988, 0xFFFFFFEE),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x80888828, 0xFFFFFE88),\n    ivec4(0x88888888, 0x88288828, 0x108088, 0xFFFFFF3E),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x88888898, 0xFEFF9E88),\n    ivec4(0x82888888, 0x88288228, 0x118888, 0xFFFFFF9E),\n    ivec4(0xFFEFFEFF, 0xFEFFFFFF, 0x88888898, 0xFFEFFE88),\n    ivec4(0x29888888, 0x88988228, 0x888888, 0xFFFFFF03),\n    ivec4(0xFFEFFEFF, 0xFFFFFFFF, 0x88888898, 0x9F93B88),\n    ivec4(0x2A888888, 0x88988228, 0x888888, 0xFFFFEF03),\n    ivec4(0xFFDEFEFF, 0xE9FFFFFF, 0x888888A2, 0x1913B09),\n    ivec4(0x2A828888, 0x88218298, 0x10888888, 0xFFFFFE00),\n    ivec4(0xEEDDEDFE, 0xE9FFFFFF, 0x990990AA, 0x1899993B),\n    ivec4(0x29828888, 0x88229929, 0x10888888, 0xEEEE0E88),\n    ivec4(0xDEDDEEEE, 0xE9FFFFEE, 0x9B9BBAC, 0x8199933),\n    ivec4(0x0, 0x12010000, 0x2222, 0x45030000),\n    ivec4(0x66666666, 0x66666677, 0x66667766, 0x6066),\n    ivec4(0x0, 0x12010000, 0x102222, 0x76640000),\n    ivec4(0x66776667, 0x66666677, 0x66667766, 0x7666),\n    ivec4(0x0, 0x18010000, 0x2222, 0x77340000),\n    ivec4(0x67766777, 0x66666675, 0x66466466, 0x6766),\n    ivec4(0x0, 0x11010000, 0x1182, 0x77440000),\n    ivec4(0x65766777, 0x66666655, 0x66476466, 0x606667),\n    ivec4(0x0, 0x1000000, 0x1011, 0x77470500),\n    ivec4(0x70766776, 0x66666605, 0x66476766, 0x707667),\n    ivec4(0x0, 0x0, 0x1000, 0x77770400),\n    ivec4(0x58667446, 0x76677705, 0x66446766, 0x767667),\n    ivec4(0x11000011, 0x10, 0x0, 0x77776400),\n    ivec4(0x68677776, 0x47667705, 0x66447766, 0x757767),\n    ivec4(0x11011111, 0x1010, 0x0, 0x77775400),\n    ivec4(0x8657576, 0x77565503, 0x66447766, 0x657766),\n    ivec4(0x28222282, 0x2182, 0x0, 0x74773400),\n    ivec4(0x88555577, 0x55365913, 0x56447456, 0x677766),\n    ivec4(0x22222222, 0x102182, 0x0, 0x74743410),\n    ivec4(0x88350977, 0x59975185, 0x56446456, 0x677766),\n    ivec4(0x22222222, 0x112288, 0x1000000, 0x43743719),\n    ivec4(0x88359535, 0x39573089, 0x56335335, 0x60677766),\n    ivec4(0x22222222, 0x102288, 0x1000000, 0x45735715),\n    ivec4(0x88391035, 0x30153981, 0x56395553, 0x60677777),\n    ivec4(0x22222222, 0x10102288, 0x1001011, 0x35755715),\n    ivec4(0x88308835, 0x31809188, 0x36993913, 0x60677777),\n    ivec4(0x28222222, 0x11112182, 0x11111011, 0x39455705),\n    ivec4(0x88188893, 0x1888888, 0x33993989, 0x60676776),\n    ivec4(0x88222222, 0x11112182, 0x11011011, 0x8435605),\n    ivec4(0x88888880, 0x88888888, 0x94991181, 0x60676746),\n    ivec4(0x88282222, 0x11011122, 0x11011011, 0x88456605),\n    ivec4(0x88181188, 0x88888888, 0x93198888, 0x676746),\n    ivec4(0x22282222, 0x11011122, 0x11111111, 0x88756705),\n    ivec4(0x88189010, 0x1118888, 0xB3138888, 0x1676746),\n    ivec4(0x22222222, 0x11111121, 0x11111111, 0x1756705),\n    ivec4(0x8898DB93, 0x33938188, 0x35898890, 0x677746),\n    ivec4(0x21222282, 0x11111111, 0x11111111, 0x9756705),\n    ivec4(0x88B099BB, 0x9BB38088, 0x558008DB, 0x657746),\n    ivec4(0x88822882, 0x11111111, 0x11111111, 0x9B756715),\n    ivec4(0x88188831, 0x88088888, 0x5789B89D, 0x11667747),\n    ivec4(0x88222882, 0x11111121, 0x11111111, 0x59757715),\n    ivec4(0x88888888, 0x88888888, 0x5789B982, 0x81757747),\n    ivec4(0x88228822, 0x11111122, 0x11111111, 0x8757715),\n    ivec4(0x88888888, 0x88888888, 0x57851188, 0x88707746),\n    ivec4(0x88228822, 0x11111122, 0x11111111, 0x8777715),\n    ivec4(0x88888888, 0x88888888, 0x54158881, 0x22507646),\n    ivec4(0x88221811, 0x11111111, 0x11111111, 0x18457710),\n    ivec4(0x88888888, 0x88888888, 0x64058888, 0x22507576),\n    ivec4(0x11811111, 0x11111111, 0x11111111, 0x88455710),\n    ivec4(0x88888888, 0x88888888, 0x64058888, 0x22527777),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x88455710),\n    ivec4(0x88888888, 0x88888888, 0x74058888, 0x22527767),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x88455311),\n    ivec4(0x818888, 0x88181011, 0x77958888, 0x22927564),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x8550411),\n    ivec4(0x11888888, 0x88881188, 0x46558188, 0x88925574),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x50760411),\n    ivec4(0x88888888, 0x88888888, 0x76378088, 0x88925544),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x43760411),\n    ivec4(0x88888808, 0x88888888, 0x77371388, 0x88227544),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x44760311),\n    ivec4(0x88881849, 0x88888888, 0x74373489, 0x28125047),\n    ivec4(0x11111111, 0x11111111, 0x81111811, 0x44761311),\n    ivec4(0x88014544, 0x80888888, 0x74474434, 0x28125047),\n    ivec4(0x11111111, 0x11111111, 0x81281818, 0x44571511),\n    ivec4(0x59434444, 0x93091101, 0x4D4744D4, 0x22815047),\n    ivec4(0x11111111, 0x11111111, 0x81888818, 0x44571581),\n    ivec4(0x4D444444, 0x9900030, 0x4D7444DD, 0x22885047),\n    ivec4(0x11111128, 0x11111111, 0x28888888, 0x44671588),\n    ivec4(0x4D44DD44, 0x9B000040, 0xD474D4DD, 0x82185047),\n    ivec4(0x11118122, 0x11111111, 0x28221281, 0x4D671581),\n    ivec4(0x4D44DD44, 0xDD0300B0, 0x4444D7DD, 0x88115047),\n    ivec4(0x11112882, 0x18111111, 0x28828882, 0x4D640581),\n    ivec4(0xDD444DD4, 0xDDBD19B0, 0x4D4D44DD, 0x18115144),\n    ivec4(0x21882888, 0x81111111, 0x22228228, 0xDD640581),\n    ivec4(0xDDDD4DD4, 0xDDDD9DE0, 0x4DDD44DD, 0x11115143),\n    ivec4(0x88882888, 0x81181181, 0x99999982, 0xDD540588),\n    ivec4(0xDDDDDDDD, 0xDDDDDDEF, 0xDDDD34DB, 0x11115144),\n    ivec4(0x88882228, 0x82181881, 0x2A882822, 0xDB540528),\n    ivec4(0xDDDDEDB3, 0xDDDDDDDD, 0xDDDD44D3, 0x111151D4),\n    ivec4(0x21222228, 0x2118881, 0x8A888888, 0xDF540528),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xEEDB4D33, 0x111151BD),\n    ivec4(0x88882822, 0x88900010, 0x2A888888, 0xBF540508),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xFFBF4D34, 0x111131FB),\n    ivec4(0x81882222, 0x88901190, 0x99888888, 0xEF5D0318),\n    ivec4(0xDDDDFFFF, 0xDDDDDDDD, 0xFFEFDD34, 0x1881E0FE),\n    ivec4(0x90992222, 0x91898888, 0x10000012, 0xEF3D0308),\n    ivec4(0xDDEDFFFF, 0xEBEEDDDD, 0xFFEFDB3D, 0x8818E9FE),\n    ivec4(0x98228228, 0x90818888, 0x88888818, 0xEF3D9D11),\n    ivec4(0xEDEEFFFF, 0xEBEEEEDE, 0xFFFFDB4D, 0x8108FEEE),\n    ivec4(0x18822188, 0x8888888, 0x88888888, 0xEFBDEE80),\n    ivec4(0xFEFFFFFF, 0xE3EEFFEF, 0xFEFFDE4D, 0x8898FEEF),\n    ivec4(0x88010088, 0x8888888, 0x88888888, 0xEEBDEF89),\n    ivec4(0xFEFFFFFF, 0xFEFFFFFF, 0xFEFFEDDB, 0x88F8FFFF),\n    ivec4(0x88181988, 0x8888888, 0x88888888, 0xBFEDFF9E),\n    ivec4(0xFEFFFFFF, 0xFBFFFFFF, 0xEEEFEEDE, 0x88F8FFFF),\n    ivec4(0x88188088, 0x18818888, 0x80888888, 0xEFFDFFEF),\n    ivec4(0xEEFFFFFF, 0xFEFFFFFF, 0xEFEEFEDE, 0x88F1FFFF),\n    ivec4(0x88081988, 0x88108888, 0xF888888, 0xEEEEFFFF),\n    ivec4(0xEFFFFFFF, 0xFEFFFFFF, 0xFFFEFFBF, 0x88F9FFFF),\n    ivec4(0x88111881, 0x88098188, 0xFF808888, 0xFFFFFFFF),\n    ivec4(0xEFFEFFFF, 0xF9FFFFFF, 0xEEFEFF9F, 0x88FFFFFF),\n    ivec4(0x18898881, 0x8810188, 0xEF8F8888, 0xFFFFFEFF),\n    ivec4(0xFFEEFFFF, 0x99FFFFFF, 0x82E9FF9F, 0x98FFFFFF),\n    ivec4(0x10118818, 0x11888899, 0xFF9E8888, 0xFFFFEFFF),\n    ivec4(0xFFEEFFFF, 0x99FFFFFF, 0x10E9EE99, 0xF8FFFFFE),\n    ivec4(0x88888188, 0x80888800, 0xFFEF8918, 0xFFFFEFFF),\n    ivec4(0xFFEEFFFF, 0xF9FFFFFF, 0x1192EC9E, 0xE9FFFF9E),\n    ivec4(0x88881888, 0x88888880, 0xFFDE8008, 0xFFFFFFFE),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x888892EE, 0xFFFFEF8F),\n    ivec4(0x88888881, 0x88881881, 0xFFBF8110, 0xFFFFFFFE),\n    ivec4(0xFFEFFFFF, 0xFFFFFFFF, 0x10888898, 0xFEFFEF89),\n    ivec4(0x88888818, 0x88880881, 0x9E909981, 0xFFFFFFEE),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x19888828, 0xFFFFEE81),\n    ivec4(0x88888888, 0x88880888, 0x9109988, 0xFFFFFFEE),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x80888828, 0xFFFFFE88),\n    ivec4(0x88888888, 0x88882288, 0x108088, 0xFFFFFF3E),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x88888898, 0xFEFF9E88),\n    ivec4(0x82888888, 0x88882922, 0x818888, 0xFFFFFF9E),\n    ivec4(0xFFEFFEFF, 0xFEFFFFFF, 0x88888898, 0xFFEFFE88),\n    ivec4(0x22888888, 0x88282922, 0x888888, 0xFFFFFF03),\n    ivec4(0xFFEFFEFF, 0xFFFFFFFF, 0x88888898, 0x9F93B88),\n    ivec4(0x22828888, 0x88288888, 0x888888, 0xFFFFEF03),\n    ivec4(0xFFDEFEFF, 0xEFFFFFFF, 0x888888A2, 0x1913B09),\n    ivec4(0x28828888, 0x88218888, 0x10888888, 0xFFFFFE00),\n    ivec4(0xEEDDEDFE, 0xE9FFFFFF, 0x990990AA, 0x1899993B),\n    ivec4(0x88128888, 0x88808888, 0x10888888, 0xEEEE0E88),\n    ivec4(0xEEDDEEEE, 0xE9FFFFEE, 0x9B9BBAC, 0x8199933),\n    ivec4(0x0, 0x1000000, 0x202212, 0x47030000),\n    ivec4(0x66666666, 0x66666677, 0x66667766, 0x6066),\n    ivec4(0x0, 0x1000000, 0x202282, 0x76540000),\n    ivec4(0x66776667, 0x66666677, 0x66667766, 0x7666),\n    ivec4(0x0, 0x1000000, 0x102212, 0x77340000),\n    ivec4(0x67766777, 0x66666675, 0x66466466, 0x6666),\n    ivec4(0x0, 0x1000000, 0x102112, 0x47470000),\n    ivec4(0x65766777, 0x66666655, 0x66476466, 0x606667),\n    ivec4(0x0, 0x1000000, 0x1111, 0x77470500),\n    ivec4(0x70766776, 0x66666605, 0x66476766, 0x707667),\n    ivec4(0x1000000, 0x10, 0x0, 0x77770400),\n    ivec4(0x51667446, 0x76677705, 0x66446766, 0x767667),\n    ivec4(0x11111111, 0x1011, 0x0, 0x77770400),\n    ivec4(0x68677776, 0x47667705, 0x66447766, 0x757667),\n    ivec4(0x22222288, 0x1182, 0x0, 0x77775400),\n    ivec4(0x8657576, 0x77565503, 0x66447766, 0x657766),\n    ivec4(0x22222282, 0x102188, 0x0, 0x74773400),\n    ivec4(0x88555577, 0x55365013, 0x56447456, 0x677766),\n    ivec4(0x22222222, 0x112228, 0x0, 0x74743410),\n    ivec4(0x88550977, 0x59575185, 0x56446456, 0x677766),\n    ivec4(0x22222222, 0x112288, 0x0, 0x43743710),\n    ivec4(0x88359535, 0x39533089, 0x56337335, 0x60677776),\n    ivec4(0x22222222, 0x10102288, 0x1000000, 0x45745715),\n    ivec4(0x88391035, 0x30153981, 0x56395355, 0x60677777),\n    ivec4(0x22222222, 0x11112282, 0x1000010, 0x39755715),\n    ivec4(0x88308835, 0x31809188, 0x35993913, 0x60677777),\n    ivec4(0x28222222, 0x11112182, 0x11111011, 0x30455705),\n    ivec4(0x88188893, 0x1888888, 0x33993989, 0x60676776),\n    ivec4(0x88222222, 0x11112122, 0x1011011, 0x98436605),\n    ivec4(0x88888880, 0x88888888, 0xA3991181, 0x60676746),\n    ivec4(0x82882222, 0x11011122, 0x1011011, 0x88756605),\n    ivec4(0x88181188, 0x88888888, 0x93198888, 0x676746),\n    ivec4(0x22222222, 0x11111121, 0x1111111, 0x88756705),\n    ivec4(0x88189010, 0x1118888, 0xB3138888, 0x676746),\n    ivec4(0x22222282, 0x11111111, 0x11111111, 0x1756705),\n    ivec4(0x8898DB93, 0x33938188, 0x35898890, 0x676746),\n    ivec4(0x81222282, 0x11111111, 0x11111111, 0x9756705),\n    ivec4(0x88B099BB, 0x9BB38088, 0x558008DB, 0x1657746),\n    ivec4(0x81228882, 0x11111111, 0x11111111, 0x9B755715),\n    ivec4(0x88188838, 0x88088888, 0x5789B89D, 0x11657747),\n    ivec4(0x82228822, 0x11111121, 0x11111111, 0x59755715),\n    ivec4(0x88888888, 0x88888888, 0x5789B982, 0x88757747),\n    ivec4(0x82228822, 0x11111121, 0x11111111, 0x8757715),\n    ivec4(0x88888888, 0x88888888, 0x57891188, 0x12707746),\n    ivec4(0x82228828, 0x11111121, 0x11111111, 0x1777710),\n    ivec4(0x88888818, 0x88888888, 0x54158881, 0x22507646),\n    ivec4(0x88281811, 0x11111111, 0x11111111, 0x18457710),\n    ivec4(0x88888888, 0x88888888, 0x64058888, 0x22507576),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x88455510),\n    ivec4(0x88888888, 0x88888888, 0x64058888, 0x22527567),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x88455710),\n    ivec4(0x88888888, 0x88888888, 0x74958888, 0x22927767),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x88455311),\n    ivec4(0x1818888, 0x88181011, 0x77958888, 0x28027564),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x8550411),\n    ivec4(0x11888888, 0x88881188, 0x46558888, 0x28025574),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x50760411),\n    ivec4(0x88888888, 0x88888888, 0x76378088, 0x28025544),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x43760411),\n    ivec4(0x88888808, 0x88888888, 0x77341388, 0x28127544),\n    ivec4(0x11111111, 0x11111111, 0x88811111, 0x44761311),\n    ivec4(0x88881843, 0x88888888, 0x74373489, 0x22117647),\n    ivec4(0x11111111, 0x11111111, 0x88821818, 0x44761311),\n    ivec4(0x88014544, 0x80888888, 0x74474434, 0x22185047),\n    ivec4(0x11111111, 0x11111111, 0x88828818, 0x44561311),\n    ivec4(0x59434444, 0x95091101, 0x4D4744D4, 0x82185047),\n    ivec4(0x11111111, 0x11111111, 0x82888818, 0x44571588),\n    ivec4(0x4D444444, 0x9990930, 0x4D7444DD, 0x88115047),\n    ivec4(0x11111121, 0x11111111, 0x22228888, 0x44671588),\n    ivec4(0x4D44DD44, 0x9B000040, 0xD474D4DD, 0x88115047),\n    ivec4(0x11118122, 0x18111111, 0x22828881, 0x4D671581),\n    ivec4(0x4D44DD44, 0xDD0300B0, 0x4D4DD7DD, 0x11115047),\n    ivec4(0x88882882, 0x18111111, 0x22228882, 0x4D640581),\n    ivec4(0xDD444DD4, 0xDDBD19E0, 0x4D4D34DD, 0x11115144),\n    ivec4(0x88882288, 0x88111111, 0x22222288, 0xDD640588),\n    ivec4(0xDDDDDDD4, 0xDDDD9DE0, 0x4DDD44DD, 0x11115144),\n    ivec4(0x21822228, 0x88111111, 0x22222288, 0xDD640528),\n    ivec4(0xDDDDDDDD, 0xDDDDDDE3, 0xDDDD34DB, 0x11115144),\n    ivec4(0x28822228, 0x88111181, 0x22222288, 0xDB540588),\n    ivec4(0xDDDDED33, 0xDDDDDDDD, 0xDDDD44D3, 0x111151D4),\n    ivec4(0x88882222, 0x88181181, 0x22222288, 0xDF540588),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xEEDB4DB3, 0x111151B4),\n    ivec4(0x88222222, 0x88181181, 0x88888888, 0xDF540388),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xFFBF4D34, 0x111131FB),\n    ivec4(0x99992222, 0x88181100, 0x88888888, 0xEF5D0381),\n    ivec4(0xDDDDFFFF, 0xDDDDDDDD, 0xFFEFDD34, 0x1181E0FE),\n    ivec4(0x88222282, 0x88110081, 0x88888888, 0xEF3D0318),\n    ivec4(0xDDEDFFFF, 0xEBEEDDDD, 0xFFEFDB3D, 0x8818E9FE),\n    ivec4(0x88882988, 0x88018188, 0x88888888, 0xEF3D9D81),\n    ivec4(0xEDEEFFFF, 0xEBEEEEDE, 0xFFFFDB4D, 0x8108FEEE),\n    ivec4(0x88882288, 0x88108888, 0x88888888, 0xEF3DE380),\n    ivec4(0xFEFFFFFF, 0xE3EEFFEF, 0xFEFFDB4D, 0x8898FEEF),\n    ivec4(0x88889810, 0x88808888, 0x88888888, 0xEFBDEF89),\n    ivec4(0xFEFFFFFF, 0xFEFFFFFF, 0xFEFFBDDB, 0x88F8FFFF),\n    ivec4(0x88889810, 0x18898888, 0x88888888, 0xBFEDFF9E),\n    ivec4(0xFEFFFFFF, 0xFBFFFFFF, 0xEEEFEBDE, 0x88F8FFFF),\n    ivec4(0x88880188, 0x1898888, 0x80881801, 0xEFFDFFEF),\n    ivec4(0xEEFFFFFF, 0xFEFFFFFF, 0xEFEEFEDF, 0x88F1FFFF),\n    ivec4(0x88181088, 0x88118888, 0x9F101181, 0xEEEEFFEF),\n    ivec4(0xEFFFFFFF, 0xFEFFFFFF, 0xFFFEFFBF, 0x88E9FFFF),\n    ivec4(0x81018188, 0x88998818, 0x9B888888, 0xFFEFFEEF),\n    ivec4(0xEFFEFFFF, 0xF9FFFFFF, 0xEEFEFF9F, 0x88FFFFFF),\n    ivec4(0x99818888, 0x99000011, 0x2C888801, 0xFFEEBBCC),\n    ivec4(0xFFEEFEFF, 0x99FFFFFF, 0x89F9FF9F, 0x98FFFFFF),\n    ivec4(0x10888888, 0x880088, 0x9E991981, 0xEEBBCCCC),\n    ivec4(0xFFEEFEFF, 0x99FFFFFF, 0x10E9EE99, 0xF8FFFFFE),\n    ivec4(0x81888888, 0x80880800, 0xEEBE8918, 0xCCCCBCBB),\n    ivec4(0xFFEEFFEE, 0xF9FFFFFF, 0x1192EE9E, 0xE9FFFF9E),\n    ivec4(0x88888888, 0x88881819, 0xFFDE8901, 0xCCCCBCEB),\n    ivec4(0xFFEFBECB, 0xFFFFFFFF, 0x888892EE, 0xFFFFEF8F),\n    ivec4(0x88888888, 0x81881880, 0xFFBF1200, 0xCCCCBCFE),\n    ivec4(0xFFBECBCC, 0xFFFFFFFF, 0x10888898, 0xFEFFEF89),\n    ivec4(0x88888888, 0x82880881, 0x9F909911, 0xCCCCECEE),\n    ivec4(0xEEBBCCCC, 0xFEFFFFFF, 0x19888828, 0xFFFFEF81),\n    ivec4(0x88888888, 0x88882888, 0x9102922, 0xBBCCEEEE),\n    ivec4(0xBBCCCCCC, 0xFEFFFFEF, 0x80888828, 0xFFFFFE88),\n    ivec4(0x82888888, 0x18882222, 0x10819A, 0xCBCCFE3E),\n    ivec4(0xCCCCCCCC, 0xFEFFFFBE, 0x88888898, 0xFEFF9E88),\n    ivec4(0x22888888, 0x9882922, 0x8198AC, 0xCBCCFE9E),\n    ivec4(0xCCCCBCBB, 0xFEFFBECB, 0x88888898, 0xFFEFFE88),\n    ivec4(0x22888888, 0x8A282222, 0x88C2CC, 0xCCCCFE03),\n    ivec4(0xCCCCBCBB, 0xFFEFCBCC, 0x88888898, 0x9F93B88),\n    ivec4(0x28828888, 0x82288888, 0x1088CACC, 0xCCCCEE03),\n    ivec4(0xCCCCBBBB, 0xEFEFCBCC, 0x888888A2, 0x1191BB09),\n    ivec4(0x88228888, 0x82218888, 0x1098CCCC, 0xCCBCFE90),\n    ivec4(0xCCBCBDBB, 0xE9EFBBBB, 0x990992AA, 0x1899993B),\n    ivec4(0x88228888, 0x89222888, 0x10A8CCCC, 0xCCBC0B88),\n    ivec4(0xCCBBBBBB, 0xE9FFBBBB, 0x9B9BB9C, 0x819993B),\n    ivec4(0x0, 0x1000000, 0x102211, 0x47030000),\n    ivec4(0x66666666, 0x66666677, 0x66667766, 0x6066),\n    ivec4(0x0, 0x1000000, 0x102212, 0x76540000),\n    ivec4(0x66776667, 0x66666677, 0x66667766, 0x7666),\n    ivec4(0x0, 0x1000000, 0x101111, 0x77340000),\n    ivec4(0x67766777, 0x66666675, 0x66466466, 0x6766),\n    ivec4(0x0, 0x1000000, 0x1111, 0x47470000),\n    ivec4(0x65766777, 0x66666655, 0x66476466, 0x506667),\n    ivec4(0x1100, 0x0, 0x1010, 0x77470500),\n    ivec4(0x70766776, 0x66666605, 0x66476766, 0x707667),\n    ivec4(0x11111111, 0x1011, 0x0, 0x77770400),\n    ivec4(0x51667446, 0x76677705, 0x66446766, 0x767667),\n    ivec4(0x99228211, 0x1008, 0x0, 0x77770400),\n    ivec4(0x68677776, 0x47667705, 0x66447766, 0x757666),\n    ivec4(0xCC2A2288, 0x1020A2, 0x0, 0x77775400),\n    ivec4(0x8657576, 0x77565503, 0x66447766, 0x657766),\n    ivec4(0xBBAC2222, 0xC9DB, 0x0, 0x74773400),\n    ivec4(0x88555577, 0x55365013, 0x56447456, 0x677766),\n    ivec4(0xCBAB2222, 0x99BBDB, 0x0, 0x74743410),\n    ivec4(0x88550977, 0x59575185, 0x56446456, 0x677766),\n    ivec4(0xCB9C2222, 0xCABC, 0x0, 0x43743710),\n    ivec4(0x88359535, 0x39533089, 0x56337335, 0x677776),\n    ivec4(0xCB2C2222, 0x11C9BC, 0x1000000, 0x45745715),\n    ivec4(0x88391035, 0x30153981, 0x56395355, 0x60677777),\n    ivec4(0xCCAC2222, 0x1111C9CC, 0x0, 0x39755715),\n    ivec4(0x88308835, 0x31809188, 0x35993913, 0x60677777),\n    ivec4(0xCCAC2222, 0x1011C0CB, 0x190, 0x30455705),\n    ivec4(0x88188893, 0x1888888, 0x33993989, 0x60676776),\n    ivec4(0xCCAC2222, 0x9300B9CB, 0x1B5, 0x98435603),\n    ivec4(0x88888880, 0x88888888, 0xA3991181, 0x60676746),\n    ivec4(0xCCCC2222, 0xBB9390CC, 0x11B3, 0x88757703),\n    ivec4(0x88181188, 0x88888888, 0x93198888, 0x676746),\n    ivec4(0xCCCC2282, 0xBB3B21CC, 0x110011D3, 0x88757405),\n    ivec4(0x88189010, 0x1118888, 0xB31A8888, 0x676746),\n    ivec4(0xCCCC2282, 0xCBBB29CA, 0x111100B9, 0x1755705),\n    ivec4(0x8898DB93, 0x33938188, 0x35898890, 0x657746),\n    ivec4(0xCCCC8222, 0xBBBBABC9, 0x110000C0, 0x9476705),\n    ivec4(0x88B099BB, 0x9BB38088, 0x558008DB, 0x11657746),\n    ivec4(0xCCCC8222, 0xBDCBBCCC, 0x10010A1, 0x9B437405),\n    ivec4(0x88188838, 0x88088888, 0x5789B89D, 0x81657747),\n    ivec4(0xCCCC8222, 0xCACCCCBC, 0x1190, 0xBBBB4403),\n    ivec4(0x88888888, 0x88888888, 0x5789B982, 0x88757747),\n    ivec4(0xCCCC8218, 0x91CCCCCC, 0x9110010, 0xB9BBBB9B),\n    ivec4(0x88888888, 0x88888888, 0x57891188, 0x22707746),\n    ivec4(0xCCCC8911, 0x11C9CCCC, 0x3010011, 0xA1BBCCBB),\n    ivec4(0x88888891, 0x88888888, 0x54158888, 0x22507646),\n    ivec4(0xCCCC8011, 0x1191CCCC, 0x9B001011, 0x98BBBBBB),\n    ivec4(0x88888800, 0x88888888, 0x64058888, 0x22507576),\n    ivec4(0xCCBC8011, 0x1111C9CC, 0xBC931111, 0x98BBBCCC),\n    ivec4(0x88111181, 0x11818888, 0x64058888, 0x22527567),\n    ivec4(0xCC3C1011, 0x111191CA, 0xBC3B1111, 0x18B3BBCC),\n    ivec4(0x33339388, 0xB9333399, 0x74958888, 0x22527767),\n    ivec4(0xCC3C1111, 0x11111191, 0xCCBC1911, 0x18B9BDCC),\n    ivec4(0xDDDD1388, 0xD3DDDDDD, 0x77958888, 0x28025564),\n    ivec4(0xC93C1111, 0x11111111, 0xCBCC9B11, 0x843CBBC),\n    ivec4(0xBBDB8988, 0xD9DDDDB3, 0x46558888, 0x28025574),\n    ivec4(0xC99B1111, 0x11111181, 0xCCCC3C10, 0x50449BC9),\n    ivec4(0x33338188, 0x383D3333, 0x76378088, 0x28125544),\n    ivec4(0xC99B1111, 0x11111111, 0xC9CCBC03, 0x43449B99),\n    ivec4(0x33938808, 0x18393333, 0x77341388, 0x22117547),\n    ivec4(0xB99B1111, 0x11111111, 0xCCCCCC9C, 0xDDBDBBBB),\n    ivec4(0x1918D3, 0x88189099, 0x74373489, 0x22117647),\n    ivec4(0x99931111, 0x19111111, 0xCCCCCCBC, 0xBDCBBCCC),\n    ivec4(0x889945D4, 0x80888888, 0x7D474434, 0x82185047),\n    ivec4(0x80001111, 0x13111111, 0xCCCCCCCC, 0xBDCCBBCC),\n    ivec4(0x39444444, 0x95091101, 0x4D4744D4, 0x88115047),\n    ivec4(0x80011811, 0x9B111111, 0xCCCCCCCC, 0xDDBBBBCC),\n    ivec4(0xDD444444, 0x9900930, 0xDD7444DD, 0x88115047),\n    ivec4(0x81008821, 0x3C111111, 0xCCACAACA, 0xBDBBCDCC),\n    ivec4(0x4D44DD44, 0x9B000030, 0x4474D4DD, 0x11115047),\n    ivec4(0x88121822, 0xA101101, 0x222288C2, 0x4D449B92),\n    ivec4(0x4D44DD44, 0xDD0300B0, 0x4444D7DD, 0x11115047),\n    ivec4(0x88822282, 0x82111101, 0x22228292, 0xDD442328),\n    ivec4(0xDD444DD4, 0xDDBD19B0, 0x4D4D34DD, 0x11115144),\n    ivec4(0x88222288, 0x82181101, 0x22222228, 0xDD441322),\n    ivec4(0xDDDD4DD4, 0xDDDD9DE0, 0x4DDD44DD, 0x11115144),\n    ivec4(0x88228228, 0x10111121, 0x22222228, 0xDD740328),\n    ivec4(0xDDDDDDDD, 0xDDDDDDEF, 0xDDDD34DB, 0x11115144),\n    ivec4(0x28222222, 0x11111181, 0x22222288, 0xDB7D0528),\n    ivec4(0xDDDDED33, 0xDDDDDDDD, 0xDDDD44D3, 0x111151D4),\n    ivec4(0x28222222, 0x18118180, 0x28228288, 0xDE7D0588),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xEEDB4DB3, 0x111151B4),\n    ivec4(0x92822222, 0x88880119, 0x88888888, 0xBF5D0588),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xFFBF4D34, 0x111131FB),\n    ivec4(0x92822222, 0x88010981, 0x88888888, 0xEF5D0381),\n    ivec4(0xDDDDFFFF, 0xDDDDDDDD, 0xFFEFDD34, 0x1181E0FE),\n    ivec4(0x88222822, 0x18908988, 0x88888888, 0xEF3D0318),\n    ivec4(0xDDEDFFFF, 0xEBEEDDDD, 0xFFEFDB3D, 0x8818E9EE),\n    ivec4(0x88288822, 0x18898088, 0x88888888, 0xEF3D9D81),\n    ivec4(0xEDEEFFFF, 0xEBEEEEDB, 0xFFFFDB4D, 0x8108FEEE),\n    ivec4(0x88188888, 0x18891088, 0x88888888, 0xEF3DEE80),\n    ivec4(0xFEFFFFFF, 0xE3EEFFEE, 0xFEFFDB4D, 0x8898FEEF),\n    ivec4(0x88188188, 0x18198088, 0x88888888, 0xEFBDEF89),\n    ivec4(0xFEFFFFFF, 0xFEFFFFEF, 0xFEFFBDDB, 0x88F8FFFF),\n    ivec4(0x88088188, 0x88008188, 0x88888888, 0xBFEDFF9F),\n    ivec4(0xFEFFFFFF, 0xFBFFFFEF, 0xEEEFEBDE, 0x88F8FFFF),\n    ivec4(0x88088188, 0x88188888, 0x80888888, 0xEFFDFFEF),\n    ivec4(0xEEFFFFFF, 0xFEFFFFEF, 0xEFEEFEDF, 0x88F1FFFF),\n    ivec4(0x88088188, 0x88918888, 0xF888888, 0xEEEEFFFF),\n    ivec4(0xEEFFFFFF, 0xFEFFFFEF, 0xFFFEFFBF, 0x88E9FFFF),\n    ivec4(0x88118888, 0x88998888, 0xFE818888, 0xFFEFFEFF),\n    ivec4(0xEFFFFFFF, 0xF9FFFFFF, 0xEEFEFF9F, 0x88FFFFEF),\n    ivec4(0x88108888, 0x8118088, 0xFF198888, 0xFFFFEEFF),\n    ivec4(0xFEEEFEFF, 0x99FFFFFF, 0x89F9FF9F, 0x98FEFFFF),\n    ivec4(0x18818888, 0x11880988, 0xFF9E8188, 0xFFFFEFFF),\n    ivec4(0xFEEEFEFF, 0x99FFFFFF, 0x10E9EE99, 0xF8FFFFFE),\n    ivec4(0x19888888, 0x80889099, 0xFFBF8918, 0xFFFFEFFF),\n    ivec4(0xFEEFFFFF, 0xF9FFFFFF, 0x1192EE9E, 0xE9FFFF9E),\n    ivec4(0x89888888, 0x88889800, 0xFFDE8908, 0xFFFFFFFE),\n    ivec4(0xFEEFFFFF, 0xFFFFFFFF, 0x888892EE, 0xFFFFEF8F),\n    ivec4(0x81888888, 0x88889888, 0xFFBF1981, 0xFFFFFFFE),\n    ivec4(0xFEEFFFFF, 0xFFFFFFFF, 0x10888898, 0xFEFFEF89),\n    ivec4(0x18888888, 0x88889888, 0x9F909981, 0xFFFFFFEE),\n    ivec4(0xEFEFFFFF, 0xFEFFFFFF, 0x19888828, 0xFFFFFF81),\n    ivec4(0x28888888, 0x88889188, 0x9109988, 0xFFFFFFEE),\n    ivec4(0xEFEFFFFF, 0xFEFFFFFF, 0x80888828, 0xFFFFFE88),\n    ivec4(0x28888888, 0x88889988, 0x108188, 0xFFFFFF3E),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x88888898, 0xFEFF9E88),\n    ivec4(0x28828888, 0x88889988, 0x818888, 0xFFFFFF9E),\n    ivec4(0xFFEFFEFF, 0xFEFFFFFF, 0x88888898, 0xFFEFFE88),\n    ivec4(0x88828888, 0x88282282, 0x888888, 0xFFFFFF03),\n    ivec4(0xFFEFFEFF, 0xFFFFFFFF, 0x88888898, 0x9F93B88),\n    ivec4(0x88228888, 0x88288882, 0x10888888, 0xFFFFEF03),\n    ivec4(0xFFEEFEFF, 0xEFFFFFFF, 0x888888A2, 0x11913B09),\n    ivec4(0x88A28288, 0x88222889, 0x10888888, 0xFFFFFE90),\n    ivec4(0xEEDDEDFE, 0xE9FFFFFF, 0x990992AA, 0x1899993B),\n    ivec4(0x88A28288, 0x88222229, 0x10888888, 0xEEEE0E18),\n    ivec4(0xEEEDEEEE, 0xE9FFFFEE, 0x9B9BB9C, 0x819993B)\n#endif\n);\n\n\n#ifdef ENABLE_VIBING_CAT\n\nconst int vibingCatBorderWidth = 2;\n\nconst int vibingCatBorderHeight = 2;\n\nconst int vibingCatBorderColorIndex = 0;\n\nconst int vibingCatImageWidth = 16;\n\nconst int vibingCatImageHeight = 16;\n\nconst int vibingCatImageCount = 147;\n\nconst int vibingCatRepeatAtImageIndex = 74;\n\nconst int vibingCatRepeatingFrameCount = vibingCatImageCount - vibingCatRepeatAtImageIndex;\n\nconst int vibingCatAnimationFrameCount = vibingCatImageCount + (vibingCatImageCount - vibingCatRepeatAtImageIndex);\n\nconst vec3 vibingCatBitmapPalette[] = vec3[]\n(\n        vec3(0.15294117647058825, 0.1411764705882353, 0.1450980392156863),\n        vec3(0.27450980392156865, 0.23137254901960785, 0.2196078431372549),\n        vec3(0.24313725490196078, 0.25098039215686274, 0.24705882352941178),\n        vec3(0.3137254901960784, 0.25882352941176473, 0.23921568627450981),\n        vec3(0.2196078431372549, 0.23921568627450981, 0.25882352941176473),\n        vec3(0.28627450980392155, 0.24313725490196078, 0.2549019607843137),\n        vec3(0.23529411764705882, 0.25882352941176473, 0.27450980392156865),\n        vec3(0.403921568627451, 0.34509803921568627, 0.32941176470588235),\n        vec3(0.5882352941176471, 0.45098039215686275, 0.41568627450980394),\n        vec3(0.6392156862745098, 0.5215686274509804, 0.4823529411764706),\n        vec3(0.5764705882352941, 0.49019607843137253, 0.5058823529411764),\n        vec3(0.49019607843137253, 0.5019607843137255, 0.5058823529411764),\n        vec3(0.6901960784313725, 0.596078431372549, 0.5568627450980392),\n        vec3(0.7843137254901961, 0.6941176470588235, 0.6588235294117647),\n        vec3(0.8196078431372549, 0.7686274509803922, 0.7333333333333333),\n        vec3(0.8784313725490196, 0.8509803921568627, 0.8196078431372549)\n);\n\nconst ivec4 vibingCatBitmapBits[] = ivec4[]\n(\n        ivec4(0xFFDEFFDE, 0xDCCCEB, 0xDFDCFFFF, 0xDBDDFE),\n        ivec4(0xBCFCFFEF, 0xD1FDFF, 0x17F7FFEF, 0x80FE9F),\n        ivec4(0x67FCFFCD, 0x70FEBE, 0xEDFFEF8C, 0x70FFEF),\n        ivec4(0xFFFF9D88, 0xD2FFFF, 0xFFFF9E87, 0xE3FFFF),\n        ivec4(0xFFFFCE88, 0x11FBFFFF, 0xFFFFCD89, 0x10FCFFFF),\n        ivec4(0xEFDD9C89, 0x20FCEFFF, 0xEFCDCC89, 0x78FCEEFE),\n        ivec4(0xDECD9C89, 0xCCFDEDFE, 0xDDCC9988, 0xCCEDDEED),\n        ivec4(0xCDCC8888, 0x99D9DECD, 0xCCC99888, 0x89C9CDCC),\n        ivec4(0xDEDCFFEF, 0xD7DDFE, 0xACEAFFDF, 0xC1EDEF),\n        ivec4(0x17FBFFCD, 0x80FDCF, 0x8BFDEF9C, 0x30FD9F),\n        ivec4(0xFEFFCE88, 0x70FFEF, 0xFFFF9E88, 0x90FFFF),\n        ivec4(0xFFFF9D88, 0x20D3FFFF, 0xFFFFCD89, 0x10F7FFFF),\n        ivec4(0xEFDE9D88, 0xF9FFFF, 0xFFDD9C89, 0x30FCEFFF),\n        ivec4(0xDECC9C89, 0x36FADEFF, 0xDECC9C88, 0x7AFCEEFE),\n        ivec4(0xDDCC8988, 0xCCEDDEDD, 0xDDCC8988, 0xC9DCDECD),\n        ivec4(0xCC9C9989, 0x98CCCECC, 0xCC999C89, 0x9C99CDCC),\n        ivec4(0x8CC8FFCE, 0x90DDFE, 0x1AE3EF9C, 0x30EDDF),\n        ivec4(0xACFECF88, 0xFCDF, 0xFFFFCF88, 0x10FDFF),\n        ivec4(0xFFFFDE88, 0x71FFFF, 0xFFFFCD89, 0x71FFFF),\n        ivec4(0xEFDECD89, 0xD2FFFF, 0xFFDD9C89, 0xF7FFFE),\n        ivec4(0xDFCD9C88, 0x32E7EFFE, 0xDECC9988, 0xE3DFFE),\n        ivec4(0xDECC8988, 0x53F7DEDD, 0xCDCC8988, 0xA9D7DECD),\n        ivec4(0xCDCC9C99, 0xCCDCDECD, 0xCCCC9C9C, 0x99CCDECC),\n        ivec4(0xCCCC9C9C, 0x9999DD9C, 0xCC99999C, 0x9C98DCCC),\n        ivec4(0x79A3EF9C, 0x70DDEF, 0x79EBDF78, 0xDCDF),\n        ivec4(0xFFFFDF79, 0xE9FF, 0xFFFFDE89, 0x30FCFF),\n        ivec4(0xFFDECD89, 0x30FDFE, 0xFFDECC89, 0x30FFEE),\n        ivec4(0xEFCD9C89, 0xC2FFEE, 0xDFCD9C88, 0x10C3FFED),\n        ivec4(0xDECC8988, 0xA0DFED, 0xDDCC8988, 0x10D3DEDD),\n        ivec4(0xCCCC9988, 0x7C2DECC, 0xCC9C9999, 0x8A87DECC),\n        ivec4(0xCCCCCC9C, 0x9C9CEDCC, 0xCCC9CC99, 0x89C9DDCC),\n        ivec4(0x9C9CCC99, 0x8998DC9C, 0xCC999999, 0x9C88D9CC),\n        ivec4(0x39C3DF88, 0x70DDEF, 0xACFDCF77, 0xDCDF),\n        ivec4(0xFFFFDE89, 0xFAFF, 0xFFEFCE89, 0x10FCFF),\n        ivec4(0xFFDD9D89, 0x10FDFE, 0xEFCD9C89, 0x70FFEE),\n        ivec4(0xEFCD8988, 0xC1EFEE, 0xDE9D8988, 0xB1EFED),\n        ivec4(0xDDCC8888, 0xA0DFDD, 0xDCCC8988, 0x11C0DECD),\n        ivec4(0xCC9C9999, 0x193DECC, 0xCCC9CC99, 0x8A77DECC),\n        ivec4(0xC99CCC9C, 0xC989DDCC, 0xCCCCCC99, 0x89C9DCCC),\n        ivec4(0xC999C999, 0x8998DCCC, 0x9C999999, 0x9C88C9CD),\n        ivec4(0x39E79F87, 0x30DDEE, 0xCDFF9E87, 0xD9EF),\n        ivec4(0xFFFFCE88, 0x10FBFF, 0xFFEE9D89, 0x10F9EF),\n        ivec4(0xEFCD9C88, 0xFDFE, 0xEFCD9C88, 0x80FFEE),\n        ivec4(0xDFCC8878, 0xC2FFED, 0xDECC8878, 0x70EFDD),\n        ivec4(0xDD9C8888, 0x1092DFDD, 0xCC9C9988, 0x1C0DECC),\n        ivec4(0xCCC99999, 0x1083DECC, 0x9CCCCC9C, 0x7A33DDCC),\n        ivec4(0xCCC9CC9C, 0xCC89DCCC, 0x9CCC9C9C, 0x9899ECCC),\n        ivec4(0x9C999C99, 0x8899DCCC, 0x9C999999, 0x8C88C9CC),\n        ivec4(0x39E88F77, 0x10DDEF, 0xEEFFDF88, 0xD9EF),\n        ivec4(0xFFEFCD88, 0xFBFF, 0xFFDE9D88, 0x10F9EF),\n        ivec4(0xEFCD9C88, 0x20FCFE, 0xEFCD9988, 0x70FFFE),\n        ivec4(0xDE9C8878, 0xC3EFED, 0xDECC8888, 0x70EFDD),\n        ivec4(0xDD9C8888, 0x1095DFCD, 0xCC9C9C99, 0x1C0DECC),\n        ivec4(0x9C9CCC99, 0x3073DFCC, 0xCCCCCCC9, 0x7A11DDCC),\n        ivec4(0xC9C9CC9C, 0x9C8AECCC, 0xCCCC9C9C, 0x99C9DCCD),\n        ivec4(0xCCC9C999, 0x8899D9CD, 0x9C999999, 0x8C88C9CD),\n        ivec4(0x39E8CF77, 0x10DDEE, 0xFEFFDF89, 0x10D9FF),\n        ivec4(0xFFEFCE88, 0xF7FF, 0xFFDECC88, 0xF8EF),\n        ivec4(0xEFCE9C88, 0x20FCFE, 0xEFCD9988, 0x70FFEE),\n        ivec4(0xDECD8887, 0xA0FFED, 0xDDCC8888, 0x70DFDD),\n        ivec4(0xDCCC9998, 0x1082DFCD, 0xCC9C9999, 0xA1DFCC),\n        ivec4(0x9CCCCC9C, 0x1073EECC, 0xCCCCCCC9, 0x7A10ECCC),\n        ivec4(0xCCC9CC9C, 0xC98AE9CC, 0xCCCC9C9C, 0x99C9D9CD),\n        ivec4(0xCCC9C999, 0x8899DCCD, 0x9C999999, 0x8C88C9CD),\n        ivec4(0x7CE7CF78, 0x10DCFE, 0xFEFFDF8C, 0x10D9FF),\n        ivec4(0xFFEFCE89, 0xF7FF, 0xFFEECC88, 0xF8EF),\n        ivec4(0xEFCE9C88, 0xF9EF, 0xEFCD9C88, 0x30FFEF),\n        ivec4(0xDFCD8887, 0xB0EFDD, 0xDDCC8988, 0x70EEDD),\n        ivec4(0xDCCC9999, 0x1073DFCD, 0xCC9CC999, 0xA0DFCC),\n        ivec4(0x9CCCCC9C, 0x1033EECD, 0xCCCCCC9C, 0x7A11ECCC),\n        ivec4(0xC99CCCCC, 0x9C89E8CC, 0xCC9CCCC9, 0x99C9DCCD),\n        ivec4(0xCCCCC999, 0x8899D9DD, 0x9C999999, 0x9C88C9CD),\n        ivec4(0x7CFBDF78, 0xDCFE, 0xFFFFDF89, 0xD8FF),\n        ivec4(0xFFEFCD89, 0xE7FF, 0xFFDECC89, 0x10F7EF),\n        ivec4(0xFFDD9988, 0xF9EF, 0xEFCD9978, 0x30FEEF),\n        ivec4(0xDECD8888, 0x70EFDD, 0xDD9D9988, 0x70EEDD),\n        ivec4(0xCCCC9999, 0x1171DFCD, 0xCCCCCC9C, 0xB0EECC),\n        ivec4(0xCC9CCCCC, 0x1131EDCD, 0xCCCCCCCC, 0x8901E9CC),\n        ivec4(0xCCCCCCC9, 0xC999E8CD, 0xCCCCCCCC, 0x98C9DCCD),\n        ivec4(0xCC9CC999, 0x8998D9DD, 0x9C999999, 0x9C88C9CC),\n        ivec4(0xACFDEF89, 0x10DDFF, 0xFFFFCF89, 0xE9FF),\n        ivec4(0xFFEECD88, 0xF8FF, 0xFFDE9C89, 0x10FAEF),\n        ivec4(0xFFCD9C88, 0x10FDEF, 0xEFCD8988, 0x80FFEE),\n        ivec4(0xDECD8988, 0x70FFDD, 0xDDCC9998, 0xB1EFDD),\n        ivec4(0xCCCCC999, 0x1180DFCC, 0xCCCCCC9C, 0xB1EEDC),\n        ivec4(0xCCC9CCCC, 0x1331EECC, 0xCCCCCCCC, 0xA913ECCC),\n        ivec4(0xCCCCCCCC, 0x9C8CE9CD, 0xCCCCCCCC, 0x99C9DCCD),\n        ivec4(0xCCCCC999, 0x8C99D9DD, 0xCC999999, 0xCC88C9DC),\n        ivec4(0x7AF9DF79, 0x80EDDF, 0xFEFFEF8C, 0x70FDFF),\n        ivec4(0xFFFFDE8C, 0x71FEFF, 0xFFEFCD89, 0x71FEFF),\n        ivec4(0xFFDECC89, 0xB0FFFF, 0xFFCDCC89, 0xD3FFFE),\n        ivec4(0xEFCD8988, 0x20F7EFFE, 0xDECC9988, 0x10E7EFEE),\n        ivec4(0xDDCD9999, 0x23E7DFDD, 0xCCCCC999, 0xF8DECC),\n        ivec4(0xCCCCCCCC, 0x37C7DFDC, 0xCCCCCCCC, 0x9997DFCD),\n        ivec4(0xCCCCCCCC, 0xC9CCDECD, 0xCCCCCCCC, 0x99C9DDCD),\n        ivec4(0xCCCCCC99, 0x8C99DCCD, 0xCC999999, 0xCC89CCCD),\n        ivec4(0x89D8FFDF, 0xD8FDEF, 0x38E7FFCE, 0xD3FECF),\n        ivec4(0xEDFFEF8C, 0xC1FFDF, 0xFFFFFF8C, 0x10C1FFFF),\n        ivec4(0xFFFFEF9D, 0x40E3FFFF, 0xFFFFDE9C, 0x10E7FFFF),\n        ivec4(0xFFDEDD9C, 0x20FAFFFF, 0xFFDECC99, 0x71FDFFFE),\n        ivec4(0xEFDDCC99, 0x74FEEFFF, 0xEECD9C89, 0x71FDDFFE),\n        ivec4(0xDDCD9C89, 0x77FEDEDD, 0xDDCC9C99, 0xCCFEDEDD),\n        ivec4(0xCCCCCCC9, 0xCCFDDECC, 0xCDCCCCCC, 0x99ECDECC),\n        ivec4(0xCCCCCCCC, 0x9CC9DDCC, 0xCC999999, 0xCDC9DDCC),\n        ivec4(0x9DDCFFFF, 0xDDEDEF, 0x78C7FFFF, 0xD9FEDF),\n        ivec4(0x13F7FFDE, 0xE7FF8D, 0xECFFFF9D, 0xD3FFDF),\n        ivec4(0xFFFFEF79, 0xF7FFFF, 0xFFFFFFCE, 0x72FAFFFF),\n        ivec4(0xFFFFEFCD, 0x34FDFFFF, 0xFFFFDECD, 0x70FEFFFF),\n        ivec4(0xFFDEDD9C, 0xB2FFFFFF, 0xFFDECC9C, 0xC7FFEFFF),\n        ivec4(0xEFDDCC9C, 0xCBFFEEFF, 0xEECDCC99, 0xDCFFDEFE),\n        ivec4(0xDDCD9C89, 0xECEFDDED, 0xDDCD9C89, 0xC9EEDDDD),\n        ivec4(0xCC9C9C99, 0xCCEDDDCC, 0xCCC99999, 0xCDDCCDCC),\n        ivec4(0x7CC8FFEF, 0xD9FDEF, 0x17C7FFDF, 0xD7FF9F),\n        ivec4(0xB9FEFF9D, 0xD1FFCE, 0xFFFFFF8D, 0xD5FFFF),\n        ivec4(0xFFFFFFCD, 0x21F7FFFF, 0xFFFFFFCD, 0x31FAFFFF),\n        ivec4(0xFFEFDECD, 0x64FDFFFF, 0xFFEFDDCC, 0x70FEFFFF),\n        ivec4(0xEFDECD9C, 0xA2FFEFFF, 0xFFDDCC9C, 0xC7FFEFFF),\n        ivec4(0xDFDDCC9C, 0xCBFFEEFF, 0xDECD9C99, 0xDCFFDEFE),\n        ivec4(0xDECD9C89, 0xECEFDDDD, 0xDDCC9C89, 0xC9EEDDDD),\n        ivec4(0xCCCC9C99, 0xCDEDCDCC, 0xCC9C9989, 0xCDDDCDCC),\n        ivec4(0x78C7FFCE, 0x90EDDF, 0xDDFFFFCE, 0x80FDEF),\n        ivec4(0xFFFFFFDE, 0x1080FFFF, 0xFFFFEECD, 0x10A2FFFF),\n        ivec4(0xFFEFEDCC, 0x10C6FFFF, 0xFFEFDD9C, 0xE3FFFE),\n        ivec4(0xFFDDCC9C, 0x20FBFFFE, 0xFFDDCC9C, 0x31FCFFFD),\n        ivec4(0xEFDD9C99, 0x74FEEEFE, 0xDECD9C89, 0x75FDDFEE),\n        ivec4(0xDDCD9C89, 0xB8FEDEDD, 0xDCCC9C89, 0xCCFEDDDC),\n        ivec4(0xDCCC9C99, 0xC9EDDDCC, 0xCDCCC999, 0xC9ECDECC),\n        ivec4(0xC9C9999C, 0xCDD9CDCC, 0x99999999, 0xDCCCCDCC),\n        ivec4(0xEEFEEFDE, 0x10DCEE, 0xFFFFDECD, 0x10E9FF),\n        ivec4(0xFFEFDDCC, 0x20FCFE, 0xFFDECDAC, 0x30FDEE),\n        ivec4(0xFFDECC99, 0x70FEDE, 0xEFCDCCAA, 0xA1FFDE),\n        ivec4(0xEFCE9C88, 0xE7EFDD, 0xDDCD9C88, 0x10E7EFDD),\n        ivec4(0xCDCD9988, 0x62E7DECD, 0xCCCC9C88, 0x1F7DECC),\n        ivec4(0xCCCC9999, 0x7AEBCECC, 0xCC999999, 0xC9DCDECC),\n        ivec4(0x9C9C9999, 0x98C9DECC, 0x99999C9C, 0x89C8DDCC),\n        ivec4(0x9C999999, 0xCD98DC9C, 0x99999989, 0xCC8CC99C),\n        ivec4(0xFEEFDECD, 0xD8FE, 0xFFEFDDAC, 0xE7EF),\n        ivec4(0xFEDECD89, 0x10FBEE, 0xFEDEACA9, 0xF8DE),\n        ivec4(0xEEDD9C88, 0x60FEDE, 0xEECDA988, 0x80FFDD),\n        ivec4(0xDDCD8988, 0xB2DFDD, 0xCCCC8C88, 0x11B2DFCD),\n        ivec4(0xCCCC8988, 0xC1DECC, 0x9C9C9999, 0x10D3DECC),\n        ivec4(0x9C999899, 0x7873DECC, 0x99999999, 0x99B8DECC),\n        ivec4(0x9999C999, 0x8899DDCC, 0x99C99999, 0x8898DCCC),\n        ivec4(0x99999999, 0xCD88C9CC, 0x99999989, 0xCC9998CC),\n        ivec4(0xFEEFDD8C, 0xD3FE, 0xFEDECD8A, 0xE3EF),\n        ivec4(0xFEDD9C88, 0xE3EE, 0xEECDAC88, 0xF3DE),\n        ivec4(0xEECD8978, 0x70FDDE, 0xDDCC8987, 0x70EEDD),\n        ivec4(0xDC9C8988, 0x76DECD, 0xCCCC8988, 0x70DFCC),\n        ivec4(0x9C898888, 0xB1DE9C, 0x99899999, 0x171DE9C),\n        ivec4(0x99999999, 0x3710EDCC, 0x99999999, 0x9978DC9C),\n        ivec4(0x89999999, 0x8899DC9C, 0x99999999, 0x8888D9CC),\n        ivec4(0x99999898, 0x8C88C8CC, 0x99898988, 0xCC8998CC),\n        ivec4(0xFEEECD89, 0xC1FE, 0xFEDE9C8A, 0xC3EF),\n        ivec4(0xFEDDAC88, 0xC2DF, 0xEECD8A78, 0xE1DF),\n        ivec4(0xDECD8878, 0x20FCDE, 0xCDCC8887, 0x30EECD),\n        ivec4(0xCCCC8888, 0x24EDCD, 0xCC9C9888, 0x70DECC),\n        ivec4(0x99899899, 0x72DE9C, 0x99899999, 0x11ED9C),\n        ivec4(0x99999999, 0x710ECCC, 0x99999999, 0x8917D89C),\n        ivec4(0x99999999, 0x98A8D89C, 0x99999999, 0x8898C9CD),\n        ivec4(0x99999898, 0x898898CD, 0x99898988, 0xCC8888CC),\n        ivec4(0xFFEFCE89, 0x91FD, 0xFEDECC8A, 0xA0FF),\n        ivec4(0xFEDE9C88, 0xB0EF, 0xEECD8978, 0xD1DF),\n        ivec4(0xEDCD8987, 0xFBDF, 0xDCCC8988, 0x10FCDD),\n        ivec4(0xCCCD8988, 0x1020FACD, 0xCCA99899, 0x30EDCC),\n        ivec4(0x99899999, 0x32EECC, 0x9999C999, 0x10F9CD),\n        ivec4(0x9C999C9C, 0x300E8CD, 0x99C99999, 0x8907D39D),\n        ivec4(0x9CC9C999, 0x999997CD, 0x9C9C9999, 0x8898C9DD),\n        ivec4(0xCC999999, 0x898899CD, 0x9C999988, 0xCC8898C9),\n        ivec4(0xFFEFDE9C, 0x1080FD, 0xFFEFCD8A, 0x70FF),\n        ivec4(0xFEDFCC88, 0x70EF, 0xFDDEAC78, 0xA0FF),\n        ivec4(0xDDCD8C88, 0xF7EF, 0xDCCD8C88, 0xFBDE),\n        ivec4(0xCCCD8C99, 0x1E7CE, 0xCC999899, 0x10FCCD),\n        ivec4(0xCC99999C, 0x21ECCD, 0x9C99CC9C, 0xF7CE),\n        ivec4(0x9C9C9C9C, 0x1300E7CD, 0x9C9C9C9C, 0x8A03C1CD),\n        ivec4(0x9C9C9C9C, 0x998987CD, 0xCCCCC999, 0x889999DD),\n        ivec4(0xCC9C9999, 0x8888C8DC, 0xCC999999, 0xCC8898C9),\n        ivec4(0xFFFFDE9D, 0x1B0ED, 0xFFFFDEAC, 0x80FE),\n        ivec4(0xFFEFCD89, 0x30FF, 0xFEDFCC8A, 0x30FF),\n        ivec4(0xEDDE9C88, 0xE7FF, 0xDDCE9C88, 0xF7EF),\n        ivec4(0xCCDD9C99, 0x21E7DE, 0xCCCC9999, 0x100FBCE),\n        ivec4(0xCC9999CC, 0x31FCCD, 0xCCC9CCCC, 0x1F7CE),\n        ivec4(0xCC9CC9CC, 0x310E3CF, 0xCCC9CCC9, 0x7A07C1CE),\n        ivec4(0xCCC9CCC9, 0x9C8977CE, 0xCDCC9C9C, 0x989999DD),\n        ivec4(0xCC9C9C99, 0x8898C8DC, 0xCC9C9999, 0xCC8898D9),\n        ivec4(0xFFFFEFCD, 0xA0ED, 0xFFFFDFCC, 0x81FD),\n        ivec4(0xFFEFDE99, 0x70FF, 0xFEEFCD8A, 0xFF),\n        ivec4(0xFEEECC88, 0xD3FF, 0xEDDE9C88, 0xF7EF),\n        ivec4(0xDCDD9C99, 0x60F7EE, 0xCCDC9C99, 0x100F7DF),\n        ivec4(0xCC9999CC, 0x30F9DD, 0xCCCCCCCC, 0x11FBCE),\n        ivec4(0xCC9CCCCC, 0x100E3DF, 0xCCCCCCCC, 0x7803C1CE),\n        ivec4(0xCCCCCCC9, 0xCC8983CF, 0xCCCCCCCC, 0x9999A9DD),\n        ivec4(0xCDCCC999, 0x889899DD, 0xCD9C9999, 0x9D8898CC),\n        ivec4(0xEFFFFFCE, 0x90ED, 0xFFFFEFCC, 0x1181FE),\n        ivec4(0xFFEFCE9C, 0xB0FF, 0xFEFFCDAC, 0x30FF),\n        ivec4(0xFEDE9D88, 0xD2FF, 0xEEDE9C8A, 0xF7EF),\n        ivec4(0xDDDE9C98, 0x10FBDF, 0xCCCDCC99, 0x100F7DE),\n        ivec4(0xCC9C99CC, 0x20FCDD, 0xCCCCCCCC, 0x11FACE),\n        ivec4(0xCCCCCCCC, 0x1100E7DF, 0xCCCCCCCC, 0x7813D1CE),\n        ivec4(0xCCCCCCCC, 0xCC8983CF, 0xCDCCCCCC, 0x99999CDD),\n        ivec4(0xCD9C9C9C, 0x889899DD, 0xCC9C9C99, 0x9D8898DC),\n        ivec4(0xDFDDFFEF, 0xD1FD, 0xFFFFFFDF, 0xC1FE),\n        ivec4(0xFFFFEECD, 0x10C2FF, 0xFFFFDFCC, 0x91FF),\n        ivec4(0xFFEFCD9C, 0xE4FF, 0xFFEFCD9A, 0x30FAFF),\n        ivec4(0xFEDECC89, 0x20FDEF, 0xDDDDCD99, 0x1073FADF),\n        ivec4(0xDDCDCC9C, 0x130FEDE, 0xCCCCCCCC, 0x1073FEDD),\n        ivec4(0xCCCCCCCC, 0x3712FADE, 0xCCCCCCCC, 0x8917F7DE),\n        ivec4(0xCCCCCCCC, 0xC99CD8DE, 0xCCCCCCCC, 0x99CCDCDE),\n        ivec4(0xDDCCCCCC, 0x8C99C9DD, 0xCDC9CCC9, 0xCD89C9DC),\n        ivec4(0xEF79EBFF, 0x10ECFD, 0xDFA9FDFF, 0x10D8FE),\n        ivec4(0xFFFFFFFF, 0x10E7FF, 0xFFFFFFFF, 0x10E7FF),\n        ivec4(0xFFFFEFDE, 0x40F7FF, 0xFFFFEFDD, 0x11F7FF),\n        ivec4(0xFFFFDECC, 0x70FFFF, 0xFFFFDDCC, 0x10B0FFFF),\n        ivec4(0xFEEECD9C, 0x10B1FFEE, 0xEDDECD9C, 0x11B5FFEE),\n        ivec4(0xDDDDCC9C, 0x7793FFDD, 0xDCCCCCCC, 0x9CA8FEDE),\n        ivec4(0xDCCCCCCC, 0xCCCCFEDD, 0xCCCCCCCC, 0x99CCFDDE),\n        ivec4(0xCCCCCCCC, 0x9C99ECDD, 0xCCCCCCC9, 0xDD99D9CD),\n        ivec4(0xFFDECCFF, 0x90DDED, 0xEFACDAFF, 0x70DEFE),\n        ivec4(0xCE37E7FF, 0x10EDFF, 0xCE9BFDFF, 0xECFF),\n        ivec4(0xFFFFFFFF, 0x10FAFF, 0xFFFFFFFF, 0x1031FAFF),\n        ivec4(0xFFFFFFFF, 0x74FEFF, 0xFFFFFFEF, 0x71FFFF),\n        ivec4(0xFFFFEEDD, 0xC4FFFF, 0xFFFFDFCD, 0x11D7FFFF),\n        ivec4(0xFFEFDDCC, 0x37F7FFEE, 0xFEEFDDCC, 0x9CEAFFEE),\n        ivec4(0xDEDECDCC, 0xCCFDEFDD, 0xDDDDCDCC, 0x99ECEFDD),\n        ivec4(0xCCCCCCCC, 0x9DD9EEDD, 0xCCCC9C9C, 0xDDC9DDCD),\n        ivec4(0xFFDFCCFE, 0x90DEDD, 0xFFCCCCFF, 0x70DEFE),\n        ivec4(0xCF78D7FF, 0x30EDFF, 0xAD11D3FF, 0xEDFF),\n        ivec4(0xCDCBFFFF, 0xF9FF, 0xFFFFFFFF, 0x10FAFF),\n        ivec4(0xFFFFFFFF, 0x4075FFFF, 0xFFFFFFFF, 0x1071FFFF),\n        ivec4(0xFFFFFFEF, 0xA2FFFF, 0xFFFFEFEE, 0xD7FFFF),\n        ivec4(0xFFFFEEDD, 0x77FBFFFF, 0xFFFFDECC, 0xCCFCFFEF),\n        ivec4(0xFFEFDDCC, 0xC9FEEFED, 0xFEDECDCC, 0x99FDEFDE),\n        ivec4(0xDDDDCD9C, 0xCDECDEDD, 0xCCCDCC99, 0xDDCCDECD),\n        ivec4(0xFFCDCCFF, 0x70DDED, 0xDF7897FF, 0xEDFE),\n        ivec4(0x9E37D7FF, 0xDCFF, 0xCECAFEFF, 0xD8FF),\n        ivec4(0xFFFFFFFF, 0x1FBFF, 0xFFFFFFFF, 0x51FBFF),\n        ivec4(0xFFFFFFEF, 0x31FDFF, 0xFFFFFFDE, 0x30FEFF),\n        ivec4(0xFFFFDEDD, 0xA2FFFF, 0xFEFFDECD, 0x11C7FFEF),\n        ivec4(0xFFEFDDCC, 0x77F7FFEE, 0xFEEFCDCC, 0x99EAFFDE),\n        ivec4(0xEEDECDCC, 0xC9FDEFDD, 0xDDDDCD9C, 0x99ECEFDD),\n        ivec4(0xCDDCCC9C, 0xCDCCDECD, 0xCCCC9C99, 0xDDCCDDCD),\n        ivec4(0xEF7997FF, 0xDCED, 0x9E37D7FF, 0xD8FD),\n        ivec4(0xCFCCFEFF, 0xC7FE, 0xFFFFFFEF, 0xD3FF),\n        ivec4(0xFFFFEFEE, 0x40E3FF, 0xFEFFEFDD, 0x10F7FF),\n        ivec4(0xFEEFDECD, 0x10FBEF, 0xFEFFCECC, 0x30FDEF),\n        ivec4(0xFEEECD9C, 0xB4FFDE, 0xFDDECD9C, 0x181FFDE),\n        ivec4(0xEDDDCD99, 0x13A5FFDD, 0xDDDDCC99, 0x99CAFFDD),\n        ivec4(0xCCCCCC99, 0x99DCDFCD, 0xCCCCCC99, 0x98C9EECD),\n        ivec4(0xCCCC9999, 0x9D99DDCD, 0xC9999999, 0xDD9CD9CC),\n        ivec4(0xDE78D7EF, 0xDAEC, 0x9E37FCDF, 0xC7FD),\n        ivec4(0xEEFEEFEF, 0xC3FD, 0xFFFFEEDE, 0xD0FF),\n        ivec4(0xFFFFDECD, 0xD2FF, 0xFEEFDDAC, 0xE7EF),\n        ivec4(0xFDDFCD9C, 0xF7EF, 0xFDDECC9A, 0x10FDDF),\n        ivec4(0xEDDECC89, 0x70FEDE, 0xDCDDCC89, 0x70EEDD),\n        ivec4(0xCCCC9C89, 0x3772EFDD, 0xCCCC9C89, 0x7887DFCC),\n        ivec4(0xCC9C9999, 0x9999EDCC, 0xCC999999, 0x9899EDCD),\n        ivec4(0x99999999, 0x8988D9CD, 0x99999999, 0xCD89C89D),\n        ivec4(0xCF78FA8E, 0xCCDD, 0xAEB7FECE, 0xD8ED),\n        ivec4(0xEEFEEFCE, 0xC7FD, 0xFFFFDDAD, 0xD1FF),\n        ivec4(0xFEEFCD9C, 0x40D6FF, 0xFEDECD9A, 0xE1EF),\n        ivec4(0xFEDE9C89, 0xF7DF, 0xEEDDAC89, 0x10FDDE),\n        ivec4(0xDDCD8C88, 0x70FEDD, 0xDCCC9C88, 0x1031EECD),\n        ivec4(0xCCCC9988, 0x170EFCD, 0xC9999999, 0x3383DECC),\n        ivec4(0xCC999999, 0xA978ECCC, 0x9C999999, 0x9899ECCD),\n        ivec4(0x99999999, 0x8898D99D, 0x99898989, 0x8C88C8CC),\n        ivec4(0xCE78FE79, 0x10DCEC, 0xBDD7EFAD, 0xCCFD),\n        ivec4(0xEDFEEF9C, 0xDBFD, 0xFFEFDD9A, 0xD3FF),\n        ivec4(0xFFEECC89, 0x20E7EF, 0xFEDEAC89, 0xF1EF),\n        ivec4(0xEFCD8C88, 0xFBDF, 0xDECD8C78, 0x30FEDE),\n        ivec4(0xDDCC8988, 0x71EFDD, 0xCCCD8988, 0x1131EFCC),\n        ivec4(0xCC9C8989, 0x84DFCC, 0x9C999899, 0x1381DECC),\n        ivec4(0x9C999999, 0x7937EDCC, 0x9999C999, 0x9989ECCC),\n        ivec4(0x99999999, 0x8898DC9C, 0x99898989, 0x8888C9CC),\n        ivec4(0xCEB8EE78, 0xDCDC, 0xBDD7EF8C, 0xCCFD),\n        ivec4(0xEDFEDF8C, 0xDBFD, 0xFFEFCD8A, 0xD3FF),\n        ivec4(0xFFEECC8A, 0x40E7EF, 0xEFCEAC88, 0xF1EF),\n        ivec4(0xEFCD8978, 0x10FADE, 0xDECD8978, 0x10FEDE),\n        ivec4(0xDDCC8888, 0x72EFDD, 0xCCCC8988, 0x1130EFCC),\n        ivec4(0xCC998989, 0xB1DFCC, 0x9C999999, 0x3371DECC),\n        ivec4(0x9C99C999, 0x8837EDCC, 0x99999C99, 0x9989ECCC),\n        ivec4(0x99999999, 0x8898DC9C, 0x99899998, 0x8888C99C),\n        ivec4(0xEEBCFE9D, 0xDCDC, 0xAEA3EF7A, 0xC8ED),\n        ivec4(0xCEFCEF8C, 0xD7FD, 0xFFFFDE8C, 0xD0FF),\n        ivec4(0xFFEECD89, 0x10D6FF, 0xFFDEAC8A, 0xE1EF),\n        ivec4(0xFFCE9C78, 0xF7DF, 0xEECD8987, 0x10FCDF),\n        ivec4(0xDDCC8988, 0x70FEDD, 0xDCCC8988, 0x1011EECD),\n        ivec4(0xCC9C9998, 0x70EFCC, 0x9C999999, 0x3373EDCC),\n        ivec4(0xCCC9C99C, 0x9937E9CD, 0x99C9C999, 0x9999ECCD),\n        ivec4(0x99999999, 0x8898D9CC, 0x99999999, 0x8888C9CC),\n        ivec4(0xFDCDFDDE, 0xDCB9, 0xDEB8FEAD, 0xD9ED),\n        ivec4(0xBDC7EF79, 0xDBFD, 0xEFFFFF9C, 0xC3FE),\n        ivec4(0xFFFFDE89, 0xD2FF, 0xFFEFCD8A, 0xE3FF),\n        ivec4(0xFFDE9C89, 0xF2EF, 0xFFDDAC78, 0xF9EF),\n        ivec4(0xEECD8988, 0x20FDDE, 0xDDCD8988, 0x70FDDE),\n        ivec4(0xCCCD9989, 0x1310EECD, 0xCC9CC999, 0x3373EECC),\n        ivec4(0xCCC9C99C, 0x9978F9CD, 0xCCC9C99C, 0x999CECCD),\n        ivec4(0x99C99999, 0x8899D9CD, 0x99999999, 0x8888C9CC),\n        ivec4(0xFCDEFEEF, 0x30CD23, 0xEFCCFFCF, 0xDDDC),\n        ivec4(0xBDC7EF89, 0xDCFE, 0xADF9DF7A, 0xDAFE),\n        ivec4(0xFFFFDF8C, 0xE7FF, 0xFFFFDE8A, 0xE3FF),\n        ivec4(0xFFEECD89, 0x40F7FF, 0xFFDFAC88, 0xF8FF),\n        ivec4(0xEFCD8C78, 0x30FFEF, 0xEECD8988, 0x30FFDE),\n        ivec4(0xDDCD8988, 0x1072FEDD, 0xCCCCC999, 0x1770EFCD),\n        ivec4(0xCCC9C99C, 0x8888EDDC, 0xCCCCCC9C, 0xC99CFCCD),\n        ivec4(0xC9999C9C, 0x89C9DCCD, 0x99999999, 0x8898D9CC),\n        ivec4(0xECDFFFEF, 0x707D20, 0xEFDCFFCF, 0x70DDDC),\n        ivec4(0xBEE7EF8C, 0x60DDFE, 0x7CF8AF87, 0xDCEF),\n        ivec4(0xFFFFDF88, 0x10EBFF, 0xFFFFCE89, 0xF7FF),\n        ivec4(0xFFEFCD88, 0x10FBFF, 0xFFCF9C88, 0x10FCFF),\n        ivec4(0xEFCD8C88, 0x70FFFF, 0xEECD8978, 0xB0FFEE),\n        ivec4(0xDDCC8888, 0x81FFDD, 0xDDCC9999, 0x3780EFCD),\n        ivec4(0xCCCCC999, 0x8897DFCD, 0xCC9CCC9C, 0xCCACFDCC),\n        ivec4(0x9C9C9C9C, 0x9899EDCD, 0x99999999, 0x8898DC9C),\n        ivec4(0xFEEEFFEF, 0x907D70, 0xDFDCFFCE, 0xA0DDFC),\n        ivec4(0x7CFBDF89, 0xB0DDFE, 0x3AFD8D87, 0xECEF),\n        ivec4(0xFFFFCE78, 0x20FCFF, 0xFFFFCE88, 0x10FCFF),\n        ivec4(0xFFEE9C88, 0x40FDFF, 0xFFDE9C78, 0x30FEFF),\n        ivec4(0xEFCD8988, 0xC4FFFE, 0xEE9C8978, 0xC1FFFE),\n        ivec4(0xDD9C8888, 0xC6EFDD, 0xDDCC9989, 0x37D1DFCD),\n        ivec4(0xCC9C9C9C, 0x88D8DECC, 0xCC9CCC9C, 0xC99CEFCC),\n        ivec4(0x9C9C9C9C, 0x98C9EDCC, 0x99999999, 0x8898DCCC),\n        ivec4(0xFEEFFFEF, 0xD37CB0, 0xDFDCFFFF, 0xD1DDEC),\n        ivec4(0xADFAFFCE, 0xC0DDFF, 0x18FBEF9D, 0x70EEEF),\n        ivec4(0xCCFF9F88, 0x70FDDF, 0xFFFFCF88, 0x30FEFF),\n        ivec4(0xFFFFCE88, 0x74FFFF, 0xFFEF9D8A, 0x71FFFF),\n        ivec4(0xFFDD9C88, 0xE5FFFF, 0xFFCDAC88, 0x10F7FFFF),\n        ivec4(0xDECC8988, 0x3F7EFFE, 0xDDCC8988, 0x78F7DFDD),\n        ivec4(0xDDCC9998, 0xCCFCDEDD, 0xCC9C9C99, 0xC9ECDFCC),\n        ivec4(0xCCC9CC9C, 0x99C9DECC, 0x99999C99, 0x8999DDCC),\n        ivec4(0xDBFFEEEE, 0xCA0730, 0xFEEFFEEF, 0xDAADD7),\n        ivec4(0xEFDCFFFF, 0xDBDEFE, 0xADECFFFF, 0xD1EDFF),\n        ivec4(0x5BF7FFDF, 0xC0FEDF, 0xBBFCFFCE, 0x70FECF),\n        ivec4(0xFFFFDF89, 0xB0FFFF, 0xFFFFEF88, 0x91FFFF),\n        ivec4(0xFFFFDF89, 0xE6FFFF, 0xFFFFCE8C, 0x10F7FFFF),\n        ivec4(0xFFDECD89, 0x53FCFFFF, 0xFFCD9C89, 0xA8FCFFFE),\n        ivec4(0xEECD9C88, 0xCCFEEEFE, 0xDDCC9988, 0xC9FEDFDD),\n        ivec4(0xCDCC8988, 0x99ECDDDC, 0xCC999988, 0x9CD9DDCC),\n        ivec4(0x74ECFFFF, 0x10030000, 0xEBFFEFEE, 0xB0AC0370),\n        ivec4(0xFFEFFEEE, 0xB0DE7CDB, 0xFFCEFEFF, 0x80DDDDFE),\n        ivec4(0xCEDCFFFF, 0x60DDFDFF, 0x7ADBFFFF, 0xDAFEDF),\n        ivec4(0x17E6FFFF, 0xD7FF9F, 0xBCFDFFEF, 0xC0FFCF),\n        ivec4(0xFFFFFFCD, 0xE6FFFF, 0xFFFFFF8C, 0x1E7FFFF),\n        ivec4(0xFFFFEF89, 0x77FBFFFF, 0xFFFFEF9C, 0xA9FDFFFF),\n        ivec4(0xFFEFDE9C, 0xD9FFFFFF, 0xFFDECD9C, 0xC9FFEFFE),\n        ivec4(0xEEDDCC89, 0xC9FFDEFE, 0xDDCCAA8A, 0xCCEEDDED),\n        ivec4(0xDBFFFF, 0x0, 0xD7FFEEFE, 0x0),\n        ivec4(0xFEEFEEEE, 0xCC1700B7, 0xFFDFEEEF, 0xDCCD3BFC),\n        ivec4(0xEFCCFEFF, 0xEBDDDDFF, 0x9DCAFFFF, 0xD1DDFDFF),\n        ivec4(0x7BC6FFFF, 0x80DDFFCF, 0x7B1FFFF, 0x10DCFE8F),\n        ivec4(0xBAFDFFEF, 0xE8FFCF, 0xFFFFFFDF, 0xE3FFFF),\n        ivec4(0xFFFFEF9C, 0x37F7FFFF, 0xFFFFFF7C, 0x99FCFFFF),\n        ivec4(0xFFFFFFCD, 0xC9FFFFFF, 0xFFFFEFCD, 0xC8FFFFFE),\n        ivec4(0xFFDEDD9C, 0xC8FFEEFE, 0xEECDCCAC, 0xCCFFDDFD),\n        ivec4(0x60EBEFEE, 0x0, 0xD7FFEEEE, 0x10),\n        ivec4(0xFEEFDCFF, 0xAB1800B2, 0xFFCDFCFF, 0xDACD7BFA),\n        ivec4(0xDEBCFDFF, 0xD7DDDDFF, 0xBC77FDFF, 0xD0DDECFF),\n        ivec4(0x3874FEFF, 0x70DDFDDF, 0xBACBFFEF, 0xC9FDDF),\n        ivec4(0xFEFFFFDE, 0xC7FFEF, 0xFFFFFFCE, 0xC3FFFF),\n        ivec4(0xFFFFFFCE, 0x33D2FFFF, 0xFFFFFFDE, 0x88E7FFFF),\n        ivec4(0xFFEFEECD, 0xC9FCEFFF, 0xFFEFDECC, 0x98FDFFEE),\n        ivec4(0xEFDDCD9C, 0x88FDDFED, 0xEECDBC9A, 0x9CFDDEEC),\n        ivec4(0xB6FEDFFE, 0x50000, 0xFCEECDFF, 0x10CC2720),\n        ivec4(0xFFCEDBFF, 0x30DDACCB, 0xDFBBEBFF, 0x10DCCDFE),\n        ivec4(0x8E13F7FF, 0xDADCFE, 0xACB7FDEF, 0xC7DDFE),\n        ivec4(0xEEFEFFDF, 0x91ECFF, 0xFFFFFFEF, 0x70FCFF),\n        ivec4(0xFFFFFFDE, 0x70FDFF, 0xFFFFEFDE, 0x30FDFF),\n        ivec4(0xFFEFDDCD, 0x1130FFEF, 0xFEEFDECC, 0x77A7FFDF),\n        ivec4(0xFEDECD9C, 0x99E9FFDE, 0xFEDECCAA, 0x98E9FFDD),\n        ivec4(0xDDDDCC89, 0x88E9DFCD, 0xCCCCBC8A, 0x89D8DECC),\n        ivec4(0xEBDEDCFF, 0xC76A40, 0xFEBDEAFF, 0xD1CCAB),\n        ivec4(0xCF7BE7EF, 0xD1CDED, 0xAE77FCDF, 0x90CCFE),\n        ivec4(0xDEECFEDE, 0x70CDFE, 0xFFFFFFDE, 0x10DCFF),\n        ivec4(0xFFFFEEDE, 0xEBFF, 0xFEFFDECD, 0xF7FF),\n        ivec4(0xFEEFDD9C, 0x10FAEF, 0xFEDECC9B, 0x30FDDF),\n        ivec4(0xFDDECD89, 0x370FFDE, 0xEDDDAC8A, 0x7773FFDD),\n        ivec4(0xDCDCCC88, 0x99CAEFCD, 0xCCCC9C8A, 0x98C9EFCD),\n        ivec4(0xCCCC9988, 0x88C9DECC, 0xA9A98A8A, 0x8988DC9C),\n        ivec4(0xEEACFCDF, 0x90CDBB, 0xCF77FD9D, 0x80CDED),\n        ivec4(0x9DCBFE8D, 0x70CDFD, 0xFEFEEFCE, 0xCCFE),\n        ivec4(0xFFFFDE9D, 0xEAFF, 0xFFEFDDBC, 0xF7EF),\n        ivec4(0xFFEECC8C, 0xF7EF, 0xFEDEAC8A, 0xFCDF),\n        ivec4(0xEEDD9C88, 0x30FEDE, 0xEDCDAA78, 0x70FFDD),\n        ivec4(0xDCCD8988, 0x174EFCD, 0xCCCC9988, 0x7783EFCC),\n        ivec4(0x9C9C9989, 0x999AEFCC, 0x9C999A89, 0x98C9DECC),\n        ivec4(0x9999A999, 0x8898DC9C, 0x998B8A88, 0x8988D8CC),\n        ivec4(0x9EC7DE78, 0x70CDED, 0xACFCEF7A, 0x10CCFD),\n        ivec4(0xFEFFDE89, 0xD9FE, 0xFFEFCD8A, 0xE8FF),\n        ivec4(0xFFDE9C88, 0x10F7FF, 0xEFCDAC78, 0xF7EF),\n        ivec4(0xEFCD8978, 0x20FDEE, 0xDECC8B77, 0x70FEDE),\n        ivec4(0xDD9C8888, 0x72EFDD, 0xDC9C8988, 0x171EFCC),\n        ivec4(0xCC9C8988, 0x3B1DFCC, 0x999A9A99, 0x7887DECC),\n        ivec4(0x9C999999, 0x99A9EDCC, 0x9999C999, 0x9899ED9C),\n        ivec4(0x99A99999, 0x8888DC9C, 0xA998A888, 0x8988C89C),\n        ivec4(0xBDFA9F78, 0xDCFD, 0xEDFFCE7A, 0xC8FE),\n        ivec4(0xFFEF9D78, 0xD3FF, 0xFFDEAC88, 0x10F7FF),\n        ivec4(0xEFCD8978, 0xF7FF, 0xDFAD8A77, 0xFAEF),\n        ivec4(0xEE9C8877, 0x70FEEE, 0xDDAC8888, 0xB1FEDD),\n        ivec4(0xDC9C8888, 0x1170EECD, 0xCC9C8888, 0xB5DFCC),\n        ivec4(0x9C999C99, 0x17B1DECC, 0x99999C99, 0x7833EE9C),\n        ivec4(0x9999CC99, 0x9989ECCC, 0x999C9C99, 0x9899EC9C),\n        ivec4(0x99999999, 0x8898D9CC, 0x99A9A9A8, 0x8988C8CC),\n        ivec4(0xADFCDF78, 0xDBFD, 0xFEFFCE88, 0xC3FE),\n        ivec4(0xFFEF9D78, 0xD1FF, 0xFFDEAC78, 0x10E7FF),\n        ivec4(0xEFCD8C78, 0xF2FF, 0xEFAD8A77, 0x10FAFF),\n        ivec4(0xEE9C8887, 0x30FEEE, 0xDD9C8888, 0x73FDDD),\n        ivec4(0xDD9C8988, 0x170EECD, 0xCC999C99, 0x1075DFCC),\n        ivec4(0xC999CC99, 0x1332EECC, 0xC9C9CC99, 0x7833FCCD),\n        ivec4(0x9C9CCC9C, 0xC9B9E9CC, 0x99CC9C99, 0x9999DCCD),\n        ivec4(0x9C999C99, 0x8898C9CD, 0x9999A9A9, 0x8988C8CD),\n        ivec4(0xAEFCDF88, 0xD7FD, 0xFEFFCE89, 0xC1FD),\n        ivec4(0xFFFECD88, 0xC4FF, 0xFFDFAC78, 0xD7FF),\n        ivec4(0xEFCE9C78, 0xD4FF, 0xEFCD8A77, 0xF8EF),\n        ivec4(0xEE9D8888, 0xFDEE, 0xDD9C8A88, 0x73FCDE),\n        ivec4(0xDD9C9988, 0x160EDCD, 0xCC999C99, 0x1035EECD),\n        ivec4(0xC999CC9C, 0x1321ECCC, 0x9CCCCCC9, 0x8815FBCD),\n        ivec4(0xC9C9CC9C, 0xC989E8CD, 0x9CCC9C9C, 0x9899DC9D),\n        ivec4(0x9C9C9C99, 0x8898C9CD, 0x9C9C99A9, 0x898898CD),\n        ivec4(0xCEFDEF89, 0xD7FD, 0xFFFFCE8A, 0xC0FE),\n        ivec4(0xFFFFCD88, 0x10C2FF, 0xFFDFAC8A, 0xD3FF),\n        ivec4(0xFFCE8C78, 0xE0FF, 0xFFCD8A87, 0x10FBFF),\n        ivec4(0xDECD8888, 0x10FDEE, 0xDDCD9A88, 0x1033FADE),\n        ivec4(0xDC9D9C99, 0x34FDDD, 0xCC99CCC9, 0x1031EECD),\n        ivec4(0xCCCCCCCC, 0x1701FACD, 0xCCCCCC9C, 0x7833F7CD),\n        ivec4(0x9CCCCCCC, 0xC98CDBCD, 0xCCCCCC9C, 0x9999DCCD),\n        ivec4(0xCC9C9C9C, 0x8898C9CD, 0xCC999999, 0x8C8898DD),\n        ivec4(0xEEFFCF88, 0xD3FD, 0xFFFFCE8A, 0xC0FE),\n        ivec4(0xFFDE9C88, 0x10D7FF, 0xFFDFAC78, 0xC1FF),\n        ivec4(0xEFCD8978, 0xF7FF, 0xEFCD8A88, 0x10FCFF),\n        ivec4(0xEECC8888, 0x74FDDE, 0xDDCD9999, 0x1151FCDE),\n        ivec4(0xCC9CCC9C, 0x76EDCD, 0xCCCCCCC9, 0x1131EECD),\n        ivec4(0xCCCCCCCC, 0x1340FACD, 0xCCCCCCCC, 0x8937F7CD),\n        ivec4(0xCCCCCCCC, 0xC9ACD8CD, 0xCCCCCC9C, 0x9999CCDD),\n        ivec4(0xCCCC9C9C, 0x8898C9DD, 0xCC9C9999, 0x9C8898DD),\n        ivec4(0xFFFFCD78, 0xC7FE, 0xFFEFAC78, 0x1D1FF),\n        ivec4(0xFFDE9C78, 0x20F7FF, 0xFFCD8A78, 0xF5FF),\n        ivec4(0xEFCC8888, 0x50FCFF, 0xDFAD8A88, 0x70FEFF),\n        ivec4(0xDE9C9999, 0x51B3FEDE, 0xDDCC9C99, 0x71FEDD),\n        ivec4(0xCCC9CCCC, 0x5175EFCD, 0xCCCCCC9C, 0x1130EECD),\n        ivec4(0xCCDCCCCC, 0x1751F9CD, 0xCCCCCCCC, 0x9958F7CD),\n        ivec4(0xCCCCCCCC, 0x9C9CDACD, 0xCCCCCCCC, 0x9899CCDE),\n        ivec4(0xCDCCCC9C, 0x8999C9DD, 0xCC9C9C99, 0xCD88C9DD),\n        ivec4(0xEDFF9D78, 0x1DAEF, 0xFFFF9D88, 0x1E8FF),\n        ivec4(0xFFEF8C88, 0x61FAFF, 0xFFDEAC88, 0x51FDFF),\n        ivec4(0xEFCD8988, 0x20FFFF, 0xEF9C8A88, 0x10B1FFFF),\n        ivec4(0xDE9C8888, 0x10D7FFFF, 0xDECC9999, 0x35A3FFEE),\n        ivec4(0xDDCCCC99, 0x61C7EFDC, 0xCCCCCCCC, 0x53A2EFDC),\n        ivec4(0xCCCCCCCC, 0x7873EFCD, 0xCCDCCCCC, 0xCC89EECD),\n        ivec4(0xCCDCCCCC, 0x99CCEDCD, 0xDCCCCCCC, 0x9999DCCD),\n        ivec4(0xCCCCCCC9, 0x9C98D9DE, 0xCCCCC999, 0xCD9CC9CD),\n        ivec4(0xCEFDEF9C, 0x70DDFF, 0xB9FECE89, 0x10ECEF),\n        ivec4(0xEDFF8C88, 0x20FADF, 0xFFFF8D88, 0x31FCFF),\n        ivec4(0xFFEF8D88, 0x1B4FFFF, 0xFFEF9C88, 0xB1FFFF),\n        ivec4(0xEFCD8C88, 0x10D5FFFF, 0xEFCD8988, 0x11E7FFFF),\n        ivec4(0xDECC8988, 0x15FBFFFF, 0xDE9C8988, 0x77E7EFEE),\n        ivec4(0xCD9C9C99, 0x99FADFDD, 0xCDCCCC9C, 0xCCECDFCD),\n        ivec4(0xCCCDCCCC, 0xC9D9DFCD, 0xDCCCCCCC, 0x9CC9DECC),\n        ivec4(0xCCCCCCCC, 0xDD9CDCCD, 0xCCCCC999, 0xCCCCD9CD),\n        ivec4(0xFEFEFFDE, 0x809DCB, 0xDFFDFFEF, 0x70EEFE),\n        ivec4(0xCCFFDFCC, 0x50FDEF, 0xB7FFCE89, 0x10FD9F),\n        ivec4(0xFEDF9978, 0x40FDDF, 0xFFDF8978, 0x71FFFF),\n        ivec4(0xFFDF8988, 0x40D7FFFF, 0xFFDF8988, 0x11D3FFFF),\n        ivec4(0xFFCD8988, 0x27FBFFFF, 0xEFCD9988, 0x77FAFFFF),\n        ivec4(0xCECC8888, 0xCCFDFFFF, 0xCD9C8888, 0xCCFDFFFF),\n        ivec4(0xCD9C9988, 0x9CEDDEED, 0xCCCC9999, 0xDDDCDEDD),\n        ivec4(0xCCCCCC9C, 0xDDDDDDCC, 0xCC9C9C99, 0xDCDCDDCC),\n        ivec4(0xFBFFDFAC, 0x501730, 0xEFFEEFCD, 0x10CDDA),\n        ivec4(0xDEFFEFDE, 0x50EEFF, 0xCBFFDFAC, 0xFCDF),\n        ivec4(0xE7DF9C88, 0x40FC8E, 0xFECE8977, 0x10FCCF),\n        ivec4(0xFF7C8887, 0xB0FFFF, 0xFF9F8888, 0x57C7FFFF),\n        ivec4(0xFF9D8888, 0x77E6FFFF, 0xFF9C8888, 0x77FAFFFF),\n        ivec4(0xDE9C8888, 0x99FDFFFF, 0xCD9C8878, 0x98FCFFFF),\n        ivec4(0xCD898888, 0xDDFCEFEE, 0xCC898888, 0xEDDDDEDD),\n        ivec4(0xCC998888, 0xDDDDDECC, 0xCCC99999, 0xCCDCDDCC),\n        ivec4(0xD3FFDEA9, 0x100, 0xFDFEEF9C, 0xA8B7),\n        ivec4(0xDEFFEECD, 0xEBFD, 0xCAFFCD88, 0xE3EF),\n        ivec4(0xF7CE8978, 0xE3AF, 0xFF8C7887, 0xF7FF),\n        ivec4(0xFF8C8898, 0x554FEFF, 0xFF9D8888, 0x3871FEFF),\n        ivec4(0xEF8C8888, 0x77B5FFFF, 0xDF9C8888, 0x87C8FFFF),\n        ivec4(0xCD898887, 0x88E9FFEF, 0xCD897878, 0x9CDCEFEF),\n        ivec4(0xCC888888, 0xDDDDDEDD, 0xCC998988, 0xEDDEDDCD),\n        ivec4(0xCC9C9999, 0xDDDDDDCC, 0xCCC99989, 0xCCC9DCCC),\n        ivec4(0x70FDCFA9, 0x0, 0xE7FEDEA9, 0x7011),\n        ivec4(0xDEFFCE9C, 0xC0DC, 0xCCDF8987, 0xB0FE),\n        ivec4(0xEB8D7887, 0x70CF, 0xFF8D8788, 0xC0FF),\n        ivec4(0xEF8D8788, 0x540F7FF, 0xEF9C8888, 0x7801F7FF),\n        ivec4(0xDE898787, 0x7757FCFF, 0xCD898877, 0x7777FCFF),\n        ivec4(0x9D788888, 0x88C9EEDD, 0xCC898888, 0xCDC9ECCD),\n        ivec4(0xCC9C9998, 0xDDDDD9CD, 0xCC9C9C99, 0xDDDDDDCC),\n        ivec4(0xC99C9998, 0xCCCCDCCC, 0x9C999998, 0x999CC9CC),\n        ivec4(0xCBDE9A, 0x0, 0xA0EEAE8B, 0x0),\n        ivec4(0xECFE9D8A, 0x507C, 0xCDCE7888, 0x10ED),\n        ivec4(0xEC8C3888, 0xED, 0xFF8D8788, 0x50FE),\n        ivec4(0xEF8C7788, 0xB4FF, 0xDE898787, 0x7801D0FF),\n        ivec4(0xCD787877, 0x7813E5EE, 0x9D888888, 0x3787E7DD),\n        ivec4(0x9C888888, 0x8898D9CD, 0xCC9C8988, 0xDC89C8CD),\n        ivec4(0xC99C9998, 0xDCDD9CCD, 0xC9999999, 0xDCCCCDCC),\n        ivec4(0xC9998988, 0xC99CC9CC, 0x9C998888, 0x989998C9),\n        ivec4(0xB6DCDC, 0x1000000, 0x70EDBD7B, 0x0),\n        ivec4(0xEBEEAC79, 0x5B, 0xCDAD7788, 0xDA),\n        ivec4(0xFD897788, 0xFB, 0xEF8C8788, 0xFD),\n        ivec4(0xDF897787, 0x30FE, 0xCD887778, 0x8A00B0FF),\n        ivec4(0x8D887878, 0x7817A1DE, 0xCC888888, 0x7777A7DD),\n        ivec4(0xCC998888, 0x798899CD, 0xC9C98989, 0xDC8C98CD),\n        ivec4(0x9C9C9999, 0xCDDD8CCC, 0x9C9C9988, 0xCCCDCCCC),\n        ivec4(0x9D99A888, 0x99C99999, 0xCD898888, 0x888999C9),\n        ivec4(0xB6CCDC, 0x1000000, 0x30EEBD7B, 0x0),\n        ivec4(0xDBCE7888, 0x77, 0xDD7C7788, 0xD3),\n        ivec4(0xFE898787, 0xF7, 0xDF798787, 0xFC),\n        ivec4(0xCE787777, 0x40FE, 0x9D787878, 0x8A0070EE),\n        ivec4(0x9C888888, 0x781771CE, 0xCC998888, 0x377733CD),\n        ivec4(0xC9998988, 0x798889CC, 0xCC999998, 0xDC8C88CC),\n        ivec4(0x9C9C9989, 0xDDDD9CC9, 0xCC998988, 0xCCCCCCC9),\n        ivec4(0xCD898A88, 0x99999999, 0xCD898888, 0x889899C9),\n        ivec4(0xB7CDCA, 0x14000000, 0x30EEBC7B, 0x0),\n        ivec4(0xDA9D77A8, 0xA2, 0xEE7C8778, 0xD0),\n        ivec4(0xFF897788, 0xF7, 0xDE797778, 0xFA),\n        ivec4(0x9E887777, 0x40FD, 0x9D888888, 0x8A0130DD),\n        ivec4(0xCC898888, 0x781731CE, 0xCC9C8988, 0x777713CC),\n        ivec4(0xC99C9989, 0x89888AC9, 0xCC9C9988, 0xDC8C98D9),\n        ivec4(0x9C9C9989, 0xCDDD8CD9, 0xCD9C99A8, 0xCCCDCC99),\n        ivec4(0xCE998988, 0x9899C999, 0xCD998888, 0x888999C9),\n        ivec4(0xB6CDCA, 0x14000000, 0x70FDBC7B, 0x4000000),\n        ivec4(0xEB8D7788, 0xC0, 0xEF8D8778, 0xC0),\n        ivec4(0xEF8C7788, 0xF5, 0xDF797777, 0xF7),\n        ivec4(0xCE888778, 0x40ED, 0xCD898878, 0x8A0130DC),\n        ivec4(0xCC9C8888, 0x881711DC, 0xC99C9989, 0x777313D8),\n        ivec4(0xCCCC9989, 0x89888AD7, 0xCC9C9998, 0xDC8C98D9),\n        ivec4(0xCD9C9989, 0xDCDD9CC9, 0xCE999988, 0xCCCDCC99),\n        ivec4(0xDE99A888, 0x98999999, 0xDE9C8888, 0x888999C9),\n        ivec4(0xB6CDCC, 0x12000000, 0x10EDBC7B, 0x4000000),\n        ivec4(0xDB9E7788, 0x40000C0, 0xEF8E8778, 0x90),\n        ivec4(0xFF8C8787, 0xE2, 0xDF897777, 0xF3),\n        ivec4(0xCE888878, 0x20FA, 0xCD998888, 0x890510E9),\n        ivec4(0xCC9C8988, 0x881711DA, 0xCCCC9999, 0x777703D7),\n        ivec4(0xCCCC9C99, 0x898889D7, 0xCDCC9989, 0xDC8C98D9),\n        ivec4(0xCDCC99A9, 0xDDDD9CC9, 0xDE999989, 0xCCCDDC99),\n        ivec4(0xDE9CA989, 0x98999999, 0xDE9C8988, 0x888999C9),\n        ivec4(0xB6DCCC, 0x14010000, 0x50FEACBB, 0x4040000),\n        ivec4(0xEB9E77A8, 0xC0, 0xFF8E8888, 0xA0),\n        ivec4(0xFF8C7888, 0xE2, 0xEF897787, 0xF3),\n        ivec4(0xDE888888, 0x10020FA, 0xDD999988, 0x890510EC),\n        ivec4(0xCCCD99A9, 0x881701DA, 0xDCCDC999, 0x387713D7),\n        ivec4(0xCCCCC999, 0x8C9889D7, 0xCDCCCC99, 0xDC9C98D9),\n        ivec4(0xDD9C9C99, 0xDDDD9DC9, 0xDFCC9999, 0xDCCDCD9C),\n        ivec4(0xDECC9989, 0x99C9C99C, 0xEECD9988, 0x889999CC),\n        ivec4(0xB7CDCC, 0x16010000, 0x30EEBCBB, 0x44000000),\n        ivec4(0xEA8E87A8, 0xC0, 0xFF8D8888, 0xA0),\n        ivec4(0xFF8C7788, 0xE2, 0xDF798787, 0xF3),\n        ivec4(0xCF898887, 0x50020FA, 0xCD9C8989, 0xA90310E9),\n        ivec4(0xCCCD9989, 0x883701E8, 0xDCCDC999, 0x388703D7),\n        ivec4(0xCCCCCC99, 0x8C9889D7, 0xCDCC9C99, 0xDC9D98DC),\n        ivec4(0xCECC9C99, 0xDDDD9DC9, 0xDECC9999, 0xCCCDCD9C),\n        ivec4(0xEECC99A9, 0x99C9C9CC, 0xEECD9988, 0x889999C9),\n        ivec4(0xCBDDDC, 0x56100000, 0xB0EFBCBB, 0x44000010),\n        ivec4(0xFD8EA8C9, 0x440000C0, 0xFF8988BA, 0xD0),\n        ivec4(0xEF898888, 0xFB, 0xEF898788, 0xFA),\n        ivec4(0xCE888888, 0x70070FE, 0xDE9C9989, 0xAC0731ED),\n        ivec4(0xDCCD9C99, 0x893841E9, 0xDDCDCC9C, 0x788713D7),\n        ivec4(0xDDCCCC9C, 0x9D9899D7, 0xDDCCCC9C, 0xDDCDC9DC),\n        ivec4(0xDDCCCC9C, 0xEDDECDC9, 0xDFCCCC99, 0xDCCDDDCC),\n        ivec4(0xEFCD9C99, 0xC9CCCC9C, 0xEECD9999, 0x899999CC),\n        ivec4(0xCBEEEE, 0x55110000, 0xD5EFBCBB, 0x44000070),\n        ivec4(0xFEDE9CA9, 0x440000D4, 0xEF899BCC, 0xF3),\n        ivec4(0xCF88A8AA, 0x40FC, 0xDF889899, 0x74FF),\n        ivec4(0x9E8888A8, 0x3B00A4FF, 0x9D8888A9, 0x9957A3FF),\n        ivec4(0xCD9C9998, 0x897887EF, 0xDDCCCC99, 0x788877DD),\n        ivec4(0xDDCCCC9C, 0x9D999CDD, 0xDDCCCC9C, 0xDDDE99ED),\n        ivec4(0xCDCDCC9C, 0xDEDDCDD9, 0xDECCCC99, 0xCCDDDCCC),\n        ivec4(0xDFCCC999, 0x99CCCCCC, 0xEECC9999, 0x899999CC),\n        ivec4(0xB7EEFF, 0x55110000, 0xD7FFCDDD, 0x44000053),\n        ivec4(0xFFCFBABB, 0x440000CB, 0xFFCEBCC9, 0xFC),\n        ivec4(0xCFAACCCC, 0x70FF, 0x8D98C9C9, 0x40D1FF),\n        ivec4(0x8C999999, 0x7A40F7FF, 0x8D9999AC, 0xA958FBFF),\n        ivec4(0x89889999, 0x8878FADF, 0x9C999899, 0x8998ECDF),\n        ivec4(0xCDC99999, 0xDD9CDDDE, 0xCDCCCC9C, 0xDDDDCCDD),\n        ivec4(0xCDCDCC9C, 0xEDDDDDED, 0xCDCDCC9C, 0xCCDDDCDD),\n        ivec4(0xCECC9C9C, 0x99CCCCDC, 0xDD9C9999, 0x899999DC),\n        ivec4(0xB7EDEF, 0x55110000, 0xE7FFEEDE, 0x44000010),\n        ivec4(0xFFCCCBAA, 0x440040DA, 0xFFCC7BAB, 0x30FE),\n        ivec4(0xEFCDCCCC, 0xC4FF, 0x9CCACDCD, 0xF7EF),\n        ivec4(0x889A9CCC, 0x7A40FE9F, 0x9899C9C9, 0xA978FF9F),\n        ivec4(0x989CC999, 0x89C8FF9E, 0x9999999C, 0x89C8FF9F),\n        ivec4(0x88889999, 0xCDDCEE9D, 0x99989899, 0xDDDEECCD),\n        ivec4(0xCCCC9999, 0xEEDDDDDD, 0xCCCCCCC9, 0xCCDDDDDD),\n        ivec4(0xCDC9C999, 0x9CCCCCDD, 0xCCC99999, 0x8999C9DC),\n        ivec4(0x20EBFEEF, 0x15110000, 0xFDDFEDDD, 0x44000030),\n        ivec4(0xEF9CBBAB, 0x440040FC, 0xDFBC7BC9, 0x80FE),\n        ivec4(0xDECDCDCD, 0xE6FF, 0xA9C9CDCC, 0xFACF),\n        ivec4(0xA89CCCCC, 0x7A74FF8C, 0x9899C9C9, 0xA9A8FF8C),\n        ivec4(0x9999C999, 0x89EAFF89, 0x9999999C, 0x89D8FF89),\n        ivec4(0x88999999, 0xDDDDDF89, 0x88889899, 0xDDDEDD89),\n        ivec4(0x9989999A, 0xEEEDDD9D, 0xCC999999, 0xDCDDDDCD),\n        ivec4(0xCCCC9999, 0x99CCDCCD, 0xCC9999A9, 0x9999C9CC),\n        ivec4(0xB0FDFEEE, 0x55100000, 0xFFCDCAAB, 0x44000070),\n        ivec4(0xEF9C7BA8, 0x40010FC, 0xDECDCBCD, 0x70FE),\n        ivec4(0xA9C9CDCD, 0xE5DF, 0x88999CCC, 0xFA8D),\n        ivec4(0x989999C9, 0x7A74FF89, 0x989999C9, 0x89B8FF8C),\n        ivec4(0x98989999, 0x88D8FF8C, 0x88989999, 0x89D8EF89),\n        ivec4(0x88889899, 0xDDCCDD88, 0x89888899, 0xDDDDDD9C),\n        ivec4(0x9C999998, 0xEEDEDDCD, 0xCC9C9999, 0xCCCDDDCD),\n        ivec4(0xC9C99999, 0xC9CCCCCD, 0xCC9999A9, 0x89999CCC),\n        ivec4(0xB0EDDDDD, 0x15010000, 0xFE9DBABB, 0x4000031),\n        ivec4(0xEFCD78C8, 0xEB, 0x9CC9DCCC, 0x10FE),\n        ivec4(0x7898C9CC, 0xC0DF, 0x8899A9C9, 0xF79F),\n        ivec4(0x8889999A, 0x7A64FD8E, 0x88989899, 0x8978FD9F),\n        ivec4(0x88889899, 0x7887FE8D, 0x888888A9, 0x88C9DD8C),\n        ivec4(0x89888888, 0xCD99DC9D, 0x9C9C9999, 0xDDDDDCCD),\n        ivec4(0xCC9C9C99, 0xDEDDCDDD, 0xCCC99999, 0xCCDDDCDD),\n        ivec4(0xCCC99999, 0x9CCC9CCC, 0xCC9999A9, 0x899999DC),\n        ivec4(0x70EADDDD, 0x14010000, 0xFACE8BB7, 0x4000000),\n        ivec4(0xEFCD79C8, 0xAB, 0x9D88C9CC, 0xEC),\n        ivec4(0x78989A99, 0x70DF, 0x888898AA, 0xD0EF),\n        ivec4(0x888888A8, 0x4740F7DF, 0x888888A9, 0x8817FBDF),\n        ivec4(0x788788A8, 0x7877FA8D, 0x89888888, 0x7888E89D),\n        ivec4(0x99998888, 0x9D98D9CD, 0xCC999999, 0xDCCDC8CD),\n        ivec4(0xCC9C9C99, 0xDDDD9DDD, 0xCC9C9C99, 0xCCCCCCCD),\n        ivec4(0xCC99999A, 0x99C999CC, 0xCD998989, 0x889999CC),\n        ivec4(0xCBDEDE, 0x12000000, 0xE7CFBABB, 0x4000000),\n        ivec4(0xFDCE7998, 0xA7, 0xCE88C9CC, 0xF7),\n        ivec4(0x7988999A, 0x40EE, 0x8988889A, 0xB0FF),\n        ivec4(0x888888A8, 0x500E3EF, 0x898788A9, 0x8913E3EF),\n        ivec4(0x88878888, 0x8877E89E, 0x99888888, 0x788797CD),\n        ivec4(0xCC999988, 0x8998CCDD, 0xCDC99999, 0xDC9C99CD),\n        ivec4(0xCCC99C99, 0xDDDD9CDC, 0xCCCC9999, 0xDCCDCDCC),\n        ivec4(0xCD999999, 0x9999C9CC, 0xCD9989A8, 0x9899C9C9),\n        ivec4(0xB7DEDE, 0x5010000, 0xC1DFAABB, 0x4000000),\n        ivec4(0xFCCE89A7, 0xA2, 0xCE88CACC, 0xE1),\n        ivec4(0x8C87989A, 0xFC, 0x8D8888A8, 0x30FF),\n        ivec4(0x898888A8, 0xA2FF, 0x89778888, 0x8901C1EF),\n        ivec4(0x88888788, 0x8877C7CF, 0x9C888888, 0x387773DE),\n        ivec4(0xCD9C9989, 0x889889CD, 0xCD999999, 0xCD9999CD),\n        ivec4(0xCDCC9C99, 0xDDDD9CDC, 0xCCC99999, 0xDDDCCCC9),\n        ivec4(0xCD999999, 0x99CCCCC9, 0xCD9989A8, 0x989999CC),\n        ivec4(0x76EDEE, 0x15000000, 0xA0EFB9BA, 0x4000000),\n        ivec4(0xFBCE8CA7, 0x90, 0xDF88CACC, 0xD0),\n        ivec4(0x8D87889A, 0xFB, 0x8D8888A8, 0x10FE),\n        ivec4(0x8C8888A8, 0x70FF, 0x89778888, 0x7C01A0FF),\n        ivec4(0x89888788, 0x8837A7DF, 0x9C998888, 0x387733DD),\n        ivec4(0xCD999989, 0x889889CC, 0xCDCC9999, 0xCD8899DC),\n        ivec4(0xCDCC9C99, 0xDCDD99D9, 0xCDC99999, 0xDDDDCDC9),\n        ivec4(0xCE999999, 0xC99CCC99, 0xCE9989A8, 0x8999999C),\n        ivec4(0x74DCEE, 0x14010000, 0x70EEBCBA, 0x4000000),\n        ivec4(0xFBDF8C87, 0xA0, 0xDE89C8CC, 0xD0),\n        ivec4(0x8E87A89A, 0xF3, 0x8F888888, 0xFD),\n        ivec4(0x8D8888A8, 0x50FF, 0x8C777898, 0x790070FF),\n        ivec4(0x89888888, 0x883787DF, 0xCD898888, 0x787733DC),\n        ivec4(0xCD9C9989, 0x789888C9, 0xCDCC9999, 0x9D8899DC),\n        ivec4(0xCDCC9C99, 0xDCDD99D9, 0xCD9C9999, 0xDDDDCDC9),\n        ivec4(0xCE9C9999, 0xCC9CCC99, 0xDD9989A8, 0x8999999C),\n        ivec4(0x61ECEE, 0x14010000, 0x70EEACBA, 0x4000000),\n        ivec4(0xF7DF8C87, 0xA0, 0xEF8CCACC, 0xD0),\n        ivec4(0x9E87A8A9, 0xF3, 0x9F8888A8, 0xFC),\n        ivec4(0x8D8888A8, 0x70FF, 0x8D878798, 0x7C0070FF),\n        ivec4(0x89888888, 0x883783EF, 0xCD998888, 0x787733DC),\n        ivec4(0xDC9C9CA9, 0x789888D8, 0xDDCC9C99, 0x9D8899DC),\n        ivec4(0xCDCCCC9C, 0xDCDD89D9, 0xCDCC9999, 0xDDDDCDC9),\n        ivec4(0xCECC9999, 0xCCCCCC99, 0xDE999989, 0x9899999C),\n        ivec4(0x70EBEE, 0x12000000, 0x70FECCBC, 0x4000000),\n        ivec4(0xF7DF8B87, 0xB0, 0xEF8CC9CC, 0xE0),\n        ivec4(0x9E87989A, 0xF7, 0x8F8888A8, 0xFC),\n        ivec4(0x8E8888A8, 0x70FF, 0x8D788898, 0x7C0170FF),\n        ivec4(0x89888888, 0x883781EF, 0xCC998888, 0x787733DD),\n        ivec4(0xDD9C9CA9, 0x789889D9, 0xDCCC9C99, 0xCD9899D9),\n        ivec4(0xCDCCCC99, 0xDCDD99D9, 0xCDCC999C, 0xDDDDCDC9),\n        ivec4(0xDDC99999, 0xCC9CCC9C, 0xDD9C99A8, 0x9899999C),\n        ivec4(0x70ECEE, 0x14010000, 0x70EEBDCC, 0x4000000),\n        ivec4(0xFBCFB987, 0xB1, 0xEE9DCCCC, 0xE1),\n        ivec4(0x9E879A9C, 0xF7, 0x8E9898AA, 0xFD),\n        ivec4(0x8D8888A9, 0x70FF, 0x8E8888A9, 0x8C0070FF),\n        ivec4(0x89888888, 0x8838A3EF, 0xCD998989, 0x787737DD),\n        ivec4(0xCD9C9C99, 0x889889DC, 0xCDCCCC99, 0xCD99C9DC),\n        ivec4(0xDDCCCC9C, 0xDDDD9CD9, 0xCDCCCC99, 0xDDDDCDC9),\n        ivec4(0xDE9C9C99, 0xCCCDCC9C, 0xDE9999A9, 0x9999C99C),\n        ivec4(0xB0DDEF, 0x14010000, 0x90EFCCBC, 0x4000000),\n        ivec4(0xFCCE7B87, 0x77, 0xEFCC9CCD, 0xF7),\n        ivec4(0x9E87CA9C, 0xEC, 0x8C8899AA, 0xFF),\n        ivec4(0x8C8888A9, 0xB1FF, 0x8D8898A9, 0xAC01A1FF),\n        ivec4(0x88888889, 0x8838C3DF, 0x9C898888, 0x787777DE),\n        ivec4(0xCDCCCC99, 0x88988CDD, 0xCDCC9C99, 0xDD9999DC),\n        ivec4(0xDDCCCC9C, 0xDDDD9CDC, 0xCDCCCC99, 0xDDDDDDC9),\n        ivec4(0xCECC9999, 0xCCCCCC9C, 0xDE9C99A9, 0x999999CC),\n        ivec4(0x74DCEF, 0x14110000, 0x90EEEECE, 0x4000000),\n        ivec4(0xFEAEBB87, 0x6A, 0xFFCE8BC9, 0xFC),\n        ivec4(0xCE99CDCD, 0x20FE, 0x8998C9AC, 0x70FF),\n        ivec4(0x88A9A999, 0x500E6FF, 0x898999C9, 0xAC17E7FF),\n        ivec4(0x88889899, 0x8978F7DF, 0x998898A9, 0x7888DACF),\n        ivec4(0xCC9C9999, 0x8C99CCDE, 0xCDCCCC99, 0xDD9CC9DD),\n        ivec4(0xCDCCCC9C, 0xDDDE9DDC, 0xCDCCCC99, 0xDDDDDDDC),\n        ivec4(0xCECC9999, 0xCCCCCCCC, 0xDE9999A9, 0x999999CC),\n        ivec4(0x20CBDE, 0x15100000, 0x70FCFFEF, 0x4000000),\n        ivec4(0xFECECCAC, 0x4003063, 0xFFBC7BB7, 0x70ED),\n        ivec4(0xFFCDAACC, 0xB0FF, 0xCDC9CDCD, 0xD0FE),\n        ivec4(0x889A9C9C, 0x700F7DF, 0x8899999C, 0x9C57FADF),\n        ivec4(0x88999A99, 0x8978FECF, 0x88899999, 0x8997FDCF),\n        ivec4(0x88889899, 0x9DC9FDCD, 0x999999A9, 0xDDCDDCDD),\n        ivec4(0xCC9C9C99, 0xDDDDCDDD, 0xCCCCCC99, 0xDDDDDDDD),\n        ivec4(0xCDCCC999, 0xCCCCCCCC, 0xCD999989, 0x989999CC),\n        ivec4(0x40B7DC, 0x15100000, 0xDBFEFF, 0x4000000),\n        ivec4(0xEDEFEEDD, 0x40000040, 0xFFBCBABB, 0xC4EB),\n        ivec4(0xDFAC38A7, 0xE4FF, 0xEF9D9BDC, 0xF3FE),\n        ivec4(0xCDDCDDCC, 0x5B00FCFE, 0x88CACCCC, 0x9C58FECF),\n        ivec4(0x88A999C9, 0x89A8FF8D, 0x989999AC, 0x79A8FF8F),\n        ivec4(0x98999999, 0x9DD9FF8D, 0x88889999, 0xDDDDFE9C),\n        ivec4(0x89889899, 0xDEEDEE9C, 0x999999A8, 0xDDDDDDCD),\n        ivec4(0xCC9999A9, 0xCCCCCCCD, 0x9C9999A8, 0x989999CC),\n        ivec4(0x40CBED, 0x15100000, 0xECFEEF, 0x4000000),\n        ivec4(0xEEEFEEDD, 0x40000060, 0xEFBCBCBB, 0xA7EB),\n        ivec4(0xCFBC38A7, 0xE7FF, 0xDFBC87CC, 0xF7FE),\n        ivec4(0xDEDDDDCD, 0x5A40FEFE, 0x99C9CCCC, 0x9C78FFDE),\n        ivec4(0x88CACCCC, 0x89C7FF8D, 0x8899A999, 0x89D7FF8C),\n        ivec4(0x9999C999, 0xCDE9FF89, 0x98999999, 0xDDDEFF8C),\n        ivec4(0x88899999, 0xDEEDDF89, 0x888888A8, 0xDDDDDD89),\n        ivec4(0x888888A8, 0xC9DCCC9C, 0x99898888, 0x9999C9CC),\n        ivec4(0xB6FDFF, 0x14010000, 0xA7FFEEDE, 0x4000000),\n        ivec4(0xFFCDCCAB, 0x40070B0, 0xDFBC7BB7, 0xD0FC),\n        ivec4(0xEF9C78C9, 0xE4FF, 0xDECDDDCD, 0xF7FE),\n        ivec4(0xACCCCCCC, 0x7A00FDEE, 0x8898CCCC, 0x9C78FF9E),\n        ivec4(0x9799AAC9, 0x89C7FF8C, 0x98999999, 0x89C7FF8D),\n        ivec4(0x98989999, 0xCDDCFF8C, 0x889898A9, 0xDDDEEF8C),\n        ivec4(0x88888898, 0xEEEDDE89, 0x888888A8, 0xDDDDDD9C),\n        ivec4(0x89888888, 0x9CCCCC9C, 0x999988B8, 0x98999CCC),\n        ivec4(0x50EBEEDE, 0x11000000, 0xFACEACBC, 0x0),\n        ivec4(0xFFAC7B87, 0x70C7, 0xEFCC8BCC, 0xB0FE),\n        ivec4(0xCECCDCCC, 0xB0EF, 0x8988CCC9, 0xE2EE),\n        ivec4(0x87A8AA99, 0x7C00FA9F, 0x88888999, 0x8978FCCF),\n        ivec4(0x8888899A, 0x8987FE9E, 0x88888899, 0x7C88FD9E),\n        ivec4(0x888888A8, 0xDDC9FD8C, 0x88888788, 0xCDDDDC9C),\n        ivec4(0x89988888, 0xDEDDDE9C, 0x9C9989A9, 0xDCDDDCCD),\n        ivec4(0x99998988, 0x99C999CC, 0x99898888, 0x989999C9),\n        ivec4(0x70EADDCD, 0x1000000, 0xFA9E8B7B, 0x0),\n        ivec4(0xFF9D78C8, 0x20AC, 0xDEC9CCCC, 0x10FD),\n        ivec4(0x8CB7CAC9, 0xB0EF, 0x7888899A, 0xC0DF),\n        ivec4(0x888898A8, 0x7A00F7DF, 0x888888A8, 0x8958FBEF),\n        ivec4(0x78888888, 0x8877FACE, 0x88878788, 0x7988EC9D),\n        ivec4(0x89888888, 0xCD99D99D, 0x9C999888, 0xDDDDCCCC),\n        ivec4(0x9C999989, 0xDDDDDDCC, 0x9C998989, 0xCCCDCCCD),\n        ivec4(0x9C998988, 0x99C999C9, 0x9C898888, 0x88999999),\n        ivec4(0x30EBDDCD, 0x0, 0xF79EBAB7, 0x0),\n        ivec4(0xFECD78C8, 0xAC, 0xDEAACCCC, 0xEA),\n        ivec4(0x7C879A9A, 0x60EE, 0x888888A8, 0x70FF),\n        ivec4(0x78888888, 0x5A00E2EF, 0x89888888, 0x8917D3EF),\n        ivec4(0x78777888, 0x7877E7CE, 0x88888888, 0x7888C8CD),\n        ivec4(0x99888888, 0x9D88C9CD, 0x9C998988, 0xCCCD99CC),\n        ivec4(0x9C999989, 0xDDDDCDCC, 0x9C998989, 0xCCCDCCCC),\n        ivec4(0x9C998888, 0x89999999, 0xCD898888, 0x889899C8),\n        ivec4(0x10DBDDCD, 0x1000000, 0xD19E8BB7, 0x0),\n        ivec4(0xFECD8BCA, 0xC7, 0xCE88CC9C, 0xE3),\n        ivec4(0x7C87A8A9, 0xFC, 0x89888888, 0x20FF),\n        ivec4(0x88878888, 0x800A0FF, 0x89878788, 0x8907A1EF),\n        ivec4(0x88787888, 0x7877979F, 0x89888888, 0x788777CD),\n        ivec4(0x9C898988, 0x9C8899CD, 0xCC999998, 0xDC9D89C9),\n        ivec4(0xCC999989, 0xDDDDCDC9, 0x9C998988, 0xDCDCCC9C),\n        ivec4(0xCD999888, 0x99999999, 0xCD988888, 0x88989999),\n        ivec4(0xDBCDCD, 0x1000000, 0xD1CF8BB7, 0x0),\n        ivec4(0xEDCDB9CC, 0xC4, 0xCE87CAC9, 0xE0),\n        ivec4(0x8C8788A8, 0xFB, 0x8D8888B8, 0xFE),\n        ivec4(0x88878888, 0x70070FF, 0x89777888, 0x890771DF),\n        ivec4(0x88888888, 0x887783DD, 0x9C898888, 0x788737CC),\n        ivec4(0xCC998988, 0x8C8899D9, 0xCC9C9999, 0xDC9D98D9),\n        ivec4(0x9C9C8989, 0xCDDD9DC9, 0xCC9C9998, 0xDCCDCC9C),\n        ivec4(0xCD998888, 0x99C99999, 0xCD998888, 0x88989999),\n        ivec4(0xDBCDCD, 0x1000000, 0xC1CF8BB7, 0x10),\n        ivec4(0xEECDACCC, 0xC0, 0xCE8798AC, 0xC0),\n        ivec4(0x7D888BA8, 0xF7, 0x8E888888, 0xFC),\n        ivec4(0x8C778888, 0x170050FE, 0x89878788, 0x890771EE),\n        ivec4(0x99888888, 0x887771DC, 0xCC998888, 0x788737D8),\n        ivec4(0xCD9C9989, 0x8D8899C8, 0xCD9C9989, 0xCCCD88D9),\n        ivec4(0xCCCC99A9, 0xDDDD9D99, 0xDD999989, 0xDCCCCC9C),\n        ivec4(0xDC9C8989, 0x99C99999, 0xDD9C8888, 0x88989999),\n        ivec4(0xCBCECD, 0x10000000, 0xC0CF8BB7, 0x10),\n        ivec4(0xFDCDACCC, 0xB0, 0xCE879AAC, 0xC0),\n        ivec4(0x8E8788A8, 0xF3, 0x8E8888A8, 0xFA),\n        ivec4(0x8D878788, 0x1B0050FD, 0x8C878788, 0x890731ED),\n        ivec4(0x9C898888, 0x887733D9, 0xCC999988, 0x788737D7),\n        ivec4(0xDCCC99A9, 0x9D8899C8, 0xCDCC9999, 0xCCCD89D9),\n        ivec4(0xCDCC9CA9, 0xDDDD9D99, 0xDD9C9989, 0xCCCDCC9C),\n        ivec4(0xDC9C9989, 0x99999999, 0xDD9D8988, 0x88989999),\n        ivec4(0xCBDEDD, 0x14000000, 0xC0DF8BBB, 0x10),\n        ivec4(0xFDCE89CC, 0xB0, 0xCF78C9AC, 0xC0),\n        ivec4(0x8E88A8A9, 0xF5, 0x8F8888A8, 0xFA),\n        ivec4(0x8D888889, 0x1B0020FD, 0x8C788888, 0x891730FD),\n        ivec4(0x9C898888, 0x887733D9, 0xCD9C9C89, 0x798777D3),\n        ivec4(0xDDCCC999, 0xCD8899C8, 0xCDCCCC99, 0xCDDD99D9),\n        ivec4(0xCDCC9C9C, 0xDDDDCD99, 0xDDCC9999, 0xDCDDDC9C),\n        ivec4(0xECCC99A9, 0x99C9999C, 0xED9D9989, 0x88989999),\n        ivec4(0xDBEEDE, 0x14010000, 0xD1CFBBBB, 0x4000010),\n        ivec4(0xFDCE88CC, 0xC0, 0xDF9BDCCC, 0xD0),\n        ivec4(0x7D88AAA9, 0xF7, 0x8E888999, 0xFD),\n        ivec4(0x8C88A899, 0x7A0030FF, 0x898888A9, 0x991870FE),\n        ivec4(0x9C888988, 0x887777DC, 0xCDCC9989, 0x7C8878D7),\n        ivec4(0xDDCC9C9C, 0xCD8999C9, 0xCDCCCC99, 0xCDDD9CD9),\n        ivec4(0xCDCCCC9C, 0xDEDDCD99, 0xDDCC9999, 0xCCDDDC9C),\n        ivec4(0xECCC9C99, 0x99999CC9, 0xECCD99A9, 0x989899C9),\n        ivec4(0x40D7FEEE, 0x14010000, 0xE7CFCCCC, 0x4000001),\n        ivec4(0xFFADBBCA, 0xC7, 0xEFCDDCCD, 0xF7),\n        ivec4(0x8DCBCCCC, 0xFD, 0x889AA9AC, 0x30FF),\n        ivec4(0x8899999C, 0x7D04C4EF, 0x89899999, 0xA938A5FF),\n        ivec4(0x898898A9, 0x898797CF, 0xCC999989, 0x8C9889DD),\n        ivec4(0xCDCCCC99, 0xDD9CC9DC, 0xCDCCCC99, 0xDDDD9CD9),\n        ivec4(0xDDCCCC9C, 0xDDDDDDCC, 0xDDCC9C99, 0xCCDCCCCC),\n        ivec4(0xDD9C9C99, 0x99C99C9C, 0xDD9D9989, 0x99999999),\n        ivec4(0x40D7FEEF, 0x14010000, 0xEBEFEDCD, 0x4000001),\n        ivec4(0xEFACBBCB, 0x400000CC, 0xEFBCCBDC, 0xFE),\n        ivec4(0xCECDDDCC, 0x70FF, 0x8ACCCCCC, 0x400C0DF),\n        ivec4(0xA8A9AC9C, 0xBC05F78F, 0x9999C9C9, 0x9938F79F),\n        ivec4(0x9899999C, 0x8988FA9F, 0x88989999, 0x8C98DC9D),\n        ivec4(0x9C999999, 0xDD9CCCCD, 0xCCCCC999, 0xDEDD9DDD),\n        ivec4(0xCDCCCC9C, 0xEDDDDDDD, 0xCDCC9C99, 0xCCDCCCCD),\n        ivec4(0xDD9C9C99, 0x99C99CC9, 0xDD9999A9, 0x989998C9),\n        ivec4(0xDBFFEF, 0x11100000, 0xEAEFEECE, 0x4001010),\n        ivec4(0xEFCCCCCA, 0x440070EA, 0xCFBBBBCC, 0xB0FE),\n        ivec4(0xCEA9CCCD, 0xD0FF, 0xDCDDCDCD, 0x500F3DF),\n        ivec4(0xAACCCCCC, 0xAC05FC8D, 0x999CCCAC, 0x9978FE89),\n        ivec4(0x9C99C99C, 0x8C87FE99, 0x99C9CC9C, 0x9DC8EF9C),\n        ivec4(0x8999999C, 0xDDCDDD89, 0x99999999, 0xDEDDDDCC),\n        ivec4(0xCCCCCC9C, 0xDDDDDDDD, 0xCC9C9C99, 0xCCDCCCDD),\n        ivec4(0xCD9C9999, 0x99C9CCC9, 0xCD9999A9, 0x999998C9),\n        ivec4(0x70ECFFEF, 0x11010000, 0xFDEFEECD, 0x4001070),\n        ivec4(0xCFCCCCCB, 0x4000B0FA, 0xADBBBBCC, 0xA0FF),\n        ivec4(0xCDB8CDCD, 0xE6FF, 0xDDDDCCCC, 0x700FAEF),\n        ivec4(0xCACCCCCC, 0x9C27FEAC, 0xC9CCCCCC, 0x9978CF88),\n        ivec4(0x99999CCC, 0x8997CF98, 0x999CCC9C, 0xCDC9DF99),\n        ivec4(0x99C9C99C, 0xDDDECE99, 0x98989999, 0xDEEDDD89),\n        ivec4(0xC9999C9C, 0xDDDDDDCC, 0xCCC9C999, 0x9CDCCCCD),\n        ivec4(0xCC999999, 0x99C99CC9, 0x9C8999A9, 0x999898C9),\n        ivec4(0xD7EFEFDD, 0x14010000, 0xEFCDCDCC, 0x40030C3),\n        ivec4(0xCEAABBCA, 0x400B0FE, 0xAD8BC9CD, 0xC0FF),\n        ivec4(0xDDDCDDCC, 0xF7FF, 0xCCCDCCCC, 0xB00FCCD),\n        ivec4(0xCACCCCCC, 0xCC47DE88, 0x99C9CCAC, 0x8988CF88),\n        ivec4(0x99999C9C, 0x8C97CF99, 0x999CCC9C, 0xCDD9CF99),\n        ivec4(0x99C9999C, 0xDDDDCE89, 0x88989999, 0xEEEDCE89),\n        ivec4(0xC999C999, 0xDCDDDDCC, 0xCCC99999, 0x9CCCCCCC),\n        ivec4(0x9C999999, 0x99C9C9C9, 0x9C898989, 0x89899999),\n        ivec4(0xFDDECDCC, 0x5010010, 0xCFA9BBCA, 0x40010DA),\n        ivec4(0xCE8ACACC, 0x70FE, 0xDDDCDCDC, 0xA0FF),\n        ivec4(0xCADDCCCC, 0xF6CE, 0x989CCCCC, 0x1B00FB89),\n        ivec4(0x99A99C9C, 0x9C17ED88, 0x99999C9C, 0x8978EF98),\n        ivec4(0x9999C99C, 0x7C88DF89, 0x88989999, 0xDDC9DD88),\n        ivec4(0x89989999, 0xDDDDCC99, 0x9C999999, 0xEEDDDECC),\n        ivec4(0xCCCCC99C, 0xCDDDDDCD, 0xCC99C999, 0x99CC9CCC),\n        ivec4(0x9D9999A9, 0x99C99999, 0x9D988888, 0x89899899),\n        ivec4(0xFDCC9C9A, 0x11000010, 0xDFA9B7CC, 0x40000D9),\n        ivec4(0xDF9DDCCD, 0x40FD, 0x99DCCCCC, 0x70DF),\n        ivec4(0xA8C9CCCC, 0xD08E, 0x989899C9, 0x1B00F38D),\n        ivec4(0x9898999C, 0xAC57FA8C, 0x9899999C, 0x8978F98D),\n        ivec4(0x88889999, 0x8987EC89, 0x89889998, 0xCD99DC9C),\n        ivec4(0x9C9C9999, 0xDDDD99CD, 0xCC9C9C9C, 0xEEDDCDCD),\n        ivec4(0xCCC9C999, 0xDCDDDDDD, 0xCCC99999, 0xC9C99CCC),\n        ivec4(0xCD999999, 0x99C999C9, 0xCD898988, 0x89899999),\n        ivec4(0xF99D8AAB, 0x1000010, 0xEF8C97CC, 0xC7),\n        ivec4(0xCEDCDCCD, 0xFB, 0x88C9CCAC, 0xDE),\n        ivec4(0x87999A9C, 0xA09F, 0x88899899, 0x700E09F),\n        ivec4(0x88889999, 0x8C07E79E, 0x88889999, 0x8877E78D),\n        ivec4(0x888888A8, 0x7887989D, 0x99999999, 0x9D9899CD),\n        ivec4(0x9C9C9999, 0xDDCD99DC, 0xCC9C9C9C, 0xDEDDCDDC),\n        ivec4(0xCC9C9C99, 0xCCDDDCCC, 0xCD999999, 0x99CCCCCC),\n        ivec4(0xCD9999A8, 0x99999999, 0xCD9C8888, 0x88889999),\n        ivec4(0xF79EA9A8, 0x1000010, 0xFE9DB8DC, 0xC0),\n        ivec4(0xCEC9DCCC, 0xE6, 0x8898CC9C, 0xEC),\n        ivec4(0x8899A899, 0x50CF, 0x888898C9, 0x500B0DF),\n        ivec4(0x88889999, 0x8C05C1CF, 0x88888889, 0x8857939E),\n        ivec4(0x898998A8, 0x787877CD, 0xCC999999, 0x8C8889DC),\n        ivec4(0xCDCCC999, 0xDD9C99D9, 0xCCCCC999, 0xDDDD9DD9),\n        ivec4(0xCCCCC999, 0xDDDDDDCC, 0xDD999999, 0x99CCCC9C),\n        ivec4(0xDD9C99A8, 0x99C99999, 0xDD9C8998, 0x88889999),\n        ivec4(0xD1CFA9A8, 0x1000010, 0xFDCE88CC, 0x80),\n        ivec4(0xCECACDCD, 0xD0, 0x7998C9AC, 0xF3),\n        ivec4(0x88A9A899, 0xFD, 0x88889899, 0x50FF),\n        ivec4(0x88889899, 0x7C0071DF, 0x89888888, 0x883773CE),\n        ivec4(0x9C989989, 0x787737D9, 0xCC9C9C99, 0x898889D7),\n        ivec4(0xCDCCC999, 0xDC8C99D9, 0xCDCCC999, 0xDDDD8DD9),\n        ivec4(0xCDCCC999, 0xDDDDDD99, 0xDDCC9999, 0xCCDCCC9C),\n        ivec4(0xDD9C99A9, 0x99999C99, 0xDDCD9988, 0x88999999),\n        ivec4(0xA1DF99AA, 0x1000000, 0xFCCE8ACA, 0x70),\n        ivec4(0xDFC9DCCD, 0xB0, 0x7D889CAC, 0xE0),\n        ivec4(0x89899899, 0xFA, 0x8C889899, 0xFD),\n        ivec4(0x88889899, 0x790030EE, 0x89888888, 0x881773DD),\n        ivec4(0x9D9899A9, 0x887733D7, 0xCDCC9999, 0x798888C1),\n        ivec4(0xDDCCCC99, 0xCD8999C9, 0xCDCC9999, 0xCDDD9CC9),\n        ivec4(0xDDCCC999, 0xEEDDDD99, 0xDD9C9999, 0xCCDDCC9C),\n        ivec4(0xEDCD99A9, 0x99999C9C, 0xDDCD9989, 0x88999999),\n        ivec4(0x70EF9CAC, 0x11000000, 0xFCCF8ACB, 0x10),\n        ivec4(0xEFCCCCCD, 0x70, 0x8D98CCCC, 0xD0),\n        ivec4(0x8989A999, 0xF7, 0x8C889899, 0xFC),\n        ivec4(0x89889899, 0x7A0050FD, 0x89888889, 0x891771EC),\n        ivec4(0x9D9999A9, 0x887733D7, 0xCDCCC999, 0x798878C3),\n        ivec4(0xDDCCCC9C, 0xCD989999, 0xDDCCCC99, 0xCDDD9CC9),\n        ivec4(0xDDCC9C9C, 0xEEDDDD9C, 0xEDCD9999, 0xDCDDDC9C),\n        ivec4(0xEDCD9C99, 0x999C9C9C, 0xECDD9C89, 0x989999C9),\n        ivec4(0x20EDCDCC, 0x10000000, 0xEACF8ACB, 0x10),\n        ivec4(0xFECEC9DD, 0x70, 0x9E98CCCC, 0xC0),\n        ivec4(0x7C9A9999, 0xF3, 0x8C8999C9, 0xFA),\n        ivec4(0x89889899, 0x3A0020FD, 0x898898A9, 0x890870EC),\n        ivec4(0x9C9898A8, 0x887737D7, 0xCDCCC999, 0x788878C1),\n        ivec4(0xDDCCCC9C, 0xCD889999, 0xDDCCCC99, 0xDDDD9CC9),\n        ivec4(0xDDCC9C9C, 0xDEDDDD99, 0xEDCD9999, 0xCDDDDC9C),\n        ivec4(0xECCD9C99, 0x99C99CCC, 0xECDE9C99, 0x99C999C9),\n        ivec4(0x10ECEECE, 0x11000000, 0xE89FAACB, 0x10),\n        ivec4(0xFFCEC8DD, 0x70, 0xCFD9DDCC, 0xC0),\n        ivec4(0x889ACCCC, 0xF5, 0x989899AC, 0xFC),\n        ivec4(0x999899CC, 0x5A0020FD, 0x88889999, 0x890830ED),\n        ivec4(0x9C8999A9, 0x887777D8, 0xCD9C9C9C, 0x798878C1),\n        ivec4(0xDDCCCC9C, 0xCD989999, 0xDDCCCC9C, 0xDDDD9CC9),\n        ivec4(0xDCCDCC9C, 0xDEDDDDC9, 0xEDCD9C9C, 0xDDDDDC9C),\n        ivec4(0xECCD9C99, 0x99C9CCCC, 0xECDE9C99, 0x98C99999),\n        ivec4(0x20FCFEDE, 0x11000000, 0xF8CEC9CA, 0x4000070),\n        ivec4(0xFF8CCBDE, 0xA0, 0xDFDDDECD, 0xE0),\n        ivec4(0x88CCCCCC, 0xEB, 0x8899C9CC, 0xCE),\n        ivec4(0x999AC9CC, 0x5A0070CF, 0x8999C99C, 0x990871CF),\n        ivec4(0x89989999, 0x887777CD, 0xCCCCC9C9, 0x798878D7),\n        ivec4(0xCDCCCCCC, 0xCD9899C9, 0xDECCCC9C, 0xDDDD99D9),\n        ivec4(0xDDCDCC9C, 0xDEDDDD99, 0xEDCCCC99, 0xDDDDCD9D),\n        ivec4(0xFDCDC999, 0x99C99C9C, 0xECDD9C99, 0x98C999C9),\n        ivec4(0x50FCFFEE, 0x11000000, 0xFCDEDDDC, 0x4000070),\n        ivec4(0xDFB9CBDD, 0xE4, 0xDFCAEEDD, 0xF7),\n        ivec4(0xDCEEDDCC, 0x20EE, 0xC8CCCCCC, 0x708D),\n        ivec4(0x99C9CCCC, 0x7C00D49D, 0x99C9CCCC, 0x8918E39D),\n        ivec4(0x9999CC9C, 0x8978D79C, 0x9999CC99, 0x798899CC),\n        ivec4(0xCCCCCCCC, 0xCD99CCDD, 0xCDCDCC9C, 0xDDDD8CDC),\n        ivec4(0xDDCCCC9C, 0xEEDDDDC9, 0xDDCCCC9C, 0xDDDDDCCC),\n        ivec4(0xEDCDCC99, 0x99C99CCC, 0xEDCD9C99, 0x98C999C9),\n        ivec4(0x10DBFFEF, 0x11000000, 0xFAFFEFDE, 0x4000011),\n        ivec4(0xDFDCCCDC, 0x40000FA, 0xCDBBECCD, 0x10FE),\n        ivec4(0xCDECEECD, 0xA0FF, 0xEDDEDDCC, 0xE0DE),\n        ivec4(0xCCCCCCCC, 0x8C01E7A8, 0xCCCCDCCC, 0xA958DC98),\n        ivec4(0xC9CCCCCC, 0x8987DD9C, 0x99CCCCCC, 0x8C98DE99),\n        ivec4(0x99CCCCCC, 0xDD9CDC9C, 0xCCCCCC9C, 0xDDDDCDCC),\n        ivec4(0xDCCCCCCC, 0xEEDDDDDC, 0xCDCCCC9C, 0xCDDDDCCD),\n        ivec4(0xDECCCC9C, 0xC9C99CCC, 0xDDCC9989, 0x999999C9),\n        ivec4(0xC7EEEF, 0x11010000, 0xD7FFFFDF, 0x4000000),\n        ivec4(0xFFFFEEDD, 0x40030FC, 0xCDCDCCCD, 0xB0FF),\n        ivec4(0xBCBBDDCD, 0xE2DF, 0xBAEDDECC, 0xFADF),\n        ivec4(0xEEEEDDCC, 0xAC05FEEE, 0xDCDCCCCC, 0x8CA89ED9),\n        ivec4(0xCCCCCDCC, 0x89C88CC9, 0xCCCCCCCC, 0x8CD89C9C),\n        ivec4(0xCCCCCCCC, 0xDDEC9D9C, 0xC9CCCC9C, 0xDDEDCD99),\n        ivec4(0xCCCCCCCC, 0xEEDDDD9C, 0xCCCCCC9C, 0xDDDDCDCC),\n        ivec4(0xCCCCC99C, 0xC9C9CCDC, 0xCD9999A9, 0x999999C9),\n        ivec4(0x40B7DDEE, 0x11010000, 0xA3FDFFEE, 0x4000000),\n        ivec4(0xFFFFEFDD, 0x400070D7, 0xEEEEDEDC, 0xC4FF),\n        ivec4(0xCCBBCCCD, 0xF7DF, 0x7BDBDECC, 0x40FDCE),\n        ivec4(0xCAEEDECC, 0xAD76FFCE, 0xEEDECDCC, 0x99C8EFEE),\n        ivec4(0xCDCDCCCC, 0x8CF89CDC, 0xCCCCCCCC, 0x8CCC98CC),\n        ivec4(0xCCCDDDCC, 0xDDCDC9C9, 0xCCCCCCCC, 0xDDDF9CC9),\n        ivec4(0xCCCCCCCC, 0xEFDD9C9C, 0xCCCCC999, 0xDDDD9D99),\n        ivec4(0xC9CC9C99, 0xCCCCCC9C, 0x9C9999A9, 0x99C9C9C9),\n        ivec4(0x40C7EEEF, 0x11010000, 0xC7FEFFEF, 0x4000000),\n        ivec4(0xFFFFEFDD, 0x440070E7, 0xDEDECDCD, 0xC0FF),\n        ivec4(0xCCBBCCCD, 0x40F7CF, 0x7ACBDECC, 0x40FCCE),\n        ivec4(0xCAEEDECC, 0xAC76FFCE, 0xEEEECDCC, 0x9CC8EFEE),\n        ivec4(0xDDCCCCCC, 0x8CF8CCDC, 0xCCCCCCCC, 0x8CCC88CC),\n        ivec4(0xCCCDCDCC, 0xDD8DC999, 0xCCCCCCCC, 0xDDCF9CC9),\n        ivec4(0xCCCCCCCC, 0xEECECC99, 0xCC9C999C, 0xDDDE9999),\n        ivec4(0x99CC9999, 0xCCDC9C99, 0xC9C999A9, 0x99999999),\n        ivec4(0x50DBFFEF, 0x11010000, 0xF9FFEFDE, 0x4000010),\n        ivec4(0xDFEECDCD, 0x40FC, 0xCCBBCBCD, 0x70FF),\n        ivec4(0x9CB7DDCD, 0xD6CF, 0xBCFCDECC, 0xFADF),\n        ivec4(0xFEDEDDCC, 0x8C02FEDE, 0xCDCDCCCC, 0xACA8CEC9),\n        ivec4(0xCCCCCCCC, 0x8CD888C9, 0xCCCCCDCC, 0x8CD89899),\n        ivec4(0xC9CCCCCC, 0xDDDC9C99, 0xC9CCC9C9, 0xDDED9999),\n        ivec4(0xC9CC9999, 0xEEDD9C99, 0x999C9CC9, 0xDDDD9D99),\n        ivec4(0x999C9C99, 0xCCCCCC99, 0x9C9999AA, 0x99999999),\n        ivec4(0xB0FEFFDE, 0x1010000, 0xFEDDDDDC, 0x31),\n        ivec4(0xCEACBBCC, 0xFA, 0xAC78DCDD, 0x10FE),\n        ivec4(0x9DEADECD, 0xC0EF, 0xEEDECDCC, 0xF1DE),\n        ivec4(0xCDCCCCCC, 0x8C01CCA8, 0x9CCCCCCC, 0x89788C98),\n        ivec4(0x99C9CCCC, 0x89878D99, 0x99CCC999, 0x8CC89E99),\n        ivec4(0x99C9C999, 0xDDC99D88, 0x98999CC9, 0xDDDD9D89),\n        ivec4(0x99999C9C, 0xEEDDCD9C, 0xC9C99C9C, 0xDDDDCDCC),\n        ivec4(0x9C999999, 0xCCC99CC9, 0xCC9998A8, 0x99999999),\n        ivec4(0xC1EEEEDD, 0x1000000, 0xDFCCBCCC, 0x80),\n        ivec4(0x9E8BC7DD, 0xF6, 0xCE9BEDCD, 0xFC),\n        ivec4(0xDDEDCDCC, 0xB0DE, 0xC9CCCCCC, 0x400C089),\n        ivec4(0xC9C99CCC, 0x8C01C388, 0x9899C9C9, 0x8937DA88),\n        ivec4(0x8899CC99, 0x8977DC99, 0x88999C99, 0x8C87CD88),\n        ivec4(0x88989999, 0xDD99C989, 0x99C9999C, 0xCDDDCDCC),\n        ivec4(0xCCC99C9C, 0xEEDDDDCC, 0xCCC9999C, 0xCDDDCCCC),\n        ivec4(0xCC999999, 0x9CC99CC9, 0xCC9988A8, 0x98999999),\n        ivec4(0xD3DEDDCC, 0x1000000, 0xDFA978CC, 0x80),\n        ivec4(0xCF7AEBCE, 0xD0, 0xDDDDDECC, 0xEB),\n        ivec4(0xCACCCCCC, 0x308D, 0x98C9CC9C, 0x4007088),\n        ivec4(0x899A999C, 0x8C01D189, 0x9898CCC9, 0x8937E389),\n        ivec4(0x88989999, 0x8877D789, 0x88989999, 0x8C87C99C),\n        ivec4(0x9C99999C, 0xDD9999CC, 0x9CCC9CAC, 0xCDDD9CD9),\n        ivec4(0xCC9C9C9C, 0xEEDDDDC9, 0xDC999C99, 0xDCDDCCCC),\n        ivec4(0xDC999999, 0x99999C99, 0xDC9C8988, 0x98999999),\n        ivec4(0xE7CDCCCA, 0x1000000, 0xDFB987DD, 0x10),\n        ivec4(0xDE9CEDCD, 0xC0, 0xC9DDCCCC, 0xC7),\n        ivec4(0x9899CCC9, 0x8C, 0x889899C9, 0x100308D),\n        ivec4(0x889AC999, 0x7C01C08D, 0x889899C9, 0x8918C18C),\n        ivec4(0x8898999A, 0x7877839C, 0x9C9999C9, 0x7C8889C8),\n        ivec4(0xCC9CCC99, 0xDD8C99CC, 0xCDCC9CC9, 0xCDDD9CC9),\n        ivec4(0xCDCCC999, 0xDEDDDD99, 0xDC9C9999, 0xCCDDCC9C),\n        ivec4(0xECCC9999, 0x999999C9, 0xDCCD99A8, 0x98999999),\n        ivec4(0xE79DA9C9, 0x1000000, 0xEDBCC7DE, 0x0),\n        ivec4(0xDDDDDDCD, 0xA0, 0x98CCCCCC, 0x97),\n        ivec4(0x989AC999, 0x89, 0x8898C9CC, 0x400109E),\n        ivec4(0x88989999, 0x8900718E, 0x88989999, 0x8917719D),\n        ivec4(0x99999999, 0x787733D7, 0xCCCC9C9C, 0x89888993),\n        ivec4(0xCECC9C9C, 0xCD8C99CC, 0xCDCCCCC9, 0xCDDD8DC9),\n        ivec4(0xDDCC9C9C, 0xEDDDDD8C, 0xECCD999C, 0xCCDDCC9C),\n        ivec4(0xECCD9C99, 0x99999CC9, 0xECCE9CA9, 0x98989999),\n        ivec4(0xD3CEA9C9, 0x11000000, 0xFC8CC7DE, 0x0),\n        ivec4(0xCDDEDECD, 0xB0, 0x88CCCCCC, 0x91),\n        ivec4(0x98A8999C, 0x98, 0x8898CC9C, 0xCE),\n        ivec4(0x8898C999, 0x8C00309E, 0x8999999A, 0x891771DC),\n        ivec4(0x9CC9999C, 0x787713C1, 0xCDCCCC9C, 0x89888971),\n        ivec4(0xDECCCC9C, 0xDD8C9999, 0xDCCCCCC9, 0xCDDD9CC9),\n        ivec4(0xECCDC99C, 0xEDDDDD9C, 0xFCDDCC99, 0xCCDDCC9C),\n        ivec4(0xFCDECC99, 0x99999CCC, 0xECDECC99, 0x98999999),\n        ivec4(0xD3CEACDC, 0x11000000, 0xF9BCD7DE, 0x4000000),\n        ivec4(0xDDDEEECC, 0xB0, 0x98CCCCCC, 0x91),\n        ivec4(0x99999CCC, 0x98, 0x9898CC9C, 0xCE),\n        ivec4(0x8898C999, 0x7C00109E, 0x99999999, 0x891870D9),\n        ivec4(0xCCCCCC9C, 0x787713C1, 0xDDCCCC9C, 0x89888931),\n        ivec4(0xDDDCCCCC, 0xDD8C9989, 0xDCCDCCCC, 0xCDDD9DC9),\n        ivec4(0xFCCDCC9C, 0xEEDDDD9C, 0xFCDECC9C, 0xCCDDCC9D),\n        ivec4(0xFDDFCD9C, 0x99C99CCC, 0xECDECD99, 0x899999CC),\n        ivec4(0xE3CEACDD, 0x15000000, 0xEDBCE8DF, 0x4000000),\n        ivec4(0xEEDDEECC, 0xA0, 0xD8DCCCCC, 0x98),\n        ivec4(0x99C9CCCC, 0x89, 0x99C9CCCC, 0x10CE),\n        ivec4(0x88C9CC9C, 0x8C00709E, 0x999999AC, 0x890870DC),\n        ivec4(0xCCCCCCCC, 0x787733C3, 0xDDCCCC9C, 0x89888971),\n        ivec4(0xDDDDCCCC, 0xDD9C9989, 0xDCCDCCCC, 0xCDDD9CC9),\n        ivec4(0xEDCDCC9C, 0xEEDDDD9C, 0xFCDECC9C, 0xCCDDDC9D),\n        ivec4(0xFDDFCD9C, 0x99999CCC, 0xECDECD99, 0x8999999C),\n        ivec4(0xF8EEDDDE, 0x15010000, 0xCFB9FCCE, 0x4000080),\n        ivec4(0xDFECEFCD, 0xE2, 0xEEDECDCC, 0x30CD),\n        ivec4(0xCCDCDCCC, 0x9099, 0xC9CCCCCC, 0x400D19C),\n        ivec4(0x99DCCCCC, 0x8C01E79C, 0x99CCCCCC, 0x9918C19D),\n        ivec4(0xCCCCCCCC, 0x887783CD, 0xCDCCCCCC, 0x8C888C98),\n        ivec4(0xDEDDCDCC, 0xDD9CC9CC, 0xDDCDCCCC, 0xDDEDCDC9),\n        ivec4(0xEDCDCDCC, 0xEDDEDD9C, 0xFDDECCCC, 0xCCDDDDCD),\n        ivec4(0xFDDFCD9C, 0xC9C9CCCC, 0xECDECD9C, 0x9999C9C9),\n        ivec4(0xFEFFEEEE, 0x15111070, 0xDECDFECE, 0x440000F7),\n        ivec4(0xBCFCEFCC, 0x400410FE, 0xEDFFCECC, 0xA1EF),\n        ivec4(0xEEDEDDCD, 0xDCFD, 0xCDDDDCCC, 0x580C9CC),\n        ivec4(0xDCDCCDCD, 0x9D85CDCC, 0xCCCDCCCC, 0x99C8CDCC),\n        ivec4(0xCCCDDCCC, 0x8987CDCC, 0xDCCCCCCC, 0x8DC8DDCD),\n        ivec4(0xDDDDDDCC, 0xDDCDCCDD, 0xDDCDCCCC, 0xDEEECDDC),\n        ivec4(0xDDDDDDCC, 0xEEEEDDCD, 0xFDDDCCCC, 0xCCDDDDCD),\n        ivec4(0xFDDDCC9C, 0xCCCCCCCC, 0xFDDECCCC, 0x9999CCC9),\n        ivec4(0xFFFFEFDE, 0x551110A1, 0xFFEFEFDE, 0x440450FD),\n        ivec4(0xCCFDDECC, 0x4414D4DF, 0xFBFFCDCC, 0x4440F7AD),\n        ivec4(0xFFDEDCCC, 0x4070FEEE, 0xEEDDDCCC, 0x17E8FDEE),\n        ivec4(0xDDDDDDCD, 0xCD9CCDDD, 0xDDDDDCCC, 0x9CDDCCCC),\n        ivec4(0xCCCDCDCD, 0x99DDCCDC, 0xDCCCCDCC, 0x9DDDCCDC),\n        ivec4(0xCDCCDCCC, 0xEDDDCDCD, 0xCDCDCDCC, 0xDEEEDEDD),\n        ivec4(0xDDDDDCCC, 0xEEEEDDDD, 0xDDCCCCCC, 0xCCDDDDDD),\n        ivec4(0xDDCDCCCC, 0xCCCCCCDC, 0xEDCCCC99, 0x9999CCCC),\n        ivec4(0xFFFFEFDE, 0x551103C7, 0xFFFFEEDE, 0x440471FF),\n        ivec4(0xDDFEDECD, 0x404FBEE, 0xFBDFCCCC, 0x4414DFAC),\n        ivec4(0xFFDECDCC, 0x4B0DFCA, 0xEFCDCCCD, 0x57FCDFFE),\n        ivec4(0xDDDDDCCC, 0xEDDDEEEE, 0xCDCDDDCC, 0xCDDCDCCD),\n        ivec4(0xDDCDCDCD, 0xCCCCCCCD, 0xCDCCCCCC, 0xEECCCCDC),\n        ivec4(0xDDDCDCCC, 0xEECDDCCC, 0xCCDCCCCC, 0xEECDDCCC),\n        ivec4(0xCDCCCDCC, 0xEEDEDCCD, 0xCCDCCCCC, 0xDCDDDDCD),\n        ivec4(0xCCCCCCCC, 0xC9CCCCDC, 0xCDC9C999, 0x99C9C9CC),\n        ivec4(0xFFFFEEDE, 0x151111FC, 0xEFEEEECD, 0x4404D1FF),\n        ivec4(0xDAEFCDCC, 0x444FCDC, 0xFDDECCCC, 0x474CEBC),\n        ivec4(0xEFCDCDCC, 0x4E7CEFA, 0xDECDCDCC, 0xA7FEFEFF),\n        ivec4(0xCDCDDCCC, 0xDEDCDDDD, 0xCDCDDDCC, 0xCCDCDCCC),\n        ivec4(0xCDCDDCCC, 0xCDC9CCCD, 0xCCCCCCCC, 0xCFCCCCDC),\n        ivec4(0xDDCCCCCC, 0xDEC9CDDC, 0xCCCCCCCD, 0xDECCCCCC),\n        ivec4(0xDCCCCCCC, 0xEECDDCCC, 0xCCDC9C99, 0xDCCDDCCC),\n        ivec4(0xCCCCCC99, 0xC9CCCCCC, 0x9CC99C99, 0x9999C9CC),\n        ivec4(0xEFEDEECD, 0x550131FD, 0xACEECDCC, 0x4440E3DD),\n        ivec4(0xFBEFCCCC, 0x4444DC8C, 0xFFCDCCCC, 0x4B4DECB),\n        ivec4(0xDECCCCCC, 0x50EDEFFF, 0xCDCDCDCC, 0xDBDCDDCD),\n        ivec4(0xCCCDCCCC, 0x9CC9CCCC, 0xDCCCCCCC, 0xCC99C9CC),\n        ivec4(0xCCCCCDCC, 0xDD99C9CC, 0xCCCCCCCC, 0xDE9CCCCC),\n        ivec4(0x99CCCCCC, 0xDD9CCCCC, 0xC9CCCCCC, 0xEECDCCCC),\n        ivec4(0x9CCC9C9C, 0xDDDDCCCC, 0x9CCC9C9C, 0xCCCDCCCD),\n        ivec4(0x9C999C99, 0xC9CC99CC, 0x9C899999, 0x999999C9),\n        ivec4(0xCDECDDCC, 0x10131DD, 0xB8EECDC9, 0xD19D),\n        ivec4(0xF9DECCCC, 0x4400EBBC, 0xDFCDCCCC, 0xC2EFEE),\n        ivec4(0xCDCCCCCC, 0x50CCCDCD, 0xCCCCCCCC, 0x87C8C9CC),\n        ivec4(0xCCCCCCC9, 0xCCAC98C9, 0xCCCC9CCC, 0xD99C98CC),\n        ivec4(0x9C99CCCC, 0xC89C999C, 0x99999C9C, 0x9C9D999C),\n        ivec4(0x9CC9C9C9, 0xDDCDC9CC, 0xCCCC99C9, 0xDDDDCCCC),\n        ivec4(0xCCC9CC99, 0xDDDDCDCD, 0x9C9C9999, 0xCCCDCCCC),\n        ivec4(0x9C9999A9, 0x99CC9CCC, 0x9D898888, 0x89899999),\n        ivec4(0xCCDADE9C, 0x10000EA, 0x88EECDB9, 0x70CE),\n        ivec4(0xFADEC9CC, 0xE7CE, 0xDDCCCC9C, 0x94EDDD),\n        ivec4(0xCCCC9C9C, 0x8ACCCC, 0xCCC99999, 0x298889A),\n        ivec4(0xC9CC9C9C, 0x8C9D8899, 0x9C99C99C, 0x88CD9899),\n        ivec4(0x999899C9, 0x78C988C8, 0xC9999999, 0x79C99CC9),\n        ivec4(0xC9C99999, 0xDD9CCCCC, 0xCC9CC999, 0xCCDDCCCC),\n        ivec4(0xCCCC9999, 0xDEDDDCCC, 0xCC999999, 0xCCCDCCCC),\n        ivec4(0xCD999888, 0x9999999C, 0x9D898988, 0x88999999),\n        ivec4(0xCDCADEAC, 0x10000D7, 0x7AFDCDAA, 0xCD),\n        ivec4(0xECDE9C9C, 0xC7DF, 0xCDCC9C9C, 0x80D9DD),\n        ivec4(0xCCCC9C99, 0x909ACA, 0xC9C99999, 0xC18998),\n        ivec4(0x999CC999, 0x7CD88999, 0x9C989999, 0x88C88898),\n        ivec4(0x99889999, 0x38C79C98, 0xC99C9999, 0x7898CCC9),\n        ivec4(0xC99C9C99, 0x9D8899CC, 0xCC9C9C99, 0xDCDD99DC),\n        ivec4(0xCCCC9999, 0xDDDDCDC9, 0xCD999999, 0xDCCDCC9C),\n        ivec4(0xCD999988, 0x99999999, 0xCD998988, 0x88999999),\n        ivec4(0xCDC9DEAC, 0x10000C1, 0x8AEDCDA9, 0xD8),\n        ivec4(0xECDE9C99, 0xB4DE, 0xCDCC99A9, 0x30C9DD),\n        ivec4(0xC9C999A9, 0x70999A, 0xC9C99989, 0x908998),\n        ivec4(0x99999999, 0x7AD08C98, 0x99889999, 0x88878998),\n        ivec4(0x99889899, 0x38839C98, 0xC9999999, 0x7788C9CC),\n        ivec4(0xCCCC9998, 0x8C8899CC, 0xCCC99999, 0xDCCD89D9),\n        ivec4(0xCCCC9999, 0xDDDDCDC9, 0xCD9C9999, 0xDDCCCC8C),\n        ivec4(0xDD999988, 0x99CC998C, 0xDD998988, 0x88999899),\n        ivec4(0xDDDCDEAC, 0x1000070, 0x8CFCCDAA, 0xE1),\n        ivec4(0xECCE9C99, 0x70EE, 0xDCCCC9A9, 0xC9DE),\n        ivec4(0xA99C9989, 0x509999, 0xC99C9998, 0x708C98),\n        ivec4(0x99999999, 0x18808D98, 0x89889999, 0x88138D98),\n        ivec4(0x99889999, 0x7833C999, 0xCC999999, 0x7787C8CC),\n        ivec4(0xCCCC9999, 0x898899C9, 0xCD9C9999, 0xDC9D98C9),\n        ivec4(0xDCCC9C99, 0xCDDD9D99, 0xDD9C9999, 0xDDDDCC9C),\n        ivec4(0xDDCC9989, 0x99CCC989, 0xDDCD8988, 0x98999899),\n        ivec4(0xDDDDDFAC, 0x1000050, 0xBCFC9DA9, 0xD1),\n        ivec4(0xDCCE9C99, 0x70ED, 0xCDCC9CA9, 0xC8DD),\n        ivec4(0x9C9C9989, 0xC99A, 0xC99C9989, 0x109D98),\n        ivec4(0x99999999, 0x17309D99, 0x8988999C, 0x8803CC88),\n        ivec4(0x99999999, 0x7837C79C, 0xCC999999, 0x778788CC),\n        ivec4(0xCDCC9999, 0x88889988, 0xCDCCC999, 0xDD9C98C9),\n        ivec4(0xDCCCC999, 0xCCDD9D99, 0xEC9D9C99, 0xDDDDCC9C),\n        ivec4(0xECCD9999, 0xC9CC999C, 0xECCE9C89, 0x98999999),\n        ivec4(0xECEEEE9C, 0x10000010, 0xADFDCDAA, 0xC1),\n        ivec4(0xDCDE9999, 0x40EC, 0xDECCC9A9, 0xC7DE),\n        ivec4(0x9C9C9989, 0xCCCC, 0x999C9999, 0x9D98),\n        ivec4(0x99C99999, 0x7109DC9, 0x8988999C, 0x8807CC88),\n        ivec4(0x9C999999, 0x7817C79C, 0xCC999999, 0x778787CC),\n        ivec4(0xCDCC9C99, 0x88989C88, 0xCDCC9C9C, 0xDD999899),\n        ivec4(0xDCCC9C9C, 0xDCDD9CC9, 0xECCD9C9C, 0xDDDDDD99),\n        ivec4(0xECCD9C99, 0xCCCCC99C, 0xFCDE9C99, 0x98999999),\n        ivec4(0xFCEEEFCC, 0x11010110, 0xCDFDCE99, 0x40000C0),\n        ivec4(0xCCDE9C99, 0x10EB, 0xDECD9CA9, 0xD7EF),\n        ivec4(0xCCCC9C99, 0xCCCC, 0xCC9C9999, 0x9DC9),\n        ivec4(0xC9CCCC9C, 0x770CEC9, 0x89989C9C, 0x8907CC99),\n        ivec4(0x9C999C9C, 0x8817C89C, 0xCCCCC999, 0x388787CC),\n        ivec4(0xCDCCCC9C, 0x78989C88, 0xDDCC9C99, 0xDD9C999C),\n        ivec4(0xDCCCCC9C, 0xDCDD9C99, 0xFCCDCC99, 0xDEDDDD99),\n        ivec4(0xFCDD9C9C, 0xCCCDCC9C, 0xECDE9C99, 0x9899999C),\n        ivec4(0xFEFEEECD, 0x11110030, 0xDDFECDA9, 0x40000E3),\n        ivec4(0xEACE9999, 0x40000DD, 0xEECCCC99, 0xE7EF),\n        ivec4(0xCCCC9C99, 0x70DCDD, 0xCC9C9999, 0x80CCC9),\n        ivec4(0xC9CCCC9C, 0x7C0CC99, 0x99C99C9C, 0xA9879DC9),\n        ivec4(0x9999CC9C, 0x8877CDC9, 0xC99C9C9C, 0x7887C8DC),\n        ivec4(0xCDCC9C9C, 0x7898CCC9, 0xCDCCCC9C, 0xDD9C99CC),\n        ivec4(0xDDCCCC9C, 0xDCDD9CC9, 0xDDCDCC99, 0xDEDDDD99),\n        ivec4(0xFCCDCC99, 0xCCCDCC9C, 0xFCDE9C99, 0x9899999C),\n        ivec4(0xFEFFEFCD, 0x15111091, 0xEEEFCCCC, 0x460010EA),\n        ivec4(0xFDCE9C99, 0x4004B0CE, 0xEFCC9C9C, 0x4EADE),\n        ivec4(0xCDCC9C9C, 0xC5EEDE, 0xCCCCC999, 0xD7CDCC),\n        ivec4(0xCCCCCCCC, 0x3BD7CCCC, 0xCCCCCC9C, 0x99DCCCCC),\n        ivec4(0x99C9C9CC, 0x89D89C9C, 0xC9CCCC9C, 0x78C8CDCD),\n        ivec4(0xCCCCCC9C, 0x8998CDDC, 0xCDCCCC9C, 0xDD9DC9DC),\n        ivec4(0xDDCCCCCC, 0xDCEECDCC, 0xDDCCCC9C, 0xEEDDDD9C),\n        ivec4(0xEDCD9C9C, 0xDCCDCC9C, 0xEDCD9C99, 0x99C999CC),\n        ivec4(0xFFFFDECD, 0x151101E8, 0xFEDECCCC, 0x40080EF),\n        ivec4(0xFFCCC9CC, 0x4441E7DD, 0xCECCCC99, 0x450DEFD),\n        ivec4(0xCC9C9C9C, 0x60FAEFDE, 0xCCCC9C9C, 0x80ECCDCC),\n        ivec4(0xCC9CCCCC, 0xAACDCCCC, 0xCCCCCC9C, 0xD9CDC9CC),\n        ivec4(0x99CCCCCC, 0x99CDCC9C, 0xCCCCCC9C, 0x88DCCC99),\n        ivec4(0xCCCCCC9C, 0x8CCCCDCC, 0xCCCCCCC9, 0xEDCDCCDC),\n        ivec4(0xCDCCCC9C, 0xDDEDCDDC, 0xCDCCCC9C, 0xDEDDDDCC),\n        ivec4(0xDDCC9C9C, 0xCCCDCC9C, 0xDD9C9999, 0x99C999CC),\n        ivec4(0xFFEFDEAC, 0x151171FC, 0xFFDDDDCC, 0x4404E7FF),\n        ivec4(0xDE9CCCCD, 0x4462DEFD, 0xCDC9CCCC, 0x4C5CEEF),\n        ivec4(0xCCCC9C9C, 0x74FEFECE, 0xCC9C9C9C, 0xDADEDDCC),\n        ivec4(0xCCCC9CCC, 0xDDCDCCCC, 0xCC9CCCCC, 0xDDC9CCCC),\n        ivec4(0xC9CCCCCC, 0xDDCCCCCC, 0xCCCCCC9C, 0xD9CC9999),\n        ivec4(0xCCCCCC9C, 0xDDCDCCCC, 0xCCCC9C9C, 0xEDDECCCC),\n        ivec4(0xCCCCCC9C, 0xDDEDCDCD, 0xCCCC9999, 0xEDDDDDDD),\n        ivec4(0xCCCCC999, 0xCCCCCCCC, 0xCD999999, 0x99C999CC),\n        ivec4(0xFFEFCD9A, 0x151183FE, 0xEFDECDCC, 0x4610FCFF),\n        ivec4(0xCDCCCDCD, 0x44B4DEFE, 0xCC99CCCC, 0x14D7ECDF),\n        ivec4(0xCCC9CC9C, 0xB4EEEECD, 0xCCC99C9C, 0xEDEECECC),\n        ivec4(0xCC9CCCCC, 0xDDCDCCCC, 0x9CCCCC9C, 0xCCCCCCCC),\n        ivec4(0xCCCCCCCC, 0xCC9CCCC9, 0xCCCCCCC9, 0xCD999CC9),\n        ivec4(0x9CCCCC9C, 0xDE9C9999, 0xCCCC9C9C, 0xDDCCCC9C),\n        ivec4(0xC9C9CC9C, 0xDEDDCDCC, 0xCCC99999, 0xDDDDDCCC),\n        ivec4(0xC9999999, 0xCCCCC9CC, 0x99999998, 0x999999C9)\n);\n\n#endif\n\nvoid mainImage(out vec4 fragmentColor, in vec2 fragmentCoordinates)\n{\n    float minimal_side_resolution = min(iResolution.x, iResolution.y);\n    vec2 image_position = vec2((fragmentCoordinates.x - ((iResolution.x - minimal_side_resolution) * 0.5)) * float(imageWidth) / minimal_side_resolution, (fragmentCoordinates.y - ((iResolution.y - minimal_side_resolution) * 0.5)) * float(imageHeight) / minimal_side_resolution);\n    int x = int(floor(image_position.x));\n    int y = int(floor(image_position.y));\n    vec3 color;\n    if ((x >= 0) && (x < imageWidth) && (y >= 0) && (y < imageHeight))\n    {\n        int image_index = int(iTime * playbackSpeed / 0.075) % imageCount;\n        int index = x + ((imageHeight - 1 - y) * imageWidth) + ((imageWidth * imageHeight) * image_index);\n        color = bitmapPalette[(bitmapBits[index / (4 * indicesPerBitmapBitsElement)][(index / indicesPerBitmapBitsElement) % 4] >> (((((index % 2) == 0) ? (index + 1) : (index - 1)) % indicesPerBitmapBitsElement) * 4)) & 0xF];\n    }\n    else if (((x < 0) && (x >= -primaryBorderSize)) || ((x >= imageWidth) && (x < (imageWidth + primaryBorderSize))) || ((y < 0) && (y >= -primaryBorderSize)) || ((y >= imageHeight) && (y < (imageHeight + primaryBorderSize))))\n    {\n        color = bitmapPalette[primaryBorderColorIndex];\n    }\n    else if ((x == -(primaryBorderSize + 1)) || (x == (imageWidth + primaryBorderSize)) || (y == -(primaryBorderSize + 1)) || (y == (imageHeight + primaryBorderSize)))\n    {\n        color = bitmapPalette[secondaryBorderColorIndex];\n    }\n    else\n    {\n        float time = iTime * playbackSpeed / 0.6;\n        int palette_entry_index = int(time);\n        color = mix(bitmapPalette[palette_entry_index % bitmapPalette.length()], bitmapPalette[(palette_entry_index + 1) % bitmapPalette.length()], pow(fract(time), 0.25));        \n#ifdef ENABLE_VIBING_CAT\n        image_position = fragmentCoordinates * ((vec2(vibingCatImageWidth + vibingCatBorderWidth, vibingCatImageHeight + vibingCatBorderHeight) * 5.0) + vec2(vibingCatBorderWidth, vibingCatBorderHeight)) / minimal_side_resolution;\n        x = (int(floor(image_position.x)) % (vibingCatImageWidth + vibingCatBorderWidth)) - vibingCatBorderWidth;\n        y = (int(floor(image_position.y)) % (vibingCatImageHeight + vibingCatBorderHeight)) - vibingCatBorderHeight;\n        if ((x >= 0) && (x < vibingCatImageWidth) && (y >= 0) && (y < vibingCatImageHeight))\n        {\n            int animation_frame_index = int(floor(iTime * 30.0));\n            int image_index = 0;\n            if (animation_frame_index < vibingCatAnimationFrameCount)\n            {\n                image_index = (animation_frame_index < vibingCatImageCount) ? animation_frame_index : ((vibingCatImageCount + vibingCatImageCount) - animation_frame_index - 1);\n            }\n            else\n            {\n                image_index = (animation_frame_index - vibingCatAnimationFrameCount) % (vibingCatRepeatingFrameCount * 2);\n                image_index = ((image_index < vibingCatRepeatingFrameCount) ? image_index : ((vibingCatRepeatingFrameCount + vibingCatRepeatingFrameCount) - image_index - 1)) + vibingCatRepeatAtImageIndex;\n                \n            }\n            int index = x + ((vibingCatImageHeight - 1 - y) * vibingCatImageWidth) + ((vibingCatImageWidth * vibingCatImageHeight) * image_index);\n            color *= vibingCatBitmapPalette[(vibingCatBitmapBits[index / (4 * indicesPerBitmapBitsElement)][(index / indicesPerBitmapBitsElement) % 4] >> (((((index % 2) == 0) ? (index + 1) : (index - 1)) % indicesPerBitmapBitsElement) * 4)) & 0xF];\n        }\n        else\n        {\n            color *= vibingCatBitmapPalette[vibingCatBorderColorIndex];\n        }\n#endif\n    }\n    fragmentColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "sound_code": "// Ivean Polkka\n\nstruct Instrument\n{\n    uint waveType;\n    float waveRatio;\n    float attackTime;\n    float amplitude;\n    float decayTime;\n    float sustainAmplitude;\n    float releaseTime;\n    float leftRight;\n};\n\nstruct Note\n{\n    float playAtTime;\n    uint instrumentIndex;\n    float frequency;\n    float duration;\n    float velocity;\n};\n\nconst float volume = 0.75;\n\nconst float pitch = 1.0;\n\nconst float repeatMusicTime = 19.2;\n\nconst uint repeatMusic = 8U;\n\nconst float musicPlayTime = repeatMusicTime * float(repeatMusic);\n\nconst uint antiAliasing = 2U;\n\nconst float halfPi = 1.57079632679;\n\nconst float pi = 3.14159265359;\n\nconst float doublePi = 6.28318530718;\n\nconst uint squareWaveType = 0U;\n\nconst uint triangleWaveType = 1U;\n\nconst uint sineWaveType = 2U;\n\nconst uint whiteNoiseWaveType = 3U;\n\nconst Instrument[] instruments = Instrument[]\n(\n    //         Wave type           Wave ratio   Attack time    Amplitude    Decay time     Sustain amplitude   Release time   Left/Right\n    \n    // Piano\n    Instrument(triangleWaveType,   0.3125,      0.001953125,   0.21875,     0.0009765625,  0.125,              0.75,          0.5),\n    \n    // Piano\n    Instrument(sineWaveType,       0.25,        0.001953125,   0.013671875, 0.0009765625,  0.0078125,          0.75,          0.5),\n    \n    // Bass \n    Instrument(triangleWaveType,   0.0625,      0.00390625,    0.125,       0.00390625,    0.0625,             0.75,          0.5),\n    \n    // Left bell\n    Instrument(triangleWaveType,   0.125,       0.001953125,   0.046875,    0.001953125,   0.0234375,          0.75,          0.125),\n    \n    // Right bell\n    Instrument(triangleWaveType,   0.125,       0.001953125,   0.046875,    0.001953125,   0.0234375,          0.75,          0.875),\n    \n    // Primary drum\n    Instrument(sineWaveType,       1.0,         0.00048828125, 0.25,        0.00048828125, 0.1875,             0.75,          0.5),\n    \n    // Secondary drum\n    Instrument(triangleWaveType,   0.5,         0.0009765625,  0.375,       0.00048828125, 0.0625,             0.75,          0.5),\n    \n    // Left snare\n    Instrument(whiteNoiseWaveType, 1.0,         0.001953125,   0.0625,      0.001953125,   0.03125,            0.75,          0.25),\n    \n    // Right snare\n    Instrument(whiteNoiseWaveType, 1.0,         0.001953125,   0.0625,      0.001953125,   0.03125,            0.75,          0.75)\n    \n);\n\nconst uint primaryPianoInstrumentIndex = 0U;\n\nconst uint secondaryPianoInstrumentIndex = 1U;\n\nconst uint bassInstrumentIndex = 2U;\n\nconst uint leftBellInstrumentIndex = 3U;\n\nconst uint rightBellInstrumentIndex = 4U;\n\nconst uint primaryDrumInstrumentIndex = 5U;\n\nconst uint secondaryDrumInstrumentIndex = 6U;\n\nconst uint leftSnareInstrumentIndex = 7U;\n\nconst uint rightSnareInstrumentIndex = 8U;\n\nconst float c1 = 32.70319566257483;\n\nconst float cS1 = 34.64782887210902;\n\nconst float d1 = 36.70809598967594;\n\nconst float dS1 = 38.89087296526011;\n\nconst float e1 = 41.20344461410874;\n\nconst float f1 = 43.653528929125486;\n\nconst float fS1 = 46.24930283895431;\n\nconst float g1 = 48.999429497718666;\n\nconst float gS1 = 51.91308719749314;\n\nconst float a1 = 55.0;\n\nconst float aS1 = 58.27047018976124;\n\nconst float b1 = 61.7354126570155;\n\nconst float c2 = 65.40639132514966;\n\nconst float cS2 = 69.29565774421803;\n\nconst float d2 = 73.41619197935188;\n\nconst float dS2 = 77.78174593052022;\n\nconst float e2 = 82.40688922821748;\n\nconst float f2 = 87.30705785825097;\n\nconst float fS2 = 92.49860567790861;\n\nconst float g2 = 97.99885899543733;\n\nconst float gS2 = 103.82617439498628;\n\nconst float a2 = 110.0;\n\nconst float aS2 = 116.54094037952248;\n\nconst float b2 = 123.47082531403103;\n\nconst float c3 = 130.8127826502993;\n\nconst float cS3 = 138.59131548843604;\n\nconst float d3 = 146.8323839587038;\n\nconst float dS3 = 155.56349186104043;\n\nconst float e3 = 164.81377845643496;\n\nconst float f3 = 174.61411571650194;\n\nconst float fS3 = 184.99721135581723;\n\nconst float g3 = 195.99771799087463;\n\nconst float gS3 = 207.65234878997256;\n\nconst float a3 = 220.0;\n\nconst float aS3 = 233.08188075904496;\n\nconst float b3 = 246.94165062806206;\n\nconst float c4 = 261.6255653005986;\n\nconst float cS4 = 277.1826309768721;\n\nconst float d4 = 293.6647679174076;\n\nconst float dS4 = 311.12698372208087;\n\nconst float e4 = 329.6275569128699;\n\nconst float f4 = 349.2282314330039;\n\nconst float fS4 = 369.99442271163446;\n\nconst float g4 = 391.99543598174927;\n\nconst float gS4 = 415.3046975799451;\n\nconst float a4 = 440.0;\n\nconst float aS4 = 466.1637615180899;\n\nconst float b4 = 493.8833012561241;\n\nconst float c5 = 523.2511306011972;\n\nconst float cS5 = 554.3652619537442;\n\nconst float d5 = 587.3295358348151;\n\nconst float dS5 = 622.2539674441618;\n\nconst float e5 = 659.2551138257398;\n\nconst float f5 = 698.4564628660078;\n\nconst float fS5 = 739.9888454232689;\n\nconst float g5 = 783.9908719634986;\n\nconst float gS5 = 830.6093951598903;\n\nconst float a5 = 880.0;\n\nconst float aS5 = 932.3275230361799;\n\nconst float b5 = 987.7666025122483;\n\nconst Note[] notes = Note[]\n(\n    // Piano (primary)\n    Note(0.0 + 0.0,   primaryPianoInstrumentIndex, aS3, 0.3 - 0.125, 1.0),\n    Note(0.0 + 0.3,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 0.6,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 0.9,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.05,  primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(0.0 + 1.2,   primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.5,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.8,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 2.1,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 1.0),\n    Note(0.0 + 2.25,  primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 2.4,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(0.0 + 2.7,   primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.0,   primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.3,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 1.0),\n    Note(0.0 + 3.6,   primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.9,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 4.2,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    Note(4.8 + 0.0,   primaryPianoInstrumentIndex, aS3, 0.3 - 0.125, 1.0),\n    Note(4.8 + 0.3,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 0.6,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 0.9,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.05,  primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(4.8 + 1.2,   primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.5,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.8,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.1,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 1.0),\n    Note(4.8 + 2.25,  primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.4,   primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.7,   primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 3.0,   primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 3.3,   primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 1.0),\n    Note(4.8 + 3.6,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(4.8 + 3.9,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 4.2,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    Note(9.6 + 0.0,   primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 1.0),\n    Note(9.6 + 0.15,  primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.3,   primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.6,   primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.9,   primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.2,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(9.6 + 1.5,   primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.65,  primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.95,  primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.1,   primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.4,   primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 1.0),\n    Note(9.6 + 2.55,  primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.7,   primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.0,   primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.3,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(9.6 + 3.6,   primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.9,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(9.6 + 4.05,  primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    Note(14.4 + 0.0,  primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 1.0),\n    Note(14.4 + 0.15, primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.3,  primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.6,  primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.9,  primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.2,  primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(14.4 + 1.5,  primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.65, primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.95, primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.1,  primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.4,  primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 1.0),\n    Note(14.4 + 2.55, primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.7,  primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.0,  primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.3,  primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(14.4 + 3.6,  primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.9,  primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(14.4 + 4.05, primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    // Piano (secondary)\n    Note(0.0 + 0.0,   secondaryPianoInstrumentIndex, aS3, 0.3 - 0.125, 1.0),\n    Note(0.0 + 0.3,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 0.6,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 0.9,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.05,  secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(0.0 + 1.2,   secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.5,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.8,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 2.1,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 1.0),\n    Note(0.0 + 2.25,  secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 2.4,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(0.0 + 2.7,   secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.0,   secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.3,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 1.0),\n    Note(0.0 + 3.6,   secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.9,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 4.2,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    Note(4.8 + 0.0,   secondaryPianoInstrumentIndex, aS3, 0.3 - 0.125, 1.0),\n    Note(4.8 + 0.3,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 0.6,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 0.9,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.05,  secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(4.8 + 1.2,   secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.5,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.8,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.1,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 1.0),\n    Note(4.8 + 2.25,  secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.4,   secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.7,   secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 3.0,   secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 3.3,   secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 1.0),\n    Note(4.8 + 3.6,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(4.8 + 3.9,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 4.2,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    Note(9.6 + 0.0,   secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 1.0),\n    Note(9.6 + 0.15,  secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.3,   secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.6,   secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.9,   secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.2,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(9.6 + 1.5,   secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.65,  secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.95,  secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.1,   secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.4,   secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 1.0),\n    Note(9.6 + 2.55,  secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.7,   secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.0,   secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.3,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(9.6 + 3.6,   secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.9,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(9.6 + 4.05,  secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    Note(14.4 + 0.0,  secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 1.0),\n    Note(14.4 + 0.15, secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.3,  secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.6,  secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.9,  secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.2,  secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(14.4 + 1.5,  secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.65, secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.95, secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.1,  secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.4,  secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 1.0),\n    Note(14.4 + 2.55, secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.7,  secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.0,  secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.3,  secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(14.4 + 3.6,  secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.9,  secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(14.4 + 4.05, secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    // Bass\n    Note(0.0 + 0.0,   bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(0.0 + 0.3,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 0.45,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 0.6,   bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(0.0 + 0.9,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.2,   bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(0.0 + 1.5,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.65,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.8,   bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(0.0 + 2.1,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 2.4,   bassInstrumentIndex, cS2, 0.3 - 0.125, 1.0),\n    Note(0.0 + 2.7,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 2.85,  bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.0,   bassInstrumentIndex, cS2, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.3,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.6,   bassInstrumentIndex, cS2, 0.3 - 0.125, 1.0),\n    Note(0.0 + 3.9,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 4.05,  bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 4.2,   bassInstrumentIndex, cS2, 0.3 - 0.125, 0.75),\n    Note(0.0 + 4.5,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n     \n    Note(4.8 + 0.0,   bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(4.8 + 0.3,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 0.45,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 0.6,   bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(4.8 + 0.9,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.2,   bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(4.8 + 1.5,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.65,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.8,   bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.1,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.4,   bassInstrumentIndex, fS2, 0.3 - 0.125, 1.0),\n    Note(4.8 + 2.7,   bassInstrumentIndex, fS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.85,  bassInstrumentIndex, fS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 3.0,   bassInstrumentIndex, fS2, 0.3 - 0.125, 0.75),\n    Note(4.8 + 3.3,   bassInstrumentIndex, fS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 3.6,   bassInstrumentIndex, f2,  0.3 - 0.125, 1.0),\n    Note(4.8 + 3.9,   bassInstrumentIndex, f3,  0.3 - 0.125, 0.75),\n    Note(4.8 + 4.05,  bassInstrumentIndex, f3,  0.3 - 0.125, 0.75),\n    Note(4.8 + 4.2,   bassInstrumentIndex, f2,  0.3 - 0.125, 0.75),\n    Note(4.8 + 4.5,   bassInstrumentIndex, f3,  0.3 - 0.125, 0.75),\n     \n    Note(9.6 + 0.0,   bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(9.6 + 0.3,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.45,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.6,   bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.9,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.2,   bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(9.6 + 1.5,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.65,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.8,   bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.1,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.4,   bassInstrumentIndex, cS2, 0.3 - 0.125, 1.0),\n    Note(9.6 + 2.7,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.85,  bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.0,   bassInstrumentIndex, cS2, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.3,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.6,   bassInstrumentIndex, cS2, 0.3 - 0.125, 1.0),\n    Note(9.6 + 3.9,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 4.05,  bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 4.2,   bassInstrumentIndex, cS2, 0.3 - 0.125, 0.75),\n    Note(9.6 + 4.5,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    \n    Note(14.4 + 0.0,  bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(14.4 + 0.3,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.45, bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.6,  bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.9,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.2,  bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(14.4 + 1.5,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.65, bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.8,  bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.1,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.4,  bassInstrumentIndex, fS2, 0.3 - 0.125, 1.0),\n    Note(14.4 + 2.7,  bassInstrumentIndex, fS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.85, bassInstrumentIndex, fS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.0,  bassInstrumentIndex, fS2, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.3,  bassInstrumentIndex, fS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.6,  bassInstrumentIndex, f2,  0.3 - 0.125, 1.0),\n    Note(14.4 + 3.9,  bassInstrumentIndex, f3,  0.3 - 0.125, 0.75),\n    Note(14.4 + 4.05, bassInstrumentIndex, f3,  0.3 - 0.125, 0.75),\n    Note(14.4 + 4.2,  bassInstrumentIndex, f2,  0.3 - 0.125, 0.75),\n    Note(14.4 + 4.5,  bassInstrumentIndex, f3,  0.3 - 0.125, 0.75),\n    \n    // Bell\n    Note(0.0 + 0.0,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(0.0 + 0.3,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 0.45,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 0.6,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(0.0 + 0.9,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 1.2,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(0.0 + 1.5,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 1.65,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 1.8,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(0.0 + 2.1,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 2.4,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(0.0 + 2.7,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 2.85,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 3.0,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(0.0 + 3.3,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 3.6,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(0.0 + 3.9,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 4.05,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 4.2,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(0.0 + 4.5,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n     \n    Note(4.8 + 0.0,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(4.8 + 0.3,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 0.45,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 0.6,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(4.8 + 0.9,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 1.2,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(4.8 + 1.5,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 1.65,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 1.8,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(4.8 + 2.1,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 2.4,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(4.8 + 2.7,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 2.85,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 3.0,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(4.8 + 3.3,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 3.6,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(4.8 + 3.9,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 4.05,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 4.2,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(4.8 + 4.5,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n     \n    Note(9.6 + 0.0,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(9.6 + 0.3,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 0.45,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 0.6,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(9.6 + 0.9,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 1.2,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(9.6 + 1.5,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 1.65,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 1.8,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(9.6 + 2.1,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 2.4,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(9.6 + 2.7,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 2.85,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 3.0,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(9.6 + 3.3,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 3.6,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(9.6 + 3.9,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 4.05,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 4.2,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(9.6 + 4.5,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    \n    Note(14.4 + 0.0,  rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(14.4 + 0.3,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 0.45, leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 0.6,  rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(14.4 + 0.9,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 1.2,  rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(14.4 + 1.5,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 1.65, leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 1.8,  rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(14.4 + 2.1,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 2.4,  rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(14.4 + 2.7,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 2.85, leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 3.0,  rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(14.4 + 3.3,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 3.6,  rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(14.4 + 3.9,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 4.05, leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 4.2,  rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(14.4 + 4.5,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    \n    // Primary drum\n    Note(0.0 + 0.0,   primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(0.0 + 0.6,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 1.2,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 1.8,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 2.4,   primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(0.0 + 3.0,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 3.6,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 4.2,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(4.8 + 0.0,   primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(4.8 + 0.6,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 1.2,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 1.8,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 2.4,   primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(4.8 + 3.0,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 3.6,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 4.2,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(9.6 + 0.0,   primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(9.6 + 0.6,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 1.2,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 1.8,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 2.4,   primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(9.6 + 3.0,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 3.6,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 4.2,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(14.4 + 0.0,  primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(14.4 + 0.6,  primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 1.2,  primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 1.8,  primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 2.4,  primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(14.4 + 3.0,  primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 3.6,  primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 4.2,  primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    // Secondary drum\n    Note(0.0 + 0.0,   secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(0.0 + 0.6,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 1.2,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 1.8,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 2.4,   secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(0.0 + 3.0,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 3.6,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 4.2,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(4.8 + 0.0,   secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(4.8 + 0.6,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 1.2,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 1.8,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 2.4,   secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(4.8 + 3.0,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 3.6,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 4.2,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(9.6 + 0.0,   secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(9.6 + 0.6,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 1.2,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 1.8,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 2.4,   secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(9.6 + 3.0,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 3.6,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 4.2,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(14.4 + 0.0,  secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(14.4 + 0.6,  secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 1.2,  secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 1.8,  secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 2.4,  secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(14.4 + 3.0,  secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 3.6,  secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 4.2,  secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    // Snare\n    Note(0.3 + 0.0,   leftSnareInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(0.3 + 0.6,   rightSnareInstrumentIndex, dS1, 0.125, 0.75),\n    Note(0.3 + 1.2,   leftSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.3 + 1.8,   rightSnareInstrumentIndex, dS1, 0.125, 0.75),\n    Note(0.3 + 2.4,   leftSnareInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(0.3 + 3.0,   rightSnareInstrumentIndex, dS1, 0.125, 0.75),\n    Note(0.3 + 3.6,   leftSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.3 + 4.2,   rightSnareInstrumentIndex, dS1, 0.125, 0.75),\n    \n    Note(5.1 + 0.0,   leftSnareInstrumentIndex,   dS1, 0.125, 1.0),\n    Note(5.1 + 0.6,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(5.1 + 1.2,   leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(5.1 + 1.8,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(5.1 + 2.4,   leftSnareInstrumentIndex,   dS1, 0.125, 1.0),\n    Note(5.1 + 3.0,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(5.1 + 3.6,   leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(5.1 + 3.75,  rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(5.1 + 4.05,  leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(5.1 + 4.2,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(9.9 + 0.0,   leftSnareInstrumentIndex,   dS1, 0.125, 1.0),\n    Note(9.9 + 0.6,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.9 + 1.2,   leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(9.9 + 1.8,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.9 + 2.4,   leftSnareInstrumentIndex,   dS1, 0.125, 1.0),\n    Note(9.9 + 3.0,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.9 + 3.6,   leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(9.9 + 4.2,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(14.7 + 0.0,  leftSnareInstrumentIndex,   dS1, 0.125, 1.0),\n    Note(14.7 + 0.6,  rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.7 + 1.2,  leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(14.7 + 1.8,  rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.7 + 2.4,  leftSnareInstrumentIndex,   dS1, 0.125, 1.0),\n    Note(14.7 + 3.0,  rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.7 + 3.6,  leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(14.7 + 3.75, rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.7 + 4.05, leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(14.7 + 4.2,  rightSnareInstrumentIndex,  dS1, 0.125, 0.75)\n);\n\nvec2 PlayNotes(const in float time)\n{\n    vec2 ret = vec2(0.0);\n    Note note;\n    Instrument instrument;\n    float sustain_time;\n    float duration;\n    float play_at_time;\n    float relative_time;\n    float scaled_relative_time;\n    float volume;\n    vec2 note_volume;\n    float beats_per_second;\n    float normalized_wave_time;\n    for (int note_index = 0; note_index < notes.length(); note_index++)\n    {\n        note = notes[note_index];\n        instrument = instruments[note.instrumentIndex];\n        sustain_time = max(note.duration - instrument.attackTime - instrument.decayTime, 0.0);\n        duration = (instrument.attackTime + instrument.decayTime + sustain_time + instrument.releaseTime) / playbackSpeed;\n        play_at_time = note.playAtTime / playbackSpeed;\n        relative_time = time - play_at_time;\n        scaled_relative_time = relative_time * playbackSpeed;\n        if ((time >= play_at_time) && ((time - duration) < play_at_time))\n        {\n            switch (instrument.waveType)\n            {\n            case squareWaveType:\n                beats_per_second = 1.0 / note.frequency;\n                normalized_wave_time = mod(relative_time * pitch, beats_per_second) / beats_per_second;\n                volume = (normalized_wave_time > instrument.waveRatio) ? -1.0 : 1.0;\n                break;\n            case triangleWaveType:\n                volume = 1.0;\n                beats_per_second = 1.0 / note.frequency;\n                normalized_wave_time = mod(relative_time * pitch, beats_per_second) / beats_per_second;\n                if (normalized_wave_time < instrument.waveRatio)\n                {\n                    volume = (clamp(normalized_wave_time / instrument.waveRatio, 0.0, 1.0) * 2.0) - 1.0;\n                }\n                else if (normalized_wave_time > instrument.waveRatio)\n                {\n                    volume = 1.0 - (clamp((normalized_wave_time - instrument.waveRatio) / (1.0 - instrument.waveRatio), 0.0, 1.0) * 2.0);\n                }\n                break;\n            case sineWaveType:\n                volume = sin(relative_time * pitch * doublePi * note.frequency);\n                break;\n            case whiteNoiseWaveType:\n                volume = (fract(sin(relative_time * pitch * 12865.9898) * 43758.5453) * 2.0) - 1.0;\n                break;\n            }\n            note_volume = vec2((instrument.leftRight > 0.5) ? cos((instrument.leftRight - 0.5) * pi) : 1.0, (instrument.leftRight < 0.5) ? cos((0.5 - instrument.leftRight) * pi) : 1.0) * volume * note.velocity;\n            if (scaled_relative_time < instrument.attackTime)\n            {\n                note_volume *= (scaled_relative_time / instrument.attackTime) * instrument.amplitude;\n            }\n            else if (scaled_relative_time < (instrument.attackTime + instrument.decayTime))\n            {\n                note_volume *= mix(instrument.amplitude, instrument.sustainAmplitude, (scaled_relative_time - instrument.attackTime) / instrument.decayTime);\n            }\n            else if (scaled_relative_time < (instrument.attackTime + instrument.decayTime + sustain_time))\n            {\n                note_volume *= instrument.sustainAmplitude;\n            }\n            else\n            {\n                note_volume *= mix(0.0, instrument.sustainAmplitude, exp((-(scaled_relative_time - instrument.attackTime - instrument.decayTime - sustain_time) * doublePi) / instrument.releaseTime));\n            }\n            ret += note_volume;\n        }\n    }\n    return ret;\n}\n\nvec2 mainSound(in int samp, float time)\n{\n    if (time >= musicPlayTime)\n    {\n        return vec2(0.0);\n    }\n    vec2 current_volume = vec2(0.0);\n    for (uint anti_aliasing_index = 0U; anti_aliasing_index != antiAliasing; anti_aliasing_index++)\n    {\n        float current_time = time - float(anti_aliasing_index) / (iSampleRate * float(antiAliasing));\n        current_volume += (current_time < 0.0) ? vec2(0.0, 0.0) : PlayNotes(mod(current_time, repeatMusicTime / playbackSpeed));\n    }\n    return current_volume * volume / float(antiAliasing);\n}\n", "sound_inputs": [], "common_code": "// User settings\n\n// Low-resolution mode is less taxing on your device\n// Uncomment the line below if you are watching this on a potato!\n//#define LOW_RESOLUTION_MODE\n\n// Uncomment to enable vibing cat\n// Warning: May not work on every machine!\n#define ENABLE_VIBING_CAT\n\n// End of user settings\n\n\n\n#ifdef ENABLE_VIBING_CAT\nconst float playbackSpeed = 1.5;\n#else\nconst float playbackSpeed = 1.0;\n#endif\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsXGWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mdXGWS", "name": "Ivean Polkka (LQ) - Sound Shader", "author": "BigETI", "description": "You are free to play around the code and do something else.", "tags": ["sound", "music", "audio"], "likes": 1, "viewed": 191, "published": 3, "date": "1666708206", "time_retrieved": "2024-07-30T16:24:41.287689", "image_code": "// Ivean Polkka - loituma\n\n#ifdef LOW_RESOLUTION_MODE\nconst int imageWidth = 32;\n\nconst int imageHeight = 32;\n#else\nconst int imageWidth = 64;\n\nconst int imageHeight = 64;\n#endif\n\nconst int imageCount = 4;\n\nconst int indicesPerBitmapBitsElement = 8;\n\nconst int primaryBorderSize = 2;\n\nconst int primaryBorderColorIndex = 10;\n\nconst int secondaryBorderColorIndex = 12;\n\nconst vec3 bitmapPalette[] = vec3[]\n(\n        vec3(0.9215686274509803, 0.7215686274509804, 0.6352941176470588),\n        vec3(0.9490196078431372, 0.7843137254901961, 0.7058823529411765),\n        vec3(0.7058823529411765, 0.807843137254902, 0.792156862745098),\n        vec3(0.6196078431372549, 0.43529411764705883, 0.34509803921568627),\n        vec3(0.6274509803921569, 0.3803921568627451, 0.19215686274509805),\n        vec3(0.7686274509803922, 0.5294117647058824, 0.32941176470588235),\n        vec3(0.8392156862745098, 0.5372549019607843, 0.3058823529411765),\n        vec3(0.788235294117647, 0.47058823529411764, 0.23921568627450981),\n        vec3(0.9450980392156862, 0.8588235294117647, 0.8196078431372549),\n        vec3(0.6745098039215687, 0.6235294117647059, 0.6039215686274509),\n        vec3(0.4666666666666667, 0.611764705882353, 0.5607843137254902),\n        vec3(0.396078431372549, 0.38823529411764707, 0.38823529411764707),\n        vec3(0.3607843137254902, 0.5137254901960784, 0.42745098039215684),\n        vec3(0.38823529411764707, 0.23137254901960785, 0.2784313725490196),\n        vec3(0.4823529411764706, 0.3254901960784314, 0.5333333333333333),\n        vec3(0.5490196078431373, 0.37254901960784315, 0.596078431372549)\n);\n\nconst ivec4 bitmapBits[] = ivec4[]\n(\n#ifdef LOW_RESOLUTION_MODE\n    ivec4(0x01000000, 0x03000022, 0x66776666, 0x00666666),\n    ivec4(0x00000000, 0x34000012, 0x66757677, 0x00664666),\n    ivec4(0x00000000, 0x47000011, 0x66057646, 0x70674766),\n    ivec4(0x00100000, 0x77000000, 0x66056776, 0x75674466),\n    ivec4(0x009222A2, 0x77000000, 0x36135577, 0x67664456),\n    ivec4(0x10CA22CA, 0x74190000, 0x57893535, 0x67763335),\n    ivec4(0x00BC2ACC, 0x75150100, 0x80883035, 0x67779913),\n    ivec4(0x00CC9BCC, 0x43050111, 0x88888880, 0x67469981),\n    ivec4(0x00CAACCC, 0x75051111, 0x11881810, 0x67461388),\n    ivec4(0x11C0BCBC, 0x75051111, 0xB388B0BB, 0x654680DB),\n    ivec4(0x11A1CC9C, 0x75151111, 0x88888888, 0x75478982),\n    ivec4(0x1122CC29, 0x77151111, 0x88888888, 0x50461581),\n    ivec4(0x1181CC81, 0x45101111, 0x81881888, 0x52770588),\n    ivec4(0x11010B11, 0x45111111, 0xDDDDDD88, 0x92649588),\n    ivec4(0x11911911, 0x76111111, 0x3D333388, 0x92443788),\n    ivec4(0x11011011, 0x76111111, 0x18998843, 0x22473789),\n    ivec4(0x11801011, 0x57111811, 0x09114344, 0x824747D4),\n    ivec4(0x11898128, 0x67888888, 0x00304444, 0x184774DD),\n    ivec4(0x81811182, 0x64812282, 0xBDB044D4, 0x11444DDD),\n    ivec4(0x81888888, 0x64812288, 0xDDEFDDDD, 0x1144DDDB),\n    ivec4(0x81882228, 0x54882282, 0xDDDDDDFF, 0x11BDDBB3),\n    ivec4(0x90882922, 0x5D812288, 0xDDDDDDFF, 0x81FEEF34),\n    ivec4(0x11889828, 0x3D818888, 0xEEDEEEFF, 0x08EEFF4D),\n    ivec4(0x10882888, 0xBD898888, 0xFFEFFFFF, 0xF8FFFFDB),\n    ivec4(0x10881188, 0xFDEF8888, 0xFFFFFFFF, 0xF1FFEEDE),\n    ivec4(0x09888088, 0xEFFF8088, 0xFFFFFEFF, 0xFFFFFE9F),\n    ivec4(0x88098888, 0xFFFF9E88, 0xFFFFEEFF, 0xFFFEE999),\n    ivec4(0x88088888, 0xFFFEDE01, 0xFFFFEFFF, 0xFF8F88EE),\n    ivec4(0x88088888, 0xFFEE9081, 0xFFFFEFFF, 0xFF818828),\n    ivec4(0x28288888, 0xFF3E1088, 0xFFFFEFFF, 0xFF888898),\n    ivec4(0x98288888, 0xFF038888, 0xFFFFEFFF, 0xF9888898),\n    ivec4(0x21988288, 0xFF008888, 0xFFFFDDFE, 0x993B09AA),\n    ivec4(0x01000000, 0x03000022, 0x66776666, 0x00666666),\n    ivec4(0x01000000, 0x34000022, 0x66757677, 0x00664666),\n    ivec4(0x00000000, 0x47000011, 0x66057676, 0x70674766),\n    ivec4(0x00100011, 0x77000000, 0x66056776, 0x75674466),\n    ivec4(0x00822282, 0x77000000, 0x36135577, 0x67664456),\n    ivec4(0x11882222, 0x74190000, 0x57893535, 0x67663335),\n    ivec4(0x10882222, 0x75150011, 0x80883035, 0x67779913),\n    ivec4(0x11822222, 0x43050111, 0x88888880, 0x67469981),\n    ivec4(0x01222822, 0x75051111, 0x11881810, 0x67461388),\n    ivec4(0x11112282, 0x75051111, 0xB388B0BB, 0x654680DB),\n    ivec4(0x11212282, 0x75151111, 0x88888888, 0x75478982),\n    ivec4(0x11222222, 0x77151111, 0x88888888, 0x50461581),\n    ivec4(0x11118111, 0x45101111, 0x88888888, 0x52770588),\n    ivec4(0x11111111, 0x45111111, 0x18118188, 0x92649588),\n    ivec4(0x11111111, 0x76111111, 0x88888888, 0x92443788),\n    ivec4(0x11111111, 0x76111111, 0x88888849, 0x12473789),\n    ivec4(0x11111111, 0x57112818, 0x09014344, 0x814747D4),\n    ivec4(0x11111128, 0x67888888, 0x00404444, 0x184774DD),\n    ivec4(0x11111182, 0x64818282, 0xBDB044D4, 0x11444DDD),\n    ivec4(0x18818888, 0x54889982, 0xDDEFDDDD, 0x1144DDDB),\n    ivec4(0x11812228, 0x54288888, 0xDDDDDDFF, 0x11BDDB33),\n    ivec4(0x90908822, 0x5D188888, 0xDDDDDDFF, 0x81FEEF34),\n    ivec4(0x81882228, 0x3D118818, 0xEEDEEEFF, 0x08EEFF4D),\n    ivec4(0x88880188, 0xBD898888, 0xFFFFFFFF, 0xF8FFFFDB),\n    ivec4(0x81881888, 0xFDEF8888, 0xFFFFFFFF, 0xF1FFEEDE),\n    ivec4(0x09881181, 0xFFFF8088, 0xFFFFFEFF, 0xFFFFFE9F),\n    ivec4(0x88991118, 0xFFFF9E88, 0xFFFFEEFF, 0xFFFEE999),\n    ivec4(0x88808888, 0xFFFEDE08, 0xFFFFEFFF, 0xFF8F88EE),\n    ivec4(0x88818818, 0xFFEE9081, 0xFFFFEFFF, 0xFF818828),\n    ivec4(0x88888888, 0xFF3E1088, 0xFFFFEFFF, 0xFF888898),\n    ivec4(0x28228888, 0xFF038888, 0xFFFFEFFF, 0xF9888898),\n    ivec4(0x21888288, 0xFF008888, 0xFFFFDDFE, 0x993B09AA),\n    ivec4(0x00000000, 0x03002012, 0x66776666, 0x00666666),\n    ivec4(0x00000000, 0x34001012, 0x66757677, 0x00664666),\n    ivec4(0x00000000, 0x47000011, 0x66057676, 0x70674766),\n    ivec4(0x00111111, 0x77000000, 0x66056776, 0x75674466),\n    ivec4(0x10882282, 0x77000000, 0x36135577, 0x67664456),\n    ivec4(0x11882222, 0x74100000, 0x53893535, 0x67763335),\n    ivec4(0x11822222, 0x75150010, 0x80883035, 0x67779913),\n    ivec4(0x11222222, 0x43050111, 0x88888880, 0x67469981),\n    ivec4(0x11212222, 0x75051111, 0x11881810, 0x67461388),\n    ivec4(0x11112282, 0x75051111, 0xB388B0BB, 0x654680DB),\n    ivec4(0x11212222, 0x75151111, 0x88888888, 0x75478982),\n    ivec4(0x11212228, 0x77101111, 0x88888818, 0x50461581),\n    ivec4(0x11111111, 0x45101111, 0x88888888, 0x52670588),\n    ivec4(0x11111111, 0x45111111, 0x18118188, 0x02649588),\n    ivec4(0x11111111, 0x76111111, 0x88888888, 0x02443788),\n    ivec4(0x11111111, 0x76118111, 0x88888843, 0x11473789),\n    ivec4(0x11111111, 0x56118218, 0x09014344, 0x184747D4),\n    ivec4(0x11111121, 0x67882288, 0x00404444, 0x114774DD),\n    ivec4(0x11118882, 0x64812282, 0xBDE044D4, 0x11444DDD),\n    ivec4(0x11118228, 0x64282288, 0xDDE3DDDD, 0x1144DDDB),\n    ivec4(0x18818822, 0x54882288, 0xDDDDDDFF, 0x11B4DBB3),\n    ivec4(0x18009922, 0x5D818888, 0xDDDDDDFF, 0x81FEEF34),\n    ivec4(0x01888888, 0x3D818888, 0xEEDEEEFF, 0x08EEFF4D),\n    ivec4(0x80888810, 0xBD898888, 0xFFFFFFFF, 0xF8FFFFDB),\n    ivec4(0x89888888, 0xFDEF8801, 0xFFFFFFFF, 0xF1FFEEDF),\n    ivec4(0x99180188, 0xEFEF8888, 0xFFFFFEFF, 0xFFFFFE9F),\n    ivec4(0x88888888, 0xBBCC9981, 0xFFFFEEFF, 0xFFFEE999),\n    ivec4(0x88198888, 0xCCEBDE01, 0xFFFFEFCB, 0xFF8F88EE),\n    ivec4(0x88818888, 0xCCEE9011, 0xFFFFBBCC, 0xFF818828),\n    ivec4(0x88228888, 0xCC3E109A, 0xFFBECCCC, 0xFF888898),\n    ivec4(0x28228888, 0xCC0388CC, 0xEFCCCCBB, 0xF9888898),\n    ivec4(0x21882288, 0xBC9098CC, 0xEFBBBCBB, 0x993B09AA),\n    ivec4(0x00000000, 0x03001011, 0x66776666, 0x00666666),\n    ivec4(0x00000000, 0x34001011, 0x66757677, 0x00664666),\n    ivec4(0x00000000, 0x47000010, 0x66057676, 0x70674766),\n    ivec4(0x00082211, 0x77000000, 0x66056776, 0x75664466),\n    ivec4(0x00DBAC22, 0x77000000, 0x36135577, 0x67664456),\n    ivec4(0x00BC9C22, 0x74100000, 0x53893535, 0x67763335),\n    ivec4(0x11CCAC22, 0x75150000, 0x80883035, 0x67779913),\n    ivec4(0x00CBAC22, 0x430300B5, 0x88888880, 0x67469981),\n    ivec4(0x3BCCCC82, 0x750500D3, 0x11881810, 0x67461A88),\n    ivec4(0xBBC9CC22, 0x470500C0, 0xB388B0BB, 0x654680DB),\n    ivec4(0xCCBCCC22, 0xBB030090, 0x88888888, 0x75478982),\n    ivec4(0xC9CCCC11, 0xBBBB0111, 0x88888891, 0x50461588),\n    ivec4(0x11CCBC11, 0xBBCC9311, 0x81881181, 0x52670588),\n    ivec4(0x11913C11, 0xB9CCBC11, 0xDDDDDD88, 0x02649588),\n    ivec4(0x11819B11, 0x44C9CC10, 0x3D333388, 0x12443788),\n    ivec4(0x11119B11, 0xBDBBCC9C, 0x189919D3, 0x11473789),\n    ivec4(0x11110011, 0xCCCCCCCC, 0x09014444, 0x114747D4),\n    ivec4(0x11110021, 0xBBCCACCA, 0x00304444, 0x114774DD),\n    ivec4(0x11018282, 0x44282292, 0xBDB044D4, 0x11444DDD),\n    ivec4(0x11212228, 0x74282228, 0xDDEFDDDD, 0x1144DDDB),\n    ivec4(0x11802222, 0x7D882288, 0xDDDDDDFF, 0x11B4DBB3),\n    ivec4(0x01818222, 0x5D818888, 0xDDDDDDFF, 0x81FEEF34),\n    ivec4(0x89882822, 0x3D818888, 0xEEDBEEFF, 0x08EEFF4D),\n    ivec4(0x19881888, 0xBD898888, 0xFFEFFFFF, 0xF8FFFFDB),\n    ivec4(0x18880888, 0xFDEF8888, 0xFFEFFFFF, 0xF1FFEEDF),\n    ivec4(0x99881188, 0xEFFF8188, 0xFFFFFFFF, 0xFFEFFE9F),\n    ivec4(0x88888188, 0xFFFF9E88, 0xFFFFEEFF, 0xFFFEE999),\n    ivec4(0x88008888, 0xFFFEDE08, 0xFFFFEFFF, 0xFF8F88EE),\n    ivec4(0x88888888, 0xFFEE9081, 0xFFFFEFFF, 0xFF818828),\n    ivec4(0x88888888, 0xFF3E1088, 0xFFFFEFFF, 0xFF888898),\n    ivec4(0x28828288, 0xFF038888, 0xFFFFEFFF, 0xF9888898),\n    ivec4(0x2289A288, 0xFF908888, 0xFFFFDDFE, 0x993B09AA)\n#else\n    ivec4(0x0, 0x12010000, 0x2122, 0x45030000),\n    ivec4(0x66666666, 0x66666677, 0x66667766, 0x6066),\n    ivec4(0x0, 0x18010000, 0x2222, 0x76640000),\n    ivec4(0x66776667, 0x66666677, 0x66667766, 0x7666),\n    ivec4(0x0, 0x11000000, 0x2212, 0x77340000),\n    ivec4(0x67766777, 0x66666675, 0x66466466, 0x6766),\n    ivec4(0x0, 0x11000000, 0x1111, 0x77440000),\n    ivec4(0x65766777, 0x66666655, 0x66476466, 0x606667),\n    ivec4(0x0, 0x0, 0x1011, 0x77470500),\n    ivec4(0x70766446, 0x66666605, 0x66476766, 0x707667),\n    ivec4(0x0, 0x0, 0x0, 0x77770400),\n    ivec4(0x58667446, 0x76677705, 0x66446766, 0x767667),\n    ivec4(0x10000000, 0x10, 0x0, 0x77776400),\n    ivec4(0x68677776, 0x47667705, 0x66447766, 0x757767),\n    ivec4(0x9001191, 0x1001, 0x0, 0x77575400),\n    ivec4(0x8657576, 0x77565503, 0x66447766, 0x657766),\n    ivec4(0xAB2222A2, 0x1192, 0x0, 0x74773400),\n    ivec4(0x88555577, 0x55365013, 0x56447456, 0x677766),\n    ivec4(0xCC2222C9, 0x20C2, 0x0, 0x74743419),\n    ivec4(0x88350977, 0x59975185, 0x56446456, 0x677766),\n    ivec4(0xCC2222CA, 0x1022CA, 0x1000000, 0x43743719),\n    ivec4(0x88359535, 0x39573089, 0x56337335, 0x60677776),\n    ivec4(0xCC2292CC, 0xA2BC, 0x1000000, 0x45745415),\n    ivec4(0x88391035, 0x30153981, 0x56395355, 0x60677777),\n    ivec4(0xCC2AA2CC, 0xA2BC, 0x11010100, 0x35755715),\n    ivec4(0x88308835, 0x31809188, 0x36993913, 0x60677777),\n    ivec4(0xCC2CC2CC, 0x100A1BC, 0x11011011, 0x39455705),\n    ivec4(0x88188893, 0x1888888, 0x33993989, 0x60676776),\n    ivec4(0xCC9BC9CC, 0x110091CC, 0x11011011, 0x8435605),\n    ivec4(0x88888880, 0x88888888, 0x94991181, 0x60676746),\n    ivec4(0xCCACCCCC, 0x110021CC, 0x11010010, 0x88456605),\n    ivec4(0x88881188, 0x88888888, 0x93198888, 0x676746),\n    ivec4(0xCCACCCCC, 0x110011CA, 0x11111111, 0x88756705),\n    ivec4(0x88189010, 0x1118888, 0xB3138888, 0x1677746),\n    ivec4(0xCCBCCCCC, 0x111111C9, 0x11111111, 0x1756705),\n    ivec4(0x8898DB93, 0x33938188, 0x35898890, 0x1677746),\n    ivec4(0xCCBCCCBC, 0x111110C0, 0x11111111, 0x9756705),\n    ivec4(0x88B099BB, 0x9BB38088, 0x558008DB, 0x657746),\n    ivec4(0xCCBCCC3C, 0x111111C1, 0x10111111, 0x9B756715),\n    ivec4(0x88188831, 0x88088888, 0x5789B89D, 0x10667747),\n    ivec4(0xCCCCCC9C, 0x111111A1, 0x11111111, 0x59757715),\n    ivec4(0x88888888, 0x88888888, 0x5789B982, 0x11757747),\n    ivec4(0xCCCCCC2C, 0x11111192, 0x11111111, 0x8757715),\n    ivec4(0x88888888, 0x88888888, 0x57851188, 0x88707746),\n    ivec4(0xCACCCC29, 0x11112122, 0x11111111, 0x8777715),\n    ivec4(0x88888888, 0x88888888, 0x54158881, 0x22507646),\n    ivec4(0xBACC2C28, 0x11111122, 0x11111111, 0x18457710),\n    ivec4(0x88888888, 0x88888888, 0x54058888, 0x22507576),\n    ivec4(0xCACC1081, 0x11111181, 0x11111111, 0x88455710),\n    ivec4(0x88188188, 0x18818888, 0x54058888, 0x22527577),\n    ivec4(0xCC9C1111, 0x11111111, 0x11111111, 0x88455710),\n    ivec4(0x39331388, 0xB3333339, 0x74058888, 0x22527767),\n    ivec4(0xCC0B1111, 0x11111101, 0x11111111, 0x88455311),\n    ivec4(0xDDDD1B88, 0xD3DDDDDD, 0x77958888, 0x22927564),\n    ivec4(0xBB1A1111, 0x11111191, 0x11111111, 0x8550411),\n    ivec4(0x3DDD8988, 0xD9BDDDBB, 0x46558188, 0x22925574),\n    ivec4(0xAA191111, 0x11111191, 0x11111111, 0x50760411),\n    ivec4(0x33338188, 0x383D3333, 0x76378088, 0x82925544),\n    ivec4(0x88101111, 0x11111191, 0x11111111, 0x43760411),\n    ivec4(0x33198808, 0x18393353, 0x77371388, 0x88225544),\n    ivec4(0x88101111, 0x11111101, 0x11111111, 0x44760311),\n    ivec4(0x9881843, 0x88189099, 0x74373489, 0x88227547),\n    ivec4(0x88101111, 0x11111110, 0x11111811, 0x44761311),\n    ivec4(0x88084544, 0x80888888, 0x74474434, 0x28127047),\n    ivec4(0x18101111, 0x11111180, 0x81181811, 0x44571511),\n    ivec4(0x59434444, 0x93091111, 0x4D4744D4, 0x28825047),\n    ivec4(0x8811111, 0x11111189, 0x81288818, 0x44571511),\n    ivec4(0x4D444444, 0x9900030, 0xDD7444DD, 0x22885047),\n    ivec4(0x8811128, 0x11111189, 0x88888888, 0x44671588),\n    ivec4(0x4D444D44, 0x9B000030, 0xD474D4DD, 0x22185047),\n    ivec4(0x8818122, 0x11111889, 0x28228281, 0x4D671581),\n    ivec4(0x4D44DD44, 0xDD0300B0, 0x4D4DD7DD, 0x82115047),\n    ivec4(0x8112182, 0x18810881, 0x28228882, 0x4D641581),\n    ivec4(0xDD444DD4, 0xDDBD19B0, 0x4D4D44DD, 0x88115044),\n    ivec4(0x98812882, 0x88810888, 0x22228828, 0xDD640581),\n    ivec4(0xDDDD4D44, 0xDDDD9D30, 0x4DDD44DD, 0x11115143),\n    ivec4(0x98882888, 0x82810888, 0x22222288, 0xDD640581),\n    ivec4(0xDDDDDDDD, 0xDDDDDDEF, 0xDDDD34DB, 0x11115144),\n    ivec4(0x22882888, 0x82180888, 0x22222282, 0xDB540328),\n    ivec4(0xDDDDED33, 0xDDDDDDDD, 0xDDDD44D3, 0x111151D4),\n    ivec4(0x22222228, 0x82819188, 0x22222282, 0xDE540388),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xEEDB4DB3, 0x111151BD),\n    ivec4(0xA9292822, 0x18999920, 0x22222282, 0xBF540381),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xFFBF4D34, 0x111131FB),\n    ivec4(0x28292822, 0x8908988, 0x28222288, 0xEF5D0381),\n    ivec4(0xDDDDFFFF, 0xDDDDDDDD, 0xFFEFDD34, 0x1181E0FE),\n    ivec4(0x88982222, 0x8188188, 0x88888888, 0xEF3D0388),\n    ivec4(0xDDEDFFFF, 0xEBEEDDDD, 0xFFEFDB3D, 0x8818E9FE),\n    ivec4(0x88988228, 0x8118188, 0x88888888, 0xEF3D9D81),\n    ivec4(0xEDEEFFFF, 0xEBEEEEDE, 0xFFFFDB4D, 0x8108FEEE),\n    ivec4(0x88988888, 0x18098888, 0x88888888, 0xEF3DEE80),\n    ivec4(0xFEFFFFFF, 0xE3EEFFEF, 0xFEFFDE4D, 0x1198FEEF),\n    ivec4(0x88288888, 0x88108888, 0x88888888, 0xEEBDEE89),\n    ivec4(0xFEFFFFFF, 0xFEFFFFEF, 0xFEFFBDDB, 0x88F8FFFF),\n    ivec4(0x88018888, 0x88818888, 0x88888888, 0xDFEDFF9E),\n    ivec4(0xFEFFFFFF, 0xFBFFFFFF, 0xEEEFEBDE, 0x88F8FFFF),\n    ivec4(0x88118888, 0x88108888, 0x80888888, 0xEFFDFFEF),\n    ivec4(0xEEFFFFFF, 0xFEFFFFFF, 0xEFEEFEDE, 0x88F1FFFF),\n    ivec4(0x88108888, 0x88098888, 0xF888888, 0xEEEEFFFF),\n    ivec4(0xEFFFFFFF, 0xFEFFFFFF, 0xFFFEFFBF, 0x88F9FFFF),\n    ivec4(0x88808888, 0x18098888, 0xFF808888, 0xFFEFFEFF),\n    ivec4(0xEFFEFFFF, 0xF9FFFFFF, 0xEEFEFF9F, 0x88FFFFFF),\n    ivec4(0x8818888, 0x8088088, 0xEF8F8888, 0xFFFFFEFF),\n    ivec4(0xFFEEFFFF, 0x99FFFFFF, 0x82E9FF9F, 0x98FFFFFF),\n    ivec4(0x10888888, 0x11889909, 0xFF9E8888, 0xFFFFEFFF),\n    ivec4(0xFFEEFFFF, 0x99FFFFFF, 0x10E9EE99, 0xF8FFFFFE),\n    ivec4(0x81888888, 0x80888998, 0xFFEF8918, 0xFFFFEFFF),\n    ivec4(0xFFEFFFFF, 0xF9FFFFFF, 0x1192EC9E, 0xE9FFFF9E),\n    ivec4(0x88888888, 0x88888808, 0xFFDE8001, 0xFFFFFFFE),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x888892EE, 0xFFFFEF8F),\n    ivec4(0x88888888, 0x88888808, 0xFFBF8110, 0xFFFFFFFE),\n    ivec4(0xFFEFFFFF, 0xFFFFFFFF, 0x10888898, 0xFEFFEF89),\n    ivec4(0x88888888, 0x88888808, 0x9E909981, 0xFFFFFFEE),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x19888828, 0xFFFFEE81),\n    ivec4(0x88888888, 0x88188808, 0x9109988, 0xFFFFFFEE),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x80888828, 0xFFFFFE88),\n    ivec4(0x88888888, 0x88288828, 0x108088, 0xFFFFFF3E),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x88888898, 0xFEFF9E88),\n    ivec4(0x82888888, 0x88288228, 0x118888, 0xFFFFFF9E),\n    ivec4(0xFFEFFEFF, 0xFEFFFFFF, 0x88888898, 0xFFEFFE88),\n    ivec4(0x29888888, 0x88988228, 0x888888, 0xFFFFFF03),\n    ivec4(0xFFEFFEFF, 0xFFFFFFFF, 0x88888898, 0x9F93B88),\n    ivec4(0x2A888888, 0x88988228, 0x888888, 0xFFFFEF03),\n    ivec4(0xFFDEFEFF, 0xE9FFFFFF, 0x888888A2, 0x1913B09),\n    ivec4(0x2A828888, 0x88218298, 0x10888888, 0xFFFFFE00),\n    ivec4(0xEEDDEDFE, 0xE9FFFFFF, 0x990990AA, 0x1899993B),\n    ivec4(0x29828888, 0x88229929, 0x10888888, 0xEEEE0E88),\n    ivec4(0xDEDDEEEE, 0xE9FFFFEE, 0x9B9BBAC, 0x8199933),\n    ivec4(0x0, 0x12010000, 0x2222, 0x45030000),\n    ivec4(0x66666666, 0x66666677, 0x66667766, 0x6066),\n    ivec4(0x0, 0x12010000, 0x102222, 0x76640000),\n    ivec4(0x66776667, 0x66666677, 0x66667766, 0x7666),\n    ivec4(0x0, 0x18010000, 0x2222, 0x77340000),\n    ivec4(0x67766777, 0x66666675, 0x66466466, 0x6766),\n    ivec4(0x0, 0x11010000, 0x1182, 0x77440000),\n    ivec4(0x65766777, 0x66666655, 0x66476466, 0x606667),\n    ivec4(0x0, 0x1000000, 0x1011, 0x77470500),\n    ivec4(0x70766776, 0x66666605, 0x66476766, 0x707667),\n    ivec4(0x0, 0x0, 0x1000, 0x77770400),\n    ivec4(0x58667446, 0x76677705, 0x66446766, 0x767667),\n    ivec4(0x11000011, 0x10, 0x0, 0x77776400),\n    ivec4(0x68677776, 0x47667705, 0x66447766, 0x757767),\n    ivec4(0x11011111, 0x1010, 0x0, 0x77775400),\n    ivec4(0x8657576, 0x77565503, 0x66447766, 0x657766),\n    ivec4(0x28222282, 0x2182, 0x0, 0x74773400),\n    ivec4(0x88555577, 0x55365913, 0x56447456, 0x677766),\n    ivec4(0x22222222, 0x102182, 0x0, 0x74743410),\n    ivec4(0x88350977, 0x59975185, 0x56446456, 0x677766),\n    ivec4(0x22222222, 0x112288, 0x1000000, 0x43743719),\n    ivec4(0x88359535, 0x39573089, 0x56335335, 0x60677766),\n    ivec4(0x22222222, 0x102288, 0x1000000, 0x45735715),\n    ivec4(0x88391035, 0x30153981, 0x56395553, 0x60677777),\n    ivec4(0x22222222, 0x10102288, 0x1001011, 0x35755715),\n    ivec4(0x88308835, 0x31809188, 0x36993913, 0x60677777),\n    ivec4(0x28222222, 0x11112182, 0x11111011, 0x39455705),\n    ivec4(0x88188893, 0x1888888, 0x33993989, 0x60676776),\n    ivec4(0x88222222, 0x11112182, 0x11011011, 0x8435605),\n    ivec4(0x88888880, 0x88888888, 0x94991181, 0x60676746),\n    ivec4(0x88282222, 0x11011122, 0x11011011, 0x88456605),\n    ivec4(0x88181188, 0x88888888, 0x93198888, 0x676746),\n    ivec4(0x22282222, 0x11011122, 0x11111111, 0x88756705),\n    ivec4(0x88189010, 0x1118888, 0xB3138888, 0x1676746),\n    ivec4(0x22222222, 0x11111121, 0x11111111, 0x1756705),\n    ivec4(0x8898DB93, 0x33938188, 0x35898890, 0x677746),\n    ivec4(0x21222282, 0x11111111, 0x11111111, 0x9756705),\n    ivec4(0x88B099BB, 0x9BB38088, 0x558008DB, 0x657746),\n    ivec4(0x88822882, 0x11111111, 0x11111111, 0x9B756715),\n    ivec4(0x88188831, 0x88088888, 0x5789B89D, 0x11667747),\n    ivec4(0x88222882, 0x11111121, 0x11111111, 0x59757715),\n    ivec4(0x88888888, 0x88888888, 0x5789B982, 0x81757747),\n    ivec4(0x88228822, 0x11111122, 0x11111111, 0x8757715),\n    ivec4(0x88888888, 0x88888888, 0x57851188, 0x88707746),\n    ivec4(0x88228822, 0x11111122, 0x11111111, 0x8777715),\n    ivec4(0x88888888, 0x88888888, 0x54158881, 0x22507646),\n    ivec4(0x88221811, 0x11111111, 0x11111111, 0x18457710),\n    ivec4(0x88888888, 0x88888888, 0x64058888, 0x22507576),\n    ivec4(0x11811111, 0x11111111, 0x11111111, 0x88455710),\n    ivec4(0x88888888, 0x88888888, 0x64058888, 0x22527777),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x88455710),\n    ivec4(0x88888888, 0x88888888, 0x74058888, 0x22527767),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x88455311),\n    ivec4(0x818888, 0x88181011, 0x77958888, 0x22927564),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x8550411),\n    ivec4(0x11888888, 0x88881188, 0x46558188, 0x88925574),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x50760411),\n    ivec4(0x88888888, 0x88888888, 0x76378088, 0x88925544),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x43760411),\n    ivec4(0x88888808, 0x88888888, 0x77371388, 0x88227544),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x44760311),\n    ivec4(0x88881849, 0x88888888, 0x74373489, 0x28125047),\n    ivec4(0x11111111, 0x11111111, 0x81111811, 0x44761311),\n    ivec4(0x88014544, 0x80888888, 0x74474434, 0x28125047),\n    ivec4(0x11111111, 0x11111111, 0x81281818, 0x44571511),\n    ivec4(0x59434444, 0x93091101, 0x4D4744D4, 0x22815047),\n    ivec4(0x11111111, 0x11111111, 0x81888818, 0x44571581),\n    ivec4(0x4D444444, 0x9900030, 0x4D7444DD, 0x22885047),\n    ivec4(0x11111128, 0x11111111, 0x28888888, 0x44671588),\n    ivec4(0x4D44DD44, 0x9B000040, 0xD474D4DD, 0x82185047),\n    ivec4(0x11118122, 0x11111111, 0x28221281, 0x4D671581),\n    ivec4(0x4D44DD44, 0xDD0300B0, 0x4444D7DD, 0x88115047),\n    ivec4(0x11112882, 0x18111111, 0x28828882, 0x4D640581),\n    ivec4(0xDD444DD4, 0xDDBD19B0, 0x4D4D44DD, 0x18115144),\n    ivec4(0x21882888, 0x81111111, 0x22228228, 0xDD640581),\n    ivec4(0xDDDD4DD4, 0xDDDD9DE0, 0x4DDD44DD, 0x11115143),\n    ivec4(0x88882888, 0x81181181, 0x99999982, 0xDD540588),\n    ivec4(0xDDDDDDDD, 0xDDDDDDEF, 0xDDDD34DB, 0x11115144),\n    ivec4(0x88882228, 0x82181881, 0x2A882822, 0xDB540528),\n    ivec4(0xDDDDEDB3, 0xDDDDDDDD, 0xDDDD44D3, 0x111151D4),\n    ivec4(0x21222228, 0x2118881, 0x8A888888, 0xDF540528),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xEEDB4D33, 0x111151BD),\n    ivec4(0x88882822, 0x88900010, 0x2A888888, 0xBF540508),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xFFBF4D34, 0x111131FB),\n    ivec4(0x81882222, 0x88901190, 0x99888888, 0xEF5D0318),\n    ivec4(0xDDDDFFFF, 0xDDDDDDDD, 0xFFEFDD34, 0x1881E0FE),\n    ivec4(0x90992222, 0x91898888, 0x10000012, 0xEF3D0308),\n    ivec4(0xDDEDFFFF, 0xEBEEDDDD, 0xFFEFDB3D, 0x8818E9FE),\n    ivec4(0x98228228, 0x90818888, 0x88888818, 0xEF3D9D11),\n    ivec4(0xEDEEFFFF, 0xEBEEEEDE, 0xFFFFDB4D, 0x8108FEEE),\n    ivec4(0x18822188, 0x8888888, 0x88888888, 0xEFBDEE80),\n    ivec4(0xFEFFFFFF, 0xE3EEFFEF, 0xFEFFDE4D, 0x8898FEEF),\n    ivec4(0x88010088, 0x8888888, 0x88888888, 0xEEBDEF89),\n    ivec4(0xFEFFFFFF, 0xFEFFFFFF, 0xFEFFEDDB, 0x88F8FFFF),\n    ivec4(0x88181988, 0x8888888, 0x88888888, 0xBFEDFF9E),\n    ivec4(0xFEFFFFFF, 0xFBFFFFFF, 0xEEEFEEDE, 0x88F8FFFF),\n    ivec4(0x88188088, 0x18818888, 0x80888888, 0xEFFDFFEF),\n    ivec4(0xEEFFFFFF, 0xFEFFFFFF, 0xEFEEFEDE, 0x88F1FFFF),\n    ivec4(0x88081988, 0x88108888, 0xF888888, 0xEEEEFFFF),\n    ivec4(0xEFFFFFFF, 0xFEFFFFFF, 0xFFFEFFBF, 0x88F9FFFF),\n    ivec4(0x88111881, 0x88098188, 0xFF808888, 0xFFFFFFFF),\n    ivec4(0xEFFEFFFF, 0xF9FFFFFF, 0xEEFEFF9F, 0x88FFFFFF),\n    ivec4(0x18898881, 0x8810188, 0xEF8F8888, 0xFFFFFEFF),\n    ivec4(0xFFEEFFFF, 0x99FFFFFF, 0x82E9FF9F, 0x98FFFFFF),\n    ivec4(0x10118818, 0x11888899, 0xFF9E8888, 0xFFFFEFFF),\n    ivec4(0xFFEEFFFF, 0x99FFFFFF, 0x10E9EE99, 0xF8FFFFFE),\n    ivec4(0x88888188, 0x80888800, 0xFFEF8918, 0xFFFFEFFF),\n    ivec4(0xFFEEFFFF, 0xF9FFFFFF, 0x1192EC9E, 0xE9FFFF9E),\n    ivec4(0x88881888, 0x88888880, 0xFFDE8008, 0xFFFFFFFE),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x888892EE, 0xFFFFEF8F),\n    ivec4(0x88888881, 0x88881881, 0xFFBF8110, 0xFFFFFFFE),\n    ivec4(0xFFEFFFFF, 0xFFFFFFFF, 0x10888898, 0xFEFFEF89),\n    ivec4(0x88888818, 0x88880881, 0x9E909981, 0xFFFFFFEE),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x19888828, 0xFFFFEE81),\n    ivec4(0x88888888, 0x88880888, 0x9109988, 0xFFFFFFEE),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x80888828, 0xFFFFFE88),\n    ivec4(0x88888888, 0x88882288, 0x108088, 0xFFFFFF3E),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x88888898, 0xFEFF9E88),\n    ivec4(0x82888888, 0x88882922, 0x818888, 0xFFFFFF9E),\n    ivec4(0xFFEFFEFF, 0xFEFFFFFF, 0x88888898, 0xFFEFFE88),\n    ivec4(0x22888888, 0x88282922, 0x888888, 0xFFFFFF03),\n    ivec4(0xFFEFFEFF, 0xFFFFFFFF, 0x88888898, 0x9F93B88),\n    ivec4(0x22828888, 0x88288888, 0x888888, 0xFFFFEF03),\n    ivec4(0xFFDEFEFF, 0xEFFFFFFF, 0x888888A2, 0x1913B09),\n    ivec4(0x28828888, 0x88218888, 0x10888888, 0xFFFFFE00),\n    ivec4(0xEEDDEDFE, 0xE9FFFFFF, 0x990990AA, 0x1899993B),\n    ivec4(0x88128888, 0x88808888, 0x10888888, 0xEEEE0E88),\n    ivec4(0xEEDDEEEE, 0xE9FFFFEE, 0x9B9BBAC, 0x8199933),\n    ivec4(0x0, 0x1000000, 0x202212, 0x47030000),\n    ivec4(0x66666666, 0x66666677, 0x66667766, 0x6066),\n    ivec4(0x0, 0x1000000, 0x202282, 0x76540000),\n    ivec4(0x66776667, 0x66666677, 0x66667766, 0x7666),\n    ivec4(0x0, 0x1000000, 0x102212, 0x77340000),\n    ivec4(0x67766777, 0x66666675, 0x66466466, 0x6666),\n    ivec4(0x0, 0x1000000, 0x102112, 0x47470000),\n    ivec4(0x65766777, 0x66666655, 0x66476466, 0x606667),\n    ivec4(0x0, 0x1000000, 0x1111, 0x77470500),\n    ivec4(0x70766776, 0x66666605, 0x66476766, 0x707667),\n    ivec4(0x1000000, 0x10, 0x0, 0x77770400),\n    ivec4(0x51667446, 0x76677705, 0x66446766, 0x767667),\n    ivec4(0x11111111, 0x1011, 0x0, 0x77770400),\n    ivec4(0x68677776, 0x47667705, 0x66447766, 0x757667),\n    ivec4(0x22222288, 0x1182, 0x0, 0x77775400),\n    ivec4(0x8657576, 0x77565503, 0x66447766, 0x657766),\n    ivec4(0x22222282, 0x102188, 0x0, 0x74773400),\n    ivec4(0x88555577, 0x55365013, 0x56447456, 0x677766),\n    ivec4(0x22222222, 0x112228, 0x0, 0x74743410),\n    ivec4(0x88550977, 0x59575185, 0x56446456, 0x677766),\n    ivec4(0x22222222, 0x112288, 0x0, 0x43743710),\n    ivec4(0x88359535, 0x39533089, 0x56337335, 0x60677776),\n    ivec4(0x22222222, 0x10102288, 0x1000000, 0x45745715),\n    ivec4(0x88391035, 0x30153981, 0x56395355, 0x60677777),\n    ivec4(0x22222222, 0x11112282, 0x1000010, 0x39755715),\n    ivec4(0x88308835, 0x31809188, 0x35993913, 0x60677777),\n    ivec4(0x28222222, 0x11112182, 0x11111011, 0x30455705),\n    ivec4(0x88188893, 0x1888888, 0x33993989, 0x60676776),\n    ivec4(0x88222222, 0x11112122, 0x1011011, 0x98436605),\n    ivec4(0x88888880, 0x88888888, 0xA3991181, 0x60676746),\n    ivec4(0x82882222, 0x11011122, 0x1011011, 0x88756605),\n    ivec4(0x88181188, 0x88888888, 0x93198888, 0x676746),\n    ivec4(0x22222222, 0x11111121, 0x1111111, 0x88756705),\n    ivec4(0x88189010, 0x1118888, 0xB3138888, 0x676746),\n    ivec4(0x22222282, 0x11111111, 0x11111111, 0x1756705),\n    ivec4(0x8898DB93, 0x33938188, 0x35898890, 0x676746),\n    ivec4(0x81222282, 0x11111111, 0x11111111, 0x9756705),\n    ivec4(0x88B099BB, 0x9BB38088, 0x558008DB, 0x1657746),\n    ivec4(0x81228882, 0x11111111, 0x11111111, 0x9B755715),\n    ivec4(0x88188838, 0x88088888, 0x5789B89D, 0x11657747),\n    ivec4(0x82228822, 0x11111121, 0x11111111, 0x59755715),\n    ivec4(0x88888888, 0x88888888, 0x5789B982, 0x88757747),\n    ivec4(0x82228822, 0x11111121, 0x11111111, 0x8757715),\n    ivec4(0x88888888, 0x88888888, 0x57891188, 0x12707746),\n    ivec4(0x82228828, 0x11111121, 0x11111111, 0x1777710),\n    ivec4(0x88888818, 0x88888888, 0x54158881, 0x22507646),\n    ivec4(0x88281811, 0x11111111, 0x11111111, 0x18457710),\n    ivec4(0x88888888, 0x88888888, 0x64058888, 0x22507576),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x88455510),\n    ivec4(0x88888888, 0x88888888, 0x64058888, 0x22527567),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x88455710),\n    ivec4(0x88888888, 0x88888888, 0x74958888, 0x22927767),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x88455311),\n    ivec4(0x1818888, 0x88181011, 0x77958888, 0x28027564),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x8550411),\n    ivec4(0x11888888, 0x88881188, 0x46558888, 0x28025574),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x50760411),\n    ivec4(0x88888888, 0x88888888, 0x76378088, 0x28025544),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x43760411),\n    ivec4(0x88888808, 0x88888888, 0x77341388, 0x28127544),\n    ivec4(0x11111111, 0x11111111, 0x88811111, 0x44761311),\n    ivec4(0x88881843, 0x88888888, 0x74373489, 0x22117647),\n    ivec4(0x11111111, 0x11111111, 0x88821818, 0x44761311),\n    ivec4(0x88014544, 0x80888888, 0x74474434, 0x22185047),\n    ivec4(0x11111111, 0x11111111, 0x88828818, 0x44561311),\n    ivec4(0x59434444, 0x95091101, 0x4D4744D4, 0x82185047),\n    ivec4(0x11111111, 0x11111111, 0x82888818, 0x44571588),\n    ivec4(0x4D444444, 0x9990930, 0x4D7444DD, 0x88115047),\n    ivec4(0x11111121, 0x11111111, 0x22228888, 0x44671588),\n    ivec4(0x4D44DD44, 0x9B000040, 0xD474D4DD, 0x88115047),\n    ivec4(0x11118122, 0x18111111, 0x22828881, 0x4D671581),\n    ivec4(0x4D44DD44, 0xDD0300B0, 0x4D4DD7DD, 0x11115047),\n    ivec4(0x88882882, 0x18111111, 0x22228882, 0x4D640581),\n    ivec4(0xDD444DD4, 0xDDBD19E0, 0x4D4D34DD, 0x11115144),\n    ivec4(0x88882288, 0x88111111, 0x22222288, 0xDD640588),\n    ivec4(0xDDDDDDD4, 0xDDDD9DE0, 0x4DDD44DD, 0x11115144),\n    ivec4(0x21822228, 0x88111111, 0x22222288, 0xDD640528),\n    ivec4(0xDDDDDDDD, 0xDDDDDDE3, 0xDDDD34DB, 0x11115144),\n    ivec4(0x28822228, 0x88111181, 0x22222288, 0xDB540588),\n    ivec4(0xDDDDED33, 0xDDDDDDDD, 0xDDDD44D3, 0x111151D4),\n    ivec4(0x88882222, 0x88181181, 0x22222288, 0xDF540588),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xEEDB4DB3, 0x111151B4),\n    ivec4(0x88222222, 0x88181181, 0x88888888, 0xDF540388),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xFFBF4D34, 0x111131FB),\n    ivec4(0x99992222, 0x88181100, 0x88888888, 0xEF5D0381),\n    ivec4(0xDDDDFFFF, 0xDDDDDDDD, 0xFFEFDD34, 0x1181E0FE),\n    ivec4(0x88222282, 0x88110081, 0x88888888, 0xEF3D0318),\n    ivec4(0xDDEDFFFF, 0xEBEEDDDD, 0xFFEFDB3D, 0x8818E9FE),\n    ivec4(0x88882988, 0x88018188, 0x88888888, 0xEF3D9D81),\n    ivec4(0xEDEEFFFF, 0xEBEEEEDE, 0xFFFFDB4D, 0x8108FEEE),\n    ivec4(0x88882288, 0x88108888, 0x88888888, 0xEF3DE380),\n    ivec4(0xFEFFFFFF, 0xE3EEFFEF, 0xFEFFDB4D, 0x8898FEEF),\n    ivec4(0x88889810, 0x88808888, 0x88888888, 0xEFBDEF89),\n    ivec4(0xFEFFFFFF, 0xFEFFFFFF, 0xFEFFBDDB, 0x88F8FFFF),\n    ivec4(0x88889810, 0x18898888, 0x88888888, 0xBFEDFF9E),\n    ivec4(0xFEFFFFFF, 0xFBFFFFFF, 0xEEEFEBDE, 0x88F8FFFF),\n    ivec4(0x88880188, 0x1898888, 0x80881801, 0xEFFDFFEF),\n    ivec4(0xEEFFFFFF, 0xFEFFFFFF, 0xEFEEFEDF, 0x88F1FFFF),\n    ivec4(0x88181088, 0x88118888, 0x9F101181, 0xEEEEFFEF),\n    ivec4(0xEFFFFFFF, 0xFEFFFFFF, 0xFFFEFFBF, 0x88E9FFFF),\n    ivec4(0x81018188, 0x88998818, 0x9B888888, 0xFFEFFEEF),\n    ivec4(0xEFFEFFFF, 0xF9FFFFFF, 0xEEFEFF9F, 0x88FFFFFF),\n    ivec4(0x99818888, 0x99000011, 0x2C888801, 0xFFEEBBCC),\n    ivec4(0xFFEEFEFF, 0x99FFFFFF, 0x89F9FF9F, 0x98FFFFFF),\n    ivec4(0x10888888, 0x880088, 0x9E991981, 0xEEBBCCCC),\n    ivec4(0xFFEEFEFF, 0x99FFFFFF, 0x10E9EE99, 0xF8FFFFFE),\n    ivec4(0x81888888, 0x80880800, 0xEEBE8918, 0xCCCCBCBB),\n    ivec4(0xFFEEFFEE, 0xF9FFFFFF, 0x1192EE9E, 0xE9FFFF9E),\n    ivec4(0x88888888, 0x88881819, 0xFFDE8901, 0xCCCCBCEB),\n    ivec4(0xFFEFBECB, 0xFFFFFFFF, 0x888892EE, 0xFFFFEF8F),\n    ivec4(0x88888888, 0x81881880, 0xFFBF1200, 0xCCCCBCFE),\n    ivec4(0xFFBECBCC, 0xFFFFFFFF, 0x10888898, 0xFEFFEF89),\n    ivec4(0x88888888, 0x82880881, 0x9F909911, 0xCCCCECEE),\n    ivec4(0xEEBBCCCC, 0xFEFFFFFF, 0x19888828, 0xFFFFEF81),\n    ivec4(0x88888888, 0x88882888, 0x9102922, 0xBBCCEEEE),\n    ivec4(0xBBCCCCCC, 0xFEFFFFEF, 0x80888828, 0xFFFFFE88),\n    ivec4(0x82888888, 0x18882222, 0x10819A, 0xCBCCFE3E),\n    ivec4(0xCCCCCCCC, 0xFEFFFFBE, 0x88888898, 0xFEFF9E88),\n    ivec4(0x22888888, 0x9882922, 0x8198AC, 0xCBCCFE9E),\n    ivec4(0xCCCCBCBB, 0xFEFFBECB, 0x88888898, 0xFFEFFE88),\n    ivec4(0x22888888, 0x8A282222, 0x88C2CC, 0xCCCCFE03),\n    ivec4(0xCCCCBCBB, 0xFFEFCBCC, 0x88888898, 0x9F93B88),\n    ivec4(0x28828888, 0x82288888, 0x1088CACC, 0xCCCCEE03),\n    ivec4(0xCCCCBBBB, 0xEFEFCBCC, 0x888888A2, 0x1191BB09),\n    ivec4(0x88228888, 0x82218888, 0x1098CCCC, 0xCCBCFE90),\n    ivec4(0xCCBCBDBB, 0xE9EFBBBB, 0x990992AA, 0x1899993B),\n    ivec4(0x88228888, 0x89222888, 0x10A8CCCC, 0xCCBC0B88),\n    ivec4(0xCCBBBBBB, 0xE9FFBBBB, 0x9B9BB9C, 0x819993B),\n    ivec4(0x0, 0x1000000, 0x102211, 0x47030000),\n    ivec4(0x66666666, 0x66666677, 0x66667766, 0x6066),\n    ivec4(0x0, 0x1000000, 0x102212, 0x76540000),\n    ivec4(0x66776667, 0x66666677, 0x66667766, 0x7666),\n    ivec4(0x0, 0x1000000, 0x101111, 0x77340000),\n    ivec4(0x67766777, 0x66666675, 0x66466466, 0x6766),\n    ivec4(0x0, 0x1000000, 0x1111, 0x47470000),\n    ivec4(0x65766777, 0x66666655, 0x66476466, 0x506667),\n    ivec4(0x1100, 0x0, 0x1010, 0x77470500),\n    ivec4(0x70766776, 0x66666605, 0x66476766, 0x707667),\n    ivec4(0x11111111, 0x1011, 0x0, 0x77770400),\n    ivec4(0x51667446, 0x76677705, 0x66446766, 0x767667),\n    ivec4(0x99228211, 0x1008, 0x0, 0x77770400),\n    ivec4(0x68677776, 0x47667705, 0x66447766, 0x757666),\n    ivec4(0xCC2A2288, 0x1020A2, 0x0, 0x77775400),\n    ivec4(0x8657576, 0x77565503, 0x66447766, 0x657766),\n    ivec4(0xBBAC2222, 0xC9DB, 0x0, 0x74773400),\n    ivec4(0x88555577, 0x55365013, 0x56447456, 0x677766),\n    ivec4(0xCBAB2222, 0x99BBDB, 0x0, 0x74743410),\n    ivec4(0x88550977, 0x59575185, 0x56446456, 0x677766),\n    ivec4(0xCB9C2222, 0xCABC, 0x0, 0x43743710),\n    ivec4(0x88359535, 0x39533089, 0x56337335, 0x677776),\n    ivec4(0xCB2C2222, 0x11C9BC, 0x1000000, 0x45745715),\n    ivec4(0x88391035, 0x30153981, 0x56395355, 0x60677777),\n    ivec4(0xCCAC2222, 0x1111C9CC, 0x0, 0x39755715),\n    ivec4(0x88308835, 0x31809188, 0x35993913, 0x60677777),\n    ivec4(0xCCAC2222, 0x1011C0CB, 0x190, 0x30455705),\n    ivec4(0x88188893, 0x1888888, 0x33993989, 0x60676776),\n    ivec4(0xCCAC2222, 0x9300B9CB, 0x1B5, 0x98435603),\n    ivec4(0x88888880, 0x88888888, 0xA3991181, 0x60676746),\n    ivec4(0xCCCC2222, 0xBB9390CC, 0x11B3, 0x88757703),\n    ivec4(0x88181188, 0x88888888, 0x93198888, 0x676746),\n    ivec4(0xCCCC2282, 0xBB3B21CC, 0x110011D3, 0x88757405),\n    ivec4(0x88189010, 0x1118888, 0xB31A8888, 0x676746),\n    ivec4(0xCCCC2282, 0xCBBB29CA, 0x111100B9, 0x1755705),\n    ivec4(0x8898DB93, 0x33938188, 0x35898890, 0x657746),\n    ivec4(0xCCCC8222, 0xBBBBABC9, 0x110000C0, 0x9476705),\n    ivec4(0x88B099BB, 0x9BB38088, 0x558008DB, 0x11657746),\n    ivec4(0xCCCC8222, 0xBDCBBCCC, 0x10010A1, 0x9B437405),\n    ivec4(0x88188838, 0x88088888, 0x5789B89D, 0x81657747),\n    ivec4(0xCCCC8222, 0xCACCCCBC, 0x1190, 0xBBBB4403),\n    ivec4(0x88888888, 0x88888888, 0x5789B982, 0x88757747),\n    ivec4(0xCCCC8218, 0x91CCCCCC, 0x9110010, 0xB9BBBB9B),\n    ivec4(0x88888888, 0x88888888, 0x57891188, 0x22707746),\n    ivec4(0xCCCC8911, 0x11C9CCCC, 0x3010011, 0xA1BBCCBB),\n    ivec4(0x88888891, 0x88888888, 0x54158888, 0x22507646),\n    ivec4(0xCCCC8011, 0x1191CCCC, 0x9B001011, 0x98BBBBBB),\n    ivec4(0x88888800, 0x88888888, 0x64058888, 0x22507576),\n    ivec4(0xCCBC8011, 0x1111C9CC, 0xBC931111, 0x98BBBCCC),\n    ivec4(0x88111181, 0x11818888, 0x64058888, 0x22527567),\n    ivec4(0xCC3C1011, 0x111191CA, 0xBC3B1111, 0x18B3BBCC),\n    ivec4(0x33339388, 0xB9333399, 0x74958888, 0x22527767),\n    ivec4(0xCC3C1111, 0x11111191, 0xCCBC1911, 0x18B9BDCC),\n    ivec4(0xDDDD1388, 0xD3DDDDDD, 0x77958888, 0x28025564),\n    ivec4(0xC93C1111, 0x11111111, 0xCBCC9B11, 0x843CBBC),\n    ivec4(0xBBDB8988, 0xD9DDDDB3, 0x46558888, 0x28025574),\n    ivec4(0xC99B1111, 0x11111181, 0xCCCC3C10, 0x50449BC9),\n    ivec4(0x33338188, 0x383D3333, 0x76378088, 0x28125544),\n    ivec4(0xC99B1111, 0x11111111, 0xC9CCBC03, 0x43449B99),\n    ivec4(0x33938808, 0x18393333, 0x77341388, 0x22117547),\n    ivec4(0xB99B1111, 0x11111111, 0xCCCCCC9C, 0xDDBDBBBB),\n    ivec4(0x1918D3, 0x88189099, 0x74373489, 0x22117647),\n    ivec4(0x99931111, 0x19111111, 0xCCCCCCBC, 0xBDCBBCCC),\n    ivec4(0x889945D4, 0x80888888, 0x7D474434, 0x82185047),\n    ivec4(0x80001111, 0x13111111, 0xCCCCCCCC, 0xBDCCBBCC),\n    ivec4(0x39444444, 0x95091101, 0x4D4744D4, 0x88115047),\n    ivec4(0x80011811, 0x9B111111, 0xCCCCCCCC, 0xDDBBBBCC),\n    ivec4(0xDD444444, 0x9900930, 0xDD7444DD, 0x88115047),\n    ivec4(0x81008821, 0x3C111111, 0xCCACAACA, 0xBDBBCDCC),\n    ivec4(0x4D44DD44, 0x9B000030, 0x4474D4DD, 0x11115047),\n    ivec4(0x88121822, 0xA101101, 0x222288C2, 0x4D449B92),\n    ivec4(0x4D44DD44, 0xDD0300B0, 0x4444D7DD, 0x11115047),\n    ivec4(0x88822282, 0x82111101, 0x22228292, 0xDD442328),\n    ivec4(0xDD444DD4, 0xDDBD19B0, 0x4D4D34DD, 0x11115144),\n    ivec4(0x88222288, 0x82181101, 0x22222228, 0xDD441322),\n    ivec4(0xDDDD4DD4, 0xDDDD9DE0, 0x4DDD44DD, 0x11115144),\n    ivec4(0x88228228, 0x10111121, 0x22222228, 0xDD740328),\n    ivec4(0xDDDDDDDD, 0xDDDDDDEF, 0xDDDD34DB, 0x11115144),\n    ivec4(0x28222222, 0x11111181, 0x22222288, 0xDB7D0528),\n    ivec4(0xDDDDED33, 0xDDDDDDDD, 0xDDDD44D3, 0x111151D4),\n    ivec4(0x28222222, 0x18118180, 0x28228288, 0xDE7D0588),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xEEDB4DB3, 0x111151B4),\n    ivec4(0x92822222, 0x88880119, 0x88888888, 0xBF5D0588),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xFFBF4D34, 0x111131FB),\n    ivec4(0x92822222, 0x88010981, 0x88888888, 0xEF5D0381),\n    ivec4(0xDDDDFFFF, 0xDDDDDDDD, 0xFFEFDD34, 0x1181E0FE),\n    ivec4(0x88222822, 0x18908988, 0x88888888, 0xEF3D0318),\n    ivec4(0xDDEDFFFF, 0xEBEEDDDD, 0xFFEFDB3D, 0x8818E9EE),\n    ivec4(0x88288822, 0x18898088, 0x88888888, 0xEF3D9D81),\n    ivec4(0xEDEEFFFF, 0xEBEEEEDB, 0xFFFFDB4D, 0x8108FEEE),\n    ivec4(0x88188888, 0x18891088, 0x88888888, 0xEF3DEE80),\n    ivec4(0xFEFFFFFF, 0xE3EEFFEE, 0xFEFFDB4D, 0x8898FEEF),\n    ivec4(0x88188188, 0x18198088, 0x88888888, 0xEFBDEF89),\n    ivec4(0xFEFFFFFF, 0xFEFFFFEF, 0xFEFFBDDB, 0x88F8FFFF),\n    ivec4(0x88088188, 0x88008188, 0x88888888, 0xBFEDFF9F),\n    ivec4(0xFEFFFFFF, 0xFBFFFFEF, 0xEEEFEBDE, 0x88F8FFFF),\n    ivec4(0x88088188, 0x88188888, 0x80888888, 0xEFFDFFEF),\n    ivec4(0xEEFFFFFF, 0xFEFFFFEF, 0xEFEEFEDF, 0x88F1FFFF),\n    ivec4(0x88088188, 0x88918888, 0xF888888, 0xEEEEFFFF),\n    ivec4(0xEEFFFFFF, 0xFEFFFFEF, 0xFFFEFFBF, 0x88E9FFFF),\n    ivec4(0x88118888, 0x88998888, 0xFE818888, 0xFFEFFEFF),\n    ivec4(0xEFFFFFFF, 0xF9FFFFFF, 0xEEFEFF9F, 0x88FFFFEF),\n    ivec4(0x88108888, 0x8118088, 0xFF198888, 0xFFFFEEFF),\n    ivec4(0xFEEEFEFF, 0x99FFFFFF, 0x89F9FF9F, 0x98FEFFFF),\n    ivec4(0x18818888, 0x11880988, 0xFF9E8188, 0xFFFFEFFF),\n    ivec4(0xFEEEFEFF, 0x99FFFFFF, 0x10E9EE99, 0xF8FFFFFE),\n    ivec4(0x19888888, 0x80889099, 0xFFBF8918, 0xFFFFEFFF),\n    ivec4(0xFEEFFFFF, 0xF9FFFFFF, 0x1192EE9E, 0xE9FFFF9E),\n    ivec4(0x89888888, 0x88889800, 0xFFDE8908, 0xFFFFFFFE),\n    ivec4(0xFEEFFFFF, 0xFFFFFFFF, 0x888892EE, 0xFFFFEF8F),\n    ivec4(0x81888888, 0x88889888, 0xFFBF1981, 0xFFFFFFFE),\n    ivec4(0xFEEFFFFF, 0xFFFFFFFF, 0x10888898, 0xFEFFEF89),\n    ivec4(0x18888888, 0x88889888, 0x9F909981, 0xFFFFFFEE),\n    ivec4(0xEFEFFFFF, 0xFEFFFFFF, 0x19888828, 0xFFFFFF81),\n    ivec4(0x28888888, 0x88889188, 0x9109988, 0xFFFFFFEE),\n    ivec4(0xEFEFFFFF, 0xFEFFFFFF, 0x80888828, 0xFFFFFE88),\n    ivec4(0x28888888, 0x88889988, 0x108188, 0xFFFFFF3E),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x88888898, 0xFEFF9E88),\n    ivec4(0x28828888, 0x88889988, 0x818888, 0xFFFFFF9E),\n    ivec4(0xFFEFFEFF, 0xFEFFFFFF, 0x88888898, 0xFFEFFE88),\n    ivec4(0x88828888, 0x88282282, 0x888888, 0xFFFFFF03),\n    ivec4(0xFFEFFEFF, 0xFFFFFFFF, 0x88888898, 0x9F93B88),\n    ivec4(0x88228888, 0x88288882, 0x10888888, 0xFFFFEF03),\n    ivec4(0xFFEEFEFF, 0xEFFFFFFF, 0x888888A2, 0x11913B09),\n    ivec4(0x88A28288, 0x88222889, 0x10888888, 0xFFFFFE90),\n    ivec4(0xEEDDEDFE, 0xE9FFFFFF, 0x990992AA, 0x1899993B),\n    ivec4(0x88A28288, 0x88222229, 0x10888888, 0xEEEE0E18),\n    ivec4(0xEEEDEEEE, 0xE9FFFFEE, 0x9B9BB9C, 0x819993B)\n#endif\n);\n\n\n#ifdef ENABLE_VIBING_CAT\n\nconst int vibingCatBorderWidth = 2;\n\nconst int vibingCatBorderHeight = 2;\n\nconst int vibingCatBorderColorIndex = 0;\n\nconst int vibingCatImageWidth = 16;\n\nconst int vibingCatImageHeight = 16;\n\nconst int vibingCatImageCount = 147;\n\nconst int vibingCatRepeatAtImageIndex = 74;\n\nconst int vibingCatRepeatingFrameCount = vibingCatImageCount - vibingCatRepeatAtImageIndex;\n\nconst int vibingCatAnimationFrameCount = vibingCatImageCount + (vibingCatImageCount - vibingCatRepeatAtImageIndex);\n\nconst vec3 vibingCatBitmapPalette[] = vec3[]\n(\n        vec3(0.15294117647058825, 0.1411764705882353, 0.1450980392156863),\n        vec3(0.27450980392156865, 0.23137254901960785, 0.2196078431372549),\n        vec3(0.24313725490196078, 0.25098039215686274, 0.24705882352941178),\n        vec3(0.3137254901960784, 0.25882352941176473, 0.23921568627450981),\n        vec3(0.2196078431372549, 0.23921568627450981, 0.25882352941176473),\n        vec3(0.28627450980392155, 0.24313725490196078, 0.2549019607843137),\n        vec3(0.23529411764705882, 0.25882352941176473, 0.27450980392156865),\n        vec3(0.403921568627451, 0.34509803921568627, 0.32941176470588235),\n        vec3(0.5882352941176471, 0.45098039215686275, 0.41568627450980394),\n        vec3(0.6392156862745098, 0.5215686274509804, 0.4823529411764706),\n        vec3(0.5764705882352941, 0.49019607843137253, 0.5058823529411764),\n        vec3(0.49019607843137253, 0.5019607843137255, 0.5058823529411764),\n        vec3(0.6901960784313725, 0.596078431372549, 0.5568627450980392),\n        vec3(0.7843137254901961, 0.6941176470588235, 0.6588235294117647),\n        vec3(0.8196078431372549, 0.7686274509803922, 0.7333333333333333),\n        vec3(0.8784313725490196, 0.8509803921568627, 0.8196078431372549)\n);\n\nconst ivec4 vibingCatBitmapBits[] = ivec4[]\n(\n        ivec4(0xFFDEFFDE, 0xDCCCEB, 0xDFDCFFFF, 0xDBDDFE),\n        ivec4(0xBCFCFFEF, 0xD1FDFF, 0x17F7FFEF, 0x80FE9F),\n        ivec4(0x67FCFFCD, 0x70FEBE, 0xEDFFEF8C, 0x70FFEF),\n        ivec4(0xFFFF9D88, 0xD2FFFF, 0xFFFF9E87, 0xE3FFFF),\n        ivec4(0xFFFFCE88, 0x11FBFFFF, 0xFFFFCD89, 0x10FCFFFF),\n        ivec4(0xEFDD9C89, 0x20FCEFFF, 0xEFCDCC89, 0x78FCEEFE),\n        ivec4(0xDECD9C89, 0xCCFDEDFE, 0xDDCC9988, 0xCCEDDEED),\n        ivec4(0xCDCC8888, 0x99D9DECD, 0xCCC99888, 0x89C9CDCC),\n        ivec4(0xDEDCFFEF, 0xD7DDFE, 0xACEAFFDF, 0xC1EDEF),\n        ivec4(0x17FBFFCD, 0x80FDCF, 0x8BFDEF9C, 0x30FD9F),\n        ivec4(0xFEFFCE88, 0x70FFEF, 0xFFFF9E88, 0x90FFFF),\n        ivec4(0xFFFF9D88, 0x20D3FFFF, 0xFFFFCD89, 0x10F7FFFF),\n        ivec4(0xEFDE9D88, 0xF9FFFF, 0xFFDD9C89, 0x30FCEFFF),\n        ivec4(0xDECC9C89, 0x36FADEFF, 0xDECC9C88, 0x7AFCEEFE),\n        ivec4(0xDDCC8988, 0xCCEDDEDD, 0xDDCC8988, 0xC9DCDECD),\n        ivec4(0xCC9C9989, 0x98CCCECC, 0xCC999C89, 0x9C99CDCC),\n        ivec4(0x8CC8FFCE, 0x90DDFE, 0x1AE3EF9C, 0x30EDDF),\n        ivec4(0xACFECF88, 0xFCDF, 0xFFFFCF88, 0x10FDFF),\n        ivec4(0xFFFFDE88, 0x71FFFF, 0xFFFFCD89, 0x71FFFF),\n        ivec4(0xEFDECD89, 0xD2FFFF, 0xFFDD9C89, 0xF7FFFE),\n        ivec4(0xDFCD9C88, 0x32E7EFFE, 0xDECC9988, 0xE3DFFE),\n        ivec4(0xDECC8988, 0x53F7DEDD, 0xCDCC8988, 0xA9D7DECD),\n        ivec4(0xCDCC9C99, 0xCCDCDECD, 0xCCCC9C9C, 0x99CCDECC),\n        ivec4(0xCCCC9C9C, 0x9999DD9C, 0xCC99999C, 0x9C98DCCC),\n        ivec4(0x79A3EF9C, 0x70DDEF, 0x79EBDF78, 0xDCDF),\n        ivec4(0xFFFFDF79, 0xE9FF, 0xFFFFDE89, 0x30FCFF),\n        ivec4(0xFFDECD89, 0x30FDFE, 0xFFDECC89, 0x30FFEE),\n        ivec4(0xEFCD9C89, 0xC2FFEE, 0xDFCD9C88, 0x10C3FFED),\n        ivec4(0xDECC8988, 0xA0DFED, 0xDDCC8988, 0x10D3DEDD),\n        ivec4(0xCCCC9988, 0x7C2DECC, 0xCC9C9999, 0x8A87DECC),\n        ivec4(0xCCCCCC9C, 0x9C9CEDCC, 0xCCC9CC99, 0x89C9DDCC),\n        ivec4(0x9C9CCC99, 0x8998DC9C, 0xCC999999, 0x9C88D9CC),\n        ivec4(0x39C3DF88, 0x70DDEF, 0xACFDCF77, 0xDCDF),\n        ivec4(0xFFFFDE89, 0xFAFF, 0xFFEFCE89, 0x10FCFF),\n        ivec4(0xFFDD9D89, 0x10FDFE, 0xEFCD9C89, 0x70FFEE),\n        ivec4(0xEFCD8988, 0xC1EFEE, 0xDE9D8988, 0xB1EFED),\n        ivec4(0xDDCC8888, 0xA0DFDD, 0xDCCC8988, 0x11C0DECD),\n        ivec4(0xCC9C9999, 0x193DECC, 0xCCC9CC99, 0x8A77DECC),\n        ivec4(0xC99CCC9C, 0xC989DDCC, 0xCCCCCC99, 0x89C9DCCC),\n        ivec4(0xC999C999, 0x8998DCCC, 0x9C999999, 0x9C88C9CD),\n        ivec4(0x39E79F87, 0x30DDEE, 0xCDFF9E87, 0xD9EF),\n        ivec4(0xFFFFCE88, 0x10FBFF, 0xFFEE9D89, 0x10F9EF),\n        ivec4(0xEFCD9C88, 0xFDFE, 0xEFCD9C88, 0x80FFEE),\n        ivec4(0xDFCC8878, 0xC2FFED, 0xDECC8878, 0x70EFDD),\n        ivec4(0xDD9C8888, 0x1092DFDD, 0xCC9C9988, 0x1C0DECC),\n        ivec4(0xCCC99999, 0x1083DECC, 0x9CCCCC9C, 0x7A33DDCC),\n        ivec4(0xCCC9CC9C, 0xCC89DCCC, 0x9CCC9C9C, 0x9899ECCC),\n        ivec4(0x9C999C99, 0x8899DCCC, 0x9C999999, 0x8C88C9CC),\n        ivec4(0x39E88F77, 0x10DDEF, 0xEEFFDF88, 0xD9EF),\n        ivec4(0xFFEFCD88, 0xFBFF, 0xFFDE9D88, 0x10F9EF),\n        ivec4(0xEFCD9C88, 0x20FCFE, 0xEFCD9988, 0x70FFFE),\n        ivec4(0xDE9C8878, 0xC3EFED, 0xDECC8888, 0x70EFDD),\n        ivec4(0xDD9C8888, 0x1095DFCD, 0xCC9C9C99, 0x1C0DECC),\n        ivec4(0x9C9CCC99, 0x3073DFCC, 0xCCCCCCC9, 0x7A11DDCC),\n        ivec4(0xC9C9CC9C, 0x9C8AECCC, 0xCCCC9C9C, 0x99C9DCCD),\n        ivec4(0xCCC9C999, 0x8899D9CD, 0x9C999999, 0x8C88C9CD),\n        ivec4(0x39E8CF77, 0x10DDEE, 0xFEFFDF89, 0x10D9FF),\n        ivec4(0xFFEFCE88, 0xF7FF, 0xFFDECC88, 0xF8EF),\n        ivec4(0xEFCE9C88, 0x20FCFE, 0xEFCD9988, 0x70FFEE),\n        ivec4(0xDECD8887, 0xA0FFED, 0xDDCC8888, 0x70DFDD),\n        ivec4(0xDCCC9998, 0x1082DFCD, 0xCC9C9999, 0xA1DFCC),\n        ivec4(0x9CCCCC9C, 0x1073EECC, 0xCCCCCCC9, 0x7A10ECCC),\n        ivec4(0xCCC9CC9C, 0xC98AE9CC, 0xCCCC9C9C, 0x99C9D9CD),\n        ivec4(0xCCC9C999, 0x8899DCCD, 0x9C999999, 0x8C88C9CD),\n        ivec4(0x7CE7CF78, 0x10DCFE, 0xFEFFDF8C, 0x10D9FF),\n        ivec4(0xFFEFCE89, 0xF7FF, 0xFFEECC88, 0xF8EF),\n        ivec4(0xEFCE9C88, 0xF9EF, 0xEFCD9C88, 0x30FFEF),\n        ivec4(0xDFCD8887, 0xB0EFDD, 0xDDCC8988, 0x70EEDD),\n        ivec4(0xDCCC9999, 0x1073DFCD, 0xCC9CC999, 0xA0DFCC),\n        ivec4(0x9CCCCC9C, 0x1033EECD, 0xCCCCCC9C, 0x7A11ECCC),\n        ivec4(0xC99CCCCC, 0x9C89E8CC, 0xCC9CCCC9, 0x99C9DCCD),\n        ivec4(0xCCCCC999, 0x8899D9DD, 0x9C999999, 0x9C88C9CD),\n        ivec4(0x7CFBDF78, 0xDCFE, 0xFFFFDF89, 0xD8FF),\n        ivec4(0xFFEFCD89, 0xE7FF, 0xFFDECC89, 0x10F7EF),\n        ivec4(0xFFDD9988, 0xF9EF, 0xEFCD9978, 0x30FEEF),\n        ivec4(0xDECD8888, 0x70EFDD, 0xDD9D9988, 0x70EEDD),\n        ivec4(0xCCCC9999, 0x1171DFCD, 0xCCCCCC9C, 0xB0EECC),\n        ivec4(0xCC9CCCCC, 0x1131EDCD, 0xCCCCCCCC, 0x8901E9CC),\n        ivec4(0xCCCCCCC9, 0xC999E8CD, 0xCCCCCCCC, 0x98C9DCCD),\n        ivec4(0xCC9CC999, 0x8998D9DD, 0x9C999999, 0x9C88C9CC),\n        ivec4(0xACFDEF89, 0x10DDFF, 0xFFFFCF89, 0xE9FF),\n        ivec4(0xFFEECD88, 0xF8FF, 0xFFDE9C89, 0x10FAEF),\n        ivec4(0xFFCD9C88, 0x10FDEF, 0xEFCD8988, 0x80FFEE),\n        ivec4(0xDECD8988, 0x70FFDD, 0xDDCC9998, 0xB1EFDD),\n        ivec4(0xCCCCC999, 0x1180DFCC, 0xCCCCCC9C, 0xB1EEDC),\n        ivec4(0xCCC9CCCC, 0x1331EECC, 0xCCCCCCCC, 0xA913ECCC),\n        ivec4(0xCCCCCCCC, 0x9C8CE9CD, 0xCCCCCCCC, 0x99C9DCCD),\n        ivec4(0xCCCCC999, 0x8C99D9DD, 0xCC999999, 0xCC88C9DC),\n        ivec4(0x7AF9DF79, 0x80EDDF, 0xFEFFEF8C, 0x70FDFF),\n        ivec4(0xFFFFDE8C, 0x71FEFF, 0xFFEFCD89, 0x71FEFF),\n        ivec4(0xFFDECC89, 0xB0FFFF, 0xFFCDCC89, 0xD3FFFE),\n        ivec4(0xEFCD8988, 0x20F7EFFE, 0xDECC9988, 0x10E7EFEE),\n        ivec4(0xDDCD9999, 0x23E7DFDD, 0xCCCCC999, 0xF8DECC),\n        ivec4(0xCCCCCCCC, 0x37C7DFDC, 0xCCCCCCCC, 0x9997DFCD),\n        ivec4(0xCCCCCCCC, 0xC9CCDECD, 0xCCCCCCCC, 0x99C9DDCD),\n        ivec4(0xCCCCCC99, 0x8C99DCCD, 0xCC999999, 0xCC89CCCD),\n        ivec4(0x89D8FFDF, 0xD8FDEF, 0x38E7FFCE, 0xD3FECF),\n        ivec4(0xEDFFEF8C, 0xC1FFDF, 0xFFFFFF8C, 0x10C1FFFF),\n        ivec4(0xFFFFEF9D, 0x40E3FFFF, 0xFFFFDE9C, 0x10E7FFFF),\n        ivec4(0xFFDEDD9C, 0x20FAFFFF, 0xFFDECC99, 0x71FDFFFE),\n        ivec4(0xEFDDCC99, 0x74FEEFFF, 0xEECD9C89, 0x71FDDFFE),\n        ivec4(0xDDCD9C89, 0x77FEDEDD, 0xDDCC9C99, 0xCCFEDEDD),\n        ivec4(0xCCCCCCC9, 0xCCFDDECC, 0xCDCCCCCC, 0x99ECDECC),\n        ivec4(0xCCCCCCCC, 0x9CC9DDCC, 0xCC999999, 0xCDC9DDCC),\n        ivec4(0x9DDCFFFF, 0xDDEDEF, 0x78C7FFFF, 0xD9FEDF),\n        ivec4(0x13F7FFDE, 0xE7FF8D, 0xECFFFF9D, 0xD3FFDF),\n        ivec4(0xFFFFEF79, 0xF7FFFF, 0xFFFFFFCE, 0x72FAFFFF),\n        ivec4(0xFFFFEFCD, 0x34FDFFFF, 0xFFFFDECD, 0x70FEFFFF),\n        ivec4(0xFFDEDD9C, 0xB2FFFFFF, 0xFFDECC9C, 0xC7FFEFFF),\n        ivec4(0xEFDDCC9C, 0xCBFFEEFF, 0xEECDCC99, 0xDCFFDEFE),\n        ivec4(0xDDCD9C89, 0xECEFDDED, 0xDDCD9C89, 0xC9EEDDDD),\n        ivec4(0xCC9C9C99, 0xCCEDDDCC, 0xCCC99999, 0xCDDCCDCC),\n        ivec4(0x7CC8FFEF, 0xD9FDEF, 0x17C7FFDF, 0xD7FF9F),\n        ivec4(0xB9FEFF9D, 0xD1FFCE, 0xFFFFFF8D, 0xD5FFFF),\n        ivec4(0xFFFFFFCD, 0x21F7FFFF, 0xFFFFFFCD, 0x31FAFFFF),\n        ivec4(0xFFEFDECD, 0x64FDFFFF, 0xFFEFDDCC, 0x70FEFFFF),\n        ivec4(0xEFDECD9C, 0xA2FFEFFF, 0xFFDDCC9C, 0xC7FFEFFF),\n        ivec4(0xDFDDCC9C, 0xCBFFEEFF, 0xDECD9C99, 0xDCFFDEFE),\n        ivec4(0xDECD9C89, 0xECEFDDDD, 0xDDCC9C89, 0xC9EEDDDD),\n        ivec4(0xCCCC9C99, 0xCDEDCDCC, 0xCC9C9989, 0xCDDDCDCC),\n        ivec4(0x78C7FFCE, 0x90EDDF, 0xDDFFFFCE, 0x80FDEF),\n        ivec4(0xFFFFFFDE, 0x1080FFFF, 0xFFFFEECD, 0x10A2FFFF),\n        ivec4(0xFFEFEDCC, 0x10C6FFFF, 0xFFEFDD9C, 0xE3FFFE),\n        ivec4(0xFFDDCC9C, 0x20FBFFFE, 0xFFDDCC9C, 0x31FCFFFD),\n        ivec4(0xEFDD9C99, 0x74FEEEFE, 0xDECD9C89, 0x75FDDFEE),\n        ivec4(0xDDCD9C89, 0xB8FEDEDD, 0xDCCC9C89, 0xCCFEDDDC),\n        ivec4(0xDCCC9C99, 0xC9EDDDCC, 0xCDCCC999, 0xC9ECDECC),\n        ivec4(0xC9C9999C, 0xCDD9CDCC, 0x99999999, 0xDCCCCDCC),\n        ivec4(0xEEFEEFDE, 0x10DCEE, 0xFFFFDECD, 0x10E9FF),\n        ivec4(0xFFEFDDCC, 0x20FCFE, 0xFFDECDAC, 0x30FDEE),\n        ivec4(0xFFDECC99, 0x70FEDE, 0xEFCDCCAA, 0xA1FFDE),\n        ivec4(0xEFCE9C88, 0xE7EFDD, 0xDDCD9C88, 0x10E7EFDD),\n        ivec4(0xCDCD9988, 0x62E7DECD, 0xCCCC9C88, 0x1F7DECC),\n        ivec4(0xCCCC9999, 0x7AEBCECC, 0xCC999999, 0xC9DCDECC),\n        ivec4(0x9C9C9999, 0x98C9DECC, 0x99999C9C, 0x89C8DDCC),\n        ivec4(0x9C999999, 0xCD98DC9C, 0x99999989, 0xCC8CC99C),\n        ivec4(0xFEEFDECD, 0xD8FE, 0xFFEFDDAC, 0xE7EF),\n        ivec4(0xFEDECD89, 0x10FBEE, 0xFEDEACA9, 0xF8DE),\n        ivec4(0xEEDD9C88, 0x60FEDE, 0xEECDA988, 0x80FFDD),\n        ivec4(0xDDCD8988, 0xB2DFDD, 0xCCCC8C88, 0x11B2DFCD),\n        ivec4(0xCCCC8988, 0xC1DECC, 0x9C9C9999, 0x10D3DECC),\n        ivec4(0x9C999899, 0x7873DECC, 0x99999999, 0x99B8DECC),\n        ivec4(0x9999C999, 0x8899DDCC, 0x99C99999, 0x8898DCCC),\n        ivec4(0x99999999, 0xCD88C9CC, 0x99999989, 0xCC9998CC),\n        ivec4(0xFEEFDD8C, 0xD3FE, 0xFEDECD8A, 0xE3EF),\n        ivec4(0xFEDD9C88, 0xE3EE, 0xEECDAC88, 0xF3DE),\n        ivec4(0xEECD8978, 0x70FDDE, 0xDDCC8987, 0x70EEDD),\n        ivec4(0xDC9C8988, 0x76DECD, 0xCCCC8988, 0x70DFCC),\n        ivec4(0x9C898888, 0xB1DE9C, 0x99899999, 0x171DE9C),\n        ivec4(0x99999999, 0x3710EDCC, 0x99999999, 0x9978DC9C),\n        ivec4(0x89999999, 0x8899DC9C, 0x99999999, 0x8888D9CC),\n        ivec4(0x99999898, 0x8C88C8CC, 0x99898988, 0xCC8998CC),\n        ivec4(0xFEEECD89, 0xC1FE, 0xFEDE9C8A, 0xC3EF),\n        ivec4(0xFEDDAC88, 0xC2DF, 0xEECD8A78, 0xE1DF),\n        ivec4(0xDECD8878, 0x20FCDE, 0xCDCC8887, 0x30EECD),\n        ivec4(0xCCCC8888, 0x24EDCD, 0xCC9C9888, 0x70DECC),\n        ivec4(0x99899899, 0x72DE9C, 0x99899999, 0x11ED9C),\n        ivec4(0x99999999, 0x710ECCC, 0x99999999, 0x8917D89C),\n        ivec4(0x99999999, 0x98A8D89C, 0x99999999, 0x8898C9CD),\n        ivec4(0x99999898, 0x898898CD, 0x99898988, 0xCC8888CC),\n        ivec4(0xFFEFCE89, 0x91FD, 0xFEDECC8A, 0xA0FF),\n        ivec4(0xFEDE9C88, 0xB0EF, 0xEECD8978, 0xD1DF),\n        ivec4(0xEDCD8987, 0xFBDF, 0xDCCC8988, 0x10FCDD),\n        ivec4(0xCCCD8988, 0x1020FACD, 0xCCA99899, 0x30EDCC),\n        ivec4(0x99899999, 0x32EECC, 0x9999C999, 0x10F9CD),\n        ivec4(0x9C999C9C, 0x300E8CD, 0x99C99999, 0x8907D39D),\n        ivec4(0x9CC9C999, 0x999997CD, 0x9C9C9999, 0x8898C9DD),\n        ivec4(0xCC999999, 0x898899CD, 0x9C999988, 0xCC8898C9),\n        ivec4(0xFFEFDE9C, 0x1080FD, 0xFFEFCD8A, 0x70FF),\n        ivec4(0xFEDFCC88, 0x70EF, 0xFDDEAC78, 0xA0FF),\n        ivec4(0xDDCD8C88, 0xF7EF, 0xDCCD8C88, 0xFBDE),\n        ivec4(0xCCCD8C99, 0x1E7CE, 0xCC999899, 0x10FCCD),\n        ivec4(0xCC99999C, 0x21ECCD, 0x9C99CC9C, 0xF7CE),\n        ivec4(0x9C9C9C9C, 0x1300E7CD, 0x9C9C9C9C, 0x8A03C1CD),\n        ivec4(0x9C9C9C9C, 0x998987CD, 0xCCCCC999, 0x889999DD),\n        ivec4(0xCC9C9999, 0x8888C8DC, 0xCC999999, 0xCC8898C9),\n        ivec4(0xFFFFDE9D, 0x1B0ED, 0xFFFFDEAC, 0x80FE),\n        ivec4(0xFFEFCD89, 0x30FF, 0xFEDFCC8A, 0x30FF),\n        ivec4(0xEDDE9C88, 0xE7FF, 0xDDCE9C88, 0xF7EF),\n        ivec4(0xCCDD9C99, 0x21E7DE, 0xCCCC9999, 0x100FBCE),\n        ivec4(0xCC9999CC, 0x31FCCD, 0xCCC9CCCC, 0x1F7CE),\n        ivec4(0xCC9CC9CC, 0x310E3CF, 0xCCC9CCC9, 0x7A07C1CE),\n        ivec4(0xCCC9CCC9, 0x9C8977CE, 0xCDCC9C9C, 0x989999DD),\n        ivec4(0xCC9C9C99, 0x8898C8DC, 0xCC9C9999, 0xCC8898D9),\n        ivec4(0xFFFFEFCD, 0xA0ED, 0xFFFFDFCC, 0x81FD),\n        ivec4(0xFFEFDE99, 0x70FF, 0xFEEFCD8A, 0xFF),\n        ivec4(0xFEEECC88, 0xD3FF, 0xEDDE9C88, 0xF7EF),\n        ivec4(0xDCDD9C99, 0x60F7EE, 0xCCDC9C99, 0x100F7DF),\n        ivec4(0xCC9999CC, 0x30F9DD, 0xCCCCCCCC, 0x11FBCE),\n        ivec4(0xCC9CCCCC, 0x100E3DF, 0xCCCCCCCC, 0x7803C1CE),\n        ivec4(0xCCCCCCC9, 0xCC8983CF, 0xCCCCCCCC, 0x9999A9DD),\n        ivec4(0xCDCCC999, 0x889899DD, 0xCD9C9999, 0x9D8898CC),\n        ivec4(0xEFFFFFCE, 0x90ED, 0xFFFFEFCC, 0x1181FE),\n        ivec4(0xFFEFCE9C, 0xB0FF, 0xFEFFCDAC, 0x30FF),\n        ivec4(0xFEDE9D88, 0xD2FF, 0xEEDE9C8A, 0xF7EF),\n        ivec4(0xDDDE9C98, 0x10FBDF, 0xCCCDCC99, 0x100F7DE),\n        ivec4(0xCC9C99CC, 0x20FCDD, 0xCCCCCCCC, 0x11FACE),\n        ivec4(0xCCCCCCCC, 0x1100E7DF, 0xCCCCCCCC, 0x7813D1CE),\n        ivec4(0xCCCCCCCC, 0xCC8983CF, 0xCDCCCCCC, 0x99999CDD),\n        ivec4(0xCD9C9C9C, 0x889899DD, 0xCC9C9C99, 0x9D8898DC),\n        ivec4(0xDFDDFFEF, 0xD1FD, 0xFFFFFFDF, 0xC1FE),\n        ivec4(0xFFFFEECD, 0x10C2FF, 0xFFFFDFCC, 0x91FF),\n        ivec4(0xFFEFCD9C, 0xE4FF, 0xFFEFCD9A, 0x30FAFF),\n        ivec4(0xFEDECC89, 0x20FDEF, 0xDDDDCD99, 0x1073FADF),\n        ivec4(0xDDCDCC9C, 0x130FEDE, 0xCCCCCCCC, 0x1073FEDD),\n        ivec4(0xCCCCCCCC, 0x3712FADE, 0xCCCCCCCC, 0x8917F7DE),\n        ivec4(0xCCCCCCCC, 0xC99CD8DE, 0xCCCCCCCC, 0x99CCDCDE),\n        ivec4(0xDDCCCCCC, 0x8C99C9DD, 0xCDC9CCC9, 0xCD89C9DC),\n        ivec4(0xEF79EBFF, 0x10ECFD, 0xDFA9FDFF, 0x10D8FE),\n        ivec4(0xFFFFFFFF, 0x10E7FF, 0xFFFFFFFF, 0x10E7FF),\n        ivec4(0xFFFFEFDE, 0x40F7FF, 0xFFFFEFDD, 0x11F7FF),\n        ivec4(0xFFFFDECC, 0x70FFFF, 0xFFFFDDCC, 0x10B0FFFF),\n        ivec4(0xFEEECD9C, 0x10B1FFEE, 0xEDDECD9C, 0x11B5FFEE),\n        ivec4(0xDDDDCC9C, 0x7793FFDD, 0xDCCCCCCC, 0x9CA8FEDE),\n        ivec4(0xDCCCCCCC, 0xCCCCFEDD, 0xCCCCCCCC, 0x99CCFDDE),\n        ivec4(0xCCCCCCCC, 0x9C99ECDD, 0xCCCCCCC9, 0xDD99D9CD),\n        ivec4(0xFFDECCFF, 0x90DDED, 0xEFACDAFF, 0x70DEFE),\n        ivec4(0xCE37E7FF, 0x10EDFF, 0xCE9BFDFF, 0xECFF),\n        ivec4(0xFFFFFFFF, 0x10FAFF, 0xFFFFFFFF, 0x1031FAFF),\n        ivec4(0xFFFFFFFF, 0x74FEFF, 0xFFFFFFEF, 0x71FFFF),\n        ivec4(0xFFFFEEDD, 0xC4FFFF, 0xFFFFDFCD, 0x11D7FFFF),\n        ivec4(0xFFEFDDCC, 0x37F7FFEE, 0xFEEFDDCC, 0x9CEAFFEE),\n        ivec4(0xDEDECDCC, 0xCCFDEFDD, 0xDDDDCDCC, 0x99ECEFDD),\n        ivec4(0xCCCCCCCC, 0x9DD9EEDD, 0xCCCC9C9C, 0xDDC9DDCD),\n        ivec4(0xFFDFCCFE, 0x90DEDD, 0xFFCCCCFF, 0x70DEFE),\n        ivec4(0xCF78D7FF, 0x30EDFF, 0xAD11D3FF, 0xEDFF),\n        ivec4(0xCDCBFFFF, 0xF9FF, 0xFFFFFFFF, 0x10FAFF),\n        ivec4(0xFFFFFFFF, 0x4075FFFF, 0xFFFFFFFF, 0x1071FFFF),\n        ivec4(0xFFFFFFEF, 0xA2FFFF, 0xFFFFEFEE, 0xD7FFFF),\n        ivec4(0xFFFFEEDD, 0x77FBFFFF, 0xFFFFDECC, 0xCCFCFFEF),\n        ivec4(0xFFEFDDCC, 0xC9FEEFED, 0xFEDECDCC, 0x99FDEFDE),\n        ivec4(0xDDDDCD9C, 0xCDECDEDD, 0xCCCDCC99, 0xDDCCDECD),\n        ivec4(0xFFCDCCFF, 0x70DDED, 0xDF7897FF, 0xEDFE),\n        ivec4(0x9E37D7FF, 0xDCFF, 0xCECAFEFF, 0xD8FF),\n        ivec4(0xFFFFFFFF, 0x1FBFF, 0xFFFFFFFF, 0x51FBFF),\n        ivec4(0xFFFFFFEF, 0x31FDFF, 0xFFFFFFDE, 0x30FEFF),\n        ivec4(0xFFFFDEDD, 0xA2FFFF, 0xFEFFDECD, 0x11C7FFEF),\n        ivec4(0xFFEFDDCC, 0x77F7FFEE, 0xFEEFCDCC, 0x99EAFFDE),\n        ivec4(0xEEDECDCC, 0xC9FDEFDD, 0xDDDDCD9C, 0x99ECEFDD),\n        ivec4(0xCDDCCC9C, 0xCDCCDECD, 0xCCCC9C99, 0xDDCCDDCD),\n        ivec4(0xEF7997FF, 0xDCED, 0x9E37D7FF, 0xD8FD),\n        ivec4(0xCFCCFEFF, 0xC7FE, 0xFFFFFFEF, 0xD3FF),\n        ivec4(0xFFFFEFEE, 0x40E3FF, 0xFEFFEFDD, 0x10F7FF),\n        ivec4(0xFEEFDECD, 0x10FBEF, 0xFEFFCECC, 0x30FDEF),\n        ivec4(0xFEEECD9C, 0xB4FFDE, 0xFDDECD9C, 0x181FFDE),\n        ivec4(0xEDDDCD99, 0x13A5FFDD, 0xDDDDCC99, 0x99CAFFDD),\n        ivec4(0xCCCCCC99, 0x99DCDFCD, 0xCCCCCC99, 0x98C9EECD),\n        ivec4(0xCCCC9999, 0x9D99DDCD, 0xC9999999, 0xDD9CD9CC),\n        ivec4(0xDE78D7EF, 0xDAEC, 0x9E37FCDF, 0xC7FD),\n        ivec4(0xEEFEEFEF, 0xC3FD, 0xFFFFEEDE, 0xD0FF),\n        ivec4(0xFFFFDECD, 0xD2FF, 0xFEEFDDAC, 0xE7EF),\n        ivec4(0xFDDFCD9C, 0xF7EF, 0xFDDECC9A, 0x10FDDF),\n        ivec4(0xEDDECC89, 0x70FEDE, 0xDCDDCC89, 0x70EEDD),\n        ivec4(0xCCCC9C89, 0x3772EFDD, 0xCCCC9C89, 0x7887DFCC),\n        ivec4(0xCC9C9999, 0x9999EDCC, 0xCC999999, 0x9899EDCD),\n        ivec4(0x99999999, 0x8988D9CD, 0x99999999, 0xCD89C89D),\n        ivec4(0xCF78FA8E, 0xCCDD, 0xAEB7FECE, 0xD8ED),\n        ivec4(0xEEFEEFCE, 0xC7FD, 0xFFFFDDAD, 0xD1FF),\n        ivec4(0xFEEFCD9C, 0x40D6FF, 0xFEDECD9A, 0xE1EF),\n        ivec4(0xFEDE9C89, 0xF7DF, 0xEEDDAC89, 0x10FDDE),\n        ivec4(0xDDCD8C88, 0x70FEDD, 0xDCCC9C88, 0x1031EECD),\n        ivec4(0xCCCC9988, 0x170EFCD, 0xC9999999, 0x3383DECC),\n        ivec4(0xCC999999, 0xA978ECCC, 0x9C999999, 0x9899ECCD),\n        ivec4(0x99999999, 0x8898D99D, 0x99898989, 0x8C88C8CC),\n        ivec4(0xCE78FE79, 0x10DCEC, 0xBDD7EFAD, 0xCCFD),\n        ivec4(0xEDFEEF9C, 0xDBFD, 0xFFEFDD9A, 0xD3FF),\n        ivec4(0xFFEECC89, 0x20E7EF, 0xFEDEAC89, 0xF1EF),\n        ivec4(0xEFCD8C88, 0xFBDF, 0xDECD8C78, 0x30FEDE),\n        ivec4(0xDDCC8988, 0x71EFDD, 0xCCCD8988, 0x1131EFCC),\n        ivec4(0xCC9C8989, 0x84DFCC, 0x9C999899, 0x1381DECC),\n        ivec4(0x9C999999, 0x7937EDCC, 0x9999C999, 0x9989ECCC),\n        ivec4(0x99999999, 0x8898DC9C, 0x99898989, 0x8888C9CC),\n        ivec4(0xCEB8EE78, 0xDCDC, 0xBDD7EF8C, 0xCCFD),\n        ivec4(0xEDFEDF8C, 0xDBFD, 0xFFEFCD8A, 0xD3FF),\n        ivec4(0xFFEECC8A, 0x40E7EF, 0xEFCEAC88, 0xF1EF),\n        ivec4(0xEFCD8978, 0x10FADE, 0xDECD8978, 0x10FEDE),\n        ivec4(0xDDCC8888, 0x72EFDD, 0xCCCC8988, 0x1130EFCC),\n        ivec4(0xCC998989, 0xB1DFCC, 0x9C999999, 0x3371DECC),\n        ivec4(0x9C99C999, 0x8837EDCC, 0x99999C99, 0x9989ECCC),\n        ivec4(0x99999999, 0x8898DC9C, 0x99899998, 0x8888C99C),\n        ivec4(0xEEBCFE9D, 0xDCDC, 0xAEA3EF7A, 0xC8ED),\n        ivec4(0xCEFCEF8C, 0xD7FD, 0xFFFFDE8C, 0xD0FF),\n        ivec4(0xFFEECD89, 0x10D6FF, 0xFFDEAC8A, 0xE1EF),\n        ivec4(0xFFCE9C78, 0xF7DF, 0xEECD8987, 0x10FCDF),\n        ivec4(0xDDCC8988, 0x70FEDD, 0xDCCC8988, 0x1011EECD),\n        ivec4(0xCC9C9998, 0x70EFCC, 0x9C999999, 0x3373EDCC),\n        ivec4(0xCCC9C99C, 0x9937E9CD, 0x99C9C999, 0x9999ECCD),\n        ivec4(0x99999999, 0x8898D9CC, 0x99999999, 0x8888C9CC),\n        ivec4(0xFDCDFDDE, 0xDCB9, 0xDEB8FEAD, 0xD9ED),\n        ivec4(0xBDC7EF79, 0xDBFD, 0xEFFFFF9C, 0xC3FE),\n        ivec4(0xFFFFDE89, 0xD2FF, 0xFFEFCD8A, 0xE3FF),\n        ivec4(0xFFDE9C89, 0xF2EF, 0xFFDDAC78, 0xF9EF),\n        ivec4(0xEECD8988, 0x20FDDE, 0xDDCD8988, 0x70FDDE),\n        ivec4(0xCCCD9989, 0x1310EECD, 0xCC9CC999, 0x3373EECC),\n        ivec4(0xCCC9C99C, 0x9978F9CD, 0xCCC9C99C, 0x999CECCD),\n        ivec4(0x99C99999, 0x8899D9CD, 0x99999999, 0x8888C9CC),\n        ivec4(0xFCDEFEEF, 0x30CD23, 0xEFCCFFCF, 0xDDDC),\n        ivec4(0xBDC7EF89, 0xDCFE, 0xADF9DF7A, 0xDAFE),\n        ivec4(0xFFFFDF8C, 0xE7FF, 0xFFFFDE8A, 0xE3FF),\n        ivec4(0xFFEECD89, 0x40F7FF, 0xFFDFAC88, 0xF8FF),\n        ivec4(0xEFCD8C78, 0x30FFEF, 0xEECD8988, 0x30FFDE),\n        ivec4(0xDDCD8988, 0x1072FEDD, 0xCCCCC999, 0x1770EFCD),\n        ivec4(0xCCC9C99C, 0x8888EDDC, 0xCCCCCC9C, 0xC99CFCCD),\n        ivec4(0xC9999C9C, 0x89C9DCCD, 0x99999999, 0x8898D9CC),\n        ivec4(0xECDFFFEF, 0x707D20, 0xEFDCFFCF, 0x70DDDC),\n        ivec4(0xBEE7EF8C, 0x60DDFE, 0x7CF8AF87, 0xDCEF),\n        ivec4(0xFFFFDF88, 0x10EBFF, 0xFFFFCE89, 0xF7FF),\n        ivec4(0xFFEFCD88, 0x10FBFF, 0xFFCF9C88, 0x10FCFF),\n        ivec4(0xEFCD8C88, 0x70FFFF, 0xEECD8978, 0xB0FFEE),\n        ivec4(0xDDCC8888, 0x81FFDD, 0xDDCC9999, 0x3780EFCD),\n        ivec4(0xCCCCC999, 0x8897DFCD, 0xCC9CCC9C, 0xCCACFDCC),\n        ivec4(0x9C9C9C9C, 0x9899EDCD, 0x99999999, 0x8898DC9C),\n        ivec4(0xFEEEFFEF, 0x907D70, 0xDFDCFFCE, 0xA0DDFC),\n        ivec4(0x7CFBDF89, 0xB0DDFE, 0x3AFD8D87, 0xECEF),\n        ivec4(0xFFFFCE78, 0x20FCFF, 0xFFFFCE88, 0x10FCFF),\n        ivec4(0xFFEE9C88, 0x40FDFF, 0xFFDE9C78, 0x30FEFF),\n        ivec4(0xEFCD8988, 0xC4FFFE, 0xEE9C8978, 0xC1FFFE),\n        ivec4(0xDD9C8888, 0xC6EFDD, 0xDDCC9989, 0x37D1DFCD),\n        ivec4(0xCC9C9C9C, 0x88D8DECC, 0xCC9CCC9C, 0xC99CEFCC),\n        ivec4(0x9C9C9C9C, 0x98C9EDCC, 0x99999999, 0x8898DCCC),\n        ivec4(0xFEEFFFEF, 0xD37CB0, 0xDFDCFFFF, 0xD1DDEC),\n        ivec4(0xADFAFFCE, 0xC0DDFF, 0x18FBEF9D, 0x70EEEF),\n        ivec4(0xCCFF9F88, 0x70FDDF, 0xFFFFCF88, 0x30FEFF),\n        ivec4(0xFFFFCE88, 0x74FFFF, 0xFFEF9D8A, 0x71FFFF),\n        ivec4(0xFFDD9C88, 0xE5FFFF, 0xFFCDAC88, 0x10F7FFFF),\n        ivec4(0xDECC8988, 0x3F7EFFE, 0xDDCC8988, 0x78F7DFDD),\n        ivec4(0xDDCC9998, 0xCCFCDEDD, 0xCC9C9C99, 0xC9ECDFCC),\n        ivec4(0xCCC9CC9C, 0x99C9DECC, 0x99999C99, 0x8999DDCC),\n        ivec4(0xDBFFEEEE, 0xCA0730, 0xFEEFFEEF, 0xDAADD7),\n        ivec4(0xEFDCFFFF, 0xDBDEFE, 0xADECFFFF, 0xD1EDFF),\n        ivec4(0x5BF7FFDF, 0xC0FEDF, 0xBBFCFFCE, 0x70FECF),\n        ivec4(0xFFFFDF89, 0xB0FFFF, 0xFFFFEF88, 0x91FFFF),\n        ivec4(0xFFFFDF89, 0xE6FFFF, 0xFFFFCE8C, 0x10F7FFFF),\n        ivec4(0xFFDECD89, 0x53FCFFFF, 0xFFCD9C89, 0xA8FCFFFE),\n        ivec4(0xEECD9C88, 0xCCFEEEFE, 0xDDCC9988, 0xC9FEDFDD),\n        ivec4(0xCDCC8988, 0x99ECDDDC, 0xCC999988, 0x9CD9DDCC),\n        ivec4(0x74ECFFFF, 0x10030000, 0xEBFFEFEE, 0xB0AC0370),\n        ivec4(0xFFEFFEEE, 0xB0DE7CDB, 0xFFCEFEFF, 0x80DDDDFE),\n        ivec4(0xCEDCFFFF, 0x60DDFDFF, 0x7ADBFFFF, 0xDAFEDF),\n        ivec4(0x17E6FFFF, 0xD7FF9F, 0xBCFDFFEF, 0xC0FFCF),\n        ivec4(0xFFFFFFCD, 0xE6FFFF, 0xFFFFFF8C, 0x1E7FFFF),\n        ivec4(0xFFFFEF89, 0x77FBFFFF, 0xFFFFEF9C, 0xA9FDFFFF),\n        ivec4(0xFFEFDE9C, 0xD9FFFFFF, 0xFFDECD9C, 0xC9FFEFFE),\n        ivec4(0xEEDDCC89, 0xC9FFDEFE, 0xDDCCAA8A, 0xCCEEDDED),\n        ivec4(0xDBFFFF, 0x0, 0xD7FFEEFE, 0x0),\n        ivec4(0xFEEFEEEE, 0xCC1700B7, 0xFFDFEEEF, 0xDCCD3BFC),\n        ivec4(0xEFCCFEFF, 0xEBDDDDFF, 0x9DCAFFFF, 0xD1DDFDFF),\n        ivec4(0x7BC6FFFF, 0x80DDFFCF, 0x7B1FFFF, 0x10DCFE8F),\n        ivec4(0xBAFDFFEF, 0xE8FFCF, 0xFFFFFFDF, 0xE3FFFF),\n        ivec4(0xFFFFEF9C, 0x37F7FFFF, 0xFFFFFF7C, 0x99FCFFFF),\n        ivec4(0xFFFFFFCD, 0xC9FFFFFF, 0xFFFFEFCD, 0xC8FFFFFE),\n        ivec4(0xFFDEDD9C, 0xC8FFEEFE, 0xEECDCCAC, 0xCCFFDDFD),\n        ivec4(0x60EBEFEE, 0x0, 0xD7FFEEEE, 0x10),\n        ivec4(0xFEEFDCFF, 0xAB1800B2, 0xFFCDFCFF, 0xDACD7BFA),\n        ivec4(0xDEBCFDFF, 0xD7DDDDFF, 0xBC77FDFF, 0xD0DDECFF),\n        ivec4(0x3874FEFF, 0x70DDFDDF, 0xBACBFFEF, 0xC9FDDF),\n        ivec4(0xFEFFFFDE, 0xC7FFEF, 0xFFFFFFCE, 0xC3FFFF),\n        ivec4(0xFFFFFFCE, 0x33D2FFFF, 0xFFFFFFDE, 0x88E7FFFF),\n        ivec4(0xFFEFEECD, 0xC9FCEFFF, 0xFFEFDECC, 0x98FDFFEE),\n        ivec4(0xEFDDCD9C, 0x88FDDFED, 0xEECDBC9A, 0x9CFDDEEC),\n        ivec4(0xB6FEDFFE, 0x50000, 0xFCEECDFF, 0x10CC2720),\n        ivec4(0xFFCEDBFF, 0x30DDACCB, 0xDFBBEBFF, 0x10DCCDFE),\n        ivec4(0x8E13F7FF, 0xDADCFE, 0xACB7FDEF, 0xC7DDFE),\n        ivec4(0xEEFEFFDF, 0x91ECFF, 0xFFFFFFEF, 0x70FCFF),\n        ivec4(0xFFFFFFDE, 0x70FDFF, 0xFFFFEFDE, 0x30FDFF),\n        ivec4(0xFFEFDDCD, 0x1130FFEF, 0xFEEFDECC, 0x77A7FFDF),\n        ivec4(0xFEDECD9C, 0x99E9FFDE, 0xFEDECCAA, 0x98E9FFDD),\n        ivec4(0xDDDDCC89, 0x88E9DFCD, 0xCCCCBC8A, 0x89D8DECC),\n        ivec4(0xEBDEDCFF, 0xC76A40, 0xFEBDEAFF, 0xD1CCAB),\n        ivec4(0xCF7BE7EF, 0xD1CDED, 0xAE77FCDF, 0x90CCFE),\n        ivec4(0xDEECFEDE, 0x70CDFE, 0xFFFFFFDE, 0x10DCFF),\n        ivec4(0xFFFFEEDE, 0xEBFF, 0xFEFFDECD, 0xF7FF),\n        ivec4(0xFEEFDD9C, 0x10FAEF, 0xFEDECC9B, 0x30FDDF),\n        ivec4(0xFDDECD89, 0x370FFDE, 0xEDDDAC8A, 0x7773FFDD),\n        ivec4(0xDCDCCC88, 0x99CAEFCD, 0xCCCC9C8A, 0x98C9EFCD),\n        ivec4(0xCCCC9988, 0x88C9DECC, 0xA9A98A8A, 0x8988DC9C),\n        ivec4(0xEEACFCDF, 0x90CDBB, 0xCF77FD9D, 0x80CDED),\n        ivec4(0x9DCBFE8D, 0x70CDFD, 0xFEFEEFCE, 0xCCFE),\n        ivec4(0xFFFFDE9D, 0xEAFF, 0xFFEFDDBC, 0xF7EF),\n        ivec4(0xFFEECC8C, 0xF7EF, 0xFEDEAC8A, 0xFCDF),\n        ivec4(0xEEDD9C88, 0x30FEDE, 0xEDCDAA78, 0x70FFDD),\n        ivec4(0xDCCD8988, 0x174EFCD, 0xCCCC9988, 0x7783EFCC),\n        ivec4(0x9C9C9989, 0x999AEFCC, 0x9C999A89, 0x98C9DECC),\n        ivec4(0x9999A999, 0x8898DC9C, 0x998B8A88, 0x8988D8CC),\n        ivec4(0x9EC7DE78, 0x70CDED, 0xACFCEF7A, 0x10CCFD),\n        ivec4(0xFEFFDE89, 0xD9FE, 0xFFEFCD8A, 0xE8FF),\n        ivec4(0xFFDE9C88, 0x10F7FF, 0xEFCDAC78, 0xF7EF),\n        ivec4(0xEFCD8978, 0x20FDEE, 0xDECC8B77, 0x70FEDE),\n        ivec4(0xDD9C8888, 0x72EFDD, 0xDC9C8988, 0x171EFCC),\n        ivec4(0xCC9C8988, 0x3B1DFCC, 0x999A9A99, 0x7887DECC),\n        ivec4(0x9C999999, 0x99A9EDCC, 0x9999C999, 0x9899ED9C),\n        ivec4(0x99A99999, 0x8888DC9C, 0xA998A888, 0x8988C89C),\n        ivec4(0xBDFA9F78, 0xDCFD, 0xEDFFCE7A, 0xC8FE),\n        ivec4(0xFFEF9D78, 0xD3FF, 0xFFDEAC88, 0x10F7FF),\n        ivec4(0xEFCD8978, 0xF7FF, 0xDFAD8A77, 0xFAEF),\n        ivec4(0xEE9C8877, 0x70FEEE, 0xDDAC8888, 0xB1FEDD),\n        ivec4(0xDC9C8888, 0x1170EECD, 0xCC9C8888, 0xB5DFCC),\n        ivec4(0x9C999C99, 0x17B1DECC, 0x99999C99, 0x7833EE9C),\n        ivec4(0x9999CC99, 0x9989ECCC, 0x999C9C99, 0x9899EC9C),\n        ivec4(0x99999999, 0x8898D9CC, 0x99A9A9A8, 0x8988C8CC),\n        ivec4(0xADFCDF78, 0xDBFD, 0xFEFFCE88, 0xC3FE),\n        ivec4(0xFFEF9D78, 0xD1FF, 0xFFDEAC78, 0x10E7FF),\n        ivec4(0xEFCD8C78, 0xF2FF, 0xEFAD8A77, 0x10FAFF),\n        ivec4(0xEE9C8887, 0x30FEEE, 0xDD9C8888, 0x73FDDD),\n        ivec4(0xDD9C8988, 0x170EECD, 0xCC999C99, 0x1075DFCC),\n        ivec4(0xC999CC99, 0x1332EECC, 0xC9C9CC99, 0x7833FCCD),\n        ivec4(0x9C9CCC9C, 0xC9B9E9CC, 0x99CC9C99, 0x9999DCCD),\n        ivec4(0x9C999C99, 0x8898C9CD, 0x9999A9A9, 0x8988C8CD),\n        ivec4(0xAEFCDF88, 0xD7FD, 0xFEFFCE89, 0xC1FD),\n        ivec4(0xFFFECD88, 0xC4FF, 0xFFDFAC78, 0xD7FF),\n        ivec4(0xEFCE9C78, 0xD4FF, 0xEFCD8A77, 0xF8EF),\n        ivec4(0xEE9D8888, 0xFDEE, 0xDD9C8A88, 0x73FCDE),\n        ivec4(0xDD9C9988, 0x160EDCD, 0xCC999C99, 0x1035EECD),\n        ivec4(0xC999CC9C, 0x1321ECCC, 0x9CCCCCC9, 0x8815FBCD),\n        ivec4(0xC9C9CC9C, 0xC989E8CD, 0x9CCC9C9C, 0x9899DC9D),\n        ivec4(0x9C9C9C99, 0x8898C9CD, 0x9C9C99A9, 0x898898CD),\n        ivec4(0xCEFDEF89, 0xD7FD, 0xFFFFCE8A, 0xC0FE),\n        ivec4(0xFFFFCD88, 0x10C2FF, 0xFFDFAC8A, 0xD3FF),\n        ivec4(0xFFCE8C78, 0xE0FF, 0xFFCD8A87, 0x10FBFF),\n        ivec4(0xDECD8888, 0x10FDEE, 0xDDCD9A88, 0x1033FADE),\n        ivec4(0xDC9D9C99, 0x34FDDD, 0xCC99CCC9, 0x1031EECD),\n        ivec4(0xCCCCCCCC, 0x1701FACD, 0xCCCCCC9C, 0x7833F7CD),\n        ivec4(0x9CCCCCCC, 0xC98CDBCD, 0xCCCCCC9C, 0x9999DCCD),\n        ivec4(0xCC9C9C9C, 0x8898C9CD, 0xCC999999, 0x8C8898DD),\n        ivec4(0xEEFFCF88, 0xD3FD, 0xFFFFCE8A, 0xC0FE),\n        ivec4(0xFFDE9C88, 0x10D7FF, 0xFFDFAC78, 0xC1FF),\n        ivec4(0xEFCD8978, 0xF7FF, 0xEFCD8A88, 0x10FCFF),\n        ivec4(0xEECC8888, 0x74FDDE, 0xDDCD9999, 0x1151FCDE),\n        ivec4(0xCC9CCC9C, 0x76EDCD, 0xCCCCCCC9, 0x1131EECD),\n        ivec4(0xCCCCCCCC, 0x1340FACD, 0xCCCCCCCC, 0x8937F7CD),\n        ivec4(0xCCCCCCCC, 0xC9ACD8CD, 0xCCCCCC9C, 0x9999CCDD),\n        ivec4(0xCCCC9C9C, 0x8898C9DD, 0xCC9C9999, 0x9C8898DD),\n        ivec4(0xFFFFCD78, 0xC7FE, 0xFFEFAC78, 0x1D1FF),\n        ivec4(0xFFDE9C78, 0x20F7FF, 0xFFCD8A78, 0xF5FF),\n        ivec4(0xEFCC8888, 0x50FCFF, 0xDFAD8A88, 0x70FEFF),\n        ivec4(0xDE9C9999, 0x51B3FEDE, 0xDDCC9C99, 0x71FEDD),\n        ivec4(0xCCC9CCCC, 0x5175EFCD, 0xCCCCCC9C, 0x1130EECD),\n        ivec4(0xCCDCCCCC, 0x1751F9CD, 0xCCCCCCCC, 0x9958F7CD),\n        ivec4(0xCCCCCCCC, 0x9C9CDACD, 0xCCCCCCCC, 0x9899CCDE),\n        ivec4(0xCDCCCC9C, 0x8999C9DD, 0xCC9C9C99, 0xCD88C9DD),\n        ivec4(0xEDFF9D78, 0x1DAEF, 0xFFFF9D88, 0x1E8FF),\n        ivec4(0xFFEF8C88, 0x61FAFF, 0xFFDEAC88, 0x51FDFF),\n        ivec4(0xEFCD8988, 0x20FFFF, 0xEF9C8A88, 0x10B1FFFF),\n        ivec4(0xDE9C8888, 0x10D7FFFF, 0xDECC9999, 0x35A3FFEE),\n        ivec4(0xDDCCCC99, 0x61C7EFDC, 0xCCCCCCCC, 0x53A2EFDC),\n        ivec4(0xCCCCCCCC, 0x7873EFCD, 0xCCDCCCCC, 0xCC89EECD),\n        ivec4(0xCCDCCCCC, 0x99CCEDCD, 0xDCCCCCCC, 0x9999DCCD),\n        ivec4(0xCCCCCCC9, 0x9C98D9DE, 0xCCCCC999, 0xCD9CC9CD),\n        ivec4(0xCEFDEF9C, 0x70DDFF, 0xB9FECE89, 0x10ECEF),\n        ivec4(0xEDFF8C88, 0x20FADF, 0xFFFF8D88, 0x31FCFF),\n        ivec4(0xFFEF8D88, 0x1B4FFFF, 0xFFEF9C88, 0xB1FFFF),\n        ivec4(0xEFCD8C88, 0x10D5FFFF, 0xEFCD8988, 0x11E7FFFF),\n        ivec4(0xDECC8988, 0x15FBFFFF, 0xDE9C8988, 0x77E7EFEE),\n        ivec4(0xCD9C9C99, 0x99FADFDD, 0xCDCCCC9C, 0xCCECDFCD),\n        ivec4(0xCCCDCCCC, 0xC9D9DFCD, 0xDCCCCCCC, 0x9CC9DECC),\n        ivec4(0xCCCCCCCC, 0xDD9CDCCD, 0xCCCCC999, 0xCCCCD9CD),\n        ivec4(0xFEFEFFDE, 0x809DCB, 0xDFFDFFEF, 0x70EEFE),\n        ivec4(0xCCFFDFCC, 0x50FDEF, 0xB7FFCE89, 0x10FD9F),\n        ivec4(0xFEDF9978, 0x40FDDF, 0xFFDF8978, 0x71FFFF),\n        ivec4(0xFFDF8988, 0x40D7FFFF, 0xFFDF8988, 0x11D3FFFF),\n        ivec4(0xFFCD8988, 0x27FBFFFF, 0xEFCD9988, 0x77FAFFFF),\n        ivec4(0xCECC8888, 0xCCFDFFFF, 0xCD9C8888, 0xCCFDFFFF),\n        ivec4(0xCD9C9988, 0x9CEDDEED, 0xCCCC9999, 0xDDDCDEDD),\n        ivec4(0xCCCCCC9C, 0xDDDDDDCC, 0xCC9C9C99, 0xDCDCDDCC),\n        ivec4(0xFBFFDFAC, 0x501730, 0xEFFEEFCD, 0x10CDDA),\n        ivec4(0xDEFFEFDE, 0x50EEFF, 0xCBFFDFAC, 0xFCDF),\n        ivec4(0xE7DF9C88, 0x40FC8E, 0xFECE8977, 0x10FCCF),\n        ivec4(0xFF7C8887, 0xB0FFFF, 0xFF9F8888, 0x57C7FFFF),\n        ivec4(0xFF9D8888, 0x77E6FFFF, 0xFF9C8888, 0x77FAFFFF),\n        ivec4(0xDE9C8888, 0x99FDFFFF, 0xCD9C8878, 0x98FCFFFF),\n        ivec4(0xCD898888, 0xDDFCEFEE, 0xCC898888, 0xEDDDDEDD),\n        ivec4(0xCC998888, 0xDDDDDECC, 0xCCC99999, 0xCCDCDDCC),\n        ivec4(0xD3FFDEA9, 0x100, 0xFDFEEF9C, 0xA8B7),\n        ivec4(0xDEFFEECD, 0xEBFD, 0xCAFFCD88, 0xE3EF),\n        ivec4(0xF7CE8978, 0xE3AF, 0xFF8C7887, 0xF7FF),\n        ivec4(0xFF8C8898, 0x554FEFF, 0xFF9D8888, 0x3871FEFF),\n        ivec4(0xEF8C8888, 0x77B5FFFF, 0xDF9C8888, 0x87C8FFFF),\n        ivec4(0xCD898887, 0x88E9FFEF, 0xCD897878, 0x9CDCEFEF),\n        ivec4(0xCC888888, 0xDDDDDEDD, 0xCC998988, 0xEDDEDDCD),\n        ivec4(0xCC9C9999, 0xDDDDDDCC, 0xCCC99989, 0xCCC9DCCC),\n        ivec4(0x70FDCFA9, 0x0, 0xE7FEDEA9, 0x7011),\n        ivec4(0xDEFFCE9C, 0xC0DC, 0xCCDF8987, 0xB0FE),\n        ivec4(0xEB8D7887, 0x70CF, 0xFF8D8788, 0xC0FF),\n        ivec4(0xEF8D8788, 0x540F7FF, 0xEF9C8888, 0x7801F7FF),\n        ivec4(0xDE898787, 0x7757FCFF, 0xCD898877, 0x7777FCFF),\n        ivec4(0x9D788888, 0x88C9EEDD, 0xCC898888, 0xCDC9ECCD),\n        ivec4(0xCC9C9998, 0xDDDDD9CD, 0xCC9C9C99, 0xDDDDDDCC),\n        ivec4(0xC99C9998, 0xCCCCDCCC, 0x9C999998, 0x999CC9CC),\n        ivec4(0xCBDE9A, 0x0, 0xA0EEAE8B, 0x0),\n        ivec4(0xECFE9D8A, 0x507C, 0xCDCE7888, 0x10ED),\n        ivec4(0xEC8C3888, 0xED, 0xFF8D8788, 0x50FE),\n        ivec4(0xEF8C7788, 0xB4FF, 0xDE898787, 0x7801D0FF),\n        ivec4(0xCD787877, 0x7813E5EE, 0x9D888888, 0x3787E7DD),\n        ivec4(0x9C888888, 0x8898D9CD, 0xCC9C8988, 0xDC89C8CD),\n        ivec4(0xC99C9998, 0xDCDD9CCD, 0xC9999999, 0xDCCCCDCC),\n        ivec4(0xC9998988, 0xC99CC9CC, 0x9C998888, 0x989998C9),\n        ivec4(0xB6DCDC, 0x1000000, 0x70EDBD7B, 0x0),\n        ivec4(0xEBEEAC79, 0x5B, 0xCDAD7788, 0xDA),\n        ivec4(0xFD897788, 0xFB, 0xEF8C8788, 0xFD),\n        ivec4(0xDF897787, 0x30FE, 0xCD887778, 0x8A00B0FF),\n        ivec4(0x8D887878, 0x7817A1DE, 0xCC888888, 0x7777A7DD),\n        ivec4(0xCC998888, 0x798899CD, 0xC9C98989, 0xDC8C98CD),\n        ivec4(0x9C9C9999, 0xCDDD8CCC, 0x9C9C9988, 0xCCCDCCCC),\n        ivec4(0x9D99A888, 0x99C99999, 0xCD898888, 0x888999C9),\n        ivec4(0xB6CCDC, 0x1000000, 0x30EEBD7B, 0x0),\n        ivec4(0xDBCE7888, 0x77, 0xDD7C7788, 0xD3),\n        ivec4(0xFE898787, 0xF7, 0xDF798787, 0xFC),\n        ivec4(0xCE787777, 0x40FE, 0x9D787878, 0x8A0070EE),\n        ivec4(0x9C888888, 0x781771CE, 0xCC998888, 0x377733CD),\n        ivec4(0xC9998988, 0x798889CC, 0xCC999998, 0xDC8C88CC),\n        ivec4(0x9C9C9989, 0xDDDD9CC9, 0xCC998988, 0xCCCCCCC9),\n        ivec4(0xCD898A88, 0x99999999, 0xCD898888, 0x889899C9),\n        ivec4(0xB7CDCA, 0x14000000, 0x30EEBC7B, 0x0),\n        ivec4(0xDA9D77A8, 0xA2, 0xEE7C8778, 0xD0),\n        ivec4(0xFF897788, 0xF7, 0xDE797778, 0xFA),\n        ivec4(0x9E887777, 0x40FD, 0x9D888888, 0x8A0130DD),\n        ivec4(0xCC898888, 0x781731CE, 0xCC9C8988, 0x777713CC),\n        ivec4(0xC99C9989, 0x89888AC9, 0xCC9C9988, 0xDC8C98D9),\n        ivec4(0x9C9C9989, 0xCDDD8CD9, 0xCD9C99A8, 0xCCCDCC99),\n        ivec4(0xCE998988, 0x9899C999, 0xCD998888, 0x888999C9),\n        ivec4(0xB6CDCA, 0x14000000, 0x70FDBC7B, 0x4000000),\n        ivec4(0xEB8D7788, 0xC0, 0xEF8D8778, 0xC0),\n        ivec4(0xEF8C7788, 0xF5, 0xDF797777, 0xF7),\n        ivec4(0xCE888778, 0x40ED, 0xCD898878, 0x8A0130DC),\n        ivec4(0xCC9C8888, 0x881711DC, 0xC99C9989, 0x777313D8),\n        ivec4(0xCCCC9989, 0x89888AD7, 0xCC9C9998, 0xDC8C98D9),\n        ivec4(0xCD9C9989, 0xDCDD9CC9, 0xCE999988, 0xCCCDCC99),\n        ivec4(0xDE99A888, 0x98999999, 0xDE9C8888, 0x888999C9),\n        ivec4(0xB6CDCC, 0x12000000, 0x10EDBC7B, 0x4000000),\n        ivec4(0xDB9E7788, 0x40000C0, 0xEF8E8778, 0x90),\n        ivec4(0xFF8C8787, 0xE2, 0xDF897777, 0xF3),\n        ivec4(0xCE888878, 0x20FA, 0xCD998888, 0x890510E9),\n        ivec4(0xCC9C8988, 0x881711DA, 0xCCCC9999, 0x777703D7),\n        ivec4(0xCCCC9C99, 0x898889D7, 0xCDCC9989, 0xDC8C98D9),\n        ivec4(0xCDCC99A9, 0xDDDD9CC9, 0xDE999989, 0xCCCDDC99),\n        ivec4(0xDE9CA989, 0x98999999, 0xDE9C8988, 0x888999C9),\n        ivec4(0xB6DCCC, 0x14010000, 0x50FEACBB, 0x4040000),\n        ivec4(0xEB9E77A8, 0xC0, 0xFF8E8888, 0xA0),\n        ivec4(0xFF8C7888, 0xE2, 0xEF897787, 0xF3),\n        ivec4(0xDE888888, 0x10020FA, 0xDD999988, 0x890510EC),\n        ivec4(0xCCCD99A9, 0x881701DA, 0xDCCDC999, 0x387713D7),\n        ivec4(0xCCCCC999, 0x8C9889D7, 0xCDCCCC99, 0xDC9C98D9),\n        ivec4(0xDD9C9C99, 0xDDDD9DC9, 0xDFCC9999, 0xDCCDCD9C),\n        ivec4(0xDECC9989, 0x99C9C99C, 0xEECD9988, 0x889999CC),\n        ivec4(0xB7CDCC, 0x16010000, 0x30EEBCBB, 0x44000000),\n        ivec4(0xEA8E87A8, 0xC0, 0xFF8D8888, 0xA0),\n        ivec4(0xFF8C7788, 0xE2, 0xDF798787, 0xF3),\n        ivec4(0xCF898887, 0x50020FA, 0xCD9C8989, 0xA90310E9),\n        ivec4(0xCCCD9989, 0x883701E8, 0xDCCDC999, 0x388703D7),\n        ivec4(0xCCCCCC99, 0x8C9889D7, 0xCDCC9C99, 0xDC9D98DC),\n        ivec4(0xCECC9C99, 0xDDDD9DC9, 0xDECC9999, 0xCCCDCD9C),\n        ivec4(0xEECC99A9, 0x99C9C9CC, 0xEECD9988, 0x889999C9),\n        ivec4(0xCBDDDC, 0x56100000, 0xB0EFBCBB, 0x44000010),\n        ivec4(0xFD8EA8C9, 0x440000C0, 0xFF8988BA, 0xD0),\n        ivec4(0xEF898888, 0xFB, 0xEF898788, 0xFA),\n        ivec4(0xCE888888, 0x70070FE, 0xDE9C9989, 0xAC0731ED),\n        ivec4(0xDCCD9C99, 0x893841E9, 0xDDCDCC9C, 0x788713D7),\n        ivec4(0xDDCCCC9C, 0x9D9899D7, 0xDDCCCC9C, 0xDDCDC9DC),\n        ivec4(0xDDCCCC9C, 0xEDDECDC9, 0xDFCCCC99, 0xDCCDDDCC),\n        ivec4(0xEFCD9C99, 0xC9CCCC9C, 0xEECD9999, 0x899999CC),\n        ivec4(0xCBEEEE, 0x55110000, 0xD5EFBCBB, 0x44000070),\n        ivec4(0xFEDE9CA9, 0x440000D4, 0xEF899BCC, 0xF3),\n        ivec4(0xCF88A8AA, 0x40FC, 0xDF889899, 0x74FF),\n        ivec4(0x9E8888A8, 0x3B00A4FF, 0x9D8888A9, 0x9957A3FF),\n        ivec4(0xCD9C9998, 0x897887EF, 0xDDCCCC99, 0x788877DD),\n        ivec4(0xDDCCCC9C, 0x9D999CDD, 0xDDCCCC9C, 0xDDDE99ED),\n        ivec4(0xCDCDCC9C, 0xDEDDCDD9, 0xDECCCC99, 0xCCDDDCCC),\n        ivec4(0xDFCCC999, 0x99CCCCCC, 0xEECC9999, 0x899999CC),\n        ivec4(0xB7EEFF, 0x55110000, 0xD7FFCDDD, 0x44000053),\n        ivec4(0xFFCFBABB, 0x440000CB, 0xFFCEBCC9, 0xFC),\n        ivec4(0xCFAACCCC, 0x70FF, 0x8D98C9C9, 0x40D1FF),\n        ivec4(0x8C999999, 0x7A40F7FF, 0x8D9999AC, 0xA958FBFF),\n        ivec4(0x89889999, 0x8878FADF, 0x9C999899, 0x8998ECDF),\n        ivec4(0xCDC99999, 0xDD9CDDDE, 0xCDCCCC9C, 0xDDDDCCDD),\n        ivec4(0xCDCDCC9C, 0xEDDDDDED, 0xCDCDCC9C, 0xCCDDDCDD),\n        ivec4(0xCECC9C9C, 0x99CCCCDC, 0xDD9C9999, 0x899999DC),\n        ivec4(0xB7EDEF, 0x55110000, 0xE7FFEEDE, 0x44000010),\n        ivec4(0xFFCCCBAA, 0x440040DA, 0xFFCC7BAB, 0x30FE),\n        ivec4(0xEFCDCCCC, 0xC4FF, 0x9CCACDCD, 0xF7EF),\n        ivec4(0x889A9CCC, 0x7A40FE9F, 0x9899C9C9, 0xA978FF9F),\n        ivec4(0x989CC999, 0x89C8FF9E, 0x9999999C, 0x89C8FF9F),\n        ivec4(0x88889999, 0xCDDCEE9D, 0x99989899, 0xDDDEECCD),\n        ivec4(0xCCCC9999, 0xEEDDDDDD, 0xCCCCCCC9, 0xCCDDDDDD),\n        ivec4(0xCDC9C999, 0x9CCCCCDD, 0xCCC99999, 0x8999C9DC),\n        ivec4(0x20EBFEEF, 0x15110000, 0xFDDFEDDD, 0x44000030),\n        ivec4(0xEF9CBBAB, 0x440040FC, 0xDFBC7BC9, 0x80FE),\n        ivec4(0xDECDCDCD, 0xE6FF, 0xA9C9CDCC, 0xFACF),\n        ivec4(0xA89CCCCC, 0x7A74FF8C, 0x9899C9C9, 0xA9A8FF8C),\n        ivec4(0x9999C999, 0x89EAFF89, 0x9999999C, 0x89D8FF89),\n        ivec4(0x88999999, 0xDDDDDF89, 0x88889899, 0xDDDEDD89),\n        ivec4(0x9989999A, 0xEEEDDD9D, 0xCC999999, 0xDCDDDDCD),\n        ivec4(0xCCCC9999, 0x99CCDCCD, 0xCC9999A9, 0x9999C9CC),\n        ivec4(0xB0FDFEEE, 0x55100000, 0xFFCDCAAB, 0x44000070),\n        ivec4(0xEF9C7BA8, 0x40010FC, 0xDECDCBCD, 0x70FE),\n        ivec4(0xA9C9CDCD, 0xE5DF, 0x88999CCC, 0xFA8D),\n        ivec4(0x989999C9, 0x7A74FF89, 0x989999C9, 0x89B8FF8C),\n        ivec4(0x98989999, 0x88D8FF8C, 0x88989999, 0x89D8EF89),\n        ivec4(0x88889899, 0xDDCCDD88, 0x89888899, 0xDDDDDD9C),\n        ivec4(0x9C999998, 0xEEDEDDCD, 0xCC9C9999, 0xCCCDDDCD),\n        ivec4(0xC9C99999, 0xC9CCCCCD, 0xCC9999A9, 0x89999CCC),\n        ivec4(0xB0EDDDDD, 0x15010000, 0xFE9DBABB, 0x4000031),\n        ivec4(0xEFCD78C8, 0xEB, 0x9CC9DCCC, 0x10FE),\n        ivec4(0x7898C9CC, 0xC0DF, 0x8899A9C9, 0xF79F),\n        ivec4(0x8889999A, 0x7A64FD8E, 0x88989899, 0x8978FD9F),\n        ivec4(0x88889899, 0x7887FE8D, 0x888888A9, 0x88C9DD8C),\n        ivec4(0x89888888, 0xCD99DC9D, 0x9C9C9999, 0xDDDDDCCD),\n        ivec4(0xCC9C9C99, 0xDEDDCDDD, 0xCCC99999, 0xCCDDDCDD),\n        ivec4(0xCCC99999, 0x9CCC9CCC, 0xCC9999A9, 0x899999DC),\n        ivec4(0x70EADDDD, 0x14010000, 0xFACE8BB7, 0x4000000),\n        ivec4(0xEFCD79C8, 0xAB, 0x9D88C9CC, 0xEC),\n        ivec4(0x78989A99, 0x70DF, 0x888898AA, 0xD0EF),\n        ivec4(0x888888A8, 0x4740F7DF, 0x888888A9, 0x8817FBDF),\n        ivec4(0x788788A8, 0x7877FA8D, 0x89888888, 0x7888E89D),\n        ivec4(0x99998888, 0x9D98D9CD, 0xCC999999, 0xDCCDC8CD),\n        ivec4(0xCC9C9C99, 0xDDDD9DDD, 0xCC9C9C99, 0xCCCCCCCD),\n        ivec4(0xCC99999A, 0x99C999CC, 0xCD998989, 0x889999CC),\n        ivec4(0xCBDEDE, 0x12000000, 0xE7CFBABB, 0x4000000),\n        ivec4(0xFDCE7998, 0xA7, 0xCE88C9CC, 0xF7),\n        ivec4(0x7988999A, 0x40EE, 0x8988889A, 0xB0FF),\n        ivec4(0x888888A8, 0x500E3EF, 0x898788A9, 0x8913E3EF),\n        ivec4(0x88878888, 0x8877E89E, 0x99888888, 0x788797CD),\n        ivec4(0xCC999988, 0x8998CCDD, 0xCDC99999, 0xDC9C99CD),\n        ivec4(0xCCC99C99, 0xDDDD9CDC, 0xCCCC9999, 0xDCCDCDCC),\n        ivec4(0xCD999999, 0x9999C9CC, 0xCD9989A8, 0x9899C9C9),\n        ivec4(0xB7DEDE, 0x5010000, 0xC1DFAABB, 0x4000000),\n        ivec4(0xFCCE89A7, 0xA2, 0xCE88CACC, 0xE1),\n        ivec4(0x8C87989A, 0xFC, 0x8D8888A8, 0x30FF),\n        ivec4(0x898888A8, 0xA2FF, 0x89778888, 0x8901C1EF),\n        ivec4(0x88888788, 0x8877C7CF, 0x9C888888, 0x387773DE),\n        ivec4(0xCD9C9989, 0x889889CD, 0xCD999999, 0xCD9999CD),\n        ivec4(0xCDCC9C99, 0xDDDD9CDC, 0xCCC99999, 0xDDDCCCC9),\n        ivec4(0xCD999999, 0x99CCCCC9, 0xCD9989A8, 0x989999CC),\n        ivec4(0x76EDEE, 0x15000000, 0xA0EFB9BA, 0x4000000),\n        ivec4(0xFBCE8CA7, 0x90, 0xDF88CACC, 0xD0),\n        ivec4(0x8D87889A, 0xFB, 0x8D8888A8, 0x10FE),\n        ivec4(0x8C8888A8, 0x70FF, 0x89778888, 0x7C01A0FF),\n        ivec4(0x89888788, 0x8837A7DF, 0x9C998888, 0x387733DD),\n        ivec4(0xCD999989, 0x889889CC, 0xCDCC9999, 0xCD8899DC),\n        ivec4(0xCDCC9C99, 0xDCDD99D9, 0xCDC99999, 0xDDDDCDC9),\n        ivec4(0xCE999999, 0xC99CCC99, 0xCE9989A8, 0x8999999C),\n        ivec4(0x74DCEE, 0x14010000, 0x70EEBCBA, 0x4000000),\n        ivec4(0xFBDF8C87, 0xA0, 0xDE89C8CC, 0xD0),\n        ivec4(0x8E87A89A, 0xF3, 0x8F888888, 0xFD),\n        ivec4(0x8D8888A8, 0x50FF, 0x8C777898, 0x790070FF),\n        ivec4(0x89888888, 0x883787DF, 0xCD898888, 0x787733DC),\n        ivec4(0xCD9C9989, 0x789888C9, 0xCDCC9999, 0x9D8899DC),\n        ivec4(0xCDCC9C99, 0xDCDD99D9, 0xCD9C9999, 0xDDDDCDC9),\n        ivec4(0xCE9C9999, 0xCC9CCC99, 0xDD9989A8, 0x8999999C),\n        ivec4(0x61ECEE, 0x14010000, 0x70EEACBA, 0x4000000),\n        ivec4(0xF7DF8C87, 0xA0, 0xEF8CCACC, 0xD0),\n        ivec4(0x9E87A8A9, 0xF3, 0x9F8888A8, 0xFC),\n        ivec4(0x8D8888A8, 0x70FF, 0x8D878798, 0x7C0070FF),\n        ivec4(0x89888888, 0x883783EF, 0xCD998888, 0x787733DC),\n        ivec4(0xDC9C9CA9, 0x789888D8, 0xDDCC9C99, 0x9D8899DC),\n        ivec4(0xCDCCCC9C, 0xDCDD89D9, 0xCDCC9999, 0xDDDDCDC9),\n        ivec4(0xCECC9999, 0xCCCCCC99, 0xDE999989, 0x9899999C),\n        ivec4(0x70EBEE, 0x12000000, 0x70FECCBC, 0x4000000),\n        ivec4(0xF7DF8B87, 0xB0, 0xEF8CC9CC, 0xE0),\n        ivec4(0x9E87989A, 0xF7, 0x8F8888A8, 0xFC),\n        ivec4(0x8E8888A8, 0x70FF, 0x8D788898, 0x7C0170FF),\n        ivec4(0x89888888, 0x883781EF, 0xCC998888, 0x787733DD),\n        ivec4(0xDD9C9CA9, 0x789889D9, 0xDCCC9C99, 0xCD9899D9),\n        ivec4(0xCDCCCC99, 0xDCDD99D9, 0xCDCC999C, 0xDDDDCDC9),\n        ivec4(0xDDC99999, 0xCC9CCC9C, 0xDD9C99A8, 0x9899999C),\n        ivec4(0x70ECEE, 0x14010000, 0x70EEBDCC, 0x4000000),\n        ivec4(0xFBCFB987, 0xB1, 0xEE9DCCCC, 0xE1),\n        ivec4(0x9E879A9C, 0xF7, 0x8E9898AA, 0xFD),\n        ivec4(0x8D8888A9, 0x70FF, 0x8E8888A9, 0x8C0070FF),\n        ivec4(0x89888888, 0x8838A3EF, 0xCD998989, 0x787737DD),\n        ivec4(0xCD9C9C99, 0x889889DC, 0xCDCCCC99, 0xCD99C9DC),\n        ivec4(0xDDCCCC9C, 0xDDDD9CD9, 0xCDCCCC99, 0xDDDDCDC9),\n        ivec4(0xDE9C9C99, 0xCCCDCC9C, 0xDE9999A9, 0x9999C99C),\n        ivec4(0xB0DDEF, 0x14010000, 0x90EFCCBC, 0x4000000),\n        ivec4(0xFCCE7B87, 0x77, 0xEFCC9CCD, 0xF7),\n        ivec4(0x9E87CA9C, 0xEC, 0x8C8899AA, 0xFF),\n        ivec4(0x8C8888A9, 0xB1FF, 0x8D8898A9, 0xAC01A1FF),\n        ivec4(0x88888889, 0x8838C3DF, 0x9C898888, 0x787777DE),\n        ivec4(0xCDCCCC99, 0x88988CDD, 0xCDCC9C99, 0xDD9999DC),\n        ivec4(0xDDCCCC9C, 0xDDDD9CDC, 0xCDCCCC99, 0xDDDDDDC9),\n        ivec4(0xCECC9999, 0xCCCCCC9C, 0xDE9C99A9, 0x999999CC),\n        ivec4(0x74DCEF, 0x14110000, 0x90EEEECE, 0x4000000),\n        ivec4(0xFEAEBB87, 0x6A, 0xFFCE8BC9, 0xFC),\n        ivec4(0xCE99CDCD, 0x20FE, 0x8998C9AC, 0x70FF),\n        ivec4(0x88A9A999, 0x500E6FF, 0x898999C9, 0xAC17E7FF),\n        ivec4(0x88889899, 0x8978F7DF, 0x998898A9, 0x7888DACF),\n        ivec4(0xCC9C9999, 0x8C99CCDE, 0xCDCCCC99, 0xDD9CC9DD),\n        ivec4(0xCDCCCC9C, 0xDDDE9DDC, 0xCDCCCC99, 0xDDDDDDDC),\n        ivec4(0xCECC9999, 0xCCCCCCCC, 0xDE9999A9, 0x999999CC),\n        ivec4(0x20CBDE, 0x15100000, 0x70FCFFEF, 0x4000000),\n        ivec4(0xFECECCAC, 0x4003063, 0xFFBC7BB7, 0x70ED),\n        ivec4(0xFFCDAACC, 0xB0FF, 0xCDC9CDCD, 0xD0FE),\n        ivec4(0x889A9C9C, 0x700F7DF, 0x8899999C, 0x9C57FADF),\n        ivec4(0x88999A99, 0x8978FECF, 0x88899999, 0x8997FDCF),\n        ivec4(0x88889899, 0x9DC9FDCD, 0x999999A9, 0xDDCDDCDD),\n        ivec4(0xCC9C9C99, 0xDDDDCDDD, 0xCCCCCC99, 0xDDDDDDDD),\n        ivec4(0xCDCCC999, 0xCCCCCCCC, 0xCD999989, 0x989999CC),\n        ivec4(0x40B7DC, 0x15100000, 0xDBFEFF, 0x4000000),\n        ivec4(0xEDEFEEDD, 0x40000040, 0xFFBCBABB, 0xC4EB),\n        ivec4(0xDFAC38A7, 0xE4FF, 0xEF9D9BDC, 0xF3FE),\n        ivec4(0xCDDCDDCC, 0x5B00FCFE, 0x88CACCCC, 0x9C58FECF),\n        ivec4(0x88A999C9, 0x89A8FF8D, 0x989999AC, 0x79A8FF8F),\n        ivec4(0x98999999, 0x9DD9FF8D, 0x88889999, 0xDDDDFE9C),\n        ivec4(0x89889899, 0xDEEDEE9C, 0x999999A8, 0xDDDDDDCD),\n        ivec4(0xCC9999A9, 0xCCCCCCCD, 0x9C9999A8, 0x989999CC),\n        ivec4(0x40CBED, 0x15100000, 0xECFEEF, 0x4000000),\n        ivec4(0xEEEFEEDD, 0x40000060, 0xEFBCBCBB, 0xA7EB),\n        ivec4(0xCFBC38A7, 0xE7FF, 0xDFBC87CC, 0xF7FE),\n        ivec4(0xDEDDDDCD, 0x5A40FEFE, 0x99C9CCCC, 0x9C78FFDE),\n        ivec4(0x88CACCCC, 0x89C7FF8D, 0x8899A999, 0x89D7FF8C),\n        ivec4(0x9999C999, 0xCDE9FF89, 0x98999999, 0xDDDEFF8C),\n        ivec4(0x88899999, 0xDEEDDF89, 0x888888A8, 0xDDDDDD89),\n        ivec4(0x888888A8, 0xC9DCCC9C, 0x99898888, 0x9999C9CC),\n        ivec4(0xB6FDFF, 0x14010000, 0xA7FFEEDE, 0x4000000),\n        ivec4(0xFFCDCCAB, 0x40070B0, 0xDFBC7BB7, 0xD0FC),\n        ivec4(0xEF9C78C9, 0xE4FF, 0xDECDDDCD, 0xF7FE),\n        ivec4(0xACCCCCCC, 0x7A00FDEE, 0x8898CCCC, 0x9C78FF9E),\n        ivec4(0x9799AAC9, 0x89C7FF8C, 0x98999999, 0x89C7FF8D),\n        ivec4(0x98989999, 0xCDDCFF8C, 0x889898A9, 0xDDDEEF8C),\n        ivec4(0x88888898, 0xEEEDDE89, 0x888888A8, 0xDDDDDD9C),\n        ivec4(0x89888888, 0x9CCCCC9C, 0x999988B8, 0x98999CCC),\n        ivec4(0x50EBEEDE, 0x11000000, 0xFACEACBC, 0x0),\n        ivec4(0xFFAC7B87, 0x70C7, 0xEFCC8BCC, 0xB0FE),\n        ivec4(0xCECCDCCC, 0xB0EF, 0x8988CCC9, 0xE2EE),\n        ivec4(0x87A8AA99, 0x7C00FA9F, 0x88888999, 0x8978FCCF),\n        ivec4(0x8888899A, 0x8987FE9E, 0x88888899, 0x7C88FD9E),\n        ivec4(0x888888A8, 0xDDC9FD8C, 0x88888788, 0xCDDDDC9C),\n        ivec4(0x89988888, 0xDEDDDE9C, 0x9C9989A9, 0xDCDDDCCD),\n        ivec4(0x99998988, 0x99C999CC, 0x99898888, 0x989999C9),\n        ivec4(0x70EADDCD, 0x1000000, 0xFA9E8B7B, 0x0),\n        ivec4(0xFF9D78C8, 0x20AC, 0xDEC9CCCC, 0x10FD),\n        ivec4(0x8CB7CAC9, 0xB0EF, 0x7888899A, 0xC0DF),\n        ivec4(0x888898A8, 0x7A00F7DF, 0x888888A8, 0x8958FBEF),\n        ivec4(0x78888888, 0x8877FACE, 0x88878788, 0x7988EC9D),\n        ivec4(0x89888888, 0xCD99D99D, 0x9C999888, 0xDDDDCCCC),\n        ivec4(0x9C999989, 0xDDDDDDCC, 0x9C998989, 0xCCCDCCCD),\n        ivec4(0x9C998988, 0x99C999C9, 0x9C898888, 0x88999999),\n        ivec4(0x30EBDDCD, 0x0, 0xF79EBAB7, 0x0),\n        ivec4(0xFECD78C8, 0xAC, 0xDEAACCCC, 0xEA),\n        ivec4(0x7C879A9A, 0x60EE, 0x888888A8, 0x70FF),\n        ivec4(0x78888888, 0x5A00E2EF, 0x89888888, 0x8917D3EF),\n        ivec4(0x78777888, 0x7877E7CE, 0x88888888, 0x7888C8CD),\n        ivec4(0x99888888, 0x9D88C9CD, 0x9C998988, 0xCCCD99CC),\n        ivec4(0x9C999989, 0xDDDDCDCC, 0x9C998989, 0xCCCDCCCC),\n        ivec4(0x9C998888, 0x89999999, 0xCD898888, 0x889899C8),\n        ivec4(0x10DBDDCD, 0x1000000, 0xD19E8BB7, 0x0),\n        ivec4(0xFECD8BCA, 0xC7, 0xCE88CC9C, 0xE3),\n        ivec4(0x7C87A8A9, 0xFC, 0x89888888, 0x20FF),\n        ivec4(0x88878888, 0x800A0FF, 0x89878788, 0x8907A1EF),\n        ivec4(0x88787888, 0x7877979F, 0x89888888, 0x788777CD),\n        ivec4(0x9C898988, 0x9C8899CD, 0xCC999998, 0xDC9D89C9),\n        ivec4(0xCC999989, 0xDDDDCDC9, 0x9C998988, 0xDCDCCC9C),\n        ivec4(0xCD999888, 0x99999999, 0xCD988888, 0x88989999),\n        ivec4(0xDBCDCD, 0x1000000, 0xD1CF8BB7, 0x0),\n        ivec4(0xEDCDB9CC, 0xC4, 0xCE87CAC9, 0xE0),\n        ivec4(0x8C8788A8, 0xFB, 0x8D8888B8, 0xFE),\n        ivec4(0x88878888, 0x70070FF, 0x89777888, 0x890771DF),\n        ivec4(0x88888888, 0x887783DD, 0x9C898888, 0x788737CC),\n        ivec4(0xCC998988, 0x8C8899D9, 0xCC9C9999, 0xDC9D98D9),\n        ivec4(0x9C9C8989, 0xCDDD9DC9, 0xCC9C9998, 0xDCCDCC9C),\n        ivec4(0xCD998888, 0x99C99999, 0xCD998888, 0x88989999),\n        ivec4(0xDBCDCD, 0x1000000, 0xC1CF8BB7, 0x10),\n        ivec4(0xEECDACCC, 0xC0, 0xCE8798AC, 0xC0),\n        ivec4(0x7D888BA8, 0xF7, 0x8E888888, 0xFC),\n        ivec4(0x8C778888, 0x170050FE, 0x89878788, 0x890771EE),\n        ivec4(0x99888888, 0x887771DC, 0xCC998888, 0x788737D8),\n        ivec4(0xCD9C9989, 0x8D8899C8, 0xCD9C9989, 0xCCCD88D9),\n        ivec4(0xCCCC99A9, 0xDDDD9D99, 0xDD999989, 0xDCCCCC9C),\n        ivec4(0xDC9C8989, 0x99C99999, 0xDD9C8888, 0x88989999),\n        ivec4(0xCBCECD, 0x10000000, 0xC0CF8BB7, 0x10),\n        ivec4(0xFDCDACCC, 0xB0, 0xCE879AAC, 0xC0),\n        ivec4(0x8E8788A8, 0xF3, 0x8E8888A8, 0xFA),\n        ivec4(0x8D878788, 0x1B0050FD, 0x8C878788, 0x890731ED),\n        ivec4(0x9C898888, 0x887733D9, 0xCC999988, 0x788737D7),\n        ivec4(0xDCCC99A9, 0x9D8899C8, 0xCDCC9999, 0xCCCD89D9),\n        ivec4(0xCDCC9CA9, 0xDDDD9D99, 0xDD9C9989, 0xCCCDCC9C),\n        ivec4(0xDC9C9989, 0x99999999, 0xDD9D8988, 0x88989999),\n        ivec4(0xCBDEDD, 0x14000000, 0xC0DF8BBB, 0x10),\n        ivec4(0xFDCE89CC, 0xB0, 0xCF78C9AC, 0xC0),\n        ivec4(0x8E88A8A9, 0xF5, 0x8F8888A8, 0xFA),\n        ivec4(0x8D888889, 0x1B0020FD, 0x8C788888, 0x891730FD),\n        ivec4(0x9C898888, 0x887733D9, 0xCD9C9C89, 0x798777D3),\n        ivec4(0xDDCCC999, 0xCD8899C8, 0xCDCCCC99, 0xCDDD99D9),\n        ivec4(0xCDCC9C9C, 0xDDDDCD99, 0xDDCC9999, 0xDCDDDC9C),\n        ivec4(0xECCC99A9, 0x99C9999C, 0xED9D9989, 0x88989999),\n        ivec4(0xDBEEDE, 0x14010000, 0xD1CFBBBB, 0x4000010),\n        ivec4(0xFDCE88CC, 0xC0, 0xDF9BDCCC, 0xD0),\n        ivec4(0x7D88AAA9, 0xF7, 0x8E888999, 0xFD),\n        ivec4(0x8C88A899, 0x7A0030FF, 0x898888A9, 0x991870FE),\n        ivec4(0x9C888988, 0x887777DC, 0xCDCC9989, 0x7C8878D7),\n        ivec4(0xDDCC9C9C, 0xCD8999C9, 0xCDCCCC99, 0xCDDD9CD9),\n        ivec4(0xCDCCCC9C, 0xDEDDCD99, 0xDDCC9999, 0xCCDDDC9C),\n        ivec4(0xECCC9C99, 0x99999CC9, 0xECCD99A9, 0x989899C9),\n        ivec4(0x40D7FEEE, 0x14010000, 0xE7CFCCCC, 0x4000001),\n        ivec4(0xFFADBBCA, 0xC7, 0xEFCDDCCD, 0xF7),\n        ivec4(0x8DCBCCCC, 0xFD, 0x889AA9AC, 0x30FF),\n        ivec4(0x8899999C, 0x7D04C4EF, 0x89899999, 0xA938A5FF),\n        ivec4(0x898898A9, 0x898797CF, 0xCC999989, 0x8C9889DD),\n        ivec4(0xCDCCCC99, 0xDD9CC9DC, 0xCDCCCC99, 0xDDDD9CD9),\n        ivec4(0xDDCCCC9C, 0xDDDDDDCC, 0xDDCC9C99, 0xCCDCCCCC),\n        ivec4(0xDD9C9C99, 0x99C99C9C, 0xDD9D9989, 0x99999999),\n        ivec4(0x40D7FEEF, 0x14010000, 0xEBEFEDCD, 0x4000001),\n        ivec4(0xEFACBBCB, 0x400000CC, 0xEFBCCBDC, 0xFE),\n        ivec4(0xCECDDDCC, 0x70FF, 0x8ACCCCCC, 0x400C0DF),\n        ivec4(0xA8A9AC9C, 0xBC05F78F, 0x9999C9C9, 0x9938F79F),\n        ivec4(0x9899999C, 0x8988FA9F, 0x88989999, 0x8C98DC9D),\n        ivec4(0x9C999999, 0xDD9CCCCD, 0xCCCCC999, 0xDEDD9DDD),\n        ivec4(0xCDCCCC9C, 0xEDDDDDDD, 0xCDCC9C99, 0xCCDCCCCD),\n        ivec4(0xDD9C9C99, 0x99C99CC9, 0xDD9999A9, 0x989998C9),\n        ivec4(0xDBFFEF, 0x11100000, 0xEAEFEECE, 0x4001010),\n        ivec4(0xEFCCCCCA, 0x440070EA, 0xCFBBBBCC, 0xB0FE),\n        ivec4(0xCEA9CCCD, 0xD0FF, 0xDCDDCDCD, 0x500F3DF),\n        ivec4(0xAACCCCCC, 0xAC05FC8D, 0x999CCCAC, 0x9978FE89),\n        ivec4(0x9C99C99C, 0x8C87FE99, 0x99C9CC9C, 0x9DC8EF9C),\n        ivec4(0x8999999C, 0xDDCDDD89, 0x99999999, 0xDEDDDDCC),\n        ivec4(0xCCCCCC9C, 0xDDDDDDDD, 0xCC9C9C99, 0xCCDCCCDD),\n        ivec4(0xCD9C9999, 0x99C9CCC9, 0xCD9999A9, 0x999998C9),\n        ivec4(0x70ECFFEF, 0x11010000, 0xFDEFEECD, 0x4001070),\n        ivec4(0xCFCCCCCB, 0x4000B0FA, 0xADBBBBCC, 0xA0FF),\n        ivec4(0xCDB8CDCD, 0xE6FF, 0xDDDDCCCC, 0x700FAEF),\n        ivec4(0xCACCCCCC, 0x9C27FEAC, 0xC9CCCCCC, 0x9978CF88),\n        ivec4(0x99999CCC, 0x8997CF98, 0x999CCC9C, 0xCDC9DF99),\n        ivec4(0x99C9C99C, 0xDDDECE99, 0x98989999, 0xDEEDDD89),\n        ivec4(0xC9999C9C, 0xDDDDDDCC, 0xCCC9C999, 0x9CDCCCCD),\n        ivec4(0xCC999999, 0x99C99CC9, 0x9C8999A9, 0x999898C9),\n        ivec4(0xD7EFEFDD, 0x14010000, 0xEFCDCDCC, 0x40030C3),\n        ivec4(0xCEAABBCA, 0x400B0FE, 0xAD8BC9CD, 0xC0FF),\n        ivec4(0xDDDCDDCC, 0xF7FF, 0xCCCDCCCC, 0xB00FCCD),\n        ivec4(0xCACCCCCC, 0xCC47DE88, 0x99C9CCAC, 0x8988CF88),\n        ivec4(0x99999C9C, 0x8C97CF99, 0x999CCC9C, 0xCDD9CF99),\n        ivec4(0x99C9999C, 0xDDDDCE89, 0x88989999, 0xEEEDCE89),\n        ivec4(0xC999C999, 0xDCDDDDCC, 0xCCC99999, 0x9CCCCCCC),\n        ivec4(0x9C999999, 0x99C9C9C9, 0x9C898989, 0x89899999),\n        ivec4(0xFDDECDCC, 0x5010010, 0xCFA9BBCA, 0x40010DA),\n        ivec4(0xCE8ACACC, 0x70FE, 0xDDDCDCDC, 0xA0FF),\n        ivec4(0xCADDCCCC, 0xF6CE, 0x989CCCCC, 0x1B00FB89),\n        ivec4(0x99A99C9C, 0x9C17ED88, 0x99999C9C, 0x8978EF98),\n        ivec4(0x9999C99C, 0x7C88DF89, 0x88989999, 0xDDC9DD88),\n        ivec4(0x89989999, 0xDDDDCC99, 0x9C999999, 0xEEDDDECC),\n        ivec4(0xCCCCC99C, 0xCDDDDDCD, 0xCC99C999, 0x99CC9CCC),\n        ivec4(0x9D9999A9, 0x99C99999, 0x9D988888, 0x89899899),\n        ivec4(0xFDCC9C9A, 0x11000010, 0xDFA9B7CC, 0x40000D9),\n        ivec4(0xDF9DDCCD, 0x40FD, 0x99DCCCCC, 0x70DF),\n        ivec4(0xA8C9CCCC, 0xD08E, 0x989899C9, 0x1B00F38D),\n        ivec4(0x9898999C, 0xAC57FA8C, 0x9899999C, 0x8978F98D),\n        ivec4(0x88889999, 0x8987EC89, 0x89889998, 0xCD99DC9C),\n        ivec4(0x9C9C9999, 0xDDDD99CD, 0xCC9C9C9C, 0xEEDDCDCD),\n        ivec4(0xCCC9C999, 0xDCDDDDDD, 0xCCC99999, 0xC9C99CCC),\n        ivec4(0xCD999999, 0x99C999C9, 0xCD898988, 0x89899999),\n        ivec4(0xF99D8AAB, 0x1000010, 0xEF8C97CC, 0xC7),\n        ivec4(0xCEDCDCCD, 0xFB, 0x88C9CCAC, 0xDE),\n        ivec4(0x87999A9C, 0xA09F, 0x88899899, 0x700E09F),\n        ivec4(0x88889999, 0x8C07E79E, 0x88889999, 0x8877E78D),\n        ivec4(0x888888A8, 0x7887989D, 0x99999999, 0x9D9899CD),\n        ivec4(0x9C9C9999, 0xDDCD99DC, 0xCC9C9C9C, 0xDEDDCDDC),\n        ivec4(0xCC9C9C99, 0xCCDDDCCC, 0xCD999999, 0x99CCCCCC),\n        ivec4(0xCD9999A8, 0x99999999, 0xCD9C8888, 0x88889999),\n        ivec4(0xF79EA9A8, 0x1000010, 0xFE9DB8DC, 0xC0),\n        ivec4(0xCEC9DCCC, 0xE6, 0x8898CC9C, 0xEC),\n        ivec4(0x8899A899, 0x50CF, 0x888898C9, 0x500B0DF),\n        ivec4(0x88889999, 0x8C05C1CF, 0x88888889, 0x8857939E),\n        ivec4(0x898998A8, 0x787877CD, 0xCC999999, 0x8C8889DC),\n        ivec4(0xCDCCC999, 0xDD9C99D9, 0xCCCCC999, 0xDDDD9DD9),\n        ivec4(0xCCCCC999, 0xDDDDDDCC, 0xDD999999, 0x99CCCC9C),\n        ivec4(0xDD9C99A8, 0x99C99999, 0xDD9C8998, 0x88889999),\n        ivec4(0xD1CFA9A8, 0x1000010, 0xFDCE88CC, 0x80),\n        ivec4(0xCECACDCD, 0xD0, 0x7998C9AC, 0xF3),\n        ivec4(0x88A9A899, 0xFD, 0x88889899, 0x50FF),\n        ivec4(0x88889899, 0x7C0071DF, 0x89888888, 0x883773CE),\n        ivec4(0x9C989989, 0x787737D9, 0xCC9C9C99, 0x898889D7),\n        ivec4(0xCDCCC999, 0xDC8C99D9, 0xCDCCC999, 0xDDDD8DD9),\n        ivec4(0xCDCCC999, 0xDDDDDD99, 0xDDCC9999, 0xCCDCCC9C),\n        ivec4(0xDD9C99A9, 0x99999C99, 0xDDCD9988, 0x88999999),\n        ivec4(0xA1DF99AA, 0x1000000, 0xFCCE8ACA, 0x70),\n        ivec4(0xDFC9DCCD, 0xB0, 0x7D889CAC, 0xE0),\n        ivec4(0x89899899, 0xFA, 0x8C889899, 0xFD),\n        ivec4(0x88889899, 0x790030EE, 0x89888888, 0x881773DD),\n        ivec4(0x9D9899A9, 0x887733D7, 0xCDCC9999, 0x798888C1),\n        ivec4(0xDDCCCC99, 0xCD8999C9, 0xCDCC9999, 0xCDDD9CC9),\n        ivec4(0xDDCCC999, 0xEEDDDD99, 0xDD9C9999, 0xCCDDCC9C),\n        ivec4(0xEDCD99A9, 0x99999C9C, 0xDDCD9989, 0x88999999),\n        ivec4(0x70EF9CAC, 0x11000000, 0xFCCF8ACB, 0x10),\n        ivec4(0xEFCCCCCD, 0x70, 0x8D98CCCC, 0xD0),\n        ivec4(0x8989A999, 0xF7, 0x8C889899, 0xFC),\n        ivec4(0x89889899, 0x7A0050FD, 0x89888889, 0x891771EC),\n        ivec4(0x9D9999A9, 0x887733D7, 0xCDCCC999, 0x798878C3),\n        ivec4(0xDDCCCC9C, 0xCD989999, 0xDDCCCC99, 0xCDDD9CC9),\n        ivec4(0xDDCC9C9C, 0xEEDDDD9C, 0xEDCD9999, 0xDCDDDC9C),\n        ivec4(0xEDCD9C99, 0x999C9C9C, 0xECDD9C89, 0x989999C9),\n        ivec4(0x20EDCDCC, 0x10000000, 0xEACF8ACB, 0x10),\n        ivec4(0xFECEC9DD, 0x70, 0x9E98CCCC, 0xC0),\n        ivec4(0x7C9A9999, 0xF3, 0x8C8999C9, 0xFA),\n        ivec4(0x89889899, 0x3A0020FD, 0x898898A9, 0x890870EC),\n        ivec4(0x9C9898A8, 0x887737D7, 0xCDCCC999, 0x788878C1),\n        ivec4(0xDDCCCC9C, 0xCD889999, 0xDDCCCC99, 0xDDDD9CC9),\n        ivec4(0xDDCC9C9C, 0xDEDDDD99, 0xEDCD9999, 0xCDDDDC9C),\n        ivec4(0xECCD9C99, 0x99C99CCC, 0xECDE9C99, 0x99C999C9),\n        ivec4(0x10ECEECE, 0x11000000, 0xE89FAACB, 0x10),\n        ivec4(0xFFCEC8DD, 0x70, 0xCFD9DDCC, 0xC0),\n        ivec4(0x889ACCCC, 0xF5, 0x989899AC, 0xFC),\n        ivec4(0x999899CC, 0x5A0020FD, 0x88889999, 0x890830ED),\n        ivec4(0x9C8999A9, 0x887777D8, 0xCD9C9C9C, 0x798878C1),\n        ivec4(0xDDCCCC9C, 0xCD989999, 0xDDCCCC9C, 0xDDDD9CC9),\n        ivec4(0xDCCDCC9C, 0xDEDDDDC9, 0xEDCD9C9C, 0xDDDDDC9C),\n        ivec4(0xECCD9C99, 0x99C9CCCC, 0xECDE9C99, 0x98C99999),\n        ivec4(0x20FCFEDE, 0x11000000, 0xF8CEC9CA, 0x4000070),\n        ivec4(0xFF8CCBDE, 0xA0, 0xDFDDDECD, 0xE0),\n        ivec4(0x88CCCCCC, 0xEB, 0x8899C9CC, 0xCE),\n        ivec4(0x999AC9CC, 0x5A0070CF, 0x8999C99C, 0x990871CF),\n        ivec4(0x89989999, 0x887777CD, 0xCCCCC9C9, 0x798878D7),\n        ivec4(0xCDCCCCCC, 0xCD9899C9, 0xDECCCC9C, 0xDDDD99D9),\n        ivec4(0xDDCDCC9C, 0xDEDDDD99, 0xEDCCCC99, 0xDDDDCD9D),\n        ivec4(0xFDCDC999, 0x99C99C9C, 0xECDD9C99, 0x98C999C9),\n        ivec4(0x50FCFFEE, 0x11000000, 0xFCDEDDDC, 0x4000070),\n        ivec4(0xDFB9CBDD, 0xE4, 0xDFCAEEDD, 0xF7),\n        ivec4(0xDCEEDDCC, 0x20EE, 0xC8CCCCCC, 0x708D),\n        ivec4(0x99C9CCCC, 0x7C00D49D, 0x99C9CCCC, 0x8918E39D),\n        ivec4(0x9999CC9C, 0x8978D79C, 0x9999CC99, 0x798899CC),\n        ivec4(0xCCCCCCCC, 0xCD99CCDD, 0xCDCDCC9C, 0xDDDD8CDC),\n        ivec4(0xDDCCCC9C, 0xEEDDDDC9, 0xDDCCCC9C, 0xDDDDDCCC),\n        ivec4(0xEDCDCC99, 0x99C99CCC, 0xEDCD9C99, 0x98C999C9),\n        ivec4(0x10DBFFEF, 0x11000000, 0xFAFFEFDE, 0x4000011),\n        ivec4(0xDFDCCCDC, 0x40000FA, 0xCDBBECCD, 0x10FE),\n        ivec4(0xCDECEECD, 0xA0FF, 0xEDDEDDCC, 0xE0DE),\n        ivec4(0xCCCCCCCC, 0x8C01E7A8, 0xCCCCDCCC, 0xA958DC98),\n        ivec4(0xC9CCCCCC, 0x8987DD9C, 0x99CCCCCC, 0x8C98DE99),\n        ivec4(0x99CCCCCC, 0xDD9CDC9C, 0xCCCCCC9C, 0xDDDDCDCC),\n        ivec4(0xDCCCCCCC, 0xEEDDDDDC, 0xCDCCCC9C, 0xCDDDDCCD),\n        ivec4(0xDECCCC9C, 0xC9C99CCC, 0xDDCC9989, 0x999999C9),\n        ivec4(0xC7EEEF, 0x11010000, 0xD7FFFFDF, 0x4000000),\n        ivec4(0xFFFFEEDD, 0x40030FC, 0xCDCDCCCD, 0xB0FF),\n        ivec4(0xBCBBDDCD, 0xE2DF, 0xBAEDDECC, 0xFADF),\n        ivec4(0xEEEEDDCC, 0xAC05FEEE, 0xDCDCCCCC, 0x8CA89ED9),\n        ivec4(0xCCCCCDCC, 0x89C88CC9, 0xCCCCCCCC, 0x8CD89C9C),\n        ivec4(0xCCCCCCCC, 0xDDEC9D9C, 0xC9CCCC9C, 0xDDEDCD99),\n        ivec4(0xCCCCCCCC, 0xEEDDDD9C, 0xCCCCCC9C, 0xDDDDCDCC),\n        ivec4(0xCCCCC99C, 0xC9C9CCDC, 0xCD9999A9, 0x999999C9),\n        ivec4(0x40B7DDEE, 0x11010000, 0xA3FDFFEE, 0x4000000),\n        ivec4(0xFFFFEFDD, 0x400070D7, 0xEEEEDEDC, 0xC4FF),\n        ivec4(0xCCBBCCCD, 0xF7DF, 0x7BDBDECC, 0x40FDCE),\n        ivec4(0xCAEEDECC, 0xAD76FFCE, 0xEEDECDCC, 0x99C8EFEE),\n        ivec4(0xCDCDCCCC, 0x8CF89CDC, 0xCCCCCCCC, 0x8CCC98CC),\n        ivec4(0xCCCDDDCC, 0xDDCDC9C9, 0xCCCCCCCC, 0xDDDF9CC9),\n        ivec4(0xCCCCCCCC, 0xEFDD9C9C, 0xCCCCC999, 0xDDDD9D99),\n        ivec4(0xC9CC9C99, 0xCCCCCC9C, 0x9C9999A9, 0x99C9C9C9),\n        ivec4(0x40C7EEEF, 0x11010000, 0xC7FEFFEF, 0x4000000),\n        ivec4(0xFFFFEFDD, 0x440070E7, 0xDEDECDCD, 0xC0FF),\n        ivec4(0xCCBBCCCD, 0x40F7CF, 0x7ACBDECC, 0x40FCCE),\n        ivec4(0xCAEEDECC, 0xAC76FFCE, 0xEEEECDCC, 0x9CC8EFEE),\n        ivec4(0xDDCCCCCC, 0x8CF8CCDC, 0xCCCCCCCC, 0x8CCC88CC),\n        ivec4(0xCCCDCDCC, 0xDD8DC999, 0xCCCCCCCC, 0xDDCF9CC9),\n        ivec4(0xCCCCCCCC, 0xEECECC99, 0xCC9C999C, 0xDDDE9999),\n        ivec4(0x99CC9999, 0xCCDC9C99, 0xC9C999A9, 0x99999999),\n        ivec4(0x50DBFFEF, 0x11010000, 0xF9FFEFDE, 0x4000010),\n        ivec4(0xDFEECDCD, 0x40FC, 0xCCBBCBCD, 0x70FF),\n        ivec4(0x9CB7DDCD, 0xD6CF, 0xBCFCDECC, 0xFADF),\n        ivec4(0xFEDEDDCC, 0x8C02FEDE, 0xCDCDCCCC, 0xACA8CEC9),\n        ivec4(0xCCCCCCCC, 0x8CD888C9, 0xCCCCCDCC, 0x8CD89899),\n        ivec4(0xC9CCCCCC, 0xDDDC9C99, 0xC9CCC9C9, 0xDDED9999),\n        ivec4(0xC9CC9999, 0xEEDD9C99, 0x999C9CC9, 0xDDDD9D99),\n        ivec4(0x999C9C99, 0xCCCCCC99, 0x9C9999AA, 0x99999999),\n        ivec4(0xB0FEFFDE, 0x1010000, 0xFEDDDDDC, 0x31),\n        ivec4(0xCEACBBCC, 0xFA, 0xAC78DCDD, 0x10FE),\n        ivec4(0x9DEADECD, 0xC0EF, 0xEEDECDCC, 0xF1DE),\n        ivec4(0xCDCCCCCC, 0x8C01CCA8, 0x9CCCCCCC, 0x89788C98),\n        ivec4(0x99C9CCCC, 0x89878D99, 0x99CCC999, 0x8CC89E99),\n        ivec4(0x99C9C999, 0xDDC99D88, 0x98999CC9, 0xDDDD9D89),\n        ivec4(0x99999C9C, 0xEEDDCD9C, 0xC9C99C9C, 0xDDDDCDCC),\n        ivec4(0x9C999999, 0xCCC99CC9, 0xCC9998A8, 0x99999999),\n        ivec4(0xC1EEEEDD, 0x1000000, 0xDFCCBCCC, 0x80),\n        ivec4(0x9E8BC7DD, 0xF6, 0xCE9BEDCD, 0xFC),\n        ivec4(0xDDEDCDCC, 0xB0DE, 0xC9CCCCCC, 0x400C089),\n        ivec4(0xC9C99CCC, 0x8C01C388, 0x9899C9C9, 0x8937DA88),\n        ivec4(0x8899CC99, 0x8977DC99, 0x88999C99, 0x8C87CD88),\n        ivec4(0x88989999, 0xDD99C989, 0x99C9999C, 0xCDDDCDCC),\n        ivec4(0xCCC99C9C, 0xEEDDDDCC, 0xCCC9999C, 0xCDDDCCCC),\n        ivec4(0xCC999999, 0x9CC99CC9, 0xCC9988A8, 0x98999999),\n        ivec4(0xD3DEDDCC, 0x1000000, 0xDFA978CC, 0x80),\n        ivec4(0xCF7AEBCE, 0xD0, 0xDDDDDECC, 0xEB),\n        ivec4(0xCACCCCCC, 0x308D, 0x98C9CC9C, 0x4007088),\n        ivec4(0x899A999C, 0x8C01D189, 0x9898CCC9, 0x8937E389),\n        ivec4(0x88989999, 0x8877D789, 0x88989999, 0x8C87C99C),\n        ivec4(0x9C99999C, 0xDD9999CC, 0x9CCC9CAC, 0xCDDD9CD9),\n        ivec4(0xCC9C9C9C, 0xEEDDDDC9, 0xDC999C99, 0xDCDDCCCC),\n        ivec4(0xDC999999, 0x99999C99, 0xDC9C8988, 0x98999999),\n        ivec4(0xE7CDCCCA, 0x1000000, 0xDFB987DD, 0x10),\n        ivec4(0xDE9CEDCD, 0xC0, 0xC9DDCCCC, 0xC7),\n        ivec4(0x9899CCC9, 0x8C, 0x889899C9, 0x100308D),\n        ivec4(0x889AC999, 0x7C01C08D, 0x889899C9, 0x8918C18C),\n        ivec4(0x8898999A, 0x7877839C, 0x9C9999C9, 0x7C8889C8),\n        ivec4(0xCC9CCC99, 0xDD8C99CC, 0xCDCC9CC9, 0xCDDD9CC9),\n        ivec4(0xCDCCC999, 0xDEDDDD99, 0xDC9C9999, 0xCCDDCC9C),\n        ivec4(0xECCC9999, 0x999999C9, 0xDCCD99A8, 0x98999999),\n        ivec4(0xE79DA9C9, 0x1000000, 0xEDBCC7DE, 0x0),\n        ivec4(0xDDDDDDCD, 0xA0, 0x98CCCCCC, 0x97),\n        ivec4(0x989AC999, 0x89, 0x8898C9CC, 0x400109E),\n        ivec4(0x88989999, 0x8900718E, 0x88989999, 0x8917719D),\n        ivec4(0x99999999, 0x787733D7, 0xCCCC9C9C, 0x89888993),\n        ivec4(0xCECC9C9C, 0xCD8C99CC, 0xCDCCCCC9, 0xCDDD8DC9),\n        ivec4(0xDDCC9C9C, 0xEDDDDD8C, 0xECCD999C, 0xCCDDCC9C),\n        ivec4(0xECCD9C99, 0x99999CC9, 0xECCE9CA9, 0x98989999),\n        ivec4(0xD3CEA9C9, 0x11000000, 0xFC8CC7DE, 0x0),\n        ivec4(0xCDDEDECD, 0xB0, 0x88CCCCCC, 0x91),\n        ivec4(0x98A8999C, 0x98, 0x8898CC9C, 0xCE),\n        ivec4(0x8898C999, 0x8C00309E, 0x8999999A, 0x891771DC),\n        ivec4(0x9CC9999C, 0x787713C1, 0xCDCCCC9C, 0x89888971),\n        ivec4(0xDECCCC9C, 0xDD8C9999, 0xDCCCCCC9, 0xCDDD9CC9),\n        ivec4(0xECCDC99C, 0xEDDDDD9C, 0xFCDDCC99, 0xCCDDCC9C),\n        ivec4(0xFCDECC99, 0x99999CCC, 0xECDECC99, 0x98999999),\n        ivec4(0xD3CEACDC, 0x11000000, 0xF9BCD7DE, 0x4000000),\n        ivec4(0xDDDEEECC, 0xB0, 0x98CCCCCC, 0x91),\n        ivec4(0x99999CCC, 0x98, 0x9898CC9C, 0xCE),\n        ivec4(0x8898C999, 0x7C00109E, 0x99999999, 0x891870D9),\n        ivec4(0xCCCCCC9C, 0x787713C1, 0xDDCCCC9C, 0x89888931),\n        ivec4(0xDDDCCCCC, 0xDD8C9989, 0xDCCDCCCC, 0xCDDD9DC9),\n        ivec4(0xFCCDCC9C, 0xEEDDDD9C, 0xFCDECC9C, 0xCCDDCC9D),\n        ivec4(0xFDDFCD9C, 0x99C99CCC, 0xECDECD99, 0x899999CC),\n        ivec4(0xE3CEACDD, 0x15000000, 0xEDBCE8DF, 0x4000000),\n        ivec4(0xEEDDEECC, 0xA0, 0xD8DCCCCC, 0x98),\n        ivec4(0x99C9CCCC, 0x89, 0x99C9CCCC, 0x10CE),\n        ivec4(0x88C9CC9C, 0x8C00709E, 0x999999AC, 0x890870DC),\n        ivec4(0xCCCCCCCC, 0x787733C3, 0xDDCCCC9C, 0x89888971),\n        ivec4(0xDDDDCCCC, 0xDD9C9989, 0xDCCDCCCC, 0xCDDD9CC9),\n        ivec4(0xEDCDCC9C, 0xEEDDDD9C, 0xFCDECC9C, 0xCCDDDC9D),\n        ivec4(0xFDDFCD9C, 0x99999CCC, 0xECDECD99, 0x8999999C),\n        ivec4(0xF8EEDDDE, 0x15010000, 0xCFB9FCCE, 0x4000080),\n        ivec4(0xDFECEFCD, 0xE2, 0xEEDECDCC, 0x30CD),\n        ivec4(0xCCDCDCCC, 0x9099, 0xC9CCCCCC, 0x400D19C),\n        ivec4(0x99DCCCCC, 0x8C01E79C, 0x99CCCCCC, 0x9918C19D),\n        ivec4(0xCCCCCCCC, 0x887783CD, 0xCDCCCCCC, 0x8C888C98),\n        ivec4(0xDEDDCDCC, 0xDD9CC9CC, 0xDDCDCCCC, 0xDDEDCDC9),\n        ivec4(0xEDCDCDCC, 0xEDDEDD9C, 0xFDDECCCC, 0xCCDDDDCD),\n        ivec4(0xFDDFCD9C, 0xC9C9CCCC, 0xECDECD9C, 0x9999C9C9),\n        ivec4(0xFEFFEEEE, 0x15111070, 0xDECDFECE, 0x440000F7),\n        ivec4(0xBCFCEFCC, 0x400410FE, 0xEDFFCECC, 0xA1EF),\n        ivec4(0xEEDEDDCD, 0xDCFD, 0xCDDDDCCC, 0x580C9CC),\n        ivec4(0xDCDCCDCD, 0x9D85CDCC, 0xCCCDCCCC, 0x99C8CDCC),\n        ivec4(0xCCCDDCCC, 0x8987CDCC, 0xDCCCCCCC, 0x8DC8DDCD),\n        ivec4(0xDDDDDDCC, 0xDDCDCCDD, 0xDDCDCCCC, 0xDEEECDDC),\n        ivec4(0xDDDDDDCC, 0xEEEEDDCD, 0xFDDDCCCC, 0xCCDDDDCD),\n        ivec4(0xFDDDCC9C, 0xCCCCCCCC, 0xFDDECCCC, 0x9999CCC9),\n        ivec4(0xFFFFEFDE, 0x551110A1, 0xFFEFEFDE, 0x440450FD),\n        ivec4(0xCCFDDECC, 0x4414D4DF, 0xFBFFCDCC, 0x4440F7AD),\n        ivec4(0xFFDEDCCC, 0x4070FEEE, 0xEEDDDCCC, 0x17E8FDEE),\n        ivec4(0xDDDDDDCD, 0xCD9CCDDD, 0xDDDDDCCC, 0x9CDDCCCC),\n        ivec4(0xCCCDCDCD, 0x99DDCCDC, 0xDCCCCDCC, 0x9DDDCCDC),\n        ivec4(0xCDCCDCCC, 0xEDDDCDCD, 0xCDCDCDCC, 0xDEEEDEDD),\n        ivec4(0xDDDDDCCC, 0xEEEEDDDD, 0xDDCCCCCC, 0xCCDDDDDD),\n        ivec4(0xDDCDCCCC, 0xCCCCCCDC, 0xEDCCCC99, 0x9999CCCC),\n        ivec4(0xFFFFEFDE, 0x551103C7, 0xFFFFEEDE, 0x440471FF),\n        ivec4(0xDDFEDECD, 0x404FBEE, 0xFBDFCCCC, 0x4414DFAC),\n        ivec4(0xFFDECDCC, 0x4B0DFCA, 0xEFCDCCCD, 0x57FCDFFE),\n        ivec4(0xDDDDDCCC, 0xEDDDEEEE, 0xCDCDDDCC, 0xCDDCDCCD),\n        ivec4(0xDDCDCDCD, 0xCCCCCCCD, 0xCDCCCCCC, 0xEECCCCDC),\n        ivec4(0xDDDCDCCC, 0xEECDDCCC, 0xCCDCCCCC, 0xEECDDCCC),\n        ivec4(0xCDCCCDCC, 0xEEDEDCCD, 0xCCDCCCCC, 0xDCDDDDCD),\n        ivec4(0xCCCCCCCC, 0xC9CCCCDC, 0xCDC9C999, 0x99C9C9CC),\n        ivec4(0xFFFFEEDE, 0x151111FC, 0xEFEEEECD, 0x4404D1FF),\n        ivec4(0xDAEFCDCC, 0x444FCDC, 0xFDDECCCC, 0x474CEBC),\n        ivec4(0xEFCDCDCC, 0x4E7CEFA, 0xDECDCDCC, 0xA7FEFEFF),\n        ivec4(0xCDCDDCCC, 0xDEDCDDDD, 0xCDCDDDCC, 0xCCDCDCCC),\n        ivec4(0xCDCDDCCC, 0xCDC9CCCD, 0xCCCCCCCC, 0xCFCCCCDC),\n        ivec4(0xDDCCCCCC, 0xDEC9CDDC, 0xCCCCCCCD, 0xDECCCCCC),\n        ivec4(0xDCCCCCCC, 0xEECDDCCC, 0xCCDC9C99, 0xDCCDDCCC),\n        ivec4(0xCCCCCC99, 0xC9CCCCCC, 0x9CC99C99, 0x9999C9CC),\n        ivec4(0xEFEDEECD, 0x550131FD, 0xACEECDCC, 0x4440E3DD),\n        ivec4(0xFBEFCCCC, 0x4444DC8C, 0xFFCDCCCC, 0x4B4DECB),\n        ivec4(0xDECCCCCC, 0x50EDEFFF, 0xCDCDCDCC, 0xDBDCDDCD),\n        ivec4(0xCCCDCCCC, 0x9CC9CCCC, 0xDCCCCCCC, 0xCC99C9CC),\n        ivec4(0xCCCCCDCC, 0xDD99C9CC, 0xCCCCCCCC, 0xDE9CCCCC),\n        ivec4(0x99CCCCCC, 0xDD9CCCCC, 0xC9CCCCCC, 0xEECDCCCC),\n        ivec4(0x9CCC9C9C, 0xDDDDCCCC, 0x9CCC9C9C, 0xCCCDCCCD),\n        ivec4(0x9C999C99, 0xC9CC99CC, 0x9C899999, 0x999999C9),\n        ivec4(0xCDECDDCC, 0x10131DD, 0xB8EECDC9, 0xD19D),\n        ivec4(0xF9DECCCC, 0x4400EBBC, 0xDFCDCCCC, 0xC2EFEE),\n        ivec4(0xCDCCCCCC, 0x50CCCDCD, 0xCCCCCCCC, 0x87C8C9CC),\n        ivec4(0xCCCCCCC9, 0xCCAC98C9, 0xCCCC9CCC, 0xD99C98CC),\n        ivec4(0x9C99CCCC, 0xC89C999C, 0x99999C9C, 0x9C9D999C),\n        ivec4(0x9CC9C9C9, 0xDDCDC9CC, 0xCCCC99C9, 0xDDDDCCCC),\n        ivec4(0xCCC9CC99, 0xDDDDCDCD, 0x9C9C9999, 0xCCCDCCCC),\n        ivec4(0x9C9999A9, 0x99CC9CCC, 0x9D898888, 0x89899999),\n        ivec4(0xCCDADE9C, 0x10000EA, 0x88EECDB9, 0x70CE),\n        ivec4(0xFADEC9CC, 0xE7CE, 0xDDCCCC9C, 0x94EDDD),\n        ivec4(0xCCCC9C9C, 0x8ACCCC, 0xCCC99999, 0x298889A),\n        ivec4(0xC9CC9C9C, 0x8C9D8899, 0x9C99C99C, 0x88CD9899),\n        ivec4(0x999899C9, 0x78C988C8, 0xC9999999, 0x79C99CC9),\n        ivec4(0xC9C99999, 0xDD9CCCCC, 0xCC9CC999, 0xCCDDCCCC),\n        ivec4(0xCCCC9999, 0xDEDDDCCC, 0xCC999999, 0xCCCDCCCC),\n        ivec4(0xCD999888, 0x9999999C, 0x9D898988, 0x88999999),\n        ivec4(0xCDCADEAC, 0x10000D7, 0x7AFDCDAA, 0xCD),\n        ivec4(0xECDE9C9C, 0xC7DF, 0xCDCC9C9C, 0x80D9DD),\n        ivec4(0xCCCC9C99, 0x909ACA, 0xC9C99999, 0xC18998),\n        ivec4(0x999CC999, 0x7CD88999, 0x9C989999, 0x88C88898),\n        ivec4(0x99889999, 0x38C79C98, 0xC99C9999, 0x7898CCC9),\n        ivec4(0xC99C9C99, 0x9D8899CC, 0xCC9C9C99, 0xDCDD99DC),\n        ivec4(0xCCCC9999, 0xDDDDCDC9, 0xCD999999, 0xDCCDCC9C),\n        ivec4(0xCD999988, 0x99999999, 0xCD998988, 0x88999999),\n        ivec4(0xCDC9DEAC, 0x10000C1, 0x8AEDCDA9, 0xD8),\n        ivec4(0xECDE9C99, 0xB4DE, 0xCDCC99A9, 0x30C9DD),\n        ivec4(0xC9C999A9, 0x70999A, 0xC9C99989, 0x908998),\n        ivec4(0x99999999, 0x7AD08C98, 0x99889999, 0x88878998),\n        ivec4(0x99889899, 0x38839C98, 0xC9999999, 0x7788C9CC),\n        ivec4(0xCCCC9998, 0x8C8899CC, 0xCCC99999, 0xDCCD89D9),\n        ivec4(0xCCCC9999, 0xDDDDCDC9, 0xCD9C9999, 0xDDCCCC8C),\n        ivec4(0xDD999988, 0x99CC998C, 0xDD998988, 0x88999899),\n        ivec4(0xDDDCDEAC, 0x1000070, 0x8CFCCDAA, 0xE1),\n        ivec4(0xECCE9C99, 0x70EE, 0xDCCCC9A9, 0xC9DE),\n        ivec4(0xA99C9989, 0x509999, 0xC99C9998, 0x708C98),\n        ivec4(0x99999999, 0x18808D98, 0x89889999, 0x88138D98),\n        ivec4(0x99889999, 0x7833C999, 0xCC999999, 0x7787C8CC),\n        ivec4(0xCCCC9999, 0x898899C9, 0xCD9C9999, 0xDC9D98C9),\n        ivec4(0xDCCC9C99, 0xCDDD9D99, 0xDD9C9999, 0xDDDDCC9C),\n        ivec4(0xDDCC9989, 0x99CCC989, 0xDDCD8988, 0x98999899),\n        ivec4(0xDDDDDFAC, 0x1000050, 0xBCFC9DA9, 0xD1),\n        ivec4(0xDCCE9C99, 0x70ED, 0xCDCC9CA9, 0xC8DD),\n        ivec4(0x9C9C9989, 0xC99A, 0xC99C9989, 0x109D98),\n        ivec4(0x99999999, 0x17309D99, 0x8988999C, 0x8803CC88),\n        ivec4(0x99999999, 0x7837C79C, 0xCC999999, 0x778788CC),\n        ivec4(0xCDCC9999, 0x88889988, 0xCDCCC999, 0xDD9C98C9),\n        ivec4(0xDCCCC999, 0xCCDD9D99, 0xEC9D9C99, 0xDDDDCC9C),\n        ivec4(0xECCD9999, 0xC9CC999C, 0xECCE9C89, 0x98999999),\n        ivec4(0xECEEEE9C, 0x10000010, 0xADFDCDAA, 0xC1),\n        ivec4(0xDCDE9999, 0x40EC, 0xDECCC9A9, 0xC7DE),\n        ivec4(0x9C9C9989, 0xCCCC, 0x999C9999, 0x9D98),\n        ivec4(0x99C99999, 0x7109DC9, 0x8988999C, 0x8807CC88),\n        ivec4(0x9C999999, 0x7817C79C, 0xCC999999, 0x778787CC),\n        ivec4(0xCDCC9C99, 0x88989C88, 0xCDCC9C9C, 0xDD999899),\n        ivec4(0xDCCC9C9C, 0xDCDD9CC9, 0xECCD9C9C, 0xDDDDDD99),\n        ivec4(0xECCD9C99, 0xCCCCC99C, 0xFCDE9C99, 0x98999999),\n        ivec4(0xFCEEEFCC, 0x11010110, 0xCDFDCE99, 0x40000C0),\n        ivec4(0xCCDE9C99, 0x10EB, 0xDECD9CA9, 0xD7EF),\n        ivec4(0xCCCC9C99, 0xCCCC, 0xCC9C9999, 0x9DC9),\n        ivec4(0xC9CCCC9C, 0x770CEC9, 0x89989C9C, 0x8907CC99),\n        ivec4(0x9C999C9C, 0x8817C89C, 0xCCCCC999, 0x388787CC),\n        ivec4(0xCDCCCC9C, 0x78989C88, 0xDDCC9C99, 0xDD9C999C),\n        ivec4(0xDCCCCC9C, 0xDCDD9C99, 0xFCCDCC99, 0xDEDDDD99),\n        ivec4(0xFCDD9C9C, 0xCCCDCC9C, 0xECDE9C99, 0x9899999C),\n        ivec4(0xFEFEEECD, 0x11110030, 0xDDFECDA9, 0x40000E3),\n        ivec4(0xEACE9999, 0x40000DD, 0xEECCCC99, 0xE7EF),\n        ivec4(0xCCCC9C99, 0x70DCDD, 0xCC9C9999, 0x80CCC9),\n        ivec4(0xC9CCCC9C, 0x7C0CC99, 0x99C99C9C, 0xA9879DC9),\n        ivec4(0x9999CC9C, 0x8877CDC9, 0xC99C9C9C, 0x7887C8DC),\n        ivec4(0xCDCC9C9C, 0x7898CCC9, 0xCDCCCC9C, 0xDD9C99CC),\n        ivec4(0xDDCCCC9C, 0xDCDD9CC9, 0xDDCDCC99, 0xDEDDDD99),\n        ivec4(0xFCCDCC99, 0xCCCDCC9C, 0xFCDE9C99, 0x9899999C),\n        ivec4(0xFEFFEFCD, 0x15111091, 0xEEEFCCCC, 0x460010EA),\n        ivec4(0xFDCE9C99, 0x4004B0CE, 0xEFCC9C9C, 0x4EADE),\n        ivec4(0xCDCC9C9C, 0xC5EEDE, 0xCCCCC999, 0xD7CDCC),\n        ivec4(0xCCCCCCCC, 0x3BD7CCCC, 0xCCCCCC9C, 0x99DCCCCC),\n        ivec4(0x99C9C9CC, 0x89D89C9C, 0xC9CCCC9C, 0x78C8CDCD),\n        ivec4(0xCCCCCC9C, 0x8998CDDC, 0xCDCCCC9C, 0xDD9DC9DC),\n        ivec4(0xDDCCCCCC, 0xDCEECDCC, 0xDDCCCC9C, 0xEEDDDD9C),\n        ivec4(0xEDCD9C9C, 0xDCCDCC9C, 0xEDCD9C99, 0x99C999CC),\n        ivec4(0xFFFFDECD, 0x151101E8, 0xFEDECCCC, 0x40080EF),\n        ivec4(0xFFCCC9CC, 0x4441E7DD, 0xCECCCC99, 0x450DEFD),\n        ivec4(0xCC9C9C9C, 0x60FAEFDE, 0xCCCC9C9C, 0x80ECCDCC),\n        ivec4(0xCC9CCCCC, 0xAACDCCCC, 0xCCCCCC9C, 0xD9CDC9CC),\n        ivec4(0x99CCCCCC, 0x99CDCC9C, 0xCCCCCC9C, 0x88DCCC99),\n        ivec4(0xCCCCCC9C, 0x8CCCCDCC, 0xCCCCCCC9, 0xEDCDCCDC),\n        ivec4(0xCDCCCC9C, 0xDDEDCDDC, 0xCDCCCC9C, 0xDEDDDDCC),\n        ivec4(0xDDCC9C9C, 0xCCCDCC9C, 0xDD9C9999, 0x99C999CC),\n        ivec4(0xFFEFDEAC, 0x151171FC, 0xFFDDDDCC, 0x4404E7FF),\n        ivec4(0xDE9CCCCD, 0x4462DEFD, 0xCDC9CCCC, 0x4C5CEEF),\n        ivec4(0xCCCC9C9C, 0x74FEFECE, 0xCC9C9C9C, 0xDADEDDCC),\n        ivec4(0xCCCC9CCC, 0xDDCDCCCC, 0xCC9CCCCC, 0xDDC9CCCC),\n        ivec4(0xC9CCCCCC, 0xDDCCCCCC, 0xCCCCCC9C, 0xD9CC9999),\n        ivec4(0xCCCCCC9C, 0xDDCDCCCC, 0xCCCC9C9C, 0xEDDECCCC),\n        ivec4(0xCCCCCC9C, 0xDDEDCDCD, 0xCCCC9999, 0xEDDDDDDD),\n        ivec4(0xCCCCC999, 0xCCCCCCCC, 0xCD999999, 0x99C999CC),\n        ivec4(0xFFEFCD9A, 0x151183FE, 0xEFDECDCC, 0x4610FCFF),\n        ivec4(0xCDCCCDCD, 0x44B4DEFE, 0xCC99CCCC, 0x14D7ECDF),\n        ivec4(0xCCC9CC9C, 0xB4EEEECD, 0xCCC99C9C, 0xEDEECECC),\n        ivec4(0xCC9CCCCC, 0xDDCDCCCC, 0x9CCCCC9C, 0xCCCCCCCC),\n        ivec4(0xCCCCCCCC, 0xCC9CCCC9, 0xCCCCCCC9, 0xCD999CC9),\n        ivec4(0x9CCCCC9C, 0xDE9C9999, 0xCCCC9C9C, 0xDDCCCC9C),\n        ivec4(0xC9C9CC9C, 0xDEDDCDCC, 0xCCC99999, 0xDDDDDCCC),\n        ivec4(0xC9999999, 0xCCCCC9CC, 0x99999998, 0x999999C9)\n);\n\n#endif\n\nvoid mainImage(out vec4 fragmentColor, in vec2 fragmentCoordinates)\n{\n    float minimal_side_resolution = min(iResolution.x, iResolution.y);\n    vec2 image_position = vec2((fragmentCoordinates.x - ((iResolution.x - minimal_side_resolution) * 0.5)) * float(imageWidth) / minimal_side_resolution, (fragmentCoordinates.y - ((iResolution.y - minimal_side_resolution) * 0.5)) * float(imageHeight) / minimal_side_resolution);\n    int x = int(floor(image_position.x));\n    int y = int(floor(image_position.y));\n    vec3 color;\n    if ((x >= 0) && (x < imageWidth) && (y >= 0) && (y < imageHeight))\n    {\n        int image_index = int(iTime * playbackSpeed / 0.075) % imageCount;\n        int index = x + ((imageHeight - 1 - y) * imageWidth) + ((imageWidth * imageHeight) * image_index);\n        color = bitmapPalette[(bitmapBits[index / (4 * indicesPerBitmapBitsElement)][(index / indicesPerBitmapBitsElement) % 4] >> (((((index % 2) == 0) ? (index + 1) : (index - 1)) % indicesPerBitmapBitsElement) * 4)) & 0xF];\n    }\n    else if (((x < 0) && (x >= -primaryBorderSize)) || ((x >= imageWidth) && (x < (imageWidth + primaryBorderSize))) || ((y < 0) && (y >= -primaryBorderSize)) || ((y >= imageHeight) && (y < (imageHeight + primaryBorderSize))))\n    {\n        color = bitmapPalette[primaryBorderColorIndex];\n    }\n    else if ((x == -(primaryBorderSize + 1)) || (x == (imageWidth + primaryBorderSize)) || (y == -(primaryBorderSize + 1)) || (y == (imageHeight + primaryBorderSize)))\n    {\n        color = bitmapPalette[secondaryBorderColorIndex];\n    }\n    else\n    {\n        float time = iTime * playbackSpeed / 0.6;\n        int palette_entry_index = int(time);\n        color = mix(bitmapPalette[palette_entry_index % bitmapPalette.length()], bitmapPalette[(palette_entry_index + 1) % bitmapPalette.length()], pow(fract(time), 0.25));        \n#ifdef ENABLE_VIBING_CAT\n        image_position = fragmentCoordinates * ((vec2(vibingCatImageWidth + vibingCatBorderWidth, vibingCatImageHeight + vibingCatBorderHeight) * 5.0) + vec2(vibingCatBorderWidth, vibingCatBorderHeight)) / minimal_side_resolution;\n        x = (int(floor(image_position.x)) % (vibingCatImageWidth + vibingCatBorderWidth)) - vibingCatBorderWidth;\n        y = (int(floor(image_position.y)) % (vibingCatImageHeight + vibingCatBorderHeight)) - vibingCatBorderHeight;\n        if ((x >= 0) && (x < vibingCatImageWidth) && (y >= 0) && (y < vibingCatImageHeight))\n        {\n            int animation_frame_index = int(floor(iTime * 30.0));\n            int image_index = 0;\n            if (animation_frame_index < vibingCatAnimationFrameCount)\n            {\n                image_index = (animation_frame_index < vibingCatImageCount) ? animation_frame_index : ((vibingCatImageCount + vibingCatImageCount) - animation_frame_index - 1);\n            }\n            else\n            {\n                image_index = (animation_frame_index - vibingCatAnimationFrameCount) % (vibingCatRepeatingFrameCount * 2);\n                image_index = ((image_index < vibingCatRepeatingFrameCount) ? image_index : ((vibingCatRepeatingFrameCount + vibingCatRepeatingFrameCount) - image_index - 1)) + vibingCatRepeatAtImageIndex;\n                \n            }\n            int index = x + ((vibingCatImageHeight - 1 - y) * vibingCatImageWidth) + ((vibingCatImageWidth * vibingCatImageHeight) * image_index);\n            color *= vibingCatBitmapPalette[(vibingCatBitmapBits[index / (4 * indicesPerBitmapBitsElement)][(index / indicesPerBitmapBitsElement) % 4] >> (((((index % 2) == 0) ? (index + 1) : (index - 1)) % indicesPerBitmapBitsElement) * 4)) & 0xF];\n        }\n        else\n        {\n            color *= vibingCatBitmapPalette[vibingCatBorderColorIndex];\n        }\n#endif\n    }\n    fragmentColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "sound_code": "// Ivean Polkka\n\nstruct Instrument\n{\n    uint waveType;\n    float waveRatio;\n    float attackTime;\n    float amplitude;\n    float decayTime;\n    float sustainAmplitude;\n    float releaseTime;\n    float leftRight;\n};\n\nstruct Note\n{\n    float playAtTime;\n    uint instrumentIndex;\n    float frequency;\n    float duration;\n    float velocity;\n};\n\nconst float volume = 0.75;\n\nconst float pitch = 1.0;\n\nconst float repeatMusicTime = 19.2;\n\nconst uint repeatMusic = 8U;\n\nconst float musicPlayTime = repeatMusicTime * float(repeatMusic);\n\nconst uint antiAliasing = 2U;\n\nconst float halfPi = 1.57079632679;\n\nconst float pi = 3.14159265359;\n\nconst float doublePi = 6.28318530718;\n\nconst uint squareWaveType = 0U;\n\nconst uint triangleWaveType = 1U;\n\nconst uint sineWaveType = 2U;\n\nconst uint whiteNoiseWaveType = 3U;\n\nconst Instrument[] instruments = Instrument[]\n(\n    //         Wave type           Wave ratio   Attack time    Amplitude    Decay time     Sustain amplitude   Release time   Left/Right\n    \n    // Piano\n    Instrument(triangleWaveType,   0.3125,      0.001953125,   0.21875,     0.0009765625,  0.125,              0.75,          0.5),\n    \n    // Piano\n    Instrument(sineWaveType,       0.25,        0.001953125,   0.013671875, 0.0009765625,  0.0078125,          0.75,          0.5),\n    \n    // Bass \n    Instrument(triangleWaveType,   0.0625,      0.00390625,    0.125,       0.00390625,    0.0625,             0.75,          0.5),\n    \n    // Left bell\n    Instrument(triangleWaveType,   0.125,       0.001953125,   0.046875,    0.001953125,   0.0234375,          0.75,          0.125),\n    \n    // Right bell\n    Instrument(triangleWaveType,   0.125,       0.001953125,   0.046875,    0.001953125,   0.0234375,          0.75,          0.875),\n    \n    // Primary drum\n    Instrument(sineWaveType,       1.0,         0.00048828125, 0.25,        0.00048828125, 0.1875,             0.75,          0.5),\n    \n    // Secondary drum\n    Instrument(triangleWaveType,   0.5,         0.0009765625,  0.375,       0.00048828125, 0.0625,             0.75,          0.5),\n    \n    // Left snare\n    Instrument(whiteNoiseWaveType, 1.0,         0.001953125,   0.0625,      0.001953125,   0.03125,            0.75,          0.25),\n    \n    // Right snare\n    Instrument(whiteNoiseWaveType, 1.0,         0.001953125,   0.0625,      0.001953125,   0.03125,            0.75,          0.75)\n    \n);\n\nconst uint primaryPianoInstrumentIndex = 0U;\n\nconst uint secondaryPianoInstrumentIndex = 1U;\n\nconst uint bassInstrumentIndex = 2U;\n\nconst uint leftBellInstrumentIndex = 3U;\n\nconst uint rightBellInstrumentIndex = 4U;\n\nconst uint primaryDrumInstrumentIndex = 5U;\n\nconst uint secondaryDrumInstrumentIndex = 6U;\n\nconst uint leftSnareInstrumentIndex = 7U;\n\nconst uint rightSnareInstrumentIndex = 8U;\n\nconst float c1 = 32.70319566257483;\n\nconst float cS1 = 34.64782887210902;\n\nconst float d1 = 36.70809598967594;\n\nconst float dS1 = 38.89087296526011;\n\nconst float e1 = 41.20344461410874;\n\nconst float f1 = 43.653528929125486;\n\nconst float fS1 = 46.24930283895431;\n\nconst float g1 = 48.999429497718666;\n\nconst float gS1 = 51.91308719749314;\n\nconst float a1 = 55.0;\n\nconst float aS1 = 58.27047018976124;\n\nconst float b1 = 61.7354126570155;\n\nconst float c2 = 65.40639132514966;\n\nconst float cS2 = 69.29565774421803;\n\nconst float d2 = 73.41619197935188;\n\nconst float dS2 = 77.78174593052022;\n\nconst float e2 = 82.40688922821748;\n\nconst float f2 = 87.30705785825097;\n\nconst float fS2 = 92.49860567790861;\n\nconst float g2 = 97.99885899543733;\n\nconst float gS2 = 103.82617439498628;\n\nconst float a2 = 110.0;\n\nconst float aS2 = 116.54094037952248;\n\nconst float b2 = 123.47082531403103;\n\nconst float c3 = 130.8127826502993;\n\nconst float cS3 = 138.59131548843604;\n\nconst float d3 = 146.8323839587038;\n\nconst float dS3 = 155.56349186104043;\n\nconst float e3 = 164.81377845643496;\n\nconst float f3 = 174.61411571650194;\n\nconst float fS3 = 184.99721135581723;\n\nconst float g3 = 195.99771799087463;\n\nconst float gS3 = 207.65234878997256;\n\nconst float a3 = 220.0;\n\nconst float aS3 = 233.08188075904496;\n\nconst float b3 = 246.94165062806206;\n\nconst float c4 = 261.6255653005986;\n\nconst float cS4 = 277.1826309768721;\n\nconst float d4 = 293.6647679174076;\n\nconst float dS4 = 311.12698372208087;\n\nconst float e4 = 329.6275569128699;\n\nconst float f4 = 349.2282314330039;\n\nconst float fS4 = 369.99442271163446;\n\nconst float g4 = 391.99543598174927;\n\nconst float gS4 = 415.3046975799451;\n\nconst float a4 = 440.0;\n\nconst float aS4 = 466.1637615180899;\n\nconst float b4 = 493.8833012561241;\n\nconst float c5 = 523.2511306011972;\n\nconst float cS5 = 554.3652619537442;\n\nconst float d5 = 587.3295358348151;\n\nconst float dS5 = 622.2539674441618;\n\nconst float e5 = 659.2551138257398;\n\nconst float f5 = 698.4564628660078;\n\nconst float fS5 = 739.9888454232689;\n\nconst float g5 = 783.9908719634986;\n\nconst float gS5 = 830.6093951598903;\n\nconst float a5 = 880.0;\n\nconst float aS5 = 932.3275230361799;\n\nconst float b5 = 987.7666025122483;\n\nconst Note[] notes = Note[]\n(\n    // Piano (primary)\n    Note(0.0 + 0.0,   primaryPianoInstrumentIndex, aS3, 0.3 - 0.125, 1.0),\n    Note(0.0 + 0.3,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 0.6,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 0.9,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.05,  primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(0.0 + 1.2,   primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.5,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.8,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 2.1,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 1.0),\n    Note(0.0 + 2.25,  primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 2.4,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(0.0 + 2.7,   primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.0,   primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.3,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 1.0),\n    Note(0.0 + 3.6,   primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.9,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 4.2,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    Note(4.8 + 0.0,   primaryPianoInstrumentIndex, aS3, 0.3 - 0.125, 1.0),\n    Note(4.8 + 0.3,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 0.6,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 0.9,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.05,  primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(4.8 + 1.2,   primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.5,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.8,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.1,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 1.0),\n    Note(4.8 + 2.25,  primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.4,   primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.7,   primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 3.0,   primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 3.3,   primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 1.0),\n    Note(4.8 + 3.6,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(4.8 + 3.9,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 4.2,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    Note(9.6 + 0.0,   primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 1.0),\n    Note(9.6 + 0.15,  primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.3,   primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.6,   primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.9,   primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.2,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(9.6 + 1.5,   primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.65,  primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.95,  primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.1,   primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.4,   primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 1.0),\n    Note(9.6 + 2.55,  primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.7,   primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.0,   primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.3,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(9.6 + 3.6,   primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.9,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(9.6 + 4.05,  primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    Note(14.4 + 0.0,  primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 1.0),\n    Note(14.4 + 0.15, primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.3,  primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.6,  primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.9,  primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.2,  primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(14.4 + 1.5,  primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.65, primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.95, primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.1,  primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.4,  primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 1.0),\n    Note(14.4 + 2.55, primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.7,  primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.0,  primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.3,  primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(14.4 + 3.6,  primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.9,  primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(14.4 + 4.05, primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    // Piano (secondary)\n    Note(0.0 + 0.0,   secondaryPianoInstrumentIndex, aS3, 0.3 - 0.125, 1.0),\n    Note(0.0 + 0.3,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 0.6,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 0.9,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.05,  secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(0.0 + 1.2,   secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.5,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.8,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 2.1,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 1.0),\n    Note(0.0 + 2.25,  secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 2.4,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(0.0 + 2.7,   secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.0,   secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.3,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 1.0),\n    Note(0.0 + 3.6,   secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.9,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 4.2,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    Note(4.8 + 0.0,   secondaryPianoInstrumentIndex, aS3, 0.3 - 0.125, 1.0),\n    Note(4.8 + 0.3,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 0.6,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 0.9,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.05,  secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(4.8 + 1.2,   secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.5,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.8,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.1,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 1.0),\n    Note(4.8 + 2.25,  secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.4,   secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.7,   secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 3.0,   secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 3.3,   secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 1.0),\n    Note(4.8 + 3.6,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(4.8 + 3.9,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 4.2,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    Note(9.6 + 0.0,   secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 1.0),\n    Note(9.6 + 0.15,  secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.3,   secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.6,   secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.9,   secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.2,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(9.6 + 1.5,   secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.65,  secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.95,  secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.1,   secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.4,   secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 1.0),\n    Note(9.6 + 2.55,  secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.7,   secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.0,   secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.3,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(9.6 + 3.6,   secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.9,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(9.6 + 4.05,  secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    Note(14.4 + 0.0,  secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 1.0),\n    Note(14.4 + 0.15, secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.3,  secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.6,  secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.9,  secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.2,  secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(14.4 + 1.5,  secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.65, secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.95, secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.1,  secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.4,  secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 1.0),\n    Note(14.4 + 2.55, secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.7,  secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.0,  secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.3,  secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(14.4 + 3.6,  secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.9,  secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(14.4 + 4.05, secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    // Bass\n    Note(0.0 + 0.0,   bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(0.0 + 0.3,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 0.45,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 0.6,   bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(0.0 + 0.9,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.2,   bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(0.0 + 1.5,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.65,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.8,   bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(0.0 + 2.1,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 2.4,   bassInstrumentIndex, cS2, 0.3 - 0.125, 1.0),\n    Note(0.0 + 2.7,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 2.85,  bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.0,   bassInstrumentIndex, cS2, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.3,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.6,   bassInstrumentIndex, cS2, 0.3 - 0.125, 1.0),\n    Note(0.0 + 3.9,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 4.05,  bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 4.2,   bassInstrumentIndex, cS2, 0.3 - 0.125, 0.75),\n    Note(0.0 + 4.5,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n     \n    Note(4.8 + 0.0,   bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(4.8 + 0.3,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 0.45,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 0.6,   bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(4.8 + 0.9,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.2,   bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(4.8 + 1.5,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.65,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.8,   bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.1,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.4,   bassInstrumentIndex, fS2, 0.3 - 0.125, 1.0),\n    Note(4.8 + 2.7,   bassInstrumentIndex, fS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.85,  bassInstrumentIndex, fS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 3.0,   bassInstrumentIndex, fS2, 0.3 - 0.125, 0.75),\n    Note(4.8 + 3.3,   bassInstrumentIndex, fS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 3.6,   bassInstrumentIndex, f2,  0.3 - 0.125, 1.0),\n    Note(4.8 + 3.9,   bassInstrumentIndex, f3,  0.3 - 0.125, 0.75),\n    Note(4.8 + 4.05,  bassInstrumentIndex, f3,  0.3 - 0.125, 0.75),\n    Note(4.8 + 4.2,   bassInstrumentIndex, f2,  0.3 - 0.125, 0.75),\n    Note(4.8 + 4.5,   bassInstrumentIndex, f3,  0.3 - 0.125, 0.75),\n     \n    Note(9.6 + 0.0,   bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(9.6 + 0.3,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.45,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.6,   bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.9,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.2,   bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(9.6 + 1.5,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.65,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.8,   bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.1,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.4,   bassInstrumentIndex, cS2, 0.3 - 0.125, 1.0),\n    Note(9.6 + 2.7,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.85,  bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.0,   bassInstrumentIndex, cS2, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.3,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.6,   bassInstrumentIndex, cS2, 0.3 - 0.125, 1.0),\n    Note(9.6 + 3.9,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 4.05,  bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 4.2,   bassInstrumentIndex, cS2, 0.3 - 0.125, 0.75),\n    Note(9.6 + 4.5,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    \n    Note(14.4 + 0.0,  bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(14.4 + 0.3,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.45, bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.6,  bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.9,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.2,  bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(14.4 + 1.5,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.65, bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.8,  bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.1,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.4,  bassInstrumentIndex, fS2, 0.3 - 0.125, 1.0),\n    Note(14.4 + 2.7,  bassInstrumentIndex, fS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.85, bassInstrumentIndex, fS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.0,  bassInstrumentIndex, fS2, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.3,  bassInstrumentIndex, fS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.6,  bassInstrumentIndex, f2,  0.3 - 0.125, 1.0),\n    Note(14.4 + 3.9,  bassInstrumentIndex, f3,  0.3 - 0.125, 0.75),\n    Note(14.4 + 4.05, bassInstrumentIndex, f3,  0.3 - 0.125, 0.75),\n    Note(14.4 + 4.2,  bassInstrumentIndex, f2,  0.3 - 0.125, 0.75),\n    Note(14.4 + 4.5,  bassInstrumentIndex, f3,  0.3 - 0.125, 0.75),\n    \n    // Bell\n    Note(0.0 + 0.0,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(0.0 + 0.3,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 0.45,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 0.6,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(0.0 + 0.9,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 1.2,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(0.0 + 1.5,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 1.65,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 1.8,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(0.0 + 2.1,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 2.4,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(0.0 + 2.7,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 2.85,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 3.0,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(0.0 + 3.3,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 3.6,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(0.0 + 3.9,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 4.05,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 4.2,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(0.0 + 4.5,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n     \n    Note(4.8 + 0.0,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(4.8 + 0.3,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 0.45,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 0.6,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(4.8 + 0.9,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 1.2,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(4.8 + 1.5,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 1.65,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 1.8,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(4.8 + 2.1,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 2.4,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(4.8 + 2.7,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 2.85,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 3.0,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(4.8 + 3.3,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 3.6,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(4.8 + 3.9,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 4.05,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 4.2,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(4.8 + 4.5,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n     \n    Note(9.6 + 0.0,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(9.6 + 0.3,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 0.45,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 0.6,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(9.6 + 0.9,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 1.2,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(9.6 + 1.5,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 1.65,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 1.8,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(9.6 + 2.1,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 2.4,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(9.6 + 2.7,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 2.85,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 3.0,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(9.6 + 3.3,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 3.6,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(9.6 + 3.9,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 4.05,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 4.2,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(9.6 + 4.5,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    \n    Note(14.4 + 0.0,  rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(14.4 + 0.3,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 0.45, leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 0.6,  rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(14.4 + 0.9,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 1.2,  rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(14.4 + 1.5,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 1.65, leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 1.8,  rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(14.4 + 2.1,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 2.4,  rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(14.4 + 2.7,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 2.85, leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 3.0,  rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(14.4 + 3.3,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 3.6,  rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(14.4 + 3.9,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 4.05, leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 4.2,  rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(14.4 + 4.5,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    \n    // Primary drum\n    Note(0.0 + 0.0,   primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(0.0 + 0.6,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 1.2,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 1.8,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 2.4,   primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(0.0 + 3.0,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 3.6,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 4.2,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(4.8 + 0.0,   primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(4.8 + 0.6,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 1.2,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 1.8,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 2.4,   primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(4.8 + 3.0,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 3.6,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 4.2,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(9.6 + 0.0,   primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(9.6 + 0.6,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 1.2,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 1.8,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 2.4,   primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(9.6 + 3.0,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 3.6,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 4.2,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(14.4 + 0.0,  primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(14.4 + 0.6,  primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 1.2,  primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 1.8,  primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 2.4,  primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(14.4 + 3.0,  primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 3.6,  primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 4.2,  primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    // Secondary drum\n    Note(0.0 + 0.0,   secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(0.0 + 0.6,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 1.2,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 1.8,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 2.4,   secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(0.0 + 3.0,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 3.6,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 4.2,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(4.8 + 0.0,   secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(4.8 + 0.6,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 1.2,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 1.8,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 2.4,   secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(4.8 + 3.0,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 3.6,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 4.2,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(9.6 + 0.0,   secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(9.6 + 0.6,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 1.2,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 1.8,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 2.4,   secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(9.6 + 3.0,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 3.6,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 4.2,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(14.4 + 0.0,  secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(14.4 + 0.6,  secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 1.2,  secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 1.8,  secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 2.4,  secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(14.4 + 3.0,  secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 3.6,  secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 4.2,  secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    // Snare\n    Note(0.3 + 0.0,   leftSnareInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(0.3 + 0.6,   rightSnareInstrumentIndex, dS1, 0.125, 0.75),\n    Note(0.3 + 1.2,   leftSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.3 + 1.8,   rightSnareInstrumentIndex, dS1, 0.125, 0.75),\n    Note(0.3 + 2.4,   leftSnareInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(0.3 + 3.0,   rightSnareInstrumentIndex, dS1, 0.125, 0.75),\n    Note(0.3 + 3.6,   leftSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.3 + 4.2,   rightSnareInstrumentIndex, dS1, 0.125, 0.75),\n    \n    Note(5.1 + 0.0,   leftSnareInstrumentIndex,   dS1, 0.125, 1.0),\n    Note(5.1 + 0.6,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(5.1 + 1.2,   leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(5.1 + 1.8,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(5.1 + 2.4,   leftSnareInstrumentIndex,   dS1, 0.125, 1.0),\n    Note(5.1 + 3.0,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(5.1 + 3.6,   leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(5.1 + 3.75,  rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(5.1 + 4.05,  leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(5.1 + 4.2,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(9.9 + 0.0,   leftSnareInstrumentIndex,   dS1, 0.125, 1.0),\n    Note(9.9 + 0.6,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.9 + 1.2,   leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(9.9 + 1.8,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.9 + 2.4,   leftSnareInstrumentIndex,   dS1, 0.125, 1.0),\n    Note(9.9 + 3.0,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.9 + 3.6,   leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(9.9 + 4.2,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(14.7 + 0.0,  leftSnareInstrumentIndex,   dS1, 0.125, 1.0),\n    Note(14.7 + 0.6,  rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.7 + 1.2,  leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(14.7 + 1.8,  rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.7 + 2.4,  leftSnareInstrumentIndex,   dS1, 0.125, 1.0),\n    Note(14.7 + 3.0,  rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.7 + 3.6,  leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(14.7 + 3.75, rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.7 + 4.05, leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(14.7 + 4.2,  rightSnareInstrumentIndex,  dS1, 0.125, 0.75)\n);\n\nvec2 PlayNotes(const in float time)\n{\n    vec2 ret = vec2(0.0);\n    Note note;\n    Instrument instrument;\n    float sustain_time;\n    float duration;\n    float play_at_time;\n    float relative_time;\n    float scaled_relative_time;\n    float volume;\n    vec2 note_volume;\n    float beats_per_second;\n    float normalized_wave_time;\n    for (int note_index = 0; note_index < notes.length(); note_index++)\n    {\n        note = notes[note_index];\n        instrument = instruments[note.instrumentIndex];\n        sustain_time = max(note.duration - instrument.attackTime - instrument.decayTime, 0.0);\n        duration = (instrument.attackTime + instrument.decayTime + sustain_time + instrument.releaseTime) / playbackSpeed;\n        play_at_time = note.playAtTime / playbackSpeed;\n        relative_time = time - play_at_time;\n        scaled_relative_time = relative_time * playbackSpeed;\n        if ((time >= play_at_time) && ((time - duration) < play_at_time))\n        {\n            switch (instrument.waveType)\n            {\n            case squareWaveType:\n                beats_per_second = 1.0 / note.frequency;\n                normalized_wave_time = mod(relative_time * pitch, beats_per_second) / beats_per_second;\n                volume = (normalized_wave_time > instrument.waveRatio) ? -1.0 : 1.0;\n                break;\n            case triangleWaveType:\n                volume = 1.0;\n                beats_per_second = 1.0 / note.frequency;\n                normalized_wave_time = mod(relative_time * pitch, beats_per_second) / beats_per_second;\n                if (normalized_wave_time < instrument.waveRatio)\n                {\n                    volume = (clamp(normalized_wave_time / instrument.waveRatio, 0.0, 1.0) * 2.0) - 1.0;\n                }\n                else if (normalized_wave_time > instrument.waveRatio)\n                {\n                    volume = 1.0 - (clamp((normalized_wave_time - instrument.waveRatio) / (1.0 - instrument.waveRatio), 0.0, 1.0) * 2.0);\n                }\n                break;\n            case sineWaveType:\n                volume = sin(relative_time * pitch * doublePi * note.frequency);\n                break;\n            case whiteNoiseWaveType:\n                volume = (fract(sin(relative_time * pitch * 12865.9898) * 43758.5453) * 2.0) - 1.0;\n                break;\n            }\n            note_volume = vec2((instrument.leftRight > 0.5) ? cos((instrument.leftRight - 0.5) * pi) : 1.0, (instrument.leftRight < 0.5) ? cos((0.5 - instrument.leftRight) * pi) : 1.0) * volume * note.velocity;\n            if (scaled_relative_time < instrument.attackTime)\n            {\n                note_volume *= (scaled_relative_time / instrument.attackTime) * instrument.amplitude;\n            }\n            else if (scaled_relative_time < (instrument.attackTime + instrument.decayTime))\n            {\n                note_volume *= mix(instrument.amplitude, instrument.sustainAmplitude, (scaled_relative_time - instrument.attackTime) / instrument.decayTime);\n            }\n            else if (scaled_relative_time < (instrument.attackTime + instrument.decayTime + sustain_time))\n            {\n                note_volume *= instrument.sustainAmplitude;\n            }\n            else\n            {\n                note_volume *= mix(0.0, instrument.sustainAmplitude, exp((-(scaled_relative_time - instrument.attackTime - instrument.decayTime - sustain_time) * doublePi) / instrument.releaseTime));\n            }\n            ret += note_volume;\n        }\n    }\n    return ret;\n}\n\nvec2 mainSound(in int samp, float time)\n{\n    if (time >= musicPlayTime)\n    {\n        return vec2(0.0);\n    }\n    vec2 current_volume = vec2(0.0);\n    for (uint anti_aliasing_index = 0U; anti_aliasing_index != antiAliasing; anti_aliasing_index++)\n    {\n        float current_time = time - float(anti_aliasing_index) / (iSampleRate * float(antiAliasing));\n        current_volume += (current_time < 0.0) ? vec2(0.0, 0.0) : PlayNotes(mod(current_time, repeatMusicTime / playbackSpeed));\n    }\n    return current_volume * volume / float(antiAliasing);\n}\n", "sound_inputs": [], "common_code": "// User settings\n\n// Low-resolution mode is less taxing on your device\n// Uncomment the line below if you are watching this on a potato!\n#define LOW_RESOLUTION_MODE\n\n// Uncomment to enable vibing cat\n// Warning: May not work on every machine!\n//#define ENABLE_VIBING_CAT\n\n// End of user settings\n\n\n\n#ifdef ENABLE_VIBING_CAT\nconst float playbackSpeed = 1.5;\n#else\nconst float playbackSpeed = 1.0;\n#endif\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdXGWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NlcBRs", "name": "Radial Tiling Truchet", "author": "Shane", "description": "Using elongated hexagons as a base to radially tile a plane and produce a Truchet pattern.", "tags": ["2d", "spiral", "radial", "truchet", "pattern", "polar", "polygon", "tile"], "likes": 82, "viewed": 686, "published": 3, "date": "1666705824", "time_retrieved": "2024-07-30T16:24:42.300980", "image_code": "/*\n\n    Radial Tiling Truchet\n    ---------------------\n    \n    Using an elongated hexagon base pattern to radially tile a plane and\n    produce a Truchet pattern. The other day, Fabrice Neyret reproduced a \n    really cool spiral Truchet pattern that he'd come across on Twitter -- \n    I've provided the link to his version and the original below. Like many\n    of his examples, it involved subject matter that wasn't widely known and \n    visually interesting enough to investigate further.\n    \n    Like everyone else, I've seen spriral patterns that consist of single \n    polygons, or simple mixes of regular polygons, etc, but have never really \n    looked into how they are created. Given the lack of content on the web, \n    it doesn't appear that many other people know much about the process \n    either. \n    \n    As usual, the solution wasn't difficult, but it took a while to figure \n    out. As it turns out, the trick is to use elongated hexagons grouped\n    together in wedged sections that neatly stitch together in a radial\n    fashion. For a simple visual, go to the defines below and set POLYGON\n    to \"0\", TRUCHET to \"0\" then uncomment the CONSTRUCTION_WEDGES define.\n    Alternatively, have a look at some of the imagery in the links below.\n    \n    Fron a code perspective, this, and patterns like it, consist of nothing \n    more than seperate hexagon grids placed together in a radial fashion using \n    polar coordinates. Things that you may not be used to is putting together \n    a grid full of elongated hexagons, but that just involves adding a few \n    things to the regular hexagon grid code. After that, you have to restrict \n    the pattern to a fan shape, but that is literally two extra lines. Once \n    you have access to the local elongated hexagon coordinates and central ID, \n    you can do whatever you want.\n     \n    Since this is a simple demonstration, I've chosen the most basic radial\n    elongated hexagon pattern arrangement, but there are a heap of others,\n    and you can look at some of them in the links provided below. I've \n    found that a lot of the other common polygon patterns (quads, pentagons, \n    etc) can be created via the base hexagon pattern.\n    \n    This was thrown together quickly as more of a visual guide than anything \n    else. I wanted to show how different arrangements are related, which \n    required a heap of spaghetti logic, so the code isn't fantastic. However, \n    it works fine, and the base code is much more streamlined, so hopefully, \n    it will give anyone who wishes to make radial or spriral polygon patterns, \n    spiral Truchet patterns, etc, a start -- There's a few defines that \n    should help. I intend to do something more interesting with this at a \n    later date.\n \n \n    \n    References:\n    \n    // I love examples like this. I didn't bother looking at the code, \n    // but the visual itself was enough to give me a start.\n    Damasdi tiling - FabriceNeyret2\n    https://www.shadertoy.com/view/stcBRj\n    //\n    // Based on the following:\n    Symmetry - Math and art by Gbor Damsdi\n    https://szimmetria-airtemmizs.tumblr.com/post/144161547163/\n    an-other-pattern-that-uses-only-a-single\n    \n    Elongated triangular tiling - Wikipedia\n    https://en.wikipedia.org/wiki/Elongated_triangular_tiling\n    \n    Order-Six Radial Tessellations of the Plane, Using Elongated and \n    Equilateral Hexagons, Rendered with Twelve Different Coloring-Schemes\n    https://RobertLovesPi.net    \n    \n    \n*/\n\n// Polygon type - Hexagon base: 0, Quadrilateral: 1, Triangle-Square:2.\n#define POLYGON 1\n\n// Truchet type: No Truchet: 0, White Truchet: 1, Black: 2\n#define TRUCHET 2\n\n// Display the multiple tile wedges that radially tile the plane.\n//#define CONSTRUCTION_WEDGES\n\n// Dual pattern -- This is the dual to the regular triangle and square\n// pattern (POLYGON 2). With the exception of the center, it's mostly\n// pentagons. Best viewed without the Truchet pattern.\n//#define DUAL\n\n// Polygon vertices.\n//#define VERTICES\n\n// Polygon edge midpoints.\n//#define MIDPOINTS\n\n// Displaying the hexagon base pattern overlay. It's redundant when using the\n// base hexagon, but can be helpful in visualizing how the quadrilateral or \n// triangle-square pattern is constructed. Best viewed without the Truchet\n// pattern or dual overlay.\n//#define BASE_OVERLAY\n\n// Bump map highlights.\n//#define BUMP\n\n\n// Flat top hexagon scaling.\nconst vec2 s = vec2(2. + 1.7320508, 1); // Normal hexagon plus square.\n \n// Hexagonal bound: Not technically a distance function, but it's\n// good enough for this example.\nfloat getHex(vec2 p){\n \n    // Generalized elongated hexagon function, based on the \n    // partitioning rectangle above.\n    //\n    // I did this in a hurry. There'd be better ways to go \n    // about it, but it'll do for now.\n    float x = (s.x - s.y)/2.;//(1. + 1.7320508)/2.;\n    float ln;\n    p = abs(p);\n    ln =  distLineS(p, vec2(-.5, .5), vec2(.5, .5));\n    ln =  max(ln, distLineS(p, vec2(.5, .5), vec2(x, 0)));\n    ln =  max(ln, distLineS(p, vec2(x, 0), vec2(.5, -.5)));\n    return ln;\n    \n    /*    \n    float x = (1. + 1.7320508)/2.;\n    float ln =  distLineS(p, vec2(-.5, -.5), vec2(-x, 0));\n    ln =  max(ln, distLineS(p, vec2(-x, 0), vec2(-.5, .5)));\n    ln =  max(ln, distLineS(p, vec2(-.5, .5), vec2(.5, .5)));\n    ln =  max(ln, distLineS(p, vec2(.5, .5), vec2(x, 0)));\n    ln =  max(ln,distLineS(p, vec2(x, 0), vec2(.5, -.5)));\n    ln =  max(ln, distLineS(p, vec2(.5, -.5), vec2(-.5, -.5)));\n    return ln;\n*/\n}\n\n// Hexagonal grid coordinates. This returns the local coordinates and the cell's center.\n// The process is explained in more detail here:\n//\n// Minimal Hexagon Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\n//\nvec4 getGrid(vec2 p){\n  \n    \n    vec4 ip = floor(vec4(p/s, p/s - .5)) + .5;\n    vec4 q = p.xyxy - vec4(ip.xy, ip.zw + .5)*s.xyxy;\n    //return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + offs);\n    return getHex(q.xy)<getHex(q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n   \n} \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Aspect corret coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    // Scale and smoothing factor.\n    const float sc = 10.;\n    float sf = sc/iResolution.y;\n    \n    \n    // Scaling and translation.\n    vec2 p = sc*uv;\n    \n    // Scene field calculations.\n\n    vec2 op = p; // Global position copy.\n    \n    // Light for each block.\n    vec2 ld = normalize(vec2(-2, 1));\n    vec2 ld2 = ld;\n    \n    // Number of partitions for each block.\n    const float aN = 6.;\n    \n    // Creating three blocks of hexagon wedges.\n    p *= rot2(-iTime/12.);\n     \n    \n    float a = atan(p.y, p.x);\n    float na = floor(a/6.2831853*aN);\n    float ia = (na + .5)/aN;\n    //\n    p *= rot2(-ia*6.2831853);\n    ld *= rot2(-ia*6.2831853);\n    p.x -= (s.x - s.y)/2.; // Half hexagon width.\n     // Hexagonal grid coordinates.\n    vec4 p4A = getGrid(p);\n    \n    // Creating the other three blocks of hexagon wedges. These are \n    // pushed out from the center a little further.\n    p = rot2(3.14159/aN)*op;\n    ld2 = rot2(3.14159/aN)*ld2;\n    p *= rot2(-iTime/12.);\n    float a2 = atan(p.y, p.x);\n    float na2 = floor(a2/6.2831853*aN);\n    float ia2 = (na2 + .5)/aN;\n    //\n    p *= rot2(-ia2*6.2831853);\n    ld2 *= rot2(-ia2*6.2831853);\n    p.x -= (s.x - s.y)/2. + 1.; // Half hexagon width plus 1.\n     // Hexagonal grid coordinates.\n    vec4 p4B = getGrid(p);\n    \n    // Closest hexagon in each block and its offset block.\n    float dA = getHex(p4A.xy);\n    float dB = getHex(p4B.xy);\n    // Position based IDs.\n    vec2 idA = floor(p4A.zw*2.);\n    vec2 idB = floor(p4B.zw*2.);\n    // Eradicating all hexagons that fall outside each block.\n    if(abs(idA.y)>idA.x){ dA = 1e5; }\n    if(abs(idB.y)>idB.x){ dB = 1e5; }\n    \n    \n    // Obtaining the closest hexagon distance, its local coordinates,\n    // the block number, and ID.\n    float d = min(dA, dB);\n    vec4 p4 = dA<dB? p4A : p4B;\n    float n = dA<dB? na : na2 + 1.;\n    vec2 id = floor(p4.zw*2.);\n    \n    // Nearby sample for highlighting.\n    ld = dA<dB? ld : ld2;\n    float dHi = getHex(p4.xy - ld*.001);\n\n    vec4 svp4 = p4; // Local hexagon coordinate copy.\n   \n    // Using the block number and radial postion to calculate a unique\n    // position based ID for this particular hexagon.\n    float ip = (p4.z*2.) + n;\n\n    // Copy of the original local coordinate.\n    vec4 oP4 = p4;\n     \n   \n    \n    vec2 ctr = vec2(0); // Hexagon center.\n    \n    float x = (s.x - s.y)/2.; // Distance to triangle center.\n     \n    float lnL = (distLineS(p4.xy, vec2(-.5, .5), vec2(-.5, -.5))); // Left partition line.\n    float lnR = (distLineS(p4.xy, vec2(.5, .5), vec2(.5, -.5))); // Right partition line.\n    float ln = min(abs(lnL), abs(lnR));\n    \n    mat4x2 v; // Container for holding the square or triangle vertices.\n \n    int vNum = 3;\n     \n    // In the left triangle or the right triangle, adjust the midpoint.\n    // Otherwise, we're in the central square, so do nothing.\n    if(lnL<0.){\n    \n        // Left triangle.\n        ip -= .25;\n        p4.z -= .25;\n        //p4.x -= -(.5 + x/2.);\n        ctr = vec2(-(x + 1.)/3., 0); // Average of the vertices below.\n        \n        // There's a dummy variable on the end.\n        v = mat4x2(vec2(-.5, -.5), vec2(-x, 0), vec2(-.5, .5), vec2(1e5));\n    }\n    else if(lnR>0.){\n    \n        // Right triangle.\n        ip += .25;\n        p4.z += .25;\n        ctr = vec2((x + 1.)/3., 0); // Average of the vertices below.\n        \n        // There's a dummy variable on the end.\n        v = mat4x2(vec2(.5, -.5), vec2(.5, .5), vec2(x, 0), vec2(1e5));\n    }\n    else {\n    \n         vNum = 4; // Using all 4 vertices for the square.\n         // Square.\n         v = mat4x2(vec2(-.5, -.5), vec2(-.5, .5), vec2(.5, .5), vec2(.5, -.5));\n    }    \n \n    \n    // Calculating the vertex distance field, midpoint distance field, dual\n    // lines, etc, for the squares and triangles.\n    float dualLn = 1e5;\n    float vert = 1e5, mid = 1e5;\n    mat4x2 midV;\n    //mat4x2 tMidV;\n    \n    float poly = -1e5, polyHi = -1e5;\n    for(int i = 0; i<vNum; i++){\n    \n        vert = min(vert, length(p4.xy - v[i]));\n\n        vec2 vMid = mix(v[i], v[(i + 1)%vNum], .5);\n\n        midV[i] = vMid;\n        //tMidV[i] = normalize((v[i] - v[(i + 1)%vNum]).yx*vec2(-1, 1));\n\n        mid = min(mid, length(p4.xy - vMid));\n        dualLn = min(dualLn, distLine(p4.xy, ctr, vMid));\n\n        poly = max(poly, distLineS(p4.xy, v[i], v[(i + 1)%vNum]));\n        polyHi = max(polyHi, distLineS(p4.xy - ld*.001, v[i], v[(i + 1)%vNum]));\n \n    }\n\n    \n    // Quickly coding in a Truchet pattern.\n    float rnd1 = hash21(p4.zw + .101 + n);\n    float rnd2 = hash21(p4.zw + .102 + n);\n    float rnd3 = hash21(p4.zw + .103 + n);\n    float rnd4 = hash21(p4.zw + .104 + n);\n\n    float sL = 1.;\n    float th = .015*sc;\n    vec3 tr = vec3(1e5);\n\n\n    if(vNum==3){ \n\n        // Triangle Truchet pattern.\n\n        int rndI = int(floor(rnd4*3.))%3;\n        float v0 = length(p4.xy - v[rndI]);\n\n        tr.x = mid - th;\n        if(rnd1<.5) tr.x = min(tr.x, abs(v0 - .5) - th);\n        else if(rnd1<1.8) tr.x = -(vert - (sL/2. - th));\n\n        /* \n        tr.x = abs(length(p4.xy - v[0]) - .5) - th;\n        tr.y = abs(length(p4.xy - v[1]) - .5) - th;\n        tr.z = abs(length(p4.xy - v[2]) - .5) - th;\n        */ \n    }\n    else { \n\n        // Square Truchet pattern.\n\n        //if(rnd3<.5) p4.xy = p4.yx*vec2(1, -1);\n        p4.xy *= rot2(floor(rnd3*32.)*3.14159/2.);\n\n\n        float v0 = length(p4.xy - v[0]);\n\n        // All dots.\n        tr.x = mid - th;\n\n        if(rnd2<.333){\n            // Dots and one arc.\n            tr.x = min(tr.x, abs(v0 - .5) - th);\n        }\n        else if(rnd2<.5){  \n            // Two arcs.\n            v0 = min(v0, length(p4.xy - v[2]));\n            tr.x = min(tr.x, abs(v0 - .5) - th);\n        }\n        else if(rnd2<1.1){  \n            // Two lines.\n            tr.x = abs(p4.x) - th;\n            tr.y = abs(p4.y) - th;\n        }\n\n    }\n     \n     \n    #if POLYGON == 1\n\n    p4 = oP4;\n    ip = (p4.z*2.) + n;\n    lnL = (distLineS(p4.xy, vec2(.5, .5),vec2(-.5, -.5))); // Partition line.\n    ln = abs(lnL);\n    \n    vNum = 4;  \n    if(lnL<0.){\n        // Left quadrilateral.\n        ip -= .25;\n        p4.z -= .25;\n        // Center.\n        ctr = vec2(-(x + 1.)/3., 0); // Average of the vertices below.\n        // Vertices for this quad.\n        v = mat4x2(vec2(-.5, -.5), vec2(-x, 0), vec2(-.5, .5), vec2(.5,.5));\n       \n    }\n    else {\n        // Right quadrilateral.\n        ip += .25;\n        p4.z += .25;\n        // Center.\n        ctr = vec2((x + 1.)/3., 0); // Average of the vertices below.\n        // Vertices for this quad.\n        v = mat4x2(vec2(-.5, -.5), vec2(.5, .5), vec2(x, 0), vec2(.5, -.5));\n    }\n\n    poly = -1e5, polyHi = -1e5;\n    vert = 1e5, mid = 1e5;\n    for(int i = 0; i<vNum; i++){\n    \n        vert = min(vert, length(p4.xy - v[i])); // Vertices.\n\n        vec2 vMid = mix(v[i], v[(i + 1)%vNum], .5); // Midpoints.\n\n        // Dual lines and midpoints.\n        if(lnL>0. && i==3){ \n            vMid = vec2(0, -.5); \n            dualLn = min(dualLn, distLine(p4.xy, vec2(0), vMid)); \n        }\n        else if(lnL<0. && i==2) { \n            vMid = vec2(0, .5); \n            dualLn = min(dualLn, distLine(p4.xy, vec2(0), vMid)); \n        }\n\n   \n        mid = min(mid, length(p4.xy - vMid)); // Midpoint distance.\n\n        // Polygon distance, plus an extra highlight samples.\n        poly = max(poly, distLineS(p4.xy, v[i], v[(i + 1)%vNum]));\n        polyHi = max(polyHi, distLineS(p4.xy - ld*.001, v[i], v[(i + 1)%vNum]));\n \n    }\n    #elif POLYGON == 0\n    // Original hexagon base.\n    p4 = oP4;\n    ip = (p4.z*2.) + n;\n    vNum = 6;\n    poly = d;\n    polyHi = dHi;\n    mid = 1e5; // vert = 1e5;\n    vec2[6] vH = vec2[6](vec2(-.5, -.5), vec2(-x, 0), vec2(-.5, .5), vec2(.5, .5), \n                            vec2(x, 0), vec2(.5, -.5));\n    for(int i = 0; i<vNum; i++){\n            //vert = min(vert, length(p4.xy - vH[i]));\n            vec2 vMid = mix(vH[i], vH[(i + 1)%vNum], .5); // Midpoint.\n            mid = min(mid, length(p4.xy - vMid)); // Midpoint distance.\n    }\n    #endif\n     \n    // Giving the vertices and midpoints some size.\n    vert -= th;\n    mid -= .0125*sc;\n \n\n    //Debug: Restricting the pattern size.\n    //if(oP4.z>.8){ poly = 1e5; ln = 1e5; tr = vec3(1e5); }\n\n\n    // Restricting to six colors.\n    ip = mod(ip, 6.)/6.;\n    \n\n    #ifdef CONSTRUCTION_WEDGES\n    // Display the 12 wedge blocks that tile the plane.\n    ip = n/24. + mod(id.x, 2.)/2.;\n    vec3 hCol = .5 + .45*cos(6.2831*ip/4. + vec3(0, 1, 2)*1.5);\n    if(dA>dB) hCol = .5 + .45*cos(6.2831*ip/4. + vec3(0, 1,2)*1.5 + 3.14159);\n    #else \n    // Animated spectrum colors.\n    vec3 hCol = .5 + .45*cos(6.2831*ip + vec3(0, 1, 2)*1.5 - iTime);\n    //vec3 hCol = vec3(1, .1, .3);\n    //vec3 hCol = vec3(.9, .95, 1);\n    #endif\n\n \n    // Bump highlights.\n    #ifdef BUMP\n    float dSh = poly;//clamp(poly*4., -1., 0.);\n    float dShHi = polyHi;//clamp(polyHi*4., -1., 0.);\n    float b = max(dShHi - dSh, 0.)/.001;\n    //float b2 = max(dSh - dShHi, 0.)/.001;\n   \n    hCol *= .75 + b*.5;\n    #endif\n\n   // Scene color -- Set to black.\n    vec3 col = vec3(0); \n\n    // Rendering onto the background.\n\n    // Laying down the polygons first.\n    col = mix(col, hCol, 1. - smoothstep(0., sf, poly + .004*sc));\n    /*\n    // Polygons with borders.\n    col = mix(col, hCol*.75, 1. - smoothstep(0., sf, poly + .004*sc));\n    col = mix(col, hCol*.1, 1. - smoothstep(0., sf, poly + .012*sc));\n    col = mix(col, hCol, 1. - smoothstep(0., sf, poly + .0175*sc));\n    */\n\n \n    \n    \n    #if TRUCHET>0\n    // Rendering the Truchet pattern. The third Truchet field isn't used\n    // at the moment.\n    for(int i = 0; i<3; i++){\n        vec3 svCol = col;\n        \n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., tr[i]))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, tr[i]));\n        col = mix(col, svCol*.5 + .75, 1. - smoothstep(0., sf, tr[i] + .006*sc));\n        #if TRUCHET==1\n        // White.\n        col = mix(col, svCol*.25 + .35, 1. - smoothstep(0., sf, abs(tr[i] + .015*sc) - .0015*sc));\n        #elif TRUCHET==2\n        // Black.\n        col = mix(col, svCol*.06, 1. - smoothstep(0., sf, tr[i] + th - .0045*sc));\n        #endif\n    }\n    #endif\n    \n    \n    #ifdef DUAL\n    // Display the dual pattern.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dualLn - .006*sc));\n    col = mix(col, vec3(.9, .95, 1), 1. - smoothstep(0., sf, dualLn - .002*sc));\n    // col = mix(col, vec3(1), (1. - smoothstep(0., sf, dualLn - .001*sc))*.5);\n    #endif\n\n\n    #ifdef VERTICES\n    // Polygon vertices.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, vert));\n    col = mix(col, vec3(.9, .95, 1), 1. - smoothstep(0., sf, vert + .006*sc));\n    #endif\n    \n    #ifdef MIDPOINTS\n    // Polygon midpoints.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, mid));\n    col = mix(col, vec3(.6, .9, 1), 1. - smoothstep(0., sf, mid + .006*sc));\n    #endif\n    \n    #ifdef BASE_OVERLAY\n    // Hexagon base pattern overlay.\n    col = mix(col, vec3(1), (1. - smoothstep(0., sf, abs(d) - .007))); // Top layer.\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n/*\n// Basic swap function.\nvoid swap(inout int a, inout int b){\n\n    int t = a; a = b; b = t;\n}\n*/\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n\n// Signed distance to a line passing through \"a\" and \"b\".\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcBRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4506, 4605, 4626, 4832, 5536], [5538, 5755, 5776, 5776, 6065]], "test": "untested"}
{"id": "dds3RX", "name": " ", "author": "moshi", "description": " \n   \n  \n ", "tags": ["mouse"], "likes": 0, "viewed": 310, "published": 3, "date": "1666669646", "time_retrieved": "2024-07-30T16:24:43.146719", "image_code": "float pi2 = 6.283185307179586 ;\n\n\nfloat triangle(vec2 xy, vec2 center,float R){\n    vec2 r = center -xy;\n    r.x-=.1;\n   //p * cos a < d   \n    float a = atan(r.y,r.x)  ;\n    float d = length(r);\n    return step(d * cos(a),.1)* step(abs(a), pi2/6.);\n}\n\n\nfloat circle(vec2 xy, vec2 center, float R){\n    vec2 d = center -xy; \n    \n    return step(dot(d,d),R*R) ;\n}\n\nmat2 rotate2d(float a){\n float c = cos(a) ;\n float s = sin(a);\n return  mat2(c,-s, s,c ) ;\n}\n\nfloat square(vec2 xy, vec2 center){\n    vec2 d = center -xy;\n    d.x-=.3;\n    vec2 dd= step( abs(d),vec2(.1,.08) );\n    return dd.x* dd.y ;\n}\n\nfloat arrow(vec2 xy, vec2 center, float R, vec2 offset , float a){\n    xy-=offset ;\n    xy-=center ;\n    xy*=rotate2d(-a);\n    xy+=center;\n    return square(xy, center) + triangle(xy,center, R);\n}\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{  \nfloat ratio  = iResolution.x/iResolution.y;\nvec2 uv = U/iResolution.xy ;\nuv.x*=ratio;\n\nvec2 mouse = iMouse.xy/iResolution.xy ;\nmouse.x*= ratio ;\nfloat mz =  step(0. ,iMouse.z);// edge, val z>0 mz 1\nfloat mw =  step(0. ,iMouse.w);\n   vec3 color = vec3(.4,.2,.05) ;\n   vec3 color1 = vec3(.2,.7,.6) ;\n   vec3 color2 = vec3(.1,.1,.6) ;\n   vec3 color3 = vec3(.25,.3,.05) ;\n   vec3 color4 = vec3(.45,.05,.4) ;\n   vec3 color5 = vec3(uv,.6) ;\n   // ichannel0 keyboard  uv.y = 0 x= 32 32\n   float arrowdown = texelFetch(iChannel0, ivec2(32,0),0).x * .4;\n   float arrowUp = texelFetch(iChannel0, ivec2(32,1),0).x + .4;\n   float arrowL = texelFetch(iChannel0, ivec2(32,2),0).x ; // 0  \n   float arrowR = 1. - arrowL;                              // 1- \n   color= mix(color, color1+arrowdown , arrow(uv, vec2(.5,.5), .3,vec2(.0,.4), 1.57)) ;  //\n   color= mix(color, color2+arrowUp , arrow(uv, vec2(.5,.5), .3,vec2(.0,-.4), -1.57)) ; //\n   \n   \n   color= mix(color, color3+arrowL*.4 , arrow(uv, vec2(.5,.5), .3,vec2(-.4,.0), 3.14)) ;//\n   \n   \n   color= mix(color, color4+arrowR*.4 , arrow(uv, vec2(.5,.5), .3,vec2(.4,.0), .0)) ;  // \n\n    color= mix(color, color5 ,circle(uv, mouse,.1)) ;\n   O = vec4(color, 1.);\n   \n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dds3RX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 79, 79, 257], [260, 260, 304, 304, 369], [371, 371, 394, 394, 463], [465, 465, 500, 500, 606], [608, 608, 674, 674, 804], [807, 807, 845, 845, 2139]], "test": "untested"}
{"id": "cdsGRs", "name": "Opportunistic raymarching", "author": "Pidhorskyi", "description": "Fork of  \"Binary Search for SDFs\" by iq (https://www.shadertoy.com/view/wlGcWG)\n\nI came up with this approach ~5 years ago, and unfortunetly not recalling all the nuances, but overall idea is described in the comments. ", "tags": ["3d", "raycasting", "raycast", "sdf", "intersection"], "likes": 21, "viewed": 562, "published": 3, "date": "1666660383", "time_retrieved": "2024-07-30T16:24:44.075237", "image_code": "// stanislav pidhorskyi - 2022\n// inigo quilez - iq/2018-2022\n\n// A modification of original shader by iq: https://www.shadertoy.com/view/wlGcWG\n// Modification: replaced `raycast_bs` with `raycast_opp`.\n//\n// Opportunistic raymarching for SDFs.\n\n// Antialiasing level. Make it 1 if you have a slow machine\n#define AA 1\n\n\nvec3 map( vec3 p );\n\n// Opportunistic raymarching. To the best of my knowlage this does not guarantee to produce correct results,\n// but works in practice.\nvec4 raycast_opp( in vec3 ro, in vec3 rd, float tmin, float tmax)\n{\n    float t = tmin;\n    \n    const float max_overshoot_coeff = 0.9;           // max overshooting coeff\n    float overshoot_coeff = max_overshoot_coeff;     // current overshooting coeff\n    float angle = 1.000;                             // angle estimate\n    float prev_h = 1.e8;                             // previous sdf value\n        \n    float gap = 0.;                                  // difference between actual sdf value and expected one\n    float prev_gap = -1.;\n    float _prev_h = 1.e8;\n    float _o = 1.e8;\n    bool did_overshoot = false;\n\n\n    vec2  info = vec2(0.0);\n    float num = 0.0;\n    for( int i=0; i<256; i++ )\n    {\n        float angle_amplification = (1. / angle - 1.) / (1.0 / angle + 1.0);  // amplify overshooting based on estimeted angle\n        float step_increase = overshoot_coeff * prev_h * angle_amplification;\n            \n        vec3  r = map( ro+rd*(t + step_increase));\n        num += 1.0;\n\t    float h = r.x;\n        \n        prev_gap = gap;\n        gap = step_increase - h;\n        if (gap >= 0.)                                                        // Ops, we did overshoot\n        {\n            if (h > 0.001*t)                                                 \n            {\n                overshoot_coeff = gap / 2. / (prev_h * angle_amplification);\n             \tdid_overshoot = true;\n            }\n            else\n            {\n                overshoot_coeff /= 2.;                                       \n            }\n            _prev_h = h;\n            _o = step_increase;\n            continue;                                                         // backtrack and refine\n        }\n        else if (prev_gap >= 0. && did_overshoot)                             // The previous step was overshooted, still need to refine\n        {\n            prev_h = h;\n            h = _prev_h;\n            t += _o + h;\n            angle = (prev_h - h) / (prev_h + _o - step_increase);             // update angle estimate\n            did_overshoot = false;    \n            continue;                                                         // backtrack and refine\n        }\n        did_overshoot = false;\n        \n        angle = mix(angle, (prev_h - h) / (prev_h + step_increase), 0.5);     // update estimate (slowly)\n\n        t += step_increase;\n        prev_h = h;    \n        overshoot_coeff = mix(overshoot_coeff, max_overshoot_coeff, 0.5);     // recover overshoot_coeff (slowly)\n            \n        info = r.yz;\n        if( h<(0.001*t)||t>tmax ) break;\n        t += h;\n    }\n    return (t<tmax) ? vec4(t,info,num) : vec4(-1.0);\n}\n\n// traditional SDF raymarching\nvec4 raycast_rm( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    float t = tmin;\n    vec2  info = vec2(0.0);\n    float num = 0.0;\n    for( int i=0; i<256; i++ )\n    {\n        vec3  r = map( ro+rd*t );\n        num += 1.0;\n\t    float h = r.x;\n        info = r.yz;\n        if( h<(0.001*t)||t>tmax ) break;\n        t += h;\n    }\n    return (t<tmax) ? vec4(t,info,num) : vec4(-1.0);\n}\n\nvec3 map( vec3 p )\n{\n\tfloat scale = 1.0;\n    float orb = 10000.0;\n    for( int i=0; i<6; i++ )\n\t{\n\t\tp = -1.0 + 2.0*fract(0.5*p+0.5);\n        p -= sign(p)*0.04;\n        float r2 = dot(p,p);\n\t\tfloat k = 0.95/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n        orb = min( orb, r2);\n\t}\n    float d1 = sqrt( min( min( dot(p.xy,p.xy), dot(p.yz,p.yz) ), dot(p.zx,p.zx) ) ) - 0.02;\n    float d2 = abs(p.y);\n    float dmi = d2;\n    float adr = 0.7*floor((0.5*p.y+0.5)*8.0);\n    if( d1<d2 )\n    {\n        dmi = d1;\n        adr = 0.0;\n    }\n    return vec3( 0.5*dmi/scale, adr, orb );\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    float precis = 0.0001 * t * 0.57;\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n                      e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<16; i++ )\n    {\n        vec3 w = normalize(sin(float(i)+vec3(0,1,2)));\n\t\tw *= sign( dot(w,nor) );\n        float h = float(i)/15.0;\n        ao += clamp( map( pos + nor*0.01 + w*h*0.15 ).x*2.0, 0.0, 1.0 );\n    }\n    return clamp( ao, 0.0, 1.0 );\n}\n\nvec3 palette( float h )\n{\n    vec3 col =    vec3(0.0,0.3,1.0);\n    col = mix(col,vec3(1.0,0.8,0.0),smoothstep(0.33-0.2,0.33+0.2,h));\n    col = mix(col,vec3(1.0,0.0,0.0),smoothstep(0.66-0.2,0.66+0.2,h));\n    col.y += 0.5*(1.0-smoothstep(0.0,0.2,abs(h-0.33)));\n    col *= 0.5 + 0.5*h;\n    return col;\n}\n\nfloat print( in float sdf, inout vec2 p, in int str[13])\n{\n    if( p.y<0.0|| p.y>1.0 ) return sdf;\n    float d = 1e20;\n    for( int i=0; i<str.length(); i++ )\n    {\n        int c = str[i];\n        if( c==0 ) break;\n        if( p.x>0.0 && p.x<1.0 )\n        {\n            vec2 q = p/16.0;\n            d = min(d,textureGrad( iChannel0, vec2(c,15-c/16)/16.0+q, dFdx(q), dFdy(q) ).w);\n        }\n        p.x -= 0.5;\n    }\n    return min(d,sdf);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool showCost = cos(iTime*6.283185/11.0)>=0.0;\n    \n    // supersampling loop\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 0, jj = 0;\n    #endif\n    {\n        vec2 q = fragCoord+vec2(float(ii),float(jj))/float(AA);\n\n        // camera\n        vec3 ro = vec3( 2.8*cos(0.1+0.033*iTime), 0.5 + 0.20*cos(0.037*iTime), 2.8*cos(0.5+0.035*iTime) );\n        vec3 ta = vec3( 1.9*cos(1.2+0.041*iTime), 0.5 + 0.10*cos(0.027*iTime), 1.9*cos(2.0+0.038*iTime) );\n        float roll = 0.2*cos(0.02*iTime);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        \n        // render split screen\n        vec2 res = vec2(iResolution.x/2.0,iResolution.y);\n        float ori = (q.x<res.x)?0.0:res.x;\n        vec2 p = (2.0*vec2(q.x-ori,q.y)-res)/res.y;\n        vec3 col = vec3(0.0);\n        if( !showCost || p.y>-0.9 ) \n        {\n            vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n            vec4 h = (q.x<res.x) ? raycast_rm( ro, rd, 0.01, 20.0 ): \n                                   raycast_opp( ro, rd, 0.01, 20.0 );\n                                   \n            if( !showCost )\n            {\n                float t = h.x;\n                if( t>0.0 )\n                {\n                    vec3  pos = ro + t*rd;\n                    vec3  nor = calcNormal( pos, t );\n                    float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n                    float occ = pow( clamp(h.z*2.0,0.0,1.0), 1.2 );\n                          occ = 1.5*(0.1+0.9*occ)*calcAO(pos,nor);        \n                    vec3  lin = vec3(0.8,0.8,1.0)*(2.0+fre*fre*vec3(1.8,1.0,1.0))*occ*(1.0-0.5*abs(nor.y));\n\n                    col = 0.5 + 0.5*cos( 6.2831*h.y*1.7 + vec3(0.0,2.0,3.0)+0.5 );\n                    col  = col*lin;\n                    col += 0.6*pow(1.0-fre,32.0)*occ*vec3(0.5,1.0,1.5);        \n                    col *= exp(-0.3*t);\n                }\n            }\n            else\n            {\n                if( h.w>0.0 )\n                {\n                   col = palette(clamp(h.w/128.0,0.0,1.0));\n                }\n\n                col *= exp2(-0.4*h.x);\n            }\n            col *= 0.6 + 0.4*smoothstep(-0.8,-0.5,p.y);\n            col *= 2.0;\n            col = mix(col,vec3(1.0),1.0-smoothstep( 0.003,0.004,abs(q.x-res.x)/iResolution.x ));\n        }\n        // render pallette\n        else\n        {\n            col = palette( q.x/iResolution.x );\n            col = mix(col,vec3(1.0),1.0-smoothstep( 0.003,0.004,abs(p.y+0.9)/2.0*iResolution.y/iResolution.x ));\n        }\n        col = sqrt(col);\n\n        tot += col;\n    }\n    tot = tot/float(AA*AA);\n\n\n    // draw text\n    {\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float text = 1e20;\n        const float text_scale = 7.0;\n        if( fragCoord.x<iResolution.x/2.0 )\n        {\n            vec2 q = (p-vec2(-1.78,-0.85))*text_scale;\n            text = print(text,q,int[13]( 84,114, 97,100,105,116,105,111,110, 97,108,0, 0));\n            text = print(text,q,int[13]( 32,114, 97,121,109, 97, 99,104,105,110,103,0, 0));\n        }\n        else\n        {\n            vec2 q = (p-vec2( 0.0,-0.85))*text_scale;\n            text = print(text,q,int[13]( 79, 112, 112, 111, 114, 116, 117, 110, 105, 115, 116, 105, 99 ));\n            text = print(text,q,int[13]( 32,114, 97,121,109, 97, 99,104,105,110,103,0, 0));\n        }\n\n        if( showCost )\n        {\n            vec2 q;\n            q = (p-vec2(-1.77,-0.993))*14.0; text = print(text,q,int[13]( 48,0,0,0,0,0,0,0,0,0,0,0,0));\n            q = (p-vec2(-0.27,-0.993))*14.0; text = print(text,q,int[13]( 32,105,116,101,114, 97,116,105,111,110,115,0,0));\n            q = (p-vec2( 1.62,-0.993))*14.0; text = print(text,q,int[13]( 49,50,56,0,0,0,0,0,0,0,0,0,0));\n        }\n        tot = mix(tot,vec3(0.0),1.0-smoothstep( 0.06,0.08,text-0.5));\n        tot = mix(tot,vec3(1.0),1.0-smoothstep(-0.01,0.01,text-0.5));\n    }\n    \n\tfragColor = vec4( tot, 1.0 );\t\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdsGRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[343, 478, 545, 545, 3128], [3130, 3161, 3228, 3228, 3547], [3549, 3549, 3569, 3569, 4112], [4114, 4114, 4158, 4158, 4412], [4414, 4414, 4456, 4456, 4739], [4741, 4741, 4766, 4766, 5041], [5043, 5043, 5101, 5101, 5483]], "test": "untested"}
{"id": "csl3zl", "name": "Fractal mosaic 30 (music)", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 9, "viewed": 376, "published": 3, "date": "1666656716", "time_retrieved": "2024-07-30T16:24:44.996772", "image_code": "vec2 f1(vec2 a){\n    return\n        fract(a)\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    \n    vec2 a2 = vec2(1.,0.5),\n    \n    a1 =\n        a-a2\n        //a-a2+floor(a.x-.5)\n    ;\n    \n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n        //abs(abs(fract((a1)*(a2.x+a2.y))-.5)-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    vec3 col = vec3(0.);\n    \n    float t1 = 2.;\n    \n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    \n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n        \n    vec2 t2 = vec2(0.);\n        \n    for(int k = 0; k < 6; k++){\n        \n        //uv += floor(t2.x+t2.y)/2.;\n        //uv.y += 1.;\n        \n        //if(uv.x<0.) uv.x -= 1.;\n        //else uv.y -= 1.;\n        \n        uv =\n            abs(.5*sign(uv.y-uv.x)+uv+t2)\n            //uv + t2\n            //abs(sign(uv.y-uv.x)+uv+t2)\n            //abs(.5*sign(uv.x)+uv+t2)\n            //abs(.5*sign(uv.y)+uv+t2)\n            //abs((.5+uv)+t2*sign(uv.y-uv.x))\n        ;\n        //if(uv.y>uv.x) k += 1;\n\n        \n        //uv += floor(t2.x+t2.y)/2.;\n        //if(uv.y>uv.x) uv = uv.yx; else uv *= -sign(uv.y-uv.x);\n        t2 = -triangle_wave(uv-.5*sign(uv.y-uv.x)) ;\n        \n        uv = t2-triangle_wave(uv.yx);\n\n        float c1 =\n            //length(t2)\n            abs(uv.x-uv.y)\n        ;\n        //if(uv.y>-0.25)\n        col = col.yzx;\n                \n        if(uv.y < uv.x) col = vec3(col.yz,c1);\n        \n        //else uv.x += .5;\n        //if(uv.y<uv.x) {uv=uv.yx;t2=t2.yx;}\n        //if(uv.y < uv.x) uv /= 1.+mod(uv,2.);\n        //if(k%3 == 0 && uv.x>uv.y) {uv = -uv;}\n        //uv = uv+sign(.5-uv.x);\n        \n    }\n    \n    fragColor = vec4(min(col*2.,vec3(1.)),1.0);\n}\n", "image_inputs": [], "sound_code": "vec2 mainSound(int samp, float time){\n  float tempo = 1.;\n  time /= tempo;\n  \n  //time += fpow(time*2.,2.)*fpow(time/2.,2.);\n  //time /= pow(2.,fmod(time*2.,3.));\n  float s1 = 8.;\n  \n  //time = time*(1. + fmod(time*s1/2.,2.))/2.;\n  //time = time + floor(time*s1)/s1;\n  //time = time + floor(time/s1)+floor(time);\n  \n  //time = (time + fract(time*2.)/2.)/2.;\n  //time = (time + fract(time/2.)*2.)/2.;\n  \n  float s2 = 8.,\n  m4 =\n      fmod(floor(time)*floor(time),2.)\n      //fmod(floor(time+mod(time,.5))*floor(time-mod(time,.5)),2.)\n  ,\n  t=\n      time/(1.+m4)\n      //time + floor(time*s1)/s1\n  ,\n  m1 =\n      fmod(t+m4,s2)\n  ,\n  m3 =\n      fmod(t*s1/(m1+.5),s2)\n      //fmod(t*s1+m1*s1,s2)\n  ;\n  \n  //t += pow(2.,mod(floor(t/s1/s1),4.));\n\n  //t += m3;\n  //t += fmod(t/8.,8.);\n  t /=\n      (1.+fmod(t,2.))\n  ;\n\n  //t += floor(t*s1)/s1;\n  t *=\n      s1*s1\n  ;\n  \n    float m2 =\n      1. + fmod(t/s1,s1)\n      //1. + fmod(t/s1+mod(t/s1,s1/2.),s1)\n  ;\n  \n  float a=\n      //pow(2.-log(fract(t/s1/s1)),2.)\n      64.*sqrt((1.-sqrt(fract(t/s1/s1))))*.2\n      //(pow(fract(t/s1)/2.,2.)+pow(fract(-t/s1)/2.,2.))/2.\n  ,\n\n  nb = time*pow(2.,(m3+m2)/5.+6.5)*tempo;\n\n  return\n      abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a\n      //(abs(a/16.-abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a))\n      //vec2(fract(time*nb*.998/m2*s1)*a,fract(time*nb/m2)*a)\n  ;\n\n}", "sound_inputs": [], "common_code": "float fmod2(float a, float b){\n    return mod(floor(a),b)*b;\n}\n\nfloat fmod1(float a, float b){\n    //a -= mod(a/4.,4.)-mod(a/4.,2.);\n    \n    //a += fmod2(a/2.,2.);\n    //a += floor(a/8./8.*b);\n    //divide by powers of 2 to get interesting rhythms\n    float a1 = floor(a);\n    \n    /*\n    for(float i = 1.; i < mod(floor(a),64.); i *= 2.){\n        a += mod(floor(a/b),b);\n        //a *= 1.+mod(floor(a)*2.,2.);\n        //i /= 1.+mod(floor(a)*2.,2.);\n    }\n    */\n    \n    //a /= 1. + mod(floor(a1/32.+1.),2.);\n    //a /= 1. + mod(floor(a1/16.+1.),2.);\n    //a /= 1. + mod(floor(a1/8.+1.),2.);\n    //a /= 1. + mod(floor(a1/4.+1.),2.);\n    //a /= 1. + mod(floor(a1/2.+1.),2.);\n    return\n        mod(floor(a),b)\n        //mod(floor(floor(a)*b/4./4.),b)\n        //mod(mod(floor(a/2.+4.),b),b)\n        //mod(mod(floor(a/2.)+8.,floor(a/8.)+8.),b)\n        //mod(mod(floor(a/2.+8.),floor(a/8.+8.)),b)\n        //max(mod(floor(-a/2.),b),mod(floor(a),b))\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n    ;\n}\n\nfloat fmod(float a, float b){\n    return\n        fmod1(a,b)\n        //floor(fmod1(a/2.,b)*fmod1(a,b*2.)/b/2.)\n        //fmod1(a+fmod1(a/2./b,b+fmod1(a/2./b/b,b)),b)\n    ;\n}\n\n//#define fmod(a,b) mod(mod(floor((a)),floor(1.+(a)/5.)),b)\n//#define fmod(x,y) mod(floor(floor(x)+floor((x)/8./8.)/8.),y)\n#define fmod0(x,y) mod(floor(x)+1.5*floor(mod(x,y/2.)),y)\n#define fmod1(x,y) floor(mod(floor(x+floor((x)/y)),y))\n#define fmod3(x,y) mod(floor(x)*floor(x)+floor(x)*floor((x)/y),y)\n#define fmod4(x,y) mod(floor(floor((x)/2.)*2.+x),y)\n#define sqmod(x,y) floor(mod(floor(1.+x/2.)*floor(1.+x*2.),y))\n#define fmax(x,y,z) max(fmod(x,z),fmod(y,z))\n#define fpow(x,y) pow(y,fmod(x,y))", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csl3zl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 52], [54, 54, 81, 81, 287], [289, 289, 346, 346, 1787]], "test": "untested"}
{"id": "ddfGW7", "name": "Truchet patterns, but...", "author": "fishy", "description": "... they don't work lol. reference: https://christophercarlson.com/portfolio/multi-scale-truchet-patterns/", "tags": ["truchet"], "likes": 5, "viewed": 188, "published": 3, "date": "1666654054", "time_retrieved": "2024-07-30T16:24:45.900356", "image_code": "float hash21(in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nvec2 floorv(vec2 p, float x)\n{\n    return floor(p/x)*x;\n}\n\nfloat tileSd(vec2 p, vec2 b)\n{\n    if(hash21(b) < 0.5)\n    {\n        p.x = 1.-p.x;\n    }\n    return abs(min(distance(p, vec2(0.0)),distance(p, vec2(1.0))) - 0.5)-0.166666;\n}\n\nvec2 subdivide(vec2 p, float div, int iter, out int c, out float scale)\n{\n    scale = 1.0;\n    vec2 fp;\n    int i;\n    \n    for(i = 0; i < iter; i++)\n    {\n        fp = floorv(p, scale);\n        if(hash21(fp) < div)\n        {\n            c = i;\n            return fp;\n        }\n        scale *= 0.5;\n    }\n    \n    fp = floorv(p, scale);\n    c = i;\n    return fp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x /= iResolution.y/iResolution.x;\n    uv *= 5.;\n    float px = 2.*iResolution.x/iResolution.y/iResolution.y;\n    \n    int i;\n    float scale;\n    vec2 p = subdivide(uv, 0.5, 2, i, scale);\n    \n    \n    px /= scale;\n    float dist = smoothstep(-px, px, tileSd((uv-p)/scale, p*100.));\n    \n    if(mod(float(i), 2.) == 0.0){dist = 1.-dist;}\n\n    fragColor = vec4(dist);\n    //fragColor = vec4(hash21(p.xy));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddfGW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 100], [102, 102, 132, 132, 159], [161, 161, 191, 191, 334], [336, 336, 409, 409, 701], [703, 703, 760, 810, 1264]], "test": "untested"}
{"id": "cdlGRl", "name": "Fractal portrait", "author": "loicvdb", "description": "Literally just a 2nd order mandelbulb\nNo edit whatsoever", "tags": ["fractal", "mandelbulb", "pathtracing"], "likes": 69, "viewed": 1297, "published": 3, "date": "1666651584", "time_retrieved": "2024-07-30T16:24:46.794964", "image_code": "void mainImage(out vec4 o, vec2 u)\n{\n    o = texelFetch(iChannel0, ivec2(u), 0);\n    vec2 cuv = (u - iResolution.xy * 0.5) / iResolution.y;\n    o *= 1.0 - 0.5 * dot(cuv, cuv);\n    o = (o * (2.51 * o + 0.03)) / (o * (2.43 * o + 0.59) + 0.14);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define eps 0.0002\n#define fp 8.0\n#define twopi 6.28318530718\n#define lo normalize(vec3(0.9, -0.1, -0.2))\n\nuint seed;\nfloat ot;\n\nfloat de(vec3 c)\n{\n    vec3 z = c;\n    float dr = 1.0;\n    float r = length(z);\n    ot = 1.0;\n    \n    for (int j = 0; j < 11 && r < 4.0; j++)\n    {\n        dr = dr * r * 2.0 + 1.0;\n        float t = acos(z.z / r) * 2.0;\n        float p = atan(z.y, z.x) * 2.0;\n        z = r * r * vec3(sin(t) * vec2(cos(p), sin(p)), cos(t)) + c;\n        r = length(z);\n        ot = min(abs(z.z) * 9.0, ot);\n    }\n    \n    return 0.5 * log(r) * r / dr;\n}\n\nvec4 trace(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    float d = de(ro);\n    \n    for (int i = 0; i < 128 && d > eps && t < fp + eps; i++)\n    {\n        t += d;\n        d = de(ro + rd * t);\n    }\n    \n    t -= eps;\n    \n    vec3 p = ro + rd * t;\n    vec2 k = vec2(0, eps);\n    vec3 n = normalize(vec3(de(p + k.yxx), de(p + k.xyx), de(p + k.xxy)) - de(p));\n    \n    return vec4(n, t);\n}\n\nfloat hash(int s)\n{\n    uint i = uint(s) + seed;\n    i *= 0xB5297A4Du;\n    i ^= i >> 8;\n    i += 0x68E31DA4u;\n    i ^= i << 8;\n    i *= 0x1B56C4E9u;\n    i ^= i >> 8;\n    return float(i) / float(~0u);\n}\n\nvec3 ortho(vec3 n)\n{\n    return normalize(abs(n.x) > abs(n.z) ? vec3(-n.y, n.x, 0)  : vec3(0, -n.z, n.y));\n}\n\nmat3 base(vec3 n)\n{\n    vec3 o1 = n;\n    vec3 o0 = ortho(o1);\n    return mat3(o0, cross(o0, o1), o1);\n}\n\n\nvec3 li(vec3 ro, vec3 rd)\n{\n    vec3 rad = vec3(0);\n    vec3 att = vec3(1);\n    \n    for (int b = 0; b < 4; b++)\n    {\n        vec4 t = trace(ro, rd);\n        if (t.w > fp)\n        {\n            rad += att * vec3(0.9, 0.8, 0.5) * step(rd.x + rd.z, -0.8);\n            rad += att * 0.2;\n            break;\n        }\n        \n        ro += t.w * rd;\n        \n        float la = hash(4 + b * 4) * twopi;\n        float lr = 1.0 - 0.04 * hash(5 + b * 4);\n        vec3 ld = base(lo) * vec3(sqrt(1.0 - lr * lr) * vec2(cos(la), sin(la)), lr);\n        \n        float dr = sqrt(hash(6 + b * 4));\n        float da = hash(7 + b * 4) * twopi;\n        rd = base(t.xyz) * vec3(dr * cos(da), dr * sin(da), sqrt(1.0 - dr * dr));\n        \n        att *= mix(vec3(1.0, 1.0, 0.9), vec3(0.7, 0.2, 0.3), ot);\n        rad += att * vec3(5, 6, 8) * max(0.0, dot(ld, t.xyz)) * float(trace(ro, ld).w > fp);\n    }\n    \n    return rad;\n}\n\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    seed ^= 0x300A6F5Eu * uint(iFrame);\n    seed ^= 0x884C78B7u * uint(u.x);\n    seed ^= 0x1F704572u * uint(u.y);\n    \n    vec2 cuv = (u - 0.5 + vec2(hash(0), hash(1)) - iResolution.xy * 0.5) / iResolution.y;\n    \n    vec3 rot = vec3(0.95, -0.1, 4.2);\n    vec3 c = cos(rot);\n    vec3 s = sin(rot);\n    mat3 rx = mat3(1, 0, 0, 0, c.x, s.x, 0, -s.x, c.x);\n    mat3 ry = mat3(c.y, 0, -s.y, 0, 1, 0, s.y, 0, c.y);\n    mat3 rz = mat3(c.z, s.z, 0, -s.z, c.z, 0, 0, 0, 1);\n    mat3 cam = rx * ry * rz;\n    \n    float a = hash(2) * twopi;\n    vec3 ap = 0.1 * sqrt(hash(3)) * vec3(cos(a), sin(a), 0);\n    \n    vec3 rd = cam * normalize(vec3(cuv * 3.0, 4.6) - ap);\n    vec3 ro = cam * (vec3(0, -0.2, -5) + ap);\n    \n    vec4 tex = texelFetch(iChannel0, ivec2(u), 0);\n    uint m = floatBitsToUint(tex.w) + 1u;\n    o = vec4(mix(tex.xyz, li(ro + 4.0 * rd, rd), 1.0 / float(m)), uintBitsToFloat(m));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdlGRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 243]], "test": "untested"}
{"id": "mdfGRs", "name": "Gltch [291 Chars]", "author": "Xor", "description": "[url=https://twitter.com/XorDev/status/1584603104292769792]Tweet[/url]", "tags": ["golf", "300chars"], "likes": 41, "viewed": 702, "published": 3, "date": "1666634352", "time_retrieved": "2024-07-30T16:24:47.670623", "image_code": "/*\n    \"Gltch\" by @XorDev\n    \n    Tweet: twitter.com/XorDev/status/1584603104292769792\n    Twigl : t.co/C60Z76weG4\n\n    <300 chars playlist: https://www.shadertoy.com/playlist/fXlGDN\n    -3 Thanks to FabriceNeyret2\n*/\nvoid mainImage(out vec4 O, vec2 I)\n{\n    //Noise macro\n    #define N(x) texture(iChannel0,(x)/64.).r\n    \n    //Clear fragcolor\n    O -= O;\n    //Res for scaling, position and scaled coordinates\n    vec2 r = iResolution.xy, c;\n    \n    //Iterate from -1 to +1 in 100 steps\n    for(float i=-1.; i<1.; i+=.02)\n        //Compute centered position with aberation scaling\n        c=(I+I-r)/r.y/(.4+i/1e2),\n        //Generate random glitchy pattern (rotate in 45 degree increments)\n        O += ceil(cos((c*mat2(cos(ceil(N(c/=(.1+N(c)))*8.)*.785+vec4(0,33,11,0)))).x/\n        //Generate random frequency stripes\n        N(N(c)+ceil(c)+iTime)))*\n        //Pick aberration color (starting red, ending in blue)\n        vec4(1.+i,2.-abs(i+i),1.-i,1)/1e2;\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdfGRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 219, 255, 273, 965]], "test": "untested"}
{"id": "fsXBWN", "name": "Aquatic Theme", "author": "lz", "description": "Somewhere at the bottom of the ocean.", "tags": ["2d", "animation", "cineshader"], "likes": 4, "viewed": 450, "published": 3, "date": "1666633837", "time_retrieved": "2024-07-30T16:24:48.573210", "image_code": "#define PI 3.14159265359\n#define PI2 6.28318530718\n\n#define A_START 4\n#define A_N 11\n#define N_ANG 6.\n\n#define ANIM_T(_t, _e, _p) (smoothstep(_p - _e, _p, _t) - smoothstep(_p, _p + _e, _t))\n#define PULSE_T(_t, _e, _pa, _pb) (smoothstep(_pa - _e, _pa, _t) - smoothstep(_pb, _pb + _e, _t))\n\nconst float dists[10] = float[10](0.5, 0.65, 0.16, 1.0, -1.2, 0.4, 2.1, 0.3, -2.3, 0.9);\nconst vec3 cols[7] = vec3[7](vec3(0., 0.3, 0.7), vec3(0.0, 0.3, 0.96), vec3(0.5, .4, 0.2), vec3(0.4, 0.3, 0.04), vec3(0.2, .05, 0.), vec3(0.9, 0.6, 0.1), vec3(0.5, 0.21, 0.4));\nconst vec3 plasma[11] = vec3[11](vec3(0.050383,0.029803,0.527975),vec3(0.254627,0.013882,0.615419),vec3(0.417642,0.000564,0.65839),vec3(0.562738,0.051545,0.641509),vec3(0.69284,0.165141,0.564522),vec3(0.798216,0.280197,0.469538),vec3(0.881443,0.392529,0.383229),vec3(0.949217,0.517763,0.295662),vec3(0.98826,0.652325,0.211364),vec3(0.988648,0.809579,0.145357),vec3(0.940015,0.975158,0.131326));\nconst vec3 Blues[11] = vec3[11](vec3(0.9686274509803922,0.984313725490196,1.0),vec3(0.8901960784313725,0.9341176470588235,0.9749019607843137),vec3(0.8141176470588235,0.883921568627451,0.9498039215686275),vec3(0.7137254901960783,0.8321568627450979,0.9152941176470588),vec3(0.5796078431372549,0.7701960784313725,0.8737254901960784),vec3(0.4196078431372549,0.6823529411764706,0.8392156862745098),vec3(0.29098039215686267,0.5945098039215685,0.7890196078431372),vec3(0.18117647058823522,0.4949019607843136,0.7364705882352941),vec3(0.09019607843137256,0.39294117647058824,0.6705882352941177),vec3(0.03137254901960784,0.2917647058823529,0.5733333333333334),vec3(0.03137254901960784,0.18823529411764706,0.4196078431372549));\nconst vec3 bckColor = vec3(0.067, 0.67, 0.89);\n\nfloat hash2(in vec2 st) {\nreturn fract(sin(dot(st.xy,\nvec2(12.9898,78.233)))\n* 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\nvec2 i = floor(st);\nvec2 f = fract(st);\n\n// Four corners in 2D of a tile\nfloat a = hash2(i);\nfloat b = hash2(i + vec2(1.0, 0.0));\nfloat c = hash2(i + vec2(0.0, 1.0));\nfloat d = hash2(i + vec2(1.0, 1.0));\n\n// Smooth Interpolation\n\n// Cubic Hermine Curve. Same as SmoothStep()\nvec2 u = f*f*(3.0-2.0*f);\n// u = smoothstep(0.,1.,f);\n\n// Mix 4 coorners porcentages\nreturn mix(a, b, u.x) +\n(c - a)* u.y * (1.0 - u.x) +\n(d - b) * u.x * u.y;\n}\n\n\nfloat flower(in vec2 _uv, in float _N, in float _phase, in float _size)\n{\n    vec2 center = _size*vec2(cos(-PI/_N), sin(-PI/_N));\n    float alpha = _phase + atan(_uv.x, _uv.y);\n    float r = length(_uv);\n    vec2 nuv = normalize(_uv);\n    alpha = mix(alpha, -PI-(PI-alpha), step(0., alpha));\n    alpha = -mod(abs(alpha), PI2/_N);\n    vec2 op = r*vec2(cos(alpha), sin(alpha));\n    return length(op - center);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1) --> scaled\n    vec2 uv = 2.*(2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec2 grid = uv;\n    grid = uv;\n    vec3 col;\n    float svis = 0.;\n    for (float it = 0.; it < 5.; it+=1.)\n    {\n        float tfact = 0.2 * it;\n        float time = iTime - tfact;\n        // Time varying pixel color\n        vec3 tcol;\n        \n        // animation timers\n        float t5 = mod(time, 5.);\n        float t17 = mod(time, 17.);\n        float t25 = mod(time, 25.);\n        float t47 = mod(time, 47.);\n        \n        const float ampl = 1./float(A_N);\n        float dr = ampl * PULSE_T(t25, 2., 4., 21.) + ampl * PULSE_T(t17, .5, 7., 13.);\n        float clScheme = PULSE_T(t47, 0.75, 27., 43.);\n\n        for (int ii = A_START; ii <= A_START + A_N; ii++)\n        {\n          float ivis = noise(vec2(0.25 * time, float(ii)));\n          svis += ivis;\n          int i0 = ii - A_START;\n          float r = mix(1.75 - dr * float(i0), 0.25 + dr * float(i0), PULSE_T(t17, 1., 4.5, 11.5));\n          float f = flower(grid, float(ii), mod((0.2*cos(time * 0.1) + 0.1 * noise(vec2(float(ii), time))),PI2), r);\n          f = pow(f, (0.5 + r*0.1)/float(A_N) + 0.75/float(A_N)*ANIM_T(t5, 1., 2.5));\n          \n          int ci = (i0) % 11;\n          tcol += smoothstep(0., 0.25, ivis) * mix(plasma[ci], Blues[ci], clScheme) * vec3(1. - f);\n        }\n        \n        col += tcol * pow(0.5, it);\n    }\n    \n    // add background\n    col = clamp(col, vec3(0.), vec3(1.));\n    float rGrid = length(grid*0.15);\n    vec3 background = mix(bckColor * 0.1, bckColor * 0.8, 1. - exp(-rGrid));\n    \n    col = mix(background, col, 1. - rGrid);\n    \n    //col = 1.6 * pow(col, vec3(1.6));\n\n    fragColor = vec4(col,length(col)*0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXBWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1715, 1715, 1740, 1740, 1811], [1813, 1813, 1839, 1839, 2275], [2278, 2278, 2351, 2351, 2687], [2689, 2689, 2746, 2807, 4502]], "test": "untested"}
{"id": "sltBRr", "name": "Raymarching 2.0 WIP", "author": "FifthStateOfMatter", "description": "Raymarching", "tags": ["3d", "raymarching"], "likes": 3, "viewed": 247, "published": 3, "date": "1666627624", "time_retrieved": "2024-07-30T16:24:49.351130", "image_code": "#define lPos vec3(12, 25, -10)\n#define PI 3.1415926545\n#define degreesToRadians PI/180.0\n#define FOV 90.0*degreesToRadians\n#define epsilon 0.01\n#define maxSteps 500\n#define maxDist 300.0\n#define fogDensity 1.0\n#define fogColor vec3(0.4, 0.7, 0.9)\n\nfloat random(vec3 p){\n    return fract((sin(p.x*203.24 + 20398.243)*sin(p.y*834.29 + 2382.2033)*sin(p.z*405.09))*20384.043);\n}\n\nfloat noise2(vec2 p){\n    vec2 luv = fract(p);\n    vec2 id = floor(p);\n    luv = luv*luv*(3.0 - 2.0*luv);\n    float bl = random(vec3(id, 1));\n    float br = random(vec3(id + vec2(1, 0), 1));\n    float b = mix(bl, br, luv.x);\n    \n    float tl = random(vec3(id + vec2(0, 1), 1));\n    float tr = random(vec3(id + vec2(1, 1), 1));\n    float t = mix(tl, tr, luv.x);\n    return mix(b, t, luv.y);\n}\n\nfloat noise3(vec3 p){\n    vec3 fc = floor(p);\n    vec3 frc = fract(p);\n    frc = smoothstep(0.0, 1.0, frc);\n    \n    float tlf = random(fc + vec3(0, 1, 0));\n    float trf = random(fc + vec3(1, 1, 0));\n    float blf = random(fc + vec3(0, 0, 0));\n    float brf = random(fc + vec3(1, 0, 0));\n    float tlb = random(fc + vec3(0, 1, 1));\n    float trb = random(fc + vec3(1, 1, 1));\n    float blb = random(fc + vec3(0, 0, 1));\n    float brb = random(fc + vec3(1, 0, 1));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    float lerpTopBack = mix(tlb, trb, frc.x);\n    float lerpBottomBack = mix(blb, brb, frc.x);\n    \n    float lerpFront = mix(lerpBottomFront, lerpTopFront, frc.y);\n    float lerpBack = mix(lerpBottomBack, lerpTopBack, frc.y);\n    \n    return mix(lerpFront, lerpBack, frc.z);\n}\n\nfloat f = 1.0/tan(FOV/2.0);\n\nstruct material{\n    vec3 clr;\n    float intensity;\n    float type;\n};\n\nstruct SDF{\n    float dist;\n    material mat;\n};\n\nstruct cam{\n    vec3 pos;\n    vec3 dir;\n};\n\nSDF sphereSDF(vec3 p, float rad, material mat){\n    return SDF(length(p) - rad, mat);\n}\n\nSDF boxSDF(vec3 p, vec3 s, material mat){\n    vec3 q = abs(p) - s;\n    return SDF(length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0), mat);\n}\n\nSDF boxFrameSDF(vec3 p, vec3 s, float sw, float ro, material mat){\n  p = abs(p) - s;\n  vec3 q = abs(p + sw) - sw;\n  return SDF(min(\n      min(\n          length(max(vec3(p.x, q.y, q.z),0.0)) + min(max(p.x, max(q.y, q.z)), 0.0),\n          length(max(vec3(q.x, p.y, q.z),0.0)) + min(max(q.x, max(p.y, q.z)), 0.0)\n      ),\n      length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0)) - ro, mat);\n}\n\nSDF yPlaneSDF(vec3 p, float y, material mat){\n    return SDF(p.y - y, mat);\n}\n\nSDF opTwist(vec3 p, material mat){\n    const float k = 0.785;\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2 m = mat2(c, -s, s, c);\n    vec3  q = vec3(m*p.xz, p.y);\n    return boxSDF(q, vec3(1, 1, 3), mat);\n}\n\nSDF opRep(in vec3 p, in vec3 c, material mat){\n    vec3 q = mod(p + 0.5*c, c) - 0.5*c;\n    return boxSDF(q, vec3(1, 1, 1), mat);\n}\n\nSDF sceneSDF(vec3 p, float type){\n    float xt = 0.0;\n    float yt = iTime*5.0;\n    float zt = 0.0;\n    \n    mat3 yRotation;\n    yRotation[0] = vec3(cos(yt*degreesToRadians), 0, -sin(yt*degreesToRadians));\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sin(yt*degreesToRadians), 0, cos(yt*degreesToRadians));\n    \n    mat3 xRotation;\n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, cos(xt*degreesToRadians), -sin(xt*degreesToRadians));\n    xRotation[2] = vec3(0, sin(xt*degreesToRadians), cos(xt*degreesToRadians));\n    \n    mat3 zRotation;\n    zRotation[0] = vec3(cos(zt*degreesToRadians), -sin(zt*degreesToRadians), 0);\n    zRotation[1] = vec3(sin(zt*degreesToRadians), cos(zt*degreesToRadians), 0);\n    zRotation[2] = vec3(0, 0, 1);\n    \n    float f = 2.0;\n    float h = 0.25;\n    float v = -0.0;\n    int d = 1;\n    \n    float n = noise3((p + vec3(5, iTime*v, 0))*f)*h;\n    for(int i = 0; i < d; i++){\n        h /= 2.0;\n        f *= 2.0;\n        v *= 2.0;\n        n += noise3((p + vec3(5, iTime*v, 0))*f)*h;\n    }\n    \n    n /= 2.0;\n    \n    float gf = 0.25;\n    float gh = 0.7;\n    float gv = 0.0;\n    int gd = 2;\n    \n    float gn = noise3((p + vec3(5, iTime*0.5, 2))*gf)*gh;\n    for(int i = 0; i < gd; i++){\n        gh /= 2.0;\n        gf *= 2.0;\n        gv *= 2.0;\n        gn += noise3((p + vec3(5.0 + float(i), iTime*0.5 + float(i), 2.0 + float(i)))*gf)*gh;\n    }\n    \n    gn /= 2.0;\n    \n    //gn += n;\n    \n    SDF ground = yPlaneSDF(p, -0.4, material(vec3(0, 0.1, 0.1), 0.8, 3.0));\n    SDF sun = sphereSDF(p - lPos, 1.0, material(vec3(1), 0.0, 0.0));\n    SDF ball = sphereSDF(p - vec3(0, 1, 10), 1.0, material(vec3(0, 1, 0), 0.8, 2.0));\n    SDF ball2 = sphereSDF(p - vec3(3, 1.5, 12), 1.5, material(vec3(1, 0, 0), 0.4, 2.0));\n    ground.dist -= gn;\n    \n    //Thanks to @dean_the_coder for helping with ray overstepping\n    //ground.dist *= 0.6;\n    \n    float closest;\n    if(type == 0.0){\n        closest = min(sun.dist, min(ground.dist, min(ball.dist, ball2.dist)));\n    }else{\n        closest = min(ground.dist, min(ball.dist, ball2.dist));\n    }\n    \n    if(closest == ground.dist){\n        return ground;\n    }else if(closest == sun.dist){\n        return sun;\n    }else if(closest == ball.dist){\n        return ball;\n    }else if(closest == ball2.dist){\n        return ball2;\n    }\n}\n\nbool raymarch(vec3 orig, vec3 dir, out float t, out material mat, float eps, out float res, float type){\n    t = 0.0;\n    float resol = 1.0;\n    float ph = 1e20;\n    for(int i = 0; i < maxSteps && t < maxDist && t >= 0.0; i++){\n        vec3 r = orig + dir*t;\n        SDF s = sceneSDF(r, type);\n        mat = s.mat;\n        t += s.dist;\n        \n        if(s.dist < eps){\n            resol = 0.0;\n            return true;\n        }\n        \n        float y = s.dist*s.dist/(2.0*ph);\n        float d = sqrt(s.dist*s.dist - y*y);\n        resol = min(resol, 8.0*d/max(0.0, t - y));\n    }\n    res = resol;\n    return false;\n}\n\nvec3 getNormals(vec3 h){\n    return normalize(vec3(\n        sceneSDF(vec3(h.x + epsilon, h.yz), 1.0).dist - sceneSDF(vec3(h.x - epsilon, h.yz), 1.0).dist,\n        sceneSDF(vec3(h.x, h.y + epsilon, h.z), 1.0).dist - sceneSDF(vec3(h.x, h.y - epsilon, h.z), 1.0).dist,\n        sceneSDF(vec3(h.xy, h.z + epsilon), 1.0).dist - sceneSDF(vec3(h.xy, h.z - epsilon), 1.0).dist\n    ));\n}\n\nvec3 reflectRay(vec3 r, vec3 n){\n    return r - 2.0*n*dot(r, n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    cam camera = cam(vec3(0, 4, 0), vec3(5, 0, 0));\n    \n    mat3 projection;\n    \n    projection[0] = vec3(1, 0, 0);\n    projection[1] = vec3(0, 1, 0);\n    projection[2] = vec3(0, 0, f);\n    \n    mat3 xRotation;\n    \n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, cos(camera.dir.x*degreesToRadians), -sin(camera.dir.x*degreesToRadians));\n    xRotation[2] = vec3(0, sin(camera.dir.x*degreesToRadians), cos(camera.dir.x*degreesToRadians));\n    \n    mat3 yRotation;\n    \n    yRotation[0] = vec3(cos(camera.dir.y*degreesToRadians), 0, -sin(camera.dir.y*degreesToRadians));\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sin(camera.dir.y*degreesToRadians), 0, cos(camera.dir.y*degreesToRadians));\n\n    vec3 orig = camera.pos;\n    vec3 dir = normalize(vec3(uv.xy, 1.0)*xRotation*yRotation*projection);\n    \n    float t;\n    material rMat;\n    float ph;\n    bool r = raymarch(orig, dir, t, rMat, epsilon, ph, 0.0);\n    \n    //Thanks to @spalmer for help with getting the light to display correctly\n    if(!r){\n        t = 500.0;\n    }\n    \n    vec3 lRay = normalize(lPos - (orig + dir*t));\n    \n    vec3 col = mix(fogColor, vec3(1), min(pow(dot(normalize(-lRay), normalize(dir)), 100000.0/(fogDensity*0.1 + 0.7)), 1.0));\n    \n    float d;\n    if(r){\n        vec3 normal = getNormals(orig + dir*t);\n        \n        float lt;\n        material lMat;\n        float shadowClr;\n        bool rL = raymarch((orig + dir*t) + normal*0.1, normalize(lPos - (orig + dir*t)), lt, lMat, 0.0001, shadowClr, 1.0);\n        d = max(dot(normal, lRay), 0.0);\n        float spec = 0.0;\n        if(rMat.type == 1.0){\n            spec = max(pow(d, 15.0), 0.1);\n        }else{\n            spec = 0.0;\n        }\n        \n        float c;\n        \n        if(rMat.type != 0.0){\n            if(rMat.type != 3.0){\n                c = max(d, 0.1)*shadowClr;\n            }else if(rMat.type == 3.0){\n                c = max(d, 0.5);\n            }\n        }else{\n            c = 1.0;\n        }\n        \n        if(rMat.type == 0.0 || lt <= 0.01){\n            shadowClr = 1.0;\n        }\n        \n        float dtl = length(lPos - (orig + dir*t));\n        \n        if(rMat.type != 0.0 && rMat.type != 3.0){\n            col = mix((rMat.clr*max(c, 0.1) + spec)*shadowClr, fogColor, min(t/(1.0/(fogDensity*0.004)), 1.0));\n        }else if(rMat.type == 0.0){\n            col = rMat.clr;\n        }else if(rMat.type == 3.0){\n            //c *= shadowClr;\n            vec3 reflectOrig = (orig + dir*t) + normal*0.01;\n            vec3 reflectD = reflectRay(dir, normal);\n            float reflectT;\n            material reflectMat;\n            float rph;\n            \n            bool reflectMarch = raymarch(reflectOrig + normal*epsilon, normalize(reflectD), reflectT, reflectMat, epsilon, rph, 0.0);\n            if(reflectMarch){\n                float rc;\n                vec3 reflectN = getNormals(reflectOrig + normal*epsilon + normalize(reflectD)*reflectT);\n                if(reflectMat.type != 0.0){\n                    rc = dot(reflectN, normalize(lRay));\n                }else{\n                    rc = 1.0;\n                }\n                col = mix(mix(reflectMat.clr*max(c, 0.5)*max(shadowClr, 0.5)*max(rc, 0.2), rMat.clr*max(c, 0.5)*max(shadowClr, 0.3), rMat.intensity), fogColor, min(t/(1.0/(fogDensity*0.004)), 1.0));\n                //reflectT = 500.0;\n            }else{\n                col = mix(mix(fogColor*max(c, 0.5)*max(shadowClr, 0.5), rMat.clr*max(c, 0.5)*max(shadowClr, 0.3), rMat.intensity), fogColor, min(t/(1.0/(fogDensity*0.004)), 1.0));\n            }\n        }\n        //col = pow(col, vec3(1.0/2.2));\n    }\n    \n    fragColor = vec4(pow(col, vec3(1.0/2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 248, 269, 269, 374], [376, 376, 397, 397, 768], [770, 770, 791, 791, 1619], [1816, 1816, 1863, 1863, 1903], [1905, 1905, 1946, 1946, 2051], [2053, 2053, 2119, 2119, 2466], [2468, 2468, 2513, 2513, 2545], [2547, 2547, 2581, 2581, 2769], [2771, 2771, 2817, 2817, 2901], [2903, 2903, 2936, 2936, 5226], [5228, 5228, 5332, 5332, 5848], [5850, 5850, 5874, 5874, 6227], [6229, 6229, 6261, 6261, 6295], [6297, 6297, 6351, 6351, 10094]], "test": "untested"}
{"id": "cdXGzs", "name": "Vertical Video Enlargement", "author": "turboplay", "description": "Assuming you have a vertical video (thats why pass #1 crops the input), it blurs and zooms the rest. Similar to what I 've seen in shows. Enhancement of my https://www.shadertoy.com/view/flVcDz", "tags": ["video", "blur"], "likes": 0, "viewed": 195, "published": 3, "date": "1666617117", "time_retrieved": "2024-07-30T16:24:50.098133", "image_code": "// MIT\n\n// Second, enlarge\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 Radius = Size / iResolution.xy;\n\n    if (uv.x < left || uv.y < top || uv.x > right || uv.y > bottom)\n    {\n        float HorizontalZoom = 1. / (1. - (left + (1. - right)));\n        float VerticalZoom = 1. / (1. - (top + (1. - bottom)));\n\n        // https://www.shadertoy.com/view/wtKfWt\n        // Convert uv range to -1 to 1\n        vec2 xy = uv;\n        xy = xy * 2.0 - 1.0;\n\n        // Scale uv\n        xy.x /= HorizontalZoom;\n        xy.y /= VerticalZoom;\n\n        // Convert back to 0 to 1 range\n        xy = (xy + 1.) / 2.0f;\n\n        vec4 Color = texture(iChannel0,xy);\n\n        // Blur\n        // https://www.shadertoy.com/view/Xltfzj\n        for (float d = 0.0; d < Pi2; d += Pi2 / Directions)\n        {\n            for (float i = 1.0 / Quality; i <= 1.0; i += 1.0 / Quality)\n            {\n                Color += texture(iChannel0,xy + vec2(cos(d), sin(d)) * Radius * i);\n            }\n        }\n        Color /= Quality * Directions - 15.0;\n        fragColor = Color;\n    }\n    else\n        fragColor = texture(iChannel0,uv);\n\n\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// MIT\n\n// First, crop the video\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // crop enough\n    if (uv.x < left || uv.x > right || uv.y < top || uv.y > bottom)\n        fragColor = vec4(0);\n    else\n        fragColor = texture(iChannel0,uv);\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// MIT\n\n// crop %\nfloat left = 0.25;\nfloat right = 0.75;\nfloat top = 0.0f;\nfloat bottom = 1.0f;\n\n\n// Gaussian Blur Settings\nfloat Directions = 16.; // BLUR DIRECTIONS (Default 16.0 - More is better but slower), 8,64,32\nfloat Quality = 32.; // BLUR QUALITY (Default 4.0 - More is better but slower) 4,64,32\nfloat Size = 32.; // BLUR SIZE (Radius) 0-128\n\n// Constants\nconst float Pi2 = 6.28318530718; // Pi*2", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdXGzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[8, 27, 84, 134, 1226]], "test": "untested"}
{"id": "cdfGRs", "name": "Gosper Curve Zoomed", "author": "mla", "description": "The Gosper Curve using a simple stack (just storing the offset of the \"current instruction\").\n\nZoomed right in to a 14 level pattern, where we start to hit numeric limits.", "tags": ["optimized", "lsystem", "stack", "gosper"], "likes": 13, "viewed": 244, "published": 3, "date": "1666614282", "time_retrieved": "2024-07-30T16:24:50.984762", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Gosper Curve, drawn with stack. mla, 2022.\n//\n// Optimized implementation, and now with winding number calculation.\n// Zoomed in to 14 levels (so 7^14 segments in complete pattern).\n//\n// Uses an explicit stack to keep track of the recursion.\n// This one keeps track of intermediate segments and avoids recursing far from\n// the point being plotted.\n//\n// Mouse down shows segments actually drawn around mouse position\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\n#define C(turns,offset) (((turns) << 16) | ((offset) & 0xffff))\n// Each instruction is an integer number of turns, followed by\n// either an instruction offset for the recursive call or -1\n// to terminate the current level.\nconst int A = 0, B = 8, END = -1, L = -1, R = 1;\nconst int program[16] =\n  int[] (C(0,A),C(L,B),C(L+L,B),C(R,A), C(R+R,A),C(0,A),C(R,B),C(L,END),\n         C(R,A),C(L,B),C(0,B),C(L+L,B), C(L,A),C(R+R,A),C(R,B),C(0,END));\n\nconst float angle = PI/3.0;\n\nconst int maxdepth = 14;\n\nvec2 p = vec2(0);     // The drawing point\nvec2 point = vec2(100); // The moving point\nfloat plen = 0.0;     // Cumulative path length\n\nint wind = 0; // Compute winding number here\nvoid polywind(vec2 p, vec2 q, vec2 r) {\n  // NR winding number computation\n  q -= p; r -= p; // Relative to p\n  float t = determinant(mat2(q,r));\n  if (q.y <= 0.0) {\n    if (r.y > 0.0 && t > 0.0) wind++;\n  } else {\n    if (r.y <= 0.0 && t < 0.0) wind--;\n  }\n}\n\nfloat drawsegment(vec2 pos, float seglen, float theta, float t) {\n  vec2 seg = seglen*vec2(cos(theta),sin(theta));\n  if (t >= plen && t < plen+seglen) point = p + (t-plen)/seglen*seg;\n  vec2 q = p + seg;\n  float d = segment(pos,p,q);\n  polywind(pos,p,q);\n  plen += seglen;\n  p = q;\n  return d;\n}\n\nfloat magic = 0.333473; // !!\n\nvec2 map(vec2 pos) {\n  pos = (2.0*pos - iResolution.xy)/iResolution.y;\n  pos.x += 0.2*iTime;\n  pos /= exp(10.0);\n  pos -= vec2(-0.5,-0.8);\n  return pos;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 pos = map(fragCoord);\n  vec2 pos2 = pos;\n  if (iMouse.z > 0.0) pos2 = map(iMouse.xy);\n  int stack[maxdepth];\n  int depth = 0;\n  stack[depth++] = 0;\n  float t = mod(iTime,pow(7.0,0.5+0.5*float(maxdepth))); // Moving point\n  float d = 1e8;\n  float seglen = 1.0;\n  float theta = 0.0;    // Cumulative angle\n  while (depth > 0) {\n    int instr = program[stack[depth-1]++];\n    // Decode instruction\n    int turns = instr>>16;\n    int code = instr<<16>>16;\n    theta += float(turns)*angle; // Apply turn\n    if (code == END) {\n      depth--;    // Terminate level & unwind\n      seglen *= sqrt(7.0);\n    } else if (depth == maxdepth) {\n      d = min(d,drawsegment(pos,seglen,theta,t)); // Segment\n    } else if (distance(pos2,p) > 1.2*seglen) {\n      // Short circuit\n      float offset = float(maxdepth-depth)*magic;\n      vec2 seg = seglen*vec2(cos(theta-offset),sin(theta-offset));\n      polywind(pos,p,p+seg);\n      // Show skipped segments on mouse down.\n      if (iMouse.z > 0.0) d = min(d,segment(pos,p,p+seg));\n      p += seg;\n      plen += seglen*pow(7.0,0.5*float(maxdepth-depth));\n    } else {\n      stack[depth++] = code;  // Recurse\n      seglen /= sqrt(7.0);\n    }\n  }\n  float px = fwidth(pos.x);\n  vec3 col = vec3(smoothstep(0.0,px,d));\n  if ((wind&1) != 0) col *= 0.8;\n  col = mix(vec3(1,0,0), col,smoothstep(0.0,px,distance(pos,point)-0.01));\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "const float PI = 3.1415926;\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfGRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1241, 1272, 1311, 1346, 1531], [1533, 1533, 1598, 1598, 1828], [1861, 1861, 1881, 1881, 2015], [2017, 2017, 2072, 2072, 3463]], "test": "untested"}
{"id": "cdfGRl", "name": "1D worlds  explorer", "author": "lomateron", "description": "why does it look different from other 1D automata simulations?\nbecause this applies a fix to remove flickering between frames\nthis flickering fix also creates more colors\nthe bigger the kernel across time the more colors there are\nread Common tab", "tags": ["automata"], "likes": 2, "viewed": 183, "published": 3, "date": "1666613203", "time_retrieved": "2024-07-30T16:24:51.803573", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int  m = tz+1;\n    int  i = int(mod(fragCoord.y,rz))%m;\n    vec4 a = texelFetch(iChannel0,ivec2(fragCoord),0);\n    uint n = (1U<<m)-1U;\n    uint b = floatBitsToUint(a.x)&n;\n    uint c = ((b>>i)|(b<<(m-i))) &n;\n    //fragColor = cos(float(c)*88.8888+vec4(3,1,2,4))*.5+.5;\n    if(tz==1){fragColor = vec4(float(c)/float(n));}\n    if(tz==2){fragColor = vec4((c>>0)&1U,(c>>1)&1U,(c>>2)&1U,0);}\n    if(tz> 2){fragColor = cos(float(c)/float(n)*4.4+vec4(2,3,4,5)+.8);}\n    //fragColor = vec4(b&1U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rz 120.  //size of each world in pixels\n#define sz  3.   //size of kernel across space\n#define tz  1    //size of kernel across time          must be <= 32\n#define nz  .02  //size of mouse click noise ball\n\n//exploration works when texture is 1920*1080\n//if you dont have 1920*1080 texture\n//then you must change rz to textureWidth/16\n\n//1920*1080 and rz=120 will show 16*9 worlds simulations\n//becos 1920/rz*1080/rz = 16*9\n//mouse click on each world will show the next 16*8 worlds\n//go to BufferA line24, change 0U to 1U to keep exploring next 16*8*16*8 worlds\n//there are 2^(sz*tz+1) different worlds to explore\n//arktually 2^(sz*tz  ) becous half are worlds inverted in color", "buffer_a_code": "uint read(vec2 u, vec2 m)\n{\n    vec2 o = mod(u+m,rz);\n         u = floor(u/rz)*rz+o;\n    return floatBitsToUint(texelFetch(iChannel0,ivec2(u),0).x);\n}\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float ck = -floor((sz-1.)*.5);    //center the kernel\n    float ev = float(mod(sz,2.)==0.); //move and resize kernel when sz = even\n    uint  o  = 0U;                    //sum of all bits\n                          float n = (float(iFrame&1)-1.)*ev;\n    for(int   t=0 ; t<tz; ++t){ float m = n*(1.-float(t&1)); float s2 = sz-float(t&1)*ev; \n    for(float i=0.; i<s2; ++i){ uint  r = read(u,vec2(i+ck+m,-1));\n                                o += (r>>t)&1U;\n    }}\n    vec2 r2 = floor(iResolution.xy/rz);\n    uint u2 = uint(dot(floor(        u/rz),vec2(1,r2.x)));\n    uint m2 = uint(dot(floor(iMouse.xy/rz),vec2(1,r2.x)));\n    \n    uint a = +u2                      //divides screen in 16*8 worlds\n             +16U*8U        *m2       //show next 16*8 worlds with mouse click\n             +16U*8U*16U*8U *0U;      //show next 16*8*16*8 worlds\n    //if(o>=32U){a = 1430607221U;}  \n    o = (read(u,vec2(0,-1))<<1U) | ((a>>(o&31U))&1U);\n    fragColor = vec4(uintBitsToFloat(o));\n    if((iFrame%int(rz))!=int(mod(u.y,rz))){fragColor = texelFetch(iChannel0,ivec2(u),0);}\n    if(iFrame==0||iMouse.z>.5)\n    {\n        uvec2 p = uvec2(u) + 1920U*1080U*uint(iFrame);\n              p = 1103515245U * ( (p>>1U) ^ (p.yx   ) );\n        uint  q = 1103515245U * ( (p.x  ) ^ (p.y>>3U) );\n        fragColor = vec4(float(q));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfGRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 554]], "test": "untested"}
{"id": "ddXGzf", "name": "mandelbrot zoomer 2", "author": "the0neboy", "description": "emulating more bits for higher quality", "tags": ["mandelbrot"], "likes": 4, "viewed": 208, "published": 3, "date": "1666612822", "time_retrieved": "2024-07-30T16:24:52.557557", "image_code": "#define T iTime\n#define iterations 1500\n#define gradientEnabled true\n\nfloat times_frc(float a, float b) {\n  return mix(0.0, a * b, b != 0.0 ? 1.0 : 0.0);\n}\n\nfloat plus_frc(float a, float b) {\n  return mix(a, a + b, b != 0.0 ? 1.0 : 0.0);\n}\n\nfloat minus_frc(float a, float b) {\n  return mix(a, a - b, b != 0.0 ? 1.0 : 0.0);\n}\n\n// Double emulation based on GLSL Mandelbrot Shader by Henry Thasler (www.thasler.org/blog)\n//\n// Emulation based on Fortran-90 double-single package. See http://crd.lbl.gov/~dhbailey/mpdist/\n// Substract: res = ds_add(a, b) => res = a + b\nvec2 add (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float t1, t2, e;\n\n  t1 = plus_frc(dsa.x, dsb.x);\n  e = minus_frc(t1, dsa.x);\n  t2 = plus_frc(plus_frc(plus_frc(minus_frc(dsb.x, e), minus_frc(dsa.x, minus_frc(t1, e))), dsa.y), dsb.y);\n  dsc.x = plus_frc(t1, t2);\n  dsc.y = minus_frc(t2, minus_frc(dsc.x, t1));\n  return dsc;\n}\n\n// Substract: res = ds_sub(a, b) => res = a - b\nvec2 sub (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float e, t1, t2;\n\n  t1 = minus_frc(dsa.x, dsb.x);\n  e = minus_frc(t1, dsa.x);\n  t2 = minus_frc(plus_frc(plus_frc(minus_frc(minus_frc(0.0, dsb.x), e), minus_frc(dsa.x, minus_frc(t1, e))), dsa.y), dsb.y);\n\n  dsc.x = plus_frc(t1, t2);\n  dsc.y = minus_frc(t2, minus_frc(dsc.x, t1));\n  return dsc;\n}\n\n// Compare: res = -1 if a < b\n//              = 0 if a == b\n//              = 1 if a > b\nfloat cmp(vec2 dsa, vec2 dsb) {\n  if (dsa.x < dsb.x) {\n    return -1.;\n  }\n  if (dsa.x > dsb.x) {\n    return 1.;\n  }\n  if (dsa.y < dsb.y) {\n    return -1.;\n  }\n  if (dsa.y > dsb.y) {\n    return 1.;\n  }\n  return 0.;\n}\n\n// Multiply: res = ds_mul(a, b) => res = a * b\nvec2 mul (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float c11, c21, c2, e, t1, t2;\n  float a1, a2, b1, b2, cona, conb, split = 8193.;\n\n  cona = times_frc(dsa.x, split);\n  conb = times_frc(dsb.x, split);\n  a1 = minus_frc(cona, minus_frc(cona, dsa.x));\n  b1 = minus_frc(conb, minus_frc(conb, dsb.x));\n  a2 = minus_frc(dsa.x, a1);\n  b2 = minus_frc(dsb.x, b1);\n\n  c11 = times_frc(dsa.x, dsb.x);\n  c21 = plus_frc(times_frc(a2, b2), plus_frc(times_frc(a2, b1), plus_frc(times_frc(a1, b2), minus_frc(times_frc(a1, b1), c11))));\n\n  c2 = plus_frc(times_frc(dsa.x, dsb.y), times_frc(dsa.y, dsb.x));\n\n  t1 = plus_frc(c11, c2);\n  e = minus_frc(t1, c11);\n  t2 = plus_frc(plus_frc(times_frc(dsa.y, dsb.y), plus_frc(minus_frc(c2, e), minus_frc(c11, minus_frc(t1, e)))), c21);\n\n  dsc.x = plus_frc(t1, t2);\n  dsc.y = minus_frc(t2, minus_frc(dsc.x, t1));\n\n  return dsc;\n}\n\n// create double-single number from float\nvec2 set(float a) {\n  return vec2(a, 0.0);\n}\n\nfloat rand(vec2 co) {\n  // implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 complexMul(vec2 a, vec2 b) {\n  return vec2(a.x*b.x -  a.y*b.y,a.x*b.y + a.y * b.x);\n}\n\n// double complex multiplication\nvec4 dcMul(vec4 a, vec4 b) {\n  return vec4(sub(mul(a.xy,b.xy),mul(a.zw,b.zw)),add(mul(a.xy,b.zw),mul(a.zw,b.xy)));\n}\n\nvec4 dcAdd(vec4 a, vec4 b) {\n  return vec4(add(a.xy,b.xy),add(a.zw,b.zw));\n}\n\n// Length of double complex\nvec2 dcLength(vec4 a) {\n  return add(mul(a.xy,a.xy),mul(a.zw,a.zw));\n}\n\nvec4 dcSet(vec2 a) {\n  return vec4(a.x,0.,a.y,0.);\n}\n\nvec4 dcSet(vec2 a, vec2 ad) {\n  return vec4(a.x, ad.x,a.y,ad.y);\n}\n\n// Multiply double-complex with double\nvec4 dcMul(vec4 a, vec2 b) {\n  return vec4(mul(a.xy,b),mul(a.wz,b));\n}\n\n\tvec4 dcSub(vec4 a, vec4 b) {\n\t\treturn vec4(sub(a.xy,b.xy),sub(a.zw,b.zw));\n\t}\n\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nfloat zoom = 1.;\n#define offset dcSet(vec2(0.45272105023, 0.396494224267))\n\nvec2 jp = vec2(0);\n\nvec3 mapping[16] = vec3[16](\nvec3(66, 30, 15), vec3(25, 7, 26), vec3(9, 1, 47), vec3(4, 4, 73),\nvec3(0, 7, 100), vec3(12, 44, 138), vec3(24, 82, 177), vec3(57, 125, 209),\nvec3(134, 181, 229), vec3(211, 236, 248), vec3(241, 233, 191), vec3(248, 201, 95),\nvec3(255, 170, 0), vec3(204, 128, 0), vec3(153, 87, 0), vec3(106, 52, 3));\n\nvec2 powc(vec2 z, float p) {\n    float r = length(z);\n    float a = atan(z.y/z.x);\n\n    vec2 v = pow(r,p)*vec2(cos(p*a),sin(p*a));\n\n    return v;\n}\nvec2 divc(vec2 z, float p) {\n    return powc(p/z,-1.);\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 color(float t) {\n    //dont worry about any of this, because it works.\n\n    vec4 gradient[] = vec4[6](\n    vec4(0, 7, 100, 0.0),\n    vec4(32, 107, 203, 0.16),\n    vec4(237, 255, 255, 0.42),\n    vec4(255, 170, 0, 0.6425),\n    vec4(0, 2, 0, 0.8575),\n\n    vec4(0, 7, 100, 1.0));\n    \n    vec4 col = vec4(255);\n    if (gradientEnabled) {\n        for (int i=0;i<gradient.length();i++) {\n            if (gradient[i].w >= t) {\n                int ni = i-1;\n                if (ni < 0) ni = gradient.length()-1;\n                col = mix(gradient[ni],gradient[i],(t-gradient[ni].w)/(abs(gradient[ni].w-gradient[i].w)));\n                break;\n            }\n        }\n    }\n    return vec3(col);\n}\n\n//fractal formula:\nvec3 formula(vec2 fragCoord) {\n    \n    vec4 uv = dcSet(fragCoord/iResolution.xy);\n    uv = vec4(mul(uv.xy, dcSet(vec2(16.,9.)).xy), mul(uv.zw, dcSet(vec2(16.,9.)).zw));\n    uv = dcSub(uv, dcSet(vec2(8.,4.5)));\n    uv = dcMul(uv, dcSet(set(1./16.)));\n    uv = dcMul(uv, dcSet(set((zoom*2.)*(16./9.))));\n    \n    vec4 c = vec4(\n        uv\n    );\n\n    c = dcAdd(c,offset);\n    \n    vec4 z = vec4(0.);\n    \n    for (int i=0;i<iterations;i++) {\n        //if (length(z)>2.) { // smooth\n        if (max(abs(z.x),max(abs(z.y), max(abs(z.z),abs(z.w)))) > 2.0) { //scallops\n            float iterationOffset = -17.;\n            float colorSmoothness = 160.;\n            float t = mod(float(i)+iterationOffset,colorSmoothness)/(colorSmoothness);\n            \n            return color(t);\n        } else {\n            z = dcAdd((dcMul(z,z)),c);\n        }\n    }\n    \n    return vec3(0);\n}\n\n//calculate each pixel\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //zoom = pow(10.,-T);\n    zoom = pow(10.,-T/3.);\n    \n    //offset = dcSet(vec2(-0.0452407411, 0.9868162204352258));\n    \n    //jp += offset;\n    \n    vec3 col = vec3(255,0,0);\n    \n    /*vec2 boxDim = vec2(zoom/2., zoom/2.*(9./16.));\n    vec2 boxCenter = vec2(zoom*16./9., zoom)-boxDim+offset;\n    \n    if (abs(uv.x-boxCenter.x)<boxDim.x && abs(uv.y-boxCenter.y)<boxDim.y && iMouse.z > .2) {\n        vec2 boxuv = vec2((uv.x-boxCenter.x+boxDim.x)/(boxDim.x*2.),(uv.y-boxCenter.y+boxDim.y)/(boxDim.y*2.));\n        boxuv = vec2(16.,9.)*boxuv;\n        boxuv -= vec2(8.,4.5);\n        boxuv /= 16.;\n        boxuv *= (zoom/500.)*(16./9.);\n        \n        vec2 boxoffset = jp;\n        \n        boxuv += boxoffset;\n    \n        col = formula(boxuv);\n    } else {\n        col = formula(uv);\n    }*/\n    \n    col = formula(fragCoord);\n\n    // Output to screen\n    \n    /*if (length(fragCoord/iResolution.xy*vec2(2., 2.*9./16.)-vec2(1., 9./16.)) <= .01) {\n        col = vec3(255);\n    }*/\n    \n    fragColor = vec4(col/255.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddXGzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 105, 105, 155], [157, 157, 191, 191, 239], [241, 241, 276, 276, 324], [326, 566, 597, 597, 887], [889, 937, 968, 968, 1277], [1279, 1368, 1399, 1399, 1584], [1586, 1633, 1664, 1664, 2480], [2482, 2524, 2543, 2543, 2568], [2570, 2570, 2591, 2665, 2735], [2737, 2737, 2770, 2770, 2827], [2829, 2862, 2890, 2890, 2978], [2980, 2980, 3008, 3008, 3056], [3058, 3086, 3109, 3109, 3156], [3158, 3158, 3178, 3178, 3210], [3212, 3212, 3241, 3241, 3278], [3280, 3319, 3347, 3347, 3389], [3392, 3392, 3420, 3420, 3469], [4062, 4062, 4090, 4090, 4209], [4210, 4210, 4238, 4238, 4266], [4268, 4268, 4295, 4295, 4424], [4426, 4426, 4447, 4501, 5119], [5121, 5140, 5170, 5170, 6016], [6018, 6041, 6098, 6124, 7124]], "test": "untested"}
{"id": "csf3Rl", "name": "Cellular Blur", "author": "MysteryPancake", "description": "Simple blur using a repeating buffer", "tags": ["blur", "cellular", "cell", "buffer"], "likes": 2, "viewed": 243, "published": 3, "date": "1666610043", "time_retrieved": "2024-07-30T16:24:53.439200", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define cell(offset) texelFetch(iChannel0, ivec2(fragCoord) + offset, 0)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    if (iFrame > 1) {\n        // Sum of neighbours, 3 x 3 kernel\n        vec4 sum = cell(ivec2(-1,  1)) + cell(ivec2(0,  1)) + cell(ivec2(1,  1))\n                 + cell(ivec2(-1,  0))                      + cell(ivec2(1,  0))\n                 + cell(ivec2(-1, -1)) + cell(ivec2(0, -1)) + cell(ivec2(1, -1));\n                 \n        // Average of neighbours\n        fragColor = sum / 8.0;\n    } else {\n        fragColor = texture(iChannel1, fragCoord / iResolution.xy);\n    }\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csf3Rl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 121]], "test": "untested"}
{"id": "DdX3Rl", "name": "Twisted Passage", "author": "dr2", "description": "An endless twisted passage...", "tags": ["path", "trucher"], "likes": 23, "viewed": 248, "published": 3, "date": "1666609611", "time_retrieved": "2024-07-30T16:24:54.243050", "image_code": "// \"Twisted Passage\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// Based on the tiling in \"Generalized Truchet Path\"\n\n#define AA  1   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat HexEdgeDist (vec2 p);\nvec2 HexMidEdge (vec2 p);\nfloat Minv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv2 (vec2 p);\nfloat Fbm2 (vec2 p);\n\nvec3 ltDir;\nvec2 cId, cMid;\nfloat tCur, dstFar, hgSize, cDir, cType, tWid, rc, ac;\nint idObj;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat Ddot (vec2 p)\n{\n  return dot (p, p);\n}\n\nfloat TruchDist (vec2 p)\n{\n  vec2 pc, pc1, pc2;\n  float d, d1, d2;\n  if (cType == 1. || cType == 3.) {\n    if (cDir != 0.) p = 0.5 * vec2 (p.x - cDir * sqrt3 * p.y, cDir * sqrt3 * p.x + p.y);\n    pc1 = vec2 (sqrt3/2. * sign (p.x), 0.);\n    pc2 = vec2 (sqrt3 * sign (p.x), 0.);\n    d1 = sqrt (Ddot (p - pc1));\n    d2 = abs (sqrt (Ddot (p - pc2)) - 1.5);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = (d == d1) ? 0.: 1.5;\n  } else if (cType == 2. || cType == 4.) {\n    pc1 = - vec2 (0., cDir);\n    pc2 = vec2 (sqrt3/2. * sign (p.x), 0.5 * cDir);\n    d1 = Ddot (p - pc1);\n    d2 = Ddot (p - pc2);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = 0.5;\n    d = abs (sqrt (d) - rc);\n  }\n  pc = p - pc;\n  ac = - atan (pc.y, - pc.x) / (2. * pi) + 0.5;\n  if (cType == 2. && cId.x - cId.y < 0.) ac = - ac;\n  return d;\n}\n\nbool OnTrk (vec2 w)\n{\n  vec2 wp, wm;\n  float cxy;\n  bool cyo, offTrk;\n  cxy = cId.x - cId.y;\n  cyo = (mod (cId.y, 2.) == 1.);\n  wm = Rot2Cs (w, sin (- pi / 3. + vec2 (0.5 * pi, 0.))) - vec2 (0., 0.3);\n  wp = Rot2Cs (w, sin (pi / 3. + vec2 (0.5 * pi, 0.)));\n  offTrk = (cxy == -2. && wm.y > 0. || ! cyo && (abs (cxy) == 2. || cxy == -3. && w.y > -0.3 ||\n     cxy == -1. && wm.y > 0. || cxy == 1. && wm.y < 0.) || cyo && (cxy == -3. ||\n     cxy == 0. && wp.x > 0. || cxy == 1. && wm.x < 0. || cxy == 2. && wm.y < 0.));\n  return ! offTrk;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec2 w;\n  float dMin, d, dt, dh;\n  dMin = dstFar;\n  w = (p.xz - cMid) / hgSize;\n  dh = HexEdgeDist (w);\n  dt = TruchDist (w);\n  d = max (PrRoundBox2Df (vec2 (dt - tWid - 0.01, p.y - 0.35), vec2 (0.005, 0.35), 0.015),\n     - PrBox2Df (vec2 (dh, p.y - 0.25), vec2 (0.11, 0.3)));\n  DMIN (1);\n  d = max (PrRoundBox2Df (vec2 (dh - tWid - 0.01, p.y - 0.2), vec2 (0.005, 0.2), 0.015),\n     0.12 - dt);\n  DMIN (2);\n  if (cType <= 2. && rc != 0. && OnTrk (w)) {\n    d = PrCylDf (vec3 (dt, p.y - 0.4, fract (6. * (rc * ac - 0.05 * tCur)) - 0.5).xzy,\n       0.55 * tWid, 0.4);\n    DMIN (3);\n  }\n  return dMin;\n}\n\nvoid SetCConf ()\n{\n  float h, cxy;\n  cMid = HexToPix (cId * hgSize);\n  h = Hashfv2 (cId);\n  if (Hashfv2 (17.11 * cId) > 0.4) {\n    cDir = floor (3. * h) - 1.;\n    cType = 3.;\n  } else {\n    cDir = 2. * floor (2. * h) - 1.;\n    cType = 4.;\n  }\n  cxy = cId.x - cId.y;\n  if (cxy == 0.) cType = 1.;\n  else if (abs (cxy) == 1.) cType = mod (cId.x, 2.) + 1.;\n  else if (abs (cxy) == 2. || cxy == -3.) cType = 2.;\n  if (cType <= 2.) cDir = 2. * mod (cId.x, 2.) - 1.;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, cIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  cIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    cId = PixToHex (p.xz / hgSize);\n    if (cId != cIdP) {\n      cIdP = cId;\n      SetCConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  cIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    cId = PixToHex (p.xz / hgSize);\n    if (cId != cIdP) {\n      cIdP = cId;\n      SetCConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 ) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 w;\n  float dstObj, sh, h;\n  bool isBg;\n  isBg = true;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col4 = (ro.y > 0.7) ? vec4 (0.9, 0.3, 0.3, 0.2) : vec4 (0.9, 0.9, 1., 0.1) *\n       (0.9 + 0.1 * cos (16. * pi * ro.y));\n    else if (idObj == 2)  col4 = (ro.y > 0.4) ? vec4 (0.5, 0.5, 0.9, 0.2) : vec4 (0.9, 0.9, 1., 0.1) *\n       (0.9 + 0.1 * cos (16. * pi * ro.y));\n    else if (idObj == 3) col4 = vec4 (1., 1., 0., 0.2) * (0.9 + 0.1 * step (0.5, cos (16. * pi * ro.y / 0.4)));\n    isBg = false;\n  } else if (rd.y < 0.) {\n    dstObj = - ro.y / rd.y;\n    ro += dstObj * rd;\n    cId = PixToHex (ro.xz / hgSize);\n    SetCConf ();\n    vn = vec3 (0., 1., 0.);\n    h = hgSize / 16.;\n    w = (ro.xz - HexToPix (PixToHex (ro.xz / h) * h)) / h;\n    col4 = vec4 (0.8, 0.5, 0., 0.1) * (0.5 + 0.5 * smoothstep (0., 0.02, HexEdgeDist (w) - 0.03));\n    w = (ro.xz - HexToPix (cId * hgSize)) / hgSize;\n    col4 = mix (col4, vec4 (0.2, 1., 0.5, 0.1) * (0.3 + 0.3 * Fbm2 (4. * ro.xz)),\n       step (0., min (HexEdgeDist (w), TruchDist (w) - tWid)));\n    isBg = false;\n  } else {\n    col = vec3 (0.1, 0.2, 0.1);\n  }\n  if (! isBg) {\n    sh = ObjSShadow (ro + 0.01 * vn, ltDir);\n    col = col4.rgb * (0.2 + 0.1 * max (dot (vn, normalize (vec3 (- ltDir.xz, 0.)).xzy), 0.) +\n       0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (reflect (ltDir, vn), rd), 0.), 32.);\n    col = mix (col, vec3 (0.1, 0.2, 0.1), smoothstep (0.5, 1., dstObj / dstFar));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 18000.) + 30. * floor (dateCur.w / 3600.);\n  hgSize = 2.;\n  tWid = 0.12;\n  ro = vec3 (0., 8., 1. * tCur);\n  ro.xz = Rot2D (ro.xz, - pi / 3.);\n  ro.xz += 0.01;\n  az = pi / 3.;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.2 * pi * mPtr.y;\n  } else {\n    az -= 0.15 * pi * sin (0.01 * pi * tCur);\n    el -= 0.07 * pi * sin (0.013 * pi * tCur);\n  }\n  el = clamp (el, -0.2 * pi, -0.12 * pi);\n  vuMat = StdVuMat (el, az);\n  zmFac = 3.5;\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nvec2 HexMidEdge (vec2 p)\n{\n  vec2 p1, p2;\n  p = abs (p);\n  p1 = p + vec2 (- sqrt3/2., 0.);\n  p2 = p + vec2 (- sqrt3/4., -0.75);\n  return (length (p1) < length (p2)) ? p1 : p2;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdX3Rl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[872, 872, 893, 893, 916], [918, 918, 944, 944, 1758], [1760, 1760, 1781, 1781, 2297], [2299, 2299, 2321, 2321, 2924], [2926, 2926, 2944, 2944, 3387], [3389, 3389, 3422, 3422, 4674], [4676, 4676, 4697, 4697, 4952], [4954, 4954, 4991, 4991, 5380], [5382, 5382, 5417, 5417, 7030], [7032, 7032, 7088, 7088, 8377], [8379, 8379, 8412, 8412, 8501], [8503, 8503, 8550, 8550, 8597], [8599, 8599, 8641, 8641, 8692], [8694, 8694, 8718, 8718, 8948], [8950, 8950, 8974, 8974, 9034], [9036, 9036, 9064, 9064, 9144], [9146, 9146, 9172, 9172, 9323], [9325, 9325, 9347, 9347, 9385], [9387, 9387, 9423, 9423, 9629], [9631, 9631, 9661, 9661, 9774], [9776, 9776, 9807, 9807, 9871], [9905, 9905, 9929, 9929, 9989], [9991, 9991, 10015, 10015, 10127], [10129, 10129, 10154, 10154, 10340], [10342, 10342, 10363, 10363, 10518]], "test": "untested"}
{"id": "mssGRf", "name": "Gosper curve - filled", "author": "FabriceNeyret2", "description": "WIP.\nattempt to generate a  filled variant of [url]https://shadertoy.com/view/cdsGRj  [/url]\nusing signed distance.", "tags": ["2d", "fractal", "lsystem", "hilbert", "spacefilling", "templates", "peano", "eschergosper"], "likes": 15, "viewed": 252, "published": 3, "date": "1666598429", "time_retrieved": "2024-07-30T16:24:55.018975", "image_code": "// filled variant of https://shadertoy.com/view/cdsGRj\n                      // pi/3\n#define rot(a) mat2(cos(1.047*(a) + vec4(0,1.57,-1.57,0)))\n// --- draw line\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b);\n    if ( h != clamp(h,0.,1.) ) return 1e5;  // option. try commenting\n    h = clamp(h, 0., 1.);\n    return length(p - b * h) * sign(p.x*b.y-p.y*b.x);                        \n}\n// --- sort of L-system\n                  // .318  = (  pi/3 - atan(sqrt(3),2) ) / pi/3\nfloat p[] = float[](.318,-1.,-2.,1.,2.,0.,1.); // turn \nint   s[] =   int[](   1,-1 ,-1 ,1 ,1 ,1 ,-1); // draw seg: direct or reverse\n   // .333,D,  -pi/3.,iD,  -2pi/3,iD,  pi/3,D,  2pi/3,D,  0,D,  pi/3,iD\n\n#define Rec(draw,draw2)                                      \\\nfloat draw( vec2 U,vec2 P,vec2 _P ) {                        \\\n    vec2 D = _P - P;                                         \\\n    if ( length(U-(P+_P)/2.) > .88 * length(D) ) return 9.; /* optim inspired by mla https://www.shadertoy.com/view/dssGRf */ \\\n    float d=.03,v;         /* hack: short init d */          \\\n    for (int i=min(0,iFrame); i<p.length(); i++) {           \\\n        _P = P;                                              \\\n        D *= rot( p[i] );                                    \\\n        P += .378*D; /* 1./length(vec2(2,sqrt(3))) */        \\\n        v = s[i]>0 ? draw2(U,_P,P) : draw2(U,P,_P) ;         \\\n        d = abs(v) < abs(d) ? v*float(s[i]) : d;             \\\n    }                                                        \\\n    return d;                                                \\\n}\n// --- emulates recursion\n#define   draw5  line\nRec(draw4,draw5)  \nRec(draw3,draw4)  \nRec(draw2,draw3)\nRec(draw ,draw2)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y +vec2(.3,-.3), P = vec2(.6);\n // if ( draw(U, -P, P) == .03 ) { O = vec4(.5); return; }\n    O = vec4( smoothstep(1.5/R.y,-1.5/R.y, draw(U, -P, P) ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mssGRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 161, 196, 196, 430], [1733, 1733, 1771, 1771, 1987]], "test": "untested"}
{"id": "dssGRf", "name": "Gosper Curve Optimized", "author": "mla", "description": "The Gosper Curve using a simple stack (just storing the offset of the \"current instruction\"). Optimized to skip recursion when far from the point being plotted. 60 fps on Nvidia 1650 at HD resolution.\n\nNeeds to be full screen for the proper effect.", "tags": ["optimized", "lsystem", "stack", "winding", "gosper"], "likes": 15, "viewed": 212, "published": 3, "date": "1666598231", "time_retrieved": "2024-07-30T16:24:55.772960", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Gosper Curve, drawn with stack. mla, 2022.\n//\n// Inspired by https://www.shadertoy.com/view/cdsGRj by FabriceNeyret2\n//\n// Uses an explicit stack to keep track of the recursion.\n// This one keeps track of intermediate segments and avoids recursing far from\n// the point being plotted.\n//\n// Mouse down shows segments actually drawn around mouse position\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\n#define C(turns,offset) (((turns) << 16) | ((offset) & 0xffff))\n// Each instruction is an integer number of turns, followed by\n// either an instruction offset for the recursive call or -1\n// to terminate the current level.\nconst int A = 0, B = 8, END = -1, L = -1, R = 1;\nconst int program[16] =\n  int[] (C(0,A),C(L,B),C(L+L,B),C(R,A), C(R+R,A),C(0,A),C(R,B),C(L,END),\n         C(R,A),C(L,B),C(0,B),C(L+L,B), C(L,A),C(R+R,A),C(R,B),C(0,END));\n\nconst float angle = PI/3.0;\nconst int maxdepth = 5;\n\nvec2 p = vec2(0);     // The drawing point\nvec2 point = vec2(100); // The moving point\nfloat plen = 0.0;     // Cumulative path length\n\nint wind = 0; // Compute winding number here\nvoid polywind(vec2 p, vec2 q, vec2 r) {\n  // NR winding number computation\n  q -= p; r -= p; // Relative to p\n  float t = determinant(mat2(q,r));\n  if (q.y <= 0.0) {\n    if (r.y > 0.0 && t > 0.0) wind++;\n  } else {\n    if (r.y <= 0.0 && t < 0.0) wind--;\n  }\n}\n\nfloat drawsegment(vec2 pos, float seglen, float theta, float t) {\n  vec2 seg = seglen*vec2(cos(theta),sin(theta));\n  if (t >= plen && t < plen+seglen) point = p + (t-plen)/seglen*seg;\n  vec2 q = p + seg;\n  float d = segment(pos,p,q);\n  polywind(pos,p,q);\n  plen += seglen;\n  p = q;\n  return d;\n}\n\nfloat magic = 0.333473; // Segment rotation at each recursion level\n\nvec2 map(vec2 pos) {\n  pos = (2.0*pos - iResolution.xy)/iResolution.y;\n  pos -= vec2(0.5,0.8);\n  pos *= 1.6;\n  return pos;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 pos = map(fragCoord);\n  vec2 pos2 = (iMouse.z <= 0.0) ? pos : map(iMouse.xy);\n  int stack[maxdepth];\n  int depth = 0;\n  stack[depth++] = 0;\n  float t = mod(iTime,pow(7.0,0.5+0.5*float(maxdepth))); // Moving point\n  float d = 1e8;\n  float seglen = 1.0;\n  float theta = 0.0;    // Cumulative angle\n  while (depth > 0) {\n    int instr = program[stack[depth-1]++];\n    // Decode instruction\n    int turns = instr>>16;\n    int code = instr<<16>>16;\n    theta += float(turns)*angle; // Apply turn\n    if (code == END) {\n      depth--;    // Terminate level & unwind\n      seglen *= sqrt(7.0);\n    } else if (depth == maxdepth) {\n      d = min(d,drawsegment(pos,seglen,theta,t)); // Segment\n    } else {\n      // The segment is a diagonal of a hexagon off to the left or the right,\n      // so centre is at 30 to the segment, at distance radius of hexagon.\n      float offset = float(maxdepth-depth)*magic; // Segment angle adjustment\n      float sign = code == A ? -1.0 : 1.0;\n      float centreangle = sign*PI/6.0 - offset;\n      float radius = seglen/sqrt(3.0); // 0.5*seglen = radius*cos(30)\n      vec2 centre = p + radius*vec2(cos(theta+centreangle),sin(theta+centreangle));\n      float bound = 1.1*radius; // 1.0 gives some artefacts, 1.05 seems OK. \n      // Press 'x' to compare old and new bounds\n      if (key(CHAR_X)) { centre = p; bound = 1.2*seglen; }\n      if (distance(pos2,centre) > bound) {\n        // Short circuit this segment\n        vec2 seg = seglen*vec2(cos(theta-offset),sin(theta-offset));\n        polywind(pos,p,p+seg);\n        // Show skipped segments on mouse down.\n        if (iMouse.z > 0.0) d = min(d,segment(pos,p,p+seg));\n        p += seg;\n        plen += seglen*pow(7.0,0.5*float(maxdepth-depth));\n      } else {\n        stack[depth++] = code;  // Recurse\n        seglen /= sqrt(7.0);\n      }\n    }\n  }\n  // Add a couple of lines going out of the frame so the winding\n  // number calculation is sensible.\n  vec2 border = vec2(0,100);\n  d = min(d,segment(pos,border,vec2(0)));\n  polywind(pos,border,vec2(0));\n  d = min(d,segment(pos,p,p-border));\n  polywind(pos,p,p-border);\n  float px = fwidth(pos.x);\n  vec3 col = vec3(smoothstep(0.0,px,d));\n  if ((wind&1) == 0) col.gb *= 0.25;\n  col = mix(vec3(0), col,smoothstep(0.0,px,distance(pos,point)-0.01));\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.1415926;\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\n// const int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\n// const int CHAR_R = 82;\n// const int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\n// const int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssGRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1174, 1205, 1244, 1279, 1464], [1466, 1466, 1531, 1531, 1761], [1832, 1832, 1852, 1852, 1956], [1958, 1958, 2013, 2013, 4331]], "test": "untested"}
{"id": "mslGRX", "name": "Aura-warper", "author": "xenn", "description": "I'm a what?", "tags": ["fluid", "cfd", "fluiddynamics"], "likes": 7, "viewed": 704, "published": 3, "date": "1666593290", "time_retrieved": "2024-07-30T16:24:56.927872", "image_code": "// just jamming the way I do. All credit to the actual coders, all credit is due\n\n#define HEIGHT 10.50+(10.*sin(iTime/3.))\n#define BRIGHTNESS 3.\n\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n/**\n\tUse Buffer A in iChannel0 for 3D letters. Read description!\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n//void mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n    // Normalized pixel coordinates (from 0 to 1)\n    \n   \n    vec2 uv = fragCoord/iResolution.xy;\n    //Texel Size\n    vec2 texel = vec2(1.) / iResolution.xy;\n    \n     vec4 frogColor = texture(iChannel3, uv);\n\n    vec3 normal = bump2Normal(uv, iChannel2, HEIGHT, texel);\n   \tvec3 normalRGB = normal2rgb(normal);\n    \n    vec3 lightDir = normalize(vec3(abs(sin(iTime/20.)), -abs(cos(iTime/40.)), abs(sin(iTime/40.))));\n    \n    vec3 toLightDir = vec3(0.0) - lightDir;\n    \n    float mouseX = iMouse.x / iResolution.x;\n    \n\tif (mouseX < 01.99) {\n        frogColor = vec4(BRIGHTNESS*dot(toLightDir, normalize(normal)));\n        frogColor*=texture(iChannel3, uv);\n    } else {\n        frogColor = vec4(normalRGB, 1.0);\n    }  \n    \n    if(abs(toLightDir.x *.5 + .5 - uv.x) < 0.005 && abs(toLightDir.z *.5 + .5 - uv.y) < 0.005) {\n    \tfrogColor = vec4(1.,abs(toLightDir.y*2.),vec2(0.));  \n    }\n    \n    \n    \n    vec4 final = frogColor;\n    \n    vec4 ace = vec4(ACESFilm(vec3(0)), 1.0);;\n\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n//    vec2 uv = fragCoord.xy/iResolution.xy;\n\n\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n      vec3 color = vec3(texture(iChannel0, uv - 0.50 * d).r,\n                      texture(iChannel0, uv - .0 * d).g,\n                      texture(iChannel0, uv + 01.0 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.50  * d).r,\n                      texture(iChannel1, uv - .0 * d).g,\n                      texture(iChannel1, uv - 01.0 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv -0.50  * d).r,\n                      texture(iChannel2, uv - .0 * d).g,\n                      texture(iChannel2, uv - 01.0  * d).b);\n                      \n                       vec3 col3 = vec3(texture(iChannel3, uv - 0.50 * d).r,\n                      texture(iChannel3, uv - 0.0 * d).g,\n                      texture(iChannel3, uv - 1.0 * d).b);\n                      \n                      vec3 blend = (max(color,col));\n                      vec3 bland = (max(col,color));\n               //       blend *= bland;\n               //       col2 = min(col,col3)*col2;\n               //       col = mix(col,col3,color);\n              //       col3 = min(col,color)*col3;\n            //     color = mix(col,color,col3)*color;\n\n  //    color = ((max(color,col),col3)*(color));\n //     color = (mix(color,col2,col2)*(color));\n    float noise = .9 + randomFloat()*.15;\n  \t//fragColor = vec4(ACESFilm(frogColor));\n //   fragColor = mix(vec4(ACESFilm((col+(mix(bland,blend,0.5)))*noise), 1.0),frogColor,(col,1.0));\n//    fragColor = vec4(ace(final))*noise );\n //   fragColor = frogColor;\n //fragColor =(vec4(ACESFilm(mix(bland,blend,0.5)*noise),1.0));\n fragColor = mix((vec4(ACESFilm(mix(bland,blend,0.5)*noise),1.0)),frogColor,(color,.50));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col2 = texture(iChannel2,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col3 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  col = clamp(col, 0., 1.);\n  col2 = clamp(col2, 0., 1.);\n  col3 = clamp(col3, 0., 1.);\n  vec4 blend = min((mix(col,col2,0.075)),col );\n // fragColor=min(blend,col3);\n  blend = clamp(blend, 0., 1.);\n  \n  fragColor=mix(col,col2, col3);\n//fragColor = col2;\n//fragColor=blend;\n//  fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .0001;\nconst float iFeedbackFadeRate         = .999;\nconst float iFeedbackColorShiftZoom   = .05;\nconst float iFeedbackColorShiftImpact = 0.001;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = 15.95;\nconst float iBlobEdgeSmoothing        = .1;\nconst float iBlob1Radius              = 1.5;\nconst float iBlob1PowFactor           = 69.;\nconst float iBlob1ColorPulseSpeed     = .25242;\nconst float iBlob2Radius              = 1.5;\nconst float iBlob2PowFactor           =69.;\nconst float iBlob2ColorPulseSpeed     = -.01834;\nconst float iBlob2ColorPulseShift     = 0.0;\nconst float iColorShiftOfRadius       =  0.5;\nconst float iFeedbackMouseShiftFactor = .01;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * (iBlob1ColorPulseSpeed / 1.5), 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * (iBlob2ColorPulseSpeed / -1.5) + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n    \n    vec3 prevColor2 = repeatedTexture(iChannel3, uv - stShift).rgb;\n    prevColor2 *= iFeedbackFadeRate;\n    \n    vec3 prevColor3 = repeatedTexture(iChannel1, uv - stShift).rgb;\n    prevColor3 *= iFeedbackFadeRate;\n    \n    prevColor = mix(prevColor,prevColor2,prevColor3);\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n         (1. * abs(cos(iTime / 3.2)))\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          (iBlob1PowFactor)) * iBlob1Color;\n        radius =\n         (1. * abs(sin(iTime / 3.3)))\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n         (iBlob2PowFactor)) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = fragCoord.xy;\n    \n    vec2 uv = (p.xy) / iResolution.xy;\n    \n    //line thickness\n    float th = 0.001;\n    \n    //gradient detection for r,g and b separatly\n    //not sure why I did this actually\n    \n    float gxr = texture(iChannel0, uv.xy+vec2(th, 0.)).r\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).r ;\n    \n    float gyr = texture(iChannel0, uv.xy+vec2(0., th)).r\n    - texture(iChannel0, uv.xy-vec2(0., th)).r;\n    \n    float gxg = texture(iChannel0, uv.xy+vec2(th, 0.)).g\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).g ;\n    \n    float gyg = texture(iChannel0, uv.xy+vec2(0., th)).g\n    - texture(iChannel0, uv.xy-vec2(0., th)).g;\n    \n    float gxb = texture(iChannel0, uv.xy+vec2(th, 0.)).b\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).b;\n    \n    float gyb = texture(iChannel0, uv.xy+vec2(0., th)).b\n    - texture(iChannel0, uv.xy-vec2(0., th)).b;\n    \n    //hack to concea noise from: https://www.shadertoy.com/view/Mdf3zr\n    float gr = gxr*gxr + gyr*gyr;\n    float gg = gxg*gxg + gyg*gyg;\n    float gb = gxb*gxb + gyb*gyb;\n    \n    //more noise control\n    float g = pow((gr+gg+gb)/1.,1.9);\n    \n    \n    vec3 col = texture(iChannel0, p / iResolution.xy).xyz;\n    col = mix(col,  0.5 + 0.5*cos(iTime*4.+uv.y*6.+vec3(0,2,4)),g*100.);\n    \n    fragColor = vec4(col,1.);\n}", "buffer_c_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define iFeedbackColorShiftZoom 0.2\n//#define iFeedbackColorShiftImpact 0.001\n//#define iBlob1ColorPulseSpeed 0.03456\n//#define iBlob2ColorPulseSpeed 0.02345\n#define Margins .0\n\n#define PI 3.14159265359\n\nvec2 getFontSymbolSampleUV(int x, int y, vec2 uv) {\n\treturn uv * vec2(1./16.) + vec2(float(x) / 16., float(y) / 16.);\n}\n\nfloat getHeight(vec2 uv, sampler2D bumpMap, float maxHeight) {\n    return texture(bumpMap, uv).r*maxHeight;\n}\n\nvec3 getSlope(vec2 uv, float height, vec2 axis, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    float h1 = getHeight(uv+texelSize*axis, bumpMap, maxHeight);\n    float h2 = getHeight(uv-texelSize*axis, bumpMap, maxHeight);\n    return vec3(1,((height-h2) + (h1-height)) / 2.,0);\n}\n\nvec3 bump2Normal(vec2 uv, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    \n    float height = getHeight(uv, bumpMap, maxHeight);\n        \n    vec3 slopeX = getSlope(uv, height, vec2(1., 0.), bumpMap, maxHeight, texelSize).zyx;\n    vec3 slopeY = getSlope(uv, height, vec2(0., 1.), bumpMap, maxHeight, texelSize).xyz;\n    return cross(slopeX, slopeY).zyx;\n}\n\nvec3 normal2rgb(vec3 normal) {\n    return normalize(normal.rbg * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5));\n}\n\nfloat radius = 20.;\nfloat intensity = 5.;\nfloat fade = .99;\n\nfloat pi = 3.14159265359;\n\nfloat blurRadius = 3.;\n\nfloat sinWave(float v, float m){return (sin(v*m*pi*2.)+1.)/2.;}\n\n//from https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 xy2hue(vec2 v){\n    float h = (atan(v.y, v.x)/(pi) + 1.)/2.;\n    float b = length(v);\n    return vec4(hsv2rgb(vec3(h, 1., b)), 1.);\n}\n\n\n\n\n\n\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n//    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\n//vec3 hsv2rgb(vec3 cc)\n//{\n//    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n//    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n//    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n//}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n//#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n//#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_d_code": "// All components are in the range [01], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n\n// All components are in the range [01], including hue.\nvec3 hsv2rgb2(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 fragment = texture(iChannel1, uv);\n    vec3 hsv = rgb2hsv(fragment.rgb);\n    float rad = (iTime/2.0) + (hsv.z*6.28);\n    vec2 off = vec2(sin(rad), cos(rad)) / (iResolution.xy / vec2(max(hsv.y,hsv.z)*3.14));\n    hsv.x += abs(sin(iTime/11.0 + ((iMouse.x/iResolution.x)*6.28))*max(iMouse.y/iResolution.y,hsv.z*hsv.z));\n    hsv.y = max(hsv.y, min(hsv.z, 0.75));\n    fragColor = mix(texture(iChannel0, vec2(uv.x + off.x, uv.y + off.y)), vec4(hsv2rgb2(hsv), 0.1), hsv.y*0.075);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mslGRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 165, 185, 185, 264], [266, 266, 289, 289, 429], [431, 499, 556, 665, 3654]], "test": "untested"}
{"id": "NtByDD", "name": "FlipBook Mix Frame", "author": "Yon", "description": "flipbook lerp two fram", "tags": ["flipbook"], "likes": 2, "viewed": 261, "published": 3, "date": "1666582333", "time_retrieved": "2024-07-30T16:24:57.719755", "image_code": "\n\n// float saturate (float x)\n// {\n//     return min(1.0, max(0.0,x));\n// }\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec4 pcg4d(uvec4 v) {\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n\n    v ^= v >> 16u;\n\n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n\n    return v;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n\n    float row=1.;\n    float col=6.;\n    float speed = 2.;\n\n\n    vec2 CR = vec2(col,row);\n    float RmC = row*col;\n    vec2 RmCR = vec2(RmC,row);\n    vec2 uv0 = (uv+vec2(0.,row-1.))/CR;\n    float time = iTime*speed;\n\n    vec4 uvPreNext =  floor((fract(time + vec4(0.,0.,1./RmC,1./RmC)))*vec4(RmCR,RmCR));\n    \n    float weight = fract(time*(RmC));\n    vec4 uvAll = vec4(uv0,uv0)+uvPreNext/vec4(CR,CR)*vec4(1.,-1.,1.,-1.);\n\n  \n\n    vec4 frame0 = texture(iChannel0, uvAll.xy-vec2(1./96.,0.)*mod(floor(time*col),col)-vec2(1./128.,0.));\n    vec4 frame1 = texture(iChannel0, uvAll.zw-vec2(1./96.,0.)*mod(floor(time*col)+1.0,col)-vec2(1./128.,0.));\n\n    vec4 color = mix(frame0,frame1,weight);\n\n\n    // Output to screen\n    fragColor = vec4(color);\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtByDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 122, 144, 144, 395], [399, 399, 454, 504, 1292]], "test": "untested"}
{"id": "ddlGRX", "name": "Fractal mosaic 29 (music)", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 4, "viewed": 238, "published": 3, "date": "1666577379", "time_retrieved": "2024-07-30T16:24:58.465760", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 = //change this constant to get other interesting patterns\n        vec2(1.,0.5),\n   \n    a1 =\n        a+a2\n        //a+a2+floor(a2.x)\n    ;\n\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n        //abs(fract((a1+1.)*(a2.x+a2.y))-.5)\n        //abs(fract((a1+fmod(a.y,2.))*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 2.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    bool t3 = true;\n    for(int k = 0; k < 6; k++){\n        t3 = uv.x < uv.y;\n        uv =\n            abs(.5+uv+t2)\n            //abs(.5*float(t3)+uv+t2)\n        ;\n        //uv = abs(fract(vec2(uv)*1.5)-.5)/1.5;\n        //uv += (distance(floor(uv),round(uv+.5)));\n        \n        //uv.x += fpow(uv.x,2.)/2.;\n\n        t2 =\n            -triangle_wave(uv-.5*sign(uv.x-uv.y))\n            //-triangle_wave(uv-.5)/(.5+fmod(t2.x,2.))\n        ;\n        uv =\n            t2-triangle_wave(uv.yx)\n            //abs(.5+t2+triangle_wave(uv.yx))\n        ;\n        \n        //uv *= -sign(uv.x-uv.y);\n\n\n        float c1 =\n            uv.x-uv.y\n            //abs(uv.x-uv.y)\n            //distance(uv,t2)\n            //uv.x*uv.y\n            //length(uv)\n        ;\n        col = col.yzx;\n        vec3 col1 = col;\n        if(t3 || uv.y < uv.x) col1 = abs(col.yzx-vec3(col.yz,c1));\n        if(!t3 || uv.y > uv.x) col1 = abs(col1-max(col,vec3(col.yz,c1)));\n        col = col1;\n        //if(uv.x<uv.y) col=col.yzx;\n        //if(t2.x>t2.y) {uv=-uv.yx;t2=-t2.yx;}\n    }\n    fragColor = vec4(min(col*2.,vec3(1.)),1.0);\n}\n", "image_inputs": [], "sound_code": "#define fract1(a) pow(fract(a),1.+log(2.)-log(1.+fract(a)))\n\n\nvec2 mainSound(int samp, float time){\n  float tempo = .5;\n  time /= tempo;\n  float s1 =\n      4.;\n  //time += (floor(time*s1))/s1;\n  float s2 = 8.,\n  m4 =\n      fmod(floor(time*s1)*floor(time/s1),2.)\n  ,\n  t=\n      //time/(1.+m4)\n      time/(2.-m4)\n  ;\n  //t += floor(t*4.)*4.;\n  float m1 =\n      fmod(floor(t/s1)*floor(t*s1),s2)\n      //fmod(floor(t/(1.+m4))*floor(t*s1),s2)\n      //fmod(floor(t/s1)*(floor(t*s1)+floor(t)),s2)\n  ,\n  m3 =\n      fmod(floor(t*(s1))/(m1+.5),s2);\n  /*\n  for(int i = 0; i < 3; i++){\n      t += (floor(mod(((t*2.)),2.)))/2.;\n  }\n  */\n  t /=\n      (1.+fmod(t/s1,2.))/s1\n      //(1.+fmod(t/(1.+m1),2.))\n  ;\n  //t += fmod(t/8.,8.);\n\n  float m2 =\n      1. + fmod(t,s1)\n  ;\n  \n  float a= //instruments\n      //sqrt(1.-sqrt(fract(t/s1)))*.2\n      //(1.-sqrt(fract(t/s1)))*.2\n      //pow(2.-log(fract(t)),2.)\n      -log(1./64./2.+fract1(t)/8.)\n\n      //64.*pow(1.-sqrt(fract(t))/1.25,2.)\n      //pow(1.-sqrt(fract(t/s1))/1.5,2.)*pow(1.-sqrt(fract(t/s1/s1))/1.5,2.)\n      //fract(-t/s1)*fract(t/s1)\n      //pow(1.-sqrt(fract(t/s1)/pow(2.,fmod(t/s1,s1))),2.)\n  ,\n\n  nb = time*tempo*pow(2.,(m3+m2)/5.+6.);\n\n    return\n      //abs(.5-vec2(fract(nb*.998),fract(nb/2.)))*a\n      //log(abs(.5-vec2(fract(nb*.998),fract(nb/2.)))*a)\n      \n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n      \n      //gamelan\n      //a/16./2.*abs(log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb*.998),fract1(nb)))/2.)))\n\n      //oud\n      //a/16./2.*abs(log(.5+a*abs(abs(.5-vec2(fract1(nb*2.*.998),fract1(nb*2.)))/2.))\n      //+.5*log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb*.998),fract1(nb)))/2.)))/2.\n      \n      //steel drum\n      a/16./4.*abs(log(1./2.+a*abs(1./8.-abs(.5-vec2(fract1(nb*4.*.998),fract1(nb*4.)))))\n      + log(1./8.+a*abs(1./4.-abs(.5-vec2(fract1(nb*2.*.998),fract1(nb*2.)))/2.)))      \n      \n      //vec2(fract(time*nb*.998/4.*m2*s1)*a,fract(time*nb/4.*m2)*a)\n  ;\n\n}", "sound_inputs": [], "common_code": "float fmod2(float a, float b){\n    return mod(floor(a),b)*b;\n}\n\nfloat fmod1(float a, float b){\n    //divide by prime numbers to get interesting rhythms\n    float a1 = a;\n    //a += mod(floor(a/2.),4.)*2.;\n    //a += mod(floor(a/2.),2.)/2.;\n    \n    /*\n    for(float i = 1.; i < mod(floor(a),8.); i++){\n        a += mod(floor(a/2.),b)*i;\n        a *= 1.+mod(floor(a)*2.,2.);\n        i /= 1.+mod(floor(a)*2.,2.);\n    }\n    */\n    \n    //a /= 1. + mod(floor(a1/3.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    \n    return\n        mod(floor(a),b)\n        //mod(floor(mod(floor(a/2.),b*2.)),b)\n        //mod(mod(floor(a),floor(a/b+b)),b)\n        //mod(floor(a*8./b),b)\n        //mod(floor(a/2.)*floor(a*4./b),b)\n        //mod(floor(a)*mod(floor(-a*sign(.5-mod(floor(a/b/4.),3.))),b),b)\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n    ;\n}\n\nfloat fmod(float a, float b){\n    return\n        fmod1(a,b)\n        //mod(fmod1(a/2.,b*2.)*fmod1(a*2.,b),8.)\n    ;\n}\n\n//#define fmod(a,b) mod(floor(mod(a,1.+(a)*2./3.)),b)\n#define fmod0(x,y) mod((floor(mod(time,y))+floor(x)),y)\n#define fmod1(x,y) floor(mod(floor((x)/y)*y,y*y)/y)\n#define fmod2(x,y) mod(floor(x)*floor((x)/y),y)\n#define fmod3(x,y) abs(floor(mod(floor((x)*2.),y)-y/2.))*2.\n#define fmod4(x,y) mod(floor(x-floor((x)/y)),y)\n\n#define smod(x,y) floor(mod(floor(x)*floor(x),y))\n#define sqmod(x,y) floor(mod(floor(x)/4.,y*y)/y)\n#define fpow(x,y) pow(y,mod(floor(x),y))", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddlGRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 339], [341, 341, 398, 398, 1773]], "test": "untested"}
{"id": "cslGzf", "name": "", "author": "moshi", "description": "   -   `iMouse.w > 0`w0.0\n    -   `iMouse.z > 0` mousedown , \n    -   `Mouse.z < 0 && iMouse.w < 0`", "tags": ["mouse"], "likes": 0, "viewed": 298, "published": 3, "date": "1666573481", "time_retrieved": "2024-07-30T16:25:01.494662", "image_code": "float circle(vec2 xy, vec2 center,float R){\n    vec2 r = center -xy; \n    return step( dot(r,r),R * R );\n}\n\nfloat square(vec2 xy, vec2 center){\n    vec2 d = center -xy; \n    vec2 dd= step( abs(d),vec2(.2) );\n    return dd.x* dd.y ;\n}\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{  \nfloat ratio  = iResolution.x/iResolution.y;\nvec2 uv = U/iResolution.xy ;\nuv.x*=ratio;\n\nvec2 mouse = iMouse.xy/iResolution.xy ;\nmouse.x*= ratio ;\nfloat mz =  step(0. ,iMouse.z);// edge, val z>0 mz 1\nfloat mw =  step(0. ,iMouse.w);\n   vec3 color = vec3(.8,.5,.6) ;\n   vec3 color2 = vec3(.1,.1,.6) ;\n   vec3 color3 = vec3(uv,.6) ;\n   color= mix(color, color2 + mw*vec3(.5),circle(uv, vec2(.4,.5), .3)) ;\n   color= mix(color, color2 + mz*vec3(.7),square(uv, vec2(.8,.5))) ;\n   color= mix(color, color3 ,circle(uv, mouse,.1)) ;\n   O = vec4(color, 1.);\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslGzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 106], [108, 108, 143, 143, 233], [236, 236, 274, 274, 838]], "test": "untested"}
{"id": "DssGRf", "name": "Slime Battles", "author": "fenix", "description": "While fiddling around with the automaton in Euler Tangles, I somehow got this result that looks to me like blobs of goo fighting for territory, so I leaned into that idea with some rendering changes.\n*space to reset*\n*mouse to add noise*", "tags": ["2d", "slime", "automata", "cellular", "battle", "automaton"], "likes": 8, "viewed": 240, "published": 3, "date": "1666562927", "time_retrieved": "2024-07-30T16:25:02.940795", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  While fiddling with the automaton in Euler Tangles\n//\n//      https://www.shadertoy.com/view/fl3fzr\n//\n//  I somehow got this result that looks  to me like blobs of goo fighting for\n//  territory, so I leaned into that idea with some rendering changes. \n//\n//  Buffer A runs the cellular automaton/particle sim\n//  Buffer B just renders the particle densities so we can filter them next\n//  Buffer C performs a density blur to smooth the gradients for rendering\n// \n// ---------------------------------------------------------------------------------------\n\nvec3 floatToColor(float f)\n{\n    return normalize(sin((f) * vec3(1, 2, 8) + vec3(2,6,8)) * 0.5 + 0.5);\n}\n\nvec2 grad(vec2 fragCoord, ivec2 delta)\n{\n    return vec2(texelFetch(iChannel1, ivec2(fragCoord) + delta.xy, 0).x - \n        texelFetch(iChannel1, ivec2(fragCoord) - delta.xy, 0).x,\n        texelFetch(iChannel1, ivec2(fragCoord) + delta.yx, 0).x - \n        texelFetch(iChannel1, ivec2(fragCoord) - delta.yx, 0).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    cellData d = unpackCell(texelFetch(iChannel0, ivec2(fragCoord), 0));\n    \n    vec2 g = grad(fragCoord, ivec2(1, 0));\n    g = mix(g, g + normalize(g), smoothstep(0.04, 0.06, length(g)));\n    vec3 n = normalize(vec3(g, 1));\n    const vec3 lightDir = normalize(vec3(1,-1,1));\n    float dp = dot(n, lightDir);\n    float spec = pow(dp, 15.) * .3;\n    float diff = dp * 0.6 + 0.4;\n    \n    fragColor = vec4(floatToColor(d.color) * d.trailDensity, 1) * diff + spec;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float MAX_AGE = 40000.0; // Particles die after this many frames\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    \n    if (ifc == ivec2(0))\n    {\n        // Reset if resolution doesn't match\n        if (iFrame == 0 || abs(state.xy) != iResolution.xy || keyDown(KEY_SPACE))\n        {\n            fragColor = vec4(-iResolution.xy, vec2(-1));\n        }\n        else\n        {\n            if (iMouse.z > 0.)\n            {\n                state.zw = iMouse.xy / iResolution.xy;\n            }\n            else\n            {\n                state.zw = vec2(-1.);\n            }\n            \n            fragColor = vec4(abs(state.xy), state.zw);\n        }\n        return;\n    }\n    \n    float h = hash(\n        ifc.x + \n        ifc.y*int(iResolution.x) + \n        iFrame*int(iResolution.x*iResolution.y)\n    );\n    \n    if (false)\n    {\n        // Clear buffer\n        cellData init;\n        init.pos = vec2(0.5, 0.5);\n        init.vel = vec2(0);\n        init.density = 0.0;\n        init.trailDensity = 0.0;\n        init.color = 0.0;\n        init.age = 0.0;\n        \n        fragColor = packCell(init);\n\n        return;\n    }\n    \n    if (state.z >= 0.0)\n    {\n        float d = linePointDist2(iMouse.xy/iResolution.xy, state.zw, fragCoord/ iResolution.xy);\n\n        h += .000001/d;\n    }\n\n    if (h > 0.99999 || iFrame == 0 || state.x < 0.)\n    {\n        // Spawn new particle\n        vec3 h3 = hash3(uvec3(fragCoord, iFrame));\n\n        cellData newParticle;\n        newParticle.pos = vec2(0.5, 0.5); // Start in the middle of the cell\n        newParticle.vel = vec2(h3.x - 0.5, h3.y - 0.5);\n        newParticle.density = 1.0;\n        newParticle.trailDensity = 1.0;\n        newParticle.color = h3.z;\n        newParticle.age = 0.;\n        \n        fragColor = packCell(newParticle);\n    }\n    else\n    {\n        float newDensity = 0.;\n        vec2 newVel = vec2(0), newPos = vec2(0);\n        cellData d = unpackCell(texelFetch(iChannel0, ivec2(fragCoord), 0));\n\n        float h1 = hash(\n            ifc.x*int(iResolution.x) + \n            ifc.y*int(iResolution.y) + \n            iFrame*int(iResolution.x*iResolution.y)\n        );\n        float h2 = hash(int(h1*994888228.));\n\n        // Search the nearest NxN cells to find any that has density that wants to move into our cell\n        // Bigger RANGE makes larger velocities possible, but starts to be prohibitively expensive\n        const int RANGE = 4;\n        ivec2 dir = ivec2(sign(vec2(h1 - 0.5, h2 - 0.5)));\n        for (int x = -RANGE; x <= RANGE; ++x)\n        {\n            for (int y = -RANGE; y <= RANGE; ++y)\n            {\n                if (ifc.x + x < 0 || ifc.x + x >= int(iResolution.x)) continue;\n                if (ifc.y + y < 0 || ifc.y + y >= int(iResolution.y)) continue;\n\n                cellData nb = unpackCell(texelFetch(iChannel0, ivec2(fragCoord) + dir * ivec2(x, y), 0));\n\n                vec2 nbPos = nb.pos + vec2(x, y);\n                vec2 newNbPos = nbPos + nb.vel * float(RANGE);\n\n                if (nb.density > 0. && nb.age < 1.0) // Note: also rejecting particles here thar are too old\n                {\n                    // Draw smooth line from old position to new, even if it jumped past our position\n                    float aa = smoothstep(2.2, 0.1, sqrt(linePointDist2(fragCoord + newNbPos, fragCoord + nbPos, fragCoord)));\n                    \n                    // Use full color if we're drawing on black\n                    d.color = d.trailDensity < .2 || aa > .2 ? nb.color : d.color;\n                    d.trailDensity += aa;\n                    \n                    if (all(greaterThan(newNbPos, vec2(0))) && all(lessThan(newNbPos, vec2(1))))\n                    {\n                        newPos = newNbPos;\n                        newVel = nb.vel;\n                        newDensity = 1.;\n                    \n                        d.age = nb.age;\n                        d.color = nb.color; // Copy over the whole color so it doesnt get lost even with thin lines\n                    }\n                }\n            }\n        }\n\n        // Record data in fragColor\n        d.pos = newPos;\n        d.vel = newVel;\n        d.density = newDensity * 1000.;\n        d.trailDensity *= 0.999; // Fade out painted areas slowly\n        d.age += 1. / MAX_AGE;\n\n        fragColor = packCell(d);\n    }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float pack2(vec2 v)\n{\n    return uintBitsToFloat(packSnorm2x16(v));\n}\n\nvec2 unpack2(float f)\n{\n    return unpackSnorm2x16(floatBitsToUint(f));\n}\n\nstruct cellData\n{\n    vec2 pos; // position within the cell, 0 ... 1\n    vec2 vel; // -1 ... 1, multiplied by RANGE\n    float density; // either 0 or 1, depending on if a particle is present\n    float trailDensity; // allows particles to leave trails behind, 0 ... 1\n    float color; // color of trail, 0 ... 1\n    float age; // 0 ... 1\n};\n\ncellData unpackCell(vec4 c)\n{\n    cellData d;\n    \n    d.pos = unpack2(c.x);\n    d.vel = unpack2(c.y);\n    vec2 den = unpack2(c.z);\n    d.density = den.x;\n    d.trailDensity = den.y;\n    vec2 colorAge = unpack2(c.w);\n    d.color = colorAge.x;\n    d.age = colorAge.y;\n    \n    return d;\n}\n\nvec4 packCell(cellData d)\n{\n    float x = pack2(d.pos);\n    float y = pack2(d.vel);\n    float z = pack2(vec2(d.density, d.trailDensity));\n    float w = pack2(vec2(d.color, d.age));\n    \n    return vec4(x, y, z, w);\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nmat2 rot2(float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat length2(vec2 a)\n{\n    return dot(a, a);\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    vec2 closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    return dot(closestDelta, closestDelta);\n}\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    fragColor.x = unpackCell(texelFetch(iChannel0, ivec2(fragCoord), 0)).density * 20.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// gaussian blur from FabriceNeyret2's smart gaussian blur: https://www.shadertoy.com/view/WtKfD3\n\nint           N = 13; // 7                              // target sampling rate\nfloat         w = .1,                                   // filter width\n              z;                                        // LOD MIPmap level to use for integration \n#define init  w = 5./R.y; \\\n              z = ceil(max(0.,log2(w*R.y/float(N))));   // N/w = res/2^z\n#define R     iResolution.xy\n\n\nfloat convol2D(vec2 U) {                                                     \n    float  O = 0.0;  \n    float r = float(N-1)/2., g, t=0.;                                       \n    for( int k=0; k<N*N; k++ ) {                                            \n        vec2 P = vec2(k%N,k/N) / r - 1.;                                    \n        t += g = exp(-2.*dot(P,P) );                                        \n        O += g * textureLod(iChannel0, (U+w*P) *R.y/R, z ).x;                 \n    }                                                                       \n    return O/t;                                                             \n}      \n\nfloat square(float x) { return x*x; }\nvoid mainImage( out vec4 O, vec2 u )\n{\n    init \n    vec2 U = u / R.y;  \n    O = texelFetch(iChannel1, ivec2(u), 0);\n    O.x = mix(O.x, max(0., convol2D(U)), 0.1);\n    if (iFrame == 0) O == vec4(0);\n}\n\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DssGRf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[771, 771, 799, 799, 875], [877, 877, 917, 917, 1192], [1194, 1194, 1251, 1251, 1716]], "test": "untested"}
{"id": "ddlGzN", "name": "Raymarcher 3d", "author": "the0neboy", "description": "shader for raymarching, edit it as you want", "tags": ["3d", "raymarching"], "likes": 4, "viewed": 199, "published": 3, "date": "1666553403", "time_retrieved": "2024-07-30T16:25:03.913195", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 20.\n#define SURF_DIST .001\n\n#define FOG_START 10.\n#define FOG_END 20.\n\n#define BG_COLOR vec3(135, 206, 235)\n#define OBJ_COLOR vec3(0,255,25)\n\n#define GLOW_DIST .1\n#define GLOW_COL vec3(255,255,255)\n\n#define S smoothstep\n#define T iTime\n\nvec3 camPos = vec3(0,0,0);\n\nstruct MarchData  {\n    float mindistance;\n    bool didCollide;\n    bool doGlow;\n    float distanceTravelled;\n    int steps;\n    vec3 color;\n    float minDist;\n};\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat clmp(float a,float b,float h) {\n    if(h<=a)return a;\n    if(h>=b)return b;\n    return h;\n}\nfloat fogAmount(float d) {\n    return clmp(0.,FOG_END-FOG_START,d-FOG_START)/(FOG_END-FOG_START);\n}\n\nvec4 sdSphere(vec3 p)\n{\n  vec3 col = vec3(0,255,0);\n\n  //float p2 = T-2.0;\n  //float d = length(vec3(p.x-(3.0*sin((2.0*3.14159265*p2)/3.0)),p.y,p.z))-float(1.);\n  float d = length(p)-float(1.);\n  return vec4(col,d);\n}\n\nvec4 sdRect(vec3 p, vec3 b)\n{\n  vec3 col = vec3(255,0,0);\n\n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return vec4(vec3(col),d);\n}\nvec4 sdFractal(vec3 p)\n{\n  vec3 col = vec3(0,255,0);\n  vec3 np = vec3(mod(p.x, 3.)-1.5,mod(p.y, 3.)-1.5,mod(p.z, 3.)-1.5);\n  \n  float d = length(np)-float(1.);\n  return vec4(col,d);\n}\nvec4 sdPlane(vec3 p) {\n    vec3 col = vec3(0,220,100);\n    \n    float dist = p.y+1.3;\n    \n    return vec4(col,dist);\n}\n\nvec4 sdTorus(vec3 p) {\n    vec2 t = vec2(1.,.3);\n    \n    float dist = length(vec2(length(vec2(p.x, p.z))-t.x,p.y))-t.y;\n    \n    vec3 col = vec3(255, 255, 0);\n    \n    return vec4(col,dist);\n}\n\nvec4 sierpinskiTetrahedron(vec3 p) {\n    vec3 col = vec3(127,127,127);\n    \n    vec3 z = p;\n    float Scale = 2.;\n    \n    vec3 a1 = vec3(1,1,1);\n\tvec3 a2 = vec3(-1,-1,1);\n\tvec3 a3 = vec3(1,-1,-1);\n\tvec3 a4 = vec3(-1,1,-1);\n\tvec3 c;\n\tint n = 0;\n\tfloat dist, d;\n\twhile (n < 20) {\n\t\t c = a1; dist = length(z-a1);\n\t        d = length(z-a2); if (d < dist) { c = a2; dist=d; }\n\t\t d = length(z-a3); if (d < dist) { c = a3; dist=d; }\n\t\t d = length(z-a4); if (d < dist) { c = a4; dist=d; }\n\t\tz = Scale*z-c*(Scale-1.0);\n\t\tn++;\n\t}\n\n\tfloat DE = length(z) * pow(Scale, float(-n));\n    return vec4(col,DE);\n}\n\nvec4 smin(vec4 a, vec4 b, float k) {\n    float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0.0, 1.0);\n    vec3 color = vec3(mix(a.x, b.x, h),mix(a.y, b.y, h),mix(a.z, b.z, h)); \n    float dist = mix(a.w, b.w, h) - k*h*(1.0-h);\n    return vec4(color,dist);\n}\nvec4 smax(vec4 a, vec4 b, float k) {\n   return -smin(-a,-b,k);\n}\n\nvec4 GetDist(vec3 p) {\n    float s = .3;\n\n    vec4 d1 = smin(sdSphere(vec3(p.x+1.8,p.y,p.z)),sdRect(vec3(p.x-1.3,p.y,p.z-.7),vec3(1,1,2)),s);\n    return smin(sdTorus(p),d1,s);\n}\n\nMarchData RayMarch(vec3 ro, vec3 rd) {\n    MarchData _dat=MarchData(0., false, false, 0., 0, vec3(127), GLOW_DIST);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*_dat.distanceTravelled;\n        float dS = GetDist(p).w;\n        _dat.distanceTravelled += dS;\n        _dat.steps += 1;\n        _dat.color = vec3(GetDist(p));\n        \n        if(dS<_dat.minDist) _dat.minDist=dS;\n        \n        if(_dat.distanceTravelled<MAX_DIST && abs(dS)<SURF_DIST) {\n            _dat.didCollide = true;\n            return _dat;\n        }\n    }\n    \n    if (_dat.minDist < GLOW_DIST && !_dat.didCollide) _dat.doGlow = true;\n    return _dat;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 4, -3)+camPos;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.)+camPos;\n    vec3 col = BG_COLOR/255.;\n   \n    MarchData _dat = RayMarch(ro, rd);\n\n    if(_dat.didCollide) {\n        vec3 p = ro + rd * _dat.distanceTravelled;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif)*(_dat.color/255.);\n    }\n    if (_dat.doGlow) {\n        col = GLOW_COL;\n    }\n    \n    //col = mix(col, BG_COLOR/255., fogAmount(_dat.distanceTravelled));\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddlGzN.jpg", "access": "api", "license": "mit", "functions": [[1837, 1837, 1856, 1856, 1918], [1919, 1919, 1956, 1956, 2016], [2017, 2017, 2043, 2043, 2116], [2118, 2118, 2141, 2141, 2335], [2337, 2337, 2366, 2366, 2513], [2514, 2514, 2538, 2538, 2697], [2698, 2698, 2720, 2720, 2817], [2819, 2819, 2841, 2841, 3012], [3014, 3014, 3050, 3050, 3609], [3611, 3611, 3647, 3647, 3857], [3858, 3858, 3894, 3894, 3922], [3924, 3924, 3946, 3946, 4101], [4103, 4103, 4141, 4141, 4741], [4743, 4743, 4767, 4767, 4965], [4967, 4967, 5017, 5017, 5208], [5210, 5210, 5267, 5267, 6070]], "test": "untested"}
{"id": "mdf3zf", "name": "Fractal mosaic 28 (music)", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "mosaic", "rug"], "likes": 2, "viewed": 213, "published": 3, "date": "1666550165", "time_retrieved": "2024-07-30T16:25:04.773894", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 = vec2(1.,0.5);\n    return abs(fract((a+a2)*(a2.x+a2.y))-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    vec2 uv = (fragCoord)/iResolution.y/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/2.;\n    vec2 t2 = vec2(0.);\n    bool t3 = false;\n    for(int k = 0; k < 6; k++){\n        t3 = uv.x > uv.y;\n        uv.x -= floor(mod(uv.x*1.5,1.5));\n        if(t3){ uv = uv.yx;t2 = -t2.yx;}\n        uv = abs(.5-uv+t2);\n        t2 =\n            triangle_wave(uv+.5)\n            //triangle_wave(uv+.5*sign(uv.x-uv.y))*sign(uv.x-uv.y)\n        ;\n        uv = t2+triangle_wave(uv.yx);\n        if(t3 || uv.y < uv.x) col = vec3(col.yz,uv.x-uv.y);\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "sound_code": "//#define fmod(x,y) mod(floor(x),y)\n#define fmod(a, b) mod(mod(floor((a)),floor(1.+(a)/5.)),b)\nvec2 mainSound(int samp, float time){\n  \n  float s1 =\n      8.,\n  s2 = 8.,\n  m4 = fmod(floor(time*s1)/s1+floor(time*s1),2.),\n  t= //varying tempo\n      time*(1.+m4)/2.\n  ,\n  m1 =\n      fmod(floor(t*s2+floor(t*s2)*floor(t*s2))*floor(t/s2),s2)\n  ,\n  m3 =\n      fmod(t/(m1+.5),s2);\n  t *= s1*s1;\n  t /=  //varying tempo\n      (1.+fmod((t/s1+floor(t/s1))/2.,2.))\n  ;\n\n    float m2 =\n      1. + fmod(t/s1,s1)\n  ;\n  \n  float a = 64.*sqrt((1.-sqrt(fract(t/s1))))*.2,\n\n  nb = pow(2.,(m3+m2)/5.+5.5);\n\n  return\n      abs(.5-vec2(fract(time*nb*.998*2.),fract(time*nb)))*a\n      //vec2(fract(time*nb*.998/m2*s1)*a,fract(time*nb/m2*s1)*a)\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdf3zf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 103], [105, 105, 162, 162, 845]], "test": "untested"}
{"id": "mdXGRf", "name": "Generalized Truchet Path", "author": "dr2", "description": "Endless directed path on a generalized hexagonal Truchet tiling", "tags": ["hexagon", "truchet", "tile", "path"], "likes": 22, "viewed": 261, "published": 3, "date": "1666539821", "time_retrieved": "2024-07-30T16:25:05.757265", "image_code": "// \"Generalized Truchet Path\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n Mixture of two different tile patterns; tile outlines are included\n for reference. Tiles are randomly selected and rotated, except along the\n chosen path.\n*/\n\n#define AA  1   // optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat HexEdgeDist (vec2 p);\nfloat Minv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv2 (vec2 p);\n\nvec3 ltDir;\nvec2 cId, cMid;\nfloat dstFar, tCur, gSize, tLen, vel, cDir, cType;\nint idObj;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat Ddot (vec2 p)\n{\n  return dot (p, p);\n}\n\nvec3 TruchDist (vec2 p)\n{\n  vec2 pc, pc1, pc2, dp;\n  float d, d1, d2, rc, ac;\n  bool ct;\n  ct = (cType == 2. || cType == 4.);\n  if (ct) {\n    pc1 = - vec2 (0., cDir);\n    pc2 = vec2 (sqrt3/2. * sign (p.x), 0.5 * cDir);\n    d1 = Ddot (p - pc1);\n    d2 = Ddot (p - pc2);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = 0.5;\n    d = abs (sqrt (d) - rc);\n  } else {\n    if (cDir != 0.) p = 0.5 * vec2 (p.x - cDir * sqrt3 * p.y, cDir * sqrt3 * p.x + p.y);\n    pc1 = vec2 (sqrt3/2. * sign (p.x), 0.);\n    pc2 = vec2 (sqrt3 * sign (p.x), 0.);\n    d1 = sqrt (Ddot (p - pc1));\n    d2 = abs (sqrt (Ddot (p - pc2)) - 1.5);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = (d == d1) ? 0.: 1.5;\n  }\n  dp = p - pc;\n  ac = 0.5 - atan (dp.y, - dp.x) / (2. * pi);\n  if (ct && cId.x - cId.y < 0.) ac *= -1.;\n  return vec3 (d, rc, ac);\n}\n\nbool OnTrk (vec2 w)\n{\n  vec2 wp, wm;\n  float cxy;\n  bool cyo, offTrk;\n  cxy = cId.x - cId.y;\n  cyo = (mod (cId.y, 2.) == 1.);\n  wm = Rot2Cs (w, sin (- pi / 3. + vec2 (0.5 * pi, 0.))) - vec2 (0., 0.3);\n  wp = Rot2Cs (w, sin (pi / 3. + vec2 (0.5 * pi, 0.)));\n  offTrk = (cxy == -2. && wm.y > 0. || ! cyo && (abs (cxy) == 2. || cxy == -3. && w.y > -0.3 ||\n     cxy == -1. && wm.y > 0. || cxy == 1. && wm.y < 0.) ||\n     cyo && (cxy == -3. || cxy == 0. && wp.x > 0. || cxy == 1. && wm.x < 0. ||\n     cxy == 2. && wm.y < 0.));\n  return ! offTrk;\n}\n\nvoid SetPath ()\n{\n  vec4 cPath[13];\n  float tEnd[14], ts, tl;\n  ts = 1.;\n  tl = 1.5;\n  cPath[ 0] = vec4 (0., 0., -1./6., tl);\n  cPath[ 1] = vec4 (1., 0., 1./3., - ts);\n  cPath[ 2] = vec4 (0., 1., 5./6., tl);\n  cPath[ 3] = vec4 (-1., 1., -1./3., ts);\n  cPath[ 4] = vec4 (-1., 2., 1., ts);\n  cPath[ 5] = vec4 (0., 1., - 1./6., tl);\n  cPath[ 6] = vec4 (1., 1., 1./6., tl);\n  cPath[ 7] = vec4 (1., 2., 1., ts);\n  cPath[ 8] = vec4 (2., 1., -1./6., tl);\n  cPath[ 9] = vec4 (3., 1., 1./3., - ts);\n  cPath[10] = vec4 (2., 2., 5./6., tl);\n  cPath[11] = vec4 (1., 2., -1./3., ts);\n  cPath[12] = vec4 (1., 3., 1., ts);\n  tEnd[0] = 0.;\n  for (int k = 0; k <= 12; k ++) tEnd[k + 1] = tEnd[k] + abs (cPath[k].w);\n  tLen = tEnd[13];\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d, w;\n  dMin = dstFar;\n  w = gSize * TruchDist ((p.xz - cMid) / gSize).x;\n  d = length (max (abs (vec2 (w, p.y - 0.2)) - vec2 (1.5, 0.2), 0.));\n  d = min (d, length (max (abs (vec2 (abs (w - 1.5), p.y - 0.4)) - vec2 (0.1, 0.4), 0.))) - 0.05;\n  DMIN (1);\n  d = p.y;\n  DMIN (2);\n  return dMin;\n}\n\nvoid SetConf ()\n{\n  float h, cxy;\n  cMid = HexToPix (cId * gSize);\n  h = Hashfv2 (cId);\n  if (Hashfv2 (17.11 * cId) > 0.4) {\n    cDir = floor (3. * h) - 1.;\n    cType = 3.;\n  } else {\n    cDir = 2. * floor (2. * h) - 1.;\n    cType = 4.;\n  }\n  cxy = cId.x - cId.y;\n  if (cxy == 0.) cType = 1.;\n  else if (abs (cxy) == 1.) cType = mod (cId.x, 2.) + 1.;\n  else if (abs (cxy) == 2. || cxy == -3.) cType = 2.;\n  if (cType <= 2.) cDir = 2. * mod (cId.x, 2.) - 1.;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, cIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = gSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / gSize;\n  pM = HexToPix (PixToHex (ro.xz / gSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  cIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    p = ro + dHit * rd;\n    cId = PixToHex (p.xz / gSize);\n    if (cId != cIdP) {\n      cIdP = cId;\n      SetConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn, cm3;\n  vec2 w;\n  float dstObj, dt, a, t, rc, ac;\n  bgCol = vec3 (0.1, 0.2, 0.7);\n  col = bgCol;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    w = (ro.xz - cMid) / gSize;\n    if (idObj == 1) {\n      if (ro.y > 0.7) col4 = vec4 (0.6, 0.3, 0.3, 0.2);\n      else {\n        col4 = vec4 (0.2, 0.9, 0.2, 0.2);\n        cm3 = TruchDist (w);\n        dt = gSize * cm3.x;\n        if (dt < 0.6) {\n          col4 = vec4 (1., 1., 0.7, 0.2);\n          rc = cm3.y;\n          ac = cm3.z;\n          a = 6. * rc * ac;\n          if (rc != 0.) {\n            if (cType <= 2. && OnTrk (w)) a -= vel * tCur;\n            col4 = mix (col4, vec4 (0.8, 0.8, 1., 0.2), smoothstep (-0.02, 0.02,\n               abs (fract (12. * a + 0.5) - 0.5) - 0.25));\n            if (cType <= 2. && OnTrk (w)) {\n              t = fract (3. * a + 0.25) - 0.5;\n              if (dt < 0.1 && abs (fract (3. * a + 0.5) - 0.5) > 0.25 ||\n                 dt < abs (t) - 0.2 && abs (t - 0.3) > 0.2) col4 = vec4 (1., 0., 0., 0.2);\n            }\n          }\n        }\n      }\n    } else if (idObj == 2) {\n      col4 = vec4 (0., 0.5, 0., 0.2) * (0.8 + 0.2 * smoothstep (0., 0.1,\n         gSize * HexEdgeDist (w) - 0.05));\n    }\n    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) +\n       0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (reflect (ltDir, vn), rd), 0.), 32.);\n    col = mix (col, bgCol, smoothstep (0.8, 1., dstObj / dstFar));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv, vd;\n  float el, az, zmFac, sr, cGap, t, tp;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = 8.;\n  SetPath ();\n  vel = 0.8;\n  ro = vec3 (0., 30., (-1.5 * sqrt3 + (6. / tLen) * vel * tCur) * gSize);\n  ro.xz = Rot2D (ro.xz, - pi / 3.);\n  ro.xz += 0.01;\n  ro.x -= 1.5 * gSize;\n  az = pi / 3.;\n  el = -0.17 * pi;\n  zmFac = 5.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.4 * pi, -0.07 * pi);\n  vuMat = StdVuMat (el, az);\n  dstFar = 40. * gSize;\n  ltDir = vuMat * normalize (vec3 (1., 1.5, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdXGRf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[809, 809, 830, 830, 853], [855, 855, 880, 880, 1702], [1704, 1704, 1725, 1725, 2246], [2248, 2248, 2265, 2265, 2967], [2969, 2969, 2991, 2991, 3299], [3301, 3301, 3318, 3318, 3760], [3762, 3762, 3795, 3795, 5030], [5032, 5032, 5053, 5053, 5308], [5310, 5310, 5345, 5345, 6886], [6888, 6888, 6944, 6944, 8142], [8144, 8144, 8168, 8168, 8398], [8400, 8400, 8424, 8424, 8484], [8486, 8486, 8514, 8514, 8594], [8596, 8596, 8618, 8618, 8656], [8658, 8658, 8694, 8694, 8900], [8902, 8902, 8932, 8932, 9045], [9047, 9047, 9078, 9078, 9142], [9176, 9176, 9200, 9200, 9260]], "test": "untested"}
{"id": "dsf3zX", "name": "simetrius", "author": "lomateron", "description": "go full screen\nclick hold adjust release", "tags": ["automata"], "likes": 7, "viewed": 198, "published": 3, "date": "1666538870", "time_retrieved": "2024-07-30T16:25:06.500278", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int m = tz+1;\n    int i = iFrame%m;\n    vec4 a = texelFetch(iChannel0,ivec2(fragCoord),0);\n    uint n = (1U<<m)-1U;\n    uint b = floatBitsToUint(a.x)&n;\n    uint c = ((b>>i)|(b<<(m-i))) &n;\n    fragColor = cos(float(c)/float(n)*4.4+vec4(2,3,4,5)+.8);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rz 120.  //size of each world in pixels\n#define sz  3.   //size of kernel across space\n#define tz  3    //size of kernel across time          must be <= 32", "buffer_a_code": "uint read(vec2 u, vec2 m)\n{\n    vec2 o = mod(u+m,rz);\n         u = floor(u/rz)*rz+o;\n    return floatBitsToUint(texelFetch(iChannel0,ivec2(u),0).x);\n}\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float ck = -floor((sz-1.)*.5);    //center the kernel\n    float ev = float(mod(sz,2.)==0.); //move and resize kernel when sz = even\n    uint o = 0U;                      //sum of all bits\n                          float n = (float(iFrame&1)-1.)*ev;\n    for(int   t=0 ; t<tz; ++t){ float m = n*(1.-float(t&1)); float s2 = sz-float(t&1)*ev; \n    for(float i=0.; i<s2; ++i){\n    for(float j=0.; j<s2; ++j){ uint r = read(u,vec2(i,j)+ck+m);\n                                o += (r>>t)&1U;\n    }}}\n    vec2 r2 = floor(iResolution.xy/rz);\n    uint u2 = uint(dot(floor(        u/rz),vec2(1,r2.x)));\n    uint m2 = uint(dot(floor(iMouse.xy/rz),vec2(1,r2.x)));\n    \n    uint a = +u2*2U                      //divides screen in 16*8 worlds\n             +16U*8U*(16U*7U+14U);\n    //if(o>=32U){a = 1430607221U;}  \n    o = (read(u,vec2(0,0))<<1U) | ((a>>(o&31U))&1U);\n    if(iFrame==0||iMouse.z>.5)\n    {\n        vec2  v = fract(u/rz)-.5;\n        float r = step(dot(v,v)-.0005,iMouse.x/iResolution.x*.1);\n        o = uint(r);\n    }\n    fragColor = vec4(uintBitsToFloat(o));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsf3zX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 314]], "test": "untested"}
{"id": "msXGRX", "name": "noice blob the movie", "author": "lomateron", "description": "read common tab for the movie narration...ok?", "tags": ["automata"], "likes": 4, "viewed": 193, "published": 3, "date": "1666526993", "time_retrieved": "2024-07-30T16:25:07.337041", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int m = tz+1;\n    int i = iFrame%m;\n    //if(i!=0){discard;}  //comment out to see more frames but more flicker too\n    vec4 a = texelFetch(iChannel0,ivec2(fragCoord),0);\n    uint n = (1U<<m)-1U;\n    uint b = floatBitsToUint(a.x)&n;\n    uint c = ((b>>i)|(b<<(m-i))) &n;\n    fragColor = vec4(float(c)/float(n));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define sz  5.   //size of kernel across space\n#define tz  5    //size of kernel across time\n\n//somewhere on the universe a noice blob is born\n//some beins start comming out of it multiplying and expanding easily through the galaxy\n//meanwhile the noice blob keeps getting bigger until the whole universe is englufed by it\n//maybe something way more interesting than the universe is happening inside the blob\n//ze end\n\n//it happens in this simulation so it probably will happened to our universe", "buffer_a_code": "uint read(vec2 u, vec2 m)\n{\n    return floatBitsToUint(texelFetch(iChannel0,ivec2(u+m),0).x);\n}\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float ck = -floor((sz-1.)*.5);    //center the kernel\n    float ev = float(mod(sz,2.)==0.); //move and resize kernel when sz = even\n    uint o = 0U;                      //sum of all bits\n                          float n = (float(iFrame&1)-1.)*ev;\n    for(int   t=0 ; t<tz; ++t){ float m = n*(1.-float(t&1)); float s2 = sz-float(t&1)*ev; \n    for(float i=0.; i<s2; ++i){\n    for(float j=0.; j<s2; ++j){ uint r = read(u,vec2(i,j)+ck+m);\n                                o += (r>>t)&1U;\n    }}}\n    uint a = +               15U                      \n             +16U*8U        *10U       \n             +16U*8U*16U*8U *(1U<<13);\n    //if(o>=32U){a = 1430607221U;}  \n    o = (read(u,vec2(0,0))<<1U) | ((a>>(o&31U))&1U);\n    if(iFrame==0||iMouse.z>.5)\n    {\n        vec2  v = (u/iResolution.xy)-.5;\n        float r = fract(cos(dot(u,vec2(1.76543,iTime+9.)))*5467.5678)*256.;\n            //r*= step(.98,fract(cos(dot(u,vec2(1.5363,iTime)))*3467.5678));\n              r*= step(dot(v,v),.0015);\n        o = uint(r);\n    }\n    fragColor = vec4(uintBitsToFloat(o));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXGRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 374]], "test": "untested"}
{"id": "DdX3zf", "name": "Simple Neon Light", "author": "pizzahollandaise", "description": "A simple shader simulating a neon light like in Apple's iPhone 13 Pro Wallpaper", "tags": ["2d", "light", "neon"], "likes": 7, "viewed": 322, "published": 3, "date": "1666522097", "time_retrieved": "2024-07-30T16:25:08.078059", "image_code": "const float PI = 3.1415926;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert to uv\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Start and ending points of the neon light\n    vec2 a = vec2(0.2, 0.4) + sin(iTime) * vec2(0.2, 0.4);\n    vec2 b = vec2(0.7, 0.6) + sin(iTime) * vec2(0.1, -0.2);\n    \n    // Calculates the angle around the current pixel that is illuminated by the neon light \n    float light = acos(dot(normalize(a - uv), normalize(b - uv))) / PI;\n\n    // Output to screen with gamma correction\n    vec3 col = pow(light, 0.7) * vec3(1, 1, 1);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdX3zf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 87, 108, 619]], "test": "untested"}
{"id": "DdfGzf", "name": "2D worlds explorer", "author": "lomateron", "description": "read Common tab", "tags": ["automata"], "likes": 3, "viewed": 224, "published": 3, "date": "1666519454", "time_retrieved": "2024-07-30T16:25:08.828054", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int m = tz+1;\n    int i = iFrame%m;\n    //if(i!=0){discard;}  //comment out to see more frames but more flicker too\n    vec4 a = texelFetch(iChannel0,ivec2(fragCoord),0);\n    uint n = (1U<<m)-1U;\n    uint b = floatBitsToUint(a.x)&n;\n    uint c = ((b>>i)|(b<<(m-i)))&n;\n    //fragColor = cos(float(c)*88.8888+vec4(3,1,2,4))*.5+.5;\n    if(tz==1){fragColor = vec4(float(c)/float(n));}\n    if(tz==2){fragColor = vec4((c>>0)&1U,(c>>1)&1U,(c>>2)&1U,0);}\n    if(tz> 2){fragColor = cos(float(c)/float(n)*4.4+vec4(2,3,4,5)+.8);}\n    //fragColor = vec4(b&1U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rz 120.  //size of each world in pixels\n#define sz  3.   //size of kernel across space\n#define tz  1    //size of kernel across time          must be <= 32\n#define nz  .02  //size of mouse click noise ball\n\n//exploration works when texture is 1920*1080\n//if you dont have 1920*1080 texture\n//then you must change rz to textureWidth/16\n\n//1920*1080 and rz=120 will show 16*9 worlds simulations\n//becos 1920/rz*1080/rz = 16*9\n//mouse click on each world will show the next 16*8 worlds\n//go to BufferA line24, change 0U to 1U to keep exploring next 16*8*16*8 worlds\n//there are 2^(sz*sz*tz+1) different worlds to explore\n//arktually 2^(sz*sz*tz  ) becous half are worlds inverted in color\n\n//next will be 1D worlds explorer", "buffer_a_code": "uint read(vec2 u, vec2 m)\n{\n    vec2 o = mod(u+m,rz);\n         u = floor(u/rz)*rz+o;\n    return floatBitsToUint(texelFetch(iChannel0,ivec2(u),0).x);\n}\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float ck = -floor((sz-1.)*.5);    //center the kernel\n    float ev = float(mod(sz,2.)==0.); //move and resize kernel when sz = even\n    uint  o  = 0U;                      //sum of all bits\n                                float n = (float(iFrame&1)-1.)*ev;\n    for(int   t=0 ; t<tz; ++t){ float m = n*(1.-float(t&1)); float s2 = sz-float(t&1)*ev; \n    for(float i=0.; i<s2; ++i){\n    for(float j=0.; j<s2; ++j){ uint r = read(u,vec2(i,j)+ck+m);\n                                o += (r>>t)&1U;\n    }}}\n    vec2 r2 = floor(iResolution.xy/rz);\n    uint u2 = uint(dot(floor(        u/rz),vec2(1,r2.x)));\n    uint m2 = uint(dot(floor(iMouse.xy/rz),vec2(1,r2.x)));\n    \n    uint a = +u2                      //divides screen in 16*8 worlds\n             +16U*8U        *m2       //show next 16*8 worlds with mouse click\n             +16U*8U*16U*8U *0U;      //show next 16*8*16*8 worlds\n    //if(o>=32U){a = 1430607221U;}  \n    o = (read(u,vec2(0,0))<<1U) | ((a>>(o&31U))&1U);\n    fragColor = vec4(uintBitsToFloat(o));\n    if(iFrame==0||iMouse.z>.5)\n    {\n        uvec2 p = uvec2(u) + 1920U*1080U*uint(iFrame);\n              p = 1103515245U * ( (p>>1U) ^ (p.yx   ) );\n        uint  q = 1103515245U * ( (p.x  ) ^ (p.y>>3U) );\n        vec2  v = fract(u/rz)-.5;\n        fragColor = vec4(float(q)*step(dot(v,v),nz));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdfGzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 613]], "test": "untested"}
{"id": "cdXGzf", "name": "Dragon Curve with Stack", "author": "mla", "description": "The Dragon Curve using a simple stack. 9 levels deep, following Knuth: [url]https://www.youtube.com/watch?v=v678Em6qyzk[/url] ", "tags": ["lsystem", "stack", "dragon", "gosper"], "likes": 3, "viewed": 219, "published": 3, "date": "1666518009", "time_retrieved": "2024-07-30T16:25:09.575057", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Dragon Curve, drawn with stack. mla, 2022.\n//\n// Inspired by https://www.shadertoy.com/view/cdsGRj by FabriceNeyret2\n//\n// Uses an explicit stack to keep track of the recursion.\n// We still plot out all of the curve segments. A better approach would be\n// to keep track of intermediate segments and avoid recursing far from\n// the point being plotted.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\n#define C(turns,offset) (((turns) << 16) | ((offset) & 0xffff))\nconst int A = 0, B = 3, END = -1, L = -1, R = 1;\nint program[6] =\n  int[] (C(0,A),C(R,B),C(0,END), C(0,A),C(L,B),C(0,END));\nconst float angle = PI/2.0;\n\nconst int maxdepth = 9;\n\nvec2 p = vec2(0);     // The drawing point\nvec2 point = vec2(0); // The moving point\nfloat theta = 0.0;    // Cumulative angle\nfloat plen = 0.0;     // Cumulative path length\n\nfloat drawsegment(vec2 pos, float t) {\n  vec2 seg = vec2(cos(theta),sin(theta));  // Segment has length 1\n  if (t >= plen && t < plen+1.0) point = p + (t-plen)*seg;\n  vec2 q = p + seg;\n  float d = segment(pos,p,q);\n  plen += 1.0;\n  p = q;\n  return d;\n}\n\nvec3 getcol(float h) {\n  return 0.6*h2rgb(h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 pos = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  if (iMouse.x > 0.0) pos -= (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  pos = pos.yx*vec2(-1,1);\n  float scale = 0.6*pow(2.0,0.5*float(maxdepth));\n  pos *= scale;\n  pos -= scale*vec2(-0.6,-0.4);\n  int stack[maxdepth];\n  int depth = 0;\n  stack[depth++] = 0;\n  float maxlen = pow(2.0,float(maxdepth));\n  float t = mod(3.0*iTime,maxlen); // Moving point\n  float d = 1e8;\n  float clen = 0.0;\n  while (depth > 0) {\n    int instr = program[stack[depth-1]++];\n    // Decode instruction\n    int turns = instr>>16;\n    int code = instr<<16>>16;\n    theta += float(turns)*angle; // Apply turn\n    if (code == END) depth--;    // Terminate level & unwind\n    else if (depth < maxdepth) stack[depth++] = code;  // Recurse\n    else {\n      float d0 = drawsegment(pos,t); // Segment\n      if (d0 < d) { d = d0; clen = plen; }\n    } \n  }\n  float px = fwidth(pos.x);\n  vec3 col = vec3(1,1,0.8);\n  col = mix(getcol(clen/maxlen),col,vec3(smoothstep(0.0,px,d-0.05)));\n  col = mix(vec3(0), col,smoothstep(0.0,px,distance(pos,point)-0.2));\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "const float PI = 3.1415926;\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdXGzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[943, 943, 981, 981, 1195], [1197, 1197, 1219, 1219, 1244], [1246, 1246, 1301, 1301, 2446]], "test": "untested"}
{"id": "dss3z2", "name": "Gosper Curve with Stack", "author": "mla", "description": "The Gosper Curve using a simple stack (just storing the offset of the \"current instruction\").\n\nSee also Fabrice's hard wired recursion here: [url]https://www.shadertoy.com/view/cdsGRj[/url] (my one only goes down 3 levels though).", "tags": ["lsystem", "stack", "gosper"], "likes": 12, "viewed": 275, "published": 3, "date": "1666512170", "time_retrieved": "2024-07-30T16:25:10.318070", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Gosper Curve, drawn with stack. mla, 2022.\n//\n// Inspired by https://www.shadertoy.com/view/cdsGRj by FabriceNeyret2\n//\n// Uses an explicit stack to keep track of the recursion.\n// We still plot out all of the curve segments. A better approach would be\n// to keep track of intermediate segments and avoid recursing far from\n// the point being plotted.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Each instruction is an integer number of turns, followed by\n// either an instruction offset for the recursive call or -1\n// to terminate the current level.\n#define C(turns,offset) (((turns) << 16) | ((offset) & 0xffff))\nconst int A = 0, B = 8, END = -1, L = -1, R = 1;\nint program[16] =\n  int[] (C(0,A),C(L,B),C(L+L,B),C(R,A), C(R+R,A),C(0,A),C(R,B),C(L,END),\n         C(R,A),C(L,B),C(0,B),C(L+L,B), C(L,A),C(R+R,A),C(R,B),C(0,END));\n\nconst int maxdepth = 3;\nconst float angle = PI/3.0;\n\nvec2 p = vec2(0);     // The drawing point\nvec2 point = vec2(0); // The moving point\nfloat theta = 0.0;    // Cumulative angle\nfloat plen = 0.0;     // Cumulative path length\n\nfloat drawsegment(vec2 pos, float t) {\n  vec2 seg = vec2(cos(theta),sin(theta));  // Segment has length 1\n  if (t >= plen && t < plen+1.0) point = p + (t-plen)*seg;\n  vec2 q = p + seg;\n  float d = segment(pos,p,q);\n  plen += 1.0;\n  p = q;\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 pos = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  float scale = pow(7.0,0.5*float(maxdepth));\n  pos *= 0.6*scale;\n  pos -= vec2(0,0.55*scale);\n  int stack[maxdepth];\n  int depth = 0;\n  stack[depth++] = 0;\n  float t = mod(3.0*iTime,pow(7.0,float(maxdepth))); // Moving point\n  float d = 1e8;\n  while (depth > 0) {\n    int instr = program[stack[depth-1]++];\n    // Decode instruction\n    int turns = instr>>16;\n    int code = instr<<16>>16;\n    theta += float(turns)*angle; // Apply turn\n    if (code == END) depth--;    // Terminate level & unwind\n    else if (depth == maxdepth) d = min(d,drawsegment(pos,t)); // Segment\n    else stack[depth++] = code;  // Recurse\n  }\n  float px = fwidth(pos.x);\n  vec3 col = vec3(smoothstep(0.0,px,d-0.05));\n  col = mix(vec3(1,0,0), col,smoothstep(0.0,px,distance(pos,point)-0.2));\n  fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "const float PI = 3.1415926;\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dss3z2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1192, 1192, 1230, 1230, 1444], [1446, 1446, 1501, 1501, 2360]], "test": "untested"}
{"id": "cdfGzX", "name": "Fractal mosaic 27 (music)", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "mosaic", "rug"], "likes": 6, "viewed": 219, "published": 3, "date": "1666493786", "time_retrieved": "2024-07-30T16:25:11.061084", "image_code": "vec2 triangle_wave(vec2 a){\n    return\n        abs(fract((a+vec2(1.,0.5))*1.5)-.5)\n    ;\n}\n\n#define triwave_(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1_(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\nfloat t1_(vec2 c, vec2 p){\n    return triwave_((.5 - length( min(p=fract(p*sign(triwave1_(c*c.y))), 1.-p.yx) )));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    vec2 uv = (fragCoord)/iResolution.y/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/2.;\n    bool t3 = false;\n    for(int k = 0; k < 9; k++){\n        //uv.x += t1_(floor(uv/2.),floor(uv/2.));\n        \n        t3 = uv.x > uv.y && t3;\n        \n        uv = abs(triangle_wave(uv.yx-.5)-.5);\n        //uv += fmod(uv.x*8.,8.)/8.;\n        if(t3 || uv.y < uv.x) {\n            col =\n                max(col,vec3(col.yz,uv.x-uv.y))\n                //abs(1.-col-vec3(col.yz,uv.x-uv.y))\n\n                //max(1.-col,vec3(col.yz,uv.x-uv.y))\n\n                //abs(col-vec3(col.yz,uv.x-uv.y))\n                //vec3(col.yz,uv.x-uv.y)\n            ;\n            //uv *= 2.; //another interesting pattern\n        }\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "sound_code": "vec2 mainSound(int samp, float time){\n  \n  float s1 =\n      8.;\n  //time = time*(1. + fmod(time,2.))/2.;\n\n  //time += fpow(time*8.,2.)*8.+fpow(time*4.,2.)*4.+fpow(time*2.,2.)*2.;\n  \n  //time -= fpow(time*2.,2.);\n  \n  //time = (time + floor(floor(time*s1)+floor(time/s1))/s1)/2.;\n  float s2 = 8.,\n  m5 = fmod(time+floor(time/s2),s2),\n  m4 = fmod(floor(time/s1+m5/s1)*floor(time/s1)/s2,2.),\n  t=\n      time/(1.+m4)\n      //time/2.\n      //(time+floor(time*s1)/s1)/(1.+m4)\n      //time/(1.+m4)+floor(time*s1)/s1\n  ,\n  m1 =\n      fmod(t+m5,s2)\n  ,\n  m3 =\n      fmod(t/(m1+.5),s2)\n      //fmod(t*pow(2.,fmod(t/8./2.,3.)),s2)\n  ;\n  //t += floor(t*s1+floor(t/s1))/s1;\n  t *= s1*s1;\n  t /=\n      (1.+fmod((t/s1+floor(t/s1/s1))/2.,2.))\n  ;\n\n\n  float m2 =\n      1. + fmod(t/s1,s1)\n  ;\n  \n  //m3 = mod(floor(t/s1),1.+m3);\n  //m2 = mod(floor(t/s1),1.+m2);\n\n  \n  float a=\n      //64.*(1.-sqrt(fract(t/s1)/1.25))*.2\n      abs(1.-log(fract(t/s1)))\n      //log(1.+fract(-t/s1))\n      //pow(1.75,2.-log(fract(t/s1)))\n  ,\n  \n  nb = time*pow(2.,floor(m3+m2)/5.+6.5);\n\n  return\n      abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a\n      \n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a))\n      \n      //vec2(fract(nb*.998/m2*s1)*a,fract(nb/m2*s1)*a)\n  ;\n\n}", "sound_inputs": [], "common_code": "float fmod2(float a, float b){\n    return mod(floor(a),b)*b;\n}\n\nfloat fmod1(float a, float b){\n    //a += fmod2(a,2.);\n    //a += fmod2(a/2.+4.,b+4.);\n    //divide by powers of 2 to get interesting rhythms\n    float a1 = a;\n    //a /= 1. + mod(floor(a1/4.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    return\n        mod(floor(a),b)\n        //floor(mod(mod(4.+(a),4.+floor(a/2.)),b))\n        //mod(floor(floor(a*b)/8.+floor(a/b)),b)\n        //mod(floor(a/b),b)\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n    ;\n}\n\nfloat fmod(float a, float b){\n    return\n        fmod1(a,b)\n        //mod(fmod1(a,b*(1.+mod(floor(a/b*4.),8.))/b),b)\n    ;\n}\n\n\n//#define fmod(a,b) mod(mod(floor((a)),floor(1.+(a)/5.)),b)\n#define fpow(x,y) pow(y,mod(floor(x),y))", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfGzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 90], [207, 207, 233, 233, 322], [324, 324, 381, 381, 1240]], "test": "untested"}
{"id": "cslGDM", "name": "Fractal Cabin In The Woods", "author": "derSchamane", "description": "kind of fractal architecture experiment.\nclick and drag the mouse to change the camera position.\n\nsry for compile times and slow speed.\nruns smoothly on a gtx2070 in fullhd.\nDOF or TAA would propably help.", "tags": ["3d", "raymarching", "fractal", "kifs", "forrest", "cabin", "woods", "mk3drmb"], "likes": 32, "viewed": 499, "published": 3, "date": "1666491539", "time_retrieved": "2024-07-30T16:25:11.984616", "image_code": "//               = Fractal Cabin In The Woods =         \n//               by Maximilian Knape  >| 2022            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n#define GAMMA vec3(.4545)\n\n#define MAX_STEPS 180\n#define STEP_FAC 0.8\n#define MAX_DIST 1000.\n#define MIN_DIST 1.\n\n#define SURF_DIST .005\n#define SURF_MUL 2000.\n#define SURF_EXP 1.4\n\n#define PP_GLOW 0.6\n#define PP_ACES 0.5\n#define PP_CONT 0.4\n#define PP_VIGN 2.0\n#define AO_OCC 0.3\n#define AO_SCA 0.4\n\n#define AA_ENAB false //compile time warning\n#define AA_THRE .03   //fps warning\n\n#define CAM_MOVEMENT true //set false to stop animation\n\n#define iTime iTime*1.\n#define PI 3.14159265358979\n#define S(x,y,t) smoothstep(x,y,t)\n#define cAngle vec2(cos(PI/12.), sin(PI/12.))\n\nvec2 Map(in vec3 p) \n{   \n    //puh, that escalated quickly..\n    //wanted a simple small room - steady image\n    //therefore needed a house and a world around\n    //ended up here, a bit messy but I like it. <3\n    \n    float d = 10e10, col;\n    float dis = length(p.xz);\n    \n    //ground\n    float terrain = max(0., p.y + 3.*dot(sin(p/13.-2.3), cos(p/21.-15.5)) + \n                    pow((p.x+100.)/100., 3.) + pow(p.z/50., 2.) - 3.);\n    col = 3.1 + step(100.,dis)*5.1;\n    d = terrain*.8;\n    \n    //grass\n    if (dis < 100.) \n    {   //it works, but nothing more\n        float grass = max(0.,terrain - .1 - .6*noise(p.xz/8.1-14.3) + \n                      .13*noise(p.xz*11.11+32.) * S(100., 0., dis));\n        grass = mix(grass, terrain, pow(S(30.+grass*50.,3., dis), 2.));\n        if (p.x > 0.) grass = mix(grass, terrain - .1*(noise(p.zx * vec2(10.,2.))-.5), \n            S(3., 1.5, abs(p.z -5.*pow(sin((p.x-10.)/30.), 3.)) + .1*cos(p.z*5.)));\n        col = mix(col, 8.05 + grass*.3, step(grass, d));\n        d = min(d, grass * S(-100., 100., dis));\n    }\n    \n    //forest\n    if (dis > 50.) \n    {   //bob style\n        float tree = MAX_DIST; \n        const float gridSize = 30.;\n        vec3 pos = mod(p.xyz, vec3(gridSize)) - vec3(gridSize/2.);\n        pos.xz += (vec2(noise(round(p.xz/gridSize-.5)))*2.-1.) * gridSize/2.4;\n        float wind = S(.5, 1., noise(p.xz/100. + vec2(iTime/12.) + p.y/300.)) * (p.y-terrain)/10. * (1.-dis/MAX_DIST);\n        pos.y = terrain -5.;\n        float needles = fract(-p.y/4. + .5*noise(pos.xz*5.1) + atan(10.*(pos.x/pos.z+p.z))) * 10.;\n        tree = max(dot(cAngle, vec2(length(pos.xz + wind), pos.y - needles - S(30., 300., dis)*60.+10.)), -pos.y-needles+1.);\n        col = mix(col, 7.3, step(tree, d));\n        d = min(d, tree * (S(50., MAX_DIST, dis)+.4));\n    } \n    \n    //house\n    if (dis < 30.) \n    {   //earthship, seams liveable in some kind \n        float house;\n        float frame = sdKMC(p - vec3(0,0,0), 10, vec3(0,4,0), vec3(0.001), vec4(4,3,10.+ step(-p.y, -10.)*(p.x+15.)/15.,10)).x;\n        col = mix(col, 1.7, step(frame, d));\n        house = min(d, frame);\n\n        float screed = length(max(vec3(0.), abs(vec3(0,-4.7,0) + p) - vec3(9.5,.1,9.5))) - .1;\n        col = mix(col, 6.1, step(screed, house));\n        house = min(house, max(screed, -(length(p - vec3(0,5,0)) - 4.4)));\n\n        vec3 rot = p;\n        rot.xy *= Rot(-.07);\n        float roof = length(max(vec3(0.), abs(rot/vec3(1, 1.+ cos(rot.z*20.)*.004,1) - vec3(2,11,0)) - vec3(12,.03,12))) - .03;\n        col = mix(col, 5.9, step(roof, house));\n        house = min(house, max(roof, -(length(p - vec3(0,10,0)) - 3.5)));\n\n        float lSph = length(rot / vec3(1.2,.3,1.2) - vec3(0.6,36,0)) - 3.;\n        col = mix(col, -0.2, step(lSph, house));\n        house = min(house, lSph*.6);\n\n        float concrete = sdKMC(p/1.05 - vec3(0,-5,0), 8, vec3(-5), vec3(0.), vec4(4,3,12,13)).x;\n        col = mix(col, 2.2, step(concrete, house));\n        house = min(house, concrete);\n\n        if (step(-5., -p.y) * step(-1., p.y) * step(-10., -length(p.xz)) > 0.)\n        {\n            rot = p; //messy stairs\n            rot.xz *= Rot(0.65 * floor((p.y)*5.)/5.);\n            rot = max(abs(rot - vec3(0,-3,4)) - vec3(.2+.4*step(4.8,p.y), .2, 2.-1.5*S(3., 5., p.y)), 0.);\n            float stairs = length(mod(rot, vec3(0,.2,0)))-.01;\n            col = mix(col, 9.2, step(stairs, house));\n            house = min(house, stairs*.8); \n            \n            float sphere = length(p - vec3(0,.3,0)) - 1.;\n            col = mix(col, 4.6, step(sphere, house));\n            house = min(house, sphere);\n        }\n        \n        d = mix(smin(terrain, house, 1.3), d, S(20., 30., dis));\n    }\n\n    return vec2(d, col);\n}\n\nvec3 Normal(in vec3 p) \n{\n    const vec2 e = vec2(.005, 0);\n    return normalize(Map(p).x - vec3(Map(p-e.xyy).x, Map(p-e.yxy).x,Map(p-e.yyx).x));\n}\n\nvec3 RayMarch(in vec3 ro, in vec3 rd) \n{\n    float col = 0.;\n\tfloat dO = MIN_DIST;\n    int steps = 0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {\n        steps = i;\n        \n    \tvec3 p = ro + rd*dO;\n        vec2 dS = Map(p);\n        col = dS.y;\n        dO += dS.x * mix(STEP_FAC, 1., dO/MAX_DIST);\n        \n        if (dO > MAX_DIST || dS.x < (SURF_DIST * (pow(dO/MAX_DIST, SURF_EXP)*SURF_MUL+1.))) break;\n    }\n    \n    return vec3(dO, steps, col);\n}\n\nfloat SoftShadow(in vec3 ro, in vec3 lp, in float k) //Shane\n{\n    if (length(ro) > 200.) return 1.;\n\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro;\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    for (int i = 0; i<maxIterationsShad; i++)\n    {\n\n        float h = Map(ro + rd*dist).x;\n        shade = min(shade, smoothstep(0., 1., k*h/dist));\n        dist += clamp(h, .02, .25);\n        \n        if (h < .0 || dist > end) break;\n    }\n\n    return min(max(shade, 0.) + .1, 1.); \n}\n\n\nfloat CalcAO(in vec3 p, in vec3 n) //iq\n{\n    float occ = AO_OCC;\n    float sca = AO_SCA;\n\n    for( int i = 0; i < 5 ; i++ )\n    {\n        float h = 0.001 + 0.150 * float(i) / 4.0;\n        float d = Map(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= 0.95;\n    }\n    return S(0.0, 1.0 , 1.0 - 1.5 * occ);    \n}\n\n\nconst vec3 ambCol = vec3(.01,.02,.03) * 4.0;\nconst vec3 sunCol = vec3(1., .9, .8) * 1.2;\nconst vec3 skyCol = vec3(.3, .6, 1.) * 1.0;\nconst float specExp = 12.;\n\nvec3 Shade( in vec3 col, \n            in float mat, \n            in vec3 p, \n            in vec3 n, \n            in vec3 rd, \n            in vec3 lP) \n{\n    vec3  lidi = normalize(lP - p);\n    float mafa = max(mat, .0),\n          amoc = CalcAO(p, n),\n          shad = SoftShadow(p + n*.015, lP, 2.),\n          diff = max(dot(n, lidi), 0.) * shad,\n          spec = pow(diff, max(1., specExp * mafa)),\n          refl = pow(max(0., dot(lidi, reflect(rd, n))), max(1., specExp * 3. * mafa)) * shad;\n    vec3  ambc = mix(sunCol/8., ambCol, S(10., 20., length(p.xz))*.2+.6);\n          \n    return mix( ambc * col * amoc +                           //ambient\n                mix(diff * col * sunCol,                      //diffuse\n                (spec * col + refl * mafa), mafa) * sunCol,   //specular\n                \n                col  * S(0., 1., amoc * amoc + .5),           //emission\n                max(-mat, 0.));\n}\n\nvec3 Palette(int index, in vec3 p)\n{\n    switch (index)\n    {\n        case 0: return vec3(1.);                                       //lightsphere\n        case 1: return vec3(.8, .4, .35);                              //frame\n        case 2: return vec3(.6, .6, .6);                               //concrete\n        case 3: return vec3(.4, .3, .2)*(.25 + .25*noise(-p.xz/PI));   //terrain\n        case 4: return hsv2rgb_smooth(vec3(fract(iTime/21.), .8, .8)); //sphere\n        case 5: return vec3(.2, .6, .8);                               //roof\n        case 6: return vec3(.5);\n        case 7: return vec3(.3, .8, .2)*(.1 + .1*noise(p.xz/10.));     //trees\n        case 8: return vec3(.5, .8, .2)*(.13 + .15*noise(p.xz/6.2));   //grass\n        case 9: return vec3(.8, .5, .2)*(.2 + .4*noise(p.xy*vec2(.1,100.))); //messy stairs\n    }\n    return vec3(0.);\n}\n\nvoid Render( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5 * iResolution.xy) / iResolution.y;\n\tvec2 m = S(vec2(0), vec2(1), iMouse.xy / iResolution.xy);\n\n    if (length(m) <= 0.) m = vec2(0.65,.9);\n    if (CAM_MOVEMENT && !AA_ENAB) \n        m = mix(m, pow(vec2(sin(iTime/69.-1.), -cos(iTime/69.)), vec2(3)) *\n            vec2(.6, .3) + vec2(.6, .6), S(10., 100., (iMouse.z > 0.) ? 0. : iTime));\n\n    vec3 ro = vec3(-1., 3., -8.-m.x*60.);\n    ro.yz *= Rot(-m.y * PI/4. + PI/4.);\n    ro.xz *= Rot(-m.x * PI * 2.);\n    vec3 rd = R(uv, ro, vec3(0., 5., 0.), .8);\n    \n    vec3 bg = skyCol * (.2 + S(-.1, 0.3, dot(rd, vec3(0,1,0))));\n    vec3 lPos = vec3(2,2,-2)*100.; \n    vec3 col = bg;\n    vec3 p = vec3(0.);\n    \n    vec3 rmd = RayMarch(ro, rd);\n\n    if(rmd.x < MAX_DIST) \n    {\n        p = ro + rd * rmd.x;\n        vec3 n = Normal(p);\n        \n        float shine = fract(rmd.z)*abs(rmd.z)/rmd.z;\n        int index = int(floor(abs(rmd.z)));\n        col = Palette(index, p);\n        \n        if (index == 3) n *= .8 + .6*noise(p.xz*33.);\n        if (index == 8) n *= mix(.7 + .6*noise(p.xz*7.), 1., S(10., 150., rmd.x));\n        \n        col = Shade(col, shine, p, n, rd, lPos);   \n        //col = vec3(1) * CalcAO(p, n);\n    }\n    \n    float disFac = S(0., 1., pow(rmd.x / MAX_DIST, 1.2));\n    \n    col = mix(col, bg, disFac);\n\n    float sdir = dot(normalize(lPos-ro), rd);\n    float sblend =  pow(S(0.1, 1.2, sdir), 3.)*.6 + \n                    pow(max(sdir,0.01), 2000.);\n    col += sblend * disFac * sunCol;\n    \n    float glow = pow(rmd.y / float(MAX_STEPS), 1.2) + sblend*sblend;\n    col += glow * normalize(mix(sunCol/10., ambCol, S(10., 20., length(p.xz))*.5+.5)) * PP_GLOW;\n    \n    float hfog = S(0.3, .8, noise(p.zx/100.+vec2(iTime/21.))) * S(25., -10., p.y) * S(0., .05, disFac);\n    col += glow * hfog * .8;\n    \n    \n    fragColor = vec4(col,1.0);\n}\n\nvec4 PP(vec3 col, vec2 uv)\n{\n    col = mix(col, (col * (2.51 * col + 0.03)) / (col * (2.43 * col + 0.59) + 0.14), PP_ACES);\n    col = mix(col, S(vec3(0.), vec3(1.), col), PP_CONT);  \n    col *= S(PP_VIGN,-PP_VIGN/5., dot(uv,uv)); \n    col = pow(col, GAMMA);\n    \n    return vec4(col, 1.);\n}\n\n//totally unusable in realtime.\nvoid mainImage(out vec4 O, vec2 U) //Fabrice - easy adaptive super sampling | edited\n{\n    Render(O,U);\n    \n    if (AA_ENAB && fwidth(length(O)) > AA_THRE)\n    {\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { Render(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n        //O.r++; //Show sampled area\n    }\n    \n    O = PP(vec3(O), (U-.5 * iResolution.xy) / iResolution.y);\n}", "image_inputs": [], "common_code": "float sminCubic( float a, float b, float k ) //iq\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat smin( float a, float b, float k ) //iq\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nvec3 hsv2rgb_smooth( in vec3 c ) //iq\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n    \n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nmat2 Rot(in float a) //2D\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n#define Rot2D(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 Rot(in vec3 p, in vec3 r) //las\n{\n    Rot2D(p.xz, r.y);\n    Rot2D(p.yx, r.z);\n    Rot2D(p.zy, r.x);\n    return p;\n}\n\n//keep air hot, the winter is comming:\nvec2 sdKMC( in vec3 p,\n            in int iters,\n            in vec3 fTra,\n            in vec3 fRot,\n            in vec4 para)\n{//kind of kaleidoscopic menger cube \"structure\"\n    \n    float d =   length(max(vec3(0.), abs(p) - para.z - \n                length(abs(fTra) + abs(sin(fRot)))));\n    if (d > 0.) return vec2(10e3, 0.);\n    \n    int i;\n    float col = 0.;\n    float x1, y1;\n    float r = p.x*p.x + p.y*p.y + p.z*p.z;\n    \n    for(i = 0; i < iters && r < 1e8; i++)\n    {\n        if (i > 0) \n        {\n            p -= fTra;\n            p = Rot(p, fRot);\n        }\n\n        p = abs(p);\n\n        if (p.x-p.y < 0.) { x1=p.y; p.y=p.x; p.x=x1;}\n        if (p.x-p.z < 0.) { x1=p.z; p.z=p.x; p.x=x1;}\n        if (p.y-p.z < 0.) { y1=p.z; p.z=p.y; p.y=y1;}\n\n        p.z -= 0.5 * para.x * (para.y - 1.) / para.y;\n        p.z = -abs(p.z);\n        p.z += 0.5 * para.x * (para.y - 1.) / para.y;\n\n        p.x = para.y * p.x - para.z * (para.y - 1.);\n        p.y = para.y * p.y - para.w * (para.y - 1.);\n        p.z = para.y * p.z;\n\n        r = p.x*p.x + p.y*p.y + p.z*p.z;\n    }\n    \n    d = length(p) * pow(para.y, float(-i));\n\n    return vec2(d, col);\n}\n\nfloat hash(float n) { return fract(sin(n)*43758.5453123); } //iq\n\nfloat noise(in vec2 x) //iq\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n    float res = mix(mix(hash(n+  0.0), hash(n+  1.0), f.x),\n                    mix(hash(n+ 57.0), hash(n+ 58.0), f.x), f.y);\n    return res;\n}\n\nvec3 R(in vec2 uv, in vec3 p, in vec3 l, in float z)\n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslGDM.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[876, 876, 898, 1086, 4607], [4609, 4609, 4634, 4634, 4756], [4758, 4758, 4798, 4798, 5217], [5219, 5219, 5281, 5281, 5835], [5838, 5838, 5879, 5879, 6159], [6323, 6323, 6475, 6475, 7243], [7245, 7245, 7281, 7281, 8103], [8105, 8105, 8159, 8159, 9992], [9994, 9994, 10022, 10022, 10284], [10286, 10318, 10404, 10404, 10725]], "test": "untested"}
{"id": "DslGR2", "name": "80s anime tech lights", "author": "y2k_cyborg", "description": "Supposed to emulate the look of glowy blinking lights in old anime", "tags": ["retro"], "likes": 9, "viewed": 352, "published": 3, "date": "1666489573", "time_retrieved": "2024-07-30T16:25:12.731618", "image_code": "// From https://www.shadertoy.com/view/lsBfRc\n#define colorRange 0.4\n\nvec3 jodieReinhardTonemap(vec3 c){\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvec3 bloomTile(float lod, vec2 offset, vec2 uv){\n    return texture(iChannel1, uv * exp2(-lod) + offset).rgb;\n}\n\nvec3 getBloom(vec2 uv){\n\n    vec3 blur = vec3(0.0);\n\n    blur = pow(bloomTile(2., vec2(0.0,0.0), uv),vec3(2.2))       \t   \t+ blur;\n    blur = pow(bloomTile(3., vec2(0.3,0.0), uv),vec3(2.2)) * 1.3        + blur;\n    blur = pow(bloomTile(4., vec2(0.0,0.3), uv),vec3(2.2)) * 1.6        + blur;\n    blur = pow(bloomTile(5., vec2(0.1,0.3), uv),vec3(2.2)) * 1.9 \t   \t+ blur;\n    blur = pow(bloomTile(6., vec2(0.2,0.3), uv),vec3(2.2)) * 2.2 \t   \t+ blur;\n\n    return blur * colorRange;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    // avoid a teensy little bug in the bloom I can't diagnose\n    uv *= .9;\n    uv += .1;\n    \n    // Q: how to scale the bloom extent vs amount?\n    \n    vec3 color = pow(texture(iChannel0, uv).rgb * colorRange, vec3(2.2));\n    color = pow(color, vec3(2.2));\n    color += pow(getBloom(uv), vec3(2.2));\n    color = pow(color, vec3(1.0 / 2.2));\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 cols[6] = vec3[]( vec3(1,0,0), vec3(1,1,0), vec3(0,1,0), vec3(0,1,1), vec3(0,0,1), vec3(1,0,1) );\nfloat col_prob[6] = float[]( 2./12., 6./12., 7./12., 9./12., 11./12., 1. );\n\nvec3 colAt(vec3 p) {\n    // colour\n    // scale to avoid obvious correlation\n    // with other quantities\n    float hv = hash13(p * 2.7512649);\n    int ci = 5;\n    \n    for (int i = 0; i < 6; ++i) {\n        if (hv < col_prob[i]) {\n            ci = i;\n            break;\n        }\n    }\n    \n    return (cols[ci] * .6 + vec3(.3));\n}\n\n\nfloat inRectAt(vec3 f, vec3 p) {\n    // Does it exist?\n    const float pa = .1;\n    \n    // Scale to prevent obvious correlation    \n    float a = hash13(p * 1.157894);\n    if (a > pa) { return 0.; }\n    \n    // Random values we'll use for w,h,x,y\n    vec4 e = hash43(p);\n    \n    // Split the extent into width, height, and centroid x,y; apply appropriate scalings to each; then construct t,b,l,r\n    // extents can spill 1 grid cell over, but not 2\n    // grid cell center is at 0,0\n    // min size: 0.3 or higher?\n    // max size: somewhere between 1.5 and 3.0\n    // pos: +/- (3 - size) / 2\n    vec2 wh = .3 + 1.7 * e.xy;\n    vec2 xy = (vec2(3.) - wh) * (e.zw - .5);\n    \n    vec2 u = vec2(-1., 1.);\n    vec4 lrbt = xy.xxyy + .5 * u.xyxy * wh.xxyy;\n    vec4 extent = lrbt;\n    \n    // In time - grid is 1 second, similar logic\n    vec2 eT = hash23(p * 3.353546);\n    float d = 1.0 + 2.0 * eT.x;\n    float t = (3. - d) * (eT.y - .5);\n    //t = round(t * 5.) / 5.;\n    vec2 ba = vec2(t) + .5 * u.xy * vec2(d);\n    vec2 extentT = ba;\n\n    \n    if (f.x < extent.x) { return 0.; }\n    if (f.x >  extent.y) { return 0.; }\n    if (f.y < extent.z) { return  0.; }\n    if (f.y >  extent.w) { return 0.; }\n    if (f.z < extentT.x) { return 0.; }\n    if (f.z >  extentT.y) { return 0.; }\n    \n    // brightness goes up and down\n    // return 1.;\n    return smoothstep(0.,1.,clamp(10. * abs(f.z - t) / d, 0., 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 uvw = vec3(fragCoord/iResolution.x, iTime*0.3);\n    \n    // Grid scale\n    uvw.xy *= 20.;\n    uvw.z *= 1.;\n    vec3 uvwi = round(uvw);\n    vec3 uvwf = uvw - uvwi;\n    \n    vec3 col = vec3(0.,0.,0.);\n    \n    for (int xi = -1; xi <= 1; ++xi) {\n        for (int yi = -1; yi <= 1; ++yi) {\n            for (int zi = -1; zi <= 1; ++zi) {\n                vec3 d = vec3(xi,yi,-zi);\n                vec3 i = uvwi + d;\n                vec3 f = uvwf - d;\n                \n                // arbitrary winner if already set\n                float b = inRectAt(f,i);\n                if (b>0.) {\n                    col = colAt(i) * b;\n                    //col += colAt(i);\n                    break;\n                }\n            }\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "// Hash functions from https://www.shadertoy.com/view/4djSRW\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n", "buffer_b_code": "// From https://www.shadertoy.com/view/lsBfRc\n\nvec3 makeBloom(float lod, vec2 offset, vec2 bCoord){\n    \n    vec2 pixelSize = 1.0 / vec2(iResolution.x, iResolution.y);\n\n    offset += pixelSize;\n\n    float lodFactor = exp2(lod);\n\n    vec3 bloom = vec3(0.0);\n    vec2 scale = lodFactor * pixelSize;\n\n    vec2 coord = (bCoord.xy-offset)*lodFactor;\n    float totalWeight = 0.0;\n\n    if (any(greaterThanEqual(abs(coord - 0.5), scale + 0.5)))\n        return vec3(0.0);\n\n    for (int i = -5; i < 5; i++) {\n        for (int j = -5; j < 5; j++) {\n\n            float wg = pow(1.0-length(vec2(i,j)) * 0.125,6.0);\n\n            bloom = pow(texture(iChannel0,vec2(i,j) * scale + lodFactor * pixelSize + coord, lod).rgb,vec3(2.2))*wg + bloom;\n            totalWeight += wg;\n\n        }\n    }\n\n    bloom /= totalWeight;\n\n    return bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n\tvec3 blur = makeBloom(2.,vec2(0.0,0.0), uv);\n\t\tblur += makeBloom(3.,vec2(0.3,0.0), uv);\n\t\tblur += makeBloom(4.,vec2(0.0,0.3), uv);\n\t\tblur += makeBloom(5.,vec2(0.1,0.3), uv);\n\t\tblur += makeBloom(6.,vec2(0.2,0.3), uv);\n\n    fragColor = vec4(pow(blur, vec3(1.0 / 2.2)),1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DslGR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 104, 104, 227], [229, 229, 277, 277, 340], [342, 342, 365, 365, 821], [823, 823, 880, 880, 1304]], "test": "untested"}
{"id": "fdVfRD", "name": "Snowflake Dreams", "author": "amhall", "description": "My latest phone wallpaper.", "tags": ["2d", "fractal", "julia", "mouse", "sound", "triangle", "fm", "orbit", "snowflake"], "likes": 20, "viewed": 467, "published": 3, "date": "1666483544", "time_retrieved": "2024-07-30T16:25:13.674097", "image_code": "/*\n\n    Snowflake Dreams\n    Headphones or subwoofer recommended.\n    Created by Anthony Hall, 2022\n\n    I wanted a phone background with randomized Julia sets. I decided it would\n    be cool if it had sound to go with it.\n\n    The movement speed of C corresponds to the modulating wave amplutide for a\n    simple FM bass. Each iteration of triangles corresponds to one \"harmonic\"\n    of an additive synth. The \"brightness\" corresponds to a flanger on the\n    additive synth. There are a couple small details that polish up the sound\n    nicely.\n\n    Most of the animation parameters are in the common tab.\n\n*/\n\n\n// This is the total number of samples (radial around the pixel center) rather\n// than the size of a grid. Even a 2x2 grid is unnecessary for decent quality\nconst int SAMPLES = 3;\n\n// This biases later iterations to have more influence on the orbit trap, so\n// the smaller triangles are a bit bigger/brighter. I find that this looks much\n// better and reduces aliasing quite a bit. It's slightly more expensive though.\n#define ITERBIAS 0.9\n\n// Color banding is pretty noticeable on this one.\n#define DITHER\n\n// \"Globals\" populated in mainImage()\nvec2 C;\nfloat currentMaxIters, brightness;\n\nconst float phi = 2.0 / (1.0 + sqrt(5.0));\n\n\nvec2 cSquare(vec2 z)\n{\n    return vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y);\n}\n\n// Story time: some of my backgrounds use a generalized polygon \"distance\"\n// function in order to morph between different polygons. It was based on\n// radial domain repetition so it used 2 trig functions among other things.\n// The problem was I always copy+pasted that function even when my polygons\n// had a fixed number of sides, so a handful of my projects have been running\n// really inefficiently for who knows how long. Including projects I posted\n// on Shadertoy :(\nfloat orbitTrap(vec2 point)\n{\n    point.y = abs(point.y);\n    return max(point.x, dot(point, vec2(-0.5, 0.5 * sqrt(3.0))));\n}\n\nvec3 image(vec2 fragCoord)\n{\n    vec2 z = 1.3 * (2.0 * fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n\n    // Main Julia loop\n    float minOrbitDist = 1e5;\n    float iter;\n    for (iter = 0.0; iter < floor(currentMaxIters); iter += 1.0)\n    {\n        z = cSquare(z) + C;\n        float orbitDist = orbitTrap(z);\n        \n        // This might break too early for high aspect ratios\n        if (orbitDist > 10.0)\n            break;\n\n        #ifdef ITERBIAS\n            orbitDist *= pow(ITERBIAS, iter);\n        #endif\n        \n        minOrbitDist = min(minOrbitDist, orbitDist);\n    }\n    \n    // Mix in the partial last iteration\n    if (fract(currentMaxIters) > 0.0)\n    {\n        z = cSquare(z) + C;\n        float orbitDist = orbitTrap(z);\n        \n        #ifdef ITERBIAS\n            orbitDist *= pow(ITERBIAS, iter);\n        #endif\n        \n        minOrbitDist = mix(minOrbitDist, min(minOrbitDist, orbitDist),\n            fract(currentMaxIters));\n    }\n\n    float intensity = 1.0 / (minOrbitDist + 1.0);\n    \n    // Enabling the bias makes the brightness and exponents require some\n    // compensation to get everything looking nice\n    #ifdef ITERBIAS\n        brightness *= ITERBIAS;\n    #endif\n    \n    intensity = mix(intensity, \n        intensity * intensity * (3.0 - 2.0 * intensity), brightness);\n    \n    vec3 exponents = \n        vec3(8.0, 4.0, 1.0); // Ice blue\n        //vec3(15.0, 5.0, 1.0); // Slightly more saturated blue\n        //vec3(1.0, 5.0, 20.0); // Flame red\n        //vec3(3.5, 12.0, 1.2); // Purple\n        \n    #ifdef ITERBIAS\n        exponents /= ITERBIAS;      \n    #endif\n\n    return pow(vec3(intensity), exponents);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Calculate all the globals first\n    float cycle = animCycleFreq * iTime;\n\n    float oscillate = 0.5 - 0.5 * cos(cycle * tau);\n    oscillate = pow(oscillate, iterOscillateExponent);\n    currentMaxIters = 1.0 + (maxIters - 1.0) * (oscillate);\n    \n    brightness = 0.5 - 0.5 * cos(brightnessFreq * iTime * tau);\n\n    // Concentrate the movment within each cycle toward the beginning/end\n    // Skip first half of first cycle\n    float movement = 2.0 * fract(max(cycle, 0.5)) - 1.0; \n    movement = 0.5 * sign(movement) * pow(abs(movement), cMovementExponent);\n\n    // Add slight constant movement and a randomized value to the angle\n    float theta = 4.0 * phi * (floor(cycle) + movement) + 0.01 * iTime\n        + texelFetch(iChannel0, RANDTEXEL, 0).x * tau;\n    \n    // Normally, C will move slowest near the cusp. Because C doesn't\n    // travel exactly on the cardioid border, I don't know the optimal way\n    // to even out the movement speed. This basically stretches a sine\n    // wave's x axis toward x = 0 and adds that to theta, so theta moves\n    // faster near the cusp. I can't find a combination of an exponent and\n    // sine multiplier that doesn't look at least a little awkward going\n    // around the cusp.\n    float sinPhase = mod(theta / pi + 1.0, 2.0) - 1.0;\n    sinPhase = sign(sinPhase) * pow(abs(sinPhase), 0.7);\n    theta += 0.7 * sin(pi * sinPhase);\n    \n    // Move C around the main cardioid + mouse offset\n    float r = 0.6 - 0.5 * cos(theta);\n    C = r * vec2(cos(theta), sin(theta));\n    C.x += 0.25;\n    C += texelFetch(iChannel0, MOUSETEXEL, 0).xy;\n\n    // Radial supersample logic\n    vec3 color = vec3(0);\n    if (SAMPLES > 1 && abs(fragCoord.x - 0.5 * iResolution.x) / iResolution.x < 0.375)\n    {\n        for (int i = 0; i < SAMPLES; i++)\n        {\n            float theta = float(i) / float(SAMPLES) * tau;\n            vec2 offset = 0.25 * vec2(cos(theta), sin(theta));\n            color += image(fragCoord + offset);\n        }\n        color /= float(SAMPLES);\n    }\n    else\n    {\n        color = image(fragCoord);\n    }\n    \n    #ifdef DITHER\n        // Convert to (steps + 1) discrete values and dither\n        const float steps = 255.0;\n        vec3 substep = fract(color * steps);\n        color = floor(color * steps) / steps;\n        \n        ivec2 noiseTexel = ivec2(mod(fragCoord, iChannelResolution[1].xy));\n        vec3 threshold = texelFetch(iChannel1, noiseTexel, 0).rrr;\n        \n        color += vec3(greaterThan(substep, threshold)) / steps;\n    #endif\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// *** Changing these changes both the animation and sound ***\n\nconst float maxIters = 30.0;\n\n// Frequency of the entire animation in seconds\nconst float animCycleFreq = 0.07;\n\n// Higher value -> More of C's movement happens when the iter count is low\nconst float cMovementExponent = 8.0; // MUST be > 1.0, recommended >= 2.0\n\n// Higher value -> iter count spends more time low than high\nconst float iterOscillateExponent = 1.4;\n\n// Frequency of brightness oscillation\nconst float brightnessFreq = 0.24;\n\nconst float pi = radians(180.0);\nconst float tau = radians(360.0);\nconst ivec2 RANDTEXEL = ivec2(0);\nconst ivec2 MOUSETEXEL = ivec2(32, 0);", "sound_code": "// The movement speed of C corresponds to the modulating wave amplutide for a\n// simple FM bass. Each iteration of triangles corresponds to one \"harmonic\"\n// of an additive synth. The \"brightness\" corresponds to a flanger on the\n// additive synth.\n\n\n// This is the FM bass's frequency; the additive synth's is 3x this\nconst float baseFreq = 55.0 * exp2(-2.0/12.0); // G0\n\n// 32 bit floats can represent any integer sample value in the allotted 180\n// seconds, whereas using the time value for a sample immediately introduces\n// some rounding error. This pretty quickly becomes an audible buzzing. Getting\n// the phase with the actual sample value makes rounding less of a problem.\nfloat getPhase(float freq, float samp)\n{\n    float samplesPerCycle = iSampleRate / freq;\n    return mod(samp, samplesPerCycle) / samplesPerCycle;\n}\n\n// Sub/FM bass that goes with C's movement. The pitch of the modulating wave\n// is stereo, but the carrier is mono. This way there's stereo width except\n// for when it's just the sub, so there's no phase cancellation on a subwoofer.\nfloat getMovementSound(float animCycle, float samp, float time, float channel)\n{\n    float channelOffset = 2.0 * channel - 1.0;\n\n    // The modulator amplitude is proportional to C's movement speed\n    float modulatorAmp = 2.0 * fract(max(animCycle, 0.5)) - 1.0;\n    modulatorAmp = 7.5 * pow(abs(modulatorAmp), cMovementExponent - 1.0);\n    \n    float carrierFreq = baseFreq; \n    float carrierPhase = getPhase(carrierFreq, samp);\n    \n    float modulatorFreq = carrierFreq * exp2(0.02/12.0 * channelOffset); // 2 cent detune\n    float modulatorPhase = getPhase(modulatorFreq, samp);\n    \n    float sinPhase = carrierPhase + carrierFreq\n        * modulatorAmp * sin(modulatorPhase * tau) / (modulatorFreq * tau);\n    \n    return sin(sinPhase * tau);\n}\n\n// Triangle wave, odd rather than even so there's no DC offset when multiple\n// harmonics are added together\nfloat triangle(float phase)\n{\n    return 2.0 * abs(2.0 * fract(phase - 0.25) - 1.0) - 1.0;\n}\n\n// A harmonic series of triangle waves, where each harmonic corresponds to\n// one iteration of the Julia set. The fundamental is a triangle instead of\n// a sine so that 1) each harmonic is more audibly distinguishable and 2) the\n// final result doesn't end up sounding almost exactly like a saw wave.\n\n// The magic here is making the waveform dynamic. This is easily accomplished\n// by shifting the frequency of each harmonic a little bit so there's some\n// movement. By differing the frequency shifts per channel, you get effortless\n// stereo width. I find it sounds cleaner with no movement nor stereo width in\n// the first 2 harmonics.\n\nfloat getHarmonic(float harmonic, inout float totalAmp, float ampScale,\n                  float samp, float channel)\n{\n    // Quiet down the higher harmonics, but not aggressively\n    float amp = ampScale * pow(harmonic, -0.65);\n    totalAmp += amp;\n    \n    // Because of how the phase is fixed for the first 2 harmonics, this will\n    // retain maximum possible amplitude\n    totalAmp -= ampScale * 0.5 * float(harmonic == 2.0);\n    \n    // Because of the irrational frequency shift amounts, the peaks/valleys\n    // of the rest of the harmonics should never all align to reach peak\n    // amplitude (I think), i.e. in theory there's some guaranteed headroom\n    // and I could boost the volume some more. Not worth it in my opinion.\n    float freq = harmonic * 3.0 * baseFreq;\n    freq += 0.5 * fract(harmonic * sqrt(2.1 + channel)) * float(harmonic >= 3.0);\n    \n    float phase = getPhase(freq, samp);\n    return amp * triangle(phase);\n    \n}\n\nfloat getIterSound(float animCycle, float samp, float time, float channel)\n{\n    float iterOscillate = 0.5 - 0.5 * cos(animCycle * tau);\n    float harmonics = 1.0 + (maxIters - 1.0) * pow(iterOscillate, iterOscillateExponent);\n    \n    float totalAmp = 0.0;\n    float result = 0.0;\n    float harmonic = 1.0;\n    while (harmonic <= floor(harmonics))\n    {\n        result += getHarmonic(harmonic, totalAmp, 1.0, samp, channel);\n        harmonic += 1.0;\n    }\n    \n    // Mix in the partial last iteration\n    result += getHarmonic(harmonic, totalAmp, fract(harmonics), samp, channel);\n    \n    result /= totalAmp;  \n    return result;\n}\n\nvec2 mainSound( int isamp, float time )\n{\n    float samp = float(isamp);\n    float animCycle = animCycleFreq * time;\n    \n    vec2 movementSound = vec2(\n        getMovementSound(animCycle, samp, time, 0.0),\n        getMovementSound(animCycle, samp, time, 1.0));\n\n    // All a flanger does is mix a signal with a slightly delayed copy of\n    // itself. What results is frequencies near integer multiples of the delay\n    // frequency constructively interfere, and frequencies halfway between\n    // integer multiples of the delay frequency destructively interfere. The\n    // result is a comb filter with peaks at harmonics of the delay frequency,\n    // which is why a flanger sounds like a tone.\n    \n    float flangerMix = 0.5 - 0.5 * cos(brightnessFreq * time * tau);\n    flangerMix = pow(flangerMix, 0.7); // Bias toward more flange\n    \n    float flanger = 0.5 + 0.5 * cos(1.1111 * time);\n    float delayTime = 0.0003 + 0.003 * flanger;\n    float delaySamples = delayTime * iSampleRate;\n    \n    // The comb filtering from the flanger brings the average amplitude\n    // down to 2 / pi. This compensation accounts keeps the volume sounding\n    // pretty consistent for flanger vs no flanger.\n    const float combAverage = 2.2 / pi;\n    float ampCompensate = mix(combAverage, 1.0, flangerMix);\n    \n    vec2 iterSound = ampCompensate * mix(\n        vec2(\n            getIterSound(animCycle, samp, time, 0.0),\n            getIterSound(animCycle, samp, time, 1.0)),\n        vec2(\n            getIterSound(animCycle, samp - delaySamples, time, 0.0),\n            getIterSound(animCycle, samp - delaySamples, time, 1.0)),\n        0.5 * flangerMix);\n       \n    vec2 result = mix(movementSound, iterSound, 0.6);\n    \n    // Any time you're creating stereo width, always test in mono!\n    // At the last minute I caught some terrible phase cancellation in the\n    // additive synth.\n    // result = vec2(0.5 * (result.x + result.y));\n\n    // Leave a little headroom, fade in and out\n    return 0.8 * result * smoothstep(0.0, 1.0, time) * smoothstep(180.0, 170.0, time);\n}", "sound_inputs": [], "buffer_a_code": "// Randomized scalar at initialization, smooth mouse movement\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash14(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    ivec2 ifrag = ivec2(fragCoord);\n    if (ifrag == RANDTEXEL)\n    {\n        if (iFrame == 0)\n        {\n            fragColor.x = hash14(iDate);\n        }\n        else\n        {\n            fragColor.x = texelFetch(iChannel0, RANDTEXEL, 0).x;\n        }\n    }\n    else if (ifrag == MOUSETEXEL)\n    {\n        // Geometric series from current value towards goal\n        vec2 goal = vec2(0.0);\n        if (iMouse.z > 0.0)\n        {\n            goal = 0.2 * (2.0 * iMouse.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n        }\n        vec2 prev = texelFetch(iChannel0, MOUSETEXEL, 0).xy;\n        vec2 data = mix(prev, goal, 0.15);\n        fragColor.xy = data;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVfRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1248, 1248, 1270, 1270, 1321], [1323, 1797, 1826, 1826, 1922], [1924, 1924, 1952, 1952, 3601], [3603, 3603, 3658, 3697, 6210]], "test": "untested"}
{"id": "DdXGRX", "name": "Fractal mosaic 26 (music)", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "mosaic", "rug"], "likes": 2, "viewed": 160, "published": 3, "date": "1666478304", "time_retrieved": "2024-07-30T16:25:14.423095", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 = vec2(1.,0.5);\n    return abs(fract((a+a2)*(a2.x+a2.y))-.5);\n}\n\n\n#define triwave_(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1_(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\nfloat t1_(vec2 c, vec2 p){\n    return triwave_((.5 - length( min(p=fract(p*sign(triwave1_(c*c.y))), 1.-p.yx) )));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    vec2 uv = (fragCoord)/iResolution.y/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/2.;\n    vec2 t2 = vec2(0.);\n    bool t3 = false;\n    for(int k = 0; k < 6; k++){\n        \n        //uv.x -= t1_(floor(uv/2.),floor(uv/2.))/2.;\n        uv.x -= 1./8.;\n        \n        t3 = uv.x > uv.y;\n        //uv.x -= floor(mod(uv.x*1.5,1.5));\n        //uv += fmod(uv.x*2.,2.)/2.;\n        \n        //uv = (fract(vec2(uv+vec2(.5,1.5))*2.)-.5)/2.;\n        \n        if(t3){ uv = uv.yx;t2 = -t2.yx;}\n        uv =\n            abs(.5+uv+t2)\n            //abs(.5-uv+t2)\n            //abs(-.5-uv+t2)\n            //abs(.5-uv-t2)\n        ;\n        t2 =\n            triangle_wave(uv+.5)\n        ;\n        uv = t2+triangle_wave(uv.yx);\n        float c1 =\n            uv.x-uv.y\n            //uv.x*uv.y\n        ;\n        if(t3 || uv.y < uv.x) col = vec3(col.yz,c1);\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "sound_code": "vec2 mainSound(int samp, float time){\n  \n  float s1 =\n      8.;\n  //time += (floor(time*s1)+floor(time/s1))/s1;\n  float s2 = 8.,\n  m4 =\n      fmod(floor(time/s1)*floor(time*s1),2.)\n  ,\n  t=\n      time/(1.+m4)\n  ,\n  m1 =\n      fmod(t/s1,s2)\n      //fmod(time,s2)\n  ,\n  m3 =\n      fmod(floor(t*(s1))/(m1+.5),s2);\n  //t += (floor(t*s1)+floor(t/s1))/s1;\n  t /=\n      (1.+fmod(floor(t/s1-floor(t/s1)/s1)*floor(t*s1),2.))\n      //(1.+fmod(floor(time-floor(time)/s1)*floor(t*s1),2.))\n  ;\n  \n  t *=\n      s1*s1\n  ;\n\n    float m2 =\n      1. + fmod(floor(t/s1),s1)\n      //1. + fmod(floor(t/(1.+m1)),s1)\n      //1. + fmod(floor(t/s1/(1.+m3)),s1)\n  ;\n  \n  float a = 64.*((1.-sqrt(fract(t/s1))))*.2,\n\n  nb = time*pow(2.,(m3+m2)/5.+6.5);\n\n  return\n      //abs(.5-vec2(fract(nb*.998),fract(nb)))*a\n      \n      //sitar\n      log(abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n      \n      //vec2(fract(time*nb*.998/m2*s1)*a,fract(time*nb/m2*s1)*a)\n  ;\n\n}", "sound_inputs": [], "common_code": "float fmod(float a, float b){\n    //divide by powers of 2 to get interesting rhythms\n    float a1 = a;\n    //a /= 1. + mod(floor(a/2.),2.);\n    //a /= 1. + mod(floor(a/4.),2.);\n    //a /= 1. + mod(floor(a/8.),2.);\n    return\n        mod(floor(a),b)\n        //mod(floor(floor(a/8.)/8.+floor(a)),b)\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n    ;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdXGRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 103], [221, 221, 247, 247, 336], [338, 338, 395, 395, 1392]], "test": "untested"}
{"id": "dssGz2", "name": "Gaussian Filtered Lerp Square", "author": "oneshade", "description": "Gaussian filtered lerp of colors on four corners of a tile.", "tags": ["2d", "blur", "filter", "lerp", "gaussian", "bilinear", "patch"], "likes": 15, "viewed": 219, "published": 3, "date": "1666471218", "time_retrieved": "2024-07-30T16:25:15.162119", "image_code": "// https://www.desmos.com/calculator/njkwv6z5hi\n#define PI 3.1415926536\n#define SQRT_PI 1.7724538509\n\n#define sqr(x) ((x) * (x))\n#define erf(x) (sign(x) * sqrt(1.0 - exp2(-1.787776 * (x) * (x))))\nvec3 gpatch(in vec2 p, in vec2 w, in vec3 v1, in vec3 v2, in vec3 v3, in vec3 v4) {\n    vec3 c4 = v1;\n    vec3 c3 = v3 - v1;\n    vec3 c2 = v2 - v1;\n    vec3 c1 = v4 - v3 - c2;\n\n    vec2 k1 = (exp(-sqr(p / w)) - exp(-sqr((1.0 - p) / w))) * w * w / 2.0;\n    vec2 k2 = (erf(p / w) + erf((1.0 - p) / w)) * w * SQRT_PI / 2.0;\n\n    return (((k1.y + p.y * k2.y) * c1 + c2 * k2.y) * (k1.x + p.x * k2.x) + ((k1.y + p.y * k2.y) * c3 + c4 * k2.y) * k2.x) / (PI * w.x * w.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - vec2(0.5 * iResolution.x, 0.0)) / iResolution.y + vec2(0.5, 0.0);\n    vec3 color = vec3(0.0);\n\n    vec3 v3 = vec3(1, 0, 1), v4 = vec3(0, 1, 1);\n    vec3 v1 = vec3(1, 0, 0), v2 = vec3(0, 1, 0);\n\n    float filterWidth = 0.05 + 0.05 * sin(iTime) + 0.001;\n    fragColor = vec4(gpatch(uv, vec2(filterWidth), v1, v2, v3, v4), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssGz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[196, 196, 279, 279, 661], [663, 663, 718, 718, 1073]], "test": "untested"}
{"id": "sldyRH", "name": "[ConcoursJFIG2022] Cannels", "author": "PlathC", "description": "My submission for the JFIG 2022 Shadertoy contest.\nScene reference: https://passion-aquitaine.ouest-france.fr/wp-content/uploads/2019/10/Canel%C3%A9s-de-Bordeaux.jpg", "tags": ["jfig2022"], "likes": 9, "viewed": 386, "published": 3, "date": "1666467923", "time_retrieved": "2024-07-30T16:25:16.337976", "image_code": "// From Bokeh Venice \n// by Dave_Hoskins\n// Reference: https://www.shadertoy.com/view/ldG3W3\nvec3 Bokeh(vec4 base, sampler2D tex, vec2 uv, float radius, float zed)\n{\n// The Golden Angle is (3.-sqrt(5.0))*PI radians.\n#define GOLDEN_ANGLE 2.39996323\n#define ITERATIONS 30\n\n    mat2 rot = mat2(cos(GOLDEN_ANGLE), sin(GOLDEN_ANGLE), -sin(GOLDEN_ANGLE), cos(GOLDEN_ANGLE));\n\n    radius*= .6;\n\tvec3 acc = vec3(0.0), div = acc;\n    vec2 pixel = vec2(.002 *iResolution.y / iResolution.x, .002);\n    float r = 1.0;\n    vec2 vangle = vec2(0.0,radius); // Start angle\n\tfor (int j = 0; j < ITERATIONS; j++)\n    {  \n        r += 1. / r;\n\t    vangle *= rot;\n        vec4 col = texture(tex, uv + pixel * (r-1.) * vangle);\n        \n        \n        float dim = smoothstep(200.0, -1., zed-col.w);\n\t\tvec3 bokeh = (pow(col.xyz, vec3(9.0)) * 20.+1.) * dim;//..Varies depending on intensity needed..\n\t\tacc += col.xyz * bokeh;\n\t\tdiv += bokeh;\n\t}\n\treturn vec3(clamp(acc / div, 0., 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec4 v = texture(iChannel0, uv);\n    float z = min(max(v.w - 4.2, 0.01), 5.);\n\tfragColor = vec4(Bokeh(v, iChannel0, uv, z, z).rgb, 1.);\n}\n\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float Pi = 3.14159;\nconst float OneOutOfPi = 1. / Pi;\nconst float MaxFloat = uintBitsToFloat(0x7F800000u);\n\nconst vec3 SunPos = vec3(-1., 0.75, -.75) * 20.;\n\nconst float CanneleId = 1.;\nconst float CanneleTwoId = 2.;\nconst float ThinBranchesId = 3.;\nconst float LargeLeavesId = 4.;\nconst float BushId = 5.;\nconst float SpoonId = 6.;\nconst float PlateId = 7.;\nconst float PlaneId = 8.;\n\nstruct Material\n{\n    vec3 color;\n    float roughness;\n    float metalness;\n    float cc;\n    float ccRougness;\n    bool sss;\n};\n\nfloat dot2(vec3 v) {return dot(v,v);} \nfloat dot2(vec2 v) {return dot(v,v);} \n\nvec3 orthogonal(vec3 normal) \n{\n\tvec3 ref = vec3(1., 0., 0.);\n\tif (abs(dot(normal, ref)) > 1e-4)\n\t\tref = vec3(0., 1., 0.);\n    return cross(normal, ref);\n}\n\nvec2 sphericalMapping(vec3 v)\n{\n    return vec2(\n        0.5 + atan(v.x, v.z) / (2. * Pi),\n        0.5 + asin(v.y) / Pi        \n    );\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x > b.x ? b : a;\n}\n\n// Quaternion utilities from GLM source\n// License: MIT\n// Reference: https://github.com/g-truc/glm\nvec4 quat(float angle, vec3 axis) \n{\n\tfloat halfAngle = angle / 2.;\n\treturn vec4(\n\t\taxis.x * sin(halfAngle),\n\t\taxis.y * sin(halfAngle),\n\t\taxis.z * sin(halfAngle),\n\t\tcos(halfAngle)\n\t);\n}\n\n// GLM quat - vector multiplication\n// Reference: https://github.com/g-truc/glm/blob/master/glm/detail/type_quat.inl#L346\nvec3 mul(vec4 quat, vec3 point)\n{\n\tvec3 uv = cross(quat.xyz, point);\n\tvec3 uuv = cross(quat.xyz, uv);\n\treturn point + ((uv * quat.w) + uuv) * 2.;\n}\n\n// Original jFIG 2020 by haqreu, modified for 2022 edition\n// Reference: https://www.shadertoy.com/view/wsXyD8 \n#define JFIGW 32u\n#define JFIGH 12u\nconst uint[] jfigBitfield = uint[]( 0xf97800u, 0x90900u, 0xc91800u, 0x890900u, 0xf90900u, 0x180u, 0x0u, 0x38e30e0u, 0x4104900u, 0x79e49e0u, 0x824820u, 0x79e31e0u);\nbool jfig(in uint x, in uint y) {\n    uint id = x + (JFIGH-1u-y)*JFIGW;\n    if (id>=JFIGW*JFIGH) return false;\n    return 0u != (jfigBitfield[id/32u] & (1u << (id&31u)));\n}\n\n// UDN blending\n// Reference: https://google.github.io/filament/Filament.md.html#lighting/normalmapping/udnblending\nvec3 blendNormal(vec3 n, vec3 d)\n{\n    return normalize(vec3(n.xy + d.xy, n.z));\n}\n\n// SDF primitives and utilities \n// by Inigo Quilez\n// License: MIT\n// Reference: https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n  \n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    \n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    \n    return sign(d)*sqrt(abs(d))/baba;\n}\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// SDF utils from HG_SDF: A glsl library for building signed distance functions\n// by Korndrfer, Johann and Keinert, Benjamin and Ganse, Urs and Snger, Michael and Ley, Simon and Burkhardt, Konstanze and Spuler, Mario and Heusipp, Jrn\n// License: MIT\n// Reference: https://mercury.sexy/hg_sdf/\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*Pi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Hash utility from Quality hashes collection\n// by nimitz 2018 (twitter: @stormoid)\n// License: MIT\n// Modified from: iq's \"Integer Hash - III\" (https://www.shadertoy.com/view/4tXyWN)\n// Reference: https://www.shadertoy.com/view/Xt3cDn\nuint baseHash(uvec3 p)\n{\n    p = 1103515245U*((p.xyz >> 1U)^(p.yzx));\n    uint h32 = 1103515245U*((p.x^p.z)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\nuint baseHash(uint p)\n{\n    p = 1103515245U*((p >> 1U)^(p));\n    uint h32 = 1103515245U*((p)^(p>>3U));\n    return h32^(h32 >> 16);\n}\nfloat hash13(uvec3 x)\n{\n    uint n = baseHash(x);\n    return float(n)*(1.0/float(0xffffffffU));\n}\nvec3 hash33(uvec3 x)\n{\n    uint n = baseHash(x);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash31(uint x)\n{\n    uint n = baseHash(x);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n// BRDF utils\n// Main references : \n//    - Crash Course in BRDF Implementation, Jakub Boksansky\n//      Reference: https://github.com/boksajak/brdf/blob/master/brdf.h\n//    - Physically Based Rendering in Filament, Romain Guy and Mathias Agopian\n//      Reference: https://google.github.io/filament/Filament.md.html\nvec3 schlickFresnel(float cosTheta, vec3 f0)\n{\n    return f0 + (vec3(1.) - f0) * pow(1. - cosTheta, 5.);\n}\n\n// Height correlated version - optimized by substituing G_Lambda for G_Lambda_GGX and dividing by (4 * NdotL * NdotV) to cancel out \n// the terms in specular BRDF denominator\n// Source: \"Moving Frostbite to Physically Based Rendering\" by Lagarde & de Rousiers\n// Note that returned value is G2 / (4 * NdotL * NdotV) and therefore includes division by specular BRDF denominator\nfloat smithG2(float alpha2, float nl, float nv) {\n\tfloat a = nv * sqrt(alpha2 + nl * (nl - alpha2 * nl));\n\tfloat b = nl * sqrt(alpha2 + nv * (nv - alpha2 * nv));\n\treturn 0.5f / (a + b);\n}\n\nfloat ggxD(float alpha2, float nh) {\n\tfloat b = ((alpha2 - 1.) * nh * nh + 1.);\n\treturn alpha2 / (Pi * b * b);\n}\n\n// A Microfacet Based Coupled Specular-Matte BRDF Model with Importance Sampling, Csaba Kelemen\nfloat kelemenV(float cosTheta) {\n    return 0.25 / (cosTheta * cosTheta);\n}\n\n// Noise utilities\n// by Inigo Quilez\n// License: MIT\n// Reference: https://www.shadertoy.com/view/XsXfRH\nfloat shash(vec3 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\n    return -1.0+2.0*fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// return value noise (in x) and its derivatives (in yzw)\nvec4 noised( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n#if 1\n    // quintic interpolation\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n#endif    \n    \n    \n    float a = shash(i+vec3(0.0,0.0,0.0));\n    float b = shash(i+vec3(1.0,0.0,0.0));\n    float c = shash(i+vec3(0.0,1.0,0.0));\n    float d = shash(i+vec3(1.0,1.0,0.0));\n    float e = shash(i+vec3(0.0,0.0,1.0));\n\tfloat f = shash(i+vec3(1.0,0.0,1.0));\n    float g = shash(i+vec3(0.0,1.0,1.0));\n    float h = shash(i+vec3(1.0,1.0,1.0));\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\n// Ref: https://www.shadertoy.com/view/llXyWr\nvec3 Tonemap_ACES(vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n", "buffer_a_code": "vec2 sdCannele(vec3 p)\n{\n    // Body\n    float d = sdCappedCone(p - vec3(0., 0.35, 0.), 0.4, 0.4, 0.35) - 0.09;\n    \n    // Top cap cavity\n    d = opSmoothSubtraction( length(p - vec3(0., 0.85, 0.)) - 0.15, d, 0.1 );\n\n    // Contours\n    vec3 q = p;\n    pModPolar(q.xz, 12.);\n    vec3 a = vec3(0.35, 0.8, 0.);\n    vec3 b = a - vec3(-0.13, 0.8, 0.);\n    d = opSmoothUnion(sdCapsule(q, a, b, 0.08), d, 0.1);\n    \n    // Stars texture as displacement taken from Hamneggs's shader \n    // Reference: https://www.shadertoy.com/view/ls2GDw\n    vec2 uv = sphericalMapping(p);\n    d += float(length(p.xz) > 0.15) * .008 * texture(iChannel0, uv).r;\n\n    return vec2(d, CanneleId); \n}\n\nfloat sdThinBranch(vec3 p, vec3 start, vec3 end)\n{\n    const float width = 0.005;\n    float t = sdCapsule( p, start, end, width );\n    vec3  d = end - start;\n    float l = length(d);\n    d /= l;\n    \n    vec3 v = normalize(orthogonal(d) + d);\n    \n    // Random density from p\n    float s = 1. - hash13(floatBitsToUint(start + floor(p + fract(p) * 100.) + end));\n    v = mod(floor(s * 10.), 2.) == 1. ? v : reflect(-v, d);\n\n    vec3 send = start + d * s * l + v * l * smoothstep(1.5, -2.5, s) * .5;\n    t = min(t, length(send - p) - 0.1);\n    \n    return t;\n}\n\nvec2 sdThinBranches(vec3 p)\n{\n    float d =  sdThinBranch(p, vec3(1.95, -0.1, 1.95), vec3(-.4,  -0., 1.3));\n    d = min(d, sdThinBranch(p, vec3(2.05, -0.1, 1.95), vec3(-.2,   0., 1.1)));\n    d = min(d, sdThinBranch(p, vec3(2.05,  0.,  1.95), vec3(-.6,   0., 0.9)));\n    return vec2(d, ThinBranchesId);\n}\n\nvec2 sdLargerBranches(vec3 p)\n{\n    float d = sdThinBranch( p, vec3(2.7, 0., 1.05), vec3(1.,  0.01,  -0.6));\n    d = min(d, sdThinBranch( p, vec3(2.1, 0., 0.9), vec3(.8,  0.05,  -0.7) ));\n    return vec2(d, ThinBranchesId);\n}\n\nvec2 sdLargeLeaves(vec3 p)\n{\n    vec3 c = vec3(2.5, .3, 1.45);\n    vec3 r = vec3(1.5, .9, 2.2);\n    \n    // Bounding shape \n    float d = sdEllipsoid(p - c, r);\n    if(d < 0.01)\n    {\n        // Random density from p\n        vec3 s = hash33(uvec3(floor(p + fract(p) * 25.))) * 2. - 1.;\n        vec3 pp = c + s * r;\n        d = length(pp - p) - 1.4;\n    }\n        \n    return vec2(d, LargeLeavesId);\n}\n\nvec2 sdBush(vec3 p)\n{ \n    vec3 c = vec3(2.3,  0.,  -1.35);\n    vec3 r = vec3(0.95, 1.5, 2.);\n    \n    // Bounding shape \n    float d = sdEllipsoid(p - c, r);\n    if(d < 0.01)\n    {\n        // Random density from p\n        vec3 s = hash33(floatBitsToUint(floor(p + fract(p) * 25.))) * 2. - 1.;\n        vec3 pp = c + s * r;\n        d = length(pp - p) - 1.3;\n    }\n    \n    return vec2(d, BushId);\n}\n\nvec2 sdSpoon(vec3 p)\n{\n    vec3 spoonCup = vec3(0., 0.3, -1.14);\n    float d = sdCutHollowSphere(p - spoonCup, 0.35, -0.2, 0.008);\n    \n    vec3 spoonStart = vec3(0.2, 0.1, -0.94);\n    vec3 spoonDir = (spoonStart - spoonCup) * vec3(1., .25, 1.);\n    return vec2(min(d, sdCapsule(p, spoonStart- vec3(0., .05, 0.), spoonStart + spoonDir * 4., 0.025)), SpoonId);\n}\n\nvec2 sdPlate(vec3 p)\n{\n    vec3 plateCenter = vec3(0.1, -0.25, 0.);\n    vec3 q = p;\n    float d = sdCylinder(q, plateCenter, plateCenter + vec3(0., 1., 0.) * .15, 1.3);\n    return vec2(d, PlateId);\n}\n\nfloat sdJfig(vec3 p)\n{\n    const float side = .08;\n    const float radius = 2.;\n\n    float d = sdBox(p, vec3(side, float(JFIGH) * side, float(JFIGW) * side * .5));\n    if(d < 0.1)\n    {\n        vec2 gridCoordinates = floor((p.yz / side)) + vec2(0., float(JFIGW) * .5);\n\n        // Test neighborhood of the point. Since we already know\n        // it's in the bounding shape, we can assert a minimum\n        // distance to the bitfield\n        d = side * radius;\n        \n        for(float i = -radius; i <= radius; i++)\n        {\n            for(float j = -radius; j <= radius; j++)\n            {\n                float x = i + gridCoordinates.y;\n                float y = j + gridCoordinates.x;\n\n                if(!jfig(uint(x), uint(y))) continue;\n                \n                float db = sdBox(p - vec3(0., y, x - float(JFIGW) * .5) * side, vec3(side) * .5);\n                \n                // Makes the letters more cake alike\n                db -= .04;\n                \n                d = min(d, db);\n            }\n        }\n    }\n    \n    return d;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 d = opU(sdCannele(p), vec2(sdCannele(p + vec3(-0.6, 0., -0.8)).x, CanneleTwoId));\n    \n    // Morphing animation \n    float t = smoothstep(.6, .8, clamp((sin(iTime * .5) + 1.) * .5, 0., 1.));\n    \n    // Align canneles and logo\n    vec3 q = p - vec3(.2, .0, .2);\n    pR(q.xz, -Pi * .08);\n\n    // The morphing between JFIG logo and both canneles\n    // This idea comes from the \"Morphing\" shader by iapafoto \n    // Reference: https://www.shadertoy.com/view/MslSDN\n    d.x = mix(d.x, sdJfig(q), t);\n\n    // Static parts of the scene\n    d = opU(d, sdSpoon(p));\n    d = opU(d, sdPlate(p));\n    d = opU(d, vec2(sdPlane(p + vec3(0., 0.35, 0.), vec3(0., 1., 0.), 0. ), PlaneId));\n    \n    d = opU(d, sdThinBranches(p));\n    \n    q = p - vec3(.2, 0., -.4);\n    pR(q.xz, Pi * .05);\n    d = opU(d, sdLargeLeaves(q));\n    d = opU(d, sdLargerBranches(p));\n    \n    q = p - vec3(.2, 0., .2);\n    pR(q.xz, -Pi * .2);\n    d = opU(d, sdBush(q));\n    \n    return d;\n}\n\n// Map normal estimation\n// by Inigo Quilez\n// Reference: https://iquilezles.org/articles/normalsSDF\nvec3 norm(vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ).x );\n}\n\n// Softshadow approximation \n// by Inigo Quilez and Sebastian Aaltonen\n// Reference: https://iquilezles.org/articles/rmshadows/\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<1e-3 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += max(abs(h), 1e-4);\n    }\n    return res;\n}\n\n// Fast Approximations for lighting of Fast Approximations for lighting of Dynamic Scene, - Page 44, \n// By Alex Evans\n// Reference: http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2012/10/Evans-Fast_Approximations_for_Lighting_of_Dynamic_Scenes-print.pdf\n// The Cornell Box, by h3r3\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Reference: https://www.shadertoy.com/view/4ssGzS\nfloat ao(in vec3 ro, in vec3 n)\n{\n    float a = 0.;\n    const float stepCount = 2.;\n    for(float i = 0.; i < stepCount; i++)\n    {\n        float d = shash(ro + fract(ro) * i) * .5 + 1.;\n        a += max(0., (d - map(ro + n * d).x) / d);\n    }\n    return clamp(1. - a / stepCount, 0., 1.);\n}\n\n// GDC 2011  Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look\n// by Colin Barr-Brisebois\n// Reference: https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/\n// Other references: \n//     - Everyday004 - MysteryPyramid by Makio64: https://www.shadertoy.com/view/Mdt3zs\n//     - LocalThickness by ZigguratVertigo      : https://www.shadertoy.com/view/ldGGzR\nfloat thickness(in vec3 ro, in vec3 n)\n{\n    float a = 0.;\n    const float stepCount = 1.;\n    for(float i = 0.; i < stepCount; i++)\n    {\n        float d = (shash(ro + fract(ro) * i) * .5 + 1.) * .5;\n        a += max(0., (d + map(ro - n * d).x) / d);\n    }\n    return clamp(1. - a / stepCount, 0., 1.);\n}\nvec3 sss(vec3 p, vec3 n, Material material)\n{\n    float localThickness = thickness(p, n);\n    return material.color * localThickness;\n}\n\nMaterial getMaterial(float id, vec3 p, inout vec3 n)\n{\n    if(id == CanneleId || id == CanneleTwoId)\n    {\n        if(id == CanneleTwoId)\n            p += vec3(-0.6, 0., -0.8);\n    \n        vec2 uv = sphericalMapping(normalize(p));\n        \n        float rnd = noised( p * 5.).x;\n\n        // Strips\n        float stripVariations = rnd;\n        float a = mod(acos(dot(normalize(p.xz), vec2(1., 0.))), Pi / 6.);\n        \n        float strip = smoothstep(\n            0., 2., \n            (abs(a * 10. - 2.5) * .4 // The actual strip\n            + smoothstep(0., 1., abs(p.y - .55) * 1.2)) // Emphasize middle part of the cake\n            * abs(shash(vec3(floor(uv), floor(uv.x) * floor(uv.y)))) // Variations\n        );\n\n        // Center hole\n        float center = clamp(mix(1., 0., length(p.xz) * 3.), 0., 1.);\n        \n        strip += smoothstep(-.3, .7, center);\n        strip = clamp(strip*strip, 0., 1.);\n        vec3 color = mix(vec3(0.098,0.024,0.004), vec3(0.396,0.102,0.004), vec3(strip));\n        \n        // Highlight center hole\n        vec3 lighter = vec3(0.341,0.157,0.000);\n        color = mix(color, lighter, smoothstep(.6, .8, center) );\n        \n        // Increase small scale details \n        n = blendNormal(n, .1 * noised( p * 200. ).yzw);\n        \n        return Material(color, .1 + 0.2 * strip, 0., 1., 0.1, true);\n    }\n    else if(id == ThinBranchesId)\n    {\n        return Material(vec3(0.447,0.216,0.216), 1., 0., 0., 0., false);\n    }\n    else if(id == LargeLeavesId)\n    {\n        return Material(vec3(0.867,0.235,0.455), 1., 0., 0., 0., false);\n    }\n    else if(id == BushId)\n    {\n        return Material(vec3(0.000,0.600,0.169),1., 0., 0., 0., false);\n    }\n    else if(id == SpoonId)\n    {\n        // Add small scale details with the rusty texture\n        vec2 uv = sphericalMapping(n);\n        vec3 rust = texture(iChannel3, uv).rgb;\n        vec3 color = mix(vec3(0.910,0.592,0.231), rust, .55);\n        \n        return Material(color, 0.5, 1., 0., 0., false);\n    }\n    else if(id == PlateId)\n    {\n        const vec3 side = vec3(1.000,0.945,0.898);\n        const vec3 inside = vec3(0.957,0.761,0.604);\n\n        // Inner pattern as a circular sine\n        float d = length(p.xz);\n        vec3 insidePattern = mix(inside, inside - .4, vec3(abs(sin(d * 20.)) / 19.));\n        \n        // intensity variations\n        insidePattern += .08 * shash(p * 15.) * sin(length(p.xz) * 100.); \n\n        vec3 color = mix(insidePattern, side, vec3(d > 1.1));\n        return Material(color, 1., 0., 0., 0., false);\n    }\n    \n    return Material(vec3(1. - .3*noised( p * vec3(150., 1., 15.)).x), .1, 0., 0., 0., false);\n}\n\nvec3 shade(vec3 p, vec3 v, vec3 n, vec3 l, Material material)\n{\n    vec3 h = normalize(v + l);\n\n    float alpha = max(material.roughness * material.roughness, 1e-2);\n    float alpha2 = alpha * alpha;\n\n    float lh = clamp(dot(l, h), 0.,   1.);\n    float nh = clamp(dot(n, h), 0.,   1.);\n    float nl = clamp(dot(n, l), 1e-2, 1.);\n    float nv = abs(dot(n, v));\n    \n    vec3 diffuseColor = material.color * (1. - material.metalness);\n    vec3 f0 = mix(vec3(0.04), material.color, material.metalness);\n    vec3 f = schlickFresnel(lh, f0);\n    \n    vec3 diffuse = diffuseColor * OneOutOfPi * nl;\n    \n    float g = smithG2(alpha2, nl, nv);\n    float d = ggxD(alpha2, nh);\n    vec3 specular = g * d * nl * f;\n\n    material.ccRougness = clamp(material.ccRougness, 0.089, 1.0);\n    float ccAlpha = material.ccRougness * material.ccRougness;\n\n    // Clearcoat as achieved in Filament\n    // Reference: https://google.github.io/filament/Filament.md.html#materialsystem/clearcoatmodel/clearcoatspecularbrdf\n    float dc = ggxD(ccAlpha, nh);\n    float vc = kelemenV(lh);\n    vec3 fc = f * material.cc;\n    vec3 frc = dc * vc * fc;\n\n    vec3 obj = (diffuse + specular * (1.0 - fc)) * (1.0 - fc) + frc;\n\n    // Roughness reflection inspired by \n    // [ConcoursJFIG2021] IBL by xavierchermain\n    // Reference: https://www.shadertoy.com/view/ftt3RH\n    // and\n    // Physically based rendering by TDM\n    // Reference: https://www.shadertoy.com/view/XsfXWX\n    vec3 r = reflect(-v, n);\n    vec3 specularReflection = texture(iChannel1, r, material.roughness * 6.).rgb;\n    obj = mix(obj, f * specularReflection, 0.05 + 0.1 * material.metalness);\n    \n    return obj;\n}\n\nvec3 tonemap(vec3 v)\n{\n    return pow(Tonemap_ACES(v.rgb), 1. / vec3(2.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord+.5-iResolution.xy*0.5)/iResolution.y;\n    uv.y = -uv.y;\n    \n    vec3 ro      = vec3(iMouse.z > 1e-4f ? iMouse.y * 1e-2 : -3.8, (iMouse.z > 1e-4f ? 0. : cos(iTime) * .5) +  2.85, 0.);\n    vec3 forward = normalize(vec3(0., 0.5, 0.) - ro);\n    vec3 right   = normalize(cross(forward, vec3(0., 1., 0.)));\n    vec3 up      = normalize(cross(forward, right));\n    vec3 rd      = mat3( right, up, forward ) * normalize(vec3(uv, tan(Pi * .75 / 2.)));\n    \n    float xStep = iMouse.z > 1e-4f ? (iMouse.x / iResolution.x) * 2. * Pi : sin(iTime) * Pi * .08;\n    vec4 q = quat(xStep, vec3(0., 1., 0.)); ro = mul(q, ro), rd = mul(q, rd);\n\n    float t = 0.;\n    vec3 p;\n    vec2 hitInfo = vec2(MaxFloat);\n    bool hit = false;\n    \n    const float tMax = 7.5;\n    for(int i = 0; !hit && i < 75 && t < tMax; i++)\n    {\n        hitInfo = map(p = ro + rd * t);\n        t += max(abs(hitInfo.x), 1e-3);\n        hit = hitInfo.x <= 5e-3; \n    }\n    \n    fragColor.rgb = texture(iChannel1, rd).rgb;\n    if(hit)\n    {        \n        vec3 n = norm(p);\n        n = sign(dot(n, -rd)) * n;\n        \n        vec3 lSun = normalize(SunPos - p);\n        vec3 lIndirect = normalize(vec3(-1.5, .5, 1.5) * 20. - p);\n        \n        vec3 v = -rd;\n        \n        Material material = getMaterial(hitInfo.y, p, n);\n        vec3 obj = shade(p, v, n, lSun, material);\n        obj     += shade(p, v, n, lIndirect, material);\n        \n        // Lightning combination as described in Outdoors lighting\n        // by Inigo Quilez\n        // Reference: https://iquilezles.org/articles/outdoorslighting/\n        vec3 occlusion = vec3(max(.4, ao(p, n)));\n        vec3 shadow = pow(vec3(softshadow(p, lSun, 1e-1, .8, 4.)), vec3(1.0, 1.3, 1.6));\n        \n        float nlSun = clamp(dot(n, lSun), 0., 1.);\n        vec3 sun = nlSun * (vec3(1.000,0.969,0.941) * 5. ) * shadow;\n        float nlIndirect = clamp(dot( n, lIndirect ), 0.0, 1.0);\n        vec3 ind = nlIndirect * (vec3(0.859,1.000,0.996) * 3. ) * occlusion;\n\n        vec3 diffuse = material.color * OneOutOfPi * (nlSun + nlIndirect);\n        if(material.sss)\n        {\n            vec3 subsurface = sss(p, n, material);\n            obj += diffuse * subsurface * (sun + ind) * 2.;\n        }\n        \n        fragColor.rgb = obj * (sun  + ind);\n    }\n    \n    fragColor.rgb = clamp(tonemap(fragColor.rgb), 1e-3, 1.);\n    fragColor.w = t;\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void load( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    // Contribution from last frame to lower spatial instability\n    fragColor = mix(fragColor, texture(iChannel1, fragCoord / iResolution.xy), float(iFrame > 0 ) * .5);\n}\n\n// Anti-aliasing By Fabrice Neyret\n// === easy adaptive sampling. === https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n//                           more: https://www.shadertoy.com/results?query=easy+adaptive+sampling\nvoid mainImage(out vec4 O, vec2 U) {\n    load(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { load(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n      //O.r++;                        // uncomment to see where the oversampling occurs\n    }\n    O = vec4(O);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 93, 165, 215, 965], [967, 967, 1024, 1024, 1209]], "test": "untested"}
{"id": "dslGR2", "name": "Voxel Land.", "author": "thepinkpanzer", "description": "Implementation of parallax occlusion mapping to create a land of vaguely metallic cubes. It's slow and leaves lots of artefacts but here we are.", "tags": ["raymarching", "voxel", "bloom"], "likes": 2, "viewed": 287, "published": 3, "date": "1666464221", "time_retrieved": "2024-07-30T16:25:17.194684", "image_code": "#define D(p) texture(iChannel0, ((p)/iResolution.xy))\n#define A(p) texture(iChannel1, ((p)/iResolution.xy))\n\nvec4 GB(vec2 fc)\n{\n    vec4 t = vec4(0);\n    for (float x = -2.*SIGMA; x <= 2.*SIGMA; x++)\n    {\n        float N = 1./sqrt(2.*PI*SIGMA*SIGMA);\n        t += R(fc+vec2(x,0.)) * N * exp(-0.5*(float(x*x)/(SIGMA*SIGMA)));\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 gb = GB(fragCoord);\n    fragColor = tanh(0.6*gb*gb + 0.8*A(fragCoord));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define T(p) texture(iChannel0, round((p) * 64.)/64.).r\n\n#define NSAMPLES 1000\n#define NBINARY 6\n\n#define GRIDSCALE 16.\n\n#define MINDEPTH 0.2\n#define MAXDEPTH 0.8\n\n#define MAXJUMP 0.02\n\n#define BINSTART 0.02\n\nfloat r(float i, float l)\n{\n    return fract(i*(l-i));\n}\n\nfloat hash(float seed)\n{\n    return r(r(r(seed, 5.), 5.), 5.);\n}\n\nstruct surface\n{\n    vec3 normal;\n    float smoothness;\n    vec4 color;\n    vec4 on;\n};\n\nfloat height(vec3 position)\n{\n    vec2 newCoords = position.xz;\n    newCoords = fract(newCoords / GRIDSCALE);\n    float height = T(newCoords);\n    height = clamp(height, 0., 1.);\n    float f = 2. + 0.5 * hash(height);\n    float t = hash(f - 0.5);\n    height *= (0.5 + 9./16.*(cos(iTime * f + t*PI) + 1./9. * cos(3.*(iTime*f + t*PI))));\n    return height*(MAXDEPTH - MINDEPTH) + MINDEPTH;\n}\n\nsurface GetSurface(vec3 position, vec3 iViewDirection)\n{\n    vec2 newCoords = position.xz;\n    newCoords = fract(newCoords * 64. / GRIDSCALE);\n        \n    vec3 normal = vec3(0,1,0) * sign(iViewDirection.g);\n    \n    if (abs(newCoords.x - 0.5) < 0.012)\n    {\n        if (height(position + vec3(0.012,0,0)) < height(position - vec3(0.012,0,0)))\n        {\n            position = position + vec3(0.1,0,0);\n            normal = vec3(1,0,0);\n        }\n        else\n        {\n            position = position - vec3(0.1,0,0);\n            normal = vec3(-1,0,0);\n        }\n    }\n    if (abs(newCoords.y - 0.5) < 0.012)\n    {\n        if (height(position + vec3(0,0,0.012)) < height(position - vec3(0,0,0.012)))\n        {\n            position = position + vec3(0,0,0.1);\n            normal = vec3(0,0,1);\n        }\n        else\n        {\n            position = position - vec3(0,0,0.1);\n            normal = vec3(0,0,-1);\n        }\n    }\n    \n    newCoords = position.xz;\n    newCoords = fract(newCoords / GRIDSCALE);\n    \n    float smoothness = 0.4 + 0.2*hash(T(newCoords));\n    \n    vec4 color = vec4(0.4 + 0.2*hash(T(newCoords)+0.1))+0.2*vec4(0,0.1,0.4,1)*hash(T(newCoords)-0.1);\n    \n    vec4 on = hash(smoothness+0.1) < 0.03 ? normalize(vec4(hash(color.r), hash(color.g), hash(color.b),0)) : vec4(0);\n    \n    return surface(normal, smoothness, color, on);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fCoord )\n{\n    vec2 fragCoord = fCoord + 0.5 - 0.5*hash(fract(length(fCoord)+tan(iTime)));\n    float theta = (iMouse.x - iResolution.x / 2.) / iResolution.y * PI;\n    float phi   = (iMouse.y - iResolution.y / 2.) / iResolution.y * PI;\n\n    // CAMERA\n    vec3 iCameraFwd     = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\n    vec3 iCameraUp      = vec3(-sin(theta)*sin(phi),cos(phi),-cos(theta)*sin(phi));\n    vec3 iCameraRight   = normalize(cross(iCameraUp, iCameraFwd));\n    \n    vec3 iCameraPosition      = vec3(0,0,0);\n    \n    float m = 2.0;\n    \n    vec3 iViewDirection = iCameraFwd + ((fragCoord.x - iResolution.x/2.0) * iCameraRight + (fragCoord.y - iResolution.y/2.0) * iCameraUp) / iResolution.x * m;\n    iViewDirection      = normalize(iViewDirection);\n    \n    // Now we MARCH!\n    bool entered = false;\n    float firstEntry = 0.;\n    \n    float jumpDist = min((MAXDEPTH - MINDEPTH)/float(NSAMPLES)/abs(iViewDirection.g), MAXJUMP);\n    vec3 jumpVec = jumpDist * iViewDirection;\n    \n    float dist = MINDEPTH/abs(iViewDirection.g);\n    vec3 position = dist * iViewDirection + iCameraPosition;\n    \n    for (int n = 0; n < NSAMPLES; n++)\n    {\n        if (height(position) <= abs(position.g) && !entered)\n        {\n            firstEntry = dist;\n            entered = true;\n        }\n        dist += jumpDist;\n        position += jumpVec;\n    }\n    \n    jumpDist = BINSTART;\n    jumpVec  = iViewDirection;\n    \n    position = firstEntry * iViewDirection + iCameraPosition;\n    \n    for (int n = 0; n < NBINARY; n++)\n    {\n        bool inside1 = height(position - jumpVec * jumpDist / 2.) <= abs(position.g - jumpVec * jumpDist / 2.).g;\n        bool inside2 = height(position + jumpVec * jumpDist / 2.) <= abs(position.g + jumpVec * jumpDist / 2.).g;\n        \n        if (inside1 && inside2)\n        {\n            position -= jumpDist * jumpVec;\n            firstEntry -= jumpDist;\n        }\n        if (!inside1 && !inside2)\n        {\n            position += jumpDist * jumpVec;\n            firstEntry += jumpDist;\n        }\n        \n        jumpDist /= 2.;\n    }\n    \n    surface iCurrentSurface = GetSurface(position, iViewDirection);\n    \n    vec3 iSunDirection = normalize(vec3(1,0,1));\n    \n    fragColor  = vec4(0);\n    fragColor += iCurrentSurface.color * (0.4 + 0.6*max(0.,dot(iCurrentSurface.normal, iSunDirection)));\n    fragColor += iCurrentSurface.color * iCurrentSurface.color * exp((6./(1.-iCurrentSurface.smoothness))*(-1. - dot(reflect(iViewDirection, iCurrentSurface.normal), iSunDirection)))*(1.+dot(iCurrentSurface.normal, iSunDirection))*17.*iCurrentSurface.smoothness;\n    \n    fragColor = iCurrentSurface.on != vec4(0) ? (iCurrentSurface.on+vec4(0.2))*5. : fragColor;\n    \n    float t = exp(-firstEntry / 3.);\n    \n    fragColor = entered ? t*fragColor + (1.-t)*vec4(0.2 + 2.*exp(30.*(-1. - dot(iViewDirection, iSunDirection)))) : vec4(0.2 + 2.*exp(30.*(-1. - dot(iViewDirection, iSunDirection))));\n}", "buffer_a_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "vec4 GB(vec2 fc)\n{\n    vec4 t = vec4(0);\n    for (float y = -3.*SIGMA; y <= 3.*SIGMA; y++)\n    {\n        float N = 1./sqrt(2.*PI*SIGMA*SIGMA);\n        t += R(fc+vec2(0.,y)) * N * exp(-0.5*(float(y*y)/(SIGMA*SIGMA)));\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = GB(fragCoord);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R(p) texture(iChannel0,(p)/iResolution.xy)\n#define PI 3.1415926\n#define SIGMA 28.", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dslGR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[349, 349, 406, 406, 489]], "test": "untested"}
{"id": "NtVfzd", "name": "Rekursive Rubik's [TRSAC22]", "author": "robin_be", "description": "released at TRSAC, largely partycoded while sleep deprived and experiencing vertigo from the journey\ntowards the party :D\n\nOriginally written in GLSL, adapted for GLSLES/ShaderToy\n\ncompile time and performance is kinda very bad", "tags": ["raymarching"], "likes": 9, "viewed": 301, "published": 3, "date": "1666461401", "time_retrieved": "2024-07-30T16:25:18.198002", "image_code": "/*\nThe code started nice[citation needed], but quickly\nwent to shit when deadline stress increased and quick hacks were written. Also\ndoesn't help to be sleep deprived and experiencing vertigo from the journey\ntowards the party :D\n\nOriginally written in GLSL and now adapted to work with GLSL ES in ShaderToy,\noriginal source: https://github.com/yugecin/kube\n*/\n\n#define shadertoy 1\n#define debugmov 0 //noexport\n#if shadertoy == 0\n#define iTime fpar[0].x\nlayout (location=0) uniform vec4 fpar[2];\nlayout (location=2) uniform vec4 debug[2]; //noexport\n#endif\n#define PI 3.14159265359\n#define HALFPI 1.5707963268\n#define _x_ 0 /*'___' : macro name with a double underscore is reserved - unintented behavior is possible*/\n#define RED 1\n#define BLU 2\n#define GRN 3\n#define YLW 4\n#define WHI 5\n#define ORG 6\n#define SHA 7\nvec3 COLORS[8];\nint i;\nfloat gRounding, gSide, gUnit, gOffsetStuff;\nconst float ROUNDING = 2.5;\nconst float SIDE = 12. - ROUNDING;\nconst float UNIT = SIDE * 2. + 2. * ROUNDING;\nconst float SPACING = UNIT;\nconst vec3 off = vec3(0, SPACING, -SPACING);\nconst vec4 rot = vec4(0, HALFPI, -HALFPI, PI);\nvec3 gHitPosition = vec3(0);\nvec3 gCubeOff[26];\nvec3 gCubeRot[26];\nint gCubeCol0[26], gCubeCol1[26], gCubeCol2[26];\nfloat gCubeOpacity[26];\nbool gCubeHidden[26];\nint gHitIndex = 0;\nint gExclusiveCube = -1; // if set, only that cube will be considered.\n                         //useful for consecutive map() calls for lighting after we already know what cube gets hit\n#define F 0 // front\n#define L 2 // left\n#define R 4 // right\n#define U 6 // up\n#define D 8 // down\n#define B 10 // back\nconst int gNumMovements = 12;\nint gMovements[gNumMovements];\nint gCurrentMovement;\nfloat gCurrentMovementProgress = 0.;\nconst float MOVEMENT_TIME_SECONDS = .3;\nconst float HIDE_TIME_SECONDS = .2;\nconst float FADE_TIME_SECONDS = .4;\nint gCubeHiddenOrder[25];\nbool gHackFadeStuff;\nbool gShaft;\nfloat gTimeMod;\n\nmat2 rot2(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\n\nvec2 oneSidedCube(vec3 p, int cubeIndex)\n{\n\tvec2 mc = vec2(length(max(abs(p) - gSide, 0.)) - gRounding, 0);\n\tfloat tc = length(max(abs(p + vec3(0., 0., gRounding + .02)) - gSide, 0.));\n\n\treturn mc.x < tc ? mc : vec2(tc, float(gCubeCol0[cubeIndex]));\n}\n\nvec2 twoSidedCube(vec3 p, int cubeIndex)\n{\n\tvec2 mc = oneSidedCube(p, cubeIndex);\n\tfloat fc = length(max(abs(p + vec3(0, -gRounding - .02, 0.)) - gSide, 0.));\n\n\treturn mc.x < fc ? mc : vec2(fc, float(gCubeCol1[cubeIndex]));\n}\n\n// also includes the shaft\nvec2 centerCube(vec3 p, int cubeIndex)\n{\n\tvec2\tmc = oneSidedCube(p, cubeIndex),\n\t\tsh = vec2(max(length(p.xy)-gUnit/4., length(max(abs(p-vec3(0.,0.,gUnit*.375)) - gUnit*.75, 0.))), 7);\n\t\n\tmc.x = max(mc.x, -(length(p+vec3(0.,0.,-gUnit))-gUnit*1.2));\n\treturn mc.x < sh.x || !gShaft ? mc : sh;\n}\n\nvec2 middleCube(vec3 p, int cubeIndex)\n{\n\tvec2 res = twoSidedCube(p, cubeIndex);\n\tres.x = max(res.x, -(length(p+vec3(0., 62., -62.))-80.));\n\tres.x = min(res.x, length(max(abs(p - vec3(0., -7., 7.)) - vec3(7., 9., 9.), 0.)));\n\treturn res;\n}\n\nvec2 cornerCube(vec3 p, int cubeIndex)\n{\n\tvec2 mc = twoSidedCube(p, cubeIndex);\n\tfloat sc = length(max(abs(p + vec3(-gRounding - .02, 0., 0.)) - gSide, 0.));\n\n\tif (sc < mc.x) mc = vec2(sc, float(gCubeCol2[cubeIndex]));\n\tvec3 cubepos = p + vec3(9., 9., -9.);\n\tfloat bit = max(length(max(abs(cubepos) - vec3(7.), 0.)), length(p+vec3(gUnit,gUnit,-gUnit))-gUnit*1.18);\n\tmc.x = min(mc.x, bit);\n\treturn mc;\n}\n\nvec2 map(vec3 p)\n{\n\tfloat tt = clamp(gTimeMod / 9., 0., 1.) * PI * 2.;\n\tp.xy *= rot2(tt * .9 + PI * 2. * .1);\n\tif (gTimeMod >= 9.) {\n\t\tp.xy *= rot2(PI * 2. * .1 * clamp(gTimeMod - 9., 0., 1.));\n\t}\n\t//p.zy *= rot2(tt);\n\tfloat boundingbox = length(max(abs(p) - vec3(gUnit * 2.1), 0.));\n\tif (boundingbox > .1) {\n\t\treturn vec2(boundingbox, 0.);\n\t}\n\tvec2 res = vec2(9e9, 0.);\n\tfor (i = 0; i < 26; i++) {\n\t\tif (gCubeHidden[i] || (gExclusiveCube != -1 && gExclusiveCube != i)) {\n\t\t\tcontinue;\n\t\t}\n\t\tvec3 offset = gCubeOff[i];\n\t\tvec2 cub;\n\t\tvec3 pa = p;\n\t\tswitch (gCurrentMovement) {\n\t\tcase F:\n\t\t\tif (offset.y == off.y) {\n\t\t\t\tpa.xz *= rot2(HALFPI * gCurrentMovementProgress);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase L:\n\t\t\tif (offset.x == off.z) {\n\t\t\t\tpa.yz *= rot2(HALFPI * gCurrentMovementProgress);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R:\n\t\t\tif (offset.x == off.y) {\n\t\t\t\tpa.zy *= rot2(HALFPI * gCurrentMovementProgress);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase B:\n\t\t\tif (offset.y == off.z) {\n\t\t\t\tpa.zx *= rot2(HALFPI * gCurrentMovementProgress);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase U:\n\t\t\tif (offset.z == off.z) {\n\t\t\t\tpa.xy *= rot2(HALFPI * gCurrentMovementProgress);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase D:\n\t\t\tif (offset.z == off.y) {\n\t\t\t\tpa.yx *= rot2(HALFPI * gCurrentMovementProgress);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\tif (offset.x == off.z) {\n\t\t\tpa.yz *= rot2(gTimeMod);\n\t\t}\n\t\tif (offset.x == off.y) {\n\t\t\tpa.yz *= rot2(-gTimeMod);\n\t\t}\n\t\tif (offset.x == off.x) {\n\t\t\tpa.yz *= rot2(-gTimeMod * 0.8);\n\t\t}\n\t\tif (offset.y == off.z) {\n\t\t\t//pa.xz *= rot2(gTimeMod);\n\t\t}\n\t\tif (\n\t\t\t!(offset.x == 0. && offset.y == 0.) &&\n\t\t\t!(offset.x == 0. && offset.z == 0.) &&\n\t\t\t!(offset.y == 0. && offset.z == 0.)\n\t\t) {\n\t\t\toffset *= sin(gTimeMod) + 2.;\n\t\t}\n\t\t*/\n\t\tpa -= offset * gOffsetStuff;\n\t\tpa.xy *= rot2(gCubeRot[i].x);\n\t\tpa.yz *= rot2(gCubeRot[i].y);\n\t\tpa.xz *= rot2(gCubeRot[i].z);\n\t\tif (gCubeCol1[i] == _x_) {\n\t\t\tfloat boundingbox = length(max(abs(pa - vec3(0., 0., gUnit * .36)) - vec3(gUnit * .55, gUnit * .55, gUnit * .9), 0.));\n\t\t\tcub = boundingbox < .1 ? centerCube(pa, i) : vec2(boundingbox, 0.);\n\t\t} else if (gCubeCol2[i] == _x_) {\n\t\t\tfloat boundingbox = length(max(abs(pa) - vec3(gUnit * .7), 0.));\n\t\t\tcub = boundingbox < .1 ? middleCube(pa, i) : vec2(boundingbox, 0.);\n\t\t} else {\n\t\t\tfloat boundingbox = length(max(abs(pa) - vec3(gUnit * .7), 0.));\n\t\t\tcub = boundingbox < .1 ? cornerCube(pa, i) : vec2(boundingbox, 0.);\n\t\t}\n\t\tif (cub.x < res.x) {\n\t\t\tres = cub;\n\t\t\tgHitIndex = i;\n\t\t}\n\t}\n\treturn res;\n}\n\nvec3 norm(vec3 p, float dist_to_p)\n{\n\tvec2 e = vec2(.001, 0);\n\treturn normalize(dist_to_p - vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\n// x=hit y=dist_to_p z=dist_to_ro w=material(if hit)\nvec4 march(vec3 ro, vec3 rd, int maxSteps)\n{\n\tvec4 r = vec4(0);\n\tfor (i = 0; i < maxSteps && r.z < 350.; i++){\n\t\tgHitPosition = ro + rd * r.z;\n\n\t\t//p.y += 100.;\n\t\t//p.z -= 10.;\n\t\t//p.yz *= rot2(-.9);\n\t\t//p = mod(p, 30.) - 15.;\n\t\t//p.xy *= rot2(gTimeMod/2.);\n\t\t//p.yz *= rot2(gTimeMod/3.);\n\t\t//p.xz*=rot2(sin(p.z*0.2)*0.2+gTimeMod);\n\t\tvec2 m = map(gHitPosition);\n\t\tfloat distance = m.x;\n\t\tif (distance < .03) {\n\t\t\tr.x = 1.;\n\t\t\tr.y = distance;\n\t\t\tr.w = m.y;\n\t\t\tbreak;\n\t\t}\n\t\tr.z += distance;\n\t}\n\treturn r;\n}\n\nvec3 colorHit(vec4 result, vec3 rd)\n{\n\tgExclusiveCube = gHitIndex;\n\tvec3 shade = vec3(0);\n\tint material = int(result.w);\n\tif (0 <= material && material <= 7) {\n\t\tshade = COLORS[material];\n\t}\n\tvec3 normal = norm(gHitPosition, result.y);\n\t// coloring magic from https://www.shadertoy.com/view/sdVczz\n\tfloat diffuse = max(0., dot(normal, -rd));\n\tfloat fresnel = pow(1. + dot(normal, rd), 4.);\n\tfloat specular = pow(max(dot(reflect(rd, normal), -rd), 0.), 30.);\n\n\t// we could not do ambient occlusion and save map() call for more performance\n\t//float ambientOcc = clamp(map(gHitPosition + normal * .05).x / .05, 0., 1.);\n\tfloat ambientOcc = .9; // .9 on purpose, because it's brighter and looks slighty better\n\n\tfloat scat = smoothstep(0., 1., map(gHitPosition - rd * .4).x / .4); // \"sub surface scattering\"\n\tshade = mix(specular + shade * (ambientOcc + .2) * (diffuse + scat * .1), shade, fresnel);\n\t//shade = mix(background, shade, exp(-.002 * result.y * result.y * result.y));\n\tgExclusiveCube = -1;\n\treturn shade;\n}\n\n#if shadertoy == 1\nvoid mainImage(out vec4 c, in vec2 v)\n#else\nout vec4 c;\nin vec2 v;\nvoid main()\n#endif\n{\n\tgMovements[0] = F;\n\tgMovements[1] = F;\n\tgMovements[2] = B;\n\tgMovements[3] = B;\n\tgMovements[4] = L;\n\tgMovements[5] = L;\n\tgMovements[6] = R;\n\tgMovements[7] = R;\n\tgMovements[8] = U;\n\tgMovements[9] = U;\n\tgMovements[10] = D;\n\tgMovements[11] = D;\n\tCOLORS[0] = vec3(.03);\n\tCOLORS[1] = vec3(1, 0, 0);\n\tCOLORS[2] = vec3(0, 0, 1);\n\tCOLORS[3] = vec3(0, 1, 0);\n\tCOLORS[4] = vec3(1, 1, 0);\n\tCOLORS[5] = vec3(1);\n\tCOLORS[6] = vec3(1., .3, .0);\n\tCOLORS[7] = vec3(.9, .9, .8);\n\tgCubeOff[ 0] = off.zyz;\n\tgCubeOff[ 1] = off.xyz;\n\tgCubeOff[ 2] = off.yyz;\n\tgCubeOff[ 3] = off.zxz;\n\tgCubeOff[ 4] = off.xxz;\n\tgCubeOff[ 5] = off.yxz;\n\tgCubeOff[ 6] = off.zzz;\n\tgCubeOff[ 7] = off.xzz;\n\tgCubeOff[ 8] = off.yzz;\n\tgCubeOff[ 9] = off.zyx;\n\tgCubeOff[10] = off.xyx;\n\tgCubeOff[11] = off.yyx;\n\tgCubeOff[12] = off.zxx;\n\tgCubeOff[13] = off.yxx;\n\tgCubeOff[14] = off.zzx;\n\tgCubeOff[15] = off.xzx;\n\tgCubeOff[16] = off.yzx;\n\tgCubeOff[17] = off.zyy;\n\tgCubeOff[18] = off.xyy;\n\tgCubeOff[19] = off.yyy;\n\tgCubeOff[20] = off.zxy;\n\tgCubeOff[21] = off.xxy;\n\tgCubeOff[22] = off.yxy;\n\tgCubeOff[23] = off.zzy;\n\tgCubeOff[24] = off.xzy;\n\tgCubeOff[25] = off.yzy;\n\tgCubeRot[ 0] = rot.yxx;\n\tgCubeRot[ 1] = rot.xxx;\n\tgCubeRot[ 2] = rot.xxx;\n\tgCubeRot[ 3] = rot.yxx;\n\tgCubeRot[ 4] = rot.xxx;\n\tgCubeRot[ 5] = rot.zxx;\n\tgCubeRot[ 6] = rot.wxx;\n\tgCubeRot[ 7] = rot.wxx;\n\tgCubeRot[ 8] = rot.zxx;\n\tgCubeRot[ 9] = rot.xxz;\n\tgCubeRot[10] = rot.xyx;\n\tgCubeRot[11] = rot.zxz;\n\tgCubeRot[12] = rot.yyx;\n\tgCubeRot[13] = rot.zyx;\n\tgCubeRot[14] = rot.yxz;\n\tgCubeRot[15] = rot.xzx;\n\tgCubeRot[16] = rot.wxz;\n\tgCubeRot[17] = rot.yyx;\n\tgCubeRot[18] = rot.xyx;\n\tgCubeRot[19] = rot.xyx;\n\tgCubeRot[20] = rot.yyx;\n\tgCubeRot[21] = rot.xwx;\n\tgCubeRot[22] = rot.zyx;\n\tgCubeRot[23] = rot.wyx;\n\tgCubeRot[24] = rot.xwx;\n\tgCubeRot[25] = rot.xwx;\n\tgCubeHiddenOrder[ 0] = 9;\n\tgCubeHiddenOrder[ 1] = 5;\n\tgCubeHiddenOrder[ 2] = 25;\n\tgCubeHiddenOrder[ 3] = 24;\n\tgCubeHiddenOrder[ 4] = 17;\n\tgCubeHiddenOrder[ 5] = 11;\n\tgCubeHiddenOrder[ 6] = 3;\n\tgCubeHiddenOrder[ 7] = 6;\n\tgCubeHiddenOrder[ 8] = 8;\n\tgCubeHiddenOrder[ 9] = 2;\n\tgCubeHiddenOrder[10] = 14;\n\tgCubeHiddenOrder[11] = 19;\n\tgCubeHiddenOrder[12] = 1;\n\tgCubeHiddenOrder[13] = 20;\n\tgCubeHiddenOrder[14] = 22;\n\tgCubeHiddenOrder[15] = 16;\n\tgCubeHiddenOrder[16] = 23;\n\tgCubeHiddenOrder[17] = 7;\n\tgCubeHiddenOrder[18] = 18;\n\tgCubeHiddenOrder[19] = 4;\n\tgCubeHiddenOrder[20] = 10;\n\tgCubeHiddenOrder[21] = 12;\n\tgCubeHiddenOrder[22] = 13;\n\tgCubeHiddenOrder[23] = 15;\n\tgCubeHiddenOrder[24] = 21;\n\t//0,\n\tgTimeMod = mod(iTime, 10.);\n\tgCubeCol0[ 0] = RED; gCubeCol1[ 0] = YLW; gCubeCol2[ 0] = BLU;\n\tgCubeCol0[ 1] = RED; gCubeCol1[ 1] = BLU; gCubeCol2[ 1] = _x_;\n\tgCubeCol0[ 2] = RED; gCubeCol1[ 2] = BLU; gCubeCol2[ 2] = WHI;\n\tgCubeCol0[ 3] = RED; gCubeCol1[ 3] = YLW; gCubeCol2[ 3] = _x_;\n\tgCubeCol0[ 4] = RED; gCubeCol1[ 4] = _x_; gCubeCol2[ 4] = _x_;\n\tgCubeCol0[ 5] = RED; gCubeCol1[ 5] = WHI; gCubeCol2[ 5] = _x_;\n\tgCubeCol0[ 6] = RED; gCubeCol1[ 6] = GRN; gCubeCol2[ 6] = YLW;\n\tgCubeCol0[ 7] = RED; gCubeCol1[ 7] = GRN; gCubeCol2[ 7] = _x_;\n\tgCubeCol0[ 8] = RED; gCubeCol1[ 8] = WHI; gCubeCol2[ 8] = GRN;\n\tgCubeCol0[ 9] = YLW; gCubeCol1[ 9] = BLU; gCubeCol2[ 9] = _x_;\n\tgCubeCol0[10] = BLU; gCubeCol1[10] = _x_; gCubeCol2[10] = _x_;\n\tgCubeCol0[11] = BLU; gCubeCol1[11] = WHI; gCubeCol2[11] = _x_;\n\tgCubeCol0[12] = YLW; gCubeCol1[12] = _x_; gCubeCol2[12] = _x_;\n\tgCubeCol0[13] = WHI; gCubeCol1[13] = _x_; gCubeCol2[13] = _x_;\n\tgCubeCol0[14] = GRN; gCubeCol1[14] = YLW; gCubeCol2[14] = _x_;\n\tgCubeCol0[15] = GRN; gCubeCol1[15] = _x_; gCubeCol2[15] = _x_;\n\tgCubeCol0[16] = WHI; gCubeCol1[16] = GRN; gCubeCol2[16] = _x_;\n\tgCubeCol0[17] = YLW; gCubeCol1[17] = ORG; gCubeCol2[17] = BLU;\n\tgCubeCol0[18] = BLU; gCubeCol1[18] = ORG; gCubeCol2[18] = _x_;\n\tgCubeCol0[19] = BLU; gCubeCol1[19] = ORG; gCubeCol2[19] = WHI;\n\tgCubeCol0[20] = YLW; gCubeCol1[20] = ORG; gCubeCol2[20] = _x_;\n\tgCubeCol0[21] = ORG; gCubeCol1[21] = _x_; gCubeCol2[21] = _x_;\n\tgCubeCol0[22] = WHI; gCubeCol1[22] = ORG; gCubeCol2[22] = _x_;\n\tgCubeCol0[23] = GRN; gCubeCol1[23] = ORG; gCubeCol2[23] = YLW;\n\tgCubeCol0[24] = ORG; gCubeCol1[24] = GRN; gCubeCol2[24] = _x_;\n\tgCubeCol0[25] = ORG; gCubeCol1[25] = GRN; gCubeCol2[25] = WHI;\n\tgCubeHidden[0] = false;\n\tgCubeOpacity[0] = 1.;\n\tgHackFadeStuff = false;\n\tfor (i = 0; i < 26 - 1; i++) {\n\t\tint index = gCubeHiddenOrder[i];\n\t\tgCubeOpacity[index] = 1.;\n\t\tfloat time = gTimeMod >= 9. ? 0. : gTimeMod;\n\t\tint whatever = i >= 19 ? 21 : i + 1;\n\t\tfloat until = float(gNumMovements) * MOVEMENT_TIME_SECONDS + float(whatever) * HIDE_TIME_SECONDS;\n\t\tif (float(until) < time) {\n\t\t\tgCubeHidden[index] = true;\n\t\t} else {\n\t\t\tgCubeHidden[index] = false;\n\t\t\tif (float(until - FADE_TIME_SECONDS) < time) {\n\t\t\t\tif (i > 21) {\n\t\t\t\t\tgHackFadeStuff = true;\n\t\t\t\t}\n\t\t\t\tgCubeOpacity[index] = (float(until) - time) / FADE_TIME_SECONDS;\n\t\t\t}\n\t\t}\n\t}\n\n\tgCurrentMovement = -1;\n\tgCurrentMovementProgress = 0.;\n\tfor (i = 0; gTimeMod < 9. && i < gNumMovements; i++) {\n\t\tfloat until = float(i + 1) * MOVEMENT_TIME_SECONDS;\n\t\tif (float(until) < gTimeMod) {\n\t\t\tint tmp;\n#define _0 gCubeCol0\n#define _1 gCubeCol1\n#define _2 gCubeCol2\n#define swap(a,b,c,d,e,f,g,h) tmp=a[b];a[b]=c[d];c[d]=e[f];e[f]=g[h];g[h]=tmp;\n\t\t\tswitch (gMovements[i]) {\n\t\t\tcase F:\n\t\t\t\tswap(_0, 2, _1, 0, _1, 17, _2, 19);\n\t\t\t\tswap(_1, 11, _0, 1, _0, 9, _1, 18);\n\t\t\t\tswap(_1, 19, _2, 2, _0, 0, _0, 17);\n\t\t\t\tswap(_1, 2, _2, 0, _2, 17, _0, 19);\n\t\t\t\tswap(_1, 1, _1, 9, _0, 18, _0, 11);\n\t\t\t\tbreak;\n\t\t\tcase L:\n\t\t\t\tswap(_0, 0, _1, 6, _1, 23, _2, 17);\n\t\t\t\tswap(_2, 0, _0, 6, _0, 23, _1, 17);\n\t\t\t\tswap(_1, 9, _0, 3, _0, 14, _1, 20);\n\t\t\t\tswap(_2, 6, _2, 23, _0, 17, _1, 0);\n\t\t\t\tswap(_1, 3, _1, 14, _0, 20, _0, 9);\n\t\t\t\tbreak;\n\t\t\tcase R:\n\t\t\t\tswap(_0, 2, _0, 19, _0, 25, _2, 8);\n\t\t\t\tswap(_1, 25, _0, 8, _1, 2, _1, 19);\n\t\t\t\tswap(_0, 5, _0, 11, _1, 22, _1, 16);\n\t\t\t\tswap(_2, 2, _2, 19, _2, 25, _1, 8);\n\t\t\t\tswap(_1, 5, _1, 11, _0, 22, _0, 16);\n\t\t\t\tbreak;\n\t\t\tcase B:\n\t\t\t\tswap(_0, 8, _2, 25, _1, 23, _2, 6);\n\t\t\t\tswap(_0, 6, _1, 8, _0, 25, _2, 23);\n\t\t\t\tswap(_0, 7, _0, 16, _0, 24, _1, 14);\n\t\t\t\tswap(_2, 8, _1, 25, _0, 23, _1, 6);\n\t\t\t\tswap(_1, 7, _1, 16, _1, 24, _0, 14);\n\t\t\t\tbreak;\n\t\t\tcase U:\n\t\t\t\tswap(_1, 6, _1, 0, _1, 2, _1, 8);\n\t\t\t\tswap(_2, 8, _2, 6, _2, 0, _2, 2);\n\t\t\t\tswap(_1, 7, _1, 3, _1, 1, _1, 5);\n\t\t\t\tswap(_0, 6, _0, 0, _0, 2, _0, 8);\n\t\t\t\tswap(_0, 7, _0, 3, _0, 1, _0, 5);\n\t\t\t\tbreak;\n\t\t\tcase D:\n\t\t\t\tswap(_2, 17, _2, 23, _1, 25, _2, 19);\n\t\t\t\tswap(_2, 25, _0, 19, _0, 17, _0, 23);\n\t\t\t\tswap(_0, 18, _0, 20, _1, 24, _0, 22);\n\t\t\t\tswap(_1, 17, _1, 23, _0, 25, _1, 19);\n\t\t\t\tswap(_1, 18, _1, 20, _0, 24, _1, 22);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tgCurrentMovement = gMovements[i];\n\t\t\tgCurrentMovementProgress = 1. - (float(until) - gTimeMod) / MOVEMENT_TIME_SECONDS;\n\t\t\tbreak;\n\t\t}\n\t}\n\n#if shadertoy == 1\n\tvec2 uv = (v-.5*iResolution.xy)/iResolution.y;\n#else\n\tvec2 uv=v;uv.y/=1.77;\n#endif\n\n\tvec3 ro = vec3(-80, 80, -70);\n\tvec3 at = vec3(0, 0, 10);\n\n#if debugmov == 1 //noexport\n\tro = debug[0].xyz; //noexport\n\tfloat vertAngle = debug[1].y/20.; //noexport\n\tfloat horzAngle = debug[1].x/20.; //noexport\n\tif (abs(vertAngle) < .001) { //noexport\n\t\tvertAngle = .001; //noexport\n\t} //noexport\n\tfloat xylen = sin(vertAngle); //noexport\n\tvertAngle = cos(vertAngle); //noexport\n\tat.x = ro.x + cos(horzAngle) * xylen; //noexport\n\tat.y = ro.y + sin(horzAngle) * xylen; //noexport\n\tat.z = ro.z + vertAngle; //noexport\n#endif //noexport\n\n\tgRounding = ROUNDING;\n\tgSide = SIDE;\n\tgUnit = UNIT;\n\tgOffsetStuff = 1.;\n\tgShaft = true;\n\tif (gTimeMod >= 9.) {\n\t\tfloat tt = gTimeMod - 9.;\n\t\tgRounding = mix(3.4, ROUNDING, tt);\n\t\tgSide = 12. - gRounding;\n\t\tgUnit = gSide * 2. + 2. * gRounding;\n\t\tgOffsetStuff = mix(.23, 1., tt);\n\t\tro.z += mix(4., 0., tt);\n\t\tat.z += mix(4., 0., tt);\n\t\tgShaft = false;\n\t}\n\n\tvec3\tcf = normalize(at-ro),\n\t\tcl = normalize(cross(cf,vec3(0,0,-1))),\n\t\trd = mat3(cl,normalize(cross(cl,cf)),cf)*normalize(vec3(uv,1)),\n\t\tcol = vec3(.1) - length(uv) * .05;\n\n\tvec4 result = march(ro, rd, 100);\n\n\tif (result.x > 0.) { // hit\n\t\tvec3 shade = colorHit(result, rd);\n\t\tif (gCubeOpacity[gHitIndex] < 1.) {\n\t\t\tfloat opacity = gCubeOpacity[gHitIndex];\n\t\t\tgCubeHidden[gHitIndex] = true;\n\t\t\tresult = march(gHitPosition, rd, 50); // TODO: how many steps?\n\t\t\tvec3 without = result.x > 0. && (!gHackFadeStuff || gHitIndex == 0) ? colorHit(result, rd) : col;\n\t\t\tshade = mix(without, shade, opacity);\n\t\t}\n\t\tcol = shade;\n\t}\n\n\tc = vec4(pow(col, vec3(.4545)), 1.0); // pow for gamma correction because all the cool kids do it\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtVfzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1913, 1913, 1932, 1932, 1979], [1981, 1981, 2023, 2023, 2232], [2234, 2234, 2276, 2276, 2459], [2461, 2488, 2528, 2528, 2779], [2781, 2781, 2821, 2821, 3020], [3022, 3022, 3062, 3062, 3424], [3426, 3426, 3444, 3444, 5830], [5832, 5832, 5868, 5868, 5980], [5982, 6035, 6079, 6079, 6539], [6541, 6541, 6578, 6578, 7556]], "test": "untested"}
{"id": "css3R2", "name": "CRT Effect Shader", "author": "diogoquintas", "description": "https://babylonjs.medium.com/retro-crt-shader-a-post-processing-effect-study-1cb3f783afbc", "tags": ["crt"], "likes": 3, "viewed": 427, "published": 3, "date": "1666451301", "time_retrieved": "2024-07-30T16:25:18.954978", "image_code": "#define PI 3.1415926535897932384626433832795\n\nvec2 curvature = vec2(3.0, 3.0);\n\nfloat brightness = 4.0;\nfloat vignetteOpacity = 1.0;\nfloat lineOpacity = 1.0;\n\nvec2 curveRemapUV(vec2 uv)\n{\n    uv = uv * 2.0 - 1.0;\n    \n    vec2 offset = abs(uv.yx) / vec2(curvature.x, curvature.y);\n    \n    uv = uv + uv * offset * offset;\n    uv = uv * 0.5 + 0.5;\n    \n    return uv;\n}\n\nvec4 scanLineIntensity(float uv, float resolution, float opacity)\n{\n    float intensity = sin(uv * resolution * PI * 2.0);\n    \n    intensity = ((0.5 * intensity) + 0.5) * 0.9 + 0.1;\n    \n    return vec4(vec3(pow(intensity, opacity)), 1.0);\n}\n\nvec4 vignetteIntensity(vec2 uv, vec2 resolution, float opacity)\n{\n    float intensity = uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y);\n    \n    return vec4(vec3(clamp(pow((resolution.x / 4.0) * intensity, opacity), 0.0, 1.0)), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 remappedUV = curveRemapUV(uv);\n\n    if (remappedUV.x < 0.0 || remappedUV.y < 0.0 || remappedUV.x > 1.0 || remappedUV.y > 1.0){\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    } else {\n        fragColor = texture(iChannel0, remappedUV);\n        \n        fragColor *= vignetteIntensity(remappedUV, iResolution.xy, vignetteOpacity);\n        fragColor *= scanLineIntensity(remappedUV.x, iResolution.y, lineOpacity);\n        fragColor *= scanLineIntensity(remappedUV.y, iResolution.x, lineOpacity);\n        fragColor *= vec4(vec3(brightness), 1.0);\n    } \n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/css3R2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 187, 187, 368], [370, 370, 437, 437, 612], [614, 614, 679, 679, 844], [846, 846, 903, 903, 1507]], "test": "untested"}
{"id": "cdsGRj", "name": "Gosper curve", "author": "FabriceNeyret2", "description": "how do it recursive ?\nhow do procedural ?\nhttps://en.wikipedia.org/wiki/Gosper_curve\ngeneralizations: https://www.semanticscholar.org/paper/Generalized-Space-Filling-Gosper-Curves-and-Their-Spence-Werner/88441ef52c46e5d8f13e24466ce8b5218d30f83a/figure/6  ", "tags": ["2d", "fractal", "lsystem", "hilbert", "spacefilling", "templates", "peano", "eschergosper"], "likes": 24, "viewed": 454, "published": 3, "date": "1666439431", "time_retrieved": "2024-07-30T16:25:19.702978", "image_code": "                      // pi/3\n#define rot(a) mat2(cos(1.047*(a) + vec4(0,1.57,-1.57,0)))\n// --- draw line\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    p -= b* clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return dot(p,p);                        \n}\n// --- sort of L-system\n                  // .318  = (  pi/3 - atan(sqrt(3),2) ) / pi/3\nfloat p[] = float[](.318,-1.,-2.,1.,2.,0.,1.); // turn \nint   s[] =   int[](   1,-1 ,-1 ,1 ,1 ,1 ,-1); // draw seg: direct or reverse\n   // .333,D,  -pi/3.,iD,  -2pi/3,iD,  pi/3,D,  2pi/3,D,  0,D,  pi/3,iD\n\n#define Rec(draw,draw2)                                      \\\nfloat draw( vec2 U,vec2 P,vec2 _P ) {                        \\\n    vec2 D = _P - P;                                         \\\n    if ( length(U-(P+_P)/2.) > .88 * length(D) ) return 9.; /* optim inspired by mla https://www.shadertoy.com/view/dssGRf */ \\\n    float d=9.;                                              \\\n    for (int i=min(0,iFrame); i<p.length(); i++) {           \\\n        _P = P;                                              \\\n        D *= rot( p[i] );                                    \\\n        P += .378*D; /* 1./length(vec2(2,sqrt(3))) */        \\\n        d = min(d, s[i]>0 ? draw2(U,_P,P) : draw2(U,P,_P) ); \\\n    }                                                        \\\n    return d;                                                \\\n}\n// --- emulates recursion\n#define   draw5  line\nRec(draw4,draw5)  \nRec(draw3,draw4)  \nRec(draw2,draw3)\nRec(draw ,draw2)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y +vec2(.3,-.3), P = vec2(.6);\n    O = vec4( smoothstep(3./R.y,0., sqrt(draw(U, -P, P)) ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdsGRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 106, 141, 141, 259], [1499, 1499, 1537, 1537, 1693]], "test": "untested"}
{"id": "Dsl3zj", "name": "Fractal mosaic 25 (music)", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 5, "viewed": 216, "published": 3, "date": "1666439065", "time_retrieved": "2024-07-30T16:25:20.453970", "image_code": "#define fmod(x,y) mod(floor(x),y)\nvec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n        //vec2(0.5,1.)\n    ,\n    a1 = a+a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.y += iTime/8./t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    bool t3 = true;\n    for(int k = 0; k < 6; k++){\n        t3 = uv.x < uv.y;\n       if(t3){ uv = uv.yx;t2 = -t2.yx;}\n        uv =\n            abs(.5+uv+t2)\n        ;\n        t2 =\n            triangle_wave(uv+.5)\n        ;\n        uv =\n            t2-triangle_wave(uv.yx)\n        ;\n        float c1 =\n            uv.x-uv.y\n        ;\n        vec3 col1 = col.yzx;\n        if(t3 || uv.y < uv.x) col1 = abs(col.zxy-vec3(col.zx,c1));\n        if(!t3 || uv.y > uv.x) col1 = abs(col1-max(col.yzx,vec3(col.zx,c1)));\n        col = col1;\n\n    }\n    fragColor = vec4(min(col*2.,vec3(1.)),1.0);\n}\n", "image_inputs": [], "sound_code": "float fmod2(float a, float b){\n    return mod(floor(a),b)*b;\n}\n\n#define fmod(x,y) mod(floor(x),y)\n//#define fmod(x,y) mod(floor(x+fmod2(x,2.)),y)\n//#define fmod(x,y) mod(floor(x/8.),y)\n\nvec2 mainSound(int samp, float time){\n  \n  float s1 =\n      8.,\n  s2 = 8.,\n  m4 =\n      fmod(floor(time*s1)*floor(time),2.)\n  ,\n  t=\n      time/(1.+m4)\n  ,\n  m1 =\n      fmod(floor(t/s1+m4),s2);\n  t /=\n      (1.+fmod(t/s1+m4,2.))\n  ;\n  t *=\n      s1*s1\n  ;\n\n  float m2 =\n      1. + fmod(floor(t/s1+m4)*m1,s1)\n  ;\n  \n  float a = 64.*sqrt((1.-sqrt(fract(t/s1))))*.2,\n  //float a = 64.*((1.-(fract(t/s1)*fract(t/s1)))),\n\n\n  nb = time*pow(2.,(m2)/5.+7.);\n\n  return\n      //abs(.5-vec2(fract(nb*.998),fract(nb)))*a\n      \n      //sitar\n      log(abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n  ;\n\n}\n\n/*\nvec2 mainSound(int samp, float time){\n  \n  float s1 =\n      8.,\n\n  s2 = 8.,\n  \n  m4 = fmod(floor(time/s1+floor(time/s1)-floor(time*s1-floor(time))-floor(time)),2.),\n  \n  t= //varying tempo\n      time*(1.+m4)/2.\n  ,\n  m1 =\n      fmod(floor(t/s1+m4-floor(t*s1)),s1)\n  ,\n  m3 =\n      fmod(t/(m1+.5),s2);\n  t *= s1*s1;\n  t /=  \n      (1.+fmod((t/s1+floor(t/s1))/2.,2.))\n  ;\n  \n    float m2 =\n      1. + fmod(t/s1,s1)\n  ;\n  \n  float a=sqrt((1.-sqrt(fract(t/s1))))*.2,\n\n  nb = pow(2.,(m3+m2)/5.+6.5);\n\n  return vec2(fract(time*nb*.998)*a\n   ,fract(time*nb)*a);\n\n}\n*/", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dsl3zj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 61, 61, 186], [188, 188, 245, 245, 1020]], "test": "untested"}
{"id": "ftdfWj", "name": "KeplerOrbits", "author": "Pidhorskyi", "description": "Shadertoy adaptation of my old project from here: https://github.com/podgorskiy/KeplerOrbits\nThe shader shows the real-time position of celestial bodies in the sky for an observer at any given latitude and longitude.\nClick the planets!\n", "tags": ["2d", "planets", "orbits", "kepler"], "likes": 11, "viewed": 360, "published": 3, "date": "1666425709", "time_retrieved": "2024-07-30T16:25:21.433352", "image_code": "// This shader displays the planets' position (visible from the observer on Earth) in real-time.\n\n\n// Please specify your GMT here (the one that is set in the system clock, does not have to be the real one):\n#define GMT  -4\n\n\n// Please specify your geo coordinates here. You can find the coordinates of your city using this tool: https://www.latlong.net/\n#define LAT 40.440624\n#define LONG -79.995888\n\n\n// QA. \n// Q: Why is East on the left and West on the right?\n// A: This is a view of the sky, e.i. from Earth's surface upward, unlike a map with a top-down view. Thus, things are flipped.\n//\n// Q: What is the yellow curve?\n// A: Ecliptic. The ecliptic is the plane of Earth's orbit around the Sun. Since the solar system is mostly flat, most of the planets\n//    are nearby the yellow curve.\n//\n// Q: Why are some planets outside the circle?\n// A: They are below the horizon and not visible.\n\n// Stanislav Pidhorskyi - 2022\n// Original link for citation: https://www.shadertoy.com/view/ftdfWj\n// Shadertoy adaptation of my old project from here: https://github.com/podgorskiy/KeplerOrbits\n\n// For printing text, ints, and floats this shader is using utils by FabriceNeyret2: https://www.shadertoy.com/view/llySRh\n\n////////////////////////////////////////////////////////////////////////////////////\n#define M_PI 3.14159265359\n#define TO_RAD(x) (x / 180.0 * M_PI)\n#define TO_GRD(x) (x * 180.0 / M_PI)\n\nconst float k_obliquityOfTheEcliptic = 23.439281 / 180.0 * M_PI;\nconst float k_GMT = float(GMT);\nvec2 geoCoordinates = vec2(float(LAT) / 180.0 * M_PI, float(LONG) / 180.0 * M_PI);\n\n\n// Data\n////////////////////////////////////////////////////////////////////////////////////\n\n// Struct that keeps info about celestial bodies, in particular Keplerian oribital elements.\nstruct Body\n{\n\tfloat semimajorAxis;\n\tfloat eccentricity;\n\n\tfloat inclination;\n\tfloat longitudeOfAscendingNode;\n    \n\tfloat longitudeOfPerihelion;\n\tfloat meanLongitude;\n    int epoch;\n    float siderealOrbitPeriod;\n    \n    vec3 color;\n    \n    int name[9];\n    int name_length;\n};\n\n\n// UPDATE: Replaced an array with function returning the Body instance as was suggested by morimea\n// Sun, planets, and few smaller bodies\nBody get_bodies_by_id(int idx){\n// do not use switch/case because ANGLE broken\nif(idx==0) return Body(0., 0., TO_RAD(0.), TO_RAD(0.), TO_RAD(0.), TO_RAD(0.), 2451545, 1., vec3(0xFF, 0xFF, 0x00), int[9](83, 117, 110, 0, 0, 0, 0, 0, 0), 3); // Sun\nif(idx==1) return Body(0.38709893, 0.20563069, TO_RAD(7.00487), TO_RAD(48.33167), TO_RAD(77.45645), TO_RAD(252.25084), 2451545, 87.969, vec3(0xFF, 0x00, 0xAA), int[9](77, 101, 114, 99, 117, 114, 121, 0, 0), 7); // Mercury\nif(idx==2) return Body(0.72333199, 0.00677323, TO_RAD(3.39471), TO_RAD(76.68069), TO_RAD(131.53298), TO_RAD(181.97973), 2451545, 224.701, vec3(0x92, 0x6D, 0xAA), int[9](86, 101, 110, 117, 115, 0, 0, 0, 0), 5); // Venus\nif(idx==3) return Body(1.00000011, 0.01671022, TO_RAD(0.00005), TO_RAD(-11.26064), TO_RAD(102.94719), TO_RAD(100.46435), 2451545, 365.256, vec3(0x00, 0xB6, 0xFF), int[9](69, 97, 114, 116, 104, 0, 0, 0, 0), 5); // Earth\nif(idx==4) return Body(1.52366231, 0.09341233, TO_RAD(1.85061), TO_RAD(49.57854), TO_RAD(336.04084), TO_RAD(355.45332), 2451545, 686.980, vec3(0xFF, 0x24, 0x00), int[9](77, 97, 114, 115, 0, 0, 0, 0, 0), 4);  // Mars\nif(idx==5) return Body(5.203363011, 0.04839266, TO_RAD(1.30530), TO_RAD(100.55615), TO_RAD(14.75385), TO_RAD(34.40438), 2451545, 4332.589, vec3(0xFF, 0x92, 0x00), int[9](74, 117, 112, 105, 116, 101, 114, 0, 0), 7); // Jupiter\nif(idx==6) return Body(9.53707032, 0.05415060, TO_RAD(2.48446), TO_RAD(113.71504), TO_RAD(92.43194), TO_RAD(49.94432), 2451545, 10759.22, vec3(0xFF, 0xFF, 0x55), int[9](83, 97, 116, 117, 114, 110, 0, 0, 0), 6); // Saturn\nif(idx==7) return Body(19.19126393, 0.04716771, TO_RAD(0.76986), TO_RAD(74.22988), TO_RAD(170.96424), TO_RAD(313.23218), 2451545, 30685.4, vec3(0x24, 0xFF, 0xAA), int[9](85, 114, 97, 110, 117, 115, 0, 0, 0), 6); // Uranus\nif(idx==8) return Body(30.06896348, 0.00858587, TO_RAD(1.76917), TO_RAD(131.72169), TO_RAD(44.97135), TO_RAD(304.88003), 2451545, 60189., vec3(0x6D, 0xB6, 0xFF), int[9](78, 101, 112, 116, 117, 110, 101, 0, 0), 7); // Neptune\nif(idx==9) return Body(39.48168677, 0.24880766, TO_RAD(17.14175), TO_RAD(110.30347), TO_RAD(224.06676), TO_RAD(238.92881), 2451545, 90465., vec3(0x6D, 0x6D, 0xFF), int[9](80, 108, 117, 116, 111, 0, 0, 0, 0), 5); // Pluto\nif(idx==10) return Body(544.0690504866262, 0.8598045771920355, TO_RAD(11.92819679107613), TO_RAD(144.4217446113967), TO_RAD(455.3715618630623), TO_RAD(813.5892172541679), 2456200, 4635317.206254945, vec3(0x6D, 0x6D, 0xAA), int[9](83, 101, 100, 110, 97, 0, 0, 0, 0), 5); // Sedna\nif(idx==11) return Body(17.8341442925537, 0.967142908462304, TO_RAD(162.262690579161), TO_RAD(58.42008097656843), TO_RAD(169.75256608108613), TO_RAD(208.13683055752493), 2449400, 27509.1290731861, vec3(0x00, 0x49, 0xFF), int[9](49, 80, 47, 72, 97, 108, 108, 101, 121), 9); // 1P/Halley\n}\n\n\n\n// Time utils\n////////////////////////////////////////////////////////////////////////////////////\n\n// Julian day. vec2 is used to boost precision a bit, x component keeps integer part, and y component keeps fractional part\n// The result is current Julian day minus 2451545 (again for precision). \nvec2 getjd()\n{\n\tint mon = int(iDate.y + 0.5) + 1;\n\tint year = int(iDate.x + 0.5);\n\tint a = (14 - mon) / 12;\n\tint y = year + 4800 - a;\n\tint m = mon + 12 * a - 3;\n\tint jd = int(iDate.z + 0.5) + (153 * m + 2) / 5 + 365 * y + y / 4 - y / 100 + y / 400 - 32045;\n    jd -= 2451545;\n    float fr = (iDate.w - k_GMT * 60.0 * 60.0) / 86400.0 - 0.5;\n    if (fr < 0.)\n    {\n        jd -= 1;\n        fr += 1.;\n    }\n    else if (fr > 1.)\n    {\n        jd += 1;\n        fr -= 1.;\n    }\n\treturn vec2(float(jd), fr);\n}\n\nfloat GetGMST(vec2 jd)\n{   \n    // The code below really computes this: x = fract((18.697374558 + 24.06570982441908 * jd) / 24.) * 24.;\n    // but with much higher float point precision becouse it utilizes the fact that jd.x is integer and\n    // jd.y is fractional\n\tfloat x = 0.77905727325 + 0.00273790935 * jd.x + 1.00273790935 * jd.y;\n\treturn fract(x) * 24.;\n}\n\n\nfloat getlha(float alpha, float lambda, vec2 jd)\n{\n\tfloat gmst = GetGMST(jd);\n\treturn gmst / 12. * M_PI + lambda - alpha;\n}\n\n\n// Orbital utils\n////////////////////////////////////////////////////////////////////////////////////\n\nfloat GetMeanAnomaly(const Body b)\n{\n\treturn b.meanLongitude - b.longitudeOfPerihelion;\n}\n\nfloat GetTSE(const Body b, vec2 jd)\n{\n\treturn (jd.x - float(b.epoch - 2451545)) + jd.y;\n}\n\nfloat GetEccentricAnomaly(const Body b, float m)\n{\n    // Iteratively solves M = E - e \\sin E for E\n\tfloat e = 0.0;\n\tfloat lastDelta = 2.0;\n\tfor (float delta = 1., e_ = m; delta < lastDelta;)\n\t{\n\t\te = b.eccentricity * sin(e_) + m;\n\t\tlastDelta = delta;\n\t\tdelta = abs(e_ - e);\n\t\te_ = e;\n\t}\n\treturn e;\n}\n\nfloat GetRadius(const Body b, float eccentricAnomaly)\n{\n\treturn b.semimajorAxis * (1. - b.eccentricity * cos(eccentricAnomaly));\n}\n\nfloat GetArgumentOfPeriapsis(const Body b)\n{\n\treturn b.longitudeOfPerihelion - b.longitudeOfAscendingNode;\n}\n\nfloat GetTrueAnomaly(const Body b, float eccentricAnomaly)\n{\n\treturn 2.0 * atan(\n\t\tsqrt(1.0 + b.eccentricity) * sin(eccentricAnomaly / 2.0),\n\t\tsqrt(1.0 - b.eccentricity) * cos(eccentricAnomaly / 2.0)\n\t);\n}\n\n\n// Coordinate system conversions\n////////////////////////////////////////////////////////////////////////////////////\n\n\nvec3 Euler2Cartesian(vec4 e) // vec4: phi, theta, psi, r\n{\n\treturn e.w * vec3(\n        cos(e.x) * cos(e.y) - sin(e.x) * cos(e.z) * sin(e.y),\n        sin(e.x) * cos(e.y) * cos(e.z) + cos(e.x) * sin(e.y),\n        sin(e.x) * sin(e.z)\n    );\n}\n\nvec2 Cartesian2Ecliptik(vec3 p)\n{\n\tfloat lambda = atan(p.y, p.x);\n\tif (lambda < 0.)\n\t{\n\t\tlambda = lambda + 2. * M_PI;\n\t}\n    return vec2(lambda, atan(p.z, length(p.xy)));\n}\n\nvec2 Ecliptik2Equatorial(vec2 p)\n{\n\n\tfloat alpha = atan(\n\t\tsin(p.x)*cos(k_obliquityOfTheEcliptic) - tan(p.y)*sin(k_obliquityOfTheEcliptic),\n\t\tcos(p.x)\n\t);\n\tif (alpha < 0.)\n\t{\n\t\talpha = alpha + 2. * M_PI;\n\t}\n\n\tfloat delta = asin(\n\t\tsin(p.y) * cos(k_obliquityOfTheEcliptic) +\n\t\tcos(p.y) * sin(k_obliquityOfTheEcliptic) * sin(p.x)\n\t);\n\n\treturn vec2(alpha, delta);\n}\n\nvec2 Equatorial2Horizontal(vec2 e, vec2 observer, vec2 jd)\n{\n\tfloat h = getlha(e.x, observer.y, jd);\n\tif (h < 0.)\n\t{\n\t\th = h + 2. * M_PI;\n\t}\n\tfloat azimuth = atan(\n\t\tsin(h), \n\t\tcos(h) * sin(observer.x) - tan(e.y) * cos(observer.x)\n\t) + TO_RAD(180.);\n\tfloat altitude = asin(sin(observer.x) * sin(e.y) + cos(observer.x) * cos(e.y) * cos(h));\n    return vec2(azimuth, altitude);\n}\n\nvec2 Horizontal2Polar(vec2 h)\n{\n\treturn vec2(\n\t\t-sin(h.x) * (M_PI / 2.0 - h.y),\n\t\tcos(h.x) * (M_PI / 2.0 - h.y)\n\t);\n}\n\n\n// Compute Eulaer Angles from Julian day and orbital elements.\n////////////////////////////////////////////////////////////////////////////////////\n\nvec4 GetEulaerAnglesFromEccentricAnomaly(const Body b, float eccentricAnomaly)\n{\n\tfloat trueAnomaly = GetTrueAnomaly(b, eccentricAnomaly);\n\tfloat argumentOfPeriapsis = GetArgumentOfPeriapsis(b);\n\n\tfloat psi = trueAnomaly + argumentOfPeriapsis;\n\n\tfloat r = GetRadius(b, eccentricAnomaly);\n\treturn vec4(\n\t\tpsi, \n\t\tb.longitudeOfAscendingNode,\n\t\tb.inclination,\n\t\tr\n   );\n}\n\nvec4 GetEulaerAnglesFromJulianDay(const Body b, vec2 jd)\n{\n\tfloat meanMotion = 2.0 * M_PI / b.siderealOrbitPeriod;\n\tfloat currentMeanAnomaly = GetMeanAnomaly(b) + meanMotion * GetTSE(b, jd);\n\n\tfloat eccentricAnomaly = GetEccentricAnomaly(b, currentMeanAnomaly);\n\n\treturn GetEulaerAnglesFromEccentricAnomaly(b, eccentricAnomaly);\n}\n\n\n// Render text and print floats, https://www.shadertoy.com/view/llySRh\n////////////////////////////////////////////////////////////////////////////////////\n\nvoid mix_layer(inout vec4 c, float d, vec3 color, float w){ \n    float anti = fwidth(d) * w;\n    c.rgb = mix(c.rgb, color, smoothstep(anti, -anti, d));\n}\nvoid mix_layer(inout vec4 c, float d, vec4 color, float w){ \n    float anti = fwidth(d) * w;\n    c.rgb = mix(c.rgb, color.rgb, color.a * smoothstep(anti, -anti, d));\n}\n#define over(d, color) mix_layer(fragColor, d, color, 1.)\n\nvoid char(vec2 p, int c, inout vec4 fragColor) {\n    int char_id = -1; vec2 char_pos; \n    vec2 dfdx = dFdx(p/16.), dfdy = dFdy(p/16.);\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ){ // thighly y-clamped to allow dense text\n        vec4 r = textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                       dfdx, dfdy );\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0), r.x);\n    }\n}\nvoid pInt(vec2 p, float n, float d, inout vec4 fragColor) {\n    if (n < 0.){\n        char(p - vec2(-.5,0), 45, fragColor);\n        n = -n;\n    }\n    for (float i = d; i>=0.; i--) {\n        n /=  10.0;\n        char(p - .5*vec2(i,0), 48+ int(fract(n)*10.), fragColor);\n    }\n}\nvoid pInt(vec2 p, float n, inout vec4 fragColor) {\n    if (n < 0.) {\n        char(p - vec2(-.5,0), 45, fragColor);\n        n = -n;\n    }\n    for (float i = 3.; i>=0.; i--){\n        n /=  9.999999; // 10., // for windows :-(\n        char(p - .5*vec2(i,0), 48+ int(fract(n)*10.), fragColor);\n    }\n}\n// --- display float8.4\nvoid pFloat(vec2 p, float n, inout vec4 fragColor) {\n    if (n < 0.){ char(p - vec2(-.5,0), 45, fragColor); n = -n; }\n    float upper = floor(n);\n    float lower = fract(n)*1e4 + .5;  // mla fix for rounding lost decimals\n    if (lower >= 1e4) { lower -= 1e4; upper++; }\n    pInt(p,upper, fragColor); p.x -= 2.;\n    char(p, 46, fragColor);   p.x -= .5;\n    pInt(p,lower, fragColor);\n}\n#define C(c) char(p, c, fragColor);p.x -= .5;\n\n\n// Draw planets and ecliptic\n////////////////////////////////////////////////////////////////////////////////////\n\nbool draw_planet(Body b, vec2 jd, vec3 observer_pos, vec2 uv, inout vec4 fragColor)\n{\n    vec2 meq = Ecliptik2Equatorial(Cartesian2Ecliptik(Euler2Cartesian(GetEulaerAnglesFromJulianDay(b, jd)) - observer_pos));\n    vec2 mp = Horizontal2Polar(Equatorial2Horizontal(meq, geoCoordinates, jd));\n    over(length(mp - uv ) - 14. / iResolution.y, b.color / 255.);\n    \n    vec2 p = (uv - mp) * 12. / 675.* iResolution.y;\n    for (int i =0; i < b.name_length; ++i)\n    {\n        char(p, b.name[i], fragColor);   p.x -= .5;\n    }\n    \n    vec2 m = (iMouse.xy-0.5*iResolution.xy)/iResolution.y * M_PI;\n    return length(m - mp) < 30. / iResolution.y;\n}\n\nvoid draw_planet_info(Body b, vec2 jd, vec3 observer_pos, vec2 uv, inout vec4 fragColor)\n{\n    vec2 meq = Ecliptik2Equatorial(Cartesian2Ecliptik(Euler2Cartesian(GetEulaerAnglesFromJulianDay(b, jd)) - observer_pos));\n    vec2 mh = Equatorial2Horizontal(meq, geoCoordinates, jd);\n    vec2 mp = Horizontal2Polar(mh);\n    vec2 s = vec2(0.44, 0.85 - 1.) * 675. / iResolution.y;\n    float r = 0.05 * 675. / iResolution.y;\n    over(length(max(abs(uv - mp - s - vec2(r, -r))-abs(s),0.0))-r, vec4(mix(vec3(0.6), b.color / 255., 0.3), 0.9));\n    vec2 p = (uv - mp) * 12. / 675.* iResolution.y;\n    p.y += 1.7;\n    p.x -= 0.5;\n    float start_x = p.x;\n    for (int i =0; i < b.name_length; ++i)\n    {\n        char(p / 1.3, b.name[i], fragColor); p.x -= .5 * 1.3;\n    }\n    p.x = start_x; p.y += 1.3;\n    C(65)C(108)C(116)C(105)C(116)C(117)C(100)C(101)C(58)C(32)\n    pFloat(p, TO_GRD(mh.y), fragColor); p.x -= 4.5; char(p, 176, fragColor);\n    p.x = start_x; p.y += 1.0;\n    C(65)C(122)C(105)C(109)C(117)C(116)C(104)C(58)C(32)C(32)\n    pFloat(p, TO_GRD(mh.x), fragColor); p.x -= 4.5; char(p, 176, fragColor);\n}\n\nfloat d_ecliptic(float a, vec2 jd, vec2 uv)\n{\n    vec2 meq = Ecliptik2Equatorial(vec2(a, 0.));\n    vec2 mh = Equatorial2Horizontal(meq, geoCoordinates, jd);\n    vec2 mp = Horizontal2Polar(mh);\n    return length(mp - uv);\n}\n\n// Grid search to solve for ecliptic is not ideal...\n// Not sure how to improve, too lazy to compute Jacobians and solve with the Newton's method\nvoid draw_ecliptic(vec2 jd, vec2 uv, vec3 color, inout vec4 fragColor)\n{\n    float min_d = 1.0e6;\n    float min_a = 0.0;\n    float prev_a = min_a;\n    float d = 1.0;\n    for (int k =0; k < 7; ++k)\n    {\n        d *= 4.0;\n        for (int i = -3; i < 3; i++)\n        {\n            float a = prev_a + float(i) / d * 2.0 * M_PI;\n            float nd = d_ecliptic(a, jd, uv);\n            if (nd < min_d)\n            {\n                min_d = nd;\n                min_a = a;\n            }\n        }\n        // Early exit. We are too far from ecliptic, no sense to refine a.\n        if (min_d * 2.0 > d)\n            return;\n        prev_a = min_a;\n    }\n    over(min_d - 3. / iResolution.y, color);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y * 2.0;    \n    \n    vec2 jd = getjd();\n    vec3 observer_pos = Euler2Cartesian(GetEulaerAnglesFromJulianDay(get_bodies_by_id(3), jd));\n    \n    fragColor = vec4(vec3(0.), 1.0);\n    over(length(uv) - 1., vec3(1.0, 1.0, 1.0) * 0.1);\n    over(max(min(min(abs(uv.x), abs(uv.y)), min(min(abs(uv.x - uv.y), abs(uv.x + uv.y)) * 0.707, abs(length(uv) - 0.5))), length(uv) - 1.) - 1.5 / iResolution.y, vec3(1.0, 1.0, 1.0) * 0.6);\n    \n    char(uv * 12. + vec2(0.5, -11.), 78, fragColor);\n    char(uv * 12. + vec2(-11., 0.5), 87, fragColor);\n    char(uv * 12. + vec2(12., 0.5), 69, fragColor);\n    char(uv * 12. + vec2(0.5, 12), 83, fragColor);\n    \n    vec2 p = (uv * 12. + vec2(0., 0.5)) * 1.5 + vec2(1.5, 0.3);\n    char(p, 48 + 9, fragColor);  p.x -= .5; char(p, 48 + 0, fragColor);  p.x -= .5; char(p, 176, fragColor);\n    p = (uv * 12. + vec2(6., 0.5)) * 1.5 + vec2(1.0, 0.3);\n    char(p, 48 + 4, fragColor);  p.x -= .5; char(p, 48 + 5, fragColor);  p.x -= .5; char(p, 176, fragColor);\n    p = (uv * 12. + vec2(12., 0.5)) * 1.5 + vec2(1.0, 0.3);\n    char(p, 48 + 0, fragColor);  p.x -= .5; char(p, 176, fragColor);\n    draw_ecliptic(jd, uv * (M_PI / 2.), vec3(1.0, 1.0, 0.0), fragColor);\n    \n    int info = -1;\n    for (int i = 0; i < 12; ++i)\n        if (i != 3) // Don't draw Earth\n            info = draw_planet(get_bodies_by_id(i), jd, observer_pos, uv * (M_PI / 2.), fragColor) ? i : info;\n    if (info != -1)    \n        draw_planet_info(get_bodies_by_id(info), jd, observer_pos, uv * (M_PI / 2.), fragColor);\n    \n    p = fragCoord/iResolution.y * 2.0 * 16.;\n    p.y -= 1.0;\n    float start_x = p.x;\n    C(74)C(117)C(108)C(105)C(97)C(110)C(32)C(100)C(97)C(121)C(58)C(32)\n    pInt(p, jd.x + 2451545.5, 6., fragColor); p.x -= 3.5;\n    char(p, 46, fragColor);   p.x -= .5;\n    pInt(p, jd.y * 1000000., 5., fragColor); \n    p.x = start_x;\n    p.y += 1.0;\n    C(71)C(77)C(83)C(84)C(58)p.x -= 3.5;\n    pFloat(p, GetGMST(jd), fragColor);     \n}\n\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2057, 2196, 2227, 2274, 4999], [5103, 5301, 5315, 5315, 5804], [5806, 5806, 5830, 6071, 6169], [6172, 6172, 6222, 6222, 6295], [6401, 6401, 6437, 6437, 6490], [6492, 6492, 6529, 6529, 6581], [6583, 6583, 6633, 6682, 6883], [6885, 6885, 6940, 6940, 7015], [7017, 7017, 7061, 7061, 7125], [7127, 7127, 7187, 7187, 7332], [7455, 7455, 7513, 7513, 7694], [7696, 7696, 7729, 7729, 7868], [7870, 7870, 7904, 7904, 8232], [8234, 8234, 8294, 8294, 8611], [8613, 8613, 8644, 8644, 8730], [8882, 8882, 8962, 8962, 9250], [9252, 9252, 9310, 9310, 9582], [9742, 9742, 9801, 9801, 9895], [9896, 9896, 9955, 9955, 10063], [10123, 10123, 10171, 10171, 10537], [13427, 13427, 13472, 13472, 13649], [13651, 13797, 13869, 13869, 14490]], "test": "untested"}
{"id": "dsf3zj", "name": "Light Room", "author": "wyatt", "description": "light", "tags": ["light"], "likes": 26, "viewed": 331, "published": 3, "date": "1666424571", "time_retrieved": "2024-07-30T16:25:22.218253", "image_code": "Main {\n    Q = A(U)/A(U).w;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U/R))\n#define Main void mainImage (out vec4 Q, in vec2 U)\n\nvec2 quadratic (float a, float b, float c) {\n    float det = b*b-4.*a*c;\n    if (det<0.) return vec2(1e9);\n    return (-b+vec2(-1,1)*sqrt(det))/(2.*a);\n}\nvec4 color (float w) {\n    return cos(1.8+5.*w+vec4(1,2,3,4));;\n}\nvec2 sphere (vec3 p, vec3 d, float r) {\n    // (p + dx).(p + dx) = r*r\n    // p.p + 2p.dx + x.x = r*r\n    return quadratic(1.,2.*dot(p,d),dot(p,p)-r*r);\n}\n\nfloat plane (vec3 p, vec3 d, vec3 n) {\n    return -dot(p,n)/dot(d,n);\n}\nfloat mn (float a, float b) {\n    if (a < 0.&&b>0.) return b;\n    if (b < 0.&&a>0.) return a;\n    if (a < b &&a>0.) return a;\n    if (b < a &&b>0.) return b;\n    return 1e9;\n}\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}", "buffer_a_code": "#define LIGHT vec3(.1,0.25,0.2)\n#define LIGHT_R .2\n#define SPHERE_1 vec3(0.3,0,.0)\n#define SPHERE_R .3\n#define SPHERE_2 vec3(-0.4,-.3,-.1)\n#define SPHERE_2R .4\n#define SPHERE_3 vec3(0.6,-.2,-.3)\n#define SPHERE_3R .1\n#define FLOOR .3\n#define WALL 1.\n#define PLANE_1 vec3(0,1,0)\n#define PLANE_2 vec3(0,0,1)\n#define PLANE_3 vec3(0,0,-1)\n#define PLANE_4 vec3(1,0,0)\n#define PLANE_5 vec3(-1,0,0)\n#define PLANE_6 vec3(0,-1,0)\nvoid scene (inout vec3 p, inout vec3 d, inout vec4 light, float i, float w) {\n    vec4 Q = vec4(0);\n    float x = 1e9;\n    vec2 sp1 = sphere(p-SPHERE_1,d,SPHERE_R);\n    vec2 sp3 = sphere(p-SPHERE_2,d,SPHERE_2R);\n    vec2 sp4 = sphere(p-SPHERE_3,d,SPHERE_3R);\n    vec2 sp2 = sphere(p-LIGHT,d,LIGHT_R);\n    float p1 = plane(p-vec3(0,-FLOOR,0),d,PLANE_1);\n    float p2 = plane(p-vec3(0,0,-WALL),d,PLANE_2);\n    float p3 = plane(p-vec3(0,0,WALL),d,PLANE_3);\n    float p4 = plane(p-vec3(-WALL,0,0),d,PLANE_4);\n    float p5 = plane(p-vec3(WALL,0,0),d,PLANE_5);\n    float p6 = plane(p-vec3(0,WALL,0),d,PLANE_6);\n    x = mn(x,mn(sp1.x,sp1.y));\n    x = mn(x,mn(sp2.x,sp2.y));\n    x = mn(x,mn(sp3.x,sp3.y));\n    x = mn(x,mn(sp4.x,sp4.y));\n    x = mn (x,p1);\n    x = mn (x,p2);\n    x = mn (x,p3);\n    x = mn (x,p4);\n    x = mn (x,p5);\n    x = mn (x,p6);\n    p += d*x;\n    vec3 h = hash32(vec2(iFrame,i));\n    if (x == sp1.x) {\n        Q = vec4(1,1,1,0);\n        vec3 n = normalize(p-SPHERE_1);\n        if (h.z>0.4)\n            d = refract(d,n,1./(1.5+.0*w));\n        else \n            d = reflect(d,n);\n    }\n    if (x == sp1.y) {\n        Q = vec4(1,1,1,0);\n        vec3 n = -normalize(p-SPHERE_1);\n        if (h.z>0.4)\n            d = refract(d,n,1.5+.0*w);\n        else \n            d = reflect(d,n);\n    }\n    if (x == sp3.x) {\n        Q = vec4(1,1,1,.2);\n        vec3 n = normalize(p-SPHERE_2);\n        if (h.z>0.2)\n            d = refract(d,n,1./(1.5+.0*w));\n        else \n            d = reflect(d,n);\n    }\n    if (x == sp3.y) {\n        Q = vec4(1,1,1,.2);\n        vec3 n = -normalize(p-SPHERE_2);\n        if (h.z>0.2)\n            d = refract(d,n,1.5+.0*w);\n        else \n            d = reflect(d,n);\n    }\n    if (x == sp4.y) {\n        Q = vec4(1,1,1,0);\n        vec3 n = -normalize(p-SPHERE_3);\n        d = reflect(d,n);\n    }\n    if (x == sp4.x) {\n        Q = vec4(1,1,1,0);\n        vec3 n = normalize(p-SPHERE_3);\n        d = reflect(d,n);\n    }\n    if (x == sp2.x) {\n        Q = vec4(1,1,1,6);\n        vec3 n = normalize(p-LIGHT);\n        d = normalize(h*2.-1.);\n        //d = reflect(n,d);\n    }\n    if (x == sp2.y) {\n        Q = vec4(1,1,1,6);\n        vec3 n = -normalize(p-LIGHT);\n        d = normalize(h*2.-1.);\n        //d = reflect(n,d);\n    }\n    if (x == p1) {\n        Q = vec4(1,1,1,0.);\n        vec3 n = PLANE_1;\n        d = normalize(h*2.-1.);\n        d.y = abs(d.y);\n    }\n    if (x == p2) {\n        Q = vec4(.9,.9,.9,0);\n        vec3 n = PLANE_2;\n        d = reflect(d,n);\n    }\n    \n    if (x == p3) {\n        Q = vec4(1,1,1,0);\n        vec3 n = PLANE_3;\n        d = reflect(d,n);\n    }\n    if (x == p4) {\n        Q = vec4(.9,1,.9,0);\n        vec3 n = PLANE_4;\n        d = reflect(d,n);\n    }\n    if (x == p5) {\n        Q = vec4(1,.9,.8,0);\n        vec3 n = PLANE_5;\n        d = reflect(d,n);\n    }\n    if (x == p6) {\n        Q = .3*vec4(.9,.9,1,0);\n        vec3 n = PLANE_6;\n        d = reflect(d,n);\n    }\n    if (x > 1000.) {\n        Q = vec4(0);\n    }\n    light.xyz *= Q.xyz;\n    light.w += Q.w;\n    p += 1e-5*d;\n}\nMain {\n    vec2 u = 2.*(U-.5*R)/R.y;\n    vec3 h = hash32(U);\n    vec2 dr = .0*h.x*vec2(cos(6.2*h.y),sin(6.2*h.y));\n    vec3 p = vec3(.3*u-dr,-.6*WALL);\n    vec3 d = normalize(vec3(u+dr,1));\n    \n    float w = .1+.8*h.z;\n    Q = 1.+.0*color(w);\n    Q.w = 0.;\n    for (float i = 0.; i < 25.; i++) {\n        scene(p,d,Q,i,w);\n    }\n    Q = Q*Q.w;\n    Q.w = 1.;\n    Q += A(U);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsf3zj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mdf3R2", "name": "macOS Monterey 2", "author": "itsmealec", "description": "modified @vincentdchan's for the night mode version, only changed colours", "tags": ["wallpape"], "likes": 5, "viewed": 193, "published": 3, "date": "1666421665", "time_retrieved": "2024-07-30T16:25:22.961266", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord/iResolution.xy;\n  fragColor = texture(iChannel0, uv);\n\n  fragColor.xyz *= (uv.y * 1.08 + 0.65);\n  // fragColor = vec4(col); // Output to screen\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 sin_shape(in vec2 uv, in float offset_y) {\n  // Time varying pixel color\n  float y = sin((uv.x + iTime * -0.06 + offset_y) * 5.5);\n\n  float x = uv.x * 8.;\n  float a=1.;\n\tfor (int i=0; i<5; i++) {\n\t\tx*=0.53562;\n\t\tx+=6.56248;\n\t\ty+=sin(x)*a;\t\t\n\t\ta*=.5;\n\t}\n\n  float y0 = step(0.0, y * 0.08 - uv.y + offset_y);\n  return vec3(y0, y0, y0);\n}\n\nvec2 rotate(vec2 coord, float alpha) {\n  float cosA = cos(alpha);\n  float sinA = sin(alpha);\n  return vec2(coord.x * cosA - coord.y * sinA, coord.x * sinA + coord.y * cosA);\n}\n\nvec3 scene(in vec2 uv) {\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    col += sin_shape(uv, 0.3) * 0.2;\n    col += sin_shape(uv, 0.7) * 0.2;\n    col += sin_shape(uv, 1.1) * 0.2;\n\n    vec3 fragColor;\n    \nif (col.x >= 0.6 ) {\t\t\tfragColor = vec3(0.12549019607843137, 0.043137254901960784, 0.4117647058823529);\n    } else if (col.x >= 0.4) {\tfragColor = vec3(0.27254901960784315, 0.05411764705882353, 0.607843137254902);\n    } else if (col.x >= 0.2) {\tfragColor = vec3(0.7215686274509804, 0.19215686274509805, 0.7294117647058823);\n    } else {\t\t\t\t\tfragColor = vec3(0.8352941176470589, 0.3764705882352941, 0.6588235294117647);\n    }\n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = rotate(fragCoord + vec2(0.0, -300.0), 0.5);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 col0 = scene((fragCoord * 2.0)/iResolution.xy);\n    vec3 col1 = scene((-(fragCoord * 2.0) + vec2(1.0, 0.0))/iResolution.xy);\n    vec3 col2 = scene((-(fragCoord * 2.0) + vec2(1.0, 1.0))/iResolution.xy);\n    vec3 col3 = scene(((fragCoord * 2.0) + vec2(0.0, 1.0))/iResolution.xy);\n\n    // Output to screen\n    fragColor = vec4((col0 + col1 + col2 + col2) / 4.0,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdf3R2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 223]], "test": "untested"}
{"id": "mdXGR2", "name": "forest fire percolation", "author": "timeiskey", "description": "asdfgaerg", "tags": ["emergentthings"], "likes": 2, "viewed": 215, "published": 3, "date": "1666418481", "time_retrieved": "2024-07-30T16:25:23.707272", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define M 1.0\n#define HOOD_WIDTH 1.0 * M\n#define HOOD_HEIGHT 1.0 * M\n#define TREE_DENSITY 0.35\n#define FIRE_DENSITY 0.0000000000000000000001\n\nfloat rand(vec2 co){\n  \treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * length(iDate));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cellWidth = 1.0/iResolution.xy;\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t//\tsample yourself\n    vec4 cell = texture(iChannel0, uv);\n    \n    //  are you a tree\n    if(cell.g == 1.0){\n        //  check if neighbors are on fire with diagonals\n        for( float yi = -HOOD_HEIGHT; yi <= HOOD_HEIGHT; yi++ )\n        {\n            for( float xi = -HOOD_WIDTH; xi <= HOOD_WIDTH; xi++ )\n            {\n                vec2 xy = vec2(xi,yi) * cellWidth + uv;\n                xy = vec2(mod(xy.x, 1.0), mod(xy.y, 1.0) );\n                vec4 neighbor = texture(iChannel0, xy);\n                if( neighbor.r == 1.0){\n                    cell.g = 0.0;\n                    cell.r = 1.0;\n                }\n            }\n        }\n    }  \n    fragColor = cell;\n    \n    //  reset on click\n    if (iMouse.z >=0.0){\n        vec4 fire = min( vec4(1.0, 0.0, 0.0,1.0) * vec4(step(rand(uv),FIRE_DENSITY)), 1.0);        \n        vec4 tree = min( vec4(0.0, 1.0, 0.0,1.0) * vec4(step(rand(uv),TREE_DENSITY)), 1.0);        \n        fragColor = tree + fire;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdXGR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 138]], "test": "untested"}
{"id": "ddf3Rj", "name": "Hexagonererer [sound]", "author": "ShnitzelKiller", "description": "Hey did this shader I remember called \"hexagoner\" get taken down or something? This is a shitty recreation. Could someone tell me what the song was called at least? I think the lyrics were \"from the front to back\" or something.\n\nreset time to hear music", "tags": ["artistsrendition"], "likes": 8, "viewed": 252, "published": 3, "date": "1666396715", "time_retrieved": "2024-07-30T16:25:24.451282", "image_code": "#define fdist 1.\n\nfloat terrible_sdf(vec2 p)\n{\n    p *= 3.;\n    p.x *= .5 * 2.; //0.57735\n    p += 0.5;\n\tp.y += floor(p.x) * 0.5;\n\tp = abs(fract(p) - 0.5);\n\treturn abs(max(p.x * 1.5 + p.y, p.y * 2.0) - 1.0);\n}\n\nfloat terrible_hex(vec3 ro, vec3 rd, float height, float scale)\n{\n    float d = (height-ro.z) / rd.z;\n    vec2 planeuv = ro.xy + d * rd.xy;\n    \n    d = terrible_sdf(planeuv * scale) - .1;\n    return smoothstep(1.5, 0., d/fwidth(d));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 ro = vec3(sin(iTime), cos(iTime), 2.+sin(iTime/3.) + sin(iTime * 10.) * smoothstep(0.6, 0.9, abs(sin(iTime/4.))));\n    //vec3 ro = vec3(0., 0.01, 100.);\n    vec3 target = vec3(0.);\n    \n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.x;\n    vec3 nw = normalize(target-ro);\n    vec3 up = vec3(0.,0.,1.);\n    vec3 nu = normalize(cross(nw, up));\n    vec3 nv = cross(nu, nw);\n   \tvec3 rd = normalize(nw*fdist + uv.x*nu + uv.y*nv);\n    \n    \n    float hex = terrible_hex(ro, rd, 0., 1.);\n    float hex2 = terrible_hex(ro, rd, -1. + 0.5 * sin(iTime*1.75), 2. + smoothstep(0.4, 0.6, sin(iTime*0.8)));\n\n    // Output to screen\n    fragColor = vec4(mix(vec3(1.), vec3(0.8, 0.8, 1.) * hex2, 1.-hex),1.0);\n}", "image_inputs": [], "sound_code": "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    float a[] = float[](2.5, 2.75, 2.5, 2.5, 2.3, 2.3, 1.5, 1.5,1.5,1.5, 2.5, 2.5, 2.3, 2.3, 1.5, 1.5,1.5,1.5, 6., 7., 8.);\n    float freq = a[int(floor(time*3.)) % 18];\n    return vec2( sin(6. * 440. * freq * time )*0.2 );\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddf3Rj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 46, 46, 209], [211, 211, 276, 276, 446], [449, 449, 506, 556, 1271]], "test": "untested"}
{"id": "DsX3Rj", "name": "Graphic Design Experiment 1", "author": "yasuo", "description": "Graphic Design Experiment 1", "tags": ["graphicdesign", "cineshader"], "likes": 63, "viewed": 3243, "published": 3, "date": "1666369612", "time_retrieved": "2024-07-30T16:25:25.203272", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n\nfloat SimpleVesicaDistance(vec2 p, float r, float d) {\n    p.x = abs(p.x);\n    p.x+=d;\n    return length(p)-r;\n}\n\nfloat triOutside(vec2 p){\n    vec2 prevP = p;\n\n    p.x*=1.5;\n    \n    float d = abs(Tri(p,vec2(0.175),radians(45.)))-0.001;\n    \n    p*=1.5;\n    p += vec2(0.0,0.05);\n    float d2 = abs(Tri(p,vec2(0.175),radians(45.)))-0.001;\n    d = min(d,d2);\n    \n    p*=1.5;\n    p += vec2(0.0,0.06);\n    d2 = abs(Tri(p,vec2(0.175),radians(45.)))-0.001;\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y+=0.11;\n    d2 = abs(length(p)-0.015)-0.001;    \n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat triAnimation(vec2 p){\n    vec2 prevP = p;\n    \n    p.y-=iTime*0.1+0.09;\n    p.y = mod(p.y,0.16)-0.08;\n    p.y -=0.01;\n    p.x*=1.5;\n    float d = Tri(p-vec2(0.0,0.032),vec2(0.015),radians(45.)); \n    float d2 = abs(Tri(p,vec2(0.02),radians(45.)))-0.001; \n    d = min(d,d2);\n    d2 = abs(Tri(p-vec2(0.0,-0.04),vec2(0.03),radians(45.)))-0.001; \n    d = min(d,d2);\n    \n    p = prevP;\n    d = max(abs(p.y)-0.06,d);\n    \n    return d;\n}\n\nfloat waveCircle(vec2 p, float s, float numW, float amp, float deg, float thickness){\n    float r = s+amp*cos(atan(p.y,p.x)*numW);\n    float d = abs(length(p)-r)-thickness;    \n    p*=Rot(radians(deg));\n    r = s+amp*cos(atan(p.y,p.x)*numW);\n    float d2 = abs(length(p)-r)-thickness;  \n    d = min(d,d2);    \n    return d;\n}\n\nvec3 centerGraphic(vec2 p, vec3 col){\n    p*=1.2;\n    vec2 prevP = p;\n    float thickness = 0.003;\n    float deg = -40.;\n    float speed0 = -iTime*30.;\n    float speed1 = iTime*20.;\n    float speed2 = -iTime*10.;\n    float speed3 = iTime*15.;\n    float speed4 = iTime*25.;\n    \n    p*=Rot(radians(speed0));\n    p = DF(p,3.0);\n    p -= vec2(0.205);\n    \n    p*=Rot( radians(deg));\n    float a = atan(p.x,p.y);\n    float d = abs(length(p)-0.039)-thickness;\n    d = max(-p.x,d);\n    \n    col = mix(col,vec3(1.)*a,S(d,0.0));\n    \n    p = prevP;\n    p*=Rot(radians(speed0));\n    \n    float deg2 = -44.5;\n    p*=Rot( radians(deg2));\n    p = DF(p,3.0);\n    p -= vec2(0.2);\n    \n    p*=-1.;\n    p*=Rot( radians(deg));\n    a = atan(p.x,p.y);\n    d = abs(length(p)-0.04)-thickness;\n    d = max(-p.x,d);\n    col = mix(col,vec3(1.)*a,S(d,0.0));\n    \n    p = prevP;\n    \n    d = abs(length(p)-0.29)-thickness;\n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    p*=Rot(radians(speed1));\n    p+=sin(p*25.)*0.025;\n    d = abs(length(p)-0.37)-thickness*0.2;\n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    p = prevP;\n    p*=Rot(radians(speed0));\n    \n    p = DF(p,3.0);\n    p -= vec2(0.217);\n    d = abs(length(p)-0.007)-0.0005;\n    col = mix(col,vec3(1.),S(d,0.0));\n        \n    p = prevP;\n    p*=Rot(radians(speed0));\n    \n    p*=Rot( radians(deg2));\n    p = DF(p,3.0);\n    p -= vec2(0.19);\n    d = abs(length(p)-0.007)-0.0005;\n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    p = prevP;\n    p*=Rot(radians(speed0));\n    \n    p*=Rot( radians(deg2));\n    p = DF(p,3.0);\n    p -= vec2(0.225);\n    d = abs(length(p)-0.015)-0.002;\n    col = mix(col,vec3(1.),S(d,0.0));    \n    \n    p = prevP;\n    p*=Rot(radians(speed0));\n    \n    p = DF(p,3.0);\n    p -= vec2(0.18);\n    d = abs(length(p)-0.015)-0.0005;\n    col = mix(col,vec3(1.),S(d,0.0));    \n    \n    p = prevP;\n    p*=Rot(radians(speed2));\n    p = DF(p,6.0);\n    p -= vec2(0.161);\n    d = max(-(length(p)-0.012),abs(length(prevP)-0.21)-0.02);\n    p += vec2(0.024);\n    d = max(-(length(p)-0.012),d);\n    \n    col = mix(col,vec3(1.),S(abs(d)-0.002,0.0));  \n    \n    p = prevP;\n    p*=Rot(radians(speed3));\n    p = DF(p,6.0);\n    p -= vec2(0.11);\n    p*=Rot( radians(45.));\n    p.y*=2.0;\n    d = abs(SimpleVesicaDistance(p,0.12,0.11))-0.0005;\n    col = mix(col,vec3(1.),S(d,0.0));        \n    \n    p = prevP;\n    p*=Rot(radians(speed4));\n    p = DF(p,3.0);\n    p -= vec2(0.075);\n    p*=Rot( radians(45.));\n    d = abs(B(p,vec2(0.02,0.01)))-0.002;\n    col = mix(col,vec3(1.),S(d,0.0));    \n    \n    p = prevP;\n    p*=Rot(radians(speed2));\n    p*=Rot( radians(90.));\n    p = DF(p,1.5);\n    p -= vec2(0.04);\n    d = abs(length(p)-0.025)-0.0005;\n    col = mix(col,vec3(1.),S(d,0.0));        \n    \n    p = prevP;\n    p*=Rot( radians(-60.));\n    p = DF(p,1.5);\n    p -= vec2(0.032);\n    p*=Rot( radians(45.));\n    d = B(p,vec2(0.04,0.003));\n    col = mix(col,vec3(1.),S(d,0.0));       \n    \n    p = prevP;\n    p*=Rot( radians(45.));\n    d = abs(B(p,vec2(0.015)))-0.001;\n    col = mix(col,vec3(1.),S(d,0.0));   \n    \n    p = prevP;\n    p*=Rot(radians(-speed2*0.5));\n    p = DF(p,24.0);\n    p -= vec2(0.29);\n    d = abs(B(p,vec2(0.005, 0.2)))-0.0005;\n    col = mix(col,vec3(1.),S(d,0.0));   \n    \n    p = prevP;\n    p*=Rot(radians(-speed3));\n    p = DF(p,2.);\n    p -= vec2(0.4);\n    p*=Rot( radians(45.));\n    \n    d = triOutside(p);\n\n    d = max(-(length(prevP)-0.44),d);\n    col = mix(col,vec3(1.),S(d,0.0)); \n    \n    p = prevP;\n    p*=Rot(radians(-speed3));\n    p = DF(p,2.);\n    p -= vec2(0.32);\n    p*=Rot( radians(45.));\n    d = B(p,vec2(0.12, 0.2));\n    \n    p = prevP;\n    d = max(-d, abs(length(p)-0.47)-0.01);\n    col = mix(col,vec3(1.),S(abs(d)-0.001,0.0)); \n    \n    p = prevP;\n    p*=Rot(radians(-speed3));\n    p = DF(p,2.);\n    p -= vec2(0.32);\n    p*=Rot( radians(45.));\n    d = B(p,vec2(0.08, 0.2));\n    \n    p = prevP;\n    d = max(-d, abs(length(p)-0.53)-0.01);\n    col = mix(col,vec3(1.),S(abs(d)-0.001,0.0));     \n    \n    p = prevP;\n    p = DF(p,1.999);\n    p -= vec2(0.475);\n    p*=Rot( radians(45.));\n    d = triAnimation(p);\n    col = mix(col,vec3(1.),S(d,0.0)); \n    \n    p = prevP;\n    p*=Rot(radians(-speed3));\n    d = waveCircle(p,0.485,10.,0.052,18.,0.001);\n    \n    p = prevP;\n    p*=Rot(radians(-speed2));\n    float d2 = waveCircle(p,0.585,10.,0.012,18.,0.001);\n    d = min(d,d2);\n    col = mix(col,vec3(1.),S(d,0.0)); \n    \n    return col;\n}\n\nfloat graphicItem0(vec2 p){\n    vec2 prevP2 = p;\n    p.x+=iTime*0.2;\n    p.x+=0.2;\n    p.x = mod(p.x,0.2)-0.1;\n    p.x-=0.02;\n    p*=1.5;\n    p.x*=-1.;\n    vec2 prevP = p;\n    \n    float d = B(p,vec2(0.1,0.015));\n    float a = radians(45.0);\n    p.x = abs(p.x)-0.065;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    p = prevP;\n    float d2 = B(p-vec2(0.09,-0.008),vec2(0.08,0.007));\n    d = min(d,d2);\n    p.x-=0.145;\n    a = radians(55.0);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    \n    p = prevP;\n    \n    p-=vec2(0.0,-0.01);\n    d2 = B(p,vec2(0.06,0.01));\n    a = radians(45.0);\n    p.x = abs(p.x)-0.035;\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);    \n    d = max(-d2,d);\n    \n    p = prevP2;\n    d = max(abs(p.x)-0.25,d);\n    \n    return d;\n}\n\nfloat graphicItem1(vec2 p){\n    vec2 prevP = p;\n    p.x-=iTime*0.1;\n    p.y-=0.03;\n    p.x = mod(p.x,0.06)-0.03;\n    float d = abs(Tri(p,vec2(0.02),radians(45.)))-0.001;\n    p = prevP;\n    \n    p.x+=iTime*0.06;\n    p.x+=0.03;\n    p.y+=0.03;\n    p.x = mod(p.x,0.06)-0.03;\n    p.y*=-1.0;\n    \n    float d2 = Tri(p,vec2(0.02),radians(45.));\n    d = min(d,d2);\n    \n    p = prevP;\n    d = max(abs(p.x)-0.2,d);\n    \n    return d;\n}\n\nfloat graphicItem2(vec2 p){\n    vec2 prevP = p;\n    \n    p.x+=iTime*0.08;\n    p.x = mod(p.x,0.12)-0.06;\n    p.x+=0.05;\n    p.x*=-1.;\n    p*=Rot(radians(90.));\n    p.x*=3.;\n    p.y*=0.3;\n    float d = Tri(p,vec2(0.03),radians(45.));\n    \n    p = prevP;\n    d = max(abs(p.x)-0.2,d);\n    \n    return d;\n}\n\nfloat graphicItem3(vec2 p){\n    vec2 prevP = p;\n    \n    p.x-=iTime*0.12;\n    p.x = mod(p.x,0.3)-0.15;\n\n    float d = length(p)-0.01;\n    float d2 = length(p-vec2(-0.06,0.0))-0.013;\n    d = min(d,d2);\n    d2 = length(p-vec2(0.06,0.0))-0.007;\n    d = min(d,d2);\n    d2 = length(p-vec2(-0.12,0.0))-0.014;\n    d = min(d,d2);\n    d2 = length(p-vec2(0.12,0.0))-0.005;\n    d = min(d,d2);\n    \n    p = prevP;\n    d = max(abs(p.x)-0.25,d);\n    \n    return d;\n}\n\nfloat graphicItem4(vec2 p){\n    vec2 prevP = p;\n    float d = abs(length(p)-0.04)-0.001;\n    p*=Rot(radians(iTime*50.));\n    float d2 = abs(length(p)-0.026)-0.006;\n    d2 = max(-(abs(p.x)-0.01),d2);\n    d = min(d,abs(d2)-0.001);\n    \n    return d;\n}\n\nfloat graphicItem5(vec2 p){\n    vec2 prevP = p;\n    p.x*=0.8;\n    float d = abs(Tri(p,vec2(0.06),radians(45.)))-0.001;\n    float d2 = abs(Tri(p,vec2(0.06),radians(45.)))-0.005;\n    p.y+=0.05;\n    p*=Rot(radians(45.+iTime*-70.));\n    d2 = max(-(abs(p.y)-0.02),d2);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat graphicItem6(vec2 p){\n    vec2 prevP = p;\n    float d = abs(Tri(p,vec2(0.025),radians(45.)))-0.001;\n    float d2 = Tri(p-vec2(0.055,-0.01),vec2(0.015),radians(45.));\n    d = min(d,d2);\n    return d;\n}\n\nfloat graphicItem7(vec2 p){\n    vec2 prevP = p;\n    p.x-=iTime*0.12;\n    p.x = mod(p.x,0.07)-0.035;\n    p.x-=0.0325;\n    \n    p*=vec2(0.9,1.5);\n    p*=Rot(radians(90.));\n    float d = Tri(p,vec2(0.05),radians(45.));\n    d = max(-Tri(p-vec2(0.,-0.03),vec2(0.05),radians(45.)),d);\n    d = abs(d)-0.001;\n    p = prevP;\n    d = max(abs(p.x)-0.15,d);\n    return d;\n}\n\nfloat graphicItems(vec2 p) {\n    \n    vec2 prevP = p;\n    \n    p-=vec2(-0.71,-0.33);\n    p*=Rot(radians(-25.));\n    float d = graphicItem0(p);\n    \n    p = prevP;\n    \n    p-=vec2(-0.7,-0.16);\n    p*=Rot(radians(-15.));\n    float d2 = graphicItem1(p);\n    \n    d = min(d,d2);\n        \n    p = prevP;\n    \n    p-=vec2(-0.585,-0.44);\n    p*=Rot(radians(-35.));\n    d2 = graphicItem2(p);\n    \n    d = min(d,d2);\n    \n    p = prevP;\n    \n    p-=vec2(-0.73,-0.26);\n    p*=Rot(radians(-20.));\n    d2 = abs(graphicItem3(p))-0.001;\n    \n    d = min(d,d2);    \n    \n    p = prevP;\n    \n    p-=vec2(-0.67,-0.4);\n    p*=Rot(radians(-30.));\n    d2 = graphicItem3(p);\n    \n    d = min(d,d2);    \n    \n    p = prevP;\n    \n    p-=vec2(-0.78,-0.09);\n    p*=Rot(radians(-10.));\n    d2 = graphicItem3(p);\n    \n    d = min(d,d2);        \n    \n    p = prevP;\n    d2 = graphicItem4(p-vec2(-0.34,-0.45));\n    d = min(d,d2); \n    \n    d2 = graphicItem5(p-vec2(-0.48,-0.42));\n    d = min(d,d2); \n    \n    d2 = graphicItem6(p-vec2(-0.265,-0.46));\n    d = min(d,d2); \n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 prevP = p;\n    \n    vec3 col = vec3(0.);\n    \n    col = centerGraphic(p,col);\n    \n    p = abs(p);\n    p*=Rot(radians(180.));\n    float d = graphicItems(p);\n    col = mix(col,vec3(0.6),S(d,0.));\n    \n    p = prevP;\n    p.x = abs(p.x)-0.77;\n    d = graphicItem7(p);\n    col = mix(col,vec3(0.6),S(d,0.));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsX3Rj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[443, 443, 497, 497, 555], [557, 557, 582, 582, 1030], [1032, 1032, 1059, 1059, 1470], [1472, 1472, 1557, 1557, 1797], [1799, 1799, 1836, 1836, 6192], [6194, 6194, 6221, 6221, 6946], [6948, 6948, 6975, 6975, 7374], [7376, 7376, 7403, 7403, 7677], [7679, 7679, 7706, 7706, 8131], [8133, 8133, 8160, 8160, 8382], [8384, 8384, 8411, 8411, 8687], [8689, 8689, 8716, 8716, 8895], [8897, 8897, 8924, 8924, 9258], [9260, 9260, 9288, 9288, 10322], [10324, 10324, 10381, 10381, 10786]], "test": "untested"}
{"id": "dslGzS", "name": "Not So Dumb Feedback Shader", "author": "byt3_m3chanic", "description": "    not so dumb feedback shader..idea from @spalmer for time, and using a bayer texture\n    for dithering @Fabrice", "tags": ["notsodumbfeedbackshader"], "likes": 17, "viewed": 281, "published": 3, "date": "1666368396", "time_retrieved": "2024-07-30T16:25:26.003133", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    not so dumb feedback shader.. now with new idea from @spalmer for using time, and \n    from @Fabrice using a bayer texture for dithering.\n    \n    10/21/22 @byt3_m3chanic \n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    vec3 C = vec3(0);\n    vec2 uv = F.xy/R.xy;\n    \n    vec2 cuv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    C = texture(iChannel0,uv).rgb; \n    float px = 2./R.x;\n    \n\n    float d= max(box(cuv,vec2(.95,.51)),-box(cuv,vec2(.93,.49)));\n    d=smoothstep(px,-px,d);\n    \n    C = mix(C,vec3(1),d);\n    \n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    not so dumb feedback shader.. now with new idea from @spalmer for using time, and \n    from @Fabrice using a bayer texture for dithering.\n    \n    10/21/22 @byt3_m3chanic \n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI2 6.28318530718\n#define PI  3.14159265359\n\nfloat time;\nconst float scale = 3.;\n\nmat2 rot(float g) {return mat2(cos(g), sin(g),-sin(g), cos(g));}\nfloat hash21( vec2 p ) {return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234);}\n\nvec3 hue(float t){ \n    const vec3 c = vec3(0.902,0.878,0.820);\n    return .4 + .4*cos(PI2*t*(c+vec3(0.000,0.475,0.839))); \n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    //@Fabrice\n    time =  texture(iChannel1,F/8.).r * iTimeDelta;\n    \n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    vec2 vuv = uv;\n    \n    // comment out for alt version\n    uv*=rot(-T*.07);\n    \n    //@spalmer\n    vec3 C = texture(iChannel0,(F.xy/R.xy)).rgb*exp2(-2.*time);\n    \n    uv.y-=1.25+1.*sin(T*.075);\n    uv.x-=.25*cos((T*.5)+1.*sin(T*.05));\n    \n    float px = scale/R.x;\n\n    vec2 id= floor(uv*scale);\n    vec2 p = fract(uv*scale)-.5;\n    \n    \n    float hf = hash21(id);\n    float sc = 1.;\n    float xk = .02;\n    if(hf>.5){\n        id= floor(p+id*2.);\n        p = fract(p*2.)-.5;\n        hf = hash21(id);\n        px = scale*2./R.x;\n        xk = .03;\n        sc *= hf;\n        if(hf>.375){\n            id= floor(p+id*2.);\n            p = fract(p*2.)-.5;\n            hf = hash21(id);\n            px = scale*4./R.x;\n            xk = .04;\n            sc = hf;\n            if(hf>.75){\n                id= floor(p+id*2.);\n                p = fract(p*2.)-.5;\n                hf = hash21(id);\n                px = scale*8./R.x;\n                xk = .05;\n                sc = hf;\n            }\n        }\n    }\n\n    float xf = .22+.1*sin((T*hf)*1.5);\n    float d1 = length(p)-(sc*(xf-xk));\n    d1=smoothstep(px,-px,abs(d1)-xk);\n\n    float ff = vuv.y*.075;\n    vec3 clr=mix(hue((ff*PI)+T*.05),hue(((1.-ff)*PI)+T*.025),ff);\n    C = mix(C,hf>.6?clr:hf>.45?vec3(.1):vec3(.03),d1);\n\n    O = vec4(C,1.);\n}\n", "buffer_a_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dslGzS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[334, 334, 368, 368, 448], [449, 449, 490, 490, 834]], "test": "untested"}
{"id": "dds3zB", "name": "Crossfire", "author": "Danguafer", "description": "Variation of Abduction", "tags": ["bloom", "stripes"], "likes": 16, "viewed": 566, "published": 3, "date": "1666365102", "time_retrieved": "2024-07-30T16:25:26.758115", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0 , uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "mat2 rotate(float a) {\n    return mat2(sin(a), cos(a),\n               -cos(a), sin(a));\n}\n\nmat2 identity() {\n    return mat2(1.0, 0.0, 0.0, 1.0);\n}\n\nmat2 mix(mat2 a, mat2 b, float m) {\n    m = clamp(m, 0.0, 1.0);\n    return (1.0 - m) * a + m * b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.0 * uv - 1.0) * vec2(iResolution.x/iResolution.y, 1.0);\n\n    vec3 color = vec3(0.0);\n    int iterations = int(min(iTime + 1.0, 64.0));\n    for (int i = 1; i < iterations; i++) {\n        float id = float(i);\n        float radius = hash11(id);\n        float objTime = iTime + hash11(id * 321.0 + 123.0);\n        vec2 offset = 4.0 * (vec2(hash11(floor(objTime) + id), 0.0) - vec2(0.5, 0.0));\n        vec2 position = p + offset;\n        position *= rotate(hash11(floor(objTime) * 3.256) + id + floor(objTime));\n        float objShape = abs(position.x);\n        float lifeTime = mod(objTime, 1.0);\n        float objSize = (smoothstep(0.0, 0.05, lifeTime) * smoothstep(1.0, 0.0, lifeTime)) * 0.05;\n        float objMask = step(objShape, objSize);\n        vec3 objColor = 0.5 * vec3(0.25, 0.5, 0.25) + hash31(id) * vec3(1.0, 0.1, 0.75);\n        color = mix(color, objColor, objMask);\n    }\n    fragColor = texture(iChannel0, uv) * 0.15 + vec4(color, 1.0);\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//----------------------------------------------------------------------------------------\n// 1 out 4 in...\nfloat hash14(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "buffer_b_code": "#define PI acos(-1.0)\n#define TAU (PI * 2.0)\n\nvec2 random2(vec3 o) {\n    return hash23(floor(o)) - 0.5;\n}\n\nfloat random(vec3 o) { // 0..1\n    return hash13(floor(o));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 color = texture(iChannel0, uv).xyz;\n    for (int i = 0; i < 256; i++) {\n        float angle = random(vec3(uv * 4321.0, iTime * 123.0 + float(i))) * TAU;\n        float radius = random(vec3(uv * 1234.0, iTime * 321.0 + 3.0 * float(i)));\n        float size = 0.25;\n        float length = radius * size;\n        vec2 offset = vec2(cos(angle), sin(angle)) * length;\n        offset.x /= iResolution.x / iResolution.y;\n        vec2 nuv = uv + offset;\n        color += texture(iChannel0, nuv).xyz * pow(smoothstep(size, 0.0, length) * 0.2, 2.4);\n    }\n    fragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dds3zB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 139]], "test": "untested"}
{"id": "msl3zB", "name": "Abduction", "author": "Danguafer", "description": "Just a quick draft with some lazy/expensive bloom code", "tags": ["bloom", "stripes"], "likes": 13, "viewed": 457, "published": 3, "date": "1666365031", "time_retrieved": "2024-07-30T16:25:27.505118", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0 , uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#ifdef MUSIC\n#define iTime (iChannelTime[1]*1.1666666666+1.5)\n#endif\n\nmat2 rotate(float a) {\n    return mat2(sin(a), cos(a),\n               -cos(a), sin(a));\n}\n\nmat2 identity() {\n    return mat2(1.0, 0.0, 0.0, 1.0);\n}\n\nmat2 mix(mat2 a, mat2 b, float m) {\n    m = clamp(m, 0.0, 1.0);\n    return (1.0 - m) * a + m * b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.0 * uv - 1.0) * vec2(iResolution.x/iResolution.y, 1.0);\n\n    vec3 color = vec3(0.0);\n    #ifdef MUSIC\n    int iterations = int(min(max(iTime, 9.0) - 7.0, 64.0));\n    #else\n    int iterations = int(min(iTime + 1.0, 64.0));    \n    #endif\n    for (int i = 1; i < iterations; i++) {\n        float id = float(i);\n        float radius = hash11(id);\n        float objTime = iTime + hash11(id * 321.0 + 123.0);\n        vec2 offset = 4.0 * (vec2(hash11(floor(objTime) + id * 987.432), 0.0) - vec2(0.5, 0.0));\n        vec2 position = p + offset;\n        //position *= rotate(id);\n        float objShape = abs(position.x);\n        float lifeTime = mod(objTime, 1.0);\n        float objSize = (smoothstep(0.0, 0.05, lifeTime) * smoothstep(1.0, 0.0, lifeTime)) * 0.05;\n        float objMask = step(objShape, objSize);\n        vec3 objColor = 0.5 * vec3(0.25, 0.5, 0.25) + hash31(id) * vec3(1.0, 0.1, 0.75);\n        color = mix(color, objColor, objMask);\n    }\n    fragColor = texture(iChannel0, uv) * 0.15 + vec4(color, 1.0);\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define MUSIC https://soundcloud.com/siriusmo/auf-wiedersehen\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//----------------------------------------------------------------------------------------\n// 1 out 4 in...\nfloat hash14(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n", "buffer_b_code": "#define PI acos(-1.0)\n#define TAU (PI * 2.0)\n\nvec2 random2(vec3 o) {\n    return hash23(floor(o)) - 0.5;\n}\n\nfloat random(vec3 o) { // 0..1\n    return hash13(floor(o));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 color = texture(iChannel0, uv).xyz;\n    for (int i = 0; i < 256; i++) {\n        float angle = random(vec3(uv * 4321.0, iTime * 123.0 + float(i))) * TAU;\n        float radius = random(vec3(uv * 1234.0, iTime * 321.0 + 3.0 * float(i)));\n        float size = 0.25;\n        float length = radius * size;\n        vec2 offset = vec2(cos(angle), sin(angle)) * length;\n        offset.x /= iResolution.x / iResolution.y;\n        vec2 nuv = uv + offset;\n        color += texture(iChannel0, nuv).xyz * pow(smoothstep(size, 0.0, length) * 0.2, 2.4);\n    }\n    fragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msl3zB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 139]], "test": "untested"}
{"id": "ddlGRS", "name": "Tubular trails", "author": "z0rg", "description": "Inspired by https://www.shadertoy.com/view/csXGzS", "tags": ["particles", "abstract", "dots", "tube", "trails", "tubular"], "likes": 10, "viewed": 387, "published": 3, "date": "1666347330", "time_retrieved": "2024-07-30T16:25:28.249128", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 ouv = fragCoord/iResolution.xy;\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n\n    ouv -= vec2(.5);\n    ouv *= .8; // To avoid seeing clamping on texture border\n    ouv *= r2d(.1*sin(length(uv)*20.+iTime));\n        ouv += vec2(.5);\n    vec3 col = texture(iChannel0, ouv).xyz;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 ouv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    float sharp = iResolution.x;\n    vec3 col = texture(iChannel0, ouv).xyz;\n    float time = iTime;\n    float stp = .05;\n    time = floor(time/stp)*stp;\n    for (float i = 0.; i < 8.; ++i)\n    {\n        vec2 pos = uv*r2d((i/8.)*2.*PI)+vec2((sin(time*10.))*.02, pow(time*.1, .75));\n\n        float shape = length(pos)-mix(0.05, .02, sin(time*5.)*.5+.5);\n        float outline = abs(shape)-0.00005;\n        vec3 color = mix(vec3(.2,.4,.5), vec3(.2,.4,.5).zxy, sin(time*20.)*.5+.5);\n        vec3 rgb = mix(color*2., vec3(1.), sin(time*10.)*.5+.5);\n        col = mix(col, vec3(0.), 1.-sat(shape*sharp));\n        col = mix(col, rgb, 1.-sat(outline*sharp));\n        col += rgb *(1.-sat(outline*20.))*.01;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\nfloat hash11(float seed)\n{\n    return fract(sin(seed*123.456)*123.456);\n}\nmat2 r2d(float a) { float c = cos(a),s=sin(a);return mat2(c, -s, s, c);}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddlGRS.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 789]], "test": "untested"}
{"id": "DdlGzS", "name": "Fractal mosaic 24 (music)", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 4, "viewed": 193, "published": 3, "date": "1666334027", "time_retrieved": "2024-07-30T16:25:28.995133", "image_code": "#define fmod(x,y) mod(floor(x),y)\nvec2 triangle_wave(vec2 a){\n    vec2 a2 = //change this constant to get other interesting patterns\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n        //*atan(a1.y,a1.x) //another nice variation\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    vec2 uv = (fragCoord)/iResolution.y/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/2.;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    bool t3 = true;\n    for(int k = 0; k < 6; k++){\n        t3 =\n            uv.x < uv.y\n            //(uv.x < uv.y || t3) || (uv.x > uv.y || !t3)\n        ;\n\n        //uv.x += 1.;\n        uv =\n            abs(.5+uv+t2)\n        ;\n        //uv.x += 1.;\n        t2 =\n            -triangle_wave(uv-1.5)\n        ;\n        uv =\n            t2-triangle_wave(uv.yx)\n        ;\n        float c1 =\n            uv.x-uv.y\n        ;\n        col = col.yzx;\n        if(t3) col = abs(vec3(col.yz,c1));\n       \n\n    }\n    fragColor = vec4(min(col*2.,vec3(1.)),1.0);\n}\n", "image_inputs": [], "sound_code": "float fmod1(float a, float b){\n    //divide by powers of 2 to get interesting rhythms\n    float a1 = a;\n    //a /= 1. + mod(floor(a1/8.),2.);\n    //a /= 1. + mod(floor(a1/4.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    return\n        mod(floor(a),b)\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n    ;\n}\n\nfloat fmod(float a, float b){\n    return\n        fmod1(a,b)\n        //mod(fmod1(a,b*(1.+mod(floor(a),8.))),b)\n    ;\n}\n\n\n//#define fmod(a,b) mod(mod(floor((a)),floor(1.+(a)/5.)),b)\n\nvec2 mainSound(int samp, float time){\n  \n  float s1 =\n      8.,\n      //4.*(1.+fmod(floor(time/2.),2.)), //varying tempo\n\n  s2 = 8.,\n  t=\n      \n      time/(1.+fmod(floor(time*s1)*floor(time*s1)/s1/s1,2.))/2.\n  ,\n  m1 =\n      fmod(t/s1+floor(t/s1),s2)\n      //fmod(t+floor(t*s1),s2)\n  ,\n  m4 =\n      fmod(floor(t+m1)/s2,s2)\n  ,\n  m3 =\n      fmod((t+m4)*s1/(m1+.5),s2);\n\n  t *=\n      s1*s1\n  ;\n\n  float m2 =\n      1. + fmod(t/s1,s1);\n  ;\n  \n  float a = 64.*sqrt((1.-sqrt(fract(t/s1+floor(t/s1)))))*.2,\n\n  nb = time*pow(2.,(m3+m2)/5.+5.5);\n\n  return\n      abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a\n      \n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n  ;\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdlGzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 61, 61, 285], [287, 287, 344, 344, 1147]], "test": "untested"}
{"id": "dds3R4", "name": "Antialiasing via Texel Traversal", "author": "fenix", "description": "Experiment to attempt to compute antialiasing by traversing texels.\n\n*mouse to move magnifying glass*\n*shift-mouse to turn camera*\n*arrow keys to move*\n*key A to switch to supersample aa*\n*key S to show step count*\n*space to resume camera spin*", "tags": ["pixel", "voxel", "voxel", "antialiasing", "checker", "aa", "traversal"], "likes": 12, "viewed": 298, "published": 3, "date": "1666332173", "time_retrieved": "2024-07-30T16:25:29.932627", "image_code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Experiment to attempt to compute antialiasing by traversing pixels. This is like\n// voxel traversal, but done in 2D so I guess it traverses pixels instead of voxels.\n// I've seen some stuff written talking about 2D voxels, but to me, that's a pixel,\n// or a texel in this case since the pixels are part of a texture.\n//\n// If you click, you'll move the red \"magnifying glass\" that lets you browse the colors\n// of screen pixels. It also focuses the overhead camera in the inset window, showing\n// a birds-eye view of the situation. The red quadrilateral shows what the pixel's outline\n// projects to on the ground, in context with its surrounding texels. Hopefully you shold\n// see that when the red shape mostly crosses texels of a certain color, the color in the\n// in the magnfying glass (and thus the color on the ground at that point) should be similar.\n//\n// The pixels at the bottom of the screen are pretty boring...it's hard to even hit one that\n// crosses a boundary. But up near the top of the screen things are a bit more interesting.\n//\n// If you hold shift and click and drag with the mouse, you can aim the camera. You can fly\n// the camera around using the arrow keys. Also, pressing space restarts the camera spin.\n//\n// The approximation here is that I integrate the color just linearly, along the shape\n// formed by the projection of the four corners of the pixel. This is the same shape drawn \n// in red in the inset overhead camera view. That's where the texel traversal comes in;\n// it allows me to compute the total length of the shape clipped to each texel. The resulting\n// color is then the average color, weighted by line length.\n//\n// This works pretty well for extremely elongated pixels (close to the horizon) because\n// their projections are very nearly a line anyway. This is demonstrated clearly by\n// how long and skinny horizon pixels become in the inset view.\n//\n// It produces artifacts if you fly far enough into the sky and look down, as the pixel\n// projections grow large enough to encompass an entire texel, because we can go all the\n// way around the interior texel without noticing it.\n//\n// I thought about trying to implement a 2D (maybe DDA) search over all the texels in\n// the projection, but that seems complicated, probably requiring polygon clipping of\n// each square? If there's a cheap way to do this, I'd be interested.\n//\n// I have a feeling that those kind of \"shrinking\" projections (many more texels than\n// screen pixels) are better handled in hardware anyway. Surely once we start to fetch a\n// few hundred texels this way, our GPUS are going to bog down. Maybe this kind of\n// anti-aliasing could be combined with hardware mip maps for some kind of benefit...?\n//\n// You can compare to super-sampled aa by holding the A key, but it's a lot slower. I\n// suppose one of those adaptive antialiasing schemes would be faster, and I'm curious\n// if it would give the same quality and performance as the texel traversal method.\n//\n// Buffer A is only for managing persistent state\n//\n// --------------------------------------------------------------------------------------------\n\nconst vec3 SKY_RGB = vec3(.5, .5, 1.);\nconst vec3 SKY = pow(SKY_RGB, vec3(2.2));\nconst int BLUR = 2; // change to 1 for higher resolution but some shimmering when moving\n\nvec2 norm(vec2 coord)\n{\n     return (2. * coord - iResolution.xy ) / iResolution.y;\n}\n\nvec3 linear2srgb(vec3 linear)\n{\n    return pow(linear, vec3(1./2.2));\n}\n\nvec3 srgb2linear(vec3 srgb)\n{\n    return pow(srgb, vec3(2.2));\n}\n\nvec2 rayHitGround(vec2 p, vec3 cameraPos, vec3 cameraFwd, vec3 cameraUp, vec3 cameraLeft)\n{\n    vec3 ray = fxCalcRay(p, cameraFwd, cameraUp, cameraLeft);    \n    return cameraPos.xz + cameraPos.y * ray.xz / ray.y;\n}\n\nvec2[4] getPixelCornerHits(vec2 p, vec3 cameraPos, vec3 cameraFwd, vec3 cameraUp, vec3 cameraLeft)\n{\n    // sorta-hack: increase pixel size to create some blur. This minimizes some artifacts.\n    vec2 delta = vec2(BLUR, -BLUR) / iResolution.y;\n    return vec2[] (\n        rayHitGround(p + delta.yx, cameraPos, cameraFwd, cameraUp, cameraLeft),\n        rayHitGround(p + delta.yy, cameraPos, cameraFwd, cameraUp, cameraLeft),\n        rayHitGround(p + delta.xy, cameraPos, cameraFwd, cameraUp, cameraLeft),\n        rayHitGround(p + delta.xx, cameraPos, cameraFwd, cameraUp, cameraLeft));\n}\n\nvec3 colorMap(ivec2 mapPos)\n{\n    vec3 result = mix(vec3(abs(mapPos.x + mapPos.y) % 2 == 1), // checker\n        texture(iChannel1, vec2(mapPos) / iChannelResolution[1].xy).xyz, // texture\n        float(mapPos.y >= 0));\n    return result;\n}\n\nvec2 intersectXY(ivec2 xy, vec2 from, vec2 dir) { return (vec2(xy) - from) / dir; }\n\nvec3 pixelTrace(vec2 from, vec2 to)\n{\n    vec2 rayDir = to - from;\n\tivec2 mapPos = ivec2(floor(from));\n\tivec2 finalMapPos = ivec2(floor(to));\n    vec2 cur = from;\n\tvec2 deltaDist = abs(length(rayDir) / rayDir);\n    ivec2 rayStep = ivec2(sign(rayDir));\n    vec2 fixup = sign(rayDir) * 0.5 + 0.5;\n\tvec2 sideDist = (sign(rayDir) * (vec2(mapPos) - from) + fixup) * deltaDist; \n\t\n    vec3 color = vec3(0);\n    float len = 0.;\n    const int MAX_RAY_STEPS = 128;\n\n    int i;\n\tfor (i = 0; i < MAX_RAY_STEPS; i++)\n    {\n\t\tif (mapPos == finalMapPos)\n        {\n            // add the color from the last segment, which only goes to \"to\"\n            color += colorMap(mapPos) * distance(cur, to);\n            cur = to;\n            break;\n        }\n        \n        bvec2 mask = lessThanEqual(sideDist.xy, sideDist.yx);\n        \n        // find where the ray intersects the next pixel\n        vec2 ts = intersectXY(mapPos + ivec2(fixup), from, rayDir);\n        vec2 next = from + rayDir * sum(vec2(mask) * ts);\n        \n        // add up the color weigthed by length\n        color += colorMap(mapPos) * distance(cur, next);\n        cur = next;\n\t\n        // go to the next pixel\n\t\tsideDist += vec2(mask) * deltaDist;\n\t\tmapPos += ivec2(vec2(mask)) * rayStep;\n\t}\n    \n    color /= distance(from, cur);\n    \n    // if we gave up, turn grey (reduces artifacts at horizon from high altitudes)\n    color = mix(color, vec3(.5), float(i == MAX_RAY_STEPS));\n    \n    // handle debug step draw\n    color = mix(color, sin(float(i) * vec3(9,11,33)), float(keyDown(KEY_S)));\n    \n    return color;\n}\n\nvec3 integratePixelEdges(vec2 p, vec3 cameraPos, vec3 cameraFwd, vec3 cameraUp, vec3 cameraLeft)\n{\n    vec2 groundHits[4] = getPixelCornerHits(p, cameraPos, cameraFwd, cameraUp, cameraLeft);\n\n    float len = 0.;\n    vec3 color = vec3(0);\n    for (int i = 0; i < 4; ++i)\n    {\n        vec2 from = groundHits[i];\n        vec2 to = groundHits[(i + 1) % 4];\n        float segLen = distance(from, to);\n        \n        len += segLen;\n        color += pixelTrace(from, to) * segLen;\n    }\n    \n    return color / len;\n}\n\nvec3 superSamplePixel(vec2 p, vec3 cameraPos, vec3 cameraFwd, vec3 cameraUp, vec3 cameraLeft)\n{\n    vec2 points[4] = getPixelCornerHits(p, cameraPos, cameraFwd, cameraUp, cameraLeft);\n\n    const int NUM_SAMPLES_X = 32;\n    const int NUM_SAMPLES_Y = 64;\n    vec2 deltaX = (points[1] - points[0]) / float(NUM_SAMPLES_X - 1);\n    vec2 deltaY = (points[2] - points[1]) / float(NUM_SAMPLES_Y - 1);\n    vec2 rowPos = points[0];\n    vec3 color = vec3(0);\n    \n    for (int i = 0; i < NUM_SAMPLES_X; ++i)\n    {\n        vec2 pos = rowPos;\n        \n        for (int j = 0; j < NUM_SAMPLES_Y; ++j)\n        {\n            ivec2 mapPos = ivec2(floor(pos));\n            color += colorMap(mapPos);\n\n            pos += deltaX;\n        }\n        \n        rowPos += deltaY;\n    }\n    \n    return color / float(NUM_SAMPLES_X * NUM_SAMPLES_Y);\n}\n\nvec3 renderFloor(vec2 p, vec3 cameraPos, vec3 cameraFwd, vec3 cameraUp, vec3 cameraLeft)\n{\n    if (keyDown(KEY_A)) return superSamplePixel(p, cameraPos, cameraFwd, cameraUp, cameraLeft);\n    \n    return integratePixelEdges(p, cameraPos, cameraFwd, cameraUp, cameraLeft);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 state = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(2, 0), 0).xyz;\n    vec3 cameraFwd = spherical(state.zw);\n\n    vec3 cameraLeft, cameraUp;\n    fxCalcCamera(cameraPos, vec3(0, 1, 0), cameraFwd, cameraLeft, cameraUp);\n\n    vec2 p = norm(fragCoord);\n    vec3 rayDir = fxCalcRay(p, cameraFwd, cameraUp, cameraLeft);    \n    vec2 mouseP = norm(state.xy);\n    vec3 mouseDir = fxCalcRay(mouseP, cameraFwd, cameraUp, cameraLeft);    \n    vec2 mouseGroundHit = cameraPos.xz + cameraPos.y * mouseDir.xz / mouseDir.y;\n\n    vec2 INSET_BOTTOM = vec2(.4 * iResolution.x / iResolution.y, -.9);\n    vec2 INSET_TOP = vec2(.95 * iResolution.x / iResolution.y, 0.);\n    float FRAME_WIDTH = 0.01;\n    if (all(greaterThan(p, INSET_BOTTOM - FRAME_WIDTH)) &&\n        all(lessThan(p, INSET_TOP + FRAME_WIDTH)))\n    {\n        // inset frame\n        fragColor = vec4(0,1,0,1);\n        \n        if (all(greaterThan(p, INSET_BOTTOM)) &&\n            all(lessThan(p, INSET_TOP)))\n        {\n            // draw inset\n            if (mouseDir.y >= 0.)\n            {\n                fragColor = vec4(SKY, 1);\n            }\n            else\n            {            \n                vec2 mouseHits[4] = getPixelCornerHits(mouseP, cameraPos, cameraFwd, cameraUp, cameraLeft);\n                vec2 delta0 = mouseHits[0] - mouseGroundHit;\n                vec2 delta1 = mouseHits[1] - mouseGroundHit;\n                float insetScale = max(delta0.x, max(delta0.y, max(delta1.x, delta1.y)));\n                p -= (INSET_TOP + INSET_BOTTOM) * 0.5;                \n                p *= 25.*insetScale / vec2(INSET_TOP - INSET_BOTTOM) * 0.5;\n                p.x *= .32*iResolution.x / iResolution.y;\n\n                vec3 insetCameraPos\t= vec3(mouseGroundHit.x, 1, mouseGroundHit.y);\n                vec3 insetCameraFwd = vec3(0, -1, 0);\n                \n                vec3 insetCameraLeft, insetCameraUp;\n                fxCalcCamera(insetCameraPos, cameraFwd, insetCameraFwd, insetCameraLeft, insetCameraUp);\n\n                vec2 insetGroundHit = rayHitGround(p, insetCameraPos, insetCameraFwd, insetCameraUp, insetCameraLeft);\n                if (insetGroundHit.y < 0.)\n                {\n                    vec2 m = mod(insetGroundHit, vec2(2.));\n                    float sd = min(boxDist(vec2(.5, 1.5), m), boxDist(vec2(1.5, .5), m));\n                    fragColor = vec4(smoothstep(0., insetScale*3./iResolution.y, vec3(.5 - sd)), 1);\n                }\n                else\n                {\n                    fragColor = vec4(renderFloor(p, insetCameraPos, insetCameraFwd, insetCameraUp, insetCameraLeft), 1);\n                }\n                \n                // render pixel outline\n                float d = 0.01 * insetScale;                \n                drawLine(mouseHits[0], mouseHits[1], insetGroundHit, d, d*4., fragColor);\n                drawLine(mouseHits[1], mouseHits[2], insetGroundHit, d, d*4., fragColor);\n                drawLine(mouseHits[2], mouseHits[3], insetGroundHit, d, d*4., fragColor);\n                drawLine(mouseHits[3], mouseHits[0], insetGroundHit, d, d*4., fragColor);\n            }\n        }\n    }\n    else\n    {\n        vec3 floorColor = renderFloor(p, cameraPos, cameraFwd, cameraUp, cameraLeft);\n        fragColor = vec4(mix(SKY, floorColor, float(rayDir.y < 0.)), 1);\n        \n        // draw mouse\n        float mouseDist = distance(mouseP, p);\n        const float d = 0.003;\n        if (mouseDist < d*12.)\n        {\n            vec3 mouseColor = mouseDir.y < 0. ?\n                renderFloor(mouseP, cameraPos, cameraFwd, cameraUp, cameraLeft) :\n                SKY;\n\n            fragColor.xyz = mix(fragColor.xyz, vec3(1,0,0), 1. - smoothstep(d*8., d*9., mouseDist));\n            fragColor.xyz = mix(fragColor.xyz, vec3(mouseColor), 1. - smoothstep(d*6., d*7., mouseDist));\n        }\n    }\n    \n    fragColor.xyz = linear2srgb(fragColor.xyz);\n    fragColor.a = 1.;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// --------------------------------------------------------------------------------------------\n// Handle persistent state: mouse input, attract mode, etc\n// --------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    if (ifc == ivec2(0))\n    {\n        if (iFrame == 0)\n        {\n            fragColor = vec4(0,0,-iResolution.xy);\n            return;\n        }\n\n        fragColor.xy = iMouse.xy; // record previous mouse for diffs\n        fragColor.zw = texelFetch(iChannel0, ifc, 0).zw; // remember resolution; negative means attract mode on\n        if (abs(fragColor.zw) != iResolution.xy || keyDown(KEY_SPACE))\n        {\n            fragColor.zw = -iResolution.xy;\n        }\n        else if (iMouse.z > 0. || keyDown(KEY_LEFT) || keyDown(KEY_UP) || keyDown(KEY_RIGHT) || keyDown(KEY_DOWN))\n        {\n            fragColor.zw = abs(fragColor.zw);\n        }\n        return;\n    }\n    \n    vec4 oldMouseRes = texelFetch(iChannel0, ivec2(0), 0);\n    \n    if (ifc == ivec2(1, 0))\n    {\n        float y = iResolution.y * (.92 + 0.02 * smoothstep(0., 1400., iResolution.y));\n        vec2 initPos = vec2(iResolution.x * .5, y);\n        if (iFrame == 0)\n        {\n            fragColor = vec4(initPos, 0, 2);\n            return;\n        }\n\n        fragColor = texelFetch(iChannel0, ifc, 0);\n        if (oldMouseRes.z < 0.)\n        {\n            // attract mode\n            fragColor.xy = initPos;\n            fragColor.z += 0.001;\n        }\n        else\n        {\n            if (keyDown(KEY_SHIFT))\n            {\n                // turn camera\n                if (iMouse.w < 0. && iMouse.z > 0.)\n                    fragColor.zw -= vec2(2, -2)*(iMouse.xy - oldMouseRes.xy) / iResolution.xy;\n            }\n            else\n            {\n                // move magnifying glass\n                fragColor.xy = iMouse.xy;\n            }\n        }\n        \n        return;\n    }\n    \n    vec4 state = texelFetch(iChannel0, ivec2(1, 0), 0);\n\n    if (ifc == ivec2(2, 0))\n    {\n        if (iFrame == 0)\n        {\n            fragColor = vec4(0, 1, 0, 0);\n            return;\n        }\n        \n        fragColor = texelFetch(iChannel0, ifc, 0);\n        \n        vec3 cameraFwd = spherical(state.zw);\n        cameraFwd.y = -cameraFwd.y;\n        vec3 cameraLeft = -normalize(cross(cameraFwd, vec3(0, 1, 0)));\n        \n        if (keyDown(KEY_UP))\n        {\n            fragColor.xyz -= 0.1 * cameraFwd;\n        }\n        if (keyDown(KEY_DOWN))\n        {\n            fragColor.xyz += 0.1 * cameraFwd;\n        }\n        if (keyDown(KEY_LEFT))\n        {\n            fragColor.xyz -= 0.1 * cameraLeft;\n        }\n        if (keyDown(KEY_RIGHT))\n        {\n            fragColor.xyz += 0.1 * cameraLeft;\n        }\n        fragColor.y = max(0.1, fragColor.y);\n\n        return;\n    }\n    \n    discard;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "void fxCalcCamera(in vec3 cameraPos, in vec3 worldUp, in vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraLeft = -normalize(cross(cameraFwd, worldUp));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd)) * 0.5;\n}\n\nvec3 fxCalcRay(in vec2 screenPos, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nfloat linePointDist(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    vec2 closest;\n    if (deltaLen2 > 1e-10)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    return length(closestDelta);\n}\n\nfloat boxDist(vec2 a, vec2 b) { return max(abs(a.x - b.x), abs(a.y - b.y)); }\nfloat sum(vec2 x) { return x.x + x.y; }\n\nvoid drawLine(vec2 from, vec2 to, vec2 p, float d1, float d2, inout vec4 fragColor)\n{\n    float dist = linePointDist(from, to, p);\n    fragColor = mix(fragColor, vec4(1,0,0,1), 1. - smoothstep(d1, d2, dist));\n}\n\nvec3 spherical(vec2 angles)\n{\n    vec4 sc = vec4(sin(angles), cos(angles));\n    return vec3(sc.y * sc.z, sc.w, sc.y * sc.x);\n}\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_A 65\n#define KEY_S 83\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dds3R4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[3519, 3519, 3542, 3542, 3604], [3606, 3606, 3637, 3637, 3677], [3679, 3679, 3708, 3708, 3743], [3745, 3745, 3836, 3836, 3960], [4550, 4550, 4579, 4579, 4789], [4791, 4791, 4840, 4840, 4874], [4876, 4876, 4913, 4913, 6448], [6450, 6450, 6548, 6548, 6963], [6965, 6965, 7060, 7060, 7789], [7791, 7791, 7881, 7881, 8063], [8065, 8065, 8122, 8122, 12060]], "test": "untested"}
{"id": "mdX3RB", "name": "better 3d goggles", "author": "mds2", "description": "An anaglyph stereo rendering of a pair of \"better 3d goggles\"\n\nInspired by https://xkcd.com/977/ : \"What your favorite map projection says about you\", particularly the entry on the Dymaxion projection.", "tags": ["anaglyph", "stereo", "xkcd"], "likes": 4, "viewed": 280, "published": 3, "date": "1666311205", "time_retrieved": "2024-07-30T16:25:30.711544", "image_code": "#define RADIUS 1.0\n#define TOP 0.15\n#define BOTTOM -0.1\n#define SMOOTHING 0.025\n#define MAX_DIST 5.0\n#define THICK 0.1\n\nfloat bandSdf(in vec3 pt) {\n  float baseSphere = length(pt) - RADIUS;\n  if (baseSphere > abs(1.5 * (TOP - BOTTOM))) {\n    return baseSphere;\n  }\n  float chops = max(pt.z - TOP, BOTTOM - pt.z);\n  chops = checked_smooth_min(max(pt.x - 0.25 * TOP, -0.25 * TOP - pt.x), chops, 4.0 * SMOOTHING);\n  chops = max(chops, BOTTOM - pt.z);\n  return checked_smooth_max(baseSphere, chops, SMOOTHING);\n}\n\nfloat socketSdf(in vec3 pt) {\n  vec3 center = vec3(0.4 * RADIUS, -0.866 * RADIUS, 0.5 * (TOP + BOTTOM));\n  float d = length(vec3(abs(pt.x), pt.yz) - center);\n  float spheres = d - abs(1.5 * (TOP - BOTTOM));\n  return checked_smooth_max(spheres, -0.866 * RADIUS - THICK - pt.y, SMOOTHING);\n}\n\nfloat sdf(in vec3 pt) {\n  float frame = bandSdf(pt);\n  if (frame > abs(1.5 * (TOP - BOTTOM))) {\n    return frame;\n  }\n  float outer = checked_smooth_min(socketSdf(pt), frame, 4.0 * SMOOTHING);\n  if (outer > THICK + SMOOTHING) {\n    return outer + SMOOTHING;\n  }\n  float withEyes = checked_smooth_max(outer, -(length(pt) + THICK - RADIUS), SMOOTHING);\n  return checked_smooth_max(withEyes, 3.0 - length(pt - vec3(0.0, 0.0, -3.0)) - THICK - BOTTOM, SMOOTHING);\n}\n\nvec3 surfNorm(in vec3 pt) {\n  float f = sdf(pt);\n  const float h = 0.01;\n  return normalize(\n           vec3(\n             sdf(pt + vec3(h, 0.0, 0.0)) - f,\n             sdf(pt + vec3(0.0, h, 0.0)) - f,\n             sdf(pt + vec3(0.0, 0.0, h)) - f));\n}\n\nfloat castRay(in vec3 orig, in vec3 dir, out float accum) {\n  float along = 0.0;\n  accum = 0.0;\n  for (int i = 0; i < 100; ++i) {\n    vec3 pt = orig + along * dir;\n    float dist = sdf(pt);\n    if (abs(dist) < 1.0e-5) {\n      return along;\n    }\n    accum = accum + 0.3 / max(dist, 0.1);\n    along = along + 0.3 * dist;\n    if (along > MAX_DIST) {\n      return along;\n    }\n  }\n  return MAX_DIST * 1.01;\n}\n\nfloat brightness(in vec2 fragCoord, in float eye )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float noise = texture(iChannel0, 2.0 * uv).r;\n    \n    vec3 orig = vec3(eye, -3.1, 0.1 * RADIUS);\n    \n    vec3 dir = normalize(vec3(uv.x, -0.8, uv.y + 0.1 * RADIUS) - orig);\n    vec3 light = normalize(vec3(0.2, -1.0, 0.1));\n    \n    float ct = cos(0.2);\n    float st = sin(0.2);\n    mat3 pitch = mat3(1.0, 0.0, 0.0,\n                      0.0, ct, st,\n                      0.0, -st, ct);\n    \n    ct = cos(0.5 * iTime);\n    st = sin(0.5 * iTime);\n    \n    mat3 twist = mat3(ct, st, 0.0,\n                      -st, ct, 0.0,\n                      0.0, 0.0, 1.0);\n                      \n    orig = orig * pitch * twist;\n    dir = dir * pitch * twist;\n    light = light * pitch * twist;\n    \n    float glowIntegral;\n    \n    float noiseBump = 0.15 * noise;\n    noiseBump = noiseBump;\n    \n    float dist = castRay(orig + noiseBump * dir, dir, glowIntegral) + noiseBump;\n\n    // Time varying pixel color\n    float col = (0.004 * max(glowIntegral, 3.0));\n    \n    if (dist < MAX_DIST) {\n        vec3 n = surfNorm(orig + dist * dir);\n        vec3 bounce = normalize(reflect(dir, n));\n        float lightDot = dot(bounce, light);\n        col += 1.5 * smoothstep(0.95, 1.0, lightDot);\n    }\n\n    // Output to screen\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  const float eyeHalfDist = 0.15;\n  fragColor = vec4(brightness(fragCoord, -eyeHalfDist), vec2(brightness(fragCoord, eyeHalfDist)), 1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32186, "src": "https://soundcloud.com/mds/beepbox-loop-minor-slide", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "/**\n * standard blend func, courtesy IQ\n */\nfloat conventional_smin(in highp float a, in highp float b, in highp float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/** more expensive, but smoother, blend funcs */\nfloat super_smooth_max(in highp float a, in highp float b, in highp float k) {\n  // return 0.25 * k * log(exp(4.0 * a / k) + exp(4.0 * b / k));\n  return 0.1732802*k*log2(exp2(5.771*a/k) + exp2(5.771*b/k));\n}\n\nfloat super_smooth_min(in float a, in float b, in float k) {\n  return -super_smooth_max(-a, -b, k);\n}\n\n/** best of both worlds */\nfloat checked_smooth_min(in highp float a, in highp float b, in highp float k) {\n  float val = conventional_smin(a, b, k);\n  if (abs(val) < 4.0 * k) {\n    return super_smooth_min(a, b, k);\n  }\n  return val;\n}\n\nfloat checked_smooth_max(in highp float a, in highp float b, in highp float k) {\n  return -checked_smooth_min(-a, -b, k);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdX3RB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 147, 147, 508], [510, 510, 539, 539, 799], [801, 801, 824, 824, 1261], [1263, 1263, 1290, 1290, 1514], [1516, 1516, 1575, 1575, 1921], [1923, 1923, 1975, 2025, 3346], [3348, 3348, 3405, 3405, 3545]], "test": "untested"}
{"id": "ddXGzB", "name": "Simple Sphere Raytracer", "author": "Kgavaga", "description": "A simple Raytracer which only renders Spheres.\n", "tags": ["3d", "raytracing", "reflection"], "likes": 4, "viewed": 334, "published": 3, "date": "1666307912", "time_retrieved": "2024-07-30T16:25:31.643054", "image_code": "// ############### Options ################\nconst bool ANTIALIASING_ENABLED = true;\nconst int DEPTH = 3; // Number of times a ray will be reflected\nconst float START_FOV = 90.0;\nconst float VARIANCE_FOV = 20.0;\nconst float CAMERA_HEIGHT = 2.0;\nconst float RADIUS_OF_CAMERA_ORBIT = 5.0;\nconst float JUMP_HEIGHT = 2.0;\n\nfloat BIG_SPHERE_RADIUS = 1.0;\nfloat SMALL_SPHERE_RADIUS = 0.3;\nfloat MEDIUM_SMALL_SPHERE_RADIUS = 0.4;\nfloat MEDIUM_BIG_SPHERE_RADIUS = 0.7;\n// ######################################## \n\nconst int SPHERE_COUNT = 10; // Number of spheres to render\nconst float NO_COLLISION = -1.0;\n\nvec3 backgroundColor = vec3(0.2,0.2,0.2);\n\nstruct Camera{\n    vec3 position;\n    vec3 rotation;\n    float distanceFromProjectionPlane;\n};\n\nstruct Sphere{\n    vec3 position;\n    float radius;\n    vec3 color;\n    float ambientStrength;\n    float specularStrength;\n    float shininess;\n    float reflectiveness;\n};\n\nstruct Light{\n    vec3 position;\n    vec3 color;\n};\n\n// Calculates the distance from the projection plane (the plane that the camera's rays\n// will be traced through) to the center of the camera's view\nfloat calculateDistanceFromProjectionPlane(float windowRatio, float fov){\n    float tanResult = tan(radians(fov/2.0));\n    float distanceFromPlane = (windowRatio/(tanResult*2.0));\n    return abs(distanceFromPlane);\n}\n\n// Get the 3d rotation matrix for specific yaw, roll and pitch rotations\nmat3 getRotationMatrix(float xRotation, float yRotation, float zRotation){\n    mat3 xRotationMatrix = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(xRotation), -sin(xRotation),\n        0.0, sin(xRotation), cos(xRotation)\n    );\n    mat3 yRotationMatrix = mat3(\n        cos(yRotation), 0.0, sin(yRotation),\n        0.0, 1.0, 0.0,\n        -sin(yRotation), 0.0, cos(yRotation)\n    );\n    mat3 zRotationMatrix = mat3(\n        cos(zRotation), -sin(zRotation), 0.0,\n        sin(zRotation), cos(zRotation), 0.0,\n        0.0, 0.0, 1.0\n    );\n    \n    return xRotationMatrix*yRotationMatrix*zRotationMatrix;\n}\n\n// Returns a ray going from the camera to the selected pixel\n// The function also accounts for the rotation of the camera\nvec3 getRay(vec2 fragCoord, float windowWidth, float windowHeight, Camera camera){\n    // Calculate the roation matrix based on the rotation off the camera\n    float xRotation = camera.rotation.x;\n    float yRotation = camera.rotation.y;\n    float zRotation = camera.rotation.z;\n    mat3 rotationMatrix = getRotationMatrix(xRotation, yRotation, zRotation);\n    \n    // Calculate the position of the current pixel on the projection plane\n    vec3 pixelPosition = vec3(\n        ((fragCoord.x/windowWidth)-0.5)*windowWidth/windowHeight,\n        (fragCoord.y/windowHeight)-0.5,\n        -camera.distanceFromProjectionPlane\n    );\n    \n    // Rotate the pixel position according to the roation of the camera\n    pixelPosition*=rotationMatrix;\n    return normalize(pixelPosition);\n}\n\n// Calculates the distance to the closest collison with the sphere\n// If there is no collision, the function returns -1.0\nfloat collideWith(Sphere sphere, vec3 rayOrigin, vec3 rayDirection){\n    // Solve the quadratic function\n    float b = 2.0 * dot(rayDirection, rayOrigin - sphere.position);\n    float c = pow(length(rayOrigin - sphere.position), 2.0) - pow(sphere.radius, 2.0);\n    float delta = pow(b, 2.0) - 4.0 * c;\n    if (delta > 0.0){\n        float t1 = (-b - sqrt(delta)) / 2.0;\n        if (t1 > 0.0){\n            // Return the smallest distance (the smallest solution of the quadratic function)\n            return t1;\n        }\n    }\n    return -1.0;\n}\n\n// Calculates the closest point where a ray collides with one of the spheres\n// \"oCollisionPoint\" : Closest collision point\n// \"oClosestSphereIndex\" : Array index of the closest sphere with which the ray collided\n// rayDirection has to be a unit vector\nbool collideWithClosest(Sphere[SPHERE_COUNT] spheres, vec3 rayOrigin, vec3 rayDirection, out int oClosestSphereIndex, out vec3 oCollisionPoint){\n    int closestSphereIndex;\n    float closestDistance = NO_COLLISION;\n    \n    // Iterate through all spheres and check if the sphere is hit by the ray\n    for (int i = 0; i < SPHERE_COUNT; i++){\n        float currentDistance = collideWith(spheres[i], rayOrigin, rayDirection);\n        if (currentDistance != NO_COLLISION && (currentDistance < closestDistance || closestDistance == -1.0)){\n            closestSphereIndex = i;\n            closestDistance = currentDistance;\n        }\n    }\n    \n    // Check if a collision with an object happened\n    if (closestDistance != NO_COLLISION){\n        oClosestSphereIndex = closestSphereIndex;\n        oCollisionPoint = rayOrigin + rayDirection*closestDistance;\n        return true;\n    }\n    return false;\n}\n\n// Checks to see if a collision point is in the shadow of an object\nbool isInShadow(Sphere[SPHERE_COUNT] spheres, vec3 collisionPoint, vec3 objectToLightVector, vec3 lightPosition){\n    int closestSphereIndex = 0;\n    vec3 nearestDistancePoint = vec3(0.0);\n    bool rayToLightCollided = collideWithClosest(spheres, collisionPoint, objectToLightVector, closestSphereIndex, nearestDistancePoint);\n    \n    if (rayToLightCollided){\n        float nearestDistance = length(nearestDistancePoint-collisionPoint);\n        float distanceToLight = length(lightPosition - collisionPoint);\n        if(nearestDistance < distanceToLight){\n            return true;\n        }\n    }\n    return false;\n}\n\n// Calculate diffuse strength\nfloat getDiffuseStrength(vec3 objectToLightVector, vec3 objectNormalVector){\n    return max(0.0,dot(objectToLightVector, objectNormalVector));\n}\n\n// Calculate specular\nfloat getSpecularStrength(vec3 objectToLightVector, vec3 objectNormalVector, vec3 objectToCameraVector, float shininess){\n    float dotProduct = dot(normalize(reflect(-objectToLightVector, objectNormalVector)), normalize(objectToCameraVector));\n    return pow(max(0.0,dotProduct), shininess);\n}\n\n// Calculates the color for a given point \"rayOrigin\" in the 3d space\nvec3 getColor(Sphere[SPHERE_COUNT] spheres, vec3 rayOrigin, vec3 rayDirection, Camera camera, Light light){\n    vec3 color = backgroundColor;\n    float reflectiveness, diffuseStrength, specularStrength = 0.0;\n    \n    // Send out and reflect the ray as many times as its set by \"DEPTH\"\n    for (int depth = 0; depth < DEPTH; depth++){\n        int hitSphereIndex = -1;\n        vec3 collisionPoint = vec3(0.0);\n        bool rayCollided = collideWithClosest(spheres, rayOrigin, rayDirection, hitSphereIndex, collisionPoint);\n\n        if (rayCollided){\n            diffuseStrength, specularStrength = 0.0;\n            \n            vec3 objectNormalVector = normalize(collisionPoint-spheres[hitSphereIndex].position);\n            vec3 objectToLightVector = normalize(light.position - collisionPoint);\n            \n            // Check to see if collisionPoint is in a cast of shadow\n            bool inShadow = isInShadow(spheres, collisionPoint, objectToLightVector, light.position);\n            if(!inShadow){\n                vec3 objectToCameraVector = normalize(camera.position - collisionPoint);\n                \n                // Calculate diffuse and specular strength since collisionPoint is not\n                // located in a cast of shadow\n                diffuseStrength = getDiffuseStrength(\n                    objectToLightVector,\n                    objectNormalVector\n                );\n                specularStrength = getSpecularStrength(\n                    objectToLightVector, \n                    objectNormalVector, \n                    objectToCameraVector, \n                    spheres[hitSphereIndex].shininess\n                );\n            }\n            \n            vec3 sphereColor = spheres[hitSphereIndex].color*light.color*(\n                spheres[hitSphereIndex].ambientStrength + diffuseStrength + spheres[hitSphereIndex].specularStrength*specularStrength\n            );\n            if (depth == 0){\n                color = sphereColor;\n                reflectiveness = spheres[hitSphereIndex].reflectiveness;\n            } else{\n                color += reflectiveness*sphereColor;\n                reflectiveness*= spheres[hitSphereIndex].reflectiveness;\n            }\n            rayOrigin = collisionPoint;\n            rayDirection = reflect(rayDirection, objectNormalVector);\n        }\n    }\n    \n    return color;\n}\n\n// Renders a given pixel with antialiasing\n// This is done by calculating the color of 9 points in close proximity and\n// taking the average color value of all of them.\nvec3 renderWithAntialiasing(vec2 fragCoord, float windowWidth, float windowHeight, Sphere[SPHERE_COUNT] spheres, Camera camera, Light light){\n    vec3 color = vec3(0.0);\n    for(float i = -1.0; i <= 1.0; i++) {\n        for(float j = -1.0; j <= 1.0; j++) {\n            vec3 rayDirection = getRay(\n                fragCoord+vec2(i*0.3, j*0.3),\n                windowWidth,\n                windowHeight,\n                camera\n            );\n    \t\tcolor += getColor(spheres, camera.position, rayDirection, camera, light);\n        }\n    }\n    color /= 9.0;\n    return color;\n}\n\n// Renders a given pixel without antialiasing\nvec3 render(vec2 fragCoord, float windowWidth, float windowHeight, Sphere[SPHERE_COUNT] spheres, Camera camera, Light light){\n    vec3 color = vec3(0.0);\n    vec3 rayDirection = getRay(\n        fragCoord,\n        windowWidth,\n        windowHeight,\n        camera\n    );\n    color = getColor(spheres, camera.position, rayDirection, camera, light);\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    float windowRatio = iResolution.x/iResolution.y;\n    \n    // Mouse input is able to affect the position of the camera\n    float mouseInput = iMouse.x/100.0;\n    // Fov changes overtime\n    float fov = START_FOV+sin(iTime-mouseInput)*VARIANCE_FOV;\n    float alpha = iTime-mouseInput;\n    // Move camera in circles and adjust the rotation of the camera\n    // to create an orbiting effect\n    Camera camera = Camera(\n        vec3(\n            sin(alpha)*RADIUS_OF_CAMERA_ORBIT,\n            CAMERA_HEIGHT + cos(iTime)*0.01,\n            cos(alpha)*RADIUS_OF_CAMERA_ORBIT\n        ),\n        vec3(\n            sin(alpha)*0.1,\n            alpha, \n            sin(alpha)*0.2\n        ),\n        calculateDistanceFromProjectionPlane(windowRatio, fov)\n    );\n    \n    float BOUNCINESS_SMALL = abs(JUMP_HEIGHT * sin(iTime));\n    float BOUNCINESS_BIG = abs(JUMP_HEIGHT * sin(iTime*1.0*3.0));\n    float BOUNCINESS_MEDIUM_SMALL = abs(JUMP_HEIGHT * sin(iTime*2.0));\n    float BOUNCINESS_MEDIUM_BIG = abs(JUMP_HEIGHT * sin(iTime*1.5));\n    \n    // Create all spheres in the scene\n    Sphere spheres[SPHERE_COUNT] = Sphere[SPHERE_COUNT](\n        Sphere( // Bigger Sphere\n            vec3(-1.0, BOUNCINESS_BIG + BIG_SPHERE_RADIUS,0.0),// position\n            BIG_SPHERE_RADIUS,      // radius \n            vec3(0.1,0.3,0.7),      // Color\n            0.1,                    // Strength of the ambient lighting on the sphere\n            0.7,                    // Strength of the specular lighting on the sphere\n            128.0,                  // Exponent for the specular lighting on the sphere\n            0.3                     // Reflectiveness of the sphere\n        ),\n        Sphere( // Small Sphere\n            vec3(1.0,BOUNCINESS_SMALL + SMALL_SPHERE_RADIUS,0.0),\n            SMALL_SPHERE_RADIUS,\n            vec3(0.5,0.1,0.4),\n            0.1,\n            0.7,\n            32.0,\n            0.3\n        ),\n        Sphere( // medium small Sphere\n            vec3(-4.0,BOUNCINESS_MEDIUM_SMALL + MEDIUM_SMALL_SPHERE_RADIUS,2.0),\n            MEDIUM_SMALL_SPHERE_RADIUS,\n            vec3(0.2,0.8,0.2),\n            0.2,\n            0.7,\n            32.0,\n            0.3\n        ),\n        Sphere( // medium big Sphere\n            vec3(0.5,BOUNCINESS_MEDIUM_BIG + MEDIUM_BIG_SPHERE_RADIUS,4.3),\n            MEDIUM_BIG_SPHERE_RADIUS,\n            vec3(0.1,0.1,0.1),\n            0.5,\n            0.7,\n            32.0,\n            1.0\n        ),\n        Sphere( // Floor\n            vec3(0.0,-9000.0,0.0),\n            9000.0,\n            vec3(0.9,0.9,0.9),\n            0.1,\n            0.8,\n            128.0,\n            0.1\n        ),\n        Sphere( // Ceiling\n            vec3(0.0,9005.0,0.0),\n            9000.0,\n            vec3(0.9,0.9,0.9),\n            0.1,\n            0.8,\n            128.0,\n            0.1\n        ),\n        Sphere( // Left Wall \n            vec3(-9005.0,0.0,0.0),\n            9000.0,\n            vec3(1.0, 0.0, 0.0),\n            0.1,\n            0.8,\n            128.0,\n            0.3\n        ),\n        Sphere( // Right Wall\n            vec3(9005.0,0.0,0.0),\n            9000.0,\n            vec3(0.0, 0.0, 1.0),\n            0.1,\n            0.8,\n            128.0,\n            0.3\n        ),\n        Sphere( // Front Wall\n            vec3(0.0,0.0,-9005.0),\n            9000.0,\n            vec3(0.9,0.9,0.9),\n            0.1,\n            0.8,\n            128.0,\n            0.3\n        ),\n        Sphere( // Back Wall\n            vec3(0.0,0.0,+9015.0),\n            9000.0,\n            vec3(0.9,0.9,0.9),\n            0.1,\n            0.8,\n            128.0,\n            0.5\n        )\n     );\n     \n     // Create the light in the scene\n     Light light = Light(\n         vec3(3.0,3.0,3.0),\n         vec3(1.0,1.0,1.0)\n     );\n\n    // Render the pixel according to the settings\n    vec3 colorOfPixel;\n    if(ANTIALIASING_ENABLED){\n        colorOfPixel = renderWithAntialiasing(fragCoord, iResolution.x, iResolution.y, spheres, camera, light);\n    } else {\n        colorOfPixel = render(fragCoord, iResolution.x, iResolution.y, spheres, camera, light);\n    }\n    \n    fragColor = vec4(colorOfPixel,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddXGzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[966, 1115, 1188, 1188, 1331], [1333, 1406, 1480, 1480, 2006], [2008, 2130, 2212, 2285, 2905], [2907, 3029, 3097, 3133, 3571], [5412, 5442, 5518, 5518, 5586], [5588, 5610, 5731, 5731, 5904], [9490, 9490, 9546, 9546, 13669]], "test": "untested"}
{"id": "cdfGRB", "name": "another basic mario", "author": "jorge2017a2", "description": "another basic mario", "tags": ["anotherbasicmario"], "likes": 5, "viewed": 229, "published": 3, "date": "1666296421", "time_retrieved": "2024-07-30T16:25:32.458872", "image_code": "///*----por jorgeflores\n///---20-oct-2022\n///---referencia el grande comunidad de shadertoy\n\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\n///----leeer mario\nconst int MARIO_BITMAP[256] = int[](\n6,6,6,6,1,1,1,1,1,1,1,1,6,6,6,6,\n6,6,6,1,1,1,1,1,1,1,1,1,1,1,1,6,\n6,6,6,0,0,0,0,3,3,3,3,5,3,6,6,6,\n6,6,0,3,0,3,3,3,3,3,3,5,3,3,3,6,\n6,6,0,3,0,0,3,3,3,3,3,3,5,3,3,3,\n6,6,0,0,3,3,3,3,3,3,5,5,5,5,5,6,\n6,6,6,6,3,3,3,3,3,3,3,3,3,3,6,6,\n6,6,6,1,1,2,1,1,1,1,2,1,6,6,6,6,\n6,6,1,1,1,2,1,1,1,1,2,1,1,1,6,6,\n6,1,1,1,1,2,2,2,2,2,2,1,1,1,1,6,\n6,3,3,1,2,4,2,2,2,2,4,2,1,3,3,6,\n6,3,3,3,2,2,2,2,2,2,2,2,3,3,3,6,\n6,3,3,2,2,2,2,2,2,2,2,2,2,3,3,6,\n6,6,6,2,2,2,6,6,6,6,2,2,2,6,6,6,\n6,6,0,0,0,6,6,6,6,6,6,0,0,0,6,6,\n6,0,0,0,0,6,6,6,6,6,6,0,0,0,0,6\n);\n\nint readMarioBitMap(in vec2 uv) \n{ return MARIO_BITMAP[int(uv.y) * 16 + int(uv.x)]; }\n\nvec4 mario(in vec2 uv)\n{   switch (readMarioBitMap(uv)) \n     {  case 0: return vec4(0.627, 0.408, 0.0,1.0);\n        case 1: return vec4(1.0,0.0,0.0,1.0);\n        case 2: return vec4(0,0.698,0.922,1.0);\n        case 3: return vec4(0.976,0.804,0.541,1.0);\n        case 4: return vec4(0.976,0.957,0,1.0);\n        case 5: return vec4(0,0,0,1.0);\n        default: return vec4(0);\n    }\n}\n\nvec4 GetColorMario(int opc) \n{   vec4 col=vec4(0.0);\n    switch(opc)\n     {\n        case 0: return vec4(0.627, 0.408, 0.0,1.0);\n        case 1: return vec4(1.0,0.0,0.0,1.0);\n        case 2: return vec4(0,0.698,0.922,1.0);\n        case 3: return vec4(0.976,0.804,0.541,1.0);\n        case 4: return vec4(0.976,0.957,0,1.0);\n        case 5: return vec4(0,0,0,1.0);\n        default: return vec4(0);\n    }\n    return  col;\n}\n\n\nfloat[256] Ladrillo= float[256](\n0.,0.,0.,0.,0.,0.,0.,1.,0.,0.,0.,0.,0.,0.,0.,0.,\n0.,0.,0.,0.,0.,0.,0.,1.,0.,0.,0.,0.,0.,0.,0.,0.,\n0.,0.,0.,0.,0.,0.,0.,1.,0.,0.,0.,0.,0.,0.,0.,0.,\n1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,\n0.,0.,0.,1.,0.,0.,0.,0.,0.,0.,0.,1.,0.,0.,0.,0.,\n0.,0.,0.,1.,0.,0.,0.,0.,0.,0.,0.,1.,0.,0.,0.,0.,\n0.,0.,0.,1.,0.,0.,0.,0.,0.,0.,0.,1.,0.,0.,0.,0.,\n1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,\n0.,0.,0.,0.,0.,0.,0.,1.,0.,0.,0.,0.,0.,0.,0.,0.,\n0.,0.,0.,0.,0.,0.,0.,1.,0.,0.,0.,0.,0.,0.,0.,0.,\n0.,0.,0.,0.,0.,0.,0.,1.,0.,0.,0.,0.,0.,0.,0.,0.,\n1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,\n0.,0.,0.,1.,0.,0.,0.,0.,0.,0.,0.,1.,0.,0.,0.,0.,\n0.,0.,0.,1.,0.,0.,0.,0.,0.,0.,0.,1.,0.,0.,0.,0.,\n0.,0.,0.,1.,0.,0.,0.,0.,0.,0.,0.,1.,0.,0.,0.,0.,\n1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.\n);\n\nfloat[256] Bloque00= float[256](\n0.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,2.,0.,\n2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,3.,0.,\n2.,1.,1.,0.,1.,1.,1.,1.,1.,1.,1.,1.,0.,1.,3.,0.,\n2.,1.,1.,0.,1.,1.,1.,1.,1.,1.,1.,1.,0.,1.,3.,0.,\n2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,3.,0.,\n2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,3.,0.,\n2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,3.,0.,\n2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,3.,0.,\n2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,3.,0.,\n2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,3.,0.,\n2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,3.,0.,\n2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,3.,0.,\n2.,1.,1.,0.,1.,1.,1.,1.,1.,1.,1.,1.,0.,1.,3.,0.,\n2.,1.,1.,0.,1.,1.,1.,1.,1.,1.,1.,1.,0.,1.,3.,0.,\n2.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,3.,0.,\n0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.\n);\n\nfloat[256] Bloque01= float[256](\n2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,1.,\n0.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,1.,1.,\n0.,0.,2.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,1.,1.,1.,\n0.,0.,0.,2.,0.,0.,0.,0.,0.,0.,0.,0.,1.,1.,1.,1.,\n0.,0.,0.,0.,2.,0.,0.,0.,0.,0.,0.,1.,1.,1.,1.,1.,\n0.,0.,0.,0.,3.,3.,3.,3.,3.,3.,1.,1.,1.,1.,1.,1.,\n0.,0.,0.,0.,3.,3.,3.,3.,3.,3.,1.,1.,1.,1.,1.,1.,\n0.,0.,0.,0.,3.,3.,3.,3.,3.,3.,1.,1.,1.,1.,1.,1.,\n0.,0.,0.,0.,3.,3.,3.,3.,3.,3.,1.,1.,1.,1.,1.,1.,\n0.,0.,0.,0.,3.,3.,3.,3.,3.,3.,1.,1.,1.,1.,1.,1.,\n0.,0.,0.,0.,3.,3.,3.,3.,3.,3.,2.,1.,1.,1.,1.,1.,\n0.,0.,0.,0.,1.,1.,1.,1.,1.,1.,1.,2.,1.,1.,1.,1.,\n0.,0.,0.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.,1.,1.,1.,\n0.,0.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.,1.,1.,\n0.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.,1.,\n1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,2.\n);\n\nvec3 RGB3(float r ,float g, float b)\n{ return vec3(r/255.,g/255.,b/255.);}\n\nvec3 GetColorLadrillo(int opc)\n{   switch(opc)\n    {   case 0:return RGB3(224., 95., 16.);\n        case 1:return RGB3(0.,0.,15.);\n        case 2:return RGB3(0.,0.,0.);\n    }\n    return vec3(1.0);\n}\n\nvec3 GetColorBloque00(int opc)\n{   switch(opc)\n    {   case 0:return RGB3(0.,0.,0.);\n        case 1:return RGB3(209.,107.,32.);\n        case 2:return RGB3(255.,178.,132.);\n        case 3:return RGB3(179.,113.,63.);\n    }\n    return vec3(1.0);\n}\n\nvec3 GetColorBloque01(int opc)\n{   switch(opc)\n    {   case 0:return RGB3(243.,173.,121.);\n        case 1:return RGB3(6.,0.,0.);\n        case 2:return RGB3(182.,106.,48.);\n        case 3:return RGB3(209.,107.,32.);\n    }\n    return vec3(1.0);\n}\n\nvec3 PonerLadrillo(vec2 uv, ivec2 pos, vec3 col)\n{   int opc;\n    ivec2 pix = ivec2(uv*256.)+ivec2(-pos.x*16,-16*pos.y);\n     pix.y=-pix.y+15;\n    if (min(pix.x, pix.y) >= 0 && max(pix.x, pix.y) < 16) \n    {   opc=int( Ladrillo[pix.x+pix.y*16] );    \n        col=GetColorLadrillo(opc); \n    }\n    return col;\n}\n\n\nvec3 PonerBloque00(vec2 uv, ivec2 pos, vec3 col)\n{\n    int opc;\n    ivec2 pix = ivec2(uv*256.)+ivec2(-pos.x*16,-16*pos.y);\n     pix.y=-pix.y+15;\n    if (min(pix.x, pix.y) >= 0 && max(pix.x, pix.y) < 16) \n    {   opc=int( Bloque00[pix.x+pix.y*16] );    \n        col=GetColorBloque00(opc); \n    }\n    return col;\n}\n\nvec3 PonerBloque01(vec2 uv, ivec2 pos, vec3 col)\n{   int opc;\n    ivec2 pix = ivec2(uv*256.)+ivec2(-pos.x*16,-16*pos.y);\n     pix.y=-pix.y+15;\n     \n    if (min(pix.x, pix.y) >= 0 && max(pix.x, pix.y) < 16) \n    {   opc=int( Bloque01[pix.x+pix.y*16] );    \n        col=GetColorBloque01(opc); \n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/max(iResolution.x,iResolution.y)*1.0;  ///original\n    vec3 col=RGB3(96.,148.,252.);\n    \n   \n    float inct=mod(iTime,16.);\n    int incy=8;\n    \n    int incx=int(-floor(mod(iTime,16.))* 16.0);\n    ivec2 pix = ivec2(uv*256.)+ivec2( incx,-16*incy);\n    int opc;\n    \n    \n    if (min(pix.x, pix.y) >= 0 && max(pix.x, pix.y) < 16) \n    {\n        opc=int( Ladrillo[pix.x+pix.y*16] );    \n        col=GetColorLadrillo(opc);\n    } else {\n        if(-pix.y>16*6)\n        {\n            col=vec3(0.0);\n        }\n        else\n        { col=RGB3(96.,148.,252.); }\n        \n    }\n    \n    for(int j=0;j<16;j++)\n    { col= PonerLadrillo(uv,ivec2(j,2),col);}\n    \n    col= PonerBloque00(uv,ivec2(6,3),col);\n    col= PonerBloque00(uv,ivec2(7,3),col);\n    col= PonerBloque00(uv,ivec2(8,4),col);\n    col= PonerBloque01(uv,ivec2(9,4),col);\n    col= PonerBloque01(uv,ivec2(10,4),col);\n    \n    \n    int posx=int(floor(abs(3.*16.0*sin(iTime*3.0))));\n    \n     pix = ivec2(uv*256.)+ivec2(-3*16,-16*3-posx );\n    if (min(pix.x, pix.y) >= 0 && max(pix.x, pix.y) < 16) \n    {\n        pix.y=-pix.y+15;\n        opc=int( MARIO_BITMAP[pix.x+pix.y*16] );\n        vec4 fcol=GetColorMario(opc);\n         if (fcol.w == 1.0) \n         col=fcol.xyz;\n    }\n    \n    float d2= sdCircle(uv-vec2(0.7,0.5), 0.05 );\n    \n    if(1.0*sin(iTime*10.0)>0.0)\n    {\n        uv.x-=0.1;uv.y-=0.05;\n        float d1a= sdSegment(uv, vec2(0.0,0.0), vec2(0.5,0.5) );\n        float d1b= sdSegment(uv, vec2(0.0,0.5), vec2(0.5,0.0) );\n        col= DrawFigSolo(vec3(1.0,0.0,0.0), col, abs(d1a)-0.01);\n        col= DrawFigSolo(vec3(1.0,0.0,0.0), col, abs(d1b)-0.01);\n    }   \n    col= DrawFigBorde(vec3(1.0,1.0,0.0), col, d2);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfGRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[311, 311, 373, 373, 503], [505, 505, 567, 567, 632], [635, 635, 687, 687, 803], [805, 805, 840, 840, 863], [1452, 1452, 1486, 1486, 1537], [1539, 1539, 1563, 1563, 1922], [1924, 1924, 1954, 1954, 2343], [4806, 4806, 4844, 4844, 4880], [4882, 4882, 4914, 4914, 5079], [5081, 5081, 5113, 5113, 5325], [5327, 5327, 5359, 5359, 5571], [5573, 5573, 5623, 5623, 5883], [5886, 5886, 5936, 5936, 6198], [6200, 6200, 6250, 6250, 6516], [6519, 6519, 6576, 6576, 8313]], "test": "untested"}
{"id": "Dsf3zB", "name": "Two colors", "author": "ersteller", "description": "this is a simple shader for displaying two seperate colors\nyes i could have use MS Paint ... ", "tags": ["twosolidcolorsstatictgrivial"], "likes": 0, "viewed": 164, "published": 3, "date": "1666291921", "time_retrieved": "2024-07-30T16:25:33.258734", "image_code": "\nvec4 solidblack = vec4(0,0.0,0.0,1.0); //This is actually black right now\nvec4 solidBlue = vec4(0.2,0.2,1.0,1.0); //This is actually black right now\nvec4 solidorang = vec4(1.0,0.65,0.0,1.0); //This is actually black right now\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy; //We obtain our coordinates for the current pixel\n    xy.x = xy.x / iResolution.x; //We divide the coordinates by the screen size\n    xy.y = xy.y / iResolution.y;\n    // Now x is 0 for the leftmost pixel, and 1 for the rightmost pixel\n    vec4 solidRed = vec4(0,0.0,0.0,1.0); //This is actually black right now\n    \n    if(xy.x > 0.75) {\n        fragColor = solidBlue;\n    }\n    else if(xy.x > 0.25) {\n        fragColor = solidblack;\n    }\n    else{\n        fragColor = solidorang;\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dsf3zB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[228, 228, 285, 285, 808]], "test": "untested"}
{"id": "csXGzS", "name": "Particle Thingies", "author": "SnoopethDuckDuck", "description": "crude particle simulation with some stuff distortions and stuff (for loop isn't ideal)", "tags": ["e"], "likes": 19, "viewed": 290, "published": 3, "date": "1666284776", "time_retrieved": "2024-07-30T16:25:34.000750", "image_code": "// all of this is a mess\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragCoord.y += 2. * cos(uv.x * 10. + iTime);\n    fragCoord.x += 2. * cos(0.04 * fragCoord.y + iTime);\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    //col += (0.125 + 0.025 * thc(2., 150. * uv.y - 4. * iTime)) * exp(-4. * length(uv));\n    //col *= 1. + 0.2 *  thc(4., 20. * log(length(uv)) - iTime);\n    \n    col = 1.25 * pow(col, vec3(1.5)); \n    col = sqrt(col);\n   \n    col /= cosh(2.5 * length(uv));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Maths and stuff:\n// http://jwilson.coe.uga.edu/EMAT6680Su06/Swanagan/Assignment7/BSAssignment7.html\n\n#define pi 3.14159\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nvec4 cell2(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel1, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel1, p, 0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = (fragCoord - 0.5 * res) / res.y;\n    float t = float(iFrame) / 60.;\n    //uv.x += 0.5 - 0.05 * t;\n    //uv *= rot(t);\n    ivec2 f = ivec2(fragCoord);\n    vec4 cel = cell(f);\n    \n    float xp = exp(-0.2 * t);\n    float k = xp / res.y;\n    \n    vec3 col = cel.rgb;\n    \n    for (int i = 0; i < 30; i++) {\n        float io = 2. * pi * float(i) / 20.;\n        vec2 p = (cell2(ivec2(i,0)).rg - 0. * res) / res.y;\n\n        float r = 0.02 + 0.012 * thc(12., 5. * t + io);\n        r *= xp;\n        float d = length(uv - p);\n        float s = smoothstep(-k, k, 2. * k - abs(d - r));\n        float s2 = smoothstep(-k, k, -2. * k - d + r);\n\n        col -= xp * vec3(clamp(s2, 0., 1.));\n        col = clamp(col, 0., 1.);\n        col += xp * 0.25 * vec3(0.5 + 0.5 * sin(10. * t + io),\n                           0.6,\n                           0.5) \n                    * vec3(clamp(s, 0., 1.));\n        col = clamp(col, 0., 1.);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\n#define sc 0.5\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    //rg == xy pos, ba == xy vel\n    vec4 col = vec4(0);\n\n    if (iFrame == 0) {\n        col.rg = 0.5 * f;\n    }\n                \n    float t = float(iFrame) / 60.;\n    col = cell(ivec2(f));\n    float h1 = h21(vec2(f.x + .01 * t, f.y - .015 * t));\n    float h2 = h21(vec2(f.y + .02 * t, f.x + f.y + .51 * t));\n    col.b += sc * (h1 - 0.5);\n    col.a += sc * (h2 - 0.5);\n    col.ba *= 0.99;\n    col.r += col.b;\n    col.g += col.a;\n\n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csXGzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 83, 83, 610]], "test": "untested"}
{"id": "dds3W7", "name": "Fork of GPVM Path Tracing", "author": "dzil123", "description": "GPVM Path Tracing Starting Point\n\nPrepared for this meeting: https://www.meetup.com/graphics-programming-virtual-meetup/events/289089535/\n\nPath Tracing logic is in Buffer A.\n\nMouse drag: change the view direction", "tags": ["pathtracing"], "likes": 4, "viewed": 196, "published": 3, "date": "1666256413", "time_retrieved": "2024-07-30T16:25:34.937246", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/**\n  * Path Tracing\n  */\n\n// Ray\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\nvec3 rayAt(Ray ray, float t) {\n  return ray.origin + t * ray.direction;\n}\n\nstruct Material {\n    int type;\n    vec3 color;\n    float roughness;\n};\n\nMaterial materials[] = Material[] (\n    Material(0, vec3(0.9, 0.9, 0.9), 0.0),\n    Material(1, vec3(1.0, 1.0, 1.0), 1.0),\n    Material(0, vec3(0.3, 0.9, 0.8), 0.0)\n);\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    int material_index;\n};\n\nSphere spheres[] = Sphere[] (\n    Sphere(vec3(0.0, -1.0, -2.0), 1.0, 0),\n    Sphere(vec3(-5.0, 0.0, 15.0), 10.0, 1),\n    Sphere(vec3(5.0, 0.0, 20.0), 10.0, 2),\n    Sphere(vec3(0.0, -54.0, 0.0), 50.0, 1)\n);\n\n// Scene\nvec3 background(Ray ray)\n{\n    float y = ray.direction.y;\n    vec3 col = vec3(0.7, 0.8, 1.0) - 0.5 * y;\n    col = mix(col, vec3(0.8, 0.9, 1.0), min(exp(-10.0*y), 0.0));\n    //col = vec3(y * .5 + .5);\n    col = texture(iChannel2, ray.direction).rgb;\n    //col += 0.1 * sky(ray.direction);\n    return col;\n}\n\nstruct HitRecord {\n    float t;\n    int material_index;\n    vec3 position;\n    vec3 normal;\n};\n\nbool raySphereIntersection(Ray ray, Sphere sphere, inout HitRecord hit) {\n    vec3 oc = ray.origin - sphere.center;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(oc, ray.direction);\n    float c = dot(oc, oc) - sphere.radius * sphere.radius;\n    float discriminant = b*b - 4.0*a*c;\n    \n    if (discriminant > 0.0) {\n        float t = (-b - sqrt(discriminant) ) / (2.0*a);\n        \n        if (t > 0.0) {\n            vec3 hitPoint = rayAt(ray, t);\n            \n            if (t < hit.t) {\n                hit.t = t;\n                hit.material_index = sphere.material_index;\n                hit.normal = normalize(hitPoint - sphere.center);\n                hit.position = hitPoint;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\nRay generateRay(vec2 fragCoord, inout uint rngState);\n\n\nbool castRay(Ray ray, inout HitRecord hit) {\n    bool anyHit = false;\n    \n    uint x = 0u;\n    vec3 cameraPos = generateRay(vec2(0.0), x).origin;\n    //anyHit = anyHit || raySphereIntersection(ray, Sphere(cameraPos, 5.0, vec3(1.0)), hit);\n    \n    for (int i = 0; i < spheres.length(); i++) {\n        anyHit = raySphereIntersection(ray, spheres[i], hit) || anyHit;\n    }\n    \n    return anyHit;\n}\n\n\n\n// Path tracing\nvec3 traceRay(Ray ray, inout uint rngState)\n{\n    vec3 color = vec3(1.0);\n\n    for (int i = 0; i < 30; i++) {\n        HitRecord hit;\n        hit.t = 10000.0;\n        if (!castRay(ray, hit)) {\n            break;\n        }\n      \n        Material mat = materials[hit.material_index];\n        \n        switch (mat.type) {\n            case 0:\n                color *= mat.color;\n                ray = Ray(hit.position, reflect(ray.direction, hit.normal));\n                break;\n            case 1:\n                color *= mat.color;\n                vec3 dir = normalize(hit.normal + randomPointSphere(rngState) * mat.roughness);\n                ray = Ray(hit.position, dir);\n                break;\n        }\n        continue;\n        \n        vec3 prevDir = ray.direction;\n        //color = max(color, vec3(0.0));\n        \n        \n        vec2 uv = iMouse.xy / iResolution.xy;\n        bool metallic = uv.x > 0.5;\n        float roughness = clamp(uv.y * 1.1 - 0.1, 0.0, 1.0);\n        \n        metallic = true;\n        roughness = .0;\n        \n        if (metallic) {\n            ray.direction += randomPointSphere(rngState) * roughness;\n        } else {\n            bool algorithm1 = true;\n            if (algorithm1) {\n                ray.direction = mix(ray.direction, hit.normal + randomPointSphere(rngState), roughness * 0.5 + 0.5);\n            } else {\n                vec3 rng = randomPointSphere(rngState);\n                if (dot(rng, hit.normal) < 0.0) {\n                    rng *= -1.0;\n                }\n                //color *= dot(rng, hit.normal);\n                ray.direction = rng;\n            }\n        }\n        \n        //ray.direction += randomPointSphere(rngState) * 0.5;\n        //color *= 1.0 + pow(max(0.0, dot(prevDir, ray.direction)), 1.0);\n        //ray.direction = hit.normal + randomPointSphere(rngState);\n        ray.direction = normalize(ray.direction);\n        continue;\n        \n        vec3 rng = randomPointSphere(rngState);\n        float rngdot = dot(rng, hit.normal);\n        rng *= sign(rngdot);\n        //return vec3(rngdot);\n        //return hit.normal;\n        return vec3(abs(abs(rngdot) - dot(rng, hit.normal)));\n        color *= abs(rngdot);\n        ray.direction = rng;\n    }\n\n    if (length(color) < 0.999 && length(background(ray)) > 0.99999) {\n        //color *= 10.0;\n    }\n\n    return color * background(ray);\n    return randomPointSphere(rngState);\n}\n\nRay generateRay(vec2 fragCoord, inout uint rngState) {\n    vec2 rotation = load(ROTATION_INDEX).xy / iResolution.x;\n    \n    vec2 jitter = vec2(uniformFloat01(rngState), uniformFloat01(rngState)) - 0.5f;\n    jitter *= 1.0;\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    \n    mat3 mat = CameraRotation(rotation);\n    \n    vec3 ro = vec3(0.0, 0.0, -10.0) * mat;\n    vec3 rd = normalize(vec3((fragCoord + jitter - iResolution.xy*0.5)*a, 0.5)) * mat;\n    return Ray(ro, rd);\n}\n\n\nvec3 finalGather(vec3 color, vec2 fragCoord) {\n    int frameCount = getFrameCount();\n    if (frameCount != 0) {\n        vec3 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n        color = mix(lastFrameColor, color, 1.0f / float(frameCount+1));\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);    \n    Ray ray = generateRay(fragCoord, rngState);\n\n    vec3 col = traceRay(ray, rngState);\n    col = finalGather(col, fragCoord);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/**\n  * Persistent states\n  */\n#define store(pos, value) if (all(equal(ivec2(fragCoord), (pos)))) { fragColor = (value); }\n\nvoid updateCamera(inout vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame == 0) {\n        store(PREVIOUS_ROTATION_INDEX, vec4(0.0, 0.0, 0.0, 0.0));\n        store(ROTATION_INDEX, vec4(0.0, 0.0, 0.0, 0.0));\n    }\n    \n    vec2 prevRotation = load(PREVIOUS_ROTATION_INDEX).xy;\n    vec3 rotation = load(ROTATION_INDEX).xyz;\n\n    bool mouseButtonDown = iMouse.z > 0.0;\n    vec2 mouseCurrentPos = iMouse.xy;\n    vec2 mouseClickPos = abs(iMouse.zw);\n    vec2 mouseDelta = (mouseClickPos - mouseCurrentPos) * 3.0;\n    \n    if (mouseButtonDown) {\n        store(ROTATION_INDEX, vec4(prevRotation + mouseDelta, 1.0, 0.0));\n    } else if (rotation.z != 0.0) {\n        store(PREVIOUS_ROTATION_INDEX, vec4(rotation.xy, 0.0, 0.0));\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = load(ivec2(fragCoord));\n\n    bool isResolutionChanged = any(notEqual(load(RESOLUTION_INDEX).xy, iResolution.xy));\n    store(RESOLUTION_INDEX, vec4(iResolution, 0.0));\n    \n    bool atStart = iFrame == 0;\n    updateCamera(fragColor, fragCoord);\n\n    store(MOUSE_POS_INDEX, iMouse);\n    \n    bool isMouseMoved = !all(equal(load(MOUSE_POS_INDEX), iMouse));\n    bool needResetFrame = atStart || isMouseMoved || isResolutionChanged;\n    int frameCount = needResetFrame ? 0 : getFrameCount() + 1;\n    store(FRAME_COUNT_INDEX, vec4(float(frameCount), 0.0, 0.0, 0.0));\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define load(pos) texelFetch(iChannel1, (pos), 0)\n\nconst ivec2 MOUSE_POS_INDEX = ivec2(0, 0);\nconst ivec2 RESOLUTION_INDEX = ivec2(1, 0);\n\nconst ivec2 FRAME_COUNT_INDEX = ivec2(0, 1);\n\nconst ivec2 PREVIOUS_ROTATION_INDEX = ivec2(2, 0);\nconst ivec2 ROTATION_INDEX = ivec2(2, 1);\n\n#define getFrameCount() int(load(FRAME_COUNT_INDEX).x)\n\nmat3 CameraRotation(vec2 m)\n{\n    m.y = -m.y;\n    \n    vec2 s = sin(m);\n    vec2 c = cos(m);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.y, s.y, 0.0, -s.y, c.y);\n    mat3 rotY = mat3(c.x, 0.0, -s.x, 0.0, 1.0, 0.0, s.x, 0.0, c.x);\n    \n    return rotX * rotY;\n}\n\nvec3 lessThanV3(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\n// Random\nuint pcg(uint seed)\n{\n    uint state = seed * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n \nfloat uniformFloat01(inout uint state)\n{\n    state = pcg(state);\n    return float(state) / 4294967296.0;\n}\n\nfloat uniformFloatn01(inout uint state)\n{\n    return uniformFloat01(state) * 2.0 - 1.0;\n}\n\nvec3 randomPointSphere(inout uint state) {\n    vec3 pos = vec3(1.0);\n    \n    for (int i = 0; i < 50; i++) {\n        pos = vec3(uniformFloatn01(state), uniformFloatn01(state), uniformFloatn01(state));\n        float l = length(pos);\n        if (l < 1.0 && l > 0.01) {\n            break;\n        }\n    }\n    return normalize(pos);\n}\n\nvec3 sky(vec3 eyedir) {\n\tfloat pi = 3.1415;\n\t\n\tfloat v_angle = acos(clamp(eyedir.y, -1.0, 1.0));\n\tfloat c = (1.0 - v_angle / (pi * 0.5));\n\tfloat sky_curve = 0.06;\n\tvec3 sky_horizon_color = vec3(0.646, 0.656, 0.67);\n\tvec3 sky_top_color = vec3(0.2, 0.3, 0.4);\n\tvec3 sky = mix(sky_horizon_color, sky_top_color, clamp(1.0 - pow(1.0 - c, 1.0 / sky_curve), 0.0, 1.0));\n\tfloat sky_energy = 2.0;\n\tsky *= sky_energy;\n\n\tvec3 light0_color = vec3(1.0);\n\tfloat light0_energy = 1.0;\n\tfloat light0_size = 0.01 / pi;\n\tvec3 light0_direction = normalize(vec3(2.0, 1.0, 0.0));\n\t\n\tfloat sun_angle = acos(dot(light0_direction, eyedir));\n\tfloat sun_curve = 0.15;\n\tfloat sun_angle_max = 0.7;\n\tif (sun_angle < light0_size) {\n\t\tsky = light0_color * light0_energy;\n\t} else if (sun_angle < sun_angle_max) {\n\t\tfloat c2 = (sun_angle - light0_size) / (sun_angle_max - light0_size);\n\t\tsky = mix(light0_color * light0_energy, sky, clamp(1.0 - pow(1.0 - c2, 1.0 / sun_curve), 0.0, 1.0));\n\t}\n\n\tc = (v_angle - (pi * 0.5)) / (pi * 0.5);\n\tvec3 ground_bottom_color = vec3(0.2, 0.169, 0.133);\n\tvec3 ground_horizon_color = vec3(0.646, 0.656, 0.67);\n\tfloat ground_curve = 0.02;\n\tvec3 ground = mix(ground_horizon_color.rgb, ground_bottom_color, clamp(1.0 - pow(1.0 - c, 1.0 / ground_curve), 0.0, 1.0));\n\n\tvec3 color = mix(ground, sky, step(0.0, eyedir.y));\n\t\n\treturn color;\n}\n\nfloat colormap_red(float x) {\n\tif (x < 0.2523055374622345) {\n\t\treturn (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\n\t} else if (x < 0.6267540156841278) {\n\t\treturn (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\n\t} else if (x < 0.8763731146612115) {\n\t\treturn 3.28717357910916E+01 * x + 8.82117255504255E+00;\n\t} else {\n\t\treturn -2.29186583577707E+02 * x + 2.38482038123159E+02;\n\t}\n}\n\nfloat colormap_green(float x) {\n\tif (x < 0.4578040540218353) {\n\t\treturn ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\n\t} else {\n\t\treturn ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\n\t}\n}\n\nfloat colormap_blue(float x) {\n\tif (x < 0.1239372193813324) {\n\t\treturn (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\n\t} else if (x < 0.7535201013088226) {\n\t\treturn ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\n\t} else {\n\t\treturn (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\n\t}\n}\n\nvec4 colormap(float x) {\n\tfloat r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\n\tfloat g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\n\tfloat b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\n\treturn vec4(r, g, b, 1.0);\n}\n\nvec3 debug_step(float t) {\n    if (t < 0.0) {\n        return vec3(0.0);\n    } else if (t > 1.0) {\n        return vec3(1.0, 1.0, 0.0);\n    }\n    \n    return colormap(t).rgb;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dds3W7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 123]], "test": "untested"}
{"id": "7lBcWV", "name": "Dumb Feedback Shader", "author": "byt3_m3chanic", "description": "just a dumb feedback shader - Buffer - I dont even know her!", "tags": ["feedback", "buffer"], "likes": 31, "viewed": 492, "published": 3, "date": "1666250902", "time_retrieved": "2024-07-30T16:25:35.710179", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    dumb feedback shader..looks kind of cool and runs pretty good fullscreen.\n    10/20/22 @byt3_m3chanic \n*/\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    vec3 C = vec3(0);\n    vec2 uv = F.xy/R.xy;\n \n    C = texture(iChannel0,uv).rgb;   \n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    dumb feedback shader..looks kind of cool and runs pretty good fullscreen.\n    10/20/22 @byt3_m3chanic  \n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI2 6.28318530718\n#define PI  3.14159265359\n\nmat2 rot(float g) {return mat2(cos(g), sin(g),-sin(g), cos(g));}\nfloat hash21( vec2 p ) {return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234);}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n    // Four corners in 2D of a tile\n    float a = hash21(i);\n    float b = hash21(i + vec2(1.0, 0.0));\n    float c = hash21(i + vec2(0.0, 1.0));\n    float d = hash21(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3. - 2.0 * f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nconst int oct = 2;\nfloat fbm ( in vec2 uv) {\n    uv*=.125;\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    mat2 rt = rot(.15);\n    for (int i = 0; i < oct; ++i) {\n        v += a * noise(uv);\n        uv = rt * uv * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n", "buffer_a_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    dumb feedback shader..looks kind of cool and runs pretty good fullscreen.\n    10/20/22 @byt3_m3chanic  \n*/\n\nfloat time;\nconst float scale = 5.;\n\nvec3 hue(float t){ \n    const vec3 c = vec3(0.122,0.467,0.918);\n    return .4 + .4*cos(PI2*t*(c+vec3(0.000,0.475,0.839))); \n}\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    time = iTime;\n\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    vec2 vuv = uv;\n    uv*=rot(T*.1);\n    vec3 C = texture(iChannel0,(F.xy/R.xy)).rgb*exp2(-2.*iTimeDelta);\n    \n    uv.y-=1.25*sin(T*.075);\n    uv.x-=.25*cos((T*.5)+1.*sin(T*.05));\n    \n    float px = scale/R.x;\n\n    vec2 id= floor(uv*scale);\n    vec2 p = fract(uv*scale)-.5;\n    \n    \n    float hf = hash21(id);\n    float xk = .02;\n    if(hf>.8){\n        id= floor(p+id*2.);\n        p = fract(p*2.)-.5;\n        hf = hash21(id);\n        px = scale*2./R.x;\n        xk = .03;\n        if(hf>.7){\n            id= floor(p+id*2.);\n            p = fract(p*2.)-.5;\n            hf = hash21(id);\n            px = scale*4./R.x;\n            xk = .04;\n            if(hf>.9){\n                id= floor(p+id*2.);\n                p = fract(p*2.)-.5;\n                hf = hash21(id);\n                px = scale*8./R.x;\n                xk = .05;\n            }\n        }\n    }\n    \n    float hs = fbm(id*3.25);\n\n    p*=rot(T*(.1*hs)*PI);\n    float d1 = hf>.5?length(p)-(hf*.5):box(p,vec2(.365,hf*.25));\n\n    d1=smoothstep(px,-px,abs(d1)-xk);\n\n    float ff = vuv.y*.075;\n    vec3 clr=mix(hue((ff*PI)+T*.05),hue(((1.-ff)*PI)+T*.025),ff);\n    C = mix(C,hf>.6?clr:vec3(.03),d1);\n\n    O = vec4(C,1.);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBcWV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[209, 209, 250, 250, 389]], "test": "untested"}
{"id": "mslGWM", "name": "anaglyph stereo infinite cave", "author": "mds2", "description": "Someone showed me a visual from before a Katy Perry show, so I decided to try to replicate it.\n\nThen I decided to try to make it in anaglyph stereo and to add some extra stuff.", "tags": ["anaglyph", "stereo", "depth"], "likes": 1, "viewed": 132, "published": 3, "date": "1666244635", "time_retrieved": "2024-07-30T16:25:36.465161", "image_code": "#define LIGHT_THICK 0.1\n#define LIGHT_HEIGHT 0.3\n#define GAP_HEIGHT 0.6\n#define CORNER_SCALE 0.02\n#define BLEND_SCALE 0.04\n\n#define PROJECTILE_RAD 0.0125\n\n#define NUM_PROJECTILES 6\nvec3 projectiles[NUM_PROJECTILES] = vec3[](vec3(0.5, 0.1, 0.0), vec3(-0.2, 0.35, 0.0), vec3(-0.5, -0.2, 0.0),\n                                           vec3(0.5, -0.15, 0.0), vec3(-0.2, -0.35, 0.0), vec3(-0.75, -0.2, 0.0));\n\nvoid initializeProjectiles() {\n  float back = -8.0 * iTime;\n  for (int i = 0; i < NUM_PROJECTILES; ++i) {\n    projectiles[i].z = mod(back, 32.0) - 1.;\n    back += 7.0;\n  }\n}\n\nfloat sdfProjectiles(in vec3 pt) {\n  float minDist = 400.0;\n  for (int i = 0; i < NUM_PROJECTILES; ++i) {\n    minDist = min(minDist, 0.95 * (length(vec3(1.0, 1.0, 0.125) * (pt - projectiles[i])) - PROJECTILE_RAD));\n  }\n  return minDist;\n}\n\nfloat sdfZ(in float z) {\n  float zMod = mod(z + iTime, GAP_HEIGHT + LIGHT_HEIGHT);\n  float bottomZ = 0.5 * LIGHT_HEIGHT - zMod;\n  float topZ = zMod - 1.5 * LIGHT_HEIGHT;\n  float zDist = max(topZ, bottomZ);\n  if (z > 15.0) {\n    return max(zDist, 0.1);\n  }\n  return zDist;\n}\n\nfloat sdf(in vec3 pt, in vec2 wh) {\n  vec2 dists = wh - abs(pt.xy);\n  float closest = checked_smooth_min(dists.x, dists.y, CORNER_SCALE);\n  float zDist = sdfZ(pt.z);\n  float zMod = mod(pt.z + iTime, GAP_HEIGHT + LIGHT_HEIGHT);\n  float crinkly = 0.0;\n  if (abs(closest - LIGHT_THICK) < 0.15 * LIGHT_THICK && zDist < 0.15 * LIGHT_THICK) {\n    crinkly = texture(iChannel0, vec2(dot(vec2(1.0), pt.xy), zMod)).r;\n  }\n  float wallsSdf = min(closest, checked_smooth_max(zDist, closest + 0.1 * LIGHT_THICK * crinkly - LIGHT_THICK, BLEND_SCALE));\n  return min(wallsSdf, sdfProjectiles(pt));\n}\n\nvec3 sdfSurfNorm(in vec3 pt, in vec2 wh) {\n  float f = sdf(pt, wh);\n  const float h = 1.0e-3;\n  return normalize(vec3(sdf(pt + vec3(h, 0.0, 0.0), wh) - f,\n                        sdf(pt + vec3(0.0, h, 0.0), wh) - f,\n                        sdf(pt + vec3(0.0, 0.0, h), wh) - f));\n}\n\nfloat toCorner(in vec3 pt, in vec2 wh) {\n  float zMod = mod(pt.z + iTime, GAP_HEIGHT + LIGHT_HEIGHT);\n  float zDist = max(0.0, 1.5 * LIGHT_HEIGHT - zMod);\n  zDist = min(zDist, 0.5 * (LIGHT_HEIGHT + LIGHT_THICK));\n  vec2 dists = wh - abs(pt.xy);\n  float xyDist = checked_smooth_min(dists.x, dists.y, CORNER_SCALE);\n  return length(vec2(zDist, xyDist));\n}\n\nfloat castRay(in vec3 o, in vec3 d, in vec2 wh, out int hitLight, out float accum) {\n  vec2 dxy = abs(d.xy);\n  vec2 oSign = sign(d.xy);\n  vec2 muls = (wh - oSign * o.xy - 1.5 * LIGHT_THICK) / max(dxy, vec2(1.0e-3));\n  float toLightInner = min(muls.x, muls.y);\n  hitLight = 0;\n  accum = 0.0;\n  float curr = min(sdfProjectiles(o), toLightInner);\n  for (int i = 0; i < 60; ++i) {\n    vec3 p = o + curr * d;\n    float dist = sdf(p, wh);\n    if (dist < 1.0e-3) {\n      if (sdfZ(p.z) < 0.01) {\n        hitLight = 1;\n      }\n      return curr;\n    }\n    if (curr > 50.0) {\n      return 50.0;\n    }\n    curr = curr + 0.9 * dist;\n    accum += 0.7 / max(0.1, dist);\n  }\n  return curr;\n}\n\nfloat ramp(in float a, in float b, in float x) {\n  return max(0.0, min(1.0, (x-a)/(b-a)));\n}\n\nfloat monocularImage( in vec2 fragCoord, float eye )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec2 wh = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    vec3 orig = vec3(0.0, 0.0, -2.0);\n    \n    // orig.xy = 0.7 * (2.0 * iMouse.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    orig.x += eye;\n    \n    vec3 dir = normalize(vec3(uv, 0.0) - orig);\n    \n    int hitLight = 0;\n    \n    float glow = 0.0;\n    \n    float d = castRay(orig, dir, wh, hitLight, glow);\n\n    // Time varying pixel color\n    float col = (1.0);\n    \n    if (hitLight == 0) {\n      col = (0.0);\n    } else {\n      float subD = toCorner(orig + dir * d, wh);\n      float maxDist = length(vec2(LIGHT_HEIGHT, LIGHT_THICK));\n      col *= LIGHT_THICK / subD;\n    }\n    \n    vec3 surfNorm = sdfSurfNorm(orig + dir * d, wh);\n    vec3 bounce = normalize(reflect(dir, surfNorm));\n    float eyeLight = smoothstep(-1.0, 1.0, -dot(bounce, dir));\n    col += eyeLight;\n    \n    \n    col += 1.0e-2 * glow * 2.0;\n    \n    col = mix(0.5, col, smoothstep(15.0, 10.0, d) * max(0.0, min(1.0, 0.75/d)));\n    \n\n    // Output to screen\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  initializeProjectiles();\n  fragColor.r = monocularImage(fragCoord, -0.125);\n  fragColor.gb = vec2(monocularImage(fragCoord, 0.125));\n  fragColor.a = 1.0;\n  }", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/**\n * standard blend func, courtesy IQ\n */\nfloat conventional_smin(in highp float a, in highp float b, in highp float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/** more expensive, but smoother, blend funcs */\nfloat super_smooth_max(in highp float a, in highp float b, in highp float k) {\n  // return 0.25 * k * log(exp(4.0 * a / k) + exp(4.0 * b / k));\n  return 0.1732802*k*log2(exp2(5.771*a/k) + exp2(5.771*b/k));\n}\n\nfloat super_smooth_min(in float a, in float b, in float k) {\n  return -super_smooth_max(-a, -b, k);\n}\n\n/** best of both worlds */\nfloat checked_smooth_min(in highp float a, in highp float b, in highp float k) {\n  float val = conventional_smin(a, b, k);\n  if (abs(val) < 4.0 * k) {\n    return super_smooth_min(a, b, k);\n  }\n  return val;\n}\n\nfloat checked_smooth_max(in highp float a, in highp float b, in highp float k) {\n  return -checked_smooth_min(-a, -b, k);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mslGWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[407, 407, 437, 437, 580], [582, 582, 616, 616, 820], [822, 822, 846, 846, 1095], [1097, 1097, 1132, 1132, 1680], [1682, 1682, 1724, 1724, 1962], [1964, 1964, 2004, 2004, 2317], [2319, 2319, 2403, 2403, 2995], [2997, 2997, 3045, 3045, 3089], [3091, 3091, 3145, 3195, 4320], [4322, 4322, 4379, 4379, 4539]], "test": "untested"}
{"id": "cds3D7", "name": "reaction diffusion attempt", "author": "ufffd", "description": "trying to follow https://www.youtube.com/watch?v=BV9ny785UNc\ninspired by byte_mechanic (https://www.shadertoy.com/view/ddX3R7) who was inspired by leon and coding train who both also inspired me", "tags": ["reactiondiffusion"], "likes": 4, "viewed": 181, "published": 3, "date": "1666244396", "time_retrieved": "2024-07-30T16:25:37.266019", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // smoothstep the A channel as output\n    vec3 col = vec3(smoothstep(0.4,0.6,texture(iChannel0,uv).a));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float dA = 1.;\nfloat dB = .25;\nfloat feed = 0.055;\nfloat k = 0.062;\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvec2 laplacianAB(in vec2 xy) {\n    vec2 sum = vec2(0.);\n    vec2 px = 1./iResolution.xy;\n    px *= 1.;\n    int range = 1;\n    for (int i=-range;i<range+1;i++){\n        for (int j=-range;j<range+1;j++){\n            vec2 offset = vec2(float(i),float(j))*px;\n            float factor = 0.05;\n            if (i==0||j==0) factor = 0.2;\n            if (i==0&&j==0) factor = -1.;\n            if (i<-1||j<-1) factor = 0.025;\n            if (i>1||j>1) factor = 0.025;\n            sum += texture(iChannel0,xy+offset).ab*factor;\n        }\n    }\n    return sum;\n}\n\nvec2 setAB(in vec2 xy) {\n    float a = texture(iChannel0,xy).a;\n    float b = texture(iChannel0,xy).b;\n    vec2 lapAB = laplacianAB(xy);\n    return vec2(\n        a +\n        dA * lapAB.x -\n        a * b * b +\n        feed * (1. - a),\n        b +\n        dB * lapAB.y +\n        a * b * b -\n        (k + feed) * b\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = (fragCoord*2. - iResolution.xy)/iResolution.y;\n    if (iFrame < 10) {\n        fragColor.b = step(0.5,length(uvc));\n        fragColor.b = mix(fragColor.b,1.,step(0.1,sin(50.*length(uvc.x))));\n        fragColor.b = mix(fragColor.b,1.,step(0.1,sin(50.*length(uvc.y))));\n        fragColor.a = 1.-fragColor.b;\n        return;\n    }\n    \n    float mouse_dist = distance(iMouse.xy/iResolution.xy,uv);\n    \n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv = rotate(uv,0.001);\n    uv.x /= iResolution.x/iResolution.y;\n    uv -= 0.5;\n    fragColor.ab = setAB(uv);\n    if (iMouse.z > 0.5) {\n        if (mouse_dist<0.03) { fragColor.b = 1.; fragColor.a = 0.; }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cds3D7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 313]], "test": "untested"}
{"id": "dslGWM", "name": "Perlin noise Kaleidoscope ", "author": "fyisic123", "description": "Hope you are having a great day :)", "tags": ["noise", "perlin", "kaleidoscope", "hue", "psy"], "likes": 6, "viewed": 225, "published": 3, "date": "1666244310", "time_retrieved": "2024-07-30T16:25:38.008036", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n     vec2 uv = (fragCoord.xy -.5 * iResolution.xy) / iResolution.y;        \n    float ogLen = length(uv); \n    \n    uv *= Rot(iTime * .1);  // slowly rotate all\n    \n    \n    // Credit to this shader for Kaleidoscope , i pretty much just copied and changed some numbers\n    //  https://www.shadertoy.com/view/4lsGWj\n    float r = 2. + (.25  * sin(iTime*0.1));\n    float a = iTime*.1;\n    float c = cos(a)*r;\n    float s = sin(a)*r;        \n    for ( int i=0; i < 5; i++ )\n    {\n    \tuv = abs(uv);\n        uv -= .25;\n        uv = uv*c + s*uv.yx*vec2(1,-1);\n    }\n    \n    \n    \n    uv *= (1.0 - ogLen) * .5 ; // making it bubble out at the sides\n    \n    \n    float p = perlin(uv + vec2(iTime, -iTime) * 0.45); // getting perlin value\n     \n\n    // Output to screen\n    vec3 h = hue(p * 40.);\n    fragColor = vec4(h , 1.0);\n}", "image_inputs": [], "common_code": "\n#define hue(v) ( .6 + .6 * cos( 2.*PI*(v) + vec3(0,-2.*PI/3.,2.*PI/3.) ) )\n#define PI 3.14159265359\n\nfloat interpolate(float a0, float a1, float w) {\n    \n     if (0.0 > w) return a0;\n     if (1.0 < w) return a1;        \n    return (a1 - a0) * (3.0 - w * 2.0) * w * w + a0;\n    \n}\n\nfloat hash12(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\nfloat dotGridGradient(float ix, float iy, float x, float y) {\n    \n    vec2 gradient = hash22(vec2(ix, iy));    \n    float dx = x - ix;\n    float dy = y - iy;    \n    return (dx*gradient.x + dy*gradient.y);\n}\n\nfloat perlin(vec2 p) {\n    \n    float x0 = floor(p.x);\n    float x1 = x0 + 1.;\n    float y0 = floor(p.y);\n    float y1 = y0 + 1.;\n\n    \n    float sx = p.x - x0;\n    float sy = p.y - y0;\n\n    \n    float n0, n1, ix0, ix1, value;\n\n    n0 = dotGridGradient(x0, y0, p.x, p.y);\n    n1 = dotGridGradient(x1, y0, p.x, p.y);\n    ix0 = interpolate(n0, n1, sx);\n\n    n0 = dotGridGradient(x0, y1, p.x, p.y);\n    n1 = dotGridGradient(x1, y1, p.x, p.y);\n    ix1 = interpolate(n0, n1, sx);\n\n    value = interpolate(ix0, ix1, sy);\n    return value * 0.5 + 0.5; \n}\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dslGWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 884]], "test": "untested"}
{"id": "Dsl3W7", "name": "chromatic dispersion 2", "author": "elenzil", "description": "16-tap naive chromatic dispersion.\nswitch to 8 taps at top of common tab.\nminor change around distribution of sampled colors.", "tags": ["refraction", "optics", "fresnel", "chromaticdispersion"], "likes": 19, "viewed": 356, "published": 3, "date": "1666235814", "time_retrieved": "2024-07-30T16:25:38.941540", "image_code": "// Fork of \"chromatic dispersion!\" by elenzil. https://shadertoy.com/view/ftcBRs\n// 2022-10-20 02:30:35\n\n// Chromatic Dispersion.\n//  8-tap version: https://www.shadertoy.com/view/cssGRn\n// 16-tap version: https://www.shadertoy.com/view/ftcBRs\n//\n// The actual work is all in the Common Tab.\n//\n// Here we collect the per-wavelength intensities from each of the buffers,\n// convert the wavelengths to RGB, and add them up.\n// I am not an expert on SRGB, so there are likely some things missing.\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n\n#if SIXTEEN_TAPS\n#define NUM_BANKS 4u\n#else\n#define NUM_BANKS 2u\n#endif\n\n    vec4 colors[NUM_BANKS];\n    \n    colors[0] = texelFetch(iChannel0, ivec2(XY), 0);\n    colors[1] = texelFetch(iChannel1, ivec2(XY), 0);\n#if SIXTEEN_TAPS\n    colors[2] = texelFetch(iChannel2, ivec2(XY), 0);\n    colors[3] = texelFetch(iChannel3, ivec2(XY), 0);\n#endif\n\n    vec3 accum = vec3(0.0);    \n    \n    for (uint wlBank = 0u; wlBank < NUM_BANKS; ++wlBank) {\n        for (uint wlSubIndex = 0u; wlSubIndex < 4u; ++wlSubIndex) {\n            float wlNm     = wavelengthNmFromBank(wlBank, wlSubIndex, XY);\n            vec3 rgb = spectral_zucconi(wlNm);\n            accum += colors[wlBank][wlSubIndex] * rgb;\n        }\n    }\n    \n    accum *= 1.5 / float(NUM_BANKS);\n    \n    RGBA = vec4(accum, 1.0);\n    \n    // gamma\n    RGBA.rgb = pow(RGBA.rgb, vec3(0.5));\n}\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// 0 = 8 taps, 1 = 16 taps.\n#define SIXTEEN_TAPS 1\n\n\n#define MINRES (min(RES.x, RES.y))\n\nconst float pi = 3.14159265359;\nconst vec3  v1 = vec3(1.0);\nconst vec3  v0 = vec3(0.0);\nconst vec3  vX = vec3(1.0, 0.0, 0.0);\nconst vec3  vY = vec3(0.0, 1.0, 0.0);\nconst vec3  vZ = vec3(0.0, 0.0, 1.0);\n\n//--------------------------------------------------------------------------------\n\nstruct ray_t {\n    vec3  ro;\n    vec3  rd;\n    float amt;   // [0, 1] amount of light left in the ray\n    float side;  // -1 = inside, 1 = outside.\n};\n\nstruct hit_t {\n    bool  hit;\n    float t;\n    vec3  pnt;\n    vec3  nrm;\n    uint  mtl;\n};\n\nhit_t newHit() {\n    hit_t ret;\n    ret.hit = false;\n    ret.t   = 1e9;\n    return ret;\n}\n\nstruct mtl_t {\n    float ior;\n    float diffVsTrns; // (0 = diffuse 1 = transparent), modulo reflection\n    \n    // Here is how the light contribution is allocated at a surface collision:\n    // ior                = Cauchy(ior, wavelength)\n    // reflect            = Schlick(ior)  (aka Fresnel)\n    // transmit + diffuse = 1 - reflect\n    // transmit           =      diffVsTrans  * (1 - reflect)\n    // diffuse            = (1 - diffVsTrans) * (1 - reflect)\n};\n\n//--------------------------------------------------------------------------------\n\nconst float ior_air     =  1.0003;\nconst float ior_aerogel =  1.03;\nconst float ior_ice     =  1.309;\nconst float ior_water   =  1.333;\nconst float ior_quartz  =  1.46;\nconst float ior_diamond =  2.42;\nconst float ior_shiny1  =  4.0;    // ad hoc\nconst float ior_mrr     =  1e2;    // ad hoc\n\nconst uint mtl_air   = 0u;\nconst uint mtl_ball1 = 1u;\nconst uint mtl_ball2 = 2u;\nconst uint mtl_floor = 3u;\nconst uint mtl_matte = 4u;\n\nconst mtl_t materials[] = mtl_t[](\n    mtl_t(ior_air    , 1.0),    // 0\n    mtl_t(ior_aerogel, 1.0),    // 1\n    mtl_t(ior_ice    , 1.0),    // 2\n    mtl_t(ior_air    , 0.0),    // 3\n    mtl_t(ior_air    , 0.0)     // 4\n);\n\n//--------------------------------------------------------------------------------\n//  David Hoskins\n//  https://www.shadertoy.com/view/4djSRW\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//--------------------------------------------------------------------------------\n\nconst float um_from_nm = 0.001;\nconst float wavelengthMax = 679.0;\nconst float wavelengthMin = 401.0;\n\n#if SIXTEEN_TAPS\nconst float numTaps = 16.0;\n#else\nconst float numTaps = 8.0;\n#endif\n\nfloat wavelengthNmFromBank(uint wlBank, uint wlSubIndex, vec2 xy) {\n    float wlNrmMin = float(wlBank * 4u + wlSubIndex     ) / numTaps;\n    float wlNrmMax = float(wlBank * 4u + wlSubIndex + 1u) / numTaps;\n    float t1       = hash12(xy * 1e3 + 1e2);\n    float t2       = mix(wlNrmMin, wlNrmMax, t1);\n    float wlNm     = mix(wavelengthMin, wavelengthMax, t2);\n    \n    return wlNm;\n}\n\n\n//--------------------------------------------------------------------------------\n\n// fifo queue.\n// usage:\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENMTATION.\n// This is a basic ringbuffer.\n// NO ERROR CHECKING\n// orion elenzil 2022.\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIES;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nuint QCount() {                                    \\\n    if (gQHead >= gQTail) {                        \\\n        return gQHead - gQTail;                    \\\n    }                                              \\\n    else {                                         \\\n        return gQNumSlots - (gQTail - gQHead);     \\\n    }                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n    return gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n    return QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n    return QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint QEnqueueIndex() {                             \\\n    gQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint QDequeueIndex() {                             \\\n    gQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n    gQ[QEnqueueIndex()] = item;                    \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n    return gQ[QDequeueIndex()];                    \\\n}\n////////////////////////////////////////////////////\n\n\n//--------------------------------------------------------------------------------\n\n// returns false if there are no real roots.\n// returns true if there are one or two real roots.\n// roots.x <= roots.y.\nbool solveQuadratic(in vec3 coeffs, out vec2 roots) {\n    const uint A = 0u;\n    const uint B = 1u;\n    const uint C = 2u;\n    \n    // (-B +- sqrt(BB - 4AC)) / 2A\n    \n    float disc = (coeffs[B] * coeffs[B]) - (4.0 * coeffs[A] * coeffs[C]);\n    \n    if (disc < 0.0) {\n        return false;\n    }\n    \n    float sqrt_disc = sqrt(disc);\n    \n    roots.x = (-coeffs[B] - sqrt_disc) / (2.0 * coeffs[A]);\n    roots.y = (-coeffs[B] + sqrt_disc) / (2.0 * coeffs[A]);\n    \n    if (roots.y < roots.x) {\n        roots.xy = roots.yx;\n    }\n    \n    return true;\n}\n\n//--------------------------------------------------------------------------------\n\nmat3 matLookTo(in vec3 lookFrom, in vec3 lookTo) {\n    vec3 fw = -normalize(lookTo - lookFrom);\n    vec3 rt =  normalize(cross(fw, vY));\n    vec3 up =  cross(rt, fw);\n    \n    return mat3(rt, up, fw);\n}\n\nmat2 matRot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n\n//--------------------------------------------------------------------------------\n\n// https://www.shadertoy.com/view/ls2Bz1\n\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n    vec3 y = vec3(1.,1.,1.) - x * x;\n    y = saturate(y-yoffset);\n    return y;\n}\nvec3 spectral_zucconi (float w)\n{\n    // w: [400, 700]\n    // x: [0,   1]\n    float x = saturate((w - 400.0)/ 300.0);\n\n    const vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n    const vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n    const vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n    return bump3y ( cs * (x - xs), ys);\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float w)\n{\n    // w: [400, 700]\n    // x: [0,   1]\n    float x = saturate((w - 400.0)/ 300.0);\n\n    const vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n    const vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n    const vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n    const vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n    const vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n    const vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n    return\n        bump3y(c1 * (x - x1), y1) +\n        bump3y(c2 * (x - x2), y2) ;\n}\n\n\n//--------------------------------------------------------------------------------\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvoid rayVsPlane(in ray_t ray, in vec3 n, in float d, uint mtl, inout hit_t hit) {\n    float t = -(dot(ray.ro, n) + d) / (dot(ray.rd, n));\n    if (t > 0.0 && t < hit.t) {\n        hit.hit = true;\n        hit.t   = t;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = n;\n    }\n}\n\n//--------------------------------------------------------------------------------\n\nvoid rayVsSphere(in ray_t ray, in vec3 c, float r, uint mtl, inout hit_t hit) {\n    \n    vec3 ro = ray.ro - c;\n    vec3 rd = ray.rd;\n\n    float A = dot(rd, rd);\n    float B = dot(ro, rd) * 2.0;\n    float C = dot(ro, ro) - (r * r);\n    \n    vec2 roots;\n    if (!solveQuadratic(vec3(A, B, C), roots)) {\n        return;\n    }\n    \n    if (roots.y < 0.0) {\n        // both hits are before the start of the ray\n        return;\n    }\n    \n    if (roots.x > 0.0) {\n        if (roots.x > hit.t) {\n            return;\n        }\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.x;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n    \n    if (roots.y < hit.t) {\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.y;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n}\n\n//--------------------------------------------------------------------------------\n\n// https://en.wikipedia.org/wiki/Schlick%27s_approximation\nfloat schlickR0(in float n1, in float n2) {\n    // same if n1 and n2 are swapped.\n    float q  = (n1 - n2) / (n1 + n2);\n    float q2 = q * q;\n    return q2;\n}\n\nfloat schlick(in float R0, in float cosTheta) {\n    float q  = 1.0 - cosTheta;\n    float q5 = q * q * q * q * q;\n    return R0 + ((1.0 - R0) * q5);\n}\n\n// https://en.wikipedia.org/wiki/Cauchy%27s_equation\nfloat cauchyN(in float invWavelengthMicrometersSquared, in float A) {\n    // I can't find a table of Cauchy coefficients,\n    // so just going with something.\n    const float B = 0.01;\n    return A + B * invWavelengthMicrometersSquared;\n}\n\n//---------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------\n\n// Below here is all the code that would go into a \"single tap\" implementation of this.\n// Since we're doing multi-taps and want this exact same code in several buffers,\n// we put it here in ShaderToy's \"common\" tab, which is like an implicit #include.\n\n\nconst float gMinRayAmt =  0.01;     // a ray must have at least this much \"amt\" to be included.\nconst uint  gMaxRays   = 10u;       // maximum number of rays per pixel per wavelength.\nconst float gSurfEps   =  0.001;    // a small distance relative to this scene.\nconst float gZoom      =  1.2;\n\nvec2 RES;\n\nfloat gT;            // time.\nvec3  gSunDir;       // direction to sun.\n\n\n// ringbuffer of rays\n#define Q_TYPE ray_t\n#define Q_MAX_ENTRIES 10u\nQ_IMPLEMENTATION\n\nconst float blankSkyTone = 0.01;\n\nfloat toneSky(in vec3 dir) {\n    float eps = cos(0.05);\n    float q = smoothstep(-.001, 0.0, dot(dir, gSunDir) - eps);\n    // the \"sun\" has brightness > 1.\n    q *= 2e1;\n    q = q * (1.0 - blankSkyTone) + blankSkyTone;\n    return q;\n}\n\nfloat toneChecks(in vec2 p) {\n    const float width2 = 0.03;\n          float width1 = width2 * mix(0.1, 0.9, smoothstep(10.0, 1.0, length(p)));\n    p *= 0.25;\n    float q = 1.0;\n    q *= smoothstep(width1, width2, abs(fract(p.x) - 0.5));\n    q *= smoothstep(width1, width2, abs(fract(p.y) - 0.5));\n    q *= smoothstep(width1, width2, abs(length(p) / 1.5 - 1.0) * 1.5);\n    q  = 1.0 - 0.95 * q;\n    q = mix(q, blankSkyTone, smoothstep(2.0, 10.0, length(p)));\n    return q;\n}\n\nfloat toneMatte(in vec3 nrm) {\n    return max(0.0, dot(nrm, gSunDir));\n}\n\nfloat tone(in hit_t h, in ray_t r) {\n    // using if()'s here because iOS was behaving strangely with switch().\n    if (h.mtl == mtl_air) {\n        return toneSky(r.rd);\n    }\n    if (h.mtl == mtl_floor) {\n        return toneChecks(h.pnt.xz) * toneMatte(h.nrm);\n    }\n    return toneMatte(h.nrm);\n}\n\n// convert a screen-space coordinate to viewport.\nvec2 viewportFromScreen(in vec2 p) {\n    return (p * 2.0 - RES.xy) / MINRES / gZoom;\n}\n\nvec3 gBallPos1;\nvec3 gBallPos2;\nvoid setupScene() {\n    gSunDir = normalize(vec3(0.0, 3.0 + sin(gT * 0.1) * 2.8, -10.0));\n    gSunDir.xz = matRot2(gT * 0.7) * gSunDir.xz;\n    \n    const float bounceHeight = 0.75;\n    \n    float fT1 = fract(gT * 2.00) * 2.0 - 1.0;\n    float fT2 = fract(gT * 2.21) * 2.0 - 1.0;\n    gBallPos1 = vY * (1.0 + bounceHeight - fT1 * fT1 * bounceHeight) - vZ * 1.5;\n    gBallPos2 = vY * (1.0 + bounceHeight - fT2 * fT2 * bounceHeight) + vZ * 1.5;\n}\n\n// given a ray and a running hit,\n// modify the hit to indicate the nearest intersection with the ray.\nvoid rayVsScene(in ray_t r, inout hit_t h) {\n    rayVsPlane (r, vY       , 0.0, mtl_floor, h);\n    rayVsSphere(r, gBallPos1, 1.0, mtl_ball1, h);\n    rayVsSphere(r, gBallPos2, 1.0, mtl_ball2, h);\n}\n\n// Ordinarily this would be 'main()', but it's here in Common for re-use in multiple buffers.\n// Uniforms like resolution, time, mouse are passed in because they're not available in Common.\n//\n// This returns the intensity at this pixel for 4 separate wavelengths ray-traced through the scene.\nvec4 commonMain(in vec2 XY, in float inTime, in vec2 inRes, in vec4 iMouse, in uint wlBank) {\n    RES     = inRes;\n    gT      = inTime * 0.2;\n    vec2 xy = viewportFromScreen(XY);\n    vec2 m  = viewportFromScreen(length(iMouse.xy) < 40.0 ? RES.xy / 2.0 : iMouse.xy);\n    \n    setupScene();\n    \n    // setup camera\n    float theta     = gT - m.x * pi;\n    vec3  lookTo    = vY;\n    vec3  lookFrom  = vec3(cos(theta), 0.4 - m.y, sin(theta)) * 5.0;\n    // don't let camera go below the floor\n    lookFrom.y = max(0.1, lookFrom.y);\n    \n    // ret is the output.\n    vec4 ret = vec4(0.0);\n    \n    \n    // loop over 4 wavelengths\n    for (uint wlSubIndex = 0u; wlSubIndex < 4u; wlSubIndex++) {\n    \n        float wlNm = wavelengthNmFromBank(wlBank, wlSubIndex, XY);\n        float wlUm = um_from_nm * wlNm;\n        float invWavelengthUmSquared = 1.0 / (wlUm * wlUm);\n\n        // intensity for this wavelength.\n        float wlOut = 0.0;\n\n        ray_t r0;\n        r0.ro   = lookFrom;\n        r0.rd   = matLookTo(lookFrom, lookTo) * normalize(vec3(xy, -2.0));\n        r0.amt  = 1.0;\n        r0.side = 1.0;\n        // ^-- cheating a little with side = 1. We're assuming the ray begins outside any object.\n\n        QEnqueue(r0);\n\n        uint rayCount = 0u;\n\n        while (!QIsEmpty()) {\n            rayCount += 1u;\n            ray_t r = QDequeue();\n\n            hit_t h = newHit();\n            h.mtl = mtl_air;    \n            rayVsScene(r, h);\n\n            if (!h.hit) {\n                // no hit\n                wlOut += r.amt * tone(h, r);\n            }\n            else {\n                // a hit!\n                // \"nrm\" here is the hit-facing normal,\n                // while h.nrm is the \"outward\" facing normal.\n                vec3  nrm     = h.nrm * r.side;\n                mtl_t mtl     = materials[h.mtl];\n                float ior     = cauchyN(invWavelengthUmSquared, mtl.ior);\n                float R0      = schlickR0(ior, ior_air);\n                float reflAmt = schlick  (R0, dot(r.rd, -nrm));\n                float trnsAmt = mtl.diffVsTrns * (1.0 - reflAmt);\n                float diffAmt = (1.0 - mtl.diffVsTrns) * (1.0 - reflAmt);\n\n                reflAmt *= r.amt;\n                trnsAmt *= r.amt;\n                diffAmt *= r.amt;\n\n                if (diffAmt > gMinRayAmt) {\n                    // diffuse lighting at surfaces.\n                    // cast a ray for shadows.\n                    ray_t shdRay;\n                    shdRay.ro         = h.pnt + h.nrm * gSurfEps;\n                    shdRay.rd         = gSunDir;\n                    shdRay.amt        = diffAmt;\n                    shdRay.side       = 1.0;\n                    hit_t shdHit      = newHit();\n                    \n                    float sunDot      = max(0.0, dot(gSunDir, h.nrm));\n                    \n                    rayVsScene(shdRay, shdHit);\n                    float lit = 1.0 - float(shdHit.hit);\n                    wlOut += diffAmt * lit * sunDot * tone(h, r);\n                }\n\n                // moving on to transmission and then reflection.\n\n                if (QSpaceLeft() < 2u)    continue;\n                if (rayCount >= gMaxRays) continue;\n\n                if (trnsAmt > gMinRayAmt) {\n                    float eta = ior_air / ior;\n                    if (r.side < 0.0) {\n                        eta = 1.0 / eta;\n                    }\n                    vec3 trnRayDir = refract(r.rd, nrm, eta);\n                    if (dot(trnRayDir, trnRayDir) < 0.001) {\n                        // total internal reflection.\n                        // this is theoretically impossible for a ray that entered a sphere,\n                        // but keeping it in here anyhow for more exotic scenarios.\n                        reflAmt += trnsAmt;\n                    }\n                    else {\n                        ray_t trnRay;\n                        trnRay.ro   = h.pnt - nrm * gSurfEps;\n                        trnRay.rd   = trnRayDir;\n                        trnRay.side = -r.side;\n                        trnRay.amt  = trnsAmt;\n                        QEnqueue(trnRay);\n                    }\n                }\n\n                if (reflAmt > gMinRayAmt) {\n                    ray_t rflRay;\n                    rflRay.ro   = h.pnt + nrm * gSurfEps;\n                    rflRay.rd   = reflect(r.rd, nrm);\n                    rflRay.side = r.side;\n                    rflRay.amt  = reflAmt;\n                    QEnqueue(rflRay);\n                }\n            }\n        }\n        \n        ret[wlSubIndex] = wlOut;\n    }\n    \n    return ret;\n}\n\n", "buffer_a_code": "const uint wavelengthBank = 0u;\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    RGBA = commonMain(XY, iTime, iResolution.xy, iMouse, wavelengthBank);   \n}\n", "buffer_a_inputs": [], "buffer_b_code": "const uint wavelengthBank = 1u;\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    RGBA = commonMain(XY, iTime, iResolution.xy, iMouse, wavelengthBank);   \n}\n", "buffer_b_inputs": [], "buffer_c_code": "const uint wavelengthBank = 2u;\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n#if SIXTEEN_TAPS\n    RGBA = commonMain(XY, iTime, iResolution.xy, iMouse, wavelengthBank);   \n#else\n    RGBA = vec4(0.0);\n#endif\n}\n", "buffer_c_inputs": [], "buffer_d_code": "const uint wavelengthBank = 3u;\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n#if SIXTEEN_TAPS\n    RGBA = commonMain(XY, iTime, iResolution.xy, iMouse, wavelengthBank);   \n#else\n    RGBA = vec4(0.0);\n#endif\n}\n", "buffer_d_inputs": [], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dsl3W7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[496, 496, 539, 539, 1377]], "test": "untested"}
{"id": "Dds3DM", "name": "Brushstrokes", "author": "sh1boot", "description": "Estimate direction for every pixel, blur that field of estimates, and then blur the original image in the direction of the blurred estimate.\n\nNot efficient because I just plucked this out of another, more complex project.", "tags": ["blur", "filtering", "bilateral"], "likes": 11, "viewed": 442, "published": 3, "date": "1666228635", "time_retrieved": "2024-07-30T16:25:39.690537", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float filter_len = smoothstep(-1.0, 0.0, cos(iTime * 0.7 + dot(uv, vec2(-0.3, 0.4)))) * 0.002;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec4 blurry = texture(iChannel0, uv);\n    float len = length(blurry.xy);\n    if (len < 0.0001) {\n        col = texture(iChannel1, uv).rgb;\n    } else if (any(isnan(blurry.xy))) {\n        col = vec3(0.0);\n    } else {\n        float t = atan(blurry.y, blurry.x) * 0.5;\n        vec2 dir = vec2(cos(t), sin(t)) * filter_len;\n        vec4 sum = vec4(0.0);\n        for (int i = -stroke_length; i <= stroke_length; ++i) {\n            sum += texture(iChannel1, uv + dir * float(i));\n        }\n        col = sum.rgb / float(2 * stroke_length + 1);\n#if 0   \n        if (fract(uv.y * 10.0) < 0.1) {\n            col.g = blurry.x < 0.0 ? 0.1 : 0.9;\n        } else if (fract(uv.y * 10.0) < 0.2) {\n            col.r = blurry.y < 0.0 ? 0.1 : 0.9;\n        }\n#endif\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 getPixel(vec2 uv) {\n    return textureLod(iChannel0, uv, 0.0);\n}\n\n// Simple sRGB->Y\nfloat srgb_to_y(in vec3 colour)\n{\n    return dot(vec3(0.2126, 0.7152, 0.0722), colour);\n}\n\n// Simple polynomial weighting functions.\nfloat linear_weight(in float ref, in float val, in float threshold)\n{   \n    float dist = 1.0 - (abs(ref - val) / threshold);\n    \n    return max(dist, 0.0);\n}\n\nfloat quadratic_weight(in float ref, in float val, in float threshold)\n{\n    float lw = linear_weight(ref, val, threshold);\n    return lw * lw;\n}\n\nvec2 csquare(vec2 v) {\n    return vec2(v.x * v.x - v.y * v.y, 2.0 * v.x * v.y);\n}\n\nvec4 bilat(vec2 uv)\n{\n    vec2 max_siz = vec2(24) / iResolution.xy;\n\n    // reference value at centre of filter.\n    vec4 ref = getPixel(uv);\n    float ref_intensity = srgb_to_y(ref.xyz);\n#if 1\n    vec4 sum = vec4(0);\n\n    for (int i = 0; i < estimator_taps; i++)\n    {\n        vec4 seed = vec4(1.2, 4.5, 6.7, 8.9) * float(i);\n        vec2 ofs = vec2(gaussian(uv.xyyx, seed),\n                        gaussian(uv.yxxy, seed));\n \n        // point sample and intensity.\n        vec4 spl = getPixel(uv + ofs * max_siz);\n        float spl_intensity = srgb_to_y(spl.xyz);\n\n        // Weight depends on sample distance from reference intensity.\n        const float THRESHOLD = 0.4;\n        float weight = quadratic_weight(ref_intensity, spl_intensity, THRESHOLD);\n\n        weight *= 1.0 - clamp(abs(ref.a - spl.a), 0.0, 1.0);\n        if (dot(ofs, ofs) > 0.0000001) sum.xy += normalize(csquare(ofs)) * weight;\n    }\n#else\n    vec2 cs = vec2(cos(uv.x + iTime), sin(uv.x + iTime));\n    vec2 sum = csquare(cs);\n#endif\n    return vec4(sum.xy, ref.aa);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    fragColor = vec4(bilat(uv).rgb, 1.0);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 seed2 = uv.xyyx + vec4(1.2, 4.5, 6.7, 8.9) + fract(iTime);\n    float radius = blur_radius * (0.5 - 0.5 * cos(iTime * 0.5 + dot(uv, vec2(0.4, 0.3))));\n\n    fragColor = gsample(iChannel0, uv, vec2(0.1, 0.0), radius);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 seed2 = uv.xyyx + vec4(1.2, 4.5, 6.7, 8.9) + fract(iTime);\n    float radius = blur_radius * (0.5 - 0.5 * cos(iTime * 0.5 + dot(uv, vec2(0.3, 0.4))));\n\n    fragColor = gsample(iChannel0, uv, vec2(0.0, 0.1), radius);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float blur_radius = 3.0;\nconst int blur_taps = 31;\nconst int stroke_length = 8;\nconst int estimator_taps = 64;\n\n\nfloat nrand( vec2 n ) {\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453); }\nvec2 nrand2( vec2 n ) { return vec2(nrand(n * vec2(-3.2145, 1.2345)),\n                                    nrand(n * vec2(-5.4321, 3.4521))); }\n\nfloat gaussian(vec4 seed1, vec4 seed2) {\n    return (nrand(seed1.zz + seed2.xy)\n          + nrand(seed1.ww + seed2.yz)\n          - nrand(seed1.xx + seed2.zw)\n          - nrand(seed1.yy + seed2.wx)) * 0.25;\n}\n\nfloat pdf(float x) {\n#if 0\n    // pdf for s=0.1667: `sum(uniform(-.5,.5, 3)/3)`\n    return 2.39365*exp(-18. * x * x);\n#else\n    // pdf for s=0.144: `sum(uniform(-.5,.5, 4)/4)`\n    return 2.77043 * exp(-24.1126 * x * x);\n#endif\n}\n\n\nvec4 gsample(sampler2D tex, vec2 uv, vec2 v, float radius) {\n#if 1\n    vec4 sum = vec4(0);\n    float den = 0.0;\n\n    for (int i=-blur_taps; i <= blur_taps; i++) {\n        float f = float(i) / float(blur_taps);\n        float w = pdf(f / radius);\n        vec2 ofs = v * f;\n        sum += texture(tex, uv + ofs) * w;\n        den += w;\n    }\n    return sum / den;\n#else\n    return texture(tex, uv);\n#endif\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dds3DM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1152]], "test": "untested"}
{"id": "msf3D7", "name": "Polar illusion", "author": "Zavie", "description": "Racing Pixtur who's doing the same effect in Tooll3. :)", "tags": ["illusion"], "likes": 0, "viewed": 28, "published": 3, "date": "1666221283", "time_retrieved": "2024-07-30T16:25:40.434548", "image_code": "const float pi = acos(-1.);\nconst float tau = 2. * pi;\n\nfloat hash(vec2 x)\n{\n    return fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 tunnel(vec2 uv)\n{\n    float r = length(uv);\n    float a = atan(uv.y, uv.x) / tau + 0.5;\n    return vec2(a, 1./tau/r);\n}\n\nvec4 UV2Grid(vec2 uv, vec2 gridSize)\n{\n    vec2 tileUV = fract(uv * gridSize);\n    vec2 index = floor(uv * gridSize);\n    return vec4(tileUV, index);\n}\n\nvec3 colorize(float x)\n{\n    vec3[] colors = vec3[](\n        vec3(0., 0., 0.),  // black\n        vec3(0.5, 0., 1.), // purple\n        vec3(1., 1., 1.),  // white\n        vec3(1., 0.4, 0.1) // red\n    );\n    int i1 = int(floor(x * float(colors.length())));\n    int i2 = (i1 + 1) % colors.length();\n    vec3 c1 = colors[i1];\n    vec3 c2 = colors[i2];\n    float w = fract(x * float(colors.length()));\n    float dw = 0.5*fwidth(w);\n    return mix(c1, c2, smoothstep(max(0., 0.5 - dw), min(1., 0.5 + dw), w));\n}\n\nfloat pattern(vec2 uv)\n{\n    vec2 gridResolution = vec2(32., 15.);\n    vec2 tunnelUV = tunnel(uv);\n    vec4 tunnelGrid = UV2Grid(tunnelUV, gridResolution);\n\n    return fract(pow(abs(sin(pi*tunnelGrid.y)), 0.8)-tunnelUV.x*20.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2[] ssaa = vec2[](\n        vec2(0.25, 0.5),\n        vec2(-0.5, 0.25),\n        vec2(0.5, -0.25),\n        vec2(-0.25, -0.5)\n    );\n\n    vec3 color = vec3(0.);\n    for (int i = 0; i < ssaa.length(); ++i)\n    {\n        vec2 uv = (fragCoord+ssaa[i])/iResolution.x * 2. - vec2(1., iResolution.y/iResolution.x);\n        color += colorize(pattern(uv));\n    }\n    color /= float(ssaa.length());\n\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msf3D7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 76, 76, 145], [147, 147, 169, 169, 271], [273, 273, 311, 311, 424], [934, 934, 958, 958, 1162]], "test": "untested"}
{"id": "msXGW7", "name": "Fake Bicubic sampling", "author": "fishy", "description": "Totally fake and totally cool B) I bet this could be used to make a cool bloom function", "tags": ["fake", "bicubic"], "likes": 1, "viewed": 178, "published": 3, "date": "1666211679", "time_retrieved": "2024-07-30T16:25:41.222441", "image_code": "#define MODE 0\n\nvec2 snapUV(vec2 p, float str, vec2 scale)\n{\n    p *= scale;\n    p += 0.5;\n    vec2 fp = floor(p);\n    \n    return (vec2(fp.x + smoothstep(0.0, 1.0, fract(p.x)), fp.y + smoothstep(0.0, 1.0, fract(p.y)))-0.5)/scale;\n    \n}\n\nvec4 bicubicTextureLod(sampler2D tex, vec2 uv, int lod)\n{\n    return textureLod(iChannel0, snapUV(uv, 1.4, vec2(textureSize(iChannel0, lod))), float(lod));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    int lod = 0;\n    \n    \n    uv.y *= iResolution.y/iResolution.x;\n    \n    \n    uv *= MODE == 0? sin(iTime*0.5)*0.05 + 0.3 : 0.5;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(bicubicTextureLod(iChannel0, uv, lod).rrr,1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXGW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 60, 60, 237], [239, 239, 296, 296, 396], [398, 398, 455, 505, 867]], "test": "untested"}
{"id": "ddX3DM", "name": "black vec4(0.) rgb #00000000 0", "author": "masterxilo", "description": "Arguably the darkest possible and least arbitrary shader. Even HDR does not define brightness levels lower than \"as low as it gets\". Your screen's minimum brightness might not be \"0 photons in the visible spectrum\" by far though...", "tags": ["simple", "color", "plain"], "likes": 1, "viewed": 230, "published": 3, "date": "1666208443", "time_retrieved": "2024-07-30T16:25:41.963460", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddX3DM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 85]], "test": "untested"}
{"id": "msfGDM", "name": "white vec4(1.) rgb #ffffffff 255", "author": "masterxilo", "description": "Arguably the brightest possible and least arbitrary shader. Unless HDR where possible here. This should exercise the maximum brightness your screen can deliver, though graphics card and screen/panel settings may still mess with your experience.", "tags": ["simple", "color", "plain"], "likes": 0, "viewed": 144, "published": 3, "date": "1666208322", "time_retrieved": "2024-07-30T16:25:42.737391", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msfGDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 83]], "test": "untested"}
{"id": "DsX3D7", "name": "Raymarching spehres", "author": "Aaras", "description": "Raymarching", "tags": ["raymarching", "chaos"], "likes": 3, "viewed": 180, "published": 3, "date": "1666203432", "time_retrieved": "2024-07-30T16:25:43.499353", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n#define PI 3.1415926535897932384626433832795\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST .1\n#define SUN vec3(-5.0, 10.0, -5.0)\n#define ZOOM 1.0\n#define DISTANCE 5.0\n#define EPSILON .1\n\nmat2 Rot(float a)\n{\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, -s, s, c);\n}\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\nfloat Sphere(vec3 p, vec3 o, float radius)\n{\n  return length(p - o) - radius ;\n}\nfloat Plane(vec3 p, float h)\n{\n  return p.y - h;\n}\nfloat Box(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat Cylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\nfloat Capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = dot(pa,ba)/dot(ba,ba);\n  return length( pa - ba*h ) - r;\n}\nvec3 RandomVector(float i) {\n    return normalize(vec3(sin(329.34+131.8*sin(722.1*i+8.23)),\n                            sin(494.34+2871.1*sin(431.1*i+415.39)),\n                            sin(757.34+9539.1*sin(161.1*i+201.39)))\n                );\n}\nfloat SmoothMin(float a, float b)\n{\n    float k = 3.0;\n    float h = pow( max( (k-abs(a-b))/k , 0.0), 3.0) * k / 6.0;\n    return min(a,b) - h;\n}\nfloat GetDist(vec3 p)\n{\n  float displacement = sin(5.0 * p.x) * sin(5.0 * p.y) * sin(5.0 * p.z) * 0.25;\n  p += displacement;\n  \n  float dSphere = Sphere(p, vec3(0.0, 0.0, 0.0), 2.0 + (sin(iTime*2.0) * 0.5));\n  \n  float d = dSphere;\n  \n  for(float i = 0.0; i < 3.0; i += 0.1)\n  {\n      vec3 pos = RandomVector(i) + vec3(sin(iTime+i*4.0));\n      float off = sin(iTime*5.0 + floor(i*4.0)) * 0.5 + 1.5;\n      pos *= off*2.0;\n      float dSmallSphere = Sphere(p, pos, 0.1);\n      \n      d = SmoothMin(d, dSmallSphere);\n  }\n  \n  return d;\n}\nvec2 RayMarch(vec3 ro, vec3 rd)\n{\n\n  float dO = 0.0;\n  float d;\n  float minD = 10000.0;\n  vec3 p;\n  for(int i = 0; i < MAX_STEPS; i++)\n  {\n    p = ro + rd * dO;\n    d = GetDist(p);\n    if(d < minD)\n      minD = d;\n    dO += d;\n    if(abs(dO) < SURF_DIST || dO > MAX_DIST)\n      break;\n  }\n  return vec2(dO, minD);\n\n}\nvec3 GetNormal(vec3 p)\n{\n  vec2 e = vec2(.01, .0);\n  float d = GetDist(p);\n  vec3 n = vec3(\n    d - GetDist(p - vec3(e.xyy)),\n    d - GetDist(p - vec3(e.yxy)),\n    d - GetDist(p - vec3(e.yyx))\n  );\n\n  \n  return normalize(n);\n}\n\nfloat GetShadow(vec3 p, vec3 s)\n{\n  float d = RayMarch(p, s).x;\n  float ds = length(SUN - p);\n\n  return step(EPSILON, d - ds);\n}\nfloat GetLight(vec3 p)\n{\n  if ( length(p) > MAX_DIST / 2.0 )\n    return 0.0; \n  \n  vec3 s = normalize(SUN - p);\n  vec3 n = GetNormal(p);\n\n\n  float l = dot(n, s);\n  l = clamp(l, 0.0, 1.0);\n\n  p += n * SURF_DIST * 3.0;\n  float sh = 1.0;GetShadow(p, s) + .1;\n\n\n  return l * sh;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  \n  vec3 c = vec3(0.0);\n  \n  vec3 ro = vec3(0, 4, -5);\n  ro.yz *= Rot(sin(iTime) * .1);\n  ro.xz *= Rot(sin(iTime / 2.0)*PI/ 2.0);\n  \n  vec3 rd = R(uv, ro, vec3(0,0,0), .7);\n\n\n  vec2 d = RayMarch(ro, rd);\n  vec3 p = ro + rd * d.x;\n\n\n\n  c = vec3(abs(GetLight(p) + 0.5)) / 1.5;// + GetNormal(p)) * 0.5;\n\n  //c = GetNormal(p) *  pow ( ((GetLight(p) + .2) / 1.2), 2.0);\n    c *= uv.xyx + vec3(0.5);\n  fragColor = vec4(c, 1.0);\n\n  if(d.x > MAX_DIST)\n    fragColor = vec4(0.1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsX3D7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 251, 270, 270, 340], [341, 341, 383, 383, 578], [579, 579, 623, 623, 659], [660, 660, 690, 690, 710], [711, 711, 738, 738, 825], [826, 826, 860, 860, 894], [895, 895, 945, 945, 1047], [1048, 1048, 1076, 1076, 1296], [1297, 1297, 1332, 1332, 1441], [1442, 1442, 1465, 1465, 1976], [1977, 1977, 2010, 2010, 2293], [2294, 2294, 2318, 2318, 2520], [2522, 2522, 2555, 2555, 2650], [2651, 2651, 2675, 2675, 2927], [2928, 2928, 2985, 2985, 3518]], "test": "untested"}
{"id": "msX3WN", "name": "Ghost Got Game", "author": "leon", "description": "", "tags": ["fluid"], "likes": 18, "viewed": 467, "published": 3, "date": "1666189668", "time_retrieved": "2024-07-30T16:25:44.272287", "image_code": "\n// Ghost Got Game \n//\n// weird variation of Cream Crane Consultant\n// https://www.shadertoy.com/view/ddX3WN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texture(iChannel0, uv);\n    vec3 color = vec3(0);\n    \n    // noise\n    vec3 blue = texture(iChannel1, fragCoord/1024.).xyz;\n    \n    // normal\n    vec3 unit = vec3(vec2(.01*blue.x), 0.);\n    vec3 normal = normalize(vec3(T(uv-unit.xz)-T(uv+unit.xz),\n                                 T(uv-unit.zy)-T(uv+unit.zy),\n                                 .1));\n    \n    // lighting\n    color += dot(normal, N(0,1,1))*.5+.5;\n    \n    // shadow\n    color *= ss(.0,.1,data.r);\n    \n    fragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R iResolution.xy\n#define ss(a,b,t) smoothstep(a,b,t)\n#define N(a,b,c) normalize(vec3(a,b,c))\n#define T(uv) texture(iChannel0, uv).r\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}", "buffer_a_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord-R)/R.y;\n    float a = 0.;\n    \n    // noise\n    float rng = hash13(vec3(fragCoord, iFrame));\n    \n    // normal\n    vec3 unit = vec3(vec2(.05*rng), 0.);\n    vec3 normal = normalize(vec3(T(uv-unit.xz)-T(uv+unit.xz),\n                                 T(uv-unit.zy)-T(uv+unit.zy),\n                                 .5));\n    \n    // ground collision\n    vec3 edge = (vec3(0,ss(.1,.0,uv.y),0.));\n    normal = normalize(normal+edge);\n    \n    // cursor motion\n    if (iMouse.z > 0.) {\n        p -= (2.*iMouse.xy-R)/R.y;\n    } else {\n        float time = iTime*2.;\n        float index = floor(time);\n        float anim = fract(time);\n        vec2 offset = mix(hash21(index), hash21(index+1.), anim)*2.-1.;\n        p += offset*.5*vec2(3.,1.);\n        p.y -= .4;\n        a = iTime * 10.;\n        p += vec2(cos(a),sin(a))*.05;\n    }\n    \n    // shape\n    float shade = ss(.1,.0,abs(length(p)));\n            \n    // neighboring\n    vec4 frame = texture(iChannel0, uv);\n    float life = frame.r;\n    unit = vec3(vec2(.1*rng), 0.);\n    life += T(uv-unit.xz)+T(uv+unit.xz)+T(uv-unit.zy)+T(uv+unit.zy)\n           +T(uv+unit.xy)+T(uv+vec2(unit.x,-unit.y))+T(uv+vec2(-unit.x,unit.y))+T(uv-unit.xy);\n    \n    // leaking\n    uv += life * normal.xy * .005 * dot(normal.xy, vec2(0,1));\n    \n    // ground collision\n    uv -= normal.xy * .005 * edge.y;\n    \n    // framebuffer fading\n    frame = texture(iChannel0, uv);\n    shade = frame.r - .005 + shade;\n    shade = max(shade, 0.);\n    \n    // fix ceiling stuck\n    if (fragCoord.y > R.y-1.) shade = 0.;\n\n    fragColor = vec4(shade, life, 0, 1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msX3WN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 171, 171, 730]], "test": "untested"}
{"id": "ddX3WN", "name": "Cream Crane Consultant", "author": "leon", "description": "edible fluid simulacre", "tags": ["fluid", "cream"], "likes": 16, "viewed": 440, "published": 3, "date": "1666189659", "time_retrieved": "2024-07-30T16:25:45.029263", "image_code": "\n// Cream Crane Consultant\n//\n// edible fluid simulacre\n//\n// variation of Bobby Blob Booping https://www.shadertoy.com/view/msX3W4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texture(iChannel0, uv);\n    vec3 color = vec3(0);\n    \n    // noise\n    vec3 blue = texture(iChannel1, fragCoord/1024.).xyz;\n    \n    // normal\n    vec3 unit = vec3(vec2(.01*blue.x), 0.);\n    vec3 normal = normalize(vec3(T(uv-unit.xz)-T(uv+unit.xz),\n                                 T(uv-unit.zy)-T(uv+unit.zy),\n                                 .1));\n                                 \n    // light\n    color += dot(normal, N(0,1,1))*.5+.5;\n    \n    // shadow\n    color *= ss(.0,.1,data.r);\n    \n    fragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R iResolution.xy\n#define ss(a,b,t) smoothstep(a,b,t)\n#define N(a,b,c) normalize(vec3(a,b,c))\n#define T(uv) texture(iChannel0, uv).r\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}", "buffer_a_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord-R)/R.y;\n    float a = 0.;\n    \n    // salt\n    float rng = hash13(vec3(fragCoord, iFrame));\n    \n    // normal\n    vec3 unit = vec3(vec2(.02*rng), 0.);\n    vec3 normal = normalize(vec3(T(uv-unit.xz)-T(uv+unit.xz),\n                                 T(uv-unit.zy)-T(uv+unit.zy),\n                                 .001));\n    \n    // ground collision\n    vec3 edge = (vec3(0,ss(.2,.0,uv.y),0.));\n    normal = normalize(normal+edge);\n    \n    // cursor motion\n    if (iMouse.z > 0.) {\n        p -= (2.*iMouse.xy-R)/R.y;\n    } else {\n        float time = iTime*1.5;\n        float index = floor(time);\n        float anim = fract(time);\n        vec2 offset = mix(hash21(index), hash21(index+1.), anim)*2.-1.;\n        p += offset*.5*vec2(2.,1.);\n        p.y -= .4;\n        a = iTime * 10.;\n        p += vec2(cos(a),sin(a))*.1;\n    }\n    \n    // shape\n    float shade = ss(.1,.0,abs(length(p)));\n                \n    // neighboring\n    vec4 frame = texture(iChannel0, uv);\n    float life = frame.r;\n    unit = vec3(vec2(.1*rng), 0.);\n    life += T(uv-unit.xz)+T(uv+unit.xz)+T(uv-unit.zy)+T(uv+unit.zy)\n           +T(uv+unit.xy)+T(uv+vec2(unit.x,-unit.y))+T(uv+vec2(-unit.x,unit.y))+T(uv-unit.xy);\n    \n    // gravity\n    uv.y += .001 * life;\n    \n    // leaking\n    uv += normal.xy * .001 * dot(normal.xy, vec2(0,1));\n    \n    // ground collision\n    uv -= normal.xy * .005 * edge.y;\n    \n    // famebuffer fading\n    frame = texture(iChannel0, uv);\n    shade = frame.r - .001 + shade;\n    shade = max(shade, 0.);\n    \n    // fix ceiling stuck\n    if (fragCoord.y > R.y-1.) shade = 0.;\n    \n    fragColor = vec4(shade, 0, 0, 1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddX3WN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 190, 190, 775]], "test": "untested"}
{"id": "msX3W4", "name": "Bobby Blob Booping", "author": "leon", "description": "another day another blob", "tags": ["fluid", "blob"], "likes": 18, "viewed": 419, "published": 3, "date": "1666189650", "time_retrieved": "2024-07-30T16:25:45.805188", "image_code": "\n// Bobby Blob Booping\n// another day another blob\n//\n// looks like the iconic 'expansive reaction-diffusion' by Flexi\n// https://www.shadertoy.com/view/4dcGW2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0.);\n    \n    // grayscale\n    vec4 data = texture(iChannel0, uv);\n    \n    // noise\n    vec3 blue = texture(iChannel1, fragCoord/1024.).xyz;\n    \n    // normal\n    vec3 unit = vec3(vec2(.005*blue.x), 0.);\n    vec3 normal = normalize(vec3(T(uv-unit.xz)-T(uv+unit.xz),\n                                 T(uv-unit.zy)-T(uv+unit.zy),\n                                 T(uv)*.1));\n\n    // lighting\n    color += dot(normal, N(0,1,1))*.5+.5;\n    \n    // shadow\n    color *= ss(.0,.2,data.r);\n    \n    fragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R iResolution.xy\n#define ss(a,b,t) smoothstep(a,b,t)\n#define N(a,b,c) normalize(vec3(a,b,c))\n#define T(uv) texture(iChannel0, uv).r\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}", "buffer_a_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord-R)/R.y;\n    float a;\n    vec3 unit;\n    \n    // noise\n    float rng = hash13(vec3(fragCoord, iFrame));\n    \n    // motion\n    float time = iTime*2.5;\n    float index = floor(time);\n    float anim = fract(time);\n    vec2 offset = mix(hash21(index), hash21(index+1.), anim)*2.-1.;\n    if (iMouse.z > 0.) p -= (2.*iMouse.xy-R)/R.y;\n    else p += offset*.6;\n    \n    // shape\n    float shade = ss(.05,.0,(length(p)-.01));\n                                 \n    // neighboring\n    vec4 frame = texture(iChannel0, uv);\n    float life = frame.r;\n    unit = vec3(vec2(.1*rng), 0.);\n    life += T(uv-unit.xz)+T(uv+unit.xz)+T(uv-unit.zy)+T(uv+unit.zy)\n           +T(uv+unit.xy)+T(uv+vec2(unit.x,-unit.y))+T(uv+vec2(-unit.x,unit.y))+T(uv-unit.xy);\n    \n    // gravity\n    uv.y += .002 * life;\n    \n    // normal\n    unit = vec3(vec2(.01*rng), 0.);\n    vec3 normal = normalize(vec3(T(uv-unit.xz)-T(uv+unit.xz),\n                                 T(uv-unit.zy)-T(uv+unit.zy),\n                                 .5));\n                                 \n    // animated growth\n    uv -= normal.xy * .04 * sin(life*3.14*2.+iTime*2.);\n    \n    // famebuffer fading\n    frame = texture(iChannel0, uv);\n    shade = frame.r - .0001 + shade;\n    shade = clamp(shade, 0., 1.);\n\n    fragColor = vec4(shade, 0, 0, 1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msX3W4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 218, 218, 803]], "test": "untested"}
{"id": "DdsGWN", "name": "Fractal mosaic 23 (music)", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 4, "viewed": 218, "published": 3, "date": "1666159450", "time_retrieved": "2024-07-30T16:25:46.564159", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    \n    a1 = a-a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.*8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    bool t3 = true;\n    for(int k = 0; k < 9; k++){\n        t3 = uv.y > uv.x || !t3;\n        uv =\n            abs(.5+uv+t2*fmod(uv.x+t2.x,2.))  \n        ;\n        t2 =\n            -triangle_wave(uv-.5)\n        ;\n        uv = t2-triangle_wave(uv.yx);\n        float c1 =\n            (uv.x-uv.y)\n        ;\n        col = col.yzx;\n        vec3 col1 = col;\n        if(t3) col1 = abs(col.yzx-vec3(col.yz,c1));\n        if(!t3 || uv.y < uv.x) col1 = abs(col1-max(col,vec3(col.yz,c1)));\n        col = col1;\n    }\n    fragColor = vec4(min(col*2.,vec3(1.)),1.0);\n}\n", "image_inputs": [], "sound_code": "vec2 mainSound(int samp, float time){\n  float tempo = 1.;\n  time /= tempo;\n  float m4 =\n      fmod(time*8.,2.)\n      //fmod(floor(time*2.)*floor(time*2.)/4.,2.)\n  ,\n  t=\n      time/(1.+m4)\n  ,\n  m1 =\n      fmod(t,8.)\n  ,\n  m3 =\n      fmod(t/(m1+.5),8./(1.+fmod(t*8.,2.)));\n      //fmod(t/(m1+.5),8./(1.+fmod(t*8.*floor(t),2.)))\n  ;\n  \n  //t /= (1.+fmod(floor(t*2.+1.)*floor(t+1.),2.))/(1.+fmod(floor(t*2.)*floor(t*4.+1.),2.));\n\n  float a = 64.*sqrt((1.-sqrt(fract(t))))*.2,\n  \n  nb = time*tempo*pow(2.,(m3+m1+1.)/5.+6.5);\n\n  return abs(.5-vec2(fract(nb*.998)\n   ,fract(nb)))*a;\n\n}", "sound_inputs": [], "common_code": "#define fmod(x,y) mod(floor(x),y)\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdsGWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 134], [136, 136, 193, 193, 1027]], "test": "untested"}
{"id": "styGzh", "name": "Space Bubbles", "author": "Plento", "description": "stuff", "tags": ["3d", "raymarch", "glass", "bubble"], "likes": 16, "viewed": 364, "published": 3, "date": "1666147008", "time_retrieved": "2024-07-30T16:25:47.321135", "image_code": "#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define A(p) texture(iChannel0, p).x\nmat2 rot(float a) {return mat2(cos(a), -sin(a), sin(a), cos(a));}\n\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat rbox( vec3 p, vec3 b, float r ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat sub( float d1, float d2 ) { return max(-d1,d2); }\n#define b vec3(1.2)\n\n\nvec3 getCell(vec3 p){return floor(p / b);}\nvec3 getCellCoord(vec3 p){return mod(p, b) - b*.5;}\n\n\nfloat map(vec3 p){\n    float d = 999.;\n  \n    vec3 id = getCell(p);\n    vec3 rup = getCellCoord(p);\n    float rnd = 2.*hash13(id*663.) - 1.;\n    \n    rup.y += rnd*.2;\n    \n    rup.xz *= rot(rnd*.3 + .3*iTime*sign(rnd) + id.x);\n    rup.xy *= rot(rnd*.3 + .3*iTime*sign(rnd) + id.y);\n    \n    rup.x+=cos(rup.z*30.)*.02;\n    rup.y+=sin(rup.z*30.)*.02;\n    d = min(length(rup)-.45, d);\n\n    d = sub(rbox(p-vec3(0., iTime*.55, 0.), vec3(2.4), .01), d );\n\n    return d;\n}\n\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nvec3 color(vec3 ro, vec3 rd, vec3 n, float t){\n    vec3 p = ro + rd*t;\n    \n    vec3 lp = ro + vec3(0., 0., 2.5);\n    \n    vec3 ld = normalize(lp-p);\n    float dd = length(p - lp);\n    float dif = max(dot(n, ld), .1);\n    float fal = max(1. / (dd), .0);\n    float spec = pow(max(dot( reflect(-ld, n), -rd), 0.), 23.);\n\n    vec3 objCol = vec3(1);\n     \n    objCol += spec * .75;\n    objCol *= (dif + .4);\n    objCol *= fal;\n    \n    return objCol;\n}\n\n\n#define FAR 10.\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n        \n    vec3 rd = normalize(vec3(uv, 1.5));    \n    rd = normalize(vec3(uv, 2.0 - dot(uv, uv) * -0.3));\n    vec3 ro = vec3(0);\n    \n    \n    if(abs(uv.x) > .75){f = vec4(0,0,0,1); return;} // Thanks elenzil\n    \n    rd.xz*=rot(.8);\n    ro.y += iTime*.55;\n    \n    float d = 0.0, t = 0., ns = 0.;\n    vec3 p, n, col = vec3(0);\n    \n    int nHits = 0;\n    int maxHits = 3;\n    \n    for(int i = 0; i < 80; i++){\n    \td = map(ro + rd*t); \n        \n        if(nHits >= maxHits || t > FAR)break;\n  \n        if(abs(d) < 0.004){\n           \n            p = ro + rd*t;\n            n = normal(p);\n            \n            if(d > 0. && nHits == 0){\n                rd = refract(rd, n, 1.02);\n                vec3 ref = reflect(n, rd);\n                col += texture(iChannel0, ref).xyz*.4;\n                col.zxy += abs(ref)*.1;\n            }\n            col += color(ro, rd, n, t);\n            \n            nHits++;\n            t += .2;\n        }\n\n        t += abs(d) * .7;\n        \n        ns++;\n    }\n    \n    if(nHits > 0)col /= float(nHits)*.6;\n    \n    col *= ss(10., 4., ns*.1);\n    col = pow(col*1.4, vec3(2.4));\n    col = 1.-exp(-col);\n    col += .12*hash12(u*42. + 32. + iTime);\n    \n    \n    f = vec4(col, 1.0);\n}\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/styGzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 179, 179, 225], [227, 227, 249, 249, 352], [354, 354, 375, 375, 492], [495, 495, 533, 533, 624], [625, 625, 658, 658, 680], [703, 703, 724, 724, 745], [746, 746, 772, 772, 797], [800, 800, 818, 818, 1265], [1268, 1268, 1295, 1295, 1496], [1498, 1498, 1544, 1544, 1946], [1966, 1966, 2006, 2006, 3267]], "test": "untested"}
{"id": "DdX3WN", "name": "3 Tangent Circles", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 16, "viewed": 331, "published": 3, "date": "1666117100", "time_retrieved": "2024-07-30T16:25:48.078111", "image_code": "// Maths and stuff:\n// http://jwilson.coe.uga.edu/EMAT6680Su06/Swanagan/Assignment7/BSAssignment7.html\n\n#define pi 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = (fragCoord - 0.5 * res) / res.y;\n    \n    float k = 1. / res.y;\n    \n    // first 2 circles\n    vec2 p1 = vec2(0.1, 0.1 * cos(0.5 * iTime));\n    vec2 p2 = vec2(-0.3, 0.1 * sin(0.5 * iTime));\n    float l = length(p1 - p2);\n    float r1 = (0.3 + 0.2 * cos(iTime)) * l;\n    float r2 = (0.3 + 0.2 * sin(iTime)) * l;\n    \n    float d1 = length(uv - p1);\n    float d2 = length(uv - p2);\n    float s1 = exp(-40. * abs(d1-r1)); //smoothstep(-k, k, 2. * k - abs(d1 - r1));\n    float s2 = exp(-40. * abs(d2-r2)); //smoothstep(-k, k, 2. * k - abs(d2 - r2));\n     \n    // angle from p2 circle where p3 circle is tangent\n    float a = atan(p2.y - p1.y, p2.x - p1.x) + pi * cos(0.25 * iTime);\n    \n    // maths and stuff\n    vec2 e = p2 - r2 * vec2(cos(a), sin(a));\n    vec2 f = e  + r1 * vec2(cos(a), sin(a));\n    vec2 g = 0.5 * (f + p1);\n    \n    // intersect 2 lines to find 3rd point\n    float v1 = (f.y - p1.y) / (f.x - p1.x);\n    float v2 = (f.y - p2.y) / (f.x - p2.x);\n    vec2 p3;\n    p3.x = (g.x + v1 * v2 * f.x + v1 * (g.y - f.y)) / (v1 * v2 + 1.);\n    p3.y = v2 * (p3.x - f.x) + f.y;\n        \n    // 3rd circle\n    float r3 = length(p3 - e);\n    float d3 = length(uv - p3);\n    float s3 = exp(-40. * abs(d3-r3)); //smoothstep(-k, k, 2. * k - abs(d3 - r3));\n    \n    vec3 col = vec3(0.2,0.6,0.95) * vec3(s1 + s2 + s3);\n    col += 0.08;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdX3WN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 181, 181, 1591]], "test": "untested"}
{"id": "csf3D4", "name": "Space Rainbow Road", "author": "rcargou", "description": "Huge credit to sonicether his bloom implementation that is essential for this shader: https://www.shadertoy.com/view/lstSRS\nWould be glad to get some feedback if you have some bug or about how I can improve this shader :)\n", "tags": ["sdf", "road", "bloom", "stars", "rainbow"], "likes": 82, "viewed": 2520, "published": 3, "date": "1666112954", "time_retrieved": "2024-07-30T16:25:49.109354", "image_code": "\nvec4 cubic(float x)\n{\n    float x2 = x * x;\n    float x3 = x2 * x;\n    vec4 w;\n    w.x =   -x3 + 3.0*x2 - 3.0*x + 1.0;\n    w.y =  3.0*x3 - 6.0*x2       + 4.0;\n    w.z = -3.0*x3 + 3.0*x2 + 3.0*x + 1.0;\n    w.w =  x3;\n    return w / 6.0;\n}\n\nvec4 BicubicTexture(in sampler2D tex, in vec2 coord)\n{\n\tvec2 resolution = iResolution.xy;\n\n\tcoord *= resolution;\n\n\tfloat fx = fract(coord.x);\n    float fy = fract(coord.y);\n    coord.x -= fx;\n    coord.y -= fy;\n\n    fx -= 0.5;\n    fy -= 0.5;\n\n    vec4 xcubic = cubic(fx);\n    vec4 ycubic = cubic(fy);\n\n    vec4 c = vec4(coord.x - 0.5, coord.x + 1.5, coord.y - 0.5, coord.y + 1.5);\n    vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x + ycubic.y, ycubic.z + ycubic.w);\n    vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) / s;\n\n    vec4 sample0 = texture(tex, vec2(offset.x, offset.z) / resolution);\n    vec4 sample1 = texture(tex, vec2(offset.y, offset.z) / resolution);\n    vec4 sample2 = texture(tex, vec2(offset.x, offset.w) / resolution);\n    vec4 sample3 = texture(tex, vec2(offset.y, offset.w) / resolution);\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix( mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 BloomFetch(vec2 coord)\n{\n \treturn BicubicTexture(iChannel3, coord).rgb;   \n}\n\nvec3 Grab(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord /= scale;\n    coord -= offset;\n\n    return BloomFetch(coord);\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvec3 GetBloom(vec2 coord)\n{\n \tvec3 bloom = vec3(0.0);\n    \n    //Reconstruct bloom from multiple blurred images\n    bloom += Grab(coord, 1.0, vec2(CalcOffset(0.0))) * 1.0;\n    bloom += Grab(coord, 2.0, vec2(CalcOffset(1.0))) * 1.5;\n\tbloom += Grab(coord, 3.0, vec2(CalcOffset(2.0))) * 1.0;\n    bloom += Grab(coord, 4.0, vec2(CalcOffset(3.0))) * 1.5;\n    bloom += Grab(coord, 5.0, vec2(CalcOffset(4.0))) * 1.8;\n    bloom += Grab(coord, 6.0, vec2(CalcOffset(5.0))) * 1.0;\n    bloom += Grab(coord, 7.0, vec2(CalcOffset(6.0))) * 1.0;\n    bloom += Grab(coord, 8.0, vec2(CalcOffset(7.0))) * 1.0;\n\n\treturn bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = ColorFetch(uv);\n    \n    \n    color += GetBloom(uv) * 0.12;\n    \n    color *= 2.0;\n    \n\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = saturate(color * 1.01);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n\n    fragColor = vec4(color, 1.0);\n   // fragColor = texture(iChannel1, uv) * 10111.;\n\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "mat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvec2 hash22( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(175.1,311.7)),\n             dot(p,vec2(260.5,752.3)));\n    return fract(sin(p+455.)*18.5453);\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n\n\nfloat sdCross(vec2 p) {\n    p *= 2.;\n    vec2 p2 = vec2(p.y, p.x);\n    p2.y = abs(p2.y);\n    p2.y -=.0;\n    p.y = abs(p.y);\n    p.y-=.0;\n\n\tvec2 v1 = vec2(-.5, 0.);\n\tvec2 v2 = vec2(.5, 0.);\n\tvec2 v3 = vec2(0., 1.5);\n    float sd1= sdTriangle(p, v1, v2, v3);\n    float sd2 = sdTriangle(p2, v1, v2, v3);\n    return min(sd1, sd2);\n\n}\n\n \nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat sdStar(vec2 p) {\n    float d1 = sdCross(p);\n    float d2 = sdCross(rotate2d(3.14 / 4.) * p  );\n    return min(d1, d2);\n}\n\n\nfloat opExtrusion( in vec3 p, in float h )\n{\n    float d = sdStar(p.xy);\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}", "buffer_a_code": "float c1() {\n    return (1. + clamp(-.2, .2, sin(iTime / 5.) ));\n}\n\nfloat c2() {\n    return 0.;\n    return .1*clamp(.0, 1., clamp(-.2, .2, sin(iTime / 3. + .7) ));\n}\n\nfloat hash31(vec3 p) {\n   \tfloat h = dot(p,vec3(127.1,311.7, 21.));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat hash21( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n    \n}\n \nvec3 HUEtoRGB(in float hue)\n{\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\n\nfloat path(float t) {\n    return 0.1;\n}\n\nfloat multiwave(float path) {\n    path /= 3.;\n    return 10.*(2. * sin(path / 20.) + \n            1./4. * sin(path / 4.) +\n            1./4. * sin(path / 4.));\n}\nfloat dmultiwave(float path) {\n    path /= 3.;\n    return (2. * cos(path / 20.) + \n            1./4. * cos(path / 4.) +\n            1./4. * cos(path / 4.));\n}\n\nfloat opS( in float d1, in float d2 )\n{\n    d1 *= -1.0;\n    return (d1 > d2) ? d1 : d2;\n}\n\n\nvec3 archCOL(vec3 p ) {\n    float rep = 52.;\n    float size = 11.;\n    float in_size = 7.8;\n    float l = 25.5;\n    p.y += multiwave(p.z);\n    float id = floor(p.z / rep);\n    p.z = mod(p.z, rep) - rep / 2.;\n    p.z-=20.;\n    float outer = length(p.xy) - size;\n    float iner = length(p.xy) - size + .5;\n    float d = opS(iner, outer);\n    \n    float dist = max(d, abs( p.z - l) );\n    vec3 c =  HUEtoRGB(hash31(vec3(id)));\n    c /= 4.;\n    c+= .3;\n    return c;\n}\n \nfloat mapStarField(vec3 p, out vec2 id) {\n\n    float r = c1();\n    vec3 rep = vec3(20.);\n    float scale = 1.;\n    p.yz = rotate2d(3.14 / -2.) * p.yz;\n    float t = iTime * 150.;\n    p /= scale;\n    p.y += t;\n    float d = p.z;\n    vec3 pm = mod(p, rep) - rep / 2.;\n    id.x = hash31(floor(p / rep));\n \n    if (id.x * r < 1.1) {\n        return rep.z / 2.;\n    }\n    pm.xz = rotate2d( 42.*iTime *id.x) * pm.xz;\n    id.x = fract(id.x *112.131);\n    id.y = 1.;\n   // id.x = .2;\n    return opExtrusion(pm  / 2., .05);\n}\n\nfloat mapArch(vec3 p) {\n    float rep = 52.;\n    float size = 11.;\n    float in_size = 7.8;\n    float l = -25.5;\n    p.y += multiwave(p.z);\n    p.z = mod(p.z, rep) - rep / 2.;\n    p.z-=20.;\n    float outer = length(p.xy) - size;\n    float iner = length(p.xy) - size + .5;\n    float d = opS(iner, outer);\n    \n    return max(d, abs( p.z - l) );\n}\n\nfloat mapFence(vec3 p) {\n    float rep = 2.;\n    float height = .4;// + (1.+ sin(p.z / 4.)) / 1.;\n    float size = .1 ;\n    \n    p.y += multiwave(p.z);\n    p.z = mod(p.z, rep) - rep / 2.;\n    p.x = abs(p.x) - 8.;\n    float dt = length(vec2(p.x, p.y -.76 - height + 4.0*size)) - size / 2.;\n        \n    vec3 pstar = vec3(p.z, p.y, p.x);\n    float dstar = opExtrusion(pstar, .01);\n    float df = abs(max(length( p.xz - size), -.1+abs(p.y +.8) - height));\n    return min(dt, dstar);\n    \n}\n\nfloat mapRoad(vec3 p, out vec2 id) {\n \n    \n    vec2 rep = vec2(1, 1.);\n    \n    vec2 mp = mod(p.xz, rep) - rep / 2.;\n    \n    float s = .35;\n    id.x = fract( ((+ p.z/rep.y)*0.323 + (p.x / rep.x )) *.0379523 );\n   \n    id.y = hash21( floor(p.xz / rep.xy ) * 10. );\n    if (id.y < 0.02)\n     id.x = fract( (floor(+ p.z/rep.y) *0.323+ floor(p.x / rep.x )) *0.0379523 );\n    float l = iTime* 2. * hash21( floor(p.xz / rep)  );\n    \n     p.y -= .3 + sin(l ) * .0;\n     float h =  p.y + 2. + multiwave(p.z) + cos(sin(p.z *c2()*.02  + iTime * c2() * .5) + p.x / 3.);\n   \n    return max( max(max(mp.x -s , mp.y - s ) , abs(p.x) - 8. ), abs( h )  - .05);\n}\n\nvec2 map(vec3 p, out vec2 id) {\n    vec2 id2;\n    vec3 ps = p;\n    p.x+=sin(p.z / 15.)*2. + cos(p.z / 20.) + sin(p.z / 200.) * 200.;\n    vec2 res =  vec2(mapRoad(p, id), 1.);\n    \n    vec2 resFence = vec2(mapFence(p), 2. );\n    if (resFence.x < res.x) {\n        res = resFence;\n    }\n    vec2 resArch = vec2(mapArch(p), 3.);\n    if (resArch.x < res.x) {\n        res = resArch;\n    }\n    vec2 resStar = vec2(mapStarField(ps, id2), 4.);\n    if (resStar.x < res.x) {\n        res = resStar;\n        id = id2;\n    }\n    return res;\n}\n\nvec2 castRay(vec3 ro, vec3 rd, out vec2 id) {\n    vec2 res = vec2(1e10, 0.);\n    vec3 pos = ro;\n\n    const float NEAR = 0.;\n    const float FAR = 220.;\n\n    float t = NEAR;\n    \n    for (int i = 0; i < 300 && t < FAR; ++i) {\n    \n        pos = ro + rd * t;\n        vec2 h = map(pos, id);\n        if (abs(h.x) < 0.001 * t) {\n            res = vec2(t, h.y);\n            break ;\n        }\n        t += t < 10. ? h.x * .5: h.x;\n    }\n    \n    return res;\n}\n\n\nvec3 normal (in vec3 p)\n{\n    vec2 e = vec2(.0001, .0);\n    vec2 id;\n    float d = map (p,id).x;\n    vec3 n = vec3 (map (p + e.xyy,id).x - d,\n                   map (p + e.yxy,id).x - d,\n                   map (p + e.yyx,id).x - d);\n    return normalize(n);\n}\n\nvec3 raymarch_arch(vec3 ro, vec3 rd) {\n    float t = 0.;\n    vec3 acc = vec3(0.);\n\n    for (int i = 0; i < 40; ++i) {\n        vec3 pos = ro + rd * t;\n         float dLight = .03+21.5/(10.+ length(mod(pos.zzz, 52.) -20.))*0.5;\n        acc += dLight * archCOL(pos) / 50.;\n    }\n    return vec3(acc);\n}\n\nfloat stars(vec2 uv) {\n\n    float acc = 0.;\n    float s = 0.1;\n    float scale = 100.;\n    for (float i = 0.; i < 3.; i = i + 1.) {\n        for (float j = 0.; j < 3.; j = j + 1.) {\n            vec2 off = vec2( (j - 2.) * s, (i - 2.) * s);  \n            acc += ( smoothstep( .92, 1.0, pow( noise(vec3( uv.x * scale + off.x, uv.y * scale + off.y, 0.)),3. )));\n        }\n    }\n    return acc / 20.;\n}\n\nvec3 render(vec3 ro, vec3 rd, vec2 uv) {\n\n    vec2 id;\n    vec2 res = castRay(ro, rd, id);\n    vec3 pos = ro + rd * res.x;\n    float mat = res.y;\n    float depth = length(pos - ro);\n    vec3 albedo = vec3(20.);\n    vec3 nor = normal(pos);\n    vec3 lightDir = normalize( vec3(-2., 1., -0.));\n    float ndotl = max(.4, dot(nor, lightDir));\n   // vec3 stars = vec3( smoothstep( .9, 1.0, pow( noise(vec3( uv.x * 100., rd.y * 100., 0.)),3. )));\n        vec3 stars = vec3(stars(vec2(uv.x, rd.y)));\n    float dLight = .03+21.5/(5.+ length(mod(pos.zzz, 52.) -20.))*0.5;\n     vec3 dLightCol = archCOL(pos);\n    if (mat == 0.) {\n        return stars;\n    }\n    if (mat == 1. || mat == 4.) {\n        albedo = 4.* HUEtoRGB(id.x);// * (texture(iChannel1, pos.xz * 11.).x * 3. + .1);\n        if (id.y < 0.02)\n        albedo *= 32.;\n        if (mat == 4.)\n        albedo *= 12.;\n     }\n    if (mat == 2.) {\n        albedo = vec3(0.5, 0.5, 0.2) * 20.;\n    }\n    float f = 1. / (1. +pow(depth * .0015 , 2.));\n\n    vec3 r = raymarch_arch(ro, rd);\n    float m = clamp(0., 1., 1.7 - f);\n    return vec3(mix(dLightCol*dLight*albedo *ndotl + albedo / 30., stars  * 4., .8));\n}\n\nvoid camera(out vec3 ro, out vec3 rd, vec2 uv) {\n    vec2 mouse = (-iResolution.xy + 2.0*iMouse.xy)/iResolution.y;\n    float speed = iTime * 15.;\n    ro = vec3( + sin(speed / 200.) * 200., 3.0 + multiwave(speed), -speed);\n    mouse = vec2(0.);\n    mouse.y += 3.;\n    vec3 lookAt = vec3(sin(speed / 200. - 0.5 / 200.) * 200. + mouse.x + uv.x, mouse.y + -uv.y + multiwave(speed)- dmultiwave(speed)*.2, 1.-speed - c1() * 0.);\n    \n    rd = normalize(ro - lookAt);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    vec3 ro, rd;\n    camera(ro, rd, uv);\n    vec3 col = pow( render(ro, rd, uv)*1.6, vec3(1.0));\n    fragColor = vec4(col * 1.,1.0);\n}", "buffer_a_inputs": [{"id": 29988, "src": "https://soundcloud.com/extra_shard/mario-kart-wii-rainbow-road", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "//First bloom pass, mipmap tree thing\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 Grab1(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = ColorFetch(coord);\n\n    return color;\n}\n\nvec3 Grab4(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 4;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab8(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 8;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab16(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 16;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    vec3 color = vec3(0.0);\n    \n    /*\n    Create a mipmap tree thingy with padding to prevent leaking bloom\n   \t\n\tSince there's no mipmaps for the previous buffer and the reduction process has to be done in one pass,\n    oversampling is required for a proper result\n\t*/\n    color += Grab1(uv, 1.0, vec2(0.0,  0.0)   );\n    color += Grab4(uv, 2.0, vec2(CalcOffset(1.0))   );\n    color += Grab8(uv, 3.0, vec2(CalcOffset(2.0))   );\n    color += Grab16(uv, 4.0, vec2(CalcOffset(3.0))   );\n    color += Grab16(uv, 5.0, vec2(CalcOffset(4.0))   );\n    color += Grab16(uv, 6.0, vec2(CalcOffset(5.0))   );\n    color += Grab16(uv, 7.0, vec2(CalcOffset(6.0))   );\n    color += Grab16(uv, 8.0, vec2(CalcOffset(7.0))   );\n\n\n    fragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Horizontal gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 1.12)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\n            color += ColorFetch(uv + offset * vec2(0.5, 0.0)) * weights[i];\n            color += ColorFetch(uv - offset * vec2(0.5, 0.0)) * weights[i];\n            weightSum += weights[i] * 2.0;\n        }\n\n        color /= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//Vertical gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 0.52)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\n            color += ColorFetch(uv + offset * vec2(0.0, 0.5)) * weights[i];\n            color += ColorFetch(uv - offset * vec2(0.0, 0.5)) * weights[i];\n            weightSum += weights[i] * 2.0;\n        }\n\n        color /= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csf3D4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 238], [240, 240, 294, 294, 1231], [1233, 1233, 1262, 1262, 1307], [1309, 1309, 1338, 1338, 1390], [1392, 1392, 1454, 1454, 1563], [1565, 1565, 1596, 1596, 1902], [1904, 1904, 1931, 1931, 2510], [2512, 2512, 2569, 2569, 3174]], "test": "untested"}
{"id": "dslGW8", "name": "Fluid Flood Flavor", "author": "leon", "description": "another fluid simulacre", "tags": ["water", "fluid", "flood"], "likes": 66, "viewed": 1396, "published": 3, "date": "1666086517", "time_retrieved": "2024-07-30T16:25:49.870319", "image_code": "\n// Fluid Flood Flavor\n//\n// variation of \"Fire Fighter Fever\" https://shadertoy.com/view/msf3WH\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // normal\n    float rng = hash13(vec3(fragCoord, iFrame));\n    vec3 unit = vec3(vec2(.001), 0.);\n    vec3 normal = normalize(vec3(T(uv-unit.xz)-T(uv+unit.xz),\n                                 T(uv-unit.zy)-T(uv+unit.zy),\n                                 .0001));\n    \n    // distort\n    fragColor = texture(iChannel1, uv+.1*normal.xy);\n    \n    // debug art\n    if (iMouse.z > 0. && iMouse.x/R.x < .2)\n    {\n        vec4 data = texture(iChannel0, uv);\n        if (uv.x > .66) fragColor = vec4(normal*.5+.5, 1);\n        else if (uv.x > .33) fragColor = vec4(vec3(sin(data.r*6.28*2.)*.5+.5), 1);\n        else fragColor = vec4(data.yz*.5+.5,.5, 1);\n    }\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R iResolution.xy\n#define ss(a,b,t) smoothstep(a,b,t)\n#define N normalize\n#define T(uv) texture(iChannel0, uv).r\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Martijn Steinrucken youtube.com/watch?v=b0AayhCO7s8\nfloat gyroid (vec3 seed)\n{\n    return dot(sin(seed),cos(seed.yzx));\n}", "buffer_a_code": "\n\n/////////// spicy noise\nfloat fbm (vec3 seed)\n{\n    // thebookofshaders.com/13\n    float result = 0.;\n    float a = .5;\n    for (int i = 0; i < 4; ++i)\n    {\n        // distort\n        seed += result / 2.;\n        \n        // animate\n        seed.y -= .1*iTime/a;\n        \n        // accumulate\n        result += gyroid(seed/a)*a;\n        \n        // granule\n        a /= 3.;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    /////////// coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord-R)/R.y;\n    \n    // salt\n    float rng = hash13(vec3(fragCoord, iFrame));\n    \n    // noise\n    vec3 seed = vec3(p * vec2(1,.2), length(p) + iTime) * 2.;\n    float noise = fbm(seed);\n    float a = noise * 3.14;\n    \n    // normal\n    vec3 unit = vec3(vec2(.005), 0.);\n    vec3 normal = normalize(vec3(T(uv-unit.xz)-T(uv+unit.xz),\n                                 T(uv-unit.zy)-T(uv+unit.zy),\n                                 unit.y));\n    \n    // mouse\n    vec2 mouse = iMouse.xy/R;\n    float clic = step(0., iMouse.z);\n    \n    \n    ////////// shape\n    float shape = 1.;\n    \n    // bottom line\n    shape *= ss(.01,.0,1.-uv.y);\n    \n    // wave\n    shape *= ss(.5,.6,sin(iTime*3.));\n    \n    // salt\n    shape *= pow(rng, 4.);\n    \n    \n    \n    ////////// forces field\n    vec2 offset = vec2(0);\n            \n    // turbulence                     \n    offset -= vec2(cos(a),sin(a)) * fbm(seed+.195);\n\n    // slope\n    offset -= normal.xy * .5;\n    \n    // gravity\n    offset += vec2(0,1);\n    \n    // obstacle\n    offset *= texture(iChannel1, uv).r;\n    \n    // mouse\n    vec2 velocity = vec2(0);\n    p -= (2.*iMouse.xy-R)/R.y;\n    float mouseArea = ss(.3,.0,length(p)-.1);\n    offset -= clic * normalize(p) * mouseArea;\n    velocity += (texture(iChannel0, vec2(0)).yz - mouse);\n    if (length(velocity) > .001) velocity = clic * normalize(velocity) * mouseArea;\n    \n    // inertia\n    velocity = clamp(texture(iChannel0, uv).yz * .99 + velocity * .5,-1.,1.);\n    \n    // inertia\n    offset += velocity;\n    \n    // apply\n    uv += .01 * offset;\n    \n    \n    \n    ////////// frame buffer\n    vec4 frame = texture(iChannel0, uv);\n    \n    // fade out\n    float fade = iTimeDelta*.2;\n    shape = max(shape, frame.r - fade);\n    \n    // result\n    shape = clamp(shape, 0., 1.);\n    fragColor = vec4(shape, velocity, 1);\n    \n    // previous mouse\n    if (fragCoord.x < 1. && fragCoord.y < 1.) fragColor = vec4(0,mouse,1);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dslGW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 155, 155, 858]], "test": "untested"}
{"id": "msl3W8", "name": "FFT (Fire For Techno)", "author": "leon", "description": "audio reactive fluid simulacre.\nyou may have to clic on pause/play on iChannel1 audio input in Buffer A for the music to start playing", "tags": ["fft", "fire", "fluid", "smoke"], "likes": 42, "viewed": 1219, "published": 3, "date": "1666086473", "time_retrieved": "2024-07-30T16:25:50.724037", "image_code": "\n// FFT (Fire For Techno)\n// audio reactive fluid simulacre\n//\n// variation of \"Fire Fighter Fever\" https://shadertoy.com/view/msf3WH\n//\n// inspired by recent fft simulation by Etienne Jacob\n// https://twitter.com/etiennejcb/status/1581307953511964672\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n                                 \n    // grayscale\n    vec4 data = texture(iChannel0, uv);\n    \n    // Inigo Quilez iquilezles.org/www/articles/palettes/palettes.htm\n    vec3 color = .5+.5*cos(vec3(1,2,3)*5.5 + data.r*5.-4.*uv.y);\n    \n    // normal\n    float rng = hash13(vec3(fragCoord, iFrame));\n    vec3 unit = vec3(vec2(.05*rng), 0.);\n    vec3 normal = normalize(vec3(T(uv-unit.xz)-T(uv+unit.xz),\n                                 T(uv-unit.zy)-T(uv+unit.zy),\n                                 unit.y));\n    \n    // light\n    float light = dot(normal, N(vec3(0,4,1)))*.5+.5;\n    color += light;\n    \n    // shadow\n    color *= data.r;\n\n    fragColor = vec4(color, 1);\n    \n    // debug art\n    if (iMouse.z > 0. && iMouse.x/R.x < .2)\n    {\n        if (uv.x > .66) fragColor = vec4(normal*.5+.5, 1);\n        else if (uv.x > .33) fragColor = vec4(vec3(sin(data.r*6.28*2.)*.5+.5), 1);\n        else fragColor = vec4(data.yz*.5+.5,.5, 1);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R iResolution.xy\n#define ss(a,b,t) smoothstep(a,b,t)\n#define N normalize\n#define T(uv) texture(iChannel0, uv).r\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Martijn Steinrucken youtube.com/watch?v=b0AayhCO7s8\nfloat gyroid (vec3 seed)\n{\n    return dot(sin(seed),cos(seed.yzx));\n}", "buffer_a_code": "\n\n/////////// spicy noise\nfloat fbm (vec3 seed)\n{\n    // thebookofshaders.com/13\n    float result = 0.;\n    float a = .5;\n    for (int i = 0; i < 4; ++i)\n    {\n        // distort\n        seed += result / 2.;\n        \n        // animate\n        seed.y -= .1*iTime/a;\n        \n        // accumulate\n        result += gyroid(seed/a)*a;\n        \n        // granule\n        a /= 3.;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    /////////// coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord-R)/R.y;\n    \n    // salt\n    float rng = hash13(vec3(fragCoord, iFrame));\n    \n    // music\n    float fft = texture(iChannel1, vec2(abs(uv.x-.5)*2., 0.0)).r;\n    fft = min(.7, fft * 2.);\n    fft += .1;\n    \n    // noise\n    vec3 seed = vec3(p, length(p) + iTime) * 2.;\n    float noise = fbm(seed);\n    float a = noise * 3.14;\n    \n    // normal\n    vec3 unit = vec3(vec2(rng*.005), 0.);\n    vec3 normal = normalize(vec3(T(uv-unit.xz)-T(uv+unit.xz),\n                                 T(uv-unit.zy)-T(uv+unit.zy),\n                                 unit.y));\n                                 \n    // mask\n    vec2 mask = vec2(1.-abs(uv.x-.5), uv.y);\n    \n    // mouse\n    vec2 mouse = iMouse.xy/R;\n    float clic = step(0., iMouse.z);\n    \n    \n    ////////// shape\n    float shape = 1.;\n    \n    // bottom line\n    shape *= ss(.01,.0,abs(uv.y));\n    \n    // salt\n    shape *= rng;\n    \n    // frequency\n    shape *= fft;\n    \n    \n    ////////// forces field\n    vec2 offset = vec2(0);\n            \n    // turbulence                     \n    offset -= vec2(cos(a),sin(a)) * fbm(seed+.195) * (1.-mask.y);\n\n    // slope\n    offset -= normal.xy * mask.y;\n    \n    // mouse\n    vec2 velocity = vec2(0);\n    p -= (2.*iMouse.xy-R)/R.y;\n    float mouseArea = ss(.3,.0,length(p)-.1);\n    offset -= clic * normalize(p) * mouseArea * 0.2;\n    velocity += (texture(iChannel0, vec2(0)).yz - mouse);\n    if (length(velocity) > .001) velocity = clic * normalize(velocity) * mouseArea;\n    \n    // inertia\n    velocity = clamp(texture(iChannel0, uv+velocity*.05).yz * .99 + velocity * .5,-1.,1.);\n    \n    // gravity\n    offset -= vec2(0,1) * (1.-mask.y);\n    \n    // inertia\n    offset += velocity;\n    \n    // apply\n    uv += .05 * offset * fft;\n    \n    \n    \n    ////////// frame buffer\n    vec4 frame = texture(iChannel0, uv);\n    \n    // fade out\n    float fade = iTimeDelta*(1.-fft)*.5;\n    shape = max(shape, frame.r - fade);\n    \n    // result\n    shape = clamp(shape, 0., 1.);\n    fragColor = vec4(shape, velocity, 1);\n    \n    // previous mouse\n    if (fragCoord.x < 1. && fragCoord.y < 1.) fragColor = vec4(0,mouse,1);\n}", "buffer_a_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msl3W8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[253, 253, 310, 310, 1295]], "test": "untested"}
{"id": "msf3WH", "name": "Fire Fighter Fever", "author": "leon", "description": "interactive fluid simulacre", "tags": ["fire", "fluid", "smoke"], "likes": 68, "viewed": 1578, "published": 3, "date": "1666086464", "time_retrieved": "2024-07-30T16:25:51.488991", "image_code": "\n// Fire Fighter Fever\n// interactive fluid simulacre\n//\n// a bit like \"Smell of Burning Plastic\" but better https://www.shadertoy.com/view/7dyBRm\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n                                 \n    // grayscale\n    vec4 data = texture(iChannel0, uv);\n    \n    // Inigo Quilez iquilezles.org/www/articles/palettes/palettes.htm\n    vec3 color = .5+.5*cos(vec3(1,2,3)*5. + data.r*5.+4.);\n    color = mix(color, vec3(1), uv.y*.5);\n    \n    // normal\n    float rng = hash13(vec3(fragCoord, iFrame));\n    vec3 unit = vec3(vec2(.05*rng), 0.);\n    vec3 normal = normalize(vec3(T(uv-unit.xz)-T(uv+unit.xz),\n                                 T(uv-unit.zy)-T(uv+unit.zy),\n                                 unit.y));\n    \n    // light\n    float light = dot(normal, N(vec3(0,-4,1)))*.5+.5;\n    color += light;\n    \n    // shadow\n    color *= data.r;\n\n    fragColor = vec4(color, 1);\n    \n    // debug art\n    if (iMouse.z > 0. && iMouse.x/R.x < .2)\n    {\n        if (uv.x > .66) fragColor = vec4(normal*.5+.5, 1);\n        else if (uv.x > .33) fragColor = vec4(vec3(sin(data.r*6.28*2.)*.5+.5), 1);\n        else fragColor = vec4(data.yz*.5+.5,.5, 1);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R iResolution.xy\n#define ss(a,b,t) smoothstep(a,b,t)\n#define N normalize\n#define T(uv) texture(iChannel0, uv).r\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Martijn Steinrucken youtube.com/watch?v=b0AayhCO7s8\nfloat gyroid (vec3 seed)\n{\n    return dot(sin(seed),cos(seed.yzx));\n}", "buffer_a_code": "\n\n/////////// spicy noise\nfloat fbm (vec3 seed)\n{\n    // thebookofshaders.com/13\n    float result = 0.;\n    float a = .5;\n    for (int i = 0; i < 4; ++i)\n    {\n        // distort\n        seed += result / 2.;\n        \n        // animate\n        seed.y -= .1*iTime/a;\n        \n        // accumulate\n        result += gyroid(seed/a)*a;\n        \n        // granule\n        a /= 3.;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    /////////// coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord-R)/R.y;\n    \n    // salt\n    float rng = hash13(vec3(fragCoord, iFrame));\n    \n    // noise\n    vec3 seed = vec3(p, length(p) + iTime) * 2.;\n    float noise = fbm(seed);\n    float a = noise * 3.14;\n    \n    // normal\n    vec3 unit = vec3(vec2(rng*.005), 0.);\n    vec3 normal = normalize(vec3(T(uv-unit.xz)-T(uv+unit.xz),\n                                 T(uv-unit.zy)-T(uv+unit.zy),\n                                 unit.y));\n                                 \n    // mask\n    vec2 mask = vec2(1.-abs(uv.x-.5)*2., uv.y);\n    \n    // mouse\n    vec2 mouse = iMouse.xy/R;\n    float clic = step(0., iMouse.z);\n    \n    \n    ////////// shape\n    float shape = 1.;\n    \n    // bottom line\n    shape *= ss(.01,.0,abs(uv.y));\n    \n    // horizontal center\n    shape *= mask.x;\n    \n    // salt\n    shape *= pow(rng, 4.);\n    \n    \n    \n    ////////// forces field\n    vec2 offset = vec2(0);\n            \n    // turbulence                     \n    offset -= vec2(cos(a),sin(a)) * fbm(seed+.195) * (1.-mask.y);\n\n    // slope\n    offset -= normal.xy * mask.y;\n    \n    // mouse\n    vec2 velocity = vec2(0);\n    p -= (2.*iMouse.xy-R)/R.y;\n    float mouseArea = ss(.3,.0,length(p)-.1);\n    offset -= clic * normalize(p) * mouseArea * 0.2;\n    velocity += (texture(iChannel0, vec2(0)).yz - mouse);\n    if (length(velocity) > .001) velocity = clic * normalize(velocity) * mouseArea;\n    \n    // inertia\n    velocity = clamp(texture(iChannel0, uv+velocity*.05).yz * .99 + velocity * .5,-1.,1.);\n    \n    // gravity\n    offset -= vec2(0,1) * (1.-mask.y);\n    \n    // inertia\n    offset += velocity;\n    \n    // apply\n    uv += .015 * offset * mask.x;\n    \n    \n    \n    ////////// frame buffer\n    vec4 frame = texture(iChannel0, uv);\n    \n    // fade out\n    float fade = iTimeDelta*.2;\n    shape = max(shape, frame.r - fade);\n    \n    // result\n    shape = clamp(shape, 0., 1.);\n    fragColor = vec4(shape, velocity, 1);\n    \n    // previous mouse\n    if (fragCoord.x < 1. && fragCoord.y < 1.) fragColor = vec4(0,mouse,1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msf3WH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 205, 205, 1227]], "test": "untested"}
{"id": "css3D8", "name": "Fractal mosaic 22 (music)", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 3, "viewed": 194, "published": 3, "date": "1666065106", "time_retrieved": "2024-07-30T16:25:52.254943", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 = //change this constant to get other interesting patterns\n        vec2(1.,.5)\n        //vec2(2.5,-1.)\n        //vec2(1.5,0.)\n        \n        //vec2(-2.,.5+mod(floor(a.x),2.))\n    ,\n    \n    a1 = a-a2;\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\n#define triwave_(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1_(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\nfloat t1_(vec2 c, vec2 p){\n    return triwave_((.5 - length( min(p=fract(p*sign(triwave1_(c*c.y))), 1.-p.yx) )));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    bool t3 = true;\n    for(int k = 0; k < 9; k++){\n        \n        //uv.y -= t1_(floor(uv),floor(uv));\n        \n        t3 = uv.x < uv.y;\n        uv =\n            max(abs(uv-t2),abs(uv-t2/2.)-fmod(uv.x,2.))\n            //abs(uv+t2)\n            //abs(uv+t2-.5)/(.5+fmod(t2.x,2.))\n            //abs(.5+uv+t2)-vec2(fmod(uv.x*2.,2.),fmod(uv.y/2.,2.))\n            //max(abs(uv+t2),abs(.5+uv+t2))\n            //abs(.5+uv+t2)*fract(uv/4.) //another interesting pattern\n        ;\n        //uv += (distance(floor(uv),round(uv+.5)));\n\n        \n        t2 =\n            triangle_wave(uv-.5-fmod(uv.x,2.))\n            //-triangle_wave(uv-.5)/(.5+fmod(t2.x,2.))\n            //-triangle_wave(uv-.5-fmod(t2.x,2.))\n        ;\n        //t2 -= float(!t3)/2.;\n        uv = (t2-triangle_wave(uv.yx));\n        //uv = fract(uv)*fract(uv/2.)*fract(uv/4.);\n\n        float c1 =\n            //(uv.x-uv.y)\n            //(uv.x*uv.y)\n            (uv.x-uv.y)\n        ;\n        col = col.yzx;\n        vec3 col1 = col;\n        if(t3 || uv.y < uv.x) col1 = abs(col.yzx-vec3(col.yz,c1));\n        if(!t3 || uv.y > uv.x) col1 = abs(col1-max(col,vec3(col.yz,c1)));\n        col = col1;\n        //col *= col+.5;\n        //if(t3 && uv.y < uv.x) col = vec3(col.yz,c1);\n\n    }\n    fragColor = vec4(min(col*2.,vec3(1.)),1.0);\n}\n", "image_inputs": [], "sound_code": "vec2 mainSound(int samp, float time){\n  float tempo = 1.;\n  time /= tempo;\n  float s1 =\n      4.,\n      //5./(1.+fmod(time/2.,2.)), //varying tempo\n  s2 = 8.,\n  m4 = fmax1(time+floor(time),time,2.),\n  t= //varying tempo\n      time/(1.+m4)\n      //time/(1.+fmod(floor(time*s1),2.))\n      //time/(1.+fmod(time/s1+floor(time*s1),2.))*2.\n      //time/(1.+fmod(time*s1+floor(time),2.))\n      //time*(1.+fmod(time*s1,2.))/2.\n  ,\n  m1 =\n      fmax1(t/s1,t,s2)\n      //fmod(t/s1+floor(t*s1),s2)\n      //fmod(t*s1+floor(t/s1),s2)\n  ,\n  //m4 = fmod(t*s1,s1),\n  m3 =\n      fmax1(t/(m1+.5),t,s2);\n      //fmod(t*(s1+m4)/(m1+.5),s2);\n      //fmod((t+m1)*s1/(m4+.5),s2);\n      //fmod(t*s1/abs(2.5-m1),s2);\n  \n  //m1 = fmod(t/s1,s2),\n  \n  //t += m3/2.;\n  t /=  //varying tempo\n      (1.+fmod(t/s1+floor(t+.5),2.))\n      //(1.+fmod((floor(t/s1)+t/s1)/2.+floor(t*s1),2.))\n  ;\n  //t += s1*s1;\n  t *=\n      s1*s1*(1.+fmod(floor(t*s1*2.)/s1,2.))/(1.+fmod(floor(t*s1/2.)/s1,2.))\n      //s1*s1\n  ;\n  \n    float m2 =\n      1. + fmod((t/s1+floor(t/s1)),s1)\n      //1. + fmod(t/s1,8./(1.+fmod(t/s1,2.)))\n      //1. + fmod(t/s1,s1/2.)*fmod(t/s1/2.,s1/2.)\n      //1. + min(fmod(time,s1),t)\n  ;\n  \n  //m3 = mod(floor(t/s1),1.+s1+m3);\n  //m2 = mod(floor(t/s1*2.),s1-m2);\n  \n  //t /= max(m2,m1+m3+1.);\n  \n  float a=\n      //32.*((1.-sqrt(fract(t/s1))))\n      16.*pow((1.-(fract(t/s1)/2.)),2.)\n  ,\n  \n  nb = time*tempo*pow(2.,(m3+m2)/5.+6.5);\n\n  return\n      abs(.5-vec2(fract(nb*.998),fract(nb)))*a\n      \n      //sitar\n      //log(abs(a/8.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n  ;\n\n}", "sound_inputs": [], "common_code": "float fmod2(float a, float b){\n    return mod(floor(a),b)*b;\n}\n\nfloat fmod(float a, float b){\n    //a += fmod2(a,2.);\n    \n    //divide by powers of 2 to get interesting rhythms\n    float a1 = a;\n    //a /= 1. + mod(floor(a1/4.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    return\n        mod(floor(a),b)\n        //mod(mod(floor(a),b+floor(b/3.)),b)\n        //mod(floor(a)*floor(-a/b),b)\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n    ;\n}\n//#define fmod(a, b) mod(floor(a/2.),b)\n//#define fmod(x,y) mod(floor(x)+floor((x)/3.)+floor((x)/5.),y)\n#define fmax1(x,y,z) max(fmod(x,z),fmod(y,z))\n#define fmin1(x,y,z) min(fmod(x,z),fmod(y,z))", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/css3D8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 410], [527, 527, 553, 553, 642], [644, 644, 701, 701, 2265]], "test": "untested"}
{"id": "DdlGD8", "name": "Quadratic Bezier - gradient 2D", "author": "iq", "description": "Signed distance and gradient to a quadratic bezier segment. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "sdf", "bezier", "gradient", "distance", "quadratic"], "likes": 26, "viewed": 1017, "published": 3, "date": "1666060680", "time_retrieved": "2024-07-30T16:25:53.007931", "image_code": "// The MIT License\n// Copyright  2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a quadratic bezier segment.\n// Faster than central differences or automatic differentiation/duals.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n// .x = f(p)\n// .y = f(p)/x\n// .z = f(p)/y\n// .yz = f(p) with f(p) = 1\nvec3 sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    vec3 res;\n\n    float p  = ky - kx*kx;\n    float q  = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float p3 = p*p*p;\n    float q2 = q*q;\n    float h  = q2 + 4.0*p3;\n\n    if( h>=0.0 )  // 1 root\n    {   \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n\n        #if 0\n        // When p0 and p<0, h-q has catastrophic cancelation. So, we do\n        // h=(q+4p)=q(1+4p/q)=q(1+w) instead. Now we approximate\n        //  by a linear Taylor expansion into hq(1+w) so that the q's\n        // cancel each other in h-q. Expanding and simplifying further we\n        // get x=vec2(p/q,-p/q-q). And using a second degree Taylor\n        // expansion instead: x=vec2(k,-k-q) with k=(1-p/q)p/q\n        if( abs(p)<0.001 )\n        {\n          //float k = p3/q;              // linear approx\n            float k = (1.0-p3/q2)*p3/q;  // quadratic approx \n            x = vec2(k,-k-q);  \n        }\n        #endif\n\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        vec2  q = d+(c+b*t)*t;\n        res = vec3(dot(q,q),q);\n    }\n    else          // 3 roots\n    {   \n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        vec2  qx = d+(c+b*t.x)*t.x; float dx=dot(qx,qx);\n        vec2  qy = d+(c+b*t.y)*t.y; float dy=dot(qy,qy);\n        res = (dx<dy) ? vec3(dx,qx) : vec3(dy,qy);\n    }\n    \n    res.x = sqrt(res.x);\n    res.yz /= -res.x;\n    \n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n        \n    // animate\n\tvec2 v0 = vec2(1.3,0.9)*cos(iTime*0.5 + vec2(0.0,5.0) );\n    vec2 v1 = vec2(1.3,0.9)*cos(iTime*0.6 + vec2(3.0,4.0) );\n    vec2 v2 = vec2(1.3,0.9)*cos(iTime*0.7 + vec2(2.0,0.0) );\n    \n    // sdf\n    vec3  dg = sdBezier( p, v0, v1, v2 );\n    float d = dg.x;\n    vec2 g = dg.yz;\n        \n    // central differenes based gradient, for comparison\n    //g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    if( iMouse.z>0.001 )\n    {\n    d = sdBezier( m, v0, v1, v2 ).x;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdlGD8.jpg", "access": "api", "license": "mit", "functions": [[1372, 1470, 1533, 1533, 3367], [3369, 3369, 3424, 3424, 4507]], "test": "untested"}
{"id": "Dss3W8", "name": "Parabola Segment - gradient 2D", "author": "iq", "description": "Signed distance and gradient to a parabolic segment. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "sdf", "gradient", "distance", "parabola"], "likes": 12, "viewed": 520, "published": 3, "date": "1666060162", "time_retrieved": "2024-07-30T16:25:53.760917", "image_code": "// The MIT License\n// Copyright  2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a parabolic segment.\n// Faster than central differences or automatic \n// differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n// .x = f(p)\n// .y = f(p)/x\n// .z = f(p)/y\n// .yz = f(p) with f(p) = 1\nvec3 sdParabola( in vec2 pos, in float wi, in float he )\n{\n    float s = sign(pos.x);\n    pos.x = abs(pos.x);\n\n    float ik = wi*wi/he;\n    float p = ik*(he-pos.y-0.5*ik)/3.0;\n    float q = pos.x*ik*ik*0.25;\n    float h = q*q - p*p*p;\n    \n    float x;\n    if( h>0.0 ) // 1 root\n    {\n        float r = sqrt(h);\n        x = pow(q+r,1.0/3.0) + pow(abs(q-r),1.0/3.0)*sign(p);\n    }\n    else        // 3 roots\n    {\n        float r = sqrt(p);\n        x = 2.0*r*cos(acos(q/(p*r))/3.0); // see https://www.shadertoy.com/view/WltSD7 for an implementation of cos(acos(x)/3) without trigonometrics\n    }\n    \n    x = min(x,wi);\n    \n    vec2 w = pos - vec2(x,he-x*x/ik);\n    float d = length(w);\n    w.x *= s;\n    return vec3(d,w/d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n        \n    // animate\n    float t = iTime/2.0;\n\tfloat w = 0.7+0.69*sin(iTime*0.61+0.0);\n    float h = 0.4+0.35*sin(iTime*0.53+2.0);\n    \n    // sdf\n    vec3  dg = sdParabola( p, w, h );\n    float d = dg.x;\n    vec2 g = dg.yz;\n        \n    // central differenes based gradient, for comparison\n    //g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    if( iMouse.z>0.001 )\n    {\n    d = sdParabola(m, w, h ).x;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dss3W8.jpg", "access": "api", "license": "mit", "functions": [[1376, 1471, 1529, 1529, 2198], [2200, 2200, 2255, 2255, 3259]], "test": "untested"}
{"id": "mdX3WH", "name": "Parabola - gradient 2D", "author": "iq", "description": "Signed distance and gradient to a parabola. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "distancefield", "sdf", "gradient", "moon", "distance"], "likes": 13, "viewed": 506, "published": 3, "date": "1666048565", "time_retrieved": "2024-07-30T16:25:54.522880", "image_code": "// The MIT License\n// Copyright  2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a parabola.\n// Probably faster than central differences or\n// automatic differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n// .x = f(p)\n// .y = f(p)/x\n// .z = f(p)/y\n// .yz = f(p) with f(p) = 1\nvec3 sdParabola( in vec2 pos, in float k )\n{\n    float s = sign(pos.x);\n    pos.x = abs(pos.x);\n    \n    float ik = 1.0/k;\n    float p = ik*(pos.y - 0.5*ik)/3.0;\n    float q = 0.25*ik*ik*pos.x;\n    \n    float h = q*q - p*p*p;\n    float r = sqrt(abs(h));\n\n    float x = (h>0.0) ? \n        // 1 root\n        pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n        // 3 roots\n        2.0*cos(atan(r,q)/3.0)*sqrt(p);\n    \n    float z = (pos.x-x<0.0)?-1.0:1.0;\n    vec2 w = pos-vec2(x,k*x*x); float l = length(w); w.x*=s;\n    \n    return z*vec3(l, w/l );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n        \n    // animate\n    float t = iTime/2.0;\n    float px =  0.0 + 0.4*cos(t*1.1+5.5); // x position\n    float py = -0.4 + 0.2*cos(t*1.2+3.0); // y position\n    float pk =  8.0 + 7.5*cos(t*1.3+3.5); // width\n    \n    // sdf\n    vec3  dg = sdParabola( p-vec2(px,py), pk );\n    float d = dg.x;\n    vec2 g = dg.yz;\n        \n    // central differenes based gradient, for comparison\n    //g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n    \n\t// coloring\n     vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n  //col = vec3(0.5+0.5*g,1.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    if( iMouse.z>0.001 )\n    {\n    d = sdParabola(m-vec2(px,py), pk ).x;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdX3WH.jpg", "access": "api", "license": "mit", "functions": [[1375, 1470, 1514, 1514, 2026], [2028, 2028, 2083, 2083, 3217]], "test": "untested"}
{"id": "ddX3WH", "name": "Moon - gradient 2D", "author": "iq", "description": "Signed distance and gradient to a moon shape. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "distancefield", "sdf", "gradient", "moon", "distance"], "likes": 25, "viewed": 686, "published": 3, "date": "1666048496", "time_retrieved": "2024-07-30T16:25:55.277861", "image_code": "// The MIT License\n// Copyright  2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a moon shape. Faster than\n// central differences or automatic differentiation/duals.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n// .x = f(p)\n// .y = f(p)/x\n// .z = f(p)/y\n// .yz = f(p) with f(p) = 1\nvec3 sdMoon(vec2 p, float d, float ra, float rb )\n{\n    float s = sign(p.y);\n    p.y = abs(p.y);\n\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n    {\n        vec2 w = p-vec2(a,b); float d = length(w); w.y *= s;\n        return vec3(d,w/d);\n    }\n\n    vec2 w1 = p;         ; float l1 = length(w1); float d1 = l1-ra; w1.y *= s;\n    vec2 w2 = p-vec2(d,0); float l2 = length(w2); float d2 = rb-l2; w2.y *= s;\n    \n    return (d1>d2) ? vec3(d1,w1/l1) : vec3(d2,-w2/l2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n        \n    // animate\n    float ra = 0.9;\n    float rb = 0.7;\n    float di = 1.2*cos(iTime+3.9);\n    \n    // sdf\n    vec3  dg = sdMoon( p, di, ra, rb );\n    float d = dg.x;\n    vec2  g = dg.yz;\n        \n    // central differenes based gradient, for comparison\n    //g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    if( iMouse.z>0.001 )\n    {\n    d = sdMoon(m, di, ra, rb ).x;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddX3WH.jpg", "access": "api", "license": "mit", "functions": [[1358, 1453, 1504, 1504, 2004], [2006, 2006, 2061, 2061, 3035]], "test": "untested"}
{"id": "Ddf3DH", "name": "Fork Apollonian II", "author": "marvpaul", "description": "I just froked the wonderful Apollonian from Inigo Quilez and adjusted some values to come up with this. \n\nA mini fork of [url]https://www.shadertoy.com/view/4ds3zn[/url].", "tags": ["3d", "raymarching", "fractal", "distancefield", "kleinian", "apollonian", "vr"], "likes": 13, "viewed": 477, "published": 3, "date": "1666036361", "time_retrieved": "2024-07-30T16:25:56.098667", "image_code": "// Copyright Inigo Quilez, 2015 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n// Antialiasing level. Make it 1 if you have a slow machine\n#define AA 1\n\n\nvec3 map( vec3 p )\n{\n\tfloat scale = 1.;\n    \n    float orb = 100000.0;\n\n    for( int i=0; i<6; i++ )\n\t{\n\t\tp = -1.0 + 2.*fract(0.5*p+0.5);\n\n        p -= sign(p)*0.17; // trick\n        \n        float r2 = dot(p,p);\n\t\tfloat k = 0.9/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\n        orb = min( orb, r2);\n\t}\n\n    float d1 = sqrt( min( min( dot(p.xy,p.xy), dot(p.yz,p.yz) ), dot(p.zx,p.zx) ) ) - 0.03;\n    float d2 = abs(p.y);\n    float dmi = d2;\n    float adr = 0.1*floor((0.2*p.x+0.1)*10.0)-10.*p.y;\n    if( d1<d2 )\n    {\n        dmi = d1;\n        adr = 0.0;\n    }\n    return vec3( 0.5*dmi/scale, adr, orb );\n}\n\nvec3 trace( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 20.0;\n    float t = 0.01;\n    vec2  info = vec2(0.0);\n    for( int i=0; i<250; i++ )\n    {\n\t    float precis = 0.001*t;\n        \n        vec3  r = map( ro+rd*t );\n\t    float h = r.x;\n        info = r.yz;\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return vec3( t, info );\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    float precis = 0.001 * t * 0.57;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n                      e.xxx*map( pos + e.xxx ).x );\n}\n\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<16; i++ )\n    {\n        vec3 w = forwardSF( float(i), 16.0 );\n\t\tw *= sign( dot(w,nor) );\n        float h = float(i)/15.0;\n        ao += clamp( map( pos + nor*0.01 + w*h*0.15 ).x*2.0, 0.0, 1.0 );\n    }\n\tao /= 16.0;\n\t\n    return clamp( ao*16.0, 0.0, 1.0 );\n}\n\n\nvec3 textureBox( sampler2D sam, in vec3 pos, in vec3 nor )\n{\n    vec3 w = nor*nor;\n    return (w.x*texture( sam, pos.yz ).xyz + \n            w.y*texture( sam, pos.zx ).xyz + \n            w.z*texture( sam, pos.xy ).xyz ) / (w.x+w.y+w.z);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\n    vec3 res = trace( ro, rd );;\n    float t = res.x;\n    if( t>0.0 )\n    {\n        vec3  pos = ro + t*rd;\n        vec3  nor = calcNormal( pos, t );\n        float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n        float occ = pow( clamp(res.z*2.0,0.0,1.0), 1.2 );\n              occ = 1.5*(0.1+0.9*occ)*calcAO(pos,nor);        \n        vec3  lin = vec3(1.0,1.0,1.5)*(2.0+fre*fre*vec3(1.8,1.0,1.0))*occ*(1.0-0.5*abs(nor.y));\n        \n      \tcol = 0.5 + 0.5*cos( 6.2831*res.y + vec3(0.0,1.0,2.0) );  \n        col *= textureBox( iChannel0, pos, nor ).xyz;\n        col = col*lin;\n        col += 0.6*pow(1.0-fre,32.0)*occ*vec3(0.5,1.0,1.5);        \n        col *= exp(-0.3*t);\n    }\n    col.z += 0.01;\n\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.15 + 0.005*iMouse.x;\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 0, jj = 0;\n    #endif\n    {\n        vec2 q = fragCoord+vec2(float(ii),float(jj))/float(AA);\n\n        // camera\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 1. + 0.20*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 1. + 0.10*cos(0.27*time), 1.*cos(2.0+0.38*time) );\n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n\n        #if 1\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n        #else\n        vec2 p = q/iResolution.xy;\n        vec2 an = 3.1415926535898 * (p*vec2(2.0, 1.0) - vec2(0.0,0.5));\n        vec3 rd = vec3(cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x));\n\t\t#endif\n\n        tot += render( ro, rd );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 col = render( fragRayOri + vec3(0.82,1.3,-0.3), fragRayDir );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ddf3DH.jpg", "access": "api", "license": "proprietary-license", "functions": [[840, 840, 860, 860, 1437], [1439, 1439, 1477, 1477, 1811], [1813, 1813, 1857, 1857, 2111], [2113, 2113, 2149, 2149, 2413], [2415, 2415, 2457, 2457, 2751], [2754, 2754, 2814, 2814, 2992], [2994, 2994, 3033, 3033, 3775], [4986, 4986, 5080, 5080, 5187]], "test": "untested"}
{"id": "Dsf3WH", "name": "UI Test 5", "author": "yasuo", "description": "3D ring UI component", "tags": ["ui", "cineshader"], "likes": 65, "viewed": 3478, "published": 3, "date": "1666031422", "time_retrieved": "2024-07-30T16:25:57.057104", "image_code": "#define MAX_STEPS 64\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define Skew(a,b) mat2(1.0,tan(a),tan(b),1.0)\n#define SkewX(a) mat2(1.0,tan(a),0.0,1.0)\n#define SkewY(a) mat2(1.0,0.0,tan(a),1.0)\n#define seg_0 0\n#define seg_1 1\n#define seg_2 2\n#define seg_3 3\n#define seg_4 4\n#define seg_5 5\n#define seg_6 6\n#define seg_7 7\n#define seg_8 8\n#define seg_9 9\n#define seg_DP 39\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nfloat getTime(float t, float duration){\n    return clamp(t,0.0,duration)/duration;\n}\n\n\nfloat segBase(vec2 p){\n    vec2 prevP = p;\n    \n    float size = 0.02;\n    float padding = 0.05;\n\n    float w = padding*3.0;\n    float h = padding*5.0;\n\n    p = mod(p,0.05)-0.025;\n    float thickness = 0.005;\n    float gridMask = min(abs(p.x)-thickness,abs(p.y)-thickness);\n    \n    p = prevP;\n    float d = B(p,vec2(w*0.5,h*0.5));\n    float a = radians(45.0);\n    p.x = abs(p.x)-0.1;\n    p.y = abs(p.y)-0.05;\n    float d2 = dot(p,vec2(cos(a),sin(a)));\n    d = max(d2,d);\n    d = max(-gridMask,d);\n    return d;\n}\n\nfloat seg0(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    float mask = B(p,vec2(size,size*2.7));\n    d = max(-mask,d);\n    return d;\n}\n\nfloat seg1(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y+=size;\n    float mask = B(p,vec2(size*2.,size*3.7));\n    d = max(-mask,d);\n    \n    p = prevP;\n    \n    p.x+=size*1.8;\n    p.y-=size*3.5;\n    mask = B(p,vec2(size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg2(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x-=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg3(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y = abs(p.y);\n    p.x+=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg4(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    \n    p.x+=size;\n    p.y+=0.08;\n    float mask = B(p,vec2(size*2.,size*2.0));\n    d = max(-mask,d);\n\n    p = prevP;\n    \n    p.y-=0.08;\n    mask = B(p,vec2(size,size*2.0));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg5(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg6(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.y+=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg7(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y+=size;\n    float mask = B(p,vec2(size*2.,size*3.7));\n    d = max(-mask,d);\n    return d;\n}\n\n\nfloat seg8(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y = abs(p.y);\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg9(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat segDecimalPoint(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.028;\n    p.y+=0.1;\n    float mask = B(p,vec2(size,size));\n    d = max(mask,d);\n    return d;\n}\n\nfloat drawFont(vec2 p, int char){\n    p*=2.0;\n    float d = 10.;\n    if(char == seg_0) {\n        d = seg0(p);\n    } else if(char == seg_1) {\n        d = seg1(p);\n    } else if(char == seg_2) {\n        d = seg2(p);\n    } else if(char == seg_3) {\n        d = seg3(p);\n    } else if(char == seg_4) {\n        d = seg4(p);\n    } else if(char == seg_5) {\n        d = seg5(p);\n    } else if(char == seg_6) {\n        d = seg6(p);\n    } else if(char == seg_7) {\n        d = seg7(p);\n    } else if(char == seg_8) {\n        d = seg8(p);\n    } else if(char == seg_9) {\n        d = seg9(p);\n    } else if(char == seg_DP) {\n        d = segDecimalPoint(p);\n    }\n    \n    return d;\n}\n\nfloat ring0(vec2 p){\n    vec2 prevP = p;\n    p*=Rot(radians(-iTime*30.+50.));\n    p = DF(p,16.0);\n    p -= vec2(0.35);\n    float d = B(p*Rot(radians(45.0)),vec2(0.005,0.03));\n    p = prevP;\n    \n    p*=Rot(radians(-iTime*30.+50.));\n    float deg = 165.;\n    float a = radians(deg);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    a = radians(-deg);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);    \n    \n    p = prevP;\n    p*=Rot(radians(iTime*30.+30.));\n    float d2 = abs(length(p)-0.55)-0.015;\n    d2 = max(-(abs(p.x)-0.4),d2);\n    d = min(d,d2);\n    p = prevP;\n    d2 = abs(length(p)-0.55)-0.001;\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(-iTime*50.+30.));\n    p+=sin(p*25.-radians(iTime*80.))*0.01;\n    d2 = abs(length(p)-0.65)-0.0001;\n    d = min(d,d2);\n    \n    p = prevP;\n    a = radians(-sin(iTime*1.2))*120.0;\n    a+=radians(-70.);\n    p.x+=cos(a)*0.58;\n    p.y+=sin(a)*0.58;\n    \n    d2 = abs(Tri(p*Rot(-a)*Rot(radians(90.0)),vec2(0.03),radians(45.)))-0.003;\n    d = min(d,d2);      \n    \n    p = prevP;\n    a = radians(sin(iTime*1.3))*100.0;\n    a+=radians(-10.);\n    p.x+=cos(a)*0.58;\n    p.y+=sin(a)*0.58;\n    \n    d2 = abs(Tri(p*Rot(-a)*Rot(radians(90.0)),vec2(0.03),radians(45.)))-0.003;\n    d = min(d,d2);     \n    \n    return d;\n}\n\nfloat ring1(vec2 p){\n    vec2 prevP = p;\n    float size = 0.45;\n    float deg = 140.;\n    float thickness = 0.02;\n    float d = abs(length(p)-size)-thickness;\n    \n    p*=Rot(radians(iTime*60.));\n    float a = radians(deg);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    a = radians(-deg);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    \n    p = prevP;\n    float d2 = abs(length(p)-size)-0.001;\n    \n    return min(d,d2);\n}\n\nfloat ring2(vec2 p){\n    vec2 prevP = p;\n    float size = 0.3;\n    float deg = 120.;\n    float thickness = 0.02;\n    \n    p*=Rot(-radians(sin(iTime*2.)*90.));\n    float d = abs(length(p)-size)-thickness;\n    float a = radians(-deg);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    a = radians(deg);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    \n    float d2 = abs(length(p)-size)-thickness;\n    a = radians(-deg);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(deg);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n    \n    return min(d,d2);\n}\n\nfloat ring3(vec2 p){\n    p*=Rot(radians(-iTime*80.-120.));\n    \n    vec2 prevP = p;\n    float deg = 140.;\n    \n    p = DF(p,6.0);\n    p -= vec2(0.3);\n    float d = abs(B(p*Rot(radians(45.0)),vec2(0.03,0.025)))-0.003;\n    \n    p = prevP;\n    float a = radians(-deg);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    a = radians(deg);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    \n    p = prevP;\n    \n    p = DF(p,6.0);\n    p -= vec2(0.3);\n    float d2 = abs(B(p*Rot(radians(45.0)),vec2(0.03,0.025)))-0.003;\n    \n    p = prevP;\n    a = radians(-deg);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(deg);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n    \n    return min(d,d2);\n}\n\nfloat ring4(vec2 p){\n    p*=Rot(radians(iTime*75.-220.));\n    \n    vec2 prevP = p;\n    float deg = 20.;\n    \n    float d = abs(length(p)-0.25)-0.01;\n    \n    p = DF(p,2.0);\n    p -= vec2(0.1);\n    \n    float a = radians(-deg);\n    d = max(-dot(p,vec2(cos(a),sin(a))),d);\n    a = radians(deg);\n    d = max(-dot(p,vec2(cos(a),sin(a))),d);\n    \n    return d;\n}\n\nfloat ring5(vec2 p){\n    p*=Rot(radians(-iTime*70.+170.));\n    \n    vec2 prevP = p;\n    float deg = 150.;\n    \n    float d = abs(length(p)-0.16)-0.02;\n    \n    float a = radians(-deg);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    a = radians(deg);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    \n    p = prevP;\n    p*=Rot(radians(-30.));\n    float d2 = abs(length(p)-0.136)-0.02;\n    \n    deg = 60.;\n    a = radians(-deg);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(deg);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n    \n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat ring6(vec2 p){\n    vec2 prevP = p;\n    p*=Rot(radians(iTime*72.+110.));\n    \n    float d = abs(length(p)-0.95)-0.001;\n    d = max(-(abs(p.x)-0.4),d);\n    d = max(-(abs(p.y)-0.4),d);\n    \n    p = prevP;\n    p*=Rot(radians(-iTime*30.+50.));\n    p = DF(p,16.0);\n    p -= vec2(0.6);\n    float d2 = B(p*Rot(radians(45.0)),vec2(0.02,0.03));\n    p = prevP;\n    \n    p*=Rot(radians(-iTime*30.+50.));\n    float deg = 155.;\n    float a = radians(deg);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(-deg);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);    \n    \n    return min(d,d2);\n}\n\nfloat bg(vec2 p){\n    p.y-=iTime*0.1;\n    vec2 prevP = p;\n\n    p*=2.8;\n    vec2 gv = fract(p)-0.5;\n    vec2 gv2 = fract(p*3.)-0.5;\n    vec2 id = floor(p);\n\n    float d = min(B(gv2,vec2(0.02,0.09)),B(gv2,vec2(0.09,0.02)));\n    \n    float n = Hash21(id);\n    gv+=vec2(0.166,0.17);\n    float d2 = abs(B(gv,vec2(0.169)))-0.004;\n         \n    if(n<0.3){\n        gv*= Rot(radians(iTime*60.));\n        d2 = max(-(abs(gv.x)-0.08),d2);\n        d2 = max(-(abs(gv.y)-0.08),d2);\n        d = min(d,d2);\n    } else if(n>=0.3 && n<0.6){\n        gv*= Rot(radians(-iTime*60.));\n        d2 = max(-(abs(gv.x)-0.08),d2);\n        d2 = max(-(abs(gv.y)-0.08),d2);\n        d = min(d,d2);\n    } else if(n>=0.6 && n<1.){\n        gv*= Rot(radians(iTime*60.)+n);\n        d2 = abs(length(gv)-0.1)-0.025;\n        d2 = max(-(abs(gv.x)-0.03),d2);\n        d = min(d,abs(d2)-0.003);\n    }\n    \n    p = prevP;\n    p = mod(p,0.02)-0.01;\n    d2 = B(p,vec2(0.001));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat numberWithCIrcleUI(vec2 p){\n    \n    vec2 prevP = p;\n    \n    p*=SkewX(radians(-15.0));\n    int num = int(mod(iTime*6.0,10.0));\n    float d = drawFont(p-vec2(-0.16,0.),num);\n    num = int(mod(iTime*3.0,10.0));\n    float d2 = drawFont(p-vec2(-0.08,0.),num);\n    d = min(d,d2); \n    d2 = drawFont(p-vec2(-0.02,0.),seg_DP);\n    d = min(d,d2); \n    \n    p*=1.5;\n    num = int(mod(iTime*10.0,10.0));\n    d2 = drawFont(p-vec2(0.04,-0.03),num);\n    d = min(d,d2); \n    num = int(mod(iTime*15.0,10.0));\n    d2 = drawFont(p-vec2(0.12,-0.03),num);\n    d = abs(min(d,d2))-0.002; \n    \n    p = prevP;\n    \n    p.x-=0.07;\n    p*=Rot(radians(-iTime*50.));\n    p = DF(p,4.);\n    p -= vec2(0.085);\n    d2 = B(p*Rot(radians(45.0)),vec2(0.015,0.018));\n    p = prevP;\n    d2 = max(-B(p,vec2(0.13,0.07)),d2);\n    d = min(d,abs(d2)-0.0005);\n    \n    return d;\n}\n\nfloat blockUI(vec2 p){\n    vec2 prevP = p;\n    p.x+=iTime*0.05;\n    p.y = abs(p.y)-0.02;\n    p.x = mod(p.x,0.04)-0.02;\n    float d = B(p,vec2(0.0085));\n    p = prevP;\n    p.x+=iTime*0.05;\n    p.x+=0.02;\n    p.x = mod(p.x,0.04)-0.02;\n    float d2 = B(p,vec2(0.0085));\n    d = min(d,d2);\n    p = prevP;\n    d = max((abs(p.x)-0.2),d);\n    return abs(d)-0.0002;\n}\n\nfloat smallCircleUI(vec2 p){\n    p*=1.1;\n    vec2 prevP = p;\n    \n    float deg = 20.;\n    \n    p*=Rot(radians(sin(iTime*3.)*50.));\n    float d = abs(length(p)-0.1)-0.003;\n    \n    p = DF(p,0.75);\n    p -= vec2(0.02);\n    \n    float a = radians(-deg);\n    d = max(-dot(p,vec2(cos(a),sin(a))),d);\n    a = radians(deg);\n    d = max(-dot(p,vec2(cos(a),sin(a))),d);\n    \n    p = prevP;\n    p*=Rot(radians(-sin(iTime*2.)*80.));\n    float d2 = abs(length(p)-0.08)-0.001;\n    d2 = max(-p.x,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(-iTime*50.));\n    d2 = abs(length(p)-0.05)-0.015;\n    deg = 170.;\n    a = radians(deg);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(-deg);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2); \n    d = min(d,abs(d2)-0.0005);\n    \n    return d;\n}\n\nfloat smallCircleUI2(vec2 p){\n    vec2 prevP = p;\n    float d = abs(length(p)-0.04)-0.0001;\n    float d2 = length(p)-0.03;\n    \n    p*=Rot(radians(iTime*30.));\n    float deg = 140.;\n    float a = radians(deg);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(-deg);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2); \n    d = min(d,d2);\n    \n    d2 = length(p)-0.03;\n    a = radians(deg);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(-deg);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2); \n    d = min(d, d2);\n    \n    d = max(-(length(p)-0.02),d);\n    \n    return d;\n}\n\nfloat rectUI(vec2 p){\n    p*= Rot(radians(45.));\n    vec2 prevP = p;\n    float d = abs(B(p,vec2(0.12)))-0.003;\n    p*= Rot(radians(iTime*60.));\n    d = max(-(abs(p.x)-0.05),d);\n    d = max(-(abs(p.y)-0.05),d);\n    p = prevP;\n    float d2 = abs(B(p,vec2(0.12)))-0.0005;\n    d = min(d,d2);\n    \n    d2 = abs(B(p,vec2(0.09)))-0.003;\n    p*= Rot(radians(-iTime*50.));\n    d2 = max(-(abs(p.x)-0.03),d2);\n    d2 = max(-(abs(p.y)-0.03),d2);\n    d = min(d,d2);\n    p = prevP;\n    d2 = abs(B(p,vec2(0.09)))-0.0005;\n    d = min(d,d2);\n    \n    p*=Rot(radians(-45.));\n    p.y = abs(p.y)-0.07-sin(iTime*3.)*0.01;\n    d2 = Tri(p,vec2(0.02),radians(45.));\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(45.));\n    p.y = abs(p.y)-0.07-sin(iTime*3.)*0.01;\n    d2 = Tri(p,vec2(0.02),radians(45.));\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(45.));\n    d2 = abs(B(p,vec2(0.025)))-0.0005;\n    d2 = max(-(abs(p.x)-0.01),d2);\n    d2 = max(-(abs(p.y)-0.01),d2);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat graphUI(vec2 p){\n    vec2 prevP = p;\n    p.x+=0.5;\n    p.y-=iTime*0.25;\n    p*=vec2(1.,100.);\n\n    vec2 gv = fract(p)-0.5;\n    vec2 id = floor(p);\n    \n    float n = Hash21(vec2(id.y))*2.;\n    \n    float w = (abs(sin(iTime*n)+0.25)*0.03)*n*0.5;\n    float d = B(gv,vec2(w, 0.1));\n    \n    p = prevP;\n    d = max((abs(p.x)-0.2),d);\n    d = max((abs(p.y)-0.2),d);\n    \n    return d;\n}\n\nfloat staticUI(vec2 p){\n    vec2 prevP = p;\n    float d = B(p,vec2(0.005,0.13));\n    p-=vec2(0.02,-0.147);\n    p*=Rot(radians(-45.));\n    float d2 = B(p,vec2(0.005,0.028));\n    d = min(d,d2);\n    p = prevP;\n    d2 = B(p-vec2(0.04,-0.2135),vec2(0.005,0.049));\n    d = min(d,d2);\n    p-=vec2(0.02,-0.28);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(0.005,0.03));\n    d = min(d,d2);\n    p = prevP;\n    d2 = length(p-vec2(0.,0.13))-0.012;\n    d = min(d,d2);\n    d2 = length(p-vec2(0.,-0.3))-0.012;\n    d = min(d,d2);\n    return d;\n}\n\nfloat arrowUI(vec2 p){\n    vec2 prevP = p;\n    p.x*=-1.;\n    p.x-=iTime*0.12;\n    p.x = mod(p.x,0.07)-0.035;\n    p.x-=0.0325;\n    \n    p*=vec2(0.9,1.5);\n    p*=Rot(radians(90.));\n    float d = Tri(p,vec2(0.05),radians(45.));\n    d = max(-Tri(p-vec2(0.,-0.03),vec2(0.05),radians(45.)),d);\n    d = abs(d)-0.0005;\n    p = prevP;\n    d = max(abs(p.x)-0.15,d);\n    return d;\n}\n\nfloat sideLine(vec2 p) {\n    p.x*=-1.0;\n    vec2 prevP = p;\n    p.y = abs(p.y)-0.17;\n    p*=Rot(radians(45.));\n    float d = B(p,vec2(0.035,0.01));\n    p = prevP;\n    float d2 = B(p-vec2(0.0217,0.),vec2(0.01,0.152));\n    d = min(d,d2);\n    return abs(d)-0.0005;\n}\n\nfloat sideUI(vec2 p){\n    vec2 prevP = p;\n    p.x*=-1.;\n    p.x+=0.025;\n    float d = sideLine(p);\n    p = prevP;\n    p.y= abs(p.y)-0.275;\n    float d2 = sideLine(p);\n    d = min(d,d2);\n    return d;\n}\n\nfloat overlayUI(vec2 p){\n    vec2 prevP = p;\n    \n    float d = numberWithCIrcleUI(p-vec2(0.56,-0.34));\n    p.x = abs(p.x)-0.56;\n    p.y-=0.45;\n    float d2 = blockUI(p);\n    d = min(d,d2);\n    p = prevP;\n    \n    p.x = abs(p.x)-0.72;\n    p.y-=0.35;\n    d2 = smallCircleUI2(p);\n    d = min(d,d2);\n    p = prevP;\n    d2 = smallCircleUI2(p-vec2(-0.39,-0.42));\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x -= 0.58;\n    p.y -= 0.07;\n    p.y = abs(p.y)-0.12;\n    d2 = smallCircleUI(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = rectUI(p-vec2(-0.58,-0.3));\n    d = min(d,d2);\n    \n    p-=vec2(-0.58,0.1);\n    p.x = abs(p.x)-0.05;\n    d2 = graphUI(p);\n    d = min(d,d2);\n    p = prevP;\n    \n    p.x = abs(p.x)-0.72;\n    p.y-=0.13;\n    d2 = staticUI(p);\n    d = min(d,d2);\n    p = prevP;\n    \n    p.x = abs(p.x)-0.51;\n    p.y-=0.35;\n    d2 = arrowUI(p);\n    d = min(d,d2);\n    p = prevP;\n    \n    p.x = abs(p.x)-0.82;\n    d2 = sideUI(p);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    p.z+=0.7;\n    float maxThick = 0.03;\n    float minThick = 0.007;\n    float thickness = maxThick;\n    float frame = mod(iTime,30.);\n    float time = frame;\n    if(frame>=10.0 && frame<20.){\n        time = getTime(time-10.0,1.5);\n        thickness = (maxThick+minThick)-cubicInOut(time)*maxThick;\n    } else if(frame>=20.){\n        time = getTime(time-20.0,1.5);\n        thickness = minThick+cubicInOut(time)*maxThick;\n    }    \n    \n    float d = ring0(p.xy);\n    d = max((abs(p.z)-thickness),d);\n    \n    p.z-=0.2;\n    float d2 = ring1(p.xy);\n    d2 = max((abs(p.z)-thickness),d2);\n    d = min(d,d2);\n    \n    p.z-=0.2;\n    d2 = ring2(p.xy);\n    d2 = max((abs(p.z)-thickness),d2);\n    d = min(d,d2);\n        \n    p.z-=0.2;\n    d2 = ring3(p.xy);\n    d2 = max((abs(p.z)-thickness),d2);\n    d = min(d,d2);\n            \n    p.z-=0.2;\n    d2 = ring4(p.xy);\n    d2 = max((abs(p.z)-thickness),d2);\n    d = min(d,d2);\n    \n    p.z-=0.2;\n    d2 = ring5(p.xy);\n    d2 = max((abs(p.z)-thickness),d2);\n    d = min(d,d2);\n    \n    p.z-=0.2;\n    d2 = ring6(p.xy);\n    d2 = max((abs(p.z)-thickness),d2);\n    d = min(d,d2);\n    \n    return d;\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd, int stepnum) {\n    vec3 res = vec3(0.0);\n    float steps = 0.0;\n    float alpha = 0.0;\n    \n    float tmax = 5.;\n    float t = 0.0;\n    \n    float glowVal = 0.003;\n    \n    for(float i=0.; i<float(stepnum); i++) {\n        steps = i;\n        vec3 p = ro + rd*t;\n        float d = GetDist(p);\n        float absd = abs(d);\n\n        if (t > tmax) break;\n\n        alpha += 1.0 - smoothstep(0.0,glowVal, d);        \n        t += max(0.0001, absd * 0.6);\n    }\n    alpha /= steps;\n    \n    res += alpha * vec3(1.5);\n    return res;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, -2.1);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n    \n        float YZ = 45.;\n        float ogRXZ = 50.;\n        float animRXZ = 20.;\n        \n        float frame = mod(iTime,30.);\n        float time = frame;\n\n        if(frame>=10.0 && frame<20.){\n            time = getTime(time-10.0,1.5);\n            \n            YZ = 45.-cubicInOut(time)*45.0;\n            ogRXZ = 50.-cubicInOut(time)*50.0;\n            animRXZ = 20.-cubicInOut(time)*20.0;\n        } else if(frame>=20.){\n            time = getTime(time-20.0,1.5);\n            \n            YZ = cubicInOut(time)*45.0;\n            ogRXZ = cubicInOut(time)*50.0;\n            animRXZ = cubicInOut(time)*20.0;\n        }\n    \n        ro.yz *= Rot(radians(YZ));\n        ro.xz *= Rot(radians(sin(iTime*0.3)*animRXZ+ogRXZ));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec3 d = RayMarch(ro, rd, MAX_STEPS);\n    vec3 col = vec3(.0);\n    float bd = bg(uv);\n    col = mix(col,vec3(1.),S(bd,0.0));\n\n    col=mix(col,d.xyz,0.7);\n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n\n    float d2 = overlayUI(uv);\n    col = mix(col,vec3(1.),S(d2,0.0));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dsf3WH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[772, 772, 794, 794, 884], [886, 886, 913, 913, 997], [999, 999, 1038, 1038, 1083], [1086, 1086, 1108, 1108, 1599], [1601, 1601, 1620, 1620, 1770], [1772, 1772, 1791, 1791, 2092], [2094, 2094, 2113, 2113, 2401], [2403, 2403, 2422, 2422, 2712], [2714, 2714, 2733, 2733, 3021], [3023, 3023, 3042, 3042, 3330], [3332, 3332, 3351, 3351, 3621], [3623, 3623, 3642, 3642, 3825], [3828, 3828, 3847, 3847, 4033], [4035, 4035, 4054, 4054, 4324], [4326, 4326, 4356, 4356, 4516], [4518, 4518, 4551, 4551, 5186], [5188, 5188, 5208, 5208, 6448], [6450, 6450, 6470, 6470, 6873], [6875, 6875, 6895, 6895, 7432], [7434, 7434, 7454, 7454, 8125], [8127, 8127, 8147, 8147, 8484], [8486, 8486, 8506, 8506, 9069], [9071, 9071, 9091, 9091, 9666], [9668, 9668, 9685, 9685, 10635], [10637, 10637, 10670, 10670, 11483], [11485, 11485, 11507, 11507, 11844], [11846, 11846, 11874, 11874, 12647], [12649, 12649, 12678, 12678, 13239], [13241, 13241, 13262, 13262, 14246], [14248, 14248, 14270, 14270, 14635], [14637, 14637, 14660, 14660, 15165], [15167, 15167, 15189, 15189, 15538], [15540, 15540, 15564, 15564, 15803], [15805, 15805, 15826, 15826, 16006], [16008, 16008, 16032, 16032, 16985], [16987, 16987, 17010, 17010, 18168], [18170, 18170, 18216, 18216, 18728], [18730, 18730, 18772, 18772, 18967], [18969, 18969, 19026, 19026, 20404]], "test": "untested"}
{"id": "DsfGD8", "name": "SDF ray marching and voronoi", "author": "LukasBoersma", "description": "Simple test using standard SDF ray marching, with reflections and refractions. The floor uses a 2D voronoi implementation.", "tags": ["raymarching", "voronoi", "sdf"], "likes": 10, "viewed": 330, "published": 3, "date": "1666025541", "time_retrieved": "2024-07-30T16:25:58.000581", "image_code": "/***********************************************\n* MY SOURCES OF INSPIRATION AND CODE SAMPLES:\n*  - https://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n*  - Various demos and shader samples by Inigo Quilez (https://iquilezles.org/)\n***********************************************/\n\n\n\n/***********************************************\n* SETTINGS\n***********************************************/\n\n// Number of nested ray marching calls (for reflections/refractions)\n#define MARCHING_NESTED_CALLS 3\n\n// Max number of marching steps\n#define MARCHING_MAX_STEPS 512\n\n// When we are this close to a surface, we count it as \"on the surface\"\n#define MARCHING_EPSILON 1e-3\n\n#define MARCHING_MAX_DISTANCE 20.0\n\n#define MARCHING_USE_BUILTIN_DERIVATIVES 1\n\n#define GRADIENT_DELTA_EPSILON 1e-4\n\n#define SHADOW_BIAS 0.2\n\n#define SHADOW_HARDNESS 8.0\n\n\n\n/***********************************************\n* MATERIALS\n***********************************************/\n\nstruct Material\n{\n    vec3 diffuse;\n    vec3 filtering;\n    bool reflections;\n    bool refractions;\n    float shininess;\n};\n\nconst Material[4] materials = Material[4](\n    // WHITE\n    Material(\n        vec3(1),\n        vec3(1),\n        false,\n        false,\n        0.5\n    ),\n    // RED\n    Material(\n        vec3(1,0,0),\n        vec3(0.3, 0.05, 0.05),\n        true,\n        true,\n        0.5\n    ),\n    // GREEN\n    Material(\n        vec3(0,0,0),\n        vec3(0.3,1,0.3),\n        true,\n        true,\n        1.0\n    ),\n    // BLUE\n    Material(\n        vec3(0,0,1),\n        vec3(1),\n        true,\n        false,\n        0.8\n    )\n);\n\n#define MAT_WHITE   1\n#define MAT_RED     2\n#define MAT_GREEN   3\n#define MAT_BLUE    4\n\n\n\n/***********************************************\n* UTILS\n***********************************************/\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return fract(sin(x*10534.125)); }\nfloat random( int x ) { return fract(sin(float(x)*10534.125)); }\nfloat random( vec2  v ) { return fract(sin(dot(v, vec2(12.9898, 78.233)))*15.1981); }\nfloat random( vec3  v ) { return fract(sin(dot(v, vec3(10534.125, 67125.378, 23679.367)))*1573.1981); }\nfloat random( vec4  v ) { return fract(sin(dot(v, vec4(10534.125, 67125.378, 23679.367, 29814.204)))*1573.1981); }\n\n\nfloat distSquared(vec2 a, vec2 b)\n{\n    vec2 d = a-b;\n    return dot(d,d);\n}\n\nfloat distSquared(vec3 a, vec3 b)\n{\n    vec3 d = a-b;\n    return dot(d,d);\n}\n\n// Smooth min-function,\n// From https://iquilezles.org/articles/smin/\nfloat sMinCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n\n\n/***********************************************\n* VORONOI\n***********************************************/\n\nvec2 getCellPoint2D(ivec2 cell)\n{\n    vec2 rand = vec2(\n        random(cell.x + cell.y),\n        random(cell.x * 5 + cell.y * 3)\n    )*0.5;\n    return vec2(cell) + rand;\n}\n\nfloat voronoi2D(vec2 uv)\n{\n    ivec2 cell = ivec2(uv);\n    \n    float bestDistance = 1e9;\n    float res = 0.0;\n    \n    for(int dx=-1; dx <= 1; dx++)\n    {\n        for(int dy=-2; dy <= 2; dy++)\n        {\n            vec2 cellPoint = getCellPoint2D(cell+ivec2(dx,dy));\n            bestDistance = min(bestDistance, distance(uv, cellPoint));\n            //res += 1.0/pow( distance(uv, cellPoint), 8.0 );\n        }\n    }\n    \n    return bestDistance;\n    //return pow( 1.0/res, 1.0/16.0 );\n}\n\n\n\n/***********************************************\n* RAY MATH\n***********************************************/\n\nstruct Ray\n{\n    vec3 start;\n    vec3 dir;\n};\n\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    c, 0.0, -s,\n    0.0, 1.0, 0.0,\n    s, 0.0, c\n  );\n}\n\nRay getViewRay(vec2 fragCoord)\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 screenCoords = fragCoord.xy / iResolution.xy - vec2(0.5);\n    screenCoords.x *= aspectRatio;\n    \n    mat3 view = rotation3dY(iTime/3.);\n\n    vec3 camPos = view * vec3(0.0, 2.5, -10.0);\n\n    // Todo: Proper ciew direction calculation\n    vec3 viewDirection = normalize(view * vec3(screenCoords.xy, 1.0));\n\n    return Ray(camPos, viewDirection);\n}\n\n\n\n/***********************************************\n* SDF FUNCTIONS\n***********************************************/\n\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdCube(vec3 p, float r)\n{\n    return max(max(abs(p.x), abs(p.y)), abs(p.z)) - r;\n}\n\nfloat sdVoronoiColumns(vec3 p)\n{\n    float v = voronoi2D(p.xz / 10.0) - 0.5;\n    return max(p.y, v);\n}\n\n\n\n/***********************************************\n* SCENE DEFINITION (MAIN DISTANCE FIELD)\n***********************************************/\n\n#define JOIN_SMOOTH(sdValue1, sdValue2, k) sMinCubic((sdValue1), (sdValue2), k)\n\n#define JOIN_IMPL(a,b) sMinCubic((a), (b), cos(iTime) * 0.75 + 0.75)\n\nfloat join(float sd1, float sd2) { return JOIN_IMPL(sd1, sd2); }\nfloat join(float sd1, float sd2, float sd3) { return JOIN_IMPL(JOIN_IMPL(sd1, sd2), sd3); }\nfloat join(float sd1, float sd2, float sd3, float sd4) { return JOIN_IMPL(JOIN_IMPL(JOIN_IMPL(sd1, sd2), sd3), sd4); }\nfloat join(float sd1, float sd2, float sd3, float sd4, float sd5) { return JOIN_IMPL(JOIN_IMPL(JOIN_IMPL(JOIN_IMPL(sd1, sd2), sd3), sd4), sd5); }\nfloat join(float sd1, float sd2, float sd3, float sd4, float sd5, float sd6) { return JOIN_IMPL(JOIN_IMPL(JOIN_IMPL(JOIN_IMPL(JOIN_IMPL(sd1, sd2), sd3), sd4), sd5), sd6); }\n\n#define DRAW(sdValue, matValue) do { mat = sd < sdValue ? mat : matValue; sd = JOIN_IMPL(sd, sdValue); } while(false)\n\nvec2 sdMain(vec3 p)\n{\n    int mat = MAT_WHITE;\n    float sd = 1e6;\n\n    float plane = abs(sdPlane(p)) > 1.3 ? sdPlane(p) : sdPlane(p) - voronoi2D(p.xz*0.3) - voronoi2D(p.xz)*0.1;\n\n    DRAW(plane, MAT_WHITE);\n    DRAW(\n        JOIN_SMOOTH(\n            sdSphere(p - vec3(0,1,0), 1.0),\n            join(\n                sdSphere(p - vec3(0.5,1.5 + sin(iTime+1.),0.5), 0.3),\n                sdSphere(p - vec3(-0.5,1.5 + sin(iTime+2.),0.5), 0.3),\n                sdSphere(p - vec3(-0.5,1.5 + sin(iTime+3.),-0.5), 0.3),\n                sdSphere(p - vec3(0.5,1.5 + sin(iTime+4.),-0.5), 0.3)\n            ),\n            0.8\n        ),\n        MAT_RED\n    );\n\n    DRAW(sdSphere(p - vec3(3,1,3), 1.0), MAT_WHITE);\n\n    float sphere = sdSphere(p - vec3(-3,1,3), 1.0);\n    float cube = sdCube(p - vec3(-3,1,3), 1.0);\n\n    DRAW(\n        mix(sphere, cube, sin(iTime*3.) * 0.4 + 0.4),\n        MAT_BLUE\n    );\n    DRAW(sdSphere(p - vec3(3,1,-3), 1.0), MAT_RED);\n    DRAW(sdSphere(p - vec3(-3,1,-3), 1.0), MAT_GREEN);\n    \n    return vec2(sd, float(mat));\n}\n\n\n\n/***********************************************\n* RAY MARCHING\n***********************************************/\n\nstruct MarchingResult\n{\n    vec4 posAndMaterial;\n    vec2 minDistance; // x: minimum distance read from SDF, y: ray length where that distance was found\n};\n\nvec3 getSdNormal(vec3 p)\n{\n    // Todo: Try using the dFdx/dFdy functions for builtin faster derivatives\n    return normalize(vec3(\n        sdMain(vec3(p.x + GRADIENT_DELTA_EPSILON, p.y, p.z)).x - sdMain(vec3(p.x - GRADIENT_DELTA_EPSILON, p.y, p.z)).x,\n        sdMain(vec3(p.x, p.y + GRADIENT_DELTA_EPSILON, p.z)).x - sdMain(vec3(p.x, p.y - GRADIENT_DELTA_EPSILON, p.z)).x,\n        sdMain(vec3(p.x, p.y, p.z  + GRADIENT_DELTA_EPSILON)).x - sdMain(vec3(p.x, p.y, p.z - GRADIENT_DELTA_EPSILON)).x\n    ));\n}\n\n// Returns the nearest surface position (from sdMain) that intersects the given ray.\n// Returns a vec4 where xyz is the position, and w is the material index if an intersection was found,\n// or 0 if no intersection was found.\nMarchingResult rayMarch(Ray ray, float startT, float endT, float minStep, float maxStep)\n{\n    // Our position on the ray (position = ray.start + ray.dir * t)\n    float t = startT;\n    vec2 minDist = vec2(1e6, 0.0); // x: minimum distance read from SDF, y: ray length where that distance was found\n    float sd = 0.0;\n    bool distHasPeaked = false;\n    bool isOutside = false;\n\n    for(int i = 0; i < MARCHING_MAX_STEPS && t < endT; i++)\n    {\n        vec3 p = ray.start + ray.dir * t;\n        vec2 sdAndMat = sdMain(p);\n        float newSd = sdAndMat.x;\n        float mat = sdAndMat.y;\n\n        if(newSd <= sd)\n        {\n            distHasPeaked = true;\n        }\n\n        if(newSd > 0.)\n        {\n            isOutside = true;\n        }\n\n        if(distHasPeaked && newSd < minDist.x)\n        {\n            minDist = vec2(newSd, t);\n        }\n\n        sd = newSd;\n\n        t += clamp(abs(sd), minStep, maxStep);\n\n        // Are we on a surface?\n        if(isOutside && sd < MARCHING_EPSILON)\n        {\n            p = ray.start + ray.dir * t;\n            return MarchingResult(\n                vec4(p, float(mat)),\n                vec2(0.0, t)\n            );\n        }\n    }\n\n    // No intersection found. Return a vec4 with a zero in the w component.\n    return MarchingResult(vec4(0), minDist);\n}\n\nMarchingResult rayMarchForDiffuse(Ray ray)\n{\n    return rayMarch(ray, MARCHING_EPSILON*2., MARCHING_MAX_DISTANCE, MARCHING_EPSILON*2.0, 1e6);\n}\n\nfloat rayMarchForShadow(Ray ray)\n{\n    const float startT = SHADOW_BIAS;\n    const float endT = MARCHING_MAX_DISTANCE;\n    const float minStep = MARCHING_EPSILON;\n    const float maxStep = 1e6;\n    // Our position on the ray (position = ray.start + ray.dir * t)\n    float t = startT;\n    float sd = 0.0;\n    bool distHasPeaked = false;\n\n    float res = 1.0;\n\n    for(int i = 0; i < MARCHING_MAX_STEPS && t < endT; i++)\n    {\n        vec3 p = ray.start + ray.dir * t;\n        vec2 sdAndMat = sdMain(p);\n        float newSd = sdAndMat.x;\n        float mat = sdAndMat.y;\n\n        if(newSd <= sd)\n        {\n            distHasPeaked = true;\n        }\n\n        sd = newSd;\n\n        if(distHasPeaked)\n        {\n            res = min(res, SHADOW_HARDNESS * sd/t);\n        }\n\n\n        t += clamp(abs(sd), minStep, maxStep);\n\n        // Are we on a surface?\n        if(sd < MARCHING_EPSILON)\n        {\n            return 0.0;\n        }\n    }\n\n    // No intersection found. Return the soft shadow result\n    return res;\n}\n\n\n\n/***********************************************\n* SHADING\n***********************************************/\n\nconst vec3 light1Direction = normalize(vec3(1.0, 1.0, -0.5));\nconst vec3 light1Color = vec3(0.5, 0.3, 0.5);\nconst vec3 light2Direction = normalize(vec3(-0.5, 0.8, -1.0));\nconst vec3 light2Color = vec3(0.3, 0.5, 0.8);\n\nconst vec3 ambientColor = vec3(0.2);\n\nfloat directionalShadow(vec3 pos, vec3 lightDir)\n{\n    return rayMarchForShadow(Ray(pos, lightDir));\n}\n\nvec3 shade(Material material, vec3 pos, vec3 n, vec3 viewDir, vec3 reflection, vec3 refraction, bool useShadows)\n{\n    float shadowLight1 = useShadows ? directionalShadow(pos, light1Direction) : 1.0;\n    vec3 light1 = shadowLight1 * max(vec3(0.), dot(n, light1Direction) * light1Color);\n\n    float shadowLight2 = useShadows ? directionalShadow(pos, light2Direction) : 1.0;\n    vec3 light2 = shadowLight2 * max(vec3(0.), dot(n, light2Direction) * light2Color);\n\n    float fresnel = clamp(pow(1. + dot(viewDir, n), 1.0/material.shininess) + max(0., material.shininess-1.), 0., 1.);\n\n    float occlusionFactor = 0.0;\n    for(float od = 0.02; od < 0.3; od += 0.1)\n    {\n        occlusionFactor += max(0., sdMain(pos + n*od).x/od);\n    }\n    occlusionFactor = pow(clamp(occlusionFactor/3., 0., 1.), 0.3);\n\n    return material.diffuse * ((light1 + light2 + ambientColor) * occlusionFactor) + reflection*fresnel + refraction*material.filtering;\n}\n\n\n\n/***********************************************\n* MAIN\n***********************************************/\n\nvec3 renderRay(Ray ray)\n{\n    MarchingResult hit = rayMarchForDiffuse(ray);\n\n    // hit?\n    if(hit.posAndMaterial.w > 0.)\n    {\n        int materialIndex = int(hit.posAndMaterial.w);\n        Material material = materials[materialIndex-1];\n        vec3 pos = hit.posAndMaterial.xyz;\n        vec3 n = getSdNormal(pos);\n        vec3 reflection = vec3(0);\n        vec3 refraction = vec3(0);\n\n        if(material.reflections)\n        {\n            vec3 reflectedRayDir = normalize(reflect(ray.dir, n));\n            Ray ray2 = Ray(pos + reflectedRayDir * 0.1, reflectedRayDir);\n            MarchingResult hit2 = rayMarchForDiffuse(ray2);\n            if(hit2.posAndMaterial.w > 0.)\n            {\n                int materialIndex2 = int(hit2.posAndMaterial.w);\n                Material material2 = materials[materialIndex2-1];\n                vec3 pos2 = hit2.posAndMaterial.xyz;\n                vec3 n2 = getSdNormal(pos2);\n                vec3 reflection2 = vec3(0);\n\n                if(material2.reflections)\n                {\n                    vec3 reflectedRayDir2 = normalize(reflect(ray2.dir, n2));\n                    Ray ray3 = Ray(pos2 + reflectedRayDir2 * 0.1, reflectedRayDir2);\n                    MarchingResult hit3 = rayMarchForDiffuse(ray3);\n                    if(hit3.posAndMaterial.w > 0.)\n                    {\n                        int materialIndex3 = int(hit3.posAndMaterial.w);\n                        Material material3 = materials[materialIndex3-1];\n                        vec3 pos3 = hit3.posAndMaterial.xyz;\n                        vec3 n3 = getSdNormal(pos3);\n                        reflection2 = shade(material3, pos3, n3, ray3.dir, vec3(0), vec3(0), false);\n                    }\n                }\n\n                reflection = shade(material2, pos2, n2, ray2.dir, reflection2, vec3(0), true);\n            }\n        }\n\n        if(material.refractions)\n        {\n            vec3 refractedRayDir = normalize(refract(ray.dir, n, 0.9));\n            Ray ray2 = Ray(pos + refractedRayDir * 2.5, refractedRayDir);\n            MarchingResult hit2 = rayMarchForDiffuse(ray2);\n            int materialIndex2 = int(hit2.posAndMaterial.w);\n            Material material2 = materials[materialIndex2-1];\n            vec3 pos2 = hit2.posAndMaterial.xyz;\n            vec3 n2 = getSdNormal(pos2);\n            refraction = shade(material2, pos2, n2, ray2.dir, vec3(0), vec3(0), true);\n        }\n\n        return shade(material, pos, n, ray.dir, reflection, refraction, true);\n    } \n    else\n    {\n        return vec3(0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= aspectRatio;\n\n    //fragColor = vec4(vec3(voronoi2D(uv*10.0)), 1.0);\n\n    \n\n    Ray viewRay = getViewRay(fragCoord);\n\n    vec3 col = renderRay(viewRay);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsfGD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1804, 1853, 1878, 1878, 1912], [1913, 1913, 1936, 1936, 1977], [1978, 1978, 2003, 2003, 2063], [2064, 2064, 2089, 2089, 2167], [2168, 2168, 2193, 2193, 2282], [2285, 2285, 2320, 2320, 2361], [2363, 2363, 2398, 2398, 2439], [2441, 2511, 2557, 2557, 2643], [2756, 2756, 2789, 2789, 2927], [2929, 2929, 2955, 2955, 3416], [3577, 3577, 3608, 3608, 3728], [3730, 3730, 3762, 3762, 4173], [4292, 4292, 4315, 4315, 4333], [4335, 4335, 4368, 4368, 4396], [4398, 4398, 4429, 4429, 4486], [4488, 4488, 4520, 4520, 4590], [4885, 4885, 4919, 4919, 4949], [4950, 4950, 4995, 4995, 5041], [5042, 5042, 5098, 5098, 5160], [5161, 5161, 5228, 5228, 5306], [5307, 5307, 5385, 5385, 5479], [5600, 5600, 5621, 5621, 6639], [6914, 6914, 6940, 7018, 7418], [7420, 7646, 7736, 7804, 8948], [8950, 8950, 8994, 8994, 9093], [9095, 9095, 9129, 9129, 10106], [10475, 10475, 10525, 10525, 10577], [10579, 10579, 10693, 10693, 11518], [11628, 11628, 11653, 11653, 14171], [14173, 14173, 14230, 14230, 14553]], "test": "untested"}
{"id": "mds3Dr", "name": "Mandelbrot perturbation zoom", "author": "marvpaul", "description": "took Inigo Quilez perturbation code for the Mandelbrot and added a zoom, also improved performance with reducing number of iterations as well as escape threshold", "tags": ["2d", "mandelbrot", "iteration", "perturbation"], "likes": 2, "viewed": 204, "published": 3, "date": "1666022367", "time_retrieved": "2024-07-30T16:25:58.753568", "image_code": "\n\n// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// This is my own take on the orbit perturbation idea, but\n// using a more direct method than most implementations.\n//\n// The trick is that if the reference orbit is in the interior\n// of the M-set, it won't diverge and numbers will stay sane.\n// Then, the nearby points of the plane will produce orbits that\n// will deviate from the reference orbit just a little, little\n// enough that the difference can be expressed with single\n// precision floating point numbers. So this code iterates the\n// reference orbit Zn and also the current orbit Wn in delta form:\n//\n// Given\n//\n// Zn and Wn = Zn + Zn\n// \n// Then\n//\n// Zn+1 = f(Zn) = Zn + C\n// Wn+1 = f(Wn) = f(Zn+Zn) = (Zn+Zn) + C + C = \n//              = Zn + Zn + 2ZnZn + C+C = \n//              = Zn+1 + Zn(Zn + 2Zn) + C = \n//              = Zn+1 + Zn+1\n//\n// So, what we need to iterate is\n//\n// Zn+1 = (Zn + C) + 2ZnZn  --> delta-orbit (Wn-Zn)\n//  Zn+1 = ( Zn +  C)             --> periodic orbit, doesn't diverge\n\n\nvec2 cmul(vec2 a, vec2 b) { return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x); }\n\n\nfloat mandelbrot_perturbation( vec2 c, vec2 dc )\n{\n    vec2 z  = vec2(0.0);\n    vec2 dz = vec2(0.0);\n    float n = -1.0;\n    for( int i=0; i<700; i++ )\n    {\n        dz = cmul(2.0*z+dz,dz) + dc;  // dz = cmul(dz,dz)+dc + 2.0*cmul(z,dz);\n        \n        z  = cmul(z,z)+c; // this could be precomputed since it's constant for the whole image\n        \n        // instead of checking for Wn to escape...\n        // if( dot(z+dz,z+dz)>4.0 ) { n=float(i); break; }\n        // ... we only check Zn, since Zn is periodic and can't escape\n        if( dot(dz,dz)>2. ) { n=float(i); break; }\n    }\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // input\n    vec3 col = vec3(0.0);\n        vec2  p = 3.0*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n        // viewport\n        float zoom; vec2 c;\n        //zoom=0.001 + 0.001*-0.999; c=vec2(-0.7436441,0.131825);\n       zoom=1./exp2(mod(iTime, 30.)); c=vec2(-0.743641,0.131825);\n\n        // mandelbrot\t\n        vec2 dc = p*zoom;\n        float l =  mandelbrot_perturbation(c, dc);\n        // color\n        col += (l<0.0) ? vec3(0.0) : 0.5 + 0.5*cos( pow(zoom,0.2)*l*0.5 + vec3(sin(iTime)+1.5,3.,2.0));\n\n    \n    // output    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mds3Dr.jpg", "access": "api", "license": "mit", "functions": [[2103, 2103, 2130, 2130, 2179], [2182, 2182, 2232, 2232, 2787], [2790, 2790, 2847, 2860, 3418]], "test": "untested"}
{"id": "Nss3D4", "name": "motya_test_v1", "author": "motya", "description": "color gradient test", "tags": ["v1"], "likes": 1, "viewed": 179, "published": 3, "date": "1665993046", "time_retrieved": "2024-07-30T16:25:59.561408", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy; //   \n    xy.x = xy.x / iResolution.x; //    \n    xy.y = xy.y / iResolution.y;\n    //  x      0,      1\n    vec4 solidRed = vec4(0,0.0,0.0,1.0); //   \n    solidRed.b =  cos(iTime + xy.x-xy.y);\n    solidRed.r =  sin(iTime + xy.y-xy.x);\n    solidRed.g =  cos(iTime + xy.x-xy.y);\n     solidRed.a =  sin(iTime + xy.y-xy.x);//     x\n    fragColor = solidRed;\n}", "image_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nss3D4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 815]], "test": "untested"}
{"id": "7lyBWc", "name": "Volumes with Direct Lighting", "author": "SpinningCube", "description": "Upgrade of my previous volumetric ray marcher. The volumes now scatter light from a single light source by casting shadow rays at various positions along the ray.", "tags": ["3d", "raymarching", "lighting", "volumetric"], "likes": 3, "viewed": 274, "published": 3, "date": "1665989925", "time_retrieved": "2024-07-30T16:26:00.317387", "image_code": "/*\n *\n * Volumes with Direct Lighting\n * by SpinningCube\n *\n * \n * Uses a constant step size, and samples from a 3D layered noise texture.\n * At each sample, a secondary \"shadow ray\" is also cast towards the light source\n * if the density at that position is greater than 0.\n * The shadow ray measures how much direct light that sample receives.\n * Randomness is used to get rid of layering artifacts\n * \n * \n * Filmic tonemapping curve by milesWaugh\n *\n * Hash functions by Nimitz:\n * https://www.shadertoy.com/view/Xt3cDn\n *\n */\n\nuint baseHash(uvec3 p)\n{\n    p = 1103515245U*((p.xyz >> 1U)^(p.yzx));\n    uint h32 = 1103515245U*((p.x^p.z)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash13(uvec3 x)\n{\n    uint n = baseHash(x);\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash23(uvec3 x)\n{\n    uint n = baseHash(x);\n    uvec2 rz = uvec2(n, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash33(uvec3 x)\n{\n    uint n = baseHash(x);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash43(uvec3 x)\n{\n    uint n = baseHash(x);\n    uvec4 rz = uvec4(n, n*16807U, n*48271U, n*69621U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec4((rz >> 1) & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n\n/* Variables */\n\nconst int maxSteps = 256;\nconst float epsilon = 0.005;\nconst float pi = 3.1415926536;\nconst float focalLength = 0.7;\nconst float renderDist = 50.;\n\nvec3 lightDir = normalize(vec3(-1,1,-2));\nvec3 lightCol = 4. * vec3(1, 1, .8);\nfloat lightDist = 10.;\n\nvec3 camera;\nfloat SDE;\nvec3 ray;\nfloat rayDensity;\nvec3 volumetricColor;\n\nvec3 surfCol;\nvec3 surfNormal;\nfloat surfSpecular;\nfloat surfRoughness;\nbool updateMat;\n\nvec3 diffuse = vec3(0.);\nvec3 specular;\nvec3 ambient = vec3(0.05);\n\n\nvec3 rayDirection( float focal, vec2 xy ) {\n    return (normalize(vec3(xy, focal)));\n}\n\nfloat visibility(float x) {\n    return exp(-x);\n}\n\nmat2 rotate(float a) {\n    float sinA = sin(a);\n    float cosA = cos(a);\n    return mat2(cosA, -sinA, sinA, cosA);\n}\n\n/* Objects */\n\nfloat Sphere( vec3 ray, vec3 pos, float radius ) {\n    return distance(ray, pos ) - radius;\n}\n\nfloat SphereVolume( vec3 ray, vec3 pos, float radius, float density ) {\n    return density * max(0., (radius - distance(ray, pos))/radius);\n}\n\nfloat Ground( vec3 ray, float y ) {\n    return ray.y - y;\n}\n\nvoid addSDF( float SDF, vec3 col, float specular, float roughness ) {\n    if ( SDF < SDE ) {\n        SDE = SDF;\n        if (updateMat) {\n        \tsurfCol = col;\n        \tsurfSpecular = specular;\n        \tsurfRoughness = roughness * roughness;\n        }\n    }\n}\n\nfloat Noise3D(vec3 pos) {\n    int layers = 6;\n    float noise = 0.;\n    for (int i = 1; i <= layers; i++) {\n        float scale = exp2(float(i));\n        noise += 1./scale * texture(iChannel0, 0.008*pos*scale).r;\n    }\n    \n    return max(0., mix(-.25, 1., noise/(1. - exp2(-float(layers)))));\n}\n\n/* Scene */\n\nfloat scene( vec3 ray, float renderDist ) {\n    \n    SDE = renderDist;\n\n    addSDF( Sphere( ray, vec3(0.), 2.), .6 * vec3(0.2,1.,0.2), 1.5, 0.1 );\n    \n    return SDE;\n}\n\nfloat sceneVolumes( vec3 ray ) {\n    \n    float density = 0.;\n    \n    density += max(0., 25.0 * SphereVolume( ray, vec3(0.), 12., 7. * pow(Noise3D( .2 * ray + iTime + 1./60. * vec3(0.5, 1, 0.5)), 8.)));\n    \n    return max(0., density);\n}\n\n/* Sampling and Raycasts */\n\nvec3 calcNormal( vec3 p )\n{\n    const float h = 10. * epsilon; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy * scene( p + k.xyy*h, renderDist ) + \n                      k.yyx * scene( p + k.yyx*h, renderDist ) + \n                      k.yxy * scene( p + k.yxy*h, renderDist ) + \n                      k.xxx * scene( p + k.xxx*h, renderDist ));\n    \n}\n\nfloat shadowRay( vec3 rayDir, vec3 start, float renderDist ) {\n    float shadowRayDensity = 0.;\n    float firstStepSize = .4;\n    float secondStepSize = 0.005;\n    bool oldUpdateMat = updateMat;\n    updateMat = false;\n    ray = start;\n    float rayLength = 0.;\n    float oldSDE = SDE;\n    for ( int i = 0; i <= maxSteps; i++ ) {\n    \n        float nextStepSize = min(firstStepSize, firstStepSize);\n        \n        ray += rayDir * float(nextStepSize >= firstStepSize) * nextStepSize * (hash13( uvec3(86412.4352 * start.xyz + vec3(6425.432, 9624.242, 2355.543) * vec3(float(i)) ) ) - 0.5);\n        \n        float pointDensity = sceneVolumes( ray );\n        shadowRayDensity += 1. * pointDensity * nextStepSize;        \n        scene( ray, renderDist );\n        rayLength += nextStepSize;\n        ray = rayDir * rayLength + start;\n        \n        if ( rayLength > renderDist ) {\n            updateMat = oldUpdateMat;\n            ray = start;\n            SDE = oldSDE;\n            return 0.;\n        }\n        if ( SDE < epsilon ) {\n            for ( int i = 0; i <= maxSteps; i++ ) {\n                scene( ray, renderDist );\n                rayLength -= secondStepSize;\n                ray = rayDir * rayLength + start;\n                if (SDE >= 0.) {\n                    break;\n                }\n            }\n            updateMat = oldUpdateMat;\n            ray = start;\n            if ( SDE < epsilon ) {\n                SDE = oldSDE;\n                return 0.;\n            }\n            SDE = oldSDE;\n            return visibility(shadowRayDensity);\n        }\n        firstStepSize *= 1.02;\n    }\n    updateMat = oldUpdateMat;\n    ray = start;\n    SDE = oldSDE;\n    return visibility(shadowRayDensity);\n}\n\nvec4 shootRay( vec3 rayDir, vec3 start, float renderDist, bool updateMaterial ) {\n    rayDensity = 0.;\n    float firstStepSize = 0.05;\n    float secondStepSize = 0.005;\n    updateMat = updateMaterial;\n    ray = start;\n    float rayLength = 0.;\n    for ( int i = 0; i <= maxSteps; i++ ) {\n    \n        float nextStepSize = min(SDE, firstStepSize + 0.2 * rayDensity);\n        \n        scene( ray, renderDist );\n        \n        ray += rayDir * float(nextStepSize >= firstStepSize + 0.2 * rayDensity) * nextStepSize * (hash13( uvec3(48421.425 * rayDir.xyz + 30214.6452 * vec3(1.2, 0.6, 1.5) * float(i)) ) - 0.5);\n        \n        float pointDensity = sceneVolumes( ray );\n        if (pointDensity > 0.0) {\n            vec3 sampleColor = lightCol * shadowRay(lightDir, ray, lightDist) + .5 * ambient;\n            volumetricColor += 0.3 * visibility(rayDensity) * nextStepSize * pointDensity * sampleColor;\n        }\n        rayDensity += pointDensity * nextStepSize;\n        \n        rayLength += nextStepSize;\n        ray = rayDir * rayLength + start;\n        \n        if ( rayLength > renderDist ) {\n            return vec4(0., ray);\n        }\n        if ( SDE < 0.01 * epsilon ) {\n            for ( int i = 0; i <= maxSteps; i++ ) {\n        \n                scene( ray, renderDist );\n                rayLength -= secondStepSize;\n                ray = rayDir * rayLength + start;\n                if (SDE >= 0.) {\n                    break;\n                }\n            }\n            return vec4(float(SDE < epsilon), ray);\n        }\n        firstStepSize *= 1.01;\n    }\n    return vec4(0., ray);\n}\n\n/* Lighting */\n\nfloat GGX (float halfDot, float roughness) {\n    float r2 = roughness*roughness;\n    float a = halfDot * halfDot * (r2 - 1.) + 1.;\n    return r2 / (a * a);\n}\n\nvoid directionalLight(vec3 ray, vec3 rayDir, vec3 lightDir, vec3 surfNormal, vec3 intensity, float lightDist) {\n    float lightVisibility = shadowRay(lightDir, ray + (surfNormal * epsilon), lightDist);\n    if ( lightVisibility > 0. ) {\n        float lambertian = dot(surfNormal, lightDir);\n        intensity *= lambertian * lightVisibility;\n        \n        diffuse += max(intensity, 0.);\n\t\t\n        vec3 halfway = normalize(lightDir - rayDir);\n        float halfDot = dot(surfNormal, halfway);\n    \tspecular += max(intensity * GGX(halfDot, surfRoughness), 0.);\n\n    }\n}\n\nvoid pointLight( vec3 ray, vec3 rayDir, vec3 position, vec3 intensity, vec3 surfNormal ) {\n    vec3 lightDir = normalize(position - ray);\n    directionalLight( ray, rayDir, lightDir, surfNormal, intensity, distance(position, ray) );\n}\n\nvoid sceneLights(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    directionalLight( ray, rayDir, normalize(vec3(-1,1,-2)), surfNormal, lightCol, 2. );\n}\n\n// Filmic tonemapping curve by milesWaugh\nvec3 filmic(vec3 color) {\n    //return color;\n    return 1.0 - (1.0/(5.0 * color * color + 1.0));\n}\n\n// Uses Schlick's approximation\nfloat fresnel(float IOR, float roughness, vec3 surfNormal, vec3 incident) {\n    float F0 = (1. - IOR)/(1. + IOR);\n    F0 *= F0;\n    return F0 + (1. - roughness)*((1. - F0) * pow(1. - dot(surfNormal, incident), 5.));\n}\n\nvec3 lighting(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    diffuse = vec3(0.0);\n    specular = vec3(0.0);\n    \n    sceneLights(ray, rayDir, surfNormal);\n    \n\n    float f = fresnel(1.5, surfRoughness, surfNormal, -rayDir);\n    vec3 finalCol = mix(surfCol * (diffuse + ambient), vec3(specular) + ambient, f);\n    \n    return finalCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    volumetricColor = vec3(0.);\n    camera = vec3(0, 0, -30);\n    \n    vec2 mouse = (1.1 * iMouse.xy)/iResolution.xy - vec2(0.5);\n    \n    if(iMouse.xy == vec2(0.0)){\n        mouse = vec2(0.25, 0.0);\n    }    \n    \n    camera.yz *= rotate(pi * -mouse.y);\n    camera.xz *= rotate(2. * pi * -mouse.x);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.x;\n    vec2 UV = fragCoord/iResolution.xy;\n    vec3 rayDir = rayDirection( focalLength, uv );\n    \n    rayDir.yz *= rotate(pi * -mouse.y);\n    rayDir.xz *= rotate(2. * pi * -mouse.x);\n    \n    vec4 rayData = shootRay( rayDir, camera, renderDist, true );\n    \n    float cameraRayDensity = rayDensity;\n    \n    vec3 col;\n    \n    vec3 finalVolumetricColor = volumetricColor;\n    \n    if (rayData.x == 1.) {\n        vec3 surfNormal = calcNormal( rayData.yzw );\n    \tcol = lighting( rayData.yzw, rayDir, surfNormal );\n    }\n    else {\n        col = ambient;\n    }\n    \n    col = filmic( mix( finalVolumetricColor, col, visibility(cameraRayDensity)) );\n    \n    // Output to screen\n    fragColor = vec4(pow(col, vec3(1.0/2.2)),1.0);\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyBWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[532, 532, 556, 556, 681], [683, 683, 706, 706, 780], [782, 782, 804, 804, 1003], [1005, 1005, 1027, 1027, 1233], [1235, 1235, 1257, 1257, 1473], [1976, 1976, 2019, 2019, 2062], [2064, 2064, 2091, 2091, 2113], [2115, 2115, 2137, 2137, 2231], [2248, 2248, 2298, 2298, 2341], [2343, 2343, 2414, 2414, 2484], [2486, 2486, 2521, 2521, 2545], [2547, 2547, 2616, 2616, 2807], [2809, 2809, 2834, 2834, 3104], [3119, 3119, 3162, 3162, 3288], [3290, 3290, 3322, 3322, 3529], [3560, 3560, 3587, 3587, 3958], [3960, 3960, 4022, 4022, 5670], [5672, 5672, 5753, 5753, 7268], [7286, 7286, 7330, 7330, 7443], [7445, 7445, 7556, 7556, 8015], [8017, 8017, 8107, 8107, 8251], [8253, 8253, 8311, 8311, 8402], [8404, 8446, 8471, 8491, 8545], [8547, 8579, 8654, 8654, 8796], [8798, 8798, 8853, 8853, 9134], [9136, 9136, 9193, 9193, 10336]], "test": "untested"}
{"id": "msX3Dr", "name": "FLOPS Benchmark Thingy", "author": "Zi7ar21", "description": "My very own FP32 benchmark, it gave me results (~706.5 GFLOPS) near what my manufacturer provided (1075.2-1126.4 GFLOPS) but please read the disclaimer. Not all FLOPS are created equal...", "tags": ["bench", "point", "float", "core", "benchmark", "floating", "gpu", "flop", "hardware", "mark", "flops", "fp32"], "likes": 1, "viewed": 282, "published": 3, "date": "1665968137", "time_retrieved": "2024-07-30T16:26:01.134203", "image_code": "// FLOPS formula: 1 / (t / (n * x * y))\n// where `t` is the frametime in seconds (Can be measured with the Shadertoy Unofficial Plugin,\n// otherwise you can use 1 / [frames per second]), `n` is the FLOP's per pixel (~347 in this case,\n// see more info below), `x` is the resolution in the x-axis, and `y` is the resolution in the y-axis.\n//\n// NOTE #1: This is NOT a good benchmark. It's just my interperitation of a FLOP, which varies depending\n// on things like cycles per instruction per GPU. E.g. addition and square root take a different number of\n// cycles to execute (depending on the GPU and architecture) but I still consider each to be 1 FLOP, so\n// depending on the distribution of each operation you perform, you will get a different FLOPS measurement.\n// I think the FLOPS measurements that manufacturers and other benchmarks produce are based on a somewhat\n// equal distribution of each operation a GPU can perform, so they aren't as high as what this shader yields.\n// Still, it's kinda cool.\n//\n// NOTE #2: the precision loss (or even cap) of the framerate counter and overhead of rendering a new frame\n// can skew results so I recommend using the Shadertoy Unofficial Plugin and Shadertoy Frame Exporter browser\n// extensions, the Unofficial Plugin to display a frametime counter (in milliseconds) and the Frame Exporter\n// to set the resolution to something like 1024x1024 or more depending on your GPU. You can press the preview\n// button (a part of the frame exporter and then set the resolution and press [Alt]-[1] to lock the resolution,\n// and then you can turn off the preview thing and it will still render at the resolution you entered and the\n// rest of the GUI won't be scaled funny. On High-DPI displays, zoom out 50% or whatever it takes to get\n// everything to be 100% resolution, as these plugins act funny.\n//\n// Example Result and Calculation:\n// With Intel Iris Plus Graphics (Intel Core i7-1065G7 integrated graphics) I get ~8.24 ms (0.00824 seconds)\n// per frame when rendering at 4096x4096. 1/(0.00824/(347*4096*4096)) = 706,516,256,311 which divided by\n// 1,000,000,000 is 706.516256311 GFLOPS.\n// \n// More info about my GPU:\n// https://en.wikipedia.org/wiki/Intel_Graphics_Technology#Ice_Lake\n// https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units#Gen9\n// 64 Execution Units, 512 Shading Units, FP16 2150.4-2252.8 GFLOPS, FP32 1075.2-1126.4 GFLOPS,\n// Device ID 8A52, Core Configuration 512:64:8 (GT2), Clock Rate min/max 300/1100 MHz, Mem Bandwidth 59.7 GB/s\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\nconst float     PI = 3.141592653589793; // Pi\nconst float TWO_PI = 6.283185307179586; // 2 * Pi = \"Tau\"\nconst float INV_PI = 0.318309886183791; // 1 / Pi\n//const float     PI = uintBitsToFloat(0x40490FDBu); // Pi\n//const float TWO_PI = uintBitsToFloat(0x40C90FDBu); // 2 * Pi = \"Tau\"\n//const float INV_PI = uintBitsToFloat(0x3EA2F983u); // 1 / Pi\n\n// Triangle Ray-Surface Intersection Function\n// https://iquilezles.org/articles/intersectors/\nvec3 triangleIntersect(vec3 ro, vec3 rd, vec3 v0, vec3 v1, vec3 v2) {\n    vec3 v1v0 = v1 - v0; // ~3 FLOP (3x SUB)\n    vec3 v2v0 = v2 - v0; // ~3 FLOP (3x SUB)\n    vec3 rov0 = ro - v0; // ~3 FLOP (3x SUB)\n\n    vec3 n = cross(v1v0, v2v0); // ~9 FLOP (6x MUL, 3x SUB)\n    vec3 q = cross(rov0, rd  ); // ~9 FLOP (6x MUL, 3x SUB)\n\n    float d = 1.0 / dot(rd, n); // ~6 FLOP (3x MUL, 2x ADD, 1x DIV)\n\n    float u = d * dot(-q, v2v0); // ~7 FLOP (1x NEG, 3x MUL, 2x ADD, 1x MUL)\n    float v = d * dot( q, v1v0); // ~6 FLOP (3x MUL, 2x ADD, 1x MUL)\n    float t = d * dot(-n, rov0); // ~7 FLOP (1x NEG, 3x MUL, 2x ADD, 1x MUL)\n\n    t = (u < 0.0 || v < 0.0 || (u + v) > 1.0) ? -1.0 : t; // no intersection, ~9 FLOP (2x LESS, 1x ADD, 1x GREAT, 2x MAX, 1x SUB, 2x MUL)\n\n    return vec3(t, u, v); // Total: ~62? FLOP (16x SUB, 29x MUL, 1x DIV, 7x ADD, 2x NEG, 2x LESS, 1x GREAT, 2x MAX)\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // MSAA Sampling Pattern\n    const vec2 s0 = vec2(-0.375, -0.125);\n    const vec2 s1 = vec2( 0.125, -0.375);\n    const vec2 s2 = vec2(-0.125,  0.375);\n    const vec2 s3 = vec2( 0.375,  0.125);\n\n    // Triangle Vertex Positions\n    const vec3 v0 = vec3( 1.000, -1.000, -1.000);\n    const vec3 v1 = vec3(-1.000,  1.000, -1.000);\n    const vec3 v2 = vec3(-1.000, -1.000,  1.000);\n\n    vec2 hres = 0.5 * iResolution.xy; // ~2 FLOP (2x ADD)\n\n    float ires = 1.0 / max(hres.x, hres.y); // ~2 FLOP (1x MAX, 1x DIV)\n\n    vec2 uv0 = fragCoord.xy + s0; // ~2 FLOP (2x ADD)\n    vec2 uv1 = fragCoord.xy + s1; // ~2 FLOP (2x ADD)\n    vec2 uv2 = fragCoord.xy + s2; // ~2 FLOP (2x ADD)\n    vec2 uv3 = fragCoord.xy + s3; // ~2 FLOP (2x ADD)\n\n    uv0 = ires * (uv0 - hres); // ~4 FLOP (2x SUB, 2x MUL)\n    uv1 = ires * (uv1 - hres); // ~4 FLOP (2x SUB, 2x MUL)\n    uv2 = ires * (uv2 - hres); // ~4 FLOP (2x SUB, 2x MUL)\n    uv3 = ires * (uv3 - hres); // ~4 FLOP (2x SUB, 2x MUL)\n\n    float theta = TWO_PI * fract(0.5 * iTime); // ~3 FLOP (1x MUL, 1x MOD, 1x MUL)\n\n    float cos_theta = cos(theta), sin_theta = sin(theta); // ~2 FLOP (1x COS, 1x SIN)\n\n    vec3 ro = vec3(sin_theta, cos_theta, 5.0);\n\n    vec3 rd0 = normalize(vec3(uv0, -1.0)); // ~8 FLOP (3x MUL, 2x ADD, 3x DIV)\n    vec3 rd1 = normalize(vec3(uv1, -1.0)); // ~8 FLOP (3x MUL, 2x ADD, 3x DIV)\n    vec3 rd2 = normalize(vec3(uv2, -1.0)); // ~8 FLOP (3x MUL, 2x ADD, 3x DIV)\n    vec3 rd3 = normalize(vec3(uv3, -1.0)); // ~8 FLOP (3x MUL, 2x ADD, 3x DIV)\n\n    vec3 t0 = triangleIntersect(ro, rd0, v0, v1, v2); // ~62 FLOP\n    vec3 t1 = triangleIntersect(ro, rd1, v0, v1, v2); // ~62 FLOP\n    vec3 t2 = triangleIntersect(ro, rd2, v0, v1, v2); // ~62 FLOP\n    vec3 t3 = triangleIntersect(ro, rd3, v0, v1, v2); // ~62 FLOP\n\n    fragColor.xy = vec2(0);\n\n    fragColor.xy += t0.x >= 0.0 ? t0.yz : vec2(0); // ~8 FLOP (1x GREATEQUAL, 1x SUB, 4x MUL, 2x ADD)\n    fragColor.xy += t1.x >= 0.0 ? t1.yz : vec2(0); // ~8 FLOP (1x GREATEQUAL, 1x SUB, 4x MUL, 2x ADD)\n    fragColor.xy += t2.x >= 0.0 ? t2.yz : vec2(0); // ~8 FLOP (1x GREATEQUAL, 1x SUB, 4x MUL, 2x ADD)\n    fragColor.xy += t3.x >= 0.0 ? t3.yz : vec2(0); // ~8 FLOP (1x GREATEQUAL, 1x SUB, 4x MUL, 2x ADD)\n\n    fragColor.xy *= 0.25; // ~2 FLOP (2x MUL)\n\n    fragColor = vec4(fragColor.xy, 0.0, 1.0); // Total: 347 FLOP per pixel\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msX3Dr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2965, 3060, 3129, 3129, 3936], [3938, 3938, 3993, 4022, 6324]], "test": "untested"}
{"id": "DslGDn", "name": "test_2022_10_17", "author": "xlat", "description": "school", "tags": ["fragmentshader"], "likes": 0, "viewed": 149, "published": 3, "date": "1665965748", "time_retrieved": "2024-07-30T16:26:01.976950", "image_code": "float circleShape_1(vec2 position, float radius)\n{\n\treturn step(radius, length(position));\n}\n\n///--------|\n///  |\n///--------:\nfloat circleShape_2(vec2 position, float radius)\n    {if (length(position) > radius) return 1.0;\n    else                            return 0.0;\n}\n\n///--------|\n///     |\n///--------:\nfloat circleShape_3(vec2 position, float radius)\n{\n    radius /= 2.0;\n    if(  position.x > -radius &&\n         position.x <  radius &&\n         position.y > -radius &&\n         position.y <  radius) return 0.0;\n    else                       return 1.0;\n}\n\n///--------|\n///  test01|\n///--------:\nvoid test01( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 position = fragCoord / iResolution.x;\n    \n\tvec2 translate = vec2(sin(iTime), cos(iTime)) * 0.2 - vec2(0.5,0.5 * iResolution.y/iResolution.x);\n\tposition += translate;\n\n    //float circle = circleShape_1(position, 0.1);\n    //float circle = circleShape_2(position, 0.1);\n\t  float circle = circleShape_3(position, 0.1);\n\n\tvec3 color = vec3(circle);\n\n\tfragColor = vec4(color, 1.0);\n\n}\n\n///--------|\n///  test02|\n///--------:\nvoid test02( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 position = fragCoord / iResolution.xy;\n    \n    position -= 0.5;\n\n\t  float circle = circleShape_1(position, 0.1);\n    //float circle = circleShape_2(position, 0.1);\n\t//float circle = circleShape_3(position, 0.1);\n\n\tvec3 color = vec3(circle);\n\n\tfragColor = vec4(color, 1.0);\n\n}\n\n///---------------------------------------------------|\n///  .\n///---------------------------------------------------:\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      test01(fragColor, fragCoord);\n      \n      vec4 Color;\n     \n      test02(Color, fragCoord);\n      \n      \n      if(Color.r == 0.0) fragColor = Color;\n      \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DslGDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 92], [94, 139, 193, 193, 285], [287, 329, 379, 379, 585], [587, 626, 680, 680, 1071], [1073, 1112, 1166, 1166, 1452], [1454, 1595, 1652, 1652, 1818]], "test": "untested"}
{"id": "cdXGDr", "name": "This is a cubemap Render Target ", "author": "MacLin", "description": "This is a cubemap Render Target ", "tags": ["test"], "likes": 2, "viewed": 250, "published": 3, "date": "1665932583", "time_retrieved": "2024-07-30T16:26:02.740907", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 texCoord = fragCoord.xy / iResolution.xy; \n    vec2 thetaphi = ((texCoord * 2.0) - vec2(1.0)) * vec2(3.1415926535897932384626433832795, 1.5707963267948966192313216916398); \n    vec3 rayDirection = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n\tfragColor = texture(iChannel0, rayDirection);\n    // for apply the equirectangular map like a cubemap:\n    // rayDirection = normalize(rayDirection);\n    // texture(uTexEnvMap, vec2((atan(rayDirection.z, rayDirection.x) / 6.283185307179586476925286766559) + 0.5, acos(rayDirection.y) / 3.1415926535897932384626433832795));    \n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "/*\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}\n*/\nfloat max3(vec3 rd) {\n   return max(max(rd.x, rd.y), rd.z);\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec3 rd = abs(rayDir);\n    \n    vec3 col = vec3(0);\n    if (max3(rd) == rd.x) col = vec3(1, 0, 0);\n    if (max3(rd) == rd.y) col = vec3(0, 1, 0);\n    if (max3(rd) == rd.z) col = vec3(0, 0, 1);\n    \n    fragColor = vec4(col,1.0); // Output cubemap\n}", "cube_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdXGDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 686]], "test": "untested"}
{"id": "dds3RM", "name": "cone - circle intersection", "author": "sympou", "description": "now intersecting with a circle :)\ni am looking for a way to include a bounding sphere to my cone-marching program, with min and max values for the ray.\nthis might be usable, or too heavy, i'm not sure yet.", "tags": ["cone"], "likes": 9, "viewed": 233, "published": 3, "date": "1665920122", "time_retrieved": "2024-07-30T16:26:03.504865", "image_code": "#define coneWidth    .25\n#define camPos       vec2(0.1,0.2)\n#define circlePos    vec2(0.5,0.5)\n#define circleRadius 0.06\n\n#define lineWidth 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //rendered color\n    vec3 col = vec3(1.);\n    \n    //distance between pixel and shapes outlines\n    float d = 99999.;\n    \n    \n    ////finding the values/////\n    \n    //initial values\n    vec2 p = fragCoord;\n    vec2 m = iMouse.xy;\n    if ( m == vec2(0.) ) m = vec2( 0.5, 0.5 + cos(iTime)*0.1 ) * iResolution.xy;\n    vec2 ro         = camPos       * iResolution.xy;\n    vec2 pos        = circlePos    * iResolution.xy;\n    float circleRad = circleRadius * iResolution.y;\n    \n    //direction between mouse and origin\n    vec2  rd   = normalize(m - ro);\n    \n    //some values used to find the \"hidden\" circle\n    //(invert offset2 to intersect from inside)\n    float cw2     = coneWidth * coneWidth;\n    vec2  offset2 = rd * circleRad / coneWidth;\n    vec2  sr      = pos - ro + offset2;\n    float len2    = length(sr);\n    vec2  rd2     = sr / len2;\n    float dist    = len2 / (1. - cw2);\n    \n    //coordinates of the hidden circle,\n    //on which the collision actually occurs\n    float rad  = dist * coneWidth;\n    vec2 pos2  = ro + rd2 * dist - offset2;\n\n    //ray-circle intersection\n    //https://www.shadertoy.com/view/4d2XWV\n    vec2 oc = ro - pos2;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = sqrt(b*b - c);\n    float tN = - b - h;\n    float tF = - b + h;\n    \n    ////drawing the shapes/////\n \n    //drawing the starting point\n    d = min(d, circleFillDist(p, ro, 2.5));\n    \n    //drawing the target circle\n    d = min(d, circleFillDist(p, pos, 2.5));\n    d = min(d, circleDist(p, pos, circleRad));\n\n    //drawing the edges of the cone\n    vec2 offset = vec2(rd.y,-rd.x) * coneWidth / sqrt(1.-cw2);\n    d = min(d, segLineDist(p, ro, ro + rd + offset));\n    d = min(d, segLineDist(p, ro, ro + rd - offset));\n\n    //drawing the two resulting circles\n    if ( tN > 0. ) {\n        d = min(d, circleDist(p, ro + rd * tN, coneWidth * tN));\n        d = min(d, circleDist(p, ro + rd * tF, coneWidth * tF));\n        d = min(d, circleFillDist(p, ro + rd * tN, 2.5));\n        d = min(d, circleFillDist(p, ro + rd * tF, 2.5));\n    }\n \n    //distance to color\n    d = smoothLine( d / lineWidth );\n    col = min(col, vec3( d ) );\n \n    //showing \"hidden\" circle and line\n    float d2 = circleDist(p, pos2, rad);\n    d2 = min(d2, segLineDist(p, ro, ro + rd));\n    d2 = smoothLine( d2 / lineWidth );\n    col = min(col, vec3( mix(d2,1.,0.9) ) );\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "float circleDist(vec2 pos, vec2 pt, float radius) {\n    return abs(length(pos-pt) - radius);\n}\nfloat circleFillDist(vec2 pos, vec2 pt, float radius) {\n    return max(length(pos-pt) - radius, 0.);\n}\nfloat segLineDist(vec2 pos, vec2 a, vec2 b) {\n    vec2 pa = pos-a, ba = b-a;\n    float h = max( dot(pa,ba) / dot(ba,ba), 0.0);\n    return length( pa - ba*h );\n}\nfloat smoothLine( in float x) {\n    float t = clamp(x , 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dds3RM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 201, 227, 2630]], "test": "untested"}
{"id": "stVfR1", "name": "Isle of Eight", "author": "ruudhelderman", "description": "Tiny race track in nave perspective view. No ray marching, no lighting, no anti-aliasing, no motion blur. Very flat, very fast, very retro.", "tags": ["retro", "perspective", "race"], "likes": 16, "viewed": 375, "published": 3, "date": "1665919932", "time_retrieved": "2024-07-30T16:26:04.262838", "image_code": "// \"Isle of Eight\" https://www.shadertoy.com/view/stVfR1\n// Copyright 2022 Ruud Helderman\n// MIT License\n\nconst float speed = 0.4;\nconst float hang = -1.0;\nconst float height_cam = 0.01;\nconst float height_ceiling = 0.03;\nconst float fence_sqradius = 1.0375;\nconst float wall_sqradius = 0.25;\nconst float wall_thick = 0.03;\n\nconst vec4 dark = vec4(0.7, 0.7, 0.7, 1);\nconst vec4 reflection = vec4(0, 0, 0, 0.2);\n\n#define BLEND(c1, c2) ((c1).a < 1.0 ? mix((c2), vec4((c1).rgb, 1), (c1).a) : (c1))\n\nvec2 pmul(vec2 a, vec2 b)    // perpendicular multiply\n{\n    return vec2(dot(a, b), a.x * b.y - a.y * b.x);\n}\n\nvec2 perspective(vec2 uv, float h)\n{\n    return vec2(1, uv.x) * h / uv.y;\n}\n\nfloat area(vec2 coord)\n{\n    vec2 sqr = coord * coord;\n    return min(abs(sqr.x + sqr.y - 1.0), abs(sqr.y + sqr.x * (sqr.x - 1.0))) * 40.0 - 1.0;\n}\n\nbool fence(vec2 fpos)\n{\n    fpos.x = sin(45.0 * fpos.x);\n    fpos.y *= 180.0;\n    fpos *= fpos * fpos;\n    return abs(dot(fpos, fpos) - 1.9) < 1.0;\n}\n\nbool ceiling(vec2 coord)\n{\n    return abs(dot(coord, coord) - wall_sqradius) < wall_thick;\n}\n\nfloat shadow(vec2 coord)\n{\n    return ceiling(coord) ? 0.8 : 1.0;\n}\n\nbool wall(vec2 fpos)\n{\n    fpos.x = cos(fpos.x * 2.0);\n    fpos.y *= 0.54 / height_ceiling;\n    fpos *= fpos * fpos;\n    return abs(dot(fpos, fpos) - 1.02) < 1.0;\n}\n\nvec3 road_color(float a)\n{\n    return a > 0.2 ? vec3(a, 1, 0) * 0.5 : vec3(abs(a) > 0.1 ? 0.5 : 0.8);\n}\n\nvec4 earth(vec2 uv, vec2 dir, float height, vec2 path)\n{\n    vec2 coord = path + pmul(perspective(uv, -height), dir);\n    vec3 n = texture(iChannel0, coord).rgb * 0.2;\n    float a = area(coord);\n    return a < 0.6 + n.r\n        ? vec4((road_color(a) + n) * shadow(coord), 1)\n        : reflection;\n}\n\nvec4 sky(vec2 uv, vec2 dir)\n{\n    return vec4(1.0 - texture(iChannel2, normalize(vec3(pmul(vec2(uv.x, -1), dir), uv.y).xzy)).rg, 1, 1);\n}\n\nvec2 circle_wall(vec2 uv, vec2 dir, float height, vec2 path, vec2 c, float sqradius, float side)\n{\n    float b = path.x * (path.x * path.x + 2.0 * uv.x * c.x * c.x * c.x);\n    vec2 a = pmul(c, vec2(1, uv.x));\n    float m = dot(a, a);\n    float d = sqradius * m - b * b;\n    if (d > 0.0)\n    {\n        vec2 coord = pmul(a, vec2(side * sqrt(d), b)) / m;\n        float dist = dot(coord - path, dir);\n        if (dist > 0.0)\n        {\n            return vec2(atan(coord.y, coord.x), uv.y * dist + height);\n        }\n    }\n    return vec2(0);\n}\n\nvec4 walls_and_beyond(vec2 uv, vec2 dir, float height, vec2 path, vec2 c)\n{\n    // outer wall of entrance\n    vec2 fpos = circle_wall(uv, dir, height, path, c, wall_sqradius + wall_thick, -1.0);\n    if (fpos.y > 0.0 && wall(fpos))\n    {\n        return texture(iChannel0, fpos);\n    }\n    // inner wall of entrance\n    fpos = circle_wall(uv, dir, height, path, c, wall_sqradius - wall_thick, -1.0);\n    if (fpos.y > 0.0 && fpos.y < height_ceiling && wall(fpos))\n    {\n        return dark * texture(iChannel0, fpos);\n    }\n    // inner wall of exit\n    fpos = circle_wall(uv, dir, height, path, c, wall_sqradius - wall_thick, 1.0);\n    if (fpos.y > 0.0 && wall(fpos))\n    {\n        return texture(iChannel0, fpos);\n    }\n    // ceiling\n    vec2 p = perspective(uv, height_ceiling - height);\n    if (p.x > 0.0)\n    {\n        vec2 coord = path + pmul(p, dir);\n        if (ceiling(coord))\n        {\n            return dark * texture(iChannel0, coord);\n        }\n    }\n    // outer wall of exit\n    fpos = circle_wall(uv, dir, height, path, c, wall_sqradius + wall_thick, 1.0);\n    if (fpos.y > 0.0 && wall(fpos))\n    {\n        return dark * texture(iChannel0, fpos);\n    }\n    // fence\n    fpos = circle_wall(uv, dir, height, path, c, fence_sqradius, 1.0);\n    return fpos.y > 0.0 && fence(fpos)\n        ? texture(iChannel1, fpos)\n        : uv.y > 0.0 ? sky(uv, dir) : earth(uv, dir, height, path);\n}\n\nvec4 with_reflection(vec2 uv, vec2 dir, vec2 path, vec2 c)\n{\n    vec4 color = walls_and_beyond(uv, dir, height_cam, path, c);\n    return BLEND(color, walls_and_beyond(vec2(uv.x, -uv.y), dir, -height_cam, path, c));\n}\n\nbool revs(vec2 u, float v)\n{\n    return abs(u.x) < 0.1 && u.y > 0.0 && u.y < v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * speed;\n    float c = cos(t), s = sin(t);\n    \n    vec2 path = vec2(s, s * c);\n    vec2 velocity = vec2(c, 2.0 * c * c - 1.0);\n    vec2 direction = normalize(velocity);\n    vec2 dash = fragCoord / iResolution.xy * 5.0;\n    vec2 tilt = normalize(vec2(1, hang * speed * dot(direction, vec2(-4.0 * path.y, path.x))));\n    vec2 uv = pmul(tilt, (fragCoord - 0.5 * iResolution.xy) / iResolution.y);\n    \n    fragColor = revs(dash - 0.25, length(velocity))\n            ? vec4(dash.y, 2.0 - dash.y, 0, 1)\n            : with_reflection(uv, direction, path, velocity);\n}\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29834, "src": "https://soundcloud.com/advanced-sport-touring/racing-from-bike-25sec", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVfR1.jpg", "access": "api", "license": "mit", "functions": [[496, 496, 552, 552, 605], [607, 607, 643, 643, 682], [684, 684, 708, 708, 831], [833, 833, 856, 856, 982], [984, 984, 1010, 1010, 1076], [1078, 1078, 1104, 1104, 1145], [1147, 1147, 1169, 1169, 1311], [1313, 1313, 1339, 1339, 1416], [1418, 1418, 1474, 1474, 1716], [1718, 1718, 1747, 1747, 1855], [1857, 1857, 1955, 1955, 2396], [2398, 2398, 2473, 2503, 3793], [3795, 3795, 3855, 3855, 4011], [4013, 4013, 4041, 4041, 4094], [4096, 4096, 4153, 4153, 4735]], "test": "untested"}
{"id": "DdXGWn", "name": "Looping Hilbertian Saltation", "author": "dr2", "description": "Closed-path generalization of \"Hilbertian Saltation\"", "tags": ["hilbert", "jump", "path"], "likes": 17, "viewed": 267, "published": 3, "date": "1665912722", "time_retrieved": "2024-07-30T16:26:05.202326", "image_code": "// \"Looping Hilbertian Saltation\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nvec3 HsvToRgb (vec3 c);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val);\n\nconst int nBall = 41;\nvec3 bPos[nBall], ltDir, ltDirS, qHit;\nvec2 gId, gIdL;\nfloat tCur, dstFar, gSize, bSize, hInd, vDirI, vDirO, cHt, cRad, bRad, vFac, bAng[nBall], iQuad;\nint idObj, ballNum;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\n// Hilbert indexing - without bit ops (from \"Hilbert's Path\")\n\nint LoBit (int x)\n{\n  return x - 2 * (x / 2);\n}\n\nint FlipLoBit (int x)\n{\n  return 4 * (x / 2) - x + 1;\n}\n\nconst int maxBits = 7;\n\nint HilXy2D (ivec2 p, int n)\n{\n  ivec2 r;\n  int j, td, d;\n  d = 0;\n  td = 1;\n  j = n / 2;\n  for (int b = 0; b < maxBits - 1; b ++) {\n    td *= 2;\n    j /= 2;\n    if (j == 1) break;\n  }\n  j = n / 2;\n  for (int b = 0; b < maxBits - 1; b ++) {\n    r = ivec2 (LoBit (p.x / td), LoBit (p.y / td));\n    d += j * j * ((r.y == 0) ? 3 * r.x : FlipLoBit (3 * r.x));\n    if (r.y == 0) {\n      if (r.x == 1) p = n - 1 - p;\n      p = p.yx;\n    }\n    td /= 2;\n    j /= 2;\n    if (j == 0) break;\n  }\n  return d;\n}\n\nivec2 HilD2Xy (int d, int n)\n{\n  ivec2 p, r;\n  int j, td;\n  td = d;\n  p = ivec2 (0);\n  j = 1;\n  for (int b = 0; b < maxBits; b ++) {\n    r.x = LoBit (td / 2);\n    r.y = LoBit ((r.x == 0) ? td : FlipLoBit (td));\n    if (r.y == 0) {\n      if (r.x == 1) p = j - 1 - p;\n      p = p.yx;\n    }\n    p += j * r;\n    td /= 4;\n    j *= 2;\n    if (j == n) break;\n  }\n  return p;\n}\n\n#define HT(v) (2.5 - 2. * Maxv2 (abs (v - bSize + 0.5)) / bSize)\n\nvoid SetGParm ()\n{\n  vec2 dq, gIdLL;\n  int ic, ib;\n  ib = int (bSize);\n  gIdL = gId;\n  iQuad = 0.;\n  if (gIdL.x >= bSize) {\n    gIdL.x -= bSize;\n    iQuad += 1.;\n  }\n  if (gIdL.y >= bSize) {\n    gIdL.y -= bSize;\n    iQuad += 2.;\n  }\n  gIdLL = gIdL;\n  if (iQuad < 2.) gIdLL.y = bSize - 1. - gIdLL.y;\n  ic = HilXy2D (ivec2 (gIdLL), ib);\n  hInd = float (ic);\n  cHt = HT (gId);\n  if (ic > 0) {\n    dq = gIdLL - vec2 (HilD2Xy (ic - 1, ib));\n    vDirI = (dq.y == 0.) ? ((dq.x > 0.) ? 0. : 2.) : ((dq.y > 0.) ? 1. : 3.);\n  } else {\n    vDirI = (abs (iQuad - 1.) == 1.) ? 1. : 0.;\n  }\n  if (ic < ib * ib - 1) {\n    dq = vec2 (HilD2Xy (ic + 1, ib)) - gIdLL;\n    vDirO = (dq.y == 0.) ? ((dq.x > 0.) ? 0. : 2.) : ((dq.y > 0.) ? 1. : 3.);\n  } else {\n    vDirO = (abs (iQuad - 1.) == 1.) ? 0. : 3.;\n  }\n}\n\nfloat GObjDf (vec3 p)\n{\n  vec3 q, qq;\n  vec2 b, r;\n  float dMin, d;\n  dMin = dstFar;\n  r = vec2 (0.06, 0.05);\n  if (Minv2 (gIdL) >= 0. && Maxv2 (gIdL) < bSize) {\n    q = p;\n    if (abs (iQuad - 2.) == 1.) q.x -= bSize;\n    if (iQuad >= 2.) q.z -= bSize;\n    q.xz -= gSize * (gIdL + 0.5);\n    if (iQuad < 2.) q.z *= -1.;\n    qq = q;\n    qq.y -= r.y + 0.02;\n    q.y -= 0.5 * cHt;\n    d = PrRoundCylDf (vec3 (abs (q.xz) - 0.6 * cRad, q.y), 0.07 * cRad, 0.01, 0.5 * cHt);\n    DMINQ (1);\n    q.y -= 0.5 * cHt + 0.1;\n    d = PrRoundCylDf (q.xzy, cRad - 0.02, 0.02, 0.1);\n    DMINQ (2);\n    if (vDirI >= 0.) {\n      q = qq;\n      if (vDirI > 0.) q.xz = vec2 (-1., 1.) * ((vDirI == 2.) ? q.xz : q.zx *\n         sign (vDirI - 2.));\n      d = max (PrRoundBox2Df (q.zy, r, 0.02), q.x + cRad);\n      DMINQ (3);\n    }\n    if (vDirO >= 0.) {\n      q = qq;\n      if (vDirO > 0.) q.xz = vec2 (-1., 1.) * ((vDirO == 2.) ? q.xz : q.zx *\n         sign (vDirO - 2.));\n      d = max (PrRoundBox2Df (q.zy, r, 0.02), - q.x + cRad);\n      DMINQ (3);\n    }\n    q = qq;\n    if (vDirI == vDirO) {\n      if (vDirI == 0. || vDirI == 2.) q.xz = q.zx;\n      d = PrRoundBox2Df (q.xy, r, 0.02);\n    } else if (vDirI != vDirO) {\n      d = max (abs (q.x) - cRad, abs (q.z) - cRad);\n      b = vec2 (1.);\n      if (vDirI == 1. && vDirO == 0. || vDirI == 2. && vDirO == 3.) b.x = -1.;\n      else if (vDirI == 0. && vDirO == 1. || vDirI == 3. && vDirO == 2.) b.y = -1.;\n      else if (vDirI == 2. && vDirO == 1. || vDirI == 3. && vDirO == 0.) b = vec2 (-1.);\n      q.xz += cRad * b;\n      d = max (d, PrRoundBox2Df (vec2 (length (q.xz) - cRad, q.y), r, 0.02));\n    }\n    DMINQ (4);\n  }\n  return dMin;\n}\n\nfloat GObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  vec2 gIdP;\n  float dHit, d, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  rdi.xz = 1. / rd.xz;\n  gIdP = vec2 (-999.);\n  eps = 0.005;\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    gId = floor (p.xz / gSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGParm ();\n    }\n    d = GObjDf (p);\n    dHit += min (d, eps + max (0., Minv2 ((gSize * (gId + step (0., rd.xz)) - p.xz) * rdi.xz)));\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 GObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvoid BPos ()\n{\n  vec3 bp[2];\n  vec2 bs;\n  float tc, t, bb;\n  bb = bSize * bSize;\n  for (int k = VAR_ZERO; k < nBall; k ++) {\n    tc = vFac * tCur + (float (k) / float (nBall)) * 4. * bb;\n    for (int j = 0; j < 2; j ++) {\n      t = mod (tc + float (j), 4. * bb);\n      bs = sign (vec2 (abs (t - 2. * bb) - bb, t - 2. * bb));\n      bp[j].xz = bs * (vec2 (HilD2Xy (int (mod ((sign (0.5 - (abs (bs.x - bs.y)))) *\n         mod (t, bb), bb)), int (bSize))) + 0.5) + bSize;\n      bp[j].y = HT (bp[j].xz - 0.5);\n    }\n    t = clamp (1.3 * fract (tc) - 0.15, 0., 1.);\n    bPos[k] = mix (bp[0], bp[1], t);\n    bPos[k].y += bRad + 0.2 + 3. * t * (1. - t);\n  }\n}\n\nvec4 BallHit (vec3 ro, vec3 rd)\n{\n  vec3 u, vn;\n  float dMin, d, b, w;\n  dMin = dstFar;\n  for (int k = VAR_ZERO; k < nBall; k ++) {\n    u = ro - bPos[k];\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + bRad * bRad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vn = (u + d * rd) / bRad;\n        ballNum = k;\n      }\n    }\n  }\n  return vec4 (dMin, vn);\n} \n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  q -= vec3 (vec2 (bSize), -0.1).xzy;\n  d = PrRoundBoxDf (q, vec3 (vec2 (bSize), 0.1).xzy - 0.01, 0.01);\n  DMINQ (5);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BlkHitSil (vec3 ro, vec3 rd, vec3 sz)\n{\n  vec3 v, tm, tp;\n  float dn, df;\n  v = ro / rd;\n  tp = sz / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  return (df > 0. && dn < df) ? dn : dstFar;\n}\n\nvec3 BallCol (int k)\n{\n  return HsvToRgb (vec3 (fract (4. * float (k) / float (nBall)), 0.8, 0.9));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, db4;\n  vec3 col, vn, qHitG, bsSize;\n  vec2 b;\n  float dstObj, dstObjG, db, s, pFac, hi, nDotL;\n  int idObjG;\n  vFac = 0.5;\n  bRad = 0.2;\n  bsSize = vec3 (bSize + 0.1, 1.8, bSize + 0.1);\n  db = BlkHitSil (ro - vec3 (bsSize.xz, 1.6).xzy, rd, bsSize);\n  if (db < dstFar) {\n    dstObjG = GObjRay (ro, rd);\n    idObjG = idObj;\n    qHitG = qHit;\n  } else dstObjG = db;\n  BPos ();\n  if (db < dstFar) db4 = BallHit (ro, rd);\n  else db4.x = dstFar;\n  dstObj = (db < dstFar) ? ObjRay (ro, rd) : dstFar;\n  if (dstObjG < min (dstObj, dstFar)) {\n    dstObj = dstObjG;\n    idObj = idObjG;\n    qHit = qHitG;\n  }\n  if (min (dstObj, db4.x) < dstFar) {\n    if (db4.x < dstObj) {\n      dstObj = db4.x;\n      idObj = 6 + ballNum;\n    }\n    ro += dstObj * rd;\n    vn = (dstObj == dstObjG) ? GObjNf (ro) : ((idObj < 6) ? ObjNf (ro) : db4.yzw);\n    nDotL = max (dot (vn, ltDir), 0.);\n    pFac = 16.;\n    if (idObj == 1) {\n      col4 = vec4 (0.9, 0.9, 0.95, 0.1) * (0.85 + 0.15 * sin (32. * pi * qHit.y));\n    } else if (idObj == 2) {\n      col4 = vec4 (0.9, 0.9, 0.9, 0.1);\n      b = qHit.xz;\n      if (length (b) < cRad - 0.01) {\n        for (int k = VAR_ZERO; k < nBall; k ++) {\n          s = length (ro.xz - bPos[k].xz);\n          if (s < bRad) {\n            col4.rgb = mix (BallCol (k), col4.rgb, 0.2 + 0.8 * smoothstep (0.5, 1., s /\n               (bRad - 0.15 * min (bPos[k].y - (cHt + bRad + 0.2), 0.75))));\n            break;\n          }\n        }\n      } else {\n        hi = hInd + iQuad * bSize * bSize;\n        if (iQuad < 2.) {\n          b.y *= -1.;\n          hi = 2. * bSize * bSize - 1. - hi; \n        }\n        b = Rot2D (b, - 0.5 * pi * tCur);\n        col4 = mix (0.9 * col4, vec4 (1., 1., 1., -1.), smoothstep (0.05, 0.1,\n           ShowIntPZ (vec2 (-0.8 * fract (3. * atan (b.y, - b.x) / (2. * pi)), qHit.y + 0.07),\n           0.7 * vec2 (0.5, 0.2), 3., hi + 1.)));\n      }\n    } else if (idObj == 3) {\n      b = qHit.xz;\n    } else if (idObj == 4) {\n      if (vDirI == vDirO) {\n        b = qHit.zx;\n        if (vDirI >= 2.) b.x = - b.x;\n      } else {\n        b = vec2 (atan (qHit.z, qHit.x) / pi + 1. / pFac, length (qHit.xz) - cRad);\n        if (vDirI == 0. && vDirO == 3. || vDirI == 1. && vDirO == 0.) b.x = - b.x;\n        else if (vDirI == 2. && vDirO == 1. || vDirI == 3. && vDirO == 2.) b.x = - b.x;\n      }\n    } else if (idObj == 5) {\n      col4 = vec4 (0.4, 0.2, 0.1, 0.1) * (0.8 + 0.2 * smoothstep (0., 0.02,\n         0.5 - Maxv2 (abs (fract (ro.xz) - 0.5)))) * (0.7 + 0.3 * smoothstep (0.02, 0.05,\n         length (abs (fract (ro.xz) - 0.5) - 0.6 * cRad) - 0.07 * cRad));\n    } else if (idObj >= 6) {\n      col4 = vec4 (BallCol (idObj - 6), 0.15);\n      nDotL *= nDotL;\n    }\n    if (idObj == 3 || idObj == 4) {\n      col4 = vec4 (0.8, 0.85, 0.8, 0.1);\n      s = (iQuad < 2.) ? pFac * (b.x + vFac * tCur) + 1. : pFac * (b.x - vFac * tCur);\n      if (abs (b.y) < 0.05) col4 = mix (0.9 * col4, vec4 (1., 1., 1., -1.), \n         smoothstep (-0.05, 0.05, sin (pi * s)));\n    }\n    if (col4.a >= 0.) col = col4.rgb * (0.3 + 0.7 * nDotL) +\n       col4.a * (pow (max (dot (ltDir, reflect (rd, vn)), 0.), 64.) +\n       pow (max (dot (ltDirS, reflect (rd, vn)), 0.), 64.));\n    else col = col4.rgb * (0.5 + 0.5 * max (dot (-rd, vn), 0.));\n  } else {\n    col = vec3 (0.8, 0.8, 1.) * (0.2 + 0.2 * (rd.y + 1.) * (rd.y + 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = -0.45 * pi;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  el = clamp (el, -0.5 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  gSize = 1.;\n  bSize = 4.;\n  cRad = 1. / pi;\n  ro = vuMat * vec3 (0., 0.2, -4. * bSize);\n  ro.xz += bSize;\n  zmFac = 3.5;\n  dstFar = 120.;\n  ltDir = normalize (vec3 (0.7, 1., -1.));\n  ltDirS = ltDir;\n  ltDirS.xz = Rot2D (ltDirS.xz, 0.2 * pi);\n  ltDir = vuMat * ltDir;\n  ltDirS = vuMat * ltDirS;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (Minv2 (q) >= 0. && Maxv2 (q) < 1.) {\n    q.x *= mxChar;\n    nDig = mxChar;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = max (val, 0.) / pow (10., mxChar - idChar - 1.);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdXGWn.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[989, 989, 1008, 1008, 1036], [1038, 1038, 1061, 1061, 1093], [1119, 1119, 1149, 1149, 1617], [1619, 1619, 1649, 1649, 1988], [2056, 2056, 2074, 2074, 2847], [2849, 2849, 2872, 2872, 4512], [4514, 4514, 4548, 4548, 5113], [5115, 5115, 5137, 5137, 5393], [6048, 6048, 6081, 6081, 6459], [6462, 6462, 6484, 6484, 6672], [6674, 6674, 6707, 6707, 6891], [6893, 6893, 6914, 6914, 7169], [7171, 7171, 7216, 7216, 7398], [7400, 7400, 7422, 7422, 7501], [7503, 7503, 7538, 7538, 10909], [10911, 10911, 10967, 10967, 12155], [12157, 12157, 12203, 12203, 12250], [12252, 12252, 12299, 12299, 12346], [12348, 12348, 12405, 12405, 12481], [12483, 12483, 12507, 12507, 12629], [12631, 12631, 12653, 12653, 12680], [12682, 12682, 12704, 12704, 12731], [12733, 12733, 12755, 12755, 12793], [12795, 12795, 12817, 12817, 12855], [12857, 12857, 12893, 12893, 13099], [13101, 13101, 13131, 13131, 13244], [13246, 13246, 13269, 13269, 13371], [13444, 13444, 13476, 13476, 14018], [14020, 14020, 14082, 14082, 14449]], "test": "untested"}
{"id": "dsl3zM", "name": "Acid Hieroglyphs", "author": "jarble", "description": "A series of strange-looking glyphs.", "tags": ["2d", "hexagon", "rainbow", "pattern", "everyday", "hieroglyphs"], "likes": 3, "viewed": 236, "published": 3, "date": "1665887699", "time_retrieved": "2024-07-30T16:26:05.960300", "image_code": "// Code by Flopine (modified by jarble)\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU (2.*PI)\n#define hr vec2(1.,sqrt(3.))\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define hd(u, s) (max(abs(u.x), dot(abs(u), normalize(hr)))-s)\n#define circle(u,s) (length(u)-s)\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(0.02,fwidth(val-thre)))\n\n#define palette(t,c,d) (vec3(0.5)+vec3(0.5)*cos(TAU*(c*t+d)) )\n\n#define noise(u) textureLod(iChannel0, u, 0.).x\n\n\nfloat moda(inout vec2 p, float rep)\n{\n    float per = TAU/rep;\n    float a = atan(p.y,p.x);\n    float c = floor(a/per)+floor(iTime*8.);\n    a = mod(a,per/(1.+p.x))-per*.5;\n    if (abs(c) >= (rep*.5)) c = abs(c);\n    p = vec2(cos(a), sin(a))*length(p);\n    return c;\n}\n\nvec4 hexgrid (vec2 uv)\n{\n    vec2 ga=mod(uv,hr)-hr*.5, gb=mod(uv-hr*.5,hr)-hr*.5, \n    guv=dot(ga,ga)<dot(gb,gb)?ga:gb, gid=uv-guv;\n    return vec4(guv,gid);\n}\n\nvec3 frame (vec2 uv)\n{\n    vec4 hg = hexgrid(uv);\n    vec2 uu = hg.xy, uid = hg.zw;    \n    float uswi = noise(uid*.25);\n    \n    float h = 1.;\n    \n    float aid = moda(uu, 6.);  \n    h *= AAstep(0.001, abs(uu.y)-0.01);\n    \n    if (uswi <.5)\n    {\n        uu.x -= 0.5;\n        h *= AAstep( 0.02, abs(circle(uu, 0.25)) );\n    }\n\n    h *= AAstep( 0.02, abs(circle(uu, 0.35)) ); \n    uu.x -= 0.435;\n    h *= AAstep(0.001, abs(uu.x)-0.01);\n    \n    return mix(palette(aid+mod(uid.x*uid.y, 2.), vec3(.1), vec3(0.3,0.8,0.1)), vec3(0.),  h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    uv.y += iTime*.3;\n    uv *= 2.;\n    \n    vec3 col = frame(uv);\n\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define fmod(x,y) mod(floor(x),y)\n#define floor1(x) fmod((x)*2.,2.)*floor(x)\n#define fmod1(x,y) mod(floor1(x),y)\n\nvec2 mainSound(int samp, float time){\n  \n  float s1 =\n      4.,\n      //5./(1.+fmod(time/2.,2.)), //varying tempo\n\n  s2 = 8.,\n  t= //varying tempo\n      //time\n      time*(2.-fmod(time/s1+floor1(time),2.))/2.\n      //time/(1.+fmod(time*s1,2.))\n      //time/(1.+fmod(time/s1+floor(time*s1),2.))\n      //time/(1.+fmod(time*s1+floor(time),2.))\n      //time*(1.+fmod(time*s1,2.))/2.\n  ,\n  m1 =\n      fmod1(t*s2/2.,s2)\n      //fmod(t/s1+floor(t*s1),s2)\n      //fmod(t*s1+floor(t/s1),s2)\n  ,\n  //m4 = fmod(t*s1,s1),\n  m3 =\n      fmod(-t/(m1+.5),s2);\n      //fmod(t*(s1+m4)/(m1+.5),s2);\n      //fmod((t+m1)*s1/(m4+.5),s2);\n      //fmod(t*s1/abs(2.5-m1),s2);\n  \n  //m1 = fmod(t/s1,s2),\n  \n  //t += m3/2.;\n  t *= s1;\n  t /=  //varying tempo\n      (1.+fmod((-t+floor(t))/2.,2.))\n      //(1.+fmod((t/s1-floor(t/s1))/2.,2.))\n      //(1.+fmod(t/s1+floor(t*s1),2.))\n  ;\n  \n  \n    float m2 =\n      1. + fmod(t,s1)\n      //1. + fmod(t/s1,8./(1.+fmod(t/s1,2.)))\n      //1. + fmod(t/s1,s1/2.)*fmod(t/s1/2.,s1/2.)\n      //1. + min(fmod(time,s1),t)\n  ;\n  //t /= max(m2,m1+m3+1.);\n  \n  float a=\n      32.*(sqrt(1.-sqrt(fract(t)/1.25)))*.2\n      //(pow(1.-fract(t/s1)/1.25,2.))*.2\n  ,\n  \n\n  \n  nb = time*pow(2.,(m3+m2)/7.+6.5);\n\n  return abs(.5-vec2(fract(nb*.998)\n   ,fract(nb)))*a;\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsl3zM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[808, 808, 845, 845, 1075], [1077, 1077, 1101, 1101, 1236], [1238, 1238, 1260, 1260, 1776], [1778, 1778, 1835, 1835, 2006]], "test": "untested"}
{"id": "cssGRM", "name": "Water Tunnel", "author": "wyatt", "description": "path tracer", "tags": ["tunnel"], "likes": 17, "viewed": 446, "published": 3, "date": "1665870046", "time_retrieved": "2024-07-30T16:26:06.739217", "image_code": "Main {\n    Q = A(U)/float(iFrame);\n\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U))\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage (out vec4 Q, in vec2 U)\n#define ei(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nvec3 hash(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}", "buffer_a_code": "Main {\n    Q = vec4(0);\n    for (float x = -20.; x < 20.; x++)\n       Q += .5*exp(-x*x/8./8.)*(A(U+vec2(x,0))*2.-1.);\n\n}", "buffer_a_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    Q = vec4(.3);\n    for (float x = -20.; x < 20.; x++)\n       Q += .002*exp(-x*x/8./8.)*A(U+vec2(0,x));\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "bool ignore_water;\nfloat map (vec3 p, inout float s, inout vec4 Q) {\n    \n    float r = 1e9;\n    Q = vec4(0);\n    s = 0.;\n    float h = p.y+.5*texture(iChannel2,.2*p.xz*600./R.x+0.5).x;\n        \n    { //tunnel\n        vec3 pt = p;\n        pt.x += .5*cos(pt.z);\n        vec2 uv = vec2(pt.z-.5,atan(pt.y,pt.x))*.5/3.14159;\n        vec4 c = B(uv);\n        pt.xy += .03*pt.xy*c.x;\n        float rt = 1.-length(pt.xy);\n        if (rt < r) {\n            r = rt;\n            Q = c;\n            s = .2;\n            if (h < 0.) s = 1.;\n            \n        }\n    }\n    { // light\n        vec3 pl = p;\n        pl.x += .5*cos(pl.z);\n        float rl = min(\n            length(pl.xy-vec2(.1,.8))-.02,\n            length(pl.xy-vec2(-.1,.8))-.02\n        );\n        if (rl < r) {\n            r = rl;\n            Q = vec4(6)+5.*sin(vec4(1,2,3,4)+pl.z);\n            s = 1.;\n        }\n    }\n    if (!ignore_water) { // water\n        h = abs(h)-.03;\n        if (h < r) {\n            r = h;\n            Q = vec4(.4,.8,1,1);\n            s = 0.;\n        }\n    }\n  \n    return r;\n}\nvec3 normal (vec3 p) {\n    vec2 e = vec2(1e-2,0);\n    float s = 0.; vec4 q = vec4(0);\n    return normalize(vec3(\n        map(p+e.xyy,s,q)-map(p-e.xyy,s,q),\n        map(p+e.yxy,s,q)-map(p-e.yxy,s,q),\n        map(p+e.yyx,s,q)-map(p-e.yyx,s,q)\n    ));\n}\nvoid scene (inout vec3 p, inout vec3 d, inout vec4 Q, float b) {\n    float r = 0.,s = 0.; vec3 n = vec3(0,0,1);\n    vec3 p0 = p; vec4 q = Q;\n    for (float i = 0.; i < 200.; i++)\n    {\n        r = map(p,s,q);\n        p += d*r;\n    }\n    n = normal(p);\n    if (s > 0.) {\n        d = reflect(d,n);\n        vec3 h = hash(vec2(b,iFrame));\n        h.xy = s*h.x*vec2(cos(6.28318530718*h.y),sin(6.28318530718*h.y));\n    \n        vec3 u = cross(d,vec3(1,0,0));\n        if (length(u)<.9) u = cross(d,vec3(0,1,0));\n        vec3 v = cross(d,u);\n        \n        d = normalize(d+u*h.x+v*h.y);\n        \n        Q *= q;\n    } else {\n        if (hash(vec2(3.+b,iTime)).x<.5) {\n            d = reflect(d,n);\n            Q *= q;\n        } else \n        { \n            d = refract(d,n,.5);\n        }\n    }\n    if (s == 0.) ignore_water = true;\n    else ignore_water = false;\n    p += 1e-3*d;\n}\n\n\nMain {\n    vec2 u = 2.*(U-.5*R)/R.y;\n    vec2 h = hash(vec2(iFrame,iTime)).xy;\n    h = sqrt(h.x)*vec2(cos(6.28318530718*h.y),sin(6.28318530718*h.y));\n    vec3 p = vec3(.4*u-.0*h-vec2(.1,0.),0);\n    vec3 d = normalize(vec3(u+.01*h,2));\n    Q = vec4(1);\n    ignore_water = false;\n    scene(p,d,Q,0.);\n    scene(p,d,Q,1.);\n    scene(p,d,Q,2.);\n    scene(p,d,Q,3.);\n    Q += A(U);\n}", "buffer_c_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cssGRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "msl3RN", "name": "Please Sin In", "author": "derSchamane", "description": "Just a little sketch created by experimenting with my raymarcher and lighting, but worth sharing.\nIf you have performance issues (most likely on fullscreen) deactivate AA at line 22.\nDrag mouse for camera movement. Enjoy\n\n\nSubstance Reference: 3-HO-PCP", "tags": ["3d", "raymarching", "waves", "sin", "sphere", "mk3drmb"], "likes": 20, "viewed": 320, "published": 3, "date": "1665846398", "time_retrieved": "2024-07-30T16:26:07.495196", "image_code": "//                      = Please Sin In =         \n//                by Maximilian Knape >| 2022            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n#define GAMMA vec3(.4545)\n\n#define MAX_STEPS 200\n#define STEP_FAC 0.8\n#define MAX_DIST 160.\n#define MIN_DIST 10.\n\n#define SURF_DIST .001\n#define SURF_MUL 100.\n#define SURF_EXP 5.\n\n#define GLOW_INT 1.0\n#define PP_CONT 0.5\n#define PP_VIGN 1.5\n\n#define AA_ENAB true\n#define AA_THRE .05\n\n\n#define iTime iTime*1.0\n#define PI 3.14159265358979\n#define S(x,y,t) smoothstep(x,y,t)\n\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 Map(vec3 p) \n{    \n    float d, col, t = mod(iTime, 2.*PI);\n    \n    float l = length(p.xz);\n    float k = pow(l,.8);\n    \n    d = max( p.y + \n             sin(-t + k) * 1.5 + \n             sin(t + k*1000./max(18., k*k)) * 0.5 + \n             l*l/-500., 0.) * \n        \n        (S(1., 50., l)*.25+.1);\n    \n\n    float sphere = (length(p - vec3(0., (sin(t-PI*.3)*.5+.5)*11.-.5, 0.)) - 2.5) *.8; \n    col = sphere < d ? 3.4 : 2.6;    \n    d = min(sphere, d);\n    \n    float drop = length(p - vec3(0., pow(sin(t-PI*.2)*.5+.5, 2.5)*5., 0.)) - .3;\n    col = drop < d ? 2.4 : col;    \n    d = min(drop, d);\n    \n    return vec2(d, col);\n}\n\nvec3 Normal(vec3 p) \n{\n    vec2 e = vec2(.001, 0);\n    return normalize(Map(p).x - vec3(Map(p-e.xyy).x, Map(p-e.yxy).x,Map(p-e.yyx).x));\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) \n{\n    float col = 0.;\n\tfloat dO = MIN_DIST;\n    int steps = 0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {\n        steps = i;\n        \n    \tvec3 p = ro + rd*dO;\n        vec2 dS = Map(p);\n        col = dS.y;\n        dO += dS.x * mix(STEP_FAC, 1., dO/MAX_DIST);\n        \n        if (dO > MAX_DIST || dS.x < (SURF_DIST * (pow(dO/MAX_DIST, SURF_EXP)*SURF_MUL+1.))) break;\n    }\n    \n    return vec3(dO, steps, col);\n}\n\nfloat SoftShadow(vec3 ro, vec3 lp, float k) //Shane\n{\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro;\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    for (int i = 0; i<maxIterationsShad; i++)\n    {\n\n        float h = Map(ro + rd*dist).x;\n        shade = min(shade, smoothstep(0., 1., k*h/dist));\n        dist += clamp(h, .02, .25);\n        \n        if (h < .0 || dist > end) break;\n    }\n\n    return min(max(shade, 0.) + .0, 1.); \n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) //BigWings\n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 hsv2rgb_smooth( in vec3 c ) //iq\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n    \n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nconst vec3 ambCol = vec3(.01,.02,.03) * 1.0;\nconst vec3 sunCol = vec3(1., .8, .6) * 1.0;\nconst vec3 skyCol = vec3(1., .6, .4) * 0.3;\nconst float specExp = 10.;\n\nvec3 Shade(vec3 col, float mat, vec3 p, vec3 n, vec3 rd, vec3 lP) \n{\n    vec3  lidi = normalize(lP - p);\n    float mafa = max(mat, .0),\n          amoc = 1.,\n          shad = SoftShadow(p + n*.015, lP, 2.),\n          diff = max(dot(n, lidi), 0.) * shad,\n          spec = pow(diff, max(1., specExp * mafa)),\n          refl = pow(max(0., dot(lidi, reflect(rd, n))), max(1., specExp * 3. * mafa)) * shad,\n          indi = 1.-diff;\n    \n    return mix( indi * mix(ambCol, skyCol, .03) * col * amoc +       //ambient\n                diff * col * sunCol * max(1. - mafa, .0) +           //diffuse\n                (spec * col + refl * mafa) * sunCol * mafa,          //specular\n                \n                col  * S(0., 1., amoc * amoc + .5),                  //emission\n                max(-mat, 0.));\n}\n\nvec3 Palette(int index)\n{\n    switch (index)\n    {\n        case 0: return vec3(1., 1., 1.);\n        case 1: return vec3(1., .8, .6);\n        case 2: return vec3(.3, .5, 1.);\n        case 3: return hsv2rgb_smooth(vec3(fract(-iTime/36.), .9, 1.))*3.;\n    }\n    return vec3(0.);\n}\n\nvoid Render( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5 * iResolution.xy) / iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy;\n    if (length(m) <= 0.) m = vec2(.8,.2);\n\n    vec3 ro = vec3(m.x*40.-20., 5., -30.-m.y*30.);\n    ro.yz *= Rot(-(m.y/3.-.42) * PI + PI*.5);\n    vec3 rd = R(uv, ro, vec3(-m.x*20.+10., 8., 0.), 1.);\n    \n    vec3 bg = skyCol;\n    vec3 lPos = vec3(-sin(iTime*PI/10.)*50., sin(iTime*PI/20.)*30.+80., -cos(iTime*PI/10.)*50.);\n    \n    vec3 col = skyCol;\n    vec3 p = vec3(0.);\n    vec3 rmd = RayMarch(ro, rd);\n\n    if(rmd.x < MAX_DIST) \n    {\n        p = ro + rd * rmd.x;\n        vec3 n = Normal(p);\n        \n        float shine = fract(rmd.z)*abs(rmd.z)/rmd.z;\n        col = Palette(int(floor(abs(rmd.z))));\n        col = Shade(col, shine, p, n, rd, lPos);\n    }\n    \n    float disFac = S(0., 1., pow(rmd.x / MAX_DIST, 1.5));\n    \n    col = mix(col, bg, disFac);\n    col += pow(rmd.y / float(MAX_STEPS), 2.) * normalize(ambCol) * GLOW_INT;\n    col += disFac * pow(max(dot(rd, normalize(lPos-ro)), 0.), specExp) * sunCol;\n    \n    fragColor = vec4(col,1.0);\n}\n\nvec4 PP(vec3 col, vec2 uv)\n{\n    col = clamp((col * (2.51f * col + 0.03f)) / (col * (2.43f * col + 0.59f) + 0.14f), 0.0f, 1.0f);\n    col = mix(col, S(vec3(0.), vec3(1.), col), PP_CONT);    \n    col *= S(PP_VIGN,-PP_VIGN/5., dot(uv,uv)); \n    col = pow(col, GAMMA);\n    \n    return vec4(col, 1.);\n}\n\nvoid mainImage(out vec4 O, vec2 U) //Fabrice - easy adaptive super sampling | edited by MK\n{\n    Render(O,U);\n    \n    if (AA_ENAB && fwidth(length(O)) > AA_THRE)\n    {\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { Render(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n        //O.r++; //Show sampled area\n    }\n    \n    O = PP(vec3(O), (U-.5 * iResolution.xy) / iResolution.y);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msl3RN.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[671, 671, 690, 690, 766], [768, 768, 787, 787, 1405], [1407, 1407, 1429, 1429, 1545], [1547, 1547, 1581, 1581, 2000], [2002, 2002, 2055, 2055, 2570], [2572, 2572, 2625, 2625, 2820], [2822, 2822, 2861, 2861, 3022], [3186, 3186, 3254, 3254, 3986], [3988, 3988, 4013, 4013, 4265], [4267, 4267, 4321, 4321, 5377], [5379, 5379, 5407, 5407, 5676], [5678, 5678, 5770, 5770, 6091]], "test": "untested"}
{"id": "NlKfWt", "name": "Extruded Asymmetric Jigsaw", "author": "Shane", "description": "Using a triangle grid to create and raymarch an animated extruded rounded asymmetric hexagon jigsaw pattern in realtime.", "tags": ["raymarching", "grid", "triangle", "jigsaw", "extrude", "asymmetric"], "likes": 46, "viewed": 634, "published": 3, "date": "1665837598", "time_retrieved": "2024-07-30T16:26:08.446652", "image_code": "/*\n\n    Extruded Asymmetric Jigsaw\n    --------------------------\n    \n    This is an animated extruded asymmetric hexagonal jigsaw pattern,\n    created and rendered in realtime.\n    \n    I came up with the idea to do this when investigating ways to extract\n    vertex lists from Voronoi cells within the confines of a pixel shader\n    program, which I managed using half space methods, but it was not fast.\n    \n    I realized later that I could construct a pretty good approximation to \n    hexagonal Voronoi by using packed hexagons with offset vertices -- The \n    added benefit was access to vertex lists. However, as efficient as it \n    was, it wasn't fast enough to raymarch in realtime without resorting to \n    overly complicated backbuffer tricks -- I have an example on Shadertoy\n    somewhere. Thankfully, I stumbled across a really fast way to render \n    extruded asymmetric hexagons when playing around with various patterns \n    on an icosahedral grid and realized it'd work on a flat plane.\n    \n    The process is quite simple: Partition space into equilateral triangles,\n    then render three lines from a randomly offset central point to the \n    random offset central points of each of the neighboring edge triangles.\n    After you've done that, you can use these three lines to construct\n    parts of three offset hexagons -- Uncomment the \"GRID\" define, then \n    refer to the image, if you're having trouble visualizing that. By the \n    way, the same technique can produce packed asymmetic quadrilateral \n    polygons on a square grid.\n    \n    Designwise there's not much to this; Just some 2D rendering on the\n    rounded extruded faces, basic lighting and specular reflection. All of \n    it is simple to implement, and cheap, which always helps. Anyway, I \n    have some icosahedral examples along similar lines that I'll post later.\n    \n\n\n    Other examples:\n    \n    // A regular extruded square jigsaw pattern.\n    Jigsaw - Shane\n    https://www.shadertoy.com/view/XdGBDW\n    \n    // An animated asymmetric hexagon-based random stringy woven \n    // Truchet jigsaw pattern.\n    Animated Hexagon Truchet Chords - Shane\n    https://www.shadertoy.com/view/WsGyDz\n\n\n*/\n\n\n/////////\n\n// Attempting not to unroll loops.\n#define ZERO min(0, iFrame)\n\n// Maximum ray distance.\n#define FAR 10.\n\n// Subtle textured lines.\n#define LINES\n\n// Display the jigsaw pattern, or not.\n#define JIGSAW\n\n// Display the offset triangle grid vertices -- which double as central\n// offset polygon vertices.\n#define SHOW_VERTICES\n\n// Display the offset triangle grid that the jigsaw pieces are constructed from.\n//#define GRID\n\n/////////\n\n\n// Object ID: Either the back plane, extruded object or beacons.\nint objID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's hash.\nfloat hash11(float x){ \n    \n    //return texture(iChannel1, vec2(64)*x).x;\n    return fract(sin(x)*43758.5453); \n}\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ \n    \n    return texture(iChannel1, p/64.).x;\n    //return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); \n}\n\n// IQ's vec2 to float hash.\nvec2 hash21A(vec2 p){  \n    vec4 p4 = texture(iChannel1, p/64.);\n    //p.x = fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); \n    return sin(p4.xy*6.2831 + iTime*(p4.zw - .5)*2.)*.5 + .5;\n}\n\n/*\n// IQ's translation of Hugo Elias's old hash routine and\n// Fabrice Neyret's float-to-uint translation.\nfloat hash11(float f){ \n\n    uint n = floatBitsToUint(f*16384.);\n    // Integer hash copied from Hugo Elias.\n\tn = (n<<13U)^n;\n    n = n*(n*n*15731U + 789221U) + 20170906U; // 1376312589U;\n    return float( n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n*/\n\n\n// Polygon face color.\nvec3 getColor(float x){\n\n    vec3 col;\n    \n    // Pink and blue.\n    float rx = hash11(x + .13);\n    col = .5 + .45*cos(x*6.2831/6. + vec3(0, 1, 2).zyx*1.15);\n    //col = mix(cCol, vec3(x*.75 + .1)*vec3(.95, .95, 1.1), 1.); // Greu and pink.\n    if(rx<.25) col = .5 + .45*cos(x*6.2831/16. + vec3(0, 1.5, 2)*2. + .35);\n    \n    \n    // Grey tones.\n    //col = vec3(.7*x + .2);\n \n \n    // Grey and green pastel.\n    //col = .5 + .45*cos(6.2831*x/3. + vec3(0, 1, 2)*1.5 + 3.5);\n    //if(hash11(x)>.65) col = mix(col, vec3(x*.4 + .5)*vec3(.95, .95, 1.1), .95);\n\n\n    // Earthtones.\n    //col = .5 + .45*cos(6.2831*x/4. + vec3(0, 1, 2)*1.35 - .5);\n \n    \n    // Multicolored.\n    //col = .5 + .45*cos(6.2831*x + vec3(0, 1, 2));\n    //col /= (.5 + dot(col, vec3(.299, .587, .114))*.75);\n    \n       \n    return col;\n}\n\n\n// These globals have been hastily put here. Globals don't always represent good\n// practice, but sometimes, it makes life easier. These particular ones don't seem\n// to effect program efficiency too much anyway.\n//\nmat3x2 gVert2D; // The three offset vertices.\n//mat3x2 gCtrN2D; // The three offset neighboring edge triangle vertices.\nvec4 gP4; // Local 2D triangle grid coordinates and triangle ID.\nvec3 gRc; // Unique random polygon number... I might rearrange this one later. \n\n// A standard square grid 2D blobby Truchet routine: Render circles\n// in opposite corners of a tile, reverse the pattern on alternate\n// checker tiles, and randomly rotate.\nvec3 poly(vec2 p, inout mat3x2 vID, inout mat3x2 v){\n\n\n    // Returns the local coordinates (centered on zero), cellID, the \n    // triangle vertex ID and relative coordinates.\n    //scale = 1./2.5; //1./2.\n    vec4 p4 = getTriVerts(p, vID, v);\n    // Local cell coordinates\n    p = p4.xy;\n    // Unique triangle ID (cell position based).\n    vec2 ctrID = p4.zw; \n    \n    gP4 = p4; // Saving the triangle data.\n\n    // Equilateral triangle cell side length.\n    float sL = length(v[0] - v[1]);\n \n    float oFctr = sL/4.; // Offset factor, based on the cell's side length.\n\n    // Distance field holders. One slot for each of the three polygons we'll\n    // be creating. Line (later used to hold the polygon data), jigsaw nodule\n    // distance (not sure why I called it mp), and the random values used for\n    // height and nodule direction (one side of the edge or the other).\n    vec3 ln, mp, rc, rc2;\n    \n   \n    mat3x2 vertOffs; // The offset points.\n\n    \n    for(int i = 0; i<3; i++){\n        // Nearest offset vertex point.\n        vertOffs[i] = v[i] - (hash21A(ctrID + vID[i]) - .5)*oFctr;\n    }\n    \n    // Using the offset vertices to calculate the offset center.\n    //ctrOffs = inCircle(vertOffs[0], vertOffs[1], vertOffs[2]);\n    vec2 ctrOffs = (vertOffs[0] + vertOffs[1] + vertOffs[2])/3.;\n    vec2 ctr = vec2(0); // Local center. //(v[0] + v[1] + v[2])/3.;\n    \n     \n    // If you look at some of the variables, you'll see that I've used a vector shuffling\n    // technique to avoid array indexing, which compilers don't like at all... I'd imagine\n    // it might effect GPU utilization as well. I can thank Shadertoy user, Cyberjax, for\n    // that tip. You'll note that there is some degree of array indexing also, but that was \n    // hard to avoid. In fact, I experimented with substituting \"vec2[3]\" for \"mat3x2\", but\n    // that seemed to slow things down... Although, I might try again later.\n    //\n    // Calculating the three lines eminating from the offset center point, and the nodule\n    // point positions on those lines.\n    for(int i = ZERO; i<3; i++){\n    \n        // The next two indices.\n        int ip1 = (i + 1)%3, ip2 = (i + 2)%3;\n\n\n        // Mid edge point and ID.\n        vec2 midID = mix(vID[i], vID[ip1], .5);\n        vec2 mid = mix(v[i], v[ip1], .5);\n\n        // Use the unique center ID to generate a random polygon height. By \n        // the way, it could be anything you want, like a texture height, etc.\n        rc.x = hash21(ctrID + vID[i] + .1);\n\n        // Random number associated with the triangle edge midpoint. It will \n        // be used to test which side of the edge the nodule will exist upon.\n        // Based on this random number, we'lladd the nodule to one side, and \n        // take away from the other.\n        rc2.x = hash21(ctrID + midID);\n\n\n        // The center ID and position of the triangle neighboring this edge.\n        vec2 ctrNgbrID = ctrID + midID*2.; \n        vec2 ctrNgbr = ctr + mid*2.;\n        // Using the above to create a the third offset vertex in the neighboring triangle.\n        // The first two vertices will be the edge vertices, since the neighboring triangle\n        // cell will share that edge.\n        //\n        // Neighbor center minus the third vertex from this side (symmetry), then \n        // using that ID to offset the vertex.\n        vec2 vertNOffs = (ctrNgbr - v[ip2]) - (hash21A(ctrNgbrID - vID[ip2]) - .5)*oFctr;\n       \n        // The neighboring offset center point for this edge.\n        //vec2 ctrNOffs = inCircle(vertOffs[i], vertOffs[ip1], vertNOffs);\n        vec2 ctrNOffs = (vertOffs[i] + vertOffs[ip1] + vertNOffs)/3.; // Neighbor triangle offsset center.\n        //gCtrN2D[i] = ctrNOffs; // Saving the point for later usage.\n\n\n        // The signed distance to the line connecting this triangle's offset center\n        // to the offset center of the neighboring triangle to this particular edge.\n        ln.x = distLineS(p, ctrOffs, ctrNOffs);\n      \n\n\n        ///////////////\n        // Creating the jigsaw edge nodules.\n        #ifdef JIGSAW\n        // Perpendicular vector and random based direction.\n        vec2 tn = normalize((ctrOffs - ctrNOffs).yx*vec2(1, -1)); \n        float dir = gTri*(rc2.x - .5<0.? -1. : 1.);\n        // Midpoint minus perpendicul direction to that point the make\n        // the nodule stick out a bit.\n        vec2 mOffs = mix(ctrOffs, ctrNOffs, .5);\n        // Round nodule distance... Other shapes are possible, but we're\n        // keeping things simple.\n        mp.x = length(p - mOffs - dir*tn*.013);\n        #endif\n        ///////////////////\n\n\n        // Cyberjax's trick to shuffle the vector entries along one place.\n        // It's extra work, but it cuts down on compile time considerably.\n        // I'm pretty sure it runs faster too, but I can't be certain of that.\n        rc = rc.yzx;\n        rc2 = rc2.yzx;\n        ln = ln.yzx;\n        mp = mp.yzx;\n\n    } \n  \n    // Recording the three offset vertices.\n    gVert2D = vertOffs;\n\n    \n     \n    float smF = .025;//.025;\n    ln = smax(ln, -ln.zxy, smF);//.zxy\n  \n    \n    // Use CSG to apply the jigsaw pattern nodules to the asymmetric hexagon pattern.\n    #ifdef JIGSAW\n    // JIGSAW\n    // Offset lines.\n    vec3 rnd3 = gTri*(rc2 - .5); \n    rnd3 = vec3(rnd3.x<0.? -1 : 1, rnd3.y<0.? -1 : 1, rnd3.z<0.? -1 : 1);\n\n \n    // For positive random numbers, take away a nodule from one side of the\n    // line, and take it away from the other.\n    mp -= .11; // Nodule size.\n    ln = rnd3*smax(rnd3*ln, -mp, smF);\n    ln = rnd3.zxy*smin(rnd3.zxy*ln, mp.zxy, smF);\n    #endif\n\n    gRc = rc; // Record the random polygon value for usage in the map function below.\n    //gPoly2D = ln; // Record the 2D polygon distance for usage in the map function below\n     \n    return ln; \n}\n \n\n// The scene's distance function: There'd be faster ways to do this, but it's\n// more readable this way. Plus, this  is a pretty simple scene, so it's \n// efficient enough.\nfloat m(vec3 p){\n    \n    // Cell coordinate, ID and triangle orientation id.\n    // Cell vertices and vertex ID.\n    mat3x2 v, vID;\n    \n    // 2D Truchet distance -- for the extrusion cross section.\n    vec3 pol = poly(p.xy, vID, v);\n   \n    // Rescaling the random heights.\n    vec3 nRc = gRc*.15 + .05;\n    \n    // 2D distance to offset vertex points.\n    vec3 v3 = vec3(length(gP4.xy - gVert2D[0]), length(gP4.xy - gVert2D[1]), length(gP4.xy - gVert2D[2]));\n    \n    \n    // Extruding the polygons.\n    vec3 s = pol + .008;\n    vec3 r = abs(p.z + nRc) - nRc;\n    pol = max(s, r) + (v3 - scale/2.)*.05; // + s*.05;\n    // Bevel.\n    //pol = max(s, r) - smoothstep(.05, .09, -s)*.015;\n \n    // Proper extrusion formula for comparisson.\n    /*\n    vec3 s = pol + .008;\n    vec3 r = abs(p.z + nRc) - nRc;\n    pol = min(max(s, r), 0.);\n    pol += vec3(length(max(vec2(s.x, r.x), 0.)), length(max(vec2(s.y, r.y), 0.)), \n                         length(max(vec2(s.z, r.z), 0.)));\n    pol += (v3 - scale/2.)*.05;\n    */\n\n    // The closest of the three extruded polygons.\n    float obj = min(min(pol.x, pol.y), pol.z); \n    \n    \n    // Back plane. Not really necessary, but it's there.\n    float fl = -p.z;\n    \n    // Object ID.\n    objID = fl<obj? 0 : 1;\n    \n    // Minimum distance for the scene.\n    //return min(min(fl, obj), vert);\n    return min(fl, obj);\n    \n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float d, t = 0.; //hash21(r.xy*57. + fract(iTime + r.z))*.5;\n    \n    for(int i = ZERO; i<64; i++){\n    \n        d = m(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not affordable for slower machines.\n    const int iter = 24; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = ZERO; i<iter; i++){\n\n        float d = m(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // IQ's subtle refinement.\n        t += clamp(d, .01, .15); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = ZERO; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = m(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n  \n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(in vec3 p) {\n\t\n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += m(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\nvoid mainImage(out vec4 c, vec2 u){\n\n    \n    // Aspect correct coordinates. Only one line necessary.\n    u = (u - iResolution.xy*.5)/iResolution.y;    \n    \n    // Unit direction vector, camera origin and light position.\n    vec3 r = normalize(vec3(u, 1)), o = vec3(0, iTime/6., -3), l = o + vec3(.25, .5, 2);\n    \n    // Rotating the camera about the XY plane.\n    r.yz = rot2(.15)*r.yz;\n    r.xz = rot2(-cos(iTime*3.14159/32.)/8.)*r.xz;\n    r.xy = rot2(sin(iTime*3.14159/32.)/8.)*r.xy; \n  \n    \n    // Raymarch to the scene.\n    float t = trace(o, r);\n \n    \n    // Object ID: Back plane (0), or the metaballs (1).\n    int gObjID = objID;\n \n \n    // Very basic lighting.\n    // Hit point and normal.\n    vec3 p = o + r*t, n = nr(p); \n    \n    \n        // Basic point lighting.   \n    vec3 ld = l - p;\n    float lDist = length(ld);\n    ld /= lDist; // Light direction vector.\n    float at = 1./(1. + lDist*lDist*.125); // Attenuation.\n    \n    // Very, very cheap shadows -- Not used here.\n    //float sh = min(min(m(p + ld*.08), m(p + ld*.16)), min(m(p + ld*.24), m(p + ld*.32)))/.08*1.5;\n    //sh = clamp(sh, 0., 1.);\n    float sh = softShadow(p, l, n, 8.); // Shadows.\n    float ao = calcAO(p, n); // Ambient occlusion.\n    \n    float df = max(dot(n, ld), 0.); // Diffuse.\n    float sp = pow(max(dot(reflect(r, n), ld), 0.), 32.); // Specular.\n    //df = pow(df, 4.)*2.;\n   \n    \n    \n    // UV texture coordinate holder.\n    vec2 uv = p.xy;\n    \n\n    \n    ////////////\n    // Cell coordinate, ID and triangle orientation id.\n    // Cell vertices and vertex ID.\n    mat3x2 v, vID;\n    // Returns the three 2D polygons that surround the three vertices of the triangle.\n    vec3 poly2D = poly(p.xy, vID, v);\n    vec2 p2 = gP4.xy;\n    /////////////\n    \n    \n    vec4 col1 = vec4(1, .15, .4, 0);\n    vec4 col2 = vec4(.4, .7, 1, 0);\n\n    \n    // Object color.\n    vec4 oCol;\n  \n    \n    // Use whatever logic to color the individual scene components. I made it\n    // all up as I went along, but things like edges, textured line patterns,\n    // etc, seem to look OK.\n    //\n    if(gObjID == 0){\n    \n       // The floor. Redundant here, but it might be needed later.\n       oCol = vec4(0);\n      \n    }\n    else {\n    \n        // Extruded offset hexagons:\n        vec4 cCol;\n        vec3 nRc = gRc*.15 + .05;\n        // The distance surrounding the three  offset triangle vertices.\n        vec3 d3 = vec3(length(gP4.xy - gVert2D[0]), length(gP4.xy - gVert2D[1]), \n                       length(gP4.xy - gVert2D[2]));\n        vec3 poly3D = max(abs(p.z + nRc) - nRc, poly2D.xyz + .008) + (d3 - scale/2.)*.05; // svPoly2D*.05;\n        int gPID = poly3D.x<poly3D.y && poly3D.x<poly3D.z? 0 : poly3D.y<poly3D.z? 1 : 2;\n        // Random polygon value - The polygon surrounds the vertex point, so the unique ID is\n        // the triangle ID plus the vertex ID.\n        float rnd = hash21(gP4.zw + vID[gPID] + .1);\n        // Generating a random color based on the random value above.\n        cCol.xyz = getColor(rnd);\n        \n        // Random offset value, based on the side length and the polygon ID.\n        // There values match the ones used by the raymarched distance funtion.\n        float oFctr = length(v[0] - v[1])/4.;\n        vec2 cOffs = (hash21A(gP4.zw + vID[gPID]) - .5)*oFctr;\n        \n        // A bluish white color.\n        //cCol = vec4(.7, .8, .9, 0);\n        // Diffuse color... Kind of interesting looking.\n        //cCol = vec4(df);\n         \n        // Make some polygons a different color.\n        //if(cCol.x<.5) if(hash11(rnd)<.85) cCol = cCol.yzxw*cCol.yzxw;\n        \n        // Trim color -- Bluish white.\n        vec4 trimCol = vec4(.7, .8, .9, 0); \n        \n        vec4 svCol = cCol; // Save the face color.\n        \n        // 2D polygon distance. Used to decorate the polygon face with edges, etc. \n        float d = poly2D[gPID]; \n        \n        // Using difference diffuse values on the face or edges, etc.\n        //df = mix(pow(df, 4.)*2., df, 1. - smoothstep(0., .01, d + .06));\n        \n        vec2 ctrOffs = (gVert2D[0] + gVert2D[1] + gVert2D[2])/3.;\n         \n        float ln = 1e5;\n         \n        // Offset triangle edge lines, used to display the grid.\n        #ifdef GRID\n        for(int i = 0; i<3; i++){\n            ln = min(ln, abs(distLineS(p2, gVert2D[i], gVert2D[(i + 1)%3])));\n        }\n         \n        /*  \n        // This one confused me for a while. You need to render lines from the\n        // closest point to the following three points: \n        // Tri center and the centers of the neighboring triangles of the vertex's\n        // joining edges. You'd need to commment \"gCtrN2D\" back in wherever it appears.\n        ln = min(ln, abs(distLineS(p2, ctrOffs, gVert2D[gPID])));\n        ln = min(ln, abs(distLineS(p2, gCtrN2D[gPID], gVert2D[gPID])));\n        ln = min(ln, abs(distLineS(p2, gCtrN2D[(gPID + 2)%3], gVert2D[gPID]))); \n        */ \n \n        // Hacky dashed lines.\n        ln = smax(ln, -(d3[gPID] - .1), .025);\n        ln = smax(ln, -(abs(fract(d3[gPID]*8.) - .5) - .1)/8., .025);\n        ln = smax(ln, (d + .08),.025);\n   \n        // Render the lines onto the face.\n        cCol = mix(cCol, cCol*1.15 + .075, (1. - smoothstep(0., .02, ln - .015)));\n        cCol = mix(cCol, vec4(0), 1. - smoothstep(0., .01, ln - .004));\n        #endif\n        \n       \n        // Subtle line pattern.\n        // Pinning the pattern to the offset point. I prefer it this way, but you\n        // could let the point float above a fixed pattern instead.\n        float lSc = 36.;\n        vec2 txP = p.xy + cOffs;\n        #ifdef LINES\n        float pat = (abs(fract((txP.x - txP.y)*.7071*lSc - .5) - .5) - .25)/lSc;\n        cCol = mix(cCol, vec4(0), (1. - smoothstep(0., .01, pat))*.35);\n        #else\n        cCol *= .85;\n        #endif\n        \n        \n        // White sides with a dark edge. \n        oCol = trimCol;\n        oCol = mix(oCol, vec4(0), 1. - smoothstep(0., .01, d + .04));\n        oCol = mix(oCol, cCol, 1. - smoothstep(0., .01, d + .06));\n        \n        //df = mix(df, pow(df, 2.)*1.2, 1. - smoothstep(0., .01, d + .05));\n     \n        ////\n        \n        #ifdef SHOW_VERTICES\n        // Rendering the offset central node.\n        float d2 = d3[gPID] - .07; // Closest distance.\n        oCol = mix(oCol, vec4(0), 1. - smoothstep(0., .01, d2));//.016=5\n        oCol = mix(oCol, trimCol, 1. - smoothstep(0., .01, d2 + .02));//.016=5\n        oCol = mix(oCol, vec4(0), 1. - smoothstep(0., .01, d2 + .04));//.016=5\n        oCol = mix(oCol, svCol, 1. - smoothstep(0., .01, d2 + .06));//.016=5\n        #endif\n        \n        /*\n        float rim = -(p.z + nRc[gPID]*2.) + .05;\n        oCol = mix(oCol, vec4(0), 1. - smoothstep(0., .01, rim));\n        oCol = mix(oCol, vec4(.7, .8, .9, 0)*.7, 1. - smoothstep(0., .01, rim + .025));\n        */\n        \n        \n        /*\n        // Corrugation on the sides -- Interesting, but a bit much, I think.\n        lSc = 24.;\n        pat = (abs(fract((rim)*lSc - .5) - .5) - .1)/lSc;\n        oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, max(pat, rim)))*.5);\n        */\n        \n        \n    }\n\n\n\n    // Specular reflection.\n    vec3 hv = normalize(-r + ld); // Half vector.\n    vec3 ref = reflect(r, n); // Surface reflection.\n    vec4 refTx = texture(iChannel0, ref); refTx *= refTx;\n    refTx = (oCol*1.5 + .66)*refTx;//smoothstep(.2, .5, refTx);\n    float spRef = pow(max(dot(hv, n), 0.), 8.); // Specular reflection.\n    float rf = (gObjID == 0)? .1 : 1.;//mix(.5, 1., 1. - smoothstep(0., .01, d + .08));\n    oCol += spRef*refTx*rf*.5; //smoothstep(.03, 1., spRef) \n\n      \n    // Apply the lighting and shading. \n    c = oCol*(df*sh + sp*sh + .5)*at*ao;\n    \n     \n \n    // Rough gamma correction.\n    c = sqrt(max(c, 0.));  \n\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning. By the way, this\n// will partition all repeat grid triangles, not just equilateral ones.\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)\nconst float scale = 1./1.6;\n \nfloat gTri;\n\nvec4 getTriVerts(in vec2 p, inout mat3x2 vID, inout mat3x2 v){\n\n    // Rectangle scale.\n    const vec2 rect = (vec2(1./.8660254, 1))*scale;\n\n    // Skewing half way along X, and not skewing in the Y direction.\n    const vec2 sk = vec2(rect.x*.5, 0)/scale; // 12 x .2\n\n    // Skew the XY plane coordinates.\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //gTri = p.x/rect.x < -p.y/rect.y? 1. : -1.;\n    // Base on the bottom (-1.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 1. : -1.;\n   \n    // Puting the skewed coordinates back into unskewed form.\n    p = unskewXY(p, sk);\n    \n    \n    // Vertex IDs for each partitioned triangle: The numbers are inflated\n    // by a factor of 3 to ensure vertex IDs are precisely the same. The\n    // reason behind it is that \"1. - 1./3.\" is not always the same as\n    // \"2./3\" on a GPU, which can mess up hash logic. However, \"3. - 2.\"\n    // is always the same as \"1.\". Yeah, incorporating hacks is annoying, \n    // but GPUs don't work as nicely as our brains do, unfortunately. :)\n    if(gTri<0.){\n        vID = mat3x2(vec2(-1.5, 1.5), vec2(1.5, -1.5), vec2(1.5));\n    }\n    else {\n        vID = mat3x2(vec2(1.5, -1.5), vec2(-1.5, 1.5), vec2(-1.5));\n    }\n    \n    // Triangle vertex points.\n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect/3., sk); // Unskew.\n    \n    // Centering at the zero point.\n    vec2 ctr = v[2]/3.; // Equilateral equivalent to: (v[0] + v[1] + v[2])/3;\n    p -= ctr;\n    v[0] -= ctr; v[1] -= ctr; v[2] -= ctr;\n    \n     // Centered ID, taking the inflation factor of three into account.\n    vec2 ctrID = vID[2]; //(vID[0] + vID[1] + vID[2])/3.;//vID[2]/2.; //\n    id = id*3. + ctrID;   \n    // Since these are out by a factor of three, \"v = vertID*rect/3.\".\n    vID[0] -= ctrID; vID[1] -= ctrID; vID[2] -= ctrID;\n\n\n    // Triangle local coordinates (centered at the zero point) and \n    // the central position point (which acts as a unique identifier).\n    return vec4(p, id);\n}\n\n/*\n// IQ;s signed distance to an equilateral triangle.\n// https://www.shadertoy.com/view/Xl2yDW\nfloat sdEqTri(in vec2 p, in float r){\n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if(p.x + k*p.y>0.) p = vec2(p.x - k*p.y, -k*p.x - p.y)/2.;\n    p.x -= clamp(p.x, -2.*r, 0.);\n    return -length(p)*sign(p.y);\n}\n*/\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n   \n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\nvec3 smin(vec3 a, vec3 b, float k){\n   vec3 f = max(vec3(0), 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\nvec3 smax(vec3 a, vec3 b, float k){\n   vec3 f = max(vec3(0), 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n/////////\n  \n// Triangle's incenter: The center of the inscribed circle, which in essence is\n// the largest circle that you can fit into a triangle.\nvec2 inCircle(in vec2 v0, in vec2 v1, in vec2 v2){\n    \n    // Side lengths.\n    vec3 len = vec3(length(v2 - v1), length(v0 - v2), length(v1 - v0));\n    //return (bc*p0 + ac*p1 + ab*p2)/dot(len, vec3(1));\n    return mat3x2(v0, v1, v2)*len/dot(len, vec3(1));\n}\n\n\n// Signed distance to a line passing through A and B.\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\n\n\n\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKfWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2723, 2756, 2778, 2778, 2836], [2839, 2853, 2875, 2928, 2968], [2970, 2998, 3019, 3019, 3134], [3136, 3164, 3185, 3185, 3358], [3722, 3745, 3768, 3768, 4557], [5042, 5216, 5268, 5422, 11002], [11006, 11179, 11195, 11292, 12547], [12549, 12570, 12606, 12655, 13117], [13119, 13310, 13362, 13453, 14580], [14583, 14735, 14770, 14770, 15155], [15159, 15250, 15270, 15601, 15871], [15874, 15874, 15909, 15975, 23625]], "test": "untested"}
{"id": "dsf3RM", "name": "Firefox GLSL bug #70", "author": "FabriceNeyret2", "description": "Uncommenting line #6 makes Firefox freeze and driver crash\n\nbug report:  [url] https://bugzilla.mozilla.org/show_bug.cgi?id=1795532  [/url]", "tags": ["glsl", "bug", "firefox"], "likes": 1, "viewed": 194, "published": 3, "date": "1665836214", "time_retrieved": "2024-07-30T16:26:09.202630", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n     O = vec4(0);\n\n    for( float i=0.,l; i < 20.; i++ ) {        // no bug without the ,l\n    //  if ( min(0.,iTime)  == 0.) continue;   // uncomment to freeze FF\n        O++;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsf3RM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 223]], "test": "untested"}
{"id": "Dss3z8", "name": "DXT1 Compression", "author": "Gegell", "description": "Demonstration of compression artifacts in DXT1 compressed images.\nThe common tab contains parameters, which can change number of bits per color / interpolant, as well as the endpoint determination algorithm.\nThe mouse + drag changes displayed view.", "tags": ["compression", "artifacts"], "likes": 2, "viewed": 156, "published": 3, "date": "1665833943", "time_retrieved": "2024-07-30T16:26:10.152092", "image_code": "mat2 rot2d(float angle) {\n    vec2 sc = vec2(sin(angle), cos(angle));\n    return mat2(sc.y, -sc.x, sc.x, sc.y);\n}\n\nfloat displayMask(vec2 fragCoord) {\n    vec2 coord = sign(iMouse.z) > 0.0 ? iMouse.xy : fragCoord;\n    coord -= iResolution.xy / 2.;\n#if POSITION_MODE == 1\n    coord = rot2d(-3.14159 / 12.0) * coord * 1.02;\n#else\n    coord = rot2d(-3.14159 / 4.0) * coord * 1.4;\n#endif\n    coord += iResolution.xy / 2.;\n    vec2 uv = clamp(coord / iResolution.xy, vec2(0.), vec2(1.));\n    return uv.x*6.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized centered pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/min(iResolution.x, iResolution.y) + .5;\n    vec2 texture_size = textureSizeCompressed(iChannel0);\n    \n    ivec2 pos = ivec2(fragCoord); //POSITION_MODE == 1\n#if POSITION_MODE == 2\n    pos = ivec2(floor(uv * texture_size));\n#endif\n    ivec2 iBlockCoord = pos / 4;\n    ivec2 fBlockCoord = pos & 3;\n\n    Block block = blockFetch(iChannel0, iBlockCoord);\n    \n    \n    vec4 col_compressed = texelFetchCompressed(iChannel0, pos);\n    vec4 col_true = texelFetch(iChannel1, pos, 0);\n    \n    float image_mask = float(all(equal(clamp(pos, ivec2(0), ivec2(texture_size)-1), pos)));\n    float display_mask = displayMask(fragCoord);\n    \n\n    // Output to screen\n    // (*): requires the same texture to be set in Buffer A and Image Tabs\n    switch (int(round(display_mask))) {\n        case 0:\n            // Show compressed texture\n            fragColor = col_compressed;\n            fragColor *= image_mask;\n            break;\n        case 1:\n            // (*) Show abs. diff. x10\n            fragColor = abs(col_compressed - col_true) * 10.;\n            fragColor *= image_mask;\n            break;\n        case 2:\n            // Show distance between the decoded block endpoint colors\n            fragColor = vec4(distance(reconstructColor(block.endpoint1), reconstructColor(block.endpoint2)));\n            fragColor *= image_mask;\n            break;\n        case 3:\n            // Show color difference between the block endpoints\n            fragColor = vec4(abs(vec3(block.endpoint1) - vec3(block.endpoint2)) / max_color_vals, 1);\n            fragColor *= image_mask;\n            break;\n        case 4:\n            // Show equal color channels in endpoints\n            fragColor = vec4(equal(block.endpoint1, block.endpoint2), 1);\n            fragColor *= image_mask;\n            break;\n        case 5:\n            // Show interpolant values\n            fragColor = vec4(float(block.interpolants[fBlockCoord.y * 4 + fBlockCoord.x]) / float(max_inter_val));\n            fragColor *= image_mask;\n            break;\n        case 6:\n            // Show raw data\n            fragColor = vec4(floatBitsToUint(texelFetch(iChannel0, ivec2(fragCoord), 0))) / float(uint(-1));\n            break;\n    }\n    \n    if (sign(iMouse.z) < 0.0) {\n        fragColor = mix(fragColor, vec4(1.0), smoothstep(0.010, 0.0025, abs(fract(display_mask)-.5)));\n    }\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "uint murmur3_finalize( in uint u )\n{\n  u ^= ( u >> 16 ); u *= 0x85EBCA6Bu;\n  u ^= ( u >> 13 ); u *= 0xC2B2AE35u;\n  u ^= ( u >> 16 );\n\n  return u;\n}\n\n// RNG from https://de.wikipedia.org/wiki/Xorshift\nuint rngSeed = 314159265u;\n\nuint xorshift(in uint value) {\n    value ^= value << 13;\n    value ^= value >> 17;\n    value ^= value << 5;\n    return value;\n}\n\nuint nextUint() {\n    rngSeed = xorshift(rngSeed);\n    return rngSeed;\n}\n\nfloat nextFloat() {\n    return float(nextUint()) / float(uint(-1));\n}\n\nvec3 nextVec3() {\n    return vec3(nextFloat(), nextFloat(), nextFloat());\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    int index = (iFragCoord.y * int(iChannelResolution[0].x) + iFragCoord.x) - 1;\n    if (index >= 0) {\n        int block_index = index / _darray_size;\n        int block_px = index % _darray_size;\n        int tex_block_width = int(ceil(iChannelResolution[1].x / 4.));\n        ivec2 iBlockCoord = ivec2(block_index % tex_block_width, block_index / tex_block_width);\n        \n        Block block;\n#if !defined ENDPOINT_FUNCTION || ENDPOINT_FUNCTION == 1\n        vec4[] endpoints = endpointBBox(iChannel1, iBlockCoord);\n        block = compress(iChannel1, iBlockCoord, endpoints[0], endpoints[1]);\n#elif ENDPOINT_FUNCTION == 2\n        block = blockFetch(iChannel0, iBlockCoord);        \n        rngSeed = murmur3_finalize(uint(block_index) ^ murmur3_finalize(uint(iFrame)));\n        float bestMSE = compressionMSE(iChannel1, block, iBlockCoord);\n        for (int i = 0; i < ITERATIONS_PER_FRAME ; i++) {\n            vec4 endpoint1 = vec4(nextVec3(), 1.);\n            vec4 endpoint2 = vec4(nextVec3(), 1.);\n            Block newBlock = compress(iChannel1, iBlockCoord, endpoint1, endpoint2);\n            float newMSE = compressionMSE(iChannel1, newBlock, iBlockCoord);\n            if (newMSE < bestMSE) {\n                bestMSE = newMSE;\n                block = newBlock;\n            }\n        }\n#endif\n        \n        PackedBlock packed = packBlock(block);\n\n        fragColor = vec4(uintBitsToFloat(packed.data[block_px]));\n    } else {\n        fragColor = vec4(iChannelResolution[1].xy, 0, 0);\n    }\n}\n", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// The number of bits each color channel gets in each endpoint.\n// Per 4x4 block of pixels we store 2 endpoint colors.\n#define COLOR_BITS uvec3(5,6,5)\n\n// The number of bits the interpolants get. \n// The interpolant is the only thing that's stored for each pixel,\n// determining where between the 2 endpoints this pixel color is situated. (lerp)\n#define INTER_BITS 2\n\n// Endpoint function table. How do we select appropriate endpoints for each block?\n// 1. Use the min and max values of the colors in the block (bounding box corners) \n// 2. Use iterative refinement (uniform random points)\n#define ENDPOINT_FUNCTION 2\n\n// If we use an iterative endpoint function, how often do we iterate per frame?\n#define ITERATIONS_PER_FRAME 16\n\n// Position selection. How to position the texture on the screen?\n// 1. Use the original fragCoord, preserving 1:1 pixel and aspect ratio.\n// 2. Use centered 0-1 UV square in the center of the screen.\n#define POSITION_MODE 1\n\n\n//\n// Endpoint determination functions\n//\nvec4[2] endpointBBox( sampler2D image, ivec2 blockID ) {\n    ivec2 uv_offset = blockID * 4;\n    \n    // Figure out some endpoints, here just simple bbox min and max\n    vec4 min_, max_;\n    min_ = max_ = texelFetch(image, uv_offset, 0);\n    for (int index = 1; index < 4 * 4; index++) {\n        ivec2 p = ivec2(index % 4, index / 4);\n        vec4 col = texelFetch(image, uv_offset + p, 0);\n        min_ = min(min_, col);\n        max_ = max(max_, col);\n    }\n    \n    return vec4[](min_, max_);\n}\n\n//\n// Compression functions\n//\n#define max_color_vals (vec3((1u << COLOR_BITS.r) - 1u, (1u << COLOR_BITS.g) - 1u, (1u << COLOR_BITS.b) - 1u)) \n#define max_inter_val float((1u << INTER_BITS) - 1u)\n\nstruct Block {\n    uvec3 endpoint1;\n    uvec3 endpoint2;\n    uint[16] interpolants;\n};\n\nuvec3 compressColor(vec3 col) {\n    return uvec3(round(clamp(col, vec3(0), vec3(1)) * vec3(max_color_vals)));\n}\n\nvec3 reconstructColor(uvec3 col) {\n    return mix(vec3(col) / max_color_vals, vec3(0.), equal(COLOR_BITS, uvec3(0u)));\n}\n\nBlock compress(sampler2D image, ivec2 blockID, vec4 endpoint1, vec4 endpoint2) {\n    ivec2 uv_offset = blockID * 4;\n    \n    // Compress to data\n    Block block;\n    block.endpoint1 = compressColor(endpoint1.rgb);\n    block.endpoint2 = compressColor(endpoint2.rgb);\n    \n    vec3 decoded_endpoint1 = reconstructColor(block.endpoint1);\n    vec3 decoded_endpoint2 = reconstructColor(block.endpoint2);\n    \n    vec3 end12 = decoded_endpoint2 - decoded_endpoint1;\n    \n    for (int index = 0; index < 4 * 4; index++) {\n        ivec2 p = ivec2(index % 4, index / 4);\n        vec4 col = texelFetch(image, uv_offset + p, 0);\n        float t_value = clamp(dot(end12, col.rgb - decoded_endpoint1) / dot(end12, end12), 0., 1.);\n        \n        t_value *= float(max_inter_val);\n        block.interpolants[index] = uint(round(t_value));\n    }\n    return block; \n}\n\nvec4 decompress(Block block, ivec2 pixelID) {\n    vec3 decoded_endpoint1 = reconstructColor(block.endpoint1);\n    vec3 decoded_endpoint2 = reconstructColor(block.endpoint2);\n    \n    vec3 end12 = decoded_endpoint2 - decoded_endpoint1;\n    int index = pixelID.y * 4 + pixelID.x;\n    \n#if INTER_BITS > 0\n    float t = float(block.interpolants[index]) / float(max_inter_val);\n#else \n    float t = 0.;\n#endif\n    vec3 col = decoded_endpoint1 + t * end12;\n    \n    return vec4(col, 1.);\n}\n\nfloat compressionMSE( sampler2D image, Block block, ivec2 blockID ) {\n    ivec2 uv_offset = blockID * 4;\n    float mse = 0.;\n    for (int index = 0; index < 4 * 4; index++) {\n        ivec2 p = ivec2(index % 4, index / 4);\n        vec4 col_true = texelFetch(image, uv_offset + p, 0);\n        vec4 col_comp = decompress(block, p);\n        vec4 delta = col_true - col_comp;\n        mse += dot(delta, delta);\n    }\n    return mse;\n}\n\n//\n// Bitpacking and unpacking\n//\n#define _endpoint_size int(COLOR_BITS.r + COLOR_BITS.g + COLOR_BITS.b)\n#define _interpolants_size (INTER_BITS * 16)\n#define _darray_size ((_endpoint_size * 2 + _interpolants_size + 31) / 32)\nstruct PackedBlock {\n    uint[_darray_size] data;\n};\n\nvoid bitfieldWrite(inout uint[_darray_size] data, uint to_write, int offset, int width) {\n    int index = offset / 32;\n    int b_offset = offset & 31;\n    uint full_mask = (1u << width) - 1u; \n    uint mask = full_mask << b_offset;\n    data[index] = (data[index] & ~mask) + ((to_write << b_offset) & mask);\n    if (b_offset + width > 32) {\n        mask = full_mask >> (32 - b_offset);\n        data[index + 1] = (data[index] & ~mask) + ((to_write >> (32 - b_offset)) & mask);\n    }\n}\n\nuint bitfieldRead(uint[_darray_size] data, int offset, int width) {\n    int index = offset / 32;\n    int b_offset = offset & 31;\n    uint mask = (1u << width) - 1u;\n    uint read = (data[index] >> b_offset) & mask;\n    if (b_offset + width > 32) {\n        mask = (1u << (width + b_offset - 32)) - 1u;\n        read += (data[index + 1] & mask) << (32 - b_offset);\n    }\n    return read;\n}\n\nPackedBlock packBlock(Block block) {\n    const ivec3 end1_offsets = ivec3(0, COLOR_BITS.r, COLOR_BITS.r + COLOR_BITS.g);\n    const ivec3 end2_offsets = end1_offsets + _endpoint_size;\n    \n    PackedBlock packed;\n    bitfieldWrite(packed.data, block.endpoint1.r, end1_offsets.r, int(COLOR_BITS.r));\n    bitfieldWrite(packed.data, block.endpoint1.g, end1_offsets.g, int(COLOR_BITS.g));\n    bitfieldWrite(packed.data, block.endpoint1.b, end1_offsets.b, int(COLOR_BITS.b));\n    \n    bitfieldWrite(packed.data, block.endpoint2.r, end2_offsets.r, int(COLOR_BITS.r));\n    bitfieldWrite(packed.data, block.endpoint2.g, end2_offsets.g, int(COLOR_BITS.g));\n    bitfieldWrite(packed.data, block.endpoint2.b, end2_offsets.b, int(COLOR_BITS.b));\n    \n    int offset = 2 * _endpoint_size;\n    for (int i = 0; i < 4*4; i++) {\n        bitfieldWrite(packed.data, block.interpolants[i], offset, INTER_BITS);\n        offset += INTER_BITS;\n    }\n    return packed;\n}\n\nBlock unpackBlock(PackedBlock packed) {\n    const ivec3 end1_offsets = ivec3(0, COLOR_BITS.r, COLOR_BITS.r + COLOR_BITS.g);\n    const ivec3 end2_offsets = end1_offsets + _endpoint_size;\n    \n    Block block;\n    block.endpoint1.r = bitfieldRead(packed.data, end1_offsets.r, int(COLOR_BITS.r));\n    block.endpoint1.g = bitfieldRead(packed.data, end1_offsets.g, int(COLOR_BITS.g));\n    block.endpoint1.b = bitfieldRead(packed.data, end1_offsets.b, int(COLOR_BITS.b));\n    \n    block.endpoint2.r = bitfieldRead(packed.data, end2_offsets.r, int(COLOR_BITS.r));\n    block.endpoint2.g = bitfieldRead(packed.data, end2_offsets.g, int(COLOR_BITS.g));\n    block.endpoint2.b = bitfieldRead(packed.data, end2_offsets.b, int(COLOR_BITS.b));\n    \n    int offset = 2 * _endpoint_size;\n    for (int i = 0; i < 4*4; i++) {\n        block.interpolants[i] = bitfieldRead(packed.data, offset, INTER_BITS);\n        offset += INTER_BITS;\n    }\n    return block;\n}\n\n//\n// Sampling function\n//\nvec2 textureSizeCompressed( sampler2D compressed ) {\n    return texelFetch(compressed, ivec2(0), 0).xy;\n}\n\nBlock blockFetch( sampler2D compressed, ivec2 blockID, vec2 texture_size) {\n    ivec2 dataSize = ivec2(textureSize(compressed, 0));\n    ivec2 blockCounts = ivec2(ceil(texture_size / 4.));\n\n    PackedBlock packed;\n    int base = (blockID.y * blockCounts.x + blockID.x) * _darray_size + 1;\n    for (int offset = 0; offset < _darray_size; offset++) {\n        int index = base + offset;\n        ivec2 data_pos = ivec2(index % dataSize.x, index / dataSize.x);\n        vec4 raw_data = texelFetch(compressed, data_pos, 0);\n        packed.data[offset] = floatBitsToUint(raw_data.r);\n    }\n    \n    return unpackBlock(packed);\n}\n\nBlock blockFetch( sampler2D compressed, ivec2 blockID ) {\n    vec2 texture_size = textureSizeCompressed(compressed);\n    return blockFetch( compressed, blockID, texture_size );\n}\n\nvec4 texelFetchCompressed( sampler2D compressed, ivec2 pos ) {\n    vec2 texture_size = textureSizeCompressed(compressed);\n    if (any(notEqual(clamp(pos, ivec2(0), ivec2(texture_size)-1), pos))) {\n        return vec4(0.);\n    }\n\n    ivec2 iBlockCoord = pos / 4;\n    ivec2 fBlockCoord = pos & 3;\n    \n    Block block = blockFetch(compressed, iBlockCoord, texture_size);\n    return decompress(block, fBlockCoord);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dss3z8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 113], [115, 115, 150, 150, 504], [506, 506, 563, 622, 3007]], "test": "untested"}
{"id": "ddf3RM", "name": "flow streamlines - grey contours", "author": "FabriceNeyret2", "description": "variant of https://shadertoy.com/view/cdfGz7 with field = texture isogrey", "tags": ["flow", "isovalue"], "likes": 27, "viewed": 428, "published": 3, "date": "1665832617", "time_retrieved": "2024-07-30T16:26:10.913057", "image_code": "// variant of https://shadertoy.com/view/cdfGz7\n// field = texture isogrey\n\nvoid mainImage( out vec4 O, vec2 u )  { \n // O = sqrt(T(u));\n    O = sqrt(1.-exp(-T(u)*vec4(4,2,1,1))); // color\n // O = sqrt(T(u))*texture(iChannel1, u/iResolution.xy)*2.; // Shane variant\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ---- compute BBoxs of next curves\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    R = iResolution.xy;\n    if (u.y>1.) { O = texture(iChannel1,u/R); \n                  O = vec4(-dFdy(O.x),dFdx(O.x),O.x,0); // contour vectors\n               // O = vec4(.1*normalize(vec2(-dFdy(O.x),dFdx(O.x))),O.x,0);\n                  return; \n                }\n    float i = u.x-.5, l = 9., p = 1./R.y;\n    vec2  P = H(i+.5-iTime), _P=P, m=P,M=P;  // random start point\n    \n    for( int t=0; t <len; t++, _P = P )      // follow trajectory\n        P += field(P,iChannel1),\n        m = min(m,P), M = max(M,P);        \n\n    O = vec4(m-p,M+p);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "int len = 10; // curve length ( i.e. number of samples )\nvec2 R;\n#define T(U)   texelFetch( iChannel0, ivec2(U), 0 )\n#define H(p) ( fract(sin(float(p)*vec2(269.5,183.3)) *43758.5453123)*R/R.y )\n\nfloat L(vec2 p, vec2 a,vec2 b) { // --- draw line  ( squared distance )\n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b), \n          c = clamp(h, 0., 1.);     \n    return h==c ? dot(p -= b*h ,p) : 1e5; \n}\n\nvec2 field(vec2 U, sampler2D CH) {  // --- velocity field induced by texture\n    return  textureLod(CH, max(vec2(0,2./R.y), U*R.y/R),0.).rg * .2;\n}", "buffer_b_code": "// --- draw only curves which BBox covers the pixel\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n     R = iResolution.xy;\n     vec2 U = u / R.y, P, _P, b;\n    O =  .98*T(u);                         // cumulates previous draw\n   \n    for( float i=0.,l; i < 400.; i++ ) {   // draw N streamlines per frame\n        vec4 B = texelFetch(iChannel1,ivec2(i,0),0); // curve bbox\n        b = step(B.xy,U)*step(U,B.zw);\n     // if (b.x*b.y == 0.) continue;       //  this form crash Firefox !\n        if (b.x*b.y == 1.) {               // pixel not in BBox: skip draw\n        _P = P = H(i+.5-iTime);            // random start point\n        l = 9.;\n        for( int t=0; t <len; t++, _P = P ) // follow trajectory\n            P += field(P,iChannel1),\n            l = min( l, L(U,_P,P) );\n        O += .2*max(0., 1.-R.y*sqrt(l));   // draw the curve\n       }\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddf3RM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 115, 136, 267]], "test": "untested"}
{"id": "cdX3z7", "name": "flow streamlines - anim vort", "author": "FabriceNeyret2", "description": "inspiration: [url]https://twitter.com/canvas_51/status/1580528793520721920[/url]\nanimated vortices variant of [url]https://shadertoy.com/view/cdfGz7[/url]", "tags": ["flow", "irrotational", "vorticity", "reproduction"], "likes": 38, "viewed": 722, "published": 3, "date": "1665830486", "time_retrieved": "2024-07-30T16:26:11.730871", "image_code": "// animated vortices variant of https://shadertoy.com/view/cdfGz7\n\nvoid mainImage( out vec4 O, vec2 u )  {  \n    O = sqrt (1. - exp( - T(u) *vec4(1,2,4,1) ) ); \n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ---- compute BBoxs of next curves\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    R = iResolution.xy;\n    float i = u.x-.5, l = 9., p = 1./R.y;\n\n    if (u.y==1.5)\n        if (iFrame==0)  // O = H(i).xyxy;\n                           O = mix( .5*R/R.y, H(i).xy, .7 ).xyxy;\n        else _i=i, O=T(u), O = vec4(O.zw,mod(O.zw+field(O.zw,iChannel0),R/R.y));\n        \n    if (u.y==.5) {\n        vec2  P = H(i+.5-iTime), _P=P, m=P, M=P; // random start point\n\n        for( int t=0; t <len; t++, _P = P )      // follow trajectory\n            P += field(P,iChannel0),\n            m = min(m,P), M = max(M,P);        \n\n        O = vec4(m-p,M+p);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "int len = 20; // curve length ( i.e. number of samples )\nvec2 R;\n#define T(U)   texelFetch( iChannel0, ivec2(U), 0 )\n#define W(i)   texelFetch( CH, ivec2(i,1), 0 ).xy\n#define H(p) ( fract(sin(float(p)*vec2(269.5,183.3)) *43758.5453123)*R/R.y )\n\nfloat L(vec2 p, vec2 a,vec2 b) { // --- draw line  ( squared distance )\n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b), \n          c = clamp(h, 0., 1.);     \n    return h==c ? dot(p -= b*h ,p) : 1e5; \n}\n\n// WHY the HELL can't we use iChannel in Commons ?!?!?!?\n\nfloat _i = -1.;\nvec2 field(vec2 U,sampler2D CH) {    // --- velocity field induced by vortices ( Biot & Savart )\n    vec2 V = vec2(0), P;\n    for( float i=0.; i < 30.; i++ ){ // N random vortices ( same strength )\n        if (i==_i) continue;         // to avoid singularity for vorticies\n        P = W(i) - U;\n     // if (P==vec2(0)) continue;    // to avoid singularity for vorticies\n        V += vec2(-P.y,P.x)  * min(100.,.1/pow(length(P),3.)) \n                     // * sign(H(i+.3).y-.5)  // random sign\n                     // * (2.*H(i+.3).y-1.)   // random sign & strength\n                     // * H(i+.3).y*2.        // random strength\n                     ;\n                          // * min(100.,.2/dot(P,P) );\n    }\n    return V*1e-3;\n}", "buffer_b_code": "// --- draw only curves which BBox covers the pixel\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n     R = iResolution.xy;\n     vec2 U = u / R.y, P, _P, b;\n    O =  .9*T(u);                           // cumulates previous draw\n   \n    for( float i=0.,l; i < 400.; i++ ) {    // draw N streamlines per frame\n        vec4 B = texelFetch(iChannel1,ivec2(i,0),0); // curve bbox\n        b = step(B.xy,U)*step(U,B.zw);\n     // if (b.x*b.y == 0.) continue;        //  this form crash Firefox !\n        if (b.x*b.y == 1.) {                // pixel not in BBox: skip draw\n          _P = P = H(i+.5-iTime);           // random start point\n        l = 9.;\n        for( int t=0; t <len; t++, _P = P ) // follow trajectory\n            P += field(P,iChannel1),\n            l = min( l, L(U,_P,P) );\n        O += .2*max(0., 1.-R.y*sqrt(l));     // draw the curve\n    }}\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdX3z7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 106, 106, 162]], "test": "untested"}
{"id": "cdfGz7", "name": "flow streamlines - optim", "author": "FabriceNeyret2", "description": "inspiration: [url]https://twitter.com/canvas_51/status/1580528793520721920[/url]\noptimized version of https://shadertoy.com/view/csXGz7 .\nTry other characteristics of vortices in Common #18-20\nanimated version: see https://www.shadertoy.com/view/cdX3z7", "tags": ["flow", "irrotational", "vorticity", "reproduction"], "likes": 16, "viewed": 564, "published": 3, "date": "1665821611", "time_retrieved": "2024-07-30T16:26:12.671356", "image_code": "// optimized version of https://shadertoy.com/view/csXGz7\n// by precomputed bounding box of each new curve before drawing\n\nvoid mainImage( out vec4 O, vec2 u )  { \n    O = sqrt(T(u));\n // O = sqrt(1.-exp(-T(u)*vec4(4,2,1,1))); // color\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ---- compute BBoxs of next curves\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    if (u.y>1.) discard;\n    R = iResolution.xy;\n    float i = u.x-.5, l = 9., p = 1./R.y;\n    vec2  P = H(i+.5-iTime), _P=P, m=P,M=P;  // random start point\n    \n    for( int t=0; t <len; t++, _P = P )      // follow trajectory\n        P += field(P),\n        m = min(m,P), M = max(M,P);        \n\n    O = vec4(m-p,M+p);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "int len = 20; // curve length ( i.e. number of samples )\nvec2 R;\n#define T(U)   texelFetch( iChannel0, ivec2(U), 0 )\n#define H(p) ( fract(sin(float(p)*vec2(269.5,183.3)) *43758.5453123)*R/R.y )\n\nfloat L(vec2 p, vec2 a,vec2 b) { // --- draw line  ( squared distance )\n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b), \n          c = clamp(h, 0., 1.);     \n    return h==c ? dot(p -= b*h ,p) : 1e5; \n}\n\nvec2 field(vec2 U) {  // --- velocity field induced by vortices ( Biot & Savart )\n    vec2 V = vec2(0), P;\n    for( float i=0.; i < 30.; i++ ) // N random vortices ( same strength )\n        P = H(i) - U,\n        V += vec2(-P.y,P.x)  * min(100.,.1/pow(length(P),3.));\n                 // * sign(H(i+.3).y-.5); // random sign\n                 // * (2.*H(i+.3).y-1.);  // random sign & strength\n                 // * H(i+.3).y*2.;       // random strength\n                          // * min(100.,.2/dot(P,P) );\n    return V*1e-3;\n}", "buffer_b_code": "// --- draw only curves which BBox covers the pixel\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n     R = iResolution.xy;\n     vec2 U = u / R.y, P, _P, b;\n    O =  .98*T(u);                         // cumulates previous draw\n   \n    for( float i=0.,l; i < 80.; i++ ) {    // draw N streamlines per frame\n        vec4 B = texelFetch(iChannel1,ivec2(i,0),0); // curve bbox\n        b = step(B.xy,U)*step(U,B.zw);\n     // if (b.x*b.y == 0.) continue;       //  this form crash Firefox !\n        if (b.x*b.y == 1.) {               // pixel not in BBox: skip draw\n        _P = P = H(i+.5-iTime);            // random start point\n        l = 9.;\n        for( int t=0; t <len; t++, _P = P ) // follow trajectory\n            P += field(P),\n            l = min( l, L(U,_P,P) );\n        O += .2*max(0., 1.-R.y*sqrt(l));   // draw the curve\n       }\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdfGz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 162, 162, 237]], "test": "untested"}
{"id": "csXGz7", "name": "flow streamlines", "author": "FabriceNeyret2", "description": "inspiration: [url]https://twitter.com/canvas_51/status/1580528793520721920[/url]\n\nsee optimized version here: [url]https://www.shadertoy.com/view/cdfGz7[/url]", "tags": ["flow", "vorticity", "reproduction"], "likes": 12, "viewed": 329, "published": 3, "date": "1665819833", "time_retrieved": "2024-07-30T16:26:13.470220", "image_code": "// see optimized version here: https://www.shadertoy.com/view/cdfGz7\n\nvoid mainImage( out vec4 O, vec2 u )  \n{  O = sqrt(T(u)); }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define R iResolution.xy\n\n#define H(p) ( fract(sin(float(p)*vec2(269.5,183.3)) *43758.5453123)*R/R.y )\n\nfloat L(vec2 p, vec2 a,vec2 b) { // --- draw line  ( squared distance )\n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b), \n          c = clamp(h, 0., 1.);     \n    return h==c ? dot(p -= b*h ,p) : 1e5; \n}\n\nvec2 field(vec2 U) {  // --- velocity field induced by vortices ( Biot & Savart )\n    vec2 V = vec2(0), P;\n    for( float i=0.; i < 30.; i++ ) // N random vortices ( same strength )\n        P = H(i) - U,\n        V += vec2(-P.y,P.x)  * min(100.,.1/pow(length(P),3.)); // * H(i+.3).y*2.; // random strength\n                          // * min(100.,.2/dot(P,P) );\n    return V*1e-3;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u / R.y, P, _P;\n    O =  T(u);                             // cumulates previous draw\n    \n    for( float i=0.,l; i < 2.; i++ ) {     // draw N streamlines per frame\n        _P = P = H(i+.5-iTime);            // random start point\n        l = 9.;\n        for( int t=0; t <20; t++, _P = P ) // follow trajectory\n            P += field(P),\n            l = min( l, L(U,_P,P) );\n        O += .2*max(0., 1.-R.y*sqrt(l));   // draw the curve\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csXGz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 110, 110, 129]], "test": "untested"}
{"id": "Dsf3R7", "name": "optical illusion: bulged checker", "author": "FabriceNeyret2", "description": "reference: [url] https://twitter.com/AkiyoshiKitaoka/status/1580868896621441024 [/url]", "tags": ["2d", "opticalillusion", "perception", "short", "short", "golf", "reproduction", "3tweets"], "likes": 29, "viewed": 306, "published": 3, "date": "1665817725", "time_retrieved": "2024-07-30T16:26:14.331916", "image_code": "#define B(c,v)  O = mix( O, vec4(c), smoothstep(12./R.y,0., v ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 4.5*( u+u - R ) / R.y +.5,\n         I = ceil(U), A = abs(U-.5);\n    O = vec4(.5 + .3*mod(I.x+I.y,2.));\n    \n    if (max(A.x,A.y) < 4. )\n        I = ceil( U = abs(U-.5) ),\n        A = abs( U = fract(U)-.5 ),\n        B( mod(I.x+I.y+ceil(iTime),2.), length(U)-.25 ),\n        B( .65, min(A.x,A.y) );        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dsf3R7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 105, 105, 453]], "test": "untested"}
{"id": "cdXGR7", "name": "wave equation single source", "author": "ilia87", "description": "wave equation with a single source. Use mouse to set source position.", "tags": ["waves", "mouseinput", "differenceequation"], "likes": 11, "viewed": 231, "published": 3, "date": "1665810488", "time_retrieved": "2024-07-30T16:26:15.169676", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0)*.1+vec4(.5);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.,0.,0.,1.);\n    vec2 waveSrc = iMouse.xy / vec2(iResolution.y);\n    if (iMouse.x == 0. && iMouse.y == 0.)\n    {\n        float s = 0.4;\n        waveSrc = .3 * vec2(cos(iTime*s),sin(2.*iTime*s))  + iResolution.xy/iResolution.y*.5;\n    }\n    float waveSrcSize = .005;\n    float waveSrcFreq = 5.1;\n    //float waveLength = 2.;\n    float waveSpeed = 3.3;\n    float dampRate = 0.3;\n    \n    vec2 uv = fragCoord / iResolution.y;\n    \n    float d2 = dot(uv - waveSrc,uv-waveSrc);\n    fragColor.xy = exp(-d2/(waveSrcSize*waveSrcSize)) * vec2(sin(waveSrcFreq*iTime),waveSrcFreq*cos(waveSrcFreq*iTime));\n    \n    vec4 prevPixel = texelFetch(iChannel0,ivec2(fragCoord),0);\n    float h = prevPixel.x;\n    float dh_dt = prevPixel.y;\n    \n    float L = 0.;\n    for ( int i=0;i<5;++i)\n    {\n        for ( int j=0;j<5;++j)\n        {\n            L -= texelFetch(iChannel0,ivec2(int(fragCoord.x)+i-2,int(fragCoord.y)+j-2),0).x;\n        }\n    }\n    L += 25.*h;\n    \n    float d2h_dt2 = -L*(waveSpeed*waveSpeed);\n    dh_dt += d2h_dt2 * iTimeDelta;\n    h += dh_dt * iTimeDelta;\n    \n    h *= exp(-iTimeDelta*dampRate);\n    \n    fragColor.x += h;\n    fragColor.y += dh_dt;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdXGR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 129]], "test": "untested"}
{"id": "DdX3zM", "name": "Fractal mosaic 21 (music)", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 4, "viewed": 230, "published": 3, "date": "1665806620", "time_retrieved": "2024-07-30T16:26:15.926652", "image_code": "#define fmod(x,y) mod(floor(x),y)\nvec2 triangle_wave(vec2 a){\n    //a += floor(a/2.);\n    vec2 a2 = //change this constant to get other interesting patterns\n        //vec2(1.,0.5)\n        //vec2(sign(a.y-a.x)+sign(a.x)/2.,sign(a.x-a.y)+sign(a.y)/2.)\n        -vec2(1.,2.5)\n        \n        //vec2(-2.,.5+mod(floor(a.x),2.))\n    ,\n    \n    \n    a1 = a2+a;\n    //a1 -= floor(a1/2.)/2.;\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 16.*4.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    bool t3 = true;\n    for(int k = 0; k < 6; k++){\n        t3 = uv.x > uv.y;\n        float t4 = floor(uv.x-uv.y);\n        uv =\n            abs(.5+uv)\n            //max(abs(uv+t2),abs(.5+uv+t2))\n            //abs(.5+uv+t2)*fract(uv/4.) //another interesting pattern\n        ;\n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*3.)-.5)/3.;\n        //uv += (distance(floor(uv),round(uv+.5)));\n\n        //if(uv.y>uv.x) uv = uv.yx; else uv *= sign(uv-uv.yx);\n        t2 =\n            -triangle_wave(uv-.5)\n            //-triangle_wave(uv-.5-t4)\n        ;\n        //t2 -= float(!t3)/2.;\n        uv =\n            t2-triangle_wave(uv.yx)\n            //t2-triangle_wave(uv.yx-floor(uv.x+uv.y))\n            //t2-triangle_wave(uv.yx-floor(t2.x-t2.y))\n        ;\n        //uv = fract(uv);\n        //uv = fract(uv)*fract(uv/2.)*fract(uv/4.);\n\n        float c1 =\n            (uv.x-uv.y)\n            //(uv.x*uv.y)\n            //abs(uv.x-uv.y)\n        ;\n        col = col.yzx;\n        vec3 col1 = col;\n        if(!(t4==0.) || uv.y < uv.x) col1 = abs(col.yzx-vec3(col.yz,c1));\n        if((t4==0.) || uv.y > uv.x) col1 = abs(col1-max(col,vec3(col.yz,c1)));\n        col = col1;\n        //col *= col+.5;\n        //if(t3 && uv.y < uv.x) col = vec3(col.yz,c1);\n\n    }\n    fragColor = vec4(min(col*2.,vec3(1.)),1.0);\n}\n", "image_inputs": [], "sound_code": "float fmod2(float a, float b){\n    return mod(floor(a/b),b)*b;\n}\n\nfloat fmod(float a, float b){\n    //a += fmod2(a*2.,8.);\n    /*\n    for(float a2 = 16.; a2 < 128.; a2 *= 2.){\n        a2 *= 2.;\n        a += mod(floor(a/a2),2.);\n    }\n    */\n    //divide by powers of 2 to get interesting rhythms\n    float a1 = a;\n    //a /= 1. + mod(floor(a1/8.),2.);\n    //a /= 1. + mod(floor(a1/4.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    return\n        mod(floor(a),b)\n        //mod(mod(floor(a/2.+2.),b*2.),b)\n        //mod(floor(a/b*2.),b)\n        //mod(floor(a)*floor(a*4./b),b)\n        //mod(floor(a)*mod(floor(-a*sign(.5-mod(floor(a/b/4.),3.))),b),b)\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n    ;\n}\n//#define fmod(a, b) mod(mod(floor((a)),floor(1.+(a)/2.)),b)\n#define fmax(x,y,z) max(fmod(x,z),fmod(y,z))\n#define fmod1(x,y) mod(floor(x)-mod(floor((x)/2.)/2.,y)*2.,y)\n#define fmod2(x,y) mod(mod(floor(x),y*1.5),y)\n#define smod(x,y) mod(floor(x)*floor(x),y)\n#define powmod(x,y) mod(floor(pow(y,mod(floor(x)/y,y))),y)\nvec2 mainSound(int samp, float time){\n  \n  float tempo = 1.;\n  time /= tempo;\n  \n  //float d1 = floor(time*8.+floor(time/8.));\n  //time += d1/8.;\n  \n  //time -= pow(2.,fmod(time*8.,5.))*pow(2.,fmod(time,7.));\n  \n  //time = time*(1. + fmod(time*8.,2.))/2.;\n\n  \n  float s1 =\n      8.,\n      //5./(1.+fmod(time/2.,2.)), //varying tempo\n  m4 =\n      fmod(time/s1+floor(time*s1),2.)\n      //fmax(time/s1+floor(time*s1),time/s1,2.)\n  ,\n  s2 =\n      //8./(1.+m4)\n      8.\n  ,\n  \n  t= //varying tempo\n      //time\n      time*(1.+m4)/2.\n      //time/(1.+fmod(time*s1,2.))\n      //time/(1.+fmod(time/s1+floor(time*s1),2.))\n      //time/(1.+fmod(time*s1+floor(time),2.))\n      //time*(1.+fmod(time*s1,2.))/2.\n  ;\n  //t += mod(floor(t*8.),8.)*8.;\n  float m1 =\n      fmod(t*s2,s2)\n      //fmod(t/s1+floor(t*s1),s2)\n      //fmod(t*s1+floor(t/s1),s2)\n  ,\n  //m4 = fmod(t*s1,s1),\n  m3 =\n      fmod(t/(m1+.5),s2);\n      //fmod(t*(s1+m4)/(m1+.5),s2);\n      //fmod((t+m1)*s1/(m4+.5),s2);\n      //fmod(t*s1/abs(2.5-m1),s2);\n  \n  //m1 = fmod(t/s1,s2),\n  \n  //t += m3/2.;\n  t *= s1*s1;\n  float c1 = (t/s1+floor(t/s1))/2.;\n  t /=  //varying tempo\n      (1.+fmod(c1,2.))\n      //(1.+fmod(t/s1+floor(t*s1),2.))\n  ;\n  \n  \n    float m2 =\n      1. + fmod(t/s1,s1)\n      //1. + fmod(t/s1,8./(1.+fmod(t/s1,2.)))\n      //1. + fmod(t/s1,s1/2.)*fmod(t/s1/2.,s1/2.)\n      //1. + min(fmod(time,s1),t)\n  ;\n  //t /= max(m2,m1+m3+1.);\n  \n  //m3 = mod(floor(t/s1),s2-m3);\n  //m2 = mod(floor(t/s1),1.+s1-m2);\n  \n  float a=\n      //sqrt((1.-sqrt(fract(t/s1))))*.2\n      //pow(1.-sqrt(fract(t/s1)/2.),2.)\n      //pow(log(1./16./2.+fract(t/s1)/8.),2.)\n      64.*pow(sqrt(fract(-t/s1)/2.)/1.25,2.)\n  ,\n  \n\n  \n  nb =\n      time*tempo*pow(2.,(m3+m2)/5.+5.5)\n      //pow(2.,1.-m4+(m3+m2)/5.+6.5)\n  ;\n\n  return\n      abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a\n      \n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n  ;\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdX3zM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 61, 85, 550], [552, 552, 609, 609, 2183]], "test": "untested"}
{"id": "dssGzN", "name": "glowing kaleidostepper", "author": "ufffd", "description": "classic", "tags": ["fractal", "kaleidoscope", "mandala"], "likes": 6, "viewed": 274, "published": 3, "date": "1665783062", "time_retrieved": "2024-07-30T16:26:16.835223", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    vec3 finalcol = vec3(0.);\n    for (int fs=1;fs<3;fs++) {\n        vec3 col = vec3(0.);\n        vec2 fuv = uv/float(fs); // fractal uv\n        if (fs==2) fuv.y *= -1.;\n        for (int i=0; i<8; i++) {\n            // fuv *= Rot(sin(iTime*0.1)*6.28);\n            float f1 = (smoothstep(0.8,1.,fract(iTime))+floor(iTime))*0.5;\n            float steptime = mix(f1,iTime+0.25,0.0);\n            steptime *= PI;\n            steptime /= 4.;\n            fuv *= Rot(steptime);\n            fuv.y += 0.05;\n            fuv = abs(fuv);\n        }\n\n        col.r = smoothstep(0.,.5,length(fuv-0.25-sin(iTime*0.11)*0.1));\n        col.r *= mix(1.,smoothstep(-1.,-0.95,sin(fuv.y*20.-iTime)),sin(iTime+fuv.x));\n        col.r = sin(col.r+5.);\n        col.r *= col.r;\n        for (int i=0; i<8; i++) {\n            fuv *= Rot(sin(iTime+0.25));\n            fuv.y += 0.05;\n            fuv = abs(fuv-0.5);\n        }\n\n        col.g = smoothstep(0.15,0.3,length(fuv-0.25-sin(iTime*0.12)*0.1));\n        for (int i=0; i<8; i++) {\n            fuv *= Rot(-0.1*iTime+0.25);\n            fuv.y += 0.5;\n            fuv = abs(fuv-0.5);\n        }\n\n        col.b = smoothstep(0.,0.3,length(fuv-0.25-sin(iTime*0.13)*0.1));\n        col.b += col.g*smoothstep(.1,0.9,length(fuv));\n        col.b -= length(fuv);\n\n        col = mix(col,0.5*col,smoothstep(1.6,1.1,col.r+col.g+col.b));\n        col += col.r * 0.5;\n        col *= 1.-smoothstep(0.4,1.,length(uv)/float(fs));\n        finalcol += col;\n    }\n    finalcol.g *= finalcol.r;\n    \n    // Output to screen\n    fragColor = vec4(finalcol,1.0);\n}", "image_inputs": [], "common_code": "#define TAU 6.283185307\n#define PI 3.1415926535\n\nfloat nsin(float a){return sin(a)*0.5+0.5;}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nbool nearly(in float a, in float b) {\n    return abs(a - b) < 0.001;\n}\n\nmat2 Rot(in float a) {\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssGzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1675]], "test": "untested"}
{"id": "ddl3zN", "name": "normal mapping test", "author": "vital_ash", "description": "Renders iChannel1 and uses iChannel0s red and green channels to create an arbitrary direction. This direction is then compared to the light source using a dot product which then becomes a multiplier for lightness.\n", "tags": ["normals", "learning"], "likes": 2, "viewed": 173, "published": 3, "date": "1665782563", "time_retrieved": "2024-07-30T16:26:17.656030", "image_code": "\n#define USE_LIGHT_PROXIMITY 1\n#define USE_FAKE_NORMALS 1\n\nfloat getLightIntensity(vec2 lightPosNorm, vec2 viewerPos) {\n    return pow(1.0-max(0.0,min(1.0,distance(lightPosNorm, viewerPos))),2.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 lightPosition = vec2(cos(iTime)/2.0+0.5,sin(iTime)/2.0+0.5);\n    \n    float intensity = getLightIntensity(lightPosition, uv);\n    vec3 bg = vec3(intensity*1.0,intensity*0.8,intensity*0.4);\n    \n    vec2 start = vec2(0.4,0.3);\n    vec2 end = vec2(0.7,0.7);\n\n    vec2 boxCoords = uv / (end-start) - start*2.5;\n    if(boxCoords.x < 0.0 || boxCoords.x > 1.0 || boxCoords.y < 0.0 || boxCoords.y > 1.0) {\n        fragColor = vec4(bg,1.0);\n    } else {\n        vec4 spriteUV = texture(iChannel1,boxCoords);\n        vec4 fakeNormalUV = texture(iChannel0,boxCoords);\n        if(USE_LIGHT_PROXIMITY == 1) {\n            spriteUV *= intensity*10.0;\n        }\n        vec2 directionMagnitudeNormal;\n        directionMagnitudeNormal = normalize(vec2((1.0-fakeNormalUV.x)-0.5,(1.0-fakeNormalUV.y)-0.5));\n        float amt = dot(normalize(lightPosition-uv),directionMagnitudeNormal)/2.0+1.0;\n        if(USE_FAKE_NORMALS == 1) {\n            spriteUV *= amt;\n        }\n        fragColor = vec4(spriteUV.xyz,1.0);\n    }\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddl3zN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 119, 119, 198], [201, 201, 258, 308, 1361]], "test": "untested"}
{"id": "dsl3RN", "name": "rocks ripples", "author": "vital_ash", "description": "Rocks move leftwards, some areas are offset differently based on iChannel1s X component.", "tags": ["scroll", "ripple"], "likes": 1, "viewed": 168, "published": 3, "date": "1665779067", "time_retrieved": "2024-07-30T16:26:18.411010", "image_code": "\nfloat lerp(float x, float y, float a) { return (y-x)*a + x; }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\n    // Time varying pixel color\n    \n    vec3 res = iChannelResolution[0];\n    \n    vec2 final = fragCoord/res.xy;\n    vec4 sampleThing = texture(iChannel1,vec3(fragCoord/iResolution.xy,1));\n    vec2 offset;\n    float chosen = sampleThing.x;\n    offset.x = lerp(iTime,iTime * chosen,0.0075);\n    offset.y = 0.0;\n    \n    vec2 uv = final + offset;\n    \n    // Output to screen\n    vec4 multi = texture(iChannel0, uv);\n    fragColor = vec4(multi.x,multi.x,multi.x ,1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsl3RN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 40, 40, 62], [63, 63, 120, 203, 642]], "test": "untested"}
{"id": "dssGRN", "name": "Artober - Respiration", "author": "Flopine", "description": "Day 14 of october's everyday challenge. It's kinda tough to get 14 ideas in 14 days ><", "tags": ["raymarching", "transparency", "truchet", "everyday"], "likes": 9, "viewed": 149, "published": 3, "date": "1665776185", "time_retrieved": "2024-07-30T16:26:19.167986", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n#define hr vec2(1.,sqrt(3.))\n\n#define circle(u,s) (length(u)-s)\n\n#define noise(u) textureLod(iChannel0, u, 0.).x\n#define hash21(x) fract(sin(dot(x,vec2(145.2, 218.5)))*4123.5)\n\nvec4 hexgrid (vec2 uv)\n{\n    vec2 a=mod(uv,hr)-hr*.5, b=mod(uv-hr*.5,hr)-hr*.5,\n    guv=dot(a,a)<dot(b,b)?a:b, gid=uv-guv;\n    return vec4(guv,gid);\n}\n\nfloat truchet (vec2 uv)\n{\n    vec4 hg = hexgrid(uv);\n    vec2 uu = hg.xy, uid = hg.zw;\n    \n    if (noise(uid*.23)<.5) uu.x *= -1.;\n    float diag = abs(uu.x*sqrt(3.)+uu.y)-0.2;\n    \n    float s = uu.x*sqrt(3.)>-uu.y ? 1.:-1.;\n    uu -= vec2(1., 1./sqrt(3.))*s*.5;\n    float cs = abs(circle(uu, sqrt(3.)/6.));\n    \n    return min(cs,diag);\n}\n\nfloat extrude (vec3 p, float d, float h, float r)\n{\n    vec2 q = vec2(d, max(length(p.xy)-r, abs(p.z)-h));\n    return length(q)-h;\n}\n\nfloat SDF (vec3 p)\n{\n    p.z = abs(p.z)-3.;\n    float r = sin(length(p)-iTime)*.5+.5;\n    return extrude(p, truchet(p.xy), 0.2, r*6.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float dither = hash21(uv);\n    \n    vec3 ro = vec3(0.001,0.001,-4.5), rd=normalize(vec3(uv,1.)), p=ro,\n    col=vec3(0.);\n    \n    bool hit = false; float shad;\n    for(float i=0.; i<64.;i++)\n    {\n        float d = SDF(p);\n        if(d<0.001)\n        {\n            hit=true; shad = i/64.;\n        }\n        d = max(abs(d)+dither*.008,0.01);\n        p += d*rd;\n    }\n    \n    if (hit) col = vec3(.8,0.9,1.)*shad;        \n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssGRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[547, 547, 571, 571, 697], [699, 699, 724, 724, 1040], [1042, 1042, 1093, 1093, 1174], [1176, 1176, 1196, 1196, 1312], [1314, 1314, 1371, 1371, 1898]], "test": "untested"}
{"id": "mdsGR4", "name": "glossy globs", "author": "ufffd", "description": "glassy topcoat idear", "tags": ["raymarch", "materials"], "likes": 8, "viewed": 362, "published": 3, "date": "1665775716", "time_retrieved": "2024-07-30T16:26:19.925960", "image_code": "// with wisdom from:\n// Nrx glass polyhedron - https://www.shadertoy.com/view/4slSzj\n// artofcode raymarch - https://www.shadertoy.com/view/WtGXDD\n// artofcode bending light - https://www.shadertoy.com/view/sllGDN\n\n#define PI 3.141592653589793\n#define MAX_STEP 100\n#define MAX_DIST 10000.\n#define SURF_DIST 0.001\n#define JIGGLE .1\n\n#define DELTA\t\t\t\t0.001\n#define RAY_COUNT\t\t\t7\n#define RAY_LENGTH_MAX\t\t100.0\n#define RAY_STEP_MAX\t\t60\n#define REFRACT_FACTOR\t\t.6\n#define REFRACT_INDEX\t\t1.2\n#define AMBIENT\t\t\t    0.7\n#define SPECULAR_POWER\t\t1.5\n#define SPECULAR_INTENSITY\t1.7\n#define FADE_POWER\t\t\t1.1\n\nfloat nsin(float a){return sin(a)*0.5+0.5;}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nbool nearly(in float a, in float b) {\n    return abs(a - b) < 0.001;\n}\n\nmat2 Rot(in float a) {\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat columnDist( vec3 p, vec3 c, vec3 r ) { \n    p.xy *= Rot(r.x);\n    // p.yz *= Rot(r.y);\n    // p.zx *= Rot(r.z);\n    return length(p.xz-c.xy)-c.z; \n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvec2 texNormalMap(in vec2 uv, in sampler2D tx, in vec2 txr)\n{\n    vec2 s = 1.0/txr.xy;\n    \n    float p = texture(tx, uv).x;\n    float h1 = texture(tx, uv + s * vec2(1,0)).x;\n    float v1 = texture(tx, uv + s * vec2(0,1)).x;\n       \n   \treturn (p - vec2(h1, v1));\n}\n\nfloat sphereDist(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 map(vec3 p) {\n    float mater = -1.;\n    float d = 1000.;   \n    \n    // sphere 1\n    vec3 sphere1p = p - vec3(0.) + JIGGLE*vec3(\n        noise(vec2(iTime*.7,1.)),\n        noise(vec2(iTime*.8,2.)),\n        noise(vec2(iTime*.9,3.))\n    );\n    float sphere1 = sphereDist(sphere1p + 0.04 - sin(p.y*10.)*0.03 - sin(p.x*p.y*70.+iTime*2.)*0.005 - sin(p.x*10.)*0.02, 0.8);\n    for (int i=0; i<10;i++) {\n        vec3 orboffset = vec3(.9,0.,0.)*(.7+float(i)*0.05);\n        orboffset.xy *= Rot(iTime*-1.-float(i)*0.1);\n        orboffset.xz *= Rot(iTime+float(i)*0.1);\n        vec3 orbp = sphere1p + orboffset;\n        float orb = sphereDist(orbp,0.1);\n        sphere1 = smin(sphere1, orb, 0.2);\n    }\n    for (int i=0; i<10;i++) {\n        vec3 orboffset = vec3(0.,.9,0.)*(.7+float(i)*0.05);\n        orboffset.xy *= Rot(iTime+float(i)*0.1);\n        orboffset.xz *= Rot(iTime+float(i)*0.1);\n        vec3 orbp = sphere1p + orboffset;\n        float orb = sphereDist(orbp,0.1);\n        sphere1 = smin(sphere1, orb, 0.2);\n    }\n    sphere1 = max(-sphereDist(sphere1p,0.65),sphere1);\n    // sphere 2\n    sphere1p.xz *= Rot(iTime*2.);\n    float sphere1in = sphereDist(sphere1p, 0.62);\n    sphere1 = max(-sphere1in, sphere1);\n    if (sphere1 < 0.001) mater = 2.;\n    d = min(d, sphere1);\n    if (sphere1in < 0.001) mater = 1.;\n    d = min(d, sphere1in);\n    \n    return vec2(d, mater);\n}\n\nvec3 getNorm(vec3 p) {\n    vec2 mapr = map(p);\n    vec2 e = vec2(.001, 0);\n    \n\tfloat d = mapr.x;\n    vec3 n = vec3(0.);\n    \n    int method = 1;\n    // method 1\n    if (method==1) { \n        n = d - vec3(\n            map(p-e.xyy).x,\n            map(p-e.yxy).x,\n            map(p-e.yyx).x);\n    }\n    // method 2\n    if (method==2) {\n        n = vec3(\n            map(p+e.xyy).x - map(p-e.xyy).x,\n            map(p+e.yxy).x - map(p-e.yxy).x,\n            map(p+e.yyx).x - map(p-e.yyx).x);\n    }\n    \n    return normalize(n);\n}\n\nvec3 getLightPos(in float i) {\n    vec3 lightPos = vec3(0, 0, -1);\n    lightPos.xz += vec2(sin(iTime+i), cos(iTime+i))*2.;\n    return lightPos;\n}\n\nfloat getLight(vec3 p, vec3 n, in vec3 rd) {\n    float dif = 0.;\n    float spec = 0.;\n    for (int i = 0; i<8; i++) {\n        for (int j=0; j<5; j++) {\n            vec3 lp = getLightPos(float(i)*0.5) + vec3(0.,float(j)-2.5 + sin(iTime*0.2)*2.,0.);\n            vec3 l = normalize(lp-p);\n\n            dif += clamp(dot(n, l), 0., 1.);\n            float d = map(p+n*SURF_DIST*2.).x;\n            if(d<length(lp-p)) dif *= .1;\n\n            spec += pow(max( dot( reflect(-l, n), -rd ), 0.), 60.);\n        }\n    }\n    \n    return dif*5. + spec;\n}\n\nvec3 getCol(vec3 p, float mater, in vec3 rd, in vec3 norm) {\n    vec3 col = vec3(0.);\n    if (mater < 0.) {\n        return vec3(0.0);\n    } else if (mater < 0.5) {\n        col = norm;\n        col *= norm;\n    } else if (mater < 1.5) {\n        col = vec3(sin(norm.g*10.+norm.r*4. + iTime*.2 + 2.*noise(20.*p.xy*p.yz)));\n        col *= norm;\n        col = col.brr*2.;\n        col.r = smoothstep(0.1,0.2,col.r) * 0.5 + 0.1;\n        col.b = smoothstep(0.1,0.2,col.b) * 0.5 + 0.1;\n        col.g *= .5 + 0.1;\n    } else if (mater < 2.5) {\n        vec2 txuv = norm.rg;\n        txuv.y += iTime * 0.1;\n        txuv.x *= .5;\n        vec3 text = texture(iChannel0, txuv*0.15).rrr;\n        col = mix(col,text*0.2,1.-col.r);\n        col.b += noise(p.xy * 3. + iTime)*0.1;\n        col.b += noise(p.xy * 2. + iTime)*0.1;\n        col.r += noise(p.xy * 2.5 + iTime*1.1)*0.1;\n    } else if (mater < 3.5) {\n        col = norm;\n        col = vec3(sin(norm.b*100.));\n    } else if (mater < 4.5) {\n        col = p * mat3(vec2(0.5), 0.1, vec2(0.2), 0.9, vec2(0.4), 1.);\n        // col = vec3(sin(norm.g*100.));\n    } else {\n        col = vec3(0.9,0.85,0.8) * 0.1;\n    }\n    return col;\n}\nvec3 k = vec3(0.);\n\nbool doesBounce(in float mater) {\n    if (mater > 1.5 && mater < 2.5) return true; // 2\n    if (mater > 4.5 && mater < 5.5) return true; // 5\n    return false;\n}\n\nvec3 materNorm(in float mater, in vec3 norm) {\n    vec3 mN;\n    if (mater > 1.5 && mater < 2.5) {\n        // todo - improve texturing https://www.youtube.com/watch?v=VaYyPTw0V84        \n        // repeated code...\n        vec2 txuv = norm.rg;\n        txuv.y += iTime * 0.1;\n        txuv.x *= .5;\n        txuv *= 0.15;\n        mN = texNormalMap(txuv, iChannel0, iChannelResolution[0].xy).xyx;\n    }\n    return mN;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 p, ro, rd, col;\n    ro = vec3(0.5,0.3,-3.); \n    ro.xz *= Rot(iTime*0.3);\n    ro -= JIGGLE*sin(vec3(iTime*1.,iTime*0.22,iTime*0.91));    \n    rd = normalize(vec3(uv.x-.15, uv.y-.2, 1.));\n    rd.xz *= Rot(iTime*0.3);\n    rd.yz *= Rot(sin(iTime)*0.05);\n    rd.xy *= Rot(sin(iTime*1.1)*0.05);\n    rd.zx *= Rot(sin(iTime*0.9)*0.05);\n    vec3 ord = rd;\n       \n    \n    float d = 0.;\n    bool hit = false;\n    bool hit_matte = false;\n    float glow = 0.;\n    float mater = -1.;\n\tvec2 delta = vec2 (DELTA, 0.0);\n    \n    float intensity = 0.;\n\n    // vec3 backColor = vec3(0.,0.01,0.02) * (1.-length(uv + vec2(0.,0.3)));\n    vec3 backColor = vec3(24., 27., 23.)/255.;\n    col = vec3(0.);\n\n\tfloat distanceFactor = 1.0;\n\tfloat refractionRatio = 1.0 / REFRACT_INDEX;\n\tfloat rayStepCount = 0.0;\n\tfor (int rayIndex = 0; rayIndex < RAY_COUNT; ++rayIndex) {\n        d = 0.; // reset ray dist\n        float ds = 0.; // distance step\n        for(int i=0;i<MAX_STEP;i++){\n            p = ro + rd * d; // update current point\n            vec2 mapr = map(p);\n            ds = mapr.x; // map distance\n            ds *= distanceFactor; // flip sdf when inside\n            mater = mapr.y; // material index\n            d += max(ds, DELTA); // update march distance\n            if(ds<0.) { hit=true; break; } // check hit\n            if(d>MAX_DIST) break; // check limit\n            glow += 1./ds; // add glow\n        }\n        if (!hit) {col = backColor; break;}\n        vec3 norm = distanceFactor*getNorm(p);\n        // material color\n        col += getCol(p,mater,rd,norm) * AMBIENT;\n        // matte lighting\n        float light = getLight(p, norm, rd);\n        if (rayIndex==0) { // light the inside only\n            col += mix(vec3(light*light), vec3(0.), smoothstep(0.,0.5,ds)); // light outside\n            col = mix(col, backColor, smoothstep(0.,0.5,ds)); // background\n        }\n        if (rayIndex==2) { // light the inside only\n            col += 0.1*mix(vec3(light*light), vec3(0.), smoothstep(0.,0.5,ds)); // light outside\n            col = mix(col, backColor, smoothstep(0.,0.5,ds)); // background\n        }\n        // check for bounces\n        bool do_bounce = doesBounce(mater);\n        if (!do_bounce) {\n            // hit matte, done bouncing\n            break;\n        } else {\n            // col *= 0.1;\n            // apply normal to material 2 - note: make this a conditional if more reflective/refractive materials are added\n            norm += 1.*materNorm(mater, norm);\n            \n            vec3 reflection = reflect(rd, norm);            \n            // reflection light (i think it should be in getLight fxn so I can call it with multiple lights)\n            if (distanceFactor > 0.) { // only calculate light on outside\n                /*\n                vec3 lp = getLightPos(0.5);\n                vec3 lightDirection = normalize(lp-p);\n                float reflectDiff = max (0.0, dot (norm, lightDirection));\n                float reflectSpec = pow (max (0.0, dot (reflection, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n                float fade = pow (1.0 - d / RAY_LENGTH_MAX, FADE_POWER);\n\n                vec3 localColor = max(sin (k * k), 0.2);\n                localColor = (AMBIENT + reflectDiff) * localColor + reflectSpec;\n                localColor = mix(backColor, localColor, fade);\n\n                col = col * (1.0 - intensity) + localColor * intensity;\n                intensity *= REFRACT_FACTOR;\n                */\n                \n                float fade = pow (1.0 - d / RAY_LENGTH_MAX, FADE_POWER);\n\n                vec3 localColor = max(sin (k * k), 0.2);\n                localColor = (AMBIENT + light) * localColor;\n                localColor = mix(backColor, localColor, fade);\n\n                col = col * (1.0 - intensity) + localColor * intensity;\n                intensity *= REFRACT_FACTOR;\n                \n            }\n\n            // Next ray...\n            ro = p;\n            vec3 refraction = refract(rd, norm, refractionRatio);\n            if (dot (refraction, refraction) < DELTA) { // reflect at grazing angles, idk how the dot math works here\n                // fragColor = vec4(1.,1.,0.,1.); return;\n                rd = reflection; // update ray dir to reflected angle\n                ro += rd * DELTA * 2.0; // step away from surface\n            } else {\n                rd = refraction; // update ray dir to refracted angle\n                ro += rd * DELTA * 2.0; // step away from surface - not needed?\n                refractionRatio = 1.0 / refractionRatio; // reverse refraction ratio \n                distanceFactor = -distanceFactor; // flip sdf sign while inside\n            }\n        }\n        \n        // todo: chromatic aberation, optical density, bevel, fresnel reflection\n        // https://www.youtube.com/watch?v=0RWaR7zApEo\n    }\n    \n    \n    \n    // col += glow*glow*glow*0.000000000000001 * nsin(iTime*.5);\n\n    // Output to screen\n    // col = pow(col, vec3(1.45));\t// gamma correction\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdsGR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[597, 597, 617, 617, 640], [642, 642, 662, 662, 729], [731, 731, 768, 768, 801], [803, 803, 825, 825, 891], [893, 893, 937, 937, 1047], [1049, 1049, 1069, 1069, 1278], [1280, 1280, 1341, 1341, 1545], [1547, 1547, 1582, 1582, 1610], [1612, 1612, 1653, 1653, 1746], [1748, 1748, 1766, 1766, 3121], [3123, 3123, 3145, 3145, 3649], [3651, 3651, 3681, 3681, 3796], [3798, 3798, 3842, 3842, 4336], [4338, 4338, 4398, 4398, 5502], [5523, 5523, 5556, 5556, 5684], [5686, 5686, 5732, 5732, 6100], [6102, 6102, 6159, 6159, 11240]], "test": "untested"}
{"id": "dssGzH", "name": "Video height castray marching", "author": "rubioh", "description": "Inspire by:\nShane's work: https://www.shadertoy.com/view/tsdXDB\nGhost's work: https://www.shadertoy.com/view/4tlyD2\n\nMinimalist and readable example for extruded tile.", "tags": ["heightmap", "extrude", "castray"], "likes": 33, "viewed": 713, "published": 3, "date": "1665774304", "time_retrieved": "2024-07-30T16:26:20.993106", "image_code": "float sdPlane(vec3 p){\n    float width = .4; // Width of the tile\n    float tiling = 15.; // Grid precision\n    \n    vec2 idx = floor(p.xy*tiling);\n    vec2 str = vec2(iResolution.y/iResolution.x, 1); \n    float h = length(texture(iChannel0, str*idx/(2.*tiling)+.5).xyz)/7.;\n    //shapable tile\n    vec2 f = fract(p.xy*tiling)-.5; // centering\n    float N = 4.; // 1. for losange 2. circle  +inf for square (L-N distances)\n    float l = pow( pow(abs(f.x), N) + pow(abs(f.y), N), 1./N);\n        \n    return h*smoothstep(0., 0.05, width-l);\n}\n\n\nfloat castray(vec3 ro, vec3 rd) {\n  vec3 p;\n  float dt, depth;\n  \n  float t = .05*fract(sin(dot(rd, vec3(125.45, 213.345, 156.2001)))); // dithering\n  for (float d = .5; d < 2.4; d += .004) { // lower value for d induce better results but more costly\n    p = ro + rd*(d+t);\n    float depth = sdPlane(p);\n    if (p.z < depth){\n        break;}\n      }\n  return p.z;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iChannelTime[0];\n    vec2 st = ( 2.*fragCoord.xy - iResolution.xy ) / iResolution.y;\n\n    vec3 ro = vec3(0, 0, 1); // ray origin \n    vec3 rd = normalize(vec3(st, -1)); // ray direction\n\n    float d = castray(ro, rd);\n\tfragColor = vec4(vec3(d)*5., 1.);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssGzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 540], [543, 543, 576, 576, 908], [911, 911, 968, 968, 1237]], "test": "untested"}
{"id": "ddlGz4", "name": "Voronoi cells on hexagonal grid", "author": "sh1boot", "description": "Finding the nearest three neighbours on an equilateral triangular grid, with a bit of wobble.\n\nCaveat: for efficiency this only identifies three neighbours on a regular grid, then adds wobble.  Hit space to see how this breaks contour lines.", "tags": ["hexagons", "nearestneighbor"], "likes": 8, "viewed": 206, "published": 3, "date": "1665772146", "time_retrieved": "2024-07-30T16:26:21.897688", "image_code": "const float subdivisions = 6.0;\nconst mat2x2 fwd = subdivisions * mat2x2(.500, .866, -.500,.866);\nconst mat2x2 bwd = inverse(fwd);\n\nvoid neighbours(out vec2 n[3], in vec2 uv) {\n    uv *= fwd;\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    // If we skip the bwd transform then we have\n    // simple integer grid coordinates here.  Though\n    // the transform is still needed for the distance\n    // tests to find the nearest neighbour.\n    n[0] = i * bwd;\n    n[1] = (i + vec2(1.0, 1.0)) * bwd;\n    const vec2 c = vec2(1.0, 0.0);\n    n[2] = (i + (f.x > f.y ? c.xy : c.yx)) * bwd;\n}\n\nfloat nrand(vec2 n) {\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233))) * 43758.5453); }\nvec2 nrand2(vec2 n) { return vec2(nrand(n), nrand(n + 1.2345)); }\nvec2 cs(float t) { return vec2(cos(t), sin(t)); }\n\nvoid noisyneighbours(out vec2 n[3], out vec2 nn[3], in vec2 uv) {\n    float loop_size = (1.0 - cos(iTime * 0.25)) * 0.02;\n    neighbours(n, uv);\n    for (int i = 0; i < 3; ++i) {\n        nn[i] = n[i] - uv + cs(iTime * nrand(n[i]) * 2.0) * loop_size;\n    }\n}\n\nvoid sort(out vec4 sorted[3], in vec2 n[3], in vec2 nn[3]) {\n    float l0 = dot(nn[0], nn[0]);\n    float l1 = dot(nn[1], nn[1]);\n    float l2 = dot(nn[2], nn[2]);\n    vec4 nnn0 = vec4(n[0], nn[0]);\n    vec4 nnn1 = vec4(n[1], nn[1]);\n    vec4 nnn2 = vec4(n[2], nn[2]);\n    bvec2 lo = bvec2(l0 < l1 && l0 < l2,\n                     l1 < l0 && l1 < l2);\n    sorted[0] = lo.x ? nnn0 : lo.y ? nnn1 : nnn2;\n#if 1\n    bvec2 hi = bvec2(!(l0 < l1 || l0 < l2),\n                     !(l1 < l0 || l1 < l2));\n    bvec2 mi = bvec2(!(lo.x || hi.x), !(lo.y || hi.y));\n    sorted[1] = mi.x ? nnn0 : mi.y ? nnn1 : nnn2;\n    sorted[2] = hi.x ? nnn0 : hi.y ? nnn1 : nnn2;\n#endif\n}\n\nvec3 honeycomb(vec2 uv) {\n    vec2 n[3];\n    vec2 nn[3];\n    vec4 overlay = vec4(0.0);\n    noisyneighbours(n, nn, uv);\n    for (int i = 0; i < 3; ++i) {\n        vec3 col = vec3(float(i==0), float(i==1), float(i==2));\n        vec2 d = nn[i];\n        if (length(d) < 0.008) overlay = vec4(col, 1.0);\n    }\n\n    vec4 s[3];\n    sort(s, n, nn);\n    vec3 colour = vec3(nrand2(s[0].xy).xy, 0.5);\n    \n    if (texelFetch(iChannel0, ivec2(32, 2), 0).r > 0.5) {\n        float m1 = dot(0.5 * (s[0].zw + s[1].zw), normalize(s[1].zw - s[0].zw));\n        float m2 = dot(0.5 * (s[0].zw + s[2].zw), normalize(s[2].zw - s[0].zw));\n        float w = 0.25 * (4.0 - cos(min(m1, m2) * 512.0));\n        w += 0.25 * smoothstep(-0.003, 0.0, -abs(m1 - m2));\n        colour *= w;\n    }\n    return colour * (1.0 - overlay.a) + overlay.rgb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xx;\n    \n    fragColor = vec4(honeycomb(uv), 1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddlGz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 132, 176, 176, 585], [587, 587, 608, 608, 676], [677, 677, 698, 698, 742], [743, 743, 761, 761, 792], [794, 794, 859, 859, 1051], [1053, 1053, 1113, 1113, 1713], [1715, 1715, 1740, 1740, 2529], [2532, 2532, 2589, 2589, 2680]], "test": "untested"}
{"id": "cslGzN", "name": "ez edge detection", "author": "Oman395", "description": "Messing with shaders again, this time I made some simple edge detection.", "tags": ["edge"], "likes": 1, "viewed": 288, "published": 3, "date": "1665760635", "time_retrieved": "2024-07-30T16:26:22.846152", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    bool backgroundColor = false;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    if(col[0] > 0.5) fragColor = vec4(1,1,1,1);\n    else if(!backgroundColor) fragColor = vec4(0,0,0,0);\n    else fragColor = texture(iChannel1, uv);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    bool isEdge;\n    for(int x = -1; x < 2; x++) {\n        if(isEdge) break;\n        for(int y = -1; y < 2; y++) {\n            vec4 oCol = texture(iChannel0, (fragCoord + vec2(x,y)) / iResolution.xy);\n            vec4 deltaVec = col - oCol;\n            float delta = abs(deltaVec[0]) + abs(deltaVec[1]) + abs(deltaVec[2]) + abs(deltaVec[3]);\n            if(delta > 0.125) {\n                isEdge = true;\n                break;\n            }\n        }\n    }\n    if(isEdge) fragColor = vec4(1,1,1,1);\n    else fragColor = vec4(0,0,0,0);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    int cnt = 0;\n    for(int i = -2; i < 3; i++) {\n        for(int j = -2; j < 3; j++) {\n            vec4 col = texture(iChannel0, (fragCoord + vec2(i,j)) / iResolution.xy);\n            if(col[0] > 0.5) cnt++;\n        }\n    }\n    if(cnt > 15 && cnt < 25) fragColor = texture(iChannel0, uv);\n    else fragColor = vec4(0,0,0,0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cslGzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 324]], "test": "untested"}
{"id": "slKfWd", "name": "Peel Wipe", "author": "MrRobW", "description": "Wipe", "tags": ["wipe"], "likes": 3, "viewed": 168, "published": 3, "date": "1665756387", "time_retrieved": "2024-07-30T16:26:23.773672", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    float alpha = 2.0 * (mod(iTime,4.0))/4.0;\n    \n    // Output to screen\n    fragColor = vec4(0.0);\n    \n    fragColor = texture(iChannel0, uv);\n\n    if(uv.x + uv.y > alpha * 2.0)\n    {\n        fragColor = texture(iChannel1, uv);\n    }\n    else\n    {\n        vec2 uv2 = uv * 2.0;\n        \n        if(uv2.x + uv2.y > alpha * 2.0)\n        {\n            vec2 uv3 = alpha - uv;\n            \n            if(uv3.x < 0.0)\n            {\n                //fragColor = vec4(1.0);\n                fragColor = texture(iChannel1, uv);\n            }\n            else if(uv3.y < 0.0)\n            {\n                //fragColor = vec4(1.0);\n                fragColor = texture(iChannel1, uv);\n            }            \n            else\n            {\n                fragColor = texture(iChannel1, uv3);\n            }\n            \n        }\n    }\n}\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKfWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 982]], "test": "untested"}
{"id": "NlcSW7", "name": "Julia Set Uniformization", "author": "loveless_savage", "description": "click and drag\nmouse corresponds to universal c value\nInspired by: https://www.shadertoy.com/view/MdX3zN", "tags": ["2d", "fractal", "juliaset"], "likes": 3, "viewed": 152, "published": 3, "date": "1665710823", "time_retrieved": "2024-07-30T16:26:24.531645", "image_code": "//resolution of each test\n#define RESOL 512\n#define THRESHOLD 10000.\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b){\n    return vec2( a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x );\n}\n\n// complex division\nvec2 cdiv(vec2 a, vec2 b){\n    float d = dot(b,b);\n    return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d;\n}\n\n// complex exponent\nvec2 cpow(vec2 z, float n){\n    float r = length( z );\n    float a = atan( z.y, z.x );\n    return pow( r, n )*vec2( cos(a*n), sin(a*n) );\n}\n\n// square root of a complex number\nvec2 csqrt(vec2 z, bool isPositive){\n// for mathematical proof: https://math.stackexchange.com/questions/44406/how-do-i-get-the-square-root-of-a-complex-number\n    if(z.y == 0.0) return vec2(0.0,sqrt(length(z))); // doesn't work for negative numbers!\n    // square root of the complex number z takes the form:\n    // z = |z| * (z+|z|)/|z+|z||\n    vec2 rootz = vec2(z.x + length(z), z.y);\n    rootz *= sqrt(length(z)) / length(rootz);\n    if(!isPositive) rootz *=-1.;\n    return rootz;\n    \n    /*float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) );*/\n}\n\n//given the 4D Julia set coordinates, test for divergence with a certain resolution\nvec4 runTest(vec2 zi, vec2 c){\n    bool cutoff = true;\n    vec2 z = zi;\n    bool[RESOL] argsign;\n    vec2 gdiff;\n    vec2 bmap = zi;\n\n    int n = 0;\n    while(n<RESOL){\n        // if we passed the outer threshold\n        if( cutoff && dot(z,z)>THRESHOLD*THRESHOLD ) break;\n        // record quadrant data\n        if(z.y==0.)\n            argsign[n] = (z.x>=0.);\n        else\n            argsign[n] = (z.y>0.);\n        // iterate\n        z = cmul(z,z) + c;\n        // Boettcher map - https://iquilezles.org/articles/distancefractals\n        gdiff = cdiv(z,z-c);\n        bmap = cmul(bmap, cpow(gdiff,pow(0.5,float(n))) );\n        n++;\n    }\n    \n    if( dot(z,z)<=THRESHOLD*THRESHOLD ) return vec4(0.0);\n    \n    // this step maps our fractal border to the unit circle\n    // ... by undoing z^2 + c but with c = 0\n    for(int i = 0; i<n; i++){\n        z = csqrt(z,argsign[n-i-1]);\n    }\n    \n    return vec4(z.xy,bmap.xy);\n}\n\n//calculate the color of the model given a depth\nvec4 modelColor(float dep){\n    if(length(dep) == 0.0) return vec4(0.0);\n\n    float temp[3] = float[3](0.0,0.0,0.0);\n    float depmod = mod(dep,0.2);\n    if(dep==1.0) {\n        return vec4(0.0);\n    }\n\n    int depnum = int((dep-depmod)*5.0);\n\n    if((depnum&1)>0) depmod = 0.2-depmod;\n\n    temp[(4-depnum) % 3]=5.0*depmod;\n\n    depnum += 1;\n    depnum >>= 1;\n\n    temp[depnum]=1.0;\n\n    return vec4(temp[0],temp[1],temp[2],1.0);\n}\n\n// checkerboard coloring\nvec4 checkerboard(vec2 uz, float width){\n    // eliminate the filled in set\n    if(length(uz) == 0.0) return vec4(0.0);\n    \n    // find checkerboard position using step function\n    vec2 check = floor(uz/width);\n    vec4 outcol = vec4(0.3);\n    if( mod(check.x + check.y, 2.0) == 0.0 ){\n        outcol = vec4(0.8);\n    }\n    return outcol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Adjusted pixel coordinates; transform to window of Mandelbrot Set\n    vec2 z = 2.0*fragCoord.xy-iResolution.xy;\n    vec2 c = 2.0*iMouse.xy-iResolution.xy;\n    z *= 2.0/min(iResolution.x,iResolution.y);\n    c *= 2.0/min(iResolution.x,iResolution.y);\n    \n    // Test for divergence\n    vec4 uVal = runTest(z,c);\n    \n    // Output to screen\n    fragColor = checkerboard(uVal.wz,0.1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcSW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 96, 122, 122, 177], [179, 199, 225, 225, 303], [305, 325, 352, 352, 464], [466, 501, 537, 660, 1091], [2100, 2149, 2176, 2176, 2579], [2581, 2606, 2646, 2681, 2948], [2950, 2950, 3006, 3079, 3398]], "test": "untested"}
{"id": "DsfGRN", "name": "Beat Light ", "author": "mrelive", "description": "Goes to the beat yo ", "tags": ["sound"], "likes": 3, "viewed": 224, "published": 3, "date": "1665708454", "time_retrieved": "2024-07-30T16:26:25.366413", "image_code": "#define BEATMOVE 1\n\nconst float FREQ_RANGE = 100.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.0;\nconst float BRIGHTNESS = 0.3;\nconst float SPEED = -0.9;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat getfrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.09;\n}\n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 doHalo(vec2 fragment, float radius) {\n\tfloat dist = length(fragment);\n\tfloat ring = 5.0 / abs(dist - radius);\n\t\n\tfloat b = dist < radius ? BRIGHTNESS * 0.9 : BRIGHTNESS;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcol += hsv2rgb( vec3( ( angle + iTime * 0.25 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\n\t\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcol *= frequency;\n\t\n\t// Black halo\n\t;\n\t\n\treturn col;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\n\t\n\tfloat freq = abs(fragment.x * 0.6);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * 2.5, abs(fragment.x));\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\n\tcolor += doHalo(fragPos, RADIUS);\n\n    float c = cos(iTime * SPEED);\n    float s = sin(iTime * SPEED);\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\n\tcolor += doLine(rot, RADIUS, rot.x);\n\t\n\tcolor += max(luma(color) - 1.0, 0.0);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 13, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsfGRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 181, 202, 202, 371], [373, 373, 397, 397, 447], [449, 449, 478, 478, 571], [573, 573, 609, 609, 820], [822, 822, 857, 857, 921], [923, 923, 965, 965, 1387], [1389, 1389, 1440, 1440, 1692], [1695, 1695, 1752, 1752, 2185]], "test": "untested"}
{"id": "mdl3RH", "name": "Raymarching space (Bintree)", "author": "pyBlob", "description": "Reconstructing the world from sdf sampled via a binary tree traversal. Looks around corners and behind walls!", "tags": ["raymarching", "visualization"], "likes": 4, "viewed": 213, "published": 3, "date": "1665688478", "time_retrieved": "2024-07-30T16:26:26.185224", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setup(fragCoord, iResolution, iMouse, iTime);\n\n    color = vec3(0);\n    vec4 centers = vec4(0);\n\n    int rx = int(iResolution.x);\n    float r = 0., rs = 1.;\n    for (int i=0 ; i<N ; i+=1) // try only using every 2nd sample\n    for (int j=0 ; j<rx ; j+=1) // try downsampling (eg 8x, 30x)\n    {\n        vec4 A = texelFetch(iChannel0, ivec2(j, i), 0);\n        float _r = A.x;\n        vec2 _p = A.yz;\n        if (A.w < 0.) continue;\n        \n        float cr = length(uv - _p) - abs(_r);\n        if (cr < 0.)\n            r = max(r, -cr), rs = _r; // lowerbound of sdf\n\n        vec3 fill = _r < 0. ? vec3(1,.2,0) : vec3(0,.2,1);\n        blend(fill, cr + 1. * f);\n        blend2(centers, vec3(1,0,0), (length(uv - _p)));\n    }\n    \n    if (r != 0.) color = (.5 - .5 * cos(r * 100.)) * (rs < 0. ? vec3(1,.3,0) : vec3(0,.1,1)); // safe space\n    color = mix(color, vec3(0,.8,0), clamp(1.-r/f, 0., 1.)); // unmapped territory\n    \n    fade(blend(centers), T1); // sdf evaluations\n    fade(blend(vec3(1), abs(scene(uv))), T2); // scene boundary\n    blend(vec3(1), abs(length(uv - ro) - 3. * f)); // ray origin\n\n    fragColor = vec4(sqrt(color), 1);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float pi = radians(180.);\nconst int N = 16; // number of raymarching steps\n\nfloat f; vec3 color;\nvoid blend(vec4 c)\n{\n    color = mix(color, c.xyz, c.w);\n}\nvoid blend(vec3 c, float r)\n{\n    blend(vec4(c, clamp(1. - r / f, 0., 1.)));\n}\nvoid blend2(inout vec4 color, vec3 c, float r)\n{\n    color = mix(color, vec4(c, 1), clamp(1. - r / f, 0., 1.));\n}\n#define fade(block, alpha) { vec3 bg = color; block; color = mix(bg, color, alpha); }\n\nvec2 uv, ro;\nvec4 mouse;\nbool demo, down, click;\nfloat T, T1, T2;\nvoid setup(vec2 fragCoord, vec3 iResolution, vec4 iMouse, float iTime)\n{\n    f = 2. / iResolution.y;\n    uv = (fragCoord - iResolution.xy / 2.) * f;\n    mouse = (abs(iMouse) - iResolution.xyxy / 2.) * f;\n    demo = iMouse.z == 0.;\n    down = iMouse.z > 0.;\n    click = iMouse.w > 0.;\n\n    T = mod(iTime/1.2, 6.);\n    if (!demo) T = 3.;\n    //T = 0.;\n    float t = 0.2;\n    T1 = smoothstep(1.-t, 1.+t, T) - smoothstep(4.-t, 4.+t, T);\n    T2 = smoothstep(2.-t, 2.+t, T) - smoothstep(5.-t, 5.+t, T);\n\n    ro = mouse.xy;\n    if (demo)\n    {\n        float a = .3 * iTime;\n        float T=2.+pi, s=sign(T-mod(a, T+T)); a=mod(a, 2. + pi); ro=vec2(.5,0) + .5*(a<2. ? vec2(a-1., 0) : vec2(cos(a=s*(a-2.)), sin(a)));\n    }\n}\n\nfloat sdBox(vec2 p,vec2 s)\n{\n    return length(max(p=abs(p)-s,0.))+min(max(p.x,p.y),0.);\n}\n\nfloat sdLine(vec2 p,vec2 a,vec2 b)\n{\n    return length(-clamp(dot(p-=a,b-=a)/dot(b,b),0.,1.)*b+p);\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    sca = normalize(sca);\n    scb = normalize(scb);\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x > scb.x*p.y) ? dot(p,scb) : length(p);\n    return sqrt(max(0., dot(p,p) + ra*ra - 2.0*ra*k)) - rb;\n}\n\nfloat side(float r, float h)\n{\n    return sqrt(r*r - h*h);\n}\n\nfloat sdArcTo(in vec2 p, in vec2 a, in vec2 b, float r)\n{\n    vec2 m = a + b;\n    float tb = dot(m, b) / length(m);\n    float arc = sdArc(p, vec2(m.y, -m.x), vec2(side(r, tb), tb), r, 0.);\n    //return min(min(length(p-a), length(p-b)), min(length(p-m), min(arc, length(p)))) -.01;\n    return arc;\n}\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat scene(vec2 p)\n{\n    // lara: Animated Marching Visualization https://www.shadertoy.com/view/ltyGRD\n    p.x += .5;\n    float ball = length(p - vec2(1, 0)) - .3;\n    float lens = length(p - vec2(.8, 0)) - .15;\n    float wire = abs(p.y) - .05;\n    vec2 q = p; q.y = abs(q.y);\n    float eye = max(max(ball,-lens),-wire);\n    float bx = (pow(.3,2.)-pow(.15,2.)+pow(.2,2.))/(2.*.2);\n    float bh = side(.3, bx);\n    float ballArc = sdArcTo(q - vec2(1, 0), vec2(-bx,bh), vec2(side(.3,.05), .05), .3);\n    float lensArc = sdArcTo(q - vec2(.8, 0), vec2(.2-bx,bh), vec2(side(.15,.05), .05), .15);\n    float wireLine = sdLine(q, vec2(.8+side(.15,.05), .05), vec2(1.+side(.3,.05), .05));\n    float eye1 = min(min(ballArc, lensArc), wireLine) * sign(eye);\n    float socket = min(\n        sdBox(vec2(p.x,abs(p.y))-vec2(1,.6),vec2(.3,.05)),\n        sdBox(vec2(p.x,abs(p.y))-vec2(1.25,.55),vec2(.05,.05))\n    );\n    //if (false)\n        return min(eye1, socket); // proper sdf\n    return min(eye, socket); // original sdf\n}\n\nvec3 palette(float h)\n{\n    // iq: Binary Search for SDFs https://www.shadertoy.com/view/wlGcWG\n    vec3 col =    vec3(0.0,0.3,1.0);\n    col = mix(col,vec3(1.0,0.8,0.0),smoothstep(0.33-0.2,0.33+0.2,h));\n    col = mix(col,vec3(1.0,0.0,0.0),smoothstep(0.66-0.2,0.66+0.2,h));\n    col.y += 0.5*(1.0-smoothstep(0.0,0.2,abs(h-0.33)));\n    col *= 0.5 + 0.5*h;\n    return col;\n}\n", "buffer_a_code": "int lvl, seg;\nvoid init() { lvl = 0; seg = 0; }\nvoid up()   { --lvl; seg = seg>>1; }\nvoid near() { ++lvl; seg = seg<<1; }\nbool isfar() { return (seg & 1) == 1; }\nbool next() { while (isfar()) up(); ++seg; return lvl == 0; }\n\nfloat _r, _s; vec2 _p;\nbool close(vec2 ro, vec2 rd)\n{\n    rd *= exp2(-float(lvl));\n    _r = scene(_p = ro + rd * (float(seg) + .5));\n    float _s = length(rd) / 2.;\n    return _r < _s;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(-1);\n    int fcy = int(fragCoord.y);\n    if (fcy >= N)\n        return;\n\n    setup(fragCoord, iResolution, iMouse, iTime);\n    float a = fragCoord.x / iResolution.x * 2. * pi;\n\n    color = vec3(0);\n    blend(vec3(1), abs(scene(uv)) - .5 * f);\n\n    vec2 rd = vec2(cos(a), sin(a)) * 4.;\n\n    blend(vec3(1), abs(length(uv - ro) - 3. * f) - .5 * f);\n\n    init();\n    for (int i=0;i<N;++i)\n    {\n        if (close(ro, rd))\n        {\n            near();\n            if (lvl > 16)\n                break;\n        }\n        else if (next()) break;\n        if (i == fcy)\n            fragColor = vec4(_r, _p, 0);\n    }\n}\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdl3RH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 1201]], "test": "untested"}
{"id": "ddlGzH", "name": "Motion Detector", "author": "Oman395", "description": "Just messing around ;)", "tags": ["camera", "motion"], "likes": 3, "viewed": 371, "published": 3, "date": "1665686781", "time_retrieved": "2024-07-30T16:26:26.956163", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    int numberOfMovedPixels = 0;\n    \n    #ifndef ABSOLUTE\n    for(int i = -5; i < 6; i++) {\n        for(int j = -5; j < 6; j++) {\n            vec4 col = texture(iChannel0, (fragCoord + vec2(i, j)) / iResolution.xy);\n            if(col.r > 0.5) numberOfMovedPixels++;\n        }\n    }\n    if(numberOfMovedPixels > 80) fragColor = vec4(255, 255, 255, 255);\n    else fragColor = vec4(0,0,0,0);\n    #else\n    fragColor = texture(iChannel0, uv);\n    #endif\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 delta = abs(texture(iChannel0, uv) - texture(iChannel1, uv));\n    #ifndef ABSOLUTE\n    if(delta[0] + delta[1] + delta[2] + delta[3] > 0.5) fragColor = vec4(255,255,255,255);\n    else fragColor = vec4(0,0,0,0);\n    #else\n    fragColor = abs(delta);\n    #endif\n}", "buffer_c_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// #define ABSOLUTE", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddlGzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 553]], "test": "untested"}
{"id": "dsl3R8", "name": "power 1000w", "author": "chenxianming", "description": "blood of power", "tags": ["raymarching", "fbm", "cineshader"], "likes": 2, "viewed": 3822, "published": 3, "date": "1665671644", "time_retrieved": "2024-07-30T16:26:27.720120", "image_code": "#define PI 3.1415926\n\n\n\nmat2 rotation(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nconst mat2 m = mat2(-1.1, -.4, .3, 1.0);\n\nfloat noise( in vec2 p) {\n    return sin(p.x) * sin(p.y);\n}\n\nfloat fbm4(vec2 p) {\n    float f = 0.0;\n    for (float i = 0.; i < 5.; i++) {\n        f += 1.5 * .1 * noise(p * i);\n        p = m * p * abs(i - 2.) * 2.3;\n    }\n\n    return f / 0.99999990;\n}\n\nvec2 fbm4_2(vec2 p) {\n    return vec2(fbm4(p), fbm4(p + vec2(7.8)));\n}\n\nfloat coreCalc(vec3 pos, int i) {\n\n    vec3 p = pos;\n\n    p.xz *= rotation(3.1415926 * iTime * .1 * float(i) + float(i));\n\n    float d = length(p) - .5 + (fbm4_2(p.xz).y * 1.5 * fbm4_2(p.xy).x * 1. * cos(p).y * 1.) * .6;\n\n    return d;\n}\n\nfloat map(vec3 pos) {\n\n    vec3 p = pos;\n\n    float d = coreCalc(p, 1);\n\n    float bg = length(pos) - .1;\n\n    d = mix(d, .1, bg);\n\n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    const float eps = 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy * eps) +\n        e.yyx * map(pos + e.yyx * eps) +\n        e.yxy * map(pos + e.yxy * eps) +\n        e.xxx * map(pos + e.xxx * eps));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    float tt = iTime * .4;\n\n    uv = (uv - .5) * 2.;\n\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 origin = vec3(cos(tt) * -1.2, 0.0, sin(tt) * -1.2);\n    vec3 ta = vec3(0.0, 0., 0.0);\n\n    origin = vec3(0., 0., -1.);\n\n    // camera matrix\n    vec3 ww = normalize(ta - origin);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n\n    vec3 tot = vec3(0.0);\n\n    vec3 ray = normalize(uv.x * uu + uv.y * vv + 1.5 * ww);\n\n    float t = 0.0;\n\n    const float tmax = 5.0;\n\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = origin + ray * t;\n        float distance = map(p);\n        t += distance * 0.9999;\n    }\n\n    vec3 col = vec3(0.0);\n    vec3 lig = normalize(vec3(.57703));\n    vec3 hal = normalize(lig - ray);\n    // vec3 spcol = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    if (t < tmax) {\n        vec3 pos = origin + t * ray;\n        vec3 nor = calcNormal(pos);\n\n        float dif = clamp(dot(nor, vec3(.4, 1., -.5)), 0.0, 1.0);\n\n        float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 50.0) * .6;\n        spe *= dif;\n\n        float amb = dot(nor, vec3(0.0, 1.0, 0.0));\n\n        col = spe + vec3(.1) * amb + vec3(.5) * dif + vec3(.3);\n    }\n\n    // gamma        \n    col = sqrt(col);\n    tot += col;\n    \n    // Output to screen\n    fragColor = vec4(tot, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsl3R8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 48, 48, 114], [158, 158, 183, 183, 217], [219, 219, 239, 239, 409], [411, 411, 432, 432, 481], [483, 483, 516, 516, 720], [722, 722, 743, 743, 869], [871, 917, 948, 948, 1196], [1198, 1198, 1253, 1303, 2667]], "test": "untested"}
{"id": "cdl3zH", "name": "Multigrid Fluid Dynamics: Fire ", "author": "FabriceNeyret2", "description": "WIP. What did I do wrong ?\nMultigrid solver of buoyant fluid with combustion ported from [url]https://www.cs.uaf.edu/2017/spring/cs482/example/03_31_fire_expanding.html[/url].", "tags": ["fire", "port", "fluiddynamics", "pressure", "buoyancy", "cubemapa", "multigrid"], "likes": 8, "viewed": 424, "published": 3, "date": "1665669280", "time_retrieved": "2024-07-30T16:26:28.565859", "image_code": "// porting https://www.cs.uaf.edu/2017/spring/cs482/example/03_31_fire_expanding.html\n// using power-of-two square pseudobuffers via https://shadertoy.com/view/3tGBDz\n// ( first try <ith regular buffers: https://www.shadertoy.com/view/css3RH )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n                 \n    if ( U.x < R.x/2. ) O = texture( 0, (U-vec2(   R.x/2.-R.y,0)/2.) /R.y , 0.);\n    else                O = texture( 3, (U-vec2(3.*R.x/2.-R.y,0)/2.) /R.y , 0.);\n                     \n // O = O.aaaa;\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "// ported from https://www.cs.uaf.edu/2017/spring/cs482/example/03_24_multigrid_fluid.html\n\nvoid mainCubemap( out vec4 fragColor, vec2 fragCoord, vec3 o, vec3 D )\n{\n vec3 A = abs(D);\n int n = A.x > A.y ? A.x > A.z ? 0 : 2 : A.y > A.z ? 1 : 2; // faceID\n if (D[n]<0.) n += 3;\n    \n // O = texture(iChannel0,D);                               // restore global state\n    \n// $$$ port of uniforms and varyings\n#define time         iTime                      // lib.time, seconds\n#define dt          (1./60.)                    // lib.dt timestep, seconds\n#define texcoords   (fragCoord/iResolution.xy)  // our texture coords, [0-1]\n#define texF         0                          // fluid source texture\n#define texR         3                          // reaction source texture\n#define texsize      iResolution.xy             // texcoord change per pixel\n#define del         (1./texsize)                // texcoord change per pixel\n//#define OFS          vec4(.5,.5,0,0)          // to avoid leaks with other faces\n  #define OFS          vec4(0)                  // original encoding: buffer values in [0,1]\n\n if ( n==texF ) {   // $$$ replaces main(){  // ---------- pseudobuffer#0 : fluid surface ( .5+V, 0, div )\n\n/* This GLSL shader calculates the new wave texture. */\n\n// float tex_size=512.0; // pixels across\n// float del=1.0/tex_size; // texture coordinates per pixel\n   float bias=-1000.0; // mipmap bias (disable mipmaps)\n   \n   // P stores our texture coordinates\n   vec2 P=texcoords;\n   vec4 CR=texture(texR,P,bias); // reaction values\n   vec4 CF=texture(texF,P,bias) + OFS; // $$$\n   \n   vec4 A=vec4(0.0); // acceleration\n   // A.y+=-0.05; // weak gravity\n\n// Multigrid pressure physics\n   float P2V=0.1; /* pressure-to-velocity */\n   float V2P=1.0; /* velocity-to-pressure */\n   vec4 L,R,T,B;\n   float divergence=0.0; // sum across levels\n   for (float lvl=9.0;lvl>=0.0;lvl-=1.0) {\n     float scale=pow(2.0,lvl);\n     vec2 dist=scale*del; // texture coordinate jump\n     float dx=0.2; // grid size, meters/pixel\n     float dy=0.2; // grid size, meters/pixel\n     L=texture(texF,P+vec2(-dist.x,0.0),lvl) + OFS; // $$$\n     R=texture(texF,P+vec2(+dist.x,0.0),lvl) + OFS; // $$$\n     T=texture(texF,P+vec2(0.0,+dist.y),lvl) + OFS; // $$$\n     B=texture(texF,P+vec2(0.0,-dist.y),lvl) + OFS; // $$$\n\n  // Compute divergence at this level\n     divergence+=((R.x - L.x)/dx + (T.y - B.y)/dy);\n\n  // pseudo pressure drives velocity\n  //   (from Navier Stokes equation)\n     A.x += -P2V*(R.a - L.a)/dx;\n     A.y += -P2V*(T.a - B.a)/dy;\n   }\n   divergence+=-10000.0*CR.a; // burning -> want divergence\n\n   // velocity convergence *is* pseudo pressure\n   CF.a = 0.5-V2P*divergence;\n\n   // Advection physics via explicit dot(V,grad(V)):\n   vec2 V=CF.xy-vec2(0.5);\n   vec3 gradX=vec3(R-L);\n   vec3 gradY=vec3(T-B);\n   vec3 VgV=vec3(V.x*gradX+V.y*gradY);\n   A.xyz-=10.0*VgV;\n   \n   // Blur, to simulate viscosity:\n   vec4 blur=0.25*(L+R+T+B); /* neighborhood average */\n   float blurFrac=5.0;\n   A+=blurFrac*(blur-CF);\n   \n   CF+=A*dt; // adjust velocities\n\n   if (P.y<0.001) { \n      CF.xy=vec2(0.5); // stationary bottom chunk\n   }\n\n   // hot gas -> accelerate Y upwards\n   CF.y+=0.3*CR.r*dt;\n\n   // limit velocities (for stability)\n   CF.xy=clamp(CF.xy,0.0,1.0); \n  \n  if (iFrame==0)  // $$$ // Initialize fluid values\n      CF = vec4(0.5,0.5,0.0,1.0); \n      \n  fragColor = CF - OFS; // $$$ // return CF;\n  \n    \n } else if( n==texR ) {  // $$$ replaces main(){   // ---------- pseudobuffer#1 : combustion reaction ( T, fuel, air, burnt )\n \n \n/* This GLSL shader calculates the new reaction texture.\n     red: temperature\n     green: propane\n     blue: air\n*/\n\n //float tex_size=512.0; // pixels across\n //float del=1.0/tex_size; // texture coordinates per pixel\n   float bias=-1000.0; // mipmap bias (disable mipmaps)\n   \n   // P stores our texture coordinates\n   vec2 P=texcoords;\n   vec4 CR=texture(texR,P,bias);\n   vec4 CF=texture(texF,P,bias) + OFS; // $$$\n\n   // Read neighbors\n   vec2 dist=del; // $$$ was float\n   float lvl=bias;\n   vec4 L=texture(texR,P+vec2(-dist.x,0.0),lvl);\n   vec4 R=texture(texR,P+vec2(+dist.x,0.0),lvl);\n   vec4 T=texture(texR,P+vec2(0.0,+dist.y),lvl);\n   vec4 B=texture(texR,P+vec2(0.0,-dist.y),lvl);\n\n   vec4 A=vec4(0.0);\n   // Advection physics via explicit dot(V,grad(V)):\n   vec2 V=CF.xy-vec2(0.5);\n   vec3 gradX=vec3(R-L);\n   vec3 gradY=vec3(T-B);\n   vec3 VgV=vec3(V.x*gradX+V.y*gradY);\n   A.xyz-=10.0*VgV;\n\n\n   // drop blue out (cooling)\n   // combustion rate needs three things: heat, fuel, oxygen\n   float burn=0.0;\n   if (CR.r>0.3 && CR.g>0.0 && CR.b>0.0) {\n     burn=10.0*CR.r*CR.g*CR.b;\n     CR.r+=10.0*burn;\n     CR.g-=burn;\n     CR.b-=burn;\n   }\n\n   CR.r-=0.5*CR.r*dt; // fast cooling\n\n   // Clamp values, to keep them from getting too big\n   CR=clamp(CR,0.0,1.0);\n\n   // Blur, to simulate viscosity:\n   vec4 blur=0.25*(L+R+T+B); /* neighborhood average */\n   float blurFrac=3.0;\n   A+=blurFrac*(blur-CR);\n\n   CR+=A*dt;\n\n   CR.a=burn;\n      \n   if (iFrame==0) { // $$$  // Initialize reaction values\n       vec2 sphere=vec2(0.5,0.2);   // Boundary condition sphere\n       float r=length(sphere-texcoords);\n       if (r<0.2) CR = vec4((texcoords.y>0.395)?1.0:0.0,1.0,0.0,0);\n       else CR = vec4(0.0,0.0,1.0,0.0);\n   }\n    \n   fragColor = CR; // $$$ // return CR;\n }\n \n else fragColor = vec4(0,0,0,0); \n\n}\n\n", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define texture(ch,U,l) cubeFace(iChannel0,ch,U,l)\n\n\nvec4 cubeFace(samplerCube ch,int n,vec2 U,float l) {\n\n#if 0  // --- trying to prevent leaking to neighbor faces when interpolating border pixels.\n       //     not true wrapping: just prevent interpolation on borders.\n\n    float R = exp2(10. - max(0.,ceil(l)));  // shortest size at LOD l\n    U = fract(U)* R;\n    vec2 I = floor(U), F = fract(U);        // pixel Id + interpolation coefs\n       if   ( I.x== 0.  && F.x<.5) F.x=.5;\n    else if ( I.x==l-1. && F.x>.5) F.x=.5;\n       if   ( I.y== 0.  && F.y<.5) F.y=.5;\n    else if ( I.y==l-1. && F.y>.5) F.y=.5;\n    U = (I+F)/R;\n#endif\n\n    vec3 E =   vec3( 2.*fract(U) -1., 1 )                              \n             * vec3( n==0||n==5 ?-1:1 , n!=1 ?-1:1 , n>2 ?-1:1 );         \n    E = (n)%3 != 2 ? E.yzx : E.xzy;                               \n    return textureLod( ch, vec3( E[(n+1)%3], E[(n)%3], E[(n+2)%3] ) , l );\n}\n\n/** // --- trying to prevent leaking to neighbor faces when interpolating border pixels.\n    //     does correct wrapping doing manual bilinear interpolation (for integer LOD only ).\n    //     Rename the function above as  cubeFace0 .\n\n#define face(x,y) cubeFace0(ch,n, fract( ( I+vec2(x,y)+.5 ) / R ) , l )\n\nvec4 cubeFace(samplerCube ch,int n,vec2 U,float l) {\n    float R = exp2(10. - max(0.,l));              // size at LOD l, assuming l is an integer LOD\n    U = fract(U-.5/R)* R;\n    vec2 I = floor(U), F = fract(U);              // pixel Id + interpolation coefs\n    return mix( mix( face(0,0), face(1,0), F.x ), // manual bilinear interpolation\n                mix( face(0,1), face(1,1), F.x ),\n                F.y );\n}\n/**/", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdl3zH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[245, 245, 283, 283, 532]], "test": "untested"}
{"id": "css3RH", "name": "Multigrid Fluid Dynamics: Fire0", "author": "FabriceNeyret2", "description": "WIP\nMultigrid solver of buoyant fluid with combustion ported from [url]https://www.cs.uaf.edu/2017/spring/cs482/example/03_31_fire_expanding.html[/url].\nWell, it originally run in 512x512, so Ishould do this in a cubemap (assuming half precision is ok).", "tags": ["fire", "port", "fluiddynamics", "pressure", "buoyancy", "multigrid"], "likes": 4, "viewed": 279, "published": 3, "date": "1665669247", "time_retrieved": "2024-07-30T16:26:30.737054", "image_code": "// porting https://www.cs.uaf.edu/2017/spring/cs482/example/03_31_fire_expanding.html\n// ( a more basic one here: https://www.shadertoy.com/view/mss3zn )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n // O = U.x < R.x/2. ? texelFetch( iChannel0, ivec2(U), 0 )\n //                  : texelFetch( iChannel1, ivec2(U), 0 ); \n                     \n    O = U.x < R.x/2. ? texture( iChannel0, (U-vec2(R.x/2.-R.y,0)/2.) /R.y , 0.)\n                     : texture( iChannel1, (U-vec2(3.*R.x/2.-R.y,0)/2.) /R.y , 0.);\n                     \n // O = texture( iChannel1, (U-vec2(R-R.y)/2.) /R.y , 0.);\n \n // O = O.aaaa;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ported from https://www.cs.uaf.edu/2017/spring/cs482/example/03_24_multigrid_fluid.html\n\n/* This GLSL shader calculates the new wave texture. */\n\n// $$$ port of uniforms and varyings\n#define time         iTime                      // lib.time, seconds\n#define dt          (1./60.)                    // lib.dt timestep, seconds\n#define texcoords   (fragCoord/iResolution.xy)  // our texture coords, [0-1]\n#define texF         iChannel0                  // fluid source texture\n#define texR         iChannel1                  // reaction source texture\n#define texsize      iResolution.xy             // texcoord change per pixel\n#define del         (1./texsize)                // texcoord change per pixel\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){   // $$$ replaces main(){\n\n// float tex_size=512.0; // pixels across\n// float del=1.0/tex_size; // texture coordinates per pixel\n   float bias=-1000.0; // mipmap bias (disable mipmaps)\n   \n   // P stores our texture coordinates\n   vec2 P=texcoords;\n   vec4 CR=texture(texR,P,bias); // reaction values\n   vec4 CF=texture(texF,P,bias);\n   \n   vec4 A=vec4(0.0); // acceleration\n   // A.y+=-0.05; // weak gravity\n\n// Multigrid pressure physics\n   float P2V=0.1; /* pressure-to-velocity */\n   float V2P=1.0; /* velocity-to-pressure */\n   vec4 L,R,T,B;\n   float divergence=0.0; // sum across levels\n   for (float lvl=9.0;lvl>=0.0;lvl-=1.0) {\n     float scale=pow(2.0,lvl);\n     vec2 dist=scale*del; // texture coordinate jump\n     float dx=0.2; // grid size, meters/pixel\n     float dy=0.2; // grid size, meters/pixel\n     L=texture(texF,P+vec2(-dist.x,0.0),lvl);\n     R=texture(texF,P+vec2(+dist.x,0.0),lvl);\n     T=texture(texF,P+vec2(0.0,+dist.y),lvl);\n     B=texture(texF,P+vec2(0.0,-dist.y),lvl);\n\n  // Compute divergence at this level\n     divergence+=((R.x - L.x)/dx + (T.y - B.y)/dy);\n\n  // pseudo pressure drives velocity\n  //   (from Navier Stokes equation)\n     A.x += -P2V*(R.a - L.a)/dx;\n     A.y += -P2V*(T.a - B.a)/dy;\n   }\n   divergence+=-10000.0*CR.a; // burning -> want divergence\n\n   // velocity convergence *is* pseudo pressure\n   CF.a = 0.5-V2P*divergence;\n\n   // Advection physics via explicit dot(V,grad(V)):\n   vec2 V=CF.xy-vec2(0.5);\n   vec3 gradX=vec3(R-L);\n   vec3 gradY=vec3(T-B);\n   vec3 VgV=vec3(V.x*gradX+V.y*gradY);\n   A.xyz-=10.0*VgV;\n   \n   // Blur, to simulate viscosity:\n   vec4 blur=0.25*(L+R+T+B); /* neighborhood average */\n   float blurFrac=5.0;\n   A+=blurFrac*(blur-CF);\n   \n   CF+=A*dt; // adjust velocities\n\n   if (P.y<0.001) { \n      CF.xy=vec2(0.5); // stationary bottom chunk\n   }\n\n   // hot gas -> accelerate Y upwards\n   CF.y+=0.3*CR.r*dt;\n\n   // limit velocities (for stability)\n   CF.xy=clamp(CF.xy,0.0,1.0); \n\n  fragColor = CF; // $$$ // return CF;\n  \n  if (iFrame==0)  // $$$ // Initialize fluid values\n      fragColor = vec4(0.5,0.5,0.0,1.0); \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ported from https://www.cs.uaf.edu/2017/spring/cs482/example/03_24_multigrid_fluid.html\n\n/* This GLSL shader calculates the new reaction texture.\n     red: temperature\n     green: propane\n     blue: air\n*/\n\n// $$$ port of uniforms and varyings\n#define time         iTime                      // lib.time, seconds\n#define dt          (1./60.)                    // lib.dt timestep, seconds\n#define texcoords   (fragCoord/iResolution.xy)  // our texture coords, [0-1]\n#define texF         iChannel0                  // fluid source texture\n#define texR         iChannel1                  // reaction source texture\n#define texsize      iResolution.xy             // texcoord change per pixel\n#define del         (1./texsize)                // texcoord change per pixel\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){   // $$$ replaces main(){\n\n //float tex_size=512.0; // pixels across\n //float del=1.0/tex_size; // texture coordinates per pixel\n   float bias=-1000.0; // mipmap bias (disable mipmaps)\n   \n   // P stores our texture coordinates\n   vec2 P=texcoords;\n   vec4 CR=texture(texR,P,bias);\n   vec4 CF=texture(texF,P,bias);\n\n   // Read neighbors\n   vec2 dist=del; // $$$ was float\n   float lvl=bias;\n   vec4 L=texture(texR,P+vec2(-dist.x,0.0),lvl);\n   vec4 R=texture(texR,P+vec2(+dist.x,0.0),lvl);\n   vec4 T=texture(texR,P+vec2(0.0,+dist.y),lvl);\n   vec4 B=texture(texR,P+vec2(0.0,-dist.y),lvl);\n\n   vec4 A=vec4(0.0);\n   // Advection physics via explicit dot(V,grad(V)):\n   vec2 V=CF.xy-vec2(0.5);\n   vec3 gradX=vec3(R-L);\n   vec3 gradY=vec3(T-B);\n   vec3 VgV=vec3(V.x*gradX+V.y*gradY);\n   A.xyz-=10.0*VgV;\n\n\n   // drop blue out (cooling)\n   // combustion rate needs three things: heat, fuel, oxygen\n   float burn=0.0;\n   if (CR.r>0.3 && CR.g>0.0 && CR.b>0.0) {\n     burn=10.0*CR.r*CR.g*CR.b;\n     CR.r+=10.0*burn;\n     CR.g-=burn;\n     CR.b-=burn;\n   }\n\n   CR.r-=0.5*CR.r*dt; // fast cooling\n\n   // Clamp values, to keep them from getting too big\n   CR=clamp(CR,0.0,1.0);\n\n   // Blur, to simulate viscosity:\n   vec4 blur=0.25*(L+R+T+B); /* neighborhood average */\n   float blurFrac=3.0;\n   A+=blurFrac*(blur-CR);\n\n   CR+=A*dt;\n\n   CR.a=burn;\n   \n   fragColor = CR; // $$$ // return CR;\n   \n   if (iFrame==0) { // $$$  // Initialize reaction values\n       vec2 sphere=vec2(0.5,0.2);   // Boundary condition sphere\n       float r=length(sphere-texcoords);\n       if (r<0.2) fragColor = vec4((texcoords.y>0.395)?1.0:0.0,1.0,0.0,0);\n       else fragColor = vec4(0.0,0.0,1.0,0.0);\n   }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// #define texture(ch,U,l) texelFetch(ch, ivec2((U)*iResolution.xy+1e-4)>>(l<=0.?0:int(l)) , l<=0. ? 0 : int(l) )\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/css3RH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 193, 193, 631]], "test": "untested"}
{"id": "slKfWc", "name": "Deluge simulator: make it rain!", "author": "skal", "description": " Deluge! experiment with erosion and deposition on terrain.\n\nEvery so often, a deity intervenes and drops water on altitude!\nWater and sediments are  then transported along the terrain.\n", "tags": ["terrain", "simulation", "water", "heightmap", "deposition"], "likes": 2, "viewed": 288, "published": 3, "date": "1665666383", "time_retrieved": "2024-07-30T16:26:31.684521", "image_code": "//\n// Deluge simulator! Terrain and erosion\n//\n//  Starting from a 'rough' terrain, we deposit a (huge) amount of\n//  water in altitude and watch the world evolve! We store terrain\n//  and water level, sediment density, water velocity and the in/out\n//  flow on a reduce map (BufferA and BufferB).\n//\n//  There's a rather crude erosion and sediment deposition model.\n//  You're encouraged to tweak the constants, it gives quite some\n//  funny (and diverse) results.\n//\n// Some keys:\n//  'w': add new water\n//  'r': reset the terrain\n//  'u': don't show the water, just the terrain (but it's still simulated!)\n//  'm': use crude rock layer instead of full terrain\n//  's': stop the camera\n//  '1' to '5': show altitude, water, sediment, etc. For debugging.\n//  '6', '7', '8': project in 3D the water velocity, sediment, and water level\n//\n// Use the mouse to change altitude (mouse.x) and pitch (mouse.y)\n//\n//  BufferA: .x = velocity, .y = sediment amount, .w = water, .z = terrain\n//  BufferB: flow to .x:left, .y:right, .z:top, .w:bottom\n//\n//  Inspired by quite some shaders:\n//    https://www.shadertoy.com/view/tt2Szh by TekF\n//    https://www.shadertoy.com/view/wl3czN by nimitz\n//     ... and so on, and so on\n//\n// skal/ (Pascal Massimino)\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n//////////////////////////////////////////////////////////////////\n\n#define MIN_D 1e-3\n#define MAX_D 30.\n#define MAX_ITER 100\n\nbool showSediments;\nbool hideWater;\n\nconst vec3 planePos = vec3(-.5, -.5, 0.);\nconst vec3 planeScale = vec3(.0825, .08, 2.);\n\nconst float lightDistance = 20.;\nconst vec3 sunColor = vec3(1.7, 1.5, 1.2);  // bright!\nconst vec3 sunHaze = vec3(0.4, 0.5, 0.5);\nconst vec3 shadeColor = vec3(.09, .14, .17);\nconst vec3 diffuseColor = vec3(0.3, 0.6, 0.8) * 1.3;\n\n// snow\n#define lowSnowAltitude 0.5\n#define highSnowAltitude 0.8\nconst vec3 snowColor = .9 * vec3(0.72, 0.85, 0.96);\n\nconst vec3 waterColor = vec3(0.05, 0.12, 0.28) * .3;\nconst vec3 whiteWaterColor = 0.2 * vec3(.70, .72, 0.90);\n\n// cliff color and terrain\nconst vec3 cliffColor1 = vec3(0.08, 0.05, 0.03);\nconst vec3 cliffColor2 = vec3(0.10, 0.09, 0.08);\nconst vec3 rockColor = vec3(0.45, 0.30, 0.15);\nconst vec3 grassColor = vec3(0.25, 0.40, 0.10);\n\n#define ADD_FOG true\nconst vec3 fogColor = vec3(.5, .6, .9) * 0.7;\nconst vec3 fogGradient = vec3(1.2, 1.2, 1.1) * 0.3;\n#define fogAlpha 0.04  // factor controlling decay with view angle\n#define fogBeta 0.02  // decay with zenith angle\n\nconst vec3 cloudColor = 2. * vec3(1.0, 0.95, 1.0);\n\n// camera specs\n#define camDistance 4.\n#define camAltitude 1.5\n#define zoomHalfPeriod 3.\n#define zoomRamp .3\n#define focalMin 1.5\n#define focalMax 1.9\n\n//////////////////////////////////////////////////////////////////\n\nvoid spaceToPlane(inout vec2 p) {\n  p *= planeScale.xy;\n  p -= planePos.xy;\n  // we offset by 1 to avoid seeing the seam because of bilinear filtering\n  p = (fract(p) * WRAP + 1.) / iResolution.xy;\n}\n\nfloat terrain(vec2 p) {\n  float hf_details = 0.02 * (fbml(p.xy * 80., .4) - 0.1);\n  spaceToPlane(p);\n  vec4 terrain = texture(iChannel0, p.xy);\n  if (terrain.w > EPS) hf_details = 0.;\n  if (hideWater) terrain.w = 0.;\n  return hf_details + terrain.z + terrain.w + planePos.z;\n}\n\nvec4 quickTerrain(vec2 p) {\n  spaceToPlane(p);\n  return texelFetch(iChannel0, ivec2(p.xy), 0);\n}\n\nvec4 terrainValues(vec3 O, vec3 D, float d) {\n  vec3 p = O + d * D;\n  spaceToPlane(p.xy);\n  return texture(iChannel0, p.xy);\n}\n\n//////////////////////////////////////////////////////////////////\n// 'scene'\n\nfloat terrainDist(vec3 O, vec3 D) {\n  float d = EPS;\n  vec3 p = O + d * D;\n  float h = p.z - terrain(p.xy);\n  float prev_d = d;\n  for (int i = 0; i < 200; ++i) {\n    if (h <= 0.) break;  // needs refine\n    if (h < 0.001 * d || d > MAX_D) return d;\n    prev_d = d;\n    d += (h > 1e-5) ? h * 0.4 : log(abs(h) + 1.1);\n    p = O + d * D;\n    h = p.z - terrain(p.xy);\n  }\n  // refine\n  float dd = d - prev_d;\n  for (int i = 0; i < 4; ++i) {\n    dd /= 2.;\n    d -= dd;\n    p = O + d * D;\n    h = p.z - terrain(p.xy);\n    if (h > 0.) d += dd;  // step back\n    else if (-h < 0.001 * d) break;\n  }\n  return d;\n}\n\nvec2 trace(vec3 O, vec3 D) {\n  float d = terrainDist(O, D);\n  return vec2(d, (d >= MAX_D) ? 0. /*sky*/ : 1. /*terrain*/);\n}\n\n//////////////////////////////////////////////////////////////////\n// Shading and lighting\n//////////////////////////////////////////////////////////////////\n\nfloat softShadows(vec3 O, vec3 D, float dmin) {\n  float res = 1.0;\n  float d = terrainDist(O, D);\n  if (d < MAX_D) return 0.1;   // hit the terrain\n  d = 5e-2;  // 5e-2 * (1.25 ^ 20) ~= 4.33, good distance range to cover\n  for (int i = 0; i < 20; i++) {\n    vec3 p = O + d * D;\n    float h = p.z - terrain(p.xy);\n    res = min(res, 4. * h / d);\n    d *= 1.25;\n    if (d > MAX_D) break;\n  }\n  return clamp(res, 0.1, 1.0);\n}\n\n//////////////////////////////////////////////////////////////////\n\nconst vec2 EPS_T = vec2(0., 8e-3);\nvec3 terrainNormal(vec3 p) {\n  vec3 N = vec3(terrain(p.xy - EPS_T.yx) - terrain(p.xy + EPS_T.yx),\n                terrain(p.xy - EPS_T.xy) - terrain(p.xy + EPS_T.xy),\n                2. * EPS_T.y);\n  return normalize(N);\n}\n\nconst vec2 EPS_W = vec2(0., 8e-2);\nvec3 waterNormal(vec3 p) {\n  vec3 N = vec3(terrain(p.xy - EPS_W.yx) - terrain(p.xy + EPS_W.yx),\n                terrain(p.xy - EPS_W.xy) - terrain(p.xy + EPS_W.xy),\n                2. * EPS_W.y);\n  return normalize(N);\n}\n\n//////////////////////////////////////////////////////////////////\n// snow\n\nfloat computeSnow(vec3 p, in vec3 n) {  // snow amount\n  p.z += fbm(p.xy * 130., .08);  // modulate\n  // intensity of snow depends on elevation range\n  float I = smoothstep(lowSnowAltitude, highSnowAltitude, p.z);\n  // ... and slope\n  float e = smoothstep(0.75, 0.60, n.z);\n  // ... and direction of the wind\n  float o = mix(0.5, 1.5, smoothstep(0.0, 0.2, n.x));\n  return smoothstep(0.1, 0.9, I * e * o);\n}\n\nvec3 computeRock(in vec3 p, in vec3 n) {\n  float hf = fbm(p.xy * 20., .6);  // high-freq noise as 'details'\n  float hf2 = fbm(p.xy * (142. + 22. * hf), .9);\n\n  // sediment layers\n  const float stretch = 40.;\n  float h = p.z - 2.3 * dot(vec2(-.5, .2), sin(20. * p.xy));\n  float layer_mix = fbm(vec2(p.x, stretch * h), .5) * smoothstep(1., .8, n.z);\n  if (KEY(77)) return vec3(layer_mix);  // 'm' to look like mud\n\n  // exposed sedimental layers for steep cliffs\n  vec3 col = 3. * mix(cliffColor1, cliffColor2, layer_mix) * mix(1.5, 2.0, hf);\n  // rock on intermediate slopes\n  col = mix(col, rockColor * mix(0.25, 0.50, hf), smoothstep(0.70, 0.90, n.z));\n  // grass on flat area\n  col = mix(col, grassColor * mix(0.08, 0.35, hf), hf2 * smoothstep(0.75, 1.00, n.z));\n  return col;\n}\n\nvec3 computeWater(vec3 p, vec3 dir, vec3 n, float water, vec3 col) {\n  vec2 pos = p.xy + 1.0 * vec2(noise(p.xy / 100.), 0.);  // slightly displaced\n  float speed = texture(iChannel0, pos).x;\n  // make the water appear whiter on far-moving area\n  vec3 wCol = mix(waterColor, 10. * whiteWaterColor, smoothstep(0.0, 0.1, speed * n.z));\n  // add some coastal delineation\n  wCol = mix(wCol, vec3(8.0, 9.2, 10.2), smoothstep(0.003, 0.0, water));\n  return mix(col, wCol, smoothstep(.0, .03, water));\n}\n\nvec3 terrainColor(in vec3 p, in vec3 dir, in vec3 n, out bool isWater) {\n  spaceToPlane(p.xy);\n  vec4 values = texture(iChannel0, p.xy);\n  if (showSediments) return vec3(smoothstep(0.0, 0.1, 20. * values.y));\n\n  vec3 col = computeRock(p, n);\n  float water = hideWater ? 0. : values.w;\n  isWater = (water > WATER_THRESH);\n  col = isWater ? computeWater(p, dir, n, water, col)\n                : mix(col, snowColor, computeSnow(p, n));\n  return col;\n}\n\n//////////////////////////////////////////////////////////////////\n// Sky and sun\n// see https://www.shadertoy.com/view/WlSSzK\n\n#define Rayleigh 2.\n#define Mie .8\n#define RayleighAtt .5\n#define MieAtt 1.2\n#define g0 -0.93\n\nconst vec3 betaR = vec3(1.95e-2, 1.1e-1, 2.94e-1); \nconst vec3 betaM = vec3(4.00e-2, 4.0e-2, 4.00e-2);\n\nvec3 calcAtmosphericScattering(float cosine, float g1) {\n  float g2 = g1 * g1;\n  float M = Mie * (1. - g2) / (2. + g2);\n  float fcos2 = cosine * cosine;\n  float miePhase = M * pow(abs(1. + g2 + 2. * g1 * cosine), -1.5);\n  vec3 col = (1. + fcos2) * vec3(Rayleigh + betaM / betaR * miePhase);\n  return col;\n}\n\nfloat IFrac = 0.;  // TODO: bad! Remove!\nvec3 computeSky(vec3 O, vec3 D, vec3 lightDir) {\n  float sundot = max(0., dot(D, lightDir));\n  float zenithAngle = max(0.01, D.z);\n  vec3 phase = (betaR * RayleighAtt + betaM * MieAtt) / zenithAngle;\n  vec3 extinction = exp(-phase) / (1e-5 + IFrac);  // <= divine intervention!\n\n  vec3 inScatter = 0.3 * calcAtmosphericScattering(sundot, g0);\n  vec3 col = inScatter * (1.0 - extinction);\n  \n  // + sun haze\n  col += sunHaze * pow(sundot, 40.0) * extinction;\n\n  // Clouds\n  if (D.z > .0) {\n    vec2 sc = O.xy + D.xy * (100. - O.z) / D.z;\n    col += cloudColor * extinction * smoothstep(0.5, 0.8, fbm(0.002 * sc, 0.5));\n  }\n  return col;\n}\n\n// vertically sampled sky\nvec3 computeSkyVSampled(vec3 O, vec3 D, vec3 lightDir) {\n  vec3 col = vec3(0.);\n  const uint numSamples = 5u;\n  vec3 du = vec3(D.xy * D.y, -D.z * D.x);\n  for (uint i = 0u; i < numSamples; ++i) {\n    vec3 D2 = normalize(D + du * .9 * float(i) / float(numSamples));\n    col += computeSky(O, D2, lightDir);\n  }\n  return col / float(numSamples);\n}\n\n//////////////////////////////////////////////////////////////////\n// fog\n\nvec3 computeFog(float Oz, float Dz, float d) {\n  Oz *= fogAlpha;\n  Dz = -fogAlpha * max(-Dz, 0.01);\n  // This is the amount of attenuation collected by a ray Oz + t.Dz\n  // traversing an exponentially-decaying fog layer: F(z) = Fo.exp(-z/z0)\n  // It's just an integral to compute.\n  float fogAtt = (exp(-Dz * d) - 1.) * exp(-fogBeta * Oz / Dz);\n  return fogAtt * fogGradient - fogColor * .1;\n}\n\n//////////////////////////////////////////////////////////////////\n\nvec3 getLightPos() {\n  float t = iTime * .08;\n  return lightDistance * vec3(cos(t), sin(t), 0.7 - 0.4 * sin(t));\n}\n\nvec3 doLighting(vec3 O, vec3 D, vec2 hit) {\n  // sky & sun\n  vec3 light_pos = getLightPos();\n  if (hit.y <= 0.) return computeSky(O, D, normalize(light_pos - O));\n\n  // terrain\n  vec3 p = O + hit.x * D;\n  vec3 lightDir = normalize(light_pos - p);\n  vec3 n = terrainNormal(p);\n  p += n * 5e-2;\n  bool isWater;\n  vec3 col = terrainColor(p, D, n, isWater);\n  float light = max(0., dot(n, lightDir));\n  if (light > 0.) {\n    light *= softShadows(p, lightDir, .01);\n  }\n  col *= .3 + 1.0 * light;\n\n  if (isWater) {\n    n = waterNormal(p);  // use smoother normal for water reflection\n    vec3 r = reflect(D, n);\n    vec3 amb = diffuseColor * softShadows(p, r, 0.001);\n    vec3 sky = computeSkyVSampled(p, r, lightDir);\n    col += amb * sky;\n  }\n  col *= mix(shadeColor, sunColor, light);\n \n  if (ADD_FOG) col += computeFog(O.z, D.z, hit.x);\n\n  return col;\n}\n\n//////////////////////////////////////////////////////////////////\n// Camera path\n\nvec3 camPath(float t) {\n  return vec3(camDistance * cos(t) * sin(t) + .2,\n              camDistance * sin(t), camAltitude);\n}\n\nmat3 makeCamera(vec3 pos, vec3 target, float pan) {\n  vec3 front = normalize(target - pos);\n  front.xy *= mat2(cos(pan), -sin(pan), sin(pan), cos(pan));\n  vec3 up = BOOL.xxy;\n  vec3 right = normalize(cross(front, up));\n  up = cross(right, front);\n  return mat3(right, up, front);\n}\n\nfloat getFocal(float t) {\n  t = mod(t, 2. * zoomHalfPeriod);\n  t = min(smoothstep(0.0, zoomRamp,                  t),\n          smoothstep(0.0, zoomRamp, zoomHalfPeriod - t));\n  return mix(focalMin, focalMax, t);\n}\n  \n//////////////////////////////////////////////////////////////////\n// Main\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n  showSediments = KEY(84);  // 't' to show sediments\n  hideWater = KEY(85);      // 'u' to hide water\n  IFrac = float(IFrame(iFrame)) / float(WATER_BUILD_UP);\n\n  float t = KEY(83) ? 0. : iTime;  // 's' = stop camera\n  t = .2 * (length(vec2(max(t - 5., 0.), 5.)) - 5.);\n\n  vec3 pos = camPath(t) * (1. + 1.3 * iMouse.x / iResolution.x);\n  pos.z = max(quickTerrain(pos.xy).z + 0.2, pos.z);\n\n  vec3 target = camPath(t + 0.5);\n  target.z -= 0.8 + 2.0 * iMouse.y / iResolution.y;\n  float pan = .5 * sin(t * 0.3);\n  mat3 cam = makeCamera(pos, target, pan);\n\n  float focal = getFocal(t);\n  vec3 camRay = normalize(vec3(uv, focal));\n  vec3 ray_O = pos;\n  vec3 ray_D = cam * camRay;\n  vec2 hit = trace(ray_O, ray_D);\n  vec3 col = doLighting(ray_O, ray_D, hit);\n\n  col = pow(col, vec3(.4545));\n  vec2 v = fragCoord / iResolution.xy;\n  col *= pow(v.x * (1. - v.x) * v.y * (1. - v.y), .05);\n\n\n  // debug:\n  /*1*/ if (KEY(49)) col = ILOAD0(fragCoord).zzz;                 // terrain height\n  /*2*/ if (KEY(50)) col = ILOAD0(fragCoord).www / WATER_LEVEL0;  // water level\n  /*3*/ if (KEY(51)) col = vec3(length(ILOAD1(fragCoord))) * 3.;  // flow\n  /*4*/ if (KEY(52)) col = vec3(ILOAD0(fragCoord).x) * 30.;       // water velocity\n  /*5*/ if (KEY(53)) col = vec3(ILOAD0(fragCoord).y) * 30.;       // sediment\n  // Perspective views:\n  /*6*/ if (KEY(54) && hit.y > 0.) col = vec3(terrainValues(ray_O, ray_D, hit.x).x) * 50.;  // water velocity\n  /*7*/ if (KEY(55) && hit.y > 0.) col = vec3(terrainValues(ray_O, ray_D, hit.x).y) * 50.;  // sediment\n  /*8*/ if (KEY(56) && hit.y > 0.) col = vec3(terrainValues(ray_O, ray_D, hit.x).w) * 50.;  // water level\n\n  fragColor.rgb = col;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\n// Deluge simulator!   Terrain and erosion\n//\n// skal/ (Pascal Massimino)\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n//////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////\n// initial terrain\n\nfloat fbmTerrain(vec2 p) {\n  p *= 0.008;\n  float h = 150. * noise(p);  // base level, slowly varying\n  h *= pow(fbm(p * 2.0, 0.5), 1.5);  // w/ extra hi-freq modulation\n  return h / 80.;\n}\n\n// blend at the seams\n//   http://paulbourke.net/geometry/tiling/\nfloat mask(vec2 p) {\n  float edge = 50.;\n  vec2 blend;\n  blend  = smoothstep(0., edge,        p);\n  blend *= smoothstep(0., edge, WRAP - p);\n  return blend.x * blend.y;\n}\n\nfloat initialTerrain(vec2 p1, float seed) {\n  vec2 Period = WRAP * 0.5;\n  vec2 p2 = mod(p1 + Period + 310. * seed, WRAP);\n  vec2 ar = iResolution.yx / iResolution.y;\n  return fbmTerrain(p1 * ar) * mask(p1) + fbmTerrain(p2 * ar) * mask(p2);\n}\n\n//////////////////////////////////////////////////////////////////\n\nfloat Height(vec2 P) { return ILOAD0(P).z; }\nfloat Water(vec2 P) { return ILOAD0(P).w; }\nfloat Sediment(vec2 P) { return ILOAD0(P).y; }\nvec4 Flow(vec2 P) { return ILOAD1(P); }\nvec4 SFlow(vec2 P) { return Sediment(P) * ILOAD1(P); }  // sediment flow\n\nvec2 getFlow(vec2 P) {\n  float dF_out = dot(Flow(P), ONE);  // out-flow\n  float dF_in = Flow(P + BOOL.yx).x + Flow(P - BOOL.yx).y\n              + Flow(P + BOOL.xy).z + Flow(P - BOOL.xy).w;\n  return vec2(dF_in, dF_out);\n}\n\nvec2 getSFlow(vec2 P) {\n  float dF_out = dot(SFlow(P), ONE);\n  float dF_in = SFlow(P + BOOL.yx).x + SFlow(P - BOOL.yx).y\n              + SFlow(P + BOOL.xy).z + SFlow(P - BOOL.xy).w;\n  return vec2(dF_in, dF_out);\n}\n\n//////////////////////////////////////////////////////////////////\n// Terrain update\n\nvec3 terrainNormal(vec2 p) {\n  vec3 N = vec3(Height(p - BOOL.yx) - Height(p + BOOL.yx),\n                Height(p - BOOL.xy) - Height(p + BOOL.xy),\n                2. * BOOL.y);\n  return normalize(N);\n}\n\nconst float eStrength = 1.;\nconst float eMax = 0.1;\nfloat erodeTerrain(vec2 P, float z) {\n  vec3 nor = terrainNormal(P);\n  float dz = Height(P + nor.xy) + Height(P - nor.xy) - 2. * z;\n  z += clamp(dz * eStrength, -eMax, eMax);\n  return z;\n}\n\nvoid UpdateTerrain(vec2 P, inout vec4 cur) {\n  float w = cur.w; \n  float z = cur.z;\n  float s = cur.y;\n  float v = cur.x;   // water velocity\n\n  z = erodeTerrain(P, z);\n\n#if defined SEDIMENT_PHYSICS\n  if (cur.w > 0.001) {     // Sediment transport and deposition\n    vec2 dF = getFlow(P);\n    vec2 dSF = getSFlow(P);\n    float ds, ns;\n    // abrasion\n    if (v > .1) {\n      ds = min(min(w * v * abrasionSpeed, maxAbrasion), z);\n      ns = min(s + ds, maxSediment);\n      ds = ns - s;\n      ds = clamp(ds, -maxAbrasion, maxAbrasion);\n      s += ds;\n      z = max(0., z - 2.3 * ds);\n    }\n    // deposition\n    if (abs(dF.x) < .5 && s > 0.) {\n      ds = fractionDeposition * s;\n      ns = max(0., s - ds);\n      ds = min(s - ns, w);\n      s = s - ds;\n      z = z + .1 * ds;\n    }\n  }\n#endif\n\n  cur.z = max(z, 0.);\n  cur.y = s;\n}\n\n//////////////////////////////////////////////////////////////////\n// Water update\n\n#if 0\nvec2 waterSlope(vec2 P) {\n  float dWdx = Water(P + BOOL.yx) - Water(P - BOOL.yx);\n  float dWdy = Water(P + BOOL.xy) - Water(P - BOOL.xy);\n  return 0.5 * vec2(dWdx, dWdy);\n}\n#endif\n\nvoid UpdateWater(vec2 P, inout vec4 cur) {   // update water level according to flow\n  vec2 dF = getFlow(P); // [in, out] flow\n  float w = cur.w + timeStep * (dF.x - dF.y);   // w += (in-out)*dt\n  // make it rain (cyclic)!\n  if (w < .0001) w += RAIN * (0.5 + 0.5 * sin(iTime * .3));\n  // ...and evaporate, proportional to the current depth\n  w -= EVAPORATION * .001* smoothstep(0.5, 0.0, w);\n  w = max(0., w); // no negative water!\n  cur.w = w;\n}\n\nvec2 velocity(vec2 P) {\n  vec4 F = Flow(P);\n  float left   = Flow(P - BOOL.yx).y - F.x;\n  float right  = Flow(P + BOOL.yx).x - F.y;\n  float top    = Flow(P + BOOL.xy).z - F.w;\n  float bottom = Flow(P - BOOL.xy).w - F.z;\n  return 0.5 * vec2(left + right, top + bottom);\n}\n\nfloat waterSpeed(vec2 P) {\n  vec4 F = Flow(P);\n  return .2 * length(vec2(F.x - F.y, F.z - F.w));\n}\n\nfloat initialWater(vec2 P, float z, float fraction) {\n  float w = WATER_LEVEL0 * fraction;\n  w *= smoothstep(0.2, 3., z);  // more rain in altitude\n  return w;\n}\n\n//////////////////////////////////////////////////////////////////\n// sediment transport\n\nvoid UpdateSediments(vec2 P, inout vec4 cur) {\n  vec2 dSF = getSFlow(P);\n  float s = cur.s + timeStep * (dSF.x - dSF.y);\n  cur.y = min(max(s, 0.), maxSediment);\n}\n\nfloat initialSediment(vec2 P) {\n  return SEDIMENT_LEVEL0;\n}\n\n//////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 P) {\n  int I = IFrame(iFrame);\n  bool init = (I < WATER_BUILD_UP) || KEY(87);\n  bool do_terrain = (iFrame == 0) || KEY(82);  \n  if (any(greaterThanEqual(P, WRAP))) {\n    // replicate 2 samples to avoid seeing the seam\n    if (!init && all(lessThanEqual(P, WRAP + 2.))) {\n      fragColor = ILOAD0(P);\n      return;\n    } else {\n      discard;\n    }\n  }\n  fragColor = ILOAD0(P);\n  if (init || do_terrain) {\n    if (do_terrain) {\n      fragColor.z = initialTerrain(P, iTime * .4);\n      fragColor.y = initialSediment(P);\n    } else {\n      fragColor.w += initialWater(P, fragColor.z, float(I) / float(WATER_BUILD_UP));\n    }\n    fragColor.x = 0.;\n  } else {\n    UpdateWater(P, fragColor);\n    UpdateSediments(P, fragColor);\n    UpdateTerrain(P, fragColor);\n  }\n  fragColor.x = mix(fragColor.x, waterSpeed(P), .05);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//\n// Deluge simulator. Constants and defines.\n//\n// skal/ (Pascal Massimino)\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n//////////////////////////////////////////////////////////////////\n\n// Compute map size\n// #define WRAP iResolution.xy   // highest res (=slow!)\n//#define WRAP vec2(450.)\n#define WRAP vec2(360.)\n\n#define EPS 1e-3\nconst vec3 BOOL = vec3(0., 1., -1.);\n\nconst vec4 ZERO = vec4(0.);\nconst vec4 ONE = vec4(1.);\n\n// load at int position\n#define ILOAD(CHANNEL, P) texelFetch((CHANNEL), ivec2(mod(P, WRAP)), 0)\n#define ILOAD0(P) ILOAD(iChannel0, (P))\n#define ILOAD1(P) ILOAD(iChannel1, (P))\n\n#define KEY(K) (texelFetch(iChannel3, ivec2((K), 0), 0).x > 0.5)\n\n#define SEDIMENT_LEVEL0 0.02\n#define WATER_LEVEL0 0.002   // initial water amount\n#define RAIN 0.0008\n#define EVAPORATION 0.0009\n\n#define WATER_THRESH .001  // for display only\n\n#define WATER_RESET_PERIOD 2000\n#define WATER_BUILD_UP 100\nint IFrame(int frame) { return min(WATER_BUILD_UP, (frame - 1) % WATER_RESET_PERIOD); }\n\n// Sedimentation model\n#define SEDIMENT_PHYSICS\n#define abrasionSpeed 15.5\n#define depositionSpeed 0.1\n#define maxSediment 0.3\n#define maxAbrasion 0.13\n#define fractionDeposition 0.1\n\n// flow parameters\n#define flowVelocity .15  // <=> speed of sound in water\n// ~how fast water is transported. Slower values = large shockwaves, disasters!\n#define timeStep 0.04\n\n//////////////////////////////////////////////////////////////////\n\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(1.0, 113.0))) * 43758.5453123);\n}\n\nfloat noise(vec2 p) {\n  vec2 i = floor(p), f = fract(p);\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float n0 = hash(i + BOOL.xx);\n  float n1 = hash(i + BOOL.yx);\n  float n2 = hash(i + BOOL.xy);\n  float n3 = hash(i + BOOL.yy);\n  // interpolate\n  float ix0 = mix(n0, n1, u.x);\n  float ix1 = mix(n2, n3, u.x);\n  return mix(ix0, ix1, u.y);\n}\n\nfloat fbm(vec2 p, float amp) {\n  float f = 0.0;\n  for (int i = 0; i < 6; ++i, p *= 2., amp *= 0.5) {\n    f += amp * noise(p);\n  }\n  return f;\n}\n\nfloat fbml(vec2 p, float amp) {  // light version\n  float f = 0.0;\n  for (int i = 0; i < 2; ++i, p *= 2., amp *= 0.5) {\n    f += amp * noise(p);\n  }\n  return f;\n}\n\n//////////////////////////////////////////////////////////////////\n// Left-overs\n\n#if 0\nfloat terrainDerivatives(in vec2 p, out vec2 dF, out vec4 d2F) {\n  // 0 1 2\n  // 3[4]5\n  // 6 7 8\n  float h0 = Height(p + BOOL.zy);\n  float h1 = Height(p + BOOL.xy);\n  float h2 = Height(p + BOOL.yy);\n  float h3 = Height(p + BOOL.zx);\n  float h4 = Height(p + BOOL.xx);\n  float h5 = Height(p + BOOL.yx);\n  float h6 = Height(p + BOOL.zz);\n  float h7 = Height(p + BOOL.xz);\n  float h8 = Height(p + BOOL.yz);\n  // Evans-Young\n  dF = (1. / 6.) * vec2(h2 + h5 + h8 - h0 - h3 - h6,\n                        h0 + h1 + h2 - h6 - h7 - h8);\n  d2F.x = (h0 + h2 + h3 + h5 + h6 + h8 - 2. * (h1 + h4 + h7)) / 3.;  // d2F / dxx\n  d2F.y = (h0 + h1 + h2 + h6 + h7 + h8 - 2. * (h3 + h4 + h5)) / 3.;  // d2F / dyy\n  d2F.w = d2F.z = (h2 + h6 - h0 - h8) / 4.;                          // d2F / dxy\n  return h4;\n}\n\nfloat terrainCurvature(vec2 p) {\n  vec2 dF;\n  vec4 d2F;\n  float z = terrainDerivatives(p, dF, d2F);\n  return length(d2F);\n}\n\nvec3 terrainColor(vec2 p, float z, vec3 n) {\n  return terrainCurvature(p) * vec3(.8, .1, .1);\n}\n#endif\n", "buffer_b_code": "//\n// Flow advection, based on terrain height and water level\n//\n//  BufferB stores the water flow in 4 directions\n//    x = left, y = right, z = top, w = bottom\n//\n// skal/ (Pascal Massimino)\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n//////////////////////////////////////////////////////////////////\n\nfloat land(vec2 P) { return ILOAD0(P).z; }\nfloat water(vec2 P) { return ILOAD0(P).w; }\nvec4 flow(vec2 P) { return ILOAD1(P); }\n\nfloat totalH(vec2 P) {\n  vec4 v = ILOAD0(P);\n  return v.z + v.w;\n}\n\nvoid mainImage(out vec4 outFlow, in vec2 P) {\n  if (any(greaterThanEqual(P, WRAP))) {\n    if (all(lessThanEqual(P, WRAP + 2.))) {\n      outFlow = ILOAD1(P);\n      return;\n    } else {\n      discard;\n    }\n  }\n  vec4 F = ZERO;\n  if (IFrame(iFrame) >= WATER_BUILD_UP) {\n    float W0 = water(P);\n    float H = W0 + land(P); // <- = totalH(P);\n    float H0 = totalH(P - BOOL.yx);   // left\n    float H1 = totalH(P + BOOL.yx);   // right\n    float H2 = totalH(P - BOOL.xy);   // bottom\n    float H3 = totalH(P + BOOL.xy);   // top\n    vec4 diff = vec4(H) - vec4(H0, H1, H2, H3);\n    F = flow(P) + flowVelocity * diff;\n    F = max(F, ZERO);\n    float sum = timeStep * dot(F, ONE);  // total flow\n    if (sum > 0.00001) {\n      float K = clamp(W0 / sum, 0., 1.);\n      F = K * F;\n    }\n  }\n  outFlow = F;\n}\n", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKfWc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[2758, 2758, 2791, 2791, 2957], [2959, 2959, 2982, 2982, 3235], [3237, 3237, 3264, 3264, 3333], [3335, 3335, 3380, 3380, 3461], [3542, 3542, 3577, 3577, 4146], [4148, 4148, 4176, 4176, 4271], [4432, 4432, 4479, 4479, 4854], [4959, 4959, 4987, 4987, 5181], [5218, 5218, 5244, 5244, 5438], [5516, 5516, 5554, 5570, 5922], [5924, 5924, 5964, 5964, 6704], [6706, 6706, 6774, 6774, 7200], [7202, 7202, 7274, 7274, 7650], [7979, 7979, 8035, 8035, 8285], [8306, 8328, 8376, 8376, 8965], [8967, 8993, 9049, 9049, 9336], [9413, 9413, 9459, 9459, 9806], [9876, 9876, 9896, 9896, 9990], [9992, 9992, 10035, 10050, 10844], [10929, 10929, 10952, 10952, 11054], [11056, 11056, 11107, 11107, 11337], [11339, 11339, 11364, 11364, 11553], [11633, 11633, 11688, 11688, 13415]], "test": "untested"}
{"id": "css3R8", "name": "Normals to Sine Curve", "author": "mla", "description": "Find the normals to a sine curve y = sin(x) from a point (a,b) by finding the zeros of a related function g(a,b,x). The zeros are always in the highlighted area and we find them with a simple bisection process.\n\nMouse sets point (a,b).", "tags": ["sine", "curve", "normal"], "likes": 10, "viewed": 256, "published": 3, "date": "1665654955", "time_retrieved": "2024-07-30T16:26:32.439502", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Normals to Sine Curve, mla, 2022\n//\n// Find the normals from a point (a,b) to the curve y = sin(x) by finding\n// the zeros of a related function.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat scale = 6.0;\nfloat lwidth = 0.02;  // Line width\nfloat pwidth = 0.1;  // Point width\nfloat eps = 1.0/32.0; // For numerical derivative\nfloat N = 8.0;        // 2N bisection intervals\n\n// Zeros of g are the x coordinates of feet of normals from (a,b) to y = sin(x)\nfloat g(float a, float b, float x) {\n  return x - a + sin(x)*cos(x) - b*cos(x);\n}\n\nfloat h(float a, float b, float x) {\n  return 0.5*distance(vec2(a,b),vec2(x,sin(x)));\n}\n\n// Plots a function of x based on three consecutive values.\n// This is basically (y-f(x))/|(f'(x),1)|, using an approximate derivative.\nfloat graphdist(float y,float eps, float f0, float f1, float f2){\n  return abs(y-f1)/length(vec2((f2-f0)/(2.0*eps),1.0));\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  //h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nvec2 map(vec2 coords) {\n  vec2 uv = (2.0*coords - iResolution.xy)/iResolution.y;\n  uv.y += 0.5;\n  uv *= scale;\n  return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = map(fragCoord);\n  float t = 0.4*iTime;\n  vec2 mouse = vec2(6.5*sin(t),4.5*cos(t)+2.0);\n  if (iMouse.z > 0.0) mouse = map(iMouse.xy);\n  float x = uv.x, y = uv.y;\n  float px = fwidth(x);\n  float a = mouse.x, b = mouse.y;\n\n  vec3 col = vec3(0.5);\n  // Now find roots of g(a,b) - simple bisection method\n  float pdist = 1e8, ldist = 1e8, ldist2 = 1e8; // minimum distances\n  // g(a,b,x) can only have a zero in range a(abs(b)+0.5)\n  float span = abs(b)+0.5;\n  float x0 = a-span;\n  float y0 = g(a,b,x0);\n  // Find roots - split feasible range into 2N intervals\n  // and look for a bracketed root in each interval.\n  // We might miss close pairs of roots - maybe better\n  // to find roots of derivative.\n  for (float i = -N; i < N; i++) {\n    float x1 = a+span/N*(i+1.0);\n    float y1 = g(a,b,x1);\n    if (y0*y1 <= 0.0) {\n      // Bracketed, so now bisect\n      for (int j = 0; j < 6; j++) {\n        float x2 = 0.5*(x0+x1);\n        float y2 = g(a,b,x2);\n        if (y0*y2 <= 0.0) { x1 = x2; y1 = y2; }\n        else { x0 = x2; y0 = y2; }\n      }\n      vec2 zero = vec2(x0,0);\n      vec2 foot = vec2(x0,sin(x0));\n      pdist = min(pdist,distance(uv,zero));\n      pdist = min(pdist,distance(uv,foot));\n      pdist = min(pdist,distance(uv,vec2(x0,h(a,b,x0))));\n      ldist2 = min(ldist2,line(uv,zero,foot));\n      ldist = min(ldist,segment(uv,mouse,foot));\n    }\n    x0 = x1; y0 = y1;\n  }\n  col = mix(vec3(0.6),col,smoothstep(0.0,px,abs(ldist2)-0.5*lwidth));\n\n  col = mix(vec3(0.1),col,smoothstep(0.0,px,abs(y)-0.75*lwidth)); // Axes\n  float d = graphdist(y,eps,g(a,b,x-eps),g(a,b,x),g(a,b,x+eps));\n  col = mix(vec3(1,1,0),col,smoothstep(0.0,px,d-lwidth)); // normal curve\n  d = graphdist(y,eps,h(a,b,x-eps),h(a,b,x),h(a,b,x+eps));\n  col = mix(vec3(0,0,1),col,smoothstep(0.0,px,d-lwidth)); // distance curve\n  {\n#define F(x) (sin(x))\n    float y0 = F(a);\n    float y1 = F(a-eps);\n    float y2 = F(a+eps);\n    y1 -= y0; y2 -= y0; // Rebase\n    float A = 0.5*(y2+y1)/(eps*eps);\n    float B = 0.5*(y2-y1)/eps;\n    float x0 = x-a-eps;\n    float x1 = x-a;\n    float x2 = x-a+eps;\n    float f0 = A*x0*x0+B*x0;\n    float f1 = A*x1*x1+B*x1;\n    float f2 = A*x2*x2+B*x2;\n    float d = graphdist(y-y0,eps,f0,f1,f2);\n    col = mix(vec3(0),col,smoothstep(0.0,px,d-0.66*lwidth));\n#undef F\n  }\n  d = graphdist(y,eps,sin(x-eps),sin(x),sin(x+eps));\n  col = mix(vec3(1,0,0),col,smoothstep(0.0,px,d-lwidth)); // sine\n\n  col = mix(vec3(0.25),col,smoothstep(0.0,px,abs(ldist)-0.5*lwidth));\n  //col = mix(vec3(0.4),col,smoothstep(0.0,px,abs(ldist2)-0.5*lwidth));\n  col = mix(vec3(0.0),col,smoothstep(0.0,px,abs(pdist)-pwidth));\n  vec2 xseg0 = vec2(0.2,0);\n  vec2 xseg1 = xseg0.yx;\n  d = min(segment(uv,mouse+xseg0,mouse-xseg0),\n          segment(uv,mouse+xseg1,mouse-xseg1));\n  col = mix(vec3(0),col,smoothstep(0.0,px,d-lwidth));\n  if (x < a-span || x > a+span) col *= 0.8; // Highlight feasible region\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/css3R8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[508, 588, 624, 624, 669], [671, 671, 707, 707, 758], [760, 896, 961, 961, 1019], [1021, 1021, 1060, 1060, 1161], [1163, 1163, 1199, 1199, 1302], [1304, 1304, 1327, 1327, 1429]], "test": "untested"}
{"id": "cdlGRn", "name": "cakeeeee", "author": "prishainabox", "description": "More specific sources in the code.\n\nReel on IG: https://www.instagram.com/reel/Cjqqkhtjtl-/?utm_source=ig_web_copy_link\n\nSorry, my code is reused and needs refactoring.", "tags": ["raymarching"], "likes": 9, "viewed": 156, "published": 3, "date": "1665626590", "time_retrieved": "2024-07-30T16:26:33.323139", "image_code": "const float EPSILON = 0.001;\nconst float MAX_DIST = 60.0;\nconst int AA = 2; // sqrt(samples per pixel)\n\n//*******************************************************//\n\n// Light structs\n\nstruct Light {\n    bool isPointLight;\n    vec3 clr;\n    float shadowSoftness;\n    // if isPointLight, set position, else set direction\n    vec3 pos;\n    vec3 dir;\n    float brightness;\n};\n\n// create a light\nLight createLight(in vec3 pt, in bool isPointLight, in float fadeAdjust, in float shadowSoftness, in vec3 dirOrPos, in vec3 clr) {\n    Light light;\n    light.clr = clr;\n    light.shadowSoftness = shadowSoftness;\n    if (isPointLight) {\n        light.pos = dirOrPos;\n        light.isPointLight = true;\n        float d = distance(pt, light.pos);\n        d = pow(d, fadeAdjust);\n        light.brightness = 1.0 / (d * d);\n        light.dir = normalize(light.pos - pt);\n    } else {\n        light.brightness = 1.0;\n        light.dir = dirOrPos;\n    }\n    return light;\n}\n\n// Material struct\nstruct Material {\n    vec3 clr;\n    float amb;\n    float dif;\n    float spec;\n    float shininess;\n    vec3 ref;\n    bool hasFresnel;\n    int id;\n    vec3 groundBounceClr;\n};\n\n// return a nondescript material\nMaterial defaultMaterial() {\n    Material mat;\n    mat.amb = 0.1;\n    mat.clr = vec3(0.05);\n    mat.dif = 1.0;\n    mat.spec = 1.0;\n    mat.shininess = 10.0;\n    mat.ref = vec3(0.0);\n    mat.hasFresnel = false;\n    mat.id = -1;\n    mat.groundBounceClr = vec3(0.0);\n    return mat;\n}\n\n//*******************************************************//\n\n// clamp value from 0 to 1\nfloat uclamp(float val) {\n    return clamp(val, 0.0, 1.0);\n}\n\n// SMOOTH MIN from Inigo Quilez\nfloat smoothmin(in float a, in float b, in float k) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smoothmax\nfloat smoothmax(float a, float b, float k) {\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n//*******************************************************//\n\nfloat sdCake(in vec3 pt, out Material mat) {\n    mat.id = 0;\n    float res = length(pt.xz) - 2.2 - 0.4*smoothstep(2.5, 0.0, pt.y);\n    res = smoothmax(res, pt.y - 2.5, 0.6);\n    res = smoothmax(res, -pt.y-0.2, 0.2);\n    return res;\n}\n\nfloat sdCherries(in vec3 pt, in float rad, out Material mat) {\n    mat.id = 1;\n    float angBetween = 6.283185/9.0; // two PI divided by num of cherries\n    float sec = round(atan(pt.z, pt.x)/angBetween);\n    float rot = sec * angBetween;\n    vec3 p = pt - vec3(0, 2.85, 0);\n    p *= vec3(1, 1.1, 1);\n    p.xz = mat2(cos(rot), -sin(rot), \n                 sin(rot), cos(rot))*p.xz;\n    float res = length(p - vec3(1.5, 0.0, 0.0)) - rad;\n    return res;\n}\n\nfloat sdPlate(in vec3 pt, out Material mat) {\n    mat.id = 2;\n    mat.ref = vec3(0.1, 0.1, 0.2);\n    // outer\n    float res = length(pt.xz) - 3.1;\n    res = smoothmax(res, abs(pt.y) - 0.05, 0.03);\n    // inner\n    float inner = length(pt.xz) - 2.9;\n    inner = smoothmax(inner, abs(pt.y - 0.03) - 0.03, 0.03); \n    res = smoothmax(res, -inner, 0.05);\n    return res;\n}\n\nfloat sdFrosting(in vec3 pt, out Material mat) {\n    mat.id = 3;\n    float ang = atan(pt.z, pt.x);\n    float a = 2.4;\n    float res = length(pt.xz) - a - 0.05*sin(15.0 * ang);\n    vec3 p = pt - vec3(0, 2.6 - 0.7*smoothstep(a-0.3, a+0.1, length(pt.xz)), 0);\n    res = smoothmax(res, abs(p.y) - 0.2, 0.2);\n    // cherries cut out\n    Material m;\n    res = smoothmax(res, -sdCherries(pt, 0.24, m), 0.08);\n    return res*0.35;\n}\n\n\n\n//*******************************************************//\n\n// SDF SCENE\n\nfloat sdf(in vec3 pt, out Material mat) {\n\n    // distance to closest object\n    float res = MAX_DIST;\n    \n    // default\n    mat = defaultMaterial();\n    \n    // plate\n    Material plateMat = defaultMaterial();\n    float plate = sdPlate(pt, plateMat);\n    \n    // cake\n    Material cakeMat = defaultMaterial();\n    float cake = sdCake(pt, cakeMat);\n    \n    // frosting\n    Material frostingMat = defaultMaterial();\n    float frosting = sdFrosting(pt, frostingMat);\n    \n    // cherries\n    Material cherriesMat = defaultMaterial();\n    float cherries = sdCherries(pt, 0.23, cherriesMat);\n    \n    if (cake < res) {\n        res = cake;\n        mat = cakeMat;\n    }\n    \n    if (frosting < res) {\n        res = frosting;\n        mat = frostingMat;\n    }\n    \n    if (cherries < res) {\n        res = cherries;\n        mat = cherriesMat;\n    }\n    \n    mat.hasFresnel = true;\n    \n    if (plate < res) {\n        res = plate;\n        mat = plateMat;\n        mat.hasFresnel = false;\n    }\n\n    return res;\n    \n}\n\n//*******************************************************//\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pt) {\n    vec2 h = vec2(EPSILON, 0);\n    Material m;\n    // central difference sdf(pt + EPSILON) - sdf(pt - EPSILON)    \n    return normalize(vec3(\n       sdf(pt + h.xyy, m) - sdf(pt - h.xyy, m),\n       sdf(pt + h.yxy, m) - sdf(pt - h.yxy, m),\n       sdf(pt + h.yyx, m) - sdf(pt - h.yyx, m)\n    ));\n}\n\n//*******************************************************//\n\nfloat castRay(in vec3 ro, in vec3 rd, out Material mat) {\n\n    // total distance traveled\n    float td = 0.0;\n    \n    for (int i = 0; i < 100; i++) {\n        float h = sdf(ro + td*rd, mat);\n        // if distance is really close, break\n        if (abs(h) < (0.0001*td)) break;\n        // add to total distance\n        td += h;\n        // if too far, break\n        if (td >= MAX_DIST) {\n            mat.id = -1;\n            mat.ref = vec3(0.0);\n            mat.hasFresnel = false;\n            break;\n        }\n    }\n    \n    return td;\n    \n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softShadow(in vec3 ro, in vec3 rd, in float k) {\n    float res = 1.0; // result\n    float td = 0.05; // total distance traveled\n    for (int i = 0; i < 200 && td < MAX_DIST; i++) {\n        Material m;\n        float d = sdf(ro + td*rd, m);\n        if (d < 0.001) {\n            // intersection, so return shadow\n            return 0.0;\n        }\n        res = min(res, k*d/td);\n        td += d;\n    }\n    // if no intersection -> shadow 0.0 to light 1.0\n    return res;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\n// ambient occlusion\nfloat calcOcc(in vec3 pt, in vec3 nor) {\n\n    float occ = 0.0;\n    float scl = 1.0;\n    \n    Material m; // placeholder\n    \n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.11 * 0.25 * float(i);\n        float d = sdf(pt + h * nor, m);\n        occ += (h-d)*scl;\n        scl *= 0.95;\n    }\n    \n    return uclamp(1.0 - 2.0 * occ);\n    \n}\n\n//*******************************************************//\n\n// https://iquilezles.org/articles/fog\nvec3 applyFog(in vec3 rd, in float d, in vec3 clr, in vec3 sunClr, in vec3 sunDir, in vec3 skyClr) {\n    vec3 fogClr = mix( skyClr, sunClr, pow(max(dot(rd, sunDir), 0.0), 15.0) );\n    return mix(clr, fogClr, 1.0 - exp(-0.00005 * d * d * d)); // fog\n}\n\nvec3 calcLighting(in vec3 pt, in vec3 rd, in vec3 nor, in Light light, in Material mat) {\n\n    // diffuse\n    float dif = uclamp(dot(nor, light.dir)) * mat.dif;\n    \n    // shadow (has tint)\n    vec3 shadow = light.isPointLight ? vec3(1.0) : vec3(1.0, 0.8, 0.9) * softShadow(pt, light.dir, light.shadowSoftness);\n    \n    // specular\n    vec3 ref = reflect(light.dir, nor);\n    float spec = pow(uclamp(dot(rd, ref)), mat.shininess) * mat.spec;\n\n    // return dif * clr * shadow * spec + dif * clr * shadow; \n    return light.brightness * light.clr * shadow * dif * (spec + 1.0);\n    \n}\n\nvec3 calcClr(in vec3 ro, in vec3 rd, in float d, in vec3 nor, in Material mat) {\n\n    vec3 pt = ro + rd * d;\n\n    // COLORS\n    vec3 skyClr = vec3(0.55, 0.25, 0.55);\n    \n    // KEY LIGHT\n    Light sun = createLight(pt, false, 1.0, 10.9, normalize(vec3(10, 12.5, 3)), vec3(9, 8, 9)+5.0*skyClr);\n    \n    // background color\n    vec3 clr = skyClr;\n\n    if (mat.id == -1) {\n        // return background if too far (id is -1.0)\n        return clr;\n    } else if (mat.id == 0) {\n        // cake\n        mat.clr = vec3(0.06, 0.06, 0.02);\n    } else if (mat.id == 1) {\n        // cherry\n        mat.clr = vec3(0.15, 0.02, 0.01)*0.9;\n        mat.shininess = 100.0;\n        mat.dif = 0.3;\n        mat.amb = 0.0;\n        mat.spec = 10.0;\n    } else if (mat.id == 2) {\n        // plate\n        mat.clr = vec3(0.04, 0.05, 0.1);\n        mat.dif = 0.5;\n        mat.shininess = 20.0;\n        mat.spec = 20.0;\n    } else if (mat.id == 3) {\n        // frosting\n        mat.clr = vec3(0.05, 0.02, 0.01) * 0.07;\n    }\n    \n    clr = mat.clr;\n    \n    // LIGHTS\n   \n    // CALCULATE COLOR\n    float occ = calcOcc(pt, nor);\n    vec3 light = vec3(mat.amb);\n    light += calcLighting(pt, rd, nor, sun, mat); // sun\n    light += (uclamp(dot(nor, vec3(0, 1, 0))) * 0.5 + 0.5) * skyClr; // sky diffuse\n\n    clr *= light * occ;\n    \n    return clr;\n\n}\n\n//*******************************************************//\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    \n    Material mat;\n\n    float d = castRay(ro, rd, mat);\n    vec3 nor = calcNormal(ro + rd*d);\n    \n    vec3 clr = calcClr(ro, rd, d, nor, mat);\n    \n    bool willReflect = mat.ref.r > 0.0 || mat.ref.g > 0.0 || mat.ref.b > 0.0;\n    if (mat.hasFresnel || willReflect) {\n    \n        int bounces = 1;\n        vec3 ref = vec3(0.0);\n        float fresnel = 0.4 * uclamp(pow(1.0 - dot(nor, -rd), 5.0));\n        \n        // if the material will reflect\n        if (willReflect) {\n            // if reflective and doesn't have fresnel\n            if (!mat.hasFresnel) ref = mat.ref;\n            // if reflective with fresnel\n            else ref = fresnel * mat.ref;\n        } else {\n            ref = vec3(fresnel);\n        }\n        \n        // bouncing around for fresnel and reflection\n        vec3 fil = vec3(1.0);\n        if (fresnel > 0.0) {\n            for (int i = 0; i < bounces; i++) {\n                fil *= ref;\n                // to intersection point and reflect\n                ro += rd*d + nor*EPSILON*3.0;\n                rd = reflect(rd, nor);\n                // find new point\n                d = castRay(ro, rd, mat);\n                nor = calcNormal(ro + rd*d);\n                // add color\n                clr += fil * calcClr(ro, rd, d, nor, mat);\n                if (mat.id == -1) break;\n            }\n        }\n        \n    }\n    \n    clr = pow(clr, vec3(1.0 / 2.2)); // gamma correction\n    return clr;\n    \n}\n\n//*******************************************************//\n\nvec3 setCamera(in vec2 uv, in vec3 ro, in vec3 target) {\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, forward));\n    // ray direction\n    vec3 rd = normalize(uv.x * right + uv.y * up + 1.2 * forward);\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 res = iResolution.xy;\n    \n    // target\n    vec3 target = vec3(0, 0.5, 0);\n    // ray origin\n    float r = 5.5;\n    float t = iTime * 0.2;\n    vec3 ro = vec3(r * cos(t), 3.7, r * sin(t));\n    \n    // accumulate color\n    vec3 clr = vec3(0.0);\n    \n    for (int i = 0; i < AA; i++) {\n        for (int j = 0; j < AA; j++) {\n            // Normalized pixel coordinates\n            vec2 f = fragCoord + vec2(float(i), float(j)) / float(AA);\n            vec2 uv = (2.0*f - res) / min(res.x, res.y);\n            vec3 rd = setCamera(uv, ro, target);\n            // calculate color based on distance, etc\n            clr += render(ro, rd);\n        }\n    }    \n    \n    clr /= float(AA*AA);\n\n    // Output to screen\n    fragColor = vec4(clr, 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdlGRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[372, 390, 520, 520, 955], [1152, 1185, 1213, 1213, 1466], [1529, 1556, 1581, 1581, 1616], [1618, 1650, 1703, 1703, 1792], [1794, 1807, 1851, 1851, 1923], [1986, 1986, 2030, 2030, 2219], [2221, 2221, 2283, 2283, 2675], [2677, 2677, 2722, 2722, 3045], [3047, 3047, 3095, 3095, 3471], [3550, 3550, 3591, 3626, 4559], [4622, 4668, 4697, 4697, 4992], [5055, 5055, 5112, 5144, 5597], [5599, 5644, 5698, 5698, 6119], [6121, 6183, 6223, 6223, 6531], [6594, 6633, 6733, 6733, 6883], [6885, 6885, 6974, 6990, 7470], [7472, 7472, 7552, 7552, 8797], [8860, 8860, 8897, 8897, 10330], [10393, 10393, 10449, 10449, 10704], [10706, 10706, 10763, 10763, 11520]], "test": "untested"}
{"id": "DsfGzH", "name": "flutter test iResolution, iMouse", "author": "timmaffett", "description": "copy of https://www.shadertoy.com/view/llySRh\nexcept things that skia doesnt support have been removed\nadded date year,month, day display\nimproved keyboard report to show toggle, down and initial click\nallow ifdef'ing out sound and lod info", "tags": ["test", "imouse", "itime", "iresolution"], "likes": 4, "viewed": 364, "published": 3, "date": "1665618771", "time_retrieved": "2024-07-30T16:26:34.393279", "image_code": "//=== original link for citation: https://www.shadertoy.com/view/llySRh\n//find many other tricks here: https://shadertoyunofficial.wordpress.com/\n\n// --- content:\n// - 2D and 3D rotations\n// - hue\n// - printing chars, text, ints, floats\n// - key togggles ( + main special codes )\n// - events ( mouse just clicked, texture loaded )textureS\n// - antialiased line drawing \n// - hash ( 1D, 2D, 3D, etc ).\n\n// defines to (mostly) reduce functionality\n#define USE_TEXELFETCH 1\n#define SOUND_INFO   1\n#define LOD_INFO     1\n#define TEXTUREGRAD  0   // enable to remove boxes around letters, and slow fps down by x3..\n\n#define SMALL_KEY_BLOCK  0         // must be 1 for sksl\n#define BETTERNOISE 1              // must be 0 for sksl\n\n#if SMALL_KEY_BLOCK   \n#define LOWKEY 32    // space-letters only for keys for skia (sksl loop unrolling hits size limits otherwise)\n#define HIGHKEY 97\n#else\n#define LOWKEY  0\n#define HIGHKEY 255\n#endif\n\n// --- rotations -----------------------------------------------------\n\n// 2D, or one axis after the other:\n#define rot2(a)      mat2(cos(a),-sin(a),sin(a),cos(a)) // V.xy *= rot2(a.z)\n\n// 3D rot around an arbitrary axis\n#define rot(P,A,a) ( mix( A*dot(P,A), P, cos(a) ) + sin(a)*cross(P,A) )\n\n\n// --- short approx hue -------------- https://www.shadertoy.com/view/ll2cDc\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n#define hsv(h,s,v)    (v) * ( 1. + (s)* ( .6 * cos( 6.3*(v)  + vec3(0,23,21)  ) - .4 ) )\n// short exact:\n//#define hsv(h,s,v)  (v) * ( 1. + (s)* clamp(  abs( fract( h + vec3(3,2,1)/3. ) * 6. - 3. ) - 2., -1.,0.) )\n\n\n// --- printing chars, integers and floats ---------------------------\n\n// --- access to the image of ascii code c\n\n// Deferred draw (call draw_char() ). Run and compiles faster.\n//     First only determine the valid char id at cur pixel \n//     then call the draw char once at the end.\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc O+=char((U),(64+CAPS+c));\n\n#if TEXTUREGRAD\nvec2 dfdx, dfdy;\n#endif\n\nint char_id = -1;\nvec2 char_pos; \nvec4 char(vec2 p, int c) {\n#if TEXTUREGRAD\n    vec2 dfdx = dFdx(p/16.), dfdy = dFdy(p/16.);\n#endif\n    //if ( p.x>.25&& p.x<.75 && p.y>.0&& p.y<1. ) {  // normal char box\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) {// thighly y-clamped to allow dense text\n        char_id = c;\n        char_pos = p;\n    }\n    return vec4(0);\n}\nvec4 draw_char() {\n    if(char_id < 0) {\n      return vec4(0,0,1.0,1e5);\n    } else {\n#if TEXTUREGRAD\n      return textureGrad( iChannel0, char_pos/16. + fract( vec2(char_id, 15-char_id/16) / 16. ), dfdx, dfdy );\n#else\n       return texture( iChannel0, (char_pos + vec2(char_id, 15-char_id/16)) / 16. );\n#endif\n    }\n}\n\n\n// --- display int4\n#if 0\nvec4 pInt(vec2 p, float n) {  // webGL2 variant with dynamic size\n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .5 )\n        v += char(p, 48+ mod(i,10) );\n    return v;\n}\n#else\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n#endif\n\nvec4 pKeyState(vec2 U, bool kDown, bool kClick, bool kToggle ) {\n    vec4 O = vec4(0);\n    caps\n    if(kDown) { C(4); }  // D for down\n    if(kClick) { C(16); } // P for pressed C(3);  // C for click\n    if(kToggle){ C(20); } // T for toggle\n    return O;\n}\n\n// --- display float4.4\nvec4 pFloat(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n    float upper = floor(n);\n    float lower = fract(n)*1e4 + .5;  // mla fix for rounding lost decimals\n    if (lower >= 1e4) { lower -= 1e4; upper++; }\n    v += pInt(p,upper); p.x -= 2.;\n    v += char(p, 46);   p.x -= .5;\n    v += pInt(p,lower);\n    return v;\n}\n\n// printing full IEEE floats (right or left justified): see https://www.shadertoy.com/view/7dfyRH , https://www.shadertoy.com/view/7sscz7\n\n// NB: use either char.x ( pixel mask ) or char.w ( distance field + 0.5 )\n \n\n// --- key toggles -----------------------------------------------------\n\n// FYI: LEFT:37  UP:38  RIGHT:39  DOWN:40   PAGEUP:33  PAGEDOWN:34  END : 35  HOME: 36\n// Modifiers: SHIFT: 16 CTRL: 17 ALT: 18\n// Advice:  Mode: keyToggle(key)  Action: keydown(key)+keyclick(modifier)\n\n\n#if USE_TEXELFETCH\n\n// texelFetch to read keys\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0. )\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0. )\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0. )\n\n#define shift             ( texelFetch(iChannel3,ivec2(16,0),0).x  > 0. )\n#define ctrl              ( texelFetch(iChannel3,ivec2(17,0),0).x  > 0. )\n#define alt               ( texelFetch(iChannel3,ivec2(18,0),0).x  > 0. )\n#define modifier          ( int(shift) +2*int(ctrl) + 4*int(alt) )\n\n#else\n\n// Use texture() which skia supports\n#define keyDown(ascii)    ( texture(iChannel3,vec2((float(ascii)+.05)/256., 0.05/3.)).x > 0. )\n#define keyClick(ascii)   ( texture(iChannel3,vec2((float(ascii)+.05)/256., 1.05/3.)).x > 0. )\n#define keyToggle(ascii)  ( texture(iChannel3,vec2((float(ascii)+.05)/256., 2.05/3.)).x > 0. )\n\n#define shift             ( texture(iChannel3,vec2((float(16)+.05)/256., 0.05/3.)).x  > 0. )\n#define ctrl              ( texture(iChannel3,vec2((float(17)+.05)/256., 0.05/3.)).x  > 0. )\n#define alt               ( texture(iChannel3,vec2((float(18)+.05)/256., 0.05/3.)).x  > 0. )\n#define modifier          ( int(shift) +2*int(ctrl) + 4*int(alt) )\n#endif\n\n\n\n\n// --- events ----------------------------------------------------------\n\n// --- mouse side events https://www.shadertoy.com/view/3dcBRS\n#define mouseUp      ( iMouse.z < 0. )                  // mouse up even:   mouse button released (well, not just that frame)\n#define mouseDown    ( iMouse.z > 0. && iMouse.w > 0. ) // mouse down even: mouse button just clicked\n#define mouseClicked ( iMouse.w < 0. )                  // mouse clicked:   mouse button currently clicked\n\n// --- texture loaded\n#define textureLoaded(i) ( iChannelResolution[i].x > 0. ) \n\n// --- (re)init at resolution change or at texture (delayed) load:\n// in buffX, store iResolution.x or iChannelResolution[i] somewhere. e.g. (0,0).w\n// if ( currentVal != storedVal ) init; storeVal.\n\n\n// --- antialiased line drawing ------ https://www.shadertoy.com/view/4dcfW8\n\n#define S(d,r,pix) smoothstep( .75, -.75, (d)/(pix)-(r))   // antialiased draw. r >= 1.\n// segment with disc ends: seamless distance to segment\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    return length(p - b * h);                         // dist to segment\n}\n// line segment without disc ends ( sometime useful with semi-transparency )\nfloat line0(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b),                  // proj coord on line\n          c = clamp(h, 0., 1.);\n    return h==c ? length(p - b * h) : 1e5;            // dist to strict segment\n}\n    // You might directly return smoothstep( 3./R.y, 0., dist),\n    //     but more efficient to factor all lines.\n    // Indeed we can even return dot(,) and take sqrt at the end of polyline:\n    // p -= b*h; return dot(p,p);\n\n\n// for polylines with acute angles, see: https://www.shadertoy.com/view/fdVXRh\n\n\n// --- old fashioned float-based hash. Might give user-dependant results --------------------\n\n// nowadays integer noise is safer. see especially: https://www.shadertoy.com/results?query=integer+hash+-\n//                         my variants:  vec3vec3: https://www.shadertoy.com/view/NtjyWw\n//                                      vec2float: https://www.shadertoy.com/view/fsKBzw\n#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define hash2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define hash3(p) fract(sin((p)*mat3(127.1,311.7, 74.7,  269.5,183.3,246.1,  113.5,271.9,124.6))*43758.5453123)\n#define hash2x3(p) fract(sin((p)*mat3x2(127.1,311.7,  269.5,183.3,  113.5,271.9))*43758.5453123)\n// attention: on windows, it is better to use sin(mod(... , 2pi))\n\n#define SMALL_FONT_SIZE 1.5\n#define SMALLER_FONT_SIZE 2.0  // higher numbers == smaller fonts\n\n#define KEY_COLUMN_START 1.15  // was 1.45\nvoid mainImage( out vec4 O,  vec2 uv ) // === demos it all ==================================\n{\n    O -= O;\n    vec2 R = iResolution.xy, U;\n    uv *= 1.03; // overall font size adjustment (high number == smaller fonts)\n    uv /= R.y;    \n    int lod = int(mod(iTime,10.));\n    \n    U = ( uv - vec2(.0,.9) ) * 16.;  caps C(18) low C(5)C(19)C(15)C(12) caps C(-6)  // \"Resol\"\n                             U.x-=1.; low C(19)C(3)C(18)C(5)C(5)C(14)               // \"screen\"\n    U = ( uv - vec2(.6,.9) ) * 16.;   low C(20)C(5)C(24)C(20)                       // \"text\"\n#if LOD_INFO\n    U = ( uv - vec2(.85,.9) ) * 16.;  low C(12)C(15)C(4) spc C(-48+lod)             // \"lod\"\n#endif\n#if SOUND_INFO\n    U = ( uv - vec2(1.15,.9) ) * 16.;  low C(19)C(15)C(21)C(14)C(4)                 // \"sound\"\n#endif\n    U = ( uv - vec2(.0,.5) ) * 16.;  caps C(13) low C(15)C(21)C(19)C(5) caps C(-6)  // \"mouse\"\n    U = ( uv - vec2(.5,.6) ) * 16.;  caps C(20) low C(9)C(13)C(5) caps C(-6)        // \"Time\"\n    U = ( uv - vec2(KEY_COLUMN_START,.55) ) * 16.;  caps C(11) low C(5)C(25)C(19) caps C(-6)         // \"Keys\"\n\n    \n    U = ( uv - vec2(.1,.8) ) * 8.;        // --- column 1\n    O += pInt(U, R.x);  U.y += .8;   // window resolution\n    O += pInt(U, R.y);  U.y += .8;\n    O += pFloat((U-vec2(-1,.35))*SMALL_FONT_SIZE, R.x/R.y);  U.y += .8;\n  //O += pInt(U, iResolution.z);  U.y += .8;\n    U.y += .8;\n    low\n    O += pInt(U, iMouse.x);  U.y += .8;        // mouse location\n    O += pInt(U, iMouse.y);  U.y += .8;\n    U.y += .4;\n    O += pInt(U, iMouse.z);  U.y += .8;      // last mouse-click location \n    O += pInt(U, iMouse.w);  U.y += .8;\n    \n    //mouse x,y,z,w\n    U = ( uv - vec2(.35,.4) ) * 16.;  \n    C(24) U.y += 1.6; U.x+=0.5;  //x\n    C(25) U.y += 2.2; U.x+=0.5;  //y\n    C(26) U.y += 1.6; U.x+=0.5;  //z\n    C(23) U.y += 1.6; U.x+=0.5;  //w\n \n    \n    \n    U = ( uv - vec2(.5,.8) ) * 8.;        // --- column 2\n\n    if ( !textureLoaded(1) )                   // texture not loaded yet\n        if (U.x>0. && U.y>-1.5 && U.x<2.5 && U.y<1.5) O.r+= .5;\n    O += pInt(U, iChannelResolution[1].x);  U.y += .8; // texture ( video )\n    O += pInt(U, iChannelResolution[1].y);  U.y += .8; // see LOD in column 2b\n    //O += pInt(U, iChannelResolution[1].z);  U.y += .8;\n    U.y += .8;\n\n    O += pFloat(U, iTime);         U.y += .8;  // time\n    O += pInt(U, float(iFrame));   U.y += .8;  // iFrame\n    O += pFloat(U, 1./iTimeDelta); U.y += .8;  // FPS\n\n    // hour, min, second\n    U.y += .8;\n    O += pInt(U, iDate.w/3600.);          U.x -= 2.5;\n    O += pInt(U, mod(iDate.w/60.,60.));   U.x -= 2.5;\n    O += pFloat(U, mod(iDate.w,60.));  \n\n\n    //date year, month, day\n    U.y += .8;\n    U.x += 5.0;\n    O += pInt(U, iDate.x);   U.x -= 2.5; \n    O += pInt(U, iDate.y);   U.x -= 2.5;\n    O += pInt(U, iDate.z);  \n\n#if LOD_INFO\n    U = ( uv - vec2(.8,.8) ) * 8.;        // --- column 2b\n    if (iChannelResolution[1].x==1. &&  iChannelResolution[1].x > 1.) // video/sound lock by stupid new web media policy.\n        if (U.x>0. && U.y>-1.5 && U.x<2.5 && U.y<1.5) O.r+= .5; // Colored bg on fonts turned BW later: in immediate mode, should be defered.\n                                                                // Or transform char/draw_char for they directly return BW.\n    ivec2 S = ivec2(iChannelResolution[1].xy);\n    O += pInt(U, float(S.x));  U.y += .8; // texture LOD\n    O += pInt(U, float(S.y));  U.y += .4;\n    U *= SMALLER_FONT_SIZE; O += pFloat(U, iChannelTime[1]);      // iChannelTime\n#endif\n\n    // time heading\n    U = ( uv - vec2(.6,.2) ) * 16.;  caps C(8) low C(15)C(21)C(18)  // \"Hour\"\n    U = ( uv - vec2(.95,.2) ) * 16.;  caps C(13) low C(9)C(14)      // \"Min\"\n    U = ( uv - vec2(1.25,.2) ) * 16.;  caps C(19) low C(5)C(3)      // \"Sec\"\n\n#if SOUND_INFO\n    U = ( uv - vec2(1.1,.8) ) * 8.;        // --- column 3\n    O += pInt(U, iChannelResolution[2].x);  U.y += .8; // sound texture\n    O += pInt(U, iChannelResolution[2].y);  U.y += .8;\n    // O += pInt(U, iChannelResolution[2].z);  U.y += .8;\n\n    O += pInt(U, iSampleRate/1e4);          U.x -= 2.; // iSampleRate\n    O += pInt(U, mod(iSampleRate,1e4)); \n#endif\n//    U = ( uv - vec2(1.4,.45) ) * 8.;       // --- column 4\n    U = ( uv - vec2(KEY_COLUMN_START,.5) ) * 16.;       // --- column 4\n    \n#define STATE_SPACING 1.7\n#define KEY_COLUMN_SPACING  1.9\n    bool b = false;\n    int numKeysReported = 0;\n    // split key checks into two loops that check all keys and don't waist too much\n    // time checking slots that have no corresponding key\n    for (int i=LOWKEY; i<=HIGHKEY; i++) {\n        bool kToggle = keyToggle(i);\n        bool kDown = keyDown(i);\n        bool kClick = keyClick(i);\n        if (kToggle || kDown || kClick) {\n            O += pInt(U, float(i)); U.x -= STATE_SPACING;  // keypressed ascii\n            //float state = int(kToggle)*100. + int(kDown)*10. + int(kClick);\n            //O += pInt(U, float(state));  \n            O += pKeyState(U, kDown, kClick, kToggle );\n            b=true;\n            numKeysReported++;\n            if(numKeysReported==6||numKeysReported==12) { //if(mod(float(numKeysReported),6.)==0.) {\n                // next column\n                U.x -= KEY_COLUMN_SPACING;\n                U.y -= (0.1*8.) * 5.;\n            } else {\n                U.x += STATE_SPACING; // go back to column start\n                U.y += .1 *8.;  // next line\n            }\n        }\n    }\n/*    for (int i=173; i<=220; i++) { // punctuation keys\n        if (keyDown(i)) {\n            O += pInt(U, float(i));  // keypressed ascii \n            b=true;\n            U.y += .1 *8.;\n         }\n    }\n*/\n    if (b==false) O += pInt(U, -1.);\n        \n    O += draw_char().xxxx;\n\n   //O*=9.;\n    \n    // --- non-fonts stuff\n    \n    U = (uv*R.y/R-.9)/.1; \n    if (min(U.x,U.y)>0.) O = hue(U.x),  // --- hue (already in sRGB final space)\n                             O*=O;      // just to fight the final sRGB convertion\n    \n    U = (uv -vec2(.9*R.x/R.y,.8))*10.;              // --- line drawing\n    float pix = 10./R.y;               // pixel size\n    O+= S( line( U,vec2(0,0),vec2(1.1,.85)), 3., pix);\n    O+= S( line0(U,vec2(0.5,0),vec2(1.6,.85)), 3., pix);\n\n    U = (uv -.8*R/R.y)*10.;                        // --- circle, discs, transp and blend\n    O += S( abs(length(U-vec2(.2,1)) -.5), 1., pix); // disc. -.5: relative units. 1: pixel units\n    O += S( length(U-vec2(1.1,1)) -.5, 0., pix) * vec4(1,0,0,1)*.5; // vec4(pureCol)*opacity\n    O += (1.-O.a)*S( length(U-vec2(1.1,.3)) -.5, 0., pix) * vec4(0,1,0,1); // blend below prevs\n    vec4 C = S( length(U-vec2(1.1,-.3)) -.5, 0., pix) * vec4(0,0,1,1)*.5;  // blend above prevs\n    O = C + (1.-C.a)*O;\n    \n    U = uv -vec2(.9*R.x/R.y,.7);        // --- random numbers\n    if ( U.x > 0. && U.y > 0. && U.y < .08 ) \n        U.x > .05*R.x/R.y ? O.rgb += hash(U*iTime) :\n#if BETTERNOISE\n        O.rgb += hash2x3(U*((iTime)));\n#else\n        O.rgb += hash3(vec3(U,U.x)*(iTime));  // no mat2x3 in sksl\n#endif\n    // --- color space corrections\n    O = pow(O, vec4(1./2.2) ); // shader result must be in sRGB colorspace -> gamma correction\n                               // note that it is very close to sqrt(O).\n    // similarly, color operations must be done in flat space, while textures are sRGB-encoded: pow(texture(),vec4(2.2)) or ~square.\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsfGzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2079, 2079, 2105, 2105, 2411], [2412, 2412, 2430, 2430, 2730], [3254, 3254, 3318, 3318, 3511], [3513, 3537, 3567, 3567, 3909], [6581, 6637, 6672, 6672, 6844], [6845, 6922, 6958, 6958, 7169]], "test": "untested"}
{"id": "styfWd", "name": "chromatic abberation effect", "author": "fishy", "description": "chromatic abberation", "tags": ["chromaticabberation"], "likes": 5, "viewed": 400, "published": 3, "date": "1665618049", "time_retrieved": "2024-07-30T16:26:35.214084", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 separate = 0.05*(uv - 0.5)*(iMouse.xy/iResolution.xy-0.5);\n\n    vec3 col = vec3(texture(iChannel0, uv + separate).r, texture(iChannel0, uv).g, texture(iChannel0, uv + -separate).b);\n\n    fragColor = vec4(col.rgb,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/styfWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 377]], "test": "untested"}
{"id": "Dsf3RH", "name": "Sky Gradient improved", "author": "fishy", "description": "Added a glow around the sun and sun disc. Still quite simple, and totally non physically based but it looks super good! Mouse moves the sun", "tags": ["gradient"], "likes": 11, "viewed": 461, "published": 3, "date": "1665618022", "time_retrieved": "2024-07-30T16:26:36.086750", "image_code": "// Sky Gradient by Hazel Quantock\n#define sphere false\n#define ground true\n\nmat2 rotMat(float r){ return  mat2(cos(r), -sin(r), sin(r), cos(r)); }\n\n\nvec3 rotX(vec3 p, float r)\n{\n    return vec3(p.x, p.yz * rotMat(r));\n}\n\nvec3 aces_tonemap(vec3 color) // https://www.shadertoy.com/view/XsGfWV\n{\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nvec3 skyTex(vec3 ray, vec3 sun)\n{\n    //ray.y = abs(ray.y);\n    float raySun = dot(ray,sun);\n    \n    vec3 col = exp2(-(ray.y-raySun*0.5)/vec3(.1,.3,.6)); // Base gradient\n    col *= sqrt(max(0.00001, dot(vec3(sun.x, sun.y+0.3, sun.z), vec3(0.0, 1.0, 0.0)))); //Darken the sky the lower the sun is\n    return mix(col, vec3(10.0, 3.0, 0.2), smoothstep(0.9995, 1.0, max(0.0, raySun))) * sqrt(max(0.0, (dot(ray, vec3(0.0, 1.0, 0.0))))); // Sun disc\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ray;\n    ray.xy = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    ray.z = .7;\n\tray.z -= dot(ray.xy,ray.xy)*.5; // fisheye lens\n    ray = normalize(ray);\n    \n    // tilt upwards\n    vec3 k = normalize(vec3(0,sphere?-.5:.8,1));\n    vec3 i = normalize(cross(vec3(0,1,0),k));\n    vec3 j = cross(k,i);\n    ray = ray.x*i+ray.y*j+ray.z*k;\n    \n    if ( sphere )\n    {\n        // reflect ray off sphere\n        vec3 c = k*1.8;\n        float t = dot(c,ray);\n        float t2 = sqrt(dot(c,c)-t*t);\n        if ( t2 < 1. )\n        {\n            t -= sqrt(1.-t2*t2);\n            vec3 n = ray*t-c;\n            ray = reflect(ray,n);\n        }\n    }\n    \n    vec3 tint = vec3(1);\n    \n    float mouse = -iMouse.y/iResolution.y;\n    \n    if(iMouse.x == (0.0))\n    {\n        mouse = (sin(iTime)/8.-0.2);\n    }\n\n    vec3 lDir = rotX(vec3(0.0, 0.0, 1.0), mouse*5.0 + 0.5);\n\n    fragColor.rgb = aces_tonemap(skyTex( ray, lDir ));\n\n\t// signature\n\t#define L(m,n,u,v,l,f) min(f,max(abs(dot(fragCoord-vec2(m,n),vec2(u,v)))-l,abs(dot(fragCoord-vec2(m,n),vec2(-v,u)))-1.))\n\tfloat sig=L(3,7,0,1,3.5,L(7,7,0,1,3.5,L(5,7,1,0,2.,L(14.5,5,.7071,-.7071,2.5,abs(length(fragCoord-vec2(12.7,7))-3.)-1.))));\n    fragColor.rgb = .6+(clamp(fragColor.rgb,0.,1.)-.6)*sig/(.1+abs(sig));\n    \n    fragColor.rgb = fragColor.rgb;\n    fragColor.a = 1.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dsf3RH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 97, 97, 146], [149, 149, 177, 177, 219], [221, 221, 293, 293, 740], [742, 742, 775, 801, 1189], [1191, 1191, 1248, 1248, 2567]], "test": "untested"}
{"id": "ddl3zn", "name": "Alien planet Landscape", "author": "rcargou", "description": "Pretty straightforward FBM on a terrain heightmap", "tags": ["sdf"], "likes": 11, "viewed": 337, "published": 3, "date": "1665593230", "time_retrieved": "2024-07-30T16:26:36.989337", "image_code": "#define AA 1   // make this 2 or 3 for antialiasing\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\n#define PI 3.1415926535\nfloat hash( vec2 p ) {\n\tfloat h = dot(vec2( p) ,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat mapT(vec3 p ) {\n   \n    return 1.2;\n}\n\nvec2 map( in vec3 pos )\n{\n    pos.xz += fbm(pos / 2.);\n    vec2 res = vec2( 1e10, 0.0 );\n    float tmat;\n    float h = pos.y  + -.2f + (mapT((pos))) * 3.0f * fbm(pos) / .5;\n   // res.x = cylinder(pos);\n    res.y = 3.;\n    return opU(res, vec2(h, 2.0f));\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd)\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    bool l = false;\n    float tmax = 30.0;\n    float t = tmin;\n    if (rd.y > .05)\n        return vec2(100., .0);\n    // raymarch primitives   \n    {\n    \n        \n        for( int i=min(iFrame, 0); i<60 && t<tmax; i++ )\n        {\n            vec3 p = ro + rd * t;\n            vec2 h = map( p );\n            if( abs(h.x)<(0.001*t) )\n            {\n               res = vec2(t,h.y); \n                 break;\n\n            }\n          t += h.x * .2;\n        }\n    }\n    res.x = t;\n    res.y = 2.;\n    return res;\n}\n\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\nvec3 make_fog(vec3 pos, vec3 rd) {\n    float h = fbm(pos) - .2;\n    float s1 = smoothstep(0.6 + h, 0.7 + h, -pos.y);\n    float s2 = smoothstep(0.8 + h, 0.7 + h, pos.y);\n    vec3 col = vec3(.0);\n    float acc = .0;\n      pos /=3.;\n    for (int i = 0; i < 5; ++i) {\n        acc += s2 * s1 / 14.* (( fbm(pos * 2.3f + vec3(iTime * .5 * float(i + 1), 0., 0.)))) / 1.2;\n        pos *= 2.;\n       \n    }\n    return vec3(acc * .8, acc * .7, acc * .7);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{ \n    vec3 col = vec3(.0f);\n    vec3 lig = vec3(vec3(-80. + 0. * sin(iTime /8.), 15., + 0. * cos(iTime  / 8.)) );\n    vec3 ligCol = 1.0*vec3(.2f, .2f, .2f) * 1.4;\n    vec3 back = vec3(.2f, .1f, .1f);\n    vec3 amb = vec3(.2f, .2f, .2f);\n    vec3 nor;\n    float fog = .0f;\n    \n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 pos = ro + rd * t;\n    vec3 ldir = normalize(vec3(- lig));\n    fog = 1.0-exp( -0.0002*t*t*t );\n    col = vec3(.7f, .1f, .1f) / 40.;\n    nor = calcNormal(pos);\n    float ao = calcAO(pos, nor);\n    float shadow = .2 + .8 * calcSoftshadow(pos, -ldir, 0.2, 200.5);\n    float ndotl = max(.05f, dot(ldir, -nor));\n    vec3 sky_term =  back * smoothstep(0.5, 1.0, max(0., nor.y) / 1.0f) * (max(.2, shadow));\n     amb += sky_term;\n  \n    vec2 cid = floor(pos.xz * 1.5);\n    float mat = smoothstep(0.8, 1., max(0., nor.y) );\n        \n    vec3 albedo = vec3(.4, .4, .3) * texture(iChannel0, pos.xz * 1.).xxx * 2.;\n    col =  albedo * ligCol * ndotl * shadow + (ao *.2f) * amb;\n   //col = amb;\n    float ty = length(pos.y);\n    if (res.y != 3.)\n    col = mix(col, make_fog(pos, rd), clamp( ty*ty*ty*0.02, 0., 1.0) );\n    \n       \n    return vec3(col);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = vec2(0);//iMouse.xy/iResolution.xy;\n\tfloat time = .0f; //iTime;\n\n    // camera\t\n    vec3 ro = vec3(.0f, 5.5f, -3.0  + iTime + 10.);\\\n      vec3 ta = vec3( 0.5, -2.4, .5 + iTime);\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n \n        vec3 rd = normalize( vec3(p.xy,2.0) );\n        rd = normalize(rd);\n        rd = rd * ca;\n        // render\t\n        vec3 col = render( ro, rd, p );\n\n\t\t// gamma\n        col = pow( col * 3.3, vec3(1.3545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvec2 hash22( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(175.1,311.7)),\n             dot(p,vec2(260.5,752.3)));\n    return fract(sin(p+455.)*18.5453);\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p/1.3 ); p = m*p*2.02;\n    f += 0.2500*noise( p  ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p );\n    return f;\n }\n\n\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddl3zn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 269, 269, 357], [359, 359, 380, 380, 402], [404, 404, 429, 429, 659], [688, 688, 727, 727, 1293], [1296, 1341, 1419, 1419, 1687], [1689, 1735, 1767, 1767, 1977], [1979, 1979, 2021, 2021, 2337], [2340, 2340, 2374, 2374, 2785], [2787, 2787, 2838, 2838, 4034], [4036, 4036, 4088, 4088, 4265]], "test": "untested"}
{"id": "mssGzn", "name": "Neomorphic button style", "author": "fb", "description": "Neomorphic button style shader", "tags": ["sdf", "shadow", "rect"], "likes": 16, "viewed": 517, "published": 3, "date": "1665592701", "time_retrieved": "2024-07-30T16:26:37.941791", "image_code": "float sdRoundRect( in vec2 p, in vec2 b, in float r ) {\n    vec2 q = abs(p)-b+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n\n\nvec4 normalBlend(vec4 src, vec4 dst) {\n    float finalAlpha = src.a + dst.a * (1.0 - src.a);\n    return vec4(\n        (src.rgb * src.a + dst.rgb * dst.a * (1.0 - src.a)) / finalAlpha,\n        finalAlpha\n    );\n}\n\n\nfloat sigmoid(float t) {\n    return 1.0 / (1.0 + exp(-t));\n}\n\n\nbool isInnerShadow = false; // <- Here\nfloat cornerRadius = 32.0;\nfloat blurRadius = 32.0f;\n\nfloat makeShadow(vec2 pos, vec2 halfSize, float cornerRd, float blurRd, float distMul) {\n    float dist = sigmoid(distMul * sdRoundRect(pos, halfSize, cornerRd + blurRd) / blurRd);\n    return clamp(dist, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 center = iResolution.xy / 2.0;\n    vec2 hsize = iResolution.xy / 4.0;\n    vec2 shadowOffset = vec2(0.0, iResolution.y / 15.0);\n    if (isInnerShadow)\n        shadowOffset = vec2(0.0);\n    \n    // Colors\n    vec3 buttonColor = vec3(0.85);\n    vec3 lowerShadowColor = vec3(0.25);\n    vec3 upperShadowColor = vec3(1.0);\n    \n    // This is a coefficent that round rect distance will be multiplied by\n    float distMul = 1.0;\n    if (isInnerShadow)\n        distMul = -1.0;\n    \n\tfloat lowerShadow = makeShadow(fragCoord - center + shadowOffset, hsize, cornerRadius, blurRadius, distMul);\n    float upperShadow = makeShadow(fragCoord - center - shadowOffset, hsize, cornerRadius, blurRadius, distMul);\n    float rect = clamp(sdRoundRect(fragCoord - center, hsize, cornerRadius), 0.0, 1.0);\n    float rectOpacity = 1.0 - rect;\n    if (isInnerShadow)\n        rectOpacity = rect;\n    \n    vec4 finalColor = normalBlend(vec4(lowerShadowColor, 1.0 - lowerShadow), vec4(buttonColor, 1.0));\n    if (distMul >= 0.0)\n        finalColor = normalBlend(vec4(upperShadowColor, 1.0 - upperShadow), finalColor);\n    finalColor = normalBlend(vec4(buttonColor, rectOpacity), finalColor);\n    fragColor = finalColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mssGzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 141], [144, 144, 182, 182, 355], [358, 358, 382, 382, 418], [514, 514, 602, 602, 730], [732, 732, 789, 839, 2089]], "test": "untested"}
{"id": "Ddl3zn", "name": "catadioptre 2b / rhombic dodecah", "author": "FabriceNeyret2", "description": "  rhombic dodecahedron by inverting the center-face-pyramids of a cube.\nref ( thanks jt ):  [url] https://en.wikipedia.org/wiki/Rhombic_dodecahedron#/media/File:R1-cube.gif [/url]\n", "tags": ["raymarching", "sdf", "short", "golf", "3tweets", "rhombicdodecahedron"], "likes": 19, "viewed": 313, "published": 3, "date": "1665562593", "time_retrieved": "2024-07-30T16:26:38.841385", "image_code": "// variant of https://shadertoy.com/view/ld3fDr\n\n//#define R(x,y) t = max(t, max(abs(q.x+q.y),abs(q.x-q.y)) /1.41 )  // this-r : diamond x z-axis\n//#define R(x,y) t = max(t, (abs(q.x)+abs(q.y)) /1.41 )  // works to, and allows treating the 3 axes at once https://www.shadertoy.com/view/Wd2Gzt\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t = iTime;\n    mat2  R = mat2( sin(t+vec4(0,33,11,0)) ); // 2D rotation matrix\n    vec3  q = iResolution,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),    // ray direction\n          p = 40./q;                          // marching point along ray \n    O*=0.;\n    for ( O++; O.x > 0. && t > .01 ; O-=.004 )\n        q = p,\n        q.xz *= R, q.yz *= R,                 // rotations\n     // t-=t,\n     // R(x,y), R(y,z), R(x,z) -7.,           // octaedron\n        q = abs(q), q += q.yzx, t = max(q.x,max(q.y,q.z))/1.41 - 7., // https://www.shadertoy.com/view/Wd2Gzt\n        p += .2*t*D;                          // step forward = dist to obj\n    O *= O*O*1.6;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ddl3zn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[294, 294, 330, 330, 1000]], "test": "untested"}
{"id": "Dsl3Rn", "name": "Neural Cellular Automaton Worms", "author": "fenix", "description": "I just watched this video and was inspired to create this shader.\n\n     https://www.youtube.com/watch?v=3H79ZcBuw4M\n\nI have no idea how this works, but in my defence neither does the guy who made the video (or so he says).", "tags": ["cellular", "worms", "neural", "atomaton", "atomata"], "likes": 21, "viewed": 377, "published": 3, "date": "1665556959", "time_retrieved": "2024-07-30T16:26:39.726020", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// I just watched this video and was inspired to create this shader.\n//\n//     https://www.youtube.com/watch?v=3H79ZcBuw4M\n//\n// I have no idea how this works, but in my defence neither does the guy who made the video\n// (or so he says). Neural Cellular Atomaton is a pretty fancy name for essentially a \n// continuous (non-binary) CA. You can experiment with this automata (and others) at:\n//\n//     https://neuralpatterns.io/\n//\n// Other than porting to shadertoy, all I did was fancy up the rendering a little bit.\n//\n// Buffer A computes the neural cellular atomaton\n// Buffer B performs temporal blur of buffer A\n// Image computes gradient, applies lighting and color\n//\n// ---------------------------------------------------------------------------------------\n\nvec2 grad(vec2 fragCoord, float d)\n{\n    vec2 delta = vec2(d, 0);\n    return vec2(texture(iChannel0, fragCoord/iResolution.xy + delta.xy).x -\n        texture(iChannel0, fragCoord/iResolution.xy - delta.xy).x,\n        texture(iChannel0, fragCoord/iResolution.xy + delta.yx).x -\n        texture(iChannel0, fragCoord/iResolution.xy - delta.yx).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 g = grad(fragCoord, 1./iResolution.y);\n    vec3 norm = normalize(vec3(g, 1.));\n    float value = texelFetch(iChannel0, ivec2(fragCoord), 0).r;\n    vec3 color = mix(vec3(0.3,0.3,.5), vec3(1, .2, .2), smoothstep(0., 0.1, value));\n    fragColor = vec4(color * dot(norm, normalize(vec3(1,-1,1))), 1);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 kernel[] = vec3[]( vec3( 0.68, -0.9,   0.68),\n                        vec3(-0.9,  -0.66, -0.9),\n                        vec3( 0.68, -0.9,   0.68) );\n                        \nfloat convolve(vec2 fragCoord)\n{\n    float a = 0.;\n    for (int i = 0; i < 3; ++i)\n    {\n        for (int j = 0; j < 3; ++j)\n        {\n            a += texelFetch(iChannel0, ivec2(fragCoord) + ivec2(i - 1, j - 1), 0).x * kernel[i][j];\n        }\n    }\n    return a;\n}\n\n// inverse gaussian\nfloat activation(float x)\n{\n    return -1. / pow(2., (0.6 * pow(x, 2.))) + 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    \n    if (ivec2(fragCoord) == ivec2(0))\n    {\n        if (iFrame == 0 || abs(state.x) != iResolution.x * iResolution.y || keyDown(KEY_SPACE))\n        {\n            state.x = -iResolution.x * iResolution.y;\n        }\n        else\n        {\n            state.x = abs(state.x);\n        }\n        \n        fragColor = state;\n        return;\n    }\n    \n    if (iFrame == 0 || state.x < 0. ||\n        (iMouse.z > 0. && distance(iMouse.xy, fragCoord) < 0.1*iResolution.y))\n    {\n        fragColor = vec4(hash(int(fragCoord.x * fragCoord.y + iDate.x) + iFrame));\n        return;\n    }\n        \n    fragColor = vec4(activation(convolve(fragCoord)));\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//hashing noise by IQ\nfloat hash( int k )\n{\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0) * 0.1 + texelFetch(iChannel1, ivec2(fragCoord), 0) * 0.9;\n    \n    if (iFrame == 0) fragColor = vec4(0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dsl3Rn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[977, 977, 1013, 1013, 1323], [1325, 1325, 1382, 1382, 1690]], "test": "untested"}
{"id": "dsfGRn", "name": "Green Living Labyrinth", "author": "rcargou", "description": "hi", "tags": ["sdf"], "likes": 8, "viewed": 270, "published": 3, "date": "1665533703", "time_retrieved": "2024-07-30T16:26:40.668501", "image_code": "#define AA 1   // make this 2 or 3 for antialiasing\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\n#define PI 3.1415926535\nfloat hash( vec2 p ) {\n\tfloat h = dot(vec2( p) ,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat quarter_circle(vec2 uv) {\n\n    float size = 0.04;\n    float ret = 0.;\n    float l = length(uv - vec2(1., 1.) ) * 0.12;\n    ret = smoothstep(.1, .1 - size, l);\n    ret *= smoothstep(.1 - 2. * size, .1 - size, l);\n  \n    return ret;\n\n\n}\n\nfloat truchet(vec2 uv, float s) {\n    \n    if (s < 0.)\n        uv.x = 1. - uv.x;\n    float ret = quarter_circle(uv);\n    \n    vec2 tmp = uv;\n    \n    uv.x = 1.0 - tmp.y;\n    uv.y = 1.0 - tmp.x;\n    \n    ret += quarter_circle(uv);\n    return ret;\n}\n\nfloat rand_trigger(vec2 uv, vec2 id, float scale) {\n\n    float time = scale * iTime / 2. + hash(id) * 1.;\n    float r = floor(time / PI  / 3.+ .0);// + -.2;\n    float h = hash(vec2(r * vec2( hash(id))) + vec2( hash(id) ));\n    if (h < 0.5)\n        time = r * PI * 3.;//r;// - .2;\n    return min(max(sin(time  ), -0.2 ), 0.2 ) * 5.;\n }\n \n\n \nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nint hashi( vec2 p ) {\n\tfloat h = dot(vec2( p) ,vec2(127.1,311.7));\t\n    float y = 2213123. * fract(sin(h)*43758.5453123);\n    return int(y);\n}\n\nfloat diag(vec2 uv, float si) {\n    float s = .2;\n    return smoothstep(s, 0.0, abs(uv.x * si - uv.y) - s / 2.  );\n}\n\nfloat random_cylinder(vec2 id) {\n    float x = (.0 +noise( vec3(id.x * 100., id.y * 100., 0. * .301) )) ;\n    x = pow(x, 1.9);\n    float u = smoothstep(.9, 1.0, x);\n    return u * 5. - 8.;// + 100.;\n}\n\n\nfloat cylinder(vec3 pos) {\n    float rep = 1.;\n    pos.x -= .3;\n    pos.z -= .25;\n    float size = .1;\n    float scale = 1.5;\n    pos *= scale;\n    float s = -100.;\n    vec2 id = floor(pos.xz  / rep);\n    s = random_cylinder(id);\n    pos.xz = mod(pos.xz, rep) - rep / 2.;\n    return max( length(pos.xz) - size * rep, pos.y - s);\n}\n\nfloat e(in vec2 uv )\n{\n    uv *= 1.5;\n    vec2 id = floor(uv);\n\n    float r = rand_trigger(uv.xy, id, 1.0);\n    uv = fract(uv) - vec2(.5);\n      r = min(1.0, r);\n    r = max(-0.0, r);\n    float angle = 3.14 * r / 2.;\n    uv *= rotate2d(angle);\n    int si = hashi(id) % 2 == 0 ? -1 : 1;\n\n    float s = truchet(uv + vec2(.5), float(si));\n    vec3 col = vec3( s );\n    return col.x;\n}\n\nfloat mapT(vec3 p ) {\n    float h = -e(p.zx)/5. + 1.2;\n\n    return h;\n}\n\nvec2 map( in vec3 pos )\n{\n    pos.xz += fbm(pos / 2.);\n    vec2 res = vec2( 1e10, 0.0 );\n    float tmat;\n    float h = pos.y  + -.2f + (mapT((pos))) * 3.0f;\n   // res.x = cylinder(pos);\n    res.y = 3.;\n    return opU(res, vec2(h, 2.0f));\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd)\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    bool l = false;\n    float tmax = 30.0;\n    float t = tmin;\n    if (rd.y > .05)\n        return vec2(100., .0);\n    // raymarch primitives   \n    {\n    \n        \n        for( int i=min(iFrame, 0); i<100 && t<tmax; i++ )\n        {\n            vec3 p = ro + rd * t;\n            vec2 h = map( p );\n            if( abs(h.x)<(0.001*t) )\n            {\n                if (h.y == 3. && false) {\n                    l = true;\n                    t += h.x * 50.; \n                } else {\n                    res = vec2(t,h.y); \n                     break;\n                 }\n            }\n          t += i < 800 ? h.x * .3: h.x * .5;\n        }\n    }\n    res.x = t;\n    if (l) {\n       res.y = 3.;\n    }\n    return res;\n}\n\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\nvec3 make_fog(vec3 pos, vec3 rd) {\n    float h = fbm(pos) - .2;\n    float s1 = smoothstep(0.6 + h, 0.7 + h, -pos.y);\n    float s2 = smoothstep(0.8 + h, 0.7 + h, pos.y);\n    vec3 col = vec3(.0);\n    float acc = .0;\n      pos /=3.;\n    for (int i = 0; i < 5; ++i) {\n        acc += s2 * s1 / 14.* (( fbm(pos * 2.3f + vec3(iTime * .5 * float(i + 1), 0., 0.)))) / 1.;\n        pos *= 2.;\n       \n    }\n    return vec3(acc, acc, acc * 1.);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{ \n    vec3 col = vec3(.0f);\n    vec3 lig = vec3(vec3(-80. + 0. * sin(iTime /8.), 15., + 0. * cos(iTime  / 8.)) );\n    vec3 ligCol = 1.0*vec3(.2f, .2f, .2f);\n    vec3 back = vec3(.2f, .3f, .1f);\n    vec3 amb = vec3(.2f, .2f, .2f);\n    vec3 nor;\n    float fog = .0f;\n    \n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 pos = ro + rd * t;\n    vec3 ldir = normalize(vec3(- lig));\n    fog = 1.0-exp( -0.0002*t*t*t );\n    col = vec3(.2f, .7f, .1f) / 40.;\n    nor = calcNormal(pos);\n    float ao = calcAO(pos, nor);\n    float shadow = .2 + .8 * calcSoftshadow(pos, -ldir, 0.2, 200.5);\n    float ndotl = max(.05f, dot(ldir, -nor));\n    vec3 sky_term =  back * smoothstep(0.5, 1.0, max(0., nor.y) / 1.0f) * (max(.2, shadow));\n     amb += sky_term;\n  \n    vec2 cid = floor(pos.xz * 1.5);\n    float lc = random_cylinder(cid);\n    float lcs = smoothstep(1., 50., min(50., lc) );\n    float mat = smoothstep(0.8, 1., max(0., nor.y) );\n        \n    vec3 albedo = vec3(.3, .7, .4) * texture(iChannel0, pos.xy * 10.).xxx * 2.;\n    if (res.y == 3.) {\n    \n    }\n    col =  albedo * ligCol * ndotl * shadow + (ao *.2f) * amb;\n   //col = amb;\n    float ty = length(pos.y);\n    if (res.y != 3.)\n    col = mix(col, make_fog(pos, rd), clamp( ty*ty*ty*0.02, 0., 1.0) );\n    \n       \n    return vec3(col);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = vec2(0);//iMouse.xy/iResolution.xy;\n\tfloat time = .0f; //iTime;\n\n    // camera\t\n    vec3 ro = vec3(.0f, 5.5f, -3.0  + iTime + 10.);\\\n      vec3 ta = vec3( 0.5, -6.4, .5 + iTime);\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n \n        vec3 rd = normalize( vec3(p.xy,2.0) );\n        rd = normalize(rd);\n        rd = rd * ca;\n        // render\t\n        vec3 col = render( ro, rd, p );\n\n\t\t// gamma\n        col = pow( col * 3., vec3(1.1545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvec2 hash22( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(175.1,311.7)),\n             dot(p,vec2(260.5,752.3)));\n    return fract(sin(p+455.)*18.5453);\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p/1.3 ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p );\n    return f;\n }\n\n\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsfGRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 269, 269, 357], [359, 359, 390, 390, 599], [601, 601, 634, 634, 848], [850, 850, 901, 901, 1184], [1190, 1190, 1218, 1218, 1304], [1306, 1306, 1327, 1327, 1448], [1450, 1450, 1481, 1481, 1566], [1568, 1568, 1600, 1600, 1768], [1771, 1771, 1797, 1797, 2101], [2103, 2103, 2125, 2125, 2484], [2486, 2486, 2507, 2507, 2557], [2559, 2559, 2584, 2584, 2798], [2827, 2827, 2866, 2866, 3636], [3639, 3684, 3762, 3785, 4126], [4128, 4174, 4206, 4206, 4416], [4418, 4418, 4460, 4460, 4776], [4779, 4779, 4813, 4813, 5213], [5215, 5215, 5266, 5266, 6580], [6582, 6582, 6634, 6634, 6811]], "test": "untested"}
{"id": "csf3zr", "name": "Fractal mosaic 20 (music)", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 10, "viewed": 401, "published": 3, "date": "1665518959", "time_retrieved": "2024-07-30T16:26:41.448415", "image_code": "vec2 f1(vec2 a){\n    return\n        fract(a)\n        //max(abs(.5-fract(a+.5)),abs(.5-fract(a.yx)))\n    ;\n}\n\n\nvec2 triangle_wave(vec2 a){\n    \n    vec2 a2 = vec2(1.,0.5),\n    \n    a1 =\n        a-a2\n        //a-a2+floor(a.x)\n        //a-a2+floor(a.y)\n    ;\n    \n    //a1 += (distance(floor(a1),round(a1)));\n\n    return abs(f1((a1)*(a2.x+a2.y))-.5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 4.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    bool t3 = true;\n    vec2 uv1 = vec2(0.);\n    for(int k = 0; k < 6; k++){\n       //uv.x += float(int(uv.x*pow(2.,fmod(uv.x+iTime,8.)))<<2)/2.;\n       t3 =\n           uv.x < uv.y\n           //uv.x < uv.y  && !t3 || t2.x>t2.y && t3\n           //uv.x < uv.y || !t3\n           //uv.x < uv.y && t2.x > t2.y || !t3\n       ;\n       //uv += floor(uv+vec2(1.5,.5))/1.5;\n       //another awesome pattern\n       //if(t3){ uv = uv.yx;t2 = -t2.yx;}\n        //uv += floor(t2.x+t2.y)/2.;    \n        uv =\n            abs(.5+uv+t2)+uv1;\n            //max(abs(.5+uv+t2),abs(-.5+uv+t2))/scale+uv1; //looks better with more iterations\n            //abs(.5+uv+t2*(1.-fmod(uv.x,2.)/2.))+uv1;\n            //abs(.5*sign(uv.y-uv.x)+uv+t2)\n            //max(abs(uv+t2/2.),abs(uv+1.))\n            //abs(uv+t2)\n            //abs(uv+t2-.5)/(.5+fmod(t2.x,2.))\n            //abs(.5+uv+t2)-vec2(fmod(uv.x*2.,2.),fmod(uv.y/2.,2.))\n            //max(abs(uv+t2),abs(.5+uv+t2))\n            //abs(.5+uv+t2)*fract(uv/4.) //another interesting pattern\n        ;\n        \n        //if(uv.y>uv.x){uv= uv.yx; t2=t2.yx;}\n        t2 =\n            -triangle_wave(uv-.5)\n            //-triangle_wave(uv-.5+floor((uv.x+uv.y)*2.))\n            //-triangle_wave(uv-.5)*sign(.5-uv.x)\n            //-triangle_wave(uv+floor(col.x*4.)-.5)\n            //-triangle_wave(uv-.5-floor(uv.x+t2.y))\n            //triangle_wave(uv+.5*sign(uv.x-uv.y))\n            //-triangle_wave(uv+.5*sign(uv.x-uv.y))\n            //-triangle_wave(uv-.5)/(.5+fmod(t2.x,2.))\n            //-triangle_wave(uv-.5-fmod(t2.x,2.))\n        ;\n        \n\n        //t2 -= float(!t3)/2.;\n        //uv += floor(t2.x+t2.y);\n        \n        uv =\n            t2-triangle_wave(uv.yx)\n            \n            //Lots of interesting patterns here\n            \n            //t2-triangle_wave(uv.yx-floor(uv.x-uv.y))\n            //t2-triangle_wave(uv.yx-floor(uv.y+t2.x))\n            //t2-triangle_wave(uv.yx+floor(uv.x+t2.y)*floor(uv.y+t2.x))\n        ;\n        //uv /= 1. + fmod(uv.x*1.5,1.)*1.5;\n        //if(t2.y<t2.x) t2 = t2/2.; else t2=t2*2.;\n\n        //uv = fract(uv)*fract(uv/2.)*fract(uv/4.);\n        //uv = fract(uv);\n        \n        float c1 =\n            (uv.x-uv.y)\n            //distance(uv,t2)\n            //(uv.x*uv.y)\n            //abs(uv.x-uv.y)\n        ;\n        \n        col = col.yzx;\n        vec3 col1 = col;\n        if(t3 || uv.y < uv.x) col1 = abs(col.yzx-vec3(col.yz,c1));\n        if(!t3 || uv.y > uv.x) col1 = abs(col1-max(col,vec3(col.yz,c1)));\n        col = col1;\n        //uv1 += floor(uv);\n        //col *= col+.5;\n        //if(t3 && uv.y < uv.x) col = vec3(col.yz,c1);\n        \n        //THIS PATTERN IS AMAZING!\n            //if(t2.x<t2.y||t2.x>t2.y) {uv=uv.yx;t2=t2.yx;}\n        \n        //if(uv.x>uv.y) col=col.yzx;\n        //if(uv.x>uv.y && k%3 == 0) {uv = -uv;break;}\n        //if(uv.x < .5) uv.x += .5;\n        //if(uv.y < .5) uv.y += .5;\n\n\n    }\n    fragColor = vec4(min(col*2.,vec3(1.)),1.0);\n}\n", "image_inputs": [], "sound_code": "vec2 mainSound(int samp, float time){\n  float tempo =\n      1.\n      //pow(2.,fmod(time*8.,2.))\n  ;\n  \n  \n  //time += floor(time*pow(2.,fmod(time/4.,4.)))/pow(2.,fmod(time/4.,4.));\n  //time /= 2.;\n  time /= tempo;\n  //time = (time + pow(2.,fmod(time*2.,3.)));\n  //float p1 = pow(2.,1.+fmod(time*8.,3.));\n  //time += floor(time*4.)/4.;\n  //time /= 2.;\n  \n  \n  \n    float s1 =\n      8.\n      //pow(2.,1.+fmod(time,3.))\n    ;\n  \n  //time = time*(1. + fmod(time*s1,2.))/2.;\n  \n  //time += fpow(time*8.,2.)/4.;\n  \n  //float d1 =\n      //floor(time*s1)\n      //((time/s1)+floor(time*s1))\n  //;\n  //time = time + d1/s1;\n  \n  //time = time + d1/s1;\n  \n  float\n      //5./(1.+fmod(time/2.,2.)), //varying tempo\n\n  s2 = 8.,\n  m4 =\n      fmod(time*s1,2.)\n      //fmod((time+fract(time))*s1,2.)\n      //fmax1(time*s1,time,2.)\n      //fmod(time*s1+floor(time*s1*2.)/2.,2.)\n      //fmod(time*s1+floor(time/s1),2.)\n      //fmod(time*s1+fmod(time,2.),2.)\n      //fmod(time*s1/(1.+fmod(time*s1+1.,2.)),2.)\n  ,\n  s3=s2/(1.+m4),\n  t= //varying tempo\n      time/(1.+m4)\n      //time/(1.+fmod(time*s1,2.))\n      //time/(1.+fmod(time/s1+floor(time*s1),2.))\n      //time/(1.+fmod(time*s1+floor(time),2.))\n      //time*(1.+fmod(time*s1,2.))/2.\n  ;\n  //t += floor(t*pow(2.,fmod(t/4.,4.)))/pow(2.,fmod(t/4.,4.));\n  float m1 =\n      fmod(t/s1,s2)\n      //fmax1(t/s1,t,s2)\n      //fmod(t/s1-floor(t/s1/2.)-floor(t/s1/4.),s2)\n      //fmod(t/s1+floor(t*s1),s2)\n      //fmod(floor(t*s1)*floor(t*s1)/s1/s1,s1)\n\n      //fmod(t*s1+floor(t/s1),s2)\n  ,\n  //m4 = fmod(t*s1,s1),\n  m3 =\n      fmod(t*s1/(m1+.5),s2);\n      //fmod(t*(s1+m4)/(m1+.5),s2);\n      //fmod((t+m1)*s1/(m4+.5),s2);\n      //fmod(t*s1/abs(2.5-m1),s2);\n  \n  //m1 = fmod(t/s1,s2),\n  \n  //t += m3/2.;\n  //t += m1;\n  float f1=(1.+fmod(t/s1,2.));\n  t /=  //varying tempo\n      f1\n      //(1.+fmod(t/s1+floor(t*s1),2.))\n  ;\n  //t += floor(t*s1)/s1;\n  t *=\n      s1*s1\n      //s1*s1*(1.+fmod(floor(t/2.)*floor(t),2.))/(1.+fmod(floor(t)*floor(t/s1),2.))\n  ;\n  \n    float m2 =\n      1. + fmod(t/s1,s1)\n      //1. + fmod(t/s1*sign(m1-m3),s1)\n      //1. + fmod(t/s1,8./(1.+fmod(t/s1,2.)))\n      //1. + fmod(t/s1,s1/2.)*fmod(t/s1/2.,s1/2.)\n      //1. + min(fmod(time,s1),t)\n  ;\n  //t /= max(m2,m1+m3+1.);\n  \n  float a= //instruments\n      32.*pow((1.-sqrt(fract(t/s1)/2.)),2.)\n      //4.*pow((1.-log(fract(t/s1))),2.)\n      //pow(((fract(-t/s1)*(1.+m3))),2.)\n      //pow((1.-sqrt(fract(t/s1)/2.))/4.,2.)\n      //sqrt((1.-sqrt(fract(t/s1))))*.2\n\n      //fract(-t/s1)*.2\n      //pow(fract(-t/s1),2.)\n  ,\n  \n  //m31 = mod(floor(t/s1),s1-m3),\n  //m21 = mod(floor(t/s1),s1-m2),\n  \n  nb = time*tempo*pow(2.,(m3+m2)/5.+5.);\n\n  return\n      log(abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a)\n      //vec2(fract(time*nb*.998/m2*s1)*a,fract(time*nb/m2*s1)*a)\n  ;\n\n}", "sound_inputs": [], "common_code": "float fmod2(float a, float b){\n    return mod(floor(a),b)*b;\n}\n\nfloat fmod(float a, float b){\n    //a += floor(a/2./pow(2.,fmod2(a/2.,2.)));\n    \n    //a += fmod2(a,4.);\n    \n    //a += pow(2.,b)/pow(b,2.);\n    //a /= b;\n    \n    //a /= 1.+floor(mod(a,2.));\n    //float a1 = a;\n    \n    //multiply by prime numbers to get interesting rhythms\n    //a += mod(floor(a1)*5.,2.);\n    //a += mod(floor(a1)*3.,2.);\n    return\n        mod(floor(a),b)\n        //abs(8.-mod(floor(a+8.),b*2.))\n        //mod(floor(a*b/8.),b)\n        //floor(sqrt(mod(floor(a/b/b)*floor(a*2./b),b*b/2.)))\n        //min(mod(floor(-a/2.),b),mod(floor(a),b))\n        //max(mod(floor(a+1.)*floor(a),b),mod(floor(a),b))\n        //floor(mod(floor(a*2.),b*b)/b)\n    ;\n}\n\n//#define fmod(a,b) mod(mod(floor((a)/2.),floor(1.+(a)/5.)),b)\n//#define fmod(a,b) mod(floor(a) + floor((a)/2.)*2.+floor((a)/4.)*4.+floor((a)/8.)*8.+floor((a)/16.)*16.,b)\n\n//multiply by prime numbers to get an interesting rhythm\n//#define fmod(a,b) mod(floor((a))*2.+floor((a)/2.)*3.+floor((a)/4.)*5.+floor((a)/8.)*7.,b)\n\n\n#define fmod0(x,y) mod(floor((x)/2.),y)\n#define fmod1(x,y) mod(floor(x-mod(x,y/4.)),y)\n#define fmod2(x,y) floor(pow(mod((x)/2.,y),2.)/y)\n#define fmod3(x,y) floor(sqrt(mod((x)*4.,y*y)))\n#define fmod4(x,y) mod(floor(x)+floor((x)/4.)*4.,y)\n#define fmod5(x,y) max(mod(floor((x)/2.),y),mod(floor(x)+floor((x)/8.),y))\n#define fmod6(x,y) mod(floor(y*((x)/y+floor((x)/y)/y)),y)\n#define fmod7(x,y) max(max(mod(floor(x+2.),y),mod(floor(x+floor((x+5.)/2.)*2.),y)),mod(floor(x+floor((x+3.)/4.)*4.),y))\n\n#define smod(x,y) mod(floor(x)*floor(x),y)\n#define sqmod(x,y) sqrt(fmod(floor(x)*floor(x),y*y))\n#define ftime(x,y) floor(x*y)/y/y\n#define fpow(x,y) pow(y,fmod(x,y))\n#define powmod(x,y) mod(floor(pow(y,mod(floor(x)/y,y))),y)\n#define fmax1(x,y,z) max(fmod(x,z),fmod(y,z))\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csf3zr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 107], [110, 110, 137, 137, 349], [352, 352, 409, 409, 3627]], "test": "untested"}
{"id": "slyBWd", "name": "Canyons", "author": "rcargou", "description": "This time I tried to use the smoothstep function with the bm to create a canyon like terrain", "tags": ["3d", "terrain", "sdf", "fbm", "tree"], "likes": 8, "viewed": 280, "published": 3, "date": "1665507087", "time_retrieved": "2024-07-30T16:26:42.585375", "image_code": "#define AA 1   // make this 2 or 3 for antialiasing\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat mapWater(vec3 p) {\n    return p.y + 2.9 + fbm(p * vec3(2., 0., 2.) + vec3(0., 0., -iTime / 2.) ) * .05;\n}\n\nfloat mapCanyon(vec3 p ) {\n    float h = fbm(p * vec3(1., 0., 1.));\n    h = ( .2*(1. - 2.0*smoothstep(.4, 1.5, 1.-h)) * pow(h*2., 0.5 - .2*smoothstep(.8, 0.45, h) ) +.15);\n    \n    vec3 riverCoord = p;\n    riverCoord.x -= 3.5;\n    riverCoord.x= mod(riverCoord.x, 5.) - 2.5;\n    riverCoord.x += sin(p.z) / 4. + noise(vec3(0., p.y * 1., p.z * 1.) * 1.) * 1.;\n    riverCoord.x += noise(vec3(0., p.y * 15. + 2. * abs(noise(vec3(.0, p.y, 10.*p.z)))  ,0.) * 1.) / 15.;\n    float k = smoothstep(1.5, 1.8, exp(-p.y - .8)) * 10. + 1.;\n   // k = pow((.5*p.y), 5.);\n  // k=1.;\n  //k = 4./ ( exp(riverCoord.y * 1.5) * 10.);\n  //k=1.;\n    k = .1 + smoothstep(-2.5, -.4, min(0.,p.y) );\n    //k = 1.;\n    h += .8 * smoothstep(9., 7., abs(15.*riverCoord.x / k ) );\n    \n    return h;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n    float tmat;\n    float h = pos.y  + -.2f + (mapCanyon((vec3(1.0, 1.0, 1.0) * pos) / 2.0f)) * 3.0f;\n    vec2 water = vec2(0., 3.);\n    water.x = mapWater(pos);\n    res = opU(water, res);\n    return opU(res, vec2(h, 2.0f));\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 30.0;\n    if (rd.y > .05)\n        return vec2(100., .0);\n    // raymarch primitives   \n    {\n    \n        float t = tmin;\n        for( int i=min(iFrame, 0); i<1800 && t<tmax; i++ )\n        {\n            vec3 p = ro + rd * t;\n            vec2 h = map( p );\n            if( abs(h.x)<(0.001*t) )\n            {\n                res = vec2(t,h.y); \n                 break;\n            }\n            if (p.y  < -1.0)\n                h.x /= 4.;\n            t += i < 800 ? h.x * .1: h.x * .4;\n        }\n    }\n    \n    return res;\n}\n\n\nvec2 castRayRef( in vec3 ro, in vec3 rd)\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 30.0;\n    // raymarch primitives   \n    {\n    \n        float t = tmin;\n        for( int i=min(iFrame, 0); i<100 && t<tmax; i++ )\n        {\n            vec3 p = ro + rd * t;\n            vec2 h = map( p );\n            if( abs(h.x)<(0.001*t) )\n            {\n                res = vec2(t,h.y); \n                 break;\n            }\n            if (p.y  < -1.0)\n                h.x /= 4.;\n            t += i < 200 ? h.x * .1: h.x * .1;\n        }\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\nvec3 make_fog(vec3 pos, vec3 rd) {\n    float h = fbm(pos) - .2;\n    float s1 = smoothstep(0.6 + h, 0.7 + h, -pos.y);\n    float s2 = smoothstep(0.8 + h, 0.7 + h, pos.y);\n    vec3 col = vec3(.0);\n    float acc = .0;\n  \n    pos += rd * .2f;\n    float dy = 10.0f - (100.0f * pos.y);\n    acc = s2 * s1 / 14.* (( fbm(pos * 2.3f + vec3(iTime * 2., 0., 0.))));\n    return vec3(acc);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{ \n    vec3 col = vec3(.0f);\n    vec3 lig = vec3(vec3(-150., 35., 20.0) );\n    vec3 ligCol = vec3(.6f, .3f, .2f);\n    vec3 back = vec3(.7f, .3f, .1f + rd.y);\n    vec3 amb = vec3(.9f, .2f, .4f);\n    vec3 nor;\n    float fog = .0f;\n    \n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 pos = ro + rd * t;\n    vec3 ldir = normalize(vec3(- lig));\n    fog = 1.0-exp( -0.0002*t*t*t );\n    col = vec3(.2f, .7f, .1f) / 40.;\n    nor = calcNormal(pos);\n    float ao = calcAO(pos, nor);\n    float shadow = .2 + .8 * calcSoftshadow(pos, -ldir, 0.2, 5.5);\n    float ndotl = max(.05f, dot(ldir, -nor));\n    vec3 sky_term =  back * smoothstep(0.5, 1.0, max(0., nor.y) / 1.0f) * (max(.2, shadow));\n     amb += sky_term;\n    if (res.y == 2.0f) { // moutain\n        float mat = smoothstep(0.8, 1., max(0., nor.y) );\n        \n \t\tvec3 albedo = texture(iChannel0, vec2(pos.xz * 2.)).xyz;\n        col =  albedo * ligCol * shadow * ndotl  + (ao *.2f) * amb;\n    }\n    else if (res.y == 3.) {\n     \tvec3 albedo = vec3(.3f, .4f, .5f) / 1.3;\n        vec3 rdir = reflect(rd, nor);\n        vec2 t= castRayRef(pos, rdir);\n        vec3 rpos = pos + rdir * t.x;\n        \n        vec3 refCol = texture(iChannel0, vec2(rpos.xz * 2.)).xyz;\n        if (t.y == 2.)\n            albedo = albedo / 1.3 + 1.1 * refCol * ligCol;\n        col = albedo;//shadow * albedo * ligCol * ndotl + (ao *.2f) * amb;\n    } else if (rd.y > -.2){\n        col = back;\n    }\n    col = mix(col, back, fog);  \n    col = mix(col, vec3(1.0), make_fog(pos, rd).x);\n    \n    pos = ro;\n    col += vec3(.6, .6, .1) *.2 / (.1 + length( uv.xy - vec2(-1.2, .6) ));\n    return vec3(col);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = vec2(0);//iMouse.xy/iResolution.xy;\n\tfloat time = .0f; //iTime;\n\n    // camera\t\n    vec3 ro = vec3(.0f, .5f, -3.0  + iTime + 10.);\\\n      vec3 ta = vec3( -0.5, -0.4, 0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        vec3 rd = normalize( vec3(p.xy,2.0) );\n        rd.y -= .2;\n        rd = normalize(rd);\n        // render\t\n        vec3 col = render( ro, rd, p );\n\n\t\t// gamma\n        col = pow( col, vec3(.7545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvec2 hash22( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(175.1,311.7)),\n             dot(p,vec2(260.5,752.3)));\n    return fract(sin(p+455.)*18.5453);\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p/1.3 ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p );\n    return f;\n }\n\n\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyBWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[223, 223, 251, 251, 337], [339, 339, 363, 363, 450], [452, 452, 478, 478, 1221], [1223, 1223, 1248, 1248, 1509], [1538, 1538, 1578, 1578, 2173], [2176, 2176, 2218, 2218, 2761], [2763, 2808, 2886, 2909, 3250], [3252, 3298, 3330, 3330, 3540], [3542, 3542, 3584, 3584, 3900], [3903, 3903, 3937, 3937, 4279], [4281, 4281, 4332, 4332, 5979], [5981, 5981, 6033, 6033, 6210]], "test": "untested"}
{"id": "slVfD1", "name": "Atmospheric Landscape", "author": "TekF", "description": "Trying to get a cinematiic feel by focussing on fog and silhouettes more than surface materials. Inspired partly by the landscape shots in Arrival (2016).", "tags": ["volumetric"], "likes": 34, "viewed": 561, "published": 3, "date": "1665495368", "time_retrieved": "2024-07-30T16:26:43.413162", "image_code": "vec3 LinearToSRGB ( vec3 col )\n{\n    return mix( col*12.92, 1.055*pow(col,vec3(1./2.4))-.055, step(.0031308,col) );\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    ivec2 dynamicResolutionDataUV = ivec2(iResolution.xy)-1;\n    int resolutionScaling = int( floor( texelFetch( iChannel0, dynamicResolutionDataUV, 0 ).y ) );\n\n    fragColour = texelFetch(iChannel0,ivec2(fragCoord)/resolutionScaling,0);\n    \n    // contrast stretch\n    fragColour.rgb = smoothstep(vec3(.05,.06,.08)*2.,vec3(1.)-vec3(.05,.06,.08)*1.,fragColour.rgb);\n    \n    fragColour.rgb = LinearToSRGB( fragColour.rgb );\n}\n\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float MAX_MEGAPIXELS = 1.5; // adjust fullscreen resolution for speed (lower = faster)\n\nvec2 quasi2 = vec2(.754877666247,.569840290998);\nvec3 quasi3 = vec3(0.8191725,0.6710436,0.5497005);\n\nfloat Noise( vec3 pos )\n{\n    return texture(iChannel1,pos/32.).r*2.-1.;\n}\n\nfloat GroundSDF( vec3 pos, int octaves )\n{\n    float f = 0.;\n    \n    float s = 1.4;\n    vec3 p = pos * s * .1;\n    \n    for ( int i = 0; i < octaves; i++ )\n    {\n        //f = mix(f,1.,abs(Noise(p))*s);\n        f += abs(Noise(p))*s;\n        p = vec3(p.z*5.,p.xy*3.+p.yx*4.*vec2(1,-1))*2./5.;\n        s /= 2.;\n    }\n    \n    return (pos.y + f) * .8;\n}\n\nfloat FogDensity( vec3 pos, int octaves )\n{\n    float f = 0.;\n    float s = 1.; // Don't change\n    vec3 p = pos * .7;\n    \n    p += iTime*vec3(0,-.02,.02);\n    \n    for ( int i = 0; i < octaves; i++ )\n    {\n        f += Noise(p)*s;\n        p = vec3(p.z*5.,p.xy*3.+p.yx*4.*vec2(1,-1))*2./5.;\n        s /= 1.7; // lower = stronger details\n    }\n    \n    // add a low layer\n    f += smoothstep(.2,.0,abs(pos.y+1.))*.4;\n    \n    // add a cloud layer\n    f += smoothstep(.4,.2,abs(pos.y-.3))*.7;\n\n//    f = smoothstep(-.3,1.5,f); // bigger clouds\n    f = smoothstep(.2,1.5,f); // smaller clouds\n//    f = smoothstep(-.2,3.,f); // softer clouds\n\n    float g = GroundSDF(pos,2);\n    f *= 1.-g/(abs(g)+.04);\n    \n    return f*1.; // Modulate density here instead\n}\n\nfloat AirDensity( vec3 pos )\n{\n    return exp2(-pos.y/5.-3.);\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 _fragCoordIn )\n{\n    ivec2 dynamicResolutionDataUV = ivec2(iResolution.xy)-1;\n    \n    if ( int(_fragCoordIn.x) == dynamicResolutionDataUV.x &&\n         int(_fragCoordIn.y) == dynamicResolutionDataUV.y )\n    {\n        float resolutionScalingF = texelFetch( iChannel0, dynamicResolutionDataUV, 0 ).x;\n        float lastResolutionScalingF = resolutionScalingF;\n        \n        if ( iFrame == 0 ) resolutionScalingF = 1.0;\n        \n/*\n        // adjust dynamic resolution\n        if ( iTimeDelta > 1.1/60. )\n        {\n            // drop resolution fast\n            resolutionScalingF *= 1.1;\n        }\n        else\n        {\n            // increase resolution slowly\n            resolutionScalingF *= .995;\n        }\n        resolutionScalingF = max(resolutionScalingF,1.);\n        //^ that's too stuttery, just base it on resolution\n*/\n\n        resolutionScalingF = ceil(iResolution.x*iResolution.y/(MAX_MEGAPIXELS*1000000.));\n        \n        fragColour = vec4(resolutionScalingF,lastResolutionScalingF,0,1);\n\n        return;\n    }\n    \n    vec4 resolutionData = texelFetch( iChannel0, dynamicResolutionDataUV, 0 );\n    float resolutionScaling = floor( resolutionData.x );\n    float lastResolutionScaling = floor( resolutionData.y );\n    \n    vec2 fragCoord = _fragCoordIn * resolutionScaling;\n\n    // black bars to make it look more cinematic\n    if ( abs(fragCoord.y-iResolution.y*.5) > iResolution.x*.5/2.39\n        || fragCoord.x >= iResolution.x )\n    {\n        fragColour = vec4(0);\n        return;\n    }\n    \n    float time = iTime*.2; // I want a fairly static shot with enough movement to break up the aliasing\n    vec3 velocity = vec3(1.0,0,0);\n    \n    float zoom = 1.;\n    vec3 camPos = vec3(sin(time*.618)*.4,-.3+.1*sin(time),0) + time*velocity;\n    vec3 camLook = vec3(-1,-.5,4) + (time-sin(time))*velocity;\n    \n    float jitterSeed = fract(\n                            dot(quasi2.yx,fragCoord)\n                            + texelFetch(iChannel1,ivec3(fragCoord,0)&31,0).r * .2\n                        );\n    vec2 jitter = fract(quasi2*(float(iFrame) + jitterSeed)); // ideal precession per point to give maximum coverage as fast as possible\n    vec3 ray = vec3((fragCoord+jitter-iResolution.xy*.5)/(iResolution.x*zoom),1.);\n    vec3 camDir = normalize(camLook-camPos);\n    vec3 camRight = normalize(cross(vec3(0,1,0),camDir));\n    vec3 camUp = cross(camDir,camRight);\n    \n    ray = ray.x*camRight + ray.y*camUp + ray.z*camDir;\n\n    // depth of field\n    float focalDepth = 4.;\n    float aperture = .003;\n    camPos += ray*focalDepth; // rely on ray.z = 1 before transform \n    ray += ((jitter.y*2.-1.)*camRight + (jitter.x*2.-1.)*camUp)*aperture;\n    camPos -= ray*focalDepth;\n\n    ray = normalize(ray);\n\n    vec3 sunDir = normalize(vec3(-3,2,1));\n\n\n    /*\n    march against the ground\n    BUT with a maximum step size dictated by volumetric quality\n    accumulate volumetric occlusion with emissive absorbant fog\n    ground intersection picks a neutral dark ground colour - emphasis is on atmospherics\n    */\n    vec3 pos = camPos;\n    vec3 absorption = vec3(1);\n    vec3 emission = vec3(0);\n    float lastStride = 0.;\n    float lastFogDensity = 0.;\n    float lastAirDensity = 0.;\n    for ( int i=0; i < 200; i++ )\n    {\n        float h = GroundSDF( pos, 6 );\n        \n        // accumulate fog occlusion\n        float fogDensity = FogDensity(pos,6);\n        float fogIntegral = lastStride*mix(fogDensity,lastFogDensity,.5);\n\n        float airDensity = AirDensity(pos);\n        float airIntegral = lastStride*mix(airDensity,lastAirDensity,.5);\n        \n        vec3 fogAbsorptionDelta = pow( vec3(0.1), vec3(fogIntegral) );\n        vec3 fogEmissionDelta = (1.-pow( vec3(0.1), vec3(fogIntegral) ));\n        \n        // fog lighting - just sample toward light and subtract\n        float shadowStep = .07;\n        float shadow = (fogDensity - FogDensity(pos+sunDir*shadowStep,3))/shadowStep;\n        fogEmissionDelta *= mix(vec3(.2,.27,.35)*.4,vec3(1)*.6,smoothstep(-1.,1.,shadow));\n\n        vec3 airAbsorptionDelta = pow( 1.-vec3(.3,.48,.7), vec3(airIntegral) );\n        vec3 airEmissionDelta = (1. - pow( 1.-vec3(.4,.55,.7), vec3(airIntegral) )) * vec3(.6);\n\n        vec3 absorptionDelta = fogAbsorptionDelta * airAbsorptionDelta;\n        emission += (absorption*sqrt(absorptionDelta)) * (fogEmissionDelta + airEmissionDelta);\n        absorption *= absorptionDelta;\n        \n        lastFogDensity = fogDensity;\n        lastAirDensity = airDensity;\n        \n        h = min(h,.1); // fog step\n        lastStride = h;\n\n        pos += h*ray;\n        if ( h < .001 ) break;\n    }\n    \n    // do some lighting on the terrain\n    vec2 d = vec2(-1,1)*.02; // big enough to avoid most of the aliasing in the noise texture\n    vec3 normal = normalize(\n                        GroundSDF( pos + d.xxx, 6 )*d.xxx +\n                        GroundSDF( pos + d.xyy, 6 )*d.xyy +\n                        GroundSDF( pos + d.yxy, 6 )*d.yxy +\n                        GroundSDF( pos + d.yyx, 6 )*d.yyx\n                    );\n    \n    float aostep = .3;\n    float ao = smoothstep(-.2,1.5,GroundSDF( pos + normal*aostep, 6 )/aostep);\n    \n    fragColour.rgb = vec3(.5)*ao + vec3(.5)*max(dot(normal,sunDir),0.); //vec3(.03);//fract(pos);\n    fragColour.rgb *= .4*mix( vec3(.0,.2,.0), vec3(.07,.1,0)+.3, smoothstep(.3,.9,ao) ); // albedo\n\n    if ( GroundSDF( pos, 6 ) > .5 ) fragColour.rgb = vec3(.14);\n\n    fragColour.rgb = fragColour.rgb*absorption + emission;\n\n    fragColour.rgb = mix( texelFetch(iChannel0,ivec2(_fragCoordIn*resolutionScaling/lastResolutionScaling),0).rgb, fragColour.rgb, .3 );\n\n    fragColour.a = 1.;\n}\n\n\n\n", "buffer_a_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVfD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 117], [119, 119, 177, 177, 604]], "test": "untested"}
{"id": "7lKfWt", "name": "Rolling Forever 2", "author": "dr2", "description": "Balls rolling endlessly. -  updated", "tags": ["raymarch", "balls", "helix", "track"], "likes": 29, "viewed": 316, "published": 3, "date": "1665486637", "time_retrieved": "2024-07-30T16:26:44.551119", "image_code": "// \"Rolling Forever 2\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  0   // optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat SmoothMax (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 StdVuMat (float el, float az);\nfloat Fbm2 (vec2 p);\n\nconst int nBall = 17;\nconst int nSpir = 3;\nconst int nLit = 3;\nvec3 bPos[nBall], bRot[nBall], ltPos[nLit], ltCol[nLit], qHit;\nfloat htFlap[2], dstFar, tCur, posLin, radSpir, dhSpir, ballRad, rollVel, fnSpir, dLinSeg,\n   dRotSeg, lenPath;\nint idObj, ballNum;\nconst int idTrk = 1, idSup = 2, idRing = 3, idGate = 4, idBase = 6, idBall = 7;\nconst float pi = 3.1415927;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid SetParms ()\n{\n  fnSpir = float (nSpir);\n  posLin = 1.5;\n  radSpir = 3.;\n  dhSpir = 2.5;\n  rollVel = 2.;\n  dLinSeg = 2. * (posLin + radSpir);\n  dRotSeg = length (vec2 (2. * pi * (fnSpir - 0.25) * radSpir, (fnSpir - 0.25) * dhSpir));\n  lenPath = 4. * (dLinSeg + dRotSeg);\n  ballRad = 0.6;\n  ballRad = lenPath / (2. * pi * floor (lenPath / (2. * pi * ballRad)));\n}\n\nvoid BallPos (int k, out vec3 bPos, out vec3 bRot)\n{\n  float ht, htSeg, htd, posSpir, da, dLRSeg, d;\n  ht = 0.5 * fnSpir * dhSpir;\n  htSeg = (2. * ht - 0.25 * dhSpir) / dRotSeg;\n  htd = ht - 0.25 * dhSpir;\n  posSpir = posLin + radSpir;\n  da = (2. * fnSpir - 0.5) * pi / dRotSeg;\n  dLRSeg = 0.25 * lenPath;\n  d = lenPath * fract (tCur * rollVel / lenPath + float (k) / float (nBall));\n  bRot = vec3 (0., 0., 2. * pi * fract (d / (2. * pi * ballRad)));\n  bPos = vec3 (0.);\n  if (d < 2. * dLRSeg) {\n    if (d < dLinSeg) {\n      bRot.y = -1.;\n      bPos = vec3 (- posSpir + d, htd, posLin);\n    } else if (d < dLRSeg) {\n      d -= dLinSeg;\n      bRot.xy = sin (d * da - 0.5 * pi + vec2 (0.5 * pi, 0.));\n      bPos = vec3 (posSpir * vec2 (1.) + radSpir * bRot.xy, htd - d * htSeg).xzy;\n    } else if (d < dLinSeg + dLRSeg) {\n      d -= dLRSeg;\n      bRot.x = -1.;\n      bPos = vec3 (posLin, - ht, posSpir - d);\n    } else {\n      d -= dLinSeg + dLRSeg;\n      bRot.xy = sin (d * da + pi + vec2 (0.5 * pi, 0.));\n      bPos = vec3 (posSpir * vec2 (1., -1.) + radSpir * bRot.xy, - ht + d * htSeg).xzy;\n    }\n  } else {\n    d -= 2. * dLRSeg;\n    if (d < dLinSeg) {\n      bRot.y = 1.;\n      bPos = vec3 (posSpir - d, htd, - posLin);\n    } else if (d < dLRSeg) {\n      d -= dLinSeg;\n      bRot.xy = - sin (d * da - 0.5 * pi + vec2 (0.5 * pi, 0.));\n      bPos = vec3 (posSpir * vec2 (-1.) + radSpir * bRot.xy, htd - d * htSeg).xzy;\n    } else if (d < dLinSeg + dLRSeg) {\n      d -= dLRSeg;\n      bRot.x = 1.;\n      bPos = vec3 (- posLin, - ht, - posSpir + d);\n    } else {\n      d -= dLinSeg + dLRSeg;\n      bRot.xy = - sin (d * da + pi + vec2 (0.5 * pi, 0.));\n      bPos = vec3 (posSpir * vec2 (-1., 1.) + radSpir * bRot.xy, - ht + d * htSeg).xzy;\n    }\n  }\n  bPos.y += 1.75 * ballRad;\n}\n\nvec4 BallHit (vec3 ro, vec3 rd)\n{\n  vec3 u, vn;\n  float dMin, d, b, w;\n  dMin = dstFar;\n  for (int i = VAR_ZERO; i < nBall; i ++) {\n    u = ro - bPos[i];\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + ballRad * ballRad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        qHit = u + d * rd;\n        vn = qHit / ballRad;\n        ballNum = i;\n      }\n    }\n  }\n  return vec4 (dMin, vn);\n} \n\nfloat BallHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec3 u;\n  float dMin, d, b, w;\n  dMin = dstFar;\n  for (int i = VAR_ZERO; i < nBall; i ++) {\n    u = ro - bPos[i];\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + ballRad * ballRad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) dMin = d;\n    }\n  }\n  return 0.6 + 0.4 * smoothstep (0., rng, dMin);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq, sn;\n  float dMin, d, tw, hTrk, rTrk, dpTrk, wWid, wdTrk, posSpir, cl;\n  dMin = dstFar;\n  hTrk = 0.25;\n  rTrk = 0.3;\n  dpTrk = 0.3;\n  wWid = 0.1;\n  wdTrk = 2.3;\n  posSpir = posLin + radSpir;\n  sn = sign (p);\n  q = p;\n  q.xz -= posSpir * sn.xz;\n  qq = q;\n  qq.xz = sn.z * (qq.xz + sn.x * qq.zx * vec2 (-1., 1.)) / sqrt(2.);\n  qq.y -= 0.5 * (atan (qq.z, - sn.z * sn.x * qq.x) / pi - fnSpir +\n     0.25 * sn.z + 0.5) * dhSpir - hTrk;\n  tw = (length (qq.xz) - radSpir) / wdTrk;\n  for (int j = VAR_ZERO; j <= nSpir; j ++) {\n    d = SmoothMax (length (vec2 (tw, qq.y)) - rTrk, - PrBox2Df (vec2 (tw, qq.y - hTrk),\n       vec2 (rTrk - wWid, dpTrk)), 0.02);\n    d = max (d, abs (q.y) - (0.5 * fnSpir + 0.2) * dhSpir);\n    if (j == 0) d = max (d, - PrBoxDf (p + vec3 (0., 0.5 * fnSpir * dhSpir, 0.),\n       vec3 (2. * posSpir, 2.2 * hTrk, posSpir)));\n    else if (j == nSpir) d = max (d, - sn.x * q.x);\n    DMIN (idTrk);\n    qq.y -= dhSpir;\n  }\n  q = p;\n  q.y += 0.1 * dhSpir;\n  for (int k = VAR_ZERO; k <= 1; k ++) {\n    qq = q;\n    if (k == 0) {\n      qq.y -= 0.5 * fnSpir * dhSpir;\n    } else {\n      qq.xz = qq.zx;\n      qq.y += 0.5 * (fnSpir - 0.5) * dhSpir;\n    }\n    qq.z = abs (qq.z) - posLin;\n    tw = qq.z / wdTrk;\n    d = SmoothMax (length (vec2 (tw, qq.y)) - rTrk, - PrBox2Df (vec2 (tw, qq.y - hTrk),\n       vec2 (rTrk - wWid, dpTrk)), 0.02);\n    d = max (d, abs (qq.x) - posSpir);\n    DMIN (idTrk);\n  }\n  q = p;\n  q.xz = abs (q.xz) - posLin - radSpir;\n  d = PrRoundBoxDf (q, vec3 (0.05 * radSpir, 0.5 * fnSpir * dhSpir, 0.05 * radSpir), 0.05);\n  DMIN (idSup);\n  q.y -= (0.1 - 0.5 * (fnSpir - 0.5)) * dhSpir;\n  cl = 0.5 * (radSpir - 0.25 * wdTrk);\n  for (int j = VAR_ZERO; j < nSpir; j ++) {\n    qq = q;\n    qq.z -= cl;\n    d = PrRoundBoxDf (qq, vec3 (0.02 * radSpir, 0.04 * radSpir, cl), 0.02);\n    DMIN (idSup);\n    qq.yz -= vec2 (0.5 * dhSpir, -2. * cl);\n    d = PrRoundBoxDf (qq, vec3 (0.02 * radSpir, 0.04 * radSpir, cl), 0.02);\n    DMIN (idSup);\n    q.y -= dhSpir;\n  }\n  q = p;\n  q.y += 0.5 * (fnSpir * dhSpir - wdTrk);\n  q.x = abs (q.x) - posLin;\n  d = PrTorusDf (q, 0.07 * radSpir, 0.5 * wdTrk);\n  DMIN (idRing);\n  for (int k = VAR_ZERO; k <= 1; k ++) {\n    q = p;\n    q.xy -= vec2 (posLin * sign (float (k) - 0.5), -0.5 * (fnSpir * dhSpir - wdTrk));\n    d = PrCylDf (q, 0.5 * wdTrk, 0.03 * radSpir);\n    q.y += 0.2 * wdTrk - 0.7 * wdTrk * htFlap[k];\n    d = max (d, - q.y);\n    DMINQ (idGate + k);\n  }\n  q = p - vec3 (0., - 0.5 * fnSpir * dhSpir - 0.2, 0.);\n  d = PrRoundBoxDf (q, vec3 (vec2 (posLin + 2. * radSpir), 0.2).xzy - 0.02, 0.02);\n  DMINQ (idBase)\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.1 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec4 BallCol ()\n{\n  vec3 br, col, q;\n  for (int i = VAR_ZERO; i < nBall; i ++) {\n    if (i == idObj - idBall) {\n      br = bRot[i];\n      break;\n    }\n  }\n  q = qHit;\n  q.xz = Rot2Cs (q.xz, sin (atan (br.x, br.y) + vec2 (0.5 * pi, 0.)));\n  if (abs (q.z) < 0.07) col = vec3 (1., 1., 0.3);\n  else col = (q.z * (mod (pi + atan (q.x, q.y) + br.z, 2. * pi) - pi) > 0.) ? vec3 (0., 1., 1.) :\n     vec3 (1., 0., 1.);\n  return vec4 (col, 0.2);\n}\n\nvec3 WoodCol (vec3 p, vec3 vn)\n{\n  vec2 e;\n  float f;\n  e = vec2 (1., 0.1);\n  p *= 4.;\n  f = dot (vec3 (Fbm2 (p.zy * e), Fbm2 (p.zx * e), Fbm2 (p.yx * e)), abs (vn));\n  return mix (vec3 (0.8, 0.4, 0.2), vec3 (0.45, 0.25, 0.1), f);\n}\n\nvoid BallPM ()\n{\n  float dGap, db, s, d[2];\n  dGap = lenPath / float (nBall);\n  db = tCur * rollVel;\n  d[0] = 10.;\n  d[1] = 10.;\n  for (int i = VAR_ZERO; i < nBall; i ++) {\n    s = lenPath * fract (db / lenPath);\n    d[0] = min (d[0], abs (s - (lenPath - dRotSeg - 0.5 * dLinSeg)));\n    d[1] = min (d[1], abs (s - (dRotSeg + 1.5 * dLinSeg)));\n    db += dGap;\n  }\n  htFlap[0] = 1. - smoothstep (2., 4., d[0] / ballRad);\n  htFlap[1] = 1. - smoothstep (2., 4., d[1] / ballRad);\n  for (int i = VAR_ZERO; i < nBall; i ++) BallPos (i, bPos[i], bRot[i]);\n}\n\nvoid SetLights ()\n{\n  for (int k = VAR_ZERO; k < nLit; k ++) {\n    ltPos[k] = vec3 (0., 100., 0.);\n    ltPos[k].xy = Rot2D (ltPos[k].xy, 0.25 * pi * (1. + 0.2 * sin (0.05 * pi * tCur -\n       pi * float (k) / float (nLit))));\n    ltPos[k].xz = Rot2D (ltPos[k].xz, 0.1 * pi * tCur + pi * float (k) / float (nLit));\n  }\n  ltCol[0] = vec3 (1., 0.5, 0.5);\n  ltCol[1] = ltCol[0].gbr;\n  ltCol[2] = ltCol[0].brg;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, db4;\n  vec3 col, vn, qHitB, ltDir, ltAx, c;\n  float dstObj, nDotL, sh, att, ltDst;\n  BallPM ();\n  db4 = BallHit (ro, rd);\n  qHitB = qHit;\n  dstObj = ObjRay (ro, rd);\n  if (min (dstObj, db4.x) < dstFar) {\n    if (db4.x < dstObj) {\n      dstObj = db4.x;\n      idObj = idBall + ballNum;\n      qHit = qHitB;\n    }\n    ro += dstObj * rd;\n    vn = (idObj < idBall) ? ObjNf (ro) : db4.yzw;\n    if (idObj == idTrk) col4 = vec4 (1., 1., 1., 0.1);\n    else if (idObj == idSup) col4 = vec4 (0.8, 0.6, 0.2, 0.1);\n    else if (idObj == idRing) col4 = vec4 (0.9, 0.8, 0., 0.1);\n    else if (idObj == idGate || idObj == idGate + 1) col4 = \n       mix (vec4 (1., 0., 0., -1.), vec4 (0.9, 0.8, 0., 0.1), step (0.5, fract (4. * qHit.y)));\n    else if (idObj == idBase) col4 = vec4 (WoodCol (qHit, vn), 0.);\n    else if (idObj >= idBall) col4 = BallCol ();\n    if (col4.a >= 0.) {\n      col = vec3 (0.);\n      for (int k = VAR_ZERO; k < nLit; k ++) {\n        ltDir = ltPos[k] - ro;\n        ltDst = length (ltDir);\n        ltDir /= ltDst;\n        ltAx = normalize (ltPos[k]);\n        att = smoothstep (0., 0.01, dot (ltDir, ltAx) - 0.985);\n        sh = (dstObj < dstFar) ? min (ObjSShadow (ro + 0.01 * vn, ltDir),\n           BallHitSh (ro + 0.01 * vn, ltDir, 5.)) : 1.;\n        nDotL = max (dot (vn, ltDir), 0.);\n        if (col4.a > 0.) nDotL *= nDotL * nDotL;\n        c = att * ltCol[k] * (col4.rgb * (0.2 + 0.8 * sh * nDotL) + col4.a * step (0.95, sh) *\n           sh * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.));\n        col += pow (c, vec3 (2.));\n      }\n      col = pow (col, 1. / vec3 (2.));\n    } else col = col4.rgb * (0.5 + 0.5 * max (- dot (vn, rd), 0.));\n  } else col = vec3 (0.6, 0.6, 1.) * (0.2 + 0.2 * (rd.y + 1.) * (rd.y + 1.));\n  col = clamp (col, 0., 1.);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, t, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    t = mod (0.01 * tCur, 2.);\n    az = 2.5 * pi * (abs ((floor (16. * t) + smoothstep (0.8, 1.,\n       fract (16. * t))) / 16. - 1.) - 0.5);\n  }\n  el = clamp (el, -0.4 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  SetParms ();\n  ro = vuMat * vec3 (0., -0.5, - (20. + 10. * fnSpir));\n  zmFac = 5.;\n  dstFar = 100.;\n  SetLights ();\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKfWt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1081, 1081, 1099, 1099, 1447], [1449, 1449, 1501, 1501, 3224], [3226, 3226, 3259, 3259, 3665], [3668, 3668, 3715, 3715, 4045], [6670, 6670, 6703, 6703, 6886], [6888, 6888, 6909, 6909, 7164], [7166, 7166, 7203, 7203, 7431], [7433, 7433, 7450, 7450, 7870], [7872, 7872, 7904, 7904, 8104], [8106, 8106, 8122, 8122, 8655], [8657, 8657, 8676, 8676, 9064], [9066, 9066, 9101, 9101, 10893], [10895, 10895, 10951, 10951, 12115], [12117, 12117, 12149, 12149, 12249], [12251, 12251, 12297, 12297, 12344], [12346, 12346, 12379, 12379, 12468], [12470, 12470, 12512, 12512, 12563], [12565, 12565, 12611, 12611, 12668], [12670, 12670, 12715, 12715, 12807], [12809, 12809, 12854, 12854, 12892], [12894, 12894, 12924, 12924, 13037], [13039, 13039, 13070, 13070, 13134], [13136, 13136, 13172, 13172, 13378], [13412, 13412, 13436, 13436, 13548], [13550, 13550, 13575, 13575, 13761], [13763, 13763, 13784, 13784, 13939]], "test": "untested"}
{"id": "7tVBWt", "name": "Juliabrot 4D: Internal structure", "author": "mmnz", "description": "This is a 4D mandelbrot set of sorts, but not the quaternion version.\nThis maps the four dimensions of the iterated function z = z + c .\nSee https://www.shadertoy.com/view/stVBWt for an alternative rendering.", "tags": ["fractal", "julia", "mandelbrot", "sdf", "4d"], "likes": 0, "viewed": 236, "published": 3, "date": "1665484639", "time_retrieved": "2024-07-30T16:26:45.408826", "image_code": "// This is a 4D mandelbrot set of sorts, but not the quaternion version.\n// Each point on the mandelbrot set corresponds to some julia set.\n// Both sets map the places where z = z + c converges,\n// but the mandelbrot set varies the real and imaginary components of c,\n// and the julia sets vary the real and imaginary components of z.\n// Over all, there are four varying dimensions,\n// and the mandelbrot set and the julia sets are 2D slices of this 4D shape.\n// To view the whole 4D shape, I map one dimension to time and take 3D slices of the rest.\n// Even though julia sets with c outside the mandelbrot set are disconnected,\n// I would be pretty confident that the entirety of this 4D shape is connected.\n\n// A lot of this code was thrown together over the last couple of years\n// and I had to massage it quite a bit to get it to run in Shadertoy.\n// I don't quite understand the subtle differences between this version and\n// https://www.shadertoy.com/view/stVBWt\n// which allow this version to render the 'internal' distance estimate\n// that looks so much more obviously like the mandelbrot and julia sets.\n// In fact, there is plenty of code here that I only understand when I squint.\n\n// Slice can be 0, 1, 2, 3. Controls which plane varies over time.\n#define SLICE 0\n\n// Slice 0 and 1 plot Re(c) and Im(c) over x and y, so the z=0 plane at t=0 is the mandelbrot set.\n// Slice 2 and 3 plot Re(z) and Im(z) over x and y, so they are always stacks of julia sets.\n// Slice 2 plots Re(c) over z, so at t=0 it is a stack of all purely real julia sets.\n// Slice 3 plots Im(c) over z, so at t=0 it is a stack of all purely imaginary julia sets.\n\n// Pause the script when the fractal is most voluminous to see t=0.\n// Dragging with the mouse seems to work even when paused.\n\n\n// SDF of the fractal\nfloat juliabrot(in vec3 p) {\n\n    vec4 pp = vec4(4.0 * p - 2.0, 2.25 * cos(iTime / 2.0) * abs(cos(iTime / 2.0)));\n\n    vec2 c = pp.xy;\n    vec2 z = pp.zw;\n    \n    // The piecewise derivative\n    // d.xy represents dz/dc, used in the mandelbrot SDF\n    // d.zw represents dz/dz, used in the julia SDF\n    vec4 d = vec4(0, 0, 1, 0);\n    \n    // Swap all the dimensions based on slice\n    #if SLICE == 1\n        z = pp.wz;\n    #elif SLICE == 2\n        c = pp.zw;\n        z = pp.xy;\n    #elif SLICE == 3\n        c = pp.wz;\n        z = pp.xy;\n    #endif\n    \n    int i = 0;\n    int maxi = 128;\n    for (i = 0; length(z) < 16.0 && i < maxi; i++) {\n        // New derivative based on previous (dz/dc = 2zdz/dc + 1, dz/dz = 2zdz/dz)\n        d = 2.0 * vec4(\n            (z.x * d.x - z.y * d.y) + 1.0,\n            (z.x * d.y + z.y * d.x),\n            (z.x * d.z - z.y * d.w),\n            (z.x * d.w + z.y * d.z)\n        );\n        // New z based on previous (z = z + c)\n        z = vec2(z.x * z.x - z.y * z.y + c.x, (z.x + z.x) * z.y + c.y);\n    }\n    // Distance from p to fractal\n    float distance = 0.5 * length(z) * log(length(z)) / length(d);\n    \n    // SDF seems to be broken for some internal distances (?), so internal distances are set to 0\n    return (i == maxi) ? 0.0 : distance;\n}\n\n// Seems so similar to the other calcNormal, but quality is different somehow\nvec3 calcNormal(in vec3 coord) {\n    vec3 e = vec3(1, -1, 0) * 0.01;\n    return normalize(vec3(\n        juliabrot(coord + e.xzz) - juliabrot(coord + e.yzz),\n        juliabrot(coord + e.zxz) - juliabrot(coord + e.zyz),\n        juliabrot(coord + e.zzx) - juliabrot(coord + e.zzy)\n    ));\n}\n\n// Gets the front and back of a box that the ray goes through\nvec2 hitBox(vec3 rayOrigin, vec3 rayDirection) {\n    // Box was from -0.5 to +0.5, but the positions all needed + 0.5\n    vec3 tmin_tmp = (vec3(-0.5) - rayOrigin) / rayDirection;\n    vec3 tmax_tmp = (vec3(0.5) - rayOrigin) / rayDirection;\n    vec3 tmin = min(tmin_tmp, tmax_tmp);\n    vec3 tmax = max(tmin_tmp, tmax_tmp);\n    float t0 = max(tmin.x, max(tmin.y, tmin.z));\n    float t1 = min(tmax.x, min(tmax.y, tmax.z));\n    return vec2(t0, t1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    p.y -= 1.0; // Shape wasn't centred?\n    \n    float pi = acos(-1.0);\n    // Customisable\n    float thetaOffset = 0.0; // 0.1 * iTime; // Extra rotation\n    float ymin = 0.1; // 0.0 = 0deg, facing the horizon\n    float ymax = 0.9; // 1.0 = 90deg, facing the ground\n    float orbitRadius = 2.0; // Distance from center\n    // Always the same\n    vec2 storedMouse = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    float theta = -2.0 * pi * storedMouse.x + thetaOffset;\n    float phi = 0.5 * pi * (1.0 - storedMouse.y) * (ymax - ymin) + ymin;\n    vec3 rayOrigin = orbitRadius * vec3(sin(theta)*cos(phi), sin(phi), cos(theta)*cos(phi));\n    // Standard camera stuff\n    vec3 target = vec3(0, 1, 0);\n    float focalLength = 2.0;\n    vec3 ww = normalize(target - rayOrigin);\n    vec3 uu = normalize(cross(ww, vec3(0, 1, 0)));\n    vec3 vv = normalize(cross(uu, ww));\n    vec3 rayDirection = normalize(p.x * uu + p.y * vv + focalLength * ww);\n\n    // Only does the calculation inside this box\n    vec2 bounds = hitBox(rayOrigin, rayDirection);\n    // Finds the minimum amount to increment by,\n    // which is evidently a waste of time since it then divides this by 512.\n    vec3 inc = 1.0 / abs(rayDirection);\n    float delta = min(inc.x, min(inc.y, inc.z)) / 512.0;\n    \n    vec3 position = vec3(0);\n    vec4 color = vec4(0);\n    \n    // t is only interpolated inside the box, by a constant delta\n    for (float t = bounds.x; t < bounds.y; t += delta) {\n        float d = juliabrot(position);\n        position = rayOrigin + t * rayDirection + 0.5;\n        // 'internal' estimate, blue\n        if (d <= 0.0) {\n            float lighting = dot(calcNormal(position), normalize(rayOrigin));\n            // Blue to black based on light direction\n            vec4 innercolor = vec4(vec3(0.2, 0.2, 1) * lighting, 1);\n            // Mix with existing amount of yellow\n            color = mix(color, innercolor, 0.7);\n            break;\n        }\n        // 'external' estimate, yellow. Distance is arbitrary small amount.\n        if (d < 0.005 && color.a == 0.0) {\n            float lighting = dot(calcNormal(position), normalize(rayOrigin));\n            // Two different yellow colours based on light direction\n            color = mix(vec4(0.5, 0.3, 0, 1), vec4(1, 1, 0.2, 1), lighting);\n        }\n    }\n    // Background colour\n    if (color.a == 0.0) {\n        // discard; // transparency\n        color = vec4(0.8, 0.9, 1.0, 1.0);\n    };\n\n    fragColor = color;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Save mouse position.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Initialise buffer to white (buffer is unused if alpha is empty).\n    if (texelFetch(iChannel0, ivec2(0,0), 0).a < 1.0) {\n        fragColor = vec4(1);\n        return;\n    }\n    // Fetch old values\n    vec2 current = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec2 previous = texelFetch(iChannel0, ivec2(1, 0), 0).xy;\n    vec4 mouse = iMouse / iResolution.xyxy;\n    // Fix for Shadertoy ignoring mouseup outside canvas. Reset previous on click.\n    // Fix removed because it breaks things on iOS (where iMouse.w is positive until mouseup).\n    // if (mouse.w > 0.0) {\n    //     previous = current;\n    // }\n    // When mouse down, add the mouse position to the previous position minus starting offset.\n    // Otherwise, save the current position to be used for the next time the mouse is dragged.\n    if (mouse.z > 0.0) {\n        vec2 next = previous + mouse.xy - abs(mouse.zw);\n        current = vec2(fract(next.x), clamp(next.y, 0.0, 1.0)); // wrap x, clamp y\n    } else {\n        previous = current;\n    }\n    // Save current to (0,0) and previous to (1,0)\n    fragColor = vec4(fragCoord.x < 1.0 ? current : previous, 0.0, 1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVBWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1799, 1821, 1849, 1849, 3168], [3170, 3248, 3280, 3280, 3535], [3537, 3599, 3647, 3716, 4044], [4046, 4046, 4101, 4101, 6620]], "test": "untested"}
{"id": "stVBWt", "name": "Juliabrot 4D: Raymarched", "author": "mmnz", "description": "This is a 4D mandelbrot set of sorts, but not the quaternion version.\nThis maps the four dimensions of the iterated function z = z + c .\nSee https://www.shadertoy.com/view/7tVBWt for an alternative rendering.", "tags": ["fractal", "julia", "mandelbrot", "sdf", "4d"], "likes": 5, "viewed": 234, "published": 3, "date": "1665484630", "time_retrieved": "2024-07-30T16:26:46.251574", "image_code": "// This is a 4D mandelbrot set of sorts, but not the quaternion version.\n// Each point on the mandelbrot set corresponds to some julia set.\n// Both sets map the places where z = z + c converges,\n// but the mandelbrot set varies the real and imaginary components of c,\n// and the julia sets vary the real and imaginary components of z.\n// Over all, there are four varying dimensions,\n// and the mandelbrot set and the julia sets are 2D slices of this 4D shape.\n// To view the whole 4D shape, I map one dimension to time and take 3D slices of the rest.\n// Even though julia sets with c outside the mandelbrot set are disconnected,\n// I would be pretty confident that the entirety of this 4D shape is connected.\n\n// I'm still a Shadertoy beginner, so this hasn't got the quality I want.\n// This is pretty much the same as 'Orbit Controls', but with the fractal.\n// https://www.shadertoy.com/view/flVfWt\n// TODOs:\n// - Fix the weird FOV problem at the extremes\n// - No amount of tuning the escape distance, iteration counts, or maxt and mint,\n//   seems to create the 'internal' distance estimate that I somehow got for\n//   https://www.shadertoy.com/view/7tVBWt\n\n// Slice can be 0, 1, 2, 3. Controls which plane varies over time.\n#define SLICE 0\n\n// Slice 0 and 1 plot Re(c) and Im(c) over x and y, so the z=0 plane at t=0 is the mandelbrot set.\n// Slice 2 and 3 plot Re(z) and Im(z) over x and y, so they are always stacks of julia sets.\n// Slice 2 plots Re(c) over z, so at t=0 it is a stack of all purely real julia sets.\n// Slice 3 plots Im(c) over z, so at t=0 it is a stack of all purely imaginary julia sets.\n\n// Pause the script when the fractal is most voluminous to see t=0.\n// Dragging with the mouse seems to work even when paused.\n\n\n// SDF of the fractal\nfloat juliabrot(in vec4 p) {\n\n    vec2 c = p.xy;\n    vec2 z = p.zw;\n    \n    // The piecewise derivative\n    // d.xy represents dz/dc, used in the mandelbrot SDF\n    // d.zw represents dz/dz, used in the julia SDF\n    vec4 d = vec4(0, 0, 1, 0);\n    \n    // Swap all the dimensions based on slice\n    #if SLICE == 1\n        z = p.wz;\n    #elif SLICE == 2\n        c = p.zw;\n        z = p.xy;\n        z.x += 1.0;\n    #elif SLICE == 3\n        c = p.wz;\n        z = p.xy;\n        z.x += 1.0;\n    #endif\n    \n    for (int i = 0; length(z) < 16.0 && i < 128; i++) {\n        // New derivative based on previous (dz/dc = 2zdz/dc + 1, dz/dz = 2zdz/dz)\n        d = 2.0 * vec4(\n            (z.x * d.x - z.y * d.y) + 1.0,\n            (z.x * d.y + z.y * d.x),\n            (z.x * d.z - z.y * d.w),\n            (z.x * d.w + z.y * d.z)\n        );\n        // New z based on previous (z = z + c)\n        z = vec2(z.x * z.x - z.y * z.y + c.x, (z.x + z.x) * z.y + c.y);\n    }\n    // Distance from p to fractal\n    return 0.5 * length(z) * log(length(z)) / length(d);\n}\n\n// Returns distance, material\nvec2 map(in vec3 position) {\n    vec4 adjustedPosition = vec4(\n        // Position with shifted centre\n        position - vec3(1.0, 1.25, 0.0),\n        // Fourth dimension varies over time (slowing down at -2.25, 0, 2.25)\n        2.25 * cos(iTime / 2.0) * abs(cos(iTime / 2.0))\n    );\n    float fractal = juliabrot(adjustedPosition);\n    float terrain = position.y;\n    return (fractal < terrain) ? vec2(fractal, 1.0) : vec2(terrain, 2.0);\n}\n\n// Returns t, material shadow\nvec3 castRay(in vec3 rayOrigin, in vec3 rayDirection) {\n    float t = 0.0;\n    float material = -1.0;\n    float shadow = 1.0;\n    float mint = 0.001;\n    float maxt = 20.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 position = rayOrigin + t * rayDirection;\n        vec2 h = map(position);\n        material = h.y;\n        shadow = min(shadow, 8.0 * h.x / t);\n        if (h.x < mint) { break; }\n        t += h.x;\n        if (t > maxt) { break; }\n    }\n    if (t > maxt) { t = material = -1.0; }\n    shadow = clamp(shadow, 0.0, 1.0);\n    return vec3(t, material, shadow);\n}\n\n// Returns normal\nvec3 calcNormal(in vec3 position) {\n    vec2 e = vec2(1, -1) * inversesqrt(12000000.0);\n    return normalize(\n        e.xyy * map(position + e.xyy).x + \n\t\te.yyx * map(position + e.yyx).x + \n\t\te.yxy * map(position + e.yxy).x + \n\t\te.xxx * map(position + e.xxx).x\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float pi = acos(-1.0);\n    // Customisable\n    float thetaOffset = 0.0; // 0.1 * iTime; // Extra rotation\n    float ymin = 0.1; // 0.0 = 0deg, facing the horizon\n    float ymax = 0.9; // 1.0 = 90deg, facing the ground\n    float orbitRadius = 4.0; // Distance from center\n    // Always the same\n    vec2 storedMouse = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    float theta = -2.0 * pi * storedMouse.x + thetaOffset;\n    float phi = 0.5 * pi * (1.0 - storedMouse.y) * (ymax - ymin) + ymin;\n    vec3 rayOrigin = orbitRadius * vec3(sin(theta)*cos(phi), sin(phi), cos(theta)*cos(phi));\n    // Standard camera stuff\n    vec3 target = vec3(0, 1, 0);\n    float focalLength = 1.5;\n    vec3 ww = normalize(target - rayOrigin);\n    vec3 uu = normalize(cross(ww, vec3(0, 1, 0)));\n    vec3 vv = normalize(cross(uu, ww));\n    vec3 rayDirection = normalize(p.x * uu + p.y * vv + focalLength * ww);\n\n    // Sky colour, fading to grey at the horizon\n    vec3 color = vec3(0.4, 0.7, 1.0) - 0.7 * rayDirection.y;\n    color = mix(color, vec3(0.7, 0.75, 0.8), clamp(exp(-10.0 * rayDirection.y), 0.0, 1.0));\n    \n    vec3 ray = castRay(rayOrigin, rayDirection);\n    \n    if (ray.y > 0.0) {\n        vec3 position = rayOrigin + ray.x * rayDirection;\n        vec3 normal = calcNormal(position);\n        \n        // Material colour\n        vec3 material = vec3(0);\n        if (ray.y < 1.5) {\n            material = vec3(0.01, 0.02, 0.18); // Fractal: blue\n        } else {\n            material = vec3(0.05, 0.1, 0.02); // Terrain: green checkerboard\n            material += 0.05 * smoothstep(-0.1, 0.1, sin(18.0 * position.x) + cos(18.0 * position.z));\n        }\n        \n        // Lighting colours\n        vec3 sun_direction = normalize(vec3(1.0, 1.0, 1.0));\n        float sun_diffuse = clamp(dot(normal, sun_direction), 0.0, 1.0);\n        float sun_shadow = castRay(position + normal * 0.001, sun_direction).z;\n        float sky_diffuse = clamp(0.5 + 0.5 * dot(normal, vec3(0, 1, 0)), 0.0, 1.0);\n        float ground_diffuse = clamp(0.5 + 0.5 * dot(normal, vec3(0, -1, 0)), 0.0, 1.0);\n        color  = material * vec3(7.0, 4.5, 3.0) * sun_diffuse * sun_shadow;\n        color += material * vec3(0.5, 0.8, 0.9) * sky_diffuse;\n        color += material * vec3(0.7, 0.3, 0.2) * ground_diffuse;\n        \n        // Check the normals of the fractal\n        // if (ray.y < 1.5) { color = normal; }\n    }\n    \n    fragColor = vec4(pow(color, vec3(0.4545)), 1.0);\n    \n    // Test first 2px of Buffer A:\n    // fragColor = texture(iChannel0, (2.0 * fragCoord - iResolution.xy) / iResolution.y);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Save mouse position.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Initialise buffer to white (buffer is unused if alpha is empty).\n    if (texelFetch(iChannel0, ivec2(0,0), 0).a < 1.0) {\n        fragColor = vec4(1);\n        return;\n    }\n    // Fetch old values\n    vec2 current = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec2 previous = texelFetch(iChannel0, ivec2(1, 0), 0).xy;\n    vec4 mouse = iMouse / iResolution.xyxy;\n    // Fix for Shadertoy ignoring mouseup outside canvas. Reset previous on click.\n    // Fix removed because it breaks things on iOS (where iMouse.w is positive until mouseup).\n    // if (mouse.w > 0.0) {\n    //     previous = current;\n    // }\n    // When mouse down, add the mouse position to the previous position minus starting offset.\n    // Otherwise, save the current position to be used for the next time the mouse is dragged.\n    if (mouse.z > 0.0) {\n        vec2 next = previous + mouse.xy - abs(mouse.zw);\n        current = vec2(fract(next.x), clamp(next.y, 0.0, 1.0)); // wrap x, clamp y\n    } else {\n        previous = current;\n    }\n    // Save current to (0,0) and previous to (1,0)\n    fragColor = vec4(fragCoord.x < 1.0 ? current : previous, 0.0, 1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVBWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1766, 1788, 1816, 1816, 2897], [2899, 2929, 2957, 2957, 3370], [3372, 3402, 3457, 3457, 3978], [3980, 3998, 4033, 4033, 4267], [4269, 4269, 4324, 4324, 6967]], "test": "untested"}
{"id": "NlKBDK", "name": "Dreams of Cloud Iridescence", "author": "Yetman", "description": "Raymarching the RGBA 3D noise texture.", "tags": ["raymarching", "noise"], "likes": 9, "viewed": 328, "published": 3, "date": "1665484213", "time_retrieved": "2024-07-30T16:26:50.739573", "image_code": "#define STEPS 128\n#define DISTANCE 0.8\n\n#define START vec3(0.006, 0.01, 0.2)\n#define VELOCITY vec3(0.0, 0.0, 0.02)\n\n#define LAYER_1_SCALE 2.0\n#define LAYER_1_VELOCITY vec3(0.005)\n#define LAYER_1_POWER 0.3\n#define LAYER_2_SCALE 4.0\n#define LAYER_2_VELOCITY vec3(0.05)\n#define LAYER_2_POWER 0.1\n\n#define LUM_FACTORS vec3(0.3, 0.59, 0.11)\n#define THRESHOLD 0.55\n#define SMOOTHNESS 0.05\n\n#define ALPHA_FAC vec2(0.04, 0.5)\n#define VOID_COLOR vec3(0.1)\n\n#define SPLITTONE_SHADOWS vec3(0.3, 0.0, 0.4)\n#define SPLITTONE_HIGHLIGHTS vec3(1.0, 0.7, 0.1)\n\n// Pegtop's Soft Light Formula\nvec3 SoftLight(vec3 a, vec3 b)\n{\n    return ((1.0 - 2.0 * b) * a + 2.0 * b) * a;\n}\n\n// Adapted from https://catlikecoding.com/unity/tutorials/custom-srp/color-grading/\nvec3 splitToning (vec3 color) {\n    float lum = dot(LUM_FACTORS, color);\n\tvec3 shadows = mix(vec3(0.5), SPLITTONE_SHADOWS, 1.0 - lum);\n\tvec3 highlights = mix(vec3(0.5), SPLITTONE_HIGHLIGHTS, lum);\n\tcolor = SoftLight(color, shadows);\n\tcolor = SoftLight(color, highlights);\n\treturn color;\n}\n\n// Source: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec4 soft_sample(sampler3D tex, vec3 p) {\n\n    vec3 size = vec3(textureSize(tex, 0));\n    vec3 texel = fract(p) * size - 0.5;\n    \n    vec3 whole = floor(texel), fraction = fract(texel);\n    \n    // Make fractions smooth\n    //fraction = mix(fraction * fraction, sqrt(fraction), fraction);\n    fraction = smoothstep(0.0, 1.0, fraction);\n    \n    return texture(tex, (whole + fraction + 0.5) / size);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float noise = texture(iChannel1, fragCoord / iChannelResolution[1].xy).r;\n    \n    vec3 ray = normalize(vec3((fragCoord - iResolution.xy * 0.5) / iResolution.y * 2.0, 1.0));\n    vec3 march_step = ray * DISTANCE / float(STEPS);\n    vec3 pos = START + VELOCITY * iTime + march_step * (float(STEPS - 1) + noise);\n    \n    vec3 accum = vec3(0.0);\n    for(int i = STEPS - 1; i >= 0; --i){\n        pos -= march_step;\n        \n        vec3 color = texture(iChannel0, pos.xyz).rgb;\n        color = mix(color, soft_sample(iChannel0, pos.xyz * LAYER_1_SCALE + iTime * LAYER_1_VELOCITY).rgb, LAYER_1_POWER);\n        color = mix(color, soft_sample(iChannel0, pos.xyz * LAYER_2_SCALE + iTime * LAYER_2_VELOCITY).rgb, LAYER_2_POWER);\n        \n        float threshold = smoothstep(THRESHOLD, THRESHOLD + SMOOTHNESS, dot(LUM_FACTORS, color));\n        \n        float alpha = mix(ALPHA_FAC.x, ALPHA_FAC.y, threshold);\n        \n        color = max(vec3(0.0), color * (1.0 + THRESHOLD) - THRESHOLD);\n        color = mix(ALPHA_FAC.x * VOID_COLOR, ALPHA_FAC.y * color, threshold);\n        \n        accum = color + accum * (1.0 - alpha);\n    }\n\n    fragColor = vec4(splitToning(ACESFilm(accum)), 1.0);\n}", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKBDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[544, 575, 607, 607, 657], [659, 743, 774, 774, 1031], [1033, 1120, 1143, 1143, 1288], [1290, 1290, 1331, 1331, 1691]], "test": "untested"}
{"id": "ftVBDd", "name": "Video Wipe (1)", "author": "MrRobW", "description": "Video Wipe, shattered pixels", "tags": ["wipe"], "likes": 3, "viewed": 228, "published": 3, "date": "1665478807", "time_retrieved": "2024-07-30T16:26:51.724939", "image_code": "\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat n1rand( vec2 n )\n{\n\tfloat nrnd0 = nrand( n );\n\treturn nrnd0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    float alpha = (mod(iTime,4.0))/3.0;\n    \n    alpha = clamp(alpha,0.0,1.0);\n\n    float omalpha = 1.0 - alpha;\n    \n    float beta = (3.14 * n1rand(uv));\n    \n    vec2 uv1, uv2;\n    \n    float scale = 0.1;\n    \n    uv1.x = uv.x + scale * omalpha * (sin(beta));\n    uv1.y = uv.y + scale * omalpha * (cos(beta));\n\n    uv2.x = uv.x + scale * alpha * (sin(beta));\n    uv2.y = uv.y + scale * alpha * (cos(beta));\n\n    \n    fragColor = (1.0-alpha) * texture(iChannel0, uv2) + alpha * texture(iChannel1, uv1);\n\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVBDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 92], [94, 94, 118, 118, 162], [164, 164, 221, 271, 821]], "test": "untested"}
{"id": "stVfWc", "name": "Reservoir sampling", "author": "iq", "description": "A very loose interpretation of the ReSTIR paper, in particular, I only implemented the Reservoir part of it, not the PDF resampling. [url]https://research.nvidia.com/sites/default/files/pubs/2020-07_Spatiotemporal-reservoir-resampling/ReSTIR.pdf[/url]", "tags": ["3d", "sampling", "restir", "reservoir"], "likes": 113, "viewed": 6208, "published": 3, "date": "1665468372", "time_retrieved": "2024-07-30T16:26:52.777125", "image_code": "// Inigo Quilez 2022\n//\n// A very loose interpretation of the ReSTIR paper,\n//\n// https://research.nvidia.com/sites/default/files/pubs/2020-07_Spatiotemporal-reservoir-resampling/ReSTIR.pdf\n//\n// but without the pdf resampling bit. I'm just implementing the spation-temporal\n// reservoir for ambient occlusion, but might be doing mistakes ^__^\n//\n// The paper is awesome although a bit too vague and unclear at times, but the\n// main insight anyways is that one can share \"samples\" across pixels and frames,\n// instead of sharing the \"lighting\" resulting from those samples. A \"sample\" in\n// this context is a raycast direction for the ambient occlusion visibility test.\n//\n// When a pixel casts a ray that doesn't hit geometry and gets ambient light as a\n// result, it informs its neigbors and future self about this unocluded direction\n// for them to consider raycasting in that direction as well. Recall we ideally\n// cast only in the direction of unoccluded incoming light, if we had such knowledge\n// that is. Along with the sample direction, the per pixel reservoir also shares\n// the weight that the sample  should be reused with. In an ideal world all samples\n// converge into unoccluded directions and their weights to the real ambient\n// occlusion value. That would produce noise free images!\n//\n// I think I probably got some of the math wrong, including the sample invalidation.\n// Also I'm casting cosine distributed rays, which in theory cannot be reused just\n// like that with neighboring pixels. Some re-weighting needs to happen, but I am\n// not doing anything about it right now. Regardless, the shader is doing something\n// useful, at least images come cleaner, especially in higher res monitors.\n//\n// Also because Shadertoy only has RGBA32F buffers, I had to be a bit creative with\n// data packing, since I needed to store surface normals, object IDs, intersection\n// distances, the reservoir's sample direction and its weight. So I'm encoding\n// samples in a single float insted of three floats by choosing its closest\n// spherical fibonacci point. I used 2^21 (2 million) such points so I can store\n// the point ID in a float32 without exceeding its mantissa bits. Surface normals\n// are also stored that way in a single float.\n//\n// Buffer A contains the main render pass, and the initial random sample. Buffer B\n// does the temporal reservoir reuse. Buffers C and D do the spatial reservoir\n// reuse. The Image pass casts the second and final occlusion ray, using a good \n// sample direction by looking into the reservoir.\n//\n// You can use the mouse to compare 2 naive samples of ambient occlusion to the\n// reservoir method, which also uses 2 samples. Also you can disable the temporal \n// and spatial reservoirs in the Common tab. You can also choose to compare to\n// ground-truth:\n\n// 0: 64 samples - ground truth\n// 1:  2 samples - same cost as reservoir, so fair comparison\n#define COMPARE_TO 1\n\n// set to 0 for clean but wrong images...\n#define UNBIASED 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ip = ivec2(fragCoord);\n    \n    // init randoms\n    int ifr = int(iTime*144.0); // not using iFrame so I can pause and compare\n    srand( ip, ifr + 5 );\n\n    // read gbuffer\n    vec4 data = texelFetch(iChannel0,ip,0);\n\n    // get reservoir, object id and intersection distance from gbuffer\n    Reservoir r; vec2 tm;\n    read_gbuffer( data, r, tm );\n    \n    // reconstruct current camera\n    vec3 ro, rd; mat3 ca;\n    raster_to_camera( fragCoord, iResolution.xy, iTime, ro, rd, ca );\n\n\n    // pixel and mouse coordiantes\n    float px = (2.0*fragCoord.x-iResolution.x)/iResolution.y;\n    float mx = (2.0*   iMouse.x-iResolution.x)/iResolution.y;\n    if( iMouse.z<0.5 ) mx = -cos((iTime-7.0)*6.283185/6.0)*iResolution.x/iResolution.y;\n    \n    // animation\n    float ani = smoothstep(7.0,8.0,iTime);\n    mx = mix(-2.0,mx,ani);\n    \n    // do lighting/shading\n    vec3 col = vec3(0.0);\n    if( tm.y>0.0 )\n    {\n        vec3 pos = ro + tm.x*rd;\n        \n        // read normap from G-Buffer and decompress it\n        vec3 nor = id_to_nor( texelFetch(iChannel1,ip,0).z );\n\n        // coloring/material\n        float al = smoothstep( 0.01, 0.2, -sin((iTime-7.0)*6.283185/12.0) );\n        vec3 mate = mix( vec3(1.0), 0.6 + 0.5*sin(tm.y+vec3(0,2,4)), al*ani );\n        \n        // do ambient occlusion as usual... (left)\n        if( px<mx )\n        {\n             #if COMPARE_TO==0\n                 // 36 stratified samples as \"ground truth\"\n                 col = vec3(0.0);\n                 const int num = 6;\n                 for( int j=0; j<num; j++ )\n                 for( int i=0; i<num; i++ )\n                 {\n                    vec2 uv = vec2(float(i)+frand(), float(j)+frand())/float(num);\n                    vec3 dir = cosineDirection( uv, nor );\n                    if( raycast(pos+0.001*nor, dir ).y < 0.0 ) col += 1.0;\n                 }\n                 col /= float(num*num);\n             #else\n                 // one or two blue noise samples\n                 vec4 ra = texelFetch( iChannel2, (ip+ifr*ivec2(71,313))&1023, 0 );\n                 vec3 dir = cosineDirection( ra.xy, nor ); if( raycast(pos+0.001*nor, dir ).y < 0.0 ) col += 1.0;\n                 #if UNBIASED==1\n                 dir = cosineDirection( ra.zw, nor ); if( raycast(pos+0.001*nor, dir ).y < 0.0 ) col += 1.0;\n                 col /= 2.0;\n                 #endif\n             #endif\n        }\n        // ... or using the reservoir (right)\n        else\n        {\n            #if UNBIASED==1\n            vec3 dir = id_to_nor(r.y); dir *= sign(dot(dir,nor));\n            float sha = (raycast(pos+0.001*nor,dir).y<0.0) ? 1.0 : 0.0;\n            col = vec3( sha * r.wsum/r.m );\n            #else\n            col = vec3(       r.wsum/r.m ); \n            #endif\n        }\n        col *= mate;\n    }\n\n    // gammaish\n    // col = sqrt(col);\n    \n    // vertical separating line\n    col = mix( col, vec3(1,0,0), 1.0-smoothstep( 0.0, 0.01, abs(px-mx) ) );\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// --------------------------------------------------------\n// render G-Buffer and shoot initial random occlusion ray\n// --------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ip = ivec2(fragCoord);\n    \n    // init randoms\n    int ifr = int(iTime*144.0);\n    srand( ip, ifr + 0 );\n\n\n    // camera and ray\n    vec3 ro, rd; mat3 ca;\n    raster_to_camera( fragCoord, iResolution.xy, iTime, ro, rd, ca );\n\n    // raycast scene (.x = distance, .y = material)\n    vec2 tm = raycast( ro, rd );\n    \n    if( tm.y<0.0 )\n    {\n        fragColor = vec4( 0.0, 0.0, 0.0, -1.0 );\n        return;\n    }\n    \n    // compute intersection and normal\n    vec3 pos = ro + tm.x*rd;\n    vec3 nor = calcNormal(pos,tm.x);\n\n    // pick one random direction and shoot an shadow/occlusion ray\n    vec2  ran = texelFetch( iChannel2, (ivec2(fragCoord)+ifr*ivec2(71,313))&1023, 0 ).xy;\n    vec3  dir = cosineDirection( ran, nor );\n    float sha = (raycast(pos+0.001*nor, dir ).y < 0.0) ? 1.0 : 0.0;\n    \n    // store occlusion information in reservoir\n    Reservoir r = Reservoir( nor_to_id(dir), sha, 1.0 );\n\n    // store all this in G-Buffer (4 floats)\n    //    reservoir (sample direction and weight - no need to store M, which is 1)\n    //    normal\n    //    object id\n    //    intersection distance\n    fragColor = vec4( r.y, r.wsum, nor_to_id(nor), tm_to_float(tm) );\n}", "buffer_a_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// --------------------------------------------------------\n// temporal reservoir reuse\n// --------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ip = ivec2(fragCoord);\n    \n    // init randoms\n    int ifr = int(iTime*144.0);\n    srand( ip, ifr + 2 );\n\n    \n    // reconstruct current camera\n    vec3 ro, rd; mat3 ca;\n    raster_to_camera( fragCoord, iResolution.xy, iTime, ro, rd, ca );\n    \n    // store it for next frame\n    if( ip.y==0 && ip.x<=2 )\n    {\n        fragColor = vec4( ca[ip.x], -dot(ca[ip.x],ro) );\n        return;\n    }\n    \n    // read gbuffer\n    vec4 data = texelFetch(iChannel0,ip,0);\n    if( data.w<0.0 ) { fragColor= vec4(0.0,0.0,0.0,-1.0); return; }\n    \n    Reservoir r = Reservoir( data.x, data.y, 1.0 );\n    vec2 tm = float_to_tm(data.w);\n\n    #if USE_TEMPORAL==1\n    \n    // get old camear matrix\n    mat3x4 oldCam = mat3x4( texelFetch(iChannel1,ivec2(0,0), 0),\n                            texelFetch(iChannel1,ivec2(1,0), 0),\n                            texelFetch(iChannel1,ivec2(2,0), 0) );\n\n    // recontruct current intersection in world space\n    vec4 wpos = vec4(ro + rd*tm.x,1.0);\n    \n    // project to previous camera space\n    vec3 cpos = wpos*oldCam; // note inverse multiply\n    \n    // convert to previous ndc space\n    ivec2 rpos = ivec2( camera_to_raster( cpos, iResolution.xy ) );\n    \n    if( rpos.x>=0 && rpos.y>=0 && rpos.x<int(iResolution.x) && rpos.y<int(iResolution.y) )\n    {\n        // fetch reservoir from gbuffer at previous frame's pixel's location\n        vec4 old_data = texelFetch(iChannel1,rpos,0);\n        // depack data\n        Reservoir prev_r;\n        vec2 prev_tm;\n        read_gbuffer( old_data, prev_r, prev_tm );\n        \n        // is this what the paper means by \"clamp\"?\n        if( prev_r.m>r.m*20.0 ) { prev_r.wsum=r.m*20.0*prev_r.wsum/prev_r.m; prev_r.m=r.m*20.0; }\n\n        // if this is still same object...\n        if( abs(prev_tm.y-tm.y)<0.5 ) \n        {\n            // ... then combine its reservoir with current reservoir\n            r = combineReservoirs( r, prev_r );\n        }\n    }\n    #endif\n\n   \n    fragColor = store_gbuffer( r, tm );\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define USE_TEMPORAL 1\n#define USE_SPATIAL  1\n\n\n//=====================================================\n// rand\n//=====================================================\n\nint   seed = 1;\nint    rand(void) { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\nvoid  srand(ivec2 p, int frame)\n{\n    int n = 0;\n    n += frame; n=(n<<13)^n; n=n*(n*n*15731+789221)+1376312589; // hash by Hugo Elias\n    n += p.y;   n=(n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    n += p.x;   n=(n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\n\n//=====================================================\n// Geometry\n//=====================================================\n\n// https://iquilezles.org/articles/intersectors\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\n\treturn vec2( tN, tF );\n}\n\nvec3 cosineDirection( in vec2 uv, in vec3 nor )\n{\n    float a = 6.2831853*uv.x; float b = 2.0*uv.y-1.0;\n    vec3 dir = vec3(sqrt(1.0-b*b)*vec2(cos(a),sin(a)),b);\n    return normalize( nor + dir );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//=====================================================\n// Reservoir\n//=====================================================\n\nstruct Reservoir\n{\n\tfloat y;       // sample, stored as a fibonacci direction in the sphere\n\tfloat wsum;\n\tfloat m;\n};\n\nReservoir combineReservoirs( Reservoir a, Reservoir b )\n{\n    Reservoir s;\n    s.y = ( frand()*(a.wsum+b.wsum)<=a.wsum ) ? a.y : b.y;\n    s.wsum = a.wsum + b.wsum;\n    s.m = a.m + b.m;\n    return s;\n}\n\n//=====================================================\n// find closest Fibonacci points in a sphere\n// https://dl.acm.org/doi/10.1145/2816795.2818131\n//=====================================================\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float PHI = 1.6180339887498948482045868343656;\n\nfloat madfrac( float a,float b) { return a*b -floor(a*b); }\nvec2  madfrac( vec2  a,float b) { return a*b -floor(a*b); }\nconst float kConvPrecis = float(1<<21);\nfloat nor_to_id(vec3 p) \n{\n    const float n = kConvPrecis;\n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI*PHI)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    \n    vec2 F = vec2( round(Fk), round(Fk * PHI) );\n\n    vec2 ka = -2.0*F/n;\n    vec2 kb = 2.0*PI*madfrac(F+1.0, PHI-1.0) - 2.0*PI*(PHI-1.0);    \n    mat2 iB = mat2( ka.y, -ka.x, -kb.y, kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n\n    vec2 c = floor( iB * vec2(phi, cosTheta - (1.0-1.0/n)));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float cosTheta = dot(ka, uv + c) + (1.0-1.0/n);\n        \n        cosTheta = clamp(cosTheta, -1.0, 1.0)*2.0 - cosTheta;\n        float i = floor(n*0.5 - cosTheta*n*0.5);\n        float phi = 2.0*PI*madfrac(i, PHI-1.0);\n        cosTheta = 1.0 - (2.0*i + 1.0)/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta);\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return j;\n}\n\nvec3 id_to_nor( float i) \n{\n    const float n = kConvPrecis;\n    float phi = 2.0*PI*madfrac(i,PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\n//=====================================================\n// SDFs\n// https://iquilezles.org/articles/distfunctions/\n//=====================================================\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p);\n    float h = clamp( (-2.0*ndot(q,b) + ndot(b,b) )/dot(b,b), -1.0, 1.0 );\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    d *= sign( q.x*b.y + q.y*b.x - b.x*b.y );\n\treturn d - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opRepLim( in float p, in float s, in float lima, float limb, out float id )\n{\n    id = round(p/s);\n    return p-s*clamp(id,-lima,limb);\n}\n\nvec2 opRepLim( in vec2 p, in float s, in vec2 lim, out vec2 id )\n{\n    id = round(p/s);\n    return p-s*clamp(id,-lim,lim);\n}\n\nvec2 opRepLim( in vec2 p, in float s, in vec2 limmin, in vec2 limmax, out vec2 id )\n{\n    id = round(p/s);\n    return p-s*clamp(id,-limmin,limmax);\n}\nfloat opExtrussion( in float sdf, float z, in float h )\n{\n    vec2 w = vec2( sdf, abs(z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n//=====================================================\n// scene data\n//=====================================================\nfloat hash1( vec2 p ) { p = 50.0*fract( p*0.3183099 ); return fract( p.x*p.y*(p.x+p.y) ); }\nvec2 map( in vec3 p )\n{\n    vec3 op = p;\n    p.y += 2.0;\n    float ma = 0.0;\n\n    // columns\n    vec2 id;\n    vec3 q = p; q.xz = opRepLim( q.xz, 4.0, vec2(4.0,2.0), id );\n    float d = length(q.xz) - 0.9 + 0.05*p.y;\n    d = max(d,p.y-6.0);\n    d = max(d,-p.y-5.0);\n    d -= 0.05*pow(0.5+0.5*sin(atan(q.x,q.z)*16.0),2.0);\n    d -= 0.15*pow(0.5+0.5*sin(q.y*3.0+0.6),0.12) - 0.15;\n    ma = floor(50.0*hash1( id + 11.2*floor(0.25 + (q.y*3.0+0.6)/6.2831) ));\n    d *= 0.85;\n    vec3 w = vec3(q.x,abs(q.y-0.3)-5.5, q.z );\n    d = min( d,  sdBox(w,vec3(1.4,0.2,1.4)+sign(q.y-0.3)*vec3(0.1,0.05,0.1))-0.1 ); // base\n    d = max( d, -sdBox(p,vec3(14.0,10.0,6.0)) ); // clip in\n\n    // floor\n    p.y -= 0.1;\n    float bb1 = op.y+7.0;\n    if( bb1<d ) //  bounding plane\n    {\n        vec2 id0 = round(p.xz/4.0);\n        vec2 off = step(vec2(0.0), p.xz/4.0-id0);\n        for( int j=0; j<2; j++ )\n        for( int i=0; i<2; i++ )\n        {\n            vec2 id = id0 + vec2(i,j) - off;\n            id = clamp( id, -vec2(4.0,3.0), vec2(4.0,3.0) );\n            vec2 ce = id*4.0;\n            q = p-vec3(ce.x,0.0,ce.y);\n\n            float ra = 1.0*0.05 * hash1(id+vec2(1.0,3.0));\n            float b = sdBox( q-vec3(0.0,-6.0-ra,0.0), vec3(2.0,0.5,2.0)-0.1-ra )-0.1;\n            if( b<d ) { d = b; ma = floor(20.0*hash1(id)); }\n        }\n    }\n\n    float bb2 = op.y+8.0;\n    if( bb2<d ) //  bounding plane\n    {\n        p.xz -= 2.0;\n        \n        vec2 id0 = round(p.xz/4.0);\n        vec2 off = step(vec2(0.0), p.xz/4.0-id0);\n        for( int j=0; j<2; j++ )\n        for( int i=0; i<2; i++ )\n        {\n            vec2 id = id0 + vec2(i,j) - off;\n            id = clamp( id, -vec2(5.0,4.0), vec2(4.0,3.0) );\n            vec2 ce = id*4.0;\n            q = p-vec3(ce.x,0.0,ce.y);\n            \n            float ra = 0.15 * hash1(id+vec2(1.0,3.0)+23.1);\n            float b = sdBox( q-vec3(0.0,-7.0-ra,0.0), vec3(2.0,0.6,2.0)-0.1-ra )-0.1;\n            if( b<d ) { d = b; ma = floor(20.0*hash1( id + 13.5 )); }\n        }\n        p.xz += 2.0;\n    }    \n     \n    float bb3 = op.y+9.0;\n    if( bb3<d ) //  bounding plane\n    {\n        vec2 id0 = round(p.xz/4.0);\n        vec2 off = step(vec2(0.0), p.xz/4.0-id0);\n        for( int j=0; j<2; j++ )\n        for( int i=0; i<2; i++ )\n        {\n            vec2 id = id0 + vec2(i,j) - off;\n            id = clamp( id, -vec2(5.0,4.0), vec2(5.0,4.0) );\n            vec2 ce = id*4.0;\n            q = p-vec3(ce.x,0.0,ce.y);\n\n            float ra = 0.15 * hash1(id+vec2(1.0,3.0)+37.7);\n            float b = sdBox( q-vec3(0.0,-8.0-ra-1.0,0.0), vec3(2.0,0.6+1.0,2.0)-0.1-ra )-0.1;\n            if( b<d ) { d = b; ma = floor(20.0*hash1( id*7.0 + 31.1 )); }\n        }\n    }\n\n    // roof\n    float bb4 = -(op.y-4.0);\n    if( bb4<d ) //  bounding plane\n    {\n        {\n        float id1;\n        q = vec3(p.x,p.y,abs(p.z))-vec3(0.0,0.0,9.0);\n        q.x = opRepLim( q.x, 4.0, 4.0, 4.0, id1 );\n        float b = sdBox( q-vec3(0.0,7.0,0.0), vec3(1.95,1.0,0.95)-0.1 )-0.1;\n        if( b<d ) { d = b; ma = floor(20.0*(id1+6.0)); }\n        }\n        {\n        float id1;\n        q = vec3(abs(p.x)+1.0,p.y,p.z-2.0)-vec3(17.0,0.0,0.0);\n        q.z = opRepLim( q.z, 4.0, 2.0, 1.0, id1 );\n        float b = sdBox( q-vec3(0.0,7.0,0.0), vec3(1.95,1.0,1.95)-0.1 )-0.1;\n        if( b<d ) { d = b; ma = floor(30.0*(id1+6.0)); }\n        }\n\n        q = p; q.xz = opRepLim( q.xz+0.5, 1.0, vec2(18,10),vec2(19,11), id );\n        float b = sdBox( q-vec3(0.0,8.0,0.0), vec3(0.45,0.2,0.47)-0.05 )-0.05;\n        if( b<d ) { d = b; ma = floor(20.0*hash1( id + 7.8 )); }\n\n        b = sdRhombus( p.yz-vec2(8.2,0.0), vec2(3.0,10.8), 0.0 ) ;\n        b = opExtrussion( b, p.x, 19.0-0.1 )-0.1;\n        q = vec3( mod(p.x+1.0,2.0)-1.0, p.y, mod(p.z+1.0,2.0)-1.0 );\n        b = max( b, -sdBox( vec3( abs(p.x)-20.0,p.y,q.z)-vec3(0.0,8.0,0.0), vec3(2.0,5.0,0.1) )-0.05 );\n        b = max( b, -p.y+8.2 );\n        \n        float bma = 13.0;\n        float c = sdRhombus( p.yz-vec2(8.2,0.0), vec2(2.25,8.7), 0.05 );\n        c = opExtrussion( c, abs(p.x)-19.0, 2.0 );\n        if( -c>b ) { b=-c; bma = 12.0; }\n        \n        b = max( b,-sdBox(p-vec3(0.0,9.5,0.0),vec3(15.0,2.0,9.0)) );\n        if( b<d ) { d=b; ma=bma; }\n    }\n\n    return vec2( d, ma );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 b = iBox( ro-vec3(0.0,-2.0,0.0), rd, vec3(24.0,12.0,19.0) );\n    if( b.y>0.0 )\n    {\n        b.x = max(0.001,b.x);\n        \n        float tmax = b.y;\n        float t = b.x;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 h = map( pos );\n            if( h.x<(0.001*t) ) return vec2(t,1.0+h.y);\n            t += h.x*0.9;\n            if( t>tmax ) break;\n        }\n    }\n    \n    return vec2(1e20,-1.0);\n}\n\nvec3 calcNormal( in vec3 p, in float t )\n{\n#if 0\n    float e = 0.001*t;\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n#else    \n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.001*t).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nconst float kFocalLength = 2.0;\n\nvoid raster_to_camera( in vec2 px, in vec2 resolution, in float time, out vec3 ro, out vec3 rd, out mat3 ca )\n{\n    vec2 p = (2.0*px-resolution) / resolution.y;\n\n    float h = 0.5 - 0.5*cos(time*0.13);\n    vec3 ta = vec3(0.0, -5.0*h, 0.0 );\n\tro = vec3(38.0*cos(time*0.1), 10.0*h, 25.0*sin(time*0.1) );\n\n    ca = setCamera( ro, ta, 0.0 );\n    rd = ca * normalize( vec3(p,kFocalLength));\n}\n\nvec2 camera_to_raster( vec3 cpos, vec2 resolution )\n{\n    // convert camera to ndc\n    vec2 npos = kFocalLength * cpos.xy / cpos.z;\n    \n    // convert ndc to screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(resolution.y/resolution.x,1.0);\n    \n\t// convert screen to raster space\n    return spos * resolution;\n}    \n\n// note I'm normalizing the ray distance to 60 units so that I can encode\n// object ID and ray distance in a single float (as integer and decimal parts)\nfloat tm_to_float( in vec2 tm )\n{\n    return tm.y + ((tm.y<0.0)?0.0:clamp(tm.x/60.0,0.0,1.0));\n}\n\nvec2 float_to_tm( in float f )\n{\n    return vec2(fract(f)*60.0, floor(f) );\n}\n\nvec4 store_gbuffer( Reservoir r, vec2 tm )\n{\n    return vec4( r.y, r.wsum, r.m, \n                 tm.y + ((tm.y<0.0)?0.0:clamp(tm.x/60.0,0.0,1.0)) );\n}\n\nvoid read_gbuffer( vec4 data, out Reservoir r, out vec2 tm )\n{\n    r = Reservoir( data.x, data.y, data.z );\n    tm = vec2(fract(data.w)*60.0, floor(data.w) );\n}", "buffer_c_code": "// --------------------------------------------------------\n// spatial reservoir reuse\n// --------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ip = ivec2(fragCoord);\n    \n    // init randoms\n    int ifr = int(iTime*144.0);\n    srand( ip, ifr + 3 );\n\n\n    // reconstruct current camera\n    vec3 ro, rd; mat3 ca;\n    raster_to_camera( fragCoord, iResolution.xy, iTime, ro, rd, ca );\n    \n    // store it for next frame\n    if( ip.y==0 && ip.x<=2 )\n    {\n        fragColor = vec4( ca[ip.x], -dot(ca[ip.x],ro) );\n        return;\n    }\n    \n    // read gbuffer\n    vec4 data = texelFetch(iChannel0,ip,0);\n    if( data.w<0.0 ) { fragColor= vec4(0.0,0.0,0.0,-1.0); return; }\n    \n    // get reservoir, object id and intersection distance from gbuffer\n    Reservoir r; vec2 tm;\n    read_gbuffer( data, r, tm );\n    \n    #if USE_SPATIAL==1\n\n    //vec3 nor = calcNormal( ro + tm.x*rd, tm.x );\n    vec3 nor = id_to_nor( texelFetch(iChannel1,ip,0).z );\n    \n    vec2 ran = texelFetch( iChannel2, (ivec2(fragCoord)+ifr*ivec2(71,313))&1023, 0 ).xy;\n    \n    // gather samples from 32 neighboring pixels\n    for( int i=0; i<32; i++ )\n    {\n        float h = float(i)/float(32-1);\n        // note I am using h and NOT sqrt(h), which would be the correct\n        // thing to do to get homegeneous coverage. However, concentrating\n        // more samples around the origin seems like a good idea, since\n        // that's where the most relevant information is\n        float a = 6.2831*(h*13.0 + ran.x);\n        vec2 q = h*vec2(cos(a),sin(a));\n        \n        ivec2 of = ivec2( 30.0*h*vec2(cos(a),sin(a)) );\n        \n        vec4 neig_data = texelFetch(iChannel0,ip+of,0);\n\n        Reservoir neig_r;\n        vec2 neig_tm;\n        read_gbuffer( neig_data, neig_r, neig_tm );\n\n        if( abs(tm.x-neig_tm.x)<0.1*tm.x )\n        {\n            vec3 mor = id_to_nor( texelFetch(iChannel1,ip+of,0).z );\n            if( dot(nor,mor)>cos(25.0*3.14159/180.0) )\n            \n            r = combineReservoirs( r, neig_r );\n        }\n    }\n\n    #endif\n    \n    fragColor = store_gbuffer( r, tm );\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// --------------------------------------------------------\n// spatial reservoir reuse\n// --------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ip = ivec2(fragCoord);\n    \n    // init randoms\n    int ifr = int(iTime*144.0);\n    srand( ip, ifr + 4 );\n    \n    \n    // reconstruct current camera\n    vec3 ro, rd; mat3 ca;\n    raster_to_camera( fragCoord, iResolution.xy, iTime, ro, rd, ca );\n    \n    // store it for next frame\n    if( ip.y==0 && ip.x<=2 )\n    {\n        fragColor = vec4( ca[ip.x], -dot(ca[ip.x],ro) );\n        return;\n    }\n    \n    // read gbuffer\n    vec4 data = texelFetch(iChannel0,ip,0);\n    if( data.w<0.0 ) { fragColor= vec4(0.0,0.0,0.0,-1.0); return; }\n    \n    // get reservoir, object id and intersection distance from gbuffer\n    Reservoir r; vec2 tm;\n    read_gbuffer( data, r, tm );\n    \n    #if USE_SPATIAL==1\n   \n    //vec3 nor = calcNormal( ro + tm.x*rd, tm.x );\n    vec3 nor = id_to_nor( texelFetch(iChannel1,ip,0).z );\n    \n    vec2 ran = texelFetch( iChannel2, (ivec2(fragCoord)+ifr*ivec2(71,313))&1023, 0 ).xy;\n    \n    // gather samples from 32 neighboring pixels\n    for( int i=0; i<32; i++ )\n    {\n        float h = float(i)/float(32-1);\n        // note I am using h and NOT sqrt(h), which would be the correct\n        // thing to do to get homegeneous coverage. However, concentrating\n        // more samples around the origin seems like a good idea, since\n        // that's where the most relevant information is\n        float a = 6.2831*(h*13.0 + ran.y);\n        vec2 q = h*vec2(cos(a),sin(a));\n        \n        ivec2 of = ivec2( 30.0*h*vec2(cos(a),sin(a)) );\n        \n        vec4 neig_data = texelFetch(iChannel0,ip+of,0);\n\n        Reservoir neig_r;\n        vec2 neig_tm;\n        read_gbuffer( neig_data, neig_r, neig_tm );\n\n        if( abs(tm.x-neig_tm.x)<0.1*tm.x )\n        {\n            vec3 mor = id_to_nor( texelFetch(iChannel1,ip+of,0).z );\n            if( dot(nor,mor)>cos(25.0*3.14159/180.0) )\n            \n            r = combineReservoirs( r, neig_r );\n        }\n    }\n\n    #endif\n    \n    fragColor = store_gbuffer( r, tm );\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVfWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2989, 2989, 3046, 3046, 6028]], "test": "untested"}
{"id": "flVfWt", "name": "Orbit Controls", "author": "mmnz", "description": "Persistent orbit controls like in Three.js.\nDrag with the mouse, and the position you dragged to will be saved.", "tags": ["3d", "simple", "mouse", "orbit", "buffer", "navigation", "pan", "persistent"], "likes": 2, "viewed": 180, "published": 3, "date": "1665466727", "time_retrieved": "2024-07-30T16:26:53.614885", "image_code": "// Persistent orbit controls like in Three.js.\n// Mouse position is saved to Buffer A.\n// There are probably better raymarching and lighting methods -\n// the extent of my knowledge so far comes from the\n// first hour or two of Happy Jumping (youtu.be/Cfe5UQ-1L9Q).\n\n// Returns distance, material\nvec2 map(in vec3 position) {\n    float sphere = length(position) - 0.25;\n    float terrain = position.y + 0.25;\n    return (sphere < terrain) ? vec2(sphere, 1.0) : vec2(terrain, 2.0);\n}\n\n// Returns t, material shadow\nvec3 castRay(in vec3 rayOrigin, in vec3 rayDirection) {\n    float t = 0.0;\n    float material = -1.0;\n    float shadow = 1.0;\n    float mint = 0.001;\n    float maxt = 20.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 position = rayOrigin + t * rayDirection;\n        vec2 h = map(position);\n        material = h.y;\n        shadow = min(shadow, 8.0 * h.x / t);\n        if (h.x < mint) { break; }\n        t += h.x;\n        if (t > maxt) { break; }\n    }\n    if (t > maxt) { t = material = -1.0; }\n    shadow = clamp(shadow, 0.0, 1.0);\n    return vec3(t, material, shadow);\n}\n\n// Returns normal\nvec3 calcNormal(in vec3 position) {\n    vec2 e = vec2(1, -1) * inversesqrt(12000000.0);\n    return normalize(\n        e.xyy * map(position + e.xyy).x + \n\t\te.yyx * map(position + e.yyx).x + \n\t\te.yxy * map(position + e.yxy).x + \n\t\te.xxx * map(position + e.xxx).x\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float pi = acos(-1.0);\n    // Customisable\n    float thetaOffset = 0.1 * iTime; // Extra rotation\n    float ymin = 0.1; // 0.0 = 0deg, facing the horizon\n    float ymax = 0.9; // 1.0 = 90deg, facing the ground\n    float orbitRadius = 1.0; // Distance from center\n    // Always the same\n    vec2 storedMouse = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    float theta = -2.0 * pi * storedMouse.x + thetaOffset;\n    float phi = 0.5 * pi * (1.0 - storedMouse.y) * (ymax - ymin) + ymin;\n    vec3 rayOrigin = orbitRadius * vec3(sin(theta)*cos(phi), sin(phi), cos(theta)*cos(phi));\n    // Standard camera stuff\n    vec3 target = vec3(0);\n    float focalLength = 1.5;\n    vec3 ww = normalize(target - rayOrigin);\n    vec3 uu = normalize(cross(ww, vec3(0, 1, 0)));\n    vec3 vv = normalize(cross(uu, ww));\n    vec3 rayDirection = normalize(p.x * uu + p.y * vv + focalLength * ww);\n\n    // Sky colour, fading to grey at the horizon\n    vec3 color = vec3(0.4, 0.7, 1.0) - 0.7 * rayDirection.y;\n    color = mix(color, vec3(0.7, 0.75, 0.8), clamp(exp(-10.0 * rayDirection.y), 0.0, 1.0));\n    \n    vec3 ray = castRay(rayOrigin, rayDirection);\n    \n    if (ray.y > 0.0) {\n        vec3 position = rayOrigin + ray.x * rayDirection;\n        vec3 normal = calcNormal(position);\n        \n        // Material colour\n        vec3 material = vec3(0);\n        if (ray.y < 1.5) {\n            material = vec3(0.18); // Sphere: grey\n        } else {\n            material = vec3(0.05, 0.1, 0.02); // Terrain: green checkerboard\n            material += 0.05 * smoothstep(-0.1, 0.1, sin(18.0 * position.x) + cos(18.0 * position.z));\n        }\n        \n        // Lighting colours\n        vec3 sun_direction = normalize(vec3(0.8, 0.4, 0.2));\n        float sun_diffuse = clamp(dot(normal, sun_direction), 0.0, 1.0);\n        float sun_shadow = castRay(position + normal * 0.001, sun_direction).z;\n        float sky_diffuse = clamp(0.5 + 0.5 * dot(normal, vec3(0, 1, 0)), 0.0, 1.0);\n        float ground_diffuse = clamp(0.5 + 0.5 * dot(normal, vec3(0, -1, 0)), 0.0, 1.0);\n        color  = material * vec3(7.0, 4.5, 3.0) * sun_diffuse * sun_shadow;\n        color += material * vec3(0.5, 0.8, 0.9) * sky_diffuse;\n        color += material * vec3(0.7, 0.3, 0.2) * ground_diffuse;\n    }\n    \n    fragColor = vec4(pow(color, vec3(0.4545)), 1.0);\n    \n    // Test first 2px of Buffer A:\n    // fragColor = texture(iChannel0, (2.0 * fragCoord - iResolution.xy) / iResolution.y);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Initialise buffer to white (buffer is unused if alpha is empty).\n    if (texelFetch(iChannel0, ivec2(0,0), 0).a < 1.0) {\n        fragColor = vec4(1);\n        return;\n    }\n\n    // Fetch old values\n    vec2 current = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec2 previous = texelFetch(iChannel0, ivec2(1, 0), 0).xy;\n    vec4 mouse = iMouse / iResolution.xyxy;\n    \n    // Fix for Shadertoy ignoring mouseup outside canvas. Reset previous on click.\n    // Fix removed because it breaks things on iOS (where iMouse.w is positive until mouseup).\n    // if (mouse.w > 0.0) {\n    //     previous = current;\n    // }\n    \n    // When mouse down, add the mouse position to the previous position minus starting offset.\n    // Otherwise, save the current position to be used for the next time the mouse is dragged.\n    if (mouse.z > 0.0) {\n        vec2 next = previous + mouse.xy - abs(mouse.zw);\n        current = vec2(fract(next.x), clamp(next.y, 0.0, 1.0)); // wrap x, clamp y\n    } else {\n        previous = current;\n    }\n    \n    // Save current to (0,0) and previous to (1,0)\n    fragColor = vec4(fragCoord.x < 1.0 ? current : previous, 0.0, 1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVfWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[266, 296, 324, 324, 481], [483, 513, 568, 568, 1089], [1091, 1109, 1144, 1144, 1378], [1380, 1380, 1435, 1435, 3950]], "test": "untested"}
{"id": "NlKBW3", "name": "Tearable 3D Fishnet", "author": "fenix", "description": "Verlet cloth sim with point tearing. Hopefully you'll find it more \"tearable\" than \"terrible\". If you were expecting not to suffer any bad puns you've come to the wrong shader...\n\n*mouse to tear the cloth* \n*space to reset and resume attract mode*", "tags": ["3d", "simulation", "particles", "dynamics", "physics", "integration", "cloth", "fabric", "tearing", "tear", "fishnet"], "likes": 67, "viewed": 754, "published": 3, "date": "1665466113", "time_retrieved": "2024-07-30T16:26:54.565344", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Verlet cloth sim with point tearing. Hopefully you'll find it more \"tearable\" than\n//  \"terrible\". If you were expecting not to suffer any bad puns you've come to the wrong\n//  shader...\n// \n//  The stability of this, such as it is, comes from essentially an absurd number of\n//  edges. Not only is each particle connected via the visible lines to each neighbor,\n//  but to the next particle, and the next particle, and so on. I'm surely not the first\n//  person to come up with this appoach, so I don't think you can say I made this \"out\n//  of whole cloth\". Ahem.\n//  \n//  If the wind is a bit much, you can tone it down with WIND_SPEED. I could tell you\n//  more about the making of this shader, and it would be quite the yarn. But you might\n//  accuse me of fabrication.\n//\n//  OK, I'll stop.\n//\n//  Buffer A computes the particle positions\n//  Buffer B computes nearest particles to each screen pixel\n//\n// ---------------------------------------------------------------------------------------\n\nvoid drawLine(vec3 from, vec3 to, vec2 p, mat4 w2c, inout vec4 fragColor)\n{\n    // convert to camera space\n    vec3 fromCamera = (w2c * vec4(from,1.0)).xyz;\n    fromCamera.xy = fromCamera.xy / fromCamera.z;\n    vec3 toCamera = (w2c * vec4(to,1.0)).xyz;\n    toCamera.xy = toCamera.xy / toCamera.z;\n\n    // if in front of clipping plane\n    if(fromCamera.z > 0.01 && toCamera.z > 0.01) \n    {\n        float dist2 = fxLinePointDist2(fromCamera.xy, toCamera.xy, p);\n        float dist = sqrt(dist2);\n\n        float PARTICLE_SIZE = 2. / iResolution.y;\n        float particleTemp = max(0.0, PARTICLE_SIZE - dist) / PARTICLE_SIZE;\n\n        if (dist < PARTICLE_SIZE)\n        {\n            fragColor = min(fragColor, 1. - vec4(vec3(particleTemp), 0));\n        }\n    }\n}\n\nvoid drawLineToNeighbor(int nid, vec3 pos, vec2 p, mat4 w2c, inout vec4 fragColor)\n{\n    if (nid >= 0)\n    {\n        fxParticle nData = fxGetParticle(nid);\n\n        if (!nData.disabled) drawLine(pos, nData.pos, p, w2c, fragColor);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    computeClothSide(iResolution);\n    \n    // pixel\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    // camera-to-world and world-to-camera transform\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n\n\tconst vec3 reverseLightDir = normalize(vec3(1.0,2.0,3.0));\n\tconst vec3 lightColor = vec3(0.5,0.5,0.5);\t\n\tconst vec3 ambientColor = vec3(0.05,0.05,0.05);\n   \n    fragColor = vec4(.7);\n    //return;\n    ivec4 old = fxGetClosest( ivec2(fragCoord) );      \n\n    for(int j=0; j<1; j++)\n    {\n        int particle = old[j];\n        if (particle < 0 || particle >= MAX_PARTICLES) continue;\n        fxParticle data = fxGetParticle(particle);\n        if (!data.disabled)\n        {\n            drawLineToNeighbor(above(particle), data.pos, p, w2c, fragColor);\n            drawLineToNeighbor(below(particle), data.pos, p, w2c, fragColor);\n            drawLineToNeighbor(left(particle), data.pos, p, w2c, fragColor);\n            drawLineToNeighbor(right(particle), data.pos, p, w2c, fragColor);\n        }\n    }\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "uvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nvoid fxCalcCamera(out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraLookAt = vec3(0.0, 0.0f, 0.0);\n    cameraPos\t= vec3(0, 1, 3);\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft  = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd)) * 0.5;\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-0.5*resolution.y / resolution.x * cameraLeft, 0.0),\n        vec4(-0.5*cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 1.0 - 0.5;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nconst float MAX_TEMP = 1000.0;\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat fxLinePointDist2(vec2 a, vec2 b, vec2 p)\n{\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return length2(p - b * h); // squared dist to segment\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define POS 0\n#define PREV 1\n#define NUM_PARTICLE_DATA_TYPES 2\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec3 pos;\n    vec3 prev;\n    bool pinned;\n    bool disabled;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, PREV), 0);\n\n    fxParticle particle;\n    particle.pos = particleData0.xyz;\n    particle.disabled = particleData0.w != 0.;\n    particle.prev = particleData1.xyz;\n    particle.pinned = particleData1.w != 0.;\n    \n    return particle;\n}\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case POS:  \n        return vec4(p.pos, p.disabled ? 1. : 0.);\n    case PREV:  \n        return vec4(p.prev, p.pinned ? 1. : 0.);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n\nconst float SIDE_LEN = 4.;\n\n// global variables, initialized via computeClothSide\nint CLOTH_SIDE = 0; // how many particles along each side of the square\nint MAX_PARTICLES = 0; // how many particles, total\n\n// computes the size of the cloth grid relative to the current resolution\nvoid computeClothSide(vec3 res)\n{\n    float particleUse = 0.7 * (1. - 0.6 * smoothstep(1000., 1200., res.y));\n    CLOTH_SIDE = int(sqrt(res.x * res.y / float(NUM_PARTICLE_DATA_TYPES)) * particleUse);\n    MAX_PARTICLES = CLOTH_SIDE * CLOTH_SIDE;\n}\n\n// These functions compute the neighbors from each particle, and -1 if there is\n// no neighbor in that direction. Crucially, they must continue to return -1 if\n// -1 is passed in, since we do not terminate the loop right away.\n\nint above(int i)\n{\n    return i >= 0 && i >= CLOTH_SIDE ? i - CLOTH_SIDE : -1;\n}\n\nint below(int i)\n{\n    return i >= 0 && i < (CLOTH_SIDE * (CLOTH_SIDE - 1)) ? i + CLOTH_SIDE : -1;\n}\n\nint left(int i)\n{\n    return i >= 0 && (i % CLOTH_SIDE) != 0 ? i - 1 : -1;\n}\n\nint right(int i)\n{\n    return i >= 0 && (i % CLOTH_SIDE) != CLOTH_SIDE - 1 ? i + 1 : -1;\n}\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Computes the position of each particle.\n// ---------------------------------------------------------------------------------------\n\nconst vec3 GRAVITY = vec3(0,-1,0);\n\nconst float WIND_SPEED = 100.; // wind strength\nconst float WIND_CHANGE_RATE = .5; // wind change speed\nconst float WIND_RIPPLE = .01; // wind variance\nconst float EDGE_BREAK_LEN = 5.; // length over rest length before breaking\nconst float COMPRESSION_RESIST = .005; // stiffness\n\nvoid constraint(inout int nid, inout fxParticle p, float edgeLen)\n{\n    if (nid < 0) return;\n    \n    fxParticle n = fxGetParticle(nid);\n    \n    if (n.disabled)\n    {\n        nid = -1;\n        return;\n    }\n    \n    vec3 deltaPos = n.pos - p.pos;\n    float len = length(deltaPos);\n    vec3 dir = deltaPos / len;\n    \n    float error = len - edgeLen;\n    \n    if (error < 0.) error *= COMPRESSION_RESIST;\n    if (distance(p.prev, n.pos) > edgeLen * EDGE_BREAK_LEN) p.disabled = true; // fragile cloth\n    \n    float f = n.pinned ? 1.0 : .7;\n    p.pos += dir * error * f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    computeClothSide(iResolution);\n    if(id>=MAX_PARTICLES) return;\n\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n\n    fxParticle p = fxGetParticle(id);\n    \n    if (!p.pinned && !p.disabled)\n    {\n        p.prev = p.pos;\n        p.pos += p.pos - p.prev + GRAVITY; // verlet\n        p.pos.z += WIND_SPEED * sin((float(id % CLOTH_SIDE) * WIND_RIPPLE + iTime * WIND_CHANGE_RATE)); // wind\n\n        // edge constraints\n        int a, b, l, r;\n        a = b = l = r = id;\n        \n        float EDGE_LEN = SIDE_LEN / float(CLOTH_SIDE);\n        float CARDINAL_ITERATIONS = 45.;\n        for (float i = 1.; i < CARDINAL_ITERATIONS; ++i)\n        {\n            a = above(a);\n            b = below(b);\n            r = right(r);\n            l = left(l);\n\n            float sLen = EDGE_LEN * i;\n            constraint(a, p, sLen);\n            constraint(b, p, sLen);\n            constraint(r, p, sLen);\n            constraint(l, p, sLen);\n        }\n\n#define DIAGONAL_CONSTRAINTS 1\n\n#if DIAGONAL_CONSTRAINTS\n        int al, ar, bl, br;\n        al = ar = bl = br = id;\n        \n        float DIAGONAL_ITERATIONS = 25.;\n        for (float i = 1.; i < DIAGONAL_ITERATIONS; ++i)\n        {\n            ar = above(right(ar));\n            al = above(left(al));\n            br = below(right(br));\n            bl = below(left(bl));\n\n            float dLen = EDGE_LEN * i * sqrt(2.);\n            constraint(al, p, dLen);\n            constraint(ar, p, dLen);\n            constraint(bl, p, dLen);\n            constraint(br, p, dLen);\n        }\n#endif // DIAGONAL_CONSTRAINTS\n    }\n    \n    // Reset particles that have gotten too old\n    if (iFrame == 0 || state.x < 0.)\n    {   \n        float x = float(id % CLOTH_SIDE) / float(CLOTH_SIDE) - 0.5;\n        float y = 0.5 - float(id)/float(CLOTH_SIDE*CLOTH_SIDE);\n        p.pos = vec3(x + y, x - y, 0.) * SIDE_LEN / sqrt(2.);\n        p.prev = p.pos;\n        \n        // pin sides\n        p.pinned = id < CLOTH_SIDE || id >= (CLOTH_SIDE - 1) * CLOTH_SIDE || (id % CLOTH_SIDE) == 0 || (id % CLOTH_SIDE) == (CLOTH_SIDE - 1);\n        //if (id % (CLOTH_SIDE / 10) == 0 && (id / CLOTH_SIDE) % (CLOTH_SIDE / 10) == 0) p.pinned = true; // quilt pinning\n        p.disabled = false;\n    }\n    \n    bool del = false;\n    vec2 from, to;\n    if (iMouse.z > 0. && iMouse.w < 0.)\n    {\n        // mouse input\n        from = vec2(2.*iResolution.x/iResolution.y, 2.) * state.yz / iResolution.xy - vec2(iResolution.x/iResolution.y, 1.);\n        to = vec2(2.*iResolution.x/iResolution.y, 2.) * iMouse.xy / iResolution.xy - vec2(iResolution.x/iResolution.y, 1.);\n        del = true;\n    }\n    else if (state.yz == vec2(0) && state.w > 0.5)\n    {\n        // attract mode\n        from = vec2(sin((iTime - iTimeDelta) * 2.), cos((iTime - iTimeDelta) * 5.2)) * vec2(iResolution.x / iResolution.y, 1.) * 0.9;\n        to = vec2(sin(iTime * 2.), cos(iTime * 5.2)) * vec2(iResolution.x / iResolution.y, 1.) * 0.9;\n        del = sin(iTime * 23.) > 0.2;\n    }\n\n    if (del)\n    {\n        vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n        fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n        mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n        mat4 w2c = inverse(c2w);\n        \n        vec3 posCamera = (w2c * vec4(p.pos,1.0)).xyz;\n        posCamera.xy = posCamera.xy / posCamera.z;     \n        \n        float dist2 = fxLinePointDist2(from, to, posCamera.xy);\n\n        if (dist2 < 0.0005) p.disabled = true;\n    }\n\n    fragColor = fxSaveParticle(p, dataType);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Originally derived, many shaders ago, from:\n// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_)\n{\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nfloat distance2Particle(int id, vec2 fragCoord, mat4 w2cNew)\n{\n    if(id==-1) return 1e20;\n    vec4 worldPos = fxGetParticleData(id, POS);\n    if (worldPos.w != 0.) return 1e20;\n    vec3 screenPos = (w2cNew * vec4(worldPos.xyz,1.0)).xyz;\n    screenPos.xy = screenPos.xy / screenPos.z;\n    vec2 delta = (screenPos.xy)-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n   \tivec2 iFragCoord = ivec2(fragCoord);\n    computeClothSide(iResolution);\n    if(iFragCoord == ivec2(0))\n    {\n        // Reset if resolution changes\n        vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n        if (iFrame == 0 ||\n            iResolution.x * iResolution.y != abs(state.x) ||\n            keyDown(KEY_SPACE) ||\n            state.w > 30.)\n        {\n            state = vec4(-iResolution.x * iResolution.y, 0.0, 0.0, 0.0);\n        }\n        else\n        {\n            state.x = abs(state.x);\n        }\n        \n        if (iMouse.z > 0.)\n        {\n            state.yz = iMouse.xy;\n        }\n        \n        if (state.yz == vec2(0))\n        {\n            state.w += iTimeDelta;\n        }\n        \n        fragColor = state;\n        return;\n    }\n    \n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    // camera-to-world and world-to-camera transform\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n\n    ivec4 old   = fxGetClosest( iFragCoord );      \n    for(int j=0; j<4; j++){\n        int id = old[j];\n        float dis2 = distance2Particle(id, p, w2c);\n        insertion_sort( new, dis, id, dis2 );\n        \n        // randomly check one of the neighbors of the particle, it's likely to be of interest\n        int nid;\n        switch((iFrame + int(j)) % 4)\n        {\n            case 0: nid = above(id); break;\n            case 1: nid = below(id); break;\n            case 2: nid = left(id); break;\n            case 3: nid = right(id); break;\n        }\n        \n        if (nid >= 0)\n        {\n            float dis2 = distance2Particle(nid, p, w2c);\n            insertion_sort( new, dis, nid, dis2 );\n        }\n    }\n\n    uint searchRange = 15u;\n    uint searchCount = 32u;\n    \n    for(uint i=0u; i<searchCount; ++i)\n    {\n        uvec4 h0 = hash(uvec4(fragCoord, fragCoord) * i);\n\n        ivec4 old   = fxGetClosest( iFragCoord + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n        for(int j=0; j<1; j++){\n            int id = old[j];\n            float dis2 = distance2Particle(id, p, w2c);\n            insertion_sort( new, dis, id, dis2 );\n        }        \n    }\n\n    int searchIterations = 1;\n    if (iFrame < 5)\n    {\n        searchIterations = 100;\n    }\n    for(int k = 0; k < searchIterations; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n\n        //pick random id of particle\n        int id = int(h*float(MAX_PARTICLES));\n        insertion_sort(new, dis, id, distance2Particle(id, p, w2c));\n    }\n    \n    fragColor = vec4(new);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKBW3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1214, 1214, 1289, 1320, 1974], [1976, 1976, 2060, 2060, 2214], [2216, 2216, 2273, 2273, 3501]], "test": "untested"}
{"id": "7lVfWG", "name": "Outpainting experiment #6", "author": "sh1boot", "description": "Attempt at painting over occluded data with some vaguely plausible surrounding context, but also to shovel some jumbled mess in there to agitate the AI which I mean to run over the top.\n\nkeys 0-9 toggle stuff.", "tags": ["inpainting", "outpainting"], "likes": 5, "viewed": 279, "published": 3, "date": "1665444317", "time_retrieved": "2024-07-30T16:26:55.408091", "image_code": "#define MAX_WARP_ITERATIONS 4\n#define MAX_PATCH_ITERATIONS 24\n#define toggle(n) texelFetch(iChannel3, ivec2(48+n,2),0).x\n#define WARP_HIGHLIGHT (toggle(1) * 0.5 * vec4(0.0, 0.0, 1.0, 1.0))\n#define PATCH_HIGHLIGHT (toggle(2) * 0.5 * vec4(1.0, 0.0, 1.0, 1.0))\n#define OOB_HIGHLIGHT (toggle(3) * 0.5 * vec4(1.0, 1.0, 0.0, 1.0))\n#define CUT_HIGHLIGHT (toggle(0) * 0.5 * vec4(0.0, 1.0, 0.0, 1.0))\n\nfloat ActualCutout(vec2 uv) {\n    return textureLod(iChannel0, uv, 0.0).a;\n}\n\nfloat ErodedCutout(vec2 uv)\n{\n    float alpha = textureLod(iChannel0, uv, 1.5).b;\n    // This is just to make certain we get 0 in untouchable space:\n    alpha *= ActualCutout(uv);\n    return clamp(3.0 * alpha - 2.0, 0.0, 1.0);\n}\n\nvec4 GetImage(vec2 uv) {\n    return textureLod(iChannel1, uv, 0.0) * ErodedCutout(uv);\n}\n\nfloat AlphaForGradient(vec2 uv) {\n    // Fun effect: low LOD here lets noise bleed through from the\n    // random sampling used in the blur generation.\n    return textureLod(iChannel0, uv, 3.5).g;\n}\n\nvec2 AlphaGradient(vec2 uv, float eps) {\n    vec3 o = vec3(-eps, eps, 0.0);\n    float up = AlphaForGradient(uv + o.zx);\n    float dn = AlphaForGradient(uv + o.zy);\n    float lf = AlphaForGradient(uv + o.xz);\n    float rt = AlphaForGradient(uv + o.yz);\n\n    return vec2(rt - lf, dn - up) / eps;\n}\n\nvec4 GetBackfill(vec2 uv, float fade, vec4 highlight) {\n    vec2 edges = smoothstep(0.0, 0.02, uv)\n               * smoothstep(0.0, 0.02, 1.0-uv);\n    float edge = edges.x * edges.y;\n    vec4 colour = GetImage(uv) * edge * fade;\n\n    if (colour.a >= 0.1) {\n        colour = highlight + colour * (1.0 - highlight.a);\n    }\n    if (edge < 0.99) {\n        colour = colour + OOB_HIGHLIGHT * (1.0 - colour.a);\n    }\n    return colour;\n}\n\nvec4 GetWarpBackfill(vec2 uv, float gen) {\n    const float eps = 0.02;\n    vec2 g = AlphaGradient(uv, eps);\n    float base = AlphaForGradient(uv);\n    float len = length(g);\n    float alpha = pow(0.7, gen);\n#if 1\n    len = 0.04 * (gen + 1.0);\n    //len *= base * 2.0;\n    // TODO: bleed some `base` into `alpha` somehow.\n //   alpha *= (base + 3.0) / 4.0;\n#else\n    len += gen * 0.01;\n    len *= 1.0 / 64.0;\n#endif\n    uv += normalize(g) * len;\n\n    return GetBackfill(uv, alpha, WARP_HIGHLIGHT);\n}\n\nvec4 GetPatchBackfill(vec2 uv, float gen) {\n    float t = gen * 6.283185307 + fract(iTime * gen * 0.001);\n    float r = pow(0.975, gen);\n    vec2 c = 0.5 - (0.5 - vec2(hash(gen, 1.0), hash(gen, 2.0))) * 0.7;\n    uv -= c;\n    uv = uv * mat2x2(cos(t), sin(t), -sin(t), cos(t)) * r;\n    uv += c;\n\n    float th = (dot(uv, vec2(3.5, -3.5)) + gen + fract(iTime * 0.3)) * 6.28;\n    uv += vec2(cos(th), sin(th)) * 0.02;\n\n    return GetBackfill(uv, 1.0 - pow(0.7, gen + 1.0), PATCH_HIGHLIGHT);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec4 col = vec4(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)), 1.0);\n\n    vec4 tex = GetImage(uv);\n\n    for (int i = 0; i < MAX_WARP_ITERATIONS; ++i) {\n        if (tex.a >= 0.99) break;\n        vec4 back = GetWarpBackfill(uv, float(i) * 1.618033989);\n        tex = tex + back * (1.0 - tex.a);\n    }\n    for (int i = 0; i < MAX_PATCH_ITERATIONS; ++i) {\n        if (tex.a >= 0.99) break;\n        vec4 back = GetPatchBackfill(uv, float(i) * 1.618033989);\n        tex = tex + back * (1.0 - tex.a);\n    }\n    col = tex + col * (1.0 - tex.a);\n    vec4 cut = CUT_HIGHLIGHT * (1.0 - ActualCutout(uv));\n    col = cut + col * (1.0 - cut.a);\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float GetAlpha(vec2 uv)\n{\n    vec3 col = texture(iChannel0, uv).rgb;\n    float alpha = smoothstep(0.2, 0.35, col.g - max(col.r, col.b));\n#if 0\n    uv = (uv - .5) * rotmat(iTime * 0.4);\n    if (0.35 < uv.y && uv.y < 2.4) alpha = 0.0;\n#endif\n    return alpha;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(GetAlpha(uv));\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define NUM_TAPS 15\n\nvec2 pdf(vec2 x) {\n#if 1\n    // pdf for s=0.1667: `sum(uniform(-.5,.5, 3)/3)`\n    return 2.39365*exp(-18. * x * x);\n#else\n    // pdf for s=0.144: `sum(uniform(-.5,.5, 4)/4)`\n    return 2.77043 * exp(-24.1126 * x * x);\n#endif\n}\n\n\nfloat nsample(vec2 uv, float r) {\n    float seed = r;\n\n    float sum = 0.0;\n    for (int i=0; i < NUM_TAPS; i++)\n    {\n        vec2 is = vec2(float(i) * 0.5050505, seed);\n        vec2 ofs = (hash2(uv + is) + hash2(uv + is + 1.0)\n                  + hash2(uv + is + 2.0)) * 0.333333 - 0.5;\n        float lod = log2(length(iChannelResolution[0].xy * 2.0 * r / pdf(ofs)));\n        ofs *= 2.0 * r;\n        sum += textureLod(iChannel0, uv + ofs, lod).a;\n    }\n\n    return sum / float(NUM_TAPS);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(\n        0.0,//nsample(uv, 0.4),\n        nsample(uv, 0.1),\n        nsample(uv, 0.04),\n        textureLod(iChannel0, uv, 0.0).a\n    );\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "mat2x2 rotmat(float a)\n{\n    float c = cos(a), s = sin(a);\n    return mat2x2(c, s, -s, c);\n}\n\nfloat hash(vec2 uv) {\n    // Seeing some weird discontinuity coming from overflow cases -- this'll fix it!\n    uv = vec2(ivec2(floatBitsToUint(uv.x), floatBitsToUint(uv.y))) / 65537.0;\n\n    const vec2 swiz = vec2(12.9898, 78.233);\n    return fract(sin(dot(uv, swiz)) * 43758.5453);\n}\n\nfloat hash(float fx, float fy) {\n    return hash(vec2(fx, fy));\n}\nfloat hash(float f) {\n    return hash(vec2(f));\n}\n\nvec2 hash2(vec2 uv) {\n    return vec2(hash(uv), hash(uv.yx + 1.618033989));\n}\n\nvec2 hash2(float fx, float fy) {\n    return hash2(vec2(fx, fy));\n}\nvec2 hash2(float f) {\n    return hash2(vec2(f));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVfWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[393, 393, 422, 422, 469], [471, 471, 500, 500, 699], [701, 701, 725, 725, 789], [791, 791, 824, 942, 989], [991, 991, 1031, 1031, 1286], [1288, 1288, 1343, 1343, 1719], [1721, 1721, 1763, 1763, 2219], [2221, 2221, 2264, 2264, 2707], [2709, 2709, 2766, 2816, 3565]], "test": "untested"}
{"id": "Nl2Gzw", "name": "Julia Islands", "author": "golinad", "description": "Interactive water surface simulation, regarding landscape.", "tags": ["2d", "fractal", "simulation", "refraction", "water", "drops"], "likes": 9, "viewed": 312, "published": 3, "date": "1665440464", "time_retrieved": "2024-07-30T16:26:56.236875", "image_code": "float bumpiness = 1.0;\n\nvec3 norm(in vec2 fragCoord)\n{\n    float dX = texture(iChannel0, (fragCoord + vec2(1,0))/iResolution.xy).x - texture(iChannel0, (fragCoord + vec2(-1,0))/iResolution.xy).x;\n    float dY = texture(iChannel0, (fragCoord + vec2(0,1))/iResolution.xy).x - texture(iChannel0, (fragCoord + vec2(0,-1))/iResolution.xy).x;\n\n    return normalize( vec3(-dX * bumpiness, -dY * bumpiness, 1.0) );\n}\n\nvec3 landColor(float h)\n{\n    float hn = h*0.5 + 0.5;\n    return vec3(0.1, 0.3, 0.4) + vec3(hn, 0.7*hn, 0.4*hn);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    vec3 n = norm(fragCoord);\n    vec3 c = vec3(1.0) * dot(n, normalize(vec3(-1.0, 1.0, 0.0)));\n    float h = texture(iChannel0, uv).z;\n    if(h < 0.0) {\n        float rH = texture(iChannel0, uv+n.xy*0.5*h).z;\n        fragColor = vec4(c.xyz, 1.0) + vec4(landColor(rH),1.0);\n    } else {\n        fragColor = vec4(landColor(h),1.0);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// water simulation\n// waterlevel at 0.0\n// xyzw: h1, h2, landscape height, 0\n\nfloat waterlevel = 0.5;\nfloat pi = 3.14159265359;\n\n\nfloat hit(in vec2 fragCoord) {\n    float h = smoothstep(2.0, 1.0, distance(fragCoord, iMouse.xy));\n        \n    return h;\n}\nfloat rain(in vec2 fragCoord) {\n    vec2 dropPos = vec2((sin(iTime*pi*161.8)*0.5+0.5)*iResolution.x, (cos(iTime*pi*100.0)*0.5 + 0.5)*iResolution.y);\n    float h = smoothstep(2.0, 1.0, distance(fragCoord, dropPos.xy));\n    return h;\n    //return smoothstep(0.99, 1.0, sin(fragCoord.x*iTime)*cos(fragCoord.y*iTime))*1.0;\n}\n\nvec2 simStep(in vec2 fragCoord) {\n   if(texture(iChannel0, fragCoord/iResolution.xy).z < 0.0) {\n       return vec2(((texture(iChannel0, (fragCoord + vec2(-1,0))/iResolution.xy).x +\n           texture(iChannel0, (fragCoord + vec2( 1,0))/iResolution.xy).x +\n           texture(iChannel0, (fragCoord + vec2( 0,-1))/iResolution.xy).x +\n           texture(iChannel0, (fragCoord + vec2(0,1))/iResolution.xy).x) * 0.5 -\n           texture(iChannel0, fragCoord/iResolution.xy).y) * 0.99,\n           texture(iChannel0, fragCoord/iResolution.xy).x);\n   } else {\n       return vec2(0.0, texture(iChannel0, fragCoord/iResolution.xy).x);\n   }\n}\n\nfloat landscapeSin(in vec2 fragCoord) {\n    return sin(fragCoord.x*10.0)*cos(fragCoord.y*10.0)-0.5;\n}\n\n// Juliaset\nconst int maxIt = 16;\n \nvec2 cSqr(vec2 c){\n    return vec2(c.x*c.x - c.y*c.y, 2.0*c.x*c.y);\n}\n\nfloat landscapeJulia(in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)*2.0;\n    int it = 0;\n    vec2 z = uv;\n    vec2 c = vec2(-0.7, 0.6);\n    float minD = length(z);\n    for(int i=0; i< maxIt;i++){\n        z = cSqr(z) + c;\n        if(length(z) > 50.0) break;\n        it++;\n        minD = min(length(z), minD);\n    }\n    // Time varying pixel color\n    \n    return -1.0 + 1.5*float(it)/float(maxIt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 pointer = iMouse.xy/iResolution.xy;\n    \n    // initialize landscape\n    if(iFrame == 0 || iMouse.w > 0.5) {\n        fragColor.z = landscapeJulia(uv);\n    } else {\n        fragColor.z = texture(iChannel0, fragCoord/iResolution.xy).z;\n    }\n    \n    // Time varying pixel color\n    vec2 height = simStep(fragCoord) + hit(fragCoord) + rain(fragCoord);\n    //float height = sin(fragCoord.x*0.1);\n\n\n    // Output to buffer\n    fragColor.xy = vec2(height.x, height.y);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2Gzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 54, 54, 408], [410, 410, 435, 435, 524], [526, 526, 583, 633, 1037]], "test": "untested"}
{"id": "NlyBWt", "name": "Reims cathedral maze", "author": "FabriceNeyret2", "description": "reference:  [url]  https://fr.m.wikipedia.org/wiki/Fichier:Labyrinthe_de_la_cath%C3%A9drale_de_Reims.svg  [/url]\n[url] https://en.wikipedia.org/wiki/Labyrinth_of_the_Reims_Cathedral [/url]\nIt is also the official logo for French historical monuments.", "tags": ["logo", "maze", "short", "reproduction"], "likes": 20, "viewed": 273, "published": 3, "date": "1665439499", "time_retrieved": "2024-07-30T16:26:57.044716", "image_code": "// 533 chars in OpenGL. +38 chars on Windows angle to turnaround bugs\n\n#define S(v)  step( .26, abs(fract(v+.5)-.5) )   // strips\n//#define S(v)clamp( R.y*(abs(fract(v+.5)-.5)-.25) ,0.,1.)\n#define o     V = abs(U),            /* octogonal coordinates */ \\\n              W = V.y > V.x ?  V.yx : V,                         \\\n              X = C(W) ? W : ( W + vec2(W.y,-W) )/1.41\n#define C(W)     ( W.y/W.x < .41 )               // is horizontal or vertical octant\n                                                 // Windows Angle bug. on OpenGL just C is ok\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = 20.*( u+u - R ) / R.y, o, w=W;    // y and w to turnaround Windows Angle bugs\n    float x = X.x, y=x;\n    O *= 0.;\n    O += y<2.5 ? 1.                              // === inner white  \n       : y<14.25 && min(V.x,V.y)< 7.05           // === central shape\n       ?                                         // --- maze hairpin turn\n        V.x < V.y ? U.y>0.|| U.x>-.25 ? x++ : x  //     specific offsets\n                  : U.x>0. ? x>10. ? x-- :x : x > 7. ? x-- : x, \n        C(W) &&                                     // horiz & vertic octants\n          (   U.y < -V.x && X.y<1.75             // --- maze access\n              && ( U.x>0. ? x<5.74               //     inside access\n                          : x>12.25 && x<13.74 ) //     outside access\n           || W.y<.74 && x > 3. && mod( x-1.27, V.x<-U.y ?2.:3. ) < 1.47  // hairpin turns \n          )  ? S(W.y)                            // insert coridor\n             : S(x)                              // --- main octogonal strips \n       :\n         -.01;      // on OpenGL you\n   if(O.x<0.) O+=   // can delete these 2 lines\n        !C(w)                                    // === corner shapes\n          ? U = V-11.75, o, x = X.x,\n            U++,                                 // offset for neck start\n            U.x < -.4*U.y && U.y < -.4*U.x  \n                   ? S((U.x-U.y)/1.41)           // neck\n               : x>1.5 && x<5.5 \n                   ? S(x)                        // corner octogonal strips\n               :     1.                          // inner & outer white\n          : 1.;                                  // === main horiz & vertic outer white\n          \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlyBWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[512, 557, 595, 595, 2290]], "test": "untested"}
{"id": "7tGfDt", "name": "Foresty Mountain", "author": "rcargou", "description": "Not sure if some biomes actually looks like that, but I think it looks pretty cool", "tags": ["3d", "terrain", "sdf", "fbm", "tree"], "likes": 14, "viewed": 368, "published": 3, "date": "1665435356", "time_retrieved": "2024-07-30T16:26:57.985200", "image_code": "#define AA 1   // make this 2 or 3 for antialiasing\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat threeDist(vec3 p, float g, out float mat) {\n\n    p.xz *= rotate2d(3.14 / 4.);\n    p*= 2.;\n    p.xz *= 1.;\n    g*=1.0;\n    \n    float rep = .07f;\n    vec3 id = floor(p / rep);\n    p.y = g;\n    float height = .0f;\n    p.xz = mod(p.xz, rep) - vec2(rep / 2.0f);\n    p.xz *=1.5;\n    if (hash22(id.xz).x  < 0.4)\n        return 10000000.;\n    p.y *= (1.+hash22(id.xz).y * 1.6);\n    float d = sdEllipsoid(p, vec3(.035, .1, .035) );\n    mat = 12.;\n    if (hash22(id.xz).x  < 0.6)\n        mat = 13.;\n    return d;\n   \n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n    float tmat;\n    float h = pos.y  + -.2f + (fbm((vec3(1.0, .0, 1.0) * pos) / 2.0f)) * 3.0f;\n    vec2 three = vec2(threeDist(pos, h, tmat), 3.0f);\n    three.y = tmat;\n    if (pos.y  - h < -1.3f)\n        res = opU(three, res);\n    return opU(res, vec2(h, 2.0f));\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 40.0;\n    if (rd.y > .05)\n        return vec2(100., .0);\n    // raymarch primitives   \n    {\n    \n        float t = tmin;\n        for( int i=min(iFrame, 0); i<200 && t<tmax; i++ )\n        {\n            vec3 p = ro + rd * t;\n            vec2 h = map( p );\n            if( abs(h.x)<(0.001*t) )\n            {\n                res = vec2(t,h.y); \n                 break;\n            }\n            if (p.y < 0.)\n                h.x *= 0.4;\n            t += i > 60 ? h.x * 1.0: h.x * 1.2;\n        }\n    }\n    \n    return res;\n}\n\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\nvec3 make_fog(vec3 pos, vec3 rd) {\n    float h = fbm(pos) - .2;\n    float s1 = smoothstep(0.6 + h, 0.7 + h, -pos.y);\n    float s2 = smoothstep(0.8 + h, 0.7 + h, pos.y);\n    vec3 col = vec3(.0);\n    float acc = .0;\n  \n    pos += rd * .2f;\n    float dy = 10.0f - (100.0f * pos.y);\n    acc = s2 * s1 / 10.* (( fbm(pos * 2.3f)));\n    return vec3(acc);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{ \n    vec3 col = vec3(.0f);\n    vec3 lig = vec3(vec3(-150., 35., 20.0) );\n    vec3 ligCol = vec3(.6f, .3f, .2f);\n    vec3 back = vec3(.7f, .3f, .1f + rd.y);\n    vec3 amb = vec3(.9f, .2f, .4f);\n    vec3 nor;\n    float fog = .0f;\n    \n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 pos = ro + rd * t;\n    vec3 ldir = normalize(vec3(- lig));\n    fog = 1.0-exp( -0.0002*t*t*t );\n    col = vec3(.2f, .7f, .1f) / 40.;\n    nor = calcNormal(pos);\n    float ao = calcAO(pos, nor);\n    float shadow_offset = 0.1;\n\n    float shadow = .2 + .8 * calcSoftshadow(pos, -ldir, shadow_offset, 15.5);\n    float ndotl = max(.05f, dot(ldir, -nor));\n    vec3 sky_term =  back * smoothstep(0.5, 1.0, max(0., nor.y) / 1.0f) * (max(.2, shadow));\n     amb += sky_term;\n    if (res.y == 2.0f) { // moutain\n        float mat = smoothstep(-1.1, -1.34, pos.y * max(0., nor.y) );\n        \n \t\tvec3 albedo =mix(texture(iChannel0, vec2(pos.xz * 2.)).xyz, texture(iChannel1, vec2(pos.xz*4.)).xyz * vec3(.3f, 1.9f, .1f), mat);\n        col =  albedo * ligCol * shadow * ndotl  + (ao *.2f) * amb;\n    }\n    else if (res.y == 12.0f || res.y == 13.0f ) {\n     \tvec3 albedo = vec3(.2f, .7f, .1f) / 4.;\n \n        col = shadow * albedo * ligCol * ndotl + (ao *.2f) * amb;\n    } else if (rd.y > -.2){\n        col = back;\n    }\n    col = mix(col, back, fog);  \n    col = mix(col, vec3(1.0), make_fog(pos, rd).x);\n    \n    pos = ro;\n    col += vec3(.6, .6, .1) *.2 / (.1 + length( uv.xy - vec2(-1.2, .6) ));\n\t\n    return vec3(col);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = vec2(0);//iMouse.xy/iResolution.xy;\n\tfloat time = .0f; //iTime;\n\n    // camera\t\n    vec3 ro = vec3(.0f, .0f, -3.0  + iTime + 10.);\\\n      vec3 ta = vec3( -0.5, -0.4, 0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        \n        p.y += cos(p.x)  / 5.;\n        // ray direction\n        \n        vec3 rd = normalize( vec3(p.xy,2.0) );\n        // render\t\n        vec3 col = render( ro, rd, p );\n\n\t\t// gamma\n        col = pow( col, vec3(.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvec2 hash22( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(175.1,311.7)),\n             dot(p,vec2(260.5,752.3)));\n    return fract(sin(p+455.)*18.5453);\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p/1.3 ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p );\n    f += 0.00525*noise( p*4. );\n    //return f;\n//         return exp( pow(f*2., 0.5 - .2*smoothstep(.8, 0.45, f) ) -.5) - 1.1;\n     return ( (1. - .2*smoothstep(.6, 0.9, 1.-f)) * pow(f*2., 0.5 - .2*smoothstep(.8, 0.45, f) ) -.45);\n//    return f*f* (1. + .1 * smoothstep(.8, 0.45, f) )+.3;\n  //  return 1.1*log(1. + pow(f, 1.2)) + .1;\n}\n\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[223, 223, 251, 251, 337], [339, 339, 388, 388, 854], [856, 856, 881, 881, 1181], [1210, 1210, 1250, 1250, 1843], [1846, 1891, 1969, 1992, 2333], [2335, 2381, 2413, 2413, 2623], [2625, 2625, 2667, 2667, 2983], [2986, 2986, 3020, 3020, 3335], [3337, 3337, 3388, 3388, 4907], [4909, 4909, 4961, 4961, 5138]], "test": "untested"}
{"id": "slyBDt", "name": "Ray plane distortion experiment", "author": "mrange", "description": "CC0: Ray plane distortion experiment\nTinkering with distorting ray plane intersections\nAn interesting experiment but feels lack something is lacking\n", "tags": ["distortion", "rayplane"], "likes": 12, "viewed": 321, "published": 3, "date": "1665434195", "time_retrieved": "2024-07-30T16:26:58.826950", "image_code": "// CC0: Ray plane distortion experiment\n//  Tinkering with distorting ray plane intersections\n//  An interesting experiment but feels lack something is lacking\n\n// Some constants to tinker with\n#define EDGES     5.0\n#define HUE_OFF   0.0\n#define SAT_SCALE 1.0\n\n\n\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff = HUE_OFF;\n\nconst vec3 skyCol     = HSV2RGB(vec3(hoff+0.50, SAT_SCALE*0.90, 0.25));\nconst vec3 skylineCol = HSV2RGB(vec3(hoff+0.70, SAT_SCALE*0.95, 0.5));\nconst vec3 sunCol     = HSV2RGB(vec3(hoff+0.80, SAT_SCALE*0.90, 0.5));\nconst vec3 diffCol1   = HSV2RGB(vec3(hoff+0.75, SAT_SCALE*0.90, 0.5));\nconst vec3 diffCol2   = HSV2RGB(vec3(hoff+0.65, SAT_SCALE*0.90, 0.5));\n\nconst vec3 sunDir1    = normalize(vec3(0., 0.05, -1.0));\n\nconst float lpf = -2.0; \nconst vec3 lightPos1  = lpf*vec3(+1.0, 1.0, 3.0);\nconst vec3 lightPos2  = lpf*vec3(-1.0, 1.0, 3.0);\n  \n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  float sf = 1.0001-max(dot(sunDir1, rd), 0.0);\n  col += skyCol*pow((1.0-abs(rd.y)), 8.0);\n  col += (mix(0.0025, 0.125, tanh_approx(.005/sf))/abs(rd.y))*skylineCol;\n  sf *= sf;\n  col += sunCol*0.00005/sf;\n\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(4, 8.0))-3.0;\n    \n    col += vec3(6.0)*sqrt(skylineCol)*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(2.0)*sqrt(skylineCol)*exp(-0.5*max(db, 0.0));\n  }\n\n  return clamp(col, 0.0, 10.0);;\n}\n\nvec3 boxCol(vec3 col, vec3 nsp, vec3 ro, vec3 rd, vec3 nnor, vec3 nrcol, vec3 nrrcol) {\n  float nfre  = 1.0+dot(rd, nnor);\n  nfre        *= nfre;\n\n  vec3 nld1   = normalize(lightPos1-nsp); \n  vec3 nld2   = normalize(lightPos2-nsp); \n\n  float ndif1 = max(dot(nld1, nnor), 0.0);\n  ndif1       *= ndif1;\n\n  float ndif2 = max(dot(nld2, nnor), 0.0);\n  ndif2       *= ndif2;\n\n  vec3 scol = vec3(0.0);\n  scol += diffCol1*ndif1;\n  scol += diffCol2*ndif2;\n  scol += 0.1*(skyCol+skylineCol);\n  scol += nrcol*0.75*mix(vec3(0.25), vec3(0.5, 0.5, 1.0), nfre);\n  scol += nrrcol*0.5*mix(vec3(0.95, 0.5, 1.0),vec3(0.25), nfre);\n\n  vec3 pp = nsp-ro;\n\n  col = mix(col, scol, smoothstep(100.0, 98.0, dot(pp, pp)));\n  \n  return col;\n}\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec3 render1(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n\n  // Distoring the rayplane intersection\n  \n  float f = length(rd.xy)/rd.z;\n  float off = -0.1*TIME-f;\n  float a = atan(rd.y, rd.x)+off;\n  const float mangle = TAU/EDGES;\n  float n = mod1(a, mangle);\n  float angle = n*mangle-off;\n  vec3 pnor = vec3(-1.0, 0.0, 0.0);\n  pnor.xy *= ROT(-angle);\n  \n  const float r = 1.5;\n  float pt  = rayPlane(ro, rd, vec4(pnor, r));\n  // Tinker with the plane normal\n  pnor.xy *= ROT(0.25*PI*a/mangle);\n  \n  vec3 pp   = ro+rd*pt; \n\n  vec3 pcol = vec3(0.0);\n  \n  vec3 pref = reflect(rd, pnor);\n  vec3 prefr= refract(rd, pnor, 0.9);\n  if (prefr == vec3(0.0)) {\n    prefr = pref;\n  }\n  vec3 rcol = render0(pp, pref);\n  vec3 rrcol= render0(pp, prefr);\n\n  col = boxCol(col, pp, ro, rd, pnor, rcol, rrcol);\n\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  const float fov = tan(TAU/(6.-0.5));\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n  const vec3 ro = vec3(0.0, 0.0, 5.0);\n  const vec3 la = vec3(0.0, 0.0, 0.);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = cross(ww,uu);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render1(ro, rd);\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  // Stupid tricks I learnt, saturates the colors\n  col -= 0.04*vec3(1.0, 2.0, 2.0);\n  col = aces_approx(col); \n  col = sRGB(col);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyBDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[595, 595, 617, 617, 763], [1630, 1730, 1749, 1749, 1836], [1838, 1945, 1971, 1971, 2155], [2157, 2217, 2245, 2311, 2387], [2389, 2482, 2524, 2524, 2571], [2573, 2691, 2718, 2718, 2794], [2796, 2796, 2828, 2828, 3419], [3421, 3421, 3508, 3508, 4135], [4137, 4137, 4176, 4176, 4301], [4303, 4303, 4335, 4335, 5110], [5112, 5112, 5133, 5133, 5483], [5485, 5485, 5540, 5540, 5826]], "test": "untested"}
{"id": "ftGfDc", "name": "sphere light bounce", "author": "ilia87", "description": "visualization of sound with bouncing light and spheres. If it doesn't play pause and start again.", "tags": ["raymarching"], "likes": 2, "viewed": 215, "published": 3, "date": "1665430354", "time_retrieved": "2024-07-30T16:27:00.130464", "image_code": "const vec3 spherePos = vec3(0.);\n//const vec3 lightSrc = vec3(-6.0,6,25.0);\nconst vec3 ambientColor = vec3(1.0,1.0,1.0);\n//const vec3 specularColor = vec3(1.0,1.0,1.0);\nconst float shininessVal = 15.0;\nconst float Ka = 0.1;\nconst float Kd = 0.6;\nconst float Ks = 0.4;\nconst float periodicity = 10.0;\nconst float lightDistPow = .6;\nconst float lightDistFact = 1.0/20.0;\n\nvec3 camPos;\nvec3 lightSrc;\n\n//float LightSphereDistFunc(vec3 pos, vec3 lightSrc)\n//{\n//    return length(pos - lightSrc);\n//}\n\nvec3 Phong(vec3 pos, vec3 N, vec3 camPos, vec3 diffuseColor, float lightIntensity)\n{\n    vec3 L = lightSrc-pos;\n    float lightDist = length(L);\n    L /= lightDist;\n    float lambertian = max(dot(N, L), 0.0);\n    float specular = 0.0;\n    if(lambertian > 0.0) {\n      vec3 R = reflect(-L, N);      // Reflected light vector\n      vec3 V = normalize(camPos-pos); // Vector to viewer\n      // Compute the specular term\n      float specAngle = max(dot(R, V), 0.0);\n      specular = pow(specAngle, shininessVal);\n    }\n    vec3 color = Ka * ambientColor +\n                   (Kd * lambertian * diffuseColor +\n                   Ks * specular * diffuseColor)*(lightIntensity*pow(lightDist * lightDistFact,-lightDistPow));                  \n    color = clamp(color,vec3(0.),diffuseColor);\n    return color;\n}\n\nvec3 GetSpherePos(float frame)\n{\n    int ycoord = int(mod(frame, iResolution.y));\n    vec4 texel = texelFetch(iChannel1,ivec2(32,ycoord),0);\n    float a = texel.y;\n    a *= sin(frame*0.001)*0.001;\n    vec3 v = spherePos - camPos;\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c,s,-s,c);\n    v.xy *= m;\n    return v + camPos;\n}\n\nfloat GetDist(vec3 pos)\n{\n    float pp = length(round((pos -spherePos)/periodicity) - lightSrc/periodicity);\n    int i = int(mod(float(iFrame) - pp*5.2, iResolution.y));\n    //float s = texelFetch(iChannel0, ivec2(0,i),0).x;\n    //float s = texelFetch(iChannel0, ivec2(10,i),0).y + texelFetch(iChannel0, ivec2(20,i),0).y + texelFetch(iChannel0, ivec2(30,i),0).y;\n    float s = texelFetch(iChannel1, ivec2(0,i),0).x;\n    //float s = texelFetch(iChannel0, ivec2(1,i),0).z;\n    //s = max(s,texelFetch(iChannel0, ivec2(20,i),0).z);\n    //s = max(s,texelFetch(iChannel0, ivec2(30,i),0).x);\n    //s = max(s,texelFetch(iChannel0, ivec2(40,i),0).y);\n    //s = smoothstep(0.0,3.,s);\n    s = smoothstep(0.0,0.15,s);\n    s = pow(s,4.);\n    s*=.2;\n    //s*=s*s*2.;\n    //s = smoothstep(0.1,1.0,s*3.);\n    //s = pow(s)*3.;\n    \n    //vec3 pp = pos/periodicity;\n    //vec3 si;\n    //vec3 sf = modf(pp,si);\n    vec3 p = mod(pos+vec3(periodicity*0.5),periodicity)-vec3(periodicity*0.5);\n    //TODO: Need to take into account the next cell in the periodicity.\n    p -= spherePos;\n    //p.y += 0.6 * texelFetch( iChannel0, ivec2(i,1), 0 ).x;\n    float sphereRadius = 1.0;\n    sphereRadius += s;//*s*120.6;\n    //sphereRadius += 0.3 * texelFetch( iChannel0, ivec2(i,1), 0 ).x; \n    float dist = length(p-spherePos) - sphereRadius;\n    //float dist = length(p-GetSpherePos(float(iFrame) - length(p-camPos)*5.5)) - sphereRadius;\n    \n    //float a = atan(p.y,p.x);\n    //float b = atan(p.z,length(p.xy));\n    //float sb = cos(b);\n    //dist -= cos(a*5.) *0.2 * sb*sb;\n    \n    return dist;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    const vec2 e = vec2(0.001,0.);\n    return normalize(GetDist(p) - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)));\n}\n\nfloat GetWaterCoeff(float frame)\n{\n    int ycoord = int(mod(frame, iResolution.y));\n    vec4 texel = texelFetch(iChannel1,ivec2(64,ycoord),0);\n    return texel.y;\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd, float dist0)\n{\n    vec3 pos = ro + rd*dist0;\n    for (int iStep = 0;iStep < 150;++iStep)\n    {\n        float ddist = GetDist(pos);\n        //float rotFactor = GetWaterCoeff(float(iFrame)-(pos.z-camPos.z)*6.) * sin(iTime - (pos.z-camPos.z)*4.5)*0.001*ddist;\n        //float rotFactor = GetWaterCoeff(float(iFrame)) * sin(iTime - (pos.z-camPos.z)*4.5)*0.001*ddist;\n        //float rotFactor = GetWaterCoeff(float(iFrame) - (pos.z-camPos.z)*20.)*0.001*ddist;\n        //float r = GetWaterCoeff(float(iFrame) - (pos.z-camPos.z)*4.)*0.001;\n        //rd.xy *= 1.-r;\n        //float c = cos(rotFactor);\n        //float s = sin(rotFactor);\n        //mat2 m = mat2(c,-s,s,c);\n        //rd.xy *= m;\n        pos += rd * ddist;\n        //if (ddist < 0.001)\n        //    break;\n        //else if (ddist > 1000.0)\n        //    break;\n    }\n    return pos;\n}\n\nvec3 GetLightColor(float frame)\n{\n    int ycoord = int(mod(frame, iResolution.y));\n    \n    //float timePeriodic = fract(iTime*0.04);\n    //vec4 lightSphereColor = vec4(hsv2rgb(vec3(timePeriodic,1.,1.)),1.);\n    float hue = 0.2*texelFetch(iChannel1,ivec2(0,ycoord),0).w;\n    vec3 c = vec3(hsv2rgb(vec3(hue,1.,1.)));\n    return c;\n}\n\nfloat GetLightIntensity(float frame)\n{\n    int ycoord = int(mod(frame, iResolution.y));\n    \n    //float timePeriodic = fract(iTime*0.04);\n    //vec4 lightSphereColor = vec4(hsv2rgb(vec3(timePeriodic,1.,1.)),1.);\n    //float l= texelFetch(iChannel1,ivec2(32,ycoord),0).y;\n    float l1 =texelFetch(iChannel0,ivec2(64,ycoord),0).w;\n    //float l2 = texelFetch(iChannel1,ivec2(32,ycoord),0).y;\n    float l2 = texelFetch(iChannel1,ivec2(32,ycoord),0).y;\n    float l = l1*0.4 + l2*0.6;\n    return l*l;\n}\n\nvec3 GetLightPos(float frame)\n{\n    int ycoord = int(mod(frame, iResolution.y));\n    \n    //float timePeriodic = fract(iTime*0.04);\n    //vec4 lightSphereColor = vec4(hsv2rgb(vec3(timePeriodic,1.,1.)),1.);\n    //float t = texelFetch(iChannel1,ivec2(0,ycoord),0).w;\n    //vec3 lightSrc;\n    //lightSrc.xy = (iMouse.xy*2.0 - iResolution.xy) / iResolution.x;\n    //lightSrc.x = cos(t);\n    //lightSrc.y = 0.3*sin(t);\n    //lightSrc.z = 1.0;\n    \n    vec3 lightSrc = texelFetch(iChannel1,ivec2(1,ycoord),0).xyz;\n    lightSrc.z += 1.3;\n    lightSrc.z *=2.*lightSrc.z;\n    lightSrc *= 12.5;\n    lightSrc.xy *= 0.5;\n    lightSrc += camPos;\n    return lightSrc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    camPos = vec3(-2,-2,-5.) + 2.*(iTime - 5. * cos(iTime*0.1)) * vec3(-1.5,1.2,0.8);\n    lightSrc = GetLightPos(float(iFrame));\n    vec3 rd;\n    rd.xy = (fragCoord*2.0 - iResolution.xy) / iResolution.x;\n    rd.z = 1.0;\n    //rd.xz *= R;\n    vec3 ro = rd + camPos;\n    rd = normalize(rd);\n    vec3 p = RayMarch(ro,rd,0.);\n    vec3 pc = p - camPos;\n    vec3 lc = lightSrc - camPos;\n    vec3 pl = p - lightSrc;\n    float finalDist = GetDist(p);\n    if (finalDist<0.01)\n    {\n        vec3 n = GetNormal(p);\n        float colorFrame = float(iFrame) - length(pl)*0.5;\n        vec3 diffuseColor = GetLightColor(colorFrame);\n        float lightIntensity = 0.7 * GetLightIntensity(colorFrame) + 0.3;\n        fragColor = vec4(Phong(p,n,camPos,diffuseColor,lightIntensity),1.);\n    }\n    else\n    {\n        fragColor = vec4(0,0,0,1);\n    }\n    \n    //fragColor = mix(fragColor,vec4(0.1,0.1,0.1,1.0),length(pos)/1000.0);\n    fragColor.xyz *= smoothstep(0.,1.,pow(length(pc)/100.0,-0.5));\n    \n    //fragColor.z += pow(lightCloseness/8.0,5.0);\n    //if (length(lightSrc) < length(p))\n    \n    //if ( length(lc) < length(pc) )\n    \n    if ( lc.z < pc.z )\n    {\n        vec4 lightSphereColor = vec4(GetLightColor(float(iFrame)),1.);\n        float lightIntensity = GetLightIntensity(float(iFrame));\n        //lightSphereColor = mix(lightSphereColor,vec4(1.),lightIntensity*.6);\n        float minLightDist = length(cross(pc,lc))/length(pc);\n        minLightDist = smoothstep(.4*(lightIntensity*.4+.6),4.5,minLightDist);\n        //fragColor.xy *= 1.0-lightDistFact;\n        //fragColor.z += lightDistFact;\n        fragColor = mix(lightSphereColor*(.9 + 0.1*lightIntensity),fragColor,pow(minLightDist,(.1+.3*lightIntensity)*(0.1*lightIntensity + .5)));\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define windowWidth 8\n#define windowWidth2 32\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n\n    int soundBuffLen = textureSize(iChannel1,0).x;\n    \n    float soundBuffTime = float(soundBuffLen) / iSampleRate;\n    int ycoord = iFrame % int(iResolution.y);\n    if (ycoord != int(fragCoord.y))\n        return;\n    if (int(fragCoord.x) >= soundBuffLen )\n        return;\n    int pixelX = int(fragCoord.x);\n    float s  = texelFetch(iChannel1,ivec2(pixelX,0),0).x;\n    float sums = s;\n    float maxs = s;\n    for ( int i=1;i<windowWidth;++i)\n    {\n        float s  = texelFetch(iChannel1,ivec2(pixelX + i, 0),0).x;\n        sums += s;\n        maxs = max(maxs,s);\n    }\n    float maxs2 = maxs;\n    for ( int i=windowWidth;i<windowWidth2;++i)\n    {\n        float s  = texelFetch(iChannel1,ivec2(pixelX + i, 0),0).x;\n        maxs2 = max(maxs2,s);\n    }\n    sums /= float(windowWidth);\n    //vec2 s  = texelFetch(iChannel1,ivec2(int(uv.x * float(soundBuffLen)),1),0).xy;\n    fragColor.x = s;\n    fragColor.y = sums;\n    fragColor.z = maxs;\n    fragColor.w = maxs2;    \n}", "buffer_a_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define soundBuffLen 512\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);    \n    int ycoord = iFrame % int(iResolution.y);\n    if (ycoord != int(fragCoord.y))\n        return;\n    //vec2 uv = fragCoord / iResolution.xy;\n    \n    if (int(fragCoord.x) >= soundBuffLen )\n        return;\n    vec4 xn  = texelFetch(iChannel1,ivec2(int(fragCoord.x), ycoord),0);\n    int prevYCoord = ycoord - 1;\n    if (prevYCoord < 0)\n        prevYCoord += int(iResolution.y);\n    vec4 xnm1  = texelFetch(iChannel1,ivec2(int(fragCoord.x), prevYCoord),0);\n    //vec4 ynm1 = texelFetch(iChannel0,ivec2(int(fragCoord.x), prevYCoord),0);\n    //float alpha = 0.5;\n    //vec4 yn = alpha*(ynm1 + xn - xnm1);\n    vec4 yn = xn-xnm1;\n    \n    fragColor = yn;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "const int windowStarts[2] = int[2](0,64);\nconst int windowEnds[2] = int[2](16,128);\n#define COMPONENT x\n\nint iDiv32, iBase32, iMod32, ycoord;\n\nvoid func2(out vec4 fragColor, in vec2 fragCoord)\n{\n    if ( iMod32 >0)\n        return;\n    float s = 0.;\n    for (int i=0;i<512;++i)\n    {\n        s += texelFetch(iChannel1,ivec2(i, ycoord),0).x;\n    }\n    s /= 512.;\n    int prevYCoord = ycoord - 1;\n    if (prevYCoord < 0)\n        prevYCoord += int(iResolution.y);\n    vec4 prevPixel = texelFetch(iChannel0,ivec2(iBase32,prevYCoord),0);\n    vec2 speed = vec2(\n        prevPixel.y * 0.95 + pow(smoothstep(0.06,0.1,s),2.0),\n        prevPixel.z * 0.5 + pow(smoothstep(0.04,0.06,s),4.0)\n    );\n    speed = clamp(speed,0.,1.);\n    //speed.x = 0.9*speed.x + 0.1;\n    vec2 delta = iTimeDelta * speed;\n    \n    if ( int(iMod32) == 0 )\n    {\n        fragColor.x = s;\n        if ( iFrame < 5)\n        {\n            fragColor.yzw = vec3(0.);\n        }\n        else\n        {\n            fragColor.yz = speed;\n            fragColor.w = prevPixel.w + delta.x;\n        }\n    }\n}\n\nvoid func1(out vec4 fragColor, in vec2 fragCoord)\n{\n    if ( iMod32 >2)\n        return;\n    float mx = 0.;\n    int windowStart = windowStarts[iDiv32];\n    int windowEnd = windowEnds[iDiv32];\n    for ( int i=windowStart;i<windowEnd ; ++i)\n    {\n        mx = max(mx,texelFetch(iChannel1,ivec2(i, ycoord),0).COMPONENT);\n    }\n    int prevYCoord = ycoord - 1;\n    if (prevYCoord < 0)\n        prevYCoord += int(iResolution.y);\n    vec4 prevPixel = texelFetch(iChannel0,ivec2(iBase32,prevYCoord),0);\n    \n    vec2 speed = vec2(\n        prevPixel.y * 0.95 + pow(smoothstep(0.05,0.1,mx),2.0),\n        prevPixel.z * 0.9 + pow(smoothstep(0.05,0.15,mx),4.0)\n    );\n    speed = clamp(speed,0.,1.);\n    //speed.x = 0.9*speed.x + 0.1;\n    vec2 delta = iTimeDelta * speed;\n\n    \n    if ( int(iMod32) == 0 )\n    {\n        fragColor.x = mx;\n        if ( iFrame < 5)\n        {\n            fragColor.yzw = vec3(0.);\n        }\n        else\n        {\n            fragColor.yz = speed;\n            fragColor.w = prevPixel.w + delta.x;\n        }\n    }\n    else\n    {\n        vec3 P = texelFetch(iChannel0,ivec2(iBase32 + 1,prevYCoord),0).xyz; //position\n        vec3 T = texelFetch(iChannel0,ivec2(iBase32 + 2,prevYCoord),0).xyz; //tangential vector\n        \n        float lp = length(P);\n        float lt = length(T);\n        if (lp<0.9 || lp>1.1 || lt < 0.9 || lt > 1.1 || iFrame < 5 )\n        {\n            //initializing.\n            if ( int(iMod32) == 1 )\n            {\n                fragColor.xyz = vec3(1.,0.,0.);\n            }\n            else\n            {\n                fragColor.xyz = vec3(0.,1.,0.);\n            }\n            return;\n        }\n\n        float kinkAngle = 100.0 * delta.y;\n        vec3 N = cross(P,T);\n        N = N * cos(kinkAngle) + P * sin(kinkAngle);\n        N = normalize(N);\n        \n        float velocity = 1.0;\n        float deltaPos = velocity * (0.9 * delta.x + 0.1*iTimeDelta);\n        vec3 Pn = normalize(P + T * deltaPos);\n        vec3 Tn = normalize(cross(N,Pn));\n        \n        if ( int(iMod32) == 1 )\n        {\n            fragColor.xyz = Pn;\n        }\n        else\n        {\n            fragColor.xyz = Tn;\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    iDiv32 = int(fragCoord.x) >> 5;\n    iBase32 = iDiv32 << 5;\n    iMod32 = int(fragCoord.x) - iBase32;\n    ycoord = iFrame % int(iResolution.y);\n    if (ycoord != int(fragCoord.y))\n        return;\n    \n    if ( iDiv32 <=1)\n        func1(fragColor,fragCoord);\n    else if (iDiv32 == 2)\n        func2(fragColor,fragCoord);\n    else\n        return;\n    \n    \n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float ThresholdDecay( float t )\n{\n    return pow(0.8,t);\n}\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGfDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[498, 498, 582, 582, 1300], [1302, 1302, 1334, 1334, 1644], [1646, 1646, 1671, 1671, 3216], [3218, 3218, 3242, 3242, 3399], [3401, 3401, 3435, 3435, 3565], [3567, 3567, 3613, 3613, 4443], [4445, 4445, 4478, 4478, 4776], [4778, 4778, 4816, 4816, 5276], [5278, 5278, 5309, 5309, 5933], [5935, 5935, 5992, 5992, 7735]], "test": "untested"}
{"id": "7lGfWt", "name": "Funky Motherboard Carpet", "author": "leon", "description": "Beep's and boop's surfin' on the electric slide", "tags": ["abstract", "pattern"], "likes": 44, "viewed": 703, "published": 3, "date": "1665429880", "time_retrieved": "2024-07-30T16:27:01.106854", "image_code": "\n// Funky Motherboard Carpet\n//\n// What's actually happens when pixels meet, hardwary speaking\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    \n    // coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = 2.*(fragCoord*2.-iResolution.xy)/iResolution.y;\n    \n    // common parameters\n    float thin = .1;\n    float glow = .01;\n    float delay = 10.;\n    \n    // grid\n    float cell = 4.0;\n    vec2 pp = floor(uv*cell)/cell;\n\n    // random seed per cell grid\n    float seed = hash13(vec3(pp, floor(iTime/delay))) * 196.;\n    \n    // random parameters per cell grid\n    vec3 rng = hash31(seed);\n    vec3 rng2 = hash31(seed+1096.);\n    float size = mix(.01, .2, rng2.z);\n    vec2 range = mix(vec2(.2), vec2(.8), rng.xy);\n    float rangeY = mix(.1, .2, rng.z);\n    float fallOff = mix(1.1, 1.2, rng2.x);\n    float count = floor(mix(4., 12., rng2.y));\n    \n    // kaleidoscop\n    float a = 1.0;\n    for (float index = 0.; index < count; ++index)\n    {\n        // transform\n        p = abs(p)-range*a;\n        p *= rot(3.1415/4.);\n        p.y = abs(p.y)-rangeY;\n        \n        // shape\n        float dist = max(abs(p.x) + a*sin(6.28*index/count), p.y-size);\n        \n        // shade\n        color += smoothstep(thin, 0.0, dist) * glow / dist;\n        \n        a /= fallOff;\n    }\n    \n    color = clamp(color, 0., 1.);\n    \n    // palette\n    color *= .5 + .5 * cos(vec3(1,2,3)*5. + p.x * 10.);\n    \n    // glow\n    color += .04/abs(sin(p.y*12.+iTime*1.));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "\nmat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c); }\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n  p3 += dot(p3, p3.zyx + 31.32);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGfWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 153, 153, 1540]], "test": "untested"}
{"id": "ftyfWd", "name": "Raymarching wavefront (Bintree)", "author": "pyBlob", "description": "Compared to standard raymarching, all intersection tests lie on the same discrete concentric circles!\nEvery red dot represents an evaluation of the sdf.", "tags": ["raymarching", "visualization"], "likes": 15, "viewed": 470, "published": 3, "date": "1665427183", "time_retrieved": "2024-07-30T16:27:01.950598", "image_code": "int lvl, seg;\nvoid init() { lvl = 0; seg = 0; }\nvoid up()   { --lvl; seg = seg>>1; }\nvoid near() { ++lvl; seg = seg<<1; }\nbool isfar() { return (seg & 1) == 1; }\nbool next() { while (isfar()) up(); ++seg; return lvl == 0; }\n\nfloat _r, _s; vec2 _p;\nbool close(vec2 ro, vec2 rd)\n{\n    rd *= exp2(-float(lvl));\n    _r = scene(_p = ro + rd * (float(seg) + .5));\n    float _s = length(rd) / 2.;\n    return _r < _s;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setup(fragCoord, iResolution, iMouse);\n\n    float T = mod(.3*iTime/(2.*(2.+pi)), 2.);\n    float show_unrolled = demo ? smoothstep(1., 1.05, T) - smoothstep(1.95, 2., T) : 0.;\n    //show_unrolled = 1.; // Shows Buffer A\n\n    color = vec3(0);\n    blend(vec3(1), abs(scene(uv)) - .5 * f);\n\n    vec2 ro, rd;\n    ro = mouse.xy; rd = uv - ro;\n    if (demo)\n    {\n        float a = .3 * iTime;\n        float T=2.+pi, s=sign(T-mod(a, T+T)); a=mod(a, 2. + pi); ro=vec2(.5,0) + .5*(a<2. ? vec2(a-1., 0) : vec2(cos(a=s*(a-2.)), sin(a)));\n        //ro = vec2(.5, 0.) + .5 * vec2(cos(a), sin(a));\n        rd = uv - ro;\n    }\n    rd = normalize(rd) * 4.;\n\n    blend(vec3(1), abs(length(uv - ro) - 3. * f) - .5 * f);\n\n    init();\n    bool hit = false;\n    for (int i=0;i<64;++i)\n    {\n        if (close(ro, rd))\n        {\n            near();\n            if (lvl > 16) { hit = true; break; }\n        }\n        else if (next()) break;\n        blend(vec3(1,0,0), length(uv - _p));\n    }\n    if (hit) blend(vec3(0,1,0), length(uv - _p) - 1.*f);\n    else blend(vec3(lvl!=0,0,1), length(uv - _p) - 1.*f); // pink: loop limit exceeded, blue: no intersections\n    fragColor = vec4(sqrt(color), 1);\n    fragColor = mix(fragColor, texelFetch(iChannel0, ivec2(fragCoord), 0), show_unrolled);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float pi = radians(180.);\n\nfloat f; vec3 color;\nvoid blend(vec3 c, float r)\n{\n    color = mix(color, c, clamp(1. - r / f, 0., 1.));\n}\n\nvec2 uv;\nvec4 mouse;\nbool demo, down, click;\nvoid setup(vec2 fragCoord, vec3 iResolution, vec4 iMouse)\n{\n    f = 2. / iResolution.y;\n    uv = (fragCoord - iResolution.xy / 2.) * f;\n    mouse = (abs(iMouse) - iResolution.xyxy / 2.) * f;\n    demo = iMouse.z == 0.;\n    down = iMouse.z > 0.;\n    click = iMouse.w > 0.;\n}\n\nfloat sdBox(vec2 p,vec2 s)\n{\n    return length(max(p=abs(p)-s,0.))+min(max(p.x,p.y),0.);\n}\n\nfloat sdLine(vec2 p,vec2 a,vec2 b)\n{\n    return length(-clamp(dot(p-=a,b-=a)/dot(b,b),0.,1.)*b+p);\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    sca = normalize(sca);\n    scb = normalize(scb);\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x > scb.x*p.y) ? dot(p,scb) : length(p);\n    return sqrt(max(0., dot(p,p) + ra*ra - 2.0*ra*k)) - rb;\n}\n\nfloat side(float r, float h)\n{\n    return sqrt(r*r - h*h);\n}\n\nfloat sdArcTo(in vec2 p, in vec2 a, in vec2 b, float r)\n{\n    vec2 m = a + b;\n    float tb = dot(m, b) / length(m);\n    float arc = sdArc(p, vec2(m.y, -m.x), vec2(side(r, tb), tb), r, 0.);\n    //return min(min(length(p-a), length(p-b)), min(length(p-m), min(arc, length(p)))) -.01;\n    return arc;\n}\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat scene(vec2 p)\n{\n    // lara: Animated Marching Visualization https://www.shadertoy.com/view/ltyGRD\n    p.x += .5;\n    float ball = length(p - vec2(1, 0)) - .3;\n    float lens = length(p - vec2(.8, 0)) - .15;\n    float wire = abs(p.y) - .05;\n    vec2 q = p; q.y = abs(q.y);\n    float eye = max(max(ball,-lens),-wire);\n    float bx = (pow(.3,2.)-pow(.15,2.)+pow(.2,2.))/(2.*.2);\n    float bh = side(.3, bx);\n    float ballArc = sdArcTo(q - vec2(1, 0), vec2(-bx,bh), vec2(side(.3,.05), .05), .3);\n    float lensArc = sdArcTo(q - vec2(.8, 0), vec2(.2-bx,bh), vec2(side(.15,.05), .05), .15);\n    float wireLine = sdLine(q, vec2(.8+side(.15,.05), .05), vec2(1.+side(.3,.05), .05));\n    float eye1 = min(min(ballArc, lensArc), wireLine) * sign(eye);\n    float socket = min(\n        sdBox(vec2(p.x,abs(p.y))-vec2(1,.6),vec2(.3,.05)),\n        sdBox(vec2(p.x,abs(p.y))-vec2(1.25,.55),vec2(.05,.05))\n    );\n    //if (false)\n        return min(eye1, socket); // proper sdf\n    return min(eye, socket); // original sdf\n}\n\nvec3 palette(float h)\n{\n    // iq: Binary Search for SDFs https://www.shadertoy.com/view/wlGcWG\n    vec3 col =    vec3(0.0,0.3,1.0);\n    col = mix(col,vec3(1.0,0.8,0.0),smoothstep(0.33-0.2,0.33+0.2,h));\n    col = mix(col,vec3(1.0,0.0,0.0),smoothstep(0.66-0.2,0.66+0.2,h));\n    col.y += 0.5*(1.0-smoothstep(0.0,0.2,abs(h-0.33)));\n    col *= 0.5 + 0.5*h;\n    return col;\n}\n", "buffer_a_code": "int lvl, seg;\nvoid init() { lvl = 0; seg = 0; }\nvoid up()   { --lvl; seg = seg>>1; }\nvoid near() { ++lvl; seg = seg<<1; }\nbool isfar() { return (seg & 1) == 1; }\nbool next() { while (isfar()) up(); ++seg; return lvl == 0; }\n\nfloat _r, _s, _f; vec2 _p;\nbool close(vec2 ro, vec2 rd)\n{\n    _f = exp2(-float(lvl)) * (float(seg) + .5);\n    rd *= exp2(-float(lvl));\n    _r = scene(_p = ro + rd * (float(seg) + .5));\n    float _s = length(rd) / 2.;\n    return _r < _s;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setup(fragCoord, iResolution, iMouse);\n\n    color = vec3(0);\n    //blend(vec3(1), abs(scene(uv)) - .5 * f);\n\n    vec2 ro = mouse.xy;\n    if (demo)\n    {\n        float a = .3 * iTime;\n        float T=2.+pi, s=sign(T-mod(a, T+T)); a=mod(a, 2. + pi); ro=vec2(.5,0) + .5*(a<2. ? vec2(a-1., 0) : vec2(cos(a=s*(a-2.)), sin(a)));\n        //ro = vec2(.5, 0.) + .5 * vec2(cos(a), sin(a));\n    }\n    blend(vec3(1), abs(length(uv - ro) - 3. * f) - .5 * f);\n    \n    color *= .5;\n    \n    f = 1. / iResolution.y;\n    float fcy = fragCoord.y * f;\n    float a = fragCoord.x / iResolution.x * 2. * pi;\n    vec2 rd = vec2(sin(a), cos(a)) * 4.;\n    float d = 1. * pi / iResolution.x; mat2 D = mat2(cos(d), sin(d), -sin(d), cos(d));\n\n    blend(vec3(1), abs(scene(ro + rd * fcy)) - .5 * f);\n    //blend(vec3(1), abs(scene(ro + D * rd * fcy)) - .5 * f);\n    //blend(vec3(1), abs(scene(ro + rd * D * fcy)) - .5 * f);\n\n    init();\n    bool hit = false;\n    for (int i=0;i<64;++i)\n    {\n        if (close(ro, rd))\n        {\n            near();\n            if (lvl > 16) { hit = true; break; }\n        }\n        else if (next()) break;\n        blend(vec3(1,0,0), abs(_f - fcy));\n    }\n    if (hit) blend(vec3(0,1,0), abs(_f - fcy));\n    else blend(vec3(lvl!=0,0,1), abs(_f - fcy)); // pink: loop limit exceeded, blue: no intersections\n    fragColor = vec4(sqrt(color), 1);\n}\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyfWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 27, 27, 47], [48, 48, 61, 61, 84], [85, 85, 98, 98, 121], [122, 122, 136, 136, 161], [162, 162, 175, 175, 223], [413, 413, 468, 468, 1740]], "test": "untested"}
{"id": "NlGBWd", "name": "Blur: Gaussian noise", "author": "sh1boot", "description": "Not a regular gaussian blur.\n(bottom picking from mipmap instead)", "tags": ["2d", "blur", "post", "gaussian"], "likes": 3, "viewed": 294, "published": 3, "date": "1665422894", "time_retrieved": "2024-07-30T16:27:02.867149", "image_code": "#if 1\nfloat nrand( vec2 n ) {\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453); }\nvec2 nrand2( vec2 n ) { return vec2(nrand(n), nrand(n + 1.2345)); }\n#else\nfloat nrand( vec2 n ) {\n    return texelFetch( iChannel3, (ivec2(gl_FragCoord.xy)+ivec2(vec2(81,90)*(7.0*iTime + n)))%textureSize(iChannel3,0).xy, 0 ).r;\n }\nvec2 nrand2( vec2 n ) {\n    return texelFetch( iChannel3, (ivec2(gl_FragCoord.xy)+ivec2(vec2(81,90)*(7.0*iTime + n)))%textureSize(iChannel3,0).xy, 0 ).bg;\n}\n#endif\n\n\nvec2 pdf(vec2 x) {\n#if 0\n    // pdf for s=0.1667: `sum(uniform(-.5,.5, 3)/3)`\n    return 2.39365*exp(-18. * x * x);\n#else\n    // pdf for s=0.144: `sum(uniform(-.5,.5, 4)/4)`\n    return 2.77043 * exp(-24.1126 * x * x);\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.y = 1.0-uv.y;\n   \n    float max_siz;\n    if ( iMouse.z > 0.5 )\n\t\tmax_siz = 32.0 * (1.0-iMouse.x / iResolution.x); // * (0.5+0.5*sin(iTime));\n    else\n        max_siz = 32.0 * (0.5+0.5*sin(2.0*uv.x + iTime));\n\n    const int NUM_TAPS = 18;\n\n    if ( uv.y > 0.5 )\n    {\n        fragColor = texture( iChannel0, uv, log2(max_siz) );\n    }\n    else\n    {\n        vec4 sum = vec4(0);\n        \n        for (int i=0; i < NUM_TAPS; i++)\n        {\n            vec4 seed = vec4(1.2, 4.5, 6.7, 8.9) + fract(iTime) + float(i);\n            vec2 ofs = (nrand2(uv + seed.xy)\n                      + nrand2(uv + seed.yz)\n                      + nrand2(uv + seed.zw)\n                      + nrand2(uv + seed.wx)) * 0.25 - 0.5;\n\n            vec2 texcoord = uv + max_siz * ofs / iResolution.xy;\n            vec3 fiddle = iChannelResolution[0] / iResolution;\n            float lod = 0. + log2(length(max_siz / pdf(ofs) * fiddle.xy));\n            sum += textureLod(iChannel0, texcoord, lod);\n        }\n\n        fragColor = sum / float(NUM_TAPS);\n    }    \n}\n", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGBWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[494, 494, 512, 512, 720], [722, 722, 779, 779, 1864]], "test": "untested"}
{"id": "slVBDc", "name": "twisted cube", "author": "FabriceNeyret2", "description": "insipration: https://twitter.com/incre_ment/status/1579308756084568064\nvariant of https://shadertoy.com/view/Xs33RH\n", "tags": ["cube", "short", "codegolf", "reproduction", "3tweets"], "likes": 31, "viewed": 497, "published": 3, "date": "1665410778", "time_retrieved": "2024-07-30T16:27:03.764747", "image_code": "// variant of https://shadertoy.com/view/Xs33RH\n\n#define L  *I ; o+= 2e-3 / length( clamp( dot(u-a,v=b-a)/dot(v,v), 0.,1.) *v - u+a )\n#define P  ; c=r=I*r.yx; c.y=.7; b=c/=(4.+r.y) L;   b=a L;   a=c L;  a=c;\n\nvoid mainImage(out vec4 o, vec2 v)\n{\n\tvec2 I=vec2(1,-1), a,b,c=iResolution.xy, \n         u = (v-.5*c)/c.x,\n//       r = sin( iTime-.8*I + 9.*sin(iTime)*u.y );  \n         r = -sin( iTime+.8*I + 3.14*smoothstep(5.,7., mod(iTime,8.) +4.*u.y ) );  \n    P  o*=0.\n\tP P P P \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVBDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7lKfWW", "name": "Extruded Hilbert Curve", "author": "Shane", "description": "Rolling spheres along a raymarched extruded Hilbert curve pattern.", "tags": ["fractal", "grid", "raymarch", "curve", "pattern", "hilbert", "rolling", "extrude"], "likes": 75, "viewed": 690, "published": 3, "date": "1665409991", "time_retrieved": "2024-07-30T16:27:04.769062", "image_code": "/*\n\n    Extruded Truchet Pattern\n    ------------------------\n    \n    This is an extruded version of the parameterized Hilbert curve I posted\n    earlier. I was expecting it to be a little trickier to code than it was,\n    but most of the work was performed in the 2D version.\n\n    The best way to do this would be to precalculate the required 2D information\n    and store it on the backbuffer. However, I wanted to avoid multiple tabs\n    and passes, resolution headaches, etc, so generated it on the fly. The code\n    was slightly rushed, but it seems to run well enough on medium range machines.    \n    \n    I kept the curve design and background simple. The background originally had \n    more detail, but I felt it took away from the pattern itself, so I scaled it \n    back. The spheres aren't perfectly round, but I thought that gave the scene \n    some character.\n    \n    I have a more interesting version that I'll post at some stage. I also plan \n    to post a proper 3 dimensional version. If you'd like to see what one of \n    those looks like, I've posted links to Dr2 and MLA's examples below. \n    \n\n\n    References:\n    \n\n    // Efficient and concise, as always.\n    Hilbert 3D - dr2\n\thttps://www.shadertoy.com/view/lltfRj\n    \n    // Hilbert curves in 3D using the Skilling algorithm.\n    Hilbert Curves 3D - MLA\n    https://www.shadertoy.com/view/flX3W8\n    \n    // A simpler flat 2D plane version.\n\tHilbert Curve Animation - Shane\n    https://www.shadertoy.com/view/NlKfzV\n\n\n*/\n \n// Maximum ray distance.\n#define FAR 20.\n\n// The number of Hilbert curve iterations. I designed everything to work with the\n// number 4. However, values 3 to 6 will look OK. Numbers outside that range \n// haven't been accounted for.\nconst int iters = 4;\n\n// Subtle textured lines.\n//#define LINES\n\n\n// Object ID: Either the back plane, extruded object or beacons.\nint objID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n// IQ's vec2 to float hash.\n//float hash31(vec3 p){  return fract(sin(dot(p, vec3(27.619, 57.583, 19.257)))*43758.5453); }\n\n// Global time, to keep track for the rolling spheres.\nfloat gTime;\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .0, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n \n/*\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n}\n*/\n\n\n// IQ's unsigned line distance formula.\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\n// Arc distance formula.\nfloat dist(vec2 p){\n\n   \n    // Circular.\n    return length(p);\n    \n    // Hard square edge. The sphere's get distorted, but some fine\n    // tuning could fix that.\n    //p = abs(p);\n    //return max(p.x, p.y);\n    \n    // Rounded square.\n    //p = abs(p) - .015;\n    //return min(max(p.x, p.y), 0.) + length(max(p, 0.)) + .015;\n    \n    // Diamond and octagon.\n    //p = abs(p);\n    //return abs(p.x + p.y)*.7; // Requires readjusting in the Hilbert arc logic.\n    //return max(max(p.x, p.y), abs(p.x + p.y)*.7);\n}\n\nvoid swap(inout vec2 a, inout vec2 b){ vec2 t = a; a = b; b = t; }\n\n\nvec2 gDir; // Cell direction flag.\nfloat squashF; // Squashing factor hack, based on straight of arc curved cells.\n\n//\n// A standard Hilbert curve routine with some extra parameterization hacked\n// in at the end. It needs some tidying up, but it works pretty fast, all \n// things considered. I've taken an approach that's very similar to Fabrice's\n// example, here: \n//\n// Hilbert curve 5 - FabriceNeyret2\n// https://www.shadertoy.com/view/XtjXW3\n\n// Fabrice's started with a different orientation, which has led to slightly\n// neater logic, which I might try to incorporate later.\nvec4 hilbert(vec2 p){ \n\n    // Hacking in some scaling.\n    float hSc = 1./4.;\n    // If you scale the coordinates, you normally have to scale things back\n    // after you've finished calculations.\n    p *= hSc; \n    \n    // Saving the global coordinates prior to subdivision. I'm not experiencing\n    // alignment glitches, but I'm using Fabrice's hack, just to be on the safe side. :)\n    vec2 op = p + 1e-4; \n    \n    // Initial scale set to one.\n    float sc = 1.;\n    \n    // Cell ordering vector -- Clockwise from the bottom left. If the new partitioned\n    // frame is flipped, then this will be also.\n    ivec4 valC = ivec4(0, 1, 2, 3);\n    \n    // Initate to top left quadrant cell.\n    int val = 1;\n    \n    p = op; // Initialize.\n    \n    // Splitting the curve block into two. There's no real reason for doing this,\n    // but I thought it filled the canvas dimensions a little better... Plus, I\n    // like to complicate things for myself. :)\n    if(p.x<0.) p.x = abs(p.x) - .5; // Left half -- Moved to the left.\n    else { p.x = .5 - abs(p.x); p = -p.yx;  } // Right half -- Moved right and rotated CCW.\n    \n    p = fract(p + .5); // Needs to begin in the zero to one range.\n    p *= vec2(-1, 1); // Not absolutely necessary, but we're forcing the top left quadrant split.\n    \n    // The horizontal and vertical vectors. I've adopted Fabrice's naming\n    // convention (i and j), but have stored them in one vector.\n    vec4 ij = vec4(1, 0, 0, 1), d12 = ij; //vec4(ij.xy, -ij.zw);\n \n    int rn = 0; // Cell number.\n   \n    float dirX = 1.; // Hacked in to keep track of the left or right of the curve.\n    \n    for(int i = min(0, iFrame); i<iters; i++){\n       \n       \n        // The quadrant splitting logic:\n        // Bottom left: Rotate clockwise. Leave the first direction alone. The second points up.\n        // Top left: Leave the space untouched. First direction points down. Second points right.\n        // Top right: Flip across the X-axis. First direction points left. Second points down.\n        // Bottom right: Rotate clockwise then flip across the X-axis. First points up. Second left alone.\n        \n        if(p.x>0.){\n            // You need to reverse the rendering order of the two right cells.\n            // In other words, swap(dir1, dir2);\n            if(p.y>0.){ d12 = -ij; p.x = -p.x;  d12.xz = -d12.xz; val = 2; } // Top right.\n            else { d12.xy = ij.zw;  /*d12.xy = ij.zw;*/ \n                 p = p.yx*vec2(1, -1); d12 = d12.yxwz*vec4(1, -1, 1, -1); \n                 dirX *= -1.; val = 3; // Bottom right  (Exit).\n            } \n\n            // Flip vector directions on the right -- You could incorporate this into the\n            // lines above, if you wanted to.\n            d12 = d12.zwxy; \n          \n            valC = valC.wzyx; // Reverse rendering order direction in the right quadrants.\n\n        }\n        else {\n        \n            if(p.y>0.){ d12 = vec4(-ij.zw, ij.xy); val = 1; } // Top left.\n            else { /*d12.xy = -ij.zw;*/ d12.zw = ij.zw; p = p.yx; d12 = d12.yxwz; \n                 dirX *= -1.; val = 0; // Bottom left (Entry).\n            }  \n          \n        }\n        \n        // Ordering the cells from start to finish -- There's probably a smarter way,\n        // but this is what I came up with at the time. It works, so it has that \n        // going for it. :)\n        //\n        // The new quadrant value, after splitting, rotating, flipping, etc, above.\n        int valN = p.x<0.? p.y<0.? 0 : 1 : p.y<0.? 3 : 2; \n        // Number of squares per side for this iteration.\n        int sL = 1<<(iters - i - 1); // 1, 2, 4, 8, etc.\n        // Position number multiplied by total number of squares for each iteration.\n        rn += valC[valN]*sL*sL;\n       \n        // Subdivide and center.\n        p = mod(p, sc) - sc/2.;\n        sc /= 2.;\n        \n\n   \n    }\n\n    \n    // Square block number.\n    float sL = float(1<<(iters - 1));\n \n   \n    // The distance field value.\n    float d = 1e5;\n    \n    // If a swap occurred, swap the rendering order of dir1 and dir2.\n    //if(valC[val] != val) d12 = d12.zwxy;\n \n   \n    // If a swap has occurred, reverse direction.\n    float dir = valC[val] != val? -1. : 1.;\n    \n    \n    float crvLR = 4./3.14159265; //Curve length ratio.\n    \n    // The two direction vectors in this cell are perpendicular. \n    // Therefore, calculate the arc distance function and coordinates.  \n    // Otherwise, the direction vectors are aligned, so calculate\n    // the line portion.\n    //\n    // By the way, for those who don't know, curvy line coordinates are\n    // similar to 2D Euclidean plane coordinates. However, the X value runs \n    // along the curve and the Y value is perpendicular to the curve.\n    //\n    if(dot(d12.xy, d12.zw) == 0.){\n        \n        // Arc distance field and the conversion of 2D plane coordinates\n        // to curve coordinates.\n        \n        // Using the perpendicular direction vectors to center the arc.\n        p -= (d12.xy + d12.zw)*sc;\n        \n        // Pixel angle.  \n        float a = atan(p.x, p.y); \n       \n        p.y = dist(p) - sc; // The Y coordinate (centered arc distance).\n        \n        d = abs(p.y); // Distance field value.\n        \n        p.x = fract(dir*a/6.2831853*4.); // The X coordinate (angle). Order counts.\n        \n        // Hacky distortion factor at the border of the line and arcs.\n        //crvLR = mix(1.,  crvLR, 1. - p.x);\n    }\n    else { \n     \n        // Line distance field and curve coordinates. \n        \n        d = distLine(p, d12.xy*sc*1., d12.zw*sc); // Line distance.\n        p.x = fract(dir*p.x*sL - .5); // Straight line coordinate.\n        // p.y remains the same as the Euclidean Y value.\n        \n        // Hacky distortion factor at the border of the line and arcs.\n        crvLR = mix(1., crvLR, smoothstep(0., 1., abs(p.x - .5)*2.));\n        //crvLR = 1.;\n    }\n   \n   \n    // Using the current ordered cell value, the total number of cells and\n    // the fractional curve cell value to calculate the overall ordered position\n    // of the current pixel along the curve.\n    float hPos = (float(rn) + p.x)/(sL*sL);\n    \n    // Getting rid of curves, etc, outside the rectangle domain.\n    if(abs(op.x)>1. || abs(op.y)>.5){ d = 1e5; p = vec2(1e5); }\n    \n    // Handling (hacking) the entry and exit channels separately.\n    if(op.y>.5){ \n        d = min(d, distLine(op - vec2(.5/sL, 0), vec2(0), ij.zw*4.)); \n        hPos = 1. + (op.y - .5)/(sL); \n        p.x = fract(op.y*sL); // Angle for this channel.\n        crvLR = mix(1., crvLR, smoothstep(0., 1., abs(p.x - .5)*2.));\n        p.y = (op.x - sc)*dirX;\n        \n    }\n    if(op.y<-.5){ \n        d = min(d, distLine(op - vec2(-1. + .5/sL, 0), vec2(0), -ij.zw*4.)); \n        hPos = (op.y + .5)/(sL); \n        p.x = fract(op.y*sL); // Angle for this channel.\n        crvLR = mix(1., crvLR, smoothstep(0., 1., abs(p.x - .5)*2.));\n        p.y = -(op.x + (1. - sc))*dirX;\n        \n    }\n    \n    squashF = crvLR; \n   \n    p.x = fract(p.x + gTime);\n    // The curve coordinates -- Scaled back to the zero to one range.\n    p = vec2((p.x - .5)/sL/crvLR, p.y*dirX);\n    \n    \n \n    // Line thickness.\n    d -= .3/sL;\n\n    // Accounting for the left and right Hilbert curve blocks.\n    if(op.x<0.){ hPos = 1. - fract(-hPos); p.y *= -1.; }\n    \n    gDir = vec2(dirX, dir);\n    \n    // Return the distance field, curve position, and curve coordinates.\n    return vec4(d/hSc, hPos, p/hSc);\n\n}\n\n// // Emulating sin and cos waves with a triangle function.\n//vec2 sinT(in vec2 x){ return 1. - abs(fract(x/6.2831 + .25) - .5)*4.; }\n//vec2 cosT(in vec2 x){ return 1. - abs(fract(x/6.2831 + .5) - .5)*4.; }\n\n// Very basic terrain function consisting of some rotated transcendental layers.\nvec2 terrain(vec3 p){\n\n    // Simple, but cheap, background hills.\n    vec2 q = p.yx*1.8;\n    float terr = 1. - (dot((sin(q - cos(q.yx)*1.57)), vec2(.25)) + .5);\n    q *= rot2(3.14159/2.75);\n    float terr2 = 1. - (dot((sin(q*3.25 - cos(q.yx*3.25)*1.57 + 1.)), vec2(.25)) + .5);\n    //terr = mix(terr, 1. - abs(terr2 - .5)*2., .15);\n    //q *= rot2(3.14159/1.5);\n    //float terr3 = (dot((sin(q*6.5 - cos(q.yx*6.5)*1.57 + 2.)), vec2(.25)) + .5);\n    //terr2 = mix(terr2, terr3, .333);\n     //terr = mix(terr, abs(terr - .5)*2., .333);\n     \n    // Carving out the entry and exit road passes.\n    float sL = float(1<<(iters - 1));\n    terr = smin(terr, max(abs(p.x - 4.*.5/sL) - 2./sL, -p.y + 2.), .25); \n    terr = smin(terr, max(abs(p.x + 4.*(1. - .5/sL)) - 2./sL, p.y + 2.), .25);\n    \n    return vec2(terr, terr2);\n\n}\n \n// The scene's distance function. There'd be faster ways to do this.\nfloat m(vec3 p){\n    \n        // Square block number.\n    float sL = float(1<<(iters - 1));\n    // Rectangular bound.\n    float bound = sBoxS(p.xy, vec2(4, 2), 0.);//max(abs(p.x) - 4., abs(p.y) - 2.);\n\n    // Back plane.\n    float fl = -p.z;//abs(p.z - 2.) - 2.;\n    // Terrain function.\n    vec2 terr = terrain(p);\n    // Adding the terrain to the flat plain.\n    fl -= smoothstep(0., 1., bound)*terr.x*.6 + terr.y*.1  - .1;\n    //fl -= clamp(bound, 0., 1.)*terr.x*.6 + terr.y*.1  - .1;\n\n    \n    \n    // 2D Hilbert distance, for the extrusion cross section.\n    vec4 hilb = hilbert(p.xy);\n    float obj = hilb.x;\n    \n    // Variable extrusion height along the length of the curve.\n    const float hN = 3.;\n    float hgt = cos(6.2831*hilb.y*hN - 3.14159265)*.5 + .5;\n    \n\n    // Extruded curve height factor.\n    const float hf = .2; \n    // Extrude the 2D Hilbert curve object along the Z-plane. Note that this is a cheap\n    // hack. However, in this case, it doesn't make much of a visual difference.\n    obj = max(obj, abs(p.z - .25*7./4. + (hgt*hf + .25)) - (hgt*hf + .25)) + smoothstep(.03, .2, -obj)*.05;\n    // Proper extrusion formula for comparisson.\n    //obj = opExtrusion(obj, p.zz - .25*7./4. + (hgt*hf + .25), hgt*hf + .25, .01) \n    //      + smoothstep(.03, .2, -obj)*.05;\n    \n\n    // The rolling spheres.\n    float ballSz = .9/sL; //\n    // Patitioning the curve's X position.\n    vec3 bp = vec3(hilb.zw, p.z - .25*7./4. + (hgt*hf + .25)*2.) + vec3(0, 0, ballSz - .01);\n    \n    //const float N = 4.;\n    //bp.x = (mod(hilb.y + (gTime + .5)/(sL*sL), 1./N) - .5/N)*sL/squashF*4.;\n    float rollSp = (hilb.y + gTime)/(ballSz*1.57);\n    bp.xz *= rot2(rollSp);\n    \n    // Spheres.\n    float ball = (length(bp) - ballSz);\n    //float ball = sBoxS(bp, vec3(ballSz), ballSz*.25);\n \n     // Only show four spheres per curve -- There are two curves joined on either side\n     // of the zero X line, so eight spheres altogether.\n     float crv = fract(hilb.y + gTime/(sL*sL));\n     if(mod(floor(crv*(sL*sL)), sL*sL/4.)>.5) ball = 1e5;\n   \n    // Object ID.\n    objID = fl<obj && fl<ball? 0 : obj<ball? 1 : 2;\n    \n    // Minimum distance for the scene.\n    return min(min(fl, obj), ball);\n    \n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float d, t = 0.;//hash21(ro.xy*57. + fract(iTime + ro.z))*.5;\n    \n    for(int i = min(iFrame, 0); i<72; i++){\n    \n        d = m(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not affordable for slower machines.\n    const int iter = 32; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<iter; i++){\n\n        float d = m(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // IQ's subtle refinement.\n        t += clamp(d, .01, .1); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(iFrame, 0); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = m(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n  \n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(in vec3 p) {\n\t\n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += m(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to\n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks to\n    // EvilRyu for reminding me why we perform this step. It's been a while, but I vaguely\n    // recall that it's some kind of orthogonal space fix using the Gram-Schmidt process. \n    // However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\nvoid mainImage(out vec4 c, vec2 u){\n\n    \n    // Aspect correct coordinates. Only one line necessary.\n    u = (u - iResolution.xy*.5)/iResolution.y;    \n    \n    // Unit direction vector, camera origin and light position.\n    vec3 r = normalize(vec3(u, 1)), o = vec3(0, -2.5, -3), l = o + vec3(-1, 3, 1.5);//vec3(0, -2.5, -3)//1.5\n    \n    // Distorting the camera.\n    r = normalize(vec3(r.xy, r.z - length(r.xy)*.2 + (u.y + .5)*(u.y + .5)*.0));\n    \n    \n    // Rotating the camera about the XY plane.\n    r.yz = rot2(.6)*r.yz;\n    r.xz = rot2(-cos(iTime*3.14159/16.)/6.)*r.xz;\n    r.xy = rot2(sin(iTime*3.14159/16.)/8.)*r.xy; \n    \n    // Global animated sphere timing.\n    gTime = iTime*1.5;\n  \n    \n    // Raymarch to the scene.\n    float t = trace(o, r);\n    \n    // Cell direction debug.\n    vec2 svDir = gDir;\n    \n    // Object ID: Back plane (0), or the metaballs (1).\n    int gObjID = objID;\n    \n    \n    // Very basic lighting.\n    // Hit point and normal.\n    vec3 p = o + r*t, n = nr(p); \n    \n    // Integrating bump mapping -- Not used here. It's possible\n    // to bump map on a pass by pass basis to save cycles.\n    vec3 smN = n;\n    float bf =  gObjID == 0? .1 : .01; \n    if(gObjID<2) n = texBump(iChannel1, p, n, bf);///(1. + t/FAR)\n    \n\n    // Basic point lighting.   \n    vec3 ld = l - p;\n    float lDist = length(ld);\n    ld /= lDist; // Light direction vector.\n    float at = 1./(1. + lDist*lDist*.05); // Attenuation.\n    \n    // Very, very cheap shadows -- Not used here.\n    //float sh = min(min(m(p + ld*.08), m(p + ld*.16)), min(m(p + ld*.24), m(p + ld*.32)))/.08*1.5;\n    //sh = clamp(sh, 0., 1.);\n    float sh = softShadow(p, l, n, 8.); // Shadows.\n    float ao = calcAO(p, n); // Ambient occlusion.\n    \n    \n    // spr: sample spread, amp: amplitude, offs: offset.\n\tfloat spr = 4., amp = 4., offs = -.0;\n    //float crv = curve(p, spr, amp, offs)*.95 + .05;\n    \n    \n    float df = max(dot(n, ld), 0.); // Diffuse.\n    float sp = pow(max(dot(reflect(r, n), ld), 0.), 32.); // Specular.\n    \n    \n    // UV texture coordinate holder.\n    vec2 uv = p.xy;\n    // Cell ID and local cell coordinates for the texture we'll generate.\n    float sc = 1./float(1<<(iters - 3)); // Scale: .5 to about .2 seems to look OK.\n    vec2 iuv = floor(uv/sc) + .5; // Cell ID.\n    uv -= iuv*sc; // Local cell coordinates.\n    \n    // Smooth borders.\n    float bord = max(abs(uv.x), abs(uv.y)) - .5*sc;\n    bord = abs(bord) - .002;\n    \n    // 2D Hilbert face distace -- Used to render borders, etc.\n    vec4 hilb = hilbert(p.xy);\n    float d = hilb.x;\n    \n    \n    // Subtle lines for a bit of texture.\n    #ifdef LINES\n    float lSc = 20.;\n    float pat = (abs(fract((uv.x - uv.y)*lSc - .5) - .5)*2. - .5)/lSc;\n    float pat2 = (abs(fract((uv.x + uv.y)*lSc + .5) - .5)*2. - .5)/lSc;\n    #else\n    float pat = 1e5, pat2 = 1e5;\n    #endif     \n     \n    // Colors for the floor and extruded face layer. Each were made up and \n    // involve subtle gradients, just to mix things up.\n    float sf = dot(sin(p.xy - cos(p.yx*2.)), vec2(.5));\n    vec4 col2 = mix(vec4(1., .75, .6, 0), vec4(1, .85, .65, 0), smoothstep(-.5, .5, sf));\n    vec4 col1 = pow(col2, vec4(1.6));\n    \n    // Object color.\n    vec4 oCol;\n  \n    \n    // Use whatever logic to color the individual scene components. I made it\n    // all up as I went along, but things like edges, textured line patterns,\n    // etc, seem to look OK.\n    //\n    if(gObjID == 0){\n    \n       // The terrain.\n        float sL = float(1<<(iters - 1));   \n\n        vec2 vT = terrain(p);\n        float terr = vT.x*.85 + vT.y*.15;\n        \n        // Redening the terrain crevices and making the slopes lighter.\n        oCol = mix(col1, col1, smoothstep(.85, 1., abs(n.z)));\n        // Fake terrain height-based occlusion.\n        oCol *= terr*.5 + .5;\n\n        // Using the Hilbert pattern for some bottom edging.\n        oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, d - .02))*.7);\n\n        vec3 tx = tex3D(iChannel0, p/2., n);\n        oCol *= tx.xyzz*2. + .2;\n        \n        //vec3 tx2 = tex3D(iChannel1, p/2., n);\n        //oCol = mix((oCol + .5)*tx2.xyzz, oCol, abs(n.z));\n        //float gr = dot(tx2, vec3(.299, .587, .114));\n        //oCol *= gr*1.5 + .65;\n       \n    }\n    else if(gObjID==1){\n    \n        // Extruded Hilbert pattern:\n \n        // Cream sides with a dark edge. \n        oCol = mix(vec4(1, .9, .8, 0), vec4(0), 1. - smoothstep(0., .01, d + .035));\n        \n        //if(svDir.y<0.) col1 *= vec4(1.2, 1.7, 1, 0); // Debug opposite direction cells\n        \n        // Hilbert pattern dimension -- Number of cells per side.\n        float sL = float(1<<(iters - 1));\n        \n        // Four trails per curve to match each rolling sphere.\n        const float N = 4.;\n        float trailL = 1./3.; // Fraction of space between tolling spheres.\n        // Trail and trail tip positions.\n        float x = (mod(hilb.y - trailL/2./N - .5/N + (gTime - .5)/(sL*sL), 1./N) - .5/N);\n        float x2 = (mod(hilb.y - .5/N - .03/sL + (gTime - .5)/(sL*sL), 1./N) - .5/N)*sL/squashF*4.;\n        \n        // Trail tip, trail and trail fade factor.\n        float tip = length(vec2(x2, hilb.w)) - 1./sL;\n        float trail = (abs(x) - trailL/2./N)*sL/squashF*4.;\n        float trailFade = (1. - max(x/(trailL/2./N), 0.))*.5;\n\n        // Applying the trails to the colored section of the pattern.\n        col1 = mix(col1, vec4(1, .1, .4, 0), (1. - smoothstep(0., .01*4., min(trail, tip)))*trailFade);\n       \n        // Golden faces with some subtle lines.\n        vec4 fCol = mix(col1, vec4(0), (1. - smoothstep(0., .01, pat))*.35);\n        // Square borders: Omit the middle of edges where the Truchet passes through.\n        fCol = mix(fCol, vec4(0), (1. - smoothstep(0., .01, bord))*.8);\n        // Darken alternate checkers on the face only.\n        if(mod(iuv.x + iuv.y, 2.)<.5) fCol *= .8;\n        \n        // Apply the golden face to the Hilbert pattern, but leave enough room for an edge.\n        oCol = mix(oCol, fCol, 1. - smoothstep(0., .01, d + .065));\n        \n        // Applying some texture.\n        vec3 tx = tex3D(iChannel0, p/2., n);\n        oCol *= tx.xyzz*2. + .2;\n        \n        \n    }\n    else {\n    \n       // Hilbert pattern dimension -- Number of cells per side.\n       float sL = float(1<<(iters - 1));\n       \n       // The rolling ball.\n       float hf = .2; // Curve height factor.\n       float ballSz = .9/sL; // Sphere size.\n       // Curve height equation.\n       const float hN = 3.;\n       float hgt = cos(6.2831*hilb.y*hN - 3.14159265)*.5 + .5;\n       \n       // Sphere position along the curve.\n       vec3 bp = vec3(hilb.zw, p.z - .25*7./4. + (hgt*hf + .25)*2.) + vec3(0, 0, ballSz - .01);\n        \n       \n       \n       // Rollong sphere angle: CurveXCoord/Sphere_Rad .\n       float rollSp = fract((bp.x + gTime)/3.14159265)/(ballSz/2.);\n       // Apply the rotation to the curve's X coordinate -- Not to be confused with the\n       // global Euclidean X coordinate, which is just p.x.\n       bp.xz *= rot2(rollSp); // ang = time/radius.\n  \n       // I always forget this, but the object's normal needs to rotated in the \n       // same manner to match.\n       vec3 tn = n;\n       tn.xz *= rot2(rollSp);\n        \n       // Sphere color. Roughly the same as the trail color.\n       oCol = mix(col1, vec4(1, .1, .4, 0), .5);\n       \n       // Applying some texture.\n       vec3 tx = tex3D(iChannel0, bp*4., tn).xxx;\n       oCol *= tx.xyzz*2. + .2;\n           \n    \n    } \n    \n      \n    // Apply the lighting and shading. \n    c = oCol*(df*sh + sp*sh + .5)*at*ao;\n     \n\n    // Rough gamma correction.\n    c = sqrt(max(c, 0.));  \n\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKfWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1878, 1911, 1933, 1933, 1991], [1993, 2021, 2042, 2042, 2105], [2300, 2523, 2561, 2561, 2638], [2640, 2863, 2901, 2901, 2982], [2985, 3065, 3111, 3111, 4022], [4290, 4330, 4369, 4369, 4470], [4472, 4472, 4519, 4519, 4616], [4618, 4643, 4662, 4684, 5159], [5161, 5161, 5199, 5199, 5227], [13471, 13552, 13573, 13618, 14372], [14375, 14444, 14460, 14497, 16652], [16654, 16675, 16711, 16760, 17233], [17236, 17427, 17479, 17570, 18706], [18710, 18862, 18897, 18897, 19292], [19296, 19387, 19407, 19738, 20008], [20010, 20196, 20256, 20256, 21094], [21097, 21097, 21132, 21198, 28747]], "test": "untested"}
{"id": "7lKBD3", "name": "mandelbrot-set-142", "author": "Kolya142", "description": "my frist fractal", "tags": ["mandelbrotset"], "likes": 2, "viewed": 181, "published": 3, "date": "1665394898", "time_retrieved": "2024-07-30T16:27:05.663670", "image_code": "int max_iter = 100;\nfloat t1 = .25;\nfloat zoom_cof = 2.;\nvec2 offset = vec2(.8172096, .010022) - .5;\nvec2 complex_sq(vec2 z, vec2 c){\n    return vec2(z.x*z.x-z.y*z.y+c.x, 2.*z.x*z.y+c.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/(iResolution.xy)/vec2(.6, 1.);\n    float t = pow(iTime, iTime*t1);\n    vec2 mouse = iMouse.xy/iResolution.xy-.5;\n    offset += mouse/(t/t1/iTime);\n    vec2 z;\n    vec2 c = (uv)/(t/zoom_cof)+offset;\n    int iter;\n    float color;\n\n    // Time varying pixel color\n    for (int i = 0;i < max_iter; i++){\n        iter += 1;\n        z = complex_sq(z, c);\n        if (length(z)>4.) {break;}\n    };\n    color = float(iter / max_iter);\n    vec3 col = vec3(color)*vec3(t/zoom_cof*z.y, c.x*z.y, .5*z.x);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKBD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 133, 133, 189], [190, 190, 247, 297, 873]], "test": "untested"}
{"id": "slKfW3", "name": "Line 2D with lightning 3Dversion", "author": "rubioh", "description": "Approximately the same as https://www.shadertoy.com/view/styBW3 but with 3D-Sdf and raymarching algorithm", "tags": ["3d", "line", "lightning"], "likes": 3, "viewed": 206, "published": 3, "date": "1665391736", "time_retrieved": "2024-07-30T16:27:06.461537", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\nfloat lines(in vec2 pos){\n    float scale = 16.;\n    pos *= scale;\n    float v = sin(pos.x);\n    return smoothstep(-2., 2., v/fwidth(v));\n}\n\nfloat SceneSdf(vec3 p){\n    float h = 1.+cos(iTime*.5);\n    float l = length(p.xy);\n    return h*cos(l*2.*3.1415)-p.z;\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tvec2 diff = vec2(0.01, 0.);\n    float dist = SceneSdf(p);\n    \n    vec3 normal = dist - vec3(SceneSdf(p - diff.xyy),\n                              SceneSdf(p - diff.yxy),\n                              SceneSdf(p - diff.yyx) );\n    normal = normalize(normal);\n    normal.z *= -1.; // in order to have Upward normal\n    return (normal);\n}\n\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = SceneSdf(p);\n    depth += d;\n    if (d < PRECISION || depth > end) break;\n  }\n  return depth;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( 2.*fragCoord.xy - iResolution.xy ) / iResolution.y;\n    \n    vec3 backgroundColor = vec3(0., 0., 0.);\n    vec3 col;\n    vec3 normal;\n   \n    \n    \n    vec3 ro = vec3(0., 0., 5.+1.+cos(iTime*.5)); // ray origin that represents camera position\n   \n    vec3 rd = normalize(vec3(uv, -1));\n\n    float d = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // distance to sphere\n\n    if (d > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n    } else {\n    vec3 p = ro + rd * d; // point on sphere we discovered from ray marching\n    normal = GetNormal(p);\n    vec3 lightPosition = vec3(0, 0, 12);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    // Calculate diffuse reflection by taking the dot product of \n    // the normal and the light direction.\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n\n    vec2 xy = p.xy;\n    float angle = cos(length(xy*2.*3.1415));\n    angle *= cos(iTime)*.5 ;\n    mat2 rot = rotate2d(angle);  \n    xy = rot*xy;\n\n    vec2 st = vec2(length(xy), atan(xy.x, xy.y));\n\n    st.x *= smoothstep(.2, .21, length(xy));\n    st.y *= step(.02, length(xy));\n    float l = lines(st.yx);\n    col = vec3(l)+vec3(1.-l)*.2;\n\n\n    // Multiply the diffuse reflection value by an orange color and add a bit\n    // of the background color to the sphere to blend it more with the background.\n    col = dif * col;\n  }\n    vec3 res = vec3(0.);\n    if (uv.x>0.){\n        res = col;\n    }\n    else{\n        res = normal.xyz;\n    }\n  // Output to screen\n  fragColor = vec4(res, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKfW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 153, 153, 300], [301, 301, 326, 326, 440], [442, 442, 465, 465, 562], [564, 564, 588, 588, 926], [929, 929, 956, 956, 1038], [1041, 1041, 1099, 1099, 1312], [1315, 1315, 1372, 1422, 2953]], "test": "untested"}
{"id": "styBW3", "name": "Line 2d with lightning", "author": "rubioh", "description": "Approximation of the surface's normal.\nSome experiences on fake 3D randering\n", "tags": ["2d", "projection", "lightning"], "likes": 3, "viewed": 228, "published": 3, "date": "1665387327", "time_retrieved": "2024-07-30T16:27:09.472487", "image_code": "float lines(in vec2 pos){\n    float scale = 16.;\n    pos *= scale;\n    float v = sin(pos.x);\n    return smoothstep(-2., 2., v/fwidth(v));\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\n// Not real gradient just an approximation relativly ok when h is away from 0.\n// Anyway we could take any gradient since we are not dealing with a real predefine 3D structure\nvec3 calcNormal(vec2 uv, float angle) { \n float l = length(uv);\n uv = normalize(uv);\n float h = .5+abs(1.5*cos(iTime));\n float x = cos(l*16.-iTime)*uv.x;\n float y = cos(l*16.-iTime)*uv.y;\n float z = (.5+ .5*sin(l*16.-iTime))*h;\n return normalize(vec3(x, y, z));   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( 2.*fragCoord.xy - iResolution.xy ) / iResolution.y;\n    \n    float angle = .5+.5*sin(length(uv*16.)-iTime);\n    angle *= cos(iTime) ;\n    mat2 rot = rotate2d(angle);  \n    vec2 xy = uv;\n    uv = rot*uv;\n    \n    vec2 st = vec2(length(uv), atan(uv.x, uv.y));\n    \n    st.x *= smoothstep(.2, .21, length(uv));\n    st.y *= step(.02, length(uv));\n    float l = lines(st.yx);\n    // Time varying pixel color\n    vec3 col = vec3(l)+.2*vec3(1.-l);\n    \n    \n    float h = abs(angle);\n    vec3 p = vec3(uv.x, uv.y, h);\n    vec3 normal = calcNormal(xy, angle);\n    vec3 lightPosition = vec3(iMouse.x, iMouse.y, 1.);\n    vec3 lightDirection = normalize(lightPosition - p);\n    float dif = clamp(dot(lightDirection, normal), 0.2, 1.);\n    \n    col = col*dif;\n    \n    vec3 res = vec3(0.);\n    if (xy.x>0.){\n        res = col;\n    }\n    else{\n        res = normal.xyz;\n    }\n    \n    // Output to screen\n    fragColor = vec4(res, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/styBW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 139], [141, 141, 168, 168, 250], [252, 428, 467, 467, 694], [696, 696, 753, 803, 1745]], "test": "untested"}
{"id": "slyfDc", "name": "Noise - gradient - 3D (fork)", "author": "kara0xfb", "description": "Fork of iq's 2d gradient noise, but expanded to 3D (original: https://www.shadertoy.com/view/XdXGW8)\n", "tags": ["procedural", "3d", "noise", "perlin", "gradient"], "likes": 3, "viewed": 253, "published": 3, "date": "1665361951", "time_retrieved": "2024-07-30T16:27:10.318226", "image_code": "// The MIT License\n// Copyright  2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n\n// Gradient Noise (http://en.wikipedia.org/wiki/Gradient_noise), not to be confused with\n// Value Noise, and neither with Perlin's Noise (which is one form of Gradient Noise)\n// is probably the most convenient way to generate noise (a random smooth signal with \n// mostly all its energy in the low frequencies) suitable for procedural texturing/shading,\n// modeling and animation.\n//\n// It produces smoother and higher quality than Value Noise, but it's of course slighty more\n// expensive.\n//\n// The princpiple is to create a virtual grid/latice all over the plane, and assign one\n// random vector to every vertex in the grid. When querying/requesting a noise value at\n// an arbitrary point in the plane, the grid cell in which the query is performed is\n// determined, the four vertices of the grid are determined and their random vectors\n// fetched. Then, the position of the current point under  evaluation relative to each\n// vertex is doted (projected) with that vertex' random vector, and the result is\n// bilinearly interpolated with a smooth interpolant.\n\n\n// Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n// Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n// Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n// Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n// Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n// Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n// Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n// Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n// Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n// Wave     Noise 2D             : https://www.shadertoy.com/view/tldSRj\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec2 Pcg2(ivec2 v)\n{\n    uint x = uint(v.x);\n    uint y = uint(v.y);\n    x = x * 1664525u + 1013904223u;\n    y = y * 1664525u + 1013904223u;\n    x += y * 1664525u;\n    y += x * 1664525u;\n    x ^= x >> 16;\n    y ^= y >> 16;\n    x += y * 1664525u;\n    y += x * 1664525u;\n    return ivec2(x, y);\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec3 Pcg3(ivec3 v)\n{\n    uint x = uint(v.x);\n    uint y = uint(v.y);\n    uint z = uint(v.z);\n    x = x * 1664525u + 1013904223u;\n    y = y * 1664525u + 1013904223u;\n    z = z * 1664525u + 1013904223u;\n    x += y * z;\n    y += z * x;\n    z += x * y;\n    x ^= x >> 16;\n    y ^= y >> 16;\n    z ^= z >> 16;\n    x += y * z;\n    y += z * x;\n    z += x * y;\n    return ivec3(x, y, z);\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec4 Pcg4(ivec4 v)\n{\n    uint x = uint(v.x);\n    uint y = uint(v.y);\n    uint z = uint(v.z);\n    uint w = uint(v.w);\n    x = x * 1664525u + 1013904223u;\n    y = y * 1664525u + 1013904223u;\n    z = z * 1664525u + 1013904223u;\n    w = w * 1664525u + 1013904223u;\n    x += y * w;\n    y += z * x;\n    z += x * y;\n    w += y * z;\n    x ^= x >> 16;\n    y ^= y >> 16;\n    z ^= z >> 16;\n    w ^= w >> 16;\n    x += y * w;\n    y += z * x;\n    z += x * y;\n    w += y * z;\n    return ivec4(x, y, z, w);\n}\n\nvec2 grad2( ivec2 v )\n{\n    int n = Pcg2(v).x;\n    // higher quality rng in high bits\n    float x = (n & (1<<30)) != 0 ? 1.0 : -1.0;\n    float y = (n & (1<<29)) != 0 ? 1.0 : -1.0;\n    float z = (n & (1<<28)) != 0 ? 1.0 : -1.0;\n    vec3 gr = vec3(x, y, z);\n    return vec2(gr.x, gr.y);\n}\n\nvec3 grad3( ivec3 v)\n{\n    v = Pcg3(v);\n    // higher quality rng in high bits\n    float x = (v.x & (1<<30)) != 0 ? 1.0 : -1.0;\n    float y = (v.y & (1<<29)) != 0 ? 1.0 : -1.0;\n    float z = (v.z & (1<<28)) != 0 ? 1.0 : -1.0;\n    return vec3(x, y, z);\n}\n\nfloat noise2( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f * f * ((f * -2.0f) + 3.0f);\n\n    float c00 = dot(grad2(i + ivec2(0,0)), f - vec2(0.0, 0.0));\n    float c01 = dot(grad2(i + ivec2(1,0)), f - vec2(1.0, 0.0));\n    float c10 = dot(grad2(i + ivec2(0,1)), f - vec2(0.0, 1.0));\n    float c11 = dot(grad2(i + ivec2(1,1)), f - vec2(1.0, 1.0));\n    \n    float c = mix(mix(c00, c01, u.x), mix(c10, c11, u.x), u.y);\n    return c;\n}\n\nfloat noise3(in vec3 p)\n{\n    ivec3 i = ivec3(floor( p ));\n     vec3 f =       fract( p );\n\t\n\tvec3 u = f * f * ((f * -2.0f) + 3.0f);\n\n    float c000 = dot(grad3(i + ivec3(0,0,0)), f - vec3(0.0,0.0,0.0));\n    float c001 = dot(grad3(i + ivec3(0,0,1)), f - vec3(0.0,0.0,1.0));\n    \n    float c010 = dot(grad3(i + ivec3(0,1,0)), f - vec3(0.0,1.0,0.0));\n    float c011 = dot(grad3(i + ivec3(0,1,1)), f - vec3(0.0,1.0,1.0));\n    \n    float c100 = dot(grad3(i + ivec3(1,0,0)), f - vec3(1.0,0.0,0.0));\n    float c101 = dot(grad3(i + ivec3(1,0,1)), f - vec3(1.0,0.0,1.0));\n    \n    float c110 = dot(grad3(i + ivec3(1,1,0)), f - vec3(1.0,1.0,0.0));\n    float c111 = dot(grad3(i + ivec3(1,1,1)), f - vec3(1.0,1.0,1.0));\n    \n    float c00z = mix(c000, c001, u.z);\n    float c01z = mix(c010, c011, u.z);\n    float c10z = mix(c100, c101, u.z);\n    float c11z = mix(c110, c111, u.z);\n    \n    float c0yz = mix(c00z, c01z, u.y);\n    float c1yz = mix(c10z, c11z, u.y);\n    \n    float cxyz = mix(c0yz, c1yz, u.x);\n    \n    return cxyz;\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord / iResolution.xy;\n\t\n\tfloat f = 0.0;\n\n    vec2 uv2 = p*vec2(iResolution.x/iResolution.y,1.0);\n    vec3 uv3 = vec3(uv2.x, uv2.y,iTime);\n    uv3.xy = 32.0 * uv3.xy;\n    float freq = 1.0;\n    float scale = 1.0;\n    float peak = 0.0;\n    float u = min(p.x, 1.0);\n    float octaves = 1.0 + u * 3.0;\n    octaves = min(octaves, 4.0);\n    for (float i = 0.0; i < ceil(octaves); i += 1.0)\n    {\n        float amt = min(max(octaves - i, 0.0), 1.0);\n        scale *= amt;\n        peak += scale;\n        f += scale * noise3(uv3 * freq);\n        scale *= 0.55;\n        freq *= 2.0136;\n    }\n    f = f / peak;\n    f = 0.5 + 0.5*f;\n\t\n\tfragColor = vec4( f, f, f, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyfDc.jpg", "access": "api", "license": "mit", "functions": [[2942, 3043, 3064, 3064, 3338], [3340, 3441, 3462, 3462, 3821], [3823, 3924, 3945, 3945, 4417], [4419, 4419, 4442, 4442, 4705], [4707, 4707, 4729, 4729, 4960], [4962, 4962, 4989, 4989, 5438], [5440, 5440, 5465, 5465, 6460], [6514, 6514, 6571, 6571, 7249]], "test": "untested"}
{"id": "NlKBWG", "name": "K-Means Cluster Blobs", "author": "fenix", "description": "A demonstration of k-means clustering on particles in a cube.\n\nhttps://en.wikipedia.org/wiki/K-means_clustering\n\n*space to reset and advance to next scene*\n*mouse to move camera, also pauses scene advance*", "tags": ["3d", "voronoi", "blobs", "particles", "kmeans", "cluster"], "likes": 12, "viewed": 493, "published": 3, "date": "1665349430", "time_retrieved": "2024-07-30T16:27:11.281650", "image_code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Demonstration of a k-means clustering algorithm:\n//\n//     https://en.wikipedia.org/wiki/K-means_clustering\n//\n// K-means clustering is a sort of particle sim, where the particles are the centers\n// of clusters. The points themselves are fixed in space and cannot move, but they\n// each keep track of which cluster they're in, which is the cluster with the closest\n// center. This is therefore a type of voronoi diagram. The simulation part is that \n// the cluster centers shift around, moving away from where they're not needed,\n// eventually producing an even-ish distribution of points between clusters.\n//\n// I realize there are still some artifacts at the edges between clusters...if anyone\n// has any advice about those, I'm all ears!\n//\n// Buffers A, C and D update cluster centers and perform neighbor searching\n// Buffer B computes nearest cluster to each screen pixel to accelerate rendering\n// Image renders\n//\n// --------------------------------------------------------------------------------------------\n\n\n// https://www.shadertoy.com/view/llySRh\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n // if ( p.x>.25&& p.x<.75 && p.y>.0&& p.y<1. )  // normal char box\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) // thighly y-clamped to allow dense text\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\n    return vec4(0);\n}\nvec4 draw_char() {\n    int c = char_id; vec2 p = char_pos;\n    return c < 0 \n        ? vec4(0,0,0,1e5)\n        : textureGrad( iChannel2, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                       dfdx, dfdy );\n}\n\nvec4 pInt(vec2 p, float n) {  // webGL2 variant with dynamic size\n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .5 )\n        v += char(p, 48+ i%10 );\n    return v;\n}\n\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc O+= char(U,64+CAPS+c);\n\nconst float SDF_EPSILON = 0.001;\n\n// Holds positions for each cluster as we render\nvec3 posArray[33];\nint arrayCount;\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat sphereSize, sminK;\n\nfloat scene(vec3 p)\n{\n    float d = 1e6;\n    for (int i = 0; i < arrayCount; ++i)\n    {\n        d = smin(d, sdSphere(p - posArray[i], sphereSize), sminK);\n    }\n    \n    return d;\n}\n\nvec3 rayMarch(vec3 pos, vec3 dir, out float t)\n{\n    t = 0.;\n    for (int i = 0; i < 250; ++i)\n    {\n        float d = scene(pos);\n        \n        if (d < SDF_EPSILON || t > MAX_T)\n        {\n            break;\n        }\n        \n        float slowdown = 1.;//max(d * 1., 0.1);\n        t += d * slowdown;\n\n        pos += dir * d * slowdown;\n    }\n \n    return pos;\n}\n\nvec3 grad(vec3 p, float d)\n{\n    vec2 delta = vec2(d, 0);\n    return normalize(\n           vec3(scene(p + delta.xyy) - scene(p - delta.xyy),\n                scene(p + delta.yxy) - scene(p - delta.yxy),\n                scene(p + delta.yyx) - scene(p - delta.yyx)));\n}\n\nvoid doText(vec2 uv, inout vec4 O, vec4 state)\n{\n    vec2 R = iResolution.xy, U;\n    uv /= R.y;    \n    int lod = int(mod(iTime,10.));\n    \n    U = ( uv - vec2(.0,.9) ) * 16.;  caps C(14) U.x -= 0.3; C(-3)  // \"K=\"\n    U.x -= 3.3; O += pInt(U, DEMOS[int(state.z)].x); \n\n    U = ( uv - vec2(.0,.8) ) * 16.;  caps C(11)  U.x -= 0.3; C(-3)  // \"K=\"\n    U.x -= 3.3; O += pInt(U, DEMOS[int(state.z)].y); \n                             \n    O += draw_char().xxxx;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(iTime, iMouse, iResolution, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n\tvec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    ivec4 old = fxGetClosest( ivec2(fragCoord) );   \n    arrayCount = 0;\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    \n    sphereSize = DEMOS[int(state.z)].z;\n    sminK = DEMOS[int(state.z)].w;\n\n    fragColor = vec4(0,0,0,1);\n\n    float minT = MAX_T;\n    int hitId = int(1e6);\n    for(int j=0; j<4; j++)\n    {\n        int id = old[j];\n        if (id != 0 && id != -1)\n        {\n            fxParticle p = fxGetParticle(id);\n            \n            arrayCount = 1;\n            posArray[0] = p.pos;\n            \n            for (int i = 0; i < 8; ++i)\n            {\n                for (int k = 0; k < 4; ++k)\n                {\n                    int nid = p.neighbors[i][k];\n                    \n                    vec4 nb = fxGetParticleData(nid, POS);\n                    \n                    if (nb.w == float(id))\n                    {\n                        posArray[arrayCount++] = nb.xyz;\n                    }\n                }\n            }\n            \n            float t;\n            vec3 hit = rayMarch(cameraPos, rayDir, t);\n\n            if (t < minT)// * 0.999 || t < minT * 1.001 && id < hitId)\n            {\n                minT = t;\n                hitId = id;\n                \n                vec3 lightDir = normalize(vec3(1,1,1));\n                vec3 g = grad(hit, 0.001);\n                float dp = dot(g, lightDir);\n                float spec = dp > 0.0 ? pow(dp, 25.0) : 0.;\n                float ambient = 0.5;\n                float phong = abs(dp) * (1.-ambient) + ambient;\n                vec3 color = (sin(p.color * vec3(3, 99, 49)) + 1.) * 0.5;\n                \n                fragColor.xyz = phong * color + spec;\n                fragColor.a = 1.;\n            }\n        }\n    }\n    \n    fragColor.xyz = mix(fragColor.xyz, vec3(0.4), smoothstep(MAX_T * 0.8, MAX_T, minT));\n \n    doText(fragCoord, fragColor, state);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float MAX_T = 13.;\n\nconst int NUM_DEMOS = 5;\nconst vec4[NUM_DEMOS] DEMOS = vec4[NUM_DEMOS](\n    // N, K, sphere size, smin k\n    vec4(5000, 500, 0.2, 9.),\n    vec4(10000, 2000, 0.1, 8.),\n    vec4(1000, 200, 0.3, 7.),\n    vec4(5000, 1000, 0.2, 8.),\n    vec4(10000, 500, 0.1, 8.)\n);\n\nconst float PI = 3.141592653589793;\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\nuvec4 hash(uvec3 x0){\n    uvec4 x = x0.xyzz;\n    x = ((x >> 16u) ^ x.yzxy) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzxz) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzxx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\nvec4 noise(ivec4 p){\n    const float scale = pow(2., -32.);\n    uvec4 h = hash(uvec4(p));\n    return vec4(h)*scale;\n}\n\nvec4 noise(ivec3 p){\n    const float scale = 1.0/float(0xffffffffU);\n    uvec4 h = hash(uvec3(p));\n    return vec4(h)*scale;\n}\n\nvec4 noise(ivec2 p){\n    return noise(ivec3(p, 0));\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nvoid fxCalcCamera(in float iTime, in vec4 iMouse, in vec3 iResolution, out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    float animate = (iMouse.x / iResolution.x) * 2.0 - 0.5;\n    \n    cameraLookAt = vec3(0.0, 0.0f, 0.0);\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 1.1*3.14 + iTime * 0.01;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.75*3.14;\n    cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 15.0;\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft  = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd)) * 0.5;\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-0.5*resolution.y / resolution.x * cameraLeft, 0.0),\n        vec4(-0.5*cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 1.0 - 0.5;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nconst float MAX_TEMP = 1000.0;\n\nvec3 fxBlackBody(float _t)\n{\n    vec3 temp = vec3(min(1.0, _t / MAX_TEMP), min(1.0, _t / (2.0 * MAX_TEMP)), min(1.0, _t / (3.0 * MAX_TEMP)));\n    return temp * temp * temp * temp;\n}\n\nfloat fxLinePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    vec2 closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    //closestDelta *= resolution.xy / resolution.y;\n    return dot(closestDelta, closestDelta);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define FUL_NEIGHBORS 0\n#define FUR_NEIGHBORS 1\n#define FLL_NEIGHBORS 2\n#define FLR_NEIGHBORS 3\n#define BUL_NEIGHBORS 4\n#define BUR_NEIGHBORS 5\n#define BLL_NEIGHBORS 6\n#define BLR_NEIGHBORS 7\n#define POS 8\n#define VEL 9\n#define NUM_PARTICLE_DATA_TYPES 10\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec3 pos;\n    float color;\n    float cluster;\n    \n    ivec4 neighbors[8];\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, FUL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, FUR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, FLL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, FLR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, BUL_NEIGHBORS), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, BUR_NEIGHBORS), 0);\n    vec4 particleData6 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, BLL_NEIGHBORS), 0);\n    vec4 particleData7 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, BLR_NEIGHBORS), 0);\n    vec4 particleData8 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS), 0);\n    vec4 particleData9 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, VEL), 0);\n\n    fxParticle particle;\n    particle.neighbors[0] = ivec4(particleData0);\n    particle.neighbors[1] = ivec4(particleData1);\n    particle.neighbors[2] = ivec4(particleData2);\n    particle.neighbors[3] = ivec4(particleData3);\n    particle.neighbors[4] = ivec4(particleData4);\n    particle.neighbors[5] = ivec4(particleData5);\n    particle.neighbors[6] = ivec4(particleData6);\n    particle.neighbors[7] = ivec4(particleData7);\n    particle.pos = particleData8.xyz;\n    particle.cluster = float(particleData8.w);\n    particle.color = particleData9.w;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case FUL_NEIGHBORS:\n        return vec4(p.neighbors[0]);\n    case FUR_NEIGHBORS:\n        return vec4(p.neighbors[1]);\n    case FLL_NEIGHBORS:\n        return vec4(p.neighbors[2]);\n    case FLR_NEIGHBORS:\n        return vec4(p.neighbors[3]);\n    case BUL_NEIGHBORS:\n        return vec4(p.neighbors[4]);\n    case BUR_NEIGHBORS:\n        return vec4(p.neighbors[5]);\n    case BLL_NEIGHBORS:\n        return vec4(p.neighbors[6]);\n    case BLR_NEIGHBORS:\n        return vec4(p.neighbors[7]);\n    case POS:  \n        return vec4(p.pos, int(p.cluster));\n    case VEL:\n        return vec4(0, 0, 0, p.color);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n\n#define KEY_SPACE 32\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Computes the position and velocity of each particle, one per texture fragment. Buffers\n// A, C and D are chained for triple convergence speed.\n// ---------------------------------------------------------------------------------------\n\nconst vec3 GRAVITY = vec3(0.0,0.0,0.0);\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in fxParticle myPos);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    int maxParticles = int(DEMOS[int(state.z)].x);\n    int clusterParticles = int(DEMOS[int(state.z)].y);\n    if(id>=maxParticles) return;\n    \n    fxParticle p = fxGetParticle(id);\n    \n    if (dataType >= POS)\n    {\n        float closestColor = 0.;\n        float closestDist = 1e30;\n        float closestCluster = -1.;\n        vec3 center = vec3(0);\n        float count = 0.;\n        for(int i = 0; i < 8; i++)\n        {\n            ivec4 neighbors = p.neighbors[i];\n            for (int j = 0; j < 4; ++j)\n            {\n                int cid = neighbors[j];\n                if(cid==id || cid==-1 || cid == 0 || cid >= maxParticles) continue;\n\n                vec4 n = fxGetParticleData(cid, POS);\n                \n                if (n.w == float(id))\n                {\n                    center += n.xyz;\n                    count++;\n                }\n\n                vec3 deltaPos = p.pos - n.xyz;\n                float dist2 = dot(deltaPos, deltaPos) + 0.0001;\n                \n                if (dist2 < closestDist)\n                {\n                    closestDist = dist2;\n                    closestColor = fxGetParticleData(cid, VEL).w;\n\n                    closestCluster = float(cid);\n                }\n            }\n        }\n        \n        if (p.cluster == -1.)\n        {\n            if (count > 0.)\n            {\n                p.pos = center / count;\n            }\n        }\n        else if (closestCluster != -1.)\n        {\n            p.color = closestColor;\n            p.cluster = closestCluster;\n        }\n\n        // Reset particles\n        if ((iFrame % 3000) == 0 || state.y < 0.)\n        {\n            const float XZ_SPREAD = 1.01;\n            const float Y_SPREAD = 1.01;\n\n            p.pos = (noise(ivec2(fragCoord) + iFrame) - 0.5).xyz * 8.;\n\n            vec4 h = noise(ivec2(fragCoord) + iFrame + 3);\n            p.color = h.y;\n            p.cluster = id < clusterParticles ? -1. : 0.;\n        }\n\n        fragColor = fxSaveParticle(p, dataType);\n    }\n    else\n    {\n        // Nearest particle sort inspired by michael0884's Super SPH: https://www.shadertoy.com/view/tdXBRf\n        //sort neighbors and neighbor neighbors\n        ivec4 bestIds = ivec4(-1);\n        vec4 bestDists = vec4(1e6);\n        \n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, int(p.neighbors[0][i]), dataType, p);  //sort this\n            sort0(bestIds, bestDists, id, int(p.neighbors[1][i]), dataType, p);  //sort this\n            sort0(bestIds, bestDists, id, int(p.neighbors[2][i]), dataType, p);  //sort this\n            sort0(bestIds, bestDists, id, int(p.neighbors[3][i]), dataType, p);  //sort this\n            sort0(bestIds, bestDists, id, int(p.neighbors[4][i]), dataType, p);  //sort this\n            sort0(bestIds, bestDists, id, int(p.neighbors[5][i]), dataType, p);  //sort this\n            sort0(bestIds, bestDists, id, int(p.neighbors[6][i]), dataType, p);  //sort this\n            sort0(bestIds, bestDists, id, int(p.neighbors[7][i]), dataType, p);  //sort this\n        }\n        \n        int searchIterations = 15;\n        for(int k = 0; k < searchIterations; k++){\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash(\n                iFragCoord.x + \n                iFragCoord.y*int(iResolution.x) + \n                iFrame*int(iResolution.x*iResolution.y) +\n                k\n            );\n            //pick random id of particle\n            int hi;\n            if (p.cluster == -1.)\n            {\n                hi = int(mod(h*34534.0, float(maxParticles - clusterParticles))) + clusterParticles;\n            }\n            else\n            {\n                hi = int(mod(h*34534.0, float(clusterParticles)));\n            }\n            sort0(bestIds, bestDists, id, int(hi), dataType, p);  //sort this\n        }\n        fragColor = vec4(bestIds);\n    }\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id < 0 ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in fxParticle myParticle)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec4 nbX = fxGetParticleData(searchId, POS); \n    const float CLUSTER = intBitsToFloat(-1);\n    if (myParticle.cluster != -1. && nbX.w != -1.) return; // particle only neighbors with cluster particles\n    if (myParticle.cluster == -1. && (nbX.w != float(currentId))) return; // cluster particles only neighbors with particles\n\n    vec3 dx = nbX.xyz - myParticle.pos;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI) + (dx.z > 0. ? 4 : 0); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = dot(dx, dx);\n    \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "const float SWITCH_DEMO_TIME = 20.0;\n\n// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\n\nfloat distance2Particle(int id, vec2 fragCoord, mat4 w2cNew){\n\n    if(id==-1) return 1e20;\n    //vec4 worldPos = fxGetParticleData(id, POS);\n    fxParticle p = fxGetParticle(id);\n    float d = 1e6;\n    for(int i = 0; i < 8; i++)\n    {\n        ivec4 neighbors = p.neighbors[i];\n        for (int j = 0; j < 4; ++j)\n        {\n            vec4 worldPos = fxGetParticleData(neighbors[j], POS);\n            if (worldPos.w != float(id)) continue;\n            vec3 screenPos = (w2cNew * vec4(worldPos.xyz,1.0)).xyz;\n            screenPos.xy = screenPos.xy / screenPos.z;\n            if (screenPos.z > MAX_T) continue; // Discard beyond far clip\n            vec2 delta = (screenPos.xy)-fragCoord;\n            float dist = dot(delta, delta)+0.013*screenPos.z;\n            d = min(d, dist);\n        }\n    }\n\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n    if(iFragCoord == ivec2(0))\n    {\n        // Reset if resolution changes\n        vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n        if (iFrame == 0 || state.y > SWITCH_DEMO_TIME || iResolution.x * iResolution.y != state.x || keyClick(KEY_SPACE))\n        {\n            state.xyw = vec3(iResolution.x * iResolution.y, -1, 0);\n\n            if (iFrame == 0)\n            {\n                state.z = 0.;\n            }\n            else\n            {\n                state.z = float((int(state.z) + 1) % NUM_DEMOS);\n            }\n        }\n        else if (iMouse.z <= 0.)\n        {\n            state.y += iTimeDelta;\n        }\n        \n        fragColor = state;\n        return;\n    }\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(iTime, iMouse, iResolution, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    // camera-to-world and world-to-camera transform\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n\n    ivec4 old   = fxGetClosest( iFragCoord );      \n    for(int j=0; j<4; j++){\n        int id = old[j];\n        float dis2 = distance2Particle(id, p, w2c);\n        insertion_sort( new, dis, id, dis2 );\n    }\n\n    uint searchRange = 15u;\n    uint searchCount = 2u;\n    \n    for(uint i=0u; i<searchCount; ++i)\n    {\n        uvec4 h0 = hash(uvec4(fragCoord, iFrame, iResolution.x) * i);\n\n        ivec4 old   = fxGetClosest( iFragCoord + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n        for(int j=0; j<2; j++){\n            int id = old[j];\n            float dis2 = distance2Particle(id, p, w2c);\n            insertion_sort( new, dis, id, dis2 );\n        }        \n    }\n\n    int searchIterations = (iFrame % 4) == 0 ? 1 : 0;\n    if (iFrame < 5)\n    {\n        searchIterations = 4;\n    }\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    int clusterParticles = int(DEMOS[int(state.z)].y);\n    for(int k = 0; k < searchIterations; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n\n        //pick random id of particle\n        int id = int(h * float(clusterParticles));\n        insertion_sort(new, dis, id, distance2Particle(id, p, w2c));\n    }\n    \n    fragColor = vec4(new);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------------\n// Computes the position and velocity of each particle, one per texture fragment. Buffers\n// A, C and D are chained for triple convergence speed.\n// ---------------------------------------------------------------------------------------\n\nconst vec3 GRAVITY = vec3(0.0,0.0,0.0);\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in fxParticle myPos);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    int maxParticles = int(DEMOS[int(state.z)].x);\n    int clusterParticles = int(DEMOS[int(state.z)].y);\n    if(id>=maxParticles) return;\n    \n    fxParticle p = fxGetParticle(id);\n    \n    if (dataType >= POS)\n    {\n        float closestColor = 0.;\n        float closestDist = 1e30;\n        float closestCluster = -1.;\n        vec3 center = vec3(0);\n        float count = 0.;\n        for(int i = 0; i < 8; i++)\n        {\n            ivec4 neighbors = p.neighbors[i];\n            for (int j = 0; j < 4; ++j)\n            {\n                int cid = neighbors[j];\n                if(cid==id || cid==-1 || cid == 0 || cid >= maxParticles) continue;\n\n                vec4 n = fxGetParticleData(cid, POS);\n                \n                if (n.w == float(id))\n                {\n                    center += n.xyz;\n                    count++;\n                }\n\n                vec3 deltaPos = p.pos - n.xyz;\n                float dist2 = dot(deltaPos, deltaPos) + 0.0001;\n                \n                if (dist2 < closestDist)\n                {\n                    closestDist = dist2;\n                    closestColor = fxGetParticleData(cid, VEL).w;\n\n                    closestCluster = float(cid);\n                }\n            }\n        }\n        \n        if (p.cluster == -1.)\n        {\n            if (count > 0.)\n            {\n                p.pos = center / count;\n            }\n        }\n        else if (closestCluster != -1.)\n        {\n            p.color = closestColor;\n            p.cluster = closestCluster;\n        }\n\n        // Reset particles\n        if ((iFrame % 3000) == 0 || state.y < 0.)\n        {\n            const float XZ_SPREAD = 1.01;\n            const float Y_SPREAD = 1.01;\n\n            p.pos = (noise(ivec2(fragCoord) + iFrame) - 0.5).xyz * 8.;\n\n            vec4 h = noise(ivec2(fragCoord) + iFrame + 3);\n            p.color = h.y;\n            p.cluster = id < clusterParticles ? -1. : 0.;\n        }\n\n        fragColor = fxSaveParticle(p, dataType);\n    }\n    else\n    {\n        // Nearest particle sort inspired by michael0884's Super SPH: https://www.shadertoy.com/view/tdXBRf\n        //sort neighbors and neighbor neighbors\n        ivec4 bestIds = ivec4(-1);\n        vec4 bestDists = vec4(1e6);\n        \n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, int(p.neighbors[0][i]), dataType, p);  //sort this\n            sort0(bestIds, bestDists, id, int(p.neighbors[1][i]), dataType, p);  //sort this\n            sort0(bestIds, bestDists, id, int(p.neighbors[2][i]), dataType, p);  //sort this\n            sort0(bestIds, bestDists, id, int(p.neighbors[3][i]), dataType, p);  //sort this\n            sort0(bestIds, bestDists, id, int(p.neighbors[4][i]), dataType, p);  //sort this\n            sort0(bestIds, bestDists, id, int(p.neighbors[5][i]), dataType, p);  //sort this\n            sort0(bestIds, bestDists, id, int(p.neighbors[6][i]), dataType, p);  //sort this\n            sort0(bestIds, bestDists, id, int(p.neighbors[7][i]), dataType, p);  //sort this\n        }\n        \n        int searchIterations = 15;\n        for(int k = 0; k < searchIterations; k++){\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash(\n                iFragCoord.x + \n                iFragCoord.y*int(iResolution.x) + \n                iFrame*int(iResolution.x*iResolution.y) +\n                k\n            );\n            //pick random id of particle\n            int hi;\n            if (p.cluster == -1.)\n            {\n                hi = int(mod(h*34534.0, float(maxParticles - clusterParticles))) + clusterParticles;\n            }\n            else\n            {\n                hi = int(mod(h*34534.0, float(clusterParticles)));\n            }\n            sort0(bestIds, bestDists, id, int(hi), dataType, p);  //sort this\n        }\n        fragColor = vec4(bestIds);\n    }\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id < 0 ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in fxParticle myParticle)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec4 nbX = fxGetParticleData(searchId, POS); \n    const float CLUSTER = intBitsToFloat(-1);\n    if (myParticle.cluster != -1. && nbX.w != -1.) return; // particle only neighbors with cluster particles\n    if (myParticle.cluster == -1. && (nbX.w != float(currentId))) return; // cluster particles only neighbors with particles\n\n    vec3 dx = nbX.xyz - myParticle.pos;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI) + (dx.z > 0. ? 4 : 0); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = dot(dx, dx);\n    \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// ---------------------------------------------------------------------------------------\n// Computes the position and velocity of each particle, one per texture fragment. Buffers\n// A, C and D are chained for triple convergence speed.\n// ---------------------------------------------------------------------------------------\n\nconst vec3 GRAVITY = vec3(0.0,0.0,0.0);\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in fxParticle myPos);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    int maxParticles = int(DEMOS[int(state.z)].x);\n    int clusterParticles = int(DEMOS[int(state.z)].y);\n    if(id>=maxParticles) return;\n    \n    fxParticle p = fxGetParticle(id);\n    \n    if (dataType >= POS)\n    {\n        float closestColor = 0.;\n        float closestDist = 1e30;\n        float closestCluster = -1.;\n        vec3 center = vec3(0);\n        float count = 0.;\n        for(int i = 0; i < 8; i++)\n        {\n            ivec4 neighbors = p.neighbors[i];\n            for (int j = 0; j < 4; ++j)\n            {\n                int cid = neighbors[j];\n                if(cid==id || cid==-1 || cid == 0 || cid >= maxParticles) continue;\n\n                vec4 n = fxGetParticleData(cid, POS);\n                \n                if (n.w == float(id))\n                {\n                    center += n.xyz;\n                    count++;\n                }\n\n                vec3 deltaPos = p.pos - n.xyz;\n                float dist2 = dot(deltaPos, deltaPos) + 0.0001;\n                \n                if (dist2 < closestDist)\n                {\n                    closestDist = dist2;\n                    closestColor = fxGetParticleData(cid, VEL).w;\n\n                    closestCluster = float(cid);\n                }\n            }\n        }\n        \n        if (p.cluster == -1.)\n        {\n            if (count > 0.)\n            {\n                p.pos = center / count;\n            }\n        }\n        else if (closestCluster != -1.)\n        {\n            p.color = closestColor;\n            p.cluster = closestCluster;\n        }\n\n        // Reset particles\n        if ((iFrame % 3000) == 0 || state.y < 0.)\n        {\n            const float XZ_SPREAD = 1.01;\n            const float Y_SPREAD = 1.01;\n\n            p.pos = (noise(ivec2(fragCoord) + iFrame) - 0.5).xyz * 8.;\n\n            vec4 h = noise(ivec2(fragCoord) + iFrame + 3);\n            p.color = h.y;\n            p.cluster = id < clusterParticles ? -1. : 0.;\n        }\n\n        fragColor = fxSaveParticle(p, dataType);\n    }\n    else\n    {\n        // Nearest particle sort inspired by michael0884's Super SPH: https://www.shadertoy.com/view/tdXBRf\n        //sort neighbors and neighbor neighbors\n        ivec4 bestIds = ivec4(-1);\n        vec4 bestDists = vec4(1e6);\n        \n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, int(p.neighbors[0][i]), dataType, p);  //sort this\n            sort0(bestIds, bestDists, id, int(p.neighbors[1][i]), dataType, p);  //sort this\n            sort0(bestIds, bestDists, id, int(p.neighbors[2][i]), dataType, p);  //sort this\n            sort0(bestIds, bestDists, id, int(p.neighbors[3][i]), dataType, p);  //sort this\n            sort0(bestIds, bestDists, id, int(p.neighbors[4][i]), dataType, p);  //sort this\n            sort0(bestIds, bestDists, id, int(p.neighbors[5][i]), dataType, p);  //sort this\n            sort0(bestIds, bestDists, id, int(p.neighbors[6][i]), dataType, p);  //sort this\n            sort0(bestIds, bestDists, id, int(p.neighbors[7][i]), dataType, p);  //sort this\n        }\n        \n        int searchIterations = 15;\n        for(int k = 0; k < searchIterations; k++){\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash(\n                iFragCoord.x + \n                iFragCoord.y*int(iResolution.x) + \n                iFrame*int(iResolution.x*iResolution.y) +\n                k\n            );\n            //pick random id of particle\n            int hi;\n            if (p.cluster == -1.)\n            {\n                hi = int(mod(h*34534.0, float(maxParticles - clusterParticles))) + clusterParticles;\n            }\n            else\n            {\n                hi = int(mod(h*34534.0, float(clusterParticles)));\n            }\n            sort0(bestIds, bestDists, id, int(hi), dataType, p);  //sort this\n        }\n        fragColor = vec4(bestIds);\n    }\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id < 0 ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in fxParticle myParticle)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec4 nbX = fxGetParticleData(searchId, POS); \n    const float CLUSTER = intBitsToFloat(-1);\n    if (myParticle.cluster != -1. && nbX.w != -1.) return; // particle only neighbors with cluster particles\n    if (myParticle.cluster == -1. && (nbX.w != float(currentId))) return; // cluster particles only neighbors with particles\n\n    vec3 dx = nbX.xyz - myParticle.pos;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI) + (dx.z > 0. ? 4 : 0); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = dot(dx, dx);\n    \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKBWG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1319, 1319, 1345, 1345, 1635], [1636, 1636, 1654, 1654, 1853], [1855, 1855, 1883, 1920, 2040], [2278, 2278, 2311, 2311, 2339], [2341, 2382, 2423, 2423, 2497], [2525, 2525, 2546, 2546, 2706], [2708, 2708, 2756, 2756, 3074], [3076, 3076, 3104, 3104, 3342], [3804, 3804, 3861, 3861, 5981]], "test": "untested"}
{"id": "ftyfzt", "name": "Star blizzard", "author": "Dave_Hoskins", "description": "Speed test for random cloud particle rendering.\nUses a bounding sphere for fast step marching into a shaped voxel cloud.\nThe anti-aliasing also helps the time smearing by increasing sampling.", "tags": ["3d", "voxel", "stars", "blizzard", "temporalantialiasing"], "likes": 32, "viewed": 540, "published": 3, "date": "1665347351", "time_retrieved": "2024-07-30T16:27:12.291948", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/ftyfzt\n// By David Hoskins, 2022.\n\nvec3 camPos, camTar, camRay;\nfloat gTime, gTimeDelta;\n\n#define MOUSE_SCRUB\n//#define SHOW_BOUNDING\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\n\n#define tri(x) abs(fract(x)-.5)*2.\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash13(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\n//----------------------------------------------------------------------------------------------------------\n// Flattened torus...\nfloat disc( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y*1.5);\n  return length(q)-t.y;\n}\n\n//----------------------------------------------------------------------------------------------------------\nvec3 getColour(vec3 id)\n {\n\n   return cos(id*13.)*.4+.6;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\t\n    return mix(mix(mix( hash13(p+vec3(0,0,0)), \n                        hash13(p+vec3(1,0,0)),f.x),\n                   mix( hash13(p+vec3(0,1,0)), \n                        hash13(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash13(p+vec3(0,0,1)), \n                        hash13(p+vec3(1,0,1)),f.x),\n                   mix( hash13(p+vec3(0,1,1)), \n                        hash13(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n//-------------------------------------------------------------------------------------------------------\n\nfloat smthU(float k, float d1, float d2)\n{\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h); \n}\n//-------------------------------------------------------------------------------------------------------\nvec2 boundingSphere(vec3  ro, vec3  rd,vec3 cen, float rad)\n{\n    ro = (ro - cen)/ rad;\n    float d = dot(rd,ro);\n    float c = dot(ro,ro) - 1.0;\n    float h = d*d - c;\n\n    \n    if (h < 0.0 ) return vec2(-1); // Not intersecting\n\t\n    h = sqrt( h );\n    float t1 = -d - h;\n    float t2 = -d + h;\n    \n    if( t2 < 0.0) return  vec2(-1);  //...Behind \n\n    t1 = max( t1, 0.0 );\n    t2 = max( t2, 0.0 );\n\n    return vec2(t1, t2) * rad; // ...Return front and back points rescaled.\n}\n\n//-------------------------------------------------------------------------------------------------------\nfloat  mapGalaxy(vec3 p)\n{\n    float d = disc(p, vec2(55,35));\n    float d2 = disc(p, vec2(85,15));\n    d = min(d, d2);\n\n    float d3 = length(p)-62.;\n    d = smthU(20.0, d, d3);\n    return d;\n}\n\n//----------------------------------------------------------------------------------------------------------\nvec2 distanceRayPoint(vec3 ro, vec3 rd, vec3 p)\n{\n    p -= ro;\n    float h = dot(p,rd);\n    return vec2(length(p-rd*h), h);\n}\n\n//----------------------------------------------------------------------------------------------------------\nvec3 getOffset(in vec3 id, float si)\n{\n    return clamp(tri(id*3.53), si*.25, (1.-si*.25));\n}\n\n//----------------------------------------------------------------------------------------------------------\nvec3 renderStars(in vec3 ro, in vec3 rd, in vec2 bounds)\n{ \n \n    vec2 d;\n    ro += rd * bounds.x;\n    int dist = int(bounds.y - bounds.x);\n\n   \n \tvec3 pos = floor(ro),\n         ri = 1./rd,\n\t\t rs = sign(rd),\n\t\t dis = (pos-ro + 0.5 +rs*.5) * ri,\n         sum = vec3(0), col = sum;\n    \n    // Go as far as the back of the bounding sphere\n\tfor( int i = 0; i < dist; i++ )\n    {\n        vec3 id = hash33(pos*139.31);\n        float si = (id.y+id.z)*.2+.1;\n\n        vec3 offset = getOffset(id, si);\n\n        d = distanceRayPoint(ro, rd, pos+offset);\n        if (d.y > 0.0)\n        {\n            float  gal = mapGalaxy(pos+offset);\n            if (gal < 0.0)\n            {\n                vec3 mat = getColour(id);\n                float f = pow(smoothstep(si, 0.0,d.x), 20.0)*1.5;\n                col = mat * f;\n                sum += col;\n                sum += vec3(-gal*.0001,-gal*.0001,-gal*.00002 );\n                //fade *= .9;\n            }\n        }\n\n\n\t\tvec3 st = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n\t\tdis += st * rs * ri;\n        pos += st * rs;\n\n\t}\n  \n\treturn sum*.15;\n}\n\n//----------------------------------------------------------------------------------------------------------\nvec3 getSky(vec3 pos)\n{\n\tfloat t = 0.0, a = 3.;\n    pos *= 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        float v = noise(pos);\n        v = pow(abs(v-.5), 4.)*3.;\n        t += v * a;\n        pos *= 2.1;\n        pos.xy *= mat2(.7, .5, -.5, .7);\n        a *= .53;\n        //pos.x *= pos.z;\n\n    }\n    //\n\n\n\treturn vec3(t*.7, t*.7, t*.7);\n}\n\n//----------------------------------------------------------------------------------------------------------\n// Do some basic camera positioning...\nvoid getPath()\n{\n   float r = cos(gTime*.8+1.0)*50.0 + 80.0;\n\tcamPos = vec3(sin(gTime*2.)*r+10., sin(gTime*1.5)*10.+5., cos(gTime*2.)*r);\n    camTar = vec3(0,0,0);\n }\n\n//----------------------------------------------------------------------------------------------------------\nvec3 getCamera(vec2 uv)\n{\n    vec3 cw = normalize(camTar-camPos);\n\tvec3 cu = normalize(cross(cw,vec3(0,1,0)));\n\tvec3 cv = normalize(cross(cu,cw));\n    return normalize(uv.x*cu + uv.y*cv + cw * .5);\n}\n\n//----------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gT = iTime *.25;\n\n    #ifdef MOUSE_SCRUB\n    gT += iMouse.x*30./iResolution.x;\n    #endif\n    // Got to do a single camera pass to find the bounding sphere...\n    gTime = gT;\n    getPath();\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    camRay = getCamera(uv);\n    vec2 bounds = boundingSphere(camPos, camRay, vec3(0), 95.); \n    \n    \n    vec3 col = getSky(camRay); // Just a simple FBM background.\n    if (bounds.x >= 0.)\n    {\n        #ifdef SHOW_BOUNDING\n        col += vec3(.1,0,0);\n        #endif\n        for (int aa = 0; aa < 4; aa++)\n        {\n            vec2 co = (fragCoord*2. + vec2(aa & 1, (aa >> 1)));// Get anti-aliasing position\n\n            \n            gTime = gT- hash12(co)*iTimeDelta; //...Scatter the time line\n            getPath();\n            vec2 uv = (co-iResolution.xy)/iResolution.y;\n            camRay = getCamera(uv);\n            col += renderStars(camPos, camRay, bounds);\n        }\n    }\n    \n    col = clamp(col, 0.0, 1.0);\n    col = col*col*(3.0-2.0*col); // ...Stretch for higher contrast\n    col *= smoothstep(0.0, 4.0, iTime); //...Fade in\n\n    \n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyfzt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[485, 599, 621, 621, 710], [712, 826, 847, 847, 934], [936, 1050, 1072, 1072, 1167], [1169, 1300, 1330, 1330, 1399], [1401, 1510, 1536, 1536, 1568], [1570, 1570, 1596, 1596, 2098], [2207, 2207, 2249, 2249, 2345], [2346, 2452, 2513, 2513, 2933], [2935, 3041, 3067, 3067, 3235], [3237, 3346, 3395, 3395, 3471], [3473, 3582, 3620, 3620, 3675], [3677, 3786, 3844, 3844, 4874], [4876, 4985, 5008, 5008, 5325], [5327, 5475, 5491, 5491, 5641], [5643, 5752, 5777, 5777, 5951], [5953, 6062, 6119, 6119, 7273]], "test": "untested"}
{"id": "slGfW3", "name": "Fork Nimbostrat", "author": "jorge2017a2", "description": "por xor y modificado por jorge\nHere's a quick volumetric cloud renderer.", "tags": ["volume", "clouds", "light", "sky"], "likes": 12, "viewed": 301, "published": 3, "date": "1665346007", "time_retrieved": "2024-07-30T16:27:13.162620", "image_code": "//por jorge2017a2\n\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n//Xor---https://www.shadertoy.com/view/XlfyD7\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n\n#define S(d,b) smoothstep(antialiasing(1.5),0. , d - (b) )\n#define S2(d,b) smoothstep(8.0*antialiasing(1.5),0.,d - (b) )\n\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n///---------------\nfloat Speed = .03;\nvec3 Light = vec3(.6,.2,.8);\n    \nfloat Map(vec3 Position)\n{\n    vec3 P = (Position*0.5+texture(iChannel0,Position*2.+iTime*Speed*.2).xyz*.02);\n    \n    float C = texture(iChannel0,P).r;\n    C *= texture(iChannel0,P*vec3(.5,1,.5)).g;\n    C = C*.9+.1*pow(texture(iChannel0,P*5.1).a,2.);\n    return max((C-.3)*sqrt((Position.z-.1)/.3),0.)/.5;\n}\n\nvec3 NubesXor(in vec2 Coord, float pz)\n{\n    vec4 Color;\n    vec3 R = vec3((Coord-.5*iResolution.xy)/iResolution.y,1.0);\n    vec3 P = vec3(0.+sin(iTime*0.5),iTime*Speed,pz);\n    \n    vec4 C = vec4(0);\n    for(float I = .2;I<.5;I+=.01)\n    {\n        float M1 = Map(P+R*I);\n        float M2 = Map(P+R*I+Light*.01);\n        C += vec4((.6+vec3(.6,.5,.4)*(exp(-M2*10.)-M1)),1)*M1*(1.-C.a);\n        if (C.a>.99) break;\n    }\n\tColor = C+vec4(vec3(.5,.7,.9)-R.y*.4,1)*(1.-C.a);\n    return Color.xyz;\n}\n///--------------\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\n\nvec3 Nave01(vec2 p, vec3 colOut)\n{   vec2 p0=p;\n    float d1= sdBox(p, vec2(0.1,1.0) );\n    float d2= sdCircle(p, 0.5 );\n    p.y=abs(p.y)-1.0;\n    float d3= sdBox(p, vec2(1.0,0.1) );\n    vec3 col= DrawFigBorde(vec3(1.0,0.0,0.0),colOut,d1);\n    col= DrawFigBorde(vec3(1.0,0.0,0.0),col,d2);\n    col= DrawFigBorde(vec3(1.0,0.0,0.0),col,d3);\n    return col;\n}\n\nvec3 Nave02(vec2 p, vec3 colOut)\n{   vec2 p0=p;\n    p.x=abs(p.x)-1.0;\n    float d3= sdBox(p, vec2(0.1,1.0) );\n    p=p0;\n    float d2= sdCircle(p, 0.5 );\n    float d1= sdBox(p, vec2(1.0,0.1) );\n    vec3 col= DrawFigBorde(vec3(1.0,0.0,0.0),colOut,d1);\n    col= DrawFigBorde(vec3(1.0,0.0,0.0),col,d2);\n    col= DrawFigBorde(vec3(1.0,0.0,0.0),col,d3);\n    return col;\n}\n\nvec3 lineat(vec2 p, vec3 colOut)\n{   vec2 p0=p;\n    p.x=mod(p.x+0.5,2.0);\n    float d1= sdBox(p, vec2(1.0,0.1) );\n    p=p0;\n    p.y=mod(p.y+0.5,2.0);\n    float d2= sdBox(p, vec2(0.1,1.0) );    \n    vec3 col= DrawFigBorde(vec3(0.0,0.0,0.0),colOut,d1);\n    col= DrawFigBorde(vec3(0.0,0.0,0.0),col,d2);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=8.0;\n    uv*=esc;\n    vec2 uv0=uv;\n    vec3 col=vec3(1.0);\n    float t=iTime;\n    col=NubesXor(fragCoord,1.0+ 1.0*sin(t*0.05));\n    col=lineat(uv-vec2(0.0+sin(t*0.5),1.0+2.0*sin(t)), col);\n    col= Nave01(uv-vec2(0.0,4.0),col);\n    col= Nave02(uv-vec2(3.0,2.0),col);\n    col= Nave02(uv-vec2(-3.0,2.0),col);\n    //col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGfW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[437, 437, 463, 463, 745], [747, 747, 787, 787, 1240], [1260, 1260, 1322, 1322, 1452], [1454, 1454, 1491, 1491, 1565], [1567, 1567, 1602, 1602, 1625], [1628, 1628, 1662, 1662, 1983], [1985, 1985, 2019, 2019, 2350], [2352, 2352, 2386, 2386, 2669], [2671, 2671, 2728, 2728, 3235]], "test": "untested"}
{"id": "7tGfW3", "name": "Happy little windows terminal", "author": "mrange", "description": "CC0: Happy little windows terminal\nBased on: https://www.shadertoy.com/view/7tVfDV\nDid this as a windows terminal background\n", "tags": ["3d", "windows", "terminal"], "likes": 26, "viewed": 493, "published": 3, "date": "1665345162", "time_retrieved": "2024-07-30T16:27:14.024316", "image_code": "// CC0: Happy little windows terminal\n//  Based on: https://www.shadertoy.com/view/7tVfDV\n//  Did this as a windows terminal background\n//  Did a tweet demoing it it: https://twitter.com/range_marten/status/1579163778683260928?s=20&t=NdjQ90et9I44u8KsrhAFOw\n\n// Apply some global distortion\n// #define DISTORT\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define TOLERANCE       0.0005\n#define MAX_RAY_LENGTH  10.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.005\n\nfloat g_mod = 2.5;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff = 0.;\n\nconst vec3 skyCol     = HSV2RGB(vec3(hoff+0.50, 0.90, 0.25));\nconst vec3 skylineCol = HSV2RGB(vec3(hoff+0.70, 0.95, 0.5));\nconst vec3 sunCol     = HSV2RGB(vec3(hoff+0.80, 0.90, 0.5));\nconst vec3 diffCol1   = HSV2RGB(vec3(hoff+0.75, 0.90, 0.5));\nconst vec3 diffCol2   = HSV2RGB(vec3(hoff+0.95, 0.90, 0.5));\n\nconst vec3 sunDir1    = normalize(vec3(0., 0.05, -1.0));\n\nconst float lpf = 5.0; \nconst vec3 lightPos1  = lpf*vec3(+1.0, 2.0, 3.0);\nconst vec3 lightPos2  = lpf*vec3(-1.0, 2.0, 3.0);\n  \n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  float sf = 1.0001-max(dot(sunDir1, rd), 0.0);\n  col += skyCol*pow((1.0-abs(rd.y)), 8.0);\n  col += (mix(0.0025, 0.125, tanh_approx(.005/sf))/abs(rd.y))*skylineCol;\n  sf *= sf;\n  col += sunCol*0.00005/sf;\n\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n  }\n\n  return clamp(col, 0.0, 10.0);;\n}\n\nfloat df(vec3 p) {\n  vec3 p0 = p;\n  p0.xy *= ROT(0.2*p0.z-0.1*TIME);\n  float d = -box(p0.xy, vec2(g_mod, 1.25));\n#if defined(DISTORT)  \n  vec3 p1 = 2.0*p;\n  d += 0.005*sin(dot(p1.xy,p1.xz))*sin(p1.z);\n#endif  \n  return d;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float initt) {\n  float t = initt;\n  float tol = TOLERANCE;\n  for (int i = 0; i < MAX_RAY_MARCHES; ++i) {\n    if (t > MAX_RAY_LENGTH) {\n      t = MAX_RAY_LENGTH;    \n      break;\n    }\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE) {\n      break;\n    }\n    t += d;\n  }\n  return t;\n}\n\nvec3 boxCol(vec3 col, vec3 nsp, vec3 ro, vec3 rd, vec3 nnor, vec3 nrcol) {\n  float nfre  = 1.0+dot(rd, nnor);\n  nfre        *= nfre;\n\n  vec3 nld1   = normalize(lightPos1-nsp); \n  vec3 nld2   = normalize(lightPos2-nsp); \n\n  float ndif1 = max(dot(nld1, nnor), 0.0);\n  ndif1       *= ndif1;\n\n  float ndif2 = max(dot(nld2, nnor), 0.0);\n  ndif2       *= ndif2;\n\n  vec3 scol = vec3(0.0);\n  scol += diffCol1*ndif1;\n  scol += diffCol2*ndif2;\n  scol += 0.1*(skyCol+skylineCol);\n  scol += nrcol*0.75*mix(vec3(0.25), vec3(0.5, 0.5, 1.0), nfre);\n\n  vec3 pp = nsp-ro;\n\n  col = mix(col, scol, smoothstep(100.0, 20.0, dot(pp, pp)));\n  \n  return col;\n}\n\nvec3 render1(vec3 ro, vec3 rd) {\n  vec3 col = 0.1*sunCol;\n\n  float nt    = rayMarch(ro, rd, .0); \n  if (nt < MAX_RAY_LENGTH) {\n    vec3 nsp    = ro + rd*nt;\n    vec3 nnor   = normal(nsp);\n\n    vec3 nref   = reflect(rd, nnor);\n    float nrt   = rayMarch(nsp, nref, 0.2);\n    vec3 nrcol  = render0(nsp, nref);\n    \n    if (nrt < MAX_RAY_LENGTH) {\n      vec3 nrsp   = nsp + nref*nrt;\n      vec3 nrnor  = normal(nrsp);\n      vec3 nrref  = reflect(nref, nrnor);\n      nrcol = boxCol(nrcol, nrsp, ro, nref, nrnor, render0(nrsp, nrref));\n    }\n\n    col = boxCol(col, nsp, ro, rd, nnor, nrcol);\n  }\n\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  const float fov = tan(TAU/(6.-0.6));\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n  const vec3 ro = vec3(0.0, 0.0, 5.0);\n  const vec3 la = vec3(0.0, 0.0, 0.);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = cross(ww,uu);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render1(ro, rd);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  g_mod = mix(1.25, 2.5, 0.5+0.5*sin(TAU*TIME/66.0));\n  vec3 col = effect(p);\n  // Stupid tricks I learnt, saturates the colors\n  col -= 0.0333*vec3(1.0, 2.0, 2.0);\n  col = aces_approx(col); \n  col = sRGB(col);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGfW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[779, 779, 801, 801, 947], [1758, 1858, 1877, 1877, 1964], [1966, 2073, 2099, 2099, 2283], [2285, 2345, 2373, 2439, 2515], [2517, 2610, 2652, 2652, 2699], [2701, 2819, 2846, 2846, 2922], [2924, 2924, 2956, 2956, 3529], [3531, 3531, 3549, 3549, 3754], [3756, 3756, 3779, 3779, 3987], [3989, 3989, 4036, 4036, 4308], [4310, 4310, 4384, 4384, 4946], [4948, 4948, 4980, 4980, 5555], [5557, 5557, 5578, 5578, 5930], [5932, 5932, 5987, 5987, 6328]], "test": "untested"}
{"id": "wlKfR1", "name": "waves_343", "author": "yurka", "description": "test ba", "tags": ["test"], "likes": 1, "viewed": 161, "published": 3, "date": "1665326444", "time_retrieved": "2024-07-30T16:27:14.845122", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    \n    vec4 data1 = texelFetch(iChannel0,ivec2(fragCoord) + ivec2(-1, 0),0);\n    vec4 data2 = texelFetch(iChannel0,ivec2(fragCoord) + ivec2(+1, 0),0);\n    vec4 data3 = texelFetch(iChannel0,ivec2(fragCoord) + ivec2(0, -1),0);\n    vec4 data4 = texelFetch(iChannel0,ivec2(fragCoord) + ivec2(0, +1),0);\n    vec3 norm = vec3(data2.x - data1.x, data4.x - data3.x, 0.2); \n    vec3 light = vec3(0.3, -0.1, 0.7);\n    float cs = dot(norm, light) / (length(norm) * length(light));\n    fragColor = vec4(1.0 * cs, 1.0 * cs, 1.0 * cs, 1.0);\n///*\n    //float Y = data.q < 0.0 ? -data.q : 0.0;\n    //float Z = data.q > 0.0 ? +data.q : 0.0;\n    //fragColor = vec4(data.x * 30.0, Y * 1000.0, Z * 1000.0, data.q);\n    data.x *= 15.0;\n    data.q *= 500.0;\n    float xpos = data.x > 0.0? data.x : 0.0;\n    float xneg = data.x < 0.0? -data.x : 0.0;\n    float vpos = data.q > 0.0? data.q : 0.0;\n    float vneg = data.q < 0.0? -data.q : 0.0;\n    vec4 cxpos = xpos * vec4(1.0, 0.0, 0.0, 0.0);\n    vec4 cxneg = xneg * vec4(0.0, 1.0, 1.0, 0.0);\n    vec4 cvpos = vpos * vec4(0.5, 0.0, 1.0, 0.0);\n    vec4 cvneg = vneg * vec4(0.5, 1.0, 0.0, 0.0);\n    fragColor = cxpos + cxneg + cvpos+ cvneg;\n//*/\n}\n    \n    ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*(fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    \n    \n    if (iFrame < 10) {\n        vec2 pnt = vec2(0.4, -0.217);\n        float dst = length(uv - pnt);\n        \n        //float dst = length(uv);\n        //if (dst > length(uv - vec2(0.4, 0.1)))\n        //   dst = length(uv - vec2(0.4, 0.1));\n        \n        //float linex = -1.5;\n        //float dst = length(uv - vec2(linex, -0.5));\n        //if (dst > length(uv - vec2(linex, 0.5)))\n        //   dst = length(uv - vec2(linex, 0.5));\n        //if (uv.y > -0.5 && uv.y < 0.5 && dst > abs(uv.x - linex))\n        //   dst = abs(uv.x - linex);\n        /*\n        float ox = 0.5;\n        float oy = -0.3;\n        float or = 1.5;\n        float oap = 3.14 * 0.26;\n        float oan = 3.14 * 0.10;\n           \n        float dst = 10.0e10;\n        vec2 v = uv - vec2(ox, oy);\n        float vcos = -v.x/length(v);\n        if (vcos > 1.0)\n            vcos = 1.0;\n        float a = acos(vcos);\n        if ((uv.y > oy && a < oap) || (uv.y <= oy && a < oan)) \n           dst = abs(length(v) - or);\n        else \n        {\n           float dstp1 = length(uv - vec2(ox - or * cos(oan), oy - or * sin(oan)));\n           if (dst > dstp1)\n              dst = dstp1;\n           float dstp2 = length(uv - vec2(ox - or * cos(oap), oy + or * sin(oap)));\n           if (dst > dstp2)\n              dst = dstp2;\n        }*/\n        //float dst = length(uv - vec2(ox - or * cos(oa), oy - or * sin(oa)));\n        //float dst = length(uv - vec2(ox - or * cos(oa), oy - or * sin(oa/2.0)));\n        float radius = 0.2;\n        float factor = dst < radius? cos((dst / radius) * 3.14) * 0.5 + 0.5 : 0.0; //1.0/(pow(abs(dst/R), 3.0) + 1.0);\n\n        //fragColor = vec4(1.0/(pow(abs(dst/radius), 3.0) + 1.0), 0.0, 0.0, 0.0);\n        \n        float freq = 80.0;\n        float H = factor * sin((uv.x * 0.7 + uv.y * 0.3)* freq) * .1;\n        float V = factor * cos((uv.x * 0.7 + uv.y * 0.3)* freq) * .013;\n        float Y = V < 0.0 ? -V : 0.0;\n        float Z = V > 0.0 ? +V : 0.0;\n        fragColor = vec4(H, Y, Z, V);\n        \n        /*\n        float freq = 100.0;\n        float H = factor * cos(dst * freq) * 1.0;\n        float V = factor * sin(dst * freq) * 0.03;\n        float Y = V < 0.0 ? -V : 0.0;\n        float Z = V > 0.0 ? +V : 0.0;\n        fragColor = vec4(H, Y, Z, V);\n        */\n        /*\n        float freq = 80.0;\n        factor = 1.0 - max(abs(uv.x - pnt.x), abs(uv.y - pnt.y)) / 0.2;\n        if (factor < 0.0) factor = 0.0;\n        float H = factor * sin((uv.x + uv.y * 0.0)* freq) * 1.0;\n        float V = factor * cos((uv.x + uv.y * 0.0)* freq) * 0.04;\n        fragColor = vec4(H, 0.0, 0.0, V);\n        */\n    }\n    else {\n        vec4 data = texelFetch(iChannel1,ivec2(fragCoord), 0);\n        vec4 data1 = texelFetch(iChannel1,ivec2(fragCoord) + ivec2(-1, 0),0);\n        vec4 data2 = texelFetch(iChannel1,ivec2(fragCoord) + ivec2(+1, 0),0);\n        vec4 data3 = texelFetch(iChannel1,ivec2(fragCoord) + ivec2(0, -1),0);\n        vec4 data4 = texelFetch(iChannel1,ivec2(fragCoord) + ivec2(0, +1),0);\n\n        //fragColor = (data + data1 + data2 + data3 + data4) / 5.0;\n        float fact = 1.0; // 0.1;\n        vec2 mc = vec2(-0.5, 0.0);\n /*\n        if (length(uv-mc) < 0.5) {\n            fact = 0.5;\n        }\n*/\n        float A = (data.q)*(1.0) + ((data1.x + data2.x + data3.x + data4.x - data.x * 4.0) / 4.0)*fact;\n        float X = data.x + A*fact;\n        //float X = (data.x)*(1.0) - ((data1.q + data2.q + data3.q + data4.q - data.q * 4.0) / 4.0)*fact;\n        \n        // mirror parabola\n        /*\n        if ((uv.x + 1.0) < uv.y * uv.y) {\n            X = 0.0;\n            A = 0.0;\n        }\n        */\n        // mirrortwo holes\n        /*\n        if ((-0.54 < uv.x && uv.x < -0.5) && (abs(uv.y) < 0.08 || abs(uv.y) > 0.10)) {\n            X *= 0.03;\n            A *= 0.03;\n        }\n        */\n        /*\n        if (length(uv-mc) < 0.5) {\n            X *= 0.03;\n            A *= 0.03;\n        }\n        */\n        // elipse\n        vec2 elp1 = vec2(-0.9, 0.0);\n        vec2 elp2 = vec2(0.9, 0.0);\n        if (length(uv - elp1) + length(uv - elp2) > 2.5) {\n            X *= 0.03;\n            A *= 0.03;\n        }\n        \n        //fragColor = data / 1.01;\n        fragColor = vec4(X, 0.0, 0.0, A);\n    }\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float random (in vec2 _st) {\n     return fract(sin(1.0+dot(_st,vec2(127.1,311.7)))*43758.545); \n}\n\nfloat random (in float _st) {\n    return fract(sin(dot(vec2(_st, 0.0),\n                         vec2(127.1,311.7)))*\n        43758.545);\n}\nfloat lastrandom = 1.0;\nfloat nextrandom(float a)\n{\n    float r = random (lastrandom);\n    lastrandom = r + a;\n    return r;\n}\n", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = data;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKfR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1354]], "test": "untested"}
{"id": "NtVBWK", "name": "Fire/Smoke Test ", "author": "rubioh", "description": "Todo: Better Smoke", "tags": ["test", "fire", "help"], "likes": 6, "viewed": 273, "published": 3, "date": "1665320223", "time_retrieved": "2024-07-30T16:27:15.618056", "image_code": "float fbm( in vec2 x ,int I, float v)\n{    \n    float t = 0.0;\n    float amp = 0.;\n    for( int i=1; i<I; i++ )\n    {\n        float f = pow( 2., float(i) );\n        float a = pow( f, -.75 );\n        amp = 10.*step(3., float(i));\n        t += a*noise_perso(f*x+amp + vec2(0., -iTime*v));\n    }\n    return t*1.-.4;\n}\n\n\nfloat fbm_smoke( in vec2 x)\n{    \n    float t = 0.0;\n    float amp = 0.;\n    for( int i=1; i<8; i++ )\n    {\n        float f = pow( 2., float(i) );\n        float a = pow( f, -.75 );\n        t += a*noise(f*x- vec2(0., iTime*1.));\n    }\n    return t*1.-.4;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2.*fragCoord.xy - iResolution.xy ) / iResolution.y;\n    uv.y += .7;\n\n\n    uv *= 1.;\n    \n    \n    // Rendering smoke (simple FBM)\n    vec2 st = uv/2.*(vec2(2., 1.));\n    float smoke = fbm_smoke(st);\n    vec3 a = vec3(0., 0., 0.);\n    vec3 b = vec3(.2, .2, .2);\n    vec3 c = vec3(.9, .75, .6);  \n    vec3 smoke_col =  mix3ColorGradient(smoke*2., a, b, c)*(1./uv.y);\n    \n\n    // Rendering fire (multiple FBM to create some cool aspect)        \n    st = uv*vec2(2., .2);\n    float flamme = 3.*fbm(st+ fbm(st, 4, 8.), 4, 8.);\n    st = uv*vec2(1., 1.);\n    flamme = 2.*fbm(st + fbm(st, 3, 8.), 3, 8.);\n    st = uv*vec2(.1, .25);        \n    flamme += (fbm(st+ fbm(st, 5, 2.), 5, 2.)*.7+.3)*(1.-uv.y);\n    flamme = pow(flamme, 2.*(uv.y+.05)); // pow in function of uv.y in order to cancel fire power when elevating\n    a = vec3(0., 0., 0.);\n    b = vec3(.7, .1, .1);\n    c = vec3(0.9, 0.9, .5);\n    \n    vec3 flamme_col = mix3ColorGradient(flamme*2., a, b, c); // fire color   \n    float flamme_mask = smoothstep(0., 1., flamme_col.x); // Flamme mask (complete screen with smoke or with fire)\n    \n    flamme_col = clamp(flamme_col, 0.0, 1.0);\n    smoke_col = clamp(smoke_col, 0.0, 1.0);\n    fragColor = vec4(mix(vec3(0.), flamme_col, flamme_mask),1.0);\n    //fragColor = vec4((1.-flamme_mask)*smoke_col,1.0); // only smoke  -> work as I want \n    //fragColor = vec4((flamme_mask)*flamme_col,1.0);  // only fire -> work as I want\n    //fragColor = vec4((flamme_mask)*flamme_col+(1.-flamme_mask)*smoke_col,1.0); // The sum doesn't work \n}", "image_inputs": [], "common_code": "#define N_tile 30.\n\nvec3 mix3ColorGradient(float ratio, vec3 a, vec3 b, vec3 c){\n    return\n        mix(\n            mix(a, b, ratio/.5), mix(b, c, (ratio - .5)/.5), \n            step(.5, ratio));\n\n}\n\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    return a + b*cos(6.28318*(c*t+d));\n}\n\nvec2 hash( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(175.1,311.7)),\n             dot(p,vec2(4260.5,7052.3)));\n    return fract(sin(p+4551.)*184.5453);\n}\n\nvec2 hash2( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    float n = 111.0*p.x + 113.0*p.y;\n    return fract(n*fract(k*n));\n}\nfloat noise_perso(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = hash(i).x;\n    float b = hash(i + vec2(1.0, 0.0)).x;\n    float c = hash(i + vec2(0.0, 1.0)).x;\n    float d = hash(i + vec2(1.0, 1.0)).x;\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n\nvec2 hash4( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(nrand(p), nrand(p.yx));\n    return fract(sin(p+455.)*18.5453);\n}\n\n\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = hash4(i).x;\n    float b = hash4(i + vec2(1.0, 0.0)).x;\n    float c = hash4(i + vec2(0.0, 1.0)).x;\n    float d = hash4(i + vec2(1.0, 1.0)).x;\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtVBWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 314], [317, 317, 346, 346, 572], [575, 575, 632, 632, 2181]], "test": "untested"}
{"id": "7tVfDV", "name": "Happy sunday accident", "author": "mrange", "description": "CC0: Happy sunday accident\nWas tinkering a bit with an earlier and this popped out.\n", "tags": ["raymarch", "accidents"], "likes": 20, "viewed": 340, "published": 3, "date": "1665318232", "time_retrieved": "2024-07-30T16:27:16.486733", "image_code": "// CC0: Happy sunday accident\n//  Was tinkering a bit with an earlier and this popped out\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define TOLERANCE       0.0005\n#define MAX_RAY_LENGTH  10.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.005\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff = 0.;\n\nconst vec3 skyCol     = HSV2RGB(vec3(hoff+0.57, 0.90, 0.25));\nconst vec3 skylineCol = HSV2RGB(vec3(hoff+0.02, 0.95, 0.5));\nconst vec3 sunCol     = HSV2RGB(vec3(hoff+0.07, 0.95, 0.5));\nconst vec3 diffCol1   = HSV2RGB(vec3(hoff+0.60, 0.90, 0.5));\nconst vec3 diffCol2   = HSV2RGB(vec3(hoff+0.90, 0.90, 0.5));\n\nconst vec3 sunDir1    = normalize(vec3(0., 0.05, -1.0));\n\nconst float lpf = 5.0; \nconst vec3 lightPos1  = lpf*vec3(+1.0, 2.0, 3.0);\nconst vec3 lightPos2  = lpf*vec3(-1.0, 2.0, 3.0);\n  \n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat dcross(vec2 p, vec2 b, float r)  {\n  p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n  vec2  q = p - b;\n  float k = max(q.y,q.x);\n  vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n  return sign(k)*length(max(w,0.0)) + r;\n}\n\n\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  float sf = 1.0001-max(dot(sunDir1, rd), 0.0);\n  col += skyCol*pow((1.0-abs(rd.y)), 8.0);\n  col += (mix(0.0025, 0.125, tanh_approx(.005/sf))/abs(rd.y))*skylineCol;\n  sf *= sf;\n  col += sunCol*0.00005/sf;\n\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n  }\n\n  return clamp(col, 0.0, 10.0);;\n}\n\nfloat df(vec3 p) {\n  vec3 p0 = p;\n  p0.xy *= ROT(0.2*p0.z-0.1*TIME);\n  return -dcross(p0.xy, vec2(2.5, 1.5), 0.5);\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float initt) {\n  float t = initt;\n  float tol = TOLERANCE;\n  for (int i = 0; i < MAX_RAY_MARCHES; ++i) {\n    if (t > MAX_RAY_LENGTH) {\n      t = MAX_RAY_LENGTH;    \n      break;\n    }\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE) {\n      break;\n    }\n    t += d;\n  }\n  return t;\n}\n\nvec3 boxCol(vec3 col, vec3 nsp, vec3 ro, vec3 rd, vec3 nnor, vec3 nrcol) {\n  float nfre  = 1.0+dot(rd, nnor);\n  nfre        *= nfre;\n\n  vec3 nld1   = normalize(lightPos1-nsp); \n  vec3 nld2   = normalize(lightPos2-nsp); \n\n  float ndif1 = max(dot(nld1, nnor), 0.0);\n  ndif1       *= ndif1;\n\n  float ndif2 = max(dot(nld2, nnor), 0.0);\n  ndif2       *= ndif2;\n\n  vec3 scol = vec3(0.0);\n  scol += diffCol1*ndif1;\n  scol += diffCol2*ndif2;\n  scol += 0.1*(skyCol+skylineCol);\n  scol += nrcol*0.75*mix(vec3(0.25), vec3(0.5, 0.5, 1.0), nfre);\n\n  vec3 pp = nsp-ro;\n\n  col = mix(col, scol, smoothstep(90.0, 20.0, dot(pp, pp)));\n  \n  return col;\n}\n\nvec3 render1(vec3 ro, vec3 rd) {\n  vec3 skyCol = render0(ro, rd);\n  vec3 col = skyCol;\n\n  float nt    = rayMarch(ro, rd, .0); \n  if (nt < MAX_RAY_LENGTH) {\n    vec3 nsp    = ro + rd*nt;\n    vec3 nnor   = normal(nsp);\n\n    vec3 nref   = reflect(rd, nnor);\n    float nrt   = rayMarch(nsp, nref, 0.2);\n    vec3 nrcol  = render0(nsp, nref);\n    \n    if (nrt < MAX_RAY_LENGTH) {\n      vec3 nrsp   = nsp + nref*nrt;\n      vec3 nrnor  = normal(nrsp);\n      vec3 nrref  = reflect(nref, nrnor);\n      nrcol = boxCol(nrcol, nrsp, ro, nref, nrnor, render0(nrsp, nrref));\n    }\n\n    col = boxCol(col, nsp, ro, rd, nnor, nrcol);\n  }\n\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  const float fov = tan(TAU/(6.-0.5));\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n  const vec3 ro = vec3(0.0, 0.0, 5.0);\n  const vec3 la = vec3(0.0, 0.0, 0.);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = cross(ww,uu);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render1(ro, rd);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  // Stupid tricks I learnt, saturates the colors\n  col -= 0.04*vec3(1.0, 2.0, 2.0);\n  col = aces_approx(col); \n  col = sRGB(col);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVfDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[539, 539, 561, 561, 707], [1518, 1618, 1637, 1637, 1724], [1726, 1833, 1859, 1859, 2043], [2045, 2105, 2133, 2199, 2275], [2277, 2370, 2412, 2412, 2459], [2461, 2579, 2606, 2606, 2682], [2684, 2802, 2842, 2842, 3017], [3020, 3020, 3052, 3052, 3625], [3627, 3627, 3645, 3645, 3743], [3745, 3745, 3768, 3768, 3976], [3978, 3978, 4025, 4025, 4297], [4299, 4299, 4373, 4373, 4934], [4936, 4936, 4968, 4968, 5572], [5574, 5574, 5595, 5595, 5947], [5949, 5949, 6004, 6004, 6289]], "test": "untested"}
{"id": "slVBWV", "name": "Rolling Typo", "author": "yasuo", "description": "simple typo animation", "tags": ["typoanimation"], "likes": 10, "viewed": 343, "published": 3, "date": "1665304384", "time_retrieved": "2024-07-30T16:27:17.271634", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define SPEED 200.\n#define ZERO (min(iFrame,0))\n#define MATERIAL0 0\n#define MATERIAL1 1\n#define MATERIAL2 2\n\n\nfloat segBase(vec2 p){\n    vec2 prevP = p;\n    \n    float size = 0.02;\n    float padding = 0.05;\n\n    float w = padding*3.0;\n    float h = padding*5.0;\n\n    p = mod(p,0.05)-0.025;\n    float thickness = 0.005;\n    float gridMask = min(abs(p.x)-thickness,abs(p.y)-thickness);\n    \n    p = prevP;\n    float d = B(p,vec2(w*0.5,h*0.5));\n    float a = radians(45.0);\n    p.x = abs(p.x)-0.1;\n    p.y = abs(p.y)-0.05;\n    float d2 = dot(p,vec2(cos(a),sin(a)));\n    d = max(d2,d);\n    d = max(-gridMask,d);\n    return d;\n}\n\nfloat seg0(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    float mask = B(p,vec2(size,size*2.7));\n    d = max(-mask,d);\n    return d;\n}\n\nfloat seg2(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x-=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\nmat2 Rot0(vec2 p){\n    return Rot(radians(90.));\n}\n\nfloat ring(vec3 p, float size){\n    return max(abs(p.y)-1.,abs(length(p.xz)-size)-0.001);\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    p.yz*=Rot0(p.yz);\n    p.xy*=Rot0(p.xy);\n    float d = ring(p,0.4);\n    vec2 res = vec2(d,MATERIAL0);\n    \n    p.z-=0.85;\n    d = ring(p,0.4);\n    vec2 res2 = vec2(d,MATERIAL1);\n    \n    p.z+=1.7;\n    d = ring(p,0.4);\n    vec2 res3 = vec2(d,MATERIAL2);\n    \n    return combine(res,combine(res2,res3));\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 tex(vec3 p, float dir){\n    vec2 uv = vec2(0.9*atan(p.x,p.z)/6.2832,p.y/3.);\n    uv*=1.5;\n    uv.y*=-1.;\n    uv.x+=iTime*0.1*dir;\n    uv.x = mod(uv.x,0.3)-0.15;\n    uv*=Rot(radians(90.));\n    float d = seg2(uv-vec2(-0.3,0.));\n    float d2 = seg0(uv-vec2(-0.1,0.));\n    d = min(d,d2);\n    d2 = seg2(uv-vec2(0.1,0.));\n    d = min(d,d2);\n    d2 = seg2(uv-vec2(0.3,0.));\n    d = min(d,d2);\n    \n    return mix(vec3(0.0),vec3(1.8),S(d,0.0));\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    vec3 prevP = p;\n    p.yz*=Rot0(p.yz);\n    p.xy*=Rot0(p.xy);\n    if(mat == MATERIAL0){\n        col = tex(p,1.);        \n    } else if(mat == MATERIAL1){\n        p.z-=0.85;\n        col = tex(p,-1.);        \n    } else if(mat == MATERIAL2){\n        p.z+=0.85;\n        col = tex(p,-1.);        \n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, -1.35);\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVBWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[382, 382, 404, 404, 895], [897, 897, 916, 916, 1066], [1068, 1068, 1087, 1087, 1375], [1377, 1377, 1413, 1413, 1455], [1457, 1457, 1475, 1475, 1507], [1509, 1509, 1540, 1540, 1600], [1602, 1602, 1624, 1624, 1956], [1958, 1958, 2016, 2016, 2283], [2285, 2285, 2309, 2309, 2510], [2512, 2512, 2554, 2554, 2749], [2751, 2751, 2779, 2779, 3194], [3196, 3196, 3255, 3255, 3575], [3577, 3577, 3634, 3634, 4160]], "test": "untested"}
{"id": "wlGcWG", "name": "Binary Search for SDFs", "author": "iq", "description": "An old experiment on using Binary-search for robust raycasting SDFs instead of using raymarching. It works beautifully, but it's about twice slower than good old plain SDF raymarching. More info: [url]https://iquilezles.org/articles/binarysearchsdf/[/url]", "tags": ["3d", "raycasting", "raycast", "sdf", "intersection", "binarysearch"], "likes": 50, "viewed": 3045, "published": 3, "date": "1665272616", "time_retrieved": "2024-07-30T16:27:18.027613", "image_code": "// inigo quilez - iq/2018-2022\n\n// Robust Binary-Search based intersection for SDFs.\n//\n// TLDR; it's about twice slower than traditional SDF raymarching :(\n//\n// More info: https://iquilezles.org/articles/binarysearchsdf/\n\n\n// Antialiasing level (1:1x1, 2:2x2=4MSAA, 3=3x3=9MSAA, ...)\n#define AA 1\n\n\nvec3 map( vec3 p );\n\n// binary search\nvec4 raycast_bs( in vec3 ro, in vec3 rd, float tmin, float tmax)\n{\n  int lev = 0;                                 // start at the root, ie, the\n  int seg = 0;                                 // whole [tmin,tmax] segment\n  int num = 0;\n  \n  const int kMaxLevel = 18;                    // recursion (worst case will\n  while( true )                                // be 2^kMaxLevel iterations\n  {\n    float tle = (tmax-tmin)*exp2(-float(lev)); // compute center and radius\n    float tce = tmin+tle*(float(seg)+0.5);     // of current (level:segment)\n    float tra = 0.5*tle;                       // in \"t\" ray space\n        \n    vec3 m = map( ro + tce*rd );               // evaluate SDF at segment center\n    num++;\n    \n    if( m.x<tra )                              // now, if SDF overlaps the segment\n    {\n      if( tra<0.0005*tce || lev>kMaxLevel )    // and if segment is tiny\n      {\n        return vec4(tce-tra,m.yz,float(num));  // consider this an intersection\n      }\n      else                                     // otherwise, continue subdividing\n      {\n        lev++;                                 // by going to left child\n        seg <<= 1;\n      }\n    }\n    else                                       // but if they don't overlap\n    {                                          // then skip the subtree by\n      for(;(seg&1)==1;seg>>=1,lev--);          // climbing to ancestor\n      seg++;                                   // and moving to right sibling\n            \n      if( lev==0 )                             // and if we're back at the root\n      {\n        break;                                 // then quit, we are done\n      }\n    }\n  }\n\n  return vec4(-1.0);\n}\n\n// traditional SDF raymarching\nvec4 raycast_rm( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    float t = tmin;\n    for( int i=0; i<256 && t<tmax ; i++ )\n    {\n        vec3 r = map( ro+rd*t );\n        if( r.x<0.001*t ) return vec4(t,r.yz,float(i));\n        t += r.x;\n    }\n    return vec4(-1.0);\n}\n\nvec3 map( vec3 p )\n{\n\tfloat scale = 1.0;\n    float orb = 10000.0;\n    for( int i=0; i<6; i++ )\n\t{\n\t\tp = -1.0 + 2.0*fract(0.5*p+0.5);\n        p -= sign(p)*0.04;\n        float r2 = dot(p,p);\n\t\tfloat k = 0.95/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n        orb = min( orb, r2);\n\t}\n    float d1 = sqrt( min( min( dot(p.xy,p.xy), dot(p.yz,p.yz) ), dot(p.zx,p.zx) ) ) - 0.02;\n    float d2 = abs(p.y);\n    float dmi = d2;\n    float adr = 0.7*floor((0.5*p.y+0.5)*8.0);\n    if( d1<d2 )\n    {\n        dmi = d1;\n        adr = 0.0;\n    }\n    return vec3( 0.5*dmi/scale, adr, orb );\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    float precis = 0.0001 * t * 0.57;\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n                      e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<16; i++ )\n    {\n        vec3 w = normalize(sin(float(i)+vec3(0,1,2)));\n\t\tw *= sign( dot(w,nor) );\n        float h = float(i)/15.0;\n        ao += clamp( map( pos + nor*0.01 + w*h*0.15 ).x*2.0, 0.0, 1.0 );\n    }\n    return clamp( ao, 0.0, 1.0 );\n}\n\nvec3 palette( float h )\n{\n    vec3 col =    vec3(0.0,0.3,1.0);\n    col = mix(col,vec3(1.0,0.8,0.0),smoothstep(0.33-0.2,0.33+0.2,h));\n    col = mix(col,vec3(1.0,0.0,0.0),smoothstep(0.66-0.2,0.66+0.2,h));\n    col.y += 0.5*(1.0-smoothstep(0.0,0.2,abs(h-0.33)));\n    col *= 0.5 + 0.5*h;\n    return col;\n}\n\nfloat print( in float sdf, inout vec2 p, in int str[12])\n{\n    if( p.y<0.0|| p.y>1.0 ) return sdf;\n    float d = 1e20;\n    for( int i=0; i<str.length(); i++ )\n    {\n        int c = str[i];\n        if( c==0 ) break;\n        if( p.x>0.0 && p.x<1.0 )\n        {\n            vec2 q = p/16.0;\n            d = min(d,textureGrad( iChannel0, vec2(c,15-c/16)/16.0+q, dFdx(q), dFdy(q) ).w);\n        }\n        p.x -= 0.5;\n    }\n    return min(d,sdf);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool showCost = cos(iTime*6.283185/11.0)>=0.0;\n    \n    // supersampling loop\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 0, jj = 0;\n    #endif\n    {\n        vec2 q = fragCoord+vec2(float(ii),float(jj))/float(AA);\n\n        // camera\n        vec3 ro = vec3( 2.8*cos(0.1+0.033*iTime), 0.5 + 0.20*cos(0.037*iTime), 2.8*cos(0.5+0.035*iTime) );\n        vec3 ta = vec3( 1.9*cos(1.2+0.041*iTime), 0.5 + 0.10*cos(0.027*iTime), 1.9*cos(2.0+0.038*iTime) );\n        float roll = 0.2*cos(0.02*iTime);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        \n        // render split screen\n        vec2 res = vec2(iResolution.x/2.0,iResolution.y);\n        float ori = (q.x<res.x)?0.0:res.x;\n        vec2 p = (2.0*vec2(q.x-ori,q.y)-res)/res.y;\n        vec3 col = vec3(0.0);\n        if( !showCost || p.y>-0.9 ) \n        {\n            vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n            vec4 h = (q.x<res.x) ? raycast_rm( ro, rd, 0.01, 20.0 ): \n                                   raycast_bs( ro, rd, 0.01, 20.0 );\n                                   \n            if( !showCost )\n            {\n                float t = h.x;\n                if( t>0.0 )\n                {\n                    vec3  pos = ro + t*rd;\n                    vec3  nor = calcNormal( pos, t );\n                    float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n                    float occ = pow( clamp(h.z*2.0,0.0,1.0), 1.2 );\n                          occ = 1.5*(0.1+0.9*occ)*calcAO(pos,nor);        \n                    vec3  lin = vec3(0.8,0.8,1.0)*(2.0+fre*fre*vec3(1.8,1.0,1.0))*occ*(1.0-0.5*abs(nor.y));\n\n                    col = 0.5 + 0.5*cos( 6.2831*h.y*1.7 + vec3(0.0,2.0,3.0)+0.5 );\n                    col  = col*lin;\n                    col += 0.6*pow(1.0-fre,32.0)*occ*vec3(0.5,1.0,1.5);        \n                    col *= exp(-0.3*t);\n                }\n            }\n            else\n            {\n                if( h.w>0.0 )\n                {\n                   col = palette(clamp(h.w/128.0,0.0,1.0));\n                }\n\n                col *= exp2(-0.4*h.x);\n            }\n            col *= 0.6 + 0.4*smoothstep(-0.8,-0.5,p.y);\n            col *= 2.0;\n            col = mix(col,vec3(1.0),1.0-smoothstep( 0.003,0.004,abs(q.x-res.x)/iResolution.x ));\n        }\n        // render pallette\n        else\n        {\n            col = palette( q.x/iResolution.x );\n            col = mix(col,vec3(1.0),1.0-smoothstep( 0.003,0.004,abs(p.y+0.9)/2.0*iResolution.y/iResolution.x ));\n        }\n        col = sqrt(col);\n\n        tot += col;\n    }\n    tot = tot/float(AA*AA);\n\n\n    // draw text\n    {\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float text = 1e20;\n        const float text_scale = 7.0;\n        if( fragCoord.x<iResolution.x/2.0 )\n        {\n            vec2 q = (p-vec2(-1.78,-0.85))*text_scale;\n            text = print(text,q,int[12]( 84,114, 97,100,105,116,105,111,110, 97,108,0));\n            text = print(text,q,int[12]( 32,114, 97,121,109, 97, 99,104,105,110,103,0));\n        }\n        else\n        {\n            vec2 q = (p-vec2( 0.03,-0.85))*text_scale;\n            text = print(text,q,int[12]( 82,111,98, 117,115,116, 32,0,0,0,0,0));\n            text = print(text,q,int[12]( 66,105,110, 97,114,121, 32,0,0,0,0,0));\n            text = print(text,q,int[12]( 83,101, 97,114, 99,104,  0,0,0,0,0,0));\n        }\n\n        if( showCost )\n        {\n            vec2 q;\n            q = (p-vec2(-1.77,-0.993))*14.0; text = print(text,q,int[12]( 48,0,0,0,0,0,0,0,0,0,0,0));\n            q = (p-vec2(-0.27,-0.993))*14.0; text = print(text,q,int[12]( 32,105,116,101,114, 97,116,105,111,110,115,0));\n            q = (p-vec2( 1.62,-0.993))*14.0; text = print(text,q,int[12]( 49,50,56,0,0,0,0,0,0,0,0,0));\n        }\n        tot = mix(tot,vec3(0.0),1.0-smoothstep( 0.06,0.08,text-0.5));\n        tot = mix(tot,vec3(1.0),1.0-smoothstep(-0.01,0.01,text-0.5));\n    }\n    \n\tfragColor = vec4( tot, 1.0 );\t\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGcWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2031, 2062, 2129, 2129, 2335], [2337, 2337, 2357, 2357, 2900], [2902, 2902, 2946, 2946, 3200], [3202, 3202, 3244, 3244, 3527], [3529, 3529, 3554, 3554, 3829], [3831, 3831, 3889, 3889, 4271]], "test": "untested"}
{"id": "ftVfWV", "name": "Trap nation style audio visualiz", "author": "fishy", "description": "I can't believe I spent all afternoon on this. This song works well too: https://soundcloud.com/nocopyrightsounds/arya-borne-lynzz-need-u-ncs-release", "tags": ["audio", "visualizer", "trap", "nation"], "likes": 10, "viewed": 596, "published": 3, "date": "1665272395", "time_retrieved": "2024-07-30T16:27:18.789576", "image_code": "\nfloat renderParticle(vec3 pos, vec2 uv, float aa)\n{\n    return smoothstep(0.05, 0.05 - aa, distance((pos.xy/pos.z), uv) * pos.z) * max(0.0, min(1.0, pos.z) * (10.-pos.z));\n}\n\nfloat getParticles(vec3 startPos, vec3 startPosRandom, vec3 speed, vec3 speedRandom, float startOffset, float lifetime, float time, int count, vec2 uv, float aa)\n{\n    float res = 0.0;\n    for(float i = 0.0; i < float(count); i++)\n    {\n        vec3 cParticlePos = startPos + startPosRandom * (hash13(i)-0.5);\n        float cParticleSelfTime = mod(hash11(i)*startOffset+time, lifetime);\n        cParticlePos += speed + cParticleSelfTime*(hash13(i)-0.5);\n        res += renderParticle(cParticlePos, uv, aa);\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n    vec2 uv = (fragCoord/iResolution.xy-0.5)*vec2(aspect, 1.0);\n    \n    uv += shake(iTime*25.0, 1.5)*SHAKE*pow(texture(iChannel0, vec2(0.1, 0.0)).r, REACTIVITY);\n    \n    float px = aspect/min(iResolution.x, iResolution.y);\n    \n    float angle = abs(atan(uv.y, abs(uv.x)) - HPI)/PI;\n    float height = pow(getHeight(angle/X_SCALE, SMOOTHNESS*X_SCALE, iChannel0), REACTIVITY)*HEIGHT;\n    float len = length(uv) - BASELINE;\n    \n    vec4 col = vec4(vec3(1.0), smoothstep(0.0, px, height-len)*smoothstep(0.0, px, len+MASK));\n    col += getParticles(vec3(1.0, 0.0, 10.0), vec3(0.9, 1.0, 1.0), vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 3.0), 100.0, 100.0, (iTime*0.2)+texture(iChannel1, vec2(0.1)).r*20.0, PARTICLES, uv, px)*0.1;\n    \n    col = vec4(mix(texture(iChannel2, fragCoord/iResolution.xy).rgb, col.rgb, col.w), 1.0);\n    \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define reactivity 0.3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float r = reactivity;\n\n    fragColor = vec4(mix(texture(iChannel1, uv).x, texture(iChannel0, vec2(uv.x, 0.0)).x, clamp(0.0, 1.0, (1.0-uv.x) * r)));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32990, "src": "https://soundcloud.com/tennobytemusic/tennobyte-fly-away", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(texture(iChannel1, vec2(0.0)).r + pow(texture(iChannel0, vec2(0.1, 0.0)).r, REACTIVITY)*iTimeDelta,0.0,0.0,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.1415926535\n#define HPI 1.57079632679\n#define TAU 6.28318530718\n\n#define BASELINE 0.25\n#define MASK 0.05\n#define HEIGHT 0.15\n#define REACTIVITY 3.0\n#define SHAKE 0.02\n#define X_SCALE 2.0\n#define SMOOTHNESS 10.0\n#define PARTICLES 400 // Set to a lower value if you have a slow computer\n\nfloat erp(float x, float k)\n{\n    return x < 0.5 ? pow(2.0*x, k)*0.5  : 1. - pow(2.0*(1.0-x), k) / 2.;\n}\n\nfloat getHeight(float x, float res, sampler2D tex)\n{\n    return mix(texture(tex, vec2(floor(x*res)/res, 0.0)).r, texture(tex, vec2(floor(x*res + 1.0)/res, 0.0)).r, erp(fract(x*res), 1.9));\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash12(float p)\n{\n    vec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash13(float p)\n{\n    vec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec2 shake(float time, float s)\n{\n    return mix(hash12(floor(time)), hash12(floor(time) + 1.0), erp(fract(time), s))-0.5;\n}\n\n\n", "buffer_c_code": "ivec3[] colors = ivec3[] (ivec3(39, 55, 71), ivec3(0, 49, 98), ivec3(0, 97, 195), ivec3(0, 211, 255), ivec3(230, 255, 230));\n\nvec2 hash(vec2 p)\n{\n    vec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat perlinNoise(vec2 p, float s)\n{\n    vec2 tlVal = hash(vec2(floor(p.x),  ceil(p.y)));\n    vec2 blVal = hash(vec2(floor(p.x), floor(p.y)));\n    vec2 trVal = hash(vec2( ceil(p.x),  ceil(p.y)));\n    vec2 brVal = hash(vec2( ceil(p.x), floor(p.y)));\n    \n    vec2 tlOffset = p - vec2(floor(p.x),  ceil(p.y));\n    vec2 blOffset = p - vec2(floor(p.x), floor(p.y));\n    vec2 trOffset = p - vec2( ceil(p.x),  ceil(p.y));\n    vec2 brOffset = p - vec2( ceil(p.x), floor(p.y));\n    \n    float tl = dot(tlOffset, tlVal);\n    float bl = dot(blOffset, blVal);\n    float tr = dot(trOffset, trVal);\n    float br = dot(brOffset, brVal);\n    \n    float a = mix(bl, tl, erp(fract(p.y), s));\n    float b = mix(br, tr, erp(fract(p.y), s));\n    \n    return mix(a, b, erp(fract(p.x), s)) / 2.0 + 0.5;\n}\n\n\n\nfloat fbm(in vec2 x, float s, in float H)\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        t += a*perlinNoise(f*x, s);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\nvec3 colorMap(float value)\n{\n    int colorCount = colors.length();\n    \n    float v = value * float(colorCount);\n    \n    int a = int(floor(v));\n    int b = a + 1;\n    \n    float fac = fract(v);\n    return mix(vec3(colors[a])*0.00392156862745, vec3(colors[b])*0.00392156862745, vec3(fac));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    uv += shake(iTime*25.0, 1.5)*SHAKE*pow(texture(iChannel0, vec2(0.1, 0.0)).r, REACTIVITY)*0.2;\n        uv *= 0.2;\n\n    uv.x += fbm((uv + iTime*0.01) * 1.0,           1.0, 1.0);\n    uv.y += fbm((uv + iTime*0.01) * 1.0 + 10.0, 1.0, 1.0);\n    uv.x += fbm((uv + iTime*0.01) * 1.0,           1.0, 1.0);\n    uv.y += fbm((uv + iTime*0.01) * 1.0 + 10.0, 1.0, 1.0);\n\n\n    float value = erp(fbm(uv * 20.0, 1.0, 1.0)/2.1, 6.0);\n\n    fragColor = vec4(colorMap(value),1.0);\n    //fragColor = colors[1].xyzx;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVfWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 52, 52, 174], [176, 176, 339, 339, 706], [708, 708, 765, 765, 1683]], "test": "untested"}
{"id": "ftKBWV", "name": "Good matrix rain", "author": "fishy", "description": "Good now", "tags": ["rain", "wallpaper"], "likes": 2, "viewed": 354, "published": 3, "date": "1665266647", "time_retrieved": "2024-07-30T16:27:19.589437", "image_code": "vec4 bokeh(sampler2D tex, vec2 p, float radius, float ratio, float gamma, float samples)\n{\n    vec4 acc = vec4(0);\n    float m = 1./sqrt(samples);\n    for(float i = 0.; i < samples; i++)\n    {\n        vec2 th = vec2(2.399*i, sqrt(i)*m);\n        th = vec2(cos(th.x)*ratio, sin(th.x))*th.y*radius;\n        acc += pow(texture(tex, p+th), vec4(gamma));\n    }\n    return pow(acc/samples, 1./vec4(gamma));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = vec4(bokeh(iChannel0, uv, max(0.0, length(uv-0.5)-DEADZONE)*BLUR, 1., 3., 16.).rgb, 1.0);\n    //fragColor = texture(iChannel1, uv)+0.;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "ivec2[] chars = ivec2[](\n                ivec2(1, 11),\n                ivec2(2, 11),\n                ivec2(3, 11),\n                ivec2(4, 11),\n                ivec2(5, 11),\n                ivec2(6, 11),\n                ivec2(0, 12),\n                ivec2(1, 12),\n                ivec2(2, 12),\n                ivec2(3, 12),\n                ivec2(4, 12),\n                ivec2(5, 12),\n                ivec2(6, 12),\n                ivec2(7, 12),\n                ivec2(8, 12),\n                ivec2(9, 12)\n                );\n\n\nvec4 getChar(ivec2 pos, vec2 uv)\n{\n    return texture(iChannel0, (vec2(pos)+uv)*0.0625);\n}\n\nvec4 getRandomChar(vec2 seed, vec2 uv)\n{\n    int index = int(hash21(seed)*float(chars.length()));\n    return getChar(chars[index], uv);\n}\n\nfloat getCol(vec2 uv, float time, float px, float activated)\n{\n    float col = 1.0-smoothstep(0.0, px, getRandomChar(hash22(floor(uv)), fract(uv)).w - 0.5);\n    col = floor(uv.y) <= activated? 0.0 : col-pow(min(1.0, (max(0., (floor(uv.y)-activated))-1.0)/TRAIL), 1./FALLOFF);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = (uv.x-0.5)*iResolution.x/iResolution.y+0.5;\n    uv *= COUNT;\n    float px = 1.777/iResolution.y*COUNT;\n    float margin = 1.0 + TRAIL/COUNT;\n    float activated = floor(COUNT-fract(\n                            (COUNT-(floor(hash21(floor(uv.xx))*COUNT*2.0)/COUNT-iTime*SPEED))/margin\n                            )*margin*COUNT);\n    \n    float col = 0.0;\n    \n    col = getCol(uv, iTime, px, activated);\n    \n    fragColor = vec4(vec3(clamp(col, 0., 1.)), 1);\n}", "buffer_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define COUNT 50.0\n#define SPEED 0.3\n#define TRAIL 20.0\n#define FALLOFF 2.0\n#define DISTORTION 0.5\n\n#define BLUR 0.007\n#define DEADZONE 0.2\n\nfloat hash21(in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}", "buffer_b_code": "vec2 uvDistort(in vec2 uv, float str, float aspect)\n{\n    uv -= 0.5;\n    uv.y *= aspect;\n    \n    uv *= str;\n    uv += atan(uv)*length(uv)/str;\n    uv.y /= aspect;\n    uv += 0.5;\n    \n    if(hash21(floor(uv*100.0)) < 0.5)\n        uv += (hash22(floor(uv*100.0)) - 0.5)*0.002;\n    \n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float px = 1.777/iResolution.y;\n    uv = mix(uv, uvDistort(uv, 0.8, iResolution.y/iResolution.x), DISTORTION);\n    fragColor = texture(iChannel0, uv)*vec4(0.172549019608, 0.878431372549, 0.0, 1.0);\n    //fragColor = texture(iChannel1, uv);\n    fragColor *= smoothstep(px, 0.0, length(clamp(uv, vec2(0.0), vec2(1.0)) - uv));\n    fragColor *= smoothstep(-1., 1., sin(uv.y*500.0 + iTime * 20.)) * 0.3 + 0.7;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKBWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 90, 90, 401], [404, 404, 461, 511, 705]], "test": "untested"}
{"id": "NlVfDK", "name": "Fork Hand Eye C Crackhause 471", "author": "Crackhausen", "description": "CC0: Hand Eye Coordination\nWanted to add some kind of pattern to the inside of the hand\nso stole some code from an earlier shader\n", "tags": ["2d"], "likes": 10, "viewed": 234, "published": 3, "date": "1665265529", "time_retrieved": "2024-07-30T16:27:20.350402", "image_code": "// CC0: Hand Eye Coordination\n//  Wanted to add some kind of pattern to the inside of the hand\n//  so stole some code from an earlier shader\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PSIN(x)     (0.5+0.5*sin(x))\n#define LESS(a,b,c) mix(a,b,step(0.,c))\n#define SABS(x,k)   LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n\nconst float fixed_radius2 = 1.9;\nconst float min_radius2   = 0.5;\nconst float folding_limit = 1.0;\nconst float scale         = -2.8;\n\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(-a, a, k);\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat vesica(vec2 p, float r, float d) {\n  p = abs(p);\n  float b = sqrt(r*r-d*d);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat unevenCapsule(vec2 p, float r1, float r2, float h) {\n  p.x = abs(p.x);\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(p,vec2(-b,a));\n  if( k < 0.0 ) return length(p) - r1;\n  if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n  return dot(p, vec2(a,b) ) - r1;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat parabola(vec2 pos, float wi, float he) {\n  pos.x = abs(pos.x);\n  float ik = wi*wi/he;\n  float p = ik*(he-pos.y-0.5*ik)/3.0;\n  float q = pos.x*ik*ik*0.25;\n  float h = q*q - p*p*p;\n  float r = sqrt(abs(h));\n  float x = (h>0.0) ? \n      pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n      2.0*cos(atan(r/q)/3.0)*sqrt(p);\n  x = min(x,wi);\n  return length(pos-vec2(x,he-x*x/ik)) * \n         sign(ik*(pos.y-he)+pos.x*pos.x);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n\nfloat segmenty(vec2 p, float off) {\n  p.y = abs(p.y);\n  p.y -= off;\n  float d0 = abs(p.x);\n  float d1 = length(p);\n  return p.y > 0.0 ? d1 : d0;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n        float temp = (fixed_radius2 / min_radius2);\n        z *= temp;\n        dz *= temp;\n    } else if(r2 < fixed_radius2) {\n        float temp = (fixed_radius2 / r2);\n        z *= temp;\n        dz *= temp;\n    }\n}\n\nvec3 polySoftMin3(vec3 a, vec3 b, vec3 k) {\n  vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvoid box_fold(inout vec3 z, inout float dz) {\n  const float k = 0.05;\n  // Soft clamp after suggestion from ollij\n  vec3 zz = sign(z)*polySoftMin3(abs(z), vec3(folding_limit), vec3(k));\n  // Hard clamp\n  // z = clamp(z, -folding_limit, folding_limit);\n  z = zz * 2.0 - z;\n}\n\nfloat sphere(vec3 p, float t) {\n  return length(p)-t;\n}\n\n// Taken from evilryu's shader: https://www.shadertoy.com/view/XdlSD4\n// And tinkered with\nfloat mb(vec3 z) {\n    vec3 offset = z;\n    float dr = 1.0;\n    float fd = 0.0;\n    for(int n = 0; n < 5; ++n) {\n        box_fold(z, dr);\n        sphere_fold(z, dr);\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 1.0;        \n        float r1 = sphere(z, 5.0);\n        float r2 = torus(z, vec2(8.0, 1));\n        r2 = abs(r2) - 0.25;\n        float r = n < 4 ? r2 : r1;        \n        float dd = r / abs(dr);\n        if (n < 2 || dd < fd) {\n          fd = dd;\n        }\n    }\n    return fd;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat eye(vec2 p) {\n  float a  = mix(0.0, 0.85, smoothstep(0.995, 1.0, cos(TAU*TIME/5.0)));\n  const float b = 4.0;\n  float rr = mix(1.6, b, a);\n  float dd = mix(1.12, b, a);\n  \n  vec2 p0 = p;\n  p0 = p0.yx;\n  float d0 =  vesica(p0, rr, dd);\n  float d5 = d0;\n\n  vec2 p1 = p;\n  p1.y -= 0.28;\n  float d1 = circle(p1, 0.622);\n  d1 = max(d1,d0);\n\n  vec2 p2 = p;\n  p2 -= vec2(-0.155, 0.35);\n  float d2 = circle(p2, 0.065);\n\n  vec2 p3 = p;\n  p3.y -= 0.28;\n  p3 = toPolar(p3);\n  float n3 = mod1(p3.x, 0.05);\n  float d3 = abs(p3.x)-0.0125*(1.0-length(p1));\n\n  vec2 p4 = p;\n  p4.y -= 0.28;\n  float d4 = circle(p4, 0.285);\n\n  d3 = max(d3,-d4);\n\n  d1 = pmax(d1,-d2, 0.0125);\n  d1 = max(d1,-d3);\n\n  float t0 = abs(0.9*p.x);\n  t0 *= t0;\n  t0 *= t0;\n  t0 *= t0;\n  t0 = clamp(t0, 0.0, 1.0);\n  d0 = abs(d0)-mix(0.0125, -0.0025, t0);\n\n\n  float d = d0;\n  d = pmin(d, d1, 0.0125);\n  return d;\n}\n\nfloat starn(vec2 p, float r, float n, float m) {\n  // next 4 lines can be precomputed for a given shape\n  float an = 3.141593/float(n);\n  float en = 3.141593/m;  // m is between 2 and n\n  vec2  acs = vec2(cos(an),sin(an));\n  vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n  float bn = mod(atan(p.x,p.y),2.0*an) - an;\n  p = length(p)*vec2(cos(bn),abs(sin(bn)));\n  p -= r*acs;\n  p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n  return length(p)*sign(p.x);\n}\n\nvec2 hand(vec2 p) {\n  p.x = abs(p.x);\n  vec2 p0 = p;\n  p0 -= vec2(0.0, 0.180+0.00);\n  float d0 = segmenty(p0, 0.61)-0.1;\n  vec2 p1 = p;\n  p1 -= vec2(0.2, 0.125);\n  float d1 = segmenty(p1,0.55)-0.09;\n  vec2 p2 = p;\n  p2 -= vec2(0.0, -0.38+0.3);\n  p2.y = -p2.y;\n  float d2 = unevenCapsule(p2, 0.3, 0.38, 0.3);\n  vec2 p3 = p;\n  p3 -= vec2(0.47, -0.31);\n  float d3 = parabola(p3, 0.37, 0.5);\n\n  vec2 p4 = p;\n  p4 -= vec2(0.99, -0.4);\n  float d4 = circle(p4, 0.61);\n  d3 = max(d3, -d4);\n\n  vec2 p5 = p;\n  p5 -= vec2(0.0, -0.45);\n//  float d5 = vesica(p5.yx, 0.175, 0.1)-0.2;\n  float d5 = starn(p5.yx, 0.33, 10.0, 3.5);\n  float d6 = abs(d5-0.005)-0.005;\n\n\n  d0 = min(d0, d1);  \n  d3 = p.y > -0.40 ? d3 : d2;\n\n  \n  float d = d3;\n  d = min(d, d2);\n  d = pmax(d, -(d0-0.01), 0.025);\n  d = min(d, d0);\n  float ds = max(min(d0, d3), -d5);\n  d = max(d, -d6);\n  \n  float od = d;\n  od = abs(od-0.02)-0.0075;\n  \n  d = min(d, od);\n  d = pmin(d, d5, 0.01);\n  return vec2(d, ds);\n}\n\nfloat weird(vec2 p) {\n  const float s = 0.55;\n  p /= s;\n  float rep = 20.0;\n  float ss = 0.05*6.0/rep;\n  vec3 p3 = vec3(p.x, p.y, PSIN(TIME*0.257));\n  p3.yz *= ROT(TIME*0.05);\n  float n = smoothKaleidoscope(p3.xy, ss, rep);\n  return mb(p3)*s;\n}\n\nfloat df(vec2 p) {\n  const float zw = 1.25;\n  float da = weird(p/zw)*zw;\n  vec2 dh = hand(p);\n  const float ze = 0.28;\n  vec2 pe = p;\n  pe -= vec2(0.0, -0.45);\n  pe /= ze;\n  float de = eye(pe);\n  de *= ze;\n  \n  float d = dh.x;\n  d = max(d, -de);\n  d = max(d, -pmax(da, dh.y, 0.0125));\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float aa = 2.0/RESOLUTION.y;\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0 * q;\n  p.x    *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.1*q.y);\n  float d = df(p);\n  float fade = smoothstep(0.0, 4.0, TIME);\n  col = mix(col, mix(vec3(1.0, 0.5, 0.5), vec3(.5, 0.55, 0.95), q.y), smoothstep(aa, -aa, d)*fade);\n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlVfDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[601, 684, 720, 720, 953], [955, 1038, 1077, 1077, 1162], [1164, 1164, 1203, 1203, 1232], [1234, 1234, 1264, 1264, 1292], [1294, 1325, 1364, 1364, 1489], [1491, 1577, 1622, 1622, 1776], [1778, 1829, 1869, 1869, 2018], [2020, 2071, 2129, 2129, 2354], [2356, 2407, 2453, 2453, 2840], [2842, 2934, 2963, 2963, 3028], [3030, 3030, 3061, 3061, 3087], [3090, 3090, 3125, 3125, 3236], [3238, 3238, 3260, 3260, 3304], [3307, 3307, 3328, 3328, 3373], [3375, 3375, 3423, 3423, 3693], [3695, 3695, 3738, 3738, 3826], [3828, 3828, 3873, 3873, 4101], [4103, 4103, 4134, 4134, 4158], [4160, 4251, 4269, 4269, 4758], [4760, 4760, 4821, 4821, 5034], [5036, 5036, 5055, 5055, 5909], [5911, 5911, 5959, 6014, 6395], [6397, 6397, 6416, 6416, 7360], [7362, 7362, 7383, 7383, 7606], [7608, 7608, 7626, 7626, 7906], [7908, 7908, 7963, 7963, 8347]], "test": "untested"}
{"id": "slyfDK", "name": "Learn with ease glsl hlsl", "author": "omadridi858", "description": "Follow me on my Instagram\nhttps://www.instagram.com/mr.gf999/", "tags": ["learnglslhlsl"], "likes": 1, "viewed": 235, "published": 3, "date": "1665239568", "time_retrieved": "2024-07-30T16:27:21.122338", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n   //vec2 direction = normalize(vec2(gl_FragCoord.x,gl_FragCoord.y));\n      if (gl_FragCoord.x<100.){fragColor = vec4(0,0,1,  1.0);}\n    \n      if (gl_FragCoord.x>400.){\n      fragColor = vec4(0,0,1,  1.0);\n     }\n      if (gl_FragCoord.y<100.){\n      fragColor = vec4(0,0,1,  1.0);\n     }\n     if (gl_FragCoord.y>300.){\n      fragColor = vec4(0,0,1,  1.0);\n     }\n     }\n   \n\t\n   \n     \n   \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyfDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 130, 432]], "test": "untested"}
{"id": "7lyBDK", "name": "ShaderDojo 011 Remix", "author": "antonOTI", "description": "It has been a while since I've come here. yesterday I remembered that shader and though I wanted to tweak it a bit.\n\nThis is heavily inspired by Ether from Nimitz [https://www.shadertoy.com/view/MsjSW3]\n\noriginal : [https://www.shadertoy.com/view/tss3Rl]", "tags": ["raymarching"], "likes": 5, "viewed": 236, "published": 3, "date": "1665236239", "time_retrieved": "2024-07-30T16:27:22.089752", "image_code": "// Shader Dojo by AntonMakesGames\n// Original https://www.shadertoy.com/view/tss3Rl\n\n\n#define PI 3.14159\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nmat2 rot(float a)\n{\n  float ca = cos(a);\n  float sa = sin(a);\n  return mat2(ca,-sa,sa,ca);\n}\n\nfloat map(vec3 p)\n{\n  vec3 cp = p;\n  float dist = 1000.;\n\n  float time = iTime * .5;\n\n  p.zx *= rot(-time * .25);\n\n  for(float it = 0.; it < 5.; it += 1.)\n{\n  p.xz *= rot(sin(p.y + time + (fract(sin(it * 2369.)))) * PI / (it + 1.) * 1.5);\n\n  p.y += p.x * .125;\n  p.zy *= rot(time);\n\n  dist  =smin(dist, length(p) - 1., .25);\n}\n\n  return dist;\n}\n\nfloat ray(inout vec3 cp, vec3 rd, out float cd)\n{\n  float st = 0.;\n  for(;st < 1.; st += 1. /64.)\n  {\n    cd = map(cp);\n    if(cd < .01)\n    {\n      break;\n    }\n    cp += rd * cd * .75;\n  }\n\n  return st;\n}\n\nvec3 normal(vec3 p)\n{\n  vec2 e = vec2(.01,.0);\n\n  return normalize(vec3(\n  map(p - e.xyy) - map(p + e.xyy),\n  map(p - e.yxy) - map(p + e.yxy),\n  map(p - e.yyx) - map(p + e.yyx)\n));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  uv *= .35;\n\n  vec3 eye = vec3(.2,0.,-7.);\n  vec3 rd = normalize(vec3(uv, 1.));\n  vec3 cp = eye;\n\n  float cd;\n  float st = ray(cp, rd, cd);\n\n  fragColor = vec4(0.);\n  if(cd < .01)\n  {\n    vec3 norm = normal(cp);\n    vec3 li = normalize(vec3(.7,.35, 2.));\n    li.xz *= rot(sin(iTime * .125) * .5);\n    float f = pow(dot(norm, li), 4.25) * 1.1;\n    vec4 col = vec4(.76,.75,.95, 1.) * f;\n\n    col = pow(col, vec4(2.2));\n    fragColor = mix(vec4(0.), col * 1.5, f);\n  }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyBDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 149, 149, 249], [251, 251, 270, 270, 343], [345, 345, 364, 364, 689], [691, 691, 740, 740, 897], [899, 899, 920, 920, 1081], [1083, 1083, 1140, 1140, 1747]], "test": "untested"}
{"id": "7lKfzK", "name": "Cubic Pencils", "author": "mla", "description": "Pencils of plane cubics of the form LMN + kP for n = 0..3 and L,M,N,P equations of lines (L,M,N grey, P red). \n\nMove lines by dragging attached discs (N is fixed at y = 0).\n\nup/down zooms, left/right sets power of P, page up/down sets pencil density.\n", "tags": ["curve", "pencil", "cubic"], "likes": 11, "viewed": 188, "published": 3, "date": "1665230048", "time_retrieved": "2024-07-30T16:27:23.052179", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Cubic Pencils, mla 2022\n//\n// Pencils of cubics of the form LMN + kP for n = 0..3 and \n// L,M,N,P equations of lines (L,M,N grey, P red). Move lines \n// by dragging attached discs (N is fixed at y = 0).\n//\n// For power of P = n:\n// n = 0: P is disregarded, curve intersects L,M,N only at infinity.\n// n = 1: curve intersects L,M,N where they intersect P\n// n = 2: curve is tangent to L,M,N where they intersect P\n// n = 3: curve has inflexion points where L,M,N intersect P\n// L,M,N are asymptotes for n <= 2\n//\n// up/down: zoom\n// left/right: set power of P\n// page up/down: set pencil density.\n// 's': hide control points\n// 't': hide control lines\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvec3 L,M,N,P;\n\nint n = 1; // Power of P\nint NN = 32; \n\n// (FGH)' = F'GH+F(GH)' = F'GH + FG'H + FGH'\nfloat cubic(vec3 p, float k) {\n  float Lp = dot(L,p);\n  float Mp = dot(M,p);\n  float Np = dot(N,p);\n  float Pp = dot(P,p);\n  float cosk = cos(k), sink = sin(k);\n  float t = cosk*Lp*Mp*Np - sink*ipow(Pp,n);\n\n  vec2 dxdy = cosk*(Lp*Mp*N.xy + Lp*M.xy*Np + L.xy*Mp*Np) - sink*float(n)*P.xy*ipow(Pp,n-1);\n  t /= length(dxdy);\n  return t;\n}\n\nvec3 mkline(vec2 p) {\n  return vec3(p,-dot(p,p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    setscale();\n    n = (1+keycount(KEY_RIGHT)-keycount(KEY_LEFT))%4;\n    float NN = float(abs(24+keycount(KEY_PAGE_DOWN)-keycount(KEY_PAGE_UP)));\n    assert(n >= 0);\n    float pwidth = scale*0.02;\n    float lwidth = scale*0.001;\n    vec3 p = vec3(map(fragCoord),1);\n    float px = fwidth(length(p.xy));\n    L = mkline(getselection(0));\n    M = mkline(getselection(1));\n    N = vec3(0,1,0); // x axis\n    //N = L; // cusped curves with n = 3.\n    P = mkline(getselection(2));\n    \n    float LMN = dot(L,p)*dot(M,p)*dot(N,p);\n    float k = LMN/ipow(dot(P,p),n);\n    //k = dot(p,p*p)/(p.x*p.y*p.z); // Hesse pencil\n    k = atan(k);\n    k /= PI; k += 0.5; k *= NN; k -= iTime;\n    k = round(k);\n    float k0 = k;\n    k += iTime; k /= NN; k -= 0.5; k *= PI;\n    float d = cubic(p,k);\n    float t = 16.0*d/scale;\n    vec3 col = vec3(0.2);\n    vec3 lcol = 0.2+0.8*h2rgb(k0/NN);\n    col = mix(lcol,col,smoothstep(0.0,1.0*px,abs(d)));\n    if (!key(CHAR_L)) {\n      float d = line(p,P);\n      if (n != 0) col = mix(vec3(1,0,0),col,smoothstep(0.0,px,d-0.5*lwidth));\n      d = line(p,L);\n      d = min(d,line(p,M));\n      d = min(d,line(p,N));\n      col = mix(vec3(0.75),col,smoothstep(0.0,px,d-0.5*lwidth));\n    }\n    if (!key(CHAR_S)) {\n      // Show point pair locations\n      float d = 1e8;\n      for (int i = 0; i < nselections; i++) {\n        if (n == 0 && i == 2) continue;\n        d = min(d,distance(p.xy,getselection(i)));\n      }\n      col = mix(vec3(0),col,0.25+0.75*smoothstep(0.0,px,d-pwidth));\n    }\n    col = pow(col,vec3(0.4545));\n    if (alert) col.r = 1.0;//col = 1.0-col;\n    // Output to screen\n    fragColor = vec4(col, 1.0);;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n      if (t.x <= 0.0 && iMouse.z > 0.0) t.zw = map(iMouse.xy); // Default selection\n    } else if (iFrame == 0 || t.w != 12345.0) {\n      t.xy = initselection(i-1); // Current coordinates\n      t.w = 12345.0; // Magic number\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store((key),0).x))\n#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\n#define map(screenpos) (scale*(2.0*(screenpos)-iResolution.xy)/iResolution.y)\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n#define getselected() (texelFetch(iChannel2,ivec2(0,3),0))\n#define setscale() (scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP))))\n#define defaultselection() (texelFetch(iChannel2,ivec2(0,3),0).zw)\n\nfloat scale = 3.0;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst int nselections = 3;\nvec2 initselection(int i) {\n  if (i == 0) return vec2(-0.5,0.5);\n  if (i == 1) return vec2(-2.5,0);\n  if (i == 2) return vec2(0.4,-1.0);\n  return vec2(0);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n  return rgb;\n}\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nfloat line(vec3 p, vec3 q) {\n  return abs(dot(p,q)/(p.z*length(q.xy)));\n}\n\nfloat line(vec3 p, vec3 q, vec3 r) {\n  return line(p,cross(q,r));\n}\n\nfloat ipow(float x, int n) {\n float y = 1.0;\n for (int i = 0; i < n; i++) y*=x;\n return y;\n}\n\nfloat hcubic(vec3 p, float k) {\n  float A = dot(p*p,p);\n  float B = p.x*p.y*p.z;\n  float cosk = cos(k), sink = sin(k);\n  float t = cosk*A - sink*B;\n\n  vec2 dxdy = cosk*3.0*p.xy*p.xy - sink*p.yz*p.zx;\n  t /= length(dxdy);\n  return t;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKfzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[881, 926, 956, 956, 1260], [1262, 1262, 1283, 1283, 1313], [1315, 1315, 1372, 1372, 3011]], "test": "untested"}
{"id": "ftGfWV", "name": "Psycheye", "author": "rubioh", "description": "eye", "tags": ["eye"], "likes": 17, "viewed": 258, "published": 3, "date": "1665229373", "time_retrieved": "2024-07-30T16:27:24.085416", "image_code": "#define PI 3.141593\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    return a + b*cos(6.28318*(c*t+d));\n}\n\nvec2 hash( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(175.1,311.7)),\n             dot(p,vec2(260.5,752.3)));\n    return fract(sin(p+455.)*18.5453);\n}\n\nvec2 hash2( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    float n = 111.0*p.x + 113.0*p.y;\n    return fract(n*fract(k*n));\n}\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = hash2(i).x;\n    float b = hash2(i + vec2(1.0, 0.0)).x;\n    float c = hash2(i + vec2(0.0, 1.0)).x;\n    float d = hash2(i + vec2(1.0, 1.0)).x;\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm( in vec2 x)\n{    \n    float t = 0.0;\n    float amp = 0.;\n    for( int i=1; i<7; i++ )\n    {\n        float f = pow( 2., float(i) );\n        float a = pow( f, -.75 );\n        amp = 10.*step(3., float(i));\n        t += a*noise(f*x+amp);\n    }\n    return t*1.-.4;\n}\nvec2 make_eye(vec2 uv){\n    float area_eye = smoothstep(140./iResolution.y, 0., abs(abs(uv.y) - (.1*cos(iTime)+.9)*sin(uv.x+PI/2.))-.15);\n    return vec2(area_eye, // contour\n              smoothstep(140./iResolution.y, 0., abs(uv.y) - (.1*cos(iTime)+.9)*sin(uv.x+PI/2.))// inside\n            );\n}\n\nvec2 make_pupil(vec2 uv, vec2 center, float radius){\n    return vec2(\n        smoothstep(5./iResolution.y, 0., abs(length(uv+-center)-radius)-.02), // Pupille contour\n        1.-smoothstep(-5./iResolution.y, 0., (length(uv-center)-radius)-.02)); // Pupille inside\n}\n\nvec3 red_pupil(vec2 uv, vec2 center, float radius){\n    return vec3(\n        1.-smoothstep(0., radius/3., length(uv-center)), 0., 0.); // Pupille inside\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( 2.*fragCoord.xy - iResolution.xy ) / iResolution.y;\n    uv *= 1.5;\n    // Time varying pixel color\n    vec2 center = vec2(0., 0.);\n    float radius = .2+.1*cos(iTime*.3);\n    \n    \n    \n    vec2 pupille = make_pupil(uv, center, radius);\n    vec2 eye = make_eye(uv);\n    \n    vec2 st = (uv-center)*(3.);\n    \n    \n    float N = cos(iTime*.8)+ 2.;\n    \n    float length_st = pow( pow(abs(st.x), N) + pow(abs(st.y), N), 1./N);\n    float n = noise(vec2(length_st, length_st) - .2*iTime)*5.+fbm(abs(st)-iTime+fbm(abs(st))) ;\n    \n    // iq's palette\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = 1.-a;\n    vec3 c = vec3(.3, .3, .3);\n    vec3 d = vec3(0.0, 0.1, 0.2);\n    vec3 iris = palette(n, a,b,c,d)*eye.y* (1. - pupille.y) + vec3(.3)*pupille.x;\n    \n    /*\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = 1.-a;\n    vec3 c = vec3(.3, .3, .3);\n    vec3 d = vec3(0.0, 0.1, 0.2);\n    vec3 iris = palette(n, a,b,c,d)*eye.y* (1. - pupille.y);\n    */    \n    \n    \n    \n    vec3 col = iris;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGfWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 77, 77, 118], [120, 120, 141, 172, 292], [294, 294, 317, 317, 437], [438, 438, 463, 463, 800], [802, 802, 825, 825, 1073], [1074, 1074, 1097, 1097, 1371], [1373, 1373, 1425, 1425, 1638], [1640, 1640, 1691, 1691, 1794], [1796, 1796, 1853, 1903, 2960]], "test": "untested"}
{"id": "ftGfDK", "name": "Saturday cubism experiment", "author": "mrange", "description": "CC0: Saturday cubism experiment\nTrying to recreate some twitch graphics but failed\nbut thought the failure looked interesting enough to share\n", "tags": ["3d", "cubes"], "likes": 36, "viewed": 426, "published": 3, "date": "1665221439", "time_retrieved": "2024-07-30T16:27:25.054824", "image_code": "// CC0: Saturday cubism experiment\n//  Trying to recreate some twitch graphics but failed\n//  but thought the failure looked interesting enough to share\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define TOLERANCE       0.0005\n#define MAX_RAY_LENGTH  20.0\n#define MAX_RAY_MARCHES 80\n#define MAX_SHD_MARCHES 20\n#define NORM_OFF        0.005\n\nconst mat2 rot0 = ROT(0.0);\nmat2 g_rot0 = rot0;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff = 0.0;\n\nconst vec3 skyCol     = HSV2RGB(vec3(hoff+0.57, 0.90, 0.25));\nconst vec3 skylineCol = HSV2RGB(vec3(hoff+0.02, 0.95, 0.5));\nconst vec3 sunCol     = HSV2RGB(vec3(hoff+0.07, 0.95, 0.5));\nconst vec3 diffCol1   = HSV2RGB(vec3(hoff+0.60, 0.90, 1.0));\nconst vec3 diffCol2   = HSV2RGB(vec3(hoff+0.55, 0.90, 1.0));\n\nconst vec3 sunDir1    = normalize(vec3(0., 0.05, -1.0));\n\nconst vec3 lightPos1  = vec3(10.0, 10.0, 10.0);\nconst vec3 lightPos2  = vec3(-10.0, 10.0, -10.0);\n  \n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions3d/distfunctions3d.htm\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat ref(inout vec3 p, vec3 r) {\n  float d = dot(p, r);\n  p -= r*min(0.0, d)*2.0;\n  return d < 0.0 ? 0.0 : 1.0;\n}\n\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  float sf = 1.0001-max(dot(sunDir1, rd), 0.0);\n  col += skyCol*pow((1.0-abs(rd.y)), 8.0);\n  col += clamp(vec3(mix(0.0025, 0.125, tanh_approx(.005/sf))/abs(rd.y))*skylineCol, 0.0, 10.0);\n  sf *= sf;\n  col += sunCol*0.00005/sf;\n\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n  }\n\n  return clamp(col, 0.0, 10.0);\n}\n\nfloat df(vec3 p) {\n  p.xz *= g_rot0;\n  vec3 p0 = p;\n  vec3 p1 = p;\n  vec3 p2 = p;\n\n  const float ss = 1.;\n  p0.y -= -0.2;\n  p0.z = abs(p0.z);\n  p0.x = -abs(p0.x);\n  p0.x -= -0.4*ss;\n  ref(p0, normalize(vec3(1.0, -0.05, -1.0)));  \n  p0.x -= 1.3*ss;\n  ref(p0, normalize(vec3(1.0, 0.30, 1.0)));  \n  p0.x -= 1.4*ss;\n  p0.z -= 0.3*ss;\n  ref(p0, normalize(vec3(1.0, -1.0, 0.5)));\n  p0.x -= 1.25*ss;\n  p0.z -= -0.5*ss;\n  p0.y -= -0.3*ss;\n  float d0 = box(p0, vec3(0.5))-0.0125;\n\n  p1.x -= 0.4;\n  p1.y -= 0.75;\n  float d1 = box(p1, vec3(1.25))-0.0125;\n\n  p2.y += 2.0;\n  float d2 = p2.y;\n\n  float d = d1;\n  d = min(d, d0);\n  d = min(d, d2);\n  return d;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float initt) {\n  float t = initt;\n  float tol = TOLERANCE;\n  for (int i = 0; i < MAX_RAY_MARCHES; ++i) {\n    if (t > MAX_RAY_LENGTH) {\n      t = MAX_RAY_LENGTH;    \n      break;\n    }\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE) {\n      break;\n    }\n    t += d;\n  }\n  return t;\n}\n\nfloat shadow(vec3 lp, vec3 ld, float mint, float maxt) {\n  const float ds = 1.0-0.4;\n  float t = mint;\n  float nd = 1E6;\n  float h;\n  const float soff = 0.05;\n  const float smul = 1.5;\n  for (int i=0; i < MAX_SHD_MARCHES; ++i) {\n    vec3 p = lp + ld*t;\n    float d = df(p);\n    if (d < TOLERANCE || t >= maxt) {\n      float sd = 1.0-exp(-smul*max(t/maxt-soff, 0.0));\n      return t >= maxt ? mix(sd, 1.0, smoothstep(0.0, 0.025, nd)) : sd;\n    }\n    nd = min(nd, d);\n    t += ds*d;\n  }\n  float sd = 1.0-exp(-smul*max(t/maxt-soff, 0.0));\n  return sd;\n}\n\nvec3 boxCol(vec3 col, vec3 nsp, vec3 rd, vec3 nnor, vec3 nrcol, float nshd1, float nshd2) {\n  float nfre  = 1.0+dot(rd, nnor);\n  nfre        *= nfre;\n\n  vec3 nld1   = normalize(lightPos1-nsp); \n  vec3 nld2   = normalize(lightPos2-nsp); \n\n  float ndif1 = max(dot(nld1, nnor), 0.0);\n  ndif1       *= ndif1;\n\n  float ndif2 = max(dot(nld2, nnor), 0.0);\n  ndif2       *= ndif2;\n\n  vec3 scol = vec3(0.0);\n  float rf = smoothstep(1.0, 0.9, nfre);\n  scol += diffCol1*ndif1*nshd1;\n  scol += diffCol2*ndif2*nshd2;\n  scol += 0.1*(skyCol+skylineCol);\n  scol += nrcol*0.75*mix(vec3(0.25), vec3(0.5, 0.5, 1.0), nfre);\n\n  col = mix(col, scol, rf*smoothstep(90.0, 20.0, dot(nsp, nsp)));\n  \n  return col;\n}\n\nvec3 render1(vec3 ro, vec3 rd) {\n  vec3 skyCol = render0(ro, rd);\n  vec3 col = skyCol;\n\n  float nt    = rayMarch(ro, rd, .0); \n  if (nt < MAX_RAY_LENGTH) {\n    vec3 nsp    = ro + rd*nt;\n    vec3 nnor   = normal(nsp);\n\n    vec3 nref   = reflect(rd, nnor);\n    float nrt   = rayMarch(nsp, nref, 0.2);\n    vec3 nrcol  = render0(nsp, nref);\n    \n    if (nrt < MAX_RAY_LENGTH) {\n      vec3 nrsp   = nsp + nref*nrt;\n      vec3 nrnor  = normal(nrsp);\n      vec3 nrref  = reflect(nref, nrnor);\n      nrcol = boxCol(nrcol, nrsp, nref, nrnor, render0(nrsp, nrref), 1.0, 1.0);\n    }\n\n    float nshd1  = mix(0.0, 1.0, shadow(nsp, normalize(lightPos1 - nsp), 0.1, distance(lightPos1, nsp)));\n    float nshd2  = mix(0.0, 1.0, shadow(nsp, normalize(lightPos2 - nsp), 0.1, distance(lightPos2, nsp)));\n\n    col = boxCol(col, nsp, rd, nnor, nrcol, nshd1, nshd2);    \n  }\n\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  g_rot0 = ROT(-0.2*TIME);\n  \n  const float fov = tan(TAU/6.0);\n  const vec3 ro = vec3(0.0, 2.5, 5.0);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = vec3(0.1, 1.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = cross(ww,uu);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render1(ro, rd);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  col = aces_approx(col); \n  col = sRGB(col);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGfDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[678, 678, 700, 700, 846], [1632, 1732, 1751, 1751, 1838], [1840, 1947, 1973, 1973, 2157], [2159, 2219, 2247, 2313, 2389], [2391, 2484, 2526, 2526, 2573], [2575, 2693, 2720, 2720, 2796], [2798, 2916, 2943, 2943, 3030], [3032, 3032, 3065, 3065, 3146], [3148, 3148, 3180, 3180, 3774], [3776, 3776, 3794, 3794, 4421], [4423, 4423, 4446, 4446, 4654], [4656, 4656, 4703, 4703, 4975], [4977, 4977, 5033, 5033, 5527], [5529, 5529, 5620, 5620, 6218], [6220, 6220, 6252, 6252, 7089], [7091, 7091, 7112, 7112, 7490], [7492, 7492, 7547, 7547, 7747]], "test": "untested"}
{"id": "slVfDy", "name": "Hilbert c. 5b/ accidental celtic", "author": "FabriceNeyret2", "description": "just for the nice \"accidental celtic\"  bug :-)\n\nOk, building fractals by acting on the coordinates it's not the proper way to compute clean SDF...", "tags": ["short", "filling", "hilbertcurve", "celtic"], "likes": 20, "viewed": 275, "published": 3, "date": "1665212341", "time_retrieved": "2024-07-30T16:27:29.292494", "image_code": "// variant of https://shadertoy.com/view/XtjXW3\n// and https://www.shadertoy.com/view/NtKBRd\n\n#define plot(U,l) ( dot(U,l) > 0.  ? abs( dot(U , vec2(-l.y,l.x)) ) : 0. )\n#define plotC(U,l)  abs( length(U-(l)/2.) - .5 )\n\nvoid iter( inout vec2 U, inout vec2 l, inout vec2 r ) {\n        vec2 I = vec2(1,0), J = vec2(0,1), k,\n           fU = step(.5,U);                                                 // select child\n        bvec2 c = bvec2(fU);     \n        U = 2.*U - fU;                                                      // go to new local frame\n        l = c.x ? c.y ? -J : -I                                             //   node left segment\n                : c.y ?  l :  J;\n        r =  c.x==c.y ?  I : c.y ?-J:J;                                     //   node right segment\n                                                                            // the heart of Hilbert curve : \n        if (c.x) { U.x = 1.-U.x;  l.x=-l.x;  r.x=-r.x;  k=l;l=r;r=k; }      //   sym\n        if (c.y) { U   = 1.-U.yx; l  =-l.yx; r  =-r.yx; }                   //   rot+sym\n}\n\nvoid mainImage( out vec4 O,  vec2 u )\n{\n    O = vec4(0);\n    vec2  R = iResolution.xy,\n          U = u/R.y - vec2(.3,0) + 1e-5, // or bug at depth 2. why ?\n          P = vec2(.5), l=vec2(-1,0),r=l;\n    float T = 2.*ceil( log2(R.y)-4. ), t = floor(mod(iTime,T));\n        t = min(t, T-t);\n        \n#if 1\n    float v, d=9.;\n    for( int k=0; k<9; k++ ) {\n        vec2 D = vec2(k%3-1,k/3-1), \n             V = U+D/exp2(t)/4., l=vec2(-1,0),r=l; //, P = vec2(.5)-D; \n        for( float i=0.; i<t; i++ )\n            iter(V,l,r);\n         // Shane: dot(l,r)==0.\n        v = length(l+r) > 0. ?   plotC (V-P, l+r) :  plot (V-P, l) + plot (V-P, r);\n        d = min(d,v);\n    }\n    v = d;\n#else\n    for( float i=0.; i<t; i++ )\n        iter(U,l,r);\n    float v = length(l+r) > 0. ?   plotC (U-P, l+r) :  plot (U-P, l) + plot (U-P, r); \n#endif\n\n    O = vec4( sin(v*R.y/exp2(t)) ) ;\n/*  P = min(U,1.-U);                               // clamp\n    O = vec4(  smoothstep( 1.5, -1.5, ( v  -.33 ) *R.y/exp2(t) )\n              * step( 0., min(P.x,P.y)  ) );\n*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVfDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 274, 274, 1064], [1066, 1066, 1105, 1105, 2108]], "test": "untested"}
{"id": "stKBDG", "name": "Hologram Chamber", "author": "jarble", "description": "This fractal resembles a 3-dimensional hologram.", "tags": ["3d", "fractal", "hologram"], "likes": 11, "viewed": 527, "published": 3, "date": "1665193827", "time_retrieved": "2024-07-30T16:27:30.357646", "image_code": "#define R(p,a,t) mix(a*dot(p,a),p,cos(t))+sin(t)*cross(p,a)\n#define H(h) (cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    vec3 r=iResolution,c=vec3(0),\n    d=normalize(vec3(C-.5*r.xy,r.y));\n    float i=0.,s,e,g=0.,t=iTime;\n\tfor(;i++<99.;){\n        vec4 p=vec4(g*d,.08);\n        p.z-=.7;\n        p.xyz=R(p.xyz,normalize(H(t*.05)),t*.2);\n        s=1.;\n        for(int j=0;j++<7;)\n            p += .5,\n            s*=e=max(1./(1.-abs(p.y)),1.),\n            p=abs(p.wzyx)*e-.9;\n        e=abs(length(p.w)/s-.04);\n\t    g+=e+1e-4;\n\t    c+=mix(vec3(1),H(log(s)*.9),.5)*.04/exp(i*i*e);\n\t}\n\tc*=c;\n  O=vec4(c,1);\n}", "image_inputs": [], "sound_code": "#define fmod(x,y) mod(floor(x),y)\n//#define fmod(x,y) mod(floor(x+floor(x/5.)),y)\n\nvec2 mainSound(int samp, float t){\n  \n  float s1 =\n      5.,\n\n  s2 = 7.,\n      //time/(1.+fmod(time,2.))\n  m1 = fmod(t/s1,s1),\n  m4 = fmod(t*s1+s1,s2),\n  m3 =\n      fmod((t+m4)*s1/(m1+.5),s2)\n      //fmod((t+m1)/(m4+.5),s2)\n  ,\n  a= .2,\n  nb = pow(2.,(m3+m1)/5.+7.5);\n\n  return 128.*abs(.75-vec2(fract(t*nb*.998/2.)\n   ,fract(t*nb)))*a/2.;\n\n}\n\n/*\n#define fmod(x,y) mod(floor(x),y)\n\nvec2 mainSound(int samp, float time){\n  \n  float s1 =\n      4.,\n  t=time,\n  m1 = fmod(t/s1,s1),\n  m4 = fmod(t*s1,s1),\n  m3 =\n      fmod((t+m4)*s1/(m1+.5),s1),\n\n  a=sqrt((1.-sqrt(fract(m1))))*.2,\n\n  nb = pow(2.,(m3+m1)/5.+8.5-m4/2.);\n\n  return vec2(fract(time*nb*.998/2.)*a\n   ,fract(time*nb)*a)/2.;\n\n}\n*/\n\n/*\nvec2 mainSound(int samp, float t){\n  \n  float s1 =\n      3.,\n\n  s2 = 3.,\n  m1 = fmod(t*s1+s1,s2),\n  m4 = fmod(t/s1+s1,s1),\n  m3 =\n      fmod((t+m4)*s1/(m1+.5),s2),\n\n  a=sqrt((1.-sqrt(fract(m1))))*.2,\n\n  nb = pow(2.,(m3+m1)/5.+8.-m4/2.);\n\n  return vec2(fract(t*nb*.998/2.)*a\n   ,fract(t*nb)*a)/2.;\n\n}\n*/", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKBDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 145, 145, 631]], "test": "untested"}
{"id": "7tKBDm", "name": "Dynamic Editable Terrain 2", "author": "fenix", "description": "A new look for Dynamic Editable Terrain. Sky still from xor's Nimbostratus: https://www.shadertoy.com/view/Xl\n*mouse to lower terrain*\n*(0-9) + mouse to raise terrain to that height*\n*WASD/QE/RF to fly*\n*space to reset*", "tags": ["terrain", "automata", "cellular", "tiltshift", "ising", "annealing", "atomaton"], "likes": 18, "viewed": 310, "published": 3, "date": "1665192077", "time_retrieved": "2024-07-30T16:27:31.786825", "image_code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// A new look for Dynamic Editable Terrain https://www.shadertoy.com/view/NlyBWm\n//\n// I was trying to move away from the 8-bit/minecraft look of the first Dynamic Editable\n// terrain. My hope was to approach photoreal, and I'm not sure how close I got but I\n// think the result is pretty interesting anyway.\n//\n// I'm pretty new at trying to achieve realistic images, so I struggled quite a lot with\n// the noise and I'm just barely satisfied with the results. All suggestions are welcome!\n//\n// Changes since Dynamic Editable Terrain 1.0:\n// \n//  * Automaton fiddled to avoid flat-topped areas\n//  * Sand no longer appears on steep cliffsides\n//  * Snow layer for the tallest mountains\n//  * Tree line above which vegetation becomes sparse\n//  * Minecraft-eque pixel splotches removed. replaced with noise\n//  * Rendering sea floor\n//  * Noise added to color and SDF to try to create more natural-looking surfaces\n//  * Noise-based water reflection animation\n//  * Keyboard camera control\n//  * Camera collision\n//  * Motion blur\n//  * Trees!\n//\n// Buffer A computes the terrain\n// Buffer B renders with ray march\n// Buffer C renders xor's Nimbostratus for the sky: https://www.shadertoy.com/view/Xl\n// Image applies tilt-shift lens effect and motion blur\n//\n// --------------------------------------------------------------------------------------------\n\n\n// based on gaussian blur from FabriceNeyret2's smart gaussian blur: https://www.shadertoy.com/view/WtKfD3\n// Added: tilt-shift lens, motion blur\n\nint           N =  13;                              // target sampling rate\nfloat         w,                                   // filter width\n              z;                                        // LOD MIPmap level to use for integration \n#define init  z = ceil(max(0.,log2(w*R.y/float(N))));   // N/w = res/2^z\n#define R     iResolution.xy\n\n\nvec4 convol2D(vec2 U, vec2 o) {                                                     \n    vec4  O = vec4(0.0);  \n    float r = float(N-1)/2., g, t=0.;                                       \n    for( int k=0; k<N*N; k++ ) {                                            \n        vec2 P = vec2(k%N,k/N) / r - 1.;                                    \n        t += g = exp(-2.*dot(P,P) );                                        \n        O += g * textureLod(iChannel0, (U+w*P+o*float(k - N*N/2)/float(N*N)) *R.y/R, z );  \n    }                                                                       \n    return O/t;                                                             \n}      \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float depth = texelFetch(iChannel0, ivec2(u), 0).w;\n    \n    vec4 camera = texelFetch(iChannel1, ivec2(0, 1), 0);\n    vec4 prevCamera = texelFetch(iChannel1, ivec2(0, 2), 0);\n    \n    mat2 r = rot2(camera.w);\n    vec3 localCamera;\n    localCamera.xz = r * camera.xz;\n    localCamera.y = abs(camera.y);\n    vec3 localPrevCamera;\n    localPrevCamera.xz = r * prevCamera.xz;\n    localPrevCamera.y = abs(prevCamera.y);\n\n    vec2 motionBlur = 3.*(localCamera.xy - localPrevCamera.xy) / depth\n        - 4.*(localCamera.z - localPrevCamera.z) * (u - iResolution.xy * vec2(0.5, 0.9)) / (depth * iResolution.y)\n        + 5. * (camera.w - prevCamera.w) * depth * vec2(0.1, 0.0);\n    \n    // Blur based on depth, the farther from the depth of the center pixel, the more blur,\n    // to create a tilt-shift lens effect.\n    float centerDepth = texelFetch(iChannel0, ivec2(iResolution.xy*vec2(0.5, 0.4) / pow(2., 6.)), 6).w;\n    w = (abs(depth-centerDepth)) * 0.04 - 0.000;// + 1.5/iResolution.y;\n    \n    if (w > 0.0)\n    {\n        init\n        vec2 p = (u - iResolution.xy * 0.5) / iResolution.y;\n        {\n            vec2 U = u / R.y;  \n            O = convol2D(U, motionBlur);\n        }\n    }\n    else\n    {\n        O = texture(iChannel0, u/iResolution.xy);\n        //O = vec4(1,0,0,1);\n    }\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// --------------------------------------------------------------------------------------------\n// Computes the terrain height by attempting to match nearby pixels when near the camera.\n// This buffer is set up for wrapping, and hopefully there are no visible artifacts when\n// the camera wraps around.\n//\n// The celllar automaton happens in the r channel, but the g b and a channels are used\n// to compute a blurred gradient of the r channel, which ends up in a. This is used for\n// tree placement.\n// --------------------------------------------------------------------------------------------\n\nconst int MAX_DIRECTIONS = 64;\n\nfloat melt(vec3 h)\n{\n    return floor((h.x + 0.7*pow(h.y, 0.2))*(float(MAX_DIRECTIONS))* 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n\n    vec3 h = hash(uvec3(ifc.y, ifc.x, iFrame + int(iDate.w)));\n    \n    fragColor = texelFetch(iChannel0, ifc, 0);\n    vec4 state = texelFetch(iChannel2, ivec2(0), 0);\n\n    float directions = float(MAX_DIRECTIONS);\n    \n    if (iFrame == 0 || state.z < 0.)\n    {\n        fragColor.x = melt(h);\n        fragColor.yzw = vec3(0);\n    }\n    else\n    {\n        float time = float(iTime);\n        vec2 mouse = iMouse.xy;\n\n        // Apply heat everywhere but a circle around the camera position\n        vec4 camera = texelFetch(iChannel2, ivec2(0, 1), 0);\n        vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n        fxCalcCamera(camera, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n        \n        vec2 p = mod(cameraPos.xz * iResolution.y * 0.1, iResolution.xy);\n\n        float TEMP_SCALE = 3.0 / iResolution.y;\n        float t = distance(p, fragCoord)*TEMP_SCALE;\n        \n        // Copy the circle multiple times to handle wraparound conditions\n        t = min(t, distance(p + iResolution.xy*vec2(1, 0), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(0, 1), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(-1, 0), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(0, -1), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(1, 1), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(-1, -1), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(-1, 1), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(1, -1), fragCoord)*TEMP_SCALE);\n        \n        // Handle mouse input\n        if (iMouse.z > 0. && iMouse.w < 0. && state.xy != vec2(0))\n        {\n            vec3 fromLookAt, fromPos, fromFwd, fromLeft, fromUp;\n            fxCalcCamera(camera, fromLookAt, fromPos, fromFwd, fromLeft, fromUp);\n\n        \tvec3 rayFrom = fxCalcRay(state.xy, iResolution, fromFwd, fromUp, fromLeft);\n        \tvec3 rayTo = fxCalcRay(iMouse.xy, iResolution, cameraFwd, cameraUp, cameraLeft);\n            float fromT = (cameraPos.y - WATER_HEIGHT) / rayFrom.y;\n            vec3 fromHit = cameraPos - fromT * rayFrom;\n            vec2 projFrom = mod(fromHit.xz * iResolution.y * 0.1, iResolution.xy);\n            float toT = (cameraPos.y - WATER_HEIGHT) / rayTo.y;\n            vec3 toHit = cameraPos - toT * rayTo;\n            vec2 projTo = mod(toHit.xz * iResolution.y * 0.1, iResolution.xy);\n            \n            if (distance(projFrom, projTo) < iResolution.y * 0.3)\n            {\n                float dist = linePointDist2(projFrom, projTo, fragCoord);\n\n                float targetHeight = 0.;\n                for (int i = 1; i <= 9; ++i)\n                {\n                    if (keyDown(KEY_0 + i))\n                    {\n                        targetHeight = float(i)*2. + 30.;\n                    }\n                }\n\n                if (dist < iResolution.y*0.25)\n                {\n                    if (fragColor.r > targetHeight)\n                    {\n                        fragColor.r -= 0.01 * iResolution.y / (dist + 3.0);\n                    }\n                    else if (fragColor.r < targetHeight)\n                    {\n                        fragColor.r +=  0.01 * iResolution.y / (dist + 3.0);\n                    }\n                }\n            }\n        }\n        fragColor.r = clamp(fragColor.r, 0., float(MAX_DIRECTIONS));\n    \n        float annealChance = mix(0.08, 0.5, smoothstep(1200., 3000., iResolution.y));\n        if (state.w < 5.) annealChance *= 10.;\n        if (t > 1.1 + 0.9 * h.z)\n        {\n            // Melting temp\n            fragColor.x = melt(h);            \n        }\n        else if (h.y < annealChance)\n        {\n            // Count how many neighbors in range have each possible direction\n            int counts[MAX_DIRECTIONS];\n            for (int i = 0; i < int(directions); ++i)\n            {\n                counts[i] = 0;\n            }\n\n            const int RANGE = 2;\n            for (int x = -RANGE; x <= RANGE; ++x)\n            {\n                for (int y = -RANGE; y <= RANGE; ++y)\n                {\n                    ivec2 ni = ifc + ivec2(x, y);\n                    if (ni == ivec2(0)) continue; // Ignore state pixel\n                    vec4 n = texture(iChannel0, (vec2(ni) + 0.5) / iResolution.xy);\n                    counts[int(n.x)]++;\n                }\n            }\n\n            // Find the direction most popular among neighbors\n            int bestCount = -1;\n            int bestDir;\n            bool unique;\n\n            for (int d = 0; d < int(directions); ++d)\n            {\n                if (counts[d] > bestCount)\n                {\n                    bestCount = counts[d];\n                    bestDir = d;\n                    unique = true;\n                }\n                else if (counts[d] == bestCount)\n                {\n                    unique = false;\n                }\n            }\n\n            if (unique)\n            {\n                fragColor.x = float(bestDir) + 2.0*sign(fragColor.x - float(bestDir));\n            }\n        }\n        \n        // g computes a gradient of r\n        ivec2 delta = ivec2(1, 0);\n        fragColor.g = abs(texelFetch(iChannel0, ifc + delta.xy, 0).r - texelFetch(iChannel0, ifc - delta.xy, 0).r) +\n            abs(texelFetch(iChannel0, ifc + delta.yx, 0).r - texelFetch(iChannel0, ifc - delta.yx, 0).r);\n        \n        vec2 blurs = vec2(0);\n        const int BLUR_SIZE = 3;\n        for (int x = -BLUR_SIZE; x <= BLUR_SIZE; ++x)\n        {\n            for (int y = -BLUR_SIZE; y <= BLUR_SIZE; ++y)\n            {\n                blurs += texelFetch(iChannel0, ifc + ivec2(x, y), 0).gb / (1. + length(vec2(x, y)));\n            }\n        }\n        \n        // b and a contain blurs of g\n        fragColor.ba = 2.*blurs / float((BLUR_SIZE + BLUR_SIZE + 1) * (BLUR_SIZE + BLUR_SIZE + 1));\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float LAYER_HEIGHT = 0.002;\n\nconst float WATER_HEIGHT = 63.*LAYER_HEIGHT;\nconst float BEACH_HEIGHT = 66.*LAYER_HEIGHT;\nconst float TREELINE_HEIGHT = 70.*LAYER_HEIGHT;\nconst float SNOW_HEIGHT = 80.*LAYER_HEIGHT;\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nmat2 rot2(float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat square(float x)\n{\n    return x * x;\n}\n\nconst float PI = 3.141592653589793;\n\nvoid fxCalcCamera(in vec4 camState, out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraPos = camState.xyz;\n    cameraPos.y = abs(cameraPos.y);\n    cameraLookAt = cameraPos + vec3(sin(camState.w), -0.1  - 1.0 * cameraPos.y, cos(camState.w));\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd)) * 0.5;\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 1.0 - 0.5;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    vec2 closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    return dot(closestDelta, closestDelta);\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_0 48\n\n#define KEY_W 87\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_R 82\n#define KEY_F 70\n#define KEY_Q 81\n#define KEY_E 69", "buffer_b_code": "// --------------------------------------------------------------------------------------------\n// Render the scene via ray marching, with shadows and water reflections.\n// --------------------------------------------------------------------------------------------\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\n// Create infinite copies of an object -  https://iquilezles.org/articles/distfunctions\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nconst float TREE_REP = 0.004;\n\nvoid doTree(in vec3 p, float splotchesGrass, float t, inout float d, inout int mat)\n{\n    vec2 closest = opRep(p.xz, TREE_REP);\n    vec3 hsh = hash(uvec3(abs(trunc((p.xzz - 0.0015) / 0.003))));\n\n    float treeH = (textureLod(iChannel0, (p.xz - closest)*0.1, 0.).x + textureLod(iChannel0, (p.xz - closest)*0.1, 1.).x) * LAYER_HEIGHT;\n    if (treeH > BEACH_HEIGHT && treeH < TREELINE_HEIGHT)\n    {\n        vec3 tree = vec3(closest.x, p.y, closest.y);\n        float TREE_RAND = 0.015;\n        vec3 tree2 = tree * vec3(4. + 0.*hsh.z, 1., 2.) - vec3((hsh.y - 0.5)* TREE_RAND, treeH + 0.002, (hsh.z - 0.5) * TREE_RAND);\n        float treeSize = 0.002 * (1. - smoothstep(0.8, 0.9, t));\n        float dSphere = sdSphere(tree2, treeSize);\n        if (dSphere < d)\n        {\n            d = dSphere;\n            mat = 1;\n        }\n    }\n}\n\nfloat scene(vec3 p, float t, out int mat)\n{\n    mat = 0;\n    p.x *= iResolution.y/iResolution.x;\n    \n    vec2 hz = textureLod(iChannel0, p.xz*0.1, 1.).xw * 2.; // use mip to smooth terrain\n    float height = p.y - max(0.,hz.x)*LAYER_HEIGHT;\n    float d = min(height, p.y + .05);\n    if (d < .04)\n    {\n        hz = hz * .5 + textureLod(iChannel0, p.xz*0.1, 0.).xw; // only do high-rez fetch if we're close\n        height = p.y - max(0.,hz.x)*LAYER_HEIGHT;\n        d = min(height, p.y + .05);\n        \n        float lodLow = 1. - smoothstep(0.5, 1.4, t);\n        if (lodLow > 0. && d < 0.005)\n        {\n            float smoothToBeach = 1.6 + smoothstep(BEACH_HEIGHT, 1.15 * BEACH_HEIGHT, p.y) - smoothstep(0.97*WATER_HEIGHT, WATER_HEIGHT, p.y);\n            float rockBump = textureLod(iChannel2, p.xz, 0.).r - 0.5;\n\n            height -= rockBump * rockBump * 0.01 * lodLow * smoothToBeach;\n\n            // rock high lod\n            if (!((p.y < BEACH_HEIGHT && p.y > WATER_HEIGHT) || p.y >= SNOW_HEIGHT))\n            {\n                height -= (textureLod(iChannel2, p.xz*40., 3.).r - 0.5)*0.01 * max(0., lodLow - 0.3) * smoothToBeach;\n            }\n\n            float lodHigh = 1. - smoothstep(0.4, 0.8, t);\n            if (lodHigh > 0.)\n            {\n                // snow/sand roughness\n                height -= (textureLod(iChannel2, p.xz*20.0, 0.).r - 0.5) * 0.0007 * lodHigh;\n            }\n\n            d = min(height, p.y + .05);\n\n            if (hz.y < 7.8)\n            {\n                float splotchesGrass = 0. + 0.8 * texture(iChannel2, p.xz*1.0).r * lodLow;//(hGrass.x * 0.5 + 0.5); // Use x,z splotch pattern for grass, to fix rendering artifact\n                doTree(p, splotchesGrass, t, d, mat);\n            }\n        }\n    }\n    \n    return d;\n}\n\nvec3 grad(vec3 p, float t, float d)\n{\n    vec2 delta = vec2(d, 0);\n    int mat;\n    return normalize(\n           vec3(scene(p + delta.xyy, t, mat) - scene(p - delta.xyy, t, mat),\n                scene(p + delta.yxy, t, mat) - scene(p - delta.yxy, t, mat),\n                scene(p + delta.yyx, t, mat) - scene(p - delta.yyx, t, mat)));\n}\n\nconst float MAX_T = 6.0;\nconst float SDF_EPSILON = 0.0005;\nvec3 rayMarch(vec3 pos, vec3 dir, out float t, out int mat)\n{\n    t = 0.;\n    mat = 0;\n    for (int i = 0; i < 250; ++i)\n    {\n        float d = scene(pos, t, mat);\n        \n        if (d < SDF_EPSILON || t > MAX_T)\n        {\n            break;\n        }\n        \n        float slowdown = max(d * 1., 0.1);\n        t += d * slowdown;\n\n        pos += dir * d * slowdown;\n    }\n \n    return pos;\n}\n\nconst vec3 lightDir = normalize(vec3(0, 0.4, 1));\n\nvec3 getColor(vec3 hitPos, vec3 normal, float t, int mat)\n{\n    if (mat == 1) return vec3(0.15, 0.3, 0);\n    vec3 color;\n    if (hitPos.y < WATER_HEIGHT - 0.000)\n    {\n        color = vec3(0.3, 0.5, 0.1);\n    }\n    else\n    {\n        float lodSplotches = 1. - smoothstep(0.25, 0.5, t);\n        float splotches = mix(1., 0.3 + 0.5 * texture(iChannel2, hitPos.xz*20.).r + 0.5 * texture(iChannel2, hitPos.xz*40.).r, lodSplotches);//(h.x * 0.5 + 0.5);\n        float spec = pow(max(0., dot(normal, lightDir)), 10.);\n        color = vec3(0.9, 0.9, 0.8) * splotches + spec * .5;\n        float upness = dot(normal, vec3(0, 1, 0));\n        if (upness > 0.5)\n        {\n            float splotchesGrass = 0.1 + 0.9 * texture(iChannel2, hitPos.xz*8.0).r;//(hGrass.x * 0.5 + 0.5); // Use x,z splotch pattern for grass, to fix rendering artifact\n            float splotchesGrass2 = 0.3 + 0.7 * texture(iChannel2, hitPos.xz*2.0).r;//(hGrass.x * 0.5 + 0.5); // Use x,z splotch pattern for grass, to fix rendering artifact\n            vec3 grassColor = mix(vec3(0.0, 0.2, 0.), vec3(0.6, 0.5, 0.), square(splotchesGrass2));\n            if (hitPos.y < TREELINE_HEIGHT + (splotchesGrass - 0.5)*0.03) color = mix(color, grassColor * splotches * (splotches + .1), smoothstep(0.5, 0.8, upness));\n            float lodSnow = 1. - smoothstep(0.1, .8, t);\n            if (hitPos.y > SNOW_HEIGHT + lodSnow * (splotchesGrass - 0.5)* 0.01) color = vec3(2) + spec;\n        }\n        if (hitPos.y <= BEACH_HEIGHT - 0.001*splotches) color = mix(color, vec3(1.1, 1.0, 0.7) * splotches, smoothstep(0.8, 0.95, upness));\n    }\n    return color;\n}\n\nvec4 render(vec3 cameraPos, vec3 rayDir, bool doShadow, out vec3 hitPos, out vec3 normal)\n{\n    float t; int mat;\n    hitPos = rayMarch(cameraPos, rayDir, t, mat);\n\n    normal = grad(hitPos, t, 0.001);\n    vec3 offsetPos = hitPos + normal*SDF_EPSILON;\n\n    // Compute color\n    vec3 color = getColor(hitPos, normal, t, mat);\n    \n    // Apply light and shadow\n    const float AMBIENT = 0.2;\n\n    float shadowT = MAX_T;\n    vec3 reflectedColor = vec3(0);\n    \n    if (doShadow)\n    {\n        rayMarch(offsetPos, lightDir, shadowT, mat);\n    }    \n    \n    if (shadowT < MAX_T)\n    {\n        color = color * AMBIENT;\n    }\n    else\n    {\n        float dp = max(0., dot(normal, lightDir));\n        color = color * (dp*0.5 + AMBIENT);\n    }\n    \n    // Fade at distance\n    if (t >= 0.0)\n    {\n        vec3 sky = texture(iChannel1, rayDir.xy * 0.6 + 0.5).xyz;\n        color = mix(color, sky, smoothstep(0.0, MAX_T*.7, t));\n    }\n    \n    return vec4(color + reflectedColor, t);\n}\n\nvoid aaImage( out vec4 fragColor, vec2 fragCoord )\n{   \n    vec4 oldColor = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    float time = float(iTime);\n    vec2 mouse = iMouse.xy;\n\n    vec4 camera = texelFetch(iChannel1, ivec2(0, 1), 0);\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(camera, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n\tvec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n    \n    vec3 hitPos, normal;\n    vec4 colorT = render(cameraPos, rayDir, true, hitPos, normal);\n\n    // Handle reflections\n    if (hitPos.y <= WATER_HEIGHT)\n    {\n        float waterDepth = WATER_HEIGHT - hitPos.y;\n        float correctT = waterDepth / rayDir.y;\n        hitPos += correctT * rayDir;\n        const float WATER_BUMP_RATE = 0.7;\n        float waterBumpR, waterBumpT = modf(iTime * WATER_BUMP_RATE, waterBumpR);\n        vec3 waterBump = mix(texture(iChannel2, hitPos.xz*0.5 + waterBumpR*0.1).rgb,\n                                   texture(iChannel2, hitPos.xz*0.5 + (waterBumpR + 1.) * 0.1).rgb, waterBumpT);\n\n        vec3 reflectRayDir = normalize(rayDir * vec3(1,-1,1) + waterBump * 0.5);\n        \n        vec3 reflectHitPos, reflectNormal;\n        vec4 reflectColorT = render(hitPos, reflectRayDir, false, reflectHitPos, reflectNormal);\n        \n        colorT.xyz = colorT.xyz / max(vec3(1), waterDepth*vec3(800., 800., 300.));\n        \n        float shadowT; int mat;\n        rayMarch(hitPos, lightDir, shadowT, mat);\n        if (shadowT >= MAX_T)\n        {\n            float dp = max(0., dot(reflectRayDir, lightDir));\n            reflectColorT.rgb += pow(dp, 12.) * 0.;\n        }\n        \n        colorT.rgb = mix(colorT.rgb, reflectColorT.rgb * 1.6, 0.2);\n    }\n    \n    fragColor = mix(oldColor, colorT, 0.9);\n    \n#if 0 // Debug terrain texture\n    //fragColor = sin(texelFetch(iChannel0, ivec2(fragCoord), 0).r + vec4(2, 3, 4, 5));\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0).aaaa * .3;\n    fragColor.w = 0.;\n#endif\n}\n\n#define AA 1\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{   \n#if AA < 2\n    aaImage(fragColor, fragCoord);\n#else\n    vec4 accum = vec4(0);\n    for (int x = 0; x < AA; ++x)\n    {\n        for (int y = 0; y < AA; ++y)\n        {\n            vec2 aaCoord = fragCoord + vec2(float(x),float(y)) / float(AA) - 0.5;\n            vec4 aaColor;\n            aaImage(aaColor, aaCoord);\n            accum += aaColor;\n        }\n    }\n    fragColor = accum * 1. / float(AA * AA);\n#endif\n}", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// --------------------------------------------------------------------------------------------\n// Render sky and maintain persistent state.\n// --------------------------------------------------------------------------------------------\n\nvoid updateState(inout vec4 state)\n{\n    if (iFrame == 0)\n    {\n        state = vec4(0, 0, 0, 1);\n    }\n    else\n    {\n        state.xy = iMouse.xy;\n        \n        if (keyClick(KEY_SPACE) || abs(state.z) != iResolution.x * iResolution.y)\n        {\n            state.z = -iResolution.x * iResolution.y;\n            \n            state.w = 1.;\n        }\n        else\n        {\n            state.z = abs(state.z);\n        }\n        \n        if (state.w == 0.) state.w = 1.;\n        state.w += sign(state.w);\n    }\n}\n\nvoid updateCamera(inout vec4 camera, in vec4 state)\n{\n    if (iFrame == 0 || state.z < 0.)\n    {\n        camera = vec4(0, -0.2, 0, 0);\n    }\n    else\n    {\n        const float MOVE_SPEED = 0.002;\n        vec3 camMove = vec3(0);\n        if (keyDown(KEY_W))\n        {\n            camMove.z += MOVE_SPEED;\n            camera.y = abs(camera.y);\n        }\n        if (keyDown(KEY_S))\n        {\n            camMove.z -= MOVE_SPEED;\n            camera.y = abs(camera.y);\n        }\n        if (keyDown(KEY_A))\n        {\n            camMove.x += MOVE_SPEED;\n            camera.y = abs(camera.y);\n        }\n        if (keyDown(KEY_D))\n        {\n            camMove.x -= MOVE_SPEED;\n            camera.y = abs(camera.y);\n        }\n        if (keyDown(KEY_R))\n        {\n            camMove.y += MOVE_SPEED;\n            camera.y = abs(camera.y);\n        }\n        if (keyDown(KEY_F))\n        {\n            camMove.y -= MOVE_SPEED;\n            camera.y = abs(camera.y);\n        }\n        \n        if (camera.y < 0.)\n        {\n            camMove.z += MOVE_SPEED;\n            camMove.y -= 0.001*sin(state.w*0.008) - 0.00001;\n            camera.w -= 0.002*sin(state.w*0.005);\n        }\n        \n        const float TURN_RATE = 0.02;\n        if (keyDown(KEY_Q))\n        {\n            camera.w += TURN_RATE;\n            camera.y = abs(camera.y);\n        }\n        if (keyDown(KEY_E))\n        {\n            camera.w -= TURN_RATE;\n            camera.y = abs(camera.y);\n        }\n        \n        camMove.xz *= rot2(camera.w);\n        camera.xyz += camMove;\n        \n        vec2 pos1 = (camera.xz + 2.*vec2(sin(camera.w), cos(camera.w))) * iResolution.xz * 0.1;\n        float height1 = textureLod(iChannel2, pos1, 15.).r * LAYER_HEIGHT;\n        vec2 pos2 = camera.xz * iResolution.xz * 0.1;\n        float height2 = textureLod(iChannel2, pos2, 15.).r * LAYER_HEIGHT;\n        float height = max(height1, height2);\n        \n        if (abs(camera.y) < height + 0.1)\n        {\n            camera.y = mix((height + 0.1) * sign(camera.y), camera.y, 0.95);\n        }\n        if (abs(camera.y) < height + 0.01)\n        {\n            camera.y = mix((height + 0.01) * sign(camera.y), camera.y, 0.5);\n        }\n        if (abs(camera.y) < height)\n        {\n            camera.y = height * sign(camera.y);\n        }\n        float MAX_HEIGHT = 0.6;\n        camera.y = clamp(camera.y, -MAX_HEIGHT, MAX_HEIGHT);\n    }\n}\n\n// xor's Nimbostratus: https://www.shadertoy.com/view/XlfyD7\nfloat Speed = .001;\nvec3 Light = vec3(.6,.2,.8);\n    \nfloat Map(vec3 Position)\n{\n    vec3 P = (Position*0.5+texture(iChannel0,Position*2.+iTime*Speed*.2).xyz*.02);\n    \n    float C = texture(iChannel0,P).r;\n    C *= texture(iChannel0,P*vec3(.5,1,.5)).g;\n    C = C*.9+.1*pow(texture(iChannel0,P*5.1).a,2.);\n    return max((C-.3)*sqrt((Position.z-.1)/.3),0.)/.5;\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    ivec2 ifc = ivec2(fragCoord);\n    if (ifc == ivec2(0))\n    {\n        fragColor = texelFetch(iChannel1, ifc, 0);\n        updateState(fragColor);\n        return;\n    }\n\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    if (ifc == ivec2(0, 1))\n    {\n        fragColor = texelFetch(iChannel1, ifc, 0);\n        updateCamera(fragColor, state);\n        return;\n    }\n    if (ifc == ivec2(0, 2))\n    {\n        vec4 prevCamera = texelFetch(iChannel1, ivec2(0, 1), 0);\n        fragColor = prevCamera;\n        return;\n    }\n    \n    vec3 R = vec3((fragCoord-.5*iResolution.xy)/iResolution.y,1);\n    vec3 P = vec3(0,iTime*Speed,0);\n    \n    vec4 C = vec4(0);\n    for(float I = .2;I<.5;I+=.01)\n    {\n        float M1 = Map(P+R*I);\n        float M2 = Map(P+R*I+Light*.01);\n        C += vec4((.6+vec3(.6,.5,.4)*(exp(-M2*10.)-M1)),1)*M1*(1.-C.a);\n        if (C.a>.99) break;\n    }\n\tfragColor = C+vec4(vec3(.5,.7,.9)-R.y*.4,1)*(1.-C.a);\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKBDm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2062, 2062, 2093, 2093, 2729]], "test": "untested"}
{"id": "NlKfWy", "name": "Hyperbox", "author": "me_123", "description": "A box with ray marched stuff.", "tags": ["3d", "raytracing", "raymarching", "art"], "likes": 10, "viewed": 257, "published": 3, "date": "1665178652", "time_retrieved": "2024-07-30T16:27:32.979635", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);//vec4(0.0,0.0,1.0,1.0);\n    fragColor /= fragColor.w;\n    fragColor.yxz = 0.01/fragColor.xyz;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int it = 10;\nconst float eps = 0.001;\nfloat boxx( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return 1000.; // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return tN;\n}\nvec3 getRay(in vec3 cameraDir, in vec2 uv) { //get camear ray direction\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;\n\treturn normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n}\nvec3 hash33(vec3 p3)\n{ //by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nfloat noise(in vec3 x) {\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\nvec3 rus(in vec3 seed) {\n    return normalize(hash33(seed)-0.5);\n}\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nvec3 rep(in vec3 p, in float c, in vec3 l) {\n    return p-c*clamp(round(p/c),-l,l);\n}\nfloat sdf(in vec3 z) {\n    z *= 3.;\n    z += vec3(sin(iTime)*2.0, sin(iTime+1.0)*2.0, iTime*10.0);\n    z.x = mod(z.x-4.0, 8.)-4.;\n    z.y = mod(z.y-4.0, 8.)-4.;\n    vec3 p = z;\n    float r = (p.z)*0.1;\n    mat2 rot = mat2(cos(r), -sin(r), sin(r), cos(r));\n    p.xy *= rot;\n    p.z = fract(p.z)-0.5;\n    p.x = abs(p.x)-2.0;\n    float k = max(min(box(abs(p)-vec3(1.1, 0.0, 0.0), vec3(0.1, 1.1, 0.1)),\n                  box(abs(p)-vec3(0.0, 1.0, 0.0), vec3(1.2, 0.1, 0.4))), -(length(p-vec3(-1.0, 0.0, 0.0))-0.2));\n    return k*0.6*0.33333;//min(max(abs(p.x)+1.0, abs(p.y)+1.0), k);\n}\nvec3 normal( vec3 p)\n{\n    const float h = eps;\n    const vec2 k = vec2(1,-1);\n    return normalize(k.xyy * sdf(p + k.xyy * h) +\n                     k.yyx * sdf(p + k.yyx * h) +\n                     k.yxy * sdf(p + k.yxy * h) +\n                     k.xxx * sdf(p + k.xxx * h));\n}\nstruct hit {\n    vec3 p;\n    vec3 n;\n    float d;\n    int i;\n};\nhit trace(in vec3 ro, in vec3 rd) {\n\tfloat d0 = 0.0;\n    vec3 p;\n    int i;\n    for (i = 0; i < 100; i += 1) {\n    \tp = ro+rd*d0;\n        float d = sdf(p.xzy);\n        d0 += d;\n        if (d < eps || d0 > 1000.) break;\n    }\n    if (d0 > 1000.) return hit(vec3(-1), vec3(-1), -1., i);\n    return hit(p, normal(p), d0, i);\n}\nvec3 sky(in vec3 rd) {\n    return vec3(1.0, 0.9, 2.0)*vec3(noise(rd*2.0)*noise(rd))*0.1;\n}\nvec3 getColor(in vec3 ro, in vec3 rd) {\n    vec3 t1;\n    float s = ro.z/-rd.z;\n    if (s < 0.0) {s = 1000.;};\n    float b = boxx(ro-vec3(0, 0, 1.5), rd, vec3(1.5), t1);\n    if (b > s) {\n        ro = ro+rd*s;\n        rd = reflect(rd, vec3(0, 0, 1)+0.1*normalize(hash33(ro*100.)-0.5));\n        float b = boxx(ro-vec3(0, 0, 1.5), rd, vec3(1.5), t1);\n        if (b > 100.) return sky(rd);\n        ro = ro+rd*b;\n        hit t = trace(ro, rd);\n        return max(vec3(0),vec3(abs(sin(iTime+t.p.z*0.1))*3.0,abs(sin(iTime*0.5+t.p.z*0.1))*2.0,abs(sin(iTime*0.15))*1.5)/float(t.i+1));//(nt.d>0.0?vec3(0):vec3(abs(nd)));\n    };\n    b = min(b, s);\n    if (b < 1000.) {\n        ro = ro+rd*b;\n        hit t = trace(ro, rd);\n        return max(vec3(0),vec3(abs(sin(iTime+t.p.z*0.1))*3.0,abs(sin(iTime*0.5+t.p.z*0.1))*2.0,abs(sin(iTime*0.15))*1.5)/float(t.i+1));//(nt.d>0.0?vec3(0):vec3(abs(nd)));\n    } else {\n        return sky(rd);\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord+hash33(vec3(fragCoord.xy, iTime)).xy) - 0.5 * iResolution.xy) / iResolution.y;\n    \n    //camera\n    vec2 m = vec2(iTime*0.25, 1.7);\n    if (iMouse.z > 0.0) m = ((iMouse.xy)/iResolution.xy) * vec2(6.28, 3.14159263);\n        \n    vec3 ro = vec3(sin(m.y) * cos(-m.x), sin(m.y) * sin(-m.x), cos(m.y))*7.0;\n    vec3 rd = getRay(-normalize(ro), uv);\n    ro.z += 1.5;\n    vec3 color = getColor(ro, rd);\n    vec4 old = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n\n    //super sample\n    fragColor = vec4(color, 1)*0.25+old*0.75;\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKfWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 213]], "test": "untested"}
{"id": "7tGfWy", "name": "tHe gRiD", "author": "z0rg", "description": "A mix of two of my shaders to create a cyber / tron visual", "tags": ["tron", "retrowave", "cyber"], "likes": 103, "viewed": 4881, "published": 3, "date": "1665173836", "time_retrieved": "2024-07-30T16:27:33.874244", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 rdrImg(vec2 uv)\n{\n    vec3 col = pow(texture(iChannel0, uv).xyz,vec3(1.3));\n    col += pow(texture(iChannel0, uv).xyz,vec3(.9))*.35;\n    return col;\n}\n\nvec3 rdrChroma(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    vec2 off = vec2(.002);\n    col.r = rdrImg(uv+off).r;\n    col.g = rdrImg(uv).g;\n    col.b = rdrImg(uv-off).b;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec3 col = rdrChroma(uv);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define AA // Comment to deactivate antialiasing\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.141592653\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\n// Stolen from 0b5vr here https://www.shadertoy.com/view/ss3SD8\nfloat hash11(float p)\n{\n    return (fract(sin((p)*114.514)*1919.810));\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define FFT(a) (texture(iChannel3, vec2(a, 0.)).x-.25)\n\nvec3 rdrCirc(vec2 uv, float t)\n{\n    vec3 col = vec3(0.);\n    vec2 ouv = uv;\n    float rep = .03;\n    float id = floor((uv.y+rep*.5)/rep);\n    uv.y = mod(uv.y+rep*.5,rep)-rep*.5;\n    uv.x += id;\n    float cl = .1;\n    float h = clamp(asin(sin(uv.x*5.)), -cl, cl)/cl;\n    float line = abs(uv.y-h*0.01)-.001;\n    vec3 rgb = mix(vec3(.4,.3,.7), vec3(.4,.6,.9).zxy, sat(sin(id)));\n    rgb *= 1.-sat((abs(ouv.x+(fract(id*.1)-.5)+mod(t*.75+.5*id,4.)-2.)-.2)*4.);\n    col = mix(col, rgb,1.-sat(line*iResolution.x*.5));\n        col += .5*rgb*(1.-sat(line*80.));\n    return col;\n}\nvec3 rdrCircuit(vec2 uv)\n{\n    vec3 col = rdrCirc(uv, iTime);\n    col += rdrCirc(uv+vec2(0.,.2), iTime*.7);\n    col += .5*rdrCirc(2.*uv+vec2(0.,.1), iTime*.5).zxy;\n    col += .15*rdrCirc(4.*uv+vec2(0.,.1), iTime*.25).yzx;\n    return col;\n}\n\n\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    //acc = _min(acc, vec2(length(p)-2., 0.));\n    float h = .2;\n    acc = _min(acc, vec2(-p.y-.2*clamp(asin(sin(p.z*3.)),-h,h), 0.));\n    return acc;\n}\n\nvec3 getEnv(vec3 rd)\n{\n    rd.xy *= r2d(.5);\n    vec2 uv = vec2(atan(rd.z, rd.x)/PI, (acos(rd.y)/PI-.5)*2.);\n    float gradf = 3.;\n    vec3 up = mix(vec3(0.161,0.055,0.239),vec3(0.639,0.059,0.341), sat(uv.y*gradf));\n    vec3 low = mix(vec3(0.161,0.055,0.239),vec3(0.157,0.345,0.337), sat(-uv.y*gradf));\n    vec3 back = mix(low, up, float(uv.y > 0. ? low : up));\n\n    float stars = pow(texture(iChannel2, uv*4.).x, 10.);\n    \n    uv.x *= 1.75;\n    float an = iTime*.1+atan(uv.y+.1, uv.x+.1);\n    back += .25*((.35*vec3(0.945,0.220,0.310)*sat(sin(an*12.)+.8))*(1.-sat(length(uv*2.)))+\n    .5*vec3(0.945,0.263,0.216)*sat(sin(-iTime*.05+an*7.+1.)+.7)*(1.-sat(length(uv*1.5)))+\n    .5*vec3(1.000,0.533,0.502)*sat(sin(an*5.)+.5)*(1.-sat(length(uv*1.)))).zxy;\n    \n        float rep = 0.05;\n    vec2 uv2 = uv-vec2(0.,-0.35);\n    uv2 *= 1.5;\n    float id = floor((uv2.x+rep*.5)/rep);\n    uv2.x = mod(uv2.x+rep*.5,rep)-rep*.5;\n    float height = pow(FFT(abs(id*.01)),1.);\n    float shape = max(abs(uv2.y)-height, abs(uv2.x)-0.001);\n    vec3 rgbs = mix(vec3(0.208,0.675,0.431)*0., vec3(0.180+sin(id+iTime)*.5+.5,0.820,0.659+sin(-id+iTime)*.5+.5), sat((abs(uv2.y))*10.));\n    back += rgbs*(1.-sat(shape*400.))*(1.-sat(abs(uv.x*2.)-.5));\n    \n    float psz = .25;\n    uv += vec2(.2,-0.1);\n    uv *= r2d(2.5);\n    float planet = length(uv)-psz;\n    vec3 col = back+stars*vec3(0.580,0.804,0.820)*.5;\n    vec3 planetrgb = vec3(0.161,0.055,0.239)*.75\n    +vec3(0.961,0.000,0.192)*pow(texture(iChannel1,vec2(-iTime*.02,0.)+uv*5.*length(uv)).x,3.)*sat(uv.y*5.);\n    planetrgb += vec3(1.000,0.173,0.078)*(1.-sat((abs(planet)-.001)*50.))*sat(uv.y*5.);\n    col = mix(col, planetrgb, 1.-sat(planet*400.));\n    col += .8*vec3(1.000,0.173,0.078)*(1.-sat((abs(planet)-.01)*10.))*sat(uv.y*5.);\n    col += vec3(1.000,0.314,0.141)*(1.-sat(planet*100.))*.15;\n    \n    col += .25*rgbs*(1.-sat(shape*10.))*(1.-sat(abs(uv.x*2.)-.5))*sat(planet*10.);\n    uv.y *= 3.5-2.*uv.y;\n    float anr = atan(uv.y, uv.x); // ring\n    float ring = abs(length(uv)-.4)-.1;\n    col += sat(uv.y+.15)*(1.-sat(ring*100.))*texture(iChannel2, vec2(length(uv), anr*.01)).xxx;\n    return col;\n}\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = cross(rd, r);\n    return normalize(rd+(r*uv.x+u*uv.y)*4.);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01,0.);\n    return normalize(vec3(d)-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x;\n    }\n    return vec3(-1.);\n}\n\nvec3 getMat(vec3 res, vec3 rd, vec3 p, vec3 n)\n{\n    return vec3(.1);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    \n    float t = 4.68;\n    vec3 ro = vec3(sin(t)*5.,-1.5+sin(iTime*.25)*.2,cos(t)*5.+sin(iTime*.25));\n    vec3 ta = vec3(sin(iTime)*1.,-2.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    float d = 100.;\n    vec3 res = trace(ro, rd, 64);\n    \n    if (res.y > 0.)\n    {\n    d = res.y;\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = getMat(res, rd, p, n);\n        float move = p.x+iTime;\n        float river = (abs(p.z-sin(move*1.)*.5-sin(move*.5)*2.)-1.5);\n        float spec = 1.;//mix(.25,1.,1.-sat(river*400.));\n        float gloss = .05;//mix(.5,.05, 1.-sat(river*400.));\n        vec3 refl = normalize(reflect(rd, n)+gloss*(vec3(rand(), rand(), rand())-.5));\n        vec3 resrefl = trace(p+n*0.01, refl, 32);\n        vec3 reflec = vec3(0.);\n        float gridrep = 1.;\n        vec2 griduv = vec2(move, p.z);\n        griduv = mod(griduv+gridrep*.5,gridrep)-gridrep*.5;\n        float gridth = .001;\n        float grid = min(abs(griduv.x)-gridth, abs(griduv.y)-gridth);\n        //col += sat(river*400.)*vec3(0.220,0.800,0.412)*(1.-sat(grid*40.))*(1.-sat(res.y/10.));\n        col += rdrCircuit(vec2(p.x, p.z)*.1);\n        if (resrefl.y > 0.)\n        {\n            vec3 prefl = p+refl*resrefl.y;\n            vec3 nrefl = getNorm(prefl, resrefl.x);\n\n            reflec=getMat(resrefl, refl, prefl, nrefl);\n        }\n        else\n            reflec=getEnv(refl);\n        col += reflec*spec;\n    }\n    else\n        col = getEnv(rd);\n    col += vec3(0.816,0.541,1.000)*(1.-sat(exp(-d*0.2+.5)))*sat(rd.y*1.+.5);\n    col += .5*vec3(1.000,0.314,0.141)*(1.-sat(exp(-d*0.2+1.5)))*sat(rd.y*3.+.5);\n    \n    col += vec3(0.302,0.698,1.000)*pow(1.-sat(abs((rd.y-.05)*15.)),2.)*(1.-sat(abs(rd.z)));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n    seed=texture(iChannel2,uv).x;\n    seed+=fract(iTime);\n    vec3 col = rdr(uv);\n    vec2 off = vec2(1., -1.)/(iResolution.x*2.);\n    #ifdef AA\n    if (true)// Not so cheap antialiasing\n    {\n        vec3 acc = col;\n        acc += rdr(uv+off.xx);\n        acc += rdr(uv+off.xy);\n        acc += rdr(uv+off.yy);\n        acc += rdr(uv+off.yx);\n        col = acc/5.;\n        \n    }\n    #endif\n    col *= 1.-sat(length(uv*1.5));\n    col = pow(col, vec3(1.2));\n   col *= sat(iTime-1.);\n    col = mix(col, texture(iChannel0, fragCoord.xy/iResolution.xy).xyz,.5);\n       col = pow(col, vec3(1.15));\n    col = sat(col);\n\n    fragColor = vec4(col.zxx,1.0);\n}", "buffer_a_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29929, "src": "https://soundcloud.com/sir-ridley/daft-punk-end-of-line-sir-ridley-remix?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGfWy.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 419, 419, 552], [554, 554, 579, 579, 735], [737, 737, 794, 794, 906]], "test": "untested"}
{"id": "flVfWG", "name": "Living Truchet 2", "author": "rcargou", "description": "hi", "tags": ["tile"], "likes": 3, "viewed": 188, "published": 3, "date": "1665167819", "time_retrieved": "2024-07-30T16:27:34.840660", "image_code": "#define PI 3.1415926535\nfloat hash( vec2 p ) {\n\tfloat h = dot(vec2( p) ,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat quarter_circle(vec2 uv) {\n\n    float size = 0.01;\n    float ret = 0.;\n    float l = length(uv - vec2(1., 1.) ) * .18 / 0.01 * size;\n    ret = smoothstep(.1, .1 - size, l);\n    ret *= smoothstep(.1 - 2. * size, .1 - size, l);\n  \n    return ret;\n\n}\n\nfloat truchet(vec2 uv, float s) {\n    \n    if (s < 0.)\n        uv.x = 1. - uv.x;\n    float ret = quarter_circle(uv);\n    \n    vec2 tmp = uv;\n    \n    uv.x = 1.0 - tmp.y;\n    uv.y = 1.0 - tmp.x;\n    \n    ret += quarter_circle(uv);\n    return ret;\n}\n\nfloat rand_trigger(vec2 uv, vec2 id, float scale) {\n\n    float time = scale * iTime / 2. + hash(id) * 1.;\n    float r = floor(time / PI  / 3.+ .0);// + -.2;\n    float h = hash(vec2(r * vec2( hash(id))) + vec2( hash(id) ));\n    if (h < 0.5)\n        time = r * PI * 3.;//r;// - .2;\n    return min(max(sin(time  ), -0.2 ), 0.2 ) * 5.;\n }\n \n\n \nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nint hashi( vec2 p ) {\n\tfloat h = dot(vec2( p) ,vec2(127.1,311.7));\t\n    float y = 2213123. * fract(sin(h)*43758.5453123);\n    return int(y);\n}\n\nfloat diag(vec2 uv, float si) {\n    float s = .05;\n    return smoothstep(s, 0.0, abs(uv.x * si - uv.y) - s / 2.  );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    uv *= 10.;\n    vec2 id = floor(uv);\n\n    float r = rand_trigger(uv.xy, id, 1.0);\n    uv = fract(uv) - vec2(.5);\n //   r = abs(r);\n    r = min(1.0, r);\n    r = max(-0.0, r);\n    float angle = 3.14 * r / 2.;\n    uv *= rotate2d(angle);\n    int si = hashi(id) % 2 == 0 ? -1 : 1;\n    float t = rand_trigger(vec2(21.), vec2(42.), 1. );\n    float sd = diag(uv, float(si));\n    float ss = truchet(uv + vec2(.5), float(si));\n    vec3 col = vec3( mix(sd, ss, 1.) );\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVfWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 46, 46, 134], [136, 136, 167, 167, 388], [390, 390, 423, 423, 637], [639, 639, 690, 690, 973], [979, 979, 1007, 1007, 1093], [1095, 1095, 1116, 1116, 1237], [1239, 1239, 1270, 1270, 1356], [1358, 1358, 1415, 1415, 1971]], "test": "untested"}
{"id": "ftcBRs", "name": "chromatic dispersion!", "author": "elenzil", "description": "16-tap chromatic dispersion.\nChange #def at the top of common tab for 16-taps.\nReally wants a brawny GPU either way!\n 8-tap version: [url]https://www.shadertoy.com/view/cssGRn[/url]\n16-tap version: [url]https://www.shadertoy.com/view/ftcBRs[/url]\n", "tags": ["refraction", "fresnel", "chromaticdispersion"], "likes": 33, "viewed": 600, "published": 3, "date": "1665160052", "time_retrieved": "2024-07-30T16:27:36.263855", "image_code": "// Chromatic Dispersion.\n//  8-tap version: https://www.shadertoy.com/view/cssGRn\n// 16-tap version: https://www.shadertoy.com/view/ftcBRs\n//\n// The actual work is all in the Common Tab.\n//\n// Here we collect the per-wavelength intensities from each of the buffers,\n// convert the wavelengths to RGB, and add them up.\n// I am not an expert on SRGB, so there are likely some things missing.\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n\n#if SIXTEEN_TAPS\n#define NUM_BANKS 4u\n#else\n#define NUM_BANKS 2u\n#endif\n\n    vec4 colors[NUM_BANKS];\n    \n    colors[0] = texelFetch(iChannel0, ivec2(XY), 0);\n    colors[1] = texelFetch(iChannel1, ivec2(XY), 0);\n#if SIXTEEN_TAPS\n    colors[2] = texelFetch(iChannel2, ivec2(XY), 0);\n    colors[3] = texelFetch(iChannel3, ivec2(XY), 0);\n#endif\n\n    vec3 accum = vec3(0.0);    \n    \n    for (uint bank = 0u; bank < NUM_BANKS; ++bank) {\n        for (uint n = 0u; n < 4u; ++n) {\n            uint index = bank * 4u + n;\n            float wl = famousWavelengths[index];\n            vec3 rgb = spectral_zucconi(wl);\n            accum += colors[bank][n] * rgb;\n        }\n    }\n    \n    accum *= 1.5 / float(NUM_BANKS);\n    \n    RGBA = vec4(accum, 1.0);\n    \n    // gamma\n    RGBA.rgb = pow(RGBA.rgb, vec3(0.5));\n}\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// 0 = 8 taps, 1 = 16 taps.\n#define SIXTEEN_TAPS 1\n\n\n#define MINRES (min(RES.x, RES.y))\n\nconst float pi = 3.14159265359;\nconst vec3  v1 = vec3(1.0);\nconst vec3  v0 = vec3(0.0);\nconst vec3  vX = vec3(1.0, 0.0, 0.0);\nconst vec3  vY = vec3(0.0, 1.0, 0.0);\nconst vec3  vZ = vec3(0.0, 0.0, 1.0);\n\n//--------------------------------------------------------------------------------\n\nstruct ray_t {\n    vec3  ro;\n    vec3  rd;\n    float amt;   // [0, 1] amount of light left in the ray\n    float side;  // -1 = inside, 1 = outside.\n};\n\nstruct hit_t {\n    bool  hit;\n    float t;\n    vec3  pnt;\n    vec3  nrm;\n    uint  mtl;\n};\n\nhit_t newHit() {\n    hit_t ret;\n    ret.hit = false;\n    ret.t   = 1e9;\n    return ret;\n}\n\nstruct mtl_t {\n    float ior;\n    float diffVsTrns; // (0 = diffuse 1 = transparent), modulo reflection\n    \n    // Here is how the light contribution is allocated at a surface collision:\n    // ior                = Cauchy(ior, wavelength)\n    // reflect            = Schlick(ior)  (aka Fresnel)\n    // transmit + diffuse = 1 - reflect\n    // transmit           =      diffVsTrans  * (1 - reflect)\n    // diffuse            = (1 - diffVsTrans) * (1 - reflect)\n};\n\n//--------------------------------------------------------------------------------\n\nconst float ior_air     =  1.0003;\nconst float ior_aerogel =  1.03;\nconst float ior_ice     =  1.309;\nconst float ior_water   =  1.333;\nconst float ior_quartz  =  1.46;\nconst float ior_diamond =  2.42;\nconst float ior_shiny1  =  4.0;    // ad hoc\nconst float ior_mrr     =  1e2;    // ad hoc\n\nconst uint mtl_air   = 0u;\nconst uint mtl_ball1 = 1u;\nconst uint mtl_ball2 = 2u;\nconst uint mtl_floor = 3u;\nconst uint mtl_matte = 4u;\n\nconst mtl_t materials[] = mtl_t[](\n    mtl_t(ior_air    , 1.0),    // 0\n    mtl_t(ior_aerogel, 0.6),    // 1\n    mtl_t(ior_ice    , 1.0),    // 2\n    mtl_t(ior_air    , 0.0),    // 3\n    mtl_t(ior_air    , 0.0)     // 4\n);\n\n//--------------------------------------------------------------------------------\n\nconst float um_from_nm = 0.001;\nconst float famousWavelengths[] = float[] (\n#if SIXTEEN_TAPS\n    680.0,\n    661.0,\n    642.0,\n    624.0,\n    605.0,\n    586.0,\n    568.0,\n    549.0,\n    530.0,\n    512.0,\n    493.0,\n    474.0,\n    456.0,\n    437.0,\n    418.0,\n    400.0\n#else\n    680.0,\n    640.0,\n    600.0,\n    560.0,\n    520.0,\n    480.0,\n    440.0,\n    400.0\n#endif\n);\n\n//--------------------------------------------------------------------------------\n\n// fifo queue.\n// usage:\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENMTATION.\n// This is a basic ringbuffer.\n// NO ERROR CHECKING\n// orion elenzil 2022.\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIES;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nuint QCount() {                                    \\\n    if (gQHead >= gQTail) {                        \\\n        return gQHead - gQTail;                    \\\n    }                                              \\\n    else {                                         \\\n        return gQNumSlots - (gQTail - gQHead);     \\\n    }                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n    return gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n    return QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n    return QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint QEnqueueIndex() {                             \\\n    gQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint QDequeueIndex() {                             \\\n    gQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n    gQ[QEnqueueIndex()] = item;                    \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n    return gQ[QDequeueIndex()];                    \\\n}\n////////////////////////////////////////////////////\n\n\n//--------------------------------------------------------------------------------\n\n// returns false if there are no real roots.\n// returns true if there are one or two real roots.\n// roots.x <= roots.y.\nbool solveQuadratic(in vec3 coeffs, out vec2 roots) {\n    const uint A = 0u;\n    const uint B = 1u;\n    const uint C = 2u;\n    \n    // (-B +- sqrt(BB - 4AC)) / 2A\n    \n    float disc = (coeffs[B] * coeffs[B]) - (4.0 * coeffs[A] * coeffs[C]);\n    \n    if (disc < 0.0) {\n        return false;\n    }\n    \n    float sqrt_disc = sqrt(disc);\n    \n    roots.x = (-coeffs[B] - sqrt_disc) / (2.0 * coeffs[A]);\n    roots.y = (-coeffs[B] + sqrt_disc) / (2.0 * coeffs[A]);\n    \n    if (roots.y < roots.x) {\n        roots.xy = roots.yx;\n    }\n    \n    return true;\n}\n\n//--------------------------------------------------------------------------------\n\nmat3 matLookTo(in vec3 lookFrom, in vec3 lookTo) {\n    vec3 fw = -normalize(lookTo - lookFrom);\n    vec3 rt =  normalize(cross(fw, vY));\n    vec3 up =  cross(rt, fw);\n    \n    return mat3(rt, up, fw);\n}\n\nmat2 matRot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n\n//--------------------------------------------------------------------------------\n\n// https://www.shadertoy.com/view/ls2Bz1\n\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n    vec3 y = vec3(1.,1.,1.) - x * x;\n    y = saturate(y-yoffset);\n    return y;\n}\nvec3 spectral_zucconi (float w)\n{\n    // w: [400, 700]\n    // x: [0,   1]\n    float x = saturate((w - 400.0)/ 300.0);\n\n    const vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n    const vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n    const vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n    return bump3y ( cs * (x - xs), ys);\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float w)\n{\n    // w: [400, 700]\n    // x: [0,   1]\n    float x = saturate((w - 400.0)/ 300.0);\n\n    const vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n    const vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n    const vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n    const vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n    const vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n    const vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n    return\n        bump3y(c1 * (x - x1), y1) +\n        bump3y(c2 * (x - x2), y2) ;\n}\n\n\n//--------------------------------------------------------------------------------\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvoid rayVsPlane(in ray_t ray, in vec3 n, in float d, uint mtl, inout hit_t hit) {\n    float t = -(dot(ray.ro, n) + d) / (dot(ray.rd, n));\n    if (t > 0.0 && t < hit.t) {\n        hit.hit = true;\n        hit.t   = t;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = n;\n    }\n}\n\n//--------------------------------------------------------------------------------\n\nvoid rayVsSphere(in ray_t ray, in vec3 c, float r, uint mtl, inout hit_t hit) {\n    \n    vec3 ro = ray.ro - c;\n    vec3 rd = ray.rd;\n\n    float A = dot(rd, rd);\n    float B = dot(ro, rd) * 2.0;\n    float C = dot(ro, ro) - (r * r);\n    \n    vec2 roots;\n    if (!solveQuadratic(vec3(A, B, C), roots)) {\n        return;\n    }\n    \n    if (roots.y < 0.0) {\n        // both hits are before the start of the ray\n        return;\n    }\n    \n    if (roots.x > 0.0) {\n        if (roots.x > hit.t) {\n            return;\n        }\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.x;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n    \n    if (roots.y < hit.t) {\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.y;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n}\n\n//--------------------------------------------------------------------------------\n\n// https://en.wikipedia.org/wiki/Schlick%27s_approximation\nfloat schlickR0(in float n1, in float n2) {\n    // same if n1 and n2 are swapped.\n    float q  = (n1 - n2) / (n1 + n2);\n    float q2 = q * q;\n    return q2;\n}\n\nfloat schlick(in float R0, in float cosTheta) {\n    float q  = 1.0 - cosTheta;\n    float q5 = q * q * q * q * q;\n    return R0 + ((1.0 - R0) * q5);\n}\n\n// https://en.wikipedia.org/wiki/Cauchy%27s_equation\nfloat cauchyN(in float invWavelengthMicrometersSquared, in float A) {\n    // I can't find a table of Cauchy coefficients,\n    // so just going with something.\n    const float B = 0.01;\n    return A + B * invWavelengthMicrometersSquared;\n}\n\n//---------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------\n\n// Below here is all the code that would go into a \"single tap\" implementation of this.\n// Since we're doing multi-taps and want this exact same code in several buffers,\n// we put it here in ShaderToy's \"common\" tab, which is like an implicit #include.\n\n\nconst float gMinRayAmt =  0.01;     // a ray must have at least this much \"amt\" to be included.\nconst uint  gMaxRays   = 10u;       // maximum number of rays per pixel per wavelength.\nconst float gSurfEps   =  0.001;    // a small distance relative to this scene.\nconst float gZoom      =  1.2;\n\nvec2 RES;\n\nfloat gT;            // time.\nvec3  gSunDir;       // direction to sun.\n\n\n// ringbuffer of rays\n#define Q_TYPE ray_t\n#define Q_MAX_ENTRIES 10u\nQ_IMPLEMENTATION\n\nconst float blankSkyTone = 0.01;\n\nfloat toneSky(in vec3 dir) {\n    float eps = cos(0.05);\n    float q = smoothstep(-.001, 0.0, dot(dir, gSunDir) - eps);\n    // the \"sun\" has brightness > 1.\n    q *= 2e1;\n    q = q * (1.0 - blankSkyTone) + blankSkyTone;\n    return q;\n}\n\nfloat toneChecks(in vec2 p) {\n    const float width2 = 0.06;\n          float width1 = width2 * mix(0.1, 0.9, smoothstep(10.0, 1.0, length(p)));\n    p *= 0.25;\n    float q = 1.0;\n    q *= smoothstep(width1, width2, abs(fract(p.x) - 0.5));\n    q *= smoothstep(width1, width2, abs(fract(p.y) - 0.5));\n    q *= smoothstep(width1, width2, abs(length(p) / 1.5 - 1.0) * 1.5);\n    q  = 1.0 - 0.95 * q;\n    q = mix(q, blankSkyTone, smoothstep(2.0, 10.0, length(p)));\n    return q;\n}\n\nfloat toneMatte(in vec3 nrm) {\n    return max(0.0, dot(nrm, gSunDir));\n}\n\nfloat tone(in hit_t h, in ray_t r) {\n    // using if()'s here because iOS was behaving strangely with switch().\n    if (h.mtl == mtl_air) {\n        return toneSky(r.rd);\n    }\n    if (h.mtl == mtl_floor) {\n        return toneChecks(h.pnt.xz) * toneMatte(h.nrm);\n    }\n    return toneMatte(h.nrm);\n}\n\n// convert a screen-space coordinate to viewport.\nvec2 viewportFromScreen(in vec2 p) {\n    return (p * 2.0 - RES.xy) / MINRES / gZoom;\n}\n\nvec3 gBallPos1;\nvec3 gBallPos2;\nvoid setupScene() {\n    gSunDir = normalize(vec3(0.0, 3.0 + sin(gT * 0.1) * 2.8, -10.0));\n    gSunDir.xz = matRot2(gT * 0.7) * gSunDir.xz;\n    \n    const float bounceHeight = 0.75;\n    \n    float fT1 = fract(gT * 2.00) * 2.0 - 1.0;\n    float fT2 = fract(gT * 2.21) * 2.0 - 1.0;\n    gBallPos1 = vY * (1.0 + bounceHeight - fT1 * fT1 * bounceHeight) - vZ * 1.5;\n    gBallPos2 = vY * (1.0 + bounceHeight - fT2 * fT2 * bounceHeight) + vZ * 1.5;\n}\n\n// given a ray and a running hit,\n// modify the hit to indicate the nearest intersection with the ray.\nvoid rayVsScene(in ray_t r, inout hit_t h) {\n    rayVsPlane (r, vY       , 0.0, mtl_floor, h);\n    rayVsSphere(r, gBallPos1, 1.0, mtl_ball1, h);\n    rayVsSphere(r, gBallPos2, 1.0, mtl_ball2, h);\n}\n\n// Ordinarily this would be 'main()', but it's here in Common for re-use in multiple buffers.\n// Uniforms like resolution, time, mouse are passed in because they're not available in Common.\n//\n// This returns the intensity at this pixel for 4 separate wavelengths ray-traced through the scene.\nvec4 commonMain(in vec2 XY, in float inTime, in vec2 inRes, in vec4 iMouse, in uint wlBank) {\n    RES     = inRes;\n    gT      = inTime * 0.2;\n    vec2 xy = viewportFromScreen(XY);\n    vec2 m  = viewportFromScreen(length(iMouse.xy) < 40.0 ? RES.xy / 2.0 : iMouse.xy);\n    \n    setupScene();\n    \n    // setup camera\n    float theta     = gT - m.x * pi;\n    vec3  lookTo    = vY;\n    vec3  lookFrom  = vec3(cos(theta), 0.4 - m.y, sin(theta)) * 5.0;\n    // don't let camera go below the floor\n    lookFrom.y = max(0.1, lookFrom.y);\n    \n    // ret is the output.\n    vec4 ret = vec4(0.0);\n    \n    // loop over 4 wavelengths\n    for (uint wlSubIndex = 0u; wlSubIndex < 4u; wlSubIndex++) {\n    \n        uint wlIndex = wlBank * 4u + wlSubIndex;\n        \n        float wavelengthUm = um_from_nm * famousWavelengths[wlIndex];\n        float invWavelengthUmSquared = 1.0 / (wavelengthUm * wavelengthUm);\n\n        // intensity for this wavelength.\n        float wlOut = 0.0;\n\n        ray_t r0;\n        r0.ro   = lookFrom;\n        r0.rd   = matLookTo(lookFrom, lookTo) * normalize(vec3(xy, -2.0));\n        r0.amt  = 1.0;\n        r0.side = 1.0;\n        // ^-- cheating a little with side = 1. We're assuming the ray begins outside any object.\n\n        QEnqueue(r0);\n\n        uint rayCount = 0u;\n\n        while (!QIsEmpty()) {\n            rayCount += 1u;\n            ray_t r = QDequeue();\n\n            hit_t h = newHit();\n            h.mtl = mtl_air;    \n            rayVsScene(r, h);\n\n            if (!h.hit) {\n                // no hit\n                wlOut += r.amt * tone(h, r);\n            }\n            else {\n                // a hit!\n                // \"nrm\" here is the hit-facing normal,\n                // while h.nrm is the \"outward\" facing normal.\n                vec3  nrm     = h.nrm * r.side;\n                mtl_t mtl     = materials[h.mtl];\n                float ior     = cauchyN(invWavelengthUmSquared, mtl.ior);\n                float R0      = schlickR0(ior, ior_air);\n                float reflAmt = schlick  (R0, dot(r.rd, -nrm));\n                float trnsAmt = mtl.diffVsTrns * (1.0 - reflAmt);\n                float diffAmt = (1.0 - mtl.diffVsTrns) * (1.0 - reflAmt);\n\n                reflAmt *= r.amt;\n                trnsAmt *= r.amt;\n                diffAmt *= r.amt;\n\n                if (diffAmt > gMinRayAmt) {\n                    // diffuse lighting at surfaces.\n                    // cast a ray for shadows.\n                    ray_t shdRay;\n                    shdRay.ro         = h.pnt + h.nrm * gSurfEps;\n                    shdRay.rd         = gSunDir;\n                    shdRay.amt        = diffAmt;\n                    shdRay.side       = 1.0;\n                    hit_t shdHit      = newHit();\n                    \n                    rayVsScene(shdRay, shdHit);\n                    float lit = 1.0 - float(shdHit.hit);\n                    wlOut += diffAmt * lit * tone(h, r);\n                }\n\n                // moving on to transmission and then reflection.\n\n                if (QSpaceLeft() < 2u)    continue;\n                if (rayCount >= gMaxRays) continue;\n\n                if (trnsAmt > gMinRayAmt) {\n                    float eta = ior_air / ior;\n                    if (r.side < 0.0) {\n                        eta = 1.0 / eta;\n                    }\n                    vec3 trnRayDir = refract(r.rd, nrm, eta);\n                    if (dot(trnRayDir, trnRayDir) < 0.001) {\n                        // total internal reflection.\n                        // this is theoretically impossible for a ray that entered a sphere,\n                        // but keeping it in here anyhow for more exotic scenarios.\n                        reflAmt += trnsAmt;\n                    }\n                    else {\n                        ray_t trnRay;\n                        trnRay.ro   = h.pnt - nrm * gSurfEps;\n                        trnRay.rd   = trnRayDir;\n                        trnRay.side = -r.side;\n                        trnRay.amt  = trnsAmt;\n                        QEnqueue(trnRay);\n                    }\n                }\n\n                if (reflAmt > gMinRayAmt) {\n                    ray_t rflRay;\n                    rflRay.ro   = h.pnt + nrm * gSurfEps;\n                    rflRay.rd   = reflect(r.rd, nrm);\n                    rflRay.side = r.side;\n                    rflRay.amt  = reflAmt;\n                    QEnqueue(rflRay);\n                }\n            }\n        }\n        \n        ret[wlSubIndex] = wlOut;\n    }\n    \n    return ret;\n}\n\n", "buffer_a_code": "const uint wavelengthBank = 0u;\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    RGBA = commonMain(XY, iTime, iResolution.xy, iMouse, wavelengthBank);   \n}\n", "buffer_a_inputs": [], "buffer_b_code": "const uint wavelengthBank = 1u;\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    RGBA = commonMain(XY, iTime, iResolution.xy, iMouse, wavelengthBank);   \n}\n", "buffer_b_inputs": [], "buffer_c_code": "const uint wavelengthBank = 2u;\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n#if SIXTEEN_TAPS\n    RGBA = commonMain(XY, iTime, iResolution.xy, iMouse, wavelengthBank);   \n#else\n    RGBA = vec4(0.0);\n#endif\n}\n", "buffer_c_inputs": [], "buffer_d_code": "const uint wavelengthBank = 3u;\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n#if SIXTEEN_TAPS\n    RGBA = commonMain(XY, iTime, iResolution.xy, iMouse, wavelengthBank);   \n#else\n    RGBA = vec4(0.0);\n#endif\n}\n", "buffer_d_inputs": [], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcBRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[391, 391, 434, 434, 1240]], "test": "untested"}
{"id": "7lGfDy", "name": "Cellular Fractals 2", "author": "MysteryPancake", "description": "I made my own fractal using a 3x3 kernel, inspired by Conway's Game of Life", "tags": ["spiral", "cellular", "pattern", "cell", "buffer", "kernel", "gameoflife"], "likes": 5, "viewed": 195, "published": 3, "date": "1665158613", "time_retrieved": "2024-07-30T16:27:37.250218", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Stored as color, segment length, direction (radians), length until rotation\n    vec4 self = texelFetch(iChannel0, ivec2(fragCoord) / cycleCount, 0);\n    \n    // Colorize based on color, length and direction\n    fragColor = vec4(self.x, self.y * 0.05, self.z * 0.01, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI_2 = 1.57079632679489661923;\nconst int resetAfter = 768;\n#define cycleCount (1 + iFrame / resetAfter)", "buffer_a_code": "float rand(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    if (iFrame % resetAfter == 0) {\n    \n        // Initialize values, stored as color, segment length, direction (radians), length until rotation\n        fragColor = vec4(ivec2(fragCoord) == ivec2(iResolution.xy * 0.5) / cycleCount, 0.0, 0.0, 32.0);\n        \n    } else {\n        \n        // Sample current pixel directly\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        \n        // Sample in a 3 x 3 kernel\n        for (int x = -1; x <= 1; ++x) {\n            for (int y = -1; y <= 1; ++y) {\n            \n                // Ignore self\n                if (x == 0 && y == 0) continue;\n                \n                // Sample neighbour\n                ivec2 pos = ivec2(x, y);\n                vec4 neighbour = texelFetch(iChannel0, ivec2(fragCoord) + pos, 0);\n                \n                // For some reason neighbour.x > 0.0 breaks\n                if (neighbour.x > fragColor.x) {\n                    \n                    // Find where each neighbour wants to move next\n                    ivec2 target = ivec2(round(sin(neighbour.z)), round(cos(neighbour.z)));\n                    \n                    // Neighbour wants to move to us, we have to update ourselves\n                    if (abs(pos.x - target.x) >= 1 && abs(pos.y - target.y) >= 1) {\n                    \n                        fragColor = neighbour; // Transfer properties from neighbour to us\n                        ++fragColor.y; // Increase segment length\n                        \n                        // Rotate when segment length > length until rotation\n                        if (fragColor.y > fragColor.w) {\n                            fragColor.y = 0.0; // New segment, reset segment length\n                            fragColor.w -= float(cycleCount); // Shrink spiral whenever we rotate\n                            fragColor.z += PI_2; // Rotate 90 degrees (PI/2 radians)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGfDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 139, 337]], "test": "untested"}
{"id": "stGfDy", "name": "Cellular Fractals", "author": "MysteryPancake", "description": "I made my own fractal using a 3x3 kernel, inspired by Conway's Game of Life", "tags": ["spiral", "cellular", "pattern", "cell", "buffer", "kernel", "gameoflife"], "likes": 4, "viewed": 164, "published": 3, "date": "1665158114", "time_retrieved": "2024-07-30T16:27:38.146820", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Stored as color, segment length, direction (radians), length until rotation\n    vec4 self = texelFetch(iChannel0, ivec2(fragCoord) / cycleCount, 0);\n    \n    // Colorize based on color, length and direction\n    fragColor = vec4(self.x, self.y * 0.1, self.z * 0.01, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float rand(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    if (iFrame % resetAfter == 0) {\n    \n        // Initialize values, stored as color, segment length, direction (radians), length until rotation\n        fragColor = vec4(ivec2(fragCoord) == ivec2(iResolution.xy * 0.5) / cycleCount, 0.0, 0.0, 32.0);\n        \n    } else {\n        \n        // Sample current pixel directly\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        \n        // Sample in a 3 x 3 kernel\n        for (int x = -1; x <= 1; ++x) {\n            for (int y = -1; y <= 1; ++y) {\n            \n                // Ignore self\n                if (x == 0 && y == 0) continue;\n                \n                // Sample neighbour\n                ivec2 pos = ivec2(x, y);\n                vec4 neighbour = texelFetch(iChannel0, ivec2(fragCoord) + pos, 0);\n                \n                // For some reason neighbour.x > 0.0 breaks\n                if (neighbour.x > fragColor.x) {\n                    \n                    // Find where each neighbour wants to move next\n                    ivec2 target = ivec2(round(sin(neighbour.z)), round(cos(neighbour.z)));\n                    \n                    // Neighbour wants to move to us, we have to update ourselves\n                    if (abs(pos.x - target.x) == 1 && abs(pos.y - target.y) == 1) {\n                    \n                        fragColor = neighbour; // Transfer properties from neighbour to us\n                        ++fragColor.y; // Increase segment length\n                        \n                        // Rotate when segment length > length until rotation\n                        if (fragColor.y > fragColor.w) {\n                            fragColor.y = 0.0; // New segment, reset segment length\n                            fragColor.w -= float(cycleCount); // Shrink spiral whenever we rotate\n                            fragColor.z += PI_2; // Rotate 90 degrees (PI/2 radians)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI_2 = 1.57079632679489661923;\nconst int resetAfter = 768;\n#define cycleCount (1 + iFrame / resetAfter)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGfDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 139, 336]], "test": "untested"}
{"id": "stKBz3", "name": "noise spectrometer", "author": "Artemis152", "description": "trying in recreating https://youtu.be/Nv0aFaqjirg?t=872", "tags": ["noise", "spectrmeter"], "likes": 3, "viewed": 142, "published": 3, "date": "1665154431", "time_retrieved": "2024-07-30T16:27:38.952665", "image_code": "float rand(vec2 n)\n{\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat triangle(float x)\n{\n    return abs(fract(x) - .5) * 2.;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y = uv.y * 2. - 1.;\n\n    // Time varying pixel color\n    vec3 col = vec3(1.);\n    \n    float i = uv.x*180.;\n    \n    float t = texelFetch( iChannel0, ivec2(i,1), 0 ).x;\n    \n    float s = smoothstep(0., 1., triangle(i) + .3);\n    //s *= noise((floor(i+.5)));\n    s *= smoothstep(0.1, .8, noise(vec2(uv.y*20., floor(i+.5)) + rand(t) * 1200.));\n    s *= s;\n    //s *= s;\n    \n    s *= smoothstep(.3, .4, texelFetch( iChannel0, ivec2(i,0), 0 ).x - abs(uv.y));\n    \n    col = vec3(s);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKBz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 89], [92, 92, 112, 112, 150], [152, 152, 173, 173, 263], [265, 265, 286, 286, 484], [486, 486, 511, 511, 554], [556, 556, 613, 663, 1249]], "test": "untested"}
{"id": "stVfzV", "name": "SoundMemory", "author": "ilia87", "description": "analyze sound using textures as memory", "tags": ["sound"], "likes": 1, "viewed": 103, "published": 3, "date": "1665154310", "time_retrieved": "2024-07-30T16:27:39.773472", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //float c0 = texelFetch(iChannel0,ivec2(fragCoord),0).x;\n    //float c1 = texelFetch(iChannel1,ivec2(fragCoord),0).x;\n    //float c2 = texelFetch(iChannel2,ivec2(fragCoord),0).x;\n    //fragColor = vec4(c0,c1,c2,1.);\n    \n    //fragColor = texelFetch(iChannel2,ivec2(fragCoord),0)*10.;\n    //fragColor.x=0.;\n    //fragColor.z=0.;\n    //fragColor.w=1.0;\n    //fragColor *= fragColor;\n    \n    vec4 peakFinder = texelFetch(iChannel3,ivec2(0,fragCoord.y),0);\n    vec2 origTimeFrame = texelFetch(iChannel3,ivec2(1,fragCoord.y),0).xy;\n    fragColor = vec4(0,0,0,1);\n    if (uv.x < 0.2 )\n    {\n        fragColor.y = texelFetch(iChannel1,ivec2(fragCoord),0).x*10.;\n    }\n    else if (uv.x < 0.4)\n    {\n        fragColor.x = texelFetch(iChannel0,ivec2(fragCoord),0).x;\n    }\n    else if (uv.x < 0.5)\n    {\n        fragColor.x = peakFinder.x*10.;\n    }\n    else if (uv.x <0.6)\n    {\n        fragColor.y = peakFinder.y*3.;\n    }\n    else if (uv.x < 0.7)\n    {\n        fragColor.z = mod(peakFinder.z,3.0)/3.0;\n    }\n    else if (uv.x < 0.8)\n    {\n        fragColor.xyz = vec3(3.*peakFinder.y * ThresholdDecay(origTimeFrame.x - peakFinder.z));\n    }\n    else\n    {\n        int ycoord = iFrame % int(iResolution.y);\n        float accumulated = texelFetch(iChannel3,ivec2(0,ycoord),0).w;\n        float circleCenter = fract(accumulated);\n        if ( length(uv - vec2(0.9,circleCenter)) < 0.05)\n        {\n            fragColor.xyz = hsv2rgb(vec3(accumulated,1.,1.));\n        }\n        else\n        {\n            fragColor.xyz = vec3(0.);\n        }\n    }\n    \n    //fragColor.x = texelFetch(iChannel0,ivec2(fragCoord),0).z;\n    //fragColor.x *= fragColor.x;\n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define windowWidth 8\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n\n    int soundBuffLen = textureSize(iChannel1,0).x;\n    \n    float soundBuffTime = float(soundBuffLen) / iSampleRate;\n    int ycoord = iFrame % int(iResolution.y);\n    if (ycoord != int(fragCoord.y))\n        return;\n    if (int(fragCoord.x) >= soundBuffLen )\n        return;\n    int pixelX = int(fragCoord.x);\n    float s  = texelFetch(iChannel1,ivec2(pixelX,0),0).x;\n    float sums = s;\n    float maxs = s;\n    for ( int i=1;i<windowWidth;++i)\n    {\n        float s  = texelFetch(iChannel1,ivec2(pixelX + i, 0),0).x;\n        sums += s;\n        maxs = max(maxs,s);\n    }\n    sums /= float(windowWidth);\n    //vec2 s  = texelFetch(iChannel1,ivec2(int(uv.x * float(soundBuffLen)),1),0).xy;\n    fragColor.x = s;\n    fragColor.y = sums;\n    fragColor.z = maxs;\n    fragColor.w = 1.0;    \n}", "buffer_a_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define soundBuffLen 512\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);    \n    int ycoord = iFrame % int(iResolution.y);\n    if (ycoord != int(fragCoord.y))\n        return;\n    //vec2 uv = fragCoord / iResolution.xy;\n    \n    if (int(fragCoord.x) >= soundBuffLen )\n        return;\n    vec4 xn  = texelFetch(iChannel1,ivec2(int(fragCoord.x), ycoord),0);\n    int prevYCoord = ycoord - 1;\n    if (prevYCoord < 0)\n        prevYCoord += int(iResolution.y);\n    vec4 xnm1  = texelFetch(iChannel1,ivec2(int(fragCoord.x), prevYCoord),0);\n    vec4 ynm1 = texelFetch(iChannel0,ivec2(int(fragCoord.x), prevYCoord),0);\n    float alpha = 0.5;\n    //vec4 yn = alpha*(ynm1 + xn - xnm1);\n    vec4 yn = xn-xnm1;\n    \n    fragColor = yn;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define soundBuffLen 512\n#define windowWidth 512\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);    \n    int ycoord = iFrame % int(iResolution.y);\n    if (ycoord != int(fragCoord.y))\n        return;\n\n    if (int(fragCoord.x) >= soundBuffLen )\n        return;\n    vec4 maxs = vec4(0.);\n    for ( int i=0;i<windowWidth;++i)\n    {\n        vec4 s  = texelFetch(iChannel1,ivec2(int(fragCoord.x) + i, ycoord),0);\n        maxs = max(maxs,s);\n    }\n    //vec2 s  = texelFetch(iChannel1,ivec2(int(uv.x * float(soundBuffLen)),1),0).xy;\n    //float newValue = sums/float(windowWidth);\n    //ivec2 prevCoord = ivec2(fragCoord);\n    //prevCoord.y -= 1;\n    //prevCoord.y = prevCoord.y % int(iResolution.y);\n    //float prevValue = texelFetch(iChannel0,prevCoord,0).x;\n    //fragColor = vec4(newValue * 20./*-prevValue*/,0.,0.,1.);\n    fragColor = maxs;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define windowStart 0\n#define windowEnd 16\n#define COMPONENT x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    if ( int(fragCoord.x) > 1)\n        return;\n    int ycoord = iFrame % int(iResolution.y);\n    if (ycoord != int(fragCoord.y))\n        return;\n    if (int(fragCoord.x) == 1)\n    {\n        fragColor.x = iTime;\n        fragColor.y = float(iFrame);\n        return;\n    }\n    float mx = 0.;\n    for ( int i=windowStart;i<windowEnd ; ++i)\n    {\n        mx = max(mx,texelFetch(iChannel1,ivec2(i, ycoord),0).COMPONENT);\n    }\n    fragColor.x = mx;\n    int prevYCoord = ycoord - 1;\n    if (prevYCoord < 0)\n        prevYCoord += int(iResolution.y);\n    vec4 prevPixel = texelFetch(iChannel0,ivec2(0,prevYCoord),0);\n    float prevPeak = prevPixel.y;\n    float prevPeakTime = prevPixel.z;\n    float threshold = prevPeak * ThresholdDecay(iTime - prevPeakTime);\n    //float t = iTime - prevPeakTime;\n    //t/=2.0;\n    //t *= t*t;\n    //float threshold = prevPeak * (1.-smoothstep(0.,1.0,t));\n    float newPeak = prevPeak;\n    float newPeakTime = prevPeakTime;\n    if (mx > threshold || iFrame<5)\n    {\n        //New peak\n        newPeak = mx;\n        newPeakTime = iTime;\n    }\n    fragColor.y = newPeak;\n    fragColor.z = newPeakTime;    \n    if ( iFrame < 5)\n    {\n        fragColor.w = 0.0;\n    }\n    else\n    {\n        float prevAccumulated = prevPixel.w;\n        float speed = pow(0.1,iTime - prevPeakTime);\n        float peakNormalized = smoothstep(0.,0.05,newPeak);\n        speed *= pow(peakNormalized,4.0);\n        speed += 0.1*pow(peakNormalized,0.5);\n        speed = smoothstep(0.,1.,speed);\n        //intensity *= intensity;\n        fragColor.w = prevAccumulated + iTimeDelta * speed;\n    }\n}\n", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float ThresholdDecay( float t )\n{\n    return pow(0.8,t);\n}\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVfzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1948]], "test": "untested"}
{"id": "stGBWy", "name": "Cellular Spirals", "author": "MysteryPancake", "description": "Drawing spirals using a 3x3 kernel, inspired by Conway's Game of Life", "tags": ["spiral", "cellular", "pattern", "cell", "buffer", "kernel", "gameoflife"], "likes": 6, "viewed": 199, "published": 3, "date": "1665150190", "time_retrieved": "2024-07-30T16:27:40.707972", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Stored as color, segment length, direction (radians), length until rotation\n    vec4 self = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    // Colorize based on length and color\n    fragColor = vec4(self.y * 0.25, self.x, 0.0, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float PI_4 = 0.785398163397448309616;\n\nfloat rand(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    if (iFrame < 1) {\n    \n        // Initialize with noise\n        float noise = rand(fragCoord / iResolution.xy);\n        float noise2 = rand(fragCoord / iResolution.xy * 0.5);\n        \n        // Stored as color, segment length, direction (radians), length until rotation\n        fragColor = vec4(noise > 0.997 ? noise2 : 0.0, 0.0, round(noise2 * 8.0) * PI_4, 16.0);\n        \n    } else {\n        \n        // Sample current pixel directly\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        \n        // Sample in a 3 x 3 kernel\n        for (int x = -1; x <= 1; ++x) {\n            for (int y = -1; y <= 1; ++y) {\n            \n                // Ignore self\n                if (x == 0 && y == 0) continue;\n                \n                // Sample neighbour\n                ivec2 pos = ivec2(x, y);\n                vec4 neighbour = texelFetch(iChannel0, ivec2(fragCoord) + pos, 0);\n                \n                // For some reason neighbour.x > 0.0 breaks\n                if (neighbour.x > fragColor.x || fragColor.w > neighbour.w) {\n                    \n                    // Find where each neighbour wants to move next\n                    ivec2 target = ivec2(round(sin(neighbour.z)), round(cos(neighbour.z)));\n                    \n                    // Neighbour wants to move to us, we have to update ourselves\n                    if (pos.x + target.x == 0 && pos.y + target.y == 0) {\n                    \n                        fragColor = neighbour; // Transfer properties from neighbour to us\n                        ++fragColor.y; // Increase segment length\n                        \n                        // Rotate when segment length > length until rotation\n                        if (fragColor.y > fragColor.w) {\n                            fragColor.y = 0.0; // New segment, reset segment length\n                            fragColor.w -= 0.5; // Shrink spiral whenever we rotate\n                            fragColor.z += PI_4; // Rotate 45 degrees (PI/4 radians)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGBWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 139, 307]], "test": "untested"}
{"id": "slGBWG", "name": "COLORFUL HEX SHADER", "author": "ALESHADER", "description": "Colorful hex shader", "tags": ["color", "hex"], "likes": 1, "viewed": 207, "published": 3, "date": "1665147529", "time_retrieved": "2024-07-30T16:27:41.465946", "image_code": "#define SQRT3 1.73\n\nfloat hexDist(vec2 coord)\n{\n    coord = abs(coord);\n    float d = max(dot(coord, normalize(vec2(SQRT3, 1))), coord.y);\n    return d;\n}\n\nvec4 hexCoord(vec2 coord, float size)\n{\n    coord *= size;\n\n    vec2 r = vec2(SQRT3, 1);\n    vec2 h = r * 0.5;\n    vec2 a = mod(coord, r) - h;\n    vec2 b = mod(coord - h, r) - h;\n    \n    vec2 hx;\n    if (length(a) < length(b)) hx = a;\n    else hx = b;\n    \n    float x = 0.5 - hexDist(hx);\n    float y = atan(hx.y, hx.x);\n    vec2 id = coord - hx;\n    return vec4(x, y, id.x, id.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y) * 2.0;\n    vec3 col1 = 0.5 + 0.5*sin(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float size = sin(iTime * 0.5) * 2.0 + 8.0;\n    vec2 pos = vec2(cos(iTime * 0.3) * 4.0, cos(iTime * 0.3 + 45.0) * 4.0);\n    vec4 cd = hexCoord(uv + pos * 0.1, size);\n    vec3 col = mix(col1, col2, (cd.z + cd.w) / 2.0 / size + 0.5);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGBWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 47, 47, 154], [156, 156, 195, 195, 541], [543, 543, 599, 599, 1073]], "test": "untested"}
{"id": "NtK3RD", "name": "jff", "author": "yurka", "description": "Just for fun", "tags": ["spiral"], "likes": 2, "viewed": 163, "published": 3, "date": "1665134754", "time_retrieved": "2024-07-30T16:27:42.370528", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * 0.5f)/iResolution.x;\n\n    float shag = 40.0f;\n    // Time varying pixel color\n    vec3 col = vec3(\n        0.30 + 0.7*cos(-iTime*30.4 + length(uv)*shag + 0.00000000000 - atan(uv.x, uv.y)), \n        0.30 + 0.7*cos(-iTime*14.5 + length(uv)*shag + 4.18879020479 - atan(uv.x, uv.y)), \n        0.30 + 0.7*cos(-iTime*20.0 + length(uv)*shag + 2.09439510239 - atan(uv.x, uv.y))\n    );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtK3RD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 586]], "test": "untested"}
{"id": "NlGBDy", "name": "Simple color lookup table (LUT)", "author": "Trixelized", "description": "A few simple color lookup table functions;", "tags": ["lut"], "likes": 2, "viewed": 535, "published": 3, "date": "1665134539", "time_retrieved": "2024-07-30T16:27:43.311012", "image_code": "// The 'tile count' in the LUT\n\nconst float LUT_tile_size = 8.0;\n\n\n\n\n// This function converts an UV to the color in the LUT\n\nvec3 LUT_uv_to_col(in vec2 uv)\n{\n    \n    uv = fract(uv);\n    vec2 tile_num = floor(uv * LUT_tile_size) / LUT_tile_size;\n    vec2 tile_uv = fract(uv * LUT_tile_size);\n    \n    return vec3(tile_uv.x, tile_uv.y, (tile_num.x / LUT_tile_size) + (tile_num.y));\n    \n}\n\n\n\n\n// This function converts a color to the UV in the LUT\n\nvec2 LUT_col_to_uv(in vec3 col)\n{\n    col = clamp(col, 0.0, 1.0);\n    vec2 return_uv = vec2(0.0);\n    return_uv.xy += col.rg / LUT_tile_size;\n    return_uv.x += floor(col.b * (LUT_tile_size * LUT_tile_size)) / LUT_tile_size;\n    return_uv.y += floor(col.b * LUT_tile_size) / LUT_tile_size;\n    \n    return vec2(fract(return_uv));\n    \n}\n\n\n\n// Some examples:\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    // ok fine ill fix the distortion\n    float res = (iResolution.x / iResolution.y);\n    uv.x *= res;\n    \n    \n    // example 1; draw a simple LUT texture\n    vec3 col = LUT_uv_to_col(uv);\n    \n    // example; sample from UV (mouse)\n    vec2 mouse_uv = iMouse.xy / iResolution.xy * vec2(res, 1.0);\n    if (length(mouse_uv - uv) < 0.05) {\n        col = LUT_uv_to_col(mouse_uv);\n    }\n    \n    // example; UV from color\n    vec3 sample_col = texture(iChannel0, vec2(0.5)).rgb;\n    vec2 sample_uv = LUT_col_to_uv(sample_col);\n    if (length(sample_uv - uv) < 0.05) {\n        col = sample_col;\n    }\n    \n    fragColor = vec4(col * step(uv.x, 1.0), 1.0);\n    \n}\n\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGBDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 158, 158, 388], [449, 449, 482, 482, 785], [808, 808, 863, 863, 1571]], "test": "untested"}
{"id": "flGfWy", "name": "drunk Sierpinski triangle animat", "author": "FabriceNeyret2", "description": "inspiration:   [url] https://twitter.com/CmonMattTHINK/status/1577340119870316544  [/url]\nuncomment line #19 to get the original shape or #20 for its animated version\n\nAnimated variant of [url]https://shadertoy.com/view/7tGfzd[/url]", "tags": ["sierpinski", "short", "reproduction", "sierpinsky"], "likes": 15, "viewed": 272, "published": 3, "date": "1665129429", "time_retrieved": "2024-07-30T16:27:44.367189", "image_code": "// variant of https://shadertoy.com/view/7tGfzd\n\n#define H(p)        fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define H2(p)       fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define cross(a,b) ( (a).x*(b).y - (a).y*(b).x ) \n  #define R(a)      mat2(cos(a+vec4(0,11,33,0)))       // rotation\n\nfloat line(vec2 p, vec2 a,vec2 b) {                    // --- distance to line\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);    // proj coord on line\n    return length(p - b * h);                          // dist to segment\n}\n#define L(A,B) line(U,A.xy,B.xy)\n\n              // midpoint   jittering\n#define mid(A,B)  (A+B)/2. + vec4( J(A.zw,B.zw), 0,0 )\n//#define k iMouse.y/R.y\n  #define k .2\n//#define J(A,B)  k* ( H((A+B)/2.) -.5 ) *(B-A)                // repro the original\n//#define J(A,B)  k* ( H((A+B)/2.) -.5 ) *(B-A) *sin(iTime)*2. //     animated\n//#define J(A,B)  k* ( H((A+B)/2.) -.5 ) *length(A-B)          // cheap diagonal jittering\n//#define J(A,B)  k* ( H2((A+B)/2.) -.5) *length(A-B)          // full 2D jittering\n  #define J(A,B)  k* ( H2((A+B)/2.) -.5)*R(iTime) *length(A-B) //     animated\n\nvoid mainImage(out vec4 O, vec2 u) {\n     vec2  R = iResolution.xy,\n           U = ( u - .5*R ) /R.y + vec2(.5,.4);  \n     // .xy = jittered version, .zw = non-jiterred, used for coherent seeding\n     vec4  A = vec4(0), B = vec4(1,0,1,0), C = vec4(.5,.87,.5,.87), D,E,F;\n\n     for (int i=0; i < int(log2(R.y))-2; i++ ) {       // --- fractal loop\n         D = mid(A,B), E = mid(A,C), F = mid(B,C);\n         float a = cross(U-F.xy,A-F), b = cross(U-E.xy,B-E), c = cross(U-D.xy,C-D);\n           a > 0. && b < 0. ? A = E, B = F             // fractal recursion: 3 branches\n         : c > 0.           ? A = D, C = F\n         :                  ( B = D, C = E );\n    }  \n    O = vec4( sqrt( smoothstep(1./R.y,0., min(min( L(A,B), L(A,C) ), L(B,C) ) ) )); // draw triangle\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGfWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[324, 324, 359, 402, 575], [1162, 1162, 1198, 1198, 1931]], "test": "untested"}
{"id": "ftyBWy", "name": "Fork Fork Dante hzeff2607 578", "author": "hzeff2607", "description": "Dante's natty vessel - Result of an improvised live coding session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["cute", "waves", "wave", "sea", "demoscene", "water", "ocean", "flag", "moon", "toon", "boat", "pirate", "divine", "dante", "comedy", "tide"], "likes": 4, "viewed": 198, "published": 3, "date": "1665125653", "time_retrieved": "2024-07-30T16:27:45.223898", "image_code": "// Dante's natty vessel - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\n// \"You have to keep busy, after all, no dog ever pissed on a moving car.\" - Tom Waits\n\n// Major thankx to KALI for helping me \"rock the boat\", also thankx to CanadianCornDog, Brandon Stargrave, Neffers and Haptix for the recommendations and jokes\n\nvec2 z,v,e=vec2(.00035,-.00035),f=vec2(-1.7,1.7);float t,tt,b=0.,bb=0.,g=0.,sa;vec3 cp,rp,pp,po,no,al,zp,ld;\nfloat bo(vec3 p,vec3 r){  p=abs(p)-r;  return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nconst mat2 r2fucked=mat2(cos(.023),sin(.023),-cos(.023),sin(.023));\nfloat el( vec3 p, float r,vec3 h ){ vec3 q = p - clamp( p, -h, h ); return length( q )-r;}\nfloat smin(float a,float b,float k){float h=max(k-abs(a-b),0.);return min(a,b)-h*h*.25/k;}\nvec4 texNoise(vec2 uv,sampler2D tex ){ float f = 0.; f+=texture(tex, uv*.125).r*.5; f+=texture(tex,uv*.25).r*.25;\n                       f+=texture(tex,uv*.5).r*.125; f+=texture(tex,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nfloat noi(vec3 p){\n  vec3 f=floor(p),s=vec3(7,157,113);\n  p-=f;vec4 h=vec4(0,s.yz,s.y+s.z)+dot(f,s);\n  p=p*p*(3.-2.*p);\n  h=mix(fract(sin(h)*43785.5),fract(sin(h+s.x)*43785.5),p.x);\n  h.xy=mix(h.xz,h.yw,p.y);\n  return mix(h.x,h.y,p.z);\n}\nfloat wave( vec3 p,int iter,float ga)\n{  \n  vec3 np=p-vec3(0,0,tt*3.); \n  float nois=0.,amp=3.0;\n  for(int i=0;i<iter;i++){\n   nois+=abs(sin(noi((np-vec3(0,0,tt*3.))*.15)-.5)*3.14)*(amp*=.51);   \n   np.xy*=r2fucked;\n   np*=1.75;    \n  }\n  if(ga>0.)cp=np,bb=nois;  \n  float t=p.y+nois;t*=0.5;    \n  return t;\n}\nmat3 lookat(vec3 dir,vec3 up) {vec3 rt=normalize(cross(dir,up));return mat3(rt,cross(rt,dir),dir);}//NOTE TO SELF: dir and up should be normalized \nvec2 mp( vec3 p,float ga)\n{    \n  vec2 h,t=vec2(wave(p,7,1.),5.);   \n  if(abs(p.x)-2.8<0.){\n    b=wave(vec3(0),4,0.);\n    rp = p+vec3(0,b,-6);\n    vec3 wp= p-vec3(0,b*.5,0);\n    no=normalize(f.xyy*wave(f.xyy,1,0.)+f.yyx*wave(f.yyx,1,0.)+f.yxy*wave(f.yxy,1,0.)+f.xxx*wave(f.xxx,1,0.));    \n    rp*=lookat(no,vec3(0.,0.,1.));     \n    float tnoi=texNoise(rp.xz*.15,iChannel1).r;  \n    float cose=cos(rp.y*.5);\n    float boat=0.9*el(rp,0.48-tnoi-sin(rp.z*15.)*0.03,vec3(cose*.75,2.9,cose));\n    h=vec2(boat,3);    \n    h.x=abs(h.x)-.15;\n    h.x=max(h.x,rp.z-1.+tnoi+cos(rp.y*.4)*.5);\n    h.x=min(h.x, max(length(rp.xy-vec2(0,2.6))-.2+tnoi*.3,abs(rp.z-2.3)-2.7)); h.x*=0.8;\n    zp=p+vec3(0,1.7,0);\n    float wake =max( length(zp.xy)-1.2-p.z*.05,-3.-p.z);\n    wake=max(wake,-(length(wp.xy-vec2(0,2.0-abs(sin(p.z*2.5-tt*12.))*.5+abs(sin(p.x*.2))))-4.5));\n    t.x=smin(t.x,0.7*wake,1.0);        \n    t.x=max(t.x,-boat+.2);    \n    t=t.x<h.x?t:h;\n    pp=rp;pp.y=abs(pp.y)-3.2;\n    h=vec2(length(pp)-.2,6);\n    if(ga>0.)g+=0.1/(.1+h.x*h.x*(10.-9.5*sin(p.z-tt*5.)));\n    pp=rp-vec3(sin(rp.z*rp.y*.4+tt*4.)*max(0.,rp.y-2.5)*.2,3.6,3.8);\n    h.x=min(h.x,.7*bo(pp,vec3(.02,1,1)));\n    t=t.x<h.x?t:h;\n  }\t  \n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd )\n{\n  vec2 h,t=vec2(.1);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x,1.);\n    if(h.x<.0001||t.x>43.) break;\n    t.x+=h.x;t.y=h.y;\n  }\n  if(t.x>43.) t.y=0.;\n\treturn t;\n}\n#define a(d) clamp(mp(po+no*d,0.).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d,0.).x/d)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n  tt=mod(iTime,61.83);\n  vec3 ro = vec3(7.+cos(tt*.3)*3.,4.+sin(tt*.4)*2.,7.415),\n  cw=normalize(vec3(0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.6)),co,fo;\n  ld=normalize(vec3(0.0,.1,-.5));\n  v = ld.xy/ld.z-rd.xy/rd.z;\n  vec3 moon = vec3(0.15,0.45,.26)*pow(max(dot(rd,ld),0.1),54.0)+texNoise(v.xy+1.,iChannel0).r*smoothstep(.142, .13, length(v)); \n  co=fo=vec3(0.6, 2.6, 0.54)+moon-length(uv)*.2;  \n  z=tr(ro,rd);t=z.x;\n  if(z.y>0.){    \n    po=ro+rd*t; ld=normalize(vec3(.2,1.5,-.5));\n    no=normalize(e.xyy*mp(po+e.xyy,0.).x+e.yyx*mp(po+e.yyx,0.).x+e.yxy*mp(po+e.yxy,0.).x+e.xxx*mp(po+e.xxx,0.).x);\n    float tnoi=texNoise(cp.xz*.0005,iChannel0).r+texNoise(cp.xz*.005,iChannel0).r*.5;\n    al=vec3(.1,.2,1.9)*tnoi/bb*2.,sa=5.;   \n    if(z.y<5.) al=vec3(.3,.2,.0)-min(rp.z*.2,0.4),sa=0.;   \n    if(z.y>5.) al=vec3(1.)-max(ceil(rp.z-2.9),0.)*ceil(max(-(length(abs(pp+vec3(0,0,-.25))-vec3(0,0.,0))-.15), min(length(pp)-.4+.5*clamp(cos(rp.z*5.+1.3),-.6,.5),bo(abs(abs(pp.xzy)-vec3(0.0,0,0.2))-vec3(0,0,0.1),vec3(0.5,.5-2.*abs(sin(pp.y*.3)),.05))))),sa=0.;\n    float dif=max(0.,dot(no,ld)),\n    fr=pow(1.+dot(no,rd),4.);\n    co=mix(al*(a(.1)+.2)*(dif+s(1.0)*sa),fo,min(fr,.6));\n  }\n  fragColor = vec4(pow(co+g*.2*vec3(.7,.2,.1),vec3(0.55)),1);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyBWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[550, 550, 574, 574, 619], [620, 620, 637, 637, 680], [749, 749, 784, 784, 839], [840, 840, 876, 876, 930], [931, 931, 969, 969, 1165], [1166, 1166, 1184, 1184, 1403], [1404, 1404, 1443, 1443, 1713], [1714, 1714, 1745, 1745, 1813], [1813, 1862, 1889, 1889, 3069], [3070, 3070, 3099, 3099, 3265], [3361, 3361, 3417, 3417, 4807]], "test": "untested"}
{"id": "flyBDG", "name": "Fork Dante's na hzeff2607 191", "author": "hzeff2607", "description": "Dante's natty vessel - Result of an improvised live coding session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["cute", "waves", "wave", "sea", "demoscene", "water", "ocean", "flag", "moon", "toon", "boat", "pirate", "divine", "dante", "comedy", "tide"], "likes": 2, "viewed": 234, "published": 3, "date": "1665117852", "time_retrieved": "2024-07-30T16:27:45.980874", "image_code": "// Dante's natty vessel - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\n// \"You have to keep busy, after all, no dog ever pissed on a moving car.\" - Tom Waits\n\n// Major thankx to KALI for helping me \"rock the boat\", also thankx to CanadianCornDog, Brandon Stargrave, Neffers and Haptix for the recommendations and jokes\n\nvec2 z,v,e=vec2(.00035,-.00035),f=vec2(-1.7,1.7);float t,tt,b=0.,bb=0.,g=0.,sa;vec3 cp,rp,pp,po,no,al,zp,ld;\nfloat bo(vec3 p,vec3 r){  p=abs(p)-r;  return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nconst mat2 r2fucked=mat2(cos(.023),sin(.023),-cos(.023),sin(.023));\nfloat el( vec3 p, float r,vec3 h ){ vec3 q = p - clamp( p, -h, h ); return length( q )-r;}\nfloat smin(float a,float b,float k){float h=max(k-abs(a-b),0.);return min(a,b)-h*h*.25/k;}\nvec4 texNoise(vec2 uv,sampler2D tex ){ float f = 0.; f+=texture(tex, uv*.125).r*.5; f+=texture(tex,uv*.25).r*.25;\n                       f+=texture(tex,uv*.5).r*.125; f+=texture(tex,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nfloat noi(vec3 p){\n  vec3 f=floor(p),s=vec3(7,157,113);\n  p-=f;vec4 h=vec4(0,s.yz,s.y+s.z)+dot(f,s);\n  p=p*p*(3.-2.*p);\n  h=mix(fract(sin(h)*43785.5),fract(sin(h+s.x)*43785.5),p.x);\n  h.xy=mix(h.xz,h.yw,p.y);\n  return mix(h.x,h.y,p.z);\n}\nfloat wave( vec3 p,int iter,float ga)\n{  \n  vec3 np=p-vec3(0,0,tt*3.); \n  float nois=0.,amp=3.0;\n  for(int i=0;i<iter;i++){\n   nois+=abs(sin(noi((np-vec3(0,0,tt*3.))*.15)-.5)*3.14)*(amp*=.51);   \n   np.xy*=r2fucked;\n   np*=1.75;    \n  }\n  if(ga>0.)cp=np,bb=nois;  \n  float t=p.y+nois;t*=0.5;    \n  return t;\n}\nmat3 lookat(vec3 dir,vec3 up) {vec3 rt=normalize(cross(dir,up));return mat3(rt,cross(rt,dir),dir);}//NOTE TO SELF: dir and up should be normalized \nvec2 mp( vec3 p,float ga)\n{    \n  vec2 h,t=vec2(wave(p,7,1.),5.);   \n  if(abs(p.x)-2.8<0.){\n    b=wave(vec3(0),4,0.);\n    rp = p+vec3(0,b,-6);\n    vec3 wp= p-vec3(0,b*.5,0);\n    no=normalize(f.xyy*wave(f.xyy,1,0.)+f.yyx*wave(f.yyx,1,0.)+f.yxy*wave(f.yxy,1,0.)+f.xxx*wave(f.xxx,1,0.));    \n    rp*=lookat(no,vec3(0.,0.,1.));     \n    float tnoi=texNoise(rp.xz*.15,iChannel1).r;  \n    float cose=cos(rp.y*.5);\n    float boat=0.9*el(rp,0.48-tnoi-sin(rp.z*15.)*0.03,vec3(cose*.75,2.9,cose));\n    h=vec2(boat,3);    \n    h.x=abs(h.x)-.15;\n    h.x=max(h.x,rp.z-1.+tnoi+cos(rp.y*.4)*.5);\n    h.x=min(h.x, max(length(rp.xy-vec2(0,2.6))-.2+tnoi*.3,abs(rp.z-2.3)-2.7)); h.x*=0.8;\n    zp=p+vec3(0,1.7,0);\n    float wake =max( length(zp.xy)-1.2-p.z*.05,-3.-p.z);\n    wake=max(wake,-(length(wp.xy-vec2(0,2.0-abs(sin(p.z*2.5-tt*12.))*.5+abs(sin(p.x*.2))))-4.5));\n    t.x=smin(t.x,0.7*wake,1.0);        \n    t.x=max(t.x,-boat+.2);    \n    t=t.x<h.x?t:h;\n    pp=rp;pp.y=abs(pp.y)-3.2;\n    h=vec2(length(pp)-.2,6);\n    if(ga>0.)g+=0.1/(.1+h.x*h.x*(10.-9.5*sin(p.z-tt*5.)));\n    pp=rp-vec3(sin(rp.z*rp.y*.4+tt*4.)*max(0.,rp.y-2.5)*.2,3.6,3.8);\n    h.x=min(h.x,.7*bo(pp,vec3(.02,1,1)));\n    t=t.x<h.x?t:h;\n  }\t  \n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd )\n{\n  vec2 h,t=vec2(.1);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x,1.);\n    if(h.x<.0001||t.x>43.) break;\n    t.x+=h.x;t.y=h.y;\n  }\n  if(t.x>43.) t.y=0.;\n\treturn t;\n}\n#define a(d) clamp(mp(po+no*d,0.).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d,0.).x/d)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n  tt=mod(iTime,61.83);\n  vec3 ro = vec3(7.+cos(tt*.3)*3.,4.+sin(tt*.4)*2.,7.415),\n  cw=normalize(vec3(0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.6)),co,fo;\n  ld=normalize(vec3(0.0,.1,-.5));\n  v = ld.xy/ld.z-rd.xy/rd.z;\n  vec3 moon = vec3(0.15,0.45,.26)*pow(max(dot(rd,ld),0.1),54.0)+texNoise(v.xy+1.,iChannel0).r*smoothstep(.142, .13, length(v)); \n  co=fo=vec3(0.6, 2.6, 0.54)+moon-length(uv)*.2;  \n  z=tr(ro,rd);t=z.x;\n  if(z.y>0.){    \n    po=ro+rd*t; ld=normalize(vec3(.2,1.5,-.5));\n    no=normalize(e.xyy*mp(po+e.xyy,0.).x+e.yyx*mp(po+e.yyx,0.).x+e.yxy*mp(po+e.yxy,0.).x+e.xxx*mp(po+e.xxx,0.).x);\n    float tnoi=texNoise(cp.xz*.0005,iChannel0).r+texNoise(cp.xz*.005,iChannel0).r*.5;\n    al=vec3(.1,.2,1.9)*tnoi/bb*2.,sa=5.;   \n    if(z.y<5.) al=vec3(.3,.2,.0)-min(rp.z*.2,0.4),sa=0.;   \n    if(z.y>5.) al=vec3(1.)-max(ceil(rp.z-2.9),0.)*ceil(max(-(length(abs(pp+vec3(0,0,-.25))-vec3(0,0.,0))-.15), min(length(pp)-.4+.5*clamp(cos(rp.z*5.+1.3),-.6,.5),bo(abs(abs(pp.xzy)-vec3(0.0,0,0.2))-vec3(0,0,0.1),vec3(0.5,.5-2.*abs(sin(pp.y*.3)),.05))))),sa=0.;\n    float dif=max(0.,dot(no,ld)),\n    fr=pow(1.+dot(no,rd),4.);\n    co=mix(al*(a(.1)+.2)*(dif+s(1.0)*sa),fo,min(fr,.6));\n  }\n  fragColor = vec4(pow(co+g*.2*vec3(.7,.2,.1),vec3(0.55)),1);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyBDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[550, 550, 574, 574, 619], [620, 620, 637, 637, 680], [749, 749, 784, 784, 839], [840, 840, 876, 876, 930], [931, 931, 969, 969, 1165], [1166, 1166, 1184, 1184, 1403], [1404, 1404, 1443, 1443, 1713], [1714, 1714, 1745, 1745, 1813], [1813, 1862, 1889, 1889, 3069], [3070, 3070, 3099, 3099, 3265], [3361, 3361, 3417, 3417, 4807]], "test": "untested"}
{"id": "NtyBDG", "name": "interpolated parameters v3", "author": "cyperus", "description": "compute and draw interpolated parameters", "tags": ["sampling", "interpolation"], "likes": 3, "viewed": 220, "published": 3, "date": "1665117025", "time_retrieved": "2024-07-30T16:27:47.064976", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"interpolated parameters\" created by Colling Patrik (cyperus) in 2022\n//\n// BASED ON\n// - by FabriceNeyret2\n//   https://www.shadertoy.com/view/4ljyWc \"compared interpolation\"\n//\n// DESCRIPTION:\n//\n// - The animsystem alows to define and interpolate animation parameter sets.\n//   The interpolation mode for each parameter can be set individually.\n//   Interpolation modes are Jump, Linear, Cubic-Linear, Catmull-Rom.\n//\n// - Buffer A\n//   Compute and store loop-times and time interpolated parameters.\n//   Draw the parameter curves as picture.\n//\n// - Image\n//   Test the interpolated parameters by\n//   ,reading interpolated parameters from Buffer A into an 1D-array.\n//   ,drawing loop-times and interpolated parameters as bars.\n//   ,show the parameter curves picture from Buffer A.\n//   ,show the parameter buffer (texels) from Buffer A.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst bool \n    PARAMETER_BARS_DRAW = true,\n    BARS_LOOPTIMES_DRAW = true;\n\n// helper \nvec4 T3(ivec2 id) { return texelFetch(iChannel3,id,0); }\n\nvoid mainImage( out vec4 O, in vec2 U)\n{\n    /// read app state from Buffer A\n    // get animation times  \n    vec4 anim_ts = T3(buf_loop_tO);\n    \n    // get time interpolated parameters and store them into an 1D-array\n    const int a_pa_ipvR = buf_pa_ipvR.y * 4;\n    float[a_pa_ipvR] pa_ipv;    \n    for( int j = 0; j < buf_pa_ipvR.y; j++)\n    {\n        vec4 temp = T3(ivec2(0,j) + buf_pa_ipvO);\n        for( int k = 0; k<4; k++)\n            pa_ipv[4*j+k] = temp[k];\n    }\n    \n    /// draw\n    // uv coordinates\n    vec2 uv = vec2( U.x/iResolution.x, (2.*U.y/iResolution.y-1.) );  // uv.x in[0.,1.], uv.y in[-1.,1.]                                    \n    float pix = 1./iResolution.y; // pixel size        \n    \n    float a, h, f, u_id; // alpha, hue, value, id\n    O = vec4(0.);\n    \n    if(PARAMETER_BARS_DRAW) {\n    u_id = floor(uv.x*float(a_pa_ipvR));\n    f = map_v( pa_ipv[int(u_id)] );\n    a = abs(uv.y) <= abs(f) && sign(f) == sign(uv.y) ? 1.: 0.;\n    h = u_id/float(a_pa_ipvR);\n    O += (1.-O.a) * vec4( hsv2rgb(h, 1., .7),1.) * a;\n    }\n    \n    if(BARS_LOOPTIMES_DRAW) {\n    u_id = floor(4. * uv.x);\n    f = map_v( anim_ts[int(u_id)] );\n    a = abs(uv.y) < f ? 1.: 0.;\n    h = u_id/4.;\n    O += (1.-O.a) * vec4(hsv2rgb(h, 1., .1),1.) * a;\n    }\n        \n    /// mix Buffer A with Image\n    O = mix(T3(ivec2(U)), O, MIX_FACTOR);\n    \n    // gamma correction (in the last pass)\n    O.xyz = pow(O.xyz, vec3(1./2.2));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const bool\n    PARAMETER_PRESETS_INTERPOLATION_BUFFERED = false,  // (compile + time reset) (GOTO: **)\n    MAP_V_LINEAR = false; // Viewport v-axis mapping (comment to see all values form -INF to +INF)\n\n/// const\nconst float \n    PI_2 = acos(0.),\n    PI   = 2.*PI_2,\n    PI2  = 2.*PI;\n\nconst float loop_t = 36.;  // animation loop time in seconds\nconst ivec2 pa_preR = ivec2(8,3); // number of ivec2(parameter-presets, texels per preset), (4 parameters per texel)\n\nconst ivec2\n/// Buffer A: app state memory layout (O: offset, R: range)\n    buf_O = ivec2(40,10),             // buffer offset (compile + time reset)\n// state variables\n    buf_loop_tO = ivec2(3,0)+buf_O,   // loop times\n// parameter interpolated values (buffer 1D-array)\n    buf_pa_ipvO = ivec2(5,0)+buf_O,\n    buf_pa_ipvR = ivec2(1,pa_preR.y),\n// parameter presets (buffer 2D-array)  (GOTO: **)\n    buf_pa_preO = ivec2(6,0)+buf_O,\n    buf_pa_preR = pa_preR;\n\n/// viewport\nconst float \n    SUBDIV_V   = 10.,\n    MIX_FACTOR = 0.2;     // Mix Buffer A with Image \n\n// remap the v-axis for drawing, the parameter values in the Buffer A are not changed\nfloat map_v(float f)\n{\n    if(MAP_V_LINEAR)\n      return f/SUBDIV_V;            // axis-v subdivision\n    else\n      return atan(f/SUBDIV_V)/PI_2; // [-inf, +inf] --> [-1.,+1,]\n    \n}\n\nfloat inv_map_v(float f)\n{\n    if(MAP_V_LINEAR)\n      return f*SUBDIV_V;            // linear\n    else\n      return SUBDIV_V*tan(PI_2*f);  // [-1.,+1,] --> [-inf, +inf] \n}\n\n/// sdf shapes\nfloat line(vec2 p, vec2 a, vec2 b) // line segment with disc ends\n{ \n    // a,b : line start end point\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.); // proj coord on line\n    return length(p - b * h);                       // dist to segment\n}\n\nfloat line0(vec2 p, vec2 a,vec2 b) // line segment without disc ends\n{ \n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b),       // proj coord on line\n          c = clamp(h, 0., 1.);\n    return h==c ? length(p - b * h) : 1e5; // dist to strict segment\n}\n\nfloat linehv(float u, float r) // line horizontal or vertical\n{\n    return abs(u) - r;\n}\n\nfloat disk( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat circle(vec2 p, float r)\n{\n    return abs(length(p) - r);\n}\n\n// sdf operators\n\nfloat opR( in float sdf, in float r ) // round\n{\n  return sdf - r;\n}\n\nfloat opO( in float sdf, in float r ) // onion\n{\n  return abs(sdf) - r;\n}\n\n// smooth\nfloat S(float sdf, float pix)\n{\n    // pix : pixel size\n    // smooth pixel cut equal sided\n    return smoothstep(1.5, -1.5, sdf/pix);    \n}\n\n/// color\nvec3 h2rgb(float h)\n{\n    return vec3(.6*(1.+cos(2.*PI*(h+vec3(0,1,2)/3.))));\n}\n\nvec3 hsv2rgb(float h, float s, float v)\n{\n    // hue, saturation, value\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n    return v * mix( vec3(1.0), rgb, s);\n}", "buffer_a_code": "const bool\n    TIME_LINE_MOVE       = true,\n    PARAMETER_CURVE_DRAW = true;\n\n// helpers \nvec4 T3(ivec2 id) { return texelFetch(iChannel3,id,0); }\n\nbool inside(ivec2 id, ivec2 idR) {\n    return (0 <= id.x && id.x < idR.x ) && (0 <= id.y && id.y < idR.y ); }\n\n// interpolation modes\nconst int iJUMP = 0, iLINEAR = 1, iCUBLIN = 2, iCATMULL = 3;\n\n// define parameter interpolation mode for each parameter\nconst ivec4[pa_preR.y]\n    pa_imode = ivec4[](\n        ivec4(iJUMP,iLINEAR ,iCUBLIN ,iCATMULL),\n        ivec4(iJUMP,iLINEAR ,iCUBLIN ,iCATMULL),\n        ivec4(iJUMP,iLINEAR ,iCUBLIN ,iCATMULL));\n\nconst vec4[pa_preR.x * pa_preR.y]\n    pa_sets = vec4[](\n        // pa_set0:\n        vec4( 0.),\n        vec4( 0.),\n        vec4( -5.),\n\n        // pa_set1:\n        vec4( 1.),\n        vec4( 4.),\n        vec4( 5.),\n\n        // pa_set2:\n        vec4( 2.),\n        vec4( 8.),\n        vec4( -5.),\n\n        // pa_set3\n        vec4( 3.),\n        vec4( 4.),\n        vec4( 5.),\n\n        // pa_set4\n        vec4( 4.),\n        vec4( 0.),\n        vec4( -5.),\n\n        // pa_set5\n        vec4( 5.),\n        vec4( -4.),\n        vec4( 5.),\n\n        //pa_set6\n        vec4( 6.),\n        vec4( -8.),\n        vec4( -5.),\n\n        //pa_set7\n        vec4( 7.),\n        vec4( -4.),\n        vec4( 5.));\n\nvec4 buf_pa_init(ivec2 pa_tex_id) // (GOTO: **)\n{\n     // initialize parameter sets buffer\n     // id.x : parameters set index, id.y : parameter texel index\n     // return texel with 4 parameter values. \n    return pa_sets[ pa_tex_id.x * pa_preR.y +  pa_tex_id.y ];\n}\n\nvec4 loop_times(in float time, in float loop_length, in int seg_num) {\n    // the segment-times are equidistant.\n    float loop_ntimec  = time / loop_length; // loop-normalized-time continious for periodic functions\n    float loop_ntime = fract(loop_ntimec);   // in [0.,1.]          loop-normalized-time\n    time = loop_ntime * float(seg_num);      // in [0., seg_num[    loop-time\n    float seg_id = floor(time);              // in [0., seg_num-1.] segment-index\n    float seg_ntime = time-seg_id;           // in [0., 1.]         segment-normalized-time\n    return vec4(seg_ntime, seg_id, loop_ntime, loop_ntimec);\n    }\n\nivec4 seg_cp_idv4_get(in int seg_id, in int seg_num) {\n    // calculate interpolation segment control point indexes\n    return (seg_num+seg_id + ivec4(-1,0,1,2))%seg_num;                      \n    }\n\nfloat jump(vec4 cps, float t) {\n    return cps.y;} \n\nfloat linear(vec4 cps, float t) {\n    return mix(cps.y,cps.z,t);}\n\nfloat cubiclinear(vec4 cps, float t) {\n    return mix(cps.y,cps.z,smoothstep(0.,1.,t));}\n\nfloat catmull(vec4 cps, float t) {\n\tfloat A0 = mix( cps.x, cps.y, t+1.),\n\t      A1 = mix( cps.y, cps.z, t),\n\t      A2 = mix( cps.z, cps.w, t-1.),\n          B0 = mix( A0, A1, .5*t + .5),\n\t      B1 = mix( A1, A2, .5*t);\n\treturn mix( B0, B1, t);}\n\nfloat interpolate(vec4 cps, int im, float seg_nt)\n{\n    float iv = 1.; // interpolated value (default value)\n    iv = im<2? im<1? jump(cps, seg_nt)        // im == 0 \n                   : linear(cps, seg_nt)      // im == 1\n             : im<3? cubiclinear(cps, seg_nt) // im == 2\n                   : catmull(cps, seg_nt);    // im == 3\n    return iv;\n}\n\nvec4 interpolatev4( in mat4 cpm4, in ivec4 imv4, in float seg_nt)\n{\n    return vec4(interpolate(vec4(cpm4[0][0], cpm4[1][0], cpm4[2][0], cpm4[3][0]), imv4.x, seg_nt),\n                interpolate(vec4(cpm4[0][1], cpm4[1][1], cpm4[2][1], cpm4[3][1]), imv4.y, seg_nt),\n                interpolate(vec4(cpm4[0][2], cpm4[1][2], cpm4[2][2], cpm4[3][2]), imv4.z, seg_nt),\n                interpolate(vec4(cpm4[0][3], cpm4[1][3], cpm4[2][3], cpm4[3][3]), imv4.w, seg_nt));\n}\n\nvoid pa_curves_draw(inout vec4 O, in vec2 U, in float loop_nt)\n{\n    // normalized coords\n    float pix_u = 1./iResolution.x;\n    float pix_v = 1./iResolution.y;\n    U /=iResolution.xy;\n    // uv graph\n    float u = (TIME_LINE_MOVE) ? U.x : U.x+0.5+loop_nt;\n          u *= float(pa_preR.x); // u in[0, pa_preR.x]\n    float v = (2.*U.y-1.);       // v in[-1., 0., +1]\n\n    // interpolation segment coordinates (local segment coordinates)\n    float u_id = floor(u); float u_lo = u - u_id;         // index parameterset, u-local                          \n    ivec4 cp_idv4 = seg_cp_idv4_get(int(u_id),pa_preR.x); // parameter-set contolpoint ids\n    \n    // draw from front to back\n    O = vec4(0);\n\n    // parameter curves\n    for(int j = 0; j < pa_preR.y; j++) // j = index texel \n    {\n        // get controlpoint values from 4 adjacent preset texels\n        mat4 cpm4;\n        if(PARAMETER_PRESETS_INTERPOLATION_BUFFERED) { // (GOTO: **)\n        // read from buffer presets\n        cpm4 = mat4( T3( ivec2(cp_idv4.x, j) + buf_pa_preO )   // preset -1\n                   , T3( ivec2(cp_idv4.y, j) + buf_pa_preO )   // preset  0\n                   , T3( ivec2(cp_idv4.z, j) + buf_pa_preO )   // preset +1\n                   , T3( ivec2(cp_idv4.w, j) + buf_pa_preO )); // preset +2\n        }else {\n        // read from array presets\n        cpm4 = mat4( pa_sets[ cp_idv4.x * pa_preR.y +  j ]   // preset -1\n                   , pa_sets[ cp_idv4.y * pa_preR.y +  j ]   // preset  0\n                   , pa_sets[ cp_idv4.z * pa_preR.y +  j ]   // preset +1\n                   , pa_sets[ cp_idv4.w * pa_preR.y +  j ]); // preset +2 \n        }\n        \n        // interpolate texel  \n        vec4 ipvv4 = interpolatev4(cpm4, pa_imode[j], u_lo);\n        \n        // draw curves        \n        for(int k = 0; k < 4; k++) // k = index component of texel (x,y,z,w)\n        {\n            float ipv = map_v(ipvv4[k]);                     // interpolated value\n            float a = (pa_imode[j][k] == iJUMP)              // JUMP not continuous function, needs special case\n                ? S( opR(line(vec2(u,v),vec2(u_id,ipv),vec2(u_id+1.,ipv)), pix_v * 1.25 ),pix_v)\n                : smoothstep(1.5,-1.5, abs(ipv-v)/fwidth(ipv-v));\n            //a *= ivec2(0,3) == PA_SELECTED ? 1.0: 0.3;     // hightlight selected parameter\n            O += (1.-O.a) * vec4( hsv2rgb(float(4*j + k)/float(pa_preR.y * 4), 1., 1.), 1.) * a;\n        }    \n    }\n    float x;\n    // time line\n    x = (TIME_LINE_MOVE) ? U.x - loop_nt : U.x - 0.5;\n    vec4 tl_C = vec4(1,1,0,1);\n         tl_C.a *= S(linehv( x, .5 * pix_u), pix_u);\n    O += (1.-O.a) * vec4(tl_C.rgb,1.) * tl_C.a;\n    \n    // coord lines\n    // horizontal\n    vec4 coordlh_C = vec4(1.);\n         coordlh_C.a = S(linehv( v, pix_v), pix_v); // 0.\n         O += (1.-O.a) * vec4(coordlh_C.rgb,1.) * coordlh_C.a;     \n    for (float i = 0.; i < 4.; i++) // {1.,10.,100.,1000.,}\n        {coordlh_C.a = S(linehv( abs(v) - map_v( pow(10., i)), pix_v) ,pix_v);       \n         O += (1.-O.a) * vec4(coordlh_C.rgb,1.) * coordlh_C.a;}    \n        \n    // vertical   \n    x = (TIME_LINE_MOVE) ? U.x : U.x - 0.5 + loop_nt;\n    x = fract(x-.5)-0.5;\n    vec4 coordlv_C = vec4(1.);\n         coordlv_C.a *= S(linehv( x, .5 * pix_u), pix_u);\n    O += (1.-O.a) * vec4(coordlv_C.rgb,1.) * coordlv_C.a;\n       \n    // coords pattern\n    v = inv_map_v(v);\n    vec4 C0 = vec4( vec3( 0.05+(0.05*( sign(fract(0.5*u) - 0.5) * sign(fract(0.5*v) - 0.5) )) ) , 1.);\n    \n    if(MAP_V_LINEAR) {\n        O += (1.-O.a) * C0;}\n    else {\n        vec4 C1 = vec4( vec3( 0.075 ), 1.);\n        O += (1.-O.a) * mix(C0, C1, smoothstep(10., 40. ,abs(v))); } // mask false pattern for high values of v\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    bool Init = (iFrame < 10);\n    ivec2 U_id = ivec2(U);\n    vec4 loop_ts = loop_times( iTime, loop_t, pa_preR.x);\n\n    /// update app state in Buffer A\n    // store loop_times\n    if (U_id == buf_loop_tO)\n    {\n        O = loop_ts;\n        return;\n    }\n    // compute and store time interpolated parameter values\n    if (inside(U_id - buf_pa_ipvO, buf_pa_ipvR))\n    {\n         // get controlpoints ids\n        ivec4 cp_idv4 = seg_cp_idv4_get(int(loop_ts.y), pa_preR.x);\n        \n        // get controlpoint values from 4 adjacent preset texels\n        int j = U_id.y-buf_pa_ipvO.y;\n        mat4 cpm4;\n        if (PARAMETER_PRESETS_INTERPOLATION_BUFFERED) { // (GOTO: **)\n        cpm4 = mat4( T3(ivec2(cp_idv4.x, j) + buf_pa_preO)   // preset -1\n                   , T3(ivec2(cp_idv4.y, j) + buf_pa_preO)   // preset  0\n                   , T3(ivec2(cp_idv4.z, j) + buf_pa_preO)   // preset +1\n                   , T3(ivec2(cp_idv4.w, j) + buf_pa_preO)); // preset +1\n        }else {                \n        // read from array presets\n        cpm4 = mat4( pa_sets[ cp_idv4.x * pa_preR.y +  j ]   // preset -1\n                   , pa_sets[ cp_idv4.y * pa_preR.y +  j ]   // preset  0\n                   , pa_sets[ cp_idv4.z * pa_preR.y +  j ]   // preset +1\n                   , pa_sets[ cp_idv4.w * pa_preR.y +  j ]); // preset +2\n        }               \n        // interpolate texel  \n        O = interpolatev4(cpm4, pa_imode[U_id.y], loop_ts.x);\n        return;        \n    }\n    \n    // initialize parameter texel buffer\n    if(PARAMETER_PRESETS_INTERPOLATION_BUFFERED) { // (GOTO: **)\n        if (inside(U_id - buf_pa_preO, buf_pa_preR))\n        {\n            if (Init)\n                O = buf_pa_init(U_id - buf_pa_preO);\n            else\n                O = T3(U_id); // refresh with previous state\n            return;    \n        }\n    }\n    // draw\n    if(PARAMETER_CURVE_DRAW) {\n        pa_curves_draw(O, U, loop_ts.z);}\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtyBDG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1186, 1197, 1216, 1216, 1253]], "test": "untested"}
{"id": "slKBzd", "name": "oily metaballs", "author": "timmaffett", "description": "Copy of https://www.shadertoy.com/view/4t2GDG removing duplicate channels\n\nchanged texture to one that makes it brighter\n", "tags": ["metaballs", "subsurface", "iridescent"], "likes": 7, "viewed": 391, "published": 3, "date": "1665098805", "time_retrieved": "2024-07-30T16:27:47.984517", "image_code": "// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// https://iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = .0001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 40;\n\t\nvec4 spherePos[100];\n    \n\n\n// Taken From\n//https://www.shadertoy.com/view/MsX3RH\n\nvec3 nmap(vec2 t, sampler2D tx, float str)\n{\n\tfloat d=1.0/1024.0;\n\n\tfloat xy=texture(tx,t).x;\n\tfloat x2=texture(tx,t+vec2(d,0)).x;\n\tfloat y2=texture(tx,t+vec2(0,d)).x;\n\t\n\tfloat s=(1.0-str)*1.2;\n\ts*=s;\n\ts*=s;\n\t\n\treturn normalize(vec3(x2-xy,y2-xy,s/8.0));///2.0+0.5;\n}\n\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\n\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    vec3 w = pow( abs(n), vec3(k) );\n\treturn (x*w.x + y*w.y + z*w.z) / (w.x+w.y+w.z);\n}\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdPlane( vec3 p )\n{\n    \n    float f = sin( p.z * 5. ) * sin( p.x * 5. );\n    //f = 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n\treturn p.y - (abs( f) * .3)/ max( 1. , pow( length( p ), 1.));\n\n}\n\n\n\nfloat sdSphere( vec3 p, float s , float offset)\n{\n\n\n    float d1 = length(p) - .1*smoothstep(0.0,1.0,iTime);;\n    d1 *= .8;\t\n    \n   // vec3 nP = vec3( x , y , z );\n    return d1 -s;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n\n}\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat opBlend( vec2 d1, vec2 d2 )\n{\n\n    return smin( d1.x , d2.x , 8.);\n}\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n   \tvec2 res = vec2( 10000. , 0.);// vec2( sdPlane( pos - vec3( 0. , -1. , 0. )), 0.0 );\n   \n    for( int i = 0; i < 20; i++ ){\n   \t\t\n        vec2 res2 = vec2( sdSphere( (pos - spherePos[i].xyz) , spherePos[i].w  , float( i )) , float(i) + 1.);\n        //vec2 res2 = vec2( udRoundBox( (pos - spherePos[i].xyz) , vec3( spherePos[i].w  ) ,spherePos[i].w * .2 ) , float(i) + 1.);\n   \t\tres.x = opBlend( res ,  res2 );\n        \n   \t}\n    \n   \treturn res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 20.*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n#define STEPS 5\nvec3 fogCube( vec3 ro , vec3 rd , vec3 n ){\n \n    float lum = 1.;\n    \n    vec3 col = vec3( 0. );\n    for( int i = 0; i < STEPS; i++ ){\n        vec3 p = ro + rd * .3  * float( i );\n\n        lum += pow(triNoise3D( p * .3, float( i ) / float( STEPS )),.3);// + sin( p.y * 3. ) + sin( p.z * 5.);\n    \n       \tcol += hsv( lum * 4. + sin( iTime * .1 ) , 1. , 1. ) / lum;\n    }\n    \n    return col * 2.5/float(STEPS);\n    \n    \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec3 lightPos = vec3( 2. , 5. , 1. );\n\n    for( int i =0; i < 20; i++ ){\n        \n        float x = 1. * cos(iTime *.13 * (float( i )+2.));\n        float y = 1. * sin(iTime * .075 * (float( i )+4.));\n        float z = 1. * sin(iTime * .1 * (float( i )+3.3));\n        float r = .1 * ( sin( iTime * .1  *( float( i) +1.))+2.);\n        \n        spherePos[i] = vec4( x , y , z , r  );\n        \n       \n        \n  \n    \t//spherePos[i] = vec4( x * 10. , 0. , 0. , .02  );\n                \n    }\n\n   \t\n    \n    \n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n    \n    \n    vec3 col = vec3( 0. );//vec3( .8 , .8 , .8 ); \n   \n    // If we have hit something lets get real!\n    if( res.y > -.5 ){\n\n    \tvec3 pos = ro + rd * res.x;\n    \tvec3 nor = calcNormal( pos );\n        \n        // from\n       // https://www.shadertoy.com/view/MsX3RH\n        //triplanar blend vector\n\t\tvec3 tpn=normalize(max(vec3(0.0),(abs(nor.xyz)-vec3(0.2))*7.0))*0.5;\n        //normal mapping\n        float nms=.59;\n        vec3 tuv=pos*vec3(1.0 , 1. , 1.);\t//texture coordinates\n\n        vec3 nmx=nmap(tuv.yz,iChannel0,nms)+nmap(-tuv.yz,iChannel0,nms);\n        vec3 nmy=nmap(tuv.xz,iChannel0,nms)+nmap(-tuv.xz,iChannel0,nms);\n        vec3 nmz=nmap(tuv.xy,iChannel0,nms)+nmap(-tuv.xy,iChannel0,nms);\n\n        vec3 nn=normalize(nmx*tpn.x+nmy*tpn.y+nmz*tpn.z);\n        nor = normalize(nn + nor);\n        \n        \n        //vec3 pat = texCube( iChannel0, 0.5*pos, nor, 10.0 ).xyz;\n       // pat = normalize( pat );\n        \n        float AO = calcAO( pos , nor );\n        \n        float match = -dot( nor , rd );\n        \n        vec3 lightDir = normalize( pos - lightPos );\n        vec3 refl = reflect( lightDir , nor );\n        \n        float reflMatch = dot( rd , refl );\n        \n      \n        vec3 iriCol = fogCube( pos , rd , nor );\n        \n        \n        \n        \n        col = iriCol * .5 + iriCol * pow( max( 0. , -reflMatch ) , 10. ) ;\n\n       // float c = pow(( 1.-AO) , 5.)*  10.;\n        float c = 0.;\n        c += pow((1.- match),4.) * 1.;\n        c += pow(( 1.-AO) , 5.)*  2.;\n        col -= vec3( c );// * .4 * ( nor * .5 + .5 );\n        \n     \n        //col = nor;\n       /* if( res.y < .5 ){\n            \n            float f = sin( pos.z * 5. ) * sin( pos.x * 5. );\n            //col *= 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n            col *= abs( f );\n            col /= pow( length( pos ), 4.);\n        }*/\n    }\n    // apply gamma correction\n    //col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col , 1. );\n    \n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKBzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[411, 411, 455, 455, 677], [680, 732, 754, 754, 779], [780, 780, 801, 801, 881], [917, 969, 1012, 1012, 1315], [1318, 1318, 1383, 1383, 1567], [1569, 1569, 1606, 1606, 1738], [1740, 1740, 1785, 1785, 1825], [1827, 1827, 1852, 1852, 2022], [2026, 2026, 2075, 2075, 2210], [2212, 2212, 2250, 2250, 2421], [2423, 2454, 2518, 2518, 2696], [2698, 2698, 2781, 2781, 2894], [2899, 2993, 3022, 3022, 3065], [3067, 3103, 3144, 3144, 3215], [3217, 3217, 3252, 3252, 3291], [3292, 3376, 3397, 3397, 3861], [3865, 3865, 3913, 3913, 4380], [4382, 4495, 4526, 4526, 4752], [4755, 4755, 4829, 4829, 5090], [5093, 5093, 5135, 5135, 5434], [5453, 5453, 5496, 5496, 5876]], "test": "untested"}
{"id": "7lVfRd", "name": "evenmore metaballs", "author": "timmaffett", "description": "copy of https://www.shadertoy.com/view/4sXXWM\nwith edits suggested by https://www.shadertoy.com/user/tholzer to allow #define NUMmb to be arbitrarily increased", "tags": ["metaball"], "likes": 9, "viewed": 241, "published": 3, "date": "1665096241", "time_retrieved": "2024-07-30T16:27:48.748474", "image_code": "\n\n#define NUMmb 60\n\n\n//heya, \n//quick n dirty effect\n//pretty much the same thing but\n//with quads and generated textures:\n//http://dusanbosnjak.com/test/webGL/new/gui_color/ring.html\n\n\n\nfloat  rn(float xx){\n        float v0 = fract(sin(xx*.4686)*3718.927);          \n        return v0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat ts = iTime *.6;//time scaled\n\t\n\tvec3 COLOR_MASKS[16];//blob colors\n\tCOLOR_MASKS[0] = vec3( 0.20, 0.30, 1.0 );\n  \tCOLOR_MASKS[1] = vec3( 0.53, 0.85, 0.25 );\n  \tCOLOR_MASKS[2] = vec3( 1.0, 0.56, 0.15 );\n  \tCOLOR_MASKS[3] = vec3( 1.0, 0.0, 0.3 );\n  \tCOLOR_MASKS[4] = vec3( 0.05, 0.55, .30 );\n\tCOLOR_MASKS[5] = vec3( 0.5, 1.0, .40 );\n  \tCOLOR_MASKS[6] = vec3( 1.0, 0.15, 1.0 );\n  \tCOLOR_MASKS[7] = vec3( .20, .30, 0.5 );\n  \tCOLOR_MASKS[8] = vec3( .350, 1.0, 0.5 );\n  \tCOLOR_MASKS[9] = vec3( .70, .60, 0.5 );\n  \tCOLOR_MASKS[10] = vec3( .34, 1., 0.5 );\n  \tCOLOR_MASKS[11] = vec3( .20, .50, 0.5 );\n  \tCOLOR_MASKS[12] = vec3( 0.60, .10, 0.65 );\n  \tCOLOR_MASKS[13] = vec3( .40, .40, 0.85 );\n  \tCOLOR_MASKS[14] = vec3( 1.0, .30, 0.35 );\n  \tCOLOR_MASKS[15] = vec3( 1.0, 0.0, 0.5 );\n\t\n\t//screen space\n\tvec2 fragP = ( fragCoord.xy / iResolution.xy );\n\tvec2 fragPN = fragP * 2. - 1.; //-1 1\n\tfloat as = iResolution.x/iResolution.y;\n\tfragPN.x *= as; //aspect\n\t// vec2 mouseP = fragP - mouse; //mouse\n\tfloat vH = 10.0;//camera disance - fov\n\tvec3 vD = normalize(vec3(-fragPN,vH));//view dir\n\tvec3 lD = normalize(vec3(cos(iTime),.750,sin(iTime)));//light dir\t\n\t//vec3 ld = normalize(vec3(.7, .750,2.));\n\t\n\tvec2 mbPos[NUMmb];\n\tvec3 nn = vec3(.0);\n\tvec3 cc = vec3(.0);\n\n\tfor(int i=0; i<NUMmb; i++){\n\t\tfloat rn1 = rn(float(i+54));\n\t\tfloat rn2 = rn(float(i-222));\n\t\tfloat rn3 = rn(float(i-262));\n\t\tmbPos[i] = vec2(\n\t\t\tsin(rn1*6.14+ts * rn2)*as,\n\t\t\tcos(rn2*6.14+ts * rn3)\n\t\t);\n\t\tmbPos[i] = fragPN - mbPos[i]*.8;\n\t\tfloat rr = cos(rn3*6.28+ts * rn1)*.2+.5;\n\t\tmbPos[i] *= rr*20.;//blob coord\n\t\tfloat bL = length( mbPos[i] );//bl length\n\t\tfloat bA = smoothstep( 1.0, 0.97, bL );\n\t\tfloat bH = exp(-bL*2.15678);\n\t\tvec3 bN = vec3(mbPos[i]*.3*bH,bH-.01);\n\t\t//vec3 bC=COLOR_MASKS[i];\n        vec3 bC=COLOR_MASKS[i-(i/15)*15]; // Find place in color array >15 blobs\n\t\tbC*=bH;\n\t\tnn += vec3(mbPos[i]*.5*bH,bH);\n\t\tcc += bC;\n\t}\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\t\n\tvec2 mB = fragPN - (mouse.xy*2.-1.)*vec2(as,1.);\n\tmB*=6.;\n\tfloat mBL = length( mB );\n\tfloat mBH = exp(-mBL*2.15678);\n\tvec3 mBN = vec3(mB*.5*mBH, mBH);\n\tvec3 mBC = vec3(1.,.0,.0);\n\tmBC*=mBH;\n\t\n\t\t//float sq = float( //quad\n\t\t//\t(mB.x<1.&&mB.x>-1.)\n\t\t//\t&&\n\t\t//\t(mB.y<1.&&mB.y>-1.)\n\t\t//);\n\t\n\tnn+=mBN;\n\t\n\t\n\tvec3 n = normalize( vec3(nn.x,nn.y,nn.z-.01) );\n\t//float aB = smoothstep(0.0,.01,n.z);\n     float aB = smoothstep(0.0, 0.25, n.z);  // faster with lots of blobs\n     \n\tcc+=mBC;\n\tcc/=nn.z;\n\t//n *= aB;\n\tfloat ndl = dot(n,lD)*.5+.5;//wrap\t\n\t//float ndl = dot(n,lD);//wrap\n\tndl = ndl*.7+.3;\n\tvec3 h = normalize(vD+lD);\n\tfloat ndh = dot(n,h);\n\tndh = ndh*.5+.5;\n\tndh = pow(ndh,70.5)*.35;\n\tvec3 fc = cc*ndl+ndh;\n\t\n\tfloat frs = dot(n,vD);\n\tfrs = 1.0-clamp(frs,.0,1.);\n\tfrs = pow(frs,2.0);\n\tfrs = frs*.4+.121;\n\tfc+=frs;\n\t\n\tfloat color = 0.0;\n\tfragColor = vec4( fc*aB, 1.);\n\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVfRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 187, 207, 207, 288], [289, 289, 346, 346, 3161]], "test": "untested"}
{"id": "slKfzt", "name": "Torus Knot Plane no struct", "author": "timmaffett", "description": "copy of https://www.shadertoy.com/view/WssyDn with the struct removed\n", "tags": ["gradientdescent", "torusknot"], "likes": 9, "viewed": 191, "published": 3, "date": "1665091117", "time_retrieved": "2024-07-30T16:27:49.607178", "image_code": "#define PI 3.1415926535897932384626433\n\n#define sq(x) dot(x, x)\n\nvec2 sic(float t)\n{\n    return vec2(cos(t), sin(t));\n}\nvec2 perp(vec2 v)\n{\n    return (v * vec2(1, -1)).yx;\n}\n\nfloat kp = 33., \nkq = 44.,\nr1 = 0.25, \nr2 = 0.125, \nr3 = 0.065;// + 0.3*(sin(iTime)+1.)/2.;//Change kp and kq!\n\n\nvec3 torusKnot(float t)\n{\n    vec2 sicXY = sic(kp * t);\n    vec2 sicRZ = r2 * sic(kq * t);\n    \n    return vec3((sicRZ.x + r1)*sicXY, sicRZ.y);\n}\nvec3 torusKnotDerivative(float t )\n{\n    vec2 sicXY = sic(kp * t);\n    vec2 sicRZ = r2 * sic(kq * t);\n    \n    vec2 dSicXY = kp * vec2(-1, 1) * sicXY.yx;\n    vec2 dSicRZ = kq * vec2(-1, 1) * sicRZ.yx;\n    \n    return vec3(dSicRZ.x*sicXY + dSicXY*(sicRZ.x + r1), dSicRZ.y);\n}\n\nfloat torusKnotSqDistance(float t, vec3 p )\n{\n    return sq(torusKnot(t) - p);\n}\nfloat torusKnotSqDistanceDerivative(float t, vec3 p )\n{\n    return 2.*dot(torusKnot(t) - p, torusKnotDerivative(t));\n}\n\n\nvec3 torusKnotSqDistanceMinimumInside(vec3 p /*, TorusKnotParameters tkp*/ )\n{\n    //all hard coded numbers depend on the 'r's\n    \n    int sections = int(2.*max(kq,kp));\n    float sectionLength = 2.*PI/float(sections);\n    \n    float lerningRate = 1.5/(max(kq,kp));\n    const int maxIterations = 50;//50\n    \n    float minDist;\n    float bestT;\n    \n    for(int j = 0; j < sections; j++)\n    {\n        float t = sectionLength * float(j);\n        \n        for(int i = 0; i < maxIterations; i++)\n        {\n            float dt = torusKnotSqDistanceDerivative(t, p);\n            dt *= lerningRate;\n            \n            if(abs(dt) < 0.001)\n            {\n                float sqDist = torusKnotSqDistance(t, p);\n        \n                if(sqDist <= sq(r3))\n                {\n                    return vec3(t, sqDist, 1.);\n                }\n                \n                break;\n            }\n            \n            t -= dt;\n            \n            \n            if(t != clamp(t, sectionLength * (float(j)-1.), sectionLength * (float(j)+1.)))\n            {\n                break;\n            }\n        }\n    }\n    \n    return vec3(0.);\n}\n\nint gcd(ivec2 v)\n{\n    while(v.x != v.y)\n    {\n        if(v.x > v.y)\n            v.x -= v.y;\n        else\n            v.y -= v.x;\n    }\n    \n    return v.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 table = vec2(5, 3);\n    \n    vec2 uv = table*fragCoord/iResolution.xy;\n    ivec2 kpkq = ivec2(uv) + 1;\n    kpkq = kpkq.yx;\n    uv = mod(uv, 1.);\n    uv -= 0.5;\n    \n    //uv.x = table.x*fragCoord.x/iResolution.x\n    uv.x *= iResolution.x*table.y/(table.x*iResolution.y);\n\t\n    const float clickSize = 0.;\n    if(iMouse.z < 0. && length(iMouse.xy + iMouse.zw) <= clickSize)//ivec2(iMouse.xy*table/iResolution.xy) == ivec2(-iMouse.zw*table/iResolution.xy)\n    {\n\t\tuv = (fragCoord - iResolution.xy/2.)/iResolution.y;\n        kpkq = ivec2(table*iMouse.xy/iResolution.xy) + 1;\n        kpkq = kpkq.yx;\n    }\n\n    vec2 angles = /*false &&*/ iMouse.z > 0. ? PI*(2.*iMouse.xy/iResolution.xy - 1.) : 1.5*iTime*vec2(0.7, 1);//PI*vec2(0.25, 0.25)*(sic(iTime) + vec2(0, 1))\n    vec2 sic0 = sic(angles[0]);\n    vec2 sic1 = sic(angles[1]);\n    \n    vec3 f = vec3(sic1.x * sic0, sic1.y);\n    vec3 r = vec3(perp(sic0), 0);\n    vec3 u = cross(f, r);\n    \n    ////////////////////////////////////The torus knot parameters//////////////////////////////////////////\n    //float kp = 33., kq = 44., r1 = 0.25, r2 = 0.125, r3 = 0.065;// + 0.3*(sin(iTime)+1.)/2.;//Change kp and kq!\n    // p and q are flipped. The parameters: 'lerningRate', 'maxIterations' and 'sections' also may need to be changed.\n    \n    //ivec2 kpkq = ivec2(10.*iMouse.xy/iResolution.xy) + 1;\n    \n    kpkq /= gcd(kpkq);\n    \n    kp = float(kpkq.x);\n    kq = float(kpkq.y);\n    \n    \n    //TorusKnotParameters tkp = TorusKnotParameters(kp, kq, r1, r2, r3);\n    \n    vec3 p = uv.x*r + uv.y*f;\n    \n    vec3 res = torusKnotSqDistanceMinimumInside(p);\n    \n    vec3 col = vec3(0);\n    \n    \n    if(res[2] > 0.5)\n    {\n        uv.x *= table.x*iResolution.y/(iResolution.x*table.y);\n        \n        p = (uv.x*r + uv.y*f);//square of size 1x1x1\n        \n        col = 2.*p + 0.5;\n        \n        float len = length(col);\n        col = normalize(col);\n        \n        //col = vec3(vec2(kpkq)/(table+1.), 0);\n        \n        col *= smoothstep(r3, r3 - 1./iResolution.y, sqrt(res[1]));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKfzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 84, 84, 119], [120, 120, 139, 139, 174], [289, 289, 314, 314, 434], [435, 435, 471, 471, 709], [711, 711, 756, 756, 791], [792, 792, 847, 847, 910], [2058, 2058, 2076, 2076, 2216], [2218, 2218, 2275, 2275, 4379]], "test": "untested"}
{"id": "stKBzt", "name": "Fork Fractal An NikolaErce 712", "author": "NikolaErceg", "description": "Playing too much with fractals and weird sounds can hurt your mind.", "tags": ["2d", "fractal", "kifs"], "likes": 5, "viewed": 282, "published": 3, "date": "1665085749", "time_retrieved": "2024-07-30T16:27:50.478848", "image_code": "// A trick to use any variable as an array index.\n// Array index must be a constant, and the loop index is a constant when unrolled \n// so we can use it to compare it with any variable and return the array value that matches, \n// or an interpolation of the two closest matches.\n\n// mouse click to see palette\n\nvec3 palette[7]; // the color palette is stored here\n\n// just pick a color based on c value\nvec3 getcolor(float c) \n{\n\tc=mod(c,7.); // cycle palette\n\tint p=0;\n\tvec3 color=vec3(0.);\n\tfor(int i=0;i<7;i++) {\n\t\tif (float(i)-c<=.0) { // check loop index against color value\n\t\t\tcolor=palette[i]; // store color picked\t\n\t\t}\n\t}\n\treturn color;\n}\n\n// get a gradient of the palette based on c value, with a \"smooth\" parameter (0...1)\nvec3 getsmcolor(float c, float s) \n{\n    s*=.5;\n    c=mod(c-.5,7.);\n    vec3 color1=vec3(0.0),color2=vec3(0.0);\n    for(int i=0;i<7;i++) {\n        if (float(i)-c<=.0) {\n            color1 = palette[i];\n            color2 = palette[(i+1>6)?0:i+1];\n        }\n    }\n    // smooth mix the two colors\n    return mix(color1,color2,smoothstep(.5-s,.5+s,fract(c)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// define the colors \n\tpalette[6]=vec3(255,000,000)/255.;\n\tpalette[5]=vec3(255,127,000)/255.;\n\tpalette[4]=vec3(255,255,000)/255.;\n\tpalette[3]=vec3(150,050,050)/255.;\n\tpalette[2]=vec3(000,050,50)/255.;\n\tpalette[1]=vec3(075,000,130)/255.;\n\tpalette[0]=vec3(143,000,255)/255.;\n\t\n\tvec3 color=vec3(0.);\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n\tif (uv.x>.9) { \n\t\tcolor=getsmcolor(uv.y*7.+iTime*.5,.25+.75*abs(sin(iTime))); //gradient function\n\t} else if (uv.x<.1) {\n\t\tcolor=getcolor(uv.y*7.-iTime*.5); // basic function\n\t} \n\n\tvec2 p=(uv-.5);\n\tp.x*=iResolution.x/iResolution.y;\n\t\n\n\t// fractal\n    float a=iTime*.50;\t\n    float b=iTime*1.;\t\n\tfloat ot=1000.;\n\tmat2 rot=mat2(cos(a),sin(a),-sin(a),cos(a));\n\tp+=sin(b)*.005;\n    float l=length(p);\n    for(int i=0;i<15;i++) {\n\t\tp*=rot;\n        p=abs(p)*1.2-1.;\n        ot=min(ot,abs(dot(p,p)-sin(b+l*20.)*.015-.15)); //orbit trap\n\t}\n\tot=max(0.,.1-ot)/.1; //orbit trap \n\tif (length(max(vec2(0.),abs(uv-.5)-vec2(.485,.47)))>0.0) color*=0.; // border \t\n\tif (iMouse.w<1. || length(max(vec2(0.),abs(uv-.5)-vec2(.37,.46)))<0.01) {\n\t\tcolor=getsmcolor(ot*4.+l*10.-iTime*7.,1.)*(1.-.4*step(.5,1.-dot(p,p))); //get color gradient for orbit trap value\t\n\t}\n    color=mix(vec3(length(color))*.5,color,.6); // saturation adjustment\n    color*=1.-pow(l*1.1,5.); color+=pow(max(0.,.2-l)/.2,3.)*1.2; // center glow\n    fragColor = vec4(color,1.0)*min(1.,iTime*.3);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKBzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[364, 402, 427, 427, 646], [648, 733, 769, 769, 1092], [1093, 1093, 1150, 1173, 2544]], "test": "untested"}
{"id": "flVBzd", "name": " Color lines - No Eyes", "author": "timmaffett", "description": "derived from https://www.shadertoy.com/view/ldGyWR with russian comments translated to english\n\nmade get_eye() always return false", "tags": ["colors", "gradient"], "likes": 1, "viewed": 190, "published": 3, "date": "1665078875", "time_retrieved": "2024-07-30T16:27:51.501116", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n//https://www.shadertoy.com\n\n#define time (iTime*.5)\n#define mouse (u_mouse/iResolution)\n#define resolution iResolution\n\n\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\nfloat sin01( in float angle ) { return .5 + .5*sin( angle ); }\nfloat cos01( in float angle ) { return .5 + .5*cos( angle ); }\nfloat cosft( in float from, in float to, in float val ) { return from + cos01( val )*(to - from); }\nfloat sinft( in float from, in float to, in float val ) { return from + sin01( val )*(to - from); }\n\nfloat RandFloat( int i ) { return (fract( sin( float( i ) ) * 43758.5453 )); }\nint RandInt( int i ) { return int( 100000.0*RandFloat( i ) ); }\n\nvec3 hsb2rgb( in vec3 c )\n{\n\tvec3 rgb = clamp( abs( mod( c.x*6.0 + vec3( 0.0, 4.0, 2.0 ), 6.0 ) - 3.0 ) - 1.0, 0.0, 1.0 );\n\trgb = rgb * rgb*(3.0 - 2.0*rgb);\n\treturn c.z * mix( vec3( 1.0 ), rgb, c.y );\n}\n\nvec3 HsvToRgb( vec3 c )\n{\n    float s = c.y;\n\tfloat s_n = c.z - s * .5;\n\treturn vec3( s_n ) + vec3( s ) * cos( 2.0 * pi * (c.x + vec3( 1.0, 0.6666, .3333 )) );\n}\n\n//####################\n//[-1;+1]\nfloat VFx_t( float x, float t,float id )\n{\n\t//return cos(x+-1.780);\n    float da = RandFloat(int(id)) * 1.;\n\tfloat amplitude = 1.;\n\tfloat frequency = 1.;\n\tfloat y = sin( x * frequency );\n\tfloat t_t = 0.01*(-t * 130.0);\n\ty += sin( x*frequency*(2.1+da) + t_t )*4.5;\n\ty += sin( x*frequency*(1.72+da) + t_t * 1.121 )*4.0;\n\ty += sin( x*frequency*(2.221+da) + t_t * 0.437 )*5.0;\n\ty += sin( x*frequency*(3.1122+da) + t_t * 4.269 )*2.5;\n\ty *= amplitude * 0.06;\n\treturn y;\n}\n\nfloat VFx_t01( float x, float t, float id){ return .5 + .5*VFx_t( x, t, id );}\n\nfloat Fx( float x, vec2 scale )\n{\n\n    const float d_sig = 5.;\n    float sc_y = scale.y/d_sig;\n\tfloat ret = smoothstep( -scale.x, 0., x ) - smoothstep( .0, +scale.x, x );\n\n\tret *= sc_y;\n\tfloat sig = sign( sc_y );\n\tret = smoothstep( .0, sig * d_sig, ret - sig ) * sc_y;\n\treturn ret;\n}\n\n//#undef time\n//#define time (10.*1.936)\n\n//#define TEST_ONCE_4_CONSTANT_EYES\n#ifndef TEST_ONCE_4_CONSTANT_EYES\n\n#define COUNT_L 15\n\nconst float max_w = 0.5 / float( COUNT_L );\n\nconst vec2 scale = vec2( .1, 2. )*5.;\nconst vec2 d_uv = vec2( 0., -.3 );\n#else\n#define COUNT_L 8\n\nconst float max_w = .000025 / float( COUNT_L );\n\nconst vec2 scale = vec2( .1, 2. )*3.;\nconst vec2 d_uv = vec2(-0.150,-0.420);\n#endif\n\nvec3 color = vec3( 0 );\n//#define FUNC_VFX(id)\t ( max_w * (1. + VFx_t(id , time )) )\n#define FUNC_VFX(id)\t ( max_w * (1. + VFx_t((id) + uv.y, uv.y - time, id )) )\nstruct Line\n{\n\tfloat id;\n\tfloat id_2;\n\n\tfloat xs;\n\tfloat Vx;\n\tfloat c_pos;\n\n\tfloat eye_l;\n\tfloat eye_r;\n\n\tfloat eye_fl;\n\tfloat eye_fr;\n    \n\tvec2 eye_pos; //todo delete x is always c_pos\n\n\tvec3 color_eye;\n\n\tvec2 scale_eye;\n};\n\nLine setLine(in Line line_in,in vec2 uv){\n    Line line = line_in;\n    line.xs = line.id / float( COUNT_L );\n\tline.id_2 = RandFloat( int(line.id) ) * 2.;\n\tline.Vx = FUNC_VFX( line.id_2 );\n\tline.c_pos = line.xs + line.Vx;\n    return line;\n}\n\nLine setLine( in vec2 uv )\n{\n    Line line;\n\tline.id = floor( uv.x * float( COUNT_L ) );\n    return setLine(line, uv);\n}\n\nLine setLine( in vec2 uv, in float id )\n{\n    Line line;\n\tline.id = id;\n    return setLine(line, uv);\n}\n\n//____________________________________________________________\n// https://www.shadertoy.com/view/MlXyWM\n//original type\n//const int recursionCount\t\t= 8;\t// how deep to recurse\nfloat GetRecursionFade( int recursionCount, int r, float timePercent )\n{\n\tif (r > recursionCount)\n\t\treturn timePercent;\n\n\t// fade in and out recusion\n\tfloat rt = max( float( r ) - timePercent, 0.0 );\n\tfloat rc = float( recursionCount );\n\treturn rt / rc;\n}\n\nvec3 CombinePixelColor( int recursionCount, vec3 color, float timePercent, int i, int r )\n{\n\tvec3 myColor = vec3\n\t(\n\t\tmix( -0.1, 0.1, RandFloat( i + r ) ),\n\t\tmix( 0.0, 0.8, RandFloat( i + r + 100 ) ),\n\t\tmix( 0.0, 0.8, RandFloat( i + r + 200 ) )\n\t);\n\n\t// combine with my color\n\tfloat f = GetRecursionFade( recursionCount, r, timePercent );\n\tmyColor.y = pow( myColor.y, 4.0 );\n\tmyColor.z = pow( myColor.z, 4.0 );\n\tcolor += myColor * f;\n\treturn color;\n}\n\nvec3 FinishPixel( vec3 color, vec2 uv )\n{\n\t// color wander\n\tcolor.x += 0.02*time;\n\treturn HsvToRgb( color );\n}\n//____________________________________________________________\n\nbool get_eye( in Line line_in,out Line line, in vec2 uv )\n{\n#if 1\nreturn false;\n#else\n    line = line_in;\n    // \n    //expansion speed\n\t//---\n    const vec2 max_scale = vec2( (4.32), (6.680) );\n\t//line.scale_eye = vec2(max_scale.x,1.15) ;\n\tline.scale_eye = max_scale * 1.;\n\n\tfloat udid = RandFloat( int( line.id ) );\n\t//t = .94;\n\t//t= .89+.04*sinft(.0,1.,line.id+t);\n\tfloat t_time = time * .3;\n\tline.scale_eye *= sinft( .0, 1.3, t_time + udid * scale.y );\n\t//line.scale_eye *= sinft(.0,1., t_time+line.id*t*scale.y );\n\n#ifdef TEST_ONCE\n\t//test open eye\n\tline.scale_eye = max_scale * clamp( 0.968, .0, 1. );\n    line.scale_eye = max_scale * sinft(.9,1.2,time*2.);//0.936;\n#endif\n\n    // movement speed\n\tline.eye_pos.y = scale.y*(-1. + 3.*fract( .25*time*udid ));\n\tline.eye_pos.x = line.c_pos;\n\n#ifdef TEST_ONCE\n\t//test pos eye\n\tline.eye_pos.y = 0.084;\n#endif\n\n\tline.eye_fl = Fx( line.eye_pos.y - uv.y, -line.scale_eye );\n\tline.eye_fr = Fx( line.eye_pos.y - uv.y, line.scale_eye );\n\n\t//color += plot_Fy( pos_eye.x + fl ,color, uv);\n\t//color += plot_Fy( pos_eye.x + fr ,color, uv);\n    //line itself (line.xs + line.Vx) + eye\n\tline.eye_l = line.c_pos + line.eye_fl;\n\tline.eye_r = line.c_pos + line.eye_fr;\n\n\tconst float dw = .0001;\n\tfloat fill = smoothstep( line.eye_l, line.eye_l + dw, uv.x )\n\t\t- smoothstep( line.eye_r, line.eye_r + dw, uv.x );\n    \n\n\tif (fill > .00001)\n\t{\n        float t_l = smoothstep(line.eye_pos.x, line.eye_l, uv.x);\n        float t_r = smoothstep(line.eye_pos.x, line.eye_r, uv.x);\n        float to_dark_1 = pow(t_l + t_r, 2.9);\n        \n        \n        float max_r = pow(Fx( line.eye_pos.y , line.scale_eye ) , .04);\n        float to_dark_2 = \n             //smoothstep(.0, \n                            length( (line.eye_pos - uv) * line.scale_eye *vec2(2.,1.) / scale)// /max_r\n                        \n                        //, max_r*.25)\n            ;\n#if 0\n        //center positions\n        float it = to_dark_2*10.;\n        float ret = it - floor(it);\n        line.color_eye = vec3(\n        //to_dark_2\n            ret\n             //+\n            //smoothstep(line.eye_r, line.eye_pos.x, uv.x)\n        );\n        \n        //line.color_eye = plot_Fy(line.eye_pos.x ,line.color_eye ,uv);\n        //line.color_eye = plot_Fx(line.eye_pos.y ,line.color_eye ,uv);\n        \n        //line.color_eye = plot_Fy(line.eye_l ,line.color_eye ,uv);\n        //line.color_eye = plot_Fy(line.eye_r ,line.color_eye ,uv);\n        return true;\n#endif\n        \n\n        //__________________________________________________________________________________________\n        //first option\n\tvec3 ret_col1 = vec3(to_dark_2);\n#if 1\n\t{\n        ret_col1 = hsb2rgb(\n\t\t\tvec3(\n\t\t\t\tRandFloat( int(\n\t\t\t\t\tto_dark_2*30. + line.id_2*line.id + time * 10.\n\t\t\t\t\t) )\n\t\t\t\t,\n\t\t\t\t1., 1.-to_dark_1\n\t\t\t) );\n\t}\n\n#endif\n//uv second)\nvec3 ret_col2 = vec3(.0);\n#if 1   \n\t{\n        float rand_id = RandFloat( int( line.id_2 ));\n\t\tfloat iterations = to_dark_2 * (25.*sinft( .5, 1., time ) + rand_id )+ time * -.5;\n\t\tfloat pct2 = iterations - floor( iterations );\n\t\t//_____\n\t\tconst int recursionCount = 5;\n\t\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t\t\tret_col2 = CombinePixelColor( recursionCount, ret_col2, pct2, int( iterations + rand_id * time ), r );\n\n\t\tret_col2.x += time * 1.5;\n\t\tret_col2 = HsvToRgb( ret_col2 );\n\t}\n#endif\n     \n        ret_col2 = mix(ret_col2,vec3(.0),to_dark_1);\n\t\tcolor = mix(\n            ret_col1,\n            ret_col2,\n            //0.\n            sinft(.0,1.,time*udid)\n        );\n\n        //color = vec3(to_dark_2);\n\n\n#if 0 //type eye\n\t\tif (mod( line.id, 2. ) > .5)return true;\n\t\tvec2 tuv = line.eye_pos - uv;\n\t\ttuv *= line.scale_eye / scale;\n\t\t//tuv.y *= line.scale_eye.y / (scale.y*.25);\n\n\t\tfloat angle = atan( tuv.y, tuv.x ) + time * 5.;\n\t\tfloat r = length( tuv ) / line.scale_eye.x*2.5;\n\n\n\t\tfloat sign = mod( r, sinft( .5, 1.000,\n\t\t\t\t\t\t\t\t\ttime*.5\n\t\t) ) >= 0.25 ? -1. : +1.;\n\t\t//sign = 1.;\n\n\t\tfloat it_sp = 100.*(-1.620 * sqrt( r ) + angle * (-.060 * sign));\n\n\t\tfloat sp = cos( it_sp );\n\t\tfloat sp_2 = sp;\n\t\tsp = sp > .5*r ? 1. : .0;\n\n\t\t//line.color_eye = vec3(sp);\n\t\t//line.color_eye = mix(vec3(sp), line.color_eye ,sinft(.0, 1., time*4.) );\n\t\t///*\n\t\tline.color_eye = mix(//hsb2rgb(vec3(sp,sp,to_dark)), \n\t\t\t\t\t\t\t  vec3( sp ),\n\t\t\t\t\t\t\t  hsb2rgb( vec3(\n\t\t\t\t\t\t\t\t  RandFloat( int(\n\t\t\t\t\t\t\t\t\t  sign*(r + time * .5)*10.\n\t\t\t\t\t\t\t\t\t  ) )\n\t\t\t\t\t\t\t\t  , 1., to_dark_2 ) ),\n\n\t\t\t\t\t\t\t  sinft( .0, 1.5, time ) * sp_2 * r );\n\t\t/**/\n\n\n\n#endif\n\t\treturn true;\n\t\t//line.color_eye = vec3(t_eye);\n\t}\n    return false;\n#endif\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n//###################################################\n    \n\tuv.x *= resolution.x / resolution.y;\n\n\tuv += d_uv;\n\tuv *= scale;\n    \n\tLine line_c = setLine( uv ); \n    Line line_l = setLine(uv, line_c.id - 1. );\n\tLine line_r = setLine(uv, line_c.id + 1. );\n\tfloat id2 = line_c.id;\n\tfloat t_s1 = line_c.c_pos;\n\tfloat t_s2 = line_r.c_pos;\n   \n    bool hasEye = get_eye( line_c,line_c, uv );\n    color += line_c.color_eye;\n  \n\tif (uv.x < line_c.c_pos)\n\t{//l - c\n\t\tid2 = line_l.id;\n\t\tt_s1 = line_l.c_pos;\n\t\tt_s2 = line_c.c_pos;\n\n\t\thasEye = hasEye || get_eye(line_l, line_l, uv );\n\n\t\tcolor += line_l.color_eye;\n        \n\t\tt_s1 += line_l.eye_fr;\n\t\tt_s2 += line_c.eye_fl;\n\n\t}\n\telse\n\t{\n\t\t// c - r\n\t\thasEye = hasEye || get_eye(line_r, line_r, uv );\n\n        color += line_r.color_eye;\n        \n\t\tt_s1 += line_c.eye_fr;\n\t\tt_s2 += line_r.eye_fl;\n\t}\n\n\t\n\tfloat pct = smoothstep( t_s1, t_s2, uv.x );\n\t//color lines\n    //pct - bw gradient from the center (transition saturation here)\n\tpct = pow( 1.760*pct*(1.0 - pct), 1.1 );//0.376 );\n\t\t\t\t\t\t\t\t\t\t\t//pct = 1.-pct;\n\t\t\t\t\t\t\t\t\t\t\t///______________________\n                                            //gradient color type\n    \n    //first option\n\tvec3 ret_col1 = vec3(pct);\n#if 1    // makes lines colored\n\t{\n#define gen_col(val) VFx_t01( id2 + pct * uv.y + (val), (val) + uv.y + time + floor(pct*60.), id2)\n\t\tfloat r = gen_col( 0.450 );\n\t\tfloat g = gen_col( 1.3445 );\n\t\tfloat b = gen_col( 2.021 );\n\t\tret_col1 += (vec3( r, g, b )*pct) / (-.25888) + pct;\n\t\tret_col1 += hsb2rgb( vec3(\n\t\t\tRandFloat( int(\n\t\t\t(id2*10.0001 + pct * 3. + time * .1) / .1\n\t\t\t\t) ) + fract( time*.2 )\n\t\t\t, 1., pct ) );\n\t}\n\n//second)\n    vec3 ret_col2 = vec3(.0);\n\t{\n        //bw gradient multiply it and move it over time\n\t\t//float iterations =  pct*10. + u_time*-.5;//original\n\t\tfloat iterations = pct * (100.*sinft( .5, 1., time ) + RandFloat( int( id2 ) )) + time * -.5;\n\t\tfloat pct2 = iterations - floor( iterations );\n\t\t//_____\n\t\tconst int recursionCount = 5;\n\t\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t\t\tret_col2 = CombinePixelColor( recursionCount, ret_col2, pct2, int( iterations + id2 * time ), r );\n\t\t//original\n\t\t//new_color =  FinishPixel(new_color, uv);\n\n\t\t//color.x += 0.02*u_time;\n\t\t//return HsvToRgb(color);\n\n\t\tret_col2.x += time * .5;\n\t\tret_col2 = HsvToRgb( ret_col2 );\n\t}\n    if(!hasEye){\n\t\tcolor = mix(ret_col1,ret_col2,sinft(.0,\n                                            //3. * sinft(.125,1.,time)\n                                            1.\n                                            ,time));\n        //color = vec3(pow(.5,1.-pct));\n        //color =  ret_col2;\n    }\n    //else color = vec3(1.);\n    \n#else\n    color = vec3(pct);\n#endif\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVBzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[233, 233, 264, 264, 295], [296, 296, 327, 327, 358], [359, 359, 416, 416, 458], [459, 459, 516, 516, 558], [560, 560, 586, 586, 638], [639, 639, 661, 661, 702], [704, 704, 731, 731, 906], [908, 908, 933, 933, 1069], [1071, 1104, 1146, 1171, 1569], [1571, 1571, 1614, 1614, 1649], [1651, 1651, 1684, 1684, 1934], [2736, 2736, 2777, 2777, 2975], [2977, 2977, 3005, 3005, 3097], [3099, 3099, 3140, 3140, 3202], [3204, 3380, 3452, 3452, 3635], [3637, 3637, 3728, 3728, 4087], [4089, 4089, 4130, 4147, 4199], [4264, 4264, 4323, 4323, 8819], [8824, 8824, 8881, 8932, 11680]], "test": "untested"}
{"id": "NtKBRd", "name": "Hilbert curve morphed 7", "author": "FabriceNeyret2", "description": "how could we interpolate more smoothly the curve betweel levels ?", "tags": ["morphing", "short", "filling", "hilbertcurve"], "likes": 33, "viewed": 271, "published": 3, "date": "1665068177", "time_retrieved": "2024-07-30T16:27:53.016065", "image_code": "// variant of https://shadertoy.com/view/XtjXW3\n\n//#define interp(l0,l1,t)        mix(l0,l1, t ) \n  #define interp(l0,l1,t)  sqrt( mix(l0*l0,l1*l1, t ) )\n//#define interp(l0,l1,t)     1./mix(1./l0,1./l1, t ) \n//#define interp(l0,l1,t)   pow( mix(pow(l0,10.),pow(l1,10.), t ), .1 ) \n//#define interp(l0,l1,t)   pow( mix(pow(l0,.1),pow(l1,.1), t ), 10. ) \n//#define interp(l0,l1,t)   log( mix(exp(l0),exp(l1), t ) ) \n  \n#define plot(U,l) ( dot(U,l) > 0.  ? abs( dot(U , vec2(-l.y,l.x)) ) : 0. )  // segment\n#define plotC(U,l)  abs( length( U - (l)/2. ) - .5 )                        // arc\n\nvoid iter( inout vec2 U, inout vec2 l, inout vec2 r ) {\n        vec2 I = vec2(1,0), J = vec2(0,1), k,\n           fU = step(.5,U);                                                 // select child\n        bvec2 c = bvec2(fU);     \n        U = 2.*U - fU;                                                      // go to new local frame\n        l = c.x ? c.y ? -J : -I                                             //   node left segment\n                : c.y ?  l :  J;\n        r =  c.x==c.y ?  I : c.y ?-J:J;                                     //   node right segment\n                                                                            // the heart of Hilbert curve : \n        if (c.x) { U.x = 1.-U.x;  l.x=-l.x;  r.x=-r.x;  k=l;l=r;r=k; }      //   sym\n        if (c.y) { U   = 1.-U.yx; l  =-l.yx; r  =-r.yx; }                   //   rot+sym\n}\n\nvoid mainImage( out vec4 O,  vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = u/R.y - vec2(.3,0) + 1e-5, // or bug at depth 2. why ?\n          P = vec2(.5), l = vec2(-1,0), r=l;\n    float T = 2.*ceil( log2(R.y)-3. ), t = mod(iTime,T ), l0,l1; \n    t = min(t, T-t);\n    \n    for (float i=0.; i < t; i++)\n         iter(U,l,r);\n     // Shane: dot(l,r)==0.\n    l0 = length(l+r) > 0. ? plotC (U-P, l+r) :  plot (U-P, l) + plot (U-P, r); // curve at lod n & n+1\n    iter(U,l,r);\n    l1 = length(l+r) > 0. ? plotC (U-P, l+r) :  plot (U-P, l) + plot (U-P, r); \n    \n   \n    P = min(U,1.-U);                                                           // clamp \n    O = vec4(   smoothstep( 1.5, -1.5, ( interp(l0,l1,fract(t)) -.33 ) *.5*R.y/exp2(t) )  // draw\n // O = vec4(   smoothstep( 3., 0., ( mix(vec4(l0),vec4(l1),vec4(0,1,fract(t),0) ) -.1 ) *.5*R.y/exp2(t) ) \n // O = vec4(   smoothstep( 3., 0., abs( mix(vec4(l0),vec4(l1),vec4(0,1,fract(t),0) ) -.33 ) *.5*R.y/exp2(t) ) \n              * step( 0., min(P.x,P.y)  )\n            );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtKBRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[589, 589, 644, 644, 1434], [1436, 1436, 1475, 1475, 2469]], "test": "untested"}
{"id": "NtKBzt", "name": "Buffer Reflection Test", "author": "SnoopethDuckDuck", "description": "wanted it to look like water with reflection, maybe it's too subtle", "tags": ["buffer"], "likes": 4, "viewed": 162, "published": 3, "date": "1665066222", "time_retrieved": "2024-07-30T16:27:54.076230", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    col = 2.2 * pow(col, vec3(1.6)); \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y; \n    col *= exp(-abs(uv.x));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 f)\n{\n    vec3 col = vec3(0); // probably dont need\n    col = cell(ivec2(f)).rgb;\n    vec2 uv = (f - 0.5 * iResolution.xy) / iResolution.y;\n    float xp = exp(-0.25 * iTime);\n    float xp2 = exp(-0.125 * iTime);\n    \n    for (float i = 0.; i < 6.; i++) {\n        vec2 p = vec2(h21(vec2(iTime, 0.1 + i)) * 2. - 0.5, \n                      h21(vec2(0.2 * iTime, -5.1 + i)));\n        p -= 0.5;\n        float ns = fnoise(vec2(p.x, p.y/uv.y) + 0.01 * iTime, 4.);\n        vec2 q = p + 0.2 * xp * vec2(cos(pi * ns), sin(pi * ns));\n        float d = seg(uv, p, q);\n        float s = xp2 * exp(-100. * (1.-xp) * d);\n        \n        vec3 pl = pal(2. * ns + 0.12 * iTime, 0.5 * vec3(0,1,2)/3.);\n        float v = smoothstep(-0.1, 0.1, -p.y);\n        pl *= mix(v, 1., 1.-xp);\n        pl *= exp(-3. * xp * abs(p.y));\n        col = mix(col, pl, s * (1.-xp));    \n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// everything under here is from iq\nfloat seg(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n//https://www.shadertoy.com/view/XdXGW8\nvec2 grad(ivec2 z) {\n    int n = z.x+z.y*11111;\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) : gr;                            \n}\n\nfloat noise(in vec2 p) {\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fnoise(vec2 uv, float sc) {\n    float f = 0.;\n\tuv *= sc;\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n\tf  = 0.5000 * noise(uv); uv = m * uv;\n\tf += 0.2500 * noise(uv); uv = m * uv;\n\tf += 0.1250 * noise(uv); uv = m * uv;\n\tf += 0.0625 * noise(uv); uv = m * uv;\n\treturn 0.5 + 0.5 * f;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtKBzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 286]], "test": "untested"}
{"id": "NlKfzV", "name": "Hilbert Curve Animation", "author": "Shane", "description": "Combining the indexed cells and fractional cell coordinates of a standard Hilbert curve in order to produce a smooth continuous animation that runs the length of the curve.", "tags": ["curve", "hilbert"], "likes": 70, "viewed": 585, "published": 3, "date": "1665064201", "time_retrieved": "2024-07-30T16:27:55.098496", "image_code": "/*\n\n    Hilbert Curve Animation\n    -----------------------\n    \n    Rendering a Hilbert curve is one of those graphics programming cliches that\n    I'm fond of, so I've been meaning to put one up for a while. Thanks to IQ's\n    cool \"Linear To Hilbert\" example, Hilbert curves are back in vogue, so I \n    figured it was as good a time as any to jump on the bandwagon. :) I have more \n    interesting examples coming, but I wanted to start with something relatively \n    simple.\n    \n    If you're confortable with subdividing and rotating space in a fractal fashion,  \n    then coding one won't be difficult. There are several different methods out \n    there, and each have their merits. I needed to render a smoothly paramaterized \n    curve inside a raymarching loop, which meant I had to at least attempt to use \n    a quick routine.\n    \n    The method utilized here is very similar to the way in which Fabrice Neyret\n    does it. The process essentially involves subdividing, splitting the resultant \n    space into quadrants, making predetermined decisions for each quadrant, then \n    repeating for the desired number of iterations. The decision making itself is \n    pretty straight forward -- For example, if the coordinate is in the bottom \n    right quadrant, rotate then flip along the X-axis, etc. I find the process is \n    best explained in the article, \"Hilbert Curve Coloring\", which I've provided a \n    link to below. I've provided a brief explanation in the code also.\n    \n    Most of the code is dressing up. The Hilbert curve procedure itself doesn't \n    take up much room at all -- In fact, when I have time, I will put together a \n    very simple version to accompany this. I have an extruded raymarched shader \n    that I'll post pretty soon. After that, I'd like to post a proper 3D version.\n\n\n    \n    \n    References and other examples:\n    \n    // In order to understand the basic Hilbert curve algorithm, this is my\n    // preferred source.\n    Tutorial: Hilbert Curve Coloring - Kerry Mitchell\n    https://www.kerrymitchellart.com/tutorials/hilbert/hilbert-tutorial.html\n    \n    // Here is a simpler version using roughly the same algorithm that I'm using.\n    // Fabrice uses a different initial orientation that allows for more \n    // streamlined code.\n    Hilbert curve 5 - FabriceNeyret2\n    https://www.shadertoy.com/view/XtjXW3\n\n    // The idea to parameterize then animate the curve came from DjinnKahn's\n    // example, below, which is well worth a look, if you haven't seen it already.\n    // I was too lazy to read through the code, so I'm not sure how our methods\n    // compare, but they do the same thing, so I'll assume they're similar. :)\n    Sierpinski + Hilbert fractal - DjinnKahn\n    https://www.shadertoy.com/view/ft3fR4\n    \n    // Dr2 has a few Hilbert curve related examples on here. This one is\n    // his latest effort.\n    Hilbertian Saltation - dr2\n    https://www.shadertoy.com/view\n    \n    // Really fun to watch.\n    Linear To Hilbert - iq\n    https://www.shadertoy.com/view/llGcDm\n\n*/\n\n// The number of Hilbert curve iterations. I designed everything to work with the\n// number 5. However, values 3 to 6 will look OK. Numbers outside that range \n// haven't been accounted for.\nconst int iters = 5;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// IQ's unsigned line distance formula.\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n\n\n// Arc distance formula.\nfloat dist(vec2 p){\n\n   \n    // Circular.\n    return length(p);\n    \n    // Hard square edge.\n    //p = abs(p);\n    //return max(p.x, p.y);\n    \n    // Rounded square.\n    //p = abs(p) - .015;\n    //return min(max(p.x, p.y), 0.) + length(max(p, 0.)) + .015;\n    \n    // Diamond and octagon.\n    //p = abs(p);\n    //return abs(p.x + p.y)*.7; // Requires readjusting in the arc function.\n    //return max(max(p.x, p.y), abs(p.x + p.y)*.7);\n}\n\n\n// A standard Hilbert curve routine with some extra parameterization hacked\n// in at the end. It needs some tidying up, but it works pretty fast, all \n// things considered. I've taken an approach that's very similar to Fabrice's\n// example, here: \n//\n// Hilbert curve 5 - FabriceNeyret2\n// https://www.shadertoy.com/view/XtjXW3\n\n// Fabrice's started with a different orientation, which has led to slightly\n// neater logic, which I might try to incorporate later.\nvec4 hilbert(vec2 p){ \n\n    // Hacking in some scaling.\n    float hSc = iResolution.y/iResolution.x*2.1;\n    // If you scale the coordinates, you normally have to scale things back\n    // after you've finished calculations.\n    p *= hSc; \n    \n    // Saving the global coordinates prior to subdivision. I'm not experiencing\n    // alignment glitches, but I'm using Fabrice's hack, just to be on the safe side. :)\n    vec2 op = p + 1e-4; \n    \n    // Initial scale set to one.\n    float sc = 1.;\n    \n    // Cell ordering vector -- Clockwise from the bottom left. If the new partitioned\n    // frame is flipped, then this will be also.\n    ivec4 valC = ivec4(0, 1, 2, 3);\n    \n    // Initate to top left quadrant cell.\n    int val = 1;\n    \n    p = op; // Initialize.\n    \n    // Splitting the curve block into two. There's no real reason for doing this,\n    // but I thought it filled the canvas dimensions a little better... Plus, I\n    // like to complicate things for myself. :)\n    if(p.x<0.) p.x = abs(p.x) - .5; // Left half -- Moved to the left.\n    else { p.x = .5 - abs(p.x); p = -p.yx;  } // Right half -- Moved right and rotated CCW.\n    \n    p = fract(p + .5); // Needs to begin in the zero to one range.\n    p *= vec2(-1, 1); // Not absolutely necessary, but we're forcing the top left quadrant split.\n    \n    // The horizontal and vertical vectors. I've adopted Fabrice's naming\n    // convention (i and j), but have stored them in one vector.\n    vec4 ij = vec4(1, 0, 0, 1), d12 = ij; //vec4(ij.xy, -ij.zw);\n \n    int rn = 0; // Cell number.\n   \n    float dirX = 1.; // Hacked in to keep track of the left or right of the curve.\n    \n    for(int i = min(0, iFrame); i<iters; i++){\n       \n       \n        // The quadrant splitting logic:\n        // Bottom left: Rotate clockwise. Leave the first direction alone. The second points up.\n        // Top left: Leave the space untouched. First direction points down. Second points right.\n        // Top right: Flip across the X-axis. First direction points left. Second points down.\n        // Bottom right: Rotate clockwise then flip across the X-axis. First points up. Second left alone.\n        \n        if(p.x>0.){\n            // You need to reverse the rendering order of the two right cells.\n            // In other words, swap(dir1, dir2);\n            if(p.y>0.){ d12 = -ij; p.x = -p.x;  d12.xz = -d12.xz; val = 2; } // Top right.\n            else { d12.xy = ij.zw;  /*d12.xy = ij.zw;*/ \n                 p = p.yx*vec2(1, -1); d12 = d12.yxwz*vec4(1, -1, 1, -1); \n                 dirX *= -1.; val = 3; // Bottom right  (Exit).\n            } \n\n            // Flip vector directions on the right -- You could incorporate this into the\n            // lines above, if you wanted to.\n            d12 = d12.zwxy; \n          \n            valC = valC.wzyx; // Reverse rendering order direction in the right quadrants.\n            \n\n        }\n        else {\n        \n            if(p.y>0.){ d12 = vec4(-ij.zw, ij.xy); val = 1; } // Top left.\n            else { /*d12.xy = -ij.zw;*/ d12.zw = ij.zw; p = p.yx; d12 = d12.yxwz; \n                 dirX *= -1.; val = 0; // Bottom left (Entry).\n            }  \n          \n        }\n        \n        // Ordering the cells from start to finish -- There's probably a smarter way,\n        // but this is what I came up with at the time. It works, so it has that \n        // going for it. :)\n        //\n        // The new quadrant value, after splitting, rotating, flipping, etc, above.\n        int valN = p.x<0.? p.y<0.? 0 : 1 : p.y<0.? 3 : 2; \n        // Number of squares per side for this iteration.\n        int sL = 1<<(iters - i - 1); // 1, 2, 4, 8, etc.\n        // Position number multiplied by total number of squares for each iteration.\n        rn += valC[valN]*sL*sL;\n       \n        // Subdivide and center.\n        p = mod(p, sc) - sc/2.;\n        sc /= 2.;\n        \n\n   \n    }\n\n    \n    // Square dimension. I.e. Number of blocks on the side of the square.\n    float sL = float(1<<(iters - 1));\n \n   \n    // The distance field value.\n    float d = 1e5;\n    \n    // If a swap occurred, swap the rendering order of dir1 and dir2.\n    //if(valC[val] != val) d12 = d12.zwxy;\n \n   \n    // If a swap has occurred, reverse direction.\n    float dir = valC[val] != val? -1. : 1.;\n    \n    \n    float crvLR = 4./3.14159265; //Curve length ratio.\n    \n    // The two direction vectors in this cell are perpendicular. \n    // Therefore, calculate the arc distance function and coordinates.  \n    // Otherwise, the direction vectors are aligned, so calculate\n    // the line portion.\n    //\n    // By the way, for those who don't know, curvy line coordinates are\n    // similar to 2D Euclidean plane coordinates. However, the X value runs \n    // along the curve and the Y value is perpendicular to the curve.\n    //\n    if(dot(d12.xy, d12.zw) == 0.){\n        \n        // Arc distance field and the conversion of 2D plane coordinates\n        // to curve coordinates.\n        \n        // Using the perpendicular direction vectors to center the arc.\n        p -= (d12.xy + d12.zw)*sc;\n        \n        // Pixel angle.\n        float a = atan(p.x, p.y); \n       \n        p.y = dist(p) - sc; // The Y coordinate (centered arc distance).\n        \n        d = abs(p.y); // Distance field value.\n        \n        p.x = fract(dir*a/6.2831853*4.); // The X coordinate (angle). Order counts.\n        \n        // Hacky distortion factor at the border of the line and arcs.\n        //crvLR = mix(1.,  crvLR, 1. - p.x);\n    }\n    else { \n     \n        // Line distance field and curve coordinates. \n        \n        d = distLine(p, d12.xy*sc, d12.zw*sc); // Line distance (overshooting a bit).\n        p.x = fract(dir*p.x*sL - .5); // Straight line coordinate.\n        // p.y remains the same as the Euclidean Y value.\n        \n        // Hacky distortion factor at the border of the line and arcs.\n        crvLR = mix(1., crvLR, smoothstep(0., 1., abs(p.x - .5)*2.));\n        //crvLR = 1.;\n    }\n    \n   \n    // Using the current ordered cell value, the total number of cells and\n    // the fractional curve cell value to calculate the overall ordered position\n    // of the current pixel along the curve.\n    float hPos = (float(rn) + p.x)/(sL*sL);\n  \n    // Getting rid of curves, etc, outside the rectangle domain.\n    if(abs(op.x)>1. || abs(op.y)>.5){ d = 1e5; p = vec2(1e5); }\n    \n    // Handling (hacking) the entry and exit channels separately.\n    if(op.y>.5){ \n        d = min(d, distLine(op - vec2(.5/sL, 0), vec2(0), ij.zw*4.)); hPos = 1. + (op.y - .5)/(sL); \n        p.x = fract(op.y*sL); // Angle for this channel.\n        crvLR = mix(1., crvLR, smoothstep(0., 1., abs(p.x - .5)*2.));\n        p.y = (op.x - sc)*dirX;\n        \n    }\n    if(op.y<-.5){ \n        d = min(d, distLine(op - vec2(-1. + .5/sL, 0), vec2(0), -ij.zw*4.)); hPos = (op.y + .5)/(sL); \n        p.x = fract(op.y*sL); // Angle for this channel.\n        crvLR = mix(1., crvLR, smoothstep(0., 1., abs(p.x - .5)*2.));\n        p.y = -(op.x + (1. - sc))*dirX;\n        \n    }\n    \n    \n    // The curve coordinates -- Scaled back to the zero to one range.\n    p = vec2((p.x - .5)/sL/crvLR, p.y*dirX);\n\n    // Line thickness.\n    d -= .2/pow(1.6, float(iters));\n\n    // Accounting for the left and right Hilbert curve blocks.\n    if(op.x<0.){ hPos = 1. - fract(-hPos); p.y *= -1.; }\n    \n    // Return the distance field, curve position, and curve coordinates.\n    return vec4(d/hSc, hPos, p/hSc);\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Aspect corret coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    // Scale and smoothing factor.\n    const float sc = 1.;\n    float sf = sc/iResolution.y;\n    \n    \n    // Scaling and translation.\n    vec2 p = sc*uv;// + vec2(2, 1)*iTime/16.;\n    \n    // Scene field calculations.\n    \n    // Light direction. Shining down and to the left.\n    vec2 ld = normalize(vec2(-1.5, -1));\n    \n    \n    // Object shadow.\n    vec4 dSh = hilbert(p - ld*.04);\n    \n    // Hightlight pass.\n    vec4 d2 = hilbert(p - ld*.003);\n    \n    // Scene object.\n    vec4 d = hilbert(p);\n    \n    // Using the two samples to produce some directional derivative based highlighting.\n    float b = max(d2.x - d.x, 0.)/.003;\n    float b2 = max(d.x - d2.x, 0.)/.003; // Reverse, for fake reflective light.\n    //b = pow(b, 2.);\n\n\n    // Background.\n    vec2 ldUV = rot2(atan(-ld.x, ld.y))*uv;\n    vec3 bg = mix(vec3(.92, .97, 1), vec3(.55, .7, 1), smoothstep(0., 1., ldUV.y*.35 + .5));\n    \n    // Scene color -- Set to the background.\n    vec3 col = bg;\n    \n    // Adding subtle lines to the background.\n    const float lnSc = 60.;\n    vec2 pUV = rot2(-3.14159/4.)*p; \n    float pat = (abs(fract(pUV.x*lnSc) - .5)*2. - .5)/lnSc/2.;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, pat))*.05);\n    \n    //b2 = mix(b2*.25, b2*1.25, smoothstep(0., sf, pat));\n    //b = mix(b*1.25, b*.25, smoothstep(0., sf, pat));\n \n   \n    // Number of trails per Hilbert pattern block -- so six altogether.\n    const float N = 3.;\n    float sL = float(1<<(iters - 1)); // Block side length.\n    float tm = iTime*sL/2.; // Movement.\n    float crvL = sL*sL; // Block curve unit length.\n    \n    // The coordinates from the curves frame of reference.\n    // X runs the entire length of the curve block, then wraps.\n    // Y is simply the perpendicular coordinates with zero in the middle of the curve.\n    vec2 tuv = d.yw;\n    \n    // The curve color.\n    vec3 oCol = bg;\n    // Color one side of the curve.\n    //vec3 oCol = tuv.y<0.? bg : pow(bg.zyx, vec3(3));\n    \n    // Applying the bump highlighting to the curve color.\n    oCol = min(oCol*(.45 + b*b*.75 + vec3(.5, .7, 1)*b2*.2), 1.5);\n    vec3 svCol = oCol; // Saving the original.\n    \n    \n    // Repeating space N times along a moving curve.\n    // The value, stF, is a stretch factor relating to polar coordinate conversion.\n    float stF = 4.;\n    float cellID = floor(fract(tuv.x + tm/crvL)/( 1./N)); \n    float offsX = (hash21(vec2(cellID + 1., 1.23)) - .5)/N/4.;\n    tuv = (mod(tuv + tm/crvL + offsX, 1./N) - .5/N)*stF;\n    \n    // Constructing a moving tip with a trail behind it.\n    float trailL = 1./4./N*stF;\n    float trail = abs(tuv.x) - trailL;\n    float trailEnd = abs(tuv.x + (trailL + trailL/16.)) - trailL/16.;\n    // Trail fade -- You could make this solid, if you wanted.\n    float trailF = clamp((abs(tuv.x + trailL))/(trailL*2.), 0., 1.); \n    trailF = trailF*.95 + .05;\n    //float trailF = .1; \n   \n    // Trail tip color.\n    vec3 tCol = svCol.z*mix(vec3(1, .1, .4), vec3(1, .4, .1), -uv.y*.5 + .5);\n\n    // Applying the trail layers.\n    //\n    oCol = mix(oCol, svCol*trailF, 1. - smoothstep(0., sf, trail)); // Trail layer.\n    // Alternative colored trail -- Comment in the above line first. \n    //vec3 trC = mix(svCol*tCol/6., svCol, trailF);\n    //oCol = mix(oCol, trC, 1. - smoothstep(0., sf, trail)); // Trail layer.\n    oCol = mix(oCol, vec3(0), 1. -  smoothstep(0., sf, trailEnd)); // Dark trail end layer.\n    oCol = mix(oCol, tCol*2., 1. - smoothstep(0., sf, trailEnd + .04/sL)); // Trail end layer.\n    \n    // Rendering onto the background.\n    //\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., dSh.x))*.35); // Shadow.\n    //\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., d.x))*.35); // AO.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.x))*.95); // Edge, or strke.\n    col = mix(col, oCol, 1. - smoothstep(0., sf, d.x + .005)); // Top layer.\n    \n    /* \n    // Dashes moving in opposite directions. Interesting, but a little much.\n    float sc2 = float(1<<(iters - 3))*3.;\n    float lns = (abs(fract(d.y*sc2*32. - (d.w<0.? -1. : 1.)*tm/8.) - .5) - .25)/32.;\n    col = mix(col, col*.35, 1. - smoothstep(0., sf, max(abs(abs(d.w) - .0055), lns) - .005/3.));\n    */\n    \n   \n    /*\n    // Experiment with segmenting cells and applying random coloring.\n    stF = float(1<<(iters - 3))*3.;\n    float scl = 1./3.;// 1./6.\n    tuv = d.yw;\n    tuv.x += tm/crvL + 1./stF*1. + offsX - 4./crvL;\n    cellID = floor(fract(tuv.x)/scl); \n    tuv.x = (mod(tuv.x, scl) - scl/2.)*stF;\n    //float cObj = length(tuv) - float(1<<(iters - 3))*.85/crvL;\n    float cObj = max(abs(tuv.x) - 4./crvL*stF, abs(tuv.y) - 2./crvL); //length(tuv) - 2.5/crvL;\n    float crvTime = -iTime*(d.y<0.? -1. : 1.);\n     \n    float rnd = hash21(vec2(cellID, 1));\n    vec3 cCol = .5 + .45*cos(6.2831*rnd/2. + vec3(1, 0, 2)*1.5);\n    cCol *= .5 + b*b*.75;\n    //if(mod(cellID, 2.)>.5) cObj = 1e5;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, cObj)); // Edge, or strke.\n    col = mix(col, cCol, 1. - smoothstep(0., sf, cObj + .005)); // Edge, or strke.\n    */\n    \n   \n    // Rough gamma correction and screen plot.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKfzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3269, 3302, 3324, 3324, 3382], [3384, 3412, 3433, 3433, 3496], [3499, 3539, 3578, 3578, 3679], [3682, 3707, 3726, 3748, 4146], [12072, 12072, 12129, 12163, 17380]], "test": "untested"}
{"id": "7tGfzd", "name": "drunk Sierpinski triangle", "author": "FabriceNeyret2", "description": "inspiration ( but going further :-p ):   [url] https://twitter.com/CmonMattTHINK/status/1577340119870316544  [/url]\nuncomment line #13 to get the original shape.", "tags": ["sierpinski", "short", "reproduction", "sierpinsky"], "likes": 16, "viewed": 352, "published": 3, "date": "1665046090", "time_retrieved": "2024-07-30T16:27:55.907334", "image_code": "// variant of https://shadertoy.com/view/7tGBzd\n\n#define H(p)         fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n//#define H2(p)      fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define cross(a,b) ( (a).x*(b).y - (a).y*(b).x ) \n\nfloat line(vec2 p, vec2 a,vec2 b) {                   // --- distance to line\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    return length(p - b * h);                         // dist to segment\n}\n\n//#define mid(A,B)  (A+B)/2. + .24* ( H((A+B)/2.) -.5 ) *(B-A)        // repro the original\n  #define mid(A,B)  (A+B)/2. + .24* ( H((A+B)/2.) -.5 ) *length(A-B)  // cheap diagonal jittering\n                  // midpoint      jittering\n//#define mid(A,B)  (A+B)/2. + .2* ( H2((A+B)/2.) -.5 ) *length(A-B)  // full 2D jittering\n\nvoid mainImage(out vec4 O, vec2 u) {\n     vec2  R = iResolution.xy,\n           U = ( u - .5*R ) /R.y + vec2(.5,.4),  \n           A = vec2(0), B = vec2(1,0), C = vec2(.5,.87), D,E,F;\n\n     for (int i=0; i < int(log2(R.y))-2; i++ ) { // --- fractal loop\n         D = mid(A,B), E = mid(A,C), F = mid(B,C);\n         float a = cross(U-F,A-F), b = cross(U-E,B-E), c = cross(U-D,C-D);\n           a > 0. && b < 0. ? A = E, B = F       // fractal recursion: 3 branches\n         : c > 0.           ? A = D, C = F\n         :                  ( B = D, C = E );\n    }  \n\n    float l = min(min( line(U,A,B),              // triangle\n                       line(U,A,C) ),\n                       line(U,B,C) );\n    O = vec4( sqrt( smoothstep(1./R.y,0.,l ) ) );\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGfzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[259, 259, 294, 336, 507], [836, 836, 872, 872, 1582]], "test": "untested"}
{"id": "stGBzd", "name": "Squaring the Torus (400 chars)", "author": "FabriceNeyret2", "description": "golfing 1440 chars \"Squaring the Torus\" by jt. [url] https://shadertoy.com/view/7lyfzK  [/url]\n", "tags": ["simple", "torus", "torus", "square", "tileable", "order", "short", "24", "golf", "golfing", "3tweets", "perfect", "squared", "squaring", "181", "gambini"], "likes": 10, "viewed": 320, "published": 3, "date": "1665040282", "time_retrieved": "2024-07-30T16:27:56.762048", "image_code": "// golfing 1440 chars \"Squaring the Torus\" by jt. https://shadertoy.com/view/7lyfzK\n\n\nvoid mainImage( out vec4 O, vec2 U ) { \n    O *= 0.;                     \n    for( int n = 0; n < 23; n++ ) {\n        ivec2 i = ivec2( mod( U-iMouse.xy                                                                          // squares:\n                             -vec2( int[](93,95,93,61,19,166,165,148, 0,95,71,93,71,  0,61,-15,148,30,19,118,98,98,  0)[n], // x\n                                    int[](75,98,45,77,87,49 ,33 ,33 ,45,75,77,50,101,98,45, 64,  0,87,45, 50, 0,98,-53)[n]  // y\n                            ) ,181.) ); \n        i *= i -                    int[]( 2, 3, 5,10,11,15, 16, 17, 19,23,24,25, 27,30,32, 34, 33,41,42 ,48,50,83, 98)[n]; // s\n        i.x < 0 && i.y < 0 ? O = .8 + .2 * cos( vec4(n,n+23,n+21,n) +3. ) : O;\n    }\n}\n\n\n\n\n\n\n/** // 409 chars\n\nvoid mainImage( out vec4 O, vec2 U ) {      //  square: ( x , y )  s\n    int[] C = int[](  93, 75 ,  2 ,     95, 98 ,  3 ,    93, 45 ,  5 ,     61, 77 , 10 ,\n                      19, 87 , 11 ,    166, 49 , 15 ,   165, 33 , 16 ,    148, 33 , 17 ,\n                       0, 45 , 19 ,     95, 75 , 23 ,    71, 77 , 24 ,     93, 50 , 25 ,\n                      71,101 , 27 ,      0, 98 , 30 ,    61, 45 , 32 ,    -15, 64 , 34 ,\n                     148,  0 , 33 ,     30, 87 , 41 ,    19, 45 , 42 ,    118, 50 , 48 ,\n                      98,  0 , 50 ,     98, 98 , 83 ,     0,-53 , 98                     );\n    O *= 0.;                     \n    for( int n = 0; n < 23; n++ ) {\n        ivec2 i = ivec2( mod( U-iMouse.xy -vec2(C[3*n],C[3*n+1]) ,181.) ); \n        i *= i - C[3*n+2];\n        i.x < 0 && i.y < 0 ? O = .8 + .2 * cos( vec4(n,n+23,n+21,n) +3. ) : O;\n    }\n}\n\n\n\n\n\n\n/** // 428 chars   -16\n\n\nivec2 i; float n=3.;\n#define S(X,Y,s)                                                     \\\n    i = ivec2( mod( U-iMouse.xy -vec2(X,Y) ,181.) ), i *= i-s;       \\\n    i.x < 0 && i.y < 0 ? O = .8 + .2 * cos( n + vec4(0,23,21,0)) :O; \\\n    n++;\n    \nvoid mainImage( out vec4 O, vec2 U ) {\n    O *= 0.;\n    S(  93, 75 ,  2 )\n    S(  95, 98 ,  3 )\n    S(  93, 45 ,  5 )\n    S(  61, 77 , 10 )\n    S(  19, 87 , 11 )\n    S( 166, 49 , 15 )\n    S( 165, 33 , 16 )\n    S( 148, 33 , 17 )\n    S(   0, 45 , 19 )\n    S(  95, 75 , 23 )\n    S(  71, 77 , 24 )\n    S(  93, 50 , 25 )\n    S(  71,101 , 27 )\n    S(   0, 98 , 30 )\n    S(  61, 45 , 32 )\n    S( -15, 64 , 34 )\n    S( 148,  0 , 33 )\n    S(  30, 87 , 41 )\n    S(  19, 45 , 42 )\n    S( 118, 50 , 48 )\n    S(  98,  0 , 50 )\n    S(  98, 98 , 83 )\n    S(   0,-53 , 98 )\n}\n\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGBzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "slyfRt", "name": "2D Scalar Wave Equation", "author": "Zi7ar21", "description": "scalar wave equation\n1 unit = 1 pixel\nwarning: the code is messy and I am playing with it, like a sandbox", "tags": ["wave", "equation", "pde"], "likes": 11, "viewed": 278, "published": 3, "date": "1665029254", "time_retrieved": "2024-07-30T16:27:57.711510", "image_code": "// 2D Scalar Wave Equation\n// Made by Jacob Bingham (Zi7ar21) on October 6th, 2022\n// Last updated: still being worked on lol\n\n// Features\n// - Implementation of the 2-dimensional scalar wave equation\n// - high-accuracy central finite differences\n//   - https://en.wikipedia.org/wiki/Finite_difference_coefficient#Central_finite_difference\n\n// You can run multiple timesteps per frame with the Shadertoy Unofficial Plugin\n// You can also copy and paste Buffer A but be weary you may need to make a few modifications to wherever iFrame is used\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    //   red: positive amplitude\n    // green: rate of change\n    //  blue: negative amplitude\n    fragColor = vec4(max( fragColor.x, 0.0), 0.1 * abs(fragColor.y), max(-fragColor.x, 0.0), 1.0);\n\n    //fragColor = vec4(0.5 * vec3(fragColor.x + fragColor.y), 1.0); // greyscale total ampltiude approximation\n\n    //fragColor = vec4(0.5 * vec3(fragColor.r + 1.5 * fragColor.g + fragColor.b), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// timestep\n#define dt 0.0166666666666667\n//#define dt 0.0333333333333333\n//#define dt 0.01\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\nconst float     PI = 3.141592653589793; // Pi\nconst float TWO_PI = 6.283185307179586; // 2 * Pi = \"Tau\"\nconst float INV_PI = 0.318309886183791; // 1 / Pi\n//const float     PI = uintBitsToFloat(0x40490FDBu); // Pi\n//const float TWO_PI = uintBitsToFloat(0x40C90FDBu); // 2 * Pi = \"Tau\"\n//const float INV_PI = uintBitsToFloat(0x3EA2F983u); // 1 / Pi\n\n// pro tip: if you are going to square or compare lengths of vectors, use dot product instead\n// it saves an extra sqrt() operation and improves performance, if the compiler didn't already\n// notice what you were trying to do and optimize it... (spoiler: it probably won't)\n// length(v)^2 = dot(v, v)\nfloat dot2(vec2 v) { return dot(v, v); }\nfloat dot2(vec3 v) { return dot(v, v); }\nfloat dot2(vec4 v) { return dot(v, v); }\n\nfloat sinc(float x) {\n    // definite integral of pi\n    //return x != 0.0 ? sin(x) / x : 1.0; // un-normalized\n\n    // definite integral of 1\n    return x != 0.0 ? sin(PI * x) / (PI * x) : 1.0; // normalized\n}\n\n// Even smoother smoothstep(), see https://en.wikipedia.org/wiki/Smoothstep\nfloat smootherstep(float edge0, float edge1, float x) {\n    x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n\n    return x * x * x * (x * (x * 6.0 - 15.0) + 10.0);\n}\n\n// Repeating texelFetch()\nvec4 texelFetch_repeat(sampler2D _sampler, ivec2 _P, int _lod) {\n    ivec2 _textureSize = textureSize(_sampler, _lod);\n\n    // Broken on every platform I've tried testing, see explanation below\n    //_P.x = _P.x % _textureSize.x;\n    //_P.y = _P.y % _textureSize.y;\n\n    // :sob: as of GLSL 300, the % operator is undefined if one or both input integers are negative\n    // so we blasphemously convert our integers to floats and back and use floating point modulo...\n    // See 12.33: https://registry.khronos.org/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf\n    _P.x = int(mod(float(_P.x), float(_textureSize.x)));\n    _P.y = int(mod(float(_P.y), float(_textureSize.y)));\n\n    return texelFetch(_sampler, _P, _lod);\n}\n\n/*\n*/\n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Modulo 289 without a division (only multiplications)\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\n// Modulo 7 without a division\nvec3 mod7(vec3 x) {\n  return x - floor(x * (1.0 / 7.0)) * 7.0;\n}\n\n// Permutation polynomial: (34x^2 + 6x) mod 289\nvec3 permute(vec3 x) {\n  return mod289((34.0 * x + 10.0) * x);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Standard 3x3 search window for good F1 and F2 values\nvec2 cellular(vec2 P) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 3/7\n#define jitter 1.0 // Less gives more regular pattern\n\tvec2 Pi = mod289(floor(P));\n \tvec2 Pf = fract(P);\n\tvec3 oi = vec3(-1.0, 0.0, 1.0);\n\tvec3 of = vec3(-0.5, 0.5, 1.5);\n\tvec3 px = permute(Pi.x + oi);\n\tvec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n\tvec3 ox = fract(p*K) - Ko;\n\tvec3 oy = mod7(floor(p*K))*K - Ko;\n\tvec3 dx = Pf.x + 0.5 + jitter*ox;\n\tvec3 dy = Pf.y - of + jitter*oy;\n\tvec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n\tp = permute(px.y + Pi.y + oi); // p21, p22, p23\n\tox = fract(p*K) - Ko;\n\toy = mod7(floor(p*K))*K - Ko;\n\tdx = Pf.x - 0.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n\tp = permute(px.z + Pi.y + oi); // p31, p32, p33\n\tox = fract(p*K) - Ko;\n\toy = mod7(floor(p*K))*K - Ko;\n\tdx = Pf.x - 1.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n\t// Sort out the two smallest distances (F1, F2)\n\tvec3 d1a = min(d1, d2);\n\td2 = max(d1, d2); // Swap to keep candidates for F2\n\td2 = min(d2, d3); // neither F1 nor F2 are now in d3\n\td1 = min(d1a, d2); // F1 is now in d1\n\td2 = max(d1a, d2); // Swap to keep candidates for F2\n\td1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n\td1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n\td1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n\td1.y = min(d1.y, d1.z); // nor in  d1.z\n\td1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n\treturn sqrt(d1.xy);\n}\n/*\n*/", "buffer_a_code": "float source_waveform(float t) {\n    return sin(t);\n    //return sin(1.0 * t) + sin(2.0 * t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    if(iFrame < 1) {\n        fragColor = vec4(0);\n\n        //fragColor = vec4(2.0 * sinc(TWO_PI * length(uv - vec2(0.5, 0.0)) * 10.0), 0.0, 0.0, 0.0);\n        //fragColor = vec4(0.5 * texture(iChannel1, fragCoord / 256.0).x, 0.0, 0.0, 0.0);\n        //uv = 40.0 * (uv - vec2(0.5, 0.0));\n        //fragColor = vec4(10.0 * exp(-dot2(uv)), 0.0, 0.0, 0.0);\n        //if(length(uv) < 0.1) fragColor = vec4(0);\n\n        return;\n    }\n\n    // Wave Speed\n    const float c = 10.0;\n    //float c = 5.0 * uv.y + 10.0;\n    //float c = 10.0 - 2.0 * smootherstep(0.0, 1.0, 1.0 - dot(4.0 * uv, 4.0 * uv));\n    //float c = dot2(vec2(8.0, 2.0) * (uv - vec2(0.75, 0.0))) < 1.0 ? 6.5 : 10.0;\n    //float c = 10.0 - 3.5 * smootherstep(1.0, 0.9, dot2(vec2(8.0, 2.0) * (uv - vec2(0.75, 0.0))));\n    //float c = 10.0 - 3.3333333333333333 * smootherstep(1.0, 0.8, dot2(vec2(2.0, 2.0) * uv));\n    //float c = 10.0 - 3.5 * smootherstep(0.8, 0.85, 1.0 - cellular(2.5 * uv).x);\n    //float c = abs(uv.y) < 0.5 && dot2(0.5 * (uv - vec2(1.9, 0.0))) < 1.0 && dot2(0.5 * (uv + vec2(1.9, 0.0))) < 1.0 ? 6.6666666666666667 : 10.0;\n\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // https://en.wikipedia.org/wiki/Finite_difference_coefficient#Central_finite_difference\n\n    /*\n    float x0 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(2, 0), 0).x;\n    float x1 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(1, 0), 0).x;\n    float x2 = texelFetch_repeat(iChannel0, ivec2(fragCoord)              , 0).x;\n    float x3 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(1, 0), 0).x;\n    float x4 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(2, 0), 0).x;\n    float y0 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 2), 0).x;\n    float y1 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 1), 0).x;\n    float y2 = texelFetch_repeat(iChannel0, ivec2(fragCoord)              , 0).x;\n    float y3 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 1), 0).x;\n    float y4 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 2), 0).x;\n\n    float d2x = -(1.0 / 12.0) * x0 + (4.0 / 3.0) * x1 - (5.0 / 2.0) * x2 + (4.0 / 3.0) * x3 - (1.0 / 12.0) * x4;\n    float d2y = -(1.0 / 12.0) * y0 + (4.0 / 3.0) * y1 - (5.0 / 2.0) * y2 + (4.0 / 3.0) * y3 - (1.0 / 12.0) * y4;\n    */\n    /*\n    float x0 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(4, 0), 0).x;\n    float x1 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(3, 0), 0).x;\n    float x2 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(2, 0), 0).x;\n    float x3 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(1, 0), 0).x;\n    float x4 = fragColor.x;\n    float x5 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(1, 0), 0).x;\n    float x6 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(2, 0), 0).x;\n    float x7 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(3, 0), 0).x;\n    float x8 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(4, 0), 0).x;\n\n    float y0 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 4), 0).x;\n    float y1 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 3), 0).x;\n    float y2 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 2), 0).x;\n    float y3 = texelFetch_repeat(iChannel0, ivec2(fragCoord) - ivec2(0, 1), 0).x;\n    float y4 = fragColor.x;\n    float y5 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 1), 0).x;\n    float y6 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 2), 0).x;\n    float y7 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 3), 0).x;\n    float y8 = texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(0, 4), 0).x;\n\n    const float c0 = -(  1.0 / 560.0);\n    const float c1 =  (  8.0 / 315.0);\n    const float c2 = -(  1.0 /   5.0);\n    const float c3 =  (  8.0 /   5.0);\n    const float c4 = -(205.0 /  72.0);\n    const float c5 =  (  8.0 /   5.0);\n    const float c6 = -(  1.0 /   5.0);\n    const float c7 =  (  8.0 / 315.0);\n    const float c8 = -(  1.0 / 560.0);\n\n    float d2x = (c0 * x0) + (c1 * x1) + (c2 * x2) + (c3 * x3) + (c4 * x4) + (c5 * x5) + (c6 * x6) + (c7 * x7) + (c8 * x8);\n    float d2y = (c0 * y0) + (c1 * y1) + (c2 * y2) + (c3 * y3) + (c4 * y4) + (c5 * y5) + (c6 * y6) + (c7 * y7) + (c8 * y8);\n    float lap = d2x + d2y;\n    */\n\n    float lap =\n    ( 0.250 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(-1,  1), 0).x) +\n    ( 0.500 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2( 0,  1), 0).x) +\n    ( 0.250 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2( 1,  1), 0).x) +\n    ( 0.500 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(-1,  0), 0).x) +\n    (-3.000 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2( 0,  0), 0).x) +\n    ( 0.500 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2( 1,  0), 0).x) +\n    ( 0.250 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2(-1, -1), 0).x) +\n    ( 0.500 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2( 0, -1), 0).x) +\n    ( 0.250 * texelFetch_repeat(iChannel0, ivec2(fragCoord) + ivec2( 1, -1), 0).x);\n\n    fragColor.y = fragColor.y + dt * (c * c * lap);\n    \n    fragColor.x = fragColor.x + dt * fragColor.y;\n\n    //fragColor.x += 0.1 * exp(10.0 * -length(uv)) * sin(TWO_PI * length(uv) * 10.0 - dt * 0.1 * float(iFrame));\n\n    //if(uv.x < 0.0 && texture(iChannel1, 0.5 * uv).x < 0.3) fragColor = vec4(0);\n\n    \n    //if(length(uv - vec2(0.76, 0.3)) < 0.06) fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    //if(length(uv - vec2(0.75, 0.3)) < 0.05) fragColor = vec4(sin(1.0 * TWO_PI * mod(dt * float(iFrame), 1.0)), 0.0, 0.0, 0.0);\n    //if(abs(uv.x - 0.75) < 0.05 && abs(uv.y - 0.5) < 0.05) fragColor = vec4(sin(1.0 * TWO_PI * mod(dt * float(iFrame), 1.0)), 0.0, 0.0, 0.0);\n    //if(fragCoord.x > iResolution.x - 30.0 && fragCoord.y > 0.0 && fragCoord.y < iResolution.y - 0.0) fragColor = vec4(sin(mod(1.0 * TWO_PI * dt * float(iFrame), TWO_PI)), 0.0, 0.0, 0.0);\n    //if(fragCoord.x > iResolution.x - 25.0) fragColor = vec4(0);\n\n    //fragColor = mix(dt * vec4(2.0 * sin(TWO_PI * dt * float(iFrame) * 0.1), 0.0, 0.0, 0.0), fragColor, clamp(length(uv - vec2(0.5, 0.0)) / 0.03, 0.0, 1.0));\n\n    //fragColor = mix(fragColor, vec4(5.0 * sin(TWO_PI * dt * float(iFrame) * 1.0), 0.0, 0.0, 0.0), smoothstep(0.05, 0.0, length(uv - vec2(dt * float(iFrame) * 0.015, 0.0))));\n    float th = TWO_PI * fract(TWO_PI * dt * float(iFrame) * 0.01);\n    //fragColor = mix(fragColor, vec4(2.5 * sin(TWO_PI * dt * float(iFrame) * 1.0), 0.0, 0.0, 0.0), smoothstep(0.03, 0.0, length(uv - vec2(dt * float(iFrame) * 0.01, 0.0))));\n    fragColor = mix(fragColor, vec4(5.0 * source_waveform(TWO_PI * dt * float(iFrame) * 1.00), 0.0, 0.0, 0.0), smoothstep(0.05, 0.0, length(uv - 0.05 * vec2(cos(th), sin(th)))));\n    fragColor = mix(fragColor, vec4(5.0 * source_waveform(TWO_PI * dt * float(iFrame) * 1.00), 0.0, 0.0, 0.0), smoothstep(0.05, 0.0, length(uv - 0.05 * vec2(cos(th+1.5), sin(th+1.5)))));\n\n    //if(uv.x > 1.6 && abs(uv.y) < 0.2) fragColor = dt * vec4(2.0 * sin(TWO_PI * dt * float(iFrame) * 0.02), 0.0, 0.0, 0.0);\n\n    // slits\n\n    \n\n    const float r = 20.0; // repetition rate\n\n    //if(abs(fragCoord.x - 0.5 * iResolution.x) < 5.0 && abs(mod((fragCoord.y - 0.5 * iResolution.y) + 0.5 * r, r) - 0.5 * r) < 5.0) fragColor = vec4(0);\n\n\n    // Boundary conditions\n    if(fragCoord.x < 25.0 || fragCoord.x > iResolution.x - 25.0\n    //|| fragCoord.y < 20.0 || fragCoord.y > iResolution.y - 20.0) fragColor = vec4(0); // reflective\n    || fragCoord.y < 25.0 || fragCoord.y > iResolution.y - 25.0) fragColor.xy *= 0.985; // absorbant (not perfect)\n}", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyfRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[544, 544, 599, 599, 1057]], "test": "untested"}
{"id": "styBW1", "name": "The Determined Sphere", "author": "derSchamane", "description": "The search for truth in an infinite reality of apparent chaos...\n\nDrag mouse for camera movement.\nYou can play around with the scene parameters (line 33-35)\n\nsubstance reference: Kratom", "tags": ["raymarching", "sphere", "endless", "heightmap", "infinite", "sand", "desert", "rolling"], "likes": 24, "viewed": 435, "published": 3, "date": "1665015501", "time_retrieved": "2024-07-30T16:27:58.512369", "image_code": "//                  = The Determined Sphere =         \n//                by Maximilian Knape >| 2022            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n\n//   = Raymarching =\n\n#define MAX_STEPS 160\n#define STEP_FAC 0.9\n#define MAX_DIST 300.\n#define MIN_DIST 20.\n\n#define SURF_DIST .001\n#define SURF_MUL 400.\n#define SURF_EXP 1.8\n\n//  = Postprocessing = \n\n#define GAMMA vec3(.4545)\n#define GLOW_INT 0.18\n#define PP_CONT 1.0\n#define PP_VIGN 1.8\n#define AO_OCC 0.2\n#define AO_SCA 0.5\n\n#define AA_ENAB false\n#define AA_THRE .1\n\n// = Scene Parameters =\n\n#define SPH_SIZE 8.     //1..25\n#define SPH_SPEED 13.   //5..50\n#define TER_HEIGHT 3.   //1..5\n\n// --------------------\n\n#define iTime iTime*1.0\n#define PI 3.14159265358979\n#define TAU PI*2.\n#define S(x,y,t) smoothstep(x,y,t)\n#define ROT(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define SLOPE sin(atan(1.,2.2))\n#define TERSIZE 10000.\n\nfloat tOffset = 0.;\nfloat tang = 0.;\n\n\nmat2 Rot(float a) //2D\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n#define Rot2D(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 Rot(vec3 p, vec3 r) //3D - las\n{\n    Rot2D(p.xz, r.y);\n    Rot2D(p.yx, r.z);\n    Rot2D(p.zy, r.x);\n    return p;\n}\n\nfloat hash(float n) { return fract(sin(n)*43758.5453123); } //iq\n\nfloat noise(in vec2 x) //iq\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n    float res = mix(mix(hash(n+  0.0), hash(n+  1.0), f.x),\n                    mix(hash(n+ 57.0), hash(n+ 58.0), f.x), f.y);\n    return res;\n}\n\nfloat noise(in vec3 x) //iq\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix(hash(n+  0.0), hash(n+  1.0), f.x),\n                        mix(hash(n+ 57.0), hash(n+ 58.0), f.x), f.y),\n                    mix(mix(hash(n+113.0), hash(n+114.0), f.x),\n                        mix(hash(n+170.0), hash(n+171.0), f.x), f.y), f.z);\n    return res;\n}\n\nfloat SdBoxFrame( vec3 p, vec3 b, float e ) //iq\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nvec2 MirrorBox(in vec2 p, const float size) { return mod(abs(-mod(p - size, 4.*size) + 2.*size), 4.*size) - size; }\n\nvec2 Dist(vec3 p) \n{       \n    float d, t = iTime*SPH_SPEED + tOffset;\n    \n    //position\n    vec2 coor = MirrorBox(p.xz - vec2(t), TERSIZE);\n    float dis = length(p.xz) / MAX_DIST;\n    \n    //trail\n    float depth = S(SPH_SIZE, 0., max(0., abs(p.x - p.z))) * step(-SPH_SIZE / 2.5, min(p.x, p.z));\n    depth += min((length(p.xz + SPH_SIZE*.1) - SPH_SIZE*.9), 0.) * S(.8, 0., sqrt(depth));\n    float height = min(-depth * SPH_SIZE / 20., SPH_SIZE/TER_HEIGHT);\n    \n    //terrain\n    height += noise(coor / 100.) * 10.;\n    height += noise(coor /  10.) *  1.;\n    height += noise(coor /   1.) *  0.1 * max(-1., 1.-abs(depth));\n    height += S(.2, .1, dis) * noise(MirrorBox(p.xz - vec2(t), 10.) * 10.) * .01 * max(-.5, 1.5-abs(depth));\n    \n    //heightmap\n    d = max(p.y - height*TER_HEIGHT + SPH_SIZE*2., 0.) * SLOPE;\n    \n    //sphere height\n    vec2 sCoor = MirrorBox(-vec2(t), TERSIZE);\n    height  = noise(sCoor / 100.) * 10.;\n    height += noise(sCoor / 10.) * 1.;\n    height -= SPH_SIZE / 16.;\n    \n    //sphere\n    vec3 pos = p - vec3(0., height*TER_HEIGHT - SPH_SIZE, 0.);\n    float sphere = length(pos) - SPH_SIZE;\n    \n    //roll\n    pos = Rot(pos, vec3(length(vec2(iTime*SPH_SPEED + tOffset)) / SPH_SIZE, -PI/4., 0.));\n    \n    //pattern\n    const float ps = 2.;\n    float pat = length((mod(pos,ps)/ps - .5));\n    sphere -= pat * 0.1; \n    \n    //color + material\n    float col = sphere < d ? 2.1 + pat*2.0 : -1.95;\n    d = min(sphere, d);\n\n    /*\n    //ancient ruins\n    vec2 size = vec2(200.);\n    p.xz = MirrorBox(coor, 200.);//mod(abs(-mod(coor, 4.*size) + 2.*size), 4.*size) - size/2.;\n    p = Rot(p, PI*vec3(.015,-0.1,0.01));\n    float box = SdBoxFrame(p-vec3(30., 30., 25.), vec3(130.), 10.);\n    col = mix(0.7, col, step(d, box));\n    d = min(box, d);\n    */\n   \n    return vec2(d, col);\n}\n\nvec3 Normal(vec3 p) \n{\n    vec2 e = vec2(.01, 0);\n    return normalize(Dist(p).x - vec3(Dist(p-e.xyy).x, Dist(p-e.yxy).x,Dist(p-e.yyx).x));\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) \n{\n    float col = 0.;\n\tfloat dO = MIN_DIST;\n    int steps = 0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {\n        steps = i;\n        \n    \tvec3 p = ro + rd*dO;\n        vec2 dS = Dist(p);\n        col = dS.y;\n        dO += dS.x * mix(STEP_FAC, 1., dO/MAX_DIST);\n        \n        if (dO > MAX_DIST || dS.x < (SURF_DIST * (pow(dO/MAX_DIST, SURF_EXP)*SURF_MUL+1.))) break;\n    }\n    \n    return vec3(dO, steps, col);\n}\n\nfloat SoftShadow(vec3 ro, vec3 lp, float k) //Shane\n{\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro;\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end / float(maxIterationsShad);\n    \n    rd /= end;\n\n    for (int i = 0; i < maxIterationsShad; i++)\n    {\n\n        float h = Dist(ro + rd*dist).x;\n        shade = min(shade, smoothstep(0., 1., k*h/dist));\n        dist += clamp(h, .02, .25);\n        \n        if (h < .0 || dist > end) break;\n    }\n\n    return min(max(shade, 0.08) + .1, 1.); \n}\n\n\nfloat GetLight(vec3 p, vec3 n, vec3 lP, vec3 rd , float shine) \n{\n    vec3 l = normalize(lP - p);\n    float dif = S(-0., 1., dot(n, l)*.5+.5) * max(1.-max(-shine, 0.), 0.);\n    if (shine > 0.) dif = mix(dif+.2, dif*.1 + pow(max(dot(l, reflect(rd, n)), 0.), shine*20.), shine);\n    return dif;\n}\n\nfloat CalcAO(const in vec3 p, const in vec3 n) //iq\n{\n    float occ = AO_OCC;\n    float sca = AO_SCA;\n\n    for( int i = 0; i < 5 ; i++ )\n    {\n        float h = .001 + .150 * float(i) / 4.0;\n        float d = Dist(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= .95;\n    }\n    return S(.0, 1. , 1. - 1.5 * occ);    \n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z)\n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 hsv2rgb_smooth( in vec3 c ) //iq\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.0)-1., 0., 1.);\n\trgb = rgb*rgb*(3.0-2.*rgb);\n    \n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 Palette(int index)\n{\n    switch (index)\n    {\n        case 0: return vec3(.5, .5, .5);\n        case 1: return vec3(1., .72, .5);\n        case 2: return vec3(.4, .6, 1.);\n        case 3: return hsv2rgb_smooth(vec3(fract(iTime*TAU/420.+.62), .7, 1.));\n        case 4: return vec3(1., 0.5, .2);\n    }\n    return vec3(0.);\n}\n\nvoid Render( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5 * iResolution.xy) / iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy;\n    if (length(m) <= 0.) m = vec2(.5);\n\n    //cam\n    float t = iTime*SPH_SPEED + tOffset;\n    float xos = -sin(iTime*TAU / 100.) * 20.;\n    vec3 ro = vec3(xos, 30., -SPH_SIZE-40.);\n    ro.yz *= Rot(min(1.5, (m.y+.3)*.3) * PI + PI*.5);\n    ro.xz *= Rot(-m.x * TAU - PI);\n    float height = noise(MirrorBox(vec2(-t), TERSIZE) / 100.) * 10. * TER_HEIGHT;\n    ro.y += height + pow(1.-m.y, 2.) * SPH_SIZE * 8.;\n    vec3 rd = R(uv, ro, vec3(xos, 5. + height, 0.), 1.);\n    \n    //light\n    vec3 lPos = vec3(8, 6, -2) * 1000.;\n    vec3 bg =  Palette(2) * .5;\n    bg = min(bg + pow(1. / (1. + 3.*S(1., -1., dot(normalize(lPos), rd))), 4.)*vec3(1) * .3, 1.); //sky\n    bg += pow(S(.999, 1., dot(normalize(lPos), rd)), 2.); //sun\n    vec3 col = bg;\n    \n    //speed variation\n    tang = mix((noise(MirrorBox(vec2(SPH_SIZE/1. - t), TERSIZE) / 100.) *10.*TER_HEIGHT) - height, tang, .85);\n    tOffset = mix(tOffset - ((tang * SPH_SPEED*.9)), tOffset, 0.1 + SPH_SPEED/50.);\n    \n    vec3 rmd = RayMarch(ro, rd);    \n    \n    if(rmd.x < MAX_DIST) \n    {\n        vec3 p = ro + rd * rmd.x;\n        vec3 n = Normal(p);\n        \n        col = Palette(int(floor(abs(rmd.z))));\n        col *= GetLight(p, n, lPos, rd, fract(rmd.z)*abs(rmd.z)/rmd.z);\n        col *= SoftShadow(p + n*.05, lPos, 2.0);\n        col *= CalcAO(p, n);\n        col = mix(col, bg, pow(rmd.x / MAX_DIST, SURF_EXP));\n    }\n    \n    col += rmd.y / float(MAX_STEPS) * GLOW_INT * sqrt(min(rmd.x, MAX_DIST) / MAX_DIST);\n    \n    fragColor = vec4(col,1.0);\n}\n\nvec4 PP(vec3 col, vec2 uv)\n{\n    //contrast\n    col = mix(col, S(vec3(0.), vec3(1.), col), PP_CONT);    \n    //ACES color\n    col =  clamp((col * (2.51f * col + 0.03f)) / (col * (2.43f * col + 0.59f) + 0.14f), 0.0f, 1.0f);\n    //Vignette\n    col *= S(PP_VIGN,-PP_VIGN/5., dot(uv,uv)); \n    //gamma correction\n    col = pow(col, GAMMA);\n    \n    return vec4(col, 1.);\n}\n\nvoid mainImage(out vec4 O, vec2 U) //Fabrice\n{\n    Render(O,U);\n    \n    if (AA_ENAB && fwidth(length(O)) > AA_THRE)\n    {\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { Render(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n        //O.r++; //Show sampled area\n    }\n    \n    O = PP(vec3(O), (U-.5 * iResolution.xy) / iResolution.y);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/styBW1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1071, 1071, 1095, 1095, 1171], [1226, 1226, 1263, 1263, 1345], [1347, 1347, 1368, 1368, 1406], [1413, 1413, 1442, 1442, 1689], [1691, 1691, 1720, 1720, 2127], [2129, 2129, 2179, 2179, 2467], [2469, 2469, 2514, 2514, 2584], [2586, 2586, 2606, 2606, 4398], [4400, 4400, 4422, 4422, 4541], [4543, 4543, 4577, 4577, 4997], [4999, 4999, 5052, 5052, 5574], [5577, 5577, 5642, 5642, 5871], [6203, 6203, 6245, 6245, 6440], [6442, 6442, 6481, 6481, 6632], [6634, 6634, 6659, 6659, 6959], [6961, 6961, 7015, 7015, 8623], [8625, 8625, 8653, 8668, 8993], [8995, 8995, 9041, 9041, 9362]], "test": "untested"}
{"id": "NtGfzt", "name": "cone - point intersection", "author": "sympou", "description": "while doing research on cone marching and looking for optimisations,\ni found a way of getting the distance between a \"cone\" and a point.\nfinally, i'm not sure what this could be useful for, bet there it is :)", "tags": ["cone"], "likes": 6, "viewed": 198, "published": 3, "date": "1665009152", "time_retrieved": "2024-07-30T16:27:59.369078", "image_code": "#define coneWidth .25\n#define ptPos  vec2(0.5)\n#define camPos vec2(0.1,0.2)\n\n#define lineWidth 2.\n\nfloat circleDist(vec2 pos, vec2 pt, float radius) {\n    return abs(length(pos-pt) - radius);\n}\nfloat circleFillDist(vec2 pos, vec2 pt, float radius) {\n    return max(length(pos-pt) - radius, 0.);\n}\nfloat segLineDist(vec2 pos, vec2 a, vec2 b) {\n    vec2 pa = pos-a, ba = b-a;\n    float h = max( dot(pa,ba) / dot(ba,ba), 0.0);\n    return length( pa - ba*h );\n}\nfloat smoothLine( in float x) {\n    float t = clamp(x , 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 p = fragCoord;\n    vec2 m = iMouse.xy;\n\n    if ( m == vec2(0.) ) m = vec2(0.5,0.5+cos(iTime)*0.1) * iResolution.xy;\n\n    vec2 ro = camPos * iResolution.xy;\n    vec2 pt = ptPos  * iResolution.xy;\n\n\n    //distance of closest shape\n    float d = 99999.;\n    \n    vec3 col = vec3(1.);\n\n    /////////\n        \n    //direction between mouse and origin\n    vec2  rd = normalize(m - ro);\n\n    //direction and length between the point and origin\n    vec2  sr   = pt - ro;\n    float len2 = length(sr);\n    vec2  rd2  = sr / len2;\n    \n    ///////\n        \n    //coordinates of the \"hidden\" circle,\n    //on which the collision actually occurs\n    float cw2  = coneWidth*coneWidth;\n    float dist = len2 / (1. - cw2);\n    float rad  = dist * coneWidth;\n     \n    //ray-circle intersection\n    //https://www.shadertoy.com/view/4d2XWV\n    vec2 oc = - rd2 * dist;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = sqrt(b*b - c);\n    float tN = - b - h;\n    float tF = - b + h;\n    \n    /////////\n \n    //drawing the starting point\n    d = min(d, circleFillDist(p, ro, 2.5));\n    \n    //drawing the target point\n    d = min(d, circleFillDist(p, pt, 2.5));\n\n    //drawing the edges of the cone\n    vec2 offset = vec2(rd.y,-rd.x) * coneWidth / sqrt(1.-cw2);\n    d = min(d, segLineDist(p, ro, ro + rd + offset));\n    d = min(d, segLineDist(p, ro, ro + rd - offset));\n\n    //drawing the two resulting circles\n    if ( tN > 0. ) {\n        d = min(d, circleDist(p, ro + rd * tN, coneWidth * tN));\n        d = min(d, circleDist(p, ro + rd * tF, coneWidth * tF));\n        d = min(d, circleFillDist(p, ro + rd * tN, 2.5));\n        d = min(d, circleFillDist(p, ro + rd * tF, 2.5));\n    }\n \n    //distance to color\n    d = smoothLine( d / lineWidth );\n    col = min(col, vec3( d ) );\n \n    //showing \"hidden\" circle and line\n    float d2 = circleDist(p, ro + rd2 * dist, rad);\n    d2 = min(d2, segLineDist(p, ro, ro + rd));\n    d2 = smoothLine( d2 / lineWidth );\n    col = min(col, vec3( mix(d2,1.,0.9) ) );\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGfzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 150, 150, 193], [194, 194, 249, 249, 296], [297, 297, 342, 342, 457], [458, 458, 489, 489, 562], [564, 564, 621, 621, 2680]], "test": "untested"}
{"id": "ftyBRd", "name": "Helix - distance (APPROXIMATED)", "author": "iq", "description": "An [b]approximated[/b] distance to an helix. Another weekend I'll try getting the exact one based on [url=https://www.shadertoy.com/view/3t23WG]3t23WG[/url] perhaps. Credits to tdhooper for the concept. This version has a lot less math, so it's faster.", "tags": ["3d", "sdf", "distance"], "likes": 40, "viewed": 1532, "published": 3, "date": "1665000938", "time_retrieved": "2024-07-30T16:28:00.212822", "image_code": "// Inigo Quilez 2022\n\n// Based on the same concept as https://www.shadertoy.com/view/tt2Xzc\n// so credits to him. However, this implementation uses less space\n// transformations, which means no trigonoemtrics and no square roots\n// (but the last measure of course), among other things.\n//\n// IT IS NOT AN EXACT SDF, please don't use in production. I'll try\n// implementing an exact SDF some other weekend.\n//\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and https://iquilezles.org/articles/distfunctions\n\nfloat sdHelix( in vec3 p, float fr, float r1, float r2 )\n{\n    vec2  nline = vec2(fr, 6.283185*r1 );\n    vec2  pline = vec2(nline.y, -nline.x);\n    float repeat = nline.x*nline.y;\n\n    vec2  pc = vec2(p.x,r1*atan(p.y,p.z));              // to cylindrical\n\n    vec2  pp = vec2( dot(pc,pline),                     // project to line\n                     dot(pc,nline));\n    \n    pp.x = round(pp.x/repeat)*repeat;                   // repeat in x\n\n    vec2 qc = (nline*pp.y+pline*pp.x)/dot(nline,nline); // un project to cylindrical\n    qc.y /= r1;\n    \n    vec3 q = vec3(qc.x, sin(qc.y)*r1, cos(qc.y)*r1 );   // to cartesian\n        \n    return length(p-q)-r2;\n}\n\nfloat map( in vec3 pos )\n{\n    float fr = 1.0 - 0.5*cos(6.283185*iTime/6.0);\n    float r1 = 0.4;\n    float r2 = 0.1;\n\n    return sdHelix(pos,fr,r1,r2) - 0.0001;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n   \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 1.0 + 0.0*iTime;\n\tvec3 ro = vec3( 1.5*cos(an), 0.4, 1.5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 13.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( abs(h)<0.0001 || t>tmax ) break;\n            t += h*0.75;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyBRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[534, 534, 592, 592, 1194], [1196, 1196, 1222, 1222, 1358], [1360, 1406, 1438, 1438, 1677]], "test": "untested"}
{"id": "flyBzt", "name": "Illuminated sphere II", "author": "mrange", "description": "CC0: Illuminated sphere II\nContinuing experimentation to get something that looks like W11 wallpapers\nAdded an \"atmosphere\" and thought the results were appealing enough to share\n", "tags": ["3d", "sphere"], "likes": 23, "viewed": 462, "published": 3, "date": "1664992140", "time_retrieved": "2024-07-30T16:28:01.202177", "image_code": "// CC0: Illuminated sphere II\n//  Continuing experimentation to get something that looks like W11 wallpapers\n//  Added an \"atmosphere\" and thought the results were appealing enough to share\n\n#define POSTPROC\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nvec3 rgb2hsv(vec3 c) {\n  const vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nconst vec3 skyCol     = HSV2RGB(vec3(0.58, 0.86, 1.0));\nconst vec3 speCol1    = HSV2RGB(vec3(0.60, 0.25, 1.0));\nconst vec3 speCol2    = HSV2RGB(vec3(0.55, 0.25, 1.0));\nconst vec3 diffCol1   = HSV2RGB(vec3(0.60, 0.90, 1.0));\nconst vec3 diffCol2   = HSV2RGB(vec3(0.55, 0.90, 1.0));\n\nconst vec3 sunDir1    = normalize(vec3(0., 0.1, 1.0));\nconst vec3 sunDir2    = normalize(vec3(0., 0.66, 1.0));\n\nconst vec3 lightPos1   = vec3(0.0, 10.0, 10.0);\nconst vec3 lightPos2   = vec3(0.0, -80.0, 10.0);\n  \n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nvec2 raySphere(vec3 ro, vec3 rd, vec4 dim) {\n  vec3 ce = dim.xyz;\n  float ra = dim.w;\n  vec3 oc = ro - ce;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - ra*ra;\n  float h = b*b - c;\n  if( h<0.0 ) return vec2(-1.0); // no intersection\n  h = sqrt( h );\n  return vec2( -b-h, -b+h );\n}\n\nconst mat2 rot0 = ROT(0.0);\nmat2 g_rot = rot0;\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  col += 0.025*skyCol;\n  vec3 sunDir2 = sunDir2;\n  sunDir2.yz *= g_rot;\n//  col += clamp(vec3(0.0025/abs(rd.y))*skyCol, 0.0, 1.0);\n//  col += skyCol*0.0005/pow((1.0001+((dot(sunDir1, rd)))), 2.0);\n  col += skyCol*0.0005/pow((1.0001+((dot(sunDir2, rd)))), 2.0);\n\n  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n  float tp = tp1;\n  tp = max(tp0,tp1);\n\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n  }\n\n  if (tp0 > 0.0) {\n    vec3 pos  = ro + tp0*rd;\n    vec2 pp = pos.xz;\n    float ds = length(pp) - 0.5;\n    \n    col += vec3(0.25)*skyCol*exp(-.5*max(ds, 0.0));\n  }\n\n  return clamp(col, 0.0, 10.0);\n}\n\nvec3 render1(vec3 ro, vec3 rd) {\n  vec3 skyCol = render0(ro, rd);\n  vec3 col = skyCol;\n  \n  const vec4 sdim = vec4(vec3(0.0), 2.0);\n  vec2 si = raySphere(ro, rd, sdim);\n  \n  vec3 nsp = ro + rd*si.x;\n\n  vec3 nld1   = normalize(lightPos1-nsp); \n  vec3 nld2   = normalize(lightPos2-nsp); \n  \n  vec3 nnor   = normalize(nsp - sdim.xyz);\n\n  vec3 nref   = reflect(rd, nnor);\n\n  const float sf = 4.0;\n  float ndif1 = max(dot(nld1, nnor), 0.0);\n  ndif1       *= ndif1;\n  vec3 nspe1  = pow(speCol1*max(dot(nld1, nref), 0.0), sf*vec3(1.0, 0.8, 0.5));\n\n  float ndif2 = max(dot(nld2, nnor), 0.0);\n  ndif2       *= ndif2;\n  vec3 nspe2  = pow(speCol2*max(dot(nld2, nref), 0.0), sf*vec3(0.9, 0.5, 0.5));\n\n  vec3 nsky   = render0(nsp, nref);\n  float nfre  = 1.0+dot(rd, nnor);\n  nfre        *= nfre;\n\n  vec3 scol = vec3(0.0); \n  scol += nsky*mix(vec3(0.25), vec3(0.5, 0.5, 1.0), nfre);\n  scol += diffCol1*ndif1;\n  scol += diffCol2*ndif2;\n  scol += nspe1;\n  scol += nspe2;\n\n  if (si.x > -1.0) {\n    col = mix(col, scol, tanh_approx(0.9*(si.y-si.x)));\n  }\n\n  return col;\n}\n\nvec3 render2(vec3 ro, vec3 rd) {\n  const vec4 sdim = vec4(vec3(0.0), 2.33);\n  vec2 si = raySphere(ro, rd, sdim);\n  \n  vec3 nsp = ro + rd*si.x;\n\n  vec3 nld1   = normalize(lightPos1-nsp); \n  vec3 nld2   = normalize(lightPos2-nsp); \n  \n  vec3 nnor   = normalize(nsp - sdim.xyz);\n\n  vec3 nref   = reflect(rd, nnor);\n  vec3 nrefr  = refract(rd, nnor, 0.9);\n  if (nrefr == vec3(0.0)) {\n    nrefr = nref;\n  }\n\n  vec3 nsky   = render0(nsp, nref);\n  float nfre  = 1.0+dot(rd, nnor);\n  nfre        *= nfre;\n\n  vec3 scol = vec3(0.0); \n  scol += nsky*mix(0.25, 1.0, nfre);\n\n  vec3 col0 = render0(ro, rd);\n  vec3 col1 = render1(nsp, nrefr);\n  vec3 col = col0;\n\n  if (si.x > -1.0) {\n    float ff = smoothstep(0.0, 1.75, si.y-si.x);\n    col = mix(col, col1+scol, ff); \n  }\n\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  g_rot = ROT(mix(0.4, -0.84, 0.5-0.5*cos(0.04*TIME)));\n  const float fov = tan(TAU/6.0);\n  const vec3 ro = 1.0*vec3(0.0, 2.0, 5.0);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = cross(ww,uu);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render2(ro, rd);\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  col = aces_approx(col); \n#if defined(POSTPROC)  \n  vec3 hsv = rgb2hsv(col);\n  hsv.x = fract(hsv.x+(-abs(p.x)*p.y+p.y*p.y)*0.1-0.01*TIME);\n  col = hsv2rgb(hsv);\n#endif  \n  col = sRGB(col);\n\n  fragColor = vec4(col, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyBzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[539, 539, 561, 561, 707], [1001, 1092, 1114, 1114, 1439], [1934, 2034, 2053, 2053, 2140], [2142, 2249, 2275, 2275, 2459], [2461, 2521, 2549, 2615, 2691], [2693, 2805, 2847, 2847, 2894], [2896, 3014, 3041, 3041, 3117], [3119, 3241, 3285, 3285, 3530], [3579, 3579, 3611, 3611, 4509], [4511, 4511, 4543, 4543, 5564], [5566, 5566, 5598, 5598, 6340], [6342, 6342, 6363, 6363, 6771], [6773, 6773, 6830, 6830, 7174]], "test": "untested"}
{"id": "7lKfzc", "name": "Living Truchet", "author": "rcargou", "description": "hi", "tags": ["tiling"], "likes": 7, "viewed": 204, "published": 3, "date": "1664991411", "time_retrieved": "2024-07-30T16:28:02.368060", "image_code": "#define PI 3.1415926535\nfloat hash( vec2 p ) {\n\tfloat h = dot(vec2( p) ,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat quarter_circle(vec2 uv) {\n\n    float size = 0.01;\n    float ret = 0.;\n    float l = length(uv - vec2(1., 1.) ) * .18 / 0.01 * size;\n    ret = smoothstep(.1, .1 - size, l);\n    ret *= smoothstep(.1 - 2. * size, .1 - size, l);\n  \n    return ret;\n\n}\n\nfloat truchet(vec2 uv, float s) {\n    \n    if (s < 0.)\n        uv.x = 1. - uv.x;\n    float ret = quarter_circle(uv);\n    \n    vec2 tmp = uv;\n    \n    uv.x = 1.0 - tmp.y;\n    uv.y = 1.0 - tmp.x;\n    \n    ret += quarter_circle(uv);\n    return ret;\n}\n\nfloat rand_trigger(vec2 uv, vec2 id, float scale) {\n\n    float time = scale * iTime / 2. + hash(id) * 1.;\n    float r = floor(time / PI  / 3.+ .0);// + -.2;\n    float h = hash(vec2(r * vec2( hash(id))) + vec2( hash(id) ));\n    if (h < 0.5)\n        time = r * PI * 3.;//r;// - .2;\n    return min(max(sin(time  ), -0.2 ), 0.2 ) * 5.;\n }\n \n\n \nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nint hashi( vec2 p ) {\n\tfloat h = dot(vec2( p) ,vec2(127.1,311.7));\t\n    float y = 2213123. * fract(sin(h)*43758.5453123);\n    return int(y);\n}\n\nfloat diag(vec2 uv, float si) {\n    float s = .05;\n    return smoothstep(s, 0.0, abs(uv.x * si - uv.y) - s / 2.  );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    uv *= 10.;\n    vec2 id = floor(uv);\n\n    float r = rand_trigger(uv.xy, id, 1.0);\n    uv = fract(uv) - vec2(.5);\n //   r = abs(r);\n    r = min(1.0, r);\n    r = max(-0.0, r);\n    float angle = 3.14 * r / 2.;\n    uv *= rotate2d(angle);\n    int si = hashi(id) % 2 == 0 ? -1 : 1;\n    float t = rand_trigger(vec2(21.), vec2(42.), 1. );\n    float sd = diag(uv, float(si));\n    float ss = truchet(uv + vec2(.5), float(si));\n    vec3 col = vec3( mix(sd, ss, 0.) );\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKfzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 46, 46, 134], [136, 136, 167, 167, 388], [390, 390, 423, 423, 637], [639, 639, 690, 690, 973], [979, 979, 1007, 1007, 1093], [1095, 1095, 1116, 1116, 1237], [1239, 1239, 1270, 1270, 1356], [1358, 1358, 1415, 1415, 1971]], "test": "untested"}
{"id": "NtyfRt", "name": "Video Time Trail", "author": "MysteryPancake", "description": "Inspired by Bicep's Atlas music video", "tags": ["video", "time", "buffer", "trail", "atlas", "bicep"], "likes": 1, "viewed": 277, "published": 3, "date": "1664989606", "time_retrieved": "2024-07-30T16:28:03.421244", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 trail = texture(iChannel1, uv);\n    vec4 front = texture(iChannel0, uv);\n    vec4 bg = vec4(1.0, 0.2, 0.2, 0.0) + texture(iChannel2, uv * 0.5).r;\n    \n    vec4 fg = mix(trail, front, front.a);\n    fragColor = mix(bg, fg, fg.a);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29928, "src": "https://soundcloud.com/feelmybicep/bicep-atlas", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "#define colorKey(vid) clamp((distance(vid.rgb, target) - threshold) / softness, 0.0, 1.0)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    const vec3 target = vec3(0.0, 1.0, 0.0); // Find green\n    const float threshold = 0.7; // Controls target color range\n    const float softness = 0.1; // Controls linear falloff\n    \n    // One sample per rim light pass\n    vec4 vid = texture(iChannel0, uv);\n    vec4 vid2 = texture(iChannel0, uv + vec2(0.005));\n    vec4 vid3 = texture(iChannel0, uv - vec2(0.005));\n    \n    // Linear color key (https://www.shadertoy.com/view/NsfcWj)\n    float factor = colorKey(vid);\n    float factor2 = colorKey(vid2);\n    float factor3 = colorKey(vid3);\n    \n    // Yellow rim light\n    vid += vec4(1.0, 0.5, 0.5, 0.0) * (1.0 - factor2);\n    \n    // Blue rim light\n    vid += vec4(0.0, 0.0, 1.0, 0.0) * (1.0 - factor3);\n    \n    fragColor = vec4(vid.rgb, factor);\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n    const vec2 offset = vec2(-0.002, -0.002);\n\n    if (iFrame < 1) {\n\n        // Initialize values to 0\n        fragColor = vec4(0.0);\n\n    } else if (iFrame % 8 == 0) {\n\n        // Sample every 8 frames\n        vec4 last = texture(iChannel0, uv + offset);\n        vec4 vid = texture(iChannel1, uv);\n        fragColor = mix(last, vid, vid.a);\n\n    } else {\n    \n        // Use previous sample\n        fragColor = texture(iChannel0, uv + offset);\n    }\n\n    // Decrease alpha over time\n    fragColor.a = clamp(fragColor.a - 0.0005, 0.0, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtyfRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 338]], "test": "untested"}
{"id": "slVfzc", "name": "A Belgian Predator in London", "author": "sh1boot", "description": "Trying to use a mipmap-blurred alpha channel to derive a gradient pointing to valid pixels to in-paint missing areas.\n\nColourful noise is where the iterative search bails out (probably inescapable wells).", "tags": ["extrapolation", "predator", "inpainting", "stealth"], "likes": 3, "viewed": 341, "published": 3, "date": "1664987391", "time_retrieved": "2024-07-30T16:28:04.214124", "image_code": "float blurryalpha(vec2 uv) {\n    // TODO: This, but correctly?\n    float sum = 0.0;\n    float div = 0.0;\n    for (int i = 2; i < 11; ++i) {\n        float scale = pow(1.40, float(i));\n        float bias = float(i);\n        sum += texture(iChannel0, uv, float(i)).a * scale;\n        div += scale;\n    }\n    return sum / div;\n}\n\nvec2 alphagradient(vec2 uv, float eps) {\n    vec3 o = vec3(-eps, eps, 0.0);\n    float lf = blurryalpha(uv + o.xz);\n    float rt = blurryalpha(uv + o.yz);\n    float up = blurryalpha(uv + o.zx);\n    float dn = blurryalpha(uv + o.zy);\n    return vec2(rt - lf, dn - up) / eps;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 bkg = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec4 colour = textureLod(iChannel0, uv, 0.0);\n    for (int i = 0; i < 10; ++i) {\n        if (colour.a >= 0.95) break;\n        vec2 dir = alphagradient(uv, 0.02);\n        if (length(dir) < 0.001) dir = alphagradient(uv, 0.1);\n        // TODO: if length(dir) is still zeroish then add some noise\n\n        // Use the current blurred alpha value as an estimation of\n        // the distance to opaque data.\n        float alpha = blurryalpha(uv);\n\n        // Distort it a bit because I don't really know.\n        alpha = pow(alpha, 1.8);\n#if 1\n        // Guess how far out to reach to get in-fill data.\n        float scale = 0.075 * (1.0 - alpha);\n#else\n        // Different guess how far out to reach to get in-fill data.\n        float scale = 0.125 / (alpha + 0.3);\n#endif\n\n        // Try a little harder to escape as we get more desperate.\n        scale += pow(1.01, float(i)) - 1.0;\n\n        // move texture coordinate in direction of increasing alpha,\n        // by a distance inferred above.\n        uv += scale * normalize(dir);\n\n        // and try again...\n#if 0\n        colour = textureLod(iChannel0, uv, 0.0);\n#else\n        vec4 update = textureLod(iChannel0, uv, 0.0);\n        colour += update.a * (update - colour);\n#endif\n    }\n\n    bkg = bkg * (1.0 - colour.a) + colour.rgb * colour.a;\n\n    // Output to screen\n    fragColor = vec4(bkg,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float getStencil(vec2 uv) {\n    vec3 col = texture(iChannel1, uv).rgb;\n    return smoothstep(0.2, 0.35, col.g - max(col.r, col.b));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 colour = texture(iChannel0, uv);\n\n    colour.a = getStencil(uv);\n\n    fragColor = colour;\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVfzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 62, 324], [326, 326, 366, 366, 600], [602, 602, 659, 709, 2163]], "test": "untested"}
{"id": "slGfRc", "name": "inside out newton", "author": "pb", "description": "combination of newton's method for z^3-1 and good ol' z^2+c makes very pleasing black and white figures,  CLICK and DRAG the MOUSE to take over  control yourself.  Uncomment the #define to see where mipmap LOD2==LOD0 ", "tags": ["julia", "newton"], "likes": 6, "viewed": 224, "published": 3, "date": "1664979702", "time_retrieved": "2024-07-30T16:28:05.062855", "image_code": "//philip.bertani@gmail.com\n//CLICK and DRAG the MOUSE - see Buffer A\n//still need this blur to smoooth out the edges\n\nfloat[] gkhs = float[] (\n        0.000002,0.000212,0.000922,0.000212,0.000002,\n        0.000212,0.024745,0.107391,0.024745,0.000212,\n        0.000922,0.107391,0.466066,0.107391,0.000922,\n        0.000212,0.024745,0.107391,0.024745,0.000212,\n        0.000002,0.000212,0.000922,0.000212,0.000002 );\n        \n//#define SEE_LOD0_LOD2      \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )  \n//seems like mipmap level 1 does just a good job as this averaging loop\n//actually not - need to do more to make mipmap work out\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    //size of one texel in iChannel0\n    vec2 texel = 1./iResolution.xy;\n    vec4 total_color = vec4(0);\n    \n    vec4 currentPixelLOD0 = texture(iChannel0,uv,0.);\n    if ( currentPixelLOD0!=texture(iChannel0,uv,2.) ) {\n      for (int i=0;i<5;i++){\n        float fi = float(i)-2.;\n        for (int j=0;j<5;j++){ \n            float fj = float(j)-2.;\n            vec4 color = texture(iChannel0, \n                uv + vec2( texel.x*fi,texel.y*fj ) , 0. );\n            total_color += color * gkhs[i*5 + j];\n        }\n      }    \n    }\n    else { \n#ifdef SEE_LOD0_LOD2 \n            total_color = vec4(1.,0.,0.,1.); \n#else            \n            total_color = currentPixelLOD0;\n#endif\n     }\n    fragColor = sqrt(total_color);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//philip.bertani@gmail.com\n//Newton's method for z^3-1 combined with regular julia set for z^2+c\n#define too_small 1e-6\n#define Infinity 1e4\nvec2 newtonjulia(vec2 z, vec2 c, float wgt) {  //mix of newton's method and z^2+c\n  vec2 zz = z; float xy = z.x*z.y; zz*=zz; \n  vec2 julia = vec2(zz.x-zz.y, 2.*xy) ;\n  xy*=xy;  //need xy^2 \n  zz*=zz;  //need x^4 and y^4\n  float modz2 = max( zz.x+zz.y+2.*xy, too_small);\n  //following is z - (z^3-1)/3z^2 all multiplied out using complex numbers  \n  vec2 newt = vec2( 2.*(zz.x*z.x + 2.*z.x*xy + z.x*zz.y) + c.x*julia.y ,\n                    2.*(zz.y*z.y + 2.*z.y*xy + z.y*zz.x) + c.x*julia.x   );\n  newt /= (3.*modz2);\n  julia += c;  //we needed julia without the c in newt first\n  return wgt*newt + (1.-wgt)*julia;   \n}\nvoid mainImage( out vec4 rgba, in vec2 uv )\n{\n  uv = (2.*uv - iResolution.xy)/iResolution.y;\n  vec2 mm = (2.*iMouse.xy - iResolution.xy)/iResolution.y;\n  if ( iMouse.w==0. ) { mm.x=-.5;mm.y=-.4*(1.-sin((iTime+22.)/5.));}\n  vec2 c = mm*3.; c.x=.1+c.x/100.;\n  vec2 z=(uv)*4000., newz=vec2(0); \n  float modz = max(z.x*z.x+z.y*z.y,too_small); \n  z /= modz; //invert in unit circle\n  float escape_value=0., wgt=1.03;  //change wgt around to get more variations\n  for (float i=0.; i<27.; i++){\n    newz = newtonjulia(z,c,wgt);\n    if (dot(newz,newz)>Infinity) { escape_value=i; break;}\n    z=newz;\n  }\n  vec2 lz = vec2(0);\n  if ( escape_value == 0. ) lz = cos(log(abs(newz)));\n  if ( dot(lz,lz) > .5 ) rgba=vec4(1.); else rgba = vec4(0.);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGfRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[424, 454, 642, 642, 1409]], "test": "untested"}
{"id": "slKfRc", "name": "Cellular Mazes", "author": "MysteryPancake", "description": "Inspired by Conway's Game of Life, I found interesting mazes emerge from a 3x3 kernel.", "tags": ["noise", "cellular", "pattern", "cell", "maze", "gameoflife", "automaton", "pebble"], "likes": 7, "viewed": 228, "published": 3, "date": "1664978943", "time_retrieved": "2024-07-30T16:28:05.955468", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord / gridSize), 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define cell(offset) texelFetch(iChannel0, ivec2(fragCoord) + offset, 0).x\nconst int resetAfter = 64;\n\nfloat rand(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Skip invisible pixels\n    if (fragCoord.x * gridSize > iResolution.x || fragCoord.y * gridSize > iResolution.y) discard;\n\n    if (iFrame % resetAfter == 0) {\n    \n        // Initialize values, random noise\n        fragColor = vec4(vec3(rand(fragCoord / iResolution.xy)), 1.0);\n        \n    } else {\n    \n        // Sample current pixel directly\n        float self = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n\n        // Sum of neighbours, 3 x 3 kernel\n        float sum = cell(ivec2(-1,  1)) + cell(ivec2(0,  1)) + cell(ivec2(1,  1))\n                  + cell(ivec2(-1,  0))                      + cell(ivec2(1,  0))\n                  + cell(ivec2(-1, -1)) + cell(ivec2(0, -1)) + cell(ivec2(1, -1));\n                 \n        // Swap pattern every 64 frames\n        float offset = sum > float((1 + iFrame / resetAfter) % 8) ? -0.1 : 0.1;\n        fragColor = vec4(vec3(clamp(self + offset, 0.0, 1.0)), 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float gridSize = 8.0;", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKfRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 128]], "test": "untested"}
{"id": "slVBz3", "name": "Flow Field Test 1", "author": "SnoopethDuckDuck", "description": "a little laggy, other resolutions might look weird again idk", "tags": ["buffer"], "likes": 18, "viewed": 281, "published": 3, "date": "1664973948", "time_retrieved": "2024-07-30T16:28:06.745356", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc = 1.;\n    vec3 col = texelFetch(iChannel0, ivec2(sc *fragCoord), 0).rgb;\n    col = 1.8 * pow(col, vec3(1.6)); \n    //col = sqrt(col);\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y; \n    col *= exp(-abs(uv.x));\n   // col = mix(col, vec3(0.5,0.5,1), 1. - exp(-abs(uv.x)));\n    //col *= 0.25 + 0.75 * clamp(uv.y + 0.75, 0., 1.25);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\nvec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 f)\n{\n    vec3 col = vec3(0);\n    vec2 r = iResolution.xy;\n    vec4 e = cell(ivec2(f));\n    col.rgb = e.rgb;\n    vec2 uv = (f - 0.5 * r) / r.y;\n    float xp = exp(-0.2 * iTime);\n    float xp2 = exp(-0.1 * iTime);\n    \n    for (float i = 0.; i < 30.; i++) {\n        vec2 p = vec2(r.x * h21(vec2(iTime, 0.1 + i)), \n                      r.y * h21(vec2(0.2 * iTime, -5.1 - i)));\n        float ns = fnoise((p-0.5*r)/r.y, 5.);\n        float a = 2. * pi * ns;\n        vec2 q = p + r.y/8. * xp * vec2(cos(a), sin(a));\n        float d = seg(f, p, q);\n        float d2 = seg(f - r.y/160. * xp * vec2(-1,-2), p, q);\n        float s = xp2 * exp(-(1.-xp) * d);\n        float s2 = xp * exp(-(1.-xp) * d2);\n        vec3 pl = pal(0. + 2. * ns + 0.15 * iTime, 0.5 * vec3(0,1,2)/3.);\n        col = mix(col, xp * pl, s2);\n        col = mix(col, pl, s);       \n    }\n    //if (iFrame == 0 || key_down(KEY_RESET)) {     \n      //  col = vec3(0);\n    //}\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// everything under here is from iq\nfloat seg(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n//https://www.shadertoy.com/view/XdXGW8\nvec2 grad(ivec2 z) {\n    int n = z.x+z.y*11111;\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) : gr;                            \n}\n\nfloat noise(in vec2 p) {\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fnoise(vec2 uv, float sc) {\n    float f = 0.;\n\tuv *= sc;\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n\tf  = 0.5000 * noise(uv); uv = m * uv;\n\tf += 0.2500 * noise(uv); uv = m * uv;\n\tf += 0.1250 * noise(uv); uv = m * uv;\n\tf += 0.0625 * noise(uv); uv = m * uv;\n\treturn 0.5 + 0.5 * f;\n}\n\n// (Replace Buffer A with this)\n// icon might work using iFrame instead of iTime\n// dont want to change the image from what it was so I've left the\n// code alone\n\n/*\nvec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 f)\n{\n    vec2 r = iResolution.xy;\n    vec3 col = cell(ivec2(f)).rgb; // still works on mac? no col=vec3(0)\n    vec2 uv = (f - 0.5 * r) / r.y;\n    \n    float t = floor(60. * iTime) / 60.; // should work in icon now?\n    float xp = exp(-0.2 * t);\n    float xp2 = exp(-0.1 * t);\n    \n    if (t < 15.) {\n        for (float i = 0.; i < 30.; i++) {\n            vec2 p = vec2(r.x * h21(vec2(t, 0.1 + i)), \n                          r.y * h21(vec2(0.2 * t, -5.1 - i)));\n            float ns = fnoise((p-0.5*r)/r.y, 5.);\n            float a = 2. * pi * ns;\n            vec2 q = p + r.y/8. * xp * vec2(cos(a), sin(a));\n            float d = seg(f, p, q);\n            float d2 = seg(f - r.y/160. * xp * vec2(-1,-2), p, q);\n            float s = xp2 * exp(-(1.-xp) * d);\n            float s2 = xp * exp(-(1.-xp) * d2);\n            vec3 pl = pal(2. * ns + 0.15 * t, 0.5 * vec3(0,1,2)/3.);\n            col = mix(col, xp * pl, s2);\n            col = mix(col, pl, s);       \n        }\n    }\n    fragColor = vec4(col,1.0);\n}\n//*/\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVBz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 450]], "test": "untested"}
{"id": "NtKfRc", "name": "Ellipses Ordered and Noisy", "author": "rubioh", "description": "ellipse", "tags": ["ellipse"], "likes": 5, "viewed": 218, "published": 3, "date": "1664954284", "time_retrieved": "2024-07-30T16:28:07.570151", "image_code": "# define PI 3.14159265359\nvec2 hash(vec2 x){\n    vec2 p  = vec2(\n                dot(x, vec2(3451.4327, 2744.749)),\n                dot(x, vec2(2453.4327, 3218.127)));\n    return fract( sin(p)*3745.4);\n}\n\n/*\nfloat make_ellipse2(vec2 uv, vec2 ab, float amp, float angle){\n    \n    float width = .05;\n    float ca = cos(angle);\n    float sa = sin(angle);\n    float a2 = ab.x*ab.x;\n    float b2 = ab.y*ab.y;\n    float a2b2 = a2*b2;\n\n    float linear_term = 2.*ca*sa*(b2 - a2)*uv.x*uv.y/a2b2;\n    float quadratic_x = (sa*sa*a2 + ca*ca*b2)*uv.x*uv.x/a2b2;\n    float quadratic_y = (ca*ca*a2 + sa*sa*b2)*uv.y*uv.y/a2b2;\n    float n = (1.-smoothstep(-0.005, 0., quadratic_x+linear_term+quadratic_y - amp -width))*\n              smoothstep(0., 0.005, quadratic_x+linear_term+quadratic_y  - amp);\n    return n;\n}\n*/\n\nfloat make_ellipse(vec2 U, vec2 ab, float amp, float a) {\n\n    vec2 A = vec2( cos(a), sin(a) ), A2 = A*A,\n        B2 = ab*ab,\n         C = A*U;\n\n    float a2b2 = B2.x*B2.y,\n             c = 2.* C.x*C.y* (B2.y-B2.x) / a2b2;\n             \n    vec2 Q = mat2(A2.y,A2.x, A2) * B2  * U*U / a2b2;\n\n    return smoothstep( 10./iResolution.y, 0., abs( Q.x+ Q.y + c - amp ) );\n}\n\n\nmat2 rotation_matrix(float angle){\n    return mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( 2.*fragCoord.xy - iResolution.xy ) / iResolution.y;\n    uv /= 1.5;\n    \n    // N ellipse\n    float N = 11.;\n    \n    // Time varying pixel color\n    vec3 col;\n    vec3 tmp_color = vec3(1., 1., 1.);\n    vec2 ab = vec2(.3+.2*cos(iTime), .2);\n    \n    \n    for (int i=0; i<int(N); i++){\n        vec2 st = uv;\n        float angle = (2.*PI*float(i)/N)+iTime+.1;\n        mat2 rot = rotation_matrix(angle);\n        \n        vec2 tmp_ab = mix(ab, vec2(.2, .2)+0.05*hash(vec2(float(i), angle)), smoothstep(0.4,0.6, cos(iTime*.1)));\n        \n        st += rot*mix(vec2(.1, .1), vec2(0., 0.)+0.05*hash(vec2(angle, float(i))), smoothstep(0.3,0.7, abs(cos(iTime*.1))));\n        col += vec3(1.,0.,0.)*make_ellipse(st, tmp_ab, .3+.3*cos(iTime*2.), angle);\n    }\n    \n        for (int i=0; i<int(N); i++){\n        vec2 st = uv;\n        float angle = (2.*PI*float(i)/N)+iTime;\n        mat2 rot = rotation_matrix(angle);\n        \n        vec2 tmp_ab = mix(ab, vec2(.2, .2)+0.05*hash(vec2(float(i), angle)), smoothstep(0.4,0.6, cos(iTime*.1)));\n        \n        st += rot*mix(vec2(.1, .1), vec2(0., 0.)+0.05*hash(vec2(angle, float(i))), smoothstep(0.3,0.7, abs(cos(iTime*.1))));\n        col += vec3(0.,1.,0.)*make_ellipse(st, tmp_ab, .3+.3*cos(iTime*2.), angle);\n    }\n    \n        for (int i=0; i<int(N); i++){\n        vec2 st = uv;\n        float angle = (2.*PI*float(i)/N)+iTime-.1;\n        mat2 rot = rotation_matrix(angle);\n        \n        vec2 tmp_ab = mix(ab, vec2(.2, .2)+0.05*hash(vec2(float(i), angle)), smoothstep(0.4,0.6, cos(iTime*.1)));\n        \n        st += rot*mix(vec2(.1, .1), vec2(0., 0.)+0.05*hash(vec2(angle, float(i))), smoothstep(0.3,0.7, abs(cos(iTime*.1))));\n        col += vec3(0.,0.,1.)*make_ellipse(st, tmp_ab, .3+.3*cos(iTime*2.), angle);\n    }\n    // Output to screen\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtKfRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 44, 44, 203], [807, 807, 864, 864, 1174], [1177, 1177, 1211, 1211, 1279], [1281, 1281, 1338, 1388, 3226]], "test": "untested"}
{"id": "slyfR3", "name": "Outpainting experiment #4", "author": "sh1boot", "description": "Just need to figure out a method to get rid of those streaky artefacts and maybe (impossibly) the sharp point in the middle of the circles.", "tags": ["inpainting", "jumpflood", "outpainting"], "likes": 1, "viewed": 233, "published": 3, "date": "1664928031", "time_retrieved": "2024-07-30T16:28:08.695143", "image_code": "float hash(vec2 uv) {\n    // Seeing some weird discontinuity coming from overflow cases -- this'll fix it!\n    uv = vec2(ivec2(floatBitsToUint(uv.x), floatBitsToUint(uv.y))) / 65537.0;\n\n    const vec2 swiz = vec2(12.9898, 78.233);\n    return fract(sin(dot(uv, swiz)) * 43758.5453);\n}\n\nfloat hash(float f) {\n    return hash(vec2(f));\n}\n\nfloat noise(vec2 uv, float p) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    f = smoothstep(0.0, 1.0, f);\n    vec4 o = vec4(vec2(-0.5), vec2(0.5)) + fract(p * 1.73737373);\n    return mix(mix(hash(i + o.xy), hash(i + o.zy), f.x),\n               mix(hash(i + o.xw), hash(i + o.zw), f.x),\n               f.y);\n}\n\nfloat nnoise(vec2 uv, float p) {\n    return noise(uv, p) * 0.5\n         + noise(uv * 2.01, p) * 0.25\n         + noise(uv * 4.017, p) * 0.125\n         + noise(uv * 8.029, p) * 0.125;\n}\n\nvec2 scribble(vec2 uv) {\n    uv *= 16.0;\n    return vec2(nnoise(uv, 0.0), nnoise(uv, 1.0)) - 0.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 origin = tex_coord(fragCoord, iResolution.xy);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec2 nearest = texture(iChannel0, uv).zw;\n    for (int i = 0; i < 1; ++i) {\n        vec2 diff = (nearest - origin) * 0.75;\n        float s = length(diff) * 1.8;\n        nearest += diff + scribble(origin) * s;\n        uv = map_coord(nearest, iResolution.xy);\n        vec2 next_nearest = texture(iChannel0, uv).zw;\n        if (distance(nearest, next_nearest) < 0.001) break;\n        nearest = next_nearest;\n    }\n    vec4 tex = texture(iChannel1, nearest, -1.0);\n    if (nearest.x < 0.0) tex = vec4(0.5);\n\n    col += (tex.rgb - col.rgb) * tex.a;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "bool IsVisible(vec2 uv) {\n    uv -= 0.5;\n    float t = iTime * 0.7;\n    vec2 c0 = vec2(cos(t), sin(t)) * 0.2;\n    t = (t + 1.0) * 0.65;\n    vec2 c1 = vec2(cos(t), sin(t)) * 0.27;\n    t = (t + 1.0) * 0.65;\n    if (distance(uv, c0) < 0.07) return false;\n    if (distance(uv, c1) < 0.12) return false;\n\n    uv = vec2(dot(uv, vec2(cos(t), sin(t))),\n              dot(uv, vec2(-sin(t), cos(t))));\n    if (uv.y > 0.3) return false;\n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 tc = tex_coord(fragCoord, iResolution.xy);\n\n    vec4 r = texture(iChannel0, uv);\n\n    if (iFrame % STEP_INTERVAL >= 1) {\n        fragColor = r;\n        return;\n    }\n\n    int stage = (iFrame / STEP_INTERVAL) % NUM_STAGES;\n    float step_size = exp2(float(NUM_STAGES - 1 - stage));\n    vec2 scale = vec2(step_size) * tex_step(iResolution.xy);\n\n    for (int y = -1; y <= 1; ++y) {\n        for (int x = -1; x <= 1; ++x) {\n            vec2 nuv = uv + vec2(x, y) * scale;\n            vec4 neighbour = texture(iChannel0, nuv);\n            if (distance(neighbour.xy, tc) < distance(r.xy, tc)) {\n                r.xy = neighbour.xy;\n            }\n        }\n    }\n    if (stage >= NUM_STAGES - 1) {\n        r.zw = r.xy;\n        r.xy = vec2(-8.0);\n        if (IsVisible(tc)) {\n            r.xy = tc;\n        }\n    }\n    fragColor = r;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define NUM_STAGES 11\n#define STEP_INTERVAL 1\n\nvec2 tex_coord(vec2 fragCoord, vec2 resolution) {\n    return (fragCoord - resolution * 0.5) / resolution.xx + 0.5;\n}\nvec2 map_coord(vec2 tc, vec2 resolution) {\n    return ((tc - 0.5) * resolution.xx + resolution * 0.5) / resolution.xy;\n}\n\nvec2 tex_step(vec2 resolution) {\n    return 1.0 / resolution.xx;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyfR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 106, 283], [285, 285, 306, 306, 334], [336, 336, 367, 367, 651], [653, 653, 685, 685, 836], [838, 838, 862, 862, 937], [940, 940, 997, 1047, 1839]], "test": "untested"}
{"id": "styBR3", "name": "Outpainting experiment #3", "author": "sh1boot", "description": "Yet another attempt at filling in holes in data.\n\nThe frame rate isn't as bad as it looks.  It just takes a few iterations to do the JFA steps.", "tags": ["inpainting", "jumpflood", "outpainting"], "likes": 0, "viewed": 148, "published": 3, "date": "1664907152", "time_retrieved": "2024-07-30T16:28:09.535895", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 origin = tex_coord(fragCoord, iResolution.xy);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n#if STEP_INTERVAL > 1\n    vec2 nearest = texture(iChannel0, uv).xy;\n    float lod = 0.0;\n#else\n    vec2 nearest = texture(iChannel0, uv).zw;\n    float lod = log2(distance(nearest, origin)) * 1.4 + 12.5;\n#endif\n\n    vec4 tex = textureLod(iChannel1, nearest, lod);\n    if (uv.x < 0.0) tex = vec4(0.5);\n    col += (tex.rgb - col.rgb) * tex.a;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "bool IsVisible(vec2 uv) {\n    uv -= 0.5;\n    float t = iTime * 0.7;\n    vec2 c0 = vec2(cos(t), sin(t)) * 0.2;\n    t = (t + 1.0) * 0.65;\n    vec2 c1 = vec2(cos(t), sin(t)) * 0.27;\n    t = (t + 1.0) * 0.65;\n    if (distance(uv, c0) < 0.07) return false;\n    if (distance(uv, c1) < 0.12) return false;\n\n    uv = vec2(dot(uv, vec2(cos(t), sin(t))),\n              dot(uv, vec2(-sin(t), cos(t))));\n    if (uv.y > 0.3) return false;\n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 tc = tex_coord(fragCoord, iResolution.xy);\n\n    vec4 r = texture(iChannel0, uv);\n\n    if (iFrame % STEP_INTERVAL >= 1) {\n        fragColor = r;\n        return;\n    }\n\n    int stage = (iFrame / STEP_INTERVAL) % NUM_STAGES;\n    float step_size = exp2(float(NUM_STAGES - 1 - stage));\n    vec2 scale = vec2(step_size) * tex_step(iResolution.xy);\n\n    for (int y = -1; y <= 1; ++y) {\n        for (int x = -1; x <= 1; ++x) {\n            vec2 nuv = uv + vec2(x, y) * scale;\n            vec4 neighbour = texture(iChannel0, nuv);\n            if (distance(neighbour.xy, tc) < distance(r.xy, tc)) {\n                r.xy = neighbour.xy;\n            }\n        }\n    }\n    if (stage >= NUM_STAGES - 1) {\n        r.zw = r.xy;\n        r.xy = vec2(-8.0);\n        if (IsVisible(tc)) {\n            r.xy = tc;\n        }\n    }\n    fragColor = r;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define NUM_STAGES 9\n#define STEP_INTERVAL 1\n\nvec2 tex_coord(vec2 fragCoord, vec2 resolution) {\n    return (fragCoord - resolution * 0.5) / resolution.xx + 0.5;\n}\nvec2 tex_step(vec2 resolution) {\n    return 1.0 / resolution.xx;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/styBR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 690]], "test": "untested"}
{"id": "NtyfRc", "name": "Buffer Art Test 5", "author": "SnoopethDuckDuck", "description": "im not sure how this will look on other resolutions", "tags": ["buffer"], "likes": 24, "viewed": 260, "published": 3, "date": "1664904940", "time_retrieved": "2024-07-30T16:28:14.064786", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc = 1.;\n    vec3 col = texelFetch(iChannel0, ivec2(sc *fragCoord), 0).rgb;\n    col = 1.8 * pow(col, vec3(1.6)); \n    //col = sqrt(col);\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y; \n    col *= exp(-abs(uv.x));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\nvec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nfloat pxLine(vec2 f, vec2 p, vec2 q, float th) {\n    // Centre the coordinates at p\n    f -= p;\n\n    // Get direction from p to q, use for gradient and bounding box dimensions\n    vec2 dir = 0.5 * (q - p);\n    \n    // Look at the line as a function of x, and as a function of y\n    float l = max( step(abs(f.x - round(dir.x/dir.y * f.y)), th),\n                   step(abs(f.y - round(dir.y/dir.x * f.x)), th) );\n               \n    // Restrict to the box bounded by p and q           \n    return l * step(abs(f.x - dir.x), abs(dir.x))\n             * step(abs(f.y - dir.y), abs(dir.y));           \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    vec3 col = vec3(0);\n    vec2 res = iResolution.xy;\n    vec4 e = cell(ivec2(f));\n    col.rgb = e.rgb;\n    //col *= 0.99;\n    \n    \n    \n    // fragCoord must be offset by 0.5\n    //f -= 0.5 * vec2(iResolution) - 0.5;\n    f -= 0.5;\n    float t = float(iFrame) / 60.;//floor(60. * flo) / 60.;\n    float xp = 1. / cosh(0.5 * t);//exp(-0.5 * t);\n    float xp2 = 1. / cosh(0.25 * t);//exp(-0.25 * t);\n    int n = 15;\n    vec2 o = vec2(100. + 50. * t, 150. * xp * cos(t) + 0.25 * res);\n    for (int i = 0; i < n; i++) {\n        t += 1. / ( float(n) * 60.);\n        // pxLine must take rounded positions as inputs \n        \n        vec2 p = round(o);//round(o + 500. * xp * (vec2(h21(vec2(t,0.1)),h21(vec2(t,0.5))) - 0.5));\n        float h = 2. * pi * h21(p);\n        vec2 q = round(p + 400. * xp * vec2(thc(1., h + 250. * t),\n                                            ths(1., h + 250. * t)));              \n        vec2 r = 0.5 * (p + q);\n        float d = length(f - r);\n        float d2 = length(f - 20. * xp - r);\n        d = 1. / cosh(0.5 * t + 0.1 + 0.5 * (1. - xp) * d);        \n        d2 = 1. / cosh(0.5 * t + 0.1 + 0.5 * (1. - xp) * d2);\n        float c = abs(d-d2);\n        vec3 pl = pal(100. * t, 0.5 * vec3(2,0,1)/3.);\n    \n        // Draw the points\n        float s = step(min(length(f-p), length(f-q)), 2.);\n        //col = mix(col, 0.5 * pl, s);\n        \n        // Draw the line (dark line + offset light line gives shadow effect)\n        col = mix(col, vec3(0), 10. * xp * d);\n        col = mix(col, pl + 1. - xp, 8. * xp * (0.5 * c + 0.5 * d2));\n        col = clamp(col, 0., 1.);\n    }\n    \n    if (iFrame == 0 || key_down(KEY_RESET)) {     \n        col = vec3(0);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtyfRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 332]], "test": "untested"}
{"id": "NlyfR3", "name": "basic lever", "author": "jorge2017a2", "description": "basic lever", "tags": ["basiclever"], "likes": 5, "viewed": 195, "published": 3, "date": "1664893637", "time_retrieved": "2024-07-30T16:28:15.329405", "image_code": "//por jorge2017a2\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n/// y El grande Grupo de Shadertoy\n///basic lever-----4-oct-2022\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n\n#define S(d,b) smoothstep(antialiasing(1.5),0. , d - (b) )\n#define S2(d,b) smoothstep(8.0*antialiasing(1.5),0.,d - (b) )\n\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 cs(float x)\n{ return vec2(cos(x),sin(x) );}\n\n\n\nvec3 brazoPalanca(vec2 p, vec3 colOut)\n{    float l1,l2,l3,l4a,l4b,l5a,l5b;\n    float a1, a2,a3,a4a,a4b,a5a,a5b;\n    vec2 p0,p1,p2,p3,p4a, p4b,p5a,p5b;\n    \n    float t=iTime*0.5;\n    l1=-2.5;\n    l2=3.5;\n    l3=4.5;\n    p0=vec2(0.0,0.0);\n     a1=radians(360.*sin(t*1.0));\n    float b=asin(-(l1*sin(a1))/l2); //referencia  https://www.desmos.com/calculator/eb4arug8ln\n    a2=b;\n    a3=radians(0.0);\n    \n    p1=p0+l1*cs(a1);\n    p2=vec2(l1*cos(a1)+l2*cos(a2),0.0); ///caso  especial\n    p3=p2+l3*cs(a3);\n   \n    float ds3= sdCircle(p-p2,l2);\n    float ds4b= sdCircle(p,abs(l1));\n    float db1= sdBox(p-p3, vec2(0.5) );\n    \n    float d1= sdSegment(p,p0,p1);\n    float d2= sdSegment(p,p1,p2);\n    float d3= sdSegment(p,p2,p3);\n    float d4= sdSegment(p-vec2(abs(l1)+l2+l3+0.5,0.0),vec2(0.0,3.0),vec2(0.0,-3.0));\n    \n    float db2= sdBox(p-vec2(8.0,0.9), vec2(3.0,0.25) );\n    float db3= sdBox(p-vec2(8.0,-0.9), vec2(3.0,0.25) );\n    \n    vec3 col=colOut;\n    col= DrawFigBorde(vec3(1.0,0.0,0.0), col,abs(d4)-0.1 ); //pared\n    col= DrawFigBorde(colOut, col,ds4b-0.1 );\n    col= DrawFigBorde(col, col,ds3-0.1 );\n    col= DrawFigBorde(vec3(0.0), col,abs(d1)-0.1 );\n    col= DrawFigBorde(vec3(1.0,0.0,0.0), col,abs(d2)-0.1 );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0), col,abs(d3)-0.1 );\n    col= DrawFigBorde(vec3(0.0), col,db1 );\n    col= DrawFigBorde(vec3(0.0,1.0,0.0), col,db2);\n    col= DrawFigBorde(vec3(0.0,1.0,0.0), col,db3);\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = ( 2.*fragCoord - iResolution.xy ) /iResolution.y;    \n    \n    uv-=vec2(0.0,-0.5);\n    float esc=8.0;\n    uv*=esc;\n    vec3 col=vec3(0.0,0.5,1.5);\n    col= brazoPalanca(uv-vec2(-5.0,5.0), col);\n    \n     //vignette\n    vec2 u = fragCoord/iResolution.xy;\n    uv = u; uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    vig = pow(vig, 0.25); // change pow for modifying the extend of the  vignette\n    col+=(col+ 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)))/4.0;\n    fragColor = vec4(col*vig,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlyfR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[382, 382, 444, 444, 574], [576, 576, 613, 613, 687], [689, 689, 724, 724, 747], [749, 749, 801, 801, 917], [919, 919, 937, 937, 967], [971, 971, 1011, 1011, 2417], [2418, 2418, 2475, 2475, 3022]], "test": "untested"}
{"id": "NlGBR3", "name": "Buffer Art Test 9183", "author": "SnoopethDuckDuck", "description": "just thinking about doing processing/p5js style art in shaders\n\nmore ideas here:\nhttps://www.shadertoy.com/view/flGfz3\nhttps://www.shadertoy.com/view/flyfz3  <- flashes at the start\nhttps://www.shadertoy.com/view/ftGfRc", "tags": ["pixelart"], "likes": 10, "viewed": 227, "published": 3, "date": "1664892318", "time_retrieved": "2024-07-30T16:28:16.406525", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc = 1.;\n    vec3 col = texelFetch(iChannel0, ivec2(sc *fragCoord), 0).rgb;\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\nvec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nfloat pxLine(vec2 f, vec2 p, vec2 q, float th) {\n    // Centre the coordinates at p\n    f -= p;\n\n    // Get direction from p to q, use for gradient and bounding box dimensions\n    vec2 dir = 0.5 * (q - p);\n    \n    // Look at the line as a function of x, and as a function of y\n    float l = max( step(abs(f.x - round(dir.x/dir.y * f.y)), th),\n                   step(abs(f.y - round(dir.y/dir.x * f.x)), th) );\n               \n    // Restrict to the box bounded by p and q           \n    return l * step(abs(f.x - dir.x), abs(dir.x))\n             * step(abs(f.y - dir.y), abs(dir.y));           \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    vec3 col = vec3(0);\n    vec2 res = iResolution.xy;\n    vec4 e = cell(ivec2(f));\n    col.rgb = e.rgb;\n    //col *= 0.99;\n    \n    \n    \n    // fragCoord must be offset by 0.5\n    //f -= 0.5 * vec2(iResolution) - 0.5;\n    f -= 0.5;\n    float t = float(iFrame) / 60.;//floor(60. * flo) / 60.;\n    float xp = exp(-0.08 * t);\n    int n = 10;\n    vec2 o = vec2(30. * t, 0.25 * res);\n    for (int i = 0; i < n; i++) {\n        t += 1. / ( float(n) * 60.);\n        // pxLine must take rounded positions as inputs \n        vec2 p = round(o);\n        vec2 q = round(o + xp * (150. + 50. * cos(700. * t)) * vec2(xp * cos(300. * t), sin(t)));\n        vec2 p2 = p + 1.;\n        vec2 q2 = q + 1.;\n        \n        vec3 pl = pal(t, 0.5 * vec3(0,1,2)/3.);\n    \n        // Draw the points\n        float s = step(min(length(f-p), length(f-q)), 2.);\n        col = mix(col, 0.5 * pl, s);\n        \n        // Draw the line (dark line + offset light line gives shadow effect)\n        col = mix(col, vec3(0), 0.5 * pxLine(f, p, q, 20. * xp));      \n        col = mix(col, pl, 0.5 * xp * pxLine(f - 8., p, q, 20. * xp));      \n    }\n    \n    if (iFrame == 0 || key_down(KEY_RESET)) {     \n        col = vec3(0);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGBR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 197]], "test": "untested"}
{"id": "flGfR3", "name": "Twitch tiles", "author": "Trixelized", "description": "For a Twitch integration experiment", "tags": ["twitch"], "likes": 17, "viewed": 390, "published": 3, "date": "1664890716", "time_retrieved": "2024-07-30T16:28:17.260242", "image_code": "float hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat2 rotate2d(float a) {\n    return mat2(cos(a),-sin(a),\n    sin(a),cos(a));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= (iResolution.x / iResolution.y);\n    uv = rotate2d(radians(45.0)) * uv;\n    float tile_mul = 5.0 + sin(iTime * 0.2);\n    uv.x += (1.0/tile_mul) * smoothstep(0.0, 0.75, sin(iTime * 0.5 + floor(uv.y * tile_mul) * 0.5));\n    vec2 tile_uv = fract(uv * tile_mul);\n    vec2 tile_pos = floor(uv * tile_mul);\n    vec3 col = vec3(0.5, 0.1, 1.0);\n    col *= 1.2 - 0.4 * mix(hash12(tile_pos), hash12(tile_pos + 0.2), 0.5 + (tile_uv.x + tile_uv.y)/2.0);\n    col += 0.25 * pow(2.0 * length(tile_uv.y - 0.5) * abs(cos(iTime * 0.5 + floor(uv.y * tile_mul) * 0.5)), 5.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGfR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 142], [144, 144, 168, 168, 222], [224, 224, 279, 279, 926]], "test": "untested"}
{"id": "7tKfRV", "name": "Build the Palace", "author": "dr2", "description": "Minimalist assembly instructions for \"Rector's Palace\"", "tags": ["architecture", "book", "structure"], "likes": 31, "viewed": 370, "published": 3, "date": "1664877205", "time_retrieved": "2024-07-30T16:28:18.424130", "image_code": "// \"Build the Palace\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n Minimalist assembly instructions for \"Rector's Palace\" (Xl2yzK).\n Cycle through all pages twice to see everything.\n Mouse overrides paging, view type (inside or outside), orientation (scene or book).\n For monochrome images latest additions are shown in green.\n*/\n\n#define AA  1  // (= 0/1) optional antialiasing (recommended)\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrBoxAn2Df (vec2 p, vec2 b, float w);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvec3 HexGrid (vec2 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 StdVuMat (float el, float az);\nfloat Hashfv2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat IFbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDirEx, sunDir, pgSize, qHit;\nvec2 stCent;\nfloat dstFar, tCur, msAz, msEl, dstFarEx, tRead, tpCyc, tpWait, tpBook, phsTurn, idPage,\n   outWd, corWd, flrHt, refSpRad;\nint idObj, bState;\nconst int nPage = 13;\nbool isBw, incBg, isWide;\nconst int idDnFlr = 1, idUpFlr = 2, idRf = 3, idStr = 4, idStWall = 5, idWall = 6, idPil = 7,\n   idBallSt = 8, idBallRf = 9, idCen = 10, idRefSph = 11;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid SetBldParms ()\n{\n  outWd = 20.;\n  corWd = 2.;\n  flrHt = 3.;\n  stCent = vec2 (-16., 2.);\n  refSpRad = 2.1;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq, qqq;\n  vec2 wSz;\n  float dMin, d, a, r, s;\n  dMin = dstFar;\n  qq = p;\n  a = (length (qq.xz) > 0.) ? atan (qq.z, - qq.x) : 0.;\n  qq.xz = Rot2D (qq.xz, 2. * pi * (floor (4. * a / (2. * pi) + 0.5) / 4.));\n  if (bState >= 1) {\n    q = p;\n    d = PrBoxDf (q, vec3 (outWd + 1., 0.2, outWd + 1.));\n    DMINQ (idDnFlr);\n    q = p;\n    q.y -= 0.8;\n    d = PrCylAnDf (q.xzy, 2.4, 0.15, 0.7);\n    DMINQ (idCen);\n  }\n  if (bState >= 2) {\n    q = qq;\n    q.x = abs (abs (q.x) - outWd + corWd) - corWd;\n    q.y -= 2. * flrHt + 0.1;\n    d = PrBox2Df (q.xy, vec2 (0.1, 2. * flrHt));\n    q.yz = mod (q.yz, vec2 (2. * flrHt + 0.2, 2. * corWd)) - vec2 (flrHt + 0.5, corWd);\n    wSz = vec2 (1.7, 1.3);\n    d = SmoothMax (d, - min (min (length (q.yz) - wSz.x, PrBox2Df (vec2 (q.z, q.y + wSz.y), wSz)),\n       PrBoxDf (((qq.x < corWd - outWd) ? vec3 (qq.x + outWd, qq.y - 0.5, abs (qq.z) - 2.) :\n       vec3 (qq.x + outWd - 2. * corWd, q.y + flrHt - 0.1, qq.z + 6.)), vec3 (0.25, 0.5, wSz.x))), 0.01);\n    if (bState == 2) d = max (d, qq.y - 0.25 * flrHt);\n    else if (bState == 3 || bState == 4) d = max (d, qq.y - 2.25 * flrHt);\n    DMINQ (idWall);\n  }\n  if (bState >= 4) {\n    q = qq;\n    q.x = abs (q.x) - outWd + corWd;\n    q.y -= 2. * flrHt + 0.15;\n    d = PrBox2Df (q.xy, vec2 (corWd + 0.2, 0.2));\n    DMINQ (idUpFlr);\n  }\n  if (bState >= 6) {\n    q = p;\n    q.xz = abs (mod (q.xz + corWd, 2. * corWd) - corWd) - 0.1;\n    q.y -= 2. * flrHt + 0.1;\n    d = max (PrCylDf (q.xzy, 0.07, 2. * flrHt), PrBoxAn2Df (p.xz, vec2 (outWd - 2.), 3.));\n    DMINQ (idPil);\n  }\n  if (bState >= 7) {\n    qqq = qq - vec3 (stCent, flrHt + 0.3).xzy;\n    q = qqq;\n    q.xz = Rot2D (q.xz, -0.73 * pi);\n    r = length (q.xz);\n    a = (r > 0.) ? atan (q.z, - q.x) : 0.;\n    q.xz = vec2 (26. * a / (2. * pi), r - 8.);\n    q.xy = Rot2D (q.xy, -0.25 * pi);\n    s = mod (q.x, 0.5 * sqrt (2.));\n    d = max (0.5 * max (q.y + abs (s - 0.25 * sqrt (2.)) - 0.25 * sqrt (2.),\n       max (- q.y - 0.1, abs (q.z) - 1.5)), abs (qqq.y + 0.2) - (flrHt + 0.2));\n    DMINQ (idStr);\n  }\n  if (bState >= 8) {\n    d = max (0.5 * max (abs (q.y - 0.3) - 0.4, abs (abs (q.z) - 1.6) - 0.1),\n       max (max (- qqq.x, qqq.z), - qqq.y - (flrHt + 0.2)));\n    q.x = a;\n    DMINQ (idStWall);\n    q = qq;\n    q.x = abs (q.x + 8.);\n    q -= vec3 (1.6, 0.9, 1.95);\n    d = PrSphDf (q, 0.15);\n    q = qq;\n    q.z = abs (q.z + 6.);\n    q -= vec3 (-15.95, 7.3, 1.6);\n    d = min (d, PrSphDf (q, 0.15));\n    DMINQ (idBallSt);\n  }\n  if (isBw && bState >= 9) {\n    q = p;\n    q.y -= refSpRad;\n    d = PrSphDf (q, refSpRad);\n    DMINQ (idRefSph);\n  }\n  if (bState >= 10) {\n    q = qq;\n    d = dot (vec2 (qq.y, abs (abs (qq.x) - outWd + corWd)), sin (0.15 * pi + vec2 (0.5 * pi, 0.))) -\n       4. * flrHt + (isBw ? 0.01 : 0.02) * sin (4. * pi * qq.z) - 0.2;\n    d = max (max (d, abs (qq.x + outWd - 2.) - 3.), 4. * flrHt + 0.1 - qq.y);\n    DMINQ (idRf);\n    q = p;\n    q.xz = abs (q.xz) - (outWd - corWd);\n    q.y -= 4. * flrHt + 1.8;\n    d = PrSphDf (q, 0.2);\n    DMINQ (idBallRf);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 ObjNfL (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  float s;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  s = dot (v, vec4 (1.));\n  return vec4 (normalize (2. * v.yzw - s), (s - 2. * v.x - 4. * ObjDf (p)) / (e.x * e.x));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 qHitT;\n  float sh, d, h;\n  int idObjT;\n  idObjT = idObj;\n  qHitT = qHit;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  idObj = idObjT;\n  qHit = qHitT;\n  return 0.5 + 0.5 * sh;\n}\n\nfloat Truch (vec2 p)\n{\n  vec2 ip;\n  ip = floor (p);\n  p -= ip + 0.5;\n  if (Hashfv2 (ip) < 0.5) p = vec2 (- p.y, p.x);\n  return min (length (0.5 + p), length (0.5 - p));\n}\n\nvec3 ShGrid (vec2 p, vec2 g, int stag)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (stag > 0 && 2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.02, 0.03, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.07 * pi * smoothstep (0.4, 0.47, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec4 ObjCol (vec3 ro, vec3 rd, inout vec3 vn)\n{\n  vec4 col4;\n  vec3 rg;\n  vec2 vf;\n  float s, w;\n  bool fxz;\n  vf = vec2 (0.);\n  if (idObj == idWall) {\n    col4 = vec4 (0.9, 0.8, 0.7, 0.1);\n    if (abs (qHit.x) < 0.095) {\n      if (! isBw) {\n        col4 *= 0.9;\n        vf = vec2 (64., 1.);\n      }\n    } else if (abs (vn.y) < 0.01) {\n      rg = ro;\n      rg.y = mod (rg.y, 2. * flrHt + 0.2);\n      fxz = (abs (vn.x) > 0.99);\n      rg = ShGrid ((fxz ? rg.zy : rg.xy), vec2 (2., 4.), 1);\n      col4 *= rg.y;\n      if (! isBw) {\n        rg.xz *= sign (fxz ? vn.x : vn.z);\n        if (fxz) {\n          if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n          else vn.xz = Rot2D (vn.xz, rg.x);\n        } else {\n          if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n          else vn.zx = Rot2D (vn.zx, rg.x);\n        }\n        vf = vec2 (32., 1.);\n      }\n    }\n  } else if (idObj == idDnFlr) {\n    col4 = vec4 (0.8, 0.75, 0.7, 0.1);\n    rg = ShGrid (ro.xz, vec2 (1.), 0);\n    s = Maxv2 (abs (ro.xz));\n    w = length (ro.xz) - 2.5;\n    if (w < 0.) col4.rgb *= vec3 (0., 0.4, 0.6);\n    else col4.rgb *= rg.y;\n    if (s > outWd) col4.rg *= 0.95;\n    if (! isBw) {\n      if (vn.y > 0.99) {\n        if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);\n        else vn.yx = Rot2D (vn.yx, rg.x);\n      }\n      if (w > 0. && s < outWd - 2. * corWd) col4.rg *= 0.8 + 0.1 *\n         smoothstep (0.3, 0.4, length (fract (ro.xz) - 0.5));\n      else if (s < outWd) col4.rgb = mix (col4.rgb, vec3 (0.5, 0.5, 0.8),\n         SmoothBump (0.45, 0.55, 0.02, Truch (ro.xz)));\n      vf = vec2 (64., 0.5);\n    }\n } else if (idObj == idUpFlr) {\n    col4 = vec4 (0.75, 0.65, 0.7, 0.1);\n    rg = ShGrid (ro.xz, vec2 (1.), 0);\n    col4.rgb *= rg.y;\n    if (! isBw) {\n      if (vn.y > 0.99) {\n        if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);\n        else vn.yx = Rot2D (vn.yx, rg.x);\n        if (abs (Maxv2 (abs (ro.xz)) - outWd + corWd) < corWd) col4.rgb = mix (col4.rgb,\n           vec3 (0.3, 0.7, 0.3), SmoothBump (0.45, 0.55, 0.02, Truch (2. * ro.xz)));\n      }\n      vf = vec2 (64., 0.5);\n    } else {\n      col4.rgb *= 1.1;\n    }\n  } else if (idObj == idRf) {\n    col4 = (vn.y > 0.) ? vec4 (0.8, 0.3, 0., 0.1) : vec4 (0.8, 0.5, 0.4, 0.1);\n    if (! isBw) col4 *= 0.6 + 0.4 * smoothstep (0.03, 0.05, abs (fract (2. * qHit.x + 0.5) - 0.5));\n  } else if (idObj == idStr) {\n    col4 = vec4 (0.8, 0.8, 0.9, 0.1);\n    col4 *= 0.6 + 0.4 * smoothstep (0.03, 0.05, abs (fract (2. * qHit.z + 0.5) - 0.5));\n    if (! isBw) {\n      vf = vec2 (64., 0.5);\n    }\n  } else if (idObj == idStWall) {\n    col4 = vec4 (0.8, 0.8, 0.9, 0.1);\n    rg = ShGrid (qHit.xy - vec2 (0., 0.1), vec2 (20., 5.), 1);\n    col4 *= rg.y;\n    if (! isBw) {\n      if (abs (vn.y) < 0.01) {\n        if (rg.x == 0.) vn = normalize (vec3 (vn.xz, rg.z)).xzy;\n        else vn.xz = Rot2D (vn.xz, - rg.x);\n      }\n      vf = vec2 (32., 1.);\n    }\n  } else if (idObj == idPil) {\n    col4 = vec4 (0.7, 0.7, 0.8, 0.1);\n    if (! isBw) {\n      s = fract (4. * mod (ro.y, 2. * flrHt + 0.2));\n      col4 *= 0.8 + 0.2 * smoothstep (0.03, 0.05, abs (s));\n      vn = normalize (vec3 (vn.xz, -0.3 * (1. - smoothstep (0.05, 0.1, abs (s))) * sign (s))).xzy;\n      vf = vec2 (32., 1.);\n    }\n  } else if (idObj == idBallSt || idObj == idBallRf) {\n    col4 = vec4 (1., 1., 0.1, 0.3);\n  } else if (idObj == idCen) {\n    col4 = vec4 (0.8, 0.9, 0.7, 0.1);\n    rg = ShGrid (vec2 (atan (ro.z, - ro.x) / pi, ro.y + 0.05), vec2 (16., 4.), 1);\n    col4 *= rg.y;\n    if (! isBw) {\n      if (vn.y < 0.01) {\n        if (rg.x == 0.) vn = normalize (vec3 (vn.xz, rg.z)).xzy;\n        else vn.xz = Rot2D (vn.xz, - rg.x);\n      }\n      vf = vec2 (32., 1.);\n    }\n  } else if (idObj == idRefSph) {\n    col4 = vec4 (1., 1., 0.1, 0.3);\n  }\n  if (! isBw && vf.y > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n  return col4;\n}\n\nvec3 GrndCol (vec3 ro, vec3 rd, float dstGrnd, inout vec3 vn)\n{\n  vec3 col, qh;\n  vec2 vf;\n  vn = vec3 (0., 1., 0.);\n  vf = vec2 (0.);\n  if (length (ro.xz) < 50.) {\n    col = vec3 (0.5, 0.5, 0.55);\n    qh = HexGrid (1.5 * ro.xz);\n    vn.yz = Rot2D (vn.yz, 0.5 * max (length (qh.xy) - 0.3, 0.) *\n       (1. - smoothstep (-0.1, -0.05, rd.y)));\n    vn.zx = vn.z * vec2 (qh.x, - qh.y) / length (qh.xy);\n    vf = vec2 (16., 0.5);\n  } else {\n    col = vec3 (0.4, 0.4, 0.3) * (0.85 + 0.15 * smoothstep (0.3, 0.7, Fbm2 (8. * ro.xz)));\n    vf = vec2 (4., 1.);\n  }\n  vf.y *= 1. - smoothstep (0.3, 0.6, dstGrnd / dstFar);\n  if (vf.y > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n  return col;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd, a;\n  a = atan (rd.z, - rd.x) / (2. * pi) + 0.5;\n  if (rd.y > -0.02 && rd.y < 0.02 * mix (IFbm1 (16. * (a + 1.)), IFbm1 (16. * a), a)) {\n    col = vec3 (0.3, 0.35, 0.45);\n  } else {\n    q = 0.02 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float b, d, w, dMin;\n  dMin = dstFar;\n  b = dot (rd, ro);\n  w = b * b - dot (ro, ro) + rad * rad;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    if (d > 0.) {\n      dMin = d;\n      vn = (ro + d * rd) / rad;\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, vn4, ds4;\n  vec3 col, vn;\n  float dstObj, dstSph, dstGrnd, sh;\n  bool isNu;\n  dstObj = ObjRay (ro, rd);\n  dstGrnd = dstFar;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    dstObj = ObjRay (ro, rd);\n    if (! isBw) {\n      if (k == 0) {\n        ds4 = SphHit (ro - vec3 (0., refSpRad, 0.), rd, refSpRad);\n        dstSph = ds4.x;\n        if (dstSph < min (dstObj, dstFar)) {\n          ro += dstSph * rd;\n          rd = reflect (rd, ds4.yzw);\n          ro += 0.01 * rd;\n        } else break;\n      }\n    } else break;\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    if (isBw) {\n      vn4 = ObjNfL (ro);\n      vn = vn4.xyz;\n    } else {\n      vn = ObjNf (ro);\n    }\n  } else if (incBg && rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    vn = vec3 (0., 1., 0.);\n  }\n  sh = (incBg && (min (dstObj, dstGrnd) < dstFar || rd.y < 0.)) ?\n     ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n  isNu = false;\n  if (dstObj < dstFar) {\n    col4 = ObjCol (ro, rd, vn);\n    if (isBw) {\n      col = vec3 (1.) * pow (Maxv3 (col4.rgb), 0.7);\n      if (bState == 1) isNu = (idObj == idCen);\n      if (bState == 2 || bState == 3 && ro.y > 0.85 ||\n         bState == 5 && ro.y > 1.05 + 2. * flrHt) isNu = (idObj == idWall);\n      if (bState == 4) isNu = (idObj == idUpFlr);\n      if (bState == 6) isNu = (idObj == idPil);\n      if (bState == 7) isNu = (idObj == idStr);\n      if (bState == 8) isNu = (idObj == idStWall || idObj == idBallSt);\n      if (bState == 9) isNu = (idObj == idRefSph);\n      if (bState == 10) isNu = (idObj == idRf || idObj == idBallRf);\n      if (isNu) col.rb *= 0.2;\n      col *= (1. - 0.5 * smoothstep (0.5, 1., abs (vn4.w) / 64.)) *\n         (0.5 + 0.5 * max (dot (vn, sunDir), 0.));\n    } else {\n      col = col4.rgb * (0.2 + 0.1 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n         0.1 * step (sh, 0.95) * abs (dot (vn, sunDir * normalize (vec3 (-1., 0., -1.)))) +\n         0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n    }\n  } else if (incBg && rd.y < 0.) {\n    col4.rgb = GrndCol (ro, rd, dstGrnd, vn);\n    col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.));\n    col = mix (col, vec3 (0.3, 0.35, 0.45), pow (1. + rd.y, 16.));\n  } else {\n    col = (incBg) ? SkyBgCol (ro, rd) : vec3 (0.7, 0.7, 0.75);\n  }\n  col = clamp (col, 0., 1.);\n  if (! isBw) col = pow (col, vec3 (0.8));\n  return col;\n}\n\nvoid ExMain  (out vec3 fCol, in vec2 fCoord, float asp)\n{\n  mat3 vuMat;\n  vec3 ro, rd;\n  float el, az, zmFac;\n  isBw = (bState < 11);\n  incBg = (bState >= 12);\n  if (! isWide) {\n    el = -0.15 * pi;\n    az = 0.2 * pi;\n    ro = vec3 (0., 1.9, -100.);\n    zmFac = 3.9;\n    fCoord /= zmFac;\n  } else {\n    el = -0.02 * pi;\n    az = 0.;\n    ro = vec3 (0., 3., -16.);\n    zmFac = 1.5;\n    fCoord /= zmFac;\n    fCoord.x = 2. * tan (0.5 * atan (fCoord.x / asp)) * asp;\n  }\n  if (idPage > 0.) {\n    az += (msAz > -999.) ? msAz : 0.;\n    el += (msEl > -999.) ? msEl : 0.;\n    el = clamp (el, -0.4 * pi, -0.02 * pi);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * ro;\n  dstFar = 200.;\n  rd = vuMat * normalize (vec3 (fCoord, 1.));\n  sunDir = normalize (vec3 (1., 3., -1.));\n  SetBldParms ();\n  fCol = ShowScene (ro, rd);\n}\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, rRad, hRad, hOff, np, bc, thFac, nRing, y, s, w;\n  dMin = dstFarEx;\n  rRad = 0.3;\n  hRad = 0.06;\n  nRing = 4.;\n  hOff = 0.15;\n  thFac = 2.2;\n  np = float (nPage - 1);\n  q = p;\n  s = mod (nRing, 2.);\n  w = pgSize.x / nRing;\n  bc = q.x;\n  bc = mod (bc + s * w, 2. * w) - w;\n  for (int k = VAR_ZERO; k < nPage; k ++) {\n    q = p;\n    q.y -= 0.5 * np * thFac * pgSize.y;\n    y = q.y + np * thFac * pgSize.y * phsTurn;\n    if (k == 0) q.zy = Rot2D (vec2 (q.z, y), 2. * pi * phsTurn);\n    else q.y -= thFac * pgSize.y * (phsTurn - float (k));\n    d = hRad - length (vec2 (q.z + rRad, bc));\n    q.z -= - (pgSize.z - hOff + rRad);\n    d = max (PrRoundBoxDf (q, pgSize - pgSize.y, pgSize.y), d);\n    DMINQ (k + 1);\n  }\n  q = p;\n  d = abs (q.x) - pgSize.x;\n  q.x = bc;\n  q = q.zyx;\n  d = max (PrTorusDf (q, 0.8 * hRad, rRad + 0.3 * hRad), d);\n  DMINQ (nPage + 1);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFarEx) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ExObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, c, vn;\n  vec2 s, w;\n  float dstObj, sh, npCyc, nDotL, t, asp, d;\n  bool isImg;\n  pgSize = vec3 (3.4, 0.011, 1.7);\n  t = (tpBook < 0.) ? (- tpBook * float (nPage - 1) * (tpCyc + tpWait)) :\n     mod (tpBook - tpWait, tRead);\n  npCyc = mod (floor (t / (tpCyc + tpWait)), float (nPage));\n  phsTurn = min (fract (t / (tpCyc + tpWait)) * (tpCyc + tpWait) / tpCyc, 1.);\n  isImg = false;\n  dstObj = ExObjRay (ro, rd);\n  if (dstObj < dstFarEx) {\n    ro += dstObj * rd;\n    vn = ExObjNf (ro);\n    nDotL = max (dot (vn, ltDirEx), 0.);\n    if (idObj <= nPage) {\n      idPage = mod ((float (idObj - 1) + npCyc), float (nPage));\n      c = vec3 (0.85, 0.85, 0.9) * (0.85 + 0.15 * Fbm2 (8. * qHit.xz));\n      col4 = vec4 (c, 0.2);\n      s = pgSize.xz - abs (qHit.xz);\n      if (qHit.y > 0.) {\n        w = qHit.xz / pgSize.z;\n        if (min (s.x, s.y) > 0.3) {\n          isImg = true;\n          asp = pgSize.x / pgSize.z;\n          if (idPage > 0.) {\n            bState = int (idPage);\n          } else {\n            bState = 12;\n            isWide = (qHit.x < 0.);\n            w -= sign (qHit.x) * vec2 (0.45 * asp, -0.2);\n            if (abs (w.x) > 0.84 || abs (w.y) > 0.37) isImg = false;\n            w *= 2.2;\n          }\n          if (isImg) ExMain (col, w, asp);\n          if (idPage == 0.) {\n            if (fract (tCur) < 0.8) {\n              w -= vec2 (1.7, -0.7);\n              d = min (length (max (abs (w) - vec2 (0.1, 0.002), 0.)),\n                 length (max (abs (Rot2D (vec2 (w.x - 0.1, abs (w.y)), 0.2 * pi)) -\n                 vec2 (0.1, 0.002), 0.)));\n              col = mix (vec3 (0., 1., 0.), col, smoothstep (0., 0.01, length (d)));\n            }\n          }\n        } else if (min (s.x, s.y) > 0.27) {\n          col4 = vec4 (0.6 * c, 0.2);\n        }\n      }\n    } else if (idObj == nPage + 1) {\n      col4 = vec4 (0.95, 0.95, 0.8, 0.2);\n      nDotL *= nDotL;\n    }\n    sh = ExObjSShadow (ro + 0.001 * vn, ltDirEx);\n    if (isImg) col *= 0.2 + 0.8 * sh;\n    else col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDirEx - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (0.8);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tpBook = max (1.3 * tCur - 0.3, 0.);\n  az = 0.;\n  el = -0.5 * pi;\n  msAz = -999.;\n  msEl = -999.;\n  tpCyc = 3.;\n  tpWait = 4.;\n  tRead = float (nPage) * (tpCyc + tpWait);\n  isWide = (mod (tpBook - tpWait, 2. * tRead) > tRead);\n  if (mPtr.z > 0.) {\n    if (abs (mPtr.y) > 0.4) {\n      tpBook = - clamp (1.05 * mPtr.x + 0.45, 0., 1.);\n      isWide = (mPtr.y > 0.);\n    } else if (abs (mPtr.x) > 0.45) {\n      el += pi * mPtr.y * smoothstep (0.1, 0.15, abs (mPtr.y));\n    } else if (abs (mPtr.x) < 0.42 && abs (mPtr.y + 0.05) < 0.35) {\n      msAz = pi * clamp (mPtr.x / 0.4, -1., 1.);\n      msEl = pi * mPtr.y;\n    }\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0., -1.65, -19.);\n  zmFac = 9.;\n  dstFarEx = 40.;\n  ltDirEx = normalize (vec3 (1., 1., -0.3));\n  ro = vuMat * ro;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ExShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBoxAn2Df (vec2 p, vec2 b, float w)\n{\n  return max (PrBox2Df (p, vec2 (b + w)), - PrBox2Df (p, vec2 (b - w)));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HexGrid (vec2 p)\n{\n  vec2 q;\n  p -= HexToPix (PixToHex (p));\n  q = abs (p);\n  return vec3 (p, (sqrt3/2.) - q.x + 0.5 * min (q.x - sqrt3 * q.y, 0.));\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat IFbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 10.;\n  for (int j = 0; j < 3; j ++) {\n    f += floor (a * Noiseff (p));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / (1.75 * a));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKfRV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1815, 1815, 1836, 1836, 1927], [1929, 1929, 1951, 1951, 4991], [4993, 4993, 5026, 5026, 5210], [5212, 5212, 5233, 5233, 5488], [5490, 5490, 5512, 5512, 5841], [5843, 5843, 5880, 5880, 6205], [6207, 6207, 6229, 6229, 6377], [6379, 6379, 6419, 6419, 6793], [6795, 6795, 6842, 6842, 10605], [10607, 10607, 10670, 10670, 11285], [11287, 11287, 11321, 11321, 12144], [12146, 12146, 12189, 12189, 12444], [12446, 12446, 12481, 12481, 14920], [14922, 14922, 14979, 14979, 15735], [15737, 15737, 15761, 15761, 16659], [16661, 16661, 16696, 16696, 16877], [16879, 16879, 16902, 16902, 17159], [17161, 17161, 17200, 17200, 17431], [19673, 19673, 19729, 19729, 21215], [21217, 21217, 21249, 21249, 21349], [21351, 21351, 21384, 21384, 21473], [21475, 21475, 21521, 21521, 21568], [21570, 21570, 21614, 21614, 21689], [21691, 21691, 21724, 21724, 21751], [21753, 21753, 21795, 21795, 21846], [21848, 21848, 21901, 21901, 21962], [21964, 21964, 22010, 22010, 22067], [22069, 22069, 22093, 22093, 22323], [22325, 22325, 22349, 22349, 22409], [22411, 22411, 22434, 22434, 22566], [22568, 22568, 22590, 22590, 22617], [22619, 22619, 22641, 22641, 22668], [22670, 22670, 22692, 22692, 22730], [22732, 22732, 22777, 22777, 22869], [22871, 22871, 22916, 22916, 22954], [22956, 22956, 23013, 23013, 23096], [23098, 23098, 23128, 23128, 23241], [23243, 23243, 23274, 23274, 23338], [23340, 23340, 23376, 23376, 23582], [23616, 23616, 23640, 23640, 23700], [23702, 23702, 23726, 23726, 23779], [23781, 23781, 23805, 23805, 23917], [23919, 23919, 23944, 23944, 24090], [24092, 24092, 24117, 24117, 24301], [24303, 24303, 24326, 24326, 24493], [24495, 24495, 24516, 24516, 24671], [24673, 24673, 24702, 24702, 24914], [24916, 24916, 24955, 24955, 25207]], "test": "untested"}
{"id": "slKfRK", "name": "xiaoming::circle", "author": "xiao_ming", "description": "this is a circle", "tags": ["2d"], "likes": 0, "viewed": 129, "published": 3, "date": "1664866530", "time_retrieved": "2024-07-30T16:28:19.362621", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n  uv *= 2.;\n  vec3 col = .5 + .5 * cos(iTime + uv.xyx + vec3(0, 2, 4));\n  vec2 tmp = fragCoord - iResolution.xy * .5;\n  col *= 1. - step(10000., dot(tmp, tmp));\n  fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKfRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 287]], "test": "untested"}
{"id": "7lKBRK", "name": "Outpainting experiment #2", "author": "sh1boot", "description": "Trying to use just the alpha channel and mipmaps to move the texture coordinate to valid data.\n\nWant to move more slowly when near the edge, but it's going badly.", "tags": ["extrapolation", "predator", "inpainting", "stealth", "outpainting"], "likes": 3, "viewed": 245, "published": 3, "date": "1664864424", "time_retrieved": "2024-07-30T16:28:20.313080", "image_code": "float blurryalpha(vec2 uv) {\n    float sum = 0.0;\n    float div = 0.0;\n    for (int i = 2; i < 11; ++i) {\n        float scale = pow(1.40, float(i));\n        float bias = float(i);\n        sum += texture(iChannel1, uv, float(i)).a * scale;\n        div += scale;\n    }\n    return sum / div;\n}\n\nvec2 alphagradient(vec2 uv, float eps) {\n    vec3 ho = vec3(-eps, eps, 0.0);\n    vec3 vo = vec3(-eps, eps, 0.0);\n    float lf = blurryalpha(uv + ho.xz);\n    float rt = blurryalpha(uv + ho.yz);\n    float up = blurryalpha(uv + vo.zx);\n    float dn = blurryalpha(uv + vo.zy);\n    return vec2(rt - lf, dn - up) / eps;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 bkg = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec4 colour = texture(iChannel0, uv);\n    float magic = blurryalpha(uv);\n    for (int i = 0; i < 6; ++i) {\n        if (colour.a >= 0.95) break;\n        float alpha = blurryalpha(uv);\n        alpha *= alpha;\n        alpha *= alpha;\n        vec2 dir = alphagradient(uv, 0.02);\n        if (length(dir) < 0.001) dir = alphagradient(uv, 0.1);\n#if 0\n        float scale = 0.125 * (1.0 - alpha);\n#else\n        float scale = 0.125 / (alpha + 0.3);\n#endif\n        uv += scale * normalize(dir);\n        colour = texture(iChannel0, uv);\n    }\n\n    bkg = bkg * (1.0 - colour.a) + colour.rgb * colour.a;\n\n    // Output to screen\n    fragColor = vec4(bkg,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 colour = texture(iChannel0, uv);\n\n    colour.a = texture(iChannel1, uv).a;\n\n    fragColor = colour;\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    float alpha = smoothstep(0.2, 0.35, col.g - max(col.r, col.b));\n\n    fragColor = vec4(alpha);\n}", "buffer_b_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKBRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 290], [292, 292, 332, 332, 607], [609, 609, 666, 716, 1471]], "test": "untested"}
{"id": "NtKBRV", "name": "Diamond Tiling - 150 chars", "author": "GregRostami", "description": "Diamond Tiling.\nUse the Mouse Y to control the size of tiling.", "tags": ["2d", "tiling", "short"], "likes": 7, "viewed": 252, "published": 3, "date": "1664858410", "time_retrieved": "2024-07-30T16:28:21.290467", "image_code": "// 150 chars - Further golfing by Jedi Master Fabrice!\nvoid mainImage(out vec4 o, vec2 u)\n{ \n    vec2 r = iResolution.xy,\n         s = 1e2*( .3 + iMouse.yy/r.y ) / r.y;    \n    mat2 m = mat2(1,-1,1,1);\n    o = texture(iChannel0, m*ceil(.5*u*m*s)/s/r);\n}\n\n// 153 chars - Golfed by golf master Xor and Greg Rostami\n/*\nvoid mainImage(out vec4 o, vec2 u)\n{ \n    vec2 r = iResolution.xy,\n         s = 30. + 1e2*iMouse.yy/r.y;     \n    mat2 S = mat2(1,-1,1,1);\n    o = texture(iChannel0,  S*ceil(.5*u/r.y*S*s)/s*r.y/r);\n}\n*/\n\n// 181 chars - Original shader by Greg Rostami\n/*\nvoid mainImage(out vec4 o, vec2 u)\n{ \n    vec3 r = iResolution;\n    u *= .5/r.y;\n    o.xy =  ceil( vec2(u.x-u.y, u.x+u.y) * (r.z = 30. + 1e2*iMouse.y/r.y)) / r.z;\n    o = texture(iChannel0,  vec2 ( r.y/r.x * (o.x+o.y), o.y-o.x) );\n}\n*/", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtKBRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 55, 91, 91, 253]], "test": "untested"}
{"id": "7tyfzK", "name": "Illuminated sphere", "author": "mrange", "description": "CC0: Illuminated sphere\nI like the Windows 11 sphere wallpapers.\nCreated this as an impression of them\n", "tags": ["3d", "sphere"], "likes": 40, "viewed": 485, "published": 3, "date": "1664823088", "time_retrieved": "2024-07-30T16:28:22.151165", "image_code": "// CC0: Illuminated sphere\n//  I like the Windows 11 sphere wallpapers.\n//  Created this as an impression of them\n\n// Comment if you don't like the color cycling\n#define POSTPROC\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nvec3 rgb2hsv(vec3 c) {\n  const vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nconst vec3 skyCol     = HSV2RGB(vec3(0.58, 0.86, 1.0));\nconst vec3 speCol1    = HSV2RGB(vec3(0.60, 0.25, 1.0));\nconst vec3 speCol2    = HSV2RGB(vec3(0.55, 0.25, 1.0));\nconst vec3 diffCol1   = HSV2RGB(vec3(0.60, 0.90, 1.0));\nconst vec3 diffCol2   = HSV2RGB(vec3(0.55, 0.90, 1.0));\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nvec2 raySphere(vec3 ro, vec3 rd, vec4 dim) {\n  vec3 ce = dim.xyz;\n  float ra = dim.w;\n  vec3 oc = ro - ce;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - ra*ra;\n  float h = b*b - c;\n  if( h<0.0 ) return vec2(-1.0); // no intersection\n  h = sqrt( h );\n  return vec2( -b-h, -b+h );\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  const vec3 sunDir1 = normalize(vec3(0., 0.1, 1.0));\n  const vec3 sunDir2 = normalize(vec3(0., 0.82, 1.0));\n  vec3 col = vec3(0.0);\n  col += 0.025*skyCol;\n//  col += clamp(vec3(0.0025/abs(rd.y))*skyCol, 0.0, 1.0);\n//  col += skyCol*0.0005/pow((1.0001+((dot(sunDir1, rd)))), 2.0);\n  col += skyCol*0.0033/pow((1.0001+((dot(sunDir2, rd)))), 2.0);\n\n  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n  float tp = tp1;\n  tp = max(tp0,tp1);\n\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n  }\n\n  if (tp0 > 0.0) {\n    vec3 pos  = ro + tp0*rd;\n    vec2 pp = pos.xz;\n    float ds = length(pp) - 0.5;\n    \n    col += vec3(0.25)*skyCol*exp(-.5*max(ds, 0.0));\n  }\n\n  return clamp(col, 0.0, 10.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 skyCol = skyColor(ro, rd);\n  vec3 col = skyCol;\n  \n  const vec4 sdim = vec4(vec3(0.0), 2.0);\n  vec2 si = raySphere(ro, rd, sdim);\n  \n  vec3 nsp = ro + rd*si.x;\n\n  const vec3 lightPos1   = vec3(0.0, 10.0, 10.0);\n  const vec3 lightPos2   = vec3(0.0, -80.0, 10.0);\n  \n  vec3 nld1   = normalize(lightPos1-nsp); \n  vec3 nld2   = normalize(lightPos2-nsp); \n  \n  vec3 nnor   = normalize(nsp - sdim.xyz);\n\n  vec3 nref   = reflect(rd, nnor);\n\n  const float sf = 4.0;\n  float ndif1 = max(dot(nld1, nnor), 0.0);\n  ndif1       *= ndif1;\n  vec3 nspe1  = pow(speCol1*max(dot(nld1, nref), 0.0), sf*vec3(1.0, 0.8, 0.5));\n\n  float ndif2 = max(dot(nld2, nnor), 0.0);\n  ndif2       *= ndif2;\n  vec3 nspe2  = pow(speCol2*max(dot(nld2, nref), 0.0), sf*vec3(0.9, 0.5, 0.5));\n\n  vec3 nsky   = skyColor(nsp, nref);\n  float nfre  = 1.0+dot(rd, nnor);\n  nfre        *= nfre;\n\n  vec3 scol = vec3(0.0); \n  scol += nsky*mix(vec3(0.25), vec3(0.5, 0.5, 1.0), nfre);\n  scol += diffCol1*ndif1;\n  scol += diffCol2*ndif2;\n  scol += nspe1;\n  scol += nspe2;\n\n  if (si.x > 1.0) {\n    col = mix(col, scol, tanh_approx(0.9*(si.y-si.x)));\n  }\n\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  const float fov = tan(TAU/6.0);\n  const vec3 ro = 1.0*vec3(0.0, 2.0, 5.0);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = cross(ww,uu);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render(ro, rd);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  col = aces_approx(col); \n#if defined(POSTPROC)  \n  vec3 hsv = rgb2hsv(col);\n  hsv.x = fract(hsv.x-(-abs(p.x)*p.y+p.y*p.y)*0.08+0.01*TIME);\n  col = hsv2rgb(hsv);\n#endif  \n  col = sRGB(col);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tyfzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[452, 452, 474, 474, 620], [914, 1005, 1027, 1027, 1352], [1635, 1735, 1754, 1754, 1841], [1843, 1950, 1976, 1976, 2160], [2162, 2222, 2250, 2316, 2392], [2394, 2506, 2548, 2548, 2595], [2597, 2715, 2742, 2742, 2818], [2820, 2942, 2986, 2986, 3231], [3233, 3233, 3266, 3266, 4224], [4226, 4226, 4257, 4257, 5383], [5385, 5385, 5406, 5406, 5757], [5759, 5759, 5814, 5814, 6159]], "test": "untested"}
{"id": "slGfzK", "name": "Outpaint noise experiment", "author": "sh1boot", "description": "Fill in an undefined region of an image with something sort of contiguous with the defined part.\n\nThis is a quick-and-dirty (again) attempt at preparing an image for outpainting with AI.  But it's not very good.", "tags": ["noise", "outpainting"], "likes": 6, "viewed": 268, "published": 3, "date": "1664822937", "time_retrieved": "2024-07-30T16:28:22.933075", "image_code": "float hash(vec2 uv) {\n    // Seeing some weird discontinuity coming from overflow cases -- this'll fix it!\n    uv = vec2(ivec2(floatBitsToUint(uv.x), floatBitsToUint(uv.y))) / 65537.0;\n\n    const vec2 swiz = vec2(12.9898, 78.233);\n    return fract(sin(dot(uv, swiz)) * 43758.5453);\n}\n\nfloat hash(float f) {\n    return hash(vec2(f));\n}\n\nfloat noise(vec2 uv, float p) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    f = smoothstep(0.0, 1.0, f);\n    vec4 o = vec4(vec2(-0.5), vec2(0.5)) + fract(p * 1.73737373);\n    return mix(mix(hash(i + o.xy), hash(i + o.zy), f.x),\n               mix(hash(i + o.xw), hash(i + o.zw), f.x),\n               f.y);\n}\n\nfloat nnoise(vec2 uv, float p) {\n    return noise(uv, p) * 0.5\n         + noise(uv * 2.01, p) * 0.25\n         + noise(uv * 4.017, p) * 0.125\n         + noise(uv * 8.029, p) * 0.125;\n}\n\nfloat pnoise(vec2 uv, float r, float t) {\n    uv = r * vec2(\n      dot(uv, vec2(cos(t), sin(t))),\n      dot(uv, vec2(-sin(t), cos(t)))\n              );\n    return nnoise(uv, t + 1.0);\n}\n\nvec4 puke(vec2 uv) {\n   vec3 colour = vec3(\n       pnoise(uv, 18.0, 0.0),\n       pnoise(uv, 19.0, 1.0),\n       pnoise(uv, 21.0, 2.0)\n    );\n#if 0\n    colour *= mat3(\n        1.164, 0.0  , 1.596,\n        1.164,-0.392,-0.813,\n        1.164, 2.017, 0.0  );\n#endif\n\n    return smoothstep(0.0, 1.0, vec4(colour, 1.0));\n}\n\nvec2 scrib(float t, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n\nvec2 pscribble(vec2 uv, float r, float t) {\n    r *= 14.0;\n    return vec2(pnoise(uv, r, t), pnoise(uv, r, t + 1.0)) - vec2(0.5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 colour = vec4(0.0);\n\n    float yclip = 0.5 + sin(iTime * 0.01) * 0.3;\n\n    vec2 uvclip = vec2(uv.x, min(uv.y, yclip));\n    float s = uv.y - uvclip.y;\n    if (s > 0.0) {\n      colour.rgb = puke(uv).rgb;\n\n      vec2 wobble = s * s * pscribble(uv, 1.0, 0.0) * 2.0;\n      vec2 curl = s * (pscribble(uv, 0.2, 1.0) + vec2(0.0, -0.5));\n\n      uv = uvclip + wobble + curl;\n      s = smoothstep(0.2, 0.5, s);\n    }\n\n    vec4 tex = texture(iChannel0, uv);\n    if (uv.y > yclip) tex = vec4(0.0);\n    \n    colour.rgb = mix(tex.rgb, colour.rgb, s);\n    colour.a = texture(iChannel0, fragCoord / iResolution.xy).a;\n\n    fragColor = colour;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGfzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 106, 283], [285, 285, 306, 306, 334], [336, 336, 367, 367, 651], [653, 653, 685, 685, 836], [838, 838, 879, 879, 1023], [1025, 1025, 1045, 1045, 1340], [1342, 1342, 1395, 1395, 1444], [1447, 1447, 1490, 1490, 1578], [1581, 1581, 1638, 1638, 2318]], "test": "untested"}
{"id": "NlGfzV", "name": "snowy mountain by night", "author": "rcargou", "description": "Another derivate of iq's raymarcher and rainforst for the fbm", "tags": ["snowsdf"], "likes": 5, "viewed": 258, "published": 3, "date": "1664819465", "time_retrieved": "2024-07-30T16:28:23.939384", "image_code": "#define AA 1   // make this 2 or 3 for antialiasing\n#define ZERO min(iFrame, 0)\n\nfloat fbm_4( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=ZERO; i<9; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        float amp = 0.2 * step(4., float(i));\n        x = f * m2 * x * (1.-amp);\n        \n    }\n\treturn a;\n}\n\nfloat fbm_4( in vec3 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        float amp = 0.2 * step(4., float(i));\n        x = f * m3 * x * (1.-amp);\n    }\n\treturn a;\n}\n\nvec4 fbmd_7( in vec3 x )\n{\n    float f = 1.92;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=ZERO; i<7; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          // accumulate values\t\t\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3i*m;\n    }\n\treturn vec4( a, d );\n}\n\nvec4 fbmd_8( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.65;\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=ZERO; i<8; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          // accumulate values\t\t\n        if( i<4 )\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3i*m;\n    }\n\treturn vec4( a, d );\n}\n\nfloat fbm_9( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=ZERO; i<9; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n    \n\treturn a;\n}\n\nvec3 fbmd_9( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    vec2  d = vec2(0.0);\n    mat2  m = mat2(1.0,0.0,0.0,1.0);\n    for( int i=ZERO; i<9; i++ )\n    {\n        vec3 n = noised(x);\n        a += b*n.x;          // accumulate values\t\t\n        d += b*m*n.yz;       // accumulate derivatives\n        b *= s;\n        x = f*m2*x;\n        m = f*m2i*m;\n    }\n\n\treturn vec3( a, d );\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if ((res.x = length(pos - vec3(31.0, 14.0, 40.)) -1.5f) < .0f)\n        res.y = 2.0;\n    \n    float s = smoothstep(1., 105.3, pos.z);\n    float floorDist = pos.y  + .5 + fbm_9(pos.xz / 2.3) / 4.0\n    - s * (fbm_4(pos.xz / 30.0)) *60.;\n    if (floorDist  < res.x) {\n        res.x = floorDist;\n        res.y = 1.0;\n    }\n    \n    return res;\n    float r = 1.;\n    pos.x;// += pos.y * iTime / 50.;\n    vec2 id = floor(pos.xz * r);\n    float h = hash2(id.xy).x * 10. - iTime * 20. * (.5 + abs(hash2(id.xy).y)) / 2.;\n    vec3 pmod = vec3(mod(pos.xz, r) - vec2(r / 2.0), pos.y);\n    h = mod(h, 100.);\n    float snowflake = length(pmod*5. - vec3(0., 0., h))-0.2;\n    if (snowflake < res.x){\n        res.x = snowflake;\n        res.y = 1.0;\n    }\n    return res;\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 90.0;\n\n    // raymarch primitives   \n    {\n    \n        float t = tmin;\n        for( int i=ZERO; i<400 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.01*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x * 0.3;\n        }\n    }\n    \n    return res;\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.5;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n \n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 kMoonCol = vec3(196.0 / 255., 212.0 / 255., 304.0 / 255.);\nvec3 kDirtCol = vec3(18.0 / 255., 12.0 / 255., 35.0 / 255.);\nvec3 ndotl(vec3 light, vec3 nor, vec3 pos, vec3 ro) {\n return  kMoonCol* \n        max(.0f, dot(nor-normalize(pos - ro),  \n        light));\n}\n\nvec3 light(vec3 pos, vec3 nor, vec3 ro, vec3 rd) {\nfloat s = pow(abs(blueNoise( pos.xz / 1.) - 0.2), 4.0);\n     float sparkle = min(1.0, s); \n    vec3 ref = reflect(rd, nor);\n    vec3 l1_dir = normalize(vec3(-1.0f, 1.0f, 1.0f));\n    vec3 ret = vec3(.0);\n    ret += vec3(\n        max(.0, abs(pow(dot(ref, \n        l1_dir), 5.0) ))) * sparkle;\n    vec3 l1 = l1_dir;\n    vec3 l2 = normalize(vec3(10.0f, 1.0f, -1.0f));\n    ret += ndotl(l1, nor, pos, ro) + ndotl(l2, nor, pos, ro);\n    return ret;\n}\n\n\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in float distance ) // camera to point distance\n{\n    float fogAmount = 1.0 - exp( -distance*0.5 );\n    vec3  fogColor  = vec3(0.5,0.6,0.7) / 10.;\n    return mix( rgb, fogColor, fogAmount );\n}\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(.0f);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n    if (res.y >= 1.0 && res.x > 0.) {\n         float s = max(0., smoothstep(-1.0, 5.0, pos.y));\n         col = mix(vec3(1.0), kDirtCol, s * 1. * noise(pos.xz / 1.0));\n        \n    \tcol = col * 0.5 + light(pos, nor, ro, rd) * col;\n        col = applyFog(col, res.x / 10.);\n        } else if (res.x > 0.) {\n            \n            float u = 0.5f + atan(rd.y, rd.z) / (2. * 3.14);\n            float v = 0.5f - asin(rd.x  ) / 3.14;\n            vec2 uv = vec2(v * 1., u * 2.);\n            col = 1.6*pow(.2 + .8*vec3(.5*(1.0 + fbm_4(uv * 310.))), vec3(3.5));\n        }\n    else {\n        col = vec3(4.0 * pow(blueNoise(rd.xy * 2.0) - 0.4, 21.0 ));\n        res.x =10.;\n    }\n    \n   \treturn vec3(col);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat mapRectangle(vec2 p, vec2 dim) {\n    return smoothstep(0.01112, -0.01112, max( abs(p.x) - dim.x, abs(p.y) - dim.y));\n}\nfloat mapSnowFlake(vec2 p, float size) {\n\n    vec2 s = vec2(1., 20.0) * size;\n    float tot;\n    \n    tot += mapRectangle(p, s);\n    tot += mapRectangle(p * rotate2d(3.14 / 3.), s);\n    tot += mapRectangle(p * rotate2d(-3.14 / 3.), s);\n    \n    vec2 s2 = s / 4.;\n    s2.x = 0.;\n    for (int i = 0; i < 6; ++i) {\n       // tot += mapRectangle( ( p - vec2(0.01, 0.041) * rotate2d(float(i) * 3.14 / 2. + 3.14/2.) )  , s2 );\n    //    tot += mapRectangle( ( p * rotate2d(-3.14/3.) - vec2(-0.01, 0.041))  , s2 );\n    }\n    return tot;\n}\n\nvec3 snowFlakes(vec2 base_uv) {\n    \n    vec3 ret = vec3(0.);\n    \n    for (int i = 0; i < 4; ++i) {\n    \n    vec2 uv = base_uv;\n       uv.x += iTime / 10.;// * hash1(uv.x);\n \n//    vec2 uv = base_uv * float(i + 1) * 2.;\n    vec2 r = vec2(0.2, 2.0);\n    vec2 id = floor(uv / r);\n    \n    vec2 s = hash2(id.xx);\n    float speed = iTime * ( 1. + s.x) / 2.;\n    uv.y += speed;\n    vec2 m_uv = mod(uv, r) - r / 2.;\n    float size = 0.0021;\n    ret += vec3( mapSnowFlake(m_uv, size) );\n    base_uv *= 2.;\n    }\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = vec2(0);//iMouse.xy/iResolution.xy;\n\tfloat time = .0f; //iTime;\n\n    // camera\t\n    vec3 ro = vec3(.0f, 1.0f, -5.0f);//vec3( 4.6*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.6*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -0.0, 1.4, 0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = normalize( vec3(p.xy,2.0) * ca );\n\n        // render\t\n        vec3 col = render( ro, rd );\n        col = max(vec3(.0), col);\n        col += snowFlakes(p);\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "//==========================================================================================\n// hashes (low quality, do NOT use in production)\n//==========================================================================================\n\n#define hash21(p)  fract(sin(dot(p, vec2(11.9898, 78.233))) * 43758.5453) \n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nvec2 hash2( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    float n = 111.0*p.x + 113.0*p.y;\n    return fract(n*fract(k*n));\n}\nfloat blueNoise(vec2 U) {                           // 5-tap version \n    float v =  hash21( U + vec2(-1, 0) )\n             + hash21( U + vec2( 1, 0) )\n             + hash21( U + vec2( 0, 1) )\n             + hash21( U + vec2( 0,-1) ); \n    return  hash21(U) - v/4.  + .5;\n}\n//==========================================================================================\n// noises\n//==========================================================================================\n\n// value noise, and its analytical derivatives\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    #if 1\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    #else\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    #endif\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    #if 1\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec3 u = w*w*(3.0-2.0*w);\n    #endif\n    \n\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    #if 1\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec2 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    #else\n    vec2 u = w*w*(3.0-2.0*w);\n    vec2 du = 6.0*w*(1.0-w);\n    #endif\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return vec3( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k4*u.x*u.y), \n                 2.0*du * vec2( k1 + k4*u.y,\n                            k2 + k4*u.x ) );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    #if 1\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec2 u = w*w*(3.0-2.0*w);\n    #endif\n\n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n    \n    return -1.0+2.0*(a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y);\n}\n\n//==========================================================================================\n// fbm constructions\n//==========================================================================================\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\nconst mat2 m2i = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\n//------------------------------------------------------------------------------------------\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGfzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 107, 107, 393], [395, 395, 421, 421, 698], [700, 700, 726, 726, 1185], [1187, 1187, 1213, 1213, 1690], [1692, 1692, 1718, 1718, 1939], [1941, 1941, 1967, 1967, 2367], [2369, 2369, 2394, 2394, 3188], [3217, 3217, 3257, 3257, 3688], [3691, 3737, 3769, 3769, 3976], [3978, 3978, 4030, 4030, 4207], [4334, 4334, 4387, 4387, 4474], [4476, 4476, 4526, 4526, 4970], [4973, 4973, 5103, 5103, 5246], [5247, 5247, 5286, 5286, 6140], [6142, 6142, 6170, 6170, 6256], [6258, 6258, 6296, 6296, 6382], [6383, 6383, 6423, 6423, 6914], [6916, 6916, 6947, 6947, 7439]], "test": "untested"}
{"id": "ftGfzV", "name": "Ghost Head", "author": "byt3_m3chanic", "description": "Experiment with Transparent / Solid materials - just goofing around", "tags": ["crystallo"], "likes": 19, "viewed": 307, "published": 3, "date": "1664819195", "time_retrieved": "2024-07-30T16:28:24.861918", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    10/03/22 @byt3_m3chanic\n    Experiment with Transparent / Solid materials - just goofing around. And a good ole\n    isometric camera - makes it all pretty!\n    \n    Thanks to @blackle, @iq and @Drakyen\n*/\n\n#define R \t\tiResolution\n#define T \t\tiTime\n#define M \t\tiMouse\n\n#define PI          \t3.14159265358\n#define PI2         \t6.28318530718\n\n#define MAX_DIST    100.\n\n\n// AA = 1 = OFF else 2 > depending on GPU\n#define ZERO (min(iFrame,0))\n#define AA 2\n\nfloat hash21(vec2 a) { return fract(sin(dot(a,vec2(21.23,41.232)))*4123.2323); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n//@iq https://iquilezles.org/articles/distfunctions/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp(.5+.5*(d2-d1)/k, .0, 1. );\n    return mix( d2, d1, h ) - k*h*(1.-h);\n}\nfloat torus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.yx)-t.x,p.z);\n  return length(q)-t.y;\n}\nfloat vcap( vec3 p, float h, float r ){\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\nfloat cap( vec3 p, float r,float h ){\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat time;\nmat2 rx,ry,turn,r25;\nvec3 hit,hitpoint;\n\nfloat ghost(vec3 p, float hs) {\n    float res = 1e5;\n    vec3 q = p-vec3(0,-1.25,0);\n    \n    vec3 q2=q-vec3(0,1.5,.25);\n    vec3 q3=vec3(abs(q.x),q.yz)-vec3(.5,2.72,1.25);\n    vec3 q4 = q-vec3(0,2.72,1.65);\n    q4.x=abs(q4.x);q4.xz*=r25;\n    \n    float ghst = vcap(q,2.75,1.6);\n    float eyes = length(q3)-.45;\n    float lids = torus(q4-vec3(.6,0,0),vec2(.4,.09));\n    float chst = vcap(q,2.7,1.25);\n\n    float a = atan(q.z,q.x);\n    float tw = .2*sin(a*6.);\n    tw *=pow(length(q.xz),1.);\n    \n    float cuting = cap(q+vec3(0,1.,0),1.-tw,1.65)*.75;\n    \n    ghst = max(ghst,-cuting);\n    ghst = max(ghst,-eyes);\n    ghst = smin(lids,ghst,.08);\n    ghst = max(ghst,-chst);\n    \n    if(ghst<res ) {\n        res = ghst;\n    }\n\n    return res;\n}\n\nvec2 map (in vec3 p) { \n    vec2 res = vec2(MAX_DIST,0.);\n    vec3 q = p;\n\n\n    float tt = .35+.35*sin(time*1.05)+cos(.5*cos(time*.3)*5.);\n    float pt = 2.5*sin(time*1.4);\n    \n    p.y+=.5+pt;\n    p.xz*=turn;\n    \n    p.xz=abs(p.xz)-3.35;\n\n    vec2 np = p.xz;\n    float lt = length(np*PI);\n    float amp = (1./lt);\n    amp=clamp(amp,0.,.2);\n    \n    float wb = amp*sin(lt-time*PI2);\n    q.y-= (wb);\n    float be =  q.y+2.5;\n    p.yz*=rot(tt*PI*.75);\n    p.xz*=rot(tt*PI);\n    \n    float me =  ghost(p-vec3(0,.15,0),2.);\n\n    me=smin(me,be,1.3);\n    if(me<res.x) {\n        res = vec2(me,1.);\n        hit=q;\n    }\n\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec3 hue(float t){ \n    vec3 d = vec3(.173,.471,.788);\n    return .675 + .425*cos(PI2*(vec3(1.25,1,.75)*t+d)); \n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n, in vec2 F) {\n    n = normal(p,d,1.);\n    vec3 lpos = vec3(2.,5,-2);\n    vec3 l = normalize(lpos-p);\n    float diff = clamp(dot(n,l),.075,1.);\n\n    vec3 th=vec3(.1);\n\n    float dd = clamp((hitpoint.z+3.)*.1,0.,1.);\n\n    vec3 r = fract(hitpoint*.25)-.5;\n    vec3 f = fract(hitpoint*.75)-.5;\n    \n    vec3 clr = mix(vec3(.31,.13,.01),vec3(0.188,0.012,0.310),dd);\n    vec3 clx = mix(vec3(0.361,0.439,0.459),vec3(0.188,0.012,0.310),dd);\n    th = (r.x*r.z>0.)? clr:clx;\n    th = (f.x*f.z>0.)? vec3(.02):th;\n\n    vec3 h = vec3(.1);\n    h = mix(vec3(.09,.19,.19),th,clamp(1./d,0.,1.));\n\n    return h*diff;\n}\n\nvec3 render( in vec2 uv, in vec2 F )\n{\n\n    time = T;\n    turn=rot(T*10.*PI/180.);\n    vec3 C=vec3(.0);\n    r25=rot(-.35);\n    \n    float zoom = 10.;\n    \n    vec3 ro = vec3(uv*zoom,-(zoom+15.));\n    vec3 rd = vec3(0,0,1.);\n\n    float x = M.xy == vec2(0) ? 0. : -(M.y/R.y * .5 - .25) * PI;\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * .5 - .25) * PI;\n    \n    rx = rot(-.58);\n    ry = rot(.78+y);\n\n    ro.yz*=rx;ro.xz*=ry;\n    rd.yz*=rx;rd.xz*=ry;\n\n    vec3  p = ro + rd * .1;\n    float atten = 1.;\n    \n    // b = light bounces 8 is good 5 is liveable.\n    float k = 1.,b = 5.;\n    float iv = 1.;\n    // loop inspired/adapted from @blackle \n    // https://www.shadertoy.com/view/flsGDH\n    for(int i=0;i<128;i++)\n    {\n        vec2 ray = map(p);\n \n        vec3 n=vec3(0);\n        float d = ray.x*.8;\n        float m = ray.y;\n\n        p += rd * d *k;\n        \n        if (d*d < 1e-8) {\n            hitpoint=hit;\n          \n            C=mix(C,shade(p,rd,d,ray.y,n,F),atten);\n            \n            b--;\n            if(b<0.||m==4.)break;\n            \n            atten *=.85;\n            p += rd*.05;\n            k = sign(map(p).x);\n        \n            vec3 rf=refract(rd,n,iv > 0. ? .875 : 1.1);\n            iv *= -1.;\n            if(length(rf) == 0.) rf = reflect(rd,n);\n            rd=rf;\n            p+=-n*.005;\n        }\n      \n        if(distance(p,rd)>25.) { break; }\n    }\n\n    return C;\n}\n\n// AA from @iq https://www.shadertoy.com/view/3lsSzf\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    time = fract(T);\n    turn=rot(time*10.*PI/180.);\n    \n    vec3 C = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (-R.xy + 2.0*(F+o))/max(R.x,R.y);\n#else    \n        vec2 uv = (-R.xy + 2.0*F)/max(R.x,R.y);\n#endif\n\n        vec3 color = render(uv,F);\n        // compress        \n        color = 1.35*color/(1.0+color);\n        // gamma\n        color = pow( color, vec3(0.4545) );\n\n        C += color;\n#if AA>1\n    }\n    C /= float(AA*AA);\n#endif\n    // Output to screen\n    O = vec4(C,1.0);\n}\n//end", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGfzV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[553, 553, 575, 575, 633], [634, 634, 653, 653, 698], [700, 753, 796, 796, 887], [888, 888, 918, 918, 983], [984, 984, 1023, 1023, 1086], [1087, 1087, 1124, 1124, 1235], [1290, 1290, 1321, 1321, 2033], [2035, 2035, 2057, 2057, 2666], [2668, 2737, 2782, 2782, 3005], [3007, 3007, 3025, 3025, 3120], [3122, 3122, 3194, 3194, 3781], [3783, 3783, 3821, 3821, 5186]], "test": "untested"}
{"id": "NtyBWD", "name": "Test linear Rainbow", "author": "Rloret", "description": "Testing a linear function for the rainbow palette proposed by Iigo(//https://iquilezles.org/articles/palettes/).\nNo application yet.\nhttps://www.desmos.com/calculator/tw2ilmi1dg", "tags": ["rainbow", "linear"], "likes": 3, "viewed": 202, "published": 3, "date": "1664812042", "time_retrieved": "2024-07-30T16:28:25.700675", "image_code": "#define pi acos(-1.)\n//https://iquilezles.org/articles/palettes/\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 2.*pi*(c*t+d) );\n}\n\n\nfloat noise(vec3 a)\n{\n    return fract(sin(dot(a,vec3(132.341242,3.432432,17.34242)))*1435.432432);\n}\nvec3 Saw(vec3 x,vec3 d)\n{\n vec3 disp = x+d;\n return 2.0* abs(disp - round(disp));\n}\nvec3 RemapFrom01(vec3 x, float l, float h)\n{\n return l + x *(h-l);\n}\nvec3 ss( vec3 x )\n{\n  return x*x*(3.-2.0*x);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = fragCoord/iResolution.xy;\n   float video = texture(iChannel0,uv).r;\n   //video=uv.x;\n   vec3 saw = Saw(vec3(video),vec3(0.5,1.-1./6.,1./6.));\n   //saw = RemapFrom01(saw,-1./2.,1.); // add this bit if you want all the channels to add up to max 1\n   saw = clamp(saw,0.,1.);\n   //saw = ss(saw); //adding a smoothstep to the linear version makes it approximate the cosine version\n   vec3 rainbow = palette(video,vec3(.5),vec3(.5),vec3(1.),vec3(0.,1./3.,2./3.));\n   fragColor = vec4(uv.y>.5?rainbow:saw,0);\n\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtyBWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 65, 137, 137, 178], [181, 181, 202, 202, 282], [283, 283, 308, 308, 366], [367, 367, 411, 411, 435], [436, 436, 455, 455, 482], [488, 488, 545, 545, 1063]], "test": "untested"}
{"id": "NtKfzy", "name": "heavy exercise", "author": "jorge2017a2", "description": "heavy exercise", "tags": ["heavyexercise"], "likes": 21, "viewed": 240, "published": 3, "date": "1664760076", "time_retrieved": "2024-07-30T16:28:26.527464", "image_code": "//por jorge2017a2\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n/// y El grande Grupo de Shadertoy\n///heavy exercise--------  fork other arms-----2-oct-2022\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(8.0*antialiasing(1.0),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n#define R iResolution.xy\n#define s3(v,l) smoothstep(l/R.y,0.,v) // AA\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 cs(float x)\n{ return vec2(cos(x),sin(x) );}\n\n\nvec3 Brazosv2(vec2 p, vec3 colOut)\n{   float l1,l2,l3,l4a,l4b,l5a,l5b;\n    float a1, a2,a3,a4a,a4b,a5a,a5b;\n    vec2 p0,p1,p2,p3,p4a, p4b,p5a,p5b;\n    \n    float t=iTime;\n    \n    p0=vec2(0.0,0.0);\n    a1=radians(90.0+45.*sin(t*10.0));\n    a2=radians(45.*sin(t*10.0));\n    a3=radians(90.0+45.0*sin(t*10.0)); //cuerpo\n    //pierna\n    a4a=radians(270.0-45.0*sin(t*2.0+cos(t)));\n    a4b=radians(270.0+45.0*sin(t*2.0+cos(t)));\n    \n    //pies\n    a5a=radians( 10.0*sin(t*10.));\n    a5b=radians(-10.0*sin(t*10.));\n    \n    \n    l1=-2.25;\n    l2=-2.5;\n    l3=-3.0;\n    l4a=3.0;\n    l4b=3.0;\n    l5a=1.0;\n    l5b=1.0;\n    \n    p1=p0+l1*cs(a1);\n    p2=p1+l2*cs(a2);\n    p3=p2+l3*cs(a3);\n    \n    p4a=p3+l4a*cs(a4a);\n    p4b=p3+l4b*cs(a4b);\n    \n    p5a=p4a+l5a*cs(a5a);\n    p5b=p4b+l5b*cs(a5b);\n    \n    \n    float d1= sdSegment(p,p0,p1);\n    float d2= sdSegment(p,p1,p2);\n    float d3= sdSegment(p,p2,p3);\n    float d4a= sdSegment(p,p3,p4a);\n    float d4b= sdSegment(p,p3,p4b);\n    \n    float d5a= sdSegment(p,p4a,p5a);\n    float d5b= sdSegment(p,p4b,p5b);\n    \n    \n    float dDiagonal= sdSegment(p,vec2(-1.0,2.0),vec2(1.0,-2.0));\n    float dBoca= sdSegment(p-vec2(0.25,0.5),p2,p2-vec2(-0.5,0.0));\n    \n    \n    float dcabeza= sdCircle(p-p2-vec2(0.0,1.0),1.0);\n    float dOjo= sdCircle(p-p2-vec2(0.5,1.1),0.1);\n       vec3 col=colOut;\n    \n       col= DrawFigBorde(vec3(1.0),col,dcabeza);\n    col= DrawFigBorde(vec3(0.0),col,dOjo);\n    \n    col= DrawFigBorde(vec3(0.0), col,abs(dBoca)-0.01 );\n    col= DrawFigBorde(vec3(0.5), col,abs(dDiagonal)-0.1 );\n    col= DrawFigBorde(vec3(0.0), col,abs(d1)-0.1 );\n    col= DrawFigBorde(vec3(1.0,0.0,0.0), col,abs(d2)-0.1 );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0), col,abs(d3)-0.1 );\n    col= DrawFigBorde(vec3(1.0,0.0,1.0), col,abs(d4a)-0.1 );\n    col= DrawFigBorde(vec3(1.0,0.0,1.0), col,abs(d4b)-0.1 );\n    \n    col= DrawFigBorde(vec3(1.0,1.0,0.0), col,abs(d5a)-0.1 );\n    col= DrawFigBorde(vec3(1.0,1.0,0.0), col,abs(d5b)-0.1 );\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=8.0;\n    uv*=esc;\n    vec3 col=vec3(0.0,0.5,1.0);\n    col= Brazosv2(uv-vec2(0.0,5.0), col);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtKfzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[460, 460, 522, 522, 652], [654, 654, 689, 689, 712], [714, 714, 766, 766, 882], [884, 884, 902, 902, 932], [935, 935, 971, 971, 2920], [2923, 2923, 2980, 2980, 3235]], "test": "untested"}
{"id": "ftKfRy", "name": "Breaking Newton's Laws", "author": "MysteryPancake", "description": "Using regular distance instead of squared distance creates sick looking patterns", "tags": ["2d", "physics", "newton", "particle", "attraction", "force"], "likes": 8, "viewed": 307, "published": 3, "date": "1664755076", "time_retrieved": "2024-07-30T16:28:27.503854", "image_code": "// Line SDF from Inigo Quilez\nfloat line(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    fragColor = vec4(0.0);\n\n    for (float i = 0.0; i < NUM_PARTICLES; i++) {\n    \n        // Read position and velocity data from buffer\n        vec4 posVel = fetch(i);\n        \n        // Draw lines based on position and velocity of each particle\n        float trail = mass(i) / line(fragCoord, posVel.xy, posVel.xy + posVel.zw * 256.0);\n        \n        // Make faster particles more yellow\n        fragColor = max(fragColor, vec4(trail, trail * length(posVel.zw) * 24.0, 0.0, 1.0));\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float NUM_PARTICLES = 512.0;\n\n// To allow the entire buffer to be filled with particles\n#define fetch(id) texelFetch(iChannel0, ivec2(mod(id, iResolution.x), floor(id / iResolution.x)), 0)\n\n// Mass function swaps every 256 frames to get a different look\n#define mass(id) (4.0 + sin(id * (0.1 + floor(float(iFrame) / 256.0) * 0.1)) * 2.0)", "buffer_a_code": "// Position and velocity buffer\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \n    float id = fragCoord.x - 0.5 + (fragCoord.y - 0.5) * iResolution.x;\n    \n    // Don't calculate unused particles\n    if (id > NUM_PARTICLES) discard;\n    \n    if (iFrame % 256 == 0) {\n    \n        // Initialize variables\n        float x = iResolution.x * fragCoord.x / NUM_PARTICLES;\n        float y = iResolution.y * 0.5 + sin(fragCoord.x * 0.05) * iResolution.y * 0.25;\n        \n        // Store as position x, position y, velocity x, velocity y\n        fragColor = vec4(x, y, 0.0, 0.0);\n        \n    } else {\n        \n        // Read position and velocity data from previous frame\n        vec4 posVel = fetch(id);\n        vec2 pos = posVel.xy;\n        vec2 vel = posVel.zw;\n        float m = mass(id);\n        \n        for (float id2 = 0.0; id2 < NUM_PARTICLES; id2++) {\n            \n            // Ignore self\n            if (id == id2) continue;\n            \n            // Read position and velocity data from other particles\n            vec4 posVel2 = fetch(id2);\n            vec2 pos2 = posVel2.xy;\n            float m2 = mass(id2);\n            \n            // Really r should be squared as dot(dir, dir), but distance looks way cooler\n            vec2 dir = pos2 - pos;\n            float r = distance(pos, pos2); // Incorrect\n            \n            // Newton's law of attraction\n            const float G = 0.0000005;\n            float F = G * m * m2 / r;\n            \n            // Integrate position and velocity\n            vel += dir * F;\n            pos += vel;\n        }\n        \n        // Combine components again\n        fragColor = vec4(pos, vel);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKfRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 30, 75, 75, 195], [197, 197, 252, 252, 748]], "test": "untested"}
{"id": "flGfRG", "name": "RPS automata 0192381", "author": "SnoopethDuckDuck", "description": "just saving this before i change it even more (looks better in fullscreen)", "tags": ["feedback", "cellularautomata"], "likes": 23, "viewed": 284, "published": 3, "date": "1664750006", "time_retrieved": "2024-07-30T16:28:28.684698", "image_code": "vec4 cell(ivec2 f) {\n    return texelFetch(iChannel0, f, 0);\n}\n\nvoid mainImage(out vec4 col, in vec2 f)\n{\n    col = vec4(0.0);\n    int frame = iFrame % 120;\n    float o = floor(float(iFrame)/120.);\n    // Translate and zoom\n    float sc = 2.5;\n    //f -= 0.5 * iResolution.xy;\n    //f *= sc * dim.y/iResolution.y; \n    //f.x += 0.5 * dim.x;\n    //f.y += 0.5 * sc * dim.y;\n    float s = step(floor(f.x), 0.5 * dim.x);   \n    f *= 0.4;\n    // Mirrored coords \n    ivec2 ff = ivec2(s * dim.x + (1. - f.x) * (2. * s - 1.), f.y);\n    col = 1. * cell(ivec2(f));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\nvec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nvoid mainImage(out vec4 col, in vec2 f)\n{\n    col = vec4(0.0);\n    ivec2 px = ivec2(f);\n    int frame = iFrame;// % 120;\n    // not my finest line of code!\n    int h = 3 + int(floor(9. * h21(vec2(floor(float(iFrame)/120.), 19.))));\n    \n    ivec2 g = ivec2(f + vec2(100.,151.) * iTime * 60.) & 1023;\n    float rand = h21(0.01 * mod(iDate[3], 1001.) + f / iResolution.xy);\n           \n    if (frame == 0 || key_down(KEY_RESET)) {     \n        col = vec4(rand, 0.9999 * rand, 0.9998 * rand, 1.);\n        return;\n    }\n           \n    // Center cell\n    vec4 e = cell(px);\n    col = e;\n    \n    // Neighbour cells\n    vec4 b = cell(px - ivec2(0,1));\n    vec4 t = cell(px + ivec2(0,1));\n    vec4 l = cell(px - ivec2(1,0));\n    vec4 r = cell(px + ivec2(1,0));   \n    vec4 bl = cell(px + ivec2(-1,-1));\n    vec4 br = cell(px + ivec2(1, -1));\n    vec4 tl = cell(px + ivec2(-1, 1));\n    vec4 tr = cell(px + ivec2(1,  1));   \n    \n    vec4 bb = cell(px - ivec2(0,2));\n    vec4 tt = cell(px + ivec2(0,2));\n    vec4 ll = cell(px - ivec2(2,0));\n    vec4 rr = cell(px + ivec2(2,0));  \n    \n    vec4 sum = b + t + l + r;\n    vec4 diag = bl + br + tl + tr;\n    vec4 dif = abs(b-t) * abs(l-r);\n    vec4 dif2 = (t + b) * (l + r);\n    vec4 diDif = (tl + br) * (tr + bl);\n    vec4 av = (sum+diag)/8.;\n    vec4 v = 2. * av; // has to average 1.\n    v = pow(v, vec4(9));\n    float a = 0.25;// * (sum + diag);   \n    col = clamp(e + a * (v * diDif * dif2 - 1.), 0., 1.);\n    col = mix(col, abs(sum-diag) + 0.45, 0.5);\n    \n    float k = 0.2;\n    if (av.g <= col.r)\n        col.r -= k; //= mix(col.r, av.g, k); //+= k;\n    if (av.b <= col.g)\n        col.g -= k; //= mix(col.g, av.b, k); //+= k;\n    if (av.r <= col.b)\n        col.b -= k; //= mix(col.b, av.r, k); //+= k;\n    \n    //col.rgb = mix(col.rgb, 2. * av.gbr, -0.0);\n    //col *= 0.86;\n}\n\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n#define dim vec2(64, 52)\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGfRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 62], [64, 64, 105, 105, 557]], "test": "untested"}
{"id": "flKfzG", "name": "Integrated Particle Physics", "author": "MysteryPancake", "description": "First time using a buffer, had to try out a basic 2D physics simulation", "tags": ["2d", "sparks", "physics", "particle", "integration", "integrate"], "likes": 17, "viewed": 568, "published": 3, "date": "1664746889", "time_retrieved": "2024-07-30T16:28:29.491540", "image_code": "// Line SDF from Inigo Quilez\nfloat line(vec2 p, vec2 a, vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - h * ba);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    fragColor = vec4(0.0);\n\n    for (float i = 0.0; i < NUM_PARTICLES; i++) {\n    \n        // Read position and velocity data from buffer\n        vec4 posVel = fetch(i);\n        \n        // Draw lines based on position and velocity of each particle\n        float trail = 4.0 / line(fragCoord, posVel.xy, posVel.xy + posVel.zw);\n        \n        // Make faster particles more yellow\n        fragColor = max(fragColor, vec4(trail, trail * length(posVel.zw) * 0.02, 0.0, 1.0));\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Position and velocity buffer\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \n    float id = fragCoord.x - 0.5 + (fragCoord.y - 0.5) * iResolution.x;\n    \n    // Don't calculate unused particles\n    if (id > NUM_PARTICLES) discard;\n    \n    if (iFrame < 1) {\n    \n        // Initialize variables\n        float x = iResolution.x * fragCoord.x / NUM_PARTICLES;\n        float y = iResolution.y * 0.5 + sin(fragCoord.x) * iResolution.y * 0.4;\n        \n        // Store as position x, position y, velocity x, velocity y\n        fragColor = vec4(x, y, sin(fragCoord.x * 256.0) * 4.0, cos(fragCoord.x * 128.0) * 4.0);\n        \n    } else {\n        \n        // Read position and velocity data from previous frame\n        vec4 posVel = fetch(id);\n        vec2 pos = posVel.xy;\n        vec2 vel = posVel.zw;\n        \n        // Simulate gravity\n        vel.y -= 0.25;\n        \n        // Simulate wind\n        vel.x += sin(iTime) * 0.5;\n        \n        // Euler integration (I think)\n        pos += vel;\n        \n        // Dampen each particle differently, for variety\n        float dampening = 0.95 + sin(fragCoord.x * 64.0) * 0.05;\n        \n        // Bounce particles on floor\n        if (pos.y < 0.0) {\n            vel.y *= -dampening;\n            pos.y = max(-pos.y, 0.0);\n        }\n        \n        // Bounce particles on walls\n        if (pos.x < 0.0) {\n            vel.x *= -dampening;\n            pos.x = max(-pos.x, 0.0);\n        } else if (pos.x > iResolution.x) {\n            vel.x *= -dampening;\n            pos.x = iResolution.x + min(iResolution.x - pos.x, 0.0);\n        }\n        \n        // Combine components again\n        fragColor = vec4(pos, vel);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float NUM_PARTICLES = 512.0;\n\n// To allow the entire buffer to be filled with particles\n#define fetch(id) texelFetch(iChannel0, ivec2(mod(id, iResolution.x), floor(id / iResolution.x)), 0)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flKfzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 30, 66, 66, 188], [190, 190, 245, 245, 729]], "test": "untested"}
{"id": "NlVfRG", "name": "2D Water Effect Perspective", "author": "rubioh", "description": "Some experiment", "tags": ["water", "effect", "perspective"], "likes": 4, "viewed": 278, "published": 3, "date": "1664739613", "time_retrieved": "2024-07-30T16:28:30.280430", "image_code": "float make_square(vec2 uv, float radius){\n    float length_uv = max(abs(uv.y), abs(uv.x));\n    return (1.-step(radius, length_uv));\n}\nvec2 hash( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(175.1,311.7)),\n             dot(p,vec2(260.5,752.3)));\n    return fract(sin(p+455.)*18.5453);\n}\n\nvec3 random_color(vec2 p)\n{\n    return vec3(hash(p).x, hash(2.*p).x, hash(3.*p).x);\n}\n\n//==============================================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.9;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat noise2(vec3 p)\n{\n    float n = .1;\t// noise amount\n    float iter = 2.0;\n    for (int i = 0; i < 5; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = hash(i).x;\n    float b = hash(i + vec2(1.0, 0.0)).x;\n    float c = hash(i + vec2(0.0, 1.0)).x;\n    float d = hash(i + vec2(1.0, 1.0)).x;\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nfloat fbm( in vec2 x)\n{    \n    float t = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        float f = pow( 2., float(i) );\n        float a = pow( f, -.75 );\n        t += a*noise(f*x);\n    }\n    return t*1.-.4;\n}\n\nfloat fbm_water( in vec2 x)\n{    \n    float t = 0.0;\n    float amp = 0.;\n    for( int i=0; i<7; i++ )\n    {\n        float f = pow( 2., float(i) );\n        float a = pow( f, -.75 );\n        amp = .25*step(5., float(i));\n        t += a*noise(f*x+amp*iTime);\n    }\n    return t*1.-.4;\n}\n\nvec3 warp(vec2 uv){\n    vec2 st = uv;\n    st.y *= 1./(st.y+.2);\n    st.x *= .1;\n    st.x += iTime*.0002;\n    \n    vec2 tmp = st;\n\n    float n = fbm_water(tmp + fbm_water(tmp +fbm_water(tmp )));\n    vec2 pos = rotate2d(n*1./st.y*.1*abs(cos(iTime*.01)))*uv;\n    return vec3(pos, n*1./st.y*.1);\n}\n\n\nvec3 downmirror(vec2 uv){\n    float a = 1.;\n    float z = -a*(uv.y) + 1.;\n    vec2 down_uv = vec2(uv.x/z, -uv.y/z*4.);\n    vec3 warp_down_uv = warp(down_uv);\n    return warp_down_uv; \n    \n}\n\n\nvec3 make_bg(vec3 bg_color){\n    \n    vec3 res = vec3(0, 0, 0);\n    vec3 color_cell = bg_color;\n    res = color_cell;\n    return res;\n}\n\n\nfloat lines(in vec2 pos){\n    float scale = 15.0+.01*cos(iTime);\n    pos *= scale;\n    float v = sin(pos.x*3.1415);\n    return smoothstep(-2., 2., v/fwidth(v));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5, .3);\n\n    // Time varying pixel color\n\n    float up_mask = step(0., uv.y);\n    float down_mask = 1.-up_mask;\n    \n    vec2 up_uv = uv * up_mask;\n    vec2 up_centerize = vec2(0., .2);\n    up_uv = up_uv;\n\n    vec3 tmp = downmirror(uv) * (1.-up_mask);\n    \n    vec2 down_uv = tmp.xy;\n\n\n\n    vec2 bg_up = up_uv/5.;\n    bg_up = rotate2d(noise(bg_up*10.) ) * bg_up;\n    vec3 pattern_up = vec3(2.*lines(bg_up*10.));\n\n    vec2 bg_down = down_uv/5.;\n    bg_down = rotate2d(noise(bg_down*10.) ) * bg_down;\n    vec3 pattern_down = vec3(2.*lines(bg_down*10.));\n    \n    vec3 col_up = make_bg(pattern_up)*up_mask;\n    vec3 col_down = make_bg(pattern_down)*down_mask;\n\n    \n    //vec3 col_up = (vec3(up_uv.x+.2, up_uv.y+.2, 0.) );\n    //vec3 col_down = (vec3(down_uv.x+.2, down_uv.y+.2, 0.) )*down_mask;\n    \n\n    float n = tmp.z;\n    \n    float deltax = dFdx(n)*50.;\n    float deltay = dFdy(n)*100.;\n    float shadow_mask = ((deltax)+(deltay));\n\n   fragColor = vec4((col_down+down_mask*vec3(0., 0., 1.))*.4+vec3(.1,.1,.1)*(shadow_mask)*1.5+col_up,1.0);\n   //fragColor = vec4(vec3(n)*5., 1.);\n\n    // Output to screen\n       \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlVfRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 133], [134, 134, 155, 186, 306], [308, 308, 335, 335, 393], [395, 1056, 1078, 1078, 1626], [1628, 1628, 1654, 1654, 1987], [1989, 1989, 2016, 2016, 2098], [2100, 2100, 2123, 2123, 2309], [2311, 2311, 2340, 2340, 2594], [2596, 2596, 2615, 2615, 2889], [2892, 2892, 2917, 2917, 3082], [3085, 3085, 3113, 3113, 3220], [3223, 3223, 3248, 3248, 3385], [3388, 3388, 3445, 3495, 4659]], "test": "untested"}
{"id": "NlGfzy", "name": "Conics Intersecting Parabola", "author": "mla", "description": "A conic pencil, showing intersections with fixed parabola y = x.\nDrag white discs to set pencil parameters.\nSee code header for other controls.", "tags": ["pencil", "parabola", "conic", "loopless", "lineconic"], "likes": 14, "viewed": 282, "published": 3, "date": "1664736411", "time_retrieved": "2024-07-30T16:28:31.221913", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Pencils of Conics Intersecting a Parabola.\n//\n// Matthew Arcus, mla, 2022\n//\n// Linear sums of 2 conics gives a family of conics (a 'pencil'), one of which\n// passes through each point of the plane. There are 4 points (possibly coincident\n// or imaginary) which both conics pass through. Here the two conics are a line pair\n// (controlled by the white discs in the background) and a fixed circle or hyperbola.\n//\n// Also, show the intersections of the conics with the parabola y = x - finding\n// the intersections of two general conics is tiresome, but for this parabola\n// it's easy to find the quartic equation for the x values.\n//\n// White discs control the (yellow) line pair conic, drag with mouse to change.\n// 'd': use single line (doubled) for line pair\n// 'h': use fixed hyperbola instead of a circle\n// 's': hide control discs\n// 'p': hide parabola\n// <up>,<down>: zoom in/out\n//\n// See also https://www.shadertoy.com/view/7lVfD1 by jt.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat lwidth = 0.0;//0.004;\nfloat pwidth = 0.04;\nfloat K = 32.0;\nfloat px;\n\n// Polarized conic\nfloat conic(vec3 p, mat3 S, vec3 q) {\n  return dot(p,S*q);\n}\n\nfloat conic(vec3 p, mat3 S) {\n  return conic(p,S,p);\n}\n\n// The gradient uses the same matrix.\nvec3 conicgrad(vec3 p, mat3 S) {\n  return 2.0*S*p;\n}\n\nfloat conicdist(vec3 p, mat3 S) {\n  float d = conic(p,S);\n  vec3 dd = conicgrad(p,S);\n  d /= p.z*length(dd.xy); // Normalize for Euclidean distance\n  return abs(d);\n}\n\nfloat line(vec3 p, vec3 q) {\n  return abs(dot(p,q)/(p.z*length(q.xy)));\n}\n\nfloat line(vec3 p, vec3 q, vec3 r) {\n  return line(p,cross(q,r));\n}\n\nfloat point(vec3 p, vec3 q) {\n  float pz = p.z, qz = q.z;\n  p *= qz; q *= pz;\n  return distance(p,q)/abs(p.z);\n}\n\nbool intersect(vec3 p, mat3 s, out vec3 m0, out vec3 m1) {\n  // Find lines from p tangent to conic s, or (dually)\n  // find intersection points of line p with conic s.\n  // Three lines in pencil, select the two with the\n  // largest magnitude.\n  vec3 l0 = vec3(-p.y,p.x, 0);\n  vec3 l1 = vec3(p.z, 0,  -p.x);\n  vec3 l2 = vec3(0,  -p.z, p.y);\n  if (dot(l0,l0) > dot(l1,l1)) l1 = l0;\n  else if (dot(l0,l0) > dot(l2,l2)) l2 = l0;\n  // l1,l2 now the two largest (in particular, this is to avoid\n  // a zero-sized vector).\n  // Now want (l1 + k*l2)s(l1 + k*l2) = 0\n  // Ak+2Bk+C = 0\n  float A = dot(l2,s*l2);\n  float B = dot(l1,s*l2);\n  float C = dot(l1,s*l1);\n  float D = B*B-A*C;\n  if (D < 0.0) return false;\n  D = sqrt(D);\n  // If A = C = 0, then we have picked 2 lines on the conic already.\n  // Maybe should handle this case.\n  if (abs(A) > abs(C)) {\n    float k0 = (-B + D)/A;\n    float k1 = (-B - D)/A;\n    m0 = l1+k0*l2;\n    m1 = l1+k1*l2;\n  } else {\n    float k0 = (-B + D)/C;\n    float k1 = (-B - D)/C;\n    m0 = l2+k0*l1;\n    m1 = l2+k1*l1;\n  }\n  return true;\n}\n\nint intersectparabola(mat3 T, out vec4 roots) {\n  float A = T[0][0]; // x^2\n  float B = T[1][1]; // y^2\n  float C = T[2][2]; // z^2\n  float D = 2.0*T[0][1]; // xy\n  float E = 2.0*T[0][2]; // xz\n  float F = 2.0*T[1][2]; // yz\n  // Substitute y = x^2\n  return quartic(B,D,A+F,E,C,roots);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  setscale();\n  vec3 pcol = vec3(0.1);\n  bool doubleline = key(CHAR_D);\n  vec3 p = vec3(map(fragCoord.xy),1);\n  px = fwidth(p.x);\n  vec2 mouse = vec2(-2,2);\n  if (iMouse.x != 0.0) {\n    mouse = map(iMouse.xy).xy;\n  }\n  mat3 M = mat3(1,0,0,0,1,0,0,0,-1); // Just a circle\n  if (key(CHAR_H)) M = mat3(1,0,0,0,-1,0,0,0,1); // Hyperbola\n  vec3 P1 = vec3(getselection(0),1);\n  vec3 P2 = vec3(getselection(1),1);\n  if (doubleline) P2 = P1;\n  mat3 N = 0.5*(outerProduct(P1,P2)+outerProduct(P2,P1));\n\n  // Common points/tangents of pencil\n  vec3 T1,T2,T3,T4;\n  bool show1 = intersect(P1,M,T1,T2);\n  bool show2 = intersect(P2,M,T3,T4);\n\n  vec3 color = 0.2*vec3(1,1,0.8);\n\n  if (!key(CHAR_S)) {\n    // Show point pair locations\n    float d = min(point(p,P1), point(p,P2));\n    color = mix(vec3(1),color,smoothstep(0.0,px,d-1.2*pwidth));\n  }\n  {\n    float S11 = conic(p,M);\n    float S22 = conic(p,N);\n    // Find parameter of conic through p\n    float t = atan(-S11/S22);\n    t /= PI;\n    t *= K;\n    t -= iTime;\n    t = round(t); // Get nearest displayed conic\n    float t0 = t; // Remember index of conic\n    t += iTime;\n    t /= K;\n    t *= PI;\n    mat3 para = mat3 (2,0,0,0,0,-1,0,-1,0);\n    color = mix(vec3(0,1,0),color,smoothstep(0.0,px,conicdist(p,M)-lwidth));\n    color = mix(vec3(1,1,0),color,smoothstep(0.0,px,conicdist(p,N)-lwidth));\n    if (!key(CHAR_P)) color = mix(vec3(0.8,0,0),color,smoothstep(0.0,px,conicdist(p,para)-lwidth));\n    mat3 T = cos(t)*M + sin(t)*N;\n    vec3 lcol = 0.4+0.6*h2rgb(t0/K);\n    color = mix(lcol,color,smoothstep(0.0,px,conicdist(p,T)-lwidth));\n    float d = 1e8;\n    if (show1) {\n      d = min(d,point(p,T1));\n      d = min(d,point(p,T2));\n    }\n    if (show2) {\n      d = min(d,point(p,T3));\n      d = min(d,point(p,T4));\n    }\n    color = mix(pcol,color,smoothstep(0.0,px,d-pwidth));\n    if (!key(CHAR_P)) {\n      d = 1e8;\n      for (int off = -2; off <= 2; off++) {\n        float t1 = t + float(off)*PI/K;\n        mat3 T = cos(t1)*M + sin(t1)*N;\n      \n        vec4 roots;\n        int nroots = intersectparabola(T,roots);\n        for (int i = 0; i < nroots; i++) {\n           float x = roots[i];\n           d = min(d,point(p,vec3(x,x*x,1)));\n        }\n      }\n      color = mix(vec3(0.1),color,smoothstep(0.0,px,d-0.5*pwidth));\n    }\n  }\n  color = pow(color,vec3(0.4545));\n  fragColor = vec4(color,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n    } else if (iFrame == 0 || t.w != 12345.0) {\n      t.xy = initselection(i-1); // Current coordinates\n      t.w = 12345.0; // Magic number\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store((key),0).x))\n#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\n#define map(screenpos) (scale*(vec2(0,0.25)+(2.0*(screenpos)-iResolution.xy)/iResolution.y))\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n#define setscale() (scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP))))\n\nfloat scale = 3.0;\n\nconst int nselections = 2;\nvec2 initselection(int i) {\n  if (i == 0) return vec2(-1.5,1.5);\n  if (i == 1) return vec2(-1.5,-1.5);\n  return vec2(0);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 h2rgb(float h) {\n\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n  return rgb;\n}\n\n// The Kahan cubic algorithm, for explanation see:\n// https://people.eecs.berkeley.edu/~wkahan/Math128/Cubic.pdf\nfloat sgn(float x) {\n  return x < 0.0 ? -1.0: 1.0; // Return 1 for x == 0\n}\n\nint quadratic(float A, float B, float C, out vec2 res) {\n  float b = -0.5*B, b2 = b*b;\n  float q = b2 - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (false && r == 0.0) {\n    res[0] = C/A;\n    res[1] = -res[0];\n  } else {\n    res[0] = C/r;\n    res[1] = r/A;\n  }\n  return 2;\n}\n\n// Evaluate cubic and derivative.\nvoid eval(float X, float A, float B, float C, float D,\n          out float Q, out float Q1, out float B1,out float C2) {\n  float q0 = A*X;\n  B1 = q0+B;\n  C2 = B1*X+C;\n  Q1 = (q0+B1)*X + C2;\n  Q = C2*X + D;\n}\n\n// Solve: Ax^3 + Bx^2 + Cx + D == 0\n// Find one real root, then reduce to quadratic.\nint cubic(float A, float B, float C, float D, out vec3 res) {\n  float X,b1,c2;\n  X = -(B/A)/3.0;\n  float t,r,s,q,dq,x0;\n  eval(X,A,B,C,D,q,dq,b1,c2);\n  t = q/A; r = pow(abs(t),1.0/3.0); s = sgn(t);\n  t = -dq/A; if (t > 0.0) r = 1.324718*max(r,sqrt(t));\n  x0 = X - s*r;\n  if (x0 != X) {\n    // We really do need this many iterations here\n    for (int i = 0; i < 6; i++) {\n      X = x0;\n      eval(X,A,B,C,D,q,dq,b1,c2);\n      if (dq == 0.0) break;\n      x0 -= (q/dq);\n    }\n    if (abs(A)*X*X > abs(D/X)) {\n      c2 = -D/X; b1 = (c2 - C)/X;\n    }\n  }\n  res.x = X;\n  return 1 + quadratic(A,b1,c2,res.yz);\n}\n\n// Special wrapper for cubic function for solving quartic.\n// Find largest real root of x**3 + a*x**2 + b*x + c\n// Assume c < 0\nfloat qcubic(float a, float b, float c) {\n  if (c == 0.0) return 0.0;\n  vec3 res;\n  int nroots = cubic(1.0,a,b,c,res);\n  if (nroots == 1) return res.x;\n  else return max(res.x,max(res.y,res.z));\n}\n\nint quartic0(float c1, float c2, float c3, float c4, out vec4 res) {\n  // Lanczos's quartic solution\n  float alpha = 0.5*c1;\n  float A = c2-alpha*alpha;\n  float B = c3-alpha*A;\n  float a,b,beta,psi;\n  psi = qcubic(2.0*A-alpha*alpha, A*A+2.0*B*alpha-4.0*c4, -B*B);\n  // There should be a positive root, but sometimes the cubic\n  // solver doesn't find it directly (probably a double root\n  // around zero).\n  psi = max(0.0,psi);\n  a = sqrt(psi);\n  beta = 0.5*(A + psi);\n  if (psi <= 0.0) {\n    b = sqrt(max(beta*beta-c4,0.0));\n  } else {\n    b = 0.5*a*(alpha-B/psi);\n  }\n  int n0 = quadratic(1.0,alpha+a,beta+b,res.xy);\n  int n1 = quadratic(1.0,alpha-a,beta-b,res.zw);\n  if (n0 == 0) res.xy = res.zw;\n  return n0 + n1;\n}\n\nint quartic(float A, float B, float C, float D, float E, out vec4 roots) {\n  int nroots;\n  // Solve for the smallest cubic term, this produces the least wild behaviour.\n  bool flip = abs(B/A) >= abs(D/E);\n  float c1,c2,c3,c4;\n  if (!flip) {\n    c1 = B/A; c2 = C/A; c3 = D/A; c4 = E/A;\n  } else {\n    // Solve for reciprocal\n    c1 = D/E; c2 = C/E; c3 = B/E; c4 = A/E;\n  }\n  nroots = quartic0(c1,c2,c3,c4,roots);\n  if (flip) {\n    // We have solved for the reciprocal.\n    for (int i = 0; i < 4; i++) {\n      if (i == nroots) break;\n      roots[i] = 1.0/roots[i];\n    }\n  }\n  return nroots;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGfzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1197, 1216, 1253, 1253, 1276], [1278, 1278, 1307, 1307, 1332], [1334, 1372, 1404, 1404, 1424], [1426, 1426, 1459, 1459, 1592], [1594, 1594, 1622, 1622, 1667], [1669, 1669, 1705, 1705, 1736], [1738, 1738, 1767, 1767, 1850], [1852, 1852, 1910, 2095, 2919], [2921, 2921, 2968, 2968, 3208], [3210, 3210, 3267, 3267, 5607]], "test": "untested"}
{"id": "slGBzy", "name": "dottiverse", "author": "NinjaKoala", "description": "PC 4k Intro for Linux released at deadline 2022.\nBy juvi and me of epoqe\nPouet: https://www.pouet.net/prod.php?which=92439", "tags": ["2d", "intro", "4k", "demoscene", "halftone", "dots", "deadline"], "likes": 6, "viewed": 326, "published": 3, "date": "1664732708", "time_retrieved": "2024-07-30T16:28:32.288062", "image_code": "/*\nI reused some code from two older shaders of mine:\n\nhttps://www.shadertoy.com/view/Wd2cRG\nhttps://www.shadertoy.com/view/3tsXDB\n*/\n\nfloat tr = .3; // time raster\n\nfloat event2, event3, event4, event5, event6, event7, event8, event9, event10, event11, event11p5, event12, event13, event14, event15, event16, event17, event18, event19, event20, event20p5, event21, event22, event23, event24, event25, event26, event27, event27p5, event28, event29, event30, event31, event32, event33, event34, event35, event35p5, event36, event37;\n#define Z(a,b,c,d) mix(a,b,smoothstep(0.,d-c,clamp(iTime-c,0.,d-c)))\n\nfloat tau = 6.283185;\n\nint num_iterations = 3;\nint num_start_params = 25;\n\nmat2 rot(float t){return mat2(cos(t),sin(t),-sin(t),cos(t));}\n\nvec2 parametric(float t, float t1){\n\tt *= tau;\n\n\tif(t1 == 0.){\n\t\tfloat x = (1.5 + cos(10.*t)) * cos(3.*t);\n\t\tfloat y = (1.5 - cos(10.*t)) * sin(3.*t);\n\n\t\treturn .1 * vec2(x,y);\n\t}\n\n    float x = sin(2.*t);\n    float y = sin(3.*t+tau/4.+mod(t1*.5,tau));\n\n\treturn 1./7.*vec2(x,y);\n}\n\nvec2 parametric_diff(float t, float t1){\n\tt *= tau;\n\n\tif(t1 == 0.){\n\t\tfloat x = -10.*cos(3.*t)*sin(10.*t) - 3.*cos(10.*t)*sin(3.*t) - 4.5*sin(3.*t);\n\t\tfloat y = -3.*cos(10.*t)*cos(3.*t) + 10.*sin(10.*t)*sin(3.*t) + 4.5*cos(3.*t);\n\n\t\treturn tau * .1 * vec2(x,y);\n\t}\n\n\tfloat x = 2. * cos(2.*t);\n    float y = 3. * cos(3.*t+tau/4.+mod(t1*.5,tau));\n\n\treturn 1./7. * tau * vec2(x,y);\n}\n\nfloat parametric_normal_iteration(float t, vec2 uv, float t1){\n\tvec2 uv_to_p = parametric(t,t1)-uv;\n\tvec2 tang = parametric_diff(t,t1);\n\n\tfloat l_tang = dot(tang,tang);\n\treturn t - dot(tang,uv_to_p)/l_tang;\n}\n\nfloat parametric_dis_approx(vec2 uv, float t1){\n\tfloat d0 = 1e38;\n\n\tfloat t0 = 0.;\n\tfloat t;\n\n\tfor(int i=0;i<num_start_params;i++){\n\t\tt = t0;\n\t\tfor(int j=0;j<num_iterations;j++){\n\t\t\tt = parametric_normal_iteration(t,uv,t1);\n\t\t}\n\t\tt = clamp(t,0.,1.);\n\t\tvec2 uv_to_p = parametric(t,t1)-uv;\n\t\td0 = min(d0,dot(uv_to_p,uv_to_p));\n\n\t\tt0 += 1./float(num_start_params-1);\n\t}\n\n\treturn sqrt(d0);\n}\n\nfloat sgn(float a){\n\tif(a<0.){\n\t\treturn -1.;\n\t}\n\telse{\n\t\treturn 1.;\n\t}\n}\n\nvec2 from_projective(vec3 p, float radius, float stretch_factor){\n\tbool flip = false;\n\tif(p.xy == vec2(0)) return vec2(0);\n\tif(p.x == 0.){\n\t\tp=p.yxz;\n\t\tflip=true;\n\t}\n\tfloat a=p.x*p.x+p.y*p.y;\n\tfloat b=p.z*p.x/(stretch_factor*stretch_factor);\n\tfloat c=-p.x*p.x*radius*radius;\n\n\tfloat discriminant=max(0.,b*b-4.*a*c);\n\n\tfloat int_x=(-b+sgn(p.x)*sqrt(discriminant))/(2.*a);\n\tfloat int_y=int_x*p.y/p.x;\n\n\tif(flip) return vec2(int_y,int_x);\n\treturn vec2(int_x,int_y);\n}\n\nvec3 to_projective(vec2 p, float radius, float stretch_factor){\n\treturn vec3(p.xy,stretch_factor*stretch_factor*(radius*radius-dot(p,p)));\n}\n\nmat2x3 to_projective_jacobi(vec2 p, float radius, float stretch_factor){\n\tvec3 column1 = vec3(1,0,-2.*stretch_factor*stretch_factor*p.x);\n\tvec3 column2 = vec3(0,1,-2.*stretch_factor*stretch_factor*p.y);\n\n\treturn mat2x3(column1, column2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tevent2 = 33.*tr; // dots starting to appear\n\tevent3 = event2 + 33.*tr; // start zooming out (and beat starts)\n\tevent4 = event3 + 28.*tr; // end zooming out\n\tevent5 = event4 + 12.*tr; // start moving left\n\tevent6 = event5 + 2.*tr; // end moving left\n\tevent7 = event6 + 6.*tr; // start zooming in\n\tevent8 = event7 + 14.*tr; // end zooming in\n\tevent9 = event8 + 11.*tr; // start zooming in\n\tevent10 = event9 + 14.*tr; // end zooming in\n\tevent11 = event10 + 7.*tr; // start moving right\n\tevent11p5 = event10 + 7.*tr; // chromatic abberation start\n\tevent12 = event11 + 2.*tr; // end moving right\n\tevent13 = event12 + 6.*tr; // start zooming in\n\tevent14 = event13 + 14.*tr; // end zooming in\n\tevent15 = event14 + 11.*tr; // start zooming out\n\tevent16 = event15 + 28.*tr; // end zooming out\n\tevent17 = event16 + 7.*tr; // start moving up\n\tevent18 = event17 + 2.*tr; // end moving up\n\tevent19 = event18 + 6.*tr; // start zooming in\n\tevent20 = event19 + 14.*tr; // end zooming in\n\tevent20p5 = event19 + 20.*tr; // end zooming in\n\tevent21 = event20 + 11.*tr; // start zooming out\n\tevent22 = event21 + 28.*tr; // end zooming out\n\tevent23 = event22 + 7.*tr; // start moving right\n\tevent24 = event23 + 2.*tr; // end moving right\n\tevent25 = event24 + 6.*tr; // start zooming in\n\tevent26 = event25 + 14.*tr; // end zooming in\n\tevent27 = event26 + 11.*tr; // start zooming out\n\tevent27p5 = event26 + 34.*tr; // chromatic abberation start\n\tevent28 = event27 + 28.*tr; // end zooming out\n\tevent29 = event28 + 7.*tr; // start moving right\n\tevent30 = event29 + 2.*tr; // end moving right\n\tevent31 = event30 + 6.*tr; // start zooming in\n\tevent32 = event31 + 14.*tr; // end zooming in\n\tevent33 = event32 + 11.*tr; // start zooming out\n\tevent34 = event33 + 28.*tr; // end zooming out\n\tevent35 = event34 + 6.*tr; // start zooming out even more\n\tevent35p5 = event34 + 22.*tr; // radius offset start\n\tevent36 = event35 + 28.*tr; // end zooming out even more\n\tevent37 = event36 + 19.*tr; // black hole\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv-=.5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec2 old_uv = uv;\n\n\tfloat grid_size = .2;\n\n\tfloat radius_animation = exp(Z(4.,Z(0.,Z(4.,Z(0.,Z(4.,Z(0.,Z(4.,Z(0.,Z(4.,Z(0.,Z(4.,Z(0.,-3.5,event35,event36),event33,event34),event31,event32),event27,event28),event25,event26),event21,event22),event19,event20),event15,event16),event13,event14),event9,event10),event7,event8),event3,event4));\n\n\tfloat stretch_factor = 1./radius_animation;\n\tfloat radius = .3*radius_animation;\n\n\tfloat line_width = .001;\n\tfloat circle_width = .005;\n\tfloat curve_width = .001;\n\n\tfloat meta_grid_size = 2.2 * radius;\n\n\tvec3 bg_col = vec3(1);\n\tvec3 dot_col = vec3(0);\n\n    float border = 2./iResolution.y;\n\n\tuv += Z(vec2(0),Z(vec2(-meta_grid_size,0),Z(vec2(meta_grid_size,0),Z(vec2(meta_grid_size),Z(vec2(meta_grid_size,2.*meta_grid_size),vec2(2.*meta_grid_size),event29,event30),event23,event24),event17,event18),event11,event12),event5,event6);\n\n\tvec2 meta_dot_index = round(uv/meta_grid_size);\n\n\tfloat fac = fract(.05*max(0.,iTime-event3));\n\tfloat radius_perturbation = smoothstep(.7,.0,abs(fac+length(meta_dot_index*.3)-round(length(meta_dot_index*.3)+fac)));\n\n\tradius *= radius_perturbation;\n\tstretch_factor /= radius_perturbation;\n\n\tuv = uv - meta_dot_index * meta_grid_size;\n\n\tvec3 color = bg_col;\n\n\tfloat circ_width_offset = Z(0.,1.,event35p5,event36);\n\n\tvec3 uv_p = to_projective(uv,radius,stretch_factor);\n\n\tmat2x3 jac = to_projective_jacobi(uv, radius, stretch_factor);\n\n\tfloat circle_rad = .002;\n\tvec2 circle_index = round(uv_p.xy/uv_p.z/grid_size);\n\tvec2 circle_mid = circle_index*grid_size;\n\n\tvec2 int_p1 = from_projective(vec3(circle_mid,1),radius,stretch_factor);\n\n\tfloat dot_size;\n\n\tfloat nth = max(0.,floor((iTime-event3)/16./tr));\n\tfloat t0 = iTime-event3-nth*16.*tr;\n\tfloat beat = nth*3.5;\n\tbeat += .5 * smoothstep(0.,.2,t0);\n\tbeat += .5 * smoothstep(0.,.2,t0-2.*tr);\n\tbeat += .5 * smoothstep(0.,.2,t0-4.*tr);\n\tbeat += .5 * smoothstep(0.,.2,t0-6.*tr);\n\tbeat += .5 * smoothstep(0.,.2,t0-8.*tr);\n\tbeat += .5 * smoothstep(0.,.2,t0-11.*tr);\n\tbeat += .5 * smoothstep(0.,.2,t0-12.*tr);\n\n\tfloat t1 = iTime+beat;\n\t\n\tfloat index_mod = mod(dot(meta_dot_index,vec2(1)),6.);\n\tif(index_mod == 0.){\n \t\tdot_size = grid_size/2.*(.5-.5*cos(max(0.,t1+4.*int_p1.x-event2)));\n\t}\n\tif(index_mod == 1.){\n\t\tdot_size = grid_size/2.*(.5-.5*sin(t1+.5*circle_mid.x+1.*sin(1.*circle_mid.y)));\n\t}\n\telse if(index_mod == 2.){\n\t\tdot_size = grid_size/2. * smoothstep(.4,0.,abs(-fract(t1*.2)+length(circle_mid)-round(length(circle_mid)-fract(t1*.2))));\n\t}\n\telse if(index_mod == 3.){\n\t\tdot_size = grid_size/2. * smoothstep(.03,0.,parametric_dis_approx(circle_mid*.05*rot(t1*.5),0.));\n\t}\n\telse if(index_mod == 4.){\n\t\tdot_size = grid_size/2. * smoothstep(.03,0.,parametric_dis_approx(circle_mid*.05,t1));\n\t}\n\telse if(index_mod == 5.){\n\t\tdot_size = grid_size/2.*(.5-.5*sin(t1+circle_mid.x))*(.5-.5*cos(t1+circle_mid.y));\n\t}\n\n\tvec3 grid_grad_x = vec3(1./uv_p.z,0.,-uv_p.x/(uv_p.z*uv_p.z));\n\tvec3 grid_grad_y = vec3(0.,1./uv_p.z,-uv_p.y/(uv_p.z*uv_p.z));\n\n\tmat2x3 jac2 = to_projective_jacobi(int_p1, radius, stretch_factor);\n\tfloat jac_fac = max(length(grid_grad_x*jac),length(grid_grad_y*jac));\n\n\tdot_size /= jac_fac;\n\tdot_size -= border/2.;\n\n\tif(iTime < event20p5){\n\t\tnth =clamp(floor((iTime-event11p5)/16./tr),0.,3.);\n\t\tt0 = iTime-event11p5-nth*16.*tr;\n\t}\n\telse if(iTime < event27p5){\n\t\tnth = clamp(floor((iTime-event20p5)/16./tr),0.,1.);\n\t\tt0 = iTime-event20p5-nth*16.*tr;\n\t}\n\telse if(iTime > event27p5){\n\t\tnth = clamp(floor((iTime-event27p5)/16./tr),0.,3.);\n\t\tt0 = iTime-event27p5-nth*16.*tr;\n\t}\n\n\tfloat chromatic_abberation = 0.;\n\tchromatic_abberation += (t0 > 0. && t0 < 5.*tr) ? .003 : 0.;\n\tchromatic_abberation += (t0 > 8.*tr && t0-8.*tr < tr) ? .003 : 0.;\n\tchromatic_abberation += (t0 > 11.*tr && t0-11.*tr < 3.*tr) ? .003 : 0.;\n\n\tfor(int i=0;i<3;i++){\n\t\tvec2 cuv = uv+float(i-1)*chromatic_abberation;\n\t\tfloat dis = abs(length(cuv)-radius+radius*circ_width_offset)-circle_width-radius*circ_width_offset;\n\t\tdis = min(dis,distance(cuv,int_p1)-dot_size);\n\n\t\tfloat d0=length(cuv)-radius;\n\t\tdis = max(d0,dis);\n\n\t\tdis = min(dis,length(old_uv+2.*meta_grid_size)-3.*max(0.,iTime-event37));\n\n\t\tcolor[i] = mix(dot_col[i],color[i],smoothstep(-border/2., border/2., dis));\n\t}\n\n\tfragColor = vec4(color,1);\n}", "image_inputs": [{"id": 29913, "src": "https://soundcloud.com/epoqe/dottiverse", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGBzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[677, 677, 695, 695, 738], [740, 740, 775, 775, 1020], [1022, 1022, 1062, 1062, 1402], [1404, 1404, 1466, 1466, 1612], [1614, 1614, 1661, 1661, 2001], [2003, 2003, 2022, 2022, 2075], [2077, 2077, 2142, 2142, 2541], [2543, 2543, 2606, 2606, 2683], [2685, 2685, 2757, 2757, 2924], [2926, 2926, 2980, 2980, 9259]], "test": "untested"}
{"id": "7lKfWw", "name": "Hyperbolic Visu", "author": "rubioh", "description": "test", "tags": ["abstract", "hyperbolic"], "likes": 5, "viewed": 229, "published": 3, "date": "1664723882", "time_retrieved": "2024-07-30T16:28:33.166713", "image_code": "#define PI 3.14159265359\n#define saturate(v) clamp(v,0.,1.)\n\nfloat cross_(vec2 a, vec2 b){\n    return a.y*b.x-a.x*b.y;\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c){\n\tvec4 K=vec4(1.,2./3.,1./3.,3.);\n\treturn c.z*mix(K.xxx,saturate(abs(fract(c.x+K.xyz)*6.-K.w)-K.x),c.y);\n}\n\n\nvec4 make_square_cell(vec2 coord, vec2 index){\n\n    vec2 centered_coord = coord-.5;\n    float length_ = max(abs(centered_coord.x), abs(centered_coord.y));\n    float radius = .2;\n    \n    \n    float square = max(abs(centered_coord).x, abs(centered_coord).y);\n    square = 1.-smoothstep(0., 0.02, square-radius);\n    \n    vec3 HSV = vec3(cos(iTime/4.)*.5+.5, 1., 1.);\n    vec3 col = hsv2rgb(HSV);\n\n    vec3 col_square = col*square;\n    \n    return vec4(col, square);    \n}\n\n\n\nmat2 rotation_matrix(float angle){\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n   \n    vec2 uv = fragCoord/iResolution.xy;\n   \n    uv -= .5;\n    mat2 rot = rotation_matrix(iTime/5.);\n    uv = rot*uv;\n\n\n\n    float N = 5.;\n    \n\n    \n    uv *= vec2(N, N)*vec2(N, N);\n    uv = sqrt(abs(uv));\n    \n    \n    float mask = sqrt(length(uv.x))*sqrt(length(uv.y));\n    \n    rot = rotation_matrix(iTime/3.);\n    uv = rot*uv;\n    \n    float t = mod(iTime+1.3333, 4.);\n    float line = smoothstep(t-.05, t+.05, length(uv.x))*\n                 (1.-smoothstep(t-.05, t+.05, length(uv.x)));\n  \n    t = mod(iTime, 6.);\n    line += smoothstep(t-0.1-1.5, t-1.5, length(uv.x))*\n                 (1.-smoothstep(t, t+.01, length(uv.x)));\n  \n    t = mod(iTime+ 2.6666, 4.);\n    line += smoothstep(t-.05, t+.05, length(uv.x))*\n                 (1.-smoothstep(t-.05, t+.05, length(uv.x)));\n  \n            \n    \n    //uv = sqrt(abs(uv));\n\n    // Time varying pixel color\n    \n    vec4 col = make_square_cell(fract(2.*uv), floor(2.*uv));\n    \n    vec3 col_line = vec3(1., 1., 1.)*line*(1.-col.w);\n    // Output to screen\n    fragColor = vec4(1.-col.rgb+vec3(1.-mask)*1.+col_line, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 90, 90, 120], [122, 122, 144, 144, 475], [476, 476, 497, 497, 603], [606, 606, 652, 652, 1076], [1080, 1080, 1114, 1114, 1182], [1186, 1186, 1243, 1293, 2375]], "test": "untested"}
{"id": "7tyfRG", "name": "Test Perspective/Vanishing point", "author": "rubioh", "description": "test", "tags": ["perspective"], "likes": 2, "viewed": 190, "published": 3, "date": "1664723867", "time_retrieved": "2024-07-30T16:28:33.981535", "image_code": "#define PI 3.14159265359\n\nfloat cross_(vec2 a, vec2 b){\n    return a.y*b.x-a.x*b.y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n    uv -= vec2(.5);\n    uv *= 10.;\n    \n    //uv = sqrt(abs(uv));\n\n    // Time varying pixel color\n\n    vec2 center_square = vec2(3.*cos(iTime), 3.*sin(iTime));\n    \n   \n    vec2 sgn_center = sign(center_square);\n    float sgn_square = sgn_center.x*sgn_center.y;\n    \n    float radius = 1.;\n    float square = max(abs(center_square-uv).x, abs(center_square-uv).y);\n    square = 1.-step(0., square-radius);\n\n\n    vec2 vertex_up_left = sgn_center*(vec2(-radius, radius))+center_square;\n    vec2 vertex_down_left = sgn_center*(-1.*vec2(radius))+center_square;\n    vec2 vertex_down_right = sgn_center*(vec2(radius, -radius))+center_square;\n\n    float go_ul = step(.2, length(vertex_up_left-uv));\n    float go_dl = step(.2, length(vertex_down_left-uv));\n    float go_dr = step(.2, length(vertex_down_right-uv));\n   \n    vec3 col_vertex = vec3(0.,0.,1.)*(1.-go_ul);\n    col_vertex += vec3(0.,1.,.0)*(1.-go_dl);\n    col_vertex += vec3(1.,0.,.0)*(1.-go_dr);\n    \n    float down_ul = step(0., -cross_(sgn_square*uv, vertex_up_left));\n    float down_dl = step(0., -cross_(sgn_square*uv, vertex_down_left));\n    float up_dl = step(0., cross_(sgn_square*uv, vertex_down_left));\n    float up_dr = step(0., cross_(sgn_square*uv, vertex_down_right));\n    \n    float mask_side = step(0., length(vertex_down_right)-length(uv));\n    float mask_down = step(0., length(vertex_up_left)-length(uv));\n\n    vec3 side_face = vec3(.8, .8, 0.)*up_dl*down_ul*mask_down;\n    vec3 down_face = vec3(0., .8, .8)*up_dr*down_dl*mask_side;\n\n    vec3 col_center = vec3(.5)*(1.-step(.15, length(uv)));\n\n    vec3 col = vec3(square*.6)+col_vertex+col_center+down_face+side_face;\n    \n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tyfRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 55, 55, 85], [88, 88, 145, 195, 1939]], "test": "untested"}
{"id": "NlGfRy", "name": "Typo Ring", "author": "yasuo", "description": "Typo Ring", "tags": ["ring"], "likes": 18, "viewed": 276, "published": 3, "date": "1664702523", "time_retrieved": "2024-07-30T16:28:36.737167", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define SPEED 200.\n#define ZERO (min(iFrame,0))\n#define MATERIAL0 0\n#define MATERIAL1 1\n#define MATERIAL2 2\n#define MATERIAL3 3\n#define MATERIAL4 4\n#define seg_0 0\n#define seg_1 1\n#define seg_2 2\n#define seg_3 3\n#define seg_4 4\n#define seg_5 5\n#define seg_6 6\n#define seg_7 7\n#define seg_8 8\n#define seg_9 9\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nfloat segBase(vec2 p){\n    vec2 prevP = p;\n    \n    float size = 0.02;\n    float padding = 0.05;\n\n    float w = padding*3.0;\n    float h = padding*5.0;\n\n    p = mod(p,0.05)-0.025;\n    float thickness = 0.005;\n    float gridMask = min(abs(p.x)-thickness,abs(p.y)-thickness);\n    \n    p = prevP;\n    float d = B(p,vec2(w*0.5,h*0.5));\n    float a = radians(45.0);\n    p.x = abs(p.x)-0.1;\n    p.y = abs(p.y)-0.05;\n    float d2 = dot(p,vec2(cos(a),sin(a)));\n    d = max(d2,d);\n    d = max(-gridMask,d);\n    return d;\n}\n\nfloat seg0(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    float mask = B(p,vec2(size,size*2.7));\n    d = max(-mask,d);\n    return d;\n}\n\nfloat seg1(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y+=size;\n    float mask = B(p,vec2(size*2.,size*3.7));\n    d = max(-mask,d);\n    \n    p = prevP;\n    \n    p.x+=size*1.8;\n    p.y-=size*3.5;\n    mask = B(p,vec2(size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg2(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x-=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg3(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y = abs(p.y);\n    p.x+=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg4(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    \n    p.x+=size;\n    p.y+=0.08;\n    float mask = B(p,vec2(size*2.,size*2.0));\n    d = max(-mask,d);\n\n    p = prevP;\n    \n    p.y-=0.08;\n    mask = B(p,vec2(size,size*2.0));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg5(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg6(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.y+=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg7(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y+=size;\n    float mask = B(p,vec2(size*2.,size*3.7));\n    d = max(-mask,d);\n    return d;\n}\n\n\nfloat seg8(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y = abs(p.y);\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg9(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat drawFont(vec2 p, int char){\n    float d = 10.;\n    if(char == seg_0) {\n        d = seg0(p);\n    } else if(char == seg_1) {\n        d = seg1(p);\n    } else if(char == seg_2) {\n        d = seg2(p);\n    } else if(char == seg_3) {\n        d = seg3(p);\n    } else if(char == seg_4) {\n        d = seg4(p);\n    } else if(char == seg_5) {\n        d = seg5(p);\n    } else if(char == seg_6) {\n        d = seg6(p);\n    } else if(char == seg_7) {\n        d = seg7(p);\n    } else if(char == seg_8) {\n        d = seg8(p);\n    } else if(char == seg_9) {\n        d = seg9(p);\n    }\n    \n    return d;\n}\n\nfloat drawNumbers(vec2 p){\n    p*=2.0;\n    p.y+=0.5;\n    p.x+=iTime*2.;\n    vec2 gv = fract(p)-0.5;\n    vec2 id = floor(p);\n\n    float n = Hash21(id)*10.0;\n    \n    int char = int(n);\n    float size = 0.35;\n    float d = drawFont(gv*size,char);\n    float t = iTime+1.;\n    if(char < 10){\n        int num = int(mod(t*float(n),10.0));\n        d = drawFont(gv*size,num);\n    }\n    return d;\n}\n\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\nmat2 Rot0(vec2 p){\n    return Rot(0.2+iTime*0.7);\n}\n\nmat2 Rot1(vec2 p){\n    return Rot(0.1-iTime*0.2);\n}\n\nmat2 Rot2(vec2 p){\n    return Rot(0.5+iTime*0.1);\n}\n\nmat2 Rot3(vec2 p){\n    return Rot(1.5-iTime*0.5);\n}\n\nmat2 Rot4(vec2 p){\n    return Rot(2.+iTime*0.6);\n}\n\nfloat ring(vec3 p, float size){\n    return max(abs(p.y)-0.05,abs(length(p.xz)-size)-0.001);\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    p.yz*=Rot0(p.yz);\n    float d = ring(p,0.4);\n    vec2 res = vec2(d,MATERIAL0);\n    \n    p = prevP;\n    \n    p.yz*=Rot1(p.yz);\n    d = ring(p,0.45);\n    \n    vec2 res2 = vec2(d,MATERIAL1);\n    \n    p = prevP;\n    \n    p.yz*=Rot2(p.yz);\n    d = ring(p,0.5);\n    \n    vec2 res3 = vec2(d,MATERIAL2);\n        \n    p = prevP;\n    \n    p.yz*=Rot3(p.yz);\n    d = ring(p,0.55);\n    \n    vec2 res4 = vec2(d,MATERIAL3);\n            \n    p = prevP;\n    \n    p.yz*=Rot4(p.yz);\n    d = ring(p,0.6);\n    \n    vec2 res5 = vec2(d,MATERIAL4);\n    \n    return combine(combine(combine(combine(res,res2),res3),res4),res5);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 tex(vec3 p){\n    vec2 uv = vec2(1.5*atan(p.x,p.z)/6.2832,p.y/3.);\n    uv*=10.0;\n    float d = drawNumbers(uv);\n    return mix(vec3(0.0),vec3(1.8),S(d,0.0));\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    vec3 prevP = p;\n    if(mat == MATERIAL0){\n        p.yz*=Rot0(p.yz);\n        col = tex(p);        \n    } else if(mat == MATERIAL1){\n        p = prevP;\n        p.yz*=Rot1(p.yz);\n        col = tex(p);  \n    } else if(mat == MATERIAL2){\n        p = prevP;\n        p.yz*=Rot2(p.yz);\n         col = tex(p);\n    } else if(mat == MATERIAL3){\n        p = prevP;\n        p.yz*=Rot3(p.yz);\n         col = tex(p); \n    } else if(mat == MATERIAL4){\n        p = prevP;\n        p.yz*=Rot4(p.yz);\n        col = tex(p);\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, -1.35);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.yz *= Rot(radians(-5.0));\n        ro.xz *= Rot(radians(iTime*50.0));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGfRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[581, 581, 603, 603, 693], [695, 695, 717, 717, 1208], [1210, 1210, 1229, 1229, 1379], [1381, 1381, 1400, 1400, 1701], [1703, 1703, 1722, 1722, 2010], [2012, 2012, 2031, 2031, 2321], [2323, 2323, 2342, 2342, 2630], [2632, 2632, 2651, 2651, 2939], [2941, 2941, 2960, 2960, 3230], [3232, 3232, 3251, 3251, 3434], [3437, 3437, 3456, 3456, 3642], [3644, 3644, 3663, 3663, 3933], [3935, 3935, 3968, 3968, 4527], [4529, 4529, 4555, 4555, 4918], [4921, 4921, 4957, 4957, 4999], [5001, 5001, 5019, 5019, 5052], [5054, 5054, 5072, 5072, 5105], [5107, 5107, 5125, 5125, 5158], [5160, 5160, 5178, 5178, 5211], [5213, 5213, 5231, 5231, 5263], [5265, 5265, 5296, 5296, 5358], [5360, 5360, 5382, 5382, 6015], [6017, 6017, 6075, 6075, 6342], [6344, 6344, 6368, 6368, 6569], [6571, 6571, 6613, 6613, 6808], [6810, 6810, 6827, 6827, 6973], [6975, 6975, 7034, 7034, 7566], [7568, 7568, 7625, 7625, 8372]], "test": "untested"}
{"id": "NlyBWm", "name": "Dynamic Editable Terrain", "author": "fenix", "description": "The Recrystalization algorithm applied to terrain. Sky from xor's Nimbostratus: https://www.shadertoy.com/view/Xl\n*mouse to lower terrain*\n*(0-9) + mouse to raise terrain to that height*\n*shift to toggle fast render mode*\n*space to reset*", "tags": ["terrain", "automata", "cellular", "tiltshift", "ising", "annealing", "atomaton"], "likes": 65, "viewed": 920, "published": 3, "date": "1664651862", "time_retrieved": "2024-07-30T16:28:37.976852", "image_code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This is running the same kind of annealing algorithm as my shader a few days ago:\n//\n//   Metal Recrystalization https://www.shadertoy.com/view/flVBRw\n//\n// At the edge of the rendering range, the material is melted and randomized. You can\n// see this sometimes when the camera swings up, there is a sort of rain where the\n// annealing process takes places and the world is created.\n//\n// Closer to the camera, the mutation rate is slowed, but still remains reactive to\n// edits from the player. The idea of the mouse input is that when you hold a number key,\n// you create terrain at that height. Without a number key, you remove terrain.\n//\n// As the camera moves, the area within Buffer A that is melted moves with it, so that by\n// the time you return, any edits will have been erased by the melting and crystalizing\n// process. And return ye shall, since the buffer itself, rendering, etc are all set up\n// to wrap when the camera reaches the edge.\n//\n// The fancy rendering effects are disabled automatically at very high resolutions,\n// because my computer falls over trying to run them. You can click the shift key\n// to toggle them to override my settings. You might want to disable them to push\n// your FPS up to 60 at some resolutions.\n//\n// Buffer A computes the terrain\n// Buffer B renders with ray march\n// Buffer C renders xor's Nimbostratus for the sky: https://www.shadertoy.com/view/Xl\n// Image applies tilt-shift lens effect\n//\n// --------------------------------------------------------------------------------------------\n\n// based on gaussian blur from FabriceNeyret2's smart gaussian blur: https://www.shadertoy.com/view/WtKfD3\n\nint           N =  7;                              // target sampling rate\nfloat         w,                                   // filter width\n              z;                                        // LOD MIPmap level to use for integration \n#define init  z = ceil(max(0.,log2(w*R.y/float(N))));   // N/w = res/2^z\n#define R     iResolution.xy\n\n\nvec4 convol2D(vec2 U) {                                                     \n    vec4  O = vec4(0.0);  \n    float r = float(N-1)/2., g, t=0.;                                       \n    for( int k=0; k<N*N; k++ ) {                                            \n        vec2 P = vec2(k%N,k/N) / r - 1.;                                    \n        t += g = exp(-2.*dot(P,P) );                                        \n        O += g * textureLod(iChannel0, (U+w*P) *R.y/R, z );  \n    }                                                                       \n    return O/t;                                                             \n}      \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float centerDepth = texelFetch(iChannel0, ivec2(iResolution.xy*0.5), 0).w;\n    float depth = texelFetch(iChannel0, ivec2(u), 0).w;\n    \n    // Blur based on depth, the farther from the depth of the center pixel, the more blur,\n    // to create a tilt-shift lens effect.\n    w = (abs(depth-centerDepth)) * 0.015;\n    \n    if (w > 0.002)\n    {\n        init\n        vec2 p = (u - iResolution.xy * 0.5) / iResolution.y;\n        {\n            vec2 U = u / R.y;  \n            O = convol2D(U);\n        }\n    }\n    else\n    {\n        O = texture(iChannel0, u/iResolution.xy);\n    }\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// --------------------------------------------------------------------------------------------\n// Computes the terrain height by attempting to match nearby pixels when near the camera.\n// This buffer is set up for wrapping, and hopefully there are no visible artifacts when\n// the camera wraps around.\n// --------------------------------------------------------------------------------------------\n\nconst int MAX_DIRECTIONS = 13;\n\nvoid updateState(inout vec4 state)\n{\n    if (iFrame == 0)\n    {\n        state = vec4(0, 0, 0, 1);\n    }\n    else\n    {\n        state.xy = iMouse.xy;\n        \n        if (keyClick(KEY_SPACE) || abs(state.z) != iResolution.x * iResolution.y)\n        {\n            state.z = -iResolution.x * iResolution.y;\n            \n            // Automatically disable shadows when switching to very high resolutions\n            if (iResolution.y > 1000.) state.w = -1.;\n            else state.w = 1.;\n        }\n        else\n        {\n            state.z = abs(state.z);\n        }\n        \n        if (state.w == 0.) state.w = 1.;\n        state.w += sign(state.w);\n        \n        if (keyClick(KEY_SHIFT))\n        {\n            state.w = -state.w;\n        }\n    }\n}\n\nfloat melt(float h)\n{\n    h = floor(h*(float(MAX_DIRECTIONS)));\n    return h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n\n    vec3 h = hash(uvec3(ifc.y, ifc.x, iFrame + int(iDate.w)));\n    \n    fragColor = texelFetch(iChannel0, ifc, 0);\n    \n    if (ifc == ivec2(0))\n    {\n        updateState(fragColor);\n        return;\n    }\n    \n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    float directions = float(MAX_DIRECTIONS);\n    \n    if (iFrame == 0 || state.z < 0.)\n    {\n        fragColor.x = melt(h.x);\n        fragColor.yzw = vec3(0);\n    }\n    else\n    {\n        float time = float(iTime);\n        vec2 mouse = iMouse.xy;\n\n        // Apply heat everywhere but a circle around the camera position\n        vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n        fxCalcCamera(time, mouse, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n        \n        vec2 p = mod(cameraPos.xz * iResolution.y * 0.1, iResolution.xy);\n\n        float TEMP_SCALE = 3.0 / iResolution.y;\n        float t = distance(p, fragCoord)*TEMP_SCALE;\n        \n        // Copy the circle multiple times to handle wraparound conditions\n        t = min(t, distance(p + iResolution.xy*vec2(1, 0), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(0, 1), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(-1, 0), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(0, -1), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(1, 1), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(-1, -1), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(-1, 1), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(1, -1), fragCoord)*TEMP_SCALE);\n        \n        // Handle mouse input\n        if (iMouse.z > 0. && iMouse.w < 0. && state.xy != vec2(0))\n        {\n            vec3 fromLookAt, fromPos, fromFwd, fromLeft, fromUp;\n            fxCalcCamera(time - iTimeDelta, mouse, fromLookAt, fromPos, fromFwd, fromLeft, fromUp);\n\n        \tvec3 rayFrom = fxCalcRay(state.xy, iResolution, fromFwd, fromUp, fromLeft);\n        \tvec3 rayTo = fxCalcRay(iMouse.xy, iResolution, cameraFwd, cameraUp, cameraLeft);\n            float fromT = cameraPos.y / rayFrom.y;\n            vec3 fromHit = cameraPos - fromT * rayFrom;\n            vec2 projFrom = mod(fromHit.xz * iResolution.y * 0.1, iResolution.xy);\n            float toT = cameraPos.y / rayTo.y;\n            vec3 toHit = cameraPos - toT * rayTo;\n            vec2 projTo = mod(toHit.xz * iResolution.y * 0.1, iResolution.xy);\n            \n            if (distance(projFrom, projTo) < iResolution.y * 0.3)\n            {\n                float dist = linePointDist2(projFrom, projTo, fragCoord);\n\n                float targetHeight = 0.;\n                for (int i = 1; i <= 9; ++i)\n                {\n                    if (keyDown(KEY_0 + i))\n                    {\n                        targetHeight = float(i) + 2.;\n                    }\n                }\n\n                if (dist < iResolution.y*0.25)\n                {\n                    if (fragColor.r > targetHeight)\n                    {\n                        fragColor.r -= 0.01 * iResolution.y / (dist + 1.0);\n                    }\n                    else if (fragColor.r < targetHeight)\n                    {\n                        fragColor.r +=  0.01 * iResolution.y / (dist + 1.0);\n                    }\n                }\n            }\n        }\n        fragColor.r = clamp(fragColor.r, 0., float(MAX_DIRECTIONS));\n    \n        float annealChance = mix(0.02, 0.5, smoothstep(1800., 3000., iResolution.y));\n        if (abs(state.w) < 20.) annealChance *= 10.;\n        if (t > 1.1 + 0.9 * h.x)\n        {\n            // Melting temp\n            fragColor.x = melt(h.y);            \n        }\n        else if (h.y < annealChance)\n        {\n            // Count how many neighbors in range have each possible direction\n            int counts[MAX_DIRECTIONS];\n            for (int i = 0; i < int(directions); ++i)\n            {\n                counts[i] = 0;\n            }\n\n            const int RANGE = 2;\n            for (int x = -RANGE; x <= RANGE; ++x)\n            {\n                for (int y = -RANGE; y <= RANGE; ++y)\n                {\n                    ivec2 ni = ifc + ivec2(x, y);\n                    if (ni == ivec2(0)) continue; // Ignore state pixel\n                    vec4 n = texture(iChannel0, (vec2(ni) + 0.5) / iResolution.xy);\n                    counts[int(n.x)]++;\n                }\n            }\n\n            // Find the direction most popular among neighbors\n            int bestCount = -1;\n            int bestDir;\n            bool unique;\n\n            for (int d = 0; d < int(directions); ++d)\n            {\n                if (counts[d] > bestCount)\n                {\n                    bestCount = counts[d];\n                    bestDir = d;\n                    unique = true;\n                }\n                else if (counts[d] == bestCount)\n                {\n                    unique = false;\n                }\n            }\n\n            if (unique)\n            {\n                if (abs(fragColor.x - float(bestDir)) > h.x * directions*0.001)\n                    fragColor.x = float(bestDir);\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nconst float PI = 3.141592653589793;\n\nvoid fxCalcCamera(in float time, in vec2 mouse, out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    time *= 0.1;\n    \n    cameraLookAt = vec3(time + 0.5*sin(time), 1.0 + 0.6 * sin(time*0.6), time + 0.5*cos(time));\n    cameraPos = vec3(time-0.1 + 0.5*sin(time-0.1), 1.1 + 0.6 * sin(time*0.6-0.02), time-0.1 + 0.5*cos(time-0.1));\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd)) * 0.5;\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 1.0 - 0.5;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    vec2 closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    return dot(closestDelta, closestDelta);\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_0 48", "buffer_b_code": "// --------------------------------------------------------------------------------------------\n// Render the scene via ray marching, with shadows.\n// --------------------------------------------------------------------------------------------\n\nconst float LAYER_HEIGHT = 0.004;\n\nfloat scene(vec3 p, float t)\n{\n    p.x *= iResolution.y/iResolution.x;\n    float h = textureLod(iChannel0, p.xz*0.1, 0.).r + textureLod(iChannel0, p.xz*0.1, 1.).x;\n    float height = p.y - max(6.,h)*LAYER_HEIGHT;\n    \n    return min(height, p.y + .05);\n}\n\nvec3 grad(vec3 p, float t, float d)\n{\n    vec2 delta = vec2(d, 0);\n    return normalize(\n           vec3(scene(p + delta.xyy, t) - scene(p - delta.xyy, t),\n                scene(p + delta.yxy, t) - scene(p - delta.yxy, t),\n                scene(p + delta.yyx, t) - scene(p - delta.yyx, t)));\n}\n\nconst float MAX_T = 6.0;\nconst float SDF_EPSILON = 0.002;\nvec3 rayMarch(vec3 pos, vec3 dir, float scale, out float t)\n{\n    t = 0.;\n    for (int i = 0; i < 250; ++i)\n    {\n        float d = scene(pos, scale);\n        \n        if (d < SDF_EPSILON || t > MAX_T)\n        {\n            break;\n        }\n        \n        float slowdown = max(d * 0.1, 0.2);\n        t += d * slowdown;\n\n        pos += dir * d * slowdown;\n    }\n \n    return pos;\n}\n\nvec4 render(vec3 cameraPos, vec3 rayDir, bool doShadow, out vec3 hitPos, out vec3 normal)\n{\n    float t;\n    hitPos = rayMarch(cameraPos, rayDir, float(iFrame), t);\n\n    normal = grad(hitPos, float(iFrame), 0.01);\n    vec3 offsetPos = hitPos + normal*SDF_EPSILON;\n\n    // Compute color\n    vec3 h = hash(uvec3(100.*vec3(hitPos.x, hitPos.y, hitPos.z)));\n    vec3 hGrass = hash(uvec3(100.*vec3(hitPos.x, hitPos.z, hitPos.x)));\n    float splotches = (h.x * 0.5 + 0.5);\n    float splotchesGrass = (hGrass.x * 0.5 + 0.5); // Use x,z splotch pattern for grass, to fix rendering artifact\n    vec3 color = vec3(0.8, 0.4, 0.1) * splotches;\n    if (dot(normal, vec3(0, 1, 0)) > 0.8) color = vec3(0., 1.0, 0.) * splotchesGrass;\n    if (hitPos.y <= 9.*LAYER_HEIGHT) color = vec3(0.9, 0.9, 0.5) * splotches;\n    if (hitPos.y <= 7.*LAYER_HEIGHT)\n    {\n        color = vec3(0.5, 0.5, 1.0);\n    }\n    \n    // Apply light and shadow\n    vec3 lightDir = normalize(vec3(0, 0.4, 1));\n    const float AMBIENT = 0.3;\n\n    float shadowT = MAX_T;\n    \n    if (doShadow)\n    {\n        rayMarch(offsetPos, lightDir, float(iFrame), shadowT);\n    }    \n    \n    if (shadowT < MAX_T)\n    {\n        color = color * AMBIENT;\n    }\n    else\n    {\n        float dp = max(0., dot(normal, lightDir));\n        color = color * (dp + AMBIENT);\n    }\n    \n    // Fade at distance\n    if (t >= MAX_T*.75)\n    {\n        // Pebble texture == clouds\n        vec3 sky = texture(iChannel1, rayDir.xy * 0.6 + 0.5).xyz;\n        //vec3 sky = mix(vec3(0.0, 0.0, 0.1), vec3(1), texture(iChannel1, rayDir.xy * 0.6 + 0.5 ).rrr);\n        color = mix(color, sky, smoothstep(MAX_T*.75, MAX_T, t));\n    }\n    \n    return vec4(color, t);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{    \n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    float time = float(iTime);\n    vec2 mouse = iMouse.xy;\n    bool doShadow = state.w >= 0.;\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(time, mouse, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n\tvec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n    \n    vec3 hitPos, normal;\n    vec4 colorT = render(cameraPos, rayDir, doShadow, hitPos, normal);\n\n    // Handle reflections\n    if (hitPos.y <= 7.*LAYER_HEIGHT && doShadow)\n    {\n        float reflectT;\n        vec3 reflectHitPos, reflectNormal;\n        vec4 reflectColorT = render(hitPos + normal*SDF_EPSILON, reflect(rayDir, vec3(0, 1, 0)), state.w== 0., reflectHitPos, reflectNormal);\n        colorT.xyz = mix(colorT.xyz, reflectColorT.xyz, 0.4);\n    }\n    \n    fragColor = colorT;\n    \n#if 0 // Debug terrain texture\n    fragColor = sin(texelFetch(iChannel0, ivec2(fragCoord), 0).r + vec4(2, 3, 4, 5));\n    fragColor.w = 0.;\n#endif\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// xor's Nimbostratus: https://www.shadertoy.com/view/XlfyD7\n\nfloat Speed = .001;\nvec3 Light = vec3(.6,.2,.8);\n    \nfloat Map(vec3 Position)\n{\n    vec3 P = (Position*0.5+texture(iChannel0,Position*2.+iTime*Speed*.2).xyz*.02);\n    \n    float C = texture(iChannel0,P).r;\n    C *= texture(iChannel0,P*vec3(.5,1,.5)).g;\n    C = C*.9+.1*pow(texture(iChannel0,P*5.1).a,2.);\n    return max((C-.3)*sqrt((Position.z-.1)/.3),0.)/.5;\n}\nvoid mainImage(out vec4 Color,in vec2 Coord)\n{\n    vec3 R = vec3((Coord-.5*iResolution.xy)/iResolution.y,1);\n    vec3 P = vec3(0,iTime*Speed,0);\n    \n    vec4 C = vec4(0);\n    for(float I = .2;I<.5;I+=.01)\n    {\n        float M1 = Map(P+R*I);\n        float M2 = Map(P+R*I+Light*.01);\n        C += vec4((.6+vec3(.6,.5,.4)*(exp(-M2*10.)-M1)),1)*M1*(1.-C.a);\n        if (C.a>.99) break;\n    }\n\tColor = C+vec4(vec3(.5,.7,.9)-R.y*.4,1)*(1.-C.a);\n}", "buffer_c_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlyBWm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2210, 2210, 2233, 2233, 2839]], "test": "untested"}
{"id": "flKBWw", "name": "Chladney", "author": "mcpe0712", "description": "Simple equation", "tags": ["math"], "likes": 8, "viewed": 264, "published": 3, "date": "1664637863", "time_retrieved": "2024-07-30T16:28:38.749786", "image_code": "\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.0);\n    \n    uv -= 0.5;\n    uv.x /= iResolution.y/iResolution.x;\n    \n    \n    float timescale = 0.1;\n    \n    \n    float curr = iTime*timescale;\n    \n    \n    float n = 6.9*(sin(curr)+1.1);//mod(curr*5.,30.9);\n    float m = 5.9*(cos(curr)+1.1);//mod(curr*2.,18.9);\n    const float PI=3.1415;\n    \n    \n    float ans = sin(n*PI*uv.x)*sin(m*PI*uv.y) - sin(m*PI*uv.x)*sin(n*PI*uv.y);\n    col = hsv2rgb(vec3(1. - abs(ans)+curr,1.,1.));\n    fragColor = vec4(col,1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flKBWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 24, 24, 193], [195, 195, 252, 252, 784]], "test": "untested"}
{"id": "flKfDw", "name": "Today", "author": "CayenneLee", "description": "Today is Saturday", "tags": ["abstract", "mood"], "likes": 1, "viewed": 173, "published": 3, "date": "1664627331", "time_retrieved": "2024-07-30T16:28:39.499780", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 main_col=texture(iChannel0,uv).rgb;\n    vec3 sec_col=texture(iChannel1,uv).rgb;\n    \n    uv.x=cos(uv.x)*main_col.r*sec_col.b;\n    uv.y=sin(uv.y)*main_col.b*sec_col.r;\n\n    \n    vec3 col = distance(uv.x*uv.x+uv.y*uv.y,1.)*vec3(1,1,1)*tan(main_col.g);\n\n    col = 0.5 + 0.5*cos(iTime+uv.xyx+col)*col;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flKfDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 443]], "test": "untested"}
{"id": "NtKfWw", "name": "Sierpinski triangle barycentrics", "author": "hypnothalamus", "description": "Sierpinski function returns 0 if inside a black domain of a Sierpinski triangle with 'steps' iterations and outputs normalized barycentric coordinates per triangle domain.", "tags": ["triangle", "sierpinski"], "likes": 2, "viewed": 255, "published": 3, "date": "1664621730", "time_retrieved": "2024-07-30T16:28:40.277701", "image_code": "// Created by Lucian Stanculescu in CLAVICULA : https://clavicula.link\n// use freely\n\n#define ANIMATED\n#define STEPS 7\n\nfloat Sierpinski(inout vec2 p, int steps)\n{\n\tfor (int i = 0; i < steps; ++i)\n\t{\n\t\tp *= 2.0;\n\n\t\tbool a = p.x + p.y < 1.0;\n\t\tbool b = p.x > 1.0;\n\t\tbool c = p.y > 1.0;\n\n\t\tif (!a && !b && !c) return 0.0;\n\n\t\tp.x -= float(b);\n\t\tp.y -= float(c);\n\t}\n\treturn 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p.x -= 0.5 * p.y; // sqew transform\n\n#ifdef ANIMATED\n    int steps = int(iTime)%STEPS;\n#else\n    int steps = STEPS;\n#endif\n\n    steps++; // start from 1 iteration\n\n    vec2 uv = p;\n    bool s = Sierpinski(uv, steps) > 0.0;\n    fragColor = vec4( p.x>0.0 && p.y>0.0 && p.x+p.y<1.0 ? (s ? uv : 1.0-uv) : vec2(0.0), 0.0, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtKfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 163, 163, 376], [378, 378, 435, 435, 803]], "test": "untested"}
{"id": "7lGBWw", "name": "Neural Detonation", "author": "leon", "description": "neurons sparkling  ", "tags": ["abstract", "neuron"], "likes": 64, "viewed": 1474, "published": 3, "date": "1664615561", "time_retrieved": "2024-07-30T16:28:41.194250", "image_code": "\n// Neural Detonation\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define repeat(p,r) (mod(p+r/2.,r)-r/2.)\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat gyroid (vec3 seed)\n{\n    return dot(sin(seed),cos(seed.yzx));\n}\n\nfloat fbm (vec3 seed)\n{\n    float result = 0.;\n    float a = .5;\n    for (int i = 0; i < 3; ++i) {\n        seed += result;\n        result += gyroid(seed/a)*a;\n        a /= 3.;\n    }\n    return result;\n}\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n  p3 += dot(p3, p3.zyx + 31.32);\n  return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n", "buffer_a_code": "\n// globals\nfloat rng;\nfloat glow;\n\nfloat map(vec3 p)\n{\n    float dist = 100.;\n    \n    // travel\n    p.z -= iTime * .5;\n    vec3 q = p;\n    \n    // repeat\n    float grid = 4.;\n    float id = hash13(floor(p/grid-.5));\n    p = repeat(p,grid);\n    p += (hash31(id*100.)*2.-1.);\n    \n    // spice\n    float noise = fbm(p);\n    \n    // jazz\n    float t = iTime * .2 + rng * .01 + id * 196.;\n    \n    // kaleido\n    float a = 1.;\n    const float count = 5.;\n    for (float i = 0.; i < count; ++i)\n    {\n        // funk\n        float tempo = iTime*.7+i*2.+p.z*.5+q.z*.1;\n    \n        // move\n        float rythm = pow(sin(tempo)*.5+.5, 10.);\n        \n        // rotation\n        p.xz *= rot((rythm*.1+t)/a);\n        p.yx *= rot((rythm*.2+t)/a);\n        \n        // fold\n        float r = (rythm * .5 + .05 + noise*.1)/a;\n        p.xz = abs(p.xz)-r*a;\n        \n        // shape\n        dist = min(dist, length(p.xz));\n        \n        // falloff\n        a /= 1.2 + 0.7 * id;\n    }\n    \n    // shine\n    glow += .0005/dist;\n\n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    \n    // coordinates\n    vec2 p = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    vec3 ray = normalize(vec3(p, -1.));\n    vec3 pos = vec3(0,0,0) + ray;\n\n    // globals\n    rng = hash13(vec3(fragCoord, iFrame));\n    glow = 0.;\n    \n    // raymarch\n    float total = 0.;\n    float maxDist = 20.;\n    for (float steps = 35.; steps > 0.; --steps)\n    {\n        float dist = map(pos);\n        if (dist < .0001 * total || total > maxDist) break;\n        total += dist;\n        pos += ray * dist;\n    }\n\n    // palette\n    vec3 tint = .5 + .5 * cos(vec3(1,2,3)*5.5 + length(pos) * .2 - .5);\n    \n    fragColor = vec4(tint * glow,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "\n// Minimal Temporal Anti Aliasing\n// https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    vec3 temporal = texture(iChannel1, uv).rgb;\n    vec3 minColor = vec3(9999.), maxColor = vec3(-9999.);\n    for(int x = -1; x <= 1; ++x){\n        for(int y = -1; y <= 1; ++y){\n            vec3 c = texture(iChannel0, uv + vec2(x, y) / iResolution.xy).rgb;\n            minColor = min(minColor, c);\n            maxColor = max(maxColor, c);\n        }\n    }\n    temporal = clamp(temporal, minColor, maxColor);\n    fragColor.rgb = mix(color, temporal, 0.9);\n    fragColor.a = 1.0;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGBWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 80, 80, 162]], "test": "untested"}
{"id": "stGfDw", "name": "testep33", "author": "auxnoid", "description": "Have you ever shared your screen while looking at your screen share? What if you could share multiple screen shares rotated randomly at once?\n\nThis is basically what I've done here except instead of a texture I've used cos to get some cool looking colors!", "tags": ["fractal", "epileptic"], "likes": 3, "viewed": 176, "published": 3, "date": "1664601402", "time_retrieved": "2024-07-30T16:28:42.025029", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*0.9;\n\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define ScreenCount 191.             //Increase for more complex shapes\n#define ColorDelta .00001          //Decrease for less static\n\n#define pi 3.14159\n\nfloat Rectangle(vec2 uv, float Rot, vec2 Size, vec2 Pos, float Blur) {\n    uv -= .5;\n    uv /= Size;\n    uv -= Pos;\n   \tuv *= mat2(cos(Rot), -sin(Rot), sin(Rot), cos(Rot));\n    uv += 0.1;\n    \n    float XBand = smoothstep(-Size.x - Blur, -Size.x + Blur, uv.x) * smoothstep(Size.x + Blur, Size.x - Blur, uv.x);\n    float YBand = smoothstep(-Size.y - Blur, -Size.y + Blur, uv.y) * smoothstep(Size.y + Blur, Size.y - Blur, uv.y);\n    return XBand * YBand;\n}\n\nvec3 GetColor(float In)\n{\n    In += iTime * .0075;\n    return vec3(cos(In * pi + pi * .7) * .5 + .1, cos(In * pi + pi * .666666) * .5 + .5, -cos(In * pi + pi) * .5 + .5);\n}\n\nfloat Screen(vec2 uv, float Rot, vec2 Size, vec2 Pos)\n{\n    uv -= .5;\n    uv /= Size;\n    uv -= Pos;\n   \tuv *= mat2(cos(Rot), -sin(Rot), sin(Rot), cos(Rot));\n    uv += .5;\n    \n    if (Rectangle(uv, 0., vec2(.8), vec2(.7), .47) == 0.) {\n        return .0090475;\n    }\n    \n    float Col = 0.;\n    float Previous = fract(texture(iChannel0, uv).w - ColorDelta);\n    \n    return Col + Previous;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float Sum = 0.;\n    for (int n = 0; n < int(ScreenCount); n++) {\n        float i = (float(n) * 14.);\n        float t = cos(float(i) / ScreenCount * pi * -cos(iTime * pi * 92.) * .001);\n        Sum = Screen(uv, iTime, vec2(cos(t) * (0.0015 - sin(t * (pi * 0.33) * 0.01)) - .5), vec2(cos(t * -3.+(cos(t*3.)*4.)) * .03, -sin(t * 4.) * 0.003)) + Sum;\n    }\n    \n    fragColor = vec4(GetColor(Sum), Sum);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGfDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 144]], "test": "untested"}
{"id": "7lyBDW", "name": "Cafe Wall Illusion (122 chars)", "author": "fenix", "description": "An golfed rendition of the \"cafe wall illusion\". All the grey lines are, of course, entirely straight and parallel to each other. Can anyone make a shorter version?\n\nhttps://en.wikipedia.org/wiki/Caf%C3%A9_wall_illusion\n", "tags": ["wall", "optical", "illusion", "perception", "golf", "reproduction", "cafe", "cafewall"], "likes": 7, "viewed": 216, "published": 3, "date": "1664600419", "time_retrieved": "2024-07-30T16:28:42.768044", "image_code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// reference: https://en.wikipedia.org/wiki/Caf%C3%A9_wall_illusion\n\n// From FabriceNeyret2: 122 chars (-1)\n//*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u /= iResolution.y;\n    \n    O = vec4(modf(u.y / .1, O.w) < .1 ? .5 : 1. / (fract(u.x / .2 + .15 * sin(O.w * 1.6)) - .5));\n}\n/**/\n\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u /= iResolution.y;\n    \n    O = vec4(modf(u.y / .1, O.w) < .1 ? .5 : fract(u.x / .2 + .15 * sin(O.w * 1.6)) < .5 ? 1. : 0.);\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyBDW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[276, 319, 357, 357, 486]], "test": "untested"}
{"id": "styBDw", "name": "Sierpinski triangle one pass", "author": "hypnothalamus", "description": "Sierpinski function returns 0 if inside a black domain of a Sierpinski triangle with 'steps' iterations.", "tags": ["triangle", "sierpinski"], "likes": 3, "viewed": 195, "published": 3, "date": "1664598579", "time_retrieved": "2024-07-30T16:28:43.517039", "image_code": "// Created by Lucian Stanculescu in CLAVICULA : https://clavicula.link\n// use freely\n\n#define ANIMATED\n#define STEPS 7\n\nfloat Sierpinski(vec2 p, int steps)\n{\n\tfor (int i = 0; i < steps; ++i)\n\t{\n\t\tp *= 2.0;\n\n\t\tbool a = p.x + p.y < 1.0;\n\t\tbool b = p.x > 1.0;\n\t\tbool c = p.y > 1.0;\n\n\t\tif (!a && !b && !c) return 0.0;\n\n\t\tp.x -= float(b);\n\t\tp.y -= float(c);\n\t}\n\treturn 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p.x -= 0.5 * p.y; // sqew transform\n\n#ifdef ANIMATED\n    int steps = int(iTime)%STEPS;\n#else\n    int steps = STEPS;\n#endif\n\n    steps++; // start from 1 iteration\n\n    fragColor = vec4( p.x>0.0 && p.y>0.0 && p.x+p.y<1.0 ? Sierpinski(p, steps) : 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/styBDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 157, 157, 370], [372, 372, 429, 429, 725]], "test": "untested"}
{"id": "slGBDw", "name": "Recursive Circles", "author": "isaacchurchill", "description": "Each circle contains the others! The nesting depth is adjustable.", "tags": ["2d", "circles", "recursive"], "likes": 6, "viewed": 245, "published": 3, "date": "1664595395", "time_retrieved": "2024-07-30T16:28:44.310917", "image_code": "#define ANIMATE\n#define NEST_DEPTH 7\n#define SIZE_RATIO 0.45;\n\nvec4 nestedCircles(vec2 uv)\n{\n    const vec4 outsideColor = vec4(0.2, 0.2, 0.25, 1.0);\n    const vec4 circleColors[4] = vec4[](\n        vec4(1.0, 0.9, 0.0, 1.0),\n        vec4(1.0, 0.0, 0.0, 1.0),\n        vec4(0.0, 1.0, 0.0, 1.0),\n        vec4(0.0, 0.0, 1.0, 1.0));\n    const int circleChildren[12] = int[](\n        1, 2, 3,\n        2, 3, 0,\n        3, 0, 1,\n        0, 1, 2);\n    const vec2 topLeftOffset = vec2(-0.45, 0.3);\n    const vec2 topRightOffset = vec2(0.45, 0.3);\n    const vec2 bottomOffset = vec2(0.0, -0.5);\n\n\n    vec2 pos = uv;\n    float scale = 1.0;\n    if (length(pos) * scale <= 1.0) {\n        int currentColor = 0;\n        for (int i = 0; i < NEST_DEPTH; i++) {\n            #ifdef ANIMATE\n            float theta = i % 2 == 0 ? iTime * 0.5 : iTime * -0.5;\n            mat2 rotMat = mat2(\n                cos(theta), -sin(theta),\n                sin(theta), cos(theta));\n            pos *= rotMat;\n            #endif\n            \n            float smallerScale = scale * SIZE_RATIO;\n            if (length(pos - topLeftOffset * scale) <= smallerScale) {\n                pos -= topLeftOffset * scale;\n                scale = smallerScale;\n                currentColor = circleChildren[currentColor * 3];\n            } else if (length(pos - topRightOffset * scale) <= smallerScale) {\n                pos -= topRightOffset * scale;\n                scale = smallerScale;\n                currentColor = circleChildren[currentColor * 3 + 1];\n            } else if (length(pos - bottomOffset * scale) <= smallerScale) {\n                pos -= bottomOffset * scale;\n                scale = smallerScale;\n                currentColor = circleChildren[currentColor * 3 + 2];\n            } else {\n                break;\n            }\n        }\n        float gradient = 1.0 - 0.5 * dot(pos, pos) / (scale * scale);\n        return circleColors[currentColor] * gradient;\n    } else {\n        float gradient = min(dot(pos, pos) * 0.25, 1.0);\n        return outsideColor * gradient;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    fragColor = nestedCircles(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGBDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2056, 2056, 2113, 2113, 2263]], "test": "untested"}
{"id": "slGfWw", "name": "other arms", "author": "jorge2017a2", "description": "other arms", "tags": ["otherarms"], "likes": 4, "viewed": 186, "published": 3, "date": "1664592114", "time_retrieved": "2024-07-30T16:28:45.067894", "image_code": "//por jorge2017a2\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n/// y El grande Grupo de Shadertoy\n///other arms-----30-sep-2022\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(8.0*antialiasing(1.0),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n#define R iResolution.xy\n#define s3(v,l) smoothstep(l/R.y,0.,v) // AA\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 cs(float x)\n{ return vec2(cos(x),sin(x) );}\n\nvec3 Brazos(vec2 p, vec3 colOut)\n{   float l1,l2,l3,l4;\n    float a1, a2,a3,a4;\n    vec2 p0,p1,p2,p3,p4;\n    \n    float t=iTime;\n    \n    p0=vec2(0.0,0.0);\n    a1=radians(45.0*cos(t*2.));\n    a2=radians(t*50.0);\n    a3=radians(45.0);\n    a4=radians(180.0*sin(t+cos(t)));\n    l1=2.5;\n    l2=3.0;\n    l3=2.0;\n    l4=3.0;\n    \n    p1=p0+l1*cs(a1);\n    p2=p1+l2*cs(a2);\n    p3=p2+l3*cs(a3);\n    p4=p3+l4*cs(a4);\n    \n    float d1= sdSegment(p,p0,p1);\n    float d2= sdSegment(p,p1,p2);\n    float d3= sdSegment(p,p2,p3);\n    float d4= sdSegment(p,p3,p4);\n    \n    float ds1= sdCircle(p-p1,l1);\n    float ds2= sdCircle(p-p2,l2);\n    float ds3= sdCircle(p-p3,l3);\n    float ds4= sdCircle(p-p4,l4);\n    \n    vec3 col=colOut;\n    col= DrawFigBorde(vec3(1.0), col,ds4 );\n    col= DrawFigBorde(vec3(1.0), col,ds2 );\n    col= DrawFigBorde(vec3(1.0), col,ds3 );\n    col= DrawFigBorde(vec3(1.0), col,ds1 );\n    \n    col= DrawFigBorde(vec3(0.0), col,abs(d1)-0.1 );\n    col= DrawFigBorde(vec3(1.0,0.0,0.0), col,abs(d2)-0.1 );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0), col,abs(d3)-0.1 );\n    col= DrawFigBorde(vec3(1.0,0.0,1.0), col,abs(d4)-0.1 );\n    return col;\n}\n\nfloat fbm(vec2 p){\n    return texture(iChannel0, p*.001).x*.533+ texture(iChannel0, p*.01).x*.267 +\n           texture(iChannel0, p*.3).x*.133  + texture(iChannel0, p*.5).x*.067; \n}\n\nvec3 grid(vec2 uv)\n{ // Time varying pixel color\n    vec3 grid_color = vec3(.5, .2, .9);\n    vec3 col = vec3(0.9);\n    const float grid_size = .1; \n    vec2 u=uv+vec2(cos(iTime*0.05));\n    u -= (vec2(fbm(uv*16.), fbm(u*16. + .35)) - .5) * .008;\n    /// col = 0.5 + 0.5*cos(iTime+u.xyx+vec3(0,2,4));\n    col = mix(col, grid_color, s3( pow(fract(u.x / grid_size -.5)-.5, 2.)-.001 , 1.5));\n    col = mix(col, grid_color, s3( pow(fract(u.y / grid_size -.5)-.5, 2.)-.001 , 1.5));\n    col = mix(col, col*.7, texture(iChannel0, u*5.).x*.5);\n    col += texture(iChannel0, (u+vec2(.125,.382))*5.).x*.2;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec2 u = fragCoord/iResolution.xy;\n    \n    uv-=vec2(0.0,-0.5);\n    float esc=8.0;\n    uv*=esc;\n    vec3 col=vec3(0.0);\n    col= grid(u);\n    col= Brazos(uv-vec2(0.0,5.0), col);\n \n    col=pow(col,  vec3(1.));\n    //vignette\n    uv = u; uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    vig = pow(vig, 0.25); // change pow for modifying the extend of the  vignette\n    \n    fragColor = vec4(col*vig,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[432, 432, 494, 494, 624], [626, 626, 661, 661, 684], [686, 686, 738, 738, 854], [856, 856, 874, 874, 904], [906, 906, 940, 940, 2052], [2054, 2054, 2072, 2072, 2235], [2237, 2237, 2257, 2285, 2848], [2850, 2850, 2907, 2907, 3452]], "test": "untested"}
{"id": "ftyfDm", "name": "Flower Design v314", "author": "spenceryonce", "description": "I learnt this technique originally from IQ. ", "tags": ["flower", "iq", "shader", "design", "maths"], "likes": 1, "viewed": 192, "published": 3, "date": "1664578694", "time_retrieved": "2024-07-30T16:28:45.821878", "image_code": "void mainImage( out vec4 c, in vec2 fc )\n{\n    vec2 uv = fc/iResolution.xy;\n    vec3 mixedCol = mix(vec3(1.0,0.4,0.0),vec3(0.5,0.0,0.0),sqrt(uv.y*uv.y));\n    vec3 color = vec3(0.0);\n    \n    //center point\n    vec2 p = uv-vec2(0.5,0.5);\n    \n    //flower petals\n    float r = 0.15 + 0.1*cos(atan(p.y,p.x)*15.0-10.0*p.x);\n    mixedCol *= smoothstep(r,r+0.02,length(p));\n    \n    //flower stem\n    r = 0.015;\n    r += exp(-60.0*uv.y);\n    r+= 0.002*cos(50.0*p.y);\n    mixedCol *= 1.0 - (1.0-smoothstep(r,r+0.001,abs(p.x+0.08*sin(p.y))))*(1.0-smoothstep(0.0,0.1,p.y));\n    \n    \n    r = 0.05 * sin(atan(p.y,p.x));\n    mixedCol.r += 1.0-smoothstep(r,r+0.02,length(p));\n    mixedCol.g += 1.0-smoothstep(r,r+0.02,length(p));\n    \n    color += mixedCol;\n    c = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyfDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 773]], "test": "untested"}
{"id": "7lKBWD", "name": "PIXEL ART ABCDEFHGIP", "author": "SnoopethDuckDuck", "description": "i have zero clue what this is, very similar to fork / fork fork", "tags": ["feedback", "cellularautomata"], "likes": 19, "viewed": 302, "published": 3, "date": "1664577499", "time_retrieved": "2024-07-30T16:28:46.568880", "image_code": "vec4 cell(ivec2 f) {\n    return texelFetch(iChannel0, f, 0);\n}\n\nvec4 ncell(ivec2 f) {\n    return texelFetch(iChannel1, f, 0);\n}\n\nvoid mainImage(out vec4 col, in vec2 f)\n{\n    col = vec4(0.0);\n    vec4 ncol, ncol2 = vec4(0.0);\n    \n    vec2 uv = (f - 0.5 * iResolution.xy) / iResolution.y;\n    f.xy += 2. * cos(f.x / 80. + 0.5 * iTime);\n    \n    // Translate and zoom\n    f -= 0.5 * iResolution.xy;\n    f *= 2. * dim.y/iResolution.y; \n    f += vec2(0.5,1) * dim;\n\n    // Mirrored coords \n    float s = step(floor(f.x), 0.5 * dim.x);   \n    ivec2 ff = ivec2(s * dim.x + (1. - f.x) * (2. * s - 1.), f.y);\n    col = cell(ff);\n    vec4 col2 = cell(ff + ivec2(1,0)); // was 0,1\n\n    vec3 pl = pal(4. * col.r, vec3(0,1,1)/3.);\n    col.rgb = (1. - step(col.r, 0.)) * pl;\n    col.rgb += 0.5 * col.r * pal(1.5, vec3(0,1,2)/3.);\n    col.rgb += 0.5 * col2.r * pl;\n    float csh = 1. / cosh((10. - 8.8 * tanh(iTime)) * max(abs(uv.x), abs(uv.y)));\n    col = mix(col, vec4(0.5,0.5 + 0.5 * cos(0.25 * uv.y + iTime),1,1), 1.-csh);\n\n    ff.y -= int((1.-tanh(0.4 * iTime)) * 100.);\n    ncol = ncell(ff);\n    ncol2 = ncell(ff + ivec2(1,0)); \n\n    vec3 npl = pal(4. * ncol.r, vec3(0,1,1)/3.);\n    ncol.rgb = (1. - step(ncol.r, 0.)) * npl;\n    ncol.rgb += 0.5 * ncol.r * pal(1.5, vec3(0,1,2)/3.);\n    ncol.rgb += 0.5 * ncol2.r * npl;\n    ncol = mix(ncol, vec4(0.5,0.5 + 0.5 * cos(0.25 * uv.y + iTime),1,1), 1.-csh);\n\n    if (ff.y > 0 && ff.y < int(0.58 * dim.y))\n        col = ncol;\n    //col = mix(col, ncol, 0.5 + 0.5 * thc(4., 8. * uv.x + 0.4 * iTime));\n\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 cell(in ivec2 p) {\n    if (iFrame == 0) // maybe this fixes uninitialized vectors?\n        return vec4(0.0);\n        \n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nvoid mainImage(out vec4 col, in vec2 f)\n{\n    col = vec4(0.0);\n    ivec2 px = ivec2(f);\n    int frame = iFrame;//iFrame % 120;\n    \n    // not my finest line of code!\n    int h = 3 + int(floor(9. * h21(vec2(floor(float(iFrame)/120.), 19.))));\n\n    float rand = h21(f / iResolution.y + vec2(0.1, 0.151) * mod(iDate[3], 5.));\n           \n    if (frame == 0) {     \n        col = vec4(0.0, step(0.9, rand), 0.0, 1.0);\n        return;\n    }\n           \n    // Center cell\n    vec4 e = vec4(0.0);\n    e = cell(px);\n    col = e;\n    \n    // Neighbour cells\n    vec4 b = cell(px - ivec2(0,1));\n    vec4 t = cell(px + ivec2(0,1));\n    vec4 l = cell(px - ivec2(1,0));\n    vec4 r = cell(px + ivec2(1,0));   \n    vec4 bl = cell(px + ivec2(-1,-1));\n    vec4 br = cell(px + ivec2(1, -1));\n    vec4 tl = cell(px + ivec2(-1, 1));\n    vec4 tr = cell(px + ivec2(1,  1));   \n    \n    vec4 bb = cell(px - ivec2(0,2));\n    vec4 tt = cell(px + ivec2(0,2));\n    vec4 ll = cell(px - ivec2(2,0));\n    vec4 rr = cell(px + ivec2(2,0));  \n    \n    vec4 sum = b + t + l + r;\n    vec4 diag = bl + br + tl + tr;\n    vec4 dif = abs(b-t) * abs(l-r);\n    vec4 dif2 = (t + b) * (l + r);\n    vec4 diDif = (tl + br) * (tr + bl);\n    \n    if (frame < 10) {\n        col.g = 0.4 * diag.g - e.g;\n        //col.g = 0.3 * diag.g + 0.2 * sum.g - e.g;\n    } else if (frame == 10) {\n        col.g = step(0.01, e.g);\n    } else if (frame < 13) {\n        if (f.x < 0.5 * dim.x + 1. && abs(f.y - 0.5 * dim.y) < 4.) //could replace 4 with random val\n           col.r = 1.;\n    } else if (frame == 13) {\n        col.b = e.g;\n     //  if (e.g == 1. && dif2.g == 1.)\n      //     col.g = 0.;\n    } else { \n        //if (e.g < 0.5 && sum.r >0.5)\n        //    e.g = 1.;\n        if (e.g == 1. && col.r < 0.2 && (sum+diag).r > 0.5)\n            col.r = 1.;\n        \n        col.r += 0.005 * ((sum+diag).r/8. - 1.);\n               \n        float v = step(tl.r, 0.) + step(tr.r,0.) + \n                  step(bl.r,0.) + step(br.r,0.);\n        if (e.g < 1. && (sum).r >= 2. && v <= 1.)\n            col.g = 1.;\n           \n        if (col.g > 0. && dif.r != 0.) {\n            col.g = 0.;\n        }\n        \n        col.rg = clamp(col.rg, 0., 1.);\n    } \n   \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n#define dim vec2(64, 52)\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKBWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 62], [64, 64, 85, 85, 127], [129, 129, 170, 170, 1537]], "test": "untested"}
{"id": "ftyBDm", "name": "Lerp / Smoothstep Implementation", "author": "spenceryonce", "description": "I decided to try implementing my lerp functions that I made first in desmos graphing calculator to shadertoy. It worked like a charm!! I also was super excited to make my own smoothstep function. Here is the graph: https://www.desmos.com/calculator/rdm4td", "tags": ["circle", "lerp", "smoothstep", "lerpcolors"], "likes": 4, "viewed": 586, "published": 3, "date": "1664576247", "time_retrieved": "2024-07-30T16:28:47.399659", "image_code": "float lerp(float a, float b, float t){\n    return a + (b-a) * t;\n}\n\nfloat llerp(float t){\n    return t;\n}\n\nfloat squaredlerp(float t){\n    return t*t;\n}\n\nfloat quadlerp(float t){\n    return 1.0 - (1.0 - t) * (1.0 - t);\n}\n\nfloat ss(float t){\n    return lerp(quadlerp(t),squaredlerp(t),t);\n}\n\nfloat circle(vec2 uv, float r,float x, float y){\n    return ss(lerp(0.0,1.0,ss(((uv.x-x)*uv.x)/r+((uv.y-y)*uv.y)/r)));\n}\n\nvec3 lerpcolor(vec3 a, vec3 b, float t){\n    float abr = lerp(a.r,b.r,ss(t));\n    float abg = lerp(a.g,b.g,ss(t));\n    float abb = lerp(a.b,b.b,ss(t));\n    return vec3(abr,abg,abb);\n}\nvoid mainImage( out vec4 c, in vec2 fc )\n{\n    vec2 uv = (2.0*fc.xy-iResolution.xy)/iResolution.y;\n    float s = 0.1;\n    float l = lerp(0.0,1.0,ss(s));\n    \n    float ci = circle(uv,0.5,0.0,0.0);\n    vec3 color = vec3(0.0);\n    \n    vec3 cmix1 = vec3(1.0,0.5,0.1);\n    vec3 cmix2 = vec3(0.0,0.3,0.9);\n    vec3 cres = lerpcolor(cmix1,cmix2,uv.x*uv.x*sin(iTime)+uv.y*uv.y*cos(iTime));\n    \n    color += 1.0-ci;\n    color += cres;\n    \n    \n    c = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyBDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 66], [68, 68, 89, 89, 105], [107, 107, 134, 134, 152], [154, 154, 178, 178, 220], [222, 222, 240, 240, 289], [291, 291, 339, 339, 411], [413, 413, 453, 453, 596], [597, 597, 639, 639, 1062]], "test": "untested"}
